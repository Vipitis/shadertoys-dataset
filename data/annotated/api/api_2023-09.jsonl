{"id": "msKyDR", "name": "FP 2023", "author": "uctumi", "description": "Background reacts on the song.", "tags": ["procedural", "2d", "noise", "fractals", "smoke", "wind"], "likes": 1, "viewed": 215, "published": 3, "date": "1696107647", "time_retrieved": "2024-07-30T17:31:02.153562", "image_code": "/*\n * Copyright 2014 Roman Bobniev (FatumR)\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define OCTAVES  8.0\n\n#define LIVE_SMOKE 1\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Rough Value noise implementation\nfloat valueNoiseSimple(vec2 vl) {\n   float minStep = 1.0 ;\n\n   vec2 grid = floor(vl);\n   vec2 gridPnt1 = grid;\n   vec2 gridPnt2 = vec2(grid.x, grid.y + minStep);\n   vec2 gridPnt3 = vec2(grid.x + minStep, grid.y);\n   vec2 gridPnt4 = vec2(gridPnt3.x, gridPnt2.y);\n\n    float s = rand2(grid);\n    float t = rand2(gridPnt3);\n    float u = rand2(gridPnt2);\n    float v = rand2(gridPnt4);\n    \n    float x1 = smoothstep(0., 1., fract(vl.x));\n    float interpX1 = mix(s, t, x1);\n    float interpX2 = mix(u, v, x1);\n    \n    float y = smoothstep(0., 1., fract(vl.y));\n    float interpY = mix(interpX1, interpX2, y);\n    \n    return interpY;\n}\n\nfloat getLowFreqs()\n{\n    const int NUM_FREQS = 32;\n    /* Close to the spectrum of the voice frequencies for this song. */\n    const float lowStart = 0.65;\n    const float lowEnd = 0.75;\n    float result = 0.0;\n    \n    for (int i = 0; i < NUM_FREQS; i++)\n    {\n        result += texture(iChannel0,\n                            vec2(lowStart + (lowEnd - lowStart)*float(i)/float(NUM_FREQS - 1),\n                                 0.25)).x;\n    }\n\n    return smoothstep(0.0, 1.0, (result / float(NUM_FREQS)) * 2.);\n}\n\nfloat fractalNoise(vec2 vl) {\n    float persistance = 2.0;\n    float amplitude = 0.5;\n    float rez = 0.0;\n    vec2 p = vl;\n    \n    for (float i = 0.0; i < OCTAVES; i++) {\n        rez += amplitude * valueNoiseSimple(p);\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez;\n}\n\nfloat complexFBM(vec2 p) {\n    float sound = getLowFreqs();\n    float slow = iTime / 2.5;\n    float fast = iTime / .5;\n    vec2 offset1 = vec2(slow  , 0.); // Main front\n    vec2 offset2 = vec2(sin(fast )* 0.1, 0.); // sub fronts\n\n    return \n#if LIVE_SMOKE\n        (1. + sound) * \n#endif\n        fractalNoise( p + offset1 + fractalNoise(\n            \tp + fractalNoise(\n                \tp + 2. * fractalNoise(p - offset2)\n            \t)\n        \t)\n        );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec3 blueColor = vec3(0.07,0.2,.5);\n    vec3 orangeColor2 = vec3(0, 0, 0);\n    \n    vec3 rez = mix(orangeColor2, blueColor, complexFBM(uv));\n    \n    fragColor = vec4(rez, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKyDR.jpg", "access": "api", "license": "apache-2.0", "functions": [[654, 654, 674, 674, 745], [747, 747, 768, 768, 839], [841, 877, 910, 910, 1511], [1513, 1513, 1534, 1534, 2026], [2028, 2028, 2057, 2057, 2332], [2797, 2797, 2854, 2854, 3092]], "test": "untested"}
{"id": "ddKyDz", "name": "Fork Plasma Sto uctumi 658", "author": "uctumi", "description": "Experimenting with 3D Gradient noise from Inigo Quilez. \nhere the 3d noise is used in an iterative loop to deform the uv cords", "tags": ["background", "ambient", "watercolor", "3dgradientnoise"], "likes": 1, "viewed": 236, "published": 3, "date": "1696107258", "time_retrieved": "2024-07-30T17:31:02.998304", "image_code": "//experimenting with 3D Gradient noise from: https://www.shadertoy.com/view/Xsl3Dl\n#define layers 5 //int how many layers\n#define speed .25 //float speed multiplyer\n#define scale 1.2 //float scale multiplyer\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\tp = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n\n\treturn p;\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized device coordinates from -1 to 1\n    vec2 uv = (fragCoord-iResolution.xy-.5)/iResolution.y;\n    //time value\n    float t = iTime*speed;\n\n    uv *= scale;\n    float h = noise(vec3(uv*2.,t));\n    //uv distortion loop \n  for (int n = 1; n < layers; n++){\n      float i = float(n);\n    uv -= vec2(0.7 / i * sin(i * uv.y+i + t*5. + h * i) + 0.8, 0.4 / i * sin(uv.x+4.-i+h + t*5. + 0.3 * i) + 1.6);\n  }\n\n    uv -= vec2(1.2 * sin(uv.x + t + h) + 1.8, 0.4 * sin(uv.y + t + 0.3*h) + 1.6);\n\n\n    // Time varying pixel color\n    vec3 col = vec3(.5 * sin(uv.x) + 0.5, .5 * sin(uv.x + uv.y) + 0.5, .5 * sin(uv.y) + 0.8)*0.8;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddKyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 229, 229, 406], [407, 407, 433, 433, 1258], [1259, 1259, 1316, 1365, 2002]], "test": "untested"}
{"id": "DscyRX", "name": "coiled grove 3", "author": "elenzil", "description": "same as CG2, but per-branch IDs.", "tags": ["tree", "twist", "rope", "braid", "understepping", "grove", "futurehardware"], "likes": 35, "viewed": 381, "published": 3, "date": "1696097825", "time_retrieved": "2024-07-30T17:31:03.763259", "image_code": "// Optional: Set iChannel0 to the keyboard for some key controls.\n//           (I keep keyboard off so it looks nice in the iOS ShaderToy app)\n//           key controls (if enabled)\n//           1 - heat map\n//           2 - shadows\n//           3 - reflections\n//           4 - branch height variation\n\n\nconst uint  march_MaxSteps  = 250u;\nconst float march_epsilon   = 0.01;\n      float march_understep = 0.25;\nconst float normal_epsilon  = 0.05;\n\n// set in readKeyboard().\nbool do_Shadows;\nbool do_Reflections;\nbool do_HeatMap;\nbool do_BranchHeightVariety;\n\n\nfloat gMapCount = 0.0;\n\nint  gId        = 0;\nint  gIdEnd     = 0;\nbool gTrackId   = !false;\n\nvoid updateId(in vec3 q) {\n    if (gTrackId) {\n        gIdEnd = gIdEnd * 4 + 4;\n        gId *= 4;\n        gId += int(sign(q.x) * 0.5 + 0.5);\n        gId += int(sign(q.z) * 1.0 + 1.0);\n    }\n}\n\nfloat idToUnit() {\n    float f = float(gId) / float(gIdEnd - 1);\n    return f;\n}\n\nfloat gBigDir1;\nfloat gBigDir2;\nfloat gT;\n\nvoid setupScene() {\n    gT = iTime * 0.3 - 10.0;\n    gBigDir1 = 0.05 * cos(gT * 0.3);\n    gBigDir2 = 0.05 * sin(gT * 0.3 + 1.0);\n    \n    gTrackId = do_BranchHeightVariety;\n}\n\nfloat sdScene(in vec3 p) {\n\n    vec4  mp = repeated_mirrored(p.xz, 60.0);\n    float cellDist = dot(mp.zw, mp.zw);\n    \n\n    if (p.y < 0.0) {\n        // nothing below the floor\n        return 1e9;\n    }\n    \n    gMapCount += 1.0;\n    \n    float t = gT + mp.z + mp.w * 0.5;\n    \n    p.xz = mp.xy;\n\n    float d = 1e9;\n    \n    gId    = 0;\n    gIdEnd = 0;\n    \n    vec3 q = p;\n    \n    float h = 45.0 / (1.0 - .3 * dot(mp.zw, mp.zw));\n    float r =  1.0;\n    \n    if (cellDist > 3.5) {\n        return p.y;\n    }\n\n    \n    float f;\n  \n    if (cellDist < 1.0) {\n        q.xz *= rot2(q.y * gBigDir1);\n        updateId(q);\n        f = smoothstep(h * 0.1, h * 1.1, q.y);\n        q.xz = abs(q.xz) - h * 0.25 * f;\n        r *= 1.0 - 0.1 * f;\n    }\n    else {\n        t *= 0.11;\n    }\n\n    q.xz *= rot2(q.y * gBigDir2 + t * 1.5);\n    updateId(q);\n    f = smoothstep(h * 0.3, h * 0.7, q.y);\n    q.xz = abs(q.xz) - h * 0.08 * f;\n    r *= 1.0 - 0.1 * f;\n\n\n    q.xz *= rot2(q.y * 0.08 + t * 1.2);\n    updateId(q);\n    f = smoothstep(h * 0.4, h, q.y);\n    q.xz = abs(q.xz) - h * 0.04 * f;\n    r *= 1.0 - 0.75 * f;\n\n    if (do_BranchHeightVariety) {\n        f = float(gId % 13) / 12.0;\n    }\n    else {\n        f = 0.9;\n    }\n\n\n    h += -3.0 + 6.0 * f;\n    \n    r *= 1.0 + 1.5 * smoothstep(-0.5, 0.0, q.y - h * 0.98 + 3.0 * (f - 1.0));\n\n    float dCap = sdDisk(q.xz, r);\n    float dBox = sdBox(q, vec3(r - 0.2, h, r - 0.2)) - 0.1;\n    \n    float dTree = mix(dCap, dBox, smoothstep(0.0, h, q.y));\n    \n    d = min(d, dTree);\n    \n    /*\n    q = p;\n    float s = 25.0;\n    q.xz = mod(q.xz, s) - s/2.0;\n    float sr = 30.0 / (1.0 + length(p.xz));\n    q.y -= sr;\n    d = min(d, sdSphere(q, sr));*/\n    \n    if (dot(p.xz, p.xz) < 50.0) {\n        d = smin(d, p.y, 4e0);\n    }\n    \n    \n    return d;\n}\n\nvec3 gradientScene(in vec3 p) {\n    if (p.y < march_epsilon) {\n        // cheat for floor\n        return vY;\n    }\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * normal_epsilon) - d,\n        sdScene(p + vY * normal_epsilon) - d,\n        sdScene(p + vZ * normal_epsilon) - d\n    );\n}\n\nvec3 normalScene(in vec3 p) {\n    return normalize(gradientScene(p));\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd, out bool outOfSteps) {\n\n    // analytic ground plane in addition to the raymarched one.\n    float pt = rayVsPlane(ro, rd, vY, 0.0);\n    \n    outOfSteps = false;\n\n    float t = 0.0;\n\n    for (uint n = 0u; n < march_MaxSteps; ++n) {\n        vec3  p = ro + t * rd;\n        float d = sdScene(p);\n        if (d < march_epsilon) {\n            return min(pt, t);\n        }\n        if (dot(p.xz, p.xz) > 60000.0) {\n            return pt;\n        }\n        \n        t += d * march_understep;\n    }\n   \n    outOfSteps = true;\n    return pt;\n}\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.5, 1.9));\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(rd, lightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(rd.z, rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(rd.y)));\n    return c;\n}\n\nvec3 calcAlbedo(in vec3 p) {\n    gTrackId = true;\n    sdScene(p);\n    \n    bool outerTree = dot(p.xz, p.xz) > 1200.0;\n    \n    vec3 pop = outerTree ? vec3(0.4, 0.0, 0.5) : vX;\n    vec3 a;\n    /*\n    float f = idToUnit();\n    albedo.r = sin(f * 1211.23);\n    albedo.g = sin(f * 1315.43);\n    albedo.b = sin(f * 1416.63);\n    albedo = mix(albedo * 0.7, v1, 0.4);\n    */\n    float noise  = whangHashNoise(0u, 0u, uint(gId));\n    float bNoise = step(0.3, noise);\n    a = mix(pop, v1, bNoise);\n    a = mix(a, 0.1 * mix(pop, v1, 0.5), smoothstep(40.0, 20.0, p.y));\n    \n    if (outerTree) {\n        a *= 0.3;\n    }\n    \n    a = mix(a, v1 * 1.0, smoothstep( 2.0, -3.0, p.y));\n    \n    return a;\n}\n\nvec3 calcDiffuse(in vec3 p, in vec3 rd, in vec3 n, in vec3 albedo) {\n    vec3 c = albedo * (saturate(dot(n, lightDir)));\n    \n    float redness = albedo.r - albedo.g;\n    c.r += 1.0 * redness * smoothstep(1.0, 10.0, p.y) * 0.9 * (sqr((sqr(saturate(dot(n, -rd))))));\n\n    return c;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    bool outOfSteps;\n    float t = rayVsScene(ro, rd, outOfSteps);\n    if (t > 1e8) {\n        return sky(ro, rd);\n    }\n    \n    vec3 p;\n    vec3 n;\n    \n    p = ro + t * rd;\n    n = normalScene(p);\n    \n    vec3 a = calcAlbedo(p);\n    vec3 c = calcDiffuse(p, rd, n, a);\n\n    // shadow and one reflection bounce\n    ro = p + n * march_epsilon * 1.5;\n    \n\n    \n    if (do_Shadows) {\n        // shadow\n        \n        // use less precision for shadows\n        march_understep = mix(march_understep, 1.0, 0.5);\n        \n        float ts = rayVsScene(ro, lightDir, outOfSteps);\n        p = ro + ts * lightDir;\n\n        if (ts < 1e9 || outOfSteps) {\n            c *= 0.4;\n        }\n    }\n\n    if (do_Reflections) {\n        // reflect\n        \n        // use even less precision for shadows\n        march_understep = mix(march_understep, 1.0, 0.5);\n        \n        const float reflectMin = 0.07;\n        const float reflectMax = 0.9;\n        float fres = mix(reflectMin, reflectMax, smoothstep(0.9, 0.1, abs(dot(rd, n))));\n\n        vec3 c2;\n        rd = reflect(rd, n);\n        \n        if (t > 170.0) {\n            c2 = sky(ro, rd);\n        }\n        else {\n            t = rayVsScene(ro, rd, outOfSteps);\n            if (t > 1e8) {\n                c2 = sky(ro, rd);\n            }\n            else {\n                p = ro + t * rd;\n                n = normalScene(p);\n                a = calcAlbedo(p);\n                c2 = calcDiffuse(p, rd, n, a);\n            }\n        }\n\n\n        c = mix(c, c2, fres);\n    }\n    \n    return c;\n}\n\nvec3 getRayDir(in vec2 xy, in vec3 ro, in vec3 lookTo, in float fov) {\n    vec3 camFw = normalize(lookTo - ro);\n    vec3 camRt = normalize(cross(camFw, vY));\n    vec3 camUp = cross(camRt, camFw);\n    \n    vec3 rd;\n    rd = camFw + fov * (camRt * xy.x + camUp * xy.y);\n    rd = normalize(rd);\n    \n    return rd;\n}\n\nbool keyboardNumberToggle(int number) {\n    const int k0_regular = 48;\n    const int k0_numPad  = 96;\n    \n    bool regular = bool(texelFetch(iChannel0, ivec2(k0_regular + number, 2), 0).x);\n    bool numPad  = bool(texelFetch(iChannel0, ivec2(k0_numPad  + number, 2), 0).x);\n    \n    return regular ^^ numPad;\n}\n\nvoid readKeyboard() {\n    do_HeatMap             =  keyboardNumberToggle(1);\n    do_Shadows             = !keyboardNumberToggle(2);\n    do_Reflections         = !keyboardNumberToggle(3);\n    do_BranchHeightVariety = !keyboardNumberToggle(4);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    const float zoom = 0.8;\n    \n    vec2 xy = (XY * 2.0 - RES) / MINRES / zoom;\n    \n    const float heatMapSize = 0.35;\n    bool isHeatMap = do_HeatMap && XY.x < RES.x * heatMapSize && XY.y < RES.y * heatMapSize;\n    if (isHeatMap) {\n        xy = (XY * 2.0 - RES * heatMapSize) / MINRES / heatMapSize / zoom;\n    }\n    \n    setupScene();\n    \n    vec2 M = iMouse.xy;\n    if (length(M) < 100.0) {\n        M = RES/2.0;\n        M.x += gT * 21.0;\n        M.y *= 1.5 + 0.3 * sin(iTime * 0.05);\n    }\n    \n    vec3 ro = vec3(0.0, 40.0 - 50.0 * (M.y / RES.y - 0.5), -80.0);\n    ro.xz *= rot2(3.141 + (M.x / RES.x - 0.5) * -7.0);\n    vec3 lt = vY * 26.0;\n    vec3 rd = getRayDir(xy, ro, lt, 0.3);\n    \n    \n    RGBA.rgb = render(ro, rd);\n    \n    if (isHeatMap) {\n        float h = saturate(gMapCount / 500.0);\n        vec3 cool = vec3(0.0, 0.0, 0.7);\n        vec3 warm = vec3(1.0, 0.9, 0.0);\n        RGBA.rgb = mix(cool, warm, h);\n    }\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(1.0/2.2));\n    \n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 vX = vec3(1.0, 0.0, 0.0);\nconst vec3 vY = vX.yxy;\nconst vec3 vZ = vX.yyx;\nconst vec3 v0 = vX.yyy;\nconst vec3 v1 = vX.xxx;\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2  saturate(vec2  v) { return clamp(v, 0.0, 1.0); }\nvec3  saturate(vec3  v) { return clamp(v, 0.0, 1.0); }\n\nfloat sqr(float a) {\n    return a * a;\n}\n\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// iq\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/sdfrepetition/\n// fast space repetition by mirroring every other instance\n// returns (vec2 space, vec2 id)\nvec4 repeated_mirrored( vec2 p, float s )\n{\n    vec2 id = round(p/s);\n    vec2  r = p - s*id;\n    vec2  m = vec2( ((int(id.x)&1)==0) ? r.x : -r.x,\n                   ((int(id.y)&1)==0) ? r.y : -r.y );\n    return vec4(m, id);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    if (t < 0.0) {\n        t = 1e9;\n    }\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n\n// SebH\n// https://www.shadertoy.com/view/ldjczd\nfloat whangHashNoise(uint u, uint v, uint s)\n{\n    uint seed = (u*1664525u + v) + s;\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return value;\n}\n\n//--------------------------------------------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[655, 655, 681, 681, 846], [848, 848, 866, 866, 928], [973, 973, 992, 992, 1147], [1149, 1149, 1175, 1175, 2926], [2928, 2928, 2959, 2959, 3231], [3233, 3233, 3262, 3262, 3304], [3306, 3306, 3369, 3434, 3879], [3936, 3936, 3970, 3970, 4455], [4457, 4457, 4485, 4485, 5146], [5148, 5148, 5216, 5216, 5430], [5432, 5432, 5469, 5469, 7001], [7003, 7003, 7073, 7073, 7316], [7631, 7631, 7652, 7652, 7874], [7876, 7876, 7919, 7919, 8966]], "test": "untested"}
{"id": "csyyzm", "name": "Raymarched Icosahedral Traversal", "author": "Shane", "description": "Using raymarched icosahedral traversal to produce an animated randomly subdivided icosahedral object running in realtime.", "tags": ["raymarching", "math", "icosahedron", "icosahedron", "spherical", "subdivision", "polyhedron", "traversal"], "likes": 74, "viewed": 770, "published": 3, "date": "1696081500", "time_retrieved": "2024-07-30T17:31:04.706736", "image_code": "/*\n\n    Raymarched Icosahedral Traversal\n    --------------------------------\n    \n    For a while, I've wanted to make some kind of random subdivided 3D \n    polyhedral cell slice object, but it's taken a while to figure out how\n    I was going to make that happen on Shadertoy. Chances are that you've \n    never come across a polyhedral cell traversal before, and if I'd never \n    considered making this, I wouldn't have either. :) In fact, I couldn't\n    find any existance of polyhedral traversal online, so I'm not sure it's\n    even a thing.\n    \n    I wanted to find a simpler way, but I eventually and begrudgingly \n    realized that spherical coordinate traversal was the only feasable method \n    available that wouldn't set the GPU on fire. Regular raymarching using \n    neighboring cell methods would be a prohibitively expensive book-keeping \n    nightmare and boolean raytracing methods would probably be worse.\n\n    Interestingly, the subdivided icosahedral traversal didn't turn out to be \n    as difficult as I thought it'd be, but it still wasn't fun, so I doubt \n    it'll catch on as a new technique-du-jour amongst Minecraft coders or \n    whoever. :)\n    \n    The scene design -- if you can call it that -- is pretty random. After \n    completing the spherical object, I got bored and subdivided the background,\n    just to see if it was possible to have two conflicting traversal schemes\n    running concurrently. The background would look better plain, plus the \n    framerate would improve considerably, but after all that work, I was \n    insistent in on leaving it in... Anyway, for those who like novel \n    approaches... and early 2000s hot pearlescent pink -- or whatever that \n    color is, you're in luck. And for those with slower machines, my apologies. \n    However, I'll return to this later and try to speed things up.\n \n\n\t\n    Other examples:\n    \n  \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n    \n    // Very cool demonstration. Polyhedrons are more TDHoopers's domain. The\n    // example below relies on folding symmetry to work, so would be less \n    // applicable in an asymmetric setting. Having said that TDHooper would \n    // probably know of some clever ways to improve my hacky polyhedral code. :)\n    Geodesic tiling - tdhooper\n    https://www.shadertoy.com/view/llVXRd\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Random icosahedral subdivision, if desired. Commenting this out \n// will look cleaner and increase the frame rate, but I don't feel\n// it looks as interesting.\n#define ICOS_SUBDIV\n\n// Random back wall subdivision, if desired. Commenting this out \n// will increase the frame rate.\n#define WALL_SUBDIV\n\n// Using the brick background. Commenting this out will display a \n// dark matte wall, and free up some cycles.\n#define BRICKS\n\n// Color scheme -- Golden orange: 0, Pinkish purple: 1, Greenish blue: 2.\n#define COLOR 1\n\n\n// Scene object ID and individual ID storage.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n*/\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // Depending on your machine, this should be faster than\n    // the block below it.\n    return texture(iChannel0, f*vec2(.2483, .3437)).x;\n    /* \n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n    */\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    \n    return texture(iChannel0, f.xy*vec2(.2483, .1437) + f.z*vec2(.4865, .5467)).x;\n    // Volume noise texture.\n    //return texture(iChannel0, f*vec3(.2483, .4237, .4865)).x;\n    /* \n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    */ \n}\n\n\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better version of this that I'll have to find.\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n \nvec3 rotObj(in vec3 p){\n\n    vec3 oP = p;\n    \n    float tm = iTime/4.;\n    p.yz *= rot2(tm/2.);\n    p.xz *= rot2(tm);\n   \n    if(iMouse.z>0.){\n        // Mouse movement.\n        vec2 ms = (iMouse.xy/iResolution.xy - .5)*vec2(3.14159);\n        p = oP;\n        p *= rot(vec3(0, ms.y, -ms.x));\n    } \n\n    return p;\n}\n\n \n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n \n \n\n// IQ's box routine with added smoothing factor.\nfloat sBox(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n// IQ's box routine with added smoothing factor.\nfloat sBox(in vec3 p, in vec3 b, float r){\n\n  vec3 d = abs(p) - b + r;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - r;\n}\n\n\n// IQ's extrusion formula with added smoothing factor.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n\n\n/////////\n// Normalizing and scaling. If there's a clever way to do this, feel\n// free to let me know.\nmat3x3 nrmSclMat(mat3x3 m, float rad){\n    \n    return mat3x3(normalize(m[0]), normalize(m[1]), normalize(m[2]))*rad;\n}\n\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI TAU*.5 // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482 // (1. + sqrt(5.))/2.\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Direction vector and sector ID.\n//vec3 dir;\n//int sID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 q, inout mat3x3 gVertID, const float rad){\n       \n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems. The bottom section is \n    // rotated by PI/5 about the equator.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    const float scX = 5.; // Longitudinal scale.\n    vec4 sph = atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.);\n    sph = fract((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX)*TAU;\n    //sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    const vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    const vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Skip the top or bottom strip, depending on whether we're in the\n    // northern or southern hemisphere.\n    ivec3 iR = q.y<0.? ivec3(1, 2, 3) : ivec3(0, 1, 3);\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point. Usually, only one\n    // two strips are normally checked, but three are checked here on account \n    // of faux shadow rendering.\n    for(int k = 0; k<3; k++){ \n\n        int i = iR[k];\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i&1], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n    \n    // X - coordinates for all three vertices.\n    vec3 ax = mod(vec3(0, -PI/5.*baseFlip, PI/5.*baseFlip) + TAU + sph[id], TAU);\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID = mat3x3(vec3(ax.x, ayT, rad), vec3(ax.y, ayB, rad), vec3(ax.z, ayB, rad));\n    \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if ((id&1)==0) gVertID[0].x = 0.;\n\n    /*\n    // Direction and section ID stuff. Not used here.\n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    \n    sID = id;\n    */\n    \n    return q;\n}\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec3 p, vec3 a, vec3 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n/*\n/////////\n// Nimitz's simple basis function. I'll take people's word for it that it\n// fails at the negative one Z point, so I've attempted to put in a hacky fix.\nmat3 basis(in vec3 n){\n    \n    float a = min(1./(1. + n.z), 1e6);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n}\n\n\n\n// Sphere intersection: Pretty standard, and adapted from one\n// of IQ's formulae.\nvec2 sphereIntersect(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n    if(b > 0.) return vec2(1e8, 0.);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif(h<0.) return vec2(1e8, 0.);\n\treturn vec2(-b - sqrt(h), 1.); \n    \n}\n*/\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec3 ro, vec3 rd, vec3 p, vec3 n){\n\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n   //return dn>0.? max(dot(p - ro, n), 0.)/dn : 1e8;   \n\n}\n\n// Plane distance function. Probably from IQ's page.\nfloat plane(vec3 p0, vec4 p) {\n\treturn dot(p.xyz, p0 + p.xyz*p.w);\n}\n\n\nvec3 gDir2; // Cell traversing direction.\nvec3 gRd2; // Global ray variable.\n\nvec3 gRd; // Global ray variable.\nfloat gCD; // Global cell boundary distance.\nvec3 gP;\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n \n// Individual icosahedral cell ID and wall panel cell ID.\n// I'm also storing the moving height values in the final slot.\nvec4 icosCellID;\nvec3 wallCellID;\n\n \n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    \n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n            \n    // Icosahedron vertices and vertex IDs for the current cell.\n    mat3x3 v, vertID;\n\n    // Obtaining the local cell coordinates and spherical coordinates\n    // for the icosahedron cell.\n    const float rad = .5;\n    vec3 lq = getIcosTri(q, vertID, rad);\n    \n    // Converting the cell triangle vertices to world coordinates.\n    v[0] = sphericalToWorld(vertID[0]);\n    v[1] = sphericalToWorld(vertID[1]);\n    v[2] = sphericalToWorld(vertID[2]);\n         \n \n    \n    // Edge mid points.\n    mat3x3 vE = (v + mat3x3(v[1], v[2], v[0]));\n    vE = nrmSclMat(vE, rad);\n    /*\n    // The above is equivalent to the following.\n    vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n    vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n    vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n    */\n    \n\n    /////\n\n    // Triangle subdivision, if desired.\n    #ifdef ICOS_SUBDIV\n    int subDivNum = 2;\n    #else\n    int subDivNum = 1;\n    #endif\n\n    int subs = 0;\n\n    if(length(lq)>.8) subDivNum = 0;\n\n    //float midTri = 0.;\n    //\n    // There'd be faster ways to do this, but this is\n    // relatively cheap, and it works well enough.\n    for(int i = 0; i<subDivNum; i++){\n\n        #ifdef ICOS_SUBDIV\n        if(i>=1){\n            vec3 rC = v[0] + v[1] + v[2];\n            float sRnd = hash31(rC + float(i + 1)/8.);\n            if(sRnd<.65) break;\n        }\n        #endif\n        subs++;\n\n\n        // Create three line boundaries within the triangle to \n        // partition into four triangles. Pretty standard stuff.\n        // By the way, there are other partitionings, but this \n        // is the most common. At some stage, I'll include some\n        // others, like the three triangle version connecting the \n        // center to the vertices.\n        //\n        if(dot(lq, cross(vE[0], vE[1]))>0.){\n            v[0] = vE[0]; v[2] = vE[1];                    \n        }\n        else if(dot(lq, cross(vE[1], vE[2]))>0.){\n            v[0] = vE[2]; v[1] = vE[1];\n        }\n        else if(dot(lq, cross(vE[2], vE[0]))>0.){\n            v[1] = vE[0]; v[2] = vE[2];\n        }\n        else {\n            v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n            //midTri = 1.;\n        }\n\n        // Recalculating the edge mid-vectors for the next iteration.\n        vE = (v + mat3x3(v[1], v[2], v[0]));\n        vE = nrmSclMat(vE, rad); \n    }\n  \n            \n    /////  \n \n\n     // The cell center, which doubles as a cell ID,\n    // due to its uniqueness, which can be used for \n    // randomness, etc.\n    //vec3 tCntr = sSize(v[0] + v[1] + v[2], rad);\n    vec3 cntrID = (v[0] + v[1] + v[2]);\n \n\n     // Icosahedral cell boundary.\n    mat3 mEdge = mat3(cross(v[1], v[0]), cross(v[2], v[1]), cross(v[0], v[2]));\n    // Normals at each of the triangle sides.\n    mat3x3 sNrm = nrmSclMat(mEdge, 1.); \n    //mat3x3 sNrm = mat3x3(normalize(mEdge[0]), normalize(mEdge[1]), normalize(mEdge[2]));\n    \n    // Icosahedral triangle face cell boundary.\n    vec3 ep = (normalize(lq)*mEdge)/\n              vec3(length(v[1] - v[0]), length(v[2] - v[1]), length(v[0] - v[2]));  \n    float triF = min(min(ep.x, ep.y), ep.z);   \n \n    ////////////\n \n    // Random animated radius.\n    float r = hash31(cntrID + .16);\n    r = (smoothstep(.9, .95, sin(6.2831589*r + iTime))*.2 + .95)*rad;\n    // Storing the center ID and radius for later.\n    icosCellID = vec4(cntrID, r);\n    \n    \n    // The main polyhedral object.\n    float object = 1e5;\n\n    // Edge smoothing factor. Hacky, but it works well enough.\n    float eSm = 1./float(subs + 1);\n\n    // Creating the triangle wedge object for this cell by simply\n    // obtaining the maximum of all inner boundary planes.\n    float gap = .005; // Cell gap.\n    float side = plane(lq, vec4(-sNrm[0], gap)); // Normal facing plane.\n    side = smax(side, plane(lq, vec4(-sNrm[1], gap)), .06*eSm);\n    side = smax(side, plane(lq, vec4(-sNrm[2], gap)), .06*eSm);\n    //side = abs(side + .025*eSm) - .025*eSm; // Thin sides.\n\n    // The top of the triangle cell wedge.\n    float top = length(lq) - r; // Round surface.\n    //float top = -plane(lq, vec4(normalize(-cntrID), r));\n    object = abs(top + .02) - .02; // Thin slice, instead of solid.\n    //object = top; // Standard solid chunk.\n\n    // The triangle cell object consists of a top moved out from the center\n    // of the spherical opject with three triangular sides cut out. The\n    // last factor (triF) is the 2D triangle distance, which we're using to\n    // make the object look pointy on top. Removing it will return a flat\n    // surface.\n    object = smax(object, side, .015) - triF*.3;\n\n    // Inner ball.\n    object = min(object, length(lq) - .35);\n\n    // The tubes eminating from the center of the polygon.\n    float tube = distLine(lq, vec3(0), normalize(cntrID)*(r + .06*eSm)) - .04*eSm; \n    // Other failed experiments. :)\n    //float tube = distLine(lq, vec3(0), normalize(cntrID)*8.);\n    //tube = max(tube, top) - .035*eSm;\n    //tube = min(tube, length(lq - normalize(cntrID)*(r + .06*eSm)) - .04*eSm);\n    //float tube = max(top - .05, -line + length(vE[2] - normalize(cntrID)*rad)*.8); \n     \n \n \n    ///////////\n    // Icosahedral traversal section: Setup wasn't fun, but the execution\n    // is incredibly simple. Trace the ray to the outer walls, and note\n    // the minimum distance.\n    // Ray to triangle prism wall distances.\n    vec4 rC = vec4(1e5);\n    rC.x = rayLine(lq, gRd, vec3(0), -sNrm[0]);\n    rC.y = rayLine(lq, gRd, vec3(0), -sNrm[1]);\n    rC.z = rayLine(lq, gRd, vec3(0), -sNrm[2]);\n\n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... or something like that.\n    gCD = max(min(min(rC.x, rC.y), min(rC.z, rC.w)), 0.);\n    \n \n    ///////////\n    \n \n    // Standard rectangle subdivision with offset rows.\n    float wBlock = 1e5;\n    \n    // Not using bricks will return a flat dark background and free up\n    // some cycles.\n    #ifdef BRICKS\n    // Trying to speed things up by not calculating pixels we don't have to.\n    if(p.z>0. && length(p)>1.){ \n  \n        // Scale and row offset.\n        vec2 sc2 = vec2(1.5, 1)*.36;\n        vec2 p2 = p.xy - vec2(0, iTime/8.);\n        vec2 offs = vec2(0);\n        vec2 ii = mod(floor(p2/sc2), 3.)/3.;\n        p2.x -= ii.y*sc2.x;\n        offs.x += ii.y;\n   \n        vec2 svP2 = p2;\n        // Local cell position and ID. \n        vec2 ip2 = floor(p2/sc2) + .5;\n        p2 -= ip2*sc2;\n        subs = 1; // Subdivision number.\n        #ifdef WALL_SUBDIV\n        // One subdivision level.\n        if(hash21(ip2 + .2)<.35){\n            sc2 /= 2.;\n            p2 = svP2;\n            ip2 = floor(p2/sc2) + .5;\n            p2 -= ip2*sc2;\n            subs++;\n        }\n        #endif\n        ip2 = (ip2 + offs)*sc2; // Cell ID.\n     \n     \n        // Outer blocks.\n        float x = ip2.x/1.5/.36;\n        int outer = (x>3. || x<-3.)? 1 : 0;\n\n        // Height based on X-distance... I'm not even sure what the \"crv\" reference\n        // is... It makes the wall look curved on the ends. Fair enough. :D\n        float crvH = .3*max(abs(ip2.x), 0.); \n        float h = hash21(ip2 + .22); // Random height.\n\n        // Moving outer walls, and static in the middle.\n        if(outer == 1) h = smoothstep(.9, .95, sin(6.2831589*h + iTime))*.25 + crvH;\n        else h = crvH; \n\n        // Save the wall ID and height for later.\n        wallCellID = vec3(ip2, h);\n\n        vec3 p3 = vec3(p2, p.z - 2. - .04);\n        //float wBlock = sBox(vec3(p2, -(p.z + h/2.) + 3.), vec3(sc2/2., h/2.), .01);\n        float d2D = sBox(p2, sc2/2., .1*sqrt(min(sc2.x, sc2.y)));\n        //float wBlock = opExtrusion(d2D, p.z - 3., h, .015) + d2D*.2;\n        float sphCrv = length(p2/sc2/2.)*.02;\n        float blockFce = (outer == 1)? min(-d2D, .2)*.15 : 0.;\n        if(outer == 0 && hash21(ip2)<.5) d2D = abs(d2D + .04) - .04;\n        wBlock = opExtrusion(d2D, p3.z + h, .04, .025) - blockFce + sphCrv;\n\n        // The wall tube... I should look for a faster way to do this, but it'll\n        // do for now.\n        float tube2 = distLine(p3, vec3(0), \n                      vec3(0, 0, -1)*(h + .18/float(subs + 1))) - .08/float(subs + 1); \n\n        // Only connecting tubes on the outer bricks. It's not mandatory, but I\n        // wanted the inner brick to look cleaner.\n        if(outer == 1) tube = min(tube, tube2);\n\n\n        // Directional ray collision with the square cell boundaries.\n        vec2 rC2 = (gDir2.xy*sc2 - p2)/gRd2.xy; // For 2D, this will work too.\n\n        // Minimum of all distances, plus not allowing negative distances.\n        gCD = min(gCD, max(min(rC2.x, rC2.y), 0.)); // Adding a touch to advance to the next cell.\n    \n    }\n    #endif\n    \n    // Advancing the traversal distance the next cell.\n    gCD += .0001;\n    \n    \n   \n\n    //////////////////\n    // The background wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(48. - 3.))) - 48.);\n    // Flat plane back wall.\n    float wall = -p.z + 2.5;\n    \n\n    // Overall object ID -- There in one rundundant slot there.\n    vID = vec4(tube, wall, wBlock, object);\n\n    // Shortest distance to a scene object.\n    return min(min(tube, wall), min(wBlock, object));\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Closest and total distance.\n    float d, t = hash31(ro + rd)*.15;// Jittering to alleviate glow artifacts.\n    \n    gRd = rd; // Set the global icosadral ray direction varible.\n    // It needs to match the object rotation. Performing this in the\n    // \"map\" function will rotate it multiple times per loop, so \n    // won't work... I found that out the hard way. :)\n    gRd = rotObj(gRd); \n    \n    // Back wall unit direction ray. Not rotated. \n    // We need the direction itself for the standard cube\n    // traversal trickery.\n    gDir2 = sign(rd)*.5;\n    gRd2 = rd;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += min(d*.8, gCD);\n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable. \n    // machine anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n\n    gRd = rd; // Icosahedral direction ray.\n    gRd = rotObj(gRd);\n    \n    gDir2 = sign(rd)*.5; // Back wall direction ray. Not rotated.\n    gRd2 = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect:  dist += clamp(h, .01, stepDist), \n        // etc.\n        //t += clamp(d, .01, .25); // Normally this.\n        t += clamp(min(d, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.15, .3, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n    \n    vec4 iCellID = icosCellID; // Icosahedron cell ID with radius.\n    vec3 wCellID = wallCellID; // Wall cell ID with height.\n  \n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        // Sharper diffus... iveness... Diffusivity. :)\n        diff = pow(diff, 4.)*2.; \n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t     \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty \n        // subtle, so could almost be aproximated by a constant, but I prefer it. Here, \n        // it's being used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        \n        float refF = 1.; // Reflection factor.\n         \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n         \n        // Texturing position and normal.\n        vec3 txP = sp, txN = sn;\n\n        // Object patterns, coloring, etc.        \n        if(objID==1){ \n        \n           \n            // The background itself. Mostly hidden behind the bricks,\n            // but there nonetheless.\n            txP /= 3.;\n            txP.xy *= rot2(3.14159/4.);\n            txP += .25;\n         \n             // Color and reflection.\n            texCol = vec3(.0175); // Black.\n     \n            // Virtually no specular reflection.\n            refF = .0125;\n\n            \n        }\n        else if(objID==2 || (objID==0 && sp.z>1.)){ \n        \n            // Wall blocks and vertices.\n        \n            // Texture positio.\n            txP.xy -= vec2(0, iTime/8.);\n            txP.z += wCellID.z;\n            txP /= 3.;\n            txP.xy *= rot2(3.14159/4.);\n            \n            // Random color.\n            float iRnd = hash21(wCellID.xy + .06);\n            texCol = .5 + .45*cos(6.2831*iRnd/10. + vec3(0, 1, 2) + .5);\n            \n            // Darkening the bricks in the center and some on the\n            // left and right sides, and reducing the reflection factor.\n            float x = wCellID.x/1.5/.36; // Scale in distance function.\n            \n            // Darkening the back end of all poles... It was a last minute thing.\n            int back = 0;//((sp.z - 2.04) + wCellID.z - .08>0. && objID==0)? 1 : 0;\n            \n            if(((x<3. && x>-3.) || hash21(wCellID.xy + .38)<.5) || back==1){\n            //if(hash21(wCellID.xy + .38)<.8 || tip==1){\n              texCol = mix(texCol/4., vec3(.13)*dot(texCol, vec3(.299, .587, .114)), .9);\n              refF = .25;\n            }\n            \n            // Tubes and vertices on the outer bricks.\n            if(objID==0){\n                texCol = mix(texCol*2., vec3(.5)*dot(texCol, vec3(.299, .587, .114)), .65);\n            }\n           \n            #if COLOR >= 1\n            texCol = mix(texCol.xzy, texCol.yzx, \n                         1. - smoothstep(0., 1., rd.x*.5+rd.y*2. + .9));\n            #endif\n\n            #if COLOR == 2\n            texCol = texCol.yzx;  // Other colors.    \n            #endif\n \n\n        }\n        else { \n        \n            // Icosahedral color.\n        \n            // Texture position and normal.\n            float rad = .5;\n            txP = sp - sphPos;\n            txP += normalize(txP)*(rad - iCellID.w);\n            \n             \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n            \n            // Color and reflection.\n            float iRnd = hash31(iCellID.xyz + .07);\n            texCol = .5 + .45*cos(6.2831*iRnd/10. + vec3(0, 1, 2) + .5);\n             \n               \n            // Coloring the tube and vertices.\n            if(objID==0){\n                texCol = mix(texCol*2., vec3(.5)*dot(texCol, vec3(.299, .587, .114)), .65);\n            }\n            \n            // Darkening the back end of all poles... It was a last minute thing.\n            int back = 0;//(length(sp - sphPos.xyz) - iCellID.w + .02<0. && objID==0)? 1 : 0;\n            \n            \n            // Dark inner sphere.\n            if(length(sp - sphPos.xyz)<.42 || back==1){ \n                texCol = mix(texCol/4., vec3(.13)*dot(texCol, vec3(.299, .587, .114)), .9); \n                refF = .25; // Less reflection.\n            } \n            \n            #if COLOR >= 1\n            texCol = mix(texCol.xzy, texCol.yzx, \n                         1. - smoothstep(0., 1., rd.x*.5 + rd.y*2. + .9));\n            #endif\n            \n            #if COLOR == 2\n            texCol = texCol.yzx; \n            #endif\n\n        }\n        \n        \n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        vec3 rCol = spRef*refTx*1.; //smoothstep(.03, 1., spRef)  \n\n        \n        // Adding the specular reflection here.\n        texCol += rCol*refF;\n \n        // Metal and powder coat enamel.\n        vec3 tx = tex3D(iChannel2, txP + .5, txN);\n        texCol *= tx*2. + .3;\n       \n        \n        \n        // This is probably a good example for a BRDF scheme, but things look\n        // OK as is, so I'll keep things more simple.\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh*2.);\n \n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Not need here.\n    //col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n\n\n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1); \n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csyyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3107, 3140, 3162, 3162, 3220], [3222, 3554, 3575, 3664, 3867], [3869, 3911, 3932, 3932, 4365], [4369, 4503, 4522, 4522, 4757], [4761, 4761, 4784, 4784, 5076], [5081, 5161, 5207, 5207, 6119], [6123, 6346, 6384, 6384, 6465], [6471, 6520, 6562, 6562, 6650], [6653, 6702, 6744, 6744, 6842], [6845, 6900, 6970, 7023, 7128], [7132, 7235, 7273, 7273, 7354], [7356, 7427, 7464, 7464, 7582], [9002, 9126, 9195, 9939, 12828], [12831, 12888, 12927, 12927, 13028], [13742, 13800, 13848, 14120, 14250], [14252, 14305, 14335, 14335, 14373], [14782, 14810, 14828, 14869, 24137], [24141, 24162, 24198, 24234, 25196], [25200, 25395, 25447, 25549, 27061], [27064, 27155, 27191, 27563, 27835], [27838, 27990, 28026, 28026, 28310], [28313, 28313, 28369, 28398, 36609]], "test": "untested"}
{"id": "dltSR4", "name": "snek", "author": "Trixelized", "description": "stupid funsies", "tags": ["snek"], "likes": 4, "viewed": 169, "published": 3, "date": "1696079528", "time_retrieved": "2024-07-30T17:31:05.476677", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float fraction = (iResolution.x / iResolution.y);\n    uv.x *= fraction;\n    \n    float angle = iTime;\n    float s = sin(angle);\n    float c = cos(angle * 0.5);\n    \n    mat2 rotMat = mat2(c, s, -s, c);\n    vec2 rotUv = ((uv - 0.5) * rotMat) + 0.5;\n    \n    vec4 recursive = texture(iChannel0, 1.001 * vec2(uv.x / fraction, uv.y) - rotUv * 0.005) / 1.0005;\n    \n    vec3 colMul = 0.5 + 0.5 * sin(iTime + vec3(0.0, 2.09439, 4.18879));\n    \n    float add = 1.0 / (1.0 + exp(200.0 * length(rotUv - 0.45)));\n    \n    fragColor = clamp(recursive + vec4(add * colMul, 1.0), vec4(0.0), vec4(1.0));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "csKyDh", "name": "Auras", "author": "wyatt", "description": " ", "tags": ["wave", "fourier", "caustic"], "likes": 11, "viewed": 307, "published": 3, "date": "1696051444", "time_retrieved": "2024-07-30T17:31:06.247616", "image_code": "Main {\n    int I = iFrame % ( 1 + 2 + 1 + 2 );\n    Q = D(U);\n    //Q = B(U).zwzw*100.;\n   if (I!=4) discard;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n\n\n#define pi 3.14159265359\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n", "buffer_a_code": "#define dt sqrt(iTime*80000.)\nMain {\n    int I = iFrame % ( 1 + 2 + 1 + 2 );\n    U = floor(U);\n    vec2 u = 2.*(U-.5*R)/R.y;\n    if (I == 0) {\n        // Phase Space\n        Q = A(U);\n        //if (iFrame < 1) {\n            float l = length(U-.5*R);\n            Q.y = 0.;\n            Q.x = smoothstep(50.,25.,l);\n                    \n       //}\n    } else if (I == 1) {\n        // x forward pass\n        Q = vec4(0);\n        vec2 w = 2.*pi*vec2(U)/R;\n        for (float i = 0.; i < R.x; i++) {\n            vec4 a = A(vec2(i,U.y));\n            Q.xy += a.xy*ei(w.x*i);\n            //Q.zw += a.zw*ei(w.x*i);\n        }\n    } else if (I == 2) {\n        // y forward pass\n        Q = vec4(0);\n        vec2 w = 2.*pi*vec2(U)/R;\n        for (float i = 0.; i < R.y; i++) {\n            vec4 a = A(vec2(U.x,i));\n            Q.xy += a.xy*ei(w.y*i);\n            //Q.zw += a.zw*ei(w.y*i);\n        }\n    } else if (I == 3) {\n        // Frequency Space\n        vec2 w = 2.*pi*(fract(vec2(U)/R+.5)*2.-1.);\n        Q = A(U);\n        Q.xy = Q.xy*ei(dt*length(w));\n    } else if (I == 4) {\n        // x reverse pass\n        Q = vec4(0);\n        vec2 w = 2.*pi*vec2(U)/R;\n        for (float i = 0.; i < R.x; i++) \n            Q.xy += A(vec2(i,U.y)).xy*ei(-w.x*i);\n        Q /= R.x;\n    } else if (I == 5) {\n        // y reverse pass\n        Q = vec4(0);\n        vec2 w = 2.*pi*vec2(U)/R;\n        for (float i = 0.; i < R.y; i++) \n            Q.xy += A(vec2(U.x,i)).xy*ei(-w.y*i);\n        Q /= R.y;\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    int I = iFrame % ( 1 + 2 + 1 + 2 );\n    Q = B(U);\n    if (I == 5) {\n        vec4 n = A(U+vec2(0,1));\n        vec4 e = A(U+vec2(1,0));\n        vec4 s = A(U-vec2(0,1));\n        vec4 w = A(U-vec2(1,0));\n        Q.z = dot(e.xy,e.xy)-dot(w.xy,w.xy);\n        Q.w = dot(n.xy,n.xy)-dot(s.xy,s.xy);\n        Q.xy = A(U).xy;\n        Q.zw *= 100.;\n    } \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    int I = iFrame % ( 1 + 2 + 1 + 2 );\n    Q = D(U);\n    if (I == 5) Q = vec4(0);\n    #define S 8.\n    for (float x = 0.; x < 6.*S; x++)\n    for (float y = 0.; y < S; y++) {\n        vec2 u = .75*(vec2(x,y+S*float(I))-3.*S);\n        vec4 b = B(U+u);\n        vec2 v = b.zw*400.+u;\n        vec4 q = .5+10.*vec4(b.x-b.y,b.x,b.y,1);\n        v = abs(v);\n        Q += .02*q*smoothstep(2.5,1.5,max(v.x,v.y));\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdGcD1", "name": "Vinyl - by hugolnx", "author": "hugolnx", "description": "Making a vinyl", "tags": ["art", "hugolnx", "vynil"], "likes": 5, "viewed": 210, "published": 3, "date": "1696045579", "time_retrieved": "2024-07-30T17:31:07.004592", "image_code": "#define TWOPI 6.283185\n#define PI 3.14159\n#define DEG2RAD 3.14159 / 180.\n#define RAD2DEG 180. / 3.14159 \n#define C_VYNIL_1 vec3(0.05)\n#define C_VYNIL_2 vec3(0.2)\n#define C_VYNIL_1L vec3(0.2)\n#define C_VYNIL_2L vec3(0.6)\n#define C_BACK vec3(0.8, 0.8, 1.0)\n#define C_IN vec3(.5, .2, .2)\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n\n#define VYNIL_AREA_1 .05\n#define VYNIL_AREA_2 .25\n#define VYNIL_AREA_3 .35\n#define VYNIL_AREA_4 .85\n#define VYNIL_AREA_5 .9\n#define VYNIL_LINE_LEN .01\n\nfloat xstep(float minV, float maxV, float v) {return step(minV, v) * step(v, maxV);}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat normrange(float v, float minV, float maxV) { return sat((v-minV)/(maxV-minV)); }\nfloat xnormrange(float v, float minV, float maxV) { return normrange(v, minV, maxV) * xstep(minV, maxV, v); }\nfloat normAng(float a) { return mod(mod(a, TWOPI) + TWOPI, TWOPI); }\nfloat angDist(float a1, float a2) {\n  a1 = normAng(a1);\n  a2 = normAng(a2);\n  float diff1 = normAng(a1 - a2);\n  float diff2 = normAng(a2 - a1);\n  return min(diff1, diff2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * vec2(iResolution.x/iResolution.y, 1) * 2.;\n\n    float d = length(uv);\n    \n    vec3 col = vec3(0, 0, 0);\n    float stepCircIn1 = xstep(0.          , VYNIL_AREA_1, d);\n    float stepCircIn2 = xstep(VYNIL_AREA_1, VYNIL_AREA_2, d);\n    float stepCircIn3 = xstep(VYNIL_AREA_2, VYNIL_AREA_3, d);\n    float stepCircIn4 = xstep(VYNIL_AREA_3, VYNIL_AREA_4, d);\n    float stepCircIn5 = xstep(VYNIL_AREA_4, VYNIL_AREA_5, d);\n    \n    float d5 = xnormrange(d, VYNIL_AREA_4, VYNIL_AREA_5);\n    float d4 = xnormrange(d, VYNIL_AREA_3, VYNIL_AREA_4);\n    float d3 = xnormrange(d, VYNIL_AREA_2, VYNIL_AREA_3);\n    float d2 = xnormrange(d, VYNIL_AREA_1, VYNIL_AREA_2);\n    float stepCircOut = step(VYNIL_AREA_5, d);\n    \n    col += stepCircOut * C_BACK;\n    col += stepCircIn1 * C_BACK;\n    \n    float uvAng = normAng(atan(uv.y, uv.x));\n    float lightAng = mod(30. + iTime/.01, 360.) * DEG2RAD;\n    float lightAngRange = 60. * DEG2RAD;\n    float lightAngDist = min(abs(angDist(uvAng, lightAng)), abs(angDist(uvAng, lightAng+PI))); \n    float lightStep = step(lightAngDist, lightAngRange*.5);\n    float lightStepSmooth = 1. - xnormrange(lightAngDist, 0., lightAngRange * .5);\n    float noLightStep = mod(lightStep + 1., 2.);\n    \n    float lsin = sin(d5 * TWOPI*(VYNIL_AREA_1/VYNIL_LINE_LEN));\n    vec3 col5 = vec3(0.);\n    \n    vec3 noLightColor = mix(C_VYNIL_1, C_VYNIL_2, lsin);\n    vec3 lightColor = mix(C_VYNIL_1L, C_VYNIL_2L, lsin);\n    col5 += stepCircIn5 * noLightStep * noLightColor;\n    col5 += stepCircIn5 * lightStep * mix(noLightColor, lightColor, lightStepSmooth);\n    col += col5;\n    \n    \n    vec3 col4 = vec3(0.);\n    float linesAmount = 5.;\n    float lsin4 = sin(xnormrange(fract(d4*linesAmount), .0, .15)*TWOPI);\n    vec3 noLightColor4 = mix(C_VYNIL_1, C_VYNIL_2, lsin4);\n    vec3 lightColor4 = mix(C_VYNIL_1L, C_VYNIL_2L, lsin4);\n    col4 += stepCircIn4 * noLightStep * noLightColor4;\n    col4 += stepCircIn4 * lightStep * mix(noLightColor4, lightColor4, lightStepSmooth);\n    col += col4;\n    \n    vec3 col3 = vec3(0.);\n    float linesAmount3 = 2.;\n    float lsin3 = sin(xnormrange(fract(d3*linesAmount3), .0, .25)*TWOPI);\n    vec3 noLightColor3 = mix(C_VYNIL_1*.9, C_VYNIL_2*.5, lsin3);\n    vec3 lightColor3 = mix(C_VYNIL_1*.9, C_VYNIL_2L*.5, lsin3);\n    col3 += stepCircIn3 * noLightStep * noLightColor3;\n    col3 += stepCircIn3 * lightStep * mix(noLightColor3, lightColor3, lightStepSmooth);\n    col += col3;\n    \n    \n    col += stepCircIn2 * mix(C_IN, C_IN*1.2, sat(sin(d2*PI)*2.));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 525, 571, 571, 609], [610, 610, 630, 630, 655], [656, 656, 706, 706, 742], [743, 743, 794, 794, 852], [853, 853, 877, 877, 921], [922, 922, 957, 957, 1095], [1097, 1097, 1154, 1154, 3759]], "test": "untested"}
{"id": "mdGcW1", "name": "Line Integral Convolution test", "author": "Zi7ar21", "description": "I got this idea after talking to a Computational Astrophysicist who specializes in MHD, basically just advect noise over a vector field (typically related to an image) and then combine the texture back with the image, useful for visualizing magnetic lines", "tags": ["visualization", "magnetism"], "likes": 8, "viewed": 303, "published": 3, "date": "1696042307", "time_retrieved": "2024-07-30T17:31:08.104652", "image_code": "float g(float x, float sigma, float mu) {\n    x -= mu;\n    sigma = sigma != 0.0 ? 1.0/sigma : 1.0;\n    x *= sigma;\n    x *= x;\n    return sigma*0.3989422804014326779399460599343818684758586311649346576659258297*exp(-0.5*x);\n}\n\n/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //fragCoord += vec2(0.3,0.3)*iResolution.xy;\n    //fragCoord *= 0.1*sin(iTime)+0.3;\n    //fragCoord -= vec2(0.3,0.3)*iResolution.xy;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    //fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    //fragColor -= 2.0*texelFetch(iChannel3, ivec2(fragCoord), 0);\n    fragColor = fragColor*(1.0-texture(iChannel3, fragCoord/iResolution.xy));\n    //fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    fragColor = vec4(clamp(fragColor.rgb,0.0,1.0),1.0);\n}\n*/\n\nfloat noise(vec2 x) {\nx *=2.0; // scale the noise\n    float fx = fract(x.x);\n    float fy = fract(x.y);\n    x = floor(x);\n    return mix(\n    mix(texelFetch_repeat(iChannel2, ivec2(x)+ivec2(0,0), 0).r>0.9?1.0:0.0,texelFetch_repeat(iChannel2, ivec2(x)+ivec2(1,0), 0).r>0.9?1.0:0.0,fx),\n    mix(texelFetch_repeat(iChannel2, ivec2(x)+ivec2(0,1), 0).r>0.9?1.0:0.0,texelFetch_repeat(iChannel2, ivec2(x)+ivec2(1,1), 0).r>0.9?1.0:0.0,fx),\n    fy);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //fragCoord *= 0.3*sin(iTime)+0.6;\n    //float scale = sin(iTime)+2.0;\n    float scale = 4.0;\n    fragCoord += scale*iMouse.xy;\n    fragCoord *= 1.0/(scale+1.0);\n    fragColor = vec4(0);\n\n    vec2 x;\n    const float dt = 0.25;\n    const float sig = 10.0;\n    x=vec2(0);\n    for(int i = 0; i < 99; i++) {\n        x += dt*texture(iChannel1, (fragCoord+x)/iResolution.xy).xy;\n        fragColor += g(dt*float(i), sig, 0.0)*vec4(vec3(noise(fragCoord+x)), 1.0);\n    }\n    x=vec2(0);\n    for(int i = 0; i < 99; i++) {\n        x -= dt*texture(iChannel1, (fragCoord+x)/iResolution.xy).xy;\n        if(i == 0) continue;\n        fragColor += g(dt*float(i), sig, 0.0)*vec4(vec3(noise(fragCoord+x)), 1.0);\n    }\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n    //fragColor = vec4(texture(iChannel0, fragCoord/iResolution.xy).rgb*(1.0-5.0*fragColor.rgb), 1.0);\n    fragColor = vec4(texture(iChannel3, fragCoord/iResolution.xy).rgb*(1.0-2.0*fragColor.rgb), 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 texelFetch_repeat(sampler2D _sampler, ivec2 _coord, int _lod) {\n    // no idea why the -1 is neccesary but the pressure is slightly wrong without it\n    // maybe textureSize() is wrong?\n    ivec2 _textureSize = textureSize(_sampler, _lod) - 1;\n\n    // :sob: in GLSL, the % operator is undefined if one or both input integers are negative\n    // so we blasphemously convert our integers to floats and back and use the float modulo\n    //_coord.x = int(mod(float(_coord.x), float(_textureSize.x)));\n    //_coord.y = int(mod(float(_coord.y), float(_textureSize.y)));\n    //return texelFetch(_sampler, _coord, _lod);\n\n    // fixed! https://www.alecjacobson.com/weblog/?p=1140\n    return texelFetch(_sampler, ((_coord % _textureSize) + _textureSize) % _textureSize, _lod);\n}", "buffer_a_code": "// Buffer A: Original Image\nfloat textureMix(sampler2D sampler, vec2 x) {\n    vec3 col =  texture(iChannel0, x).rgb;\n    return col.r+col.g+col.b;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //fragCoord *= 0.1*sin(iTime)+0.3;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n\n    fragColor = vec4(\n     0.0035714285714285714285714285714285714285714285714285714285714286 * textureMix(iChannel0, (fragCoord - vec2(4, 0))/iResolution.xy)+\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * textureMix(iChannel0, (fragCoord - vec2(3, 0))/iResolution.xy)+\n     0.2000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord - vec2(2, 0))/iResolution.xy)+\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord - vec2(1, 0))/iResolution.xy)+\n     0.8000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord + vec2(1, 0))/iResolution.xy)+\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord + vec2(2, 0))/iResolution.xy)+\n     0.0380952380952380952380952380952380952380952380952380952380952381 * textureMix(iChannel0, (fragCoord + vec2(3, 0))/iResolution.xy)+\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * textureMix(iChannel0, (fragCoord + vec2(4, 0))/iResolution.xy),\n     0.0035714285714285714285714285714285714285714285714285714285714286 * textureMix(iChannel0, (fragCoord - vec2(0, 4))/iResolution.xy)+\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * textureMix(iChannel0, (fragCoord - vec2(0, 3))/iResolution.xy)+\n     0.2000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord - vec2(0, 2))/iResolution.xy)+\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord - vec2(0, 1))/iResolution.xy)+\n     0.8000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord + vec2(0, 1))/iResolution.xy)+\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * textureMix(iChannel0, (fragCoord + vec2(0, 2))/iResolution.xy)+\n     0.0380952380952380952380952380952380952380952380952380952380952381 * textureMix(iChannel0, (fragCoord + vec2(0, 3))/iResolution.xy)+\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * textureMix(iChannel0, (fragCoord + vec2(0, 4))/iResolution.xy),\n    0.0,\n    0.0);\n\n    float t = 0.31234754256*3.1415926535;\n    fragColor.xy = mat2(cos(t),sin(t),-sin(t),cos(t))*fragColor.xy;\n    fragColor *= 3.0;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Buffer B: Divergence of Vector Field\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //if((iFrame % STEP_INTERVAL) != 0) {\n    //    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    //\n    //    return;\n    //}\n\n    /*\n    float x0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y;\n    float y1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y;\n\n    fragColor = vec4(0.5 * ((x1 - x0) + (y1 - y0)), 0.0, 0.0, 0.0); // divergence\n    */\n\n    /*\n    fragColor = vec4(\n     0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).y +\n    -0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y +\n     0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y +\n    -0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).y,\n    0.0, 0.0, 0.0); // divergence\n    */\n\n    fragColor = vec4(\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(4, 0), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(3, 0), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(3, 0), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(4, 0), 0).x +\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 4), 0).y +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 3), 0).y +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).y +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).y +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 3), 0).y +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 4), 0).y,\n    0.0,\n    0.0,\n    0.0); // divergence\n\n    /*\n    fragColor = vec4(\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x+\n\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).y +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).y +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).y +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).y +\n     2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).y +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).y,\n     0.0,\n     0.0,\n     0.0);\n     */\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Buffer C:\n//void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n//    fragColor = vec4(texture(iChannel0, 0.0009765625*fragCoord).r > 0.9 ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n//}\n/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float divergence = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n\n    float x0 = texelFetch_repeat(iChannel2, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel2, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel2, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y1 = texelFetch_repeat(iChannel2, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n\n    if(iFrame < 1) {\n        x0 = 0.0;\n        x1 = 0.0;\n        y0 = 0.0;\n        y1 = 0.0;\n    }\n\n   \tfragColor = vec4((x0 + x1 + y0 + y1 - divergence) * 0.25, 0.0, 0.0, 0.0);\n}\n*/\n\n/* */\n#define Pressure iChannel1\n#define Divergence iChannel0\nfloat ComputePressure4( vec2 fragCoord )\n{\n    float pressure = 0.0;\n    float divergence = 0.0;\n    \n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-4,  0), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2,  0), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-3, -1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-3,  1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 36.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1, -1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1,  1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2, -2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2,  2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2,  0), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1, -1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1,  1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0, -2), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  2), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1, -3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1,  3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 4,  0), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 3, -1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 3,  1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2, -2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2,  2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1, -3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1,  3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0, -4), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  4), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-3,  0), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  0), 0).x * 9.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2, -1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2,  1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2,  0), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  0), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -1), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  1), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 16.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1, -2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1, -1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  0), 0).x * 16.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 3,  0), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2, -1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2,  1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2,  0), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1, -2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1, -1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -3), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -2), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  3), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  2), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 64.0;\n\n    return (pressure - divergence) / 256.0;\n}\n/* */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(ComputePressure4(fragCoord), 0.0, 0.0, 0.0);\n    //fragColor.r *= 0.9;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Buffer D:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    /*\n    float x0 = texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y1 = texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    vec2 pressure_gradient = 0.5 * (vec2(x1, y1) - vec2(x0, y0));\n    */\n    /*\n    vec2 pressure_gradient = vec2(\n     0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(2, 0), 0).x,\n     0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 2), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 2), 0).x);\n    */\n\n    vec2 pressure_gradient = vec2(\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(4, 0), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(3, 0), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(3, 0), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(4, 0), 0).x,\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 4), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 3), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 2), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 2), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 3), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 4), 0).x);\n\n    /*\n    pressure_gradient = vec2(\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x,\n\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x);\n    */\n\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xy - pressure_gradient, texelFetch(iChannel0, ivec2(fragCoord), 0).zw);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 225], [879, 879, 900, 900, 1321], [1322, 1322, 1377, 1452, 2379]], "test": "untested"}
{"id": "dsyyD1", "name": "VolumetricTest_2", "author": "felipunkerito", "description": ".", "tags": ["3d", "volumetrics"], "likes": 1, "viewed": 152, "published": 3, "date": "1696040916", "time_retrieved": "2024-07-30T17:31:08.874592", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI acos(-1.)\n#define TWO_PI PI * 2.0\n#define QUARTER_PI PI * 0.25\n#define A1 0\n#define normalize(v) normalize(v+1e-5)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1030);\n    p3 += dot(p3, p3.zyx + 31.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(const in float a)\n{\n    vec2 sC = vec2(sin(a), cos(a));\n    return mat2(sC.x, -sC.y,\n                sC.y,  sC.x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    vec3 oP = p;\n    //p.xy = mod(p.xy + .25, 0.5)-.25;\n    //p.z = abs(p.z-0.5)-0.2;\n    /*const float t = 2.;\n    float fre = t;\n    float am = 0.5;\n    for (int i = 0; i < 1; ++i)\n    {\n        vec2 pXY = p.xy;\n        //pXY *= rot(p.z*fre);\n        //p.z += am*(sin(p.z*fre) + 0.5*cos(pXY.y*fre));\n        //p.xy *= rot(exp(-p.z)*fre);\n        //p.z += am;\n        am *= 1.;\n        fre *= 2.;\n    }*/\n    //p.xz *= rot(p.y*20.);\n    float s = (p.z)*0.+0.;//length(p)-.8;\n    \n    float amp = 1.2, freq = 0.2, res = 0.;\n    for (int i = 0; i < 3; ++i)\n    {\n        vec3 pT = p;\n        //pT.zy *= rot(-float(3-i)*QUARTER_PI*iTime*0.012);\n        res += amp * (dot(texture(iChannel0, pT * freq + iTime*.005), vec4(0.25))*2.0-1.0);\n        amp *= .5;\n        freq *= 3.;\n    }\n    //float c = abs(length(p.xz)-.25)-.1;\n    //s = max(s, -c);\n    float r;// = min(s -res*.05, res*.01);\n    \n    float repO = 2.;\n    float rep = 1. / repO;\n    //rep*= 0.5;\n    float hRep = rep * 0.5;\n    \n    for (int i = 0; i < 2; ++i)\n    {\n        oP.xy = mod(p.xy + hRep, rep) - hRep;\n        r = smin(r, length(oP-vec3(0., 0., -0.))-rep*0.4+\n                    res * 0.3, \n                 0.);\n        rep *= 0.5;\n        hRep = rep * 0.5;\n    }\n    \n    //vec2 id = floor((p.xy+hRep)*repO);\n    //if (/*hash13(id)*/id.x > 0.1)\n    {\n        //discard;\n        //oP.xy = mod(p.xy + hRep, rep) - hRep;\n    \n        \n        //r = length(oP-vec3(0., 0., 0.))-rep*0.4;\n        //r = r + res*rep*.5;\n            \n        r = smin(p.z+.32, r, 0.3)+res*rep*.0;\n    }\n    \n    \n    return r;\n}\n\nvec2 march(const in vec3 ro, const in vec3 rd, const in vec3 lDir, inout vec3 res)\n{\n\n    const uint marchSteps = uint(128),\n               shadowSteps = uint(4);\n\n    float d = 0.0, t = 0.0;\n    float stepSize = 1. / float(marchSteps);\n    //float sigmaT = 1.0;\n    //float transparency = 1.0;\n    \n    float stepL = 1. / float(shadowSteps);\n    \n    vec3 lD = lDir * stepL;\n    vec3 rD = rd * stepSize;\n    \n    res = vec3(0.);\n    \n    //vec3 ligC = vec3(0.600,0.678,0.529);\n    \n    float curDensity = 0.;\n    float transmittance = 1.;\n    vec3 lightEnergy = vec3(0.);\n    \n    //float accumDist = 0.;\n    \n    vec3 bac = mix(vec3(0.675,0.745,0.808), vec3(0.408,0.604,0.831), rd.z+0.5);\n    \n    for (uint i = 0u; i < marchSteps; ++i)\n    {\n    \n        #if (A1 == 0)\n        vec3 p = ro + rd * t;\n        d = map(p);\n        \n        if (d < 0.001)\n        {\n             float sha = 0.0;\n             \n             vec3 pL = p;\n             \n             float lT = 0.;\n             \n             for (uint j = 0u; j < shadowSteps; ++j)\n             {\n                 pL = pL + lDir * lT;\n                 float lD = map(pL);\n                 sha += lD;\n                 \n                 lT += stepL;\n             }\n             \n            curDensity = (d*-1.);\n            float shadowTerm = exp(-sha * stepL);\n            float absorbedLight = shadowTerm * curDensity * 0.98;\n            lightEnergy += /*vec3(0.835,0.616,0.678) * */ absorbedLight * transmittance;// * stepSize;\n            transmittance *= 1.-curDensity;\n        }\n        if (transmittance < 1e-3)\n        {\n            break;\n        }\n    \n        t += stepSize; \n    \n        #else\n        if (transparency < 1e-3)\n        {\n            break;\n        }\n        vec3 p = ro + rd * t;\n        d = map(p);\n        \n        if (d <= 0.0)\n        {\n\n            float sample_attenuation = exp(-stepSize * d * sigmaT);\n            transparency *= sample_attenuation;\n\n            float lT = 0.0;\n            float tau = 0.0;\n            float tt = 0.;\n            for (uint j = 0u; j < shadowSteps; ++j)\n            {\n                vec3 lP = p + lDir * tt;\n                tau += map(lP);\n                tt += stepL;\n            }\n            float lightRayAtt = exp(-tau * stepL);\n\n            res += lightRayAtt * transparency * stepSize;\n        \n        }\n        t += stepSize;\n        #endif\n    }\n    #if (A1 == 0)\n    res = lightEnergy;\n    #endif\n    //res = mix(res, bac*(1.-transmittance), lightEnergy);\n    res += bac * transmittance;\n    res = pow(res, vec3(2.22));\n    \n    //res = bac * transmittance + res;\n\n    return vec2(t, d);\n}\n\nvec3 shade(const in vec3 ro, const in vec3 rd)\n{\n    vec3 r = vec3(0);\n    vec2 mou = iMouse.xy / iResolution.xy;\n    float t = iTime*.1;\n    vec3 lDir = normalize(vec3(0.5, 10.7, 0.6)+\n    vec3(sin(t)*0.0, 0., cos(t)*0.));\n    vec2 m = march(ro, rd, lDir, r);\n    return r;// vec3(m.x*.02);\n}\n\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (-iResolution.xy + fragCoord * 2.0) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0.0, 0.1, -1.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    #if 1\n\n    mat2 r = rot(mou.y*-PI*.05);\n\n    //ro.z += iTime *.2;\n    //rd.z += iTime *.2;\n\n    ro.yz *= r;\n    rd.yz *= r;\n    \n    r = rot(mou.x*TWO_PI);\n\n    ro.xy *= r;\n    rd.xy *= r;\n    \n    \n    \n    #endif\n    \n    \n\n    vec2 recRes = 1./iResolution.xy;\n    float mRecRes = max(recRes.x, recRes.y);\n    \n    float rat = iResolution.x/iResolution.y;\n    \n    float v = sdRoundedBox( uv, vec2(.87, 0.8)*vec2(rat, 1.), vec4(0.));\n\n    // Time varying pixel color\n    vec3 col0 = mix(vec3(1), vec3(0), smoothstep(0.01, mRecRes*100., v));\n\n    vec3 col = shade(ro, rd);\n\n    // Output to screen\n    \n    fragColor = mix(vec4(col, 1.), vec4(0.), vec4(1.-col0, 1.));\n    //fragColor = vec4(pow(col, vec3(1.)),1.0);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 193]], "test": "untested"}
{"id": "msGyRz", "name": "Peppermint Waterfall", "author": "fenix", "description": "Another 2D particle experiment. I wanted to see what it would look like to model circular particles with rotation and angular velocity.\n\n*mouse to interact*\n*shift to render shock directions*\n*space to reset*", "tags": ["voronoi", "particles", "tracking", "jfa"], "likes": 37, "viewed": 345, "published": 3, "date": "1696038065", "time_retrieved": "2024-07-30T17:31:09.832032", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another 2D particle experiment. I wanted to see what it would look like to model\n//  circular particles with rotation and angular velocity.  I'm pleased with the result,\n//  especially how the stacks get rolling all together with alternating directions per\n//  level.\n//\n//  The rendering is also an experiment, combining a 2D particle simulation with a 3D\n//  rendering style. For the shadow render, the particles are spheres, but the particle\n//  render itself is just a 2.5D hack.\n//\n//      *mouse to interact*\n//      *shift to render shock directions*\n//      *space to reset*\n//\n//  Buffer A, B, and C perform particle simulation. Only A updates the particle neighbors.\n//  Buffer D computes screen-space voronoi for render.\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 LDIR = normalize(vec3(-10, 10, -1));\nconst float THICK = .1;\n\n// From iq's Extrusion and Revolution SDF\n// https://www.shadertoy.com/view/4lyfzw\nfloat opExtrusion(vec3 p, float sdf, float h)\n{\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n// 3D SDF of shelves/wall\nfloat mapScene(vec3 p)\n{\n    float d = opExtrusion(p, sdScene(p.xy, R), THICK);\n    return min(d, THICK - p.z);\n}\n\n// normal of shelves/wall\nvec3 normScene(vec3 p)\n{\n    const vec2 e = vec2(.001, 0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\n// raymarch shelves/wall\nvec3 marchScene(vec3 p, vec3 rd)\n{\n    for (int i = 0; i < 100; ++i)\n    {\n        float d = mapScene(p);\n        if (d < .001) return p;\n        p += rd * d;\n    }\n    return p;\n}\n\n// 3D SDF of particles, for shadow render\nfloat mapParticles(vec3 p)\n{\n    // render particle\n    uint id = fxGetClosest(ivec2(p.xy * R.y + .5 * R)).x;\n    float d = 1e6;\n    if (id < g_MaxParticles)\n    {\n        fxParticle v = fxGetParticle(id);\n        vec2 del = v.pos - p.xy;\n\n        d = length(vec3(del, p.z)) - CANDY_R;\n    }\n\n    return d;\n}\n\n// From iq's Soft Shadow Variation\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax, bool par)\n{\n\tfloat res = 1.;\n    float t = mint;\n    float ph = 1e10;\n    \n    for (int i = 0; i < 32; i++)\n    {\n\t\tfloat h = mapScene(ro + rd * t);\n        if (par) h = min(h, mapParticles(ro + rd * t)); // only render particles into shadow if rendering background\n            \n        float y = i == 0 ? 0. : h*h/(2.*ph); \n        float d = sqrt(h * h - y * y);\n        \n        res = min(res, 15. * d / max(0., t - y));\n        ph = h;\n        t += h;\n        \n        if (res < .0001 || t > tmax) break;\n    }\n    res = clamp(res, 0., 1.);\n    return res * res * (3. - 2. * res);\n}\n\nconst vec3 SHDIR = normalize(vec3(-1, 1, -2));\n\n// render a single particle\nvoid renderParticle(fxParticle p, vec2 u, uint id, inout vec4 O)\n{\n    float e = .5 / R.y;\n    vec2 del = u - p.pos;\n    float d2 = length2(del);\n    if (d2 < sqr(CANDY_R + e))\n    {\n        float d = sqrt(d2);\n        float a = atan(del.y, del.x) + p.r + d / CANDY_R * ((id & 2U) == 0U ? 1. : -1.);\n\n        vec3 col = (id % 2U) == 0U ? vec3(1, .3, .3) : vec3(.2, .5, .2); // green or red\n        const float STRIPE_SIZE = PI * .0625;\n        float blur = e * 5000. * abs(p.av);\n        col = mix(col, vec3(1), smoothstep(STRIPE_SIZE + blur, STRIPE_SIZE - blur, abs(mod(a, PI * .25) - PI * .125))); // stripes\n        col = mix(col, vec3(1), smoothstep(CANDY_R * .5 + e, CANDY_R * .1, d)); // center\n        \n        if (keyDown(KEY_SHIFT))\n            col = sin(atan(abs(p.sd.y * .1), p.sd.x) + vec3(0, 11, 33)) * .5 + .5;\n\n        del *= smoothstep(CANDY_R * .6, CANDY_R, d); // make flat spot\n        vec3 n = normalize(vec3(del, CANDY_R - sqrt(del.x * del.x + del.y * del.y))); // compute normal\n\n        float sh = calcSoftshadow(vec3(u, 0), SHDIR, .01, .25, false); // shadow\n        float diff = max(-.2, dot(n, LDIR)) * .3 + .15; // diffuse\n        col *= diff * (.5 * sh + .5); // shadows only darken diffuse\n        \n        vec3 re = reflect(LDIR, n); // reflected\n        vec3 rd = normalize(vec3(u, -1)); // ray dir\n        float spec = pow(max(0., dot(rd, re)), 8.) * sh; // specular\n\n        O.a = max(O.a, smoothstep(CANDY_R + e, CANDY_R - e, d)); // alpha\n        O.rgb = min(O.rgb, col + spec);\n    }\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    fxState s = fxGetState();\n    \n    vec2 p = .96 * (u - vec2(.5, .52) * R.xy) / R.y; // chop off the top so we don't have missing shadows\n    O = vec4(1, 1, 1, 0);\n\n    // render scene\n    vec3 rd = normalize(vec3(p - vec2(0, 1), 10));\n    vec3 ro = vec3(0, 1, -10);\n    vec3 hit = marchScene(ro, rd);\n    vec3 n = normScene(hit);\n\n    if (hit.z > 0.) // don't render particles where blocked by a shelf\n    {\n        // render particles\n        uvec4 ids = fxGetClosest(ivec2(p * R.y + .5 * R));\n        for (int i = 0; i < 4; ++i)\n        {\n            uint id = ids[i];\n            if (id >= g_MaxParticles) break;\n            fxParticle v = fxGetParticle(id);\n            renderParticle(v, p, id, O);\n        }\n    }\n    \n    if (O.a < 1.) // only render shadows where it is not completely blocked by a particle\n    {\n        // render scene\n        float sh = calcSoftshadow( hit, SHDIR, .01, .5, true) * .2 + .3;\n        vec3 col = (max(0., dot(n, LDIR) * .2 + .2) * vec3(.7, .7, .86)) * sh;\n        O.rgb = mix(col, O.rgb, O.a);\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = u / R;\n    uv *=  1. - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.; // multiply with sth for intensity\n    vig = pow(vig, .15); // change pow for modifying the extend of the  vignette\n    O *= vig;\n\n    O.rgb = pow(ACESFilm(O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, 0.);\n    else\n        O = voronoiParticle(p, id, dataType);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, DT / 3.);\n    else\n        O = fxSaveParticle(p, dataType); // skip voronoi update on buffers B and C (only one is needed)\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const uint IDEAL_MAX_PARTICLES = 400U; // if you don't have this x6 many pixels, you probably can't see them anyway...\nconst float CANDY_R = .015; // pappermint radius\nconst float PI = 3.141592653589793;\nconst float DT = .0002; // bucket animation increment (t cycles from 0 to 1)\n\n// If not applied carefully, the shock direction can create the a situation where\n// the particles get shoved towards the center of a container. This hack biases\n// the shock direction towards vertical, ensuring we get smaller green and blue\n// areas and more red, and preventing particles from being shoved towards the center.\nconst vec2 SHOCK_BIAS = vec2(1, 1); // disabled (not needed here)\n\n#define R iResolution.xy\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float res;  // tracks resolution changes\n    float t;    // animation time\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nfxState fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    \n    fxState s;\n    s.res = data.x;\n    s.t = data.y;\n    \n    return s;\n}\n\nvec4 fxPutState(fxState s)\n{\n    return vec4(s.res, s.t, 0, 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0);\n}\n\n//returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define SDAV 5U\n#define NUM_PARTICLE_DATA_TYPES 6U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(R.x), X, Y)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    uvec4 nbs[4]; // neighbors\n    vec2 pos;     // position\n    vec2 vel;     // velocity\n    vec2 sd;      // shock direction\n    float r;      // rotation\n    float av;     // angular velocity\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, SDAV), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = floatBitsToUint(particleData0);\n    particle.nbs[1] = floatBitsToUint(particleData1);\n    particle.nbs[2] = floatBitsToUint(particleData2);\n    particle.nbs[3] = floatBitsToUint(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.sd = particleData5.xy;\n    particle.r = particleData5.z;\n    particle.av = particleData5.w;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, p.vel);\n    case SDAV:  \n        return vec4(p.sd, p.r, p.av);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n// UTILITIES\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res)\n{\n    float d = 1e6;\n\n    // slanted walls\n    d = min(d, sdBox((p - vec2(-.2,  .3)) * rot2(-.2), vec2(.41, .01)));\n    d = min(d, sdBox((p - vec2(-.6,  .472)), vec2(.01, .1)));\n    d = min(d, sdBox((p - vec2( .2,  .0)) * rot2(.2), vec2(.41, .01)));\n    d = min(d, sdBox((p - vec2( .6,  .172)), vec2(.01, .1)));\n    d = min(d, sdBox((p - vec2(-.2, -.3)) * rot2(-.2), vec2(.41, .01)));\n    d = min(d, sdBox((p - vec2(-.6,  -.128)), vec2(.01, .1)));\n    d = min(d, sdBox((p - vec2( .2,  -.6)) * rot2(.2), vec2(.41, .01)));\n    d = min(d, sdBox((p - vec2( .6,  -.43)), vec2(.01, .1)));\n    \n    return d;\n}\n\n// the outward normal of the scene at a point\nvec2 normScene(vec2 p, vec2 res)\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res); \n    float x0 = sdScene(p - d.xy, res); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res); \n    float y0 = sdScene(p - d.yx, res); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// PARTICLE SIM\n\nconst vec2 GRAVITY = vec2(0., -.00005);\nconst float COLLISION_STIFFNESS = .3;\nconst float BOUNDARY_ELASTICITY = 1.5;\nconst float PARTICLE_ELASTICITY = 1.;\nconst float FRIC_COEF = .25;\n\n// resolve velocity errors against another particle or the boundary\n//\n//  rv   - relative velocity\n//  n    - normal\n//  nav  - neighbor angular velocity\n//  elas - elasticity\n//  lv   - linear velocity\n//  av   - angular velocity\nvoid constraint(vec2 rv, vec2 n, float nav, float elas, inout vec2 lv, inout float av)\n{\n    vec2 t = vec2(n.y, -n.x); // tangent\n    float nv = dot(rv, -n); // normal velocity\n    float ni = elas * max(0., nv); // normal impulse\n    float tv = dot(rv, t) - (av + nav) * CANDY_R; // tangent velocity\n    float fi = clamp(tv, -ni * FRIC_COEF, ni * FRIC_COEF); // friction impulse\n\n    lv += ni * n - fi * t; // apply linear impulse\n    av += fi / CANDY_R;    // apply angular impulse\n}\n\n#define updateParticle(A, B, C, D, E) updateParticleImpl(A, B, C, D, E, iFrame, R, iChannel0, iMouse)\nvec4 updateParticleImpl(fxState s, fxParticle p, uint id, uint dataType, float toff, int iFrame, vec2 res, sampler2D par, vec4 iMouse)\n{\n    if (iFrame == 0 || s.res < 0.)\n    {\n        p.pos = vec2(-1e6); // particles start in limbo\n    }\n    else if (p.pos.y < -1.) \n    {\n        if ((id + uint(iFrame / 8)) % g_MaxParticles == 0U) // move an offscreen particle to the top\n        {\n            vec3 h1 = hash3((id + uvec3(iFrame)) * uvec3(3, 6, 9)) - .5;\n            p.pos = vec2(-.4 + .2 * h1.x, .6);\n            p.vel = vec2(0);\n            p.sd = vec2(0, 1);\n            p.r = 0.;\n            p.av = 0.;\n        }\n    }\n    else\n    {\n        p.vel = p.vel + GRAVITY; // integrate velocity        \n        p.pos += p.vel; // integrate position\n        p.r += p.av; // integrate rotation\n        p.sd *= .5; // dissipate shock direction\n\n        vec2 imp = vec2(0); // collision linear impulse\n        vec2 nsd = p.sd; // new support direction\n        for(int i = 0; i < 4; i++)\n        {\n            uvec4 nbs = p.nbs[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                uint cid = nbs[j];\n                if(cid==id || cid >= g_MaxParticles) continue;\n\n                fxParticle n = fxGetParticleImpl(par, uint(res.x), cid);\n\n                vec2 dp = p.pos - n.pos;\n                float d2 = length2(dp) + CANDY_R * 1e-4;\n\n                if (d2 < sqr(CANDY_R * 5.))\n                {\n                    vec2 dir = dp / sqrt(d2);\n                    \n                    nsd += n.sd; // diffuse shock direction\n                    \n                    if (d2 < sqr(CANDY_R * 2.))\n                    {\n                        // position correction (ignore if shock direction disagrees)\n                        if (dot(p.sd, dir) > -.2)\n                            p.pos = mix(p.pos, n.pos + 2. * CANDY_R * dir, COLLISION_STIFFNESS);\n                        \n                        constraint(p.vel - n.vel, dir, n.av, PARTICLE_ELASTICITY, imp, p.av);\n                    }\n                }\n            }\n        }\n\n        float sd2 = length2(nsd);\n        if (sd2 > 1e-9)\n            p.sd = mix(p.sd, nsd * SHOCK_BIAS / sqrt(sd2), .9); // record new shock direction\n\n        if (dot(p.sd, imp) < -.2) // resist impulses against the shock direction\n            imp *= .5;\n\n        p.vel += imp; // apply collision impulse\n        \n        // handle mouse input\n        if (iMouse.z > 0.)\n        {\n            vec2 m = (iMouse.xy - .5 * res) / res.y;\n            const float MOUSE_RANGE = .1;\n            if (distance(m, p.pos) < MOUSE_RANGE)\n            {\n                const float MOUSE_STRENGTH = .005;\n                p.vel += (p.pos - m) * MOUSE_STRENGTH;\n            }\n        }\n\n        // handle boundary\n        float ds = sdScene(p.pos, res);\n        if (ds < CANDY_R * 2.)\n        {\n            vec2 n = normScene(p.pos, res);\n            p.sd = n; // seed shock direction\n            \n            if (ds < CANDY_R) // collide with boundary\n            {\n                p.pos -= n * (ds - CANDY_R);\n                \n                constraint(p.vel, n, 0., BOUNDARY_ELASTICITY, p.vel, p.av);\n            }            \n        }\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id >= g_MaxParticles || id == currentId || any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C) voronoiParticleImpl(iChannel0, iChannel1, R, iFrame, A, B, C)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, int iFrame, fxParticle p, uint id, uint dataType)\n{\n    uvec4 closest = fxGetClosestImpl(vor, ivec2(p.pos * res.y + .5 * res));\n    uvec4 bestIds = uvec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, closest[i], dataType, p.pos);\n        }\n\n        uint searchIterations = 8U;\n        for(uint k = 0U; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash3(uvec3(id + k, id * k, k * uint(iFrame))).x;\n            //pick random id of particle\n            uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n            sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n        }\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n", "buffer_c_code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(vec2 u);\nvec4 updateState(fxState s);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(s);\n    else\n        O = voronoiScreen(u);\n}\n\nvec4 updateState(fxState s)\n{\n    if (iFrame == 0 || R.x * R.y != abs(s.res) || keyDown(KEY_SPACE))\n    {\n        s.res = -R.x * R.y;\n        s.t = 0.;\n    }\n    else\n    {\n        s.res = abs(s.res);\n        s.t = fract(s.t + DT);\n    }\n\n    return fxPutState(s);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u), length2(v.pos - v.vel - u));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\nvec4 voronoiScreen(vec2 u)\n{\n\tvec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        const float SEARCH_RANGE = 10.;\n        const int SEARCH_COUNT = 4;\n        for (int i = 0; i < SEARCH_COUNT; ++i)\n        {\n            vec3 h = hash3(uvec3(u, iFrame * 4 + i));\n            sortNbs(fxGetClosest(ivec2(u + vec2((h.xy - .5) * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        vec3 h = hash3(uvec3(u, iFrame * 4));\n        uint id = uint(h.z * float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGyRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1113, 1196, 1243, 1243, 1338], [1340, 1366, 1390, 1390, 1479], [1481, 1507, 1531, 1531, 1776], [1778, 1803, 1837, 1837, 1983], [1985, 2027, 2055, 2078, 2335], [2337, 2413, 2487, 2487, 3061], [3111, 3139, 3205, 3205, 4660], [4662, 4746, 4769, 4769, 4929], [4931, 4931, 4967, 4967, 6457]], "test": "untested"}
{"id": "mdGyWh", "name": "CSG Iterative Raytracing", "author": "ttg", "description": "CSG Raytrace with unlimited layering (up to iteration limit) by reevaluating scene as needed and merging first two hits of each primitive.", "tags": ["raytracing", "csg"], "likes": 12, "viewed": 230, "published": 3, "date": "1696034622", "time_retrieved": "2024-07-30T17:31:10.838342", "image_code": "/*\n\nCSG Iterative Raytracing\nCopyright Theron Tarigo 2023\nhttps://www.shadertoy.com/view/mdGyWh\n\nI did not invent the techniques used here, they are free to use.\nHowever, the shader is for illustration and may not be copied.\n\nCSG Raytrace with unlimited layering (up to iteration limit) by reevaluating\nscene as needed and merging first two hits of each primitive.\n\n*/\n\n#define OUTPUT_EOTF EOTF_SRGB\n//#define OUTPUT_EOTF EOTF_POWSRGB\n\n#define ORI(R)   R[3].xyz\n#define DIR(R)   R[0].xyz\n\n// no intersection\n#define DIST_INF 1e10\n\nmat4 transl(vec3 t){ mat4 m=mat4(1.0);m[3]=vec4(-t,1.);return m;}\n\nmat4 rotx(float a){\n  vec2 s = vec2(cos(a),sin(a));\n  return mat4(   1,   0,   0, 0,\n                 0, s.x, s.y, 0,\n                 0,-s.y, s.x, 0,\n                 0,   0,   0, 1 );\n}\n\nmat4 roty(float a){\n  vec2 s = vec2(cos(a),sin(a));\n  return mat4( s.x,   0,-s.y, 0,\n                 0,   1,   0, 0,\n               s.y,   0, s.x, 0,\n                 0,   0,   0, 1 );\n}\n\nmat4 rotz(float a){\n  vec2 s = vec2(cos(a),sin(a));\n  return mat4( s.x, s.y,   0, 0,\n              -s.y, s.x,   0, 0,\n                 0,   0,   1, 0,\n                 0,   0,   0, 1 );\n}\n\nvec3 tex_blendrep(sampler2D samp, vec2 u) {\n  u = fract(u);\n  return mix(\n    mix(texsrgb(samp,.5*(u+vec2(1,1))),\n        texsrgb(samp,.5*(u+vec2(0,1))),\n        u.x),\n    mix(texsrgb(samp,.5*(u+vec2(1,0))),\n        texsrgb(samp,.5*(u+vec2(0,0))),\n        u.x),\n    u.y );\n}\n\nvec3 tex_triplan(sampler2D samp, vec3 pos, vec3 nor) {\n  // rotate to distract slightly from repeats on parallel axis-aligned planes\n  mat3 rot=mat3(rotx(.5)*roty(.2));\n  pos=rot*pos; nor=rot*nor;\n  nor = normalize(nor);\n  vec3 nor2 = nor*nor;\n  vec3 o=.5+.25*sign(nor);\n  return\n      nor2.x*tex_blendrep(samp,vec2(0,o.x)+pos.yz+vec2(1./6.,0))\n    + nor2.y*tex_blendrep(samp,vec2(0,o.y)+pos.zx+vec2(3./6.,0))\n    + nor2.z*tex_blendrep(samp,vec2(0,o.z)+pos.xy+vec2(5./6.,0)) ;\n}\n\nstruct seg {\n  vec4 n,f;\n  bool inside;\n};\n\nseg segc(bool inside, vec4 A, vec4 B) { return seg(A,B,inside); }\nseg segc(bool inside, vec3 Anorm, float Adist, vec3 Bnorm, float Bdist) {\n  return segc(inside,vec4(Anorm,Adist),vec4(Bnorm,Bdist));\n}\n\nseg surf_step(bool inside, vec4 A) {\n  return segc(inside,A,vec4(0));\n}\n\nseg surf_none() {\n  return surf_step(false,vec4(vec3(0),DIST_INF));\n}\n\nseg torus(mat4 ray, vec2 r) {\n  vec2 res;\n  float dist=0.;\n  for (int i=0;i<3;i++) {\n    // iq's torus should be exact, but seems to be troublesome numerically:\n    // pretend it's an estimator and solve in a few steps for slight improvement\n    res = iq_iTorus(ORI(ray)+DIR(ray)*dist,DIR(ray),r*(1.+.001*float(2-i)));\n    if (res.y<0.) return surf_none();\n    if(i==2) {\n      dist+=res.x;\n      break;\n    }\n    dist+=.5*res.x;\n  }\n  vec3 nn = iq_nTorus(ORI(ray)+DIR(ray)*dist,r);\n  if (res.y) nn=-nn;\n  nn=nn*mat3(ray);\n  return segc(bool(res.y),nn,dist,vec3(0),0.);\n}\n\nseg sphere(mat4 ray, float r) {\n  vec3 o = ORI(ray);\n  vec3 d = DIR(ray);\n  float a = dot(d,d);\n  float b = -dot(o,d)/a;\n  float c = (r*r-dot(o,o))/a;\n  float x = b*b+c;\n  if (x<=0.||b<0.&&c<0.) return surf_none();\n  float distfront = b-sqrt(x);\n  float distback = b+sqrt(x);\n  \n  vec3 normfront = (o+abs(distfront)*d)/r;\n  vec3 normback = -(o+distback*d)/r;\n  normfront=normfront*mat3(ray);\n  normback=normback*mat3(ray);\n  if(distfront>0.) return segc(false,normfront,distfront,normback,distback);\n  return segc(true,normback,distback,vec3(0),DIST_INF);\n}\n\nseg iq_box( mat4 ray, in vec3 rad ) \n{\n// Modified from https://www.shadertoy.com/view/ld23DV\n// Portions Copyright © 2014 Inigo Quilez\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Modifications by Theron Tarigo © 2023\n\n    vec3 rdd = DIR(ray).xyz;\n    vec3 roo = ORI(ray).xyz;\n    \n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return surf_none();\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    vec3 norback = -sign(rdd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n\n    float s = 1.;\n    if(all(lessThan(abs(roo),rad)))s=-1.;\n    \n    nor=nor*mat3(ray);\n    norback=norback*mat3(ray);\n    \n    if(s>0.) return segc(false,nor,tN,norback,tF);\n    return segc(true,norback,tF,vec3(0),DIST_INF);\n}\n\n\nseg intersect(seg A, seg B) {\n\n  // sort nears\n  if(A.n.w>B.n.w) { seg T=A;A=B;B=T; }\n\n  seg R=surf_none();\n  R.inside=A.inside&&B.inside;\n  // most conservative case: never step beyond first surface, whatever it is\n  R.n=A.n; R.f.w=0.;\n  // return R;\n  \n  // if one of the segs is a step, step to it\n  // should check for one finite when other is a step...\n  if( A.n.w>A.f.w || B.n.w>B.f.w ) return R;\n\n  if(A.inside&&B.inside) {R.f=A.f.w<B.f.w?A.f:B.f; }\n  if(!A.inside&&!B.inside) {R.n=B.n; R.f=A.f.w<B.f.w?A.f:B.f; }\n  if(A.inside&&!B.inside) {\n    if(A.f.w<B.f.w) {R.n=B.n;R.f.w=0.; }\n    else {R.n=A.n;R.f.w=0.; }\n  }\n  if(!A.inside&&B.inside) {\n    if(A.f.w<B.f.w) { R.n=A.n; R.f=A.f; R.f.w=0.; }\n    else { R.n=A.n; R.f=A.n; }\n  }\n  \n  return R;\n}\n\nseg neg (seg A) {\n  A.inside=!A.inside;\n  return A;\n}\n\nseg uniond (seg A, seg B) {\n  return neg(intersect(neg(A),neg(B)));\n}\n\nseg unionconvex (seg A, seg B) {\n// to be used only when each input is either a convex primitive or a result of unionconvex !\n  seg R = surf_none();\n  R.inside = A.inside||B.inside;\n  if(A.n.w>B.n.w) { seg T=A;A=B;B=T; }\n  R.n=A.n;\n  R.f=B.n.w>A.f.w?A.f:B.f;\n  return R;\n}\n\nseg makestep (seg A) {\n  A.f.w=0.;\n  return A;\n}\n\nseg _boundseg;\n#define BOUND(B,A) (_boundseg=(B),_boundseg.inside?intersect(A,_boundseg):makestep(_boundseg))\n#define GFNBOUND(B) seg _gfnboundseg=(B); if(!_gfnboundseg.inside)return makestep(_gfnboundseg);\n#define GFNBOUNDRET(A) return intersect(_gfnboundseg,A);\n\nseg dumbtorus(mat4 ray, vec2 rad) {\n  GFNBOUND(sphere(ray,rad.x+rad.y))\n  int n=24;\n  seg d = surf_none();\n  mat4 rot=rotz(_2pi/float(n));\n  for(int i=0;i<n;i++) {\n    seg d0 = sphere(transl(vec3(rad.x,0,0))*ray,rad.y);\n    //seg d0 = iq_box(rotx(.4)*transl(vec3(rad.x,0,0))*ray,vec3(rad.y));\n    d = unionconvex(d,d0);\n    ray = rot*ray;\n  }\n  GFNBOUNDRET(d)\n  //return d;\n}\n\n//#define torus dumbtorus\n\nseg geometry (mat4 ray) {\n\n  ORI(ray).z-=.5;\n\n    //return uniond(iq_box(ray,vec3(.2)),torus(ray,vec2(1,.5)));\n\n    //return (torus(ray,vec2(1,.5)));\n\n    seg d0=iq_box(ray,vec3(1.));\n    \n    //return d0;\n    \n    seg d1=sphere(transl(vec3(.6,-.6,.02))*ray,1.03);\n    seg d2=sphere(transl(vec3(.0,-.2,.02))*ray,1.03);\n    seg d3=neg(d1);\n    seg d4=neg(d2);\n    seg d5=intersect(d3,d4);\n    seg d6=neg(d5);\n    seg d7=neg(d6);\n    seg d8=intersect(d0,d7);\n    \n    seg d9=iq_box(transl(vec3(0,-.4,0))*ray,vec3(.2));\n    seg d10=uniond(d8,d9);\n    seg d11=iq_box(transl(vec3(-1.4,0,0))*ray,vec3(.02,1,1));\n    seg d12=uniond(d10,d11);\n\n    mat4 raytor = transl(vec3(0,0,-.5))*ray;\n    seg dtorus=torus(raytor,vec2(1,.5));\n    \n    d12 = intersect(d12,neg(dtorus));\n    d12 = intersect(d12,neg(iq_box(transl(vec3(0,0,.8))*ray,vec3(1.1,.5,.3))));\n    \n    //return torus(raytor,vec2(1,1.3));\n    \n    d12 = uniond(d12,\n      intersect(iq_box(transl(vec3(0,0,-1.5))*ray,vec3(vec2(2.02),1)),\n        intersect(torus(raytor,vec2(1,1.3)),\n                  neg(torus(raytor,vec2(1,1.))) ) )\n    );\n    \n    seg R=d12;\n\n    return (R);\n}\n\n#define NORTZERO\n#ifndef NORTZERO\nint rtzero;\n#else\nconst int rtzero=0;\n#endif\n\nconst int itermax = 200;\n\nvoid mainImageLRGB (out vec4 ImgOut, vec2 f) {\n#ifndef NORTZERO\n  rtzero = min(iFrame,0);\n#endif\n  ivec2 I = ivec2(f);\n  vec2 R = iResolution.xy;\n  vec2 uf=f;\n  vec2 uv = (uf+uf-R)/R.y;\n  vec2 m = (2.*iMouse.xy-R)/R.y;\n  if(iMouse==vec4(0)) m = vec2(-.5,-.3);\n\n  mat3 rdm;\n  rdm[0]=normalize(vec3(uv,-3.));\n  rdm[2]=normalize(cross(rdm[0],vec3(0,1,0)));\n  rdm[1]=cross(rdm[0],rdm[2]);\n  mat4 ray=mat4(rdm);\n  \n  ray=transl(vec3(0,0,-6))*ray;\n  ray=rotx(pi/2.)*ray;\n  ray=rotx(m.y*1.8)*ray;\n  ray=rotz(-m.x*2.)*ray;\n  \n  float distaccum=0.;\n  vec3 lastnorm=vec3(0);\n  vec3 hitnorm;\n  float hitdist;\n  for(int iter=0;iter<itermax;iter+=1+rtzero) {\n  \n    seg d = geometry(ray);\n\n    d.n.w=max(d.n.w,.0001); // should scale to current dist?\n    hitdist=(d.n.w);\n    bool surf=true;\n    hitnorm=d.n.xyz;\n  \n    if(d.n.w>d.f.w) {\n      surf=false;\n    }\n    if(d.inside) {\n      hitdist=0.;\n      hitnorm=vec3(0,0,0);\n      surf=true;\n    }\n\n    if(hitnorm==vec3(0))hitnorm=lastnorm;\n\n    if(hitdist>=DIST_INF) break;\n    ray[3].xyz+=ray[0].xyz*(hitdist)*(1.0001);\n    distaccum+=hitdist;\n    hitdist=distaccum;\n    if(!surf&&hitnorm!=vec3(0)) lastnorm=hitnorm;\n    if(hitnorm==vec3(0))hitnorm=lastnorm;\n    \n    if(surf) break;\n  }\n  \n  vec3 col=vec3(.5);\n  vec3 n=normalize(mat3(ray)*hitnorm);\n  vec3 p=ray[3].xyz;\n  if(hitdist<DIST_INF){\n    col=.7+.3*n;\n    col*=tex_triplan(iChannel1,p/4.,n);\n    p.z+=.9;\n    p.z*=4.;\n    col*=(1.-.8*exp(-.3*dot(p,p)));\n  }\n\n  ImgOut.rgb = col;\n}\n\nvoid mainImage (out vec4 Out, vec2 f) {\n  vec4 OutLRGB;\n  mainImageLRGB(OutLRGB,f);\n  output_eotf_select = OUTPUT_EOTF;\n  Out.rgb = output_oetf(OutLRGB.rgb);\n}\n", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define if(c) if(bool(c))\n\nconst float pi = acos(-1.);\nconst float _2pi = 2.*acos(-1.);\n\nvec3 srgb_oetf (vec3 c) {\n  return mix(12.92*c,1.055*pow(c,vec3(1./2.4))-.055,step(.0031308,c));\n}\n\nvec3 srgb_eotf (vec3 e) {\n  return mix(e/12.92,pow((e+.055)/1.055,vec3(2.4)),step(.04045,e));\n}\n\n#define EOTF_SRGB 0\n#define EOTF_POWSRGB 1\n\nint output_eotf_select = EOTF_SRGB;\n\nvec3 output_oetf (vec3 c) {\n  if(output_eotf_select==EOTF_SRGB)return srgb_oetf(c);\n  if(output_eotf_select==EOTF_POWSRGB)return pow(c,vec3(1./2.2));\n}\n\nvec3 output_eotf (vec3 c) {\n  if(output_eotf_select==EOTF_SRGB)return srgb_eotf(c);\n  if(output_eotf_select==EOTF_POWSRGB)return pow(c,vec3(2.2));\n}\n\n\nvec3 texsrgb(sampler2D samp, vec2 u) {\n  return srgb_eotf(texture(samp,u).rgb);\n}\n\n\n\nvec2 iq_iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n// https://www.shadertoy.com/view/4sBGDy\n// Copyright © 2014 Inigo Quilez\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return vec2(-1.0);\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n    \n    bool inside=(k0<0.);\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return vec2(-1.0);\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return vec2(-1.0);\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return vec2(result,inside);\n}\n\n// df(x)/dx\nvec3 iq_nTorus( in vec3 pos, vec2 tor )\n{\n// https://www.shadertoy.com/view/4sBGDy\n// Copyright © 2014 Inigo Quilez\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[531, 531, 551, 551, 596], [598, 598, 617, 617, 785], [787, 787, 806, 806, 974], [976, 976, 995, 995, 1163], [1165, 1165, 1208, 1208, 1439], [1441, 1441, 1495, 1573, 1919], [1965, 1965, 2004, 2004, 2030], [2031, 2031, 2104, 2104, 2165], [2167, 2167, 2203, 2203, 2238], [2240, 2240, 2257, 2257, 2309], [2311, 2311, 2340, 2340, 2882], [2884, 2884, 2915, 2915, 3441], [3443, 3443, 3481, 4664, 5381], [5384, 5384, 5413, 5430, 6139], [6141, 6141, 6158, 6158, 6194], [6196, 6196, 6223, 6223, 6265], [6267, 6267, 6299, 6392, 6539], [6541, 6541, 6563, 6563, 6589], [7260, 7260, 7285, 7285, 8390], [8498, 8498, 8544, 8544, 9979], [9981, 9981, 10020, 10020, 10140]], "test": "untested"}
{"id": "dsyyDh", "name": "palidas 001", "author": "palidas", "description": "first one ", "tags": ["noob"], "likes": 1, "viewed": 180, "published": 3, "date": "1696027896", "time_retrieved": "2024-07-30T17:31:11.875568", "image_code": "vec3 palette( float t ) {\n  vec3 a = vec3(0.108, 0.500, 0.448);\n  vec3 b = vec3(-0.752, 0.588, -0.362);\n  vec3 c = vec3(-0.782, 0.838, 0.778);\n  vec3 d = vec3(-0.192, -0.362, 0.528);\n  \n  return a + b*cos( 6.28318*(c*t+d) );\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n   \n   vec2 uv0 = uv;\n   \n   vec3 finalColor = vec3(0.0);\n   \n   for (float i = 0.0; i < 2.0; i++ ) {\n   uv = fract(uv * 1.5) - 0.5;\n   \n   float d = length(uv);\n   \n   vec3 col = palette(length(uv0) + iTime*.1);\n   \n   d = sin(d*8. + iTime)/8.;\n   d = abs(d);\n   \n   d = 0.02 / d;\n   \n   finalColor += col * d;\n   }\n   \n   \n   uv = fract(uv * 2.0) - 0.5;\n   \n   float d = length(uv);\n   \n   vec3 col = palette(length(uv0) + iTime);\n   \n   d = sin(d*8. + iTime)/8.;\n   d = abs(d);\n   \n   d = 0.02 / d;\n   \n   finalColor += col * d;\n\n   fragColor = vec4(finalColor, 1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 229], [231, 231, 288, 288, 931]], "test": "untested"}
{"id": "DsGcD1", "name": "Letterdance", "author": "oemfoe", "description": "Oldskool effect simulation where letters are dancing and then converge to their intended place", "tags": ["letterdancefontwriter"], "likes": 1, "viewed": 138, "published": 3, "date": "1696020060", "time_retrieved": "2024-07-30T17:31:12.915787", "image_code": "const vec4 coords[2] = vec4[2](\n    vec4(0.25, 0.25, 0.25, 0.25),\n    vec4(0.50, 0.50, 0.25, 0.25)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float k = 0.5 + 0.5 * sin(iTime); // k in [0, 1]\n    \n    bool hit = false;\n    for (int i = 0; i < 2; i++) {\n        vec2 offset = vec2(\n            0.1 + cos(float(i+1) * 1.5 * iTime) * 0.1,\n            0.1 + sin(float(i+1) * 1.5 * iTime) * 0.1\n        );\n        \n        vec2 offset2 = vec2(i == 0 ? 1. : -1.);\n        vec2 uvp = vec2(uv);\n        uvp += offset * k;\n        uvp.y += sin(uvp.x * 16.) * 0.1 * k;\n        vec4 coord = coords[i];\n        if (uvp.x >= coord.x && uvp.x < coord.x + coord.z &&\n            uvp.y >= coord.y && uvp.y < coord.y + coord.w) {\n            uv = uvp;\n            hit = true;\n            break;\n        }\n    }\n    \n    fragColor = vec4(0.);\n    if (hit)\n        fragColor = vec4(texture(iChannel0, uv / 4. + vec2(0.25, 0.5)).xxx, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 161, 211, 1039]], "test": "untested"}
{"id": "dsKyDz", "name": "random emotes animated", "author": "misol101", "description": "I'm sorry, but these little guys were just begging for some simple animation!\n\nReal work was done by stb obviously.", "tags": ["procedural", "random", "happy", "smiley", "sad", "emoji", "emote", "emotion", "emoticons", "smilies", "skeptical", "concerned", "suspicious"], "likes": 19, "viewed": 476, "published": 3, "date": "1696016879", "time_retrieved": "2024-07-30T17:31:13.795438", "image_code": "/*\n    random emotes\n    2021 stb\n    \n    animation by misol101 2023\n*/\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n//#define MOD3 vec3(.1031, .11369, .13787) // int range\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// circle inversion function\nvec2 cInv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\n// a line of width w, warped by circle inversion, offset by o\nfloat arc(in vec2 p, float w, in vec2 o) {\n    p = cInv(p, vec2(0.), 1.);\n    p = cInv(p, vec2(0., o.y), 1.);\n    p.y -= o.y;\n\n    return  length(vec2(max(0., abs(p.x-o.x)-w), p.y));\n}\n\nfloat emote(vec2 p, vec2 h, float aa, float time, vec2 lk, bool eyeb) {\n    float f=1., eyes, eyebrows=-.065, mouth, head;\n    vec2 o = vec2(0., 1.);\n    \n    float blinktime = 0.45;\n    float blx = 1.0, bly = 1.0;\n    float blt = (mod(iTime,8.)-(h.x*h.y)*8.);\n    if (blt > 0. && blt < blinktime) {\n        bly = 1. + sin((blt/blinktime)*3.141)*1.5;\n        blx = 1. - sin((blt/blinktime)*3.141)*0.4;\n    }\n    \n    // get eyes\n    eyes = length(vec2((abs(p.x-lk.x)-.36)*blx+.25*pow(lk.x+h.x*0.15+0.3, 0.9+h.y), (p.y-.27-lk.y)*bly )) - (.15);\n    \n    // get eyebrows (symmetrical or not)\n    if(fract(3.447*h.x) < .5)\n        eyebrows += arc(vec2(abs(p.x-lk.x)-.35, p.y-lk.y-.5*fract(1.46*lk.y)-.35), .2, 2.*fract(h*2.31)*h.y*o-.5*o);\n    else\n        eyebrows +=\n            min(\n                arc(vec2(p.x-lk.x-.35, p.y-lk.y-.25*fract(2.31*lk.y)-.4), .2, 2.*fract(h*2.31)*h.y*o-.5*o),\n                arc(vec2(-p.x+lk.x-.35, p.y-lk.y-.25*fract(-1.81*lk.y)-.4), .2, 2.*fract(-h*1.92)*h.y*o-.5*o)\n            );\n    \n    // get mouth\n    mouth = arc(p+vec2(0., .35)-.5*lk, .4*pow(max(0.0,h.x+sin(time*h.y*1.0)+0.8), .5), vec2(.35, 1.)*(fract(2.772*h)-.5)) - .08;\n    if(fract(1.932*h.x) < .10) // some emotes are surprised\n        mouth = length(vec2(((p.x-lk.x)-.36+.25)*(1.0-h.y*0.2), (p.y+.27-lk.y)*1.1)) - (.2+sin(0.2+time*(2.0*h.x+h.y))*(0.005+(h.y)*0.08));\n    \n    // get head\n    head = (abs(length(p)-1.) - .075) ;\n    \n    // combine everything\n    f = min(f, eyes);\n    if(eyeb) // some emotes have eyebrows\n        f = min(f, eyebrows);\n    f = min(f, mouth);\n    f = min(f, head);\n    \n    // result\n    return smoothstep(-aa, aa, f);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc )\n{\n    vec2 res = iResolution.xy;\n    vec2 p   = (fc-res/2.) / res.y;\n    vec2 m   = (iMouse.xy-res/2.) / res.y;\n    \n    float zoom     = iMouse.x>0. ? .0125 + .5 * iMouse.y / res.y : .2;\n    \n    // zoom\n    p /= zoom;\n    \n    // scroll\n    p.y -= .15 * iTime;\n    \n    // one hash22 to rule them all\n    vec2 h = hash22(ceil(p)+.371);\n\n    float headSize = 1.4;// + sin(iTime*h.x*2.)*0.06;\n    float aa       = 2. / zoom / res.y * headSize;\n\n\n    float time = iTime * (0.8+(h.x*h.y)) * 1.0;\n    \n    // look variable (where the face is facing)\n    vec2 lk = (0.75+sin(time*(min(1.4,0.5+h.y*0.66+h.x*1.33)))*0.5) * (.5 * (h-.5));\n    \n    bool eyebrows = fract(4.932*h.x) < .65; // some emotes have eyebrows\n    if (!eyebrows) lk*=sin(iTime*h.x+h.y*4.); else if (sin(h.x*h.y) < 0.5) lk=-lk;\n\n    p -= lk*0.1;\n\n    // get emote\n    float f = emote((headSize)*(fract(p)*2.-1.), h, aa, time, lk, eyebrows);\n    \n    // set initial color to black/white emote\n    vec3 col = vec3(f);\n    \n    // apply circles of color\n    if(length(fract(p)-.5) < .5/headSize) {\n        col *= 1.*fract(vec3(pow(h.x, .15), pow(fract(1.314*h.y), .15), fract(1.823*h.y)));\n        col *= pow(clamp(2.0*(.75-length(fract(p)-vec2(0.5, 0.6)*1.0)), 0.0, 1.15),1.3);\n    } else {\n        col *= 1.1 * mix( vec3(1.0,0.8,0.3), vec3(0.58, 0.99, 0.99), sqrt((fc/iResolution.y).y) );\n    }\n\n    // output\n    fo = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 273, 273, 408], [410, 439, 475, 475, 523], [525, 587, 629, 629, 771], [773, 773, 844, 844, 2426], [2428, 2428, 2471, 2471, 3869]], "test": "untested"}
{"id": "csyyWh", "name": "Sunrise Window", "author": "Nguyen2007", "description": "My first complex scene", "tags": ["raymarch", "aesthetic", "plant", "realistic", "agx"], "likes": 43, "viewed": 732, "published": 3, "date": "1696009112", "time_retrieved": "2024-07-30T17:31:14.754870", "image_code": "/*\nCredits:\n    \n    Thanks Inigo for reducing the compile time from 30 to only 2 seconds\n    (on my computer)\n    \n    Inigo Quilez's lighting model: https://www.shadertoy.com/view/Xds3zN\n    Plant based on Inae's \"Happy Plant\": https://www.shadertoy.com/view/4ltyD4\n    Subsurface scattering approx by Poisson: https://www.shadertoy.com/view/dltGWl\n    Wood texture based on dean_the_coder: https://www.shadertoy.com/view/mdy3R1\n    AgX based on bwrensch's: https://www.shadertoy.com/view/cd3XWr\n    \n    The rest I made by myself\n*/\n\nvec3 tone(vec3 v)\n{\n    mat3 m = mat3(.842479062253094,  .0423282422610123, .0423756549057051,\n                  .0784335999999992, .878468636469772,  .0784336,\n                  .0792237451477643, .0791661274605434, .879142973793104);\n\n    v = sat((log2(m * v) + 12.47393) / 16.5);\n  \n    vec3 v2 = v * v;\n  \n    v = v2 * (v2 * (15.5 * v2 - 40.14 * v + 31.96) - 6.868 * v + .4298) + .1191 * v - .00232;\n  \n    v = inverse(m) * mix(vec3(dot(v, vec3(.2126, .7152, .0722))),\n                         pow(vec3(1, .9, .7) * v, vec3(1.3)), 1.2);\n    \n    return mix(1.055 * pow(v, vec3(1) / 2.4) - .055, v * 12.92, lessThan(v, vec3(.0031308)));\n}\n\n// Fix by ttg: smooth noise -> white noise\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0);\n    \n    if (1.5 * abs(I.x - .5 * R.x) > R.y) return;\n    \n    vec2 p = I / R.xy;\n    \n    vec3 col = vec3(texture(iChannel0, p - vec2(.001, 0)).x,\n                    texture(iChannel0, p).y,\n                    texture(iChannel0, p + vec2(.001, 0)).z);\n    \n    col = tone(col * (h33(I.xyx) * .3 + .7) * (p.y * .8 + .2));\n    \n    col += S01(col);\n    \n    O = vec4(col * .5, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\n#define sat(x) clamp(x, 0., 1.)\n#define S smoothstep\n#define S01(a) S(0., 1., a)\n#define N normalize\n\n#define linear(x, a, b) sat((x - a) / (b - a))\n\n#define TAU 6.283185\n\n#define ZERO min(0, iFrame)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// PCG\nvec3 h33(vec3 p)\n{\n    uvec3 v = uvec3(p * 1e5) * 1664525u + 1013904223u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    \n\treturn vec3(v) / 4294967295.;\n}\n\n#define h23(p) h33(p).xy\n\n#define h13(p) h33(p).x\n\nfloat n13(vec3 p)\n{\n    vec3 s = vec3(7, 157, 113), ip = floor(p);\n\tp = S01(p - ip);\n    \n\tvec4 h = vec4(0, s.yz, 270) + dot(ip, s);\n    \n    #define n(x) fract(sin(x) * 43758.545)\n    \n\th = mix(n(h), n(h + 7.), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n#define cc(a) (2.33 * (a) * vec3(1, (a) * .5 + .5, a))", "buffer_a_code": "// Fix by iq <3: while loop -> for loop\n\nfloat fbm(vec3 p, int o, float r)\n{\n\tfloat s = 0.,\n\t      a = 1.,\n\t      t = 0.;\n    \n\tfor(int i = ZERO; i < o; i++)\n    {\n\t\ts += a * n13(p);\n\t\tt += a;\n\t\ta *= r;\n\t\tp *= 2.;\n\t}\n    \n\treturn s / t;\n}\n\nfloat mus(vec3 p, int o, float d, float l)\n{\n\tfloat s = 0.,\n\t      a = 1.;\n          \n\tfor(int i = ZERO; i > o; i++)\n    {\n\t\ts += 2. * a * n13(p) - a;\n\t\ta *= pow(l, -d);\n\t\tp *= l;\n\t}\n    \n\treturn s;\n}\n\nvec3 wood(vec3 p)\n{\n    vec3 q = p * vec3(7.8, 1.17, 1.17);\n    \n\tfloat n1 = fbm(q + vec3(n13(q + vec3(64, 83, 33)), n13(q + vec3(27, 96, 45)), n13(q + vec3(95, 87, 91)) * 2. - 1.), 8, .5),\n          n2 = mix(mus(vec3(n1 * 4.6), 8, 0., 2.5), n1 * .8 + .2, .85);\n    \n    q = p * vec3(.01, .15, .15);\n          \n    n2 *=   (1. - mus(vec3(sin(q.x * 20. + .4 * fbm(q * 3., 3, 3.)) * .5 + .5, q.yz), 15, .26, 2.4) * .4) /* Dirt  */\n          * (1. - S(.2, 1., mus(p * vec3(500, 6, 1), 2, 2., 2.5)) * .2);                                  /* Grain */\n    \n    return mix(mix(vec3(.03, .012, .003), vec3(.25, .11, .04), linear(n2, .19, .56)), vec3(.52, .32, .19), linear(n2, .56, 1.));\n}\n\nvec3 dirRough(vec3 nor, vec3 ref, float r, vec2 h)\n{\n    float sz = (1. - h.y) / (1. + (r * r - 1.) * h.y);\n          \n    vec3 u   = N(cross(nor, abs(nor.y) > .5 ? vec3(1, 0, 0) : vec3(0, 1, 0))),\n\t     ret = sqrt(1. - sz) * (cos(TAU * h.x) * u + sin(TAU * h.x) * cross(u, ref)) + sqrt(sz) * ref;\n    \n    return dot(ret, nor) > 0. ? ret : ref;\n}\n\n#define ranDisk(h) (sqrt(h.x) * vec2(sin(h.y * TAU), cos(h.y * TAU)))\n\nfloat smin(float a, float b, float k)\n{\n\tfloat f = linear(a - b, -k, k);\n    return mix(a, b, f) - k * (f - f * f);\n}\n\n#define smax(a, b, k) smin(a, b, -k)\n\n#define sabs(p, k) (sqrt((p) * (p) + k * k) - k)\n\n#define sdSph(p, r) (length(p) - r)\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    p = abs(p) - b;\n    return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.));\n}\n\nfloat sdCyl(vec3 p, float h, float r)\n{\n    vec2 d = vec2(length(p.xz) - r, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// Modified for the \"chair\"\nfloat sdHor(vec3 p, float a, float r)\n{\n    p.x = abs(p.x);\n    \n    float l = length(p.xy);\n    \n    p.xy *= mat2(-cos(a), sin(a), sin(a), cos(a));\n    \n    p.xy = vec2(((p.y > 0. || p.x > 0.) ? p.x : l * sign(-cos(a))) - 1.,\n                abs(((p.x > 0.) ? p.y : l) - r));\n    \n    return length(vec2(length(max(p.xy, 0.)) + min(0., max(p.x, p.y)), p.z));\n}\n\nfloat leaf(vec3 p, float a, float s)\n{\n    p.xy *= rot(-a);\n\n    //main part\n    \n    p.x -= .25 * s;\n    p.y = -sabs(p.y - .02, .01) - .95 * s;\n    p.z = sabs(p.z, .01) + .05;\n    \n    float d = sdSph(p, s);\n    \n    //tip\n    p.x -= .175 * s;\n    p.z += .423 * s - .05;\n    \n   \treturn smin(d, sdSph(p, s * 1.05), .05);\n}\n\n#define opU(a, b) ((a.x < b.x) ? a : b)\n\nvec2 map(vec3 pos)\n{\n    vec2 res = vec2(10, 0);\n    \n    // Wall\n    \n    res = opU(res, vec2(sdBox(pos - vec3(0, -5, .4), vec3(5, 5, .1)), 1));\n\n    // Table\n    \n    res = opU(res, vec2(sdBox(pos, vec3(5, .025, .525)) - .05, 2));\n    \n    // Bumps\n    \n    res = opU(res, vec2(sdBox(pos - vec3(0, .15, .3), vec3(5, .05, .15)) - .03, 3));\n    res = opU(res, vec2(sdBox(pos - vec3(0, .3, .4), vec3(5, .05, .15)) - .03, 3));\n    \n    // Frame\n    \n    res = opU(res, vec2(sdBox(pos - vec3(0, 5, .4), vec3(.1, 5, .05)) - .03, 3));\n    \n    // Pot\n    \n    vec3 p = pos / 1.7 + vec3(.53, -.15, .12);\n    p.xz *= rot(2.);\n    \n    res = opU(res, vec2(smax(smax(sdSph(p, .2), p.y - .1, .01), -sdSph(p, .18), .01), 4));\n    \n    // Dirt\n    res = opU(res, vec2(smax(p.y - .06, sdSph(p, .18), .01), 5));\n    \n    // Plant\n    \n    if(sdCyl(pos + vec3(.9, -.6, .2), .2, .5) < 0.)\n    {\n        p.y -= .06;\n\n        float a = 1.2, o = .01;\n\n        for(int i = ZERO; i < 20; i++)\n        {\n            p.xz *= rot(3.883);\n            a *= .9;\n            o += .002;\n            res = opU(res, vec2(leaf(p - vec3(o, 0, 0), a, .3), 5));\n        }\n    }\n    \n    // Books\n    #define book(i) res = opU(opU(res, vec2(smax(sdBox(p, vec3(.4, .05, .3)) - .05, -sdBox(p + vec3(0, 0, .1), vec3(.5, .05, .4)), .01), i)), vec2(sdBox(p + .01 * n13(p * 20.), vec3(.41, .05, .31)), 8));\n    \n    p = pos - vec3(.17, .15, -.3);\n    p.xz *= rot(.2);\n\n    book(6)\n\n    p.y -= .2;\n    p.xz *= rot(-.2);\n\n    book(7)\n    \n    // Cloth\n    p = pos - vec3(-.9, -.33, -.17);\n    res = opU(res, vec2(smax(sdBox(p, vec3(.45, .4, .4)) - .03, -sdBox(p - vec3(0, -.1, .1), vec3(.5)), .01), 9));\n    \n    // \"Chair\"\n    \n    p = pos - vec3(.1, .1, -1.5);\n    p.y *= -1.;\n    p.xz *= rot(-.4);\n    p.yz *= rot(-.05);\n    \n    res = opU( res, vec2(max(sdHor(p, 1.6, .6), sdBox(p, vec3(.5, .6, .03))) - .03, 10));\n    res = opU( res, vec2(sdHor(p + vec3(0, .4, 0), 1.4, .5) - .05, 10));\n    \n    return res;\n}\n\nvec2 raycast(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(0);\n\n    float t = 0.;\n    for(int i = ZERO; i < 256 && t < 6.5; i++)\n    {\n        vec2 h = map(ro + rd * t);\n        if(abs(h.x) < 1e-4 * t)\n        { \n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, vec3 rd, float tmax, float w)\n{\n    float res = 1., t = 0.;\n    \n    for(int i = ZERO; i < 70 && t < tmax && res > -1. && t < tmax; i++ )\n    {\n        float h = map(ro + t * rd).x;\n        res = min(res, h / (w * t));\n        t += clamp(h, .01, .5);\n    }\n    \n    return S01(res * .5 + .5);\n}\n\n// Fix by iq: using the material from raycast instead\n//            of evaluating the map function again\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 pos, float m)\n{\n    vec3 n = vec3(0);\n    for(int i = ZERO; i < 4; i++)\n    {\n        vec3 e = mod(vec3((i + 3) / 2, i / 2, i), 2.) - .5;\n        n += e * map(pos + 1e-4 * e).x;\n    }\n    \n    if(m > 5.5 && m < 7.5)\n    {\n        vec2 e = vec2(.01, 0);\n        pos *= 1e2;\n        \n        n = mix(N(n), N(vec3(n13(pos - e.xyy) - n13(pos + e.xyy),\n                             2. * e.x,\n                             n13(pos - e.yyx) - n13(pos + e.yyx))), .1);\n    }\n    \n    return N(n);\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 1., sca = 3., h = .01;\n    \n    for(int i = ZERO; i < 5 && occ > 0.; i++)\n    {\n        occ -= (h - map(pos + h * nor).x) * sca;\n        sca *= .95;\n        h += .03;\n    }\n    \n    return sat(occ) * (.5 + .5 * nor.y);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 p)\n{\n    // background\n    vec3 col = vec3(.3, .4, .2) * fbm((-2. - ro.y) / rd.y * rd + ro, 3, .5);\n\n    // raycast scene\n    vec2 res = raycast(ro, rd);\n\n    float m = res.y, t = (m > .5) ? res.x : (-2. - ro.y) / rd.y;\n    \n    vec3 pos = ro + t * rd,\n         nor = calcNormal(pos, m),\n         ref = reflect(rd, nor);\n\n    bool pot = false;\n    \n    vec3 op = pos;\n    float ot  = t,\n          fre = .96 * pow(1. + dot(rd, nor), 5.) + .04;\n\n    // material\n    if(m == 4.)\n    {\n        pot = true;\n\n        res = raycast(pos, dirRough(nor, ref, 1. - fre, h23(pos * 1e2 + iTime)));\n        t = res.x;\n        m = res.y;\n        \n        if (m < .5) col = vec3(0);\n        pos = ro + t * rd;\n    }\n\n    if(m == 1.)  col = vec3(0);\n    if(m == 2.)  col = wood(pos.zxy) * .3;\n    if(m == 3.)  col = vec3(.4, .15, .1);\n    if(m == 5.)  col = vec3(.07, .1, .05);\n    if(m == 6.)  col = vec3(1, .2, .2);\n    if(m == 7.)  col = vec3(0, .1, .3);\n    if(m == 8.)  col = vec3(2);\n    if(m == 9.)  col = vec3(.5, .3, .2) * (.2 + (step(mod(pos.x - .075, .1), .05) + max(step(mod(pos.y, .1), .05) * float(pos.y < .1), step(mod(pos.z - .02, .1), .05))) * .6);\n    if(m == 10.) col = vec3(.4, .2, .1);\n\n    if(pot) {t = ot; pos = op;}\n\n    // lighting\n\n    float occ = calcAO(pos, nor) * .9 + .1;\n\n    vec3 lin = vec3(0),\n    \n         sun = N(vec3(5, 4, 6));\n    \n    // sun\n    {\n        float dif = sat(dot(nor, sun)) * softshadow(pos, sun, 3., .1) * occ,\n\n        km = .05;\n\n        if(m == 5. || m == 9.)             km = 1.;\n        if(m == 2. || m == 3. || m == 10.) km = .2;\n\n        float g = pow(dot(nor, N(sun - rd)), 2.) * (km * km - 1.) + 1.,\n              spe = km * km / (TAU / 2. * g * g) * dif * fre;\n\n        lin += col * 22. * cc(dif) * vec3(1.3, 1, .7);\n        lin +=       50. *   spe   * vec3(1.3, 1, .7);\n    }\n\n    // sky\n    {\n        float dif = sqrt(.5 + .5 * nor.y) * occ;\n\n        float spe = S(-.2, .2, ref.y) * max(ref.z, 0.) * dif * fre * softshadow(pos, ref, 3., .1);\n\n        lin += col *  .6 * cc(dif) * vec3(.4, .6, 1.2);\n        lin +=       2.  *   spe   * vec3(.4, .6, 1.3);\n    }\n\n    // back\n    {\n        lin += col * 1.4 * cc(sat(dot(nor, -sun)) * occ);\n    }\n\n    // sss\n\n    {\n        float dif = pow(1. + dot(nor, rd), 2.) * occ;\n\n        lin += col * cc(dif);\n        if(m == 5.) lin += col * cc(dif);\n\n        float r = 1.;\n        if(m == 5.) r = 5.;\n\n        lin += .44 * col * cc(exp(-3. * abs(dot(nor, sun)) / r) * occ) * r;\n    }\n    \n    if(pot) lin *= 2.;\n    \n    col = mix(vec3(1.3, 1, .7), lin, exp(-.002 * t * t));\n    \n    col *= pow(1. - .6 * length(p), 1.2);\n    \n    col += vec3(.4, .2, .1) * pow(sat(dot(sun, rd)), 4.);\n        \n    return max(col, 0.);\n}\n\nmat3 setCamera(vec3 ro, vec3 ta)\n{\n\tvec3 w = N(ta - ro),\n\t     u = N(vec3(-w.z, 0, w.x));\n         \n    return mat3(u, cross(u, w), w);\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    if (1.49 * abs(I.x - .5 * R.x) > R.y)\n    {\n        O = vec4(0);\n        return;\n    }\n\n    // camera\t\n    \n    vec3 ta = vec3(- .3,  .4,  0),\n         ro = vec3(-1.4, 2.4, -4);\n         \n    mat3 ca = setCamera(ro, ta);\n\n    // pixel coordinates\n    \n    vec2 p = (2. * I + 4. * h23(vec3(I, iTime)) - 2. - R.xy) / R.y;\n\n    // ray direction\n    vec3 rd = ca * N(vec3(p, 4.8)),\n         fp = ro + rd * 4.;\n    \n    ro += ca * vec3(ranDisk(h23(vec3(I, iTime) + 9.)), 0.) * .1;\n    rd  = N(fp - ro);\n    \n    vec4 last = texture(iChannel0, I / R.xy);\n    float blend = (last.a == 0. || texture(iChannel1, vec2(.126)).x > .1) ? 1. : 1. / (1. + (1. / last.a));\n    \n    O = vec4(mix(last.rgb, render(ro, rd, p), blend), blend);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34807, "src": "https://soundcloud.com/herbalpert/ladyfingers", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csyyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 556, 556, 1178], [1224, 1224, 1260, 1260, 1661]], "test": "untested"}
{"id": "mdKyWR", "name": "some imaginary stuff", "author": "01000001", "description": "just messing around with random stuff. Ended up pretty cool. ", "tags": ["smol"], "likes": 12, "viewed": 293, "published": 3, "date": "1696006211", "time_retrieved": "2024-07-30T17:31:15.689371", "image_code": "#define s(x) smoothstep(0., .7, x)\n#define iters 7\n\n//#define darkmode\n#ifdef darkmode \n    #define dark 1.-\n#else\n    #define dark\n#endif\n\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x += k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 m(vec2 uv, float s){\n    \n    vec2 a,x,p=uv;\n    \n    for (int i = 0; i++<2<<iters;){\n    \n        vec2 t = p, b = t*0.;\n        a = uv;\n        a = mix(a, t               , s(s-b++)); // Julia set becomes this at a certain input 🤔\n        a = mix(a, vec2(uv.x,  t.y), s(s-b++)); \n        a = mix(a, vec2(t.  x,uv.y), s(s-b++));\n        a = mix(a, vec2(t.  y,uv.x), s(s-b++)); // Not surprised its asymmetrical.\n        a = mix(a, vec2(uv.y,  t.x), s(s-b++)); // Curly area below looks cool. Top edge might be interesting\n        a = mix(a, uv.     yx      , s(s-b++)); // Favourite one\n        a = mix(a, t.      yx      , s(s-b++)); // What's this?! Seems rotationally symmetrical\n                                                // which is incredibly weird. Why 3? Huh???\n        a = mix(a, t*uv.yx         , s(s-b++));                                \n        a = mix(a, t.yx*uv         , s(s-b++));                                \n\n        a = mix(a, uv.     xy      , s(s-b++)); // Restore to loop\n\n        p.x = t.x*t.x - t.y*t.y + a.x;\n        p.y = 2.*t.x*t.y + a.y;\n        \n        x.y = float(i);\n        \n        if (length(p) > 2.) break;\n    }\n    x.x = dark exp(-x.y/4e1);\n    \n    return x;\n\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n    float s = mod(iTime/2., 10.);\n    cuv *= 2.;\n    \n    int ssaa = 1 + int(iFrameRate/10.);\n    \n    vec2 x = uv*0.;\n    for (int i = 0; i++<ssaa;){\n    \n        x += m(cuv + (hash(uvec3(i)).xy*2.-1.)/r.y, s);\n        \n    }\n    x /= float(ssaa);\n    \n    O = x.xxxx;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 241, 241, 386], [1607, 1607, 1644, 1644, 1998]], "test": "untested"}
{"id": "msKcWR", "name": "Old school pseudo 3D night race", "author": "Lucky4Luuk", "description": "I felt very inspired by the original shader, so I forked it and added some lighting and set it to nighttime :)", "tags": ["3d", "road", "road", "pseudo3d", "fake3d", "pseudo"], "likes": 11, "viewed": 262, "published": 3, "date": "1695998009", "time_retrieved": "2024-07-30T17:31:16.577995", "image_code": "void mainImage( out vec4 f, vec2 p ){\n    \n    vec3 q=iResolution,d=vec3(p-.5*q.xy,q.y)/q.y,c=vec3(0,.5,.7);\n    vec2 uv = p / iResolution.xy;\n    \n    q = d/(.1-d.y*5.5);\n    // q.x -= 0.5;\n    float a = iTime;\n    \n    float k = sin(0.2*a);\n    \n    float w = q.x *= q.x-=.05*k*k*k*q.z*q.z;\n    // w *= 0.2;\n\n    f.xyz=d.y>.015?c:\n    \tsin(4.*q.z+40.*a)>0.?\n        w>2.?c.xyx:w>1.2?d.zzz:c.yyy:\n\t    w>2.?c.xzx:w>1.2?c.yxx*2.:(w>.004?c:d).zzz;\n        \n        \n    vec3 lighting = vec3(0.2, 0.2, 0.2); // ambient lighting\n    float distToSide = 1.0 - clamp(abs(w - 1.2) * 0.5, 0.0, 1.0);\n    float spotStrength = (sin((4.0 * q.z + 40.0 * a) * 0.25) * 0.5 + 0.5);\n    float lightStrength = spotStrength * distToSide;\n    lightStrength *= lightStrength;\n    lighting += vec3(0.6, 0.5, 0.3) * lightStrength * 1.2;\n    \n    if (d.y <= 0.015) { f.xyz *= lighting; } else { f.xyz *= 0.3; }\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 894]], "test": "untested"}
{"id": "dsVyRw", "name": "Biom Texture Shuffle Bilinear", "author": "gehtsiegarnixan", "description": "simple demo on how to do a terrain with differen bioms and texture breakup in one. This is a modified version of Directional Flow. ", "tags": ["terrain", "terrain", "texture", "normal", "height", "tiling", "ground", "bilinear", "stochastic", "directionalflow", "biom"], "likes": 4, "viewed": 211, "published": 3, "date": "1695988063", "time_retrieved": "2024-07-30T17:31:17.721937", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a demo that shows how to disrupt texture tiling, sample \ndifferent biomes, and blend them seamlessly. This technique is a slight \nvariation of the Directional Flow method.\n\nThis code is extensively commented to help you understand its inner \nworkings. It's important to note that it's designed to work with a \nrange of features that Shadertoy may not have, such as Texture Arrays \nand Gather functions. If you have access to these native functions, \nit's recommended to use them instead. The Directional Flow algorithm \nis a versatile tool capable of creating a variety of effects, which \ngo beyond the scope of this shader.\n\nWhile this shader is relatively efficient, especially when used for \nterrain rendering, it can be further optimized. You might have come \nacross my 3-sample version of Directional Flow, which works here too. \nAdditionally, my dithered versions with a single sample also work \nwell but it needs TAA or some kind of motion blur to look good.\n\nThe more efficient versions can become quite complex and require a \ngood understanding of how the bilinear version works. I might create \nseparate variants to explain these concepts in more detail.\n\nThis demo includes mouse controls to adjust the light direction, zoom \nand various parameters mentioned below this header.\n\nAdditional reading material:\n\nCatlikeCoding's has a well explained guide on Directional Flow:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n\nCOD recently made a presentation explaining the same method:\nhttps://advances.realtimerendering.com/s2023/index.html#CODTerrain\n\nHere's a 1 sample version using dithering bilinear interpolation:\nhttps://www.shadertoy.com/view/DsVcW1\n\nAlso see this for a 3-ample texture tiling breakup:\nhttps://www.shadertoy.com/view/7dGfzR\n*/\n\n// Enable debug grid where the two mappings blend with each other\n#define LINETHICKNESS 0.01\n//#define SHOWGRID\n\n// Size of interpolation grid\n#define GRIDSIZE 32.0\n\n// Power scale: 1 means no contrast, 50 means maximum contrast\n#define CONTRAST 2.0\n\n// Maximum noise offset in grid scale\n#define NOISESTRENGTH 1.2\n\n// Scale of noise in grid scale\n#define NOISESCALE 1.3 \n\n// Size of textures in grid scale\n#define DETAILSCALE 1.0\n\n// Function to select a texture using an index. Acts like a crude texture array.\nvec4 textureArray(int index, vec2 uv) {\n    vec4 color;    \n    if (index == 0) {\n        // the gravel texture is just greyscale so we make it pretty with a colormap\n        color = vec4(bone(texture(iChannel0, uv).x),0);\n    } else if (index == 1) {\n        color = texture(iChannel1, uv);\n    } else if (index == 2) {\n        color = texture(iChannel2, uv);\n    } else {\n        color = texture(iChannel3, uv);\n    }\n    return color;\n}\n\n// Function for generating normals using three texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal(int heightMap, vec2 uv, float strength) {\n    vec2 s = 1.0 / iChannelResolution[0].xy;\n    \n    float textureOffset = 1.0;\n    \n    float p = textureArray(heightMap, uv).y;\n    float h1 = textureArray(heightMap, uv + s * vec2(textureOffset, 0.0)).y;\n    float v1 = textureArray(heightMap, uv + s * vec2(0.0, textureOffset)).y;\n    \n    vec2 xy = (p - vec2(h1, v1));\n    \n    return normalize(vec3(xy * strength, 1.0));\n}\n\n// Struct to hold material values\nstruct materialVal {\n    vec3 color;\n    vec3 normal;\n};\n\n// Function to sample biomes and generate materials\nmaterialVal biomSample(sampler2D biomTex, float gridSize, vec2 biomUV, vec2 detailUV, \n    float detailScale, vec2 offset) {\n    \n    // Biom ________________________________________________________________\n        \n    // Coordinates of every other grid point\n    vec2 scaledCoords = (floor(biomUV * (gridSize/2.) +.25 +offset) -offset)*2.;\n    \n    // Get biome texture resolution\n    vec2 texSize = vec2(textureSize(biomTex, 0));\n    \n    // Modulo for looping biome textures\n    ivec2 texelCoords = ivec2(fract(scaledCoords/gridSize) * texSize);\n    \n    // Sample the texels. Gather would be better, but is not available in Shadertoy\n    float biom = texelFetch(biomTex, texelCoords, 0).x;\n    \n    // Increase to separate numbers\n    float biomCount = 4.; // Since we can only have 4 textures\n    \n    // Scale biom sample to seperate integers\n    //int biomID = int(biom * biomCount);\n    // Since I don't have an actual biom texture I'll do some modifications \n    int biomID = int(biom * 7.);\n    \n    // Sample Detail Textures ______________________________________________\n    \n    // This hash doesn't like 0. Mod is optional and makes it repeat at uv 0-1.\n    vec2 hashCoords = mod(scaledCoords, gridSize) + 1.; \n    \n    // Obtain a cheap random vector \n    vec2 rnd = hash22(hashCoords) * 2.0 - 1.0;\n    \n    // Scale UVs for detail textures, should be higher than texSize\n    detailUV = detailUV * gridSize * detailScale;\n    \n    // Normalize vector to prevent rotation from scaling the result\n    vec2 rotation = normalize(rnd);\n    \n    // Randomly rotate\n    detailUV = rotateUV(detailUV, rotation);\n    \n    // Randomly offset\n    detailUV += rnd;\n    \n    // Sample detail texture\n    vec3 color = textureArray(biomID, detailUV).xyz; \n    \n    // Sample Normal, if you can use an actual normal texture instead\n    vec3 normal = HeightToNormal(biomID, detailUV, 50.0);\n    \n    // Since we rotated the UVs we have to rotate the normals too\n    normal = vec3(rotateUV(normal.xy, rotation), normal.z);\n    \n    // Combine color and normal into a struct\n    return materialVal(color, normal);\n}\n\n// Generate biomes blending with texture tiling breakup in one\nmaterialVal biomTexShuffle(sampler2D biomTex, vec2 uv, float gridSize, \n    float contrast, float noiseStrength, float rndScale, float texScale) {\n\n    // Tiling Noise ________________________________________________________\n    // The tiling noise idea is from COD:\n    // https://advances.realtimerendering.com/s2023/index.html#CODTerrain\n    \n    // Scale noise coordinates to be independent of biome dimension for convenience\n    vec2 noiseUV = uv * gridSize / rndScale;\n    \n    // Sample noise vector; using a 2D texture of Perlin noise would be better\n    vec2 noiseVec = simplexNoiseVec(noiseUV);\n    \n    // Apply strength and correct for biome dimension again\n    noiseVec = noiseVec * noiseStrength / gridSize;\n    \n    // Distort the grid UVs to hide the tiling pattern\n    vec2 gridUV = uv - noiseVec;\n\n    // Sample Textures _____________________________________________________\n    \n    // Sample 4 closest biomes\n    materialVal detailA = biomSample(biomTex, gridSize, gridUV, uv, texScale, \n        vec2(0.0, 0.0));\n    materialVal detailB = biomSample(biomTex, gridSize, gridUV, uv, texScale, \n        vec2(0.0, 0.5));\n    materialVal detailC = biomSample(biomTex, gridSize, gridUV, uv, texScale, \n        vec2(0.5, 0.0));\n    materialVal detailD = biomSample(biomTex, gridSize, gridUV, uv, texScale, \n        vec2(0.5, 0.5));\n    \n    // Weights ____________________________________________________________\n    \n    // Generate zigzag pattern\n    vec2 zigZag = abs(fract(gridUV * gridSize/2.0 - 0.25)*2.0-1.0);\n    \n    // Invert zigzag as a partial of the weights\n    vec2 infZigZag = 1.0 - zigZag;\n\n    // Generate alpha values (weights) for bilinear interpolation.\n    float weightA = zigZag.x * zigZag.y;\n    float weightB = zigZag.x * infZigZag.y;\n    float weightC = infZigZag.x * zigZag.y;\n    float weightD = infZigZag.x * infZigZag.y;\n    \n    // Combine weight/alpha values. \n    vec4 weights = vec4(weightA, weightB, weightC, weightD);\n        \n    // Change the weights contrast for less blurry results.\n    weights = smoothContrast(weights, contrast);\n    \n    // Interpolation _____________________________________________________\n    \n    // Color interpolation\n    vec3 color = detailA.color * weights.x +\n                 detailB.color * weights.y +\n                 detailC.color * weights.z +\n                 detailD.color * weights.w;\n\n    // Normal interpolation\n    // While you could do an SLerp, I think it looks the same, so I won't bother.\n    vec3 normal = normalize(detailA.normal * weights.x +\n                            detailB.normal * weights.y +\n                            detailC.normal * weights.z +\n                            detailD.normal * weights.w);\n\n    #ifdef SHOWGRID\n        // Overlaying the edges of the alpha mask\n        vec4 mask = step(abs(weights - 0.1), vec4(LINETHICKNESS));\n        color = max(mask.xyz, color * (1.0 - mask.w));\n    #endif\n\n    // Combine color and normal into a struct\n    return materialVal(color, normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Square UVs, with 0.5 in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x + 0.5; \n\n    // If the mouse was not clicked, animate light\n    vec3 lightDir;\n    float zoom;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomsteps = 10.;\n        zoom = mix(1.0, 0.10, pow(floor(mouse.y*zoomsteps)/zoomsteps,.5));\n    \n        // Mouse controls light direction\n        float angle = mouse.x * 3.14 * 3.;\n        lightDir = normalize(vec3(cos(angle), sin(angle), 1.0));\n    } else {\n        // Animated zoom\n        float zoomTime = iTime * 0.1;\n        zoom = mix(1.0, 0.10, cos(zoomTime) * 0.5 + 0.5);\n    \n        // Time controls light direction\n        float lightTime = iTime * 0.3;\n        lightDir = normalize(vec3(cos(lightTime), sin(lightTime), 1.0));\n    } \n    \n    // Apply zoom on the center\n    uv = (uv - 0.5) * zoom + 0.5;\n\n    // Sample terrain\n    materialVal terrain = biomTexShuffle(iChannel3, uv, GRIDSIZE, CONTRAST, \n        NOISESTRENGTH, NOISESCALE, DETAILSCALE);\n\n    // Simple color for debug view\n    vec3 color = terrain.color;\n    \n    #ifndef SHOWGRID    \n        // Apply lighting to show the normals too\n        color = phongLighting(terrain.color, terrain.normal, vec3(0,0,1), lightDir);\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_____________________GENERIC FUNCTIONS______________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n\treturn vec2(q) * SMALLESTFLOAT;\n}\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction){\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        -direction.x, direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example https://www.desmos.com/calculator/n6gpory8yq\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n// makes bone colormap with polynimal 6\nvec3 bone(float t) {\n    const vec3 c0 = vec3(-0.005007,-0.003054,0.004092);\n    const vec3 c1 = vec3(1.098251,0.964561,0.971829);\n    const vec3 c2 = vec3(-2.688698,-0.537516,2.444353);\n    const vec3 c3 = vec3(12.667310,-0.657473,-8.158684);\n    const vec3 c4 = vec3(-27.183124,8.398806,10.182004);\n    const vec3 c5 = vec3(26.505377,-12.576925,-5.329155);\n    const vec3 c6 = vec3(-9.395265,5.416416,0.883918);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.25;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.5, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 0.25;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float specular = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 36.0);\n    specular *= specularStrength;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n//_____________________________Simplex Noise______________________________\n// Copyright © 2013 Inigo Quilez\n// https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// 4 layer simplex noise range -1 to 1\nfloat simplexNoise(vec2 uv) {    \n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f;\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n// generates 2 vector of simplex noise\nvec2 simplexNoiseVec(vec2 uv) {\n    // sample noise function\n    float noiseX = simplexNoise(uv);    \n    float noiseY = simplexNoise(uv + 691.); // with prime offset\n    \n    // make noise vector\n    return vec2(noiseX, noiseY);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVyRw.jpg", "access": "api", "license": "mit", "functions": [[3301, 3382, 3421, 3421, 3821], [3823, 3945, 4006, 4006, 4385], [4479, 4531, 4655, 4791, 6643], [6645, 6708, 6854, 7137, 9713], [9715, 9715, 9770, 9812, 11212]], "test": "untested"}
{"id": "cdVyWR", "name": "lightcrypt 256byte prototype", "author": "gopher", "description": "256 byte DOS intro prototype for https://www.pouet.net/prod.php?which=88539", "tags": ["256"], "likes": 23, "viewed": 319, "published": 3, "date": "1695980558", "time_retrieved": "2024-07-30T17:31:18.611558", "image_code": "void mainImage(out vec4 O,vec2 c)\n{\n\tfloat time = iTime*.1;\n    vec3 d=vec3(c/iResolution.xy-.5,.75);\n    d.x *= 4./3.;\n    d.x += sin(time)*.25;\n    d.y *= -1.;\n    d.y += cos(time)*.25;\n    \n    vec3 p=vec3(0,0,time);\n    vec3 q;\n    float td = 0.;\n    for(int i=0;i<80;i++)\n    {\n        float nt = min(.4-dot(fract(p+.5)-.5, fract(p+.5)-.5), .25-p.y);\n        td += nt;\n        p+=d*nt;\n        if(i==40)\n        {\n            q=p;\n            \n            p.z -= .01;\n            p.y -= .01;\n            \n            d.x = cos(time);\n            d.y = -.1;\n            d.z = sin(time);\n            \n            td = 0.;\n        }\n    }\n    ivec3 u=ivec3(q*1000.);\n    float i=.5*float((u.x^u.y^u.z)&255)/1000.    \n        + .5* .35* td * step(7.,iTime)\n        + .5* .35* (q.z-time);\n    O=vec4(i);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 805]], "test": "untested"}
{"id": "dsycDz", "name": "Rector's Palace at Night", "author": "dr2", "description": "Motivated by the palace in Dubrovnik (simplified, symmetrized and wall-free); updated visuals (mouseable)", "tags": ["shadow", "light", "architecture"], "likes": 26, "viewed": 254, "published": 3, "date": "1695979939", "time_retrieved": "2024-07-30T17:31:19.598918", "image_code": "// \"Rector's Palace at Night\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Control panel appears when ring (or a hidden control) clicked; panel fades\n  automatically; look around using mouse.\n\n  Sliders control speed (red) and zoom (green).\n  Buttons switch viewer moving/stationary (blue) and night/day (yellow).\n\n  (Update of \"Rector's Palace\")\n\n  No. 84 in \"Architecture\" series\n   \"Pantheon\"                        (Dl2GDt) - earlier listed here\n   \"Roman Disco\"                     (dlXSWn)\n   \"Mriya Over Metropolis\"           (ct2SR1)\n   \"Monorail 2\"                      (msc3zn)\n   \"Mini Metropolis\"                 (msc3W2)\n   \"Truchet Path Journey\"            (mdXyRB)\n   \"Canal Ruins 2\"                   (mdByRm)\n   \"Atlantis 3\"                      (dd2yRG)\n   \"Crystal Canyon\"                  (cs2cDy)\n   \"Ziggurat of Hilbert\"             (mscyWM)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nvec3 HexGrid (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define NLIT_MX 5\n\nvec3 qHit, sunDir, vuPos, dukPos, ltPos[NLIT_MX + 1], ltAx;\nvec2 stCent, dukAzCs, dukElCs;\nfloat dstFar, tCur, outWd, corWd, flrHt, trkLen, vuAz, vuEl, extVu,\n   dukVu, dukScl, refSpRad, ntMode;\nint nFrame, idObj, nLit;\nbool isSh;\nconst int idDnFlr = 1, idUpFlr = 2, idRf = 3, idStr = 4, idStWall = 5, idWall = 6, idPil = 7,\n   idBall = 8, idCen = 9, idLit = 10, idMvLit = 11, idDuk = 12;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (nFrame, 0)\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetBldParms ()\n{\n  outWd = 20.;\n  corWd = 2.;\n  flrHt = 3.;\n  stCent = vec2 (-16., 2.);\n}\n\nfloat DukDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 cs, r;\n  float d, dm, h, s;\n  dm = dMin;\n  p /= dukScl;\n  if (0.9 * dukScl * PrSphDf (p, 1.) < dm) {\n    dm /= dukScl;\n    p.xz = Rot2Cs (p.xz, dukAzCs);\n    p.yz = Rot2Cs (p.yz, dukElCs);\n    p.z = - p.z;\n    cs = sin (0.3 + vec2 (0.5 * pi, 0.));\n    h = 0.5;\n    r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n    s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n    d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n    dm = min (dm, d);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.5, 0.3, 0.6);\n    q.yz = Rot2Cs (q.yz, cs);\n    q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n    q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n    r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n    h = 0.07;\n    s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n    d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dm, 0.05);\n    dm = min (dm, d);\n    d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)), dm, 0.1);\n    dm = min (dm, d);\n    q = p - vec3 (0., 0.65, -0.9);\n    q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n    h = 0.15;\n    r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n    d = PrEllCylDf (q, r, h);\n    q.z -= -0.9 * h;\n    d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 0.5 * h)), dm, 0.01);\n    dm = min (dm, d);\n    q = p;\n    q.x = abs (q.x);\n    d = PrSphDf (q - vec3 (0.26, 0.825, -0.6), 0.125);\n    dm = min (dm, d);\n    dm *= 0.9 * dukScl;\n  }\n  return dm;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 wSz;\n  float dMin, d, a, r, s;\n  dMin = dstFar;\n  q = p;\n  d = PrBoxDf (q, vec3 (outWd + 1., 0.2, outWd + 1.));\n  DMIN (idDnFlr);\n  qq = p;\n  a = (length (qq.xz) > 0.) ? atan (qq.z, - qq.x) : 0.;\n  qq.xz = Rot2D (qq.xz, 2. * pi * (floor (4. * a / (2. * pi) + 0.5) / 4.));\n  q = qq;\n  d = dot (vec2 (qq.y, abs (abs (qq.x) - outWd + corWd)), sin (0.15 * pi + vec2 (0.5 * pi, 0.))) -\n     4. * flrHt + 0.02 * sin (4. * pi * qq.z) - 0.2;\n  d = max (max (d, abs (qq.x + outWd - 2.) - 3.), 4. * flrHt + 0.1 - qq.y);\n  DMINQ (idRf);\n  q.x = abs (q.x) - outWd + corWd;\n  q.y -= 2. * flrHt + 0.15;\n  d = PrBox2Df (q.xy, vec2 (corWd + 0.2, 0.2));\n  DMIN (idUpFlr);\n  q = qq;\n  q.x = abs (abs (q.x) - outWd + corWd) - corWd;\n  q.y -= 2. * flrHt + 0.1;\n  d = PrBox2Df (q.xy, vec2 (0.1, 2. * flrHt));\n  q.yz = mod (q.yz, vec2 (2. * flrHt + 0.2, 2. * corWd)) - vec2 (flrHt + 0.5, corWd);\n  wSz = vec2 (1.7, 1.3);\n  d = SmoothMax (d, - min (min (length (q.yz) - wSz.x, PrBox2Df (vec2 (q.z, q.y + wSz.y), wSz)),\n     PrBoxDf (((qq.x < corWd - outWd) ? vec3 (qq.x + outWd, qq.y - 0.5, abs (qq.z) - 2.) :\n     vec3 (qq.x + outWd - 2. * corWd, q.y + flrHt - 0.1, qq.z + 6.)), vec3 (0.25, 0.5, wSz.x))), 0.01);\n  DMINQ (idWall);\n  if (! isSh) {\n    q.xz = abs (qq.xz);\n    q -= vec3 (outWd - corWd, flrHt - 0.5, 0.5 * outWd);\n    d = max (PrCylDf (q.xzy, 0.2, 0.05), - min (qq.y, 5. * flrHt - qq.y));\n    DMIN (idLit);\n  }\n  q = qq;\n  q.x = abs (q.x + 8.);\n  q -= vec3 (1.6, 0.9, 1.95);\n  d = PrSphDf (q, 0.15);\n  q = qq;\n  q.z = abs (q.z + 6.);\n  q -= vec3 (-15.95, 7.3, 1.6);\n  d = min (d, PrSphDf (q, 0.15));\n  DMIN (idBall);\n  qq -= vec3 (stCent, flrHt + 0.3).xzy;\n  q = qq;\n  q.xz = Rot2D (q.xz, -0.73 * pi);\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = vec2 (26. * a / (2. * pi), r - 8.);\n  q.xy = Rot2D (q.xy, -0.25 * pi);\n  s = mod (q.x, 0.5 * sqrt (2.));\n  d = max (0.5 * max (q.y + abs (s - 0.25 * sqrt (2.)) - 0.25 * sqrt (2.),\n     max (- q.y - 0.1, abs (q.z) - 1.5)), abs (qq.y + 0.2) - (flrHt + 0.2));\n  DMINQ (idStr);\n  d = max (0.5 * max (abs (q.y - 0.3) - 0.4, abs (abs (q.z) - 1.6) - 0.1),\n     max (max (- qq.x, qq.z), - qq.y - (flrHt + 0.2)));\n  q.x = a;\n  DMINQ (idStWall);\n  q = p;\n  q.xz = abs (mod (q.xz + corWd, 2. * corWd) - corWd) - 0.1;\n  q.y -= 2. * flrHt + 0.1;\n  d = max (PrCylDf (q.xzy, 0.07, 2. * flrHt), PrBoxAn2Df (p.xz, vec2 (outWd - 2.), 3.));\n  DMIN (idPil);\n  q = p;\n  q.xz = abs (q.xz) - (outWd - corWd);\n  q.y -= 4. * flrHt + 1.8;\n  d = PrSphDf (q, 0.2);\n  DMIN (idBall);\n  q = p;\n  q.y -= 0.8;\n  d = PrCylAnDf (q.xzy, 2.4, 0.15, 0.7);\n  DMIN (idCen);\n  if (dukVu > 0.) {\n    d = DukDf (p - dukPos, dMin);\n    DMIN (idDuk);\n  }\n  if (! isSh && ntMode > 0.) {\n    for (int k = 0; k < nLit; k ++) {\n      q = p - ltPos[k];\n      d = PrSphDf (q, 0.1);\n      DMIN (idMvLit);\n    }\n  }\n  if (isSh) {\n    q = p;\n    q.y -= refSpRad;\n    d = PrSphDf (q, refSpRad);\n    DMIN (0);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 qHitT;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  qHitT = qHit;\n  isSh = true;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = SmoothMin (sh, smoothstep (0., 0.05 * d, h), 0.1);\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  idObj = idObjT;\n  qHit = qHitT;\n  isSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, inout vec3 vn)\n{\n  vec4 col4;\n  vec3 rg;\n  vec2 vf;\n  float s;\n  bool fxz;\n  vf = vec2 (0.);\n  if (idObj == idWall) {\n    col4 = vec4 (0.9, 0.8, 0.7, 0.1);\n    if (abs (qHit.x) < 0.095) {\n      col4 *= 0.9;\n      vf = vec2 (64., 1.);\n    } else if (abs (vn.y) < 0.01) {\n      rg = ro;\n      rg.y = mod (rg.y, 2. * flrHt + 0.2);\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShGrid ((fxz ? rg.zy : rg.xy), vec2 (2., 4.), 1);\n      col4 *= rg.y;\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idDnFlr) {\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    col4 = vec4 (0.8, 0.75, 0.7, 0.1);\n    if (vn.y > 0.99) {\n      if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n      else vn.yx = Rot2D (vn.yx, rg.x);\n    }\n    if (length (ro.xz) < 2.5) col4.rgb *= vec3 (0., 0.3, 0.5);\n    s = Maxv2 (abs (ro.xz));\n    if (s < outWd - 2. * corWd)\n       col4.rg *= 0.8 + 0.1 * smoothstep (0.3, 0.4, length (fract (ro.xz) - 0.5));\n    else if (s > outWd) col4.rg *= 0.95;\n    else col4.rgb = mix (vec3 (0.5, 0.5, 0.8), col4.rgb,\n       smoothstep (0.05, 0.07, abs (Truch (ro.xz) - 0.5)));\n    col4.rgb *= rg.y;\n    vf = vec2 (64., 0.5);\n  } else if (idObj == idUpFlr) {\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    col4 = vec4 (0.75, 0.65, 0.7, 0.1);\n    if (vn.y > 0.99) {\n      if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n      else vn.yx = Rot2D (vn.yx, rg.x);\n      if (abs (Maxv2 (abs (ro.xz)) - outWd + corWd) < corWd) col4.rgb = mix (vec3 (0.3, 0.7, 0.3),\n         col4.rgb, smoothstep (0.05, 0.07, abs (Truch (2. * ro.xz) - 0.5)));\n    }\n    col4.rgb *= rg.y;\n    vf = vec2 (64., 0.5);\n  } else if (idObj == idRf) {\n    col4 = (vn.y > 0.) ? vec4 (0.8, 0.3, 0., 0.1) : vec4 (0.8, 0.5, 0.4, 0.1);\n    col4 *= 0.6 + 0.4 * smoothstep (0.03, 0.05, abs (fract (2. * qHit.x + 0.5) - 0.5));\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1) * (0.6 + 0.4 *\n       smoothstep (0.03, 0.05, abs (fract (2. * qHit.z + 0.5) - 0.5)));\n    vf = vec2 (64., 0.5);\n  } else if (idObj == idStWall) {\n    rg = ShGrid (qHit.xy - vec2 (0., 0.1), vec2 (20., 5.), 1);\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1) * rg.y;\n    if (abs (vn.y) < 0.01) {\n      if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n      else vn.xz = Rot2D (vn.xz, - rg.x);\n    }\n    vf = vec2 (32., 1.);\n  } else if (idObj == idPil) {\n    s = fract (4. * mod (ro.y, 2. * flrHt + 0.2));\n    col4 = vec4 (0.7, 0.7, 0.8, 0.1) * (0.8 + 0.2 * smoothstep (0.03, 0.05, abs (s)));\n    vn = normalize (vec3 (vn.xz, -0.3 * (1. - smoothstep (0.05, 0.1, abs (s))) * sign (s))).xzy;\n    vf = vec2 (32., 1.);\n  } else if (idObj == idBall) {\n    col4 = vec4 (1., 1., 0.1, 0.3);\n  } else if (idObj == idCen) {\n    rg = ShGrid (vec2 (atan (ro.z, - ro.x) / pi, ro.y + 0.05), vec2 (16., 4.), 1);\n    col4 = vec4 (0.8, 0.9, 0.7, 0.1) * rg.y;\n    if (vn.y < 0.01) {\n      if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n      else vn.xz = Rot2D (vn.xz, - rg.x);\n    }\n    vf = vec2 (32., 1.);\n  } else if (idObj == idLit) {\n    col4 = vec4 (0.9, 0.9, 0.7, -1.);\n  } else if (idObj == idMvLit) {\n    col4 = vec4 (0.9, 0.9, 0.95, -1.);\n  } else if (idObj == idDuk) {\n    s = max (dot (vn, - rd), 0.);\n    col4 = vec4 (0.9 * vec3 (1., 0.9, 0.3) * (0.55 + 0.45 * s) + 0.1 * pow (s, 4.) +\n       4. * pow (max (dot (VaryNf (1024. * ro, vn, 4.), - rd), 0.), 128.), -1.);\n  }\n  if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col4;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, inout vec3 vn)\n{\n  vec3 col, qh;\n  vec2 vf;\n  vn = vec3 (0., 1., 0.);\n  vf = vec2 (0.);\n  if (length (ro.xz) < 50.) {\n    col = vec3 (0.5, 0.5, 0.55);\n    qh = HexGrid (1.5 * ro.xz);\n    vn.yz = Rot2D (vn.yz, 0.5 * max (length (qh.xy) - 0.3, 0.) *\n       (1. - smoothstep (-0.1, -0.05, rd.y)));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vf = vec2 (16., 0.5);\n  } else {\n    col = vec3 (0.4, 0.4, 0.3) * (0.85 + 0.15 * smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz)));\n    vf = vec2 (4., 1.);\n  }\n  vf.y *= 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n  if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd, a;\n  a = atan (rd.z, - rd.x) / (2. * pi) + 0.5;\n  if (rd.y > -0.02 && rd.y < 0.02 * mix (IFbm1 (16. * (a + 1.)), IFbm1 (16. * a), a)) {\n    col = vec3 (0.3, 0.35, 0.45);\n    if (ntMode > 0.) col *= 0.15;\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n    if (ntMode > 0.) col = vec3 (0.1) * col.r + StarPat (rd, 6.);\n  }\n  return col;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      vn = (ro + d * rd) / rad;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstLim)\n{\n  vec3 dirGlow;\n  float dstGlow, brGlow;\n  brGlow = 0.;\n  for (int k = VAR_ZERO; k < nLit; k ++) {\n    dirGlow = ltPos[k] - ro;\n    dstGlow = length (dirGlow);\n    brGlow += smoothstep (-0.1, 0.1, dstLim - dstGlow) *\n       pow (max (dot (rd, dirGlow), 0.) / dstGlow, 2048.) / dstGlow;\n  }\n  return clamp (brGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, ds4;\n  vec3 col, c, vn, roo, rog, ltDir, ltVec;\n  float dstObj, dstSph, dstGrnd, sh, atten;\n  dukScl = 0.3;\n  refSpRad = 2.1;\n  isSh = false;\n  roo = ro;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      ds4 = SphHit (ro - vec3 (0., refSpRad, 0.), rd, refSpRad);\n      dstSph = ds4.x;\n      if (dstSph < min (dstObj, dstFar)) {\n        ro += dstSph * rd;\n        rd = reflect (rd, ds4.yzw);\n        ro += 0.01 * rd;\n      } else break;\n    }\n  }\n  rog = ro;\n  sh = 1.;\n  atten = 1.;\n  dstGrnd = dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n  }\n  if (ntMode > 0.) {\n    ltVec = roo - ro;\n    atten = smoothstep (0.7, 0.85, dot (ltAx, - normalize (ltVec))) / (1. + ((extVu == 0.) ?\n       0.01 : 0.0005) * dot (ltVec, ltVec));\n    ltVec += ltPos[nLit];\n    ltDir = normalize (ltVec);\n  }\n  if (dstObj < dstFar && idObj != idDuk && idObj != idLit || dstGrnd < dstFar || rd.y < 0.)\n     sh = (ntMode == 0.) ? ObjSShadow (ro + 0.01 * vn, sunDir, dstFar) : 1.;\n  if (dstObj < dstFar) {\n    col4 = ObjCol (ro, rd, vn);\n    if (ntMode == 0.) {\n      if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.1 * step (sh, 0.95) * abs (dot (vn, sunDir * normalize (vec3 (-1., 0., -1.)))) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      else col = col4.rgb;\n    } else {\n      if (col4.a >= 0.) {\n        col = atten * (col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n      } else {\n        col = col4.rgb * (0.3 + 0.7 * max (- dot (rd, vn), 0.));\n      }\n    }\n  } else if (rd.y < 0.) {\n    col4.rgb = GrndCol (ro, rd, dstGrnd, vn);\n    if (ntMode == 0.) {\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n      col = mix (col, vec3 (0.3, 0.35, 0.45), pow (1. + rd.y, 16.));\n    } else {\n      col = col4.rgb * atten * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.));\n    }\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (ntMode > 0. && (dstObj < dstFar && col4.a >= 0. || dstGrnd < dstFar && rd.y < 0.)) {\n    c = vec3 (0.);\n    for (int k = VAR_ZERO; k < nLit; k ++) {\n      ltVec = ltPos[k] - ro;\n      atten = 1. / (1. + 0.01 * dot (ltVec, ltVec));\n      if (atten > 0.01) {\n        ltDir = normalize (ltVec);\n        sh = ObjSShadow (ro, ltDir, length (ltVec));\n        c += atten * col4.rgb * sh * max (dot (vn, ltDir), 0.);\n      }\n    }\n    col = mix (col, c * vec3 (1.), smoothstep (-0.05, 0.05, Maxv3 (c) - Maxv3 (col)));\n  }\n  if (ntMode > 0.) col = mix (col, vec3 (1., 1., 0.3), min (2. * GlowCol (rog, rd,\n     min (dstObj, dstFar)), 1.));\n  return clamp (col, 0., 1.);\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec4 parmV)\n{\n  vec4 wgBx[4];\n  vec3 cc[4], col;\n  vec2 ut, ust, c;\n  float vW[2], asp;\n  c = vec2 (1., 0.5);\n  cc[0] = c.xyy;\n  cc[1] = c.yxy;\n  cc[2] = c.yyx;\n  cc[3] = c.xxy;\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < 2; k ++)\n     wgBx[k] = vec4 ((0.41 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n  for (int k = 2; k < 4; k ++)\n     wgBx[k] = vec4 ((0.41 + 0.05 * float (k - 2)) * asp, -0.4, 0.02, 0.02);\n  vW[0] = parmV.x;\n  vW[1] = parmV.y;\n  col = vec3 (0.);\n  for (int k = 0; k < 2; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (Maxv2 (ust) < 0.) {\n      if  (Minv2 (abs (ust)) * canvas.y < 2.) col = 0.3 * cc[k];\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? 0.3 * cc[k] : 0.6 * cc[k];\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (Maxv2 (abs (ut)) < 0.025 && Maxv2 (ut) > 0.02) col = cc[k];\n  }\n  for (int k = 2; k < 4; k ++) {\n    ust = abs (0.5 * uv - wgBx[k].xy) - wgBx[k].zw;\n    if (Maxv2 (ust) < 0.) {\n      col = cc[k];\n      if (Minv2 (abs (ust)) * canvas.y < 2.) col *= 0.6;\n    }\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr, wgBxC, parmV, c4;\n  vec3 ro, rd, col, cw;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, tCurM, cm, dukAz, dukEl;\n  int wgSel;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  dstFar = 120.;\n  SetBldParms ();\n  parmV = Loadv4 (0);\n  zmFac = 1.5 / (1. - 0.8 * parmV.y);\n  extVu = parmV.z;\n  ntMode = parmV.w;\n  stDat = Loadv4 (1);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (2);\n  el = - stDat.x;\n  az = - stDat.y;\n  tCur = stDat.z;\n  tCurM = stDat.w;\n  stDat = Loadv4 (3);\n  vuPos = stDat.xyz;\n  stDat = Loadv4 (4);\n  vuAz = stDat.x;\n  vuEl = stDat.y;\n  nLit = int (stDat.w);\n  stDat = Loadv4 (5);\n  dukPos = stDat.xyz;\n  dukPos.y += 1.2;\n  stDat = Loadv4 (6);\n  dukAz = stDat.x;\n  dukEl = stDat.y;\n  dukAzCs = CosSin (- dukAz);\n  dukElCs = CosSin (- dukEl);\n  dukVu = 1.;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec4 (0.48 * asp, -0.46, 0.022, 0.);\n  if (ntMode == 0.) sunDir = normalize (vec3 (0.7, 2., -1.));\n  if (extVu > 0.) {\n    if (false && (mPtr.z <= 0. || wgSel >= 0)) {\n      az -= 0.1 * tCur;\n      el -= 0.1 * pi * (1. + sin (0.03 * pi * tCur));\n    }\n    el -= 0.1 * pi;\n    el = clamp (el, -0.45 * pi, -0.02 * pi);\n    ro = vec3 (0., 2., -60.);\n    zmFac *= 1.5;\n  } else {\n    az -= vuAz;\n    el -= vuEl + 0.1;\n    el = clamp (el, -0.35 * pi, 0.35 * pi);\n    ro = vuPos;\n    ro.y += flrHt + 0.5;\n  }\n  vuMat = StdVuMat (el, az);\n  if (extVu > 0.) {\n    ro = vuMat * ro;\n    if (ntMode > 0.) ltPos[nLit] = vuMat * vec3 (0., 0., 20.);\n  } else {\n    if (ntMode > 0.) ltPos[nLit] = vec3 (0., 0.5, 0.5);\n  }\n  if (ntMode > 0.) {\n    for (int k = 0; k < nLit; k ++) {\n      stDat = Loadv4 (7 + k);\n      ltPos[k] = stDat.xyz;\n      ltPos[k].y += 2.;\n    }\n  }\n  if (ntMode > 0.) ltAx = vuMat * vec3 (0., 0., 1.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (tCur - tCurM < 7.) {\n    c4 = ShowWg (uv, canvas, parmV);\n    cw = mix (col, c4.rgb, c4.a);\n    cm = 0.2 + 0.8 * smoothstep (6., 7., tCur - tCurM);\n  } else {\n    cw = vec3 (0., 0.7, 0.7);\n    cm = 0.3 + 0.7 * step (2., abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y);\n  }\n  col = mix (cw, col, cm);\n  if (mPtr.z > 0. && wgSel < 0) {\n    if (Maxv2 (abs (uv)) < 0.05 && Minv2 (abs (uv)) < 0.005)\n       col = mix (col, vec3 (0.1, 1., 0.1), 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (sqrt3/2.) - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (mod (p + vec2 (0., 1.), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 10.;\n  for (int j = 0; j < 3; j ++) {\n    f += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / (1.75 * a));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Rector's Palace at Night\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Maxv2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define VAR_ZERO min (nFrame, 0)\n#define N_POS 30\n#define NLIT_MX 5\n\nvec3 bPos[N_POS + 1];\nvec2 stCent;\nfloat outWd, corWd, flrHt, trkLen, vuAz, vuEl;\nint nFrame;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\nvoid SetBldParms ()\n{\n  outWd = 20.;\n  corWd = 2.;\n  flrHt = 3.;\n  stCent = vec2 (-16., 2.);\n}\n\nvoid TrackInit ()\n{\n  float h, b, bo, s1, s2, dc;\n  h = 0.;\n  b = outWd - corWd;\n  bo = outWd - 2. * corWd;\n  s1 = 2.;\n  s2 = 6.;\n  bPos[0] = vec3 (s1, h, - outWd - 8.);\n  bPos[1] = vec3 (s1, h, - b);\n  bPos[2] = vec3 (b, h, - b);\n  bPos[3] = vec3 (b, h, b);\n  bPos[4] = vec3 (- s2, h, b);\n  bPos[5] = vec3 (- s2 - 2., h, s1);\n  h += 2. * flrHt;\n  bPos[6] = vec3 (- bo, h, - s2);\n  bPos[7] = vec3 (- b, h, - s2);\n  bPos[8] = vec3 (- b, h, - b);\n  bPos[9] = vec3 (b, h, - b);\n  bPos[10] = vec3 (b, h, s2);\n  bPos[11] = vec3 (bo, h, s2);\n  h -= 2. * flrHt;\n  bPos[12] = vec3 (s2 + 2., h, - s1);\n  bPos[13] = vec3 (s2, h, - bo + 2.);\n  bPos[14] = vec3 (-7., h, - bo + 2.);\n  bPos[15] = vec3 (-7., h, - s2 - 2.);\n  bPos[16] = vec3 (- s1, h, - s2 - 2.);\n  h += 2. * flrHt;\n  bPos[17] = vec3 (s2, h, - bo);\n  bPos[18] = vec3 (s2, h, - b);\n  bPos[19] = vec3 (- b, h, - b);\n  bPos[20] = vec3 (- b, h, b);\n  bPos[21] = vec3 (- s2, h, b);\n  bPos[22] = vec3 (- s2, h, bo);\n  h -= 2. * flrHt;\n  bPos[23] = vec3 (s1, h, s2 + 2.);\n  bPos[24] = vec3 (b, h, s2);\n  bPos[25] = vec3 (b, h, b);\n  bPos[26] = vec3 (- b, h, b);\n  bPos[27] = vec3 (- b, h, - b);\n  bPos[28] = vec3 (- s1, h, - b);\n  bPos[29] = vec3 (- s1, h, - outWd - 8.);\n  bPos[N_POS] = bPos[0];\n  dc = length (vec2 (0.5 * pi * 8., 2. * flrHt));\n  trkLen = 0.;\n  for (int k = 0; k < N_POS; k ++)\n     trkLen += ((k == 5 || k == 11 || k == 16 || k == 22) ? dc : length (bPos[k + 1] - bPos[k]));\n}\n\nvec3 TrackPos (float tp)\n{\n  vec3 bTrk, p1, p2;\n  float h, dTot, d, dCur, dc, a, t;\n  dc = length (vec2 (0.5 * pi * 8., 2. * flrHt));\n  dCur = mod (tp, trkLen);\n  dTot = 0.;\n  for (int k = VAR_ZERO; k < N_POS; k ++) {\n    d = ((k == 5 || k == 11 || k == 16 || k == 22) ? dc : length (bPos[k + 1] - bPos[k]));\n    if (dCur >=  dTot + d) dTot += d;\n    else {\n      t = (dCur - dTot) / d;\n      if (d == dc) {\n        if (k == 5) {\n          bTrk.xz = stCent;\n          a = -0.5 * t;\n        } else if (k == 11) {\n          bTrk.xz = - stCent;\n          a = 0.5 + 0.5 * t;\n        } else if (k == 16) {\n          bTrk.xz = stCent.yx * vec2 (-1., 1.);\n          a = 0.5 - 0.5 * t;\n        } else if (k == 22) {\n          bTrk.xz = stCent.yx * vec2 (1., -1.);\n          a = 1. + 0.5 * t;\n        }\n        bTrk.y = 2. * flrHt * ((k == 5 || k == 16) ? t : 1. - t);\n        bTrk.xz += 8. * vec2 (cos (pi * a), sin (pi * a));\n      } else bTrk = mix (bPos[k], bPos[k + 1], t);\n      break;\n    }\n  }\n  return bTrk;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[5], mPtr, mPtrP, stDat, parmV;\n  vec3 ltPos, p1, p2, vd, vuPos, dukPos;\n  vec2 iFrag, canvas;\n  float tCur, tCurM, tCurP, vW, asp, el, az, spd, vuTr, vuAz, vuEl, ltTr,\n     dukAz, dukEl, extVu, t;\n  int pxId, wgSel, wgReg, kSel, nLit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 7 + NLIT_MX) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  if (nFrame <= 1) {\n    parmV = vec4 (0.15, 0.25, 0., 1.);\n    mPtrP = mPtr;\n    wgSel = -1;\n    el = 0.;\n    az = 0.;\n    tCurM = tCur;\n    tCurP = tCur;\n    vuTr = 0.;\n    ltTr = 0.;\n    nLit = NLIT_MX;\n  } else {\n    parmV = Loadv4 (0);\n    stDat = Loadv4 (1);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (2);\n    el = stDat.x;\n    az = stDat.y;\n    tCurP = stDat.z;\n    tCurM = stDat.w;\n    stDat = Loadv4 (3);\n    vuTr = stDat.w;\n    stDat = Loadv4 (4);\n    nLit = int (stDat.w);\n    stDat = Loadv4 (5);\n    ltTr = stDat.w;\n  }\n  SetBldParms ();\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++)\n       wgBx[k] = vec4 ((0.41 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n    for (int k = 2; k < 4; k ++)\n       wgBx[k] = vec4 ((0.41 + 0.05 * float (k - 2)) * asp, -0.4, 0.02, 0.02);\n    wgBx[4] = vec4 (0.48 * asp, -0.46, 0.022, 0.);\n    for (int k = 0; k < 4; k ++) {\n      if (Maxv2 (abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw) < 0.) wgReg = k;\n    }\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[4].xy) < wgBx[4].z) wgReg = 4;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    if (wgSel >= 0) tCurM = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  extVu = parmV.z;\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x * sign (extVu - 0.5);\n      el = pi * mPtr.y * sign (extVu - 0.5);\n    } else {\n      az *= 0.95;\n      el *= 0.95;\n    }\n  } else {\n    if (wgSel < 2) {\n      for (int k = 0; k < 2; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n          break;\n        }\n      }\n      if      (kSel == 0) parmV.x = vW;\n      else if (kSel == 1) parmV.y = vW;\n    } else if (mPtrP.z <= 0.) {\n      if      (wgSel == 2) parmV.z = mod (++ parmV.z, 2.);\n      else if (wgSel == 3) parmV.w = mod (++ parmV.w, 2.);\n    }\n  }\n  spd = 10. * parmV.x;\n  vuTr += spd * (tCur - tCurP);\n  ltTr += 3. * (tCur - tCurP);\n  TrackInit ();\n  if (pxId == 3 || pxId == 4) {\n    p1 = TrackPos (vuTr + 2.);\n    p2 = TrackPos (vuTr - 2.);\n    vuPos = 0.5 * (p1 + p2);\n    vd = normalize (p1 - p2);\n    vuAz = atan (- vd.x, vd.z);\n    vuEl = - asin (vd.y);\n  } else if (pxId == 5 || pxId == 6) {\n    p1 = TrackPos (vuTr + 2. + 10.);\n    p2 = TrackPos (vuTr - 2. + 10.);\n    dukPos = 0.5 * (p1 + p2);\n    vd = normalize (p1 - p2);\n    dukAz = atan (- vd.x, vd.z) + 0.2 * sin (0.5 * pi * tCur);\n    dukEl = - asin (vd.y);\n  } else if (pxId >= 7 && pxId < 7 + nLit) {\n    t = (float (pxId - 7 + 1) / float (nLit + 1)) * trkLen;\n    p1 = TrackPos (ltTr + 2. + t);\n    p2 = TrackPos (ltTr - 2. + t);\n    ltPos = 0.5 * (p1 + p2);\n  }\n  if      (pxId == 0) stDat = parmV;\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 2) stDat = vec4 (el, az, tCur, tCurM);\n  else if (pxId == 3) stDat = vec4 (vuPos, vuTr);\n  else if (pxId == 4) stDat = vec4 (vuAz, vuEl, 0., float (nLit));\n  else if (pxId == 5) stDat = vec4 (dukPos, ltTr);\n  else if (pxId == 6) stDat = vec4 (dukAz, dukEl, 0., 0.);\n  else if (pxId >= 7 && pxId < 7 + nLit) stDat = vec4 (ltPos, 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsycDz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[2383, 2383, 2404, 2404, 2477], [2479, 2479, 2513, 2513, 3988], [3990, 3990, 4012, 4012, 6973], [6975, 6975, 7008, 7008, 7192], [7194, 7194, 7215, 7215, 7470], [7472, 7472, 7523, 7523, 7904], [7906, 7906, 7928, 7928, 8076], [8078, 8078, 8118, 8118, 8492], [8494, 8494, 8541, 8541, 12177], [12179, 12179, 12242, 12242, 12857], [12859, 12859, 12894, 12894, 13347], [13349, 13349, 13383, 13383, 14306], [14308, 14308, 14351, 14351, 14606], [14608, 14608, 14656, 14656, 14981], [14983, 14983, 15018, 15018, 17962], [17964, 17964, 18012, 18012, 19234], [19236, 19236, 19292, 19292, 22135], [22137, 22137, 22169, 22169, 22269], [22271, 22271, 22304, 22304, 22393], [22395, 22395, 22439, 22439, 22514], [22516, 22516, 22549, 22549, 22576], [22578, 22578, 22620, 22620, 22671], [22673, 22673, 22726, 22726, 22787], [22789, 22789, 22824, 22824, 22886], [22888, 22888, 22932, 22932, 23007], [23009, 23009, 23033, 23033, 23263], [23265, 23265, 23289, 23289, 23349], [23351, 23351, 23374, 23374, 23506], [23508, 23508, 23530, 23530, 23557], [23559, 23559, 23581, 23581, 23608], [23610, 23610, 23632, 23632, 23670], [23672, 23672, 23717, 23717, 23809], [23811, 23811, 23856, 23856, 23894], [23896, 23896, 23926, 23926, 24039], [24041, 24041, 24072, 24072, 24136], [24138, 24138, 24174, 24174, 24380], [24414, 24414, 24438, 24438, 24513], [24515, 24515, 24539, 24539, 24607], [24609, 24609, 24633, 24633, 24760], [24762, 24762, 24787, 24787, 24933], [24935, 24935, 24960, 24960, 25144], [25146, 25146, 25169, 25169, 25336], [25338, 25338, 25359, 25359, 25514], [25516, 25516, 25545, 25545, 25757], [25759, 25759, 25798, 25798, 26055], [26149, 26149, 26174, 26174, 26297]], "test": "untested"}
{"id": "mdKcRw", "name": "ocean at night", "author": "the_normalgamer", "description": "My first shader", "tags": ["sea", "moon"], "likes": 1, "viewed": 85, "published": 3, "date": "1695925167", "time_retrieved": "2024-07-30T17:31:20.416732", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(0.,0.,0.2);\n    \n    if (fragCoord.y < iResolution.y/3.+10.*sin(fragCoord.x/20.+iTime*0.5)){col += 0.2;}\n    if (fragCoord.y < iResolution.y/3.7+10.*sin(fragCoord.x/20.+iTime*1.0)){col += 0.2;}\n    if (fragCoord.y < iResolution.y/5.6+10.*sin(fragCoord.x/20.+iTime*1.5)){col += 0.2;}\n    float d = length(uv);\n    float m = 0.1/d;\n    col += m-0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 625]], "test": "untested"}
{"id": "DdVyRm", "name": "Thanh", "author": "hmthanh", "description": "sample shader", "tags": ["shader"], "likes": 0, "viewed": 126, "published": 3, "date": "1695915234", "time_retrieved": "2024-07-30T17:31:21.214598", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(uv.x, uv.y, uv.x, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVyRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 219]], "test": "untested"}
{"id": "dd3yDB", "name": "gravity particle field", "author": "01000001", "description": "Each pixel owns a particle and is coloured based on the particle’s relative distance from two points on the screen. See commments in the code.", "tags": ["chaos", "gravity"], "likes": 6, "viewed": 233, "published": 3, "date": "1695911102", "time_retrieved": "2024-07-30T17:31:22.046374", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U/iResolution.xy;\n    O = texture(iChannel0, uv);\n    \n    vec2 pos = O.xy;\n    \n    float a = length(pos-vec2(.25,.5));\n    float b = length(pos-vec2(.75,.5));\n    \n    float x = (a - b)/(a + b); // This nifty formula gives us a colour based on the ratio\n                               // of the distance of the particle from the two attractors located\n                               // at (.25, .5) and (.75,. 5)\n    x = x * .5 + .5;\n    \n    O = vec4(\n        x,\n        x*x,\n        x,\n        1.\n    );\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define DRAG\n//#define actual_gravity_equation\n\nfloat stepSize = 1e-5;\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 uv = U/r;\n    \n    if (iFrame < 1){\n        O.xy = vec2(.5);\n        O.zw = cuv * 8e-3;\n        #ifdef actual_gravity_equation\n            O.zw = cuv * 9e-3;\n        #endif\n\n        // Our particle's initial velocity, set based on its position on screen.\n        // So what we see on screen is particle position over time starting from centre\n        // with initial velocity = position on screen.\n\n    } else {\n        vec4 buff = texture(iChannel0, uv);\n        vec2 pos = buff.xy;\n        vec2 vel = buff.zw;\n        // Read data from buffer\n\n\n        if (length(vel) > stepSize){\n            vec2 dir = pos-vec2(.75, .5);\n            #ifdef actual_gravity_equation\n                float d = 1./dot(dir,dir);\n            #else\n                float d = 1./length(dir);\n            #endif\n            vel += normalize(dir) * -d * stepSize;\n            // Gravity of first attractor\n\n            dir = pos-vec2(0.25, 0.5);\n            #ifdef actual_gravity_equation\n                d = 1./dot(dir,dir);\n            #else\n                d = 1./length(dir);\n            #endif\n            vel += normalize(dir) * -d * stepSize;\n            // Gravity of second attractor\n\n            #ifdef DRAG\n                vel *= 0.99;\n            #endif\n\n\n\n            //boundary bounce\n\n            /*\n            float a = 0.9;\n            if (pos.y < -1.) vel.y = abs(vel.y)*a;\n            if (pos.y > 1.) vel.y = -abs(vel.y)*a;\n            if (pos.x < -1.) vel.x = abs(vel.x)*a;\n            if (pos.x > 1.) vel.x = -abs(vel.x)*a;\n            //*/\n\n\n\n            pos = pos + vel;\n        }\n        \n        O = vec4(pos, vel);\n        // Write the processed data back in\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3yDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 575]], "test": "untested"}
{"id": "csVyz1", "name": "Extended raymarching practice", "author": "Renslay", "description": "Raymarching practice with extended features: colors, texture and displacement mapping, reflective surface, soft shadows, fog effect.\n\nGo to https://github.com/HantosNorbert/Raymarching-in-Jack to see the whole project.", "tags": ["raymarching", "reflection", "displacementmapping"], "likes": 1, "viewed": 176, "published": 3, "date": "1695901946", "time_retrieved": "2024-07-30T17:31:23.162391", "image_code": "// Parameters\nconst int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 128.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.005;\n\nconst float PI = 3.14159265359;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.6, 0.6, 0.835);\nconst vec3 TORUS_COLOR = vec3(1.0, 1.0, 1.0);\n\nconst vec3 AMBIENT = vec3(0.5, 0.5, 0.5);\n\nconst vec3 CAM_LOOK_AT = vec3(0, 0, 0);\nconst vec3 LIGHT_POS = vec3(2., 5, -1.0);\n\n\nvec3 textColor(vec3 p, vec3 normal) {\n    float b = dot(normal, vec3(0.0, 0.0, 1.0));\n    vec2 q = vec2(0.5 - 0.5 * atan(normal.z, normal.x) / PI, -acos(p.y) / PI);\n    return texture(iChannel0, vec2(iTime / 5.0, 0.0) + q).xyz;\n}\n\nstruct Surface {\n    float id;\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\n// https://iquilezles.org/articles/distfunctions/\nSurface sdSphere( vec3 p, float r, vec3 offset ) {\n  p = p - offset;\n  vec3 n = normalize(p);\n  vec3 color = textColor(p, n);\n  \n  // displacement mapping based on the texture\n  // not the best, but the simplest\n  p = p - 0.05*(0.21*color.r + 0.71*color.g + 0.07*color.b);\n  \n  float d = length(p)-r;\n  return Surface(1.0, d, color);\n}\n\nSurface sdTorus( vec3 p, vec2 t, vec3 offset, vec3 col ) {\n  p = p - offset;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float d = length(q)-t.y;\n  return Surface(2.0, d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(0.0, d, col);\n}\n\nSurface unionSDF(Surface obj1, Surface obj2) {\n    if (obj1.sd < obj2.sd) return obj1;\n    return obj2;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(0.5, 1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0), 0.5);\n  Surface flooor = sdFloor(p, floorColor);\n\n  Surface sphere = sdSphere(p, 1., vec3(-1.5*cos(iTime), 0, 1.5*sin(iTime)));\n  Surface torus = sdTorus(p, vec2(1.0, 0.25), vec3(1.5*cos(iTime), 0, -1.5*sin(iTime)), TORUS_COLOR);\n  //Surface sphere = sdSphere(p, 1., vec3(-1.5, 0, 0));\n  //Surface torus = sdTorus(p, vec2(1.0, 0.25), vec3(1.5, 0, 0), BALL_COLOR);\n\n  Surface co = sphere;\n  co = unionSDF(co, torus);\n  co = unionSDF(co, flooor);\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = sdScene(ro + rd*t).sd;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 forward = normalize(cameraPos - lookAtPoint); // camera direction\n\tvec3 right = normalize(cross(vec3(0, 1, 0), forward)); // camera right\n\tvec3 up = normalize(cross(forward, right)); // camera up\n\treturn mat3(right, up, forward);\n}\n\n\nfloat angle(vec3 v1, vec3 v2) {\n    return clamp(dot(v1, v2), 0.0, 1.0);\n}\n\n// Phong reflection model\nfloat lightIntensity(vec3 p, vec3 norm, vec3 camPos, vec3 lightPos) {\n    float kd = 0.9;\n    float ks = 0.7;\n    float id = 0.7;\n    float is = 0.5;\n    float a = 4.0;\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 camDir = normalize(camPos - p);\n    \n    vec3 reflectDir = 2.0 * angle(lightDir, norm) * norm - lightDir;\n    float diffuseLight = kd * angle(lightDir, norm) * id;\n    float specularLight = ks * pow(angle(reflectDir, camDir), a) * is;\n    \n    float color = (diffuseLight + specularLight);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec3 camPos = vec3(4.0*sin(iTime/5.0), 1.5, 4.0*cos(iTime/5.0));\n\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col;\n  \n  mat3 camMatrix = camera(camPos, CAM_LOOK_AT);\n  vec3 rd = camMatrix * normalize(vec3(uv, -1.)); // ray direction\n\n  Surface co = rayMarch(camPos, rd); // closest object\n  \n  float dist = co.sd;\n\n  if (co.sd > MAX_DIST) {\n    col = BACKGROUND_COLOR; // ray didn't hit anything\n  } else {\n    vec3 p = camPos + rd * co.sd; // point on object or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    \n    col = co.col * (0.5*lightIntensity(p, normal, camPos, LIGHT_POS) + AMBIENT);\n\n    vec3 lightDir = normalize(LIGHT_POS - p);\n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n\n    // if torus, we have a reflective surface:\n    // cast a secondary ray\n    if (co.id == 2.0) {\n        rd = reflect(rd, normal);\n        co = rayMarch(newRayOrigin, rd);\n        if (co.sd < MAX_DIST) {\n          col = 0.5*col + 0.5*co.col;\n        }\n        else\n          col = 0.5*col + 0.5*BACKGROUND_COLOR;\n    }\n    \n    // cast shadow ray to the light source\n    // https://iquilezles.org/articles/rmshadows/\n    float shadow = softshadow(newRayOrigin, lightDir, 0.01, 3.0, 0.2);\n    shadow = clamp(0.0, 1.0, shadow + 0.3);\n    col = shadow*col;\n  }\n  \n  // apply fog effect\n  // https://iquilezles.org/articles/fog/\n  float fogAmount = 1.0 - exp( -dist*0.05 );\n  vec3  fogColor  = vec3(0.5,0.6,0.7);\n  col = mix( col, fogColor, fogAmount );\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[429, 429, 466, 466, 658], [757, 807, 857, 857, 1142], [1144, 1144, 1202, 1202, 1319], [1321, 1321, 1356, 1356, 1411], [1413, 1413, 1459, 1459, 1518], [1520, 1520, 1545, 1545, 2079], [2081, 2081, 2117, 2117, 2392], [2394, 2440, 2517, 2517, 2880], [2882, 2929, 2957, 2957, 3169], [3171, 3171, 3218, 3218, 3456], [3459, 3459, 3490, 3490, 3533], [3535, 3561, 3630, 3630, 4098], [4100, 4100, 4156, 4156, 5707]], "test": "untested"}
{"id": "dtSyDz", "name": "Raymarching with image dither", "author": "Renslay", "description": "Raymarching practice for a nand2tetris implementation in Jack. Left side is grayscale, right side is binary. I chose 8x8 ordered dithering for its simplicity.\n\nGo to https://github.com/HantosNorbert/Raymarching-in-Jack to see the whole project.", "tags": ["raymarching"], "likes": 6, "viewed": 334, "published": 3, "date": "1695901713", "time_retrieved": "2024-07-30T17:31:24.040045", "image_code": "// Parameters\nconst int MAX_MARCHING_STEPS = 64;\nconst int MAX_MARCHING_STEPS_SHADOW = 32;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 12.0;\nconst float PRECISION = 0.01;\nconst float EPSILON = 0.005;\n\nconst float BACKGROUND_COLOR = 0.835;\nconst float BALL_COLOR = 0.7;\n\nconst vec3 CAM_LOOK_AT = vec3(0, 0, 0);\nconst vec3 LIGHT_POS = vec3(2., 5, -1.0);\n\n// ordered dithering 8x8 matrix\nfloat ditherMatrix[64] = float[64]( 0., 48., 12., 60.,  3., 51., 15., 63.,\n                                   32., 16., 44., 28., 35., 19., 47., 31.,\n                                    8., 56.,  4., 52., 11., 59.,  7., 55.,\n                                   40., 24., 36., 20., 43., 27., 39., 23.,\n                                    2., 50., 14., 62.,  1., 49., 13., 61.,\n                                   34., 18., 46., 30., 33., 17., 45., 29.,\n                                   10., 58.,  6., 54.,  9., 57.,  5., 53.,\n                                   42., 26., 38., 22., 41., 25., 37., 21.);\n\nstruct Surface {\n    float sd; // signed distance value\n    float col; // color\n};\n\n// https://iquilezles.org/articles/distfunctions/\nSurface sdSphere( vec3 p, float r, vec3 offset, float col ) {\n  p = p - offset;\n  float d = length(p)-r;\n  return Surface(d, col);\n}\n\nSurface sdTorus( vec3 p, vec2 t, vec3 offset, float col ) {\n  p = p - offset;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float d = length(q)-t.y;\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, float col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface unionSDF(Surface obj1, Surface obj2) {\n    if (obj1.sd < obj2.sd) return obj1;\n    return obj2;\n}\n\nSurface sdScene(vec3 p) {\n  float floorColor = 1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0);\n  Surface flooor = sdFloor(p, floorColor);\n\n  Surface sphere = sdSphere(p, 1., vec3(-1.5*cos(iTime), 0, 1.5*sin(iTime)), BALL_COLOR);\n  Surface torus = sdTorus(p, vec2(1.0, 0.25), vec3(1.5*cos(iTime), 0, -1.5*sin(iTime)), BALL_COLOR);\n  //Surface sphere = sdSphere(p, 1., vec3(-1.5, 0, 0), BALL_COLOR);\n  //Surface torus = sdTorus(p, vec2(1.0, 0.25), vec3(1.5, 0, 0), BALL_COLOR);\n\n  Surface co = sphere;\n  co = unionSDF(co, torus);\n  co = unionSDF(co, flooor);\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, int maxMarchingSteps) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < maxMarchingSteps; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 forward = normalize(cameraPos - lookAtPoint); // camera direction\n\tvec3 right = normalize(cross(vec3(0, 1, 0), forward)); // camera right\n\tvec3 up = normalize(cross(forward, right)); // camera up\n\treturn mat3(right, up, forward);\n}\n\n\nfloat angle(vec3 v1, vec3 v2) {\n    return clamp(dot(v1, v2), 0.0, 1.0);\n}\n\n// Phong reflection model\nfloat lightIntensity(vec3 p, vec3 norm, vec3 camPos, vec3 lightPos) {\n    float kd = 0.9;\n    float ks = 0.7;\n    float id = 0.7;\n    float is = 0.5;\n    float a = 4.0;\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 camDir = normalize(camPos - p);\n    \n    vec3 reflectDir = 2.0 * angle(lightDir, norm) * norm - lightDir;\n    float diffuseLight = kd * angle(lightDir, norm) * id;\n    float specularLight = ks * pow(angle(reflectDir, camDir), a) * is;\n    \n    float color = (diffuseLight + specularLight);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec3 camPos = vec3(4.0*sin(iTime/5.0), 1.5, 4.0*cos(iTime/5.0));\n\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  float col = 0.0;\n  \n  mat3 camMatrix = camera(camPos, CAM_LOOK_AT);\n  vec3 rd = camMatrix * normalize(vec3(uv, -1.)); // ray direction\n\n  Surface co = rayMarch(camPos, rd, MAX_MARCHING_STEPS); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = BACKGROUND_COLOR; // ray didn't hit anything\n  } else {\n    vec3 p = camPos + rd * co.sd; // point on object or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    \n    col = co.col * lightIntensity(p, normal, camPos, LIGHT_POS) + 0.2*BACKGROUND_COLOR;\n    \n    vec3 lightDir = normalize(LIGHT_POS - p);\n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    // cast shadow ray to the light source\n    float shadowRayLength = rayMarch(newRayOrigin, lightDir, MAX_MARCHING_STEPS_SHADOW).sd;\n    if (shadowRayLength < length(LIGHT_POS - newRayOrigin))\n        col *= 0.25;\n  }\n  col = clamp(col, 0.0, 1.0);\n  \n  // dithering\n  if (uv.x > -cos(iTime/2.0)) {\n    col = col + ditherMatrix[8 * int(mod(fragCoord.x, 8.0)) + int(mod(fragCoord.y, 8.0))] / 64.0 - 0.5;\n    col = col < 0.5 ? 0.0 : 1.0;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, col, col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1078, 1128, 1189, 1189, 1260], [1262, 1262, 1321, 1321, 1433], [1435, 1435, 1471, 1471, 1521], [1523, 1523, 1569, 1569, 1628], [1630, 1630, 1655, 1655, 2197], [2199, 2199, 2257, 2257, 2530], [2532, 2579, 2607, 2607, 2819], [2821, 2821, 2868, 2868, 3106], [3109, 3109, 3140, 3140, 3183], [3185, 3211, 3280, 3280, 3748], [3750, 3750, 3806, 3806, 5068]], "test": "untested"}
{"id": "DscyW2", "name": "Environment Mapping on Cube", "author": "s_fx", "description": "Testing environment mapping with SDFs.", "tags": ["raymarching", "sdf", "environmentmapping"], "likes": 3, "viewed": 179, "published": 3, "date": "1695888783", "time_retrieved": "2024-07-30T17:31:24.945624", "image_code": "/* (c) 2023 s.fx */\n\nconst int   MAXI = 100;\nconst float MIND = .001;\nconst float MAXD = 100.;\n\nfloat cube( in vec3 p, in vec3 b )\n{\n    float t  = iTime;\n    float st = sin(t);\n    float ct = cos(t);\n    mat3 rot = mat3(\n             ct,     -st,  0.,\n        ct * st, ct * ct, -st,\n        st * st, st * ct,  ct\n    );\n\n    p *= rot;\n    \n    // box sdf by iq:\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 norm( in vec3 p )\n{\n    return normalize(vec3(0.) - p);\n}\n\nfloat dist( in vec3 p )\n{\n    return cube(p, vec3(2.));\n}\n\nvec3 rotateY( in vec3 v )\n{\n    float t  = iTime * .2;\n    float st = sin(t);\n    float ct = cos(t);\n    mat3 rot = mat3(\n         ct, 0., st,\n         0., 1., 0.,\n        -st, 0., ct\n    );\n    \n    return v * rot;\n}\n\nvec3 march( in vec3 rd, in vec3 ro )\n{\n    vec3  col = texture(iChannel0, rd).rgb;\n    vec3  rp  = ro;\n    vec3  re, n;\n    float d;\n    \n    for (int i = 0; i < MAXI; i++)\n    {\n        d   = dist(rp);\n        rp += rd * d;\n        \n        if (d <= MIND)\n        {\n            n   = norm(rp);\n            re  = rd - 2. * dot(rd, n) * n;\n            col = texture(iChannel1, re).rgb;\n            break;\n        }\n        \n        if (d >= MAXD)\n            break;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x     *= iResolution.x / iResolution.y;\n\n    vec3 ro   = rotateY(vec3(0., 0., -5.));\n    vec3 rd   = normalize(rotateY(vec3(uv, 1.)));\n    vec3 col  = march(rd, ro);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 132, 132, 453], [455, 455, 479, 479, 517], [519, 519, 544, 544, 576], [578, 578, 605, 605, 795], [797, 797, 835, 835, 1290], [1292, 1292, 1349, 1349, 1609]], "test": "untested"}
{"id": "cdKczD", "name": "Perlin Windwaker Shader", "author": "homek", "description": "Attempt to animate water using perlin noise, emulating Zelda WindWaker", "tags": ["water"], "likes": 2, "viewed": 116, "published": 3, "date": "1695848905", "time_retrieved": "2024-07-30T17:31:25.920017", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 3-dimensional unsigned integer input vector.\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process third vector element\n    k = x.z; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec3 gradientDirection(uint hash) {\n    switch (int(hash) & 15) { // look at the last four bits to pick a gradient direction\n    case 0:\n        return vec3(1, 1, 0);\n    case 1:\n        return vec3(-1, 1, 0);\n    case 2:\n        return vec3(1, -1, 0);\n    case 3:\n        return vec3(-1, -1, 0);\n    case 4:\n        return vec3(1, 0, 1);\n    case 5:\n        return vec3(-1, 0, 1);\n    case 6:\n        return vec3(1, 0, -1);\n    case 7:\n        return vec3(-1, 0, -1);\n    case 8:\n        return vec3(0, 1, 1);\n    case 9:\n        return vec3(0, -1, 1);\n    case 10:\n        return vec3(0, 1, -1);\n    case 11:\n        return vec3(0, -1, -1);\n    case 12:\n        return vec3(1, 1, 0);\n    case 13:\n        return vec3(-1, 1, 0);\n    case 14:\n        return vec3(0, -1, 1);\n    case 15:\n        return vec3(0, -1, -1);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(\n        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),\n        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),\n        t.z\n    );\n}\n\nvec3 fade(vec3 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n// Vars\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 position = fragCoord / iResolution.xy;\n    position.x *= iResolution.x / iResolution.y;\n\n    float frequency = 4.;\n\tfloat amplitude = 0.07;\n\t\n    \n    vec2 pulse = sin((iTime*.3) - frequency * position);\n    float dist = 2.0 * length(position.y - 0.5);\n    \n    vec2 newCoord = position + amplitude * vec2(0.0, pulse.x); // y-axis only; \n    \n    vec2 interpCoord = mix(newCoord, position, dist);\n\n    uint seed = 0x578437adU; // can be set to something else if you want a different set of random values\n    uint seed2 = 0x575537adU; // can be set to something else if you want a different set of random values\n    // float frequency = 16.0;\n    // float value = perlinNoise(vec3(position, iTime * 0.25) * frequency, seed); // single octave perlin noise\n    float noiseVal = perlinNoise(vec3(interpCoord, iTime * 0.005), 8, 2, 0.5, 2.0, seed); // multiple octaves\n    float noiseVal2 = perlinNoise(vec3(interpCoord, iTime * 0.005), 8, 2, 0.5, 2.0, seed2); // multiple octaves\n    \n    \n    \n    float di = distance(position, vec2(.5));\n    \n        noiseVal = (noiseVal + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n        noiseVal2 = (noiseVal2 + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n\n\n        vec2 uv = fragCoord / iResolution.xy;\n\n\n\n        vec3 outputCol = vec3(0.,.2,.7);\n\n        if(abs(noiseVal2-.5)<.04)\n            outputCol =vec3(0.,.4,.9);\n        if(abs(noiseVal-.5)<.03)\n           outputCol = vec3(1);// hsv2rgb(vec3(1,1,1));\n\n        fragColor = vec4(vec3(outputCol),1.);\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [304, 304, 334, 334, 604], [739, 739, 769, 769, 1299], [1302, 1302, 1337, 1337, 2128], [2130, 2130, 2269, 2269, 2446], [2448, 2448, 2467, 2495, 2548], [2550, 2550, 2595, 2595, 3790], [3792, 3792, 3906, 3906, 4344], [4346, 4354, 4409, 4409, 5959]], "test": "untested"}
{"id": "msyczD", "name": "RGB from/to GdRdB color space", "author": "BeRo", "description": "Matrix-based RGB <=> GdRdB color space conversion (e.g. useful for Chrominance Compression at spherical-harmonics-based Global Illumination solutions, see http://jcgt.org/published/0003/04/06/paper.pdf and http://jcgt.org/published/0005/04/02/paper.pdf )", "tags": ["rgb", "ycocg"], "likes": 0, "viewed": 123, "published": 3, "date": "1695840722", "time_retrieved": "2024-07-30T17:31:26.938295", "image_code": "\n// Matrix-based RGB from/to GdRdB color space conversion\n\n// Copyright (C) 2023 by Benjamin 'BeRo' Rosseaux\n\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n\n// http://creativecommons.org/publicdomain/zero/1.0/\n\n// It's e.g. useful for Chrominance Compression at spherical-harmonics-based and spherical-gaussians-based\n// Global Illumination solutions, see http://jcgt.org/published/0003/04/06/paper.pdf and\n// http://jcgt.org/published/0005/04/02/paper.pdf just with GdRdB instead YCoCg \n\nconst mat3 RGBToG_DeltaR_DeltaBMatrix = mat3(0.0, 1.0, 0.0, 1.0, -1.0,-1.0, 0.0, 0.0, 1.0);\n\nconst mat3 G_DeltaR_DeltaBToRGBMatrix = mat3(1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\nvec3 globalIlluminationConvertRGBToGdRdB(vec3 c){\n  return RGBToG_DeltaR_DeltaBMatrix * c; // vec3(c.y, c.x - c.y, c.z - c.y);\n}\n\nvec3 globalIlluminationConvertGdRdBToRGB(vec3 c){\n  return G_DeltaR_DeltaBToRGBMatrix * c; // vec3(c.y + c.x, c.x, c.z - c.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).xyz;\n    vec3 GdRdB = globalIlluminationConvertRGBToGdRdB(c);\n    vec3 RGB = globalIlluminationConvertGdRdBToRGB(GdRdB);\n\tfragColor = vec4(mix(mix(c, GdRdB, step(0.3333, uv.x) * ((sin(iTime * 6.28318 * 0.25) * 0.5) + 0.5)), RGB, step(0.6666, uv.x)), 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyczD.jpg", "access": "api", "license": "public-domain", "functions": [[745, 745, 794, 794, 873], [875, 875, 924, 924, 1003], [1005, 1005, 1062, 1062, 1398]], "test": "untested"}
{"id": "msGcRW", "name": "pathfinders", "author": "01000001", "description": "Turn left to avoid lines. Very rarely might turn right. That's it.\n\n If multiple converge to a point, they end up annihilating each other, allowing new behaviours to emerge. Eventually, only one line will be left.\n\nOthers in the series:\ndsVyz1\nDsGyzW", "tags": ["maze"], "likes": 11, "viewed": 223, "published": 3, "date": "1695831828", "time_retrieved": "2024-07-30T17:31:27.931639", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    O = texture(iChannel0, (U + vec2(.5))/iResolution.xy)*2.;\n    // Cheap Blur\n\n    O = vec4(\n        O.z,\n        O.z*O.z,\n        sqrt(O.z),\n        1.\n    );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.14159;\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot(float t){\n    return mat2(\n        cos(t), sin(t),\n        -sin(t), cos(t)\n    );\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\nvec3 h = hash(uvec3(U, iDate.z));\n\nif (iFrame < 20){\n    O = vec4(0);\n    if (h.x < 3e-2){\n        O.xy = round(vec2(1, 0)*rot( floor(h.y*8.)/8. * 2.*pi));\n        O.z = 1.;\n    }\n} else {\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n\n    O = texture(iChannel0, U/r);\n    \n    int dir = 0;\n    vec2 d;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            vec4 n = texture(iChannel0, (U + vec2(x, y))/r);\n            if (n.xy == -vec2(x,y)){\n                dir += 1;\n                if (n.xy != vec2(0)) d = n.xy;\n            }\n        }\n    }\n    \n    \n    if (O.z > 0.){\n        O.xy *= 0.;\n        O.z *= .99;\n        // Processing trail\n    }\n    \n    if (dir == 2){\n        // We're setting the next particle.\n        vec4 n = texelFetch(iChannel0, ivec2(U + d), 0);\n\n        if (n.z > 1e-2) d = round(d*rot(pi/(h.x<1e-3?4.:-4.)));\n        \n    \n        O.xy = d;\n        O.z = 1.;\n    } \n        \n    // Check if a pixel is pointing to me and it is the only neighbour. \n    // If yes, then assign random cardinal direction. \n    // If too many neighbours, set to unchanging.\n    // \n}}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 201]], "test": "untested"}
{"id": "DsGyzW", "name": "circuits", "author": "01000001", "description": "They just turn randomly when they hit a line. NO PARTICLES!\n\nOthers in the series:\nmsGcRW\ndsVyz1", "tags": ["maze"], "likes": 24, "viewed": 522, "published": 3, "date": "1695830897", "time_retrieved": "2024-07-30T17:31:29.222189", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    O = texture(iChannel0, (U + vec2(.5))/iResolution.xy);\n    // Cheap blur\n\n    O = vec4(\n        O.z*O.z,\n        sqrt(O.z),\n        O.z,\n        1.\n    );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.14159;\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot(float t){\n    return mat2(\n        cos(t), sin(t),\n        -sin(t), cos(t)\n    );\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\nvec3 h = hash(uvec3(U, iDate.z));\n\nif (iFrame < 20){\n    O = vec4(0);\n    if (h.x < 3e-4){\n        O.xy = round(vec2(1, 0)*rot( floor(h.y*8.)/8. * 2.*pi));\n        O.z = 1.;\n    }\n} else {\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n\n    O = texelFetch(iChannel0, ivec2(U), 0);\n    \n    mat3 adj = mat3(0);\n    int sum = 0;\n    int dir = 0;\n    vec2 d;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            vec4 n = texture(iChannel0, (vec2(U) + vec2(x, y))/r);\n            adj[x][y] = n.x;\n            sum += int(n.x);\n            if (n.xy == -vec2(x,y)){\n                dir += 1;\n                if (n.xy != vec2(0)) d = n.xy;\n            }\n        }\n    }\n    \n    \n    if (O.z > 0.){\n        O.xy *= 0.;\n        O.z *= .99;\n    }\n    \n    if (dir == 2){\n        // We're setting the next particle.\n        if (O.z > .1) d = round(d*rot(pi/(h.x<.5?4.:-4.)));\n        \n    \n        O.xy = d;\n        vec2 l = d;\n        vec4 n = texture(iChannel0, U + d);\n        O.z = 1.;\n    } \n        \n    // Check if a pixel is pointing to me and it is the only neighbour. \n}}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 198]], "test": "untested"}
{"id": "cdyczD", "name": "chebechev voronoi, as F(t)", "author": "18smith111", "description": "taken shadergraph code from unity documentation and translated it into GLSL, then added a manhattan distance function to replace the original euclidian distance being used.", "tags": ["voronoi", "manhattan"], "likes": 0, "viewed": 155, "published": 3, "date": "1695829687", "time_retrieved": "2024-07-30T17:31:30.133751", "image_code": "float chebyshevDistance(vec2 a, vec2 b) {\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nvec2 unity_voronoi_noise_randomVector(vec2 UV, float offset)\n{\n    mat2 m = mat2(15.27, 47.63, 99.41, 89.98);\n    UV = fract(sin(UV*m) * 46839.32);\n    return vec2(sin(UV.y + offset) * 0.5 + 0.5, cos(UV.x * offset) * 0.5 + 0.5);\n}\nfloat voronoi(vec2 p,float density,float angle)\n{ \n    float AngleOffset = angle;\n    float CellDensity = density;\n\n    vec2 g = floor(p * CellDensity);\n    vec2 f = fract(p * CellDensity);\n    \n    vec3 res = vec3(8.0, 0.0, 0.0);\n\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 lattice = vec2(x, y);\n            vec2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);\n            float d = chebyshevDistance(lattice + offset, f);\n            if(d < res.x)\n            {\n                res = vec3(d, offset.x, offset.y);\n            }\n        }\n    }\n\n return res.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 UV = fragCoord / iResolution.xy;\n    float AngleOffset = 5.0*iTime+10.0;\n    float CellDensity = 2.0*iTime+10.0;\n\n    float f = voronoi(UV,AngleOffset,CellDensity);\n\n    // Visualize the f vector\n    fragColor = vec4(f, f,f, 1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdyczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 91], [93, 93, 155, 155, 323], [324, 324, 373, 373, 967], [969, 969, 1024, 1024, 1268]], "test": "untested"}
{"id": "DllBzX", "name": "lights_carousel", "author": "bronnie", "description": "An effort to learn different functions in GLSL. Objective: Find a way to render more than 10 colors for circles without another for loop.\n\n3D camera and original Boheh effect by Martijn Steinrucken aka BigWings : https://www.shadertoy.com/view/MdfBRX\n", "tags": ["3d", "bokeh"], "likes": 1, "viewed": 140, "published": 3, "date": "1695828273", "time_retrieved": "2024-07-30T17:31:31.045318", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\n\nfloat rand(float co1, float co2){\n    return fract(sin(dot(vec2(co1,co2), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//float rr(float r){\n//    return rand(0., r);\n//}\n\nstruct ray {\n    vec3 o, d;\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n    ray a;\n    a.o = camPos;\n\n    // r and u of pixel on display plane\n    vec3 f = normalize(lookAt - camPos);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    // ray eye -> pixel on plane\n    vec3 c = a.o + zoom*f;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    a.d = normalize(i - a.o);\n    \n    return a;\n}\n\n// find closest point on ray to another point outside ray\nvec3 ClosestPoint(ray r, vec3 p) {\n    return r.o + max(0., dot(p - r.o, r.d)) * r.d;\n}\n\n// distance from ray to point\nfloat DistRay(ray r, vec3 p) {\n    return length(p - ClosestPoint(r, p));\n}\n\nvec3 Bokeh(ray r, vec3 p, float size, float blur, vec3 col) {\n    float d = DistRay(r, p);\n    \n    float c = S(size, size*(1.-blur), d);\n    c *= mix(.6, 1., S(size*.8, size, d)); // mix applies operation mainly on size>.7\n    \n    col *= c;\n\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(0., .2, 0.);\n    //vec3 camPos = vec3(.5 + 2*sin(iTime) ,1.5, .5 + 2*cos(iTime));\n    vec3 lookAt = vec3(.0, .2, 1.);\n    float zoom = 1.;\n    \n    ray r = GetRay(uv, camPos, lookAt, zoom);\n    \n    // draw things\n    float t = iTime*.1;\n    float s = 1./10.;\n    vec3 m = vec3(.0);   // sum up to frame\n    \n    for(float i = .1; i<1.1; i+=s) {\n        float ti = fract(t+i);\n        //float ti = t+i;\n        \n        // loading circle:\n        //vec3 p = vec3(2.*sin(6.3*i), 2.*cos(6.3*i), 20.-100.*ti*exp(-ti*6.));\n        \n        // accelerating\n        vec3 p = vec3(  sin(6.3*i)*.1*exp(3.*ti), \n                        cos(6.3*i)*.1*exp(3.*ti), \n                        (60.)/exp(ti*5.));\n        \n        //orange col: vec3(1.0, .7, .25))\n        //m += Bokeh(r, p, .6, .1, vec3(1.0, .7, .25));\n        \n        m += Bokeh(r, p, .6, .1, vec3(rand(2.,8.*i), rand(i,2.*i), rand(2.*i,1.*i))); \n        m *= 1.02;\n    }\n    \n    \n    \n    //fragColor = vec4(c);\n    fragColor = vec4(m, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 71, 71, 152], [238, 238, 297, 297, 642], [644, 702, 736, 736, 789], [791, 821, 851, 851, 896], [898, 898, 959, 959, 1159], [1162, 1162, 1217, 1217, 2345]], "test": "untested"}
{"id": "dsVyz1", "name": "random walkers", "author": "01000001", "description": "No voronoi tracking needed, just reading neighbour directions. They annihilate each other on collision :P\n\nOthers in the series:\nDsGyzW\nmsGcRW", "tags": ["maze"], "likes": 12, "viewed": 228, "published": 3, "date": "1695825676", "time_retrieved": "2024-07-30T17:31:31.800295", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    O = texture(iChannel0, U/iResolution.xy);\n\n    O = vec4(\n        sqrt(O.z),\n        O.z,\n        O.z*O.z,\n        1.\n    );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.14159;\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot(float t){\n    return mat2(\n        cos(t), sin(t),\n        -sin(t), cos(t)\n    );\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\nif (iFrame < 20){\n    O = vec4(0);\n    if (hash(uvec3(U, iDate.z)).x < 1e-2){\n        O.xy = vec2(1, 0);\n        O.z = 1.;\n    }\n} else {\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n\n    O = texelFetch(iChannel0, ivec2(U), 0);\n    \n    mat3 adj = mat3(0);\n    int sum = 0;\n    int dir = 0;\n    vec2 d;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            vec4 n = texture(iChannel0, (vec2(U) + vec2(x, y))/r);\n            adj[x][y] = n.x;\n            sum += int(n.x);\n            if (n.xy == -vec2(x,y)){\n                dir += 1;\n                if (n.xy != vec2(0)) d = n.xy;\n            }\n        }\n    }\n    \n    \n    if (O.z > 0.){\n        O.xy *= 0.;\n        O.z *= .99;\n    }\n    \n    if (dir == 2){\n        vec3 h = hash(uvec3(U, iFrame));\n        O.xy = mix(\n                vec2(1, 0)*rot( floor(h.x*8.)/8. * 2.*pi),\n            d, sin(float(iFrame)/30.) * .1 + .5);\n            \n        if (abs(O.x) > abs(O.y)){\n            O.x = O.x>0.?1.:-1.;\n            O.y = round(O.y);\n        } else {\n            O.y = O.y>0.?1.:-1.;\n            O.x = round(O.x);\n        }\n        \n        O.z = 1.;\n    } \n        \n    // Check if a pixel is pointing to me and it is the only neighbour. \n    // If yes, then assign random cardinal direction. \n    // If too many neighbours, set to unchanging.\n    // \n}}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 167]], "test": "untested"}
{"id": "mstyzl", "name": "Distorsi H767", "author": "zhonkvision", "description": "The name \"Harmonic Distortions\" gets to the heart of the code, in which audio harmonics and fractal distortions work together to make a world that looks both harmonious and messed up.", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 1, "viewed": 230, "published": 3, "date": "1695824926", "time_retrieved": "2024-07-30T17:31:32.640050", "image_code": "// original code by shadertoyjiang\n// edited by Zhonk Vision\n// Simplex 2D noise function\nvec3 permute(vec3 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\n// Hash function\nfloat s(vec2 v) {\n    const vec4 C = vec4(0.511324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(8.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// Rotation function with audio interaction\nvec2 rotate(vec2 p, float a, float audioAmplitude) {\n    float c = cos(a + audioAmplitude * 0.1); // Adjust the multiplier as needed\n    float s = sin(a + audioAmplitude * 0.1); // Adjust the multiplier as needed\n    return p * mat2(c, s, -s, c);\n}\n\n\n// Fractal shape function\nfloat fractalShape(vec2 u, float t, float audioAmplitude, float rotationSpeed) {\n    float n = sin(u.x) * cos(u.y);\n    float b;\n    \n    u = abs(u * 2.0);\n    b = u.x;\n    \n    vec2 a = vec2(2.0 - u);\n    \n    float param1 = 0.25 + audioAmplitude * 0.9; // Adjust the multiplier as needed\n    float param2 = 0.62 + audioAmplitude * 0.9; // Adjust the multiplier as needed\n    \n    for (int i = 0; i < 15; i++) {\n        a += u + cos(length(u));\n        u.y += sin(a.x - b - 0.5 * t) * param1;\n        u.x += sin(a.y + t) * param2;\n        u -= (u.x + u.y) - n;\n        a.x += u.x;\n    }\n    \n    return length(u) * 0.1;\n}\n\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    vec2 R = iResolution.xy;\n    vec2 u = (fragCoord * 2.0 - R) / R.y * 2.0 - vec2(0.0, 1.3);\n    u = u.yx;\n    \n    float t = 1.93 + iTime * 0.5;\n    \n    // Get the audio amplitude from the input texture\n    float audioAmplitude = texture(iChannel0, vec2(0.1)).r;\n    \n    // Calculate the fractal shape value\n    float fractalValue = fractalShape(u, t, audioAmplitude, 0.5);\n    \n    // Calculate the rotation angle based on the audio amplitude for medium frequency\n    float rotationAngle = audioAmplitude * 0.5; // Adjust the multiplier as needed\n    \n    // Apply rotation to the point\n    u = rotate(u, rotationAngle, audioAmplitude);\n    \n    // Define parameters to control color change with audio interaction\n    vec3 lowFrequencyColor = vec3(0.2, 0.0, 1.0); // Purple color for low frequency\n    vec3 highFrequencyColor = vec3(1.0, 0.2, 0.8); // Pink color for high frequency\n    \n    // Calculate the color gradient based on the audio amplitude\n    vec3 color = mix(lowFrequencyColor, highFrequencyColor, audioAmplitude);\n    \n    // Mix color gradient with black based on the fractal value\n    vec3 finalColor = mix(vec3(0.0), color, fractalValue);\n    \n    O = vec4(finalColor, 1.0);\n}\n\n\n\n\n\n\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 90, 112, 112, 161], [163, 180, 197, 197, 1037], [1039, 1083, 1135, 1135, 1331], [1334, 1360, 1440, 1440, 1982], [1984, 1984, 2031, 2031, 3231]], "test": "untested"}
{"id": "msGyz1", "name": "Isohedron", "author": "wyatt", "description": "isohedron", "tags": ["isohedron"], "likes": 35, "viewed": 730, "published": 3, "date": "1695785072", "time_retrieved": "2024-07-30T17:31:33.533661", "image_code": "#define AA 0.\nfloat scene (vec3 p, vec3 d, out vec3 no, int j, vec3 m, mat3 o) {\n    float x = 1e9;\n    for (int i = 0; i < 20; i++) {\n        vec3 a = verts[tris[i][0]]*(1.-W)*o+m;\n        vec3 b = verts[tris[i][1]]*(1.-W)*o+m;\n        vec3 c = verts[tris[i][2]]*(1.-W)*o+m;\n        vec3 n = normalize(cross(b-a,c-a));\n        vec2 y;\n        y.x = iTriangle(p,d,a+W*n,b+W*n,c+W*n);\n        if (y.x > 0. && y.x < x) {\n            x = y.x;\n            no = n;\n        }\n        y = iSegment(p,d,a,b,W);\n        if (y[j] > 0. && y[j] < x) {\n            vec3 q = p+d*y[j];\n            if (dot(q-a,n)>0.&&dot(q-m,normalize(cross(a-m,b-m)))>0.&&dot(q-m,normalize(cross(a+W*n-m,b+W*n-m)))<0.) {\n                x = y[j];\n                no = normal_segment(q,a,b);\n            }\n                \n        }\n        y = iSegment(p,d,b,c,W);\n        if (y[j] > 0. && y[j] < x) {\n            vec3 q = p+d*y[j];\n            if (dot(q-b,n)>0.&&dot(q-m,normalize(cross(b-m,c-m)))>0.&&dot(q-m,normalize(cross(b+W*n-m,c+W*n-m)))<0.) {\n                x = y[j];\n                no = normal_segment(q,b,c);\n            }\n                \n        }\n        y = iSegment(p,d,c,a,W);\n        if (y[j] > 0. && y[j] < x) {\n            vec3 q = p+d*y[j];\n            if (dot(q-c,n)>0.&&dot(q-m,normalize(cross(c-m,a-m)))>0.&&dot(q-m,normalize(cross(c+W*n-m,a+W*n-m)))<0.) {\n                x = y[j];\n                no = normal_segment(q,c,a);\n            }\n                \n        }\n        \n        y = iSphere(p,d,a,W);\n        if (y[j] > 0. && y[j] < x) {\n            vec3 q = p+d*y[j];\n            if (dot(q-a,b-a)<0.&&dot(q-a,c-a)<0.&&dot(q-m,normalize(cross(a-m,b-m)))>0.&&dot(q-m,normalize(cross(c-m,a-m)))>0.) {\n                x = y[j];\n                no = normalize(q-a);\n            } \n        }\n        y = iSphere(p,d,b,W);\n        if (y[j] > 0. && y[j] < x) {\n            vec3 q = p+d*y[j];\n            if (dot(q-b,c-b)<0.&&dot(q-b,a-b)<0.&&dot(q-m,normalize(cross(b-m,c-m)))>0.&&dot(q-m,normalize(cross(a-m,b-m)))>0.) {\n                x = y[j];\n                no = normalize(q-b);\n            } \n        }\n        y = iSphere(p,d,c,W);\n        if (y[j] > 0. && y[j] < x) {\n            vec3 q = p+d*y[j];\n            if (dot(q-c,a-c)<0.&&dot(q-c,b-c)<0.&&dot(q-m,normalize(cross(c-m,a-m)))>0.&&dot(q-m,normalize(cross(b-m,c-m)))>0.) {\n                x = y[j];\n                no = normalize(q-c);\n            } \n        }\n    }\n    no *= -(float(j)*2.-1.);\n    return x;\n}\n/*float map (vec3 p) {\n    float d = length(p)-1.-W;\n    for (int i = 0; i < 20; i++) {\n        vec3 a = verts[tris[i][0]];\n        vec3 b = verts[tris[i][1]];\n        vec3 c = verts[tris[i][2]];\n        vec3 m = 1./3.*(a+b+c);\n        vec3 no = normalize(cross(b-a,c-a));\n        m += W*no;\n        d = max(d,dot(p-m,no));\n    }\n    return d;\n\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-4,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n    ));\n}*/\nvec4 background(vec3 p,vec3 d) {\n    float x = iPlane(p-vec3(0,-1,0),d,vec3(0,1,0));\n    vec3 q = p+d*x;\n    \n    if (x < 0.) {\n        float x = iPlane(p-vec3(0,1,0),d,vec3(0,-1,0));\n        vec3 q = p+d*x;\n        vec2 u = abs(sin(vec2(5,10)*q.xz));\n        float s = min(u.x,u.y);\n        return vec4(2)*smoothstep(0.1,0.2,s)*exp(-.2*x);\n    }\n    \n    vec2 u = abs(sin(vec2(5,10)*q.xz));\n    float s = min(u.x,u.y);\n    return vec4(3)*smoothstep(.1+.03*x,0.,s)*exp(-.3*x);\n}\nvec4 scene (vec3 p, vec3 d, float x, vec3 n, float f, vec3 m, mat3 o) {\n    vec4 Q = vec4(0);\n    d = refract(d,n,eta(f));\n    vec4 c = col(f);\n    for (float i = 0.; i < 2.; i++) {\n        c.xyz *= .9-.4*n;\n        p = p+d*x;\n        p += .01*d;\n        x = scene(p,d,n,1,m,o);\n        if (x > 1e5) {\n            Q += c*background(p,d);\n            break;\n        }\n        d = refract(d,n,eta(f));\n    }\n    return Q;\n}\nMain {\n    vec3 m = texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    mat3 o = mat3(\n        texelFetch(iChannel0,ivec2(2,0),0).xyz,\n        texelFetch(iChannel0,ivec2(3,0),0).xyz,\n        texelFetch(iChannel0,ivec2(4,0),0).xyz);\n\n   \n        Q = vec4(0);\n      \n      for (float x = -AA; x <= AA; x++)\n      for (float y = -AA; y <= AA; y++) {\n        vec3 p = vec3(m.x,0,-2.3+m.z);\n        vec3 d = normalize(vec3(2.*(U-.5*R+.5/(AA==0.?1.:AA)*vec2(x,y))/R.y,1));\n        float t = -.2;\n        d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        \n\n        vec3 n;\n        float x = scene(p,d,n,0,m,o);\n        if (x < 1e7) {\n            Q += .3*background(p,reflect(d,n));\n            for (float f = 0.; f < 1.; f+=.33) \n                Q += scene(p,d,x,n,f,m,o);\n\n        } else {\n            Q += background(p,d);\n            float x = iPlane(p-vec3(0,-1,0),d,vec3(0,1,0));\n            if (x > 0.) {\n                p += d*x;\n                d = reflect(d,vec3(0,1,0));\n                p += .001*d;\n                x = scene(p,d,n,0,m,o);\n                if (x < 1e7) {\n                    Q += .2*background(p,reflect(d,n));\n                    for (float f = 0.; f < 1.; f+=.5) \n                        Q += .1*scene(p,d,x,n,f,m,o);\n                } else {\n                    Q += .1*background(p,reflect(d,n));\n                }\n            } \n        }\n    }\n    Q /= (AA*2.+1.)*(AA*2.+1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n#define W (.1)\n\n#define eta(f) (.8-.02*(f))\n//(.7-.02*f)\n#define col(f)  max(sin(-2.+3.1*(f)+vec4(1,2,3,4)),0.)\n//sin(-2.+3.2*(f-380.)/300.+vec4(1,2,3,4))\n\n#define phi 1.618033988749895\n#define rho 0.5257311121191336\n#define tau 0.85065080835204\n\n\n#define verts vec3[12] (\\\n    vec3(tau,rho,0), \\\n    vec3(-tau,rho,0), \\\n    vec3(tau,-rho,0), \\\n    vec3(-tau,-rho,0), \\\n    vec3(rho,0,tau), \\\n    vec3(rho,0,-tau), \\\n    vec3(-rho,0,tau), \\\n    vec3(-rho,0,-tau), \\\n    vec3(0,tau,rho), \\\n    vec3(0,-tau,rho), \\\n    vec3(0,tau,-rho), \\\n    vec3(0,-tau,-rho)) \n\n#define tris ivec3[20] (\\\n    ivec3(0,8,4), \\\n    ivec3(0,5,10), \\\n    ivec3(2,4,9),  \\\n    ivec3(2,11,5), \\\n    ivec3(1,6,8),  \\\n    ivec3(1,10,7), \\\n    ivec3(3,9,6),  \\\n    ivec3(3,7,11), \\\n    ivec3(0,10,8), \\\n    ivec3(1,8,10), \\\n    ivec3(11,2,9), \\\n    ivec3(9,3,11), \\\n    ivec3(4,2,0),  \\\n    ivec3(5,0,2),  \\\n    ivec3(6,1,3),  \\\n    ivec3(7,3,1),  \\\n    ivec3(8,6,4),  \\\n    ivec3(9,4,6),  \\\n    ivec3(10,5,7), \\\n    ivec3(11,7,5))\n   \nmat3 matrix (vec3 r) { \n   if (length(r)==0.) return mat3(1);\n   float a = length(r);\n   vec3 o = normalize(r);\n   float c = cos(a), t = 1.-c;\n   float s = sin(a);\n   return mat3(\n       t*o.x*o.x+c,t*o.x*o.y-o.z*s,t*o.x*o.z+o.y*s,\n       t*o.x*o.y+o.z*s,t*o.y*o.y+c,t*o.y*o.z-o.x*s,\n       t*o.x*o.z-o.y*s,t*o.y*o.z+o.x*s,t*o.z*o.z+c\n   \n   );\n}\n    \nvec2 iSphere (vec3 p, vec3 d, vec3 m, float r) {\n\n    p -= m;\n    \n    float b = 2.*dot(p,d);\n    float c = dot(p,p)-r*r;\n    float s = (b*b-4.*c);\n    if (s < 0.) return vec2(1e9);\n    else return vec2(.5*(-b-sqrt(s)),.5*(-b+sqrt(s)));\n\n}\nvec3 normal_segment (vec3 q, vec3 a, vec3 b) {\n    return normalize(q - a - (b-a)*clamp(dot(q-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec2 iSegment (vec3 p, vec3 d, vec3 a, vec3 b, float r) {    \n    vec3 q = p-a;\n    vec3 u = b-a;\n    float du = dot(d,u);\n    float uu = dot(u,u);\n    float qu = dot(q,u);\n    float dq = dot(d,q);\n    float qq = dot(q,q);\n    float a_ = 1. - du*du/uu;\n    float b_ = 2.*(dq - qu*du/uu);\n    float c_ = qq - qu*qu/uu - r*r;\n    float s = b_*b_-4.*a_*c_;\n    if (s < 0.) return vec2(1e9);\n    vec2 i = vec2(\n        (-b_-sqrt(s))/(2.*a_),\n        (-b_+sqrt(s))/(2.*a_));\n    float x = dot(p+d*i.x-a,u)/uu;\n    if (x < 0. || x > 1.) i.x = 1e9;\n    x = dot(p+d*i.y-a,u)/uu;\n    if (x < 0. || x > 1.) i.y = 1e9;\n    return i;\n}\nfloat iPlane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\nfloat iTriangle (vec3 p, vec3 d, vec3 a, vec3 b, vec3 c) {\n    vec3 n = normalize(cross(b-a,c-a));\n    float i = -dot(p-a,n)/dot(d,n);\n    vec3 x = p + d*i;\n    float ab = dot(x-a,cross(n,normalize(b-a)));\n    float bc = dot(x-b,cross(n,normalize(c-b)));\n    float ca = dot(x-c,cross(n,normalize(a-c)));\n    if (ab<0.||bc<0.||ca<0.) return 1e9;\n    return i;\n}\n", "buffer_a_code": "Main {\n    int x = int(U.x);\n    int y = int(U.y);\n    if (x>5 || y > 0) discard;\n    \n    vec3 m = texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    vec3 v = texelFetch(iChannel0,ivec2(1,0),0).xyz;\n    mat3 o = mat3(\n        texelFetch(iChannel0,ivec2(2,0),0).xyz,\n        texelFetch(iChannel0,ivec2(3,0),0).xyz,\n        texelFetch(iChannel0,ivec2(4,0),0).xyz);\n    vec3 s =  texelFetch(iChannel0,ivec2(5,0),0).xyz;\n    for (float i = 0.; i < 100.; i++) {\n        vec3 f = vec3(0,-1e-4,0);\n        vec3 t = vec3(0);\n\n        for (int i = 0; i < 12; i++) {\n            vec3 q = verts[i]*(1.-W)*o+m;\n            vec3 p = q-vec3(0,-W-1.,0);\n            if (p.y < 0.) {\n                vec3 df = vec3(0,p.y,0);\n                vec3 dv = v + cross(s,p-m);\n                df += .01*dv;\n                f += df * dot(normalize(df),normalize(p-m));\n                t += cross(df,p-m);\n            }\n        }\n        #define dt .05\n        #define da 0.5\n        v += dt*f;\n        m += dt*(da*f+v);\n        s += dt*t;\n        o *= matrix(dt*(da*t+s));\n        o[0] = normalize(cross(o[1],o[2]));\n        o[1] = normalize(cross(o[2],o[0]));\n        o[2] = normalize(cross(o[0],o[1]));\n    }\n    \n    if (iFrame < 1) {\n        m = vec3(0,1,0);\n        v = vec3(.01,0,-.01);\n        o = mat3(1);\n        s = vec3(-.02);\n    }\n    \n    if (x == 0) Q = vec4(m,1);\n    if (x == 1) Q = vec4(v,1);\n    if (x == 2) Q = vec4(o[0],1);\n    if (x == 3) Q = vec4(o[1],1);\n    if (x == 4) Q = vec4(o[2],1);\n    if (x == 5) Q = vec4(s,1);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2471, 3011, 3043, 3043, 3489], [3490, 3490, 3561, 3561, 3911]], "test": "untested"}
{"id": "csVyRh", "name": "Fade out", "author": "luluco250", "description": "Fades out at 2 seconds for half a second.", "tags": ["2d", "time", "filter", "fade", "out"], "likes": 0, "viewed": 129, "published": 3, "date": "1695779735", "time_retrieved": "2024-07-30T17:31:34.339507", "image_code": "const float FADE_OUT_START = 2.0;\nconst float FADE_OUT_DURATION = 0.5;\n\nvoid mainImage(out vec4 out_color, in vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    float fade = iTime > FADE_OUT_START\n        ? iTime < (FADE_OUT_START + FADE_OUT_DURATION)\n            ? 1.0 - (iTime - FADE_OUT_START) / FADE_OUT_DURATION\n            : 0.0\n        : 1.0;\n    \n    out_color = vec4(color * fade, 1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 123, 123, 445]], "test": "untested"}
{"id": "dsGcR1", "name": "Smoothstepped animation", "author": "makscee", "description": "Simple way to make animation out of timed translations via smoothstep function", "tags": ["sdf", "smoothstep"], "likes": 0, "viewed": 122, "published": 3, "date": "1695770758", "time_retrieved": "2024-07-30T17:31:35.480457", "image_code": "#define pi 3.141592653589793\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x*c-vec.y*s, vec.x*s+vec.y*c);\n}\n\nfloat sd_box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime - .5;\n    float w = 0.01 + smoothstep(6., 6.5, t) - smoothstep(7., 7.5, t);\n    vec2 uv = (fragCoord - iResolution.xy * .5) /iResolution.yy;\n    float s = smoothstep(.0, .5, t) * .1\n        + smoothstep(2., 2.5, t) * .1\n        - smoothstep(4., 4.5, t) * .2\n        + smoothstep(5., 5.5, t) * .3\n        - smoothstep(7., 7.5, t) * .3\n        ;\n    uv = rotate(uv, smoothstep(1., 1.5, t) * pi * .25\n        + smoothstep(3., 3.5, t) * pi * .25\n        + smoothstep(5., 5.5, t) * pi * .25\n        );\n    float v = min(smoothstep(-w, w, sd_box(uv, vec2(s))), smoothstep(w, -w, sd_box(uv, vec2(s))));\n    fragColor = vec4(vec3(v),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 63, 63, 154], [156, 156, 194, 194, 274], [276, 276, 333, 333, 986]], "test": "untested"}
{"id": "flVGR3", "name": "Sierpinski Explorations", "author": "scry", "description": "From awhile ago didn't realize I never published this :P\nuse mouse to view from different angles", "tags": ["3d"], "likes": 18, "viewed": 244, "published": 3, "date": "1695765218", "time_retrieved": "2024-07-30T17:31:36.296274", "image_code": "// 2021-11-28 05:26:13\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,(w)));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n \nvec3 slogo(vec2 uv, float ar) {\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.9995-uv.x;\n    uv *= 10.*ls;\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    //b = rr*floor(b);\n    float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+ptime,0,rr-b*1.9))*rr;\n    //l -= length(uv)*0.5;\n    //l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    //l -= 3.-ul*2;\n    //l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat abx(float a,float b) {\n    return abs(abs(a)-b)-b;\n}\n\nvec4 fr(vec3 p) {\n    //p.z = 0.;\n    //p.xz *= r2d((3.14159/180.)*-90);\n    float st = iTime*0.2;\n    float sm = sin(st*10.)*0.5+0.5;\n    //sm = 0.;\n    //sm += sin(st*2.)*0.25;\n    //sm *= 1.;\n    float lp = length(p);\n    //sm += sin(st*1)*0.125;\n    float lr = -0.001-sin(lp*20.+iTime)*0.0015;\n    float ls = 0.5;\n    //p *= 2.;\n    lr += 0.001;\n    //lr += (sin(p.z*20+iTime)*0.5+0.5)*0.004;\n    //vec3 pc = p;\n    float d = 10000.;\n    //float u = (fract(iTime*0.02+sin(p.z*4.5)*0.5)-0.5)*2.;\n    float u = 1.;\n    //u = sin(iTime)*0.5+0.5;\n    //ls /= u;\n    float lsm = 0.495;\n    vec3 dp = p;\n    //p += 0.5;\n    //p.x += 0.1;\n    d = min(d,sdVerticalCapsule(p+vec3(0.,ls/2.,0.),ls,lr));\n    d = min(d,sdVerticalCapsule(p.yxz+vec3(0,ls/2.,0),ls,lr));\n    d = min(d,sdVerticalCapsule(p.xzy+vec3(0,ls/2.,0),ls,lr));\n    //p.x -= 0.;\n    //ls *= 0.1;\n    float pd = 0.185;\n    //float pm = 1.-(sin(iTime)*0.5+0.5);\n    float pm = 1.;\n    //p *=  2.;\n    float tm = iTime;\n    tm *= 0.1;\n    float ia = 0.;\n    float pdm = (sin(dp.x*6.+iTime)*0.5+0.5)*0.5;\n    //p += sin(p*20.+iTime)/24.;\n    float lss = 0.8;\n    st += sin(st*2.)*0.25+sin(st*3.)*0.25;\n    for (int i=0;i<9;i++) {\n    //p.x += 0.1;\n    ia += 1.;\n    //p += sin(p*300.-3)/1400.;\n    pd *= u;\n    \n    //p += ;\n    //p *= pm;\n    //p -= sin(iTime)*0.01;\n    //p.xz = abs(p.xz-vec2(0.,0.))-vec2(0.,0.);\n    //p.z = abs(p.z-0.3)-0.3;\n    p.yz *= r2d((3.14159/180.)*-45.+st*0.2);\n    p.zy = abs(p.zy);\n    //p.x = abs(p.x)-0.09;\n    //p.z -= i*0.005;\n    //p.z = abs(p.z)-0.02;\n    //p.z = (fract(p.z)-0.5);\n    //p.zy = abs(p.zy)+0.01;\n    \n    p.yz *= r2d((3.14159/180.)*+45.+st*0.1);\n    //p.yz *= r2d((3.14159/180.)*-45);\n    //p.zy *= r2d((3.14159/180.)*-35.264);\n    \n    \n    \n    p.xy *= r2d((3.14159/180.)*-45.);\n    //p.x += 0.3;\n    //p.xy = abs(p.xy)-pd-0.05*(sin(p.z*10.)*0.5+0.5);\n    p.xy = abs(p.xy)-pd;\n    //p.xy = abs(p.xy)-pd+0.003;\n    //p.z = abs(p.z)-pd;\n    pd *= 0.5;\n    //pd *= pdm;\n    //u *= 0.;\n    //p.zy *= r2d((3.14159/180.)*-iTime+p.x/ls*sm*5);\n    //p.xy *= r2d((3.14159/180.)*-(p.y*2)+iTime*0.3);\n    //p.x -= .;\n    p.xy *= r2d((3.14159/180.)*+45.);\n    \n    //p = abs(p)-0.02;\n    \n    ls *= lsm;\n    //ls *= lss;\n    //ls += 0.1;\n    //ls *= 0.7;\n    //lr += 0.0001;\n    //lr *= 0.;\n    //p.x -= 900.9;\n    //p.x -= 0.01;\n    //ls /= 1.-sm;\n    //p.x += (sin(iTime)*0.5+0.5)*0.2;\n    //p.z = 0.;\n    //lr *= 1.2;\n    //lsm *= 1.;\n    //p += iTime;\n    //p = sin(p.xzz*4)/4.;\n    //p = fract(p+0.5);\n    //p += iTime;\n    //p = abs(p)-0.01*(sin(iTime*2)*0.5+0.5);\n    //p.x += ls-sm*0.3;\n    //p = (fract(p*0.5)-0.5)/0.01;\n    //p.x += sin(p.z*20+iTime)*0.02;\n    //p.z = abs(p.z)-0.006*(sin(sm+dp.y*9+iTime));\n    \n    //p.x = abs(sm-p.x)-sm*0.5;\n    //p.y *= \n    //p.x = d;\n    //p.x = abs(\n    \n    d = min(d,sdVerticalCapsule(p+vec3(0.,ls/2.,0.),ls,lr));\n    d = min(d,sdVerticalCapsule(p.yxz+vec3(0,ls/2.,0),ls,lr));\n    d = min(d,sdVerticalCapsule(p.xzy+vec3(0,ls/2.,0),ls,lr));\n    \n    //p.x += sm*0.5;\n    //p.x += 1;\n    //d = min(d,sdVerticalCapsule(p.zyx+vec3(0.,ls/2,0.),ls,lr));\n    //d = min(d,sdVerticalCapsule(p.yzx+vec3(0,ls/2,0),ls,lr));\n    //d = min(d,sdVerticalCapsule(p.xyz+vec3(0,ls/2,0),ls,lr));\n    //p.xz = abs(p.xz)-0.01;\n    //d = min(d,sdVerticalCapsule(p+vec3(0.,ls/4,0.),ls/2,lr));\n    //d = min(d,sdVerticalCapsule(p.yxz+vec3(0,ls/4,0),ls/2,lr));\n    \n    \n    }\n    //d = min(d,sdVerticalCapsule(p+vec3(0.,ls/2,0.),ls,lr));\n    //d = min(d,sdVerticalCapsule(p.yxz+vec3(0,ls/2,0),ls,lr));\n    //d = min(d,sdVerticalCapsule(p.xzy+vec3(0,ls/2,0),ls,lr));\n    //d *= 2./pm;\n    //d = min(d,sdVerticalCapsule(p,ls,lr));\n    //d = min(d,sdVerticalCapsule(p.yxz,ls,lr));\n    return vec4(p,d);\n}\nvec4 map(vec3 p) {\n    //p += 1.;\n    //p.xy *= r2d(1.);\n    //p.xz *= r2d(1.);\n    vec3 c = p;\n    //p.xy += 2.;\n    p.z -= 0.;\n    //p.xy *= r2d(iTime*0.01+p.z*1);\n    p.z -= 0.2-(cos(iTime*0.02)*0.5+0.5)*0.8;\n    //p.xy *= r2d(iTime*0.03+sin(p.z*130+iTime*2)*0.1);\n    \n    //p.xz *= r2d(iTime*0.02+sin(p.x*60+iTime*1)*0.1);\n    //p.xz *= r2d(iTime*0.02);\n    p.yz *= r2d((iTime*0.002)*1.2+(iMouse.y/iResolution.y)*12.);\n    p.xy *= r2d((3.14159/180.)*-0.);\n    p.xz *= r2d((iTime*0.001)*1.3+(iMouse.x/iResolution.x)*12.);\n    //p.xz *= r2d(3.14);\n    //p.xy *= r2d(p.z*2+iTime*0.1);\n    \n    float d = length(p)-0.5;\n    //p.z += iTime;\n    float pz = p.z;\n    float rs = 0.07;\n    //float rs = 0.001*sin(iTime*.5+p.z*2.)*sin(iTime*0.2-p.z*1);\n    //pz = (fract(pz/rs)-0.5)*rs;\n    //pz = abs(pz)+p.z;\n    vec4 frd = fr(p);\n    d = frd.w-0.0004;\n    d = max(d, -(length(c)-0.02));\n    //p.z -= 0.98*2;\n    //p = frd.xyz;\n    //d = cthing(vec3(p.xy,p.z*0.3+iTime*0.01))+0.00075;\n    //d = max(d,pz);\n    //d = max(cthing(vec3(p.xy,p.z))-0.0001,pz);\n    //d = min(d,cthing(p));\n    //p.z -= 20.;\n    //d = min(d,length(p)-0.1);\n    //p += d;\n    return vec4(p,d);\n}\n\nvec3 calcNorm(vec3 p) {\n    //float eps = 0.01*(sin(p.z*0.1)*0.5+0.5);\n    float eps = 0.0002;\n    vec2 h = vec2(eps,0.);\n    return normalize(vec3(map(p-h.xyy).w-map(p+h.xyy).w,\n                          map(p-h.yxy).w-map(p+h.yxy).w,\n                          map(p-h.yyx).w-map(p+h.yyx).w));\n}\n\n\n#define render 0\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    int steps = 320;\n    if (render == 1) {\n        steps = 1450;\n    } \n    //steps = int(noise(vec2(noise(rd.xy*3000.+iTime*20.91)*100.))*200.)+130;\n    for (int i=0;i<steps;i++) {\n        vec3 p = ro+rd*dO;\n        //ro += calcNormL(p)*0.02;\n        //ro += lens(p).xyz*0.2;\n        float dS = map(p).w;\n        dO += dS*(100./float(steps));\n        //dO += dS*(100./float(steps))*(dO+2.)*0.15;\n        ii += 8./float(steps);\n        if (dO > 1000. || dS < 0.0014) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    //uv.x *= ar;\n    \n    uv -= 0.5;\n    uv.x *= ar;\n    float c= length(uv);\n    vec3 ro = vec3(0.,0.,0.-(1./iTime+1.));\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec4 mp = map(p);\n    vec3 n = calcNorm(p);\n    float lp = length(p);\n    vec3 col = vec3(0.);\n    //col += d.x*0.3;\n    //col = vec3(d.y-1.3);\n    //mp += iTime*0.2;\n    //col = hsv2rgb(vec3(lp*3,d.y-1.2,clamp((0.9-d.x)*1.5-d.y*0.2,0.,1.)-d.y*0.25+0.25));\n    /*col = hsv2rgb(vec3(\n    lp*3.,\n    d.y-1.2,\n    clamp(1.-d.y*0.9,0.,1.)/(10.-d.x*2.)\n    ));*/\n    col += hsv2rgb(vec3(\n    sin(lp*20.)*0.2+n.y*0.12,\n    d.y-1.2,\n    clamp(3.-d.y*0.8*d.y,0.,3.)\n    ));\n    col += hsv2rgb(vec3(1.+lp*2.+iTime*0.1,1.,d.y*1.));\n    col *= 0.2;\n    //col *= n.x;\n    //col += n*0.5;\n    //col -= clamp(d.y-2.,0.,0.1);\n    //col -= pow(d.y,30.)*0.0003;\n    //col -= clamp(pow(d.y-1.1,30.),0.,0.003)*20.;\n    //col = mix(1.-col,col,sin(iTime+lp*10)*0.5+0.5);\n    //col *= 2.;\n    //col -= 0.5;\n    //col = mix(col,1.-col,sin(iTime+lp*20)*0.5+0.5);\n    col += sin(mp.w*240.+2.9);\n    if (d.x > 1000.) {\n        col *= 0.;\n        //col += d.y*0.2-1.2;\n        //col = hsv2rgb(vec3(d.y*0.8+iTime*0.1,sin(d.y*2)*0.5+0.5,sin(d.y*2.)*0.5+0.5))*0.1;\n        //col = hsv2rgb(vec3(d.y*5,sin(d.y*20)*0.5+0.5,sin(d.y*4.)*0.5+0.5));\n    }\n    col = clamp(col,0.,1.);\n    //tv = abs(tv)+0.01;\n    //tv = abs(tv)+0.2;\n    //tv = abs(tv-0.159)+0.16;\n    //tv = abs(1.-tv)-0.2;\n    vec2 ttv = tv;\n    tv -= 0.5;\n    //tv = abs(tv)-(0.4-c*0.1);\n    \n    tv = abs(tv)-0.03;\n    tv.x *= ar;\n    \n    //tv *= r2d(-iTime*0.02);\n    //tv = 0.79-abs(1.-tv);\n    //tv *= r2d(-iTime*0.01);\n    //tv = abs(tv)-0.05;\n    //tv *= r2d(iTime*0.01);\n    tv.x /= ar;\n    \n    //tv.y *= ar;\n    tv += 0.5;\n    tv =abs(tv);\n    //tv *= r2d(-iTime*0.00);\n    //tv.y *= ar;\n    vec3 bak = texture(iChannel0,tv).rgb;\n    if (d.x > 1000.5) {\n        col = bak*0.99-d.y*d.y*0.01;\n        col = rgb2hsv(col);\n        col = hsv2rgb(vec3(col.x+0.1,col.y,col.z));\n        //col = mix(col,bak,clamp(2.-d.x,0.,.9));\n        //col = mix(col,bak,clamp(d.x,0.,0.4));\n    }\n    //col = rgb2hsv(col);\n    //col = hsv2rgb(vec3(col.x,col.y,col.z));\n    col -= slogo(ttv,ar)*0.5;\n    //tv += 0.00001;float bakr = texture(iChannel0,tv).r;tv.x += 0.0001;tv.y -= 0.0003;float bakg = texture(iChannel0,tv).g;col.r += bakg*0.5;col.b += bakr*2;\n    //col *= b;\n    \n    //col = hsv2rgb(vec3(col.r+iTime*0.04,sin(col.b*8.+iTime)*0.5+0.5,sin(col.g*6.-iTime)*0.5+0.5))*1.;\n    //uvc *= r2d((3.14159/180)*-45);\n    //col += sin(uvc.x*2)*0.2;\n    //col += sin(col+iiTime*0.1+c*3.+iiTime*0.03)+cos(col-iiTime*2+sin(c*100*sin(iiTime*0.2+cos(iiTime*1.2)*0.5)));\n    //col = sin(col*0.5);\n    //col = sqrt(col*3.)-.4;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 131, 303]], "test": "untested"}
{"id": "cdGyRh", "name": "Light Lanes", "author": "QuantumSuper", "description": "A 2D network of pseudo-random lanes with light-sparks wandering along them.\n\n(Whats eating the performance on this one? Just the presence of the nested for-loop?)", "tags": ["2d", "simplistic", "lanes"], "likes": 14, "viewed": 543, "published": 3, "date": "1695748971", "time_retrieved": "2024-07-30T17:31:37.129048", "image_code": "// Light Lanes 0.51.230927 by QuantumSuper\n// 2d pseudo-random lanes with light-\"sparks\" wandering along them\n// \n\n\nfloat aaStep( float fun){return smoothstep( min(fwidth(fun),.001), .0, fun);} //simple antialiasing\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    float amp = 0.;\n\tfloat delY = .1;\n\tfloat r, ox, fun;\n    \n\tfor (float m=-1.;m<=1.;m+=.05){\n\t\tox = m;\n\t\tfun = uv.x-ox;\n\t\tfor (float n=0.;n<2./delY;n++){ //uv.y -1..1\n\t\t\tr = floor(hash21(vec2(n+ceil(iTime/8.),ox+max(.98,fract(iTime/8.))))*3.-1.); //r {-1,0,1}\n            fun += (r*(uv.y-(delY*n-1.))+ox+m) * step(delY*n-1.,uv.y+.001) * step(uv.y+.001,delY*(n+1.)-1.); //+.001 to avoid weird? singularities for negative uv.y\n            ox = r*(delY*(n+1.)-1.) - (r*(delY*n-1.)-ox-m) - m; //? isnt that supposed to be: ox += r*delY ?\n\t\t}\n\t\tamp += aaStep(abs(fun)-.009*iResolution.y/iResolution.x) * (.1+.9*aaStep(abs(fragCoord.y/iResolution.y-fract(iTime/4.+m))-.005*iResolution.y/iResolution.x));\n\t} \n\n    fragColor = vec4(vec3(amp),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 141, 141, 193], [217, 217, 238, 308, 401], [403, 403, 458, 458, 1322]], "test": "untested"}
{"id": "mdKyRz", "name": "Neon Noodle Cat", "author": "Lewie4", "description": "Neon Noodle Cat made with sdfs", "tags": ["loop", "cat", "neon"], "likes": 34, "viewed": 408, "published": 3, "date": "1695742726", "time_retrieved": "2024-07-30T17:31:37.996728", "image_code": "// SDFs: https://iquilezles.org/articles/distfunctions2d/\n// Sign: https://www.etsy.com/uk/listing/1414248168/fortune-ramen-cat-neon-sign-anime-lucky\n\nfloat dot2(vec2 A)\n{\n    return dot(A.xy, A.xy);\n}\n\nfloat saturate(float A)\n{\n    return clamp(A,0.0,1.0);\n}\n\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.*B + C;\n    vec2 c = a * 2.;\n    vec2 d = A - pos;\n    float kk = 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.*dot(a,a)+dot(d,b))/3.;\n    float kz = kk * dot(d,a);      \n    float res = 0.;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.*kx*kx-3.*ky)+kz;\n    float h = q*q + 4.*p3;\n    if( h >= 0.) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.;\n        vec2 uv = sign(x)*pow(abs(x),vec2(1./3.,1./3.));\n        float t = clamp(uv.x+uv.y-kx, 0.,1.);\n        res = dot2(d+(c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.))/3.;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.,1.);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nfloat white(vec2 UV)\n{\n    // White\n    float temp = sdBezier(UV, vec2(-.405,-.34), vec2(-.385,-.71), vec2(-.12,-.725));      // Body Left Bottom\n    temp = min(temp, sdBezier(UV, vec2(-.4,-.25), vec2(-.375,-.05), vec2(-.255,.035)));   // Body Left Top\n    temp = min(temp, sdBezier(UV, vec2(-.083,.064), vec2(-.41,.048), vec2(-.31,.38)));   // Face Left\n    temp = min(temp, sdBezier(UV, vec2(-.3,.72), vec2(-.35,.5), vec2(-.31,.38)));         // Ear Left Left\n    temp = min(temp, sdBezier(UV, vec2(-.3,.72), vec2(-.19,.71), vec2(-.08,.6)));         // Ear Left Right\n    temp = min(temp, sdBezier(UV, vec2(.13,.616), vec2(.0,.65), vec2(-.08,.6)));         // Face Top\n    temp = min(temp, sdBezier(UV, vec2(.13,.616), vec2(.225,.73), vec2(.33,.755)));         // Ear Right Left\n    temp = min(temp, sdBezier(UV, vec2(.382,.41), vec2(.4,.65), vec2(.33,.755)));         // Ear Right Right\n    temp = min(temp, sdBezier(UV, vec2(.382,.41), vec2(.45,.25), vec2(.36,.15)));         // Face Right\n    \n    temp = min(temp, sdBezier(UV, vec2(.355,-.135), vec2(.2,-.03), vec2(.225,.1)));         // Paw Right Left\n    temp = min(temp, sdBezier(UV, vec2(.36,.135), vec2(.25,.19), vec2(.225,.1)));          // Paw Right Top\n    temp = min(temp, sdBezier(UV, vec2(.36,.135), vec2(.55,.015), vec2(.458,-.165)));         // Paw Right Right\n    temp = min(temp, sdBezier(UV, vec2(.23,.11), vec2(.28,.09), vec2(.295,.055)));         // Paw Right 1\n    temp = min(temp, sdBezier(UV, vec2(.259,.148), vec2(.32,.138), vec2(.342,.09)));         // Paw Right 1\n    \n    temp = min(temp, sdBezier(UV, vec2(-.3,-.655), vec2(-.67,-.55), vec2(-.44,-.14)));   // Tail Left Bottom\n    temp = min(temp, sdBezier(UV, vec2(-.52,.145), vec2(-.368,.01), vec2(-.44,-.14)));   // Tail Left Mid\n    temp = min(temp, sdBezier(UV, vec2(-.52,.145), vec2(-.575,.22), vec2(-.52,.275)));   // Tail Left Top\n    temp = min(temp, sdBezier(UV, vec2(-.4,.26), vec2(-.48,.32), vec2(-.52,.275)));   // Tail Right Top\n    temp = min(temp, sdBezier(UV, vec2(-.4,.26), vec2(-.29,.15), vec2(-.31,-.01)));   // Tail Right Mid\n    temp = min(temp, sdBezier(UV, vec2(-.4,-.19), vec2(-.55,-.51), vec2(-.33,-.617)));   // Tail Right Bottom\n\n    temp = min(temp, sdBezier(UV, vec2(-.373,-.23), vec2(-.275,-.065), vec2(-.125,-.115)));         // Paw Left Left\n    temp = min(temp, sdBezier(UV, vec2(-.125,-.22), vec2(-.052,-.155), vec2(-.125,-.115)));         // Paw Left Top\n    temp = min(temp, sdBezier(UV, vec2(-.125,-.22), vec2(-.18,-.27), vec2(-.325,-.235)));         // Paw Left Top\n    temp = min(temp, sdBezier(UV, vec2(-.36,-.235), vec2(-.345,-.23), vec2(-.325,-.235)));         // Paw Left Right\n    temp = min(temp, sdBezier(UV, vec2(-.165,-.24), vec2(-.18,-.21), vec2(-.22,-.185)));         // Paw Left 1\n    temp = min(temp, sdBezier(UV, vec2(-.115,-.21), vec2(-.14,-.17), vec2(-.185,-.155)));         // Paw Left 2\n\n    temp = min(temp, sdBezier(UV, vec2(-.21,.348), vec2(-.07,.405), vec2(-.058,.27)));         // Eye Left\n    temp = min(temp, sdBezier(UV, vec2(.28,.38), vec2(.17,.4), vec2(.123,.295)));         // Eye Right\n\n    temp = min(temp, sdBezier(UV, vec2(.265,.269), vec2(.32,.295), vec2(.37,.292)));         // Whisker Right 1\n    temp = min(temp, sdBezier(UV, vec2(.275,.24), vec2(.32,.24), vec2(.366,.24)));         // Whisker Right 2\n    temp = min(temp, sdBezier(UV, vec2(.27,.205), vec2(.3,.2), vec2(.348,.198)));         // Whisker Right 3\n    temp = min(temp, sdBezier(UV, vec2(-.192,.228), vec2(-.25,.23), vec2(-.285,.205)));         // Whisker Left 1\n    temp = min(temp, sdBezier(UV, vec2(-.185,.195), vec2(-.21,.2), vec2(-.265,.168)));         // Whisker Left 2\n    temp = min(temp, sdBezier(UV, vec2(-.185,.166), vec2(-.23,.15), vec2(-.248,.135)));         // Whisker Left 3\n\n    //temp = min(temp, sdBezier(UV, float2(.005,.34), float2(.01,.31), float2(.005,.292)));         // Nose Top Left\n    //temp = min(temp, sdBezier(UV, float2(.078,.36), float2(.06,.33), float2(.072,.297)));         // Nose Top Right\n    temp = min(temp, sdBezier(UV, vec2(.004,.27), vec2(.045,.298), vec2(.089,.27)));         // Nose Top\n    temp = min(temp, sdBezier(UV, vec2(.004,.27), vec2(.005,.24), vec2(.048,.225)));         // Nose Left\n    temp = min(temp, sdBezier(UV, vec2(.089,.27), vec2(.09,.24), vec2(.048,.225)));         // Nose Right\n\n    temp = min(temp, sdBezier(UV, vec2(-.11,.17), vec2(-.03,.145), vec2(.048,.225)));         // Mouth Left\n    temp = min(temp, sdBezier(UV, vec2(-.11,.17), vec2(-.165,.19), vec2(-.115,.245)));         // Mouth Left\n    temp = min(temp, sdBezier(UV, vec2(.16,.18), vec2(.08,.17), vec2(.048,.225)));         // Mouth Right\n    temp = min(temp, sdBezier(UV, vec2(.16,.18), vec2(.23,.19), vec2(.235,.255)));         // Mouth Right\n\n    return temp;\n}\n\nfloat red(vec2 UV)\n{\n    // Red\n    float temp = sdBezier(UV, vec2(-.25,.067), vec2(-.26,.01), vec2(-.08,.03));      // Collar\n    \n    temp = min(temp, sdBezier(UV, vec2(-.265,.45), vec2(-.29,.55), vec2(-.25,.638)));   // Ear Left Left\n    temp = min(temp, sdBezier(UV, vec2(-.14,.57), vec2(-.18,.62), vec2(-.25,.638)));   // Ear Left Right\n    temp = min(temp, sdBezier(UV, vec2(-.14,.57), vec2(-.23,.52), vec2(-.265,.45)));   // Ear Left Bottom\n\n    temp = min(temp, sdBezier(UV, vec2(.19,.59), vec2(.23,.65), vec2(.3,.68)));   // Ear Right Left\n    temp = min(temp, sdBezier(UV, vec2(.3,.51), vec2(.32,.6), vec2(.3,.68)));   // Ear Right Left\n    temp = min(temp, sdBezier(UV, vec2(.3,.51), vec2(.28,.55), vec2(.19,.59)));   // Ear Right Left\n\n    return temp;\n}\n\nfloat blue(vec2 UV)\n{\n    // Blue\n    float temp = sdBezier(UV, vec2(-.346,-.25), vec2(-.38,-.28), vec2(-.33,-.3));      // Bowl Inner Left\n    temp = min(temp, sdBezier(UV, vec2(.52,-.27), vec2(.28,-.44), vec2(-.33,-.3)));   // Bowl Inner Mid\n    temp = min(temp, sdBezier(UV, vec2(.52,-.27), vec2(.555,-.24), vec2(.5,-.223)));   // Bowl Inner Right\n    temp = min(temp, sdBezier(UV, vec2(.225,-.192), vec2(.35,-.19), vec2(.5,-.223)));   // Bowl Inner Right\n\n    temp = min(temp, sdBezier(UV, vec2(-.37,-.245), vec2(-.46,-.29), vec2(-.39,-.325)));   // Bowl Outer Right\n    temp = min(temp, sdBezier(UV, vec2(.59,-.285), vec2(.2,-.52), vec2(-.39,-.325)));   // Bowl Outer Mid\n    temp = min(temp, sdBezier(UV, vec2(.59,-.285), vec2(.63,-.24), vec2(.59,-.215)));   // Bowl Outer Right\n    temp = min(temp, sdBezier(UV, vec2(.24,-.16), vec2(.52,-.17), vec2(.59,-.215)));   // Bowl Outer Right\n\n    temp = min(temp, sdBezier(UV, vec2(-.085,-.68), vec2(-.29,-.67), vec2(-.39,-.325)));   // Bowl Bottom Left\n    temp = min(temp, sdBezier(UV, vec2(-.035,-.685), vec2(.1,-.7), vec2(.18,-.69)));   // Bowl Bottom Middle\n    temp = min(temp, sdBezier(UV, vec2(.59,-.285), vec2(.5,-.67), vec2(.23,-.685)));   // Bowl Bottom Right\n\n    temp = min(temp, sdBezier(UV, vec2(-.135,-.675), vec2(-.15,-.77), vec2(.085,-.76)));   // Bowl Base Left\n    temp = min(temp, sdBezier(UV, vec2(.375,-.645), vec2(.4,-.77), vec2(.085,-.76)));   // Bowl Base Right\n\n    return temp;\n}\n\nfloat purple(vec2 UV)\n{\n    // Purple\n    float temp = sdBezier(UV, vec2(-.04,.02), vec2(.1,.06), vec2(.205,.092));      // Chopstick Top Left\n    temp = min(temp, sdBezier(UV, vec2(.38,.15), vec2(.49,.18), vec2(.59,.21)));   // Chopstick Top Right\n    temp = min(temp, sdBezier(UV, vec2(.42,.11), vec2(.5,.125), vec2(.60,.14)));   // Chopstick Bottom\n\n    return temp;\n}\n\nfloat yellow(vec2 UV)\n{\n    // Yellow\n    float temp = sdBezier(UV, vec2(-.528,.195), vec2(-.3,.2), vec2(-.405,-.026));      // Tail Outer\n    temp = min(temp, sdBezier(UV, vec2(-.505,.152), vec2(-.42,.16), vec2(-.44,.08)));   // Tail Inner\n\n    temp = min(temp, sdBezier(UV, vec2(-.045,.595), vec2(.01,.52), vec2(.084,.605)));   // Head Inner\n    temp = min(temp, sdBezier(UV, vec2(-.08,.585), vec2(.01,.44), vec2(.132,.6)));   // Head Outer\n    temp = min(temp, sdBezier(UV, vec2(.355,.58), vec2(.32,.5), vec2(.365,.42)));   // Head Right\n\n    temp = min(temp, sdBezier(UV, vec2(-.34,-.2), vec2(-.24,-.2), vec2(-.245,-.13)));   // Paw Left\n    temp = min(temp, sdBezier(UV, vec2(.43,.065), vec2(.33,.02), vec2(.47,-.09)));   // Paw Right\n\n    temp = min(temp, sdBezier(UV, vec2(-.258,.015), vec2(-.25,-.05), vec2(-.31,-.04)));   // Body Inner\n    temp = min(temp, sdBezier(UV, vec2(-.335,-.085), vec2(-.2,-.1), vec2(-.22,.01)));   // Body Outer\n    return temp;\n}\n\nfloat noodles(vec2 UV)\n{\n    // Noodles\n    float temp = sdBezier(UV, vec2(.285,-.205), vec2(.255,-.205), vec2(.225,-.24));      // Noodle 1\n    temp = min(temp, sdBezier(UV, vec2(.39,-.215), vec2(.33,-.225), vec2(.285,-.26)));   // Noodle 2\n    temp = min(temp, sdBezier(UV, vec2(.48,-.23), vec2(.43,-.225), vec2(.31,-.28)));   // Noodle 3\n    temp = min(temp, sdBezier(UV, vec2(.46,-.29), vec2(.41,-.275), vec2(.34,-.308)));   // Noodle 4\n    temp = min(temp, sdBezier(UV, vec2(-.23,-.31), vec2(.1,-.15), vec2(.33,-.33)));   // Noodle 5\n    temp = min(temp, sdBezier(UV, vec2(-.18,-.315), vec2(.1,-.2), vec2(.28,-.34)));   // Noodle 6\n    temp = min(temp, sdBezier(UV, vec2(-.11,-.325), vec2(.1,-.29), vec2(.16,-.35)));   // Noodle 7\n\n    float offset = sin(UV.y*50.)*.02 * 2.*(floor(sin(iTime*2.))+.5);\n    temp = min(temp, saturate(smoothstep(.16, .26, UV.y) + (smoothstep(-.245, -.345, UV.y) + length(UV.x+ offset +.05)))); // Noodle Eat 1\n    temp = min(temp, saturate(smoothstep(.17,.27, UV.y) + (smoothstep(-.235, -.335,UV.y) + length(UV.x + offset)))); // Noodle Eat 2\n    temp = min(temp, saturate(smoothstep(.2,.3, UV.y) + (smoothstep(-.23,-.33,UV.y) + length(UV.x + offset -.05)))); // Noodle Eat 3\n    temp = min(temp, saturate(smoothstep(.18,.28, UV.y) + (smoothstep(-.23, -.33,UV.y) + length(UV.x + offset -.1)))); // Noodle Eat 4\n    temp = min(temp, saturate(smoothstep(.17,.27, UV.y) + (smoothstep(-.235,-.335,UV.y) + length(UV.x + offset -.15)))); // Noodle Eat 5\n    return temp;\n}\n\nfloat glow(float A)\n{\n    return max(smoothstep(.007,0.,A), (smoothstep(.03,0.,A)*.5));\n}\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    u = (u+u-iResolution.xy)/iResolution.y;\n    O -= O;\n    \n    O.xyz = mix(vec3(.1867,.1867,.1867),vec3(1.,1.,1.), glow(white(u)));\n    O.xyz = mix(O.xyz, vec3(.7529,.0036,.007), glow(red(u)));\n    O.xyz = mix(O.xyz, vec3(.1412,.8388,.9735), glow(blue(u)));\n    O.xyz = mix(O.xyz, vec3(.807,.2307,.7758),glow(purple(u)));\n    O.xyz = mix(O.xyz, vec3(.913,.6939,.0144),glow(yellow(u)));\n    O.xyz = mix(O.xyz, vec3(.8388,.807,0.0185),glow(noodles(u)));  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 171, 171, 201], [203, 203, 228, 228, 259], [261, 261, 312, 312, 1324], [1326, 1326, 1348, 1361, 6088], [6090, 6090, 6110, 6121, 6856], [6858, 6858, 6879, 6891, 8315], [8317, 8317, 8340, 8354, 8688], [8690, 8690, 8713, 8727, 9655], [9657, 9657, 9681, 9696, 11158], [11160, 11160, 11181, 11181, 11249], [11251, 11251, 11290, 11290, 11748]], "test": "untested"}
{"id": "dsVcRR", "name": "Solid angle sphere/cone sampling", "author": "jeyko", "description": "potate", "tags": ["sphere", "cone", "sampling", "sampling", "uniform", "dw", "nee"], "likes": 23, "viewed": 483, "published": 3, "date": "1695737452", "time_retrieved": "2024-07-30T17:31:38.852440", "image_code": "// ------ I haven't actually tested if this is correct yet   ------ //\n// ------ Also quite possible you could remove the trig here ------ //\n\n// The sphere is rendered as points, just for illustrative purposes.\n// The actual directions are sampled uniformly in cone.\n\nvec3 sphere_pos = vec3(.0,0.4,0.2);\nfloat sphere_rad = 0.3;\n\nmat3 get_orth_basis(vec3 origin, vec3 target){\n    vec3 dir = normalize(target - origin);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = cross(dir, right);\n    return mat3(up, right, dir);\n}\n\nvec3 sample_cone(vec3 origin, vec3 sphere_pos, float sphere_rad){\n    mat3 orth_basis = get_orth_basis(origin, sphere_pos);\n    \n    // The apex angle is derived the same way as in https://www.shadertoy.com/view/DtSBD3\n    float l = length(sphere_pos.xyz - origin.xyz);\n    float apex_angle = asin(sphere_rad/2.0/l)*2.0;\n    \n    // --- w is the solid angle, derived from the apex angle\n    // w = integrate sin(theta) for theta from 0 to pi/2 for phi from 0 to 2pi)\n    // w = (−cos(apex_angle/2) + cos(0)) * 2pi\n\n    // pdf(w)       = 1./w\n    // --- convert to theta/phi\n    // pdf(the,phi) = sin(the) * pdf(w)\n    // pdf(phi)     = 1/2pi\n    \n    // pdf(theta) = integrate sin(the) * pdf(w) from 0 to 2pi\n    // pdf(theta) = sin(theta) * pdf(w) * 2pi\n    \n    // --- integrate & inverse to get inverse CDF\n    // c = pdf(w) * 2pi \n    // x_theta_integr_0_the = c - c * cos(the)\n    // x_theta = acos((c-the)/c)\n    // x_phi = phi * 2pi\n    \n    \n    vec2 x = hash_v2();\n    \n    float w = (-cos(apex_angle/2.0) + cos(0.0)) * 2.*pi;\n    \n    \n    float c = 2. * pi * 1./w;\n    float theta = acos((c - x.x)/c);\n    float phi = x.y * 2. * pi;\n    \n    return orth_basis * car_to_pol(theta,phi);\n}\nvec3 proj(vec3 p){\n\n    vec2 muv = (iMouse.xy - 0.5*R)/R.y;\n    \n    if(iMouse.z > 0.5){\n        p.xz *= rot(-muv.x*tau/2.0);\n        p.yz *= rot(-muv.y*2.6);\n\n    } else {\n        p.xz *= rot(iTime*0.4);\n    }\n    p.y -= 0.5;\n    p.z += 1.4;\n    \n    p.xy /= p.z;\n    \n    return p;\n}\n\n\nvoid draw_sphere(inout vec3 col, vec2 uv){\n    \n    float subdivs_the = 40.;\n    float subdivs_phi_max = 40.;\n    \n    for(float the = 0.; the <= subdivs_the; the++){\n        float the_idx = the/subdivs_the*pi;\n        \n        float sc = sqrt(abs(cos(the_idx - pi/2.0)));\n        float subdivs_phi = max(subdivs_phi_max*sc,1.0);\n        for(float phi = 0.; phi < subdivs_phi; phi++){\n            float phi_idx = phi/subdivs_phi * 2. * pi;\n            vec3 p = vec3(\n                cos(phi_idx) * sc,\n                (the/subdivs_the*2. - 1.0),\n                sin(phi_idx) * sc\n            ) * sphere_rad * 0.5;\n            p += sphere_pos;\n            p.z += 0.;\n            vec3 q = proj(p);\n            float sd = sd_dot(uv, q.xy) - 0.002;\n            //sd = min(sd, sdSegment(uv, proj(vec3(0)).xy, q.xy) - ln_sz);\n            //col = mix(col,c,0.2*smoothstep(fwidth(uv.y),0.,sd));\n            col = mix(col,vec3(1),smoothstep(fwidth(uv.y),0.,sd)*smoothstep(4.,0.,q.z));\n        }\n    }\n    \n}\n\nvoid draw_floor(inout vec3 col, vec2 uv){\n    float iters = 10.;\n    float range = 2.;\n    for(float axis = 0.; axis < 2.0; axis++){\n        for(float z = 0.; z <= iters; z++){\n            float zidx = z/iters;\n            \n            float pz = zidx * range - 0.5*range;\n            vec3 pa = vec3(-1,0,pz);\n            vec3 pb = vec3(1,0,pz);\n            if(axis > 0.5){\n                pa = vec3(pz,0,-1);\n                pb = vec3(pz,0,1);\n            }\n            \n            vec3 qa = proj(pa);\n            vec3 qb = proj(pb);\n            if(qa.z > 0.0 && qb.z > 0.){\n                float sd = sdSegment(uv, qa.xy, qb.xy) - 0.001;\n                col = mix(col,vec3(1.0),0.9*smoothstep(fwidth(uv.y),0.,sd));\n            }\n            \n        }\n    }\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n\n    vec2 uv = (U - 0.5*R)/R.y;\n\n    vec3 col = vec3(0.);\n    \n    sphere_pos += sin(\n        vec3(\n            sin(iTime*1.1),\n            sin(iTime*0.7),\n            sin(iTime*0.8)\n        )\n    )*0.2;\n    sphere_rad += sin(iTime + sin(iTime))*0.2;\n    \n    \n    draw_floor(col, uv);\n    \n    float pt_sz = 0.01;\n    float ln_sz = 0.001;\n    float opacity = 0.2;\n    \n    //seed += uint(iFrame);\n    for(float i = 0.; i < 525. + min(iTime,0.); i++){\n        vec3 c = oklch_to_srgb(vec3(0.7,0.3,hash_f()*tau));\n        vec3 p = vec3(0,0,0.);\n        vec3 s = sample_cone(p, sphere_pos, sphere_rad);\n        p += s;\n        \n        vec3 q = proj(p);\n        float sd = sdSegment(uv, proj(vec3(0,0.,0)).xy, q.xy) - ln_sz;\n        col = mix(col,c*2.,0.1*smoothstep(fwidth(uv.y),0.,sd));\n        \n        sd = sd_dot(uv, q.xy) - pt_sz;\n        col = mix(col,c*2.,0.3*smoothstep(fwidth(uv.y),0.,sd));\n    }\n    \n    draw_sphere(col, uv);\n    \n    col *= 1.;\n    col = 1.-col;\n    col = 1.-exp(-abs(col));\n    col = pow(col,vec3(0.4545));\n    //col = pow(col,vec3(2.4545));\n    //col = smoothstep(vec3(0),vec3(1.0),col);\n    C = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n\nuint seed = 154125u;\n\n\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\nuint wang(uint a) {\n\ta = (a ^ 61U) ^ (a >> 16U);\n\ta = a * 9U;\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2dU;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n#define hash_f_s(s)  ( float( hashi(uint(s)) ) / float( 0xffffffffU ) )\n\n#define hash_f()  ( float( seed = hashi(seed) ) / float( 0xffffffffU ) )\n#define hash_v2()  vec2(hash_f(),hash_f())\n#define hash_v3()  vec3(hash_f(),hash_f(),hash_f())\n#define hash_v4()  vec3(hash_f(),hash_f(),hash_f(),hash_f())\n\n\n\nfloat sd_dot(vec2 uv, vec2 p){\n    return length(uv - p);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 car_to_pol(float th, float phi){\n    return vec3(\n        sin(th)*sin(phi),\n        sin(th)*cos(phi),\n        cos(th)\n    );\n}\n\n\n\n\n\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\n\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\n\nvec3 srgb2oklab(vec3 c) {\n    \n    mat3 m1 = mat3(\n        0.4122214708,0.5363325363,0.0514459929,\n        0.2119034982,0.6806995451,0.1073969566,\n        0.0883024619,0.2817188376,0.6299787005\n    );\n    \n    vec3 lms = mul3(m1,c);\n    \n    lms = pow(lms,vec3(1./3.));\n\n    mat3 m2 = mat3(\n        +0.2104542553,+0.7936177850,-0.0040720468,\n        +1.9779984951,-2.4285922050,+0.4505937099,\n        +0.0259040371,+0.7827717662,-0.8086757660\n    );\n    \n    return mul3(m2,lms);\n}\n\nvec3 oklab2srgb(vec3 c)\n{\n    mat3 m1 = mat3(\n        1.0000000000,+0.3963377774,+0.2158037573,\n        1.0000000000,-0.1055613458,-0.0638541728,\n        1.0000000000,-0.0894841775,-1.2914855480\n    );\n\n    vec3 lms = mul3(m1,c);\n    \n    lms = lms * lms * lms;\n  \n    mat3 m2 = mat3(\n        +4.0767416621,-3.3077115913,+0.2309699292,\n        -1.2684380046,+2.6097574011,-0.3413193965,\n        -0.0041960863,-0.7034186147,+1.7076147010\n    );\n    return mul3(m2,lms);\n}\n\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\n\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\n\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 376, 376, 539], [541, 541, 606, 606, 1740], [1741, 1741, 1759, 1759, 2026], [2029, 2029, 2071, 2071, 3027], [3029, 3029, 3070, 3070, 3791], [3793, 3793, 3832, 3832, 4974]], "test": "untested"}
{"id": "msKcRR", "name": "Fork 566 Debugg Zaleki 227", "author": "Zaleki", "description": "Find all of the runtime bugs placed in the Image code tab! None of the code in the Common tab is broken.", "tags": ["labwork"], "likes": 0, "viewed": 99, "published": 3, "date": "1695737333", "time_retrieved": "2024-07-30T17:31:39.759016", "image_code": "\nvoid raycast(vec2 uv, out vec3 dir,\n             out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 0.0, 15.0), sin(iTime * 0.1) * 3.14159 * 0.5);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y; // ============== bug2 ==============\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < 256; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0:\n        // Center sphere\n        return vec3(1.0, 0.67, 0.67);\n        break;\n        case 1:\n        // Back sphere\n        return vec3(0.67, 1.0, 0.67);\n        break;\n        case 2:\n        // Front sphere\n        return vec3(0.67, 0.67, 1.0);\n        break;\n        case 3:\n        // Floor\n        float t = floor(mod((sin(p.x) + sin(p.z)) * 0.5, 2.0));\n        return mix(vec3(0.7, 0.4, 0.2), vec3(1.0), t);\n        break;\n        case -1:\n        // Background\n        break;\n    }\n    return vec3(255.0, 229.0, 119.0) / 255.0;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    if(t == -1.0) {\n        return Intersection(t, skyColor(dir),\n                            vec3(eye + 1000.0 * dir),\n                            -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n    \n    // Specular reflection applied to all surfaces\n    dir = reflect(dir, nor); // ============= bug4 =============\n    march(isect + dir * 0.01, dir, t, hitObj);\n    vec3 specReflCol;\n    if(hitObj == -1) {\n        specReflCol = skyColor(dir);\n    }\n    else {\n        vec3 isect2 = isect + t * dir;\n        nor = computeNormal(isect2);\n        specReflCol = computeMaterial(hitObj, isect2, dir, nor);\n    }\n    float fresnel = 1.0 - max(0.0, dot(normalize(eye - isect), nor));\n    fresnel = 0.25 + 0.75 * fresnel;\n    vec3 sdfColor = mix(material, specReflCol * material, fresnel);\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0); // =========== bug 1 =============\n    \n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref); // ============= bug3 ===============\n    fragColor = vec4(sdf3D(dir, eye).color, 1.);\n    \n}", "image_inputs": [], "common_code": "#define HALF_PI 1.570795\n#define MAIN_LIGHT_DIR normalize(vec3(1.0, 0.2, -0.4))\n\n// put all bugs in Image tab\n\n// todo in broken one, hard code these in two diff scenemap3d\n#define RED_SPH_POS vec3(0.)\n#define GRN_SPH_POS vec3(4.0, 0.0, -4.0)\n#define BLU_SPH_POS vec3(-4.0, 0.0, 4.0)\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n\n\nfloat random1(vec2 p) {\n  return fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nfloat random1( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\n\nfloat interpNoise3D1(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = mySmootherStep(llb, lrb, pFract.x);\n  float lerpXHB = mySmootherStep(ulb, urb, pFract.x);\n  float lerpXLF = mySmootherStep(llf, lrf, pFract.x);\n  float lerpXHF = mySmootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = mySmootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = mySmootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return mySmootherStep(lerpYB, lerpYF, pFract.z);\n}\n\n\nfloat fbm(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise3D1(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\n\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n// Map a ray direction to a color for the background\n// This function is called when a ray hits nothing\nvec3 skyColor(vec3 dir) {\n    float t = smoothstep(0.0, 1.0, dir.y);\n    t = clamp(0.0, 1.0, t + fbm(dir / 8.0, 4.0) * 0.1);\n    t = fbm(dir / 8.0, 6.0);\n    t = smoothstep(0.0, 1.0, t);\n    vec3 dawnGradient = mix(vec3(253.0, 96.0, 81.0) / 255.0, vec3(255.0, 229.0, 119.0) / 255.0, t);\n    vec3 duskGradient = mix(vec3(48.0, 24.0, 96.0) / 255.0, vec3(144.0, 96.0, 144.0) / 255.0, t);\n    t = max(0.0, dot(dir, MAIN_LIGHT_DIR));\n    return mix(duskGradient, dawnGradient, t);\n}\n\n\n\n// Version that just returns the t value, for surface normal computation\nfloat sceneMap3D(vec3 pos) {\n    float t = sphere(pos, 2.0, RED_SPH_POS);\n    t = min(t, sphere(pos, 2.0, GRN_SPH_POS));\n    t = min(t, sphere(pos, 2.0, BLU_SPH_POS));\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    return t;\n}\n\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n// Version that returns t value and the ID of the object hit\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = sphere(pos, 2.0, RED_SPH_POS);\n    float t2;\n    obj = 0; // 0 is center sphere\n    if((t2 = sphere(pos, 2.0, GRN_SPH_POS)) < t) {\n        t = t2;\n        obj = 1; // 1 is left sphere\n    }\n    if((t2 = sphere(pos, 2.0, BLU_SPH_POS)) < t) {\n        t = t2;\n        obj = 2; // 2 is right sphere\n    }\n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 3; // 3 is floor\n    }\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 79, 79, 527], [529, 529, 593, 593, 838], [841, 841, 899, 899, 1474], [1476, 1476, 1516, 1516, 2527], [2529, 2529, 2586, 2636, 2919]], "test": "untested"}
{"id": "dsKcRR", "name": "\"Almost\"-Linear Interpolation", "author": "Tech_", "description": "Interpolation that is very close to linear interpolation, but has a derivative of zero at both endpoints of the interpolation curve. (Derived from integrating a normalized semicircle from 0 to 1)", "tags": ["interpolation"], "likes": 0, "viewed": 170, "published": 3, "date": "1695737283", "time_retrieved": "2024-07-30T17:31:40.638664", "image_code": "float Interpolate(float x)\n{\n    return 2.0 / radians(180.0) * (sqrt(x * (1.0 - x)) * (2.0 * x - 1.0) + asin(sqrt(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ar = vec2(iResolution.y / iResolution.x, 1.0);\n\n    // Time varying pixel color\n    vec3 col;\n\n    float n = 20.0;\n    vec2 gridCoord = floor(uv * n / ar) / n * ar;\n    vec2 fracCoord = fract(uv * n / ar);\n    vec3 offset    = vec3(1.0 / n * ar, 0.0);\n    \n    vec3 bl = textureLod(iChannel0, gridCoord            , 0.0).rgb;\n    vec3 br = textureLod(iChannel0, gridCoord + offset.xz, 0.0).rgb;\n    vec3 tl = textureLod(iChannel0, gridCoord + offset.zy, 0.0).rgb;\n    vec3 tr = textureLod(iChannel0, gridCoord + offset.xy, 0.0).rgb;\n    \n    if (sin(iTime * 0.4) * 0.5 + 0.5 < uv.x)\n        col = mix(mix(bl, br, Interpolate(fracCoord.x)), mix(tl, tr, Interpolate(fracCoord.x)), Interpolate(fracCoord.y));\n    else\n        col = mix(mix(bl, br, fracCoord.x), mix(tl, tr, fracCoord.x), fracCoord.y);\n        \n    col *= step(0.001, abs(uv.x - sin(iTime * 0.4) * 0.5 - 0.5));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 121], [123, 123, 180, 230, 1211]], "test": "untested"}
{"id": "cdX3Rs", "name": "voiseed", "author": "gottae", "description": "- blob \nblue", "tags": ["noise", "random", "static", "generator"], "likes": 2, "viewed": 127, "published": 3, "date": "1695736967", "time_retrieved": "2024-07-30T17:31:41.588126", "image_code": "#define PI 3.1415926\n\n\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nfloat noise( in vec2 p) {\n    return sin(p.x) * sin(p.y);\n}\n\nfloat fbm4(vec2 p) {\n    float f = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        f += 1.5 * .1 * noise(p * i);\n        p = m * p * abs(i - 2.) * 2.3;\n    }\n\n    return f / 0.99999990;\n}\n\nvec2 fbm4_2(vec2 p) {\n    return vec2(fbm4(p), fbm4(p + vec2(7.8)));\n}\n\nfloat coreCalc(vec3 pos, int i) {\n\n    vec3 p = pos;\n\n    p.xz *= rotation(3.1415926 * iTime * .1 * float(i) + float(i));\n\n    float d = length(p) - .5 + (fbm4_2(p.xz).y * 1.5 * fbm4_2(p.xy).x * 1. * cos(p).y * 1.) * .6;\n\n    return d;\n}\n\nfloat map(vec3 pos) {\n\n    vec3 p = pos;\n\n    float d = coreCalc(p, 1);\n\n    float bg = length(pos) - .1;\n\n    d = mix(d, .1, bg);\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float tt = iTime * .4;\n\n    uv = (uv - .5) * 2.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 origin = vec3(cos(tt) * -1.2, 0.0, sin(tt) * -1.2);\n    vec3 ta = vec3(0.0, 0., 0.0);\n\n    origin = vec3(0., 0., -1.);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = origin + ray * t;\n        float distance = map(p);\n        t += distance * 0.9999;\n    }\n\n    vec3 col = vec3(0.0);\n    vec3 lig = normalize(vec3(.57703));\n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.066,0.077,0.465));\n\n        col = spe + vec3(0.980,0.980,0.980) * amb + vec3(0.216,0.338,0.500) * dif + vec3(0.119,0.422,0.615);\n    }\n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n    \n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"power 1000w\",\n\t\"description\": \"voiseed\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdX3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 48, 48, 114], [158, 158, 183, 183, 217], [219, 219, 239, 239, 409], [411, 411, 432, 432, 481], [483, 483, 516, 516, 720], [722, 722, 743, 743, 869], [871, 917, 948, 948, 1196], [1198, 1198, 1253, 1303, 2716]], "test": "untested"}
{"id": "csKczz", "name": "3D Surface Tension", "author": "wyatt", "description": "200 x 200 x 150 simulation. ", "tags": ["fluid"], "likes": 13, "viewed": 307, "published": 3, "date": "1695733356", "time_retrieved": "2024-07-30T17:31:42.593438", "image_code": "#define R3 vec3(200,200,25)\n#define R2 vec2(1000,1000)\nvec2 _3D (vec3 u) {\n    u = clamp(u,vec3(0),R3-1.);\n    u = floor(u);\n    return .5+u.xy+R3.xy*vec2(mod(u.z,R2.x/R3.x),floor(u.z*R3.x/R2.x));\n}\nvec3 _3D (vec2 u) {\n    u = floor(u);\n    return .5+vec3(mod(u,R3.xy),floor(u.x/R3.x)+R2.x/R3.x*floor(u.y/R3.y));\n}\nint face (vec3 dir){\n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        return 0;\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        return 1;\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        return 2;\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        return 3;\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        return 4;\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        return 5;\n    } else return -1;\n}\nvec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\nvec4 G (vec3 V) {\n    int i = int(floor(V.z/R3.z));\n    V.z = mod(V.z,R3.z);\n    return H(_3D(V),i);\n}\nvec4 T (vec3 u) {\n    u -= .5;\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f);\n    vec4 _001 = G(vec3(f.xy,c.z));\n    vec4 _010 = G(vec3(f.x,c.y,f.z));\n    vec4 _011 = G(vec3(f.x,c.yz));\n    vec4 _100 = G(vec3(c.x,f.yz));\n    vec4 _101 = G(vec3(c.x,f.y,c.z));\n    vec4 _110 = G(vec3(c.xy,f.z));\n    vec4 _111 = G(c);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\nMain {\n    if (iFrame % 2 != 0) discard;\n    Q = vec4(0);\n    float dx = 0., dy = 0.1;\n    if (iMouse.z>0.) dx = 2.*(iMouse.x/R.x-.5), dy = 2.*(iMouse.y/R.y-.5);\n    vec2 V = (U-.5*R)/R.y*R3.y+.5*R3.xy;\n    float t = .2*sin(iTime);\n    mat2 m = mat2(cos(t),sin(t),-sin(t),cos(t));\n    if (V.x<0.||V.y<0.||R3.x-V.x<0.||R3.y-V.y<0.) Q = vec4(.4,.6,1,1);\n    else for (float z = 0.; z < 6.*R3.z-1.; z++) {\n        vec3 v = vec3(V,z);\n        v.xy -= .5*R3.xy;\n        v.xy *= 1.+.004*z;\n        v.y -= .1*z;\n        v.xy += .5*R3.xy;\n        if (v.x<1.||v.y<1.||R3.x-v.x<1.||R3.y-v.y<1.) ;\n        else\n        Q += G(v).w/150.;\n    }\n    Q = sin(-2.+4.*sqrt(Q)+vec4(1,2,3,4));\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,1));\n    t = 0.*iTime;\n    d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    //Q = texture(iChannel0,d).wwww*(.5+texture(iChannel0,d));\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage (out vec4 Q, in vec2 U) \n\n", "cube_a_code": "#define R3 vec3(200,200,25)\n#define R2 vec2(1000,1000)\nvec2 _3D (vec3 u) {\n    u = clamp(u,vec3(0),R3-1.);\n    u = floor(u);\n    return .5+u.xy+R3.xy*vec2(mod(u.z,R2.x/R3.x),floor(u.z*R3.x/R2.x));\n}\nvec3 _3D (vec2 u) {\n    u = floor(u);\n    return .5+vec3(mod(u,R3.xy),floor(u.x/R3.x)+R2.x/R3.x*floor(u.y/R3.y));\n}\nint face (vec3 dir){\n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        return 0;\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        return 1;\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        return 2;\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        return 3;\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        return 4;\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        return 5;\n    } else return -1;\n}\nvec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\nvec4 G (vec3 V) {\n    V = clamp(V,vec3(0),R3*vec3(1,1,6)-vec3(0,0,1));\n    int i = int(floor(V.z/R3.z));\n    V.z = mod(V.z,R3.z);\n    return H(_3D(V),i);\n}\nvec4 T (vec3 u)  {\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f);\n    vec4 _001 = G(vec3(f.xy,c.z));\n    vec4 _010 = G(vec3(f.x,c.y,f.z));\n    vec4 _011 = G(vec3(f.x,c.yz));\n    vec4 _100 = G(vec3(c.x,f.yz));\n    vec4 _101 = G(vec3(c.x,f.y,c.z));\n    vec4 _110 = G(vec3(c.xy,f.z));\n    vec4 _111 = G(c);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\nvec3 vel (vec3 v) {\n    return v*inversesqrt(1.+dot(v,v));\n}\nvoid mainCubemap( out vec4 Q, in vec2 U, in vec3 _, in vec3 d )\n{\n    if (U.x>R2.x||U.y>R2.y) {Q = vec4(0); return;}\n    int f = face(d);\n    vec3 V = _3D(floor(U))+R3*vec3(0,0,f);\n    Q = G(V);\n    vec4 dQ = vec4(0);\n    if (iFrame % 2 == 0) {\n        for(int x=-1;x<=1;x++)\n        for(int y=-1;y<=1;y++)\n        for(int z=-1;z<=1;z++)  if(abs(x)!=abs(y)&&abs(y)!=abs(z))\n        {\n            vec3 v = vec3(x,y,z);\n            vec3 w = V+v;\n            if (w.x<2.||w.y<2.||w.z<2.||R3.x-w.x<2.||R3.y-w.y<2.||6.*R3.z-w.z<2.)\n            {\n                dQ += 1./6.*Q.w*vec4(Q.xyz,1);\n            }\n            else \n          {\n              vec4 q = G(w);\n            vec3 a = vel(Q.xyz),\n                 b = vel(q.xyz)+v;\n           float ab = dot(v,b-a);\n           float i = dot(v,(0.5*v-a))/ab;\n               float j = .5+.5*max(1.-q.w,0.);\n               float k = .5+.5*max(1.-Q.w,0.);\n               float wa = (1./6.+.00005)*Q.w*min(i,j)/j;\n               float wb = (1./6.+.00005)*q.w*max(k+i-1.,0.)/k;\n               dQ += vec4(Q.xyz,1)*wa+vec4(q.xyz,1)*wb;\n          }\n\n        }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    if (V.x < 2. || V.y < 2.|| V.z < 2.|| \n            R3.x-V.x < 2.|| R3.y-V.y < 2. || R3.z*6.-V.z < 2.)\n            Q *= 0.;\n    } else {\n        Q.y -= .0005;\n        for(int x=-1;x<=1;x++)\n        for(int y=-1;y<=1;y++)\n        for(int z=-1;z<=1;z++)  if(abs(x)!=abs(y)&&abs(y)!=abs(z)) {\n            vec3 v = vec3(x,y,z);\n            vec4 q = G(V+v);\n            Q.xyz -= .06*q.w*(q.w-1.)*v;\n        }\n        if (V.x < 2. || V.y < 2.|| V.z < 2.|| \n            R3.x-V.x < 2.|| R3.y-V.y < 2. || R3.z*6.-V.z < 2.)\n            Q *= vec4(0,0,0,.99);\n        \n        //float t = float(iFrame)/200.;\n        //if (length(V-vec3(.1,.8,.5*6.)*R3) < 8.) Q = vec4(+.8+.0*sin(t),.0*cos(t),.05*sin(.76*t),1);\n        //if (length(V-vec3(.9,.8,.5*6.)*R3) < 8.) Q = vec4(-.8+.0*sin(t),.0*cos(t),.05*sin(.86*t),1);\n        \n    }\n    if (iFrame < 100) {\n        if (V.y < .4*R3.y) Q.w = 1.+.003*(.4*R3.y-V.y);\n        if (length(V-vec3(.5,.8,3.)*R3) < 25.) Q.w = .8,Q.y=-.6;\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 74, 74, 198], [199, 199, 218, 218, 314], [315, 315, 335, 335, 770], [771, 771, 795, 795, 1248], [1249, 1249, 1266, 1266, 1351], [1352, 1352, 1369, 1369, 1969]], "test": "untested"}
{"id": "ml3Xz7", "name": "Flowerpot", "author": "z0rg", "description": "Bleep bloop", "tags": ["flower", "cyberpunk", "japan"], "likes": 18, "viewed": 277, "published": 3, "date": "1695721179", "time_retrieved": "2024-07-30T17:31:43.455134", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed*123.456)*123.456);\n}\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a); \n    return mat2(c, -s, s, c);\n}\n// Thanks IQ :)\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nvec3 rdrtree(vec2 uv, vec3 col, vec3 light)\n{\n  float sharp = iResolution.x*.5;\n  uv.x+= sin(uv.y*5.+uv.x*2.+iTime)*.02*sat(uv.y);\n  vec2 p = uv;\n  float trunk = 1000.;\n  for (float i = 0.;i<6.;++i)\n  {\n    float off = mix(.3,.05,i/7.);\n    p+= vec2(0.,-off*.5);\n    p*=r2d(.5*sat(i));\n    p+= vec2(0.,-off*.5);\n    p.x+= sin(p.y*20.)*.02;\n    p.x = abs(p.x);\n    vec2 pos = p;\n\n    float shape = _sqr(pos, vec2(.01,off*.45));\n    shape -=.0001\n    -texture(iChannel0,uv*.15).x*.007;\n    if(i<4.5)\n    {\n        trunk = smin(trunk, shape, .05);\n     }\n   else\n    {\n      float cir = length(p)-.06;\n      col = mix(col, vec3(0.957,0.333,0.286)*.7+light,\n        1.-sat(cir*sharp));\n\n    }\n  }\n  col = mix(col, vec3(0.086,0.173,0.145)*.05+light*.75,1.-sat(trunk*sharp));\n\n  return col;\n}\n\nfloat cloud(vec2 uv)\n{\n    return \n    (texture(iChannel0, uv*.05).x*.5\n    +texture(iChannel0, uv*.1*r2d(iTime*.05+uv.x*.2)).x*.2\n    +texture(iChannel0, uv*.2*r2d(-iTime*.02+uv.y*.5)).x*.2\n    +texture(iChannel0, uv*.33).x*.07)\n    *sat(texture(iChannel0, uv*.01).x-.2)\n    ;\n}\n\nvec3 rdr(vec2 uv)\n{\n    float sharp = iResolution.x*.5;\n    vec3 col = vec3(0.110,0.153,0.133)*(1.-sat(length(uv-.5)));\n    float fins = sat(200.*sin(uv.y*200.));\n    float shadow = rdrtree(uv*2.-vec2(1.,-0.5), vec3(1.), vec3(0.)).z;\n    float boxwin = _sqr(uv-vec2(.4,.5), vec2(.2,.4));\n    col = mix(col, vec3(0.957,0.333,0.286), sat(.7+fins)*shadow*(1.-sat(boxwin*sharp)));\n    float boxwin2 = _sqr(uv-vec2(.4,.5)-.2, vec2(.2,.4));\n    vec3 light = 2.*vec3(0.957,0.333,0.286)*(1.-sat(boxwin2*sharp));\n\n    col = rdrtree(uv*2.-vec2(1.2,0.2), col, .25*light*sat(.7+fins));\n    \n    float box = _sqr(uv-vec2(.6,.1), vec2(.05,.1));\n    col = mix(col, vec3(0.), 1.-sat(box*sharp));\n    \n    col += .5*vec3(0.871,0.647,0.627)*cloud(uv)*sat(.7*length(uv-.5));\n       float boxwin3 = _sqr(uv-vec2(.4,.5)-.25, vec2(.2,.4));\n     \n         float finssmoke = mix(1.,sat((sin(uv.y*150.)*.5+.5)+.5), 1.-sat(boxwin3*sharp*.1));\n        float beat = texture(iChannel1, vec2(0.1, 0.)).x;\n        col += mix(0.5,2.,beat)*finssmoke*2.*vec3(0.631,0.690,0.871)*cloud(-uv*1.)*(1.-sat(1.7*length(uv-.5)));\n    col += 2.*vec3(0.957,0.333,0.286)*(1.-sat(length(uv-.5)*1.5))*.5;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    vec3 col = vec3(0.);\n    col = rdr(uv*1.5+.5);\n    col = pow(col, vec3(1.5));\n    //col += texture(iChannel0, uv).x;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34789, "src": "https://soundcloud.com/freeflowflava/012a?in=d9k6bdkryhkh/sets/japan-phonk&si=27e8934b3f6040b9867284d04b248fce&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3Xz7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 458, 458, 510], [512, 512, 536, 536, 583], [585, 585, 604, 604, 671], [672, 688, 731, 731, 830], [831, 831, 876, 876, 1617], [1619, 1619, 1641, 1641, 1898], [1900, 1900, 1919, 1919, 3074], [3076, 3076, 3133, 3133, 3347]], "test": "untested"}
{"id": "csVyRR", "name": "COPY 2", "author": "dj_afroedi", "description": "GREAT", "tags": ["edi"], "likes": 4, "viewed": 621, "published": 3, "date": "1695718490", "time_retrieved": "2024-07-30T17:31:44.375672", "image_code": "void mainImage(out vec4 A, vec2 F) {\n    vec2 r = iResolution.xy, u = (F+F-r)/r.y;    \n    A.rgb*=0.;\n\n    float autoStartTime = 0.0;\n    float timeFactor = 2.0; // mvmnt speed\n\n    for (float i; i<25.; A.rgb +=\n        .003/(abs(length(atan(u*u*u-u*u*u)-+tanh(u/u*u)/exp2(u*u))-i*.05)+.0009)\n        * (cos(i+vec3(3.9,5.,2.54534))+001.)                           \n        * smoothstep(.5,.9, abs(tan((length(mod(max(iTime-autoStartTime, 0.0),2.)-i*.1)-1.))))\n    ) {\n        // smoother mvmnt\n        float oscillation = atan(iTime * timeFactor) * 0.1;\n        u += oscillation * vec2(sin(iTime), sin(iTime));\n\n        // mvmnt transformations\n        u *= mat2(cos((iTime+autoStartTime+i++)*.01 + vec4(0,33,11,0)));\n    }\n\n    // audio\n    float audioAmplitude = texture(iChannel0, vec2(1.)).r * 2.0; \n    A.rgb *= audioAmplitude;\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 834]], "test": "untested"}
{"id": "msyczz", "name": "COPY 1", "author": "dj_afroedi", "description": "MIX", "tags": ["edi"], "likes": 4, "viewed": 267, "published": 3, "date": "1695717363", "time_retrieved": "2024-07-30T17:31:45.241358", "image_code": "\n\n#define SAMPLE_WIDTH 8.0\n\nvec3 yLine(vec2 uv,float y, float thickness){\n    float colwave = thickness /  abs(uv.y+y);\n    return vec3(colwave);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) { \n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n    \n    // Average together some of the lower samples to get the circle to pulse to the music.\n    float avgAmp = 0.0;\n    for (float i = 0.0; i < SAMPLE_WIDTH; ++i)\n    {\n        avgAmp += texelFetch(iChannel0, ivec2(8 + int(i), 1), 0).x * (1.0 / SAMPLE_WIDTH);\n    }\n    // Most times the average Amplitude is between [0.1, 0.9], so we map that range to 0, 1\n    // for a fuller pulsing effect.\n    avgAmp = (clamp(avgAmp, 0.1, 0.9) - 0.1) * 1.25;\n    \n    col += length(uv) / max(avgAmp, 0.1);\n    col += yLine(uv, sin(uv.x + iTime * 1.0) + sin(uv.y + iTime * 1.0), 0.01);\n    col += yLine(uv, sin(uv.x + iTime * 0.2) + cos(uv.y + iTime * 2.0), 0.01);\n    col += yLine(uv, sin(uv.x + iTime * 4.0) + sin(uv.y + iTime * 0.5), 0.01);\n    col += yLine(uv, cos(uv.x + iTime * 0.2) + sin(uv.y + iTime * 1.5), 0.01);\n    // In the original the color keeps increasing past the edge of the circle so the whole screen is white,\n    // this makes the color falloff back to zero the brighter it gets so we get a ring.\n    col = max(-abs(col - 2.0) + 2.0, 0.0);\n\n    // Change ivec2 x values to sample different frequencies.\n    float r = avgAmp * col.x;\n    float g = texelFetch(iChannel0, ivec2(250,0), 0).x * col.y;\n    float b = texelFetch(iChannel0, ivec2(500,0), 0).x * col.z;\n    \n    // Takes the lowest color value and reduces it by the min difference between the other two color channels.\n    // This is done to have colors pop more often and only be white when all frequencies are around the same\n    // amplitude.\n    if (r < g && r < b)\n    {\n        r *= 1.0 - max(g - r, b - r);\n    }\n    \n    if (g < r && g < b)\n    {\n        g *= 1.0 - max(r - g, b - g);\n    }\n    \n    if (b < r && b < g)\n    {\n        b *= 1.0 - max(r - b, g - b);\n    }\n    \n    vec3 finalColor = col * vec3(r,g,b);\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 73, 73, 147], [149, 149, 205, 205, 2158]], "test": "untested"}
{"id": "mdGczz", "name": "COPY", "author": "dj_afroedi", "description": "DEEP HOLE", "tags": ["edi"], "likes": 1, "viewed": 192, "published": 3, "date": "1695714443", "time_retrieved": "2024-07-30T17:31:46.160899", "image_code": "float s;\n\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .5, cos(z * .5), z);\n    p.x+=p.y*p.x*2.;\n    return p;\n}\n\nvec3 fractal(vec3 p)\n{\n    float z = p.z * .1;\n    p.z = abs(.5 - fract(z));\n    float m = 100.;\n    for (int i = 0; i < 10; i++)\n    {\n        p.xy *= rot(z);\n        p = abs(p * (1.5+sin(z*3.)*.2)) - 2.;\n        m = min(m, abs(p.y) + .5 * abs(.5 - fract(p.x * .25 + iTime + float(i) * .1)));\n    }\n    m = exp(-8. * m) * 2.;\n    return vec3(p.xz * 2., m) * m + .5;\n}\n\nfloat g=0.;\nvec3 lpos;\n\nfloat de(vec3 p)\n{\n    float d=length(p-lpos)-s*.2;\n    p.xy -= path(p.z).xy;\n    g+=.003/(.1+d*5.);\n    return min(d,-length(p.xy) + .3);\n}\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float d, td = 0.;\n    vec3 p, col = vec3(0);\n    for (int i = 0; i < 80; i++)\n    {\n        p = from + dir * td;\n        d = de(p);\n        if (d < .001) break;\n        td += d;\n    }\n    if (d < .1) \n    {\n        p -= .001 * dir;\n        col = fractal(p) * exp(-1. * td * td) * smoothstep(.3, 1., td);\n    }\n    return (col+g)*(.3+s*4.);\n}\n\nmat3 lookat(vec3 dir, vec3 up) {\n    dir = normalize(dir);\n    vec3 rt = normalize(cross(dir, normalize(up)));\n    return mat3(rt, cross(rt, dir), dir);\n}\n\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/20.;\n}\n\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     s=getSound();\n     vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    float t = iTime;\n    vec3 from = path(t);\n    lpos = path(t+1.);\n    vec3 fw = normalize(path(t + .5) - from);\n    vec3 dir = normalize(vec3(uv, 1));\n    dir = lookat(fw, vec3(0, 1, 0)) * dir;\n    vec3 col = march(from, dir);\n    texto(col, vec2(-0.35,-0.4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "buffer_a_code": "// ↙\n//  ↙\n//   ↙\n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 35.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t _ _ _ _ _ _ _ _ _ _ D J A F R O E D I _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 29, 29, 95], [98, 98, 118, 118, 203], [205, 205, 227, 227, 573], [599, 599, 617, 617, 739], [741, 741, 774, 774, 1120], [1122, 1122, 1154, 1154, 1276], [1278, 1278, 1297, 1297, 1470], [1472, 1472, 1513, 1513, 1666], [1669, 1669, 1726, 1726, 2108]], "test": "untested"}
{"id": "msGyzR", "name": "DURIAN NAGA", "author": "zhonkvision", "description": "Exploring VJ Loops with RED Durian Naga", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 3, "viewed": 180, "published": 3, "date": "1695703969", "time_retrieved": "2024-07-30T17:31:47.039550", "image_code": "vec3 palette(float d) {\n    vec3 neonGreen = vec3(1, 0.5, 0.1); // Neon Green\n    vec3 darkerGreen = vec3(1, 0.0, 0.1); // Darker Green\n    return mix(neonGreen, darkerGreen, d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.05;\n    for (int i = 0; i < 10; ++i) {\n        float t = angle;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 7.3);\n        p.xz = abs(p.xz);\n        p.xz -= 0.2;\n    }\n    \n    float durian = length(p.xy) - 0.4; // Create a circular durian shape\n    \n    return durian;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 1.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i <2114.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 200.0) {\n            break;\n        }\n        col += palette(length(p) * 0.15) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 80.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -110.0);\n    ro.xz = rotate(ro.xz, iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.2, 0.1, 0.1)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 180], [182, 182, 212, 212, 292], [294, 294, 313, 313, 632], [634, 634, 661, 661, 1044], [1046, 1046, 1101, 1101, 1527]], "test": "untested"}
{"id": "dsyyRR", "name": "6 Fluids", "author": "wyatt", "description": "For some reason when using the cubemap, the fluid dissipates slowly... same code using a buffer does not have that problem.. is cubemap lower precision?", "tags": ["fluid"], "likes": 6, "viewed": 257, "published": 3, "date": "1695698327", "time_retrieved": "2024-07-30T17:31:47.795529", "image_code": "#define R iResolution.xy\n\nvec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    U = (U-.5*R)/R.y*1024.+512.;\n    Q = vec4(0);\n    for (int i = 0; i < 6; i++) {\n        vec4 q = H(U,i);\n        Q += q.w*max(sin(.3*float(i)*vec4(1,2,3,4)),0.);\n    }\n    //Q = 1.-Q;\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "int face (vec3 dir){\n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        return 0;\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        return 1;\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        return 2;\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        return 3;\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        return 4;\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        return 5;\n    } else return -1;\n}\nvec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\nvec2 vel(vec2 v) {\n    return .5*v*inversesqrt(1.+.1*dot(v,v));\n}\nvoid mainCubemap( out vec4 Q, in vec2 U, in vec3 _, in vec3 d )\n{\n    int f = face(d);\n    Q = H(U,f);\n    if (iFrame % 2 == 0) {\n        for(int x=-1;x<=1;x++)\n        for(int y=-1;y<=1;y++)  if(abs(x)!=abs(y))\n        {\n            vec2 u = vec2(x,y);\n            vec4 q = H(U+u,f);\n            float k = 0.;\n            for(int i = 0; i < 6; i++)   {\n                k += H(U+u,i).w;\n            }\n            Q.xy -= .08*(q.w*(q.w-1.)+k)*u;\n        }\n        Q.y -= 3e-4*sin(float(f));\n        if (length(Q.xy)>.5)Q.xy = .5*normalize(Q.xy);\n        if (U.x < 3.||1024.-U.x < 3.) Q.x *= 0.;\n        if (U.y < 3.||1024.-U.y < 3.) Q.y *= 0.;\n        if (iFrame < 3) {\n            Q.w = .2+.1*sin(.5*U.x+float(f))+.1*sin(.5*U.y+float(f*f));\n        }\n    \n    } else {\n       \n        vec4 dQ = vec4(0);\n\n        for(int x=-1;x<=1;x++)\n        for(int y=-1;y<=1;y++)  if(abs(x)!=abs(y))\n        {\n            vec2 u = vec2(x,y);\n            {\n                vec4 q = H(U+u,f);\n                vec2 a = vel(Q.xy),\n                     b = vel(q.xy)+u;\n               float ab = dot(u,b-a);\n               float i = dot(u,(0.5*u-a))/ab;\n              {\n                   float j = .5+.5*max(1.-q.w,0.);\n                   float k = .5+.5*max(1.-Q.w,0.);\n                   float wa = 0.25008*Q.w*min(i,j)/j;\n                   float wb = 0.25008*q.w*max(k+i-1.,0.)/k;\n                    dQ += vec4(Q.xyz,1)*wa+vec4(q.xyz,1)*wb;\n              }\n           }\n\n        }\n        if (dQ.w>0.)dQ.xyz/=dQ.w;\n        Q = dQ;\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 50, 50, 503], [504, 504, 545, 545, 735]], "test": "untested"}
{"id": "ms3yDB", "name": "double pendulum", "author": "Dolfun", "description": "double pendulum", "tags": ["doublependulum"], "likes": 6, "viewed": 124, "published": 3, "date": "1695694529", "time_retrieved": "2024-07-30T17:31:48.801838", "image_code": "const float r0 = 0.025;\nconst float r1 = r0 * sqrt(m1);\nconst float r2 = r0 * sqrt(m2);\nconst float thk = 0.0025;\nvec3 draw_pendulum(vec3 color, vec2 uv, vec4 state) {\n    float th1 = state.x, th2 = state.y, w1 = state.z, w2 = state.w;\n    vec2 pos1 = l1 * vec2(sin(th1), -cos(th1));\n    vec2 pos2 = pos1 + l2 * vec2(sin(th2), -cos(th2));\n    color = mix(vec3(0.9), color, smoothstep(0.0, aa, sdf_circle(uv, 0.01)));\n    color = mix(vec3(0.9), color, smoothstep(0.0, aa, sdf_circle(uv - pos1, r1)));\n    color = mix(vec3(0.9), color, smoothstep(0.0, aa, sdf_circle(uv - pos2, r2)));\n    color = mix(vec3(0.9), color, smoothstep(0.0, aa, sdf_seg(uv, vec2(0.0), pos1, thk)));\n    color = mix(vec3(0.9), color, smoothstep(0.0, aa, sdf_seg(uv, pos1, pos2, thk)));\n    return color;\n}\n\nvec3 draw_energy_bar(vec3 color, vec2 uv, vec4 state) {\n    float E0 = energy(state_0);\n    float E = energy(state);\n    float val = 0.1 * (E - E0) / abs(E0) + 0.5;\n    val = clamp(val, 0.0, 1.0);\n    float r = 0.02;\n    vec2 dim = vec2(0.01, 0.3);\n    vec2 pos = vec2(0.0, -(1.0-val)*dim.y);\n    float box = smoothstep(0.0, aa, sdf_box(uv-pos, dim*vec2(1.0, val)));\n    float border = smoothstep(0.0, aa, sdf_hollow_box(uv, dim+r, 0.0025));\n    vec2 v = vec2(dim.x+r*0.5, 0.0);\n    float line = smoothstep(0.0, aa, sdf_seg(uv,-v,v, 0.0025));\n    color = mix(vec3(0.9), color, box);\n    color = mix(vec3(0.9), color, border);\n    color = mix(vec3(0.9), color, line);\n    return color;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = (frag_coord * 2.0 - iResolution.xy) / iResolution.y;\n    vec4 state = fetch(iChannel0, STATE_ADDR);\n    \n    vec3 color = vec3(0.2);\n    color = draw_pendulum(color, uv, state);\n    if (iMouse.z > 0.0) color = draw_energy_bar(color, uv - vec2(-1.5, 0.0), state);\n    \n    vec3 trail = fetch(iChannel1, frag_coord).rgb;\n    color += trail;\n    \n    frag_color = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 f(vec4 state) {\n    float th1 = state.x, th2 = state.y, w1 = state.z, w2 = state.w;\n    float cth = cos(th1-th2), sth = sin(th1-th2);\n    float den = m1+m2*sth*sth;\n    float a1 = (m2*g*sin(th2)*cth-m2*sth*(l1*w1*w1*cth+l2*w2*w2)-(m1+m2)*g*sin(th1))/(l1*den);\n    float a2 = ((m1+m2)*(l1*w1*w1*sth-g*sin(th2)+g*sin(th1)*cth)+m2*l2*w2*w2*sth*cth)/(l2*den);\n    a1 -= damping * w1;\n    a2 -= damping * w2;\n    return vec4(w1, w2, a1, a2);\n}\n\nvec4 simple_integrate(vec4 state, float h) {\n    return state + h * f(state);\n}\n\nvec4 rk_integrate(vec4 state, float h) {\n    vec4 k1 = h*f(state);\n    vec4 k2 = h*f(state + 0.5*k1);\n    vec4 k3 = h*f(state + 0.5*k2);\n    vec4 k4 = h*f(state + k3);\n    return state + (k1+2.0*k2+2.0*k3+k4)/6.0;\n}\n\nvoid mainImage(out vec4 state, in vec2 frag_coord) {\n    if (to_store(frag_coord, STATE_ADDR)) {\n        state = state_0;\n    } else if (to_store(frag_coord, PREV_STATE_ADDR)) {\n        state = state_0;\n    }\n    if (iFrame > 0) {\n        if (to_store(frag_coord, STATE_ADDR)) {\n            state = fetch(iChannel0, STATE_ADDR);\n            float dt = iTimeDelta;\n            state = rk_integrate(state, dt);\n        } else if (to_store(frag_coord, PREV_STATE_ADDR)) {\n            state = fetch(iChannel0, STATE_ADDR);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define fetch(buf, addr) texelFetch(buf, ivec2(addr), 0)\n#define to_store(buf_pos, addr) (ivec2(buf_pos) == addr)\n\nconst ivec2 STATE_ADDR = ivec2(0, 0);\nconst ivec2 PREV_STATE_ADDR = ivec2(1, 0);\nconst float pi = 3.14159265359;\nconst float l1 = 0.4;\nconst float l2 = 0.5;\nconst float g = 9.81;\nconst float m1 = 1.0;\nconst float m2 = 1.0;\nconst vec4 state_0 = vec4(0.5*pi, 1.5*pi, 0.0, -10.0);\nconst float damping = 0.0;\n\n// anti-aliasing\nconst float aa = 0.0025;\n\nfloat energy(vec4 state) {\n    float th1 = state.x, th2 = state.y, w1 = state.z, w2 = state.w;\n    float T = 0.5*((m1+m2)*l1*l1*w1*w1+m2*l2*l2*w2*w2+m2*l1*l2*w1*w2*cos(th1-th2));\n    float V = -(m1+m2)*g*l1*cos(th1)-m2*g*l2*cos(th2);\n    return T + V;\n}\n\nfloat sdf_circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdf_seg(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdf_box(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdf_hollow_box(vec2 p, vec2 b, float r) {\n    return abs(sdf_box(p, b)) - r;\n}", "buffer_b_code": "vec2 pos(vec4 state) {\n    float th1 = state.x, th2 = state.y;\n    return vec2(l1*sin(th1)+l2*sin(th2), -l1*cos(th1)-l2*cos(th2));\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = (frag_coord * 2.0 - iResolution.xy) / iResolution.y;\n    float dt = iTimeDelta;\n    vec2 curr = pos(fetch(iChannel0, STATE_ADDR));\n    vec2 prev = pos(fetch(iChannel0, PREV_STATE_ADDR));\n    float t = smoothstep(0.0, aa, sdf_seg(uv, curr, prev, 0.005));\n    \n    vec3 color = fetch(iChannel1, frag_coord).rgb;\n    if (color.x > 0.0) color -= 0.1 * dt;\n    color = mix(vec3(0.4), color, t);\n    \n    frag_color = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3yDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 167, 167, 779], [781, 781, 836, 836, 1467], [1469, 1469, 1526, 1526, 1921]], "test": "untested"}
{"id": "csyyzz", "name": "Red Plaid", "author": "OwenTheProgrammer", "description": "Just some standard ass plaid but veryyyy smalll.", "tags": ["procedural", "2d"], "likes": 2, "viewed": 144, "published": 3, "date": "1695693930", "time_retrieved": "2024-07-30T17:31:49.716393", "image_code": "//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//    const float LINE_COUNT = 40.0;\n//    vec2 uv = fragCoord / iResolution.xy;\n//\n//    //sqrt(2)/2 = skew(45deg) = slope of y=1x\n//    //making y in [0,1] relative to x in [0,1] space 1/1 slope, so x - y = skew 45\n//    float skew = uv.x - uv.y;\n//    \n//    //loop by LINE_COUNT\n//    float stripes = fract(LINE_COUNT * skew);\n//    \n//    //(x + y) / 2 = 0.5(x + y) = 0.5x + 0.5y = dot(xy, 0.5)\n//    //where [0,0] = 0, [0,1] = 0.5, [1,0] = 0.5, [1,1] = 1.0\n//    float quadrant = dot(round(uv), vec2(0.5));\n//    \n//    //Biased line width per quadrant\n//    float color = stripes < quadrant;\n//    \n//    fragColor = vec4(color, 0.0, 0.0, 1.0);\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 u = fragCoord / iResolution.xy;\n    fragColor = vec4(fract(40.0*(u.x-u.y))<dot(round(u),vec2(0.5)), 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csyyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[717, 717, 774, 774, 901]], "test": "untested"}
{"id": "mddcDl", "name": "grey disk illusion", "author": "elenzil", "description": "optical illusion I got from \"Professor Smart\" at the washington state fair.\nhttp://www.professorsmart.info/science-shows-for-schools\nBUT IT DOESN'T WORK ON THE SCREEN - see code comments.\n", "tags": ["illusion"], "likes": 8, "viewed": 205, "published": 3, "date": "1695673371", "time_retrieved": "2024-07-30T17:31:50.576094", "image_code": "// An optical illusion I got from a flyer for \"Professor Smart\"\n// http://www.professorsmart.info/science-shows-for-schools\n//\n// BUT IT DOESN'T WORK ON THE SCREEN.\n// Presumably because my display only goes up to 60Hz.\n//\n// The effect should be a distinct grey disk in the middle of the spinning coin.\n\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst float pi   = 3.14159265359;\n\n// parameters\nconst float zoom       = 0.5;\nconst float background = 1.0;\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 xy = (XY * 2.0 - RES) / MINRES / zoom;\n    \n    float t = texelFetch(iChannel0, ivec2(0), 0).r;\n    t *= 25.0;    \n    \n    xy += 0.4 * vec2(cos(t), sin(t));\n    \n    float angle       = atan(xy.y, xy.x);\n    float repeated    = mod(angle * 10.0, pi * 2.0);\n    float u           = cos(repeated);\n    \n    float r   = length(xy);\n    \n    float c   = smoothstep(0.0, 1.2 - r, u);\n    \n    \n    float eps = 4.0 / MINRES / zoom;\n    \n    c = mix(c, 0.0             , smoothstep(-eps, eps, r - 1.0));\n    c = mix(c, background * 0.5, smoothstep(-eps, eps, r - 1.03));\n    c = mix(c, background      , smoothstep(-eps, eps, r - 1.06));\n\n    RGBA.rgb = vec3(c);\n    RGBA.a   = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = texelFetch(iChannel0, ivec2(0), 0).r;\n    float f = texelFetch(iChannel0, ivec2(0), 0).g;\n    \n    float target = iMouse.z < 1.0 ? 1.0 : 0.0;\n    \n    f = clamp(0.0, 1.0, mix(f, target, 8.0 * iTimeDelta));\n    t += iTimeDelta * f;\n    \n    fragColor = vec4(t, f, 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 529, 529, 1217]], "test": "untested"}
{"id": "DdccWX", "name": "Eye of the Jellybean Dragon", "author": "DigitalShadow", "description": "Big thanks to IQ for the smooth distance function   (https://iquilezles.org/articles/msetsmooth/)", "tags": ["fractal", "chaos", "strangeattractor", "microphone", "escapemap"], "likes": 1, "viewed": 191, "published": 3, "date": "1695668324", "time_retrieved": "2024-07-30T17:31:51.754943", "image_code": "const float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvF = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n    float cycle = mod(iTime, 3.)/3.;\n    fragColor = texture(iChannel0, vec2(1.0-uv.x, 1.0-uv.y));  \n\n\n    //cycle hue\n    vec3 hsv=RGBtoHSV(fragColor.rgb);\n    hsv.r = mod(hsv.r + iTime / 10. + pow((0.5+0.5*cos(iTime/4.)),16.) + length(uvF)/24., 1.0);\n    hsv = HSVtoRGB(hsv);\n    fragColor.rgb = hsv;   \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define itr 50          //number of iterations\n#define maxL 1000.      //maxiumum escape length\n#define fade .33        //new to old image update ratio\n#define eqBands 12.     //number of equalizer bands to track\n#define freqPerBand 20. //subdivision of equalizer bandss\n#define reactAmt 0.02   //audio react ammount\n#define sweepAmt 1.0    //cofficient sweep ammount\n#define useMax 0        //equalizer band method; 0=average, 1=maximum\n\n//rotation matrix\nmat2 rotM(float a)\n{\n\ta *= 3.14159 / 180.0;\n    float s=sin(a), c=cos(a);\n    return mat2( c, -s, s, c );\n}\n\n//get value of EQ band\nfloat getBand(float x)\n{\n    float band = floor(x*eqBands);\n    float coarseSpacing = 1.0 / eqBands;\n    float fineSpacing = coarseSpacing / freqPerBand;\n    float start = coarseSpacing * band;\n    float val = 0.0;\n    float c;\n    for(float i=0.0; i < freqPerBand; i++)\n    {\n        c=(start + fineSpacing * i);\n        c = c*c; //better frequency response curve\n        #if useMax\n            val = max(val, texture(iChannel0, vec2(c, 0.25)).r);\n        #else\n            val += texture(iChannel0, vec2(c, 0.25)).r;\n        #endif\n    }\n    \n    if (useMax==0) val /= freqPerBand;\n    return val;\n}\n\n\n//iterate formula\nint iterate(vec2 p, out float minD, out float maxD, out vec2 lastP){\n    //coefficients\n    float a1 =  -0.1 + reactAmt * getBand(0.0 / 12.0);\n    float a7 =  -0.9 + reactAmt* getBand(1.0 / 12.0);\n    float a2 =  -1.5  + reactAmt * getBand(2.0 / 12.0) + sweepAmt * sin(iTime/5.);\n    float a8 =   0.9 + reactAmt * getBand(3.0 / 12.0) + sweepAmt * cos(iTime/7.);   \n    float a3 =  -0.5 + reactAmt * getBand(4.0 / 12.0);\n    float a9 =   0.1 + reactAmt * getBand(5.0 / 12.0) + sweepAmt *cos(iTime/11.);   \n    float a4 =   0.1+ reactAmt * getBand(6.0 / 12.0) + sweepAmt * sin(iTime/17.);\n    float a10 = -0.3+ reactAmt * getBand(7.0 / 12.0);  \n    float a5 =  -0.8 + reactAmt * getBand(8.0 / 12.0);\n    float a11 = -1.5 + reactAmt * getBand(9.0 / 12.0);\n    float a6 =   0.2+ reactAmt * getBand(10.0 / 12.0);\n    float a12 =  0.0 + reactAmt * getBand(11.0 / 12.0)+ sweepAmt * cos(iTime/13.); \n    float x2, y2, xy;\n    vec2 o = p;  //point origin\n    float d;     //distance from origin\n    minD=1.0;    //max distance\n    maxD=0.0;    //min distance \n    int i=0;\n    while (i < itr){\n        x2 = p.x * p.x;\n        y2 = p.y * p.y;\n        xy = p.x * p.y;\n        p = vec2\n        (\n            a1 + a2*p.x + a3 *x2 + a4 *xy + a5 *p.y + a6 *y2, \n            a7 + a8*p.x + a9 *x2 + a10*xy + a11*p.y + a12*y2\n        ); \n        if (dot(p,p) > maxL*maxL) break;\n        d = (o.x-p.x)*(o.x-p.x) + (o.y-p.y)*(o.y-p.y);   //dot product works for smooth values, but doesn't produce sharp bands\n        minD = min(d, minD);\n        maxD = max(d, maxD);\n        i++;\n    }\n    minD = sqrt(minD);\n    maxD = sqrt(maxD);\n    lastP = p;\n    return i;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvF = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y* rotM(500.*sin(iTime / 23.));\n    vec2 lastP;\n    \n    float zoom = 20. + 3.5* getBand(0.) + 20.*pow(0.5 + .5* cos(iTime/3.),1.5);\n    float minD, maxD;\n    \n    //Measure how many iterations it takes to escape bounds\n    int i = iterate((uvF*20.0 - vec2(0.0,10.0))/zoom, minD, maxD, lastP);\n    \n    \n    //smoothing function\n    float t = float(i) - log2(log2(dot(lastP,lastP))) + 4.0;\n    t = t/float(itr);\n    \n    //mix existing image and new to temporally smooth pixel values\n    vec3 ghost = texture(iChannel1, uv).rgb;\n    ghost=max(vec3(0.),ghost);\n    \n    //color outside of fractal\n    vec3 col = 0.5 - 0.5 * sin(0. + 26. * t + (vec3(0.1,0.6,1.0) + maxD/maxL*smoothstep(0.1,0.8,max(0.0,getBand(1.)))));\n    \n    //use alternate black and white coloring inside fractal bounds\n    if(i >= itr-1) col = 0.5 + 0.5*cos(maxD/minD*vec3(1.0)); \n    \n    fragColor = vec4(mix(ghost, col, fade),1.0);\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdccWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 59, 140, 254], [256, 256, 284, 382, 664], [666, 666, 694, 743, 823], [825, 825, 853, 906, 1027], [1029, 1029, 1057, 1106, 1213], [1215, 1215, 1243, 1296, 1450], [1452, 1452, 1509, 1559, 1974]], "test": "untested"}
{"id": "DstyDl", "name": "ichannel Test", "author": "PedroLucas201441", "description": "Shader for test channel", "tags": ["sample"], "likes": 0, "viewed": 168, "published": 3, "date": "1695658668", "time_retrieved": "2024-07-30T17:31:52.622623", "image_code": "// Have fun with those values\n//\nconst float LENGTH = 120.0;\nconst float STRENGTH = 0.01;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y += sin(fragCoord.x / LENGTH + iTime) * STRENGTH;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordenadas de textura\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Amostra a textura do iChannel0\n    vec4 texColor = texture(iChannel0, uv);\n\n    // Define a cor de saída como a cor da textura\n    fragColor = texColor;\n}\n", "buffer_a_inputs": [{"id": 34781, "src": "https://soundcloud.com/fuiwxe/pr1svx-crystals-speed-up?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 146, 146, 288]], "test": "untested"}
{"id": "ds3cDs", "name": "3D Wood Blocks", "author": "wyatt", "description": "experiencing some compilation issues", "tags": ["rigidbodyphysics"], "likes": 3, "viewed": 341, "published": 3, "date": "1695654039", "time_retrieved": "2024-07-30T17:31:53.711711", "image_code": "// Fork of \"Mesh Collisions\" by wyatt. https://shadertoy.com/view/mdtcDN\n// 2023-09-25 13:13:36\n\nobj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,mat3(\n            A(6,i).xyz,\n            A(7,i).xyz,\n            A(8,i).xyz),\n        vec3(0),\n        vec3(0)\n    );\n}\nfloat absmin(float a, float b) {if (b < 0. ) return a; if (a < 0.) return b; if (b < a) return b; return a; }\nvoid tri (vec3 p, vec3 d, obj o, vec3 a, vec3 b, vec3 c, inout float x, inout vec3 n, inout vec4 q, int j) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    float i = iTriangle(p,d,a,b,c);\n    \n    if (i > 0. && i < x) {\n        x = i;\n        n = normalize(cross(b-a,c-a));\n        n *= -sign(dot(d,n));\n        q = vec4((p + d*i - o.m)*o.io  ,j);\n    }\n}\nvoid pla (vec3 p, vec3 d, vec3 no, inout float x, inout vec3 n) {\n    float i = iPlane(p,d,no);\n    if (i > 0. && i < x) {\n        x = i;\n        n = no;\n        n *= -sign(dot(d,n));\n    }\n}\nfloat scene (vec3 p, vec3 d, out vec3 n, out vec4 q) {\n    float x = 1e9;\n    n = vec3(0);\n    \n    pla(p-vec3(1,0,0),d,vec3(1,0,0),x,n);\n    pla(p-vec3(-1,0,0),d,vec3(1,0,0),x,n);\n    pla(p-vec3(0,0,1),d,vec3(0,0,1),x,n);\n    pla(p-vec3(0,0,-1),d,vec3(0,0,1),x,n);\n    pla(p-vec3(0,-.5,0),d,vec3(0,1,0),x,n);\n    q = vec4(p + d*x,0);\n   for (int i = 0;  i < N; i++) {\n        obj o = get(i);\n        \n        tri(p,d,o,_T1,x,n,q,i);\n        tri(p,d,o,_T2,x,n,q,i);\n        tri(p,d,o,_T3,x,n,q,i);\n        tri(p,d,o,_T4,x,n,q,i);\n        tri(p,d,o,_T5,x,n,q,i);\n        tri(p,d,o,_T6,x,n,q,i);\n        tri(p,d,o,_T7,x,n,q,i);\n        tri(p,d,o,_T8,x,n,q,i);\n        tri(p,d,o,_T9,x,n,q,i);\n        tri(p,d,o,_T10,x,n,q,i);\n        tri(p,d,o,_T11,x,n,q,i);\n        tri(p,d,o,_T12,x,n,q,i);\n    }\n    return x;\n}\nMain {\n    if ((iFrame+int(U.x+U.y)) % 2 == 0) discard;\n    vec3 p = vec3(0,0,-1.2),\n         d = normalize(vec3(2.*(U-.5*R)/R.y,1));\n    float t = -1.2;\n    p.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    if (iMouse.z>0.) {\n        t = iMouse.x/R.x*6.2;\n        p.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    }\n    vec3 n;\n    vec4 q;\n    float x = scene(p,d, n,q);\n     Q = (.6+.4*sin(q.w+vec4(1,2,3,4)))*(.5+.7*n.y)*texture(iChannel1,q.xyz);\n    p = p + d*x;\n    d = normalize(vec3(0,1,0)-p);\n    p += 1e-4*d;\n    x = scene(p,d,n,q);\n    Q *= 1.-exp(-1.*x);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 12\n\n#define dt .1\n\n#define K  1e-4\n#define K1 .005\n#define K2 .1\n#define K3 .5\n#define K5 .5\n\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define R iResolution.xy\n#define A(x,y) texelFetch(iChannel0,ivec2(x,y),0)\n\n#define _s_ vec3(.29,.2,.16)\n\n#define _a _s_*vec3(-1, -1,  1)\n#define _b _s_*vec3( 1, -1,  1)\n#define _c _s_*vec3(-1,  1,  1)\n#define _d _s_*vec3( 1,  1,  1)\n#define _e _s_*vec3(-1, -1, -1)\n#define _f _s_*vec3( 1, -1, -1)\n#define _g _s_*vec3(-1,  1, -1)\n#define _h _s_*vec3( 1,  1, -1)\n\n// Define the 12 triangles\n#define _T1  _a, _e, _b\n#define _T2  _b, _e, _f\n#define _T3  _b, _f, _d\n#define _T4  _d, _f, _h\n#define _T5  _d, _h, _c\n#define _T6  _c, _h, _g\n#define _T7  _c, _g, _a\n#define _T8  _a, _g, _e\n#define _T9  _c, _b, _d\n#define _T10 _c, _a, _b\n#define _T11 _g, _f, _h\n#define _T12 _g, _f, _e\n\n\n\nstruct obj {\n    vec3 m; // 0\n    mat3 o; // 1 2 3\n    vec3 v; // 4\n    vec3 s; // 5\n    \n    mat3 io; \n    \n    vec3 f; \n    vec3 t; \n};\n\nmat3 matrix (vec3 r) { \n   if (length(r)==0.) return mat3(1);\n   float a = length(r);\n   vec3 o = normalize(r);\n   float c = cos(a), t = 1.-c;\n   float s = sin(a);\n   return mat3(\n       t*o.x*o.x+c,t*o.x*o.y-o.z*s,t*o.x*o.z+o.y*s,\n       t*o.x*o.y+o.z*s,t*o.y*o.y+c,t*o.y*o.z-o.x*s,\n       t*o.x*o.z-o.y*s,t*o.y*o.z+o.x*s,t*o.z*o.z+c\n   \n   );\n}\nfloat iSphere (vec3 p, vec3 d, vec3 m, float r) {\n\n    p -= m;\n    \n    float b = 2.*dot(p,d);\n    float c = dot(p,p)-r*r;\n    float s = (b*b-4.*c);\n    if (s < 0.) return 1e9;\n    else return .5*(-b-sqrt(s));\n\n}\nfloat iSegment (vec3 p, vec3 d, vec3 a, vec3 b, float r) {    \n    vec3 q = p-a;\n    vec3 u = b-a;\n    float du = dot(d,u);\n    float uu = dot(u,u);\n    float qu = dot(q,u);\n    float dq = dot(d,q);\n    float qq = dot(q,q);\n    float a_ = 1. - du*du/uu;\n    float b_ = 2.*(dq - qu*du/uu);\n    float c_ = qq - qu*qu/uu - r*r;\n    float s = b_*b_-4.*a_*c_;\n    if (s < 0.) return 1e9;\n    float i = (-b_-sqrt(s))/(2.*a_);\n    float x = dot(p+d*i-a,u)/uu;\n    if (x < 0. || x > 1.) return 1e9;\n    return i;\n}\nfloat iPlane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\nfloat iTriangle (vec3 p, vec3 d, vec3 a, vec3 b, vec3 c) {\n    vec3 n = normalize(cross(b-a,c-a));\n    float i = -dot(p-a,n)/dot(d,n);\n    vec3 x = p + d*i;\n    float ab = dot(x-a,cross(n,normalize(b-a)));\n    float bc = dot(x-b,cross(n,normalize(c-b)));\n    float ca = dot(x-c,cross(n,normalize(a-c)));\n    if (ab<0.||bc<0.||ca<0.) return 1e9;\n    return i;\n}\n\nfloat iTriple (vec3 p, vec3 d, vec3 a, vec3 b, vec3 c, float r1, float r2) {\n       float i = 1e9;\n    \n     i = min(i,iSphere(p,d,a,r1));\n     i = min(i,iSphere(p,d,b,r1));\n     i = min(i,iSphere(p,d,c,r1));\n     \n     i = min(i,iSegment(p,d,a,b,r2));\n     i = min(i,iSegment(p,d,b,c,r2));\n     i = min(i,iSegment(p,d,c,a,r2));\n     \n     i = min(i,iTriangle(p,d,a,b,c));\n     return i;\n}\n\n\nfloat dSegment (vec3 p, vec3 a, vec3 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat dBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max((abs(p.x)-h.x)*h.y,(abs(p.y)-h.y)*h.x);\n\t\t}\nmat3 rotationMatrix(float a, float b, float c)\n{\n    float cosA = cos(a);\n    float sinA = sin(a);\n    float cosB = cos(b);\n    float sinB = sin(b);\n    float cosC = cos(c);\n    float sinC = sin(c);\n\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cosA, -sinA,\n        0.0, sinA, cosA\n    );\n\n    mat3 rotY = mat3(\n        cosB, 0.0, sinB,\n        0.0, 1.0, 0.0,\n        -sinB, 0.0, cosB\n    );\n\n    mat3 rotZ = mat3(\n        cosC, -sinC, 0.0,\n        sinC, cosC, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    // Combine the three rotation matrices\n    return rotZ * rotY * rotX;\n}\nvec3 velocity (obj o, vec3 p) {\n    return o.v+cross(o.s,p-o.m);\n}\nvoid impulse (inout obj o, vec3 p, vec3 f) {\n    vec3 r = p-o.m;\n    if (length(r)>0.) {\n        o.f += f*dot(normalize(f),normalize(-r))+f*cross(normalize(r),o.s);\n        o.t += cross(r,f)/(_s_);\n    } else o.f += f;\n}\nbool line_triangle (vec3 a, vec3 b, vec3 e, vec3 g, vec3 h, inout vec3 p, inout vec3 f) {\n    vec3 u = normalize(b-a);\n    float i = iTriangle (a,u,e,g,h);\n    if (i < 0. || i > length(a-b)) {\n        p = vec3(0), f = vec3(0);\n        return false;\n    } else {\n            p = a + u*i;\n            vec3 k = u;\n            if (length(p-b) > length(p-a)) k = -u;\n            f = normalize(cross(g-e,h-e));\n            f *= -K1*dot(k,f)*length(a-b);\n            return true;\n    }\n}\n\nvec3 integral (vec3 p, vec3 h, vec3 j, vec3 m) {\n\t\t    p -= h;\n\t\t    float L = length(p);\n\t\t    float X = p.x, Y = p.y, Z = p.z,\n\t\t          A = j.x, B = j.y, C = j.z;\n\t\t    vec3 bj = vec3(\n\t\t             B*(\n\t\t                 -sign(X)*abs(Z)*atan(-Y*abs(X)/L/abs(Z))\n\t\t                 +X/2.*(log(L-Y)-log(L+Y))\n\t\t                 +Y/2.*(log(L-X)-log(L+X))\n\t\t             ) + \n\t\t             C*(\n\t\t                 -sign(X)*abs(Y)*atan(-Z*abs(X)/L/abs(Y))\n\t\t                 +X/2.*(log(L-Z)-log(L+Z))\n\t\t                 +Z/2.*(log(L-X)-log(L+X))\n\t\t             )\n\t\t           , \n\t\t             C*(\n\t\t                 -sign(Y)*abs(X)*atan(-Z*abs(Y)/L/abs(X))\n\t\t                 +Y/2.*(log(L-Z)-log(L+Z))\n\t\t                 +Z/2.*(log(L-Y)-log(L+Y))\n\t\t             ) + \n\t\t             A*(\n\t\t                 -sign(Y)*abs(Z)*atan(-X*abs(Y)/L/abs(Z))\n\t\t                 +Y/2.*(log(L-X)-log(L+X))\n\t\t                 +X/2.*(log(L-Y)-log(L+Y))\n\t\t             )\n\t\t           ,\n\t\t             A*(\n\t\t                 -sign(Z)*abs(Y)*atan(-X*abs(Z)/L/abs(Y))\n\t\t                 +Z/2.*(log(L-X)-log(L+X))\n\t\t                 +X/2.*(log(L-Z)-log(L+Z))\n\t\t             ) + \n\t\t             B*(\n\t\t                 -sign(Z)*abs(X)*atan(-Y*abs(Z)/L/abs(X))\n\t\t                 +Z/2.*(log(L-Y)-log(L+Y))\n\t\t                 +Y/2.*(log(L-Z)-log(L+Z))\n\t\t             )\n\t\t         );\n\t\t   \n\t\t    A = m.x;\n\t\t    B = m.y;\n\t\t    C = m.z;\n\t\t    vec3 bm = -vec3(\n\t\t            +A*sign(X)*sign(Y)*atan(-Z*abs(Y)/L/abs(X))\n\t\t            -B*log((L-Z)/sqrt(X*X+Y*Y))\n\t\t            -C*sign(Y)*atan(L/abs(Y))\n\t\t            \n\t\t            +A*sign(X)*sign(Z)*atan(-Y*abs(Z)/L/abs(X))\n\t\t            -C*log((L-Y)/sqrt(X*X+Z*Z))\n\t\t            -B*sign(Z)*atan(L/abs(Z))\n\t\t          ,\n\t\t            +B*sign(Y)*sign(X)*atan(-Z*abs(X)/L/abs(Y))\n\t\t            -A*log((L-Z)/sqrt(X*X+Y*Y))\n\t\t            -C*sign(X)*atan(L/abs(X))\n\t\t            \n\t\t            +B*sign(Y)*sign(Z)*atan(-X*abs(Z)/L/abs(Y))\n\t\t            -C*log((L-X)/sqrt(Z*Z+Y*Y))\n\t\t            -A*sign(Z)*atan(L/abs(Z))\n\t\t          ,\n\t\t            +C*sign(Z)*sign(Y)*atan(-X*abs(Y)/L/abs(Z))\n\t\t            -B*log((L-X)/sqrt(Z*Z+Y*Y))\n\t\t            -A*sign(Y)*atan(L/abs(Y))\n\t\t            \n\t\t            +C*sign(Z)*sign(X)*atan(-Y*abs(X)/L/abs(Z))\n\t\t            -A*log((L-Y)/sqrt(Z*Z+X*X))\n\t\t            -B*sign(X)*atan(L/abs(X))\n\t\t    );\n\t\t         \n\t\t    return bj+bm;\n\n\t\t}\n\n\n\n\t\tvec3 B (vec3 p, vec3 h, vec3 j, vec3 m) {\n\t\t    return (\n\t\t      (\n\t\t        ( integral(p,vec3(+h.x,+h.y,+h.z),j,m) - integral(p,vec3(-h.x,+h.y,+h.z),j,m) ) \n\t\t        \n\t\t            -\n\t\t         \n\t\t        ( integral(p,vec3(+h.x,-h.y,+h.z),j,m) - integral(p,vec3(-h.x,-h.y,+h.z),j,m) ) \n\t\t      ) \n\t\t      \n\t\t          - \n\t\t      \n\t\t      (\n\t\t        ( integral(p,vec3(+h.x,+h.y,-h.z),j,m) - integral(p,vec3(-h.x,+h.y,-h.z),j,m) ) \n\t\t        \n\t\t            -\n\t\t         \n\t\t        ( integral(p,vec3(+h.x,-h.y,-h.z),j,m) - integral(p,vec3(-h.x,-h.y,-h.z),j,m) ) \n\t\t      )\n\t\t    );\n\t\t}", "buffer_a_code": "obj get (int i);vec4 set (obj o,int x);\n\nvoid triangle_triangle (inout obj o, inout obj q, vec3 a, vec3 b, vec3 c, vec3 e, vec3 g, vec3 h) {\n    vec3 _, f;\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    e = e*q.o+q.m;\n    g = g*q.o+q.m;\n    h = h*q.o+q.m;\n    if (line_triangle(a,b,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(b,c,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(c,a,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }    \n    \n    if (line_triangle(e,g,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(g,h,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    } \n    if (line_triangle(h,e,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n}\nvoid cube_cube(inout obj o, inout obj q) {\n    triangle_triangle(o,q,_T1,_T1);\n    triangle_triangle(o,q,_T1,_T2);\n    triangle_triangle(o,q,_T1,_T3);\n    triangle_triangle(o,q,_T1,_T4);\n    triangle_triangle(o,q,_T1,_T5);\n    triangle_triangle(o,q,_T1,_T6);\n    triangle_triangle(o,q,_T1,_T7);\n    triangle_triangle(o,q,_T1,_T8);\n    triangle_triangle(o,q,_T1,_T9);\n    triangle_triangle(o,q,_T1,_T10);\n    triangle_triangle(o,q,_T1,_T11);\n    triangle_triangle(o,q,_T1,_T12);\n    triangle_triangle(o,q,_T2,_T1);\n    triangle_triangle(o,q,_T2,_T2);\n    triangle_triangle(o,q,_T2,_T3);\n    triangle_triangle(o,q,_T2,_T4);\n    triangle_triangle(o,q,_T2,_T5);\n    triangle_triangle(o,q,_T2,_T6);\n    triangle_triangle(o,q,_T2,_T7);\n    triangle_triangle(o,q,_T2,_T8);\n    triangle_triangle(o,q,_T2,_T9);\n    triangle_triangle(o,q,_T2,_T10);\n    triangle_triangle(o,q,_T2,_T11);\n    triangle_triangle(o,q,_T2,_T12);\n    triangle_triangle(o,q,_T3,_T1);\n    triangle_triangle(o,q,_T3,_T2);\n    triangle_triangle(o,q,_T3,_T3);\n    triangle_triangle(o,q,_T3,_T4);\n    triangle_triangle(o,q,_T3,_T5);\n    triangle_triangle(o,q,_T3,_T6);\n    triangle_triangle(o,q,_T3,_T7);\n    triangle_triangle(o,q,_T3,_T8);\n    triangle_triangle(o,q,_T3,_T9);\n    triangle_triangle(o,q,_T3,_T10);\n    triangle_triangle(o,q,_T3,_T11);\n    triangle_triangle(o,q,_T3,_T12);\n    triangle_triangle(o,q,_T4,_T1);\n    triangle_triangle(o,q,_T4,_T2);\n    triangle_triangle(o,q,_T4,_T3);\n    triangle_triangle(o,q,_T4,_T4);\n    triangle_triangle(o,q,_T4,_T5);\n    triangle_triangle(o,q,_T4,_T6);\n    triangle_triangle(o,q,_T4,_T7);\n    triangle_triangle(o,q,_T4,_T8);\n    triangle_triangle(o,q,_T4,_T9);\n    triangle_triangle(o,q,_T4,_T10);\n    triangle_triangle(o,q,_T4,_T11);\n    triangle_triangle(o,q,_T4,_T12);\n    triangle_triangle(o,q,_T5,_T1);\n    triangle_triangle(o,q,_T5,_T2);\n    triangle_triangle(o,q,_T5,_T3);\n    triangle_triangle(o,q,_T5,_T4);\n    triangle_triangle(o,q,_T5,_T5);\n    triangle_triangle(o,q,_T5,_T6);\n    triangle_triangle(o,q,_T5,_T7);\n    triangle_triangle(o,q,_T5,_T8);\n    triangle_triangle(o,q,_T5,_T9);\n    triangle_triangle(o,q,_T5,_T10);\n    triangle_triangle(o,q,_T5,_T11);\n    triangle_triangle(o,q,_T5,_T12);\n    triangle_triangle(o,q,_T6,_T1);\n    triangle_triangle(o,q,_T6,_T2);\n    triangle_triangle(o,q,_T6,_T3);\n    triangle_triangle(o,q,_T6,_T4);\n    triangle_triangle(o,q,_T6,_T5);\n    triangle_triangle(o,q,_T6,_T6);\n    triangle_triangle(o,q,_T6,_T7);\n    triangle_triangle(o,q,_T6,_T8);\n    triangle_triangle(o,q,_T6,_T9);\n    triangle_triangle(o,q,_T6,_T10);\n    triangle_triangle(o,q,_T6,_T11);\n    triangle_triangle(o,q,_T6,_T12);\n    triangle_triangle(o,q,_T7,_T1);\n    triangle_triangle(o,q,_T7,_T2);\n    triangle_triangle(o,q,_T7,_T3);\n    triangle_triangle(o,q,_T7,_T4);\n    triangle_triangle(o,q,_T7,_T5);\n    triangle_triangle(o,q,_T7,_T6);\n    triangle_triangle(o,q,_T7,_T7);\n    triangle_triangle(o,q,_T7,_T8);\n    triangle_triangle(o,q,_T7,_T9);\n    triangle_triangle(o,q,_T7,_T10);\n    triangle_triangle(o,q,_T7,_T11);\n    triangle_triangle(o,q,_T7,_T12);\n    triangle_triangle(o,q,_T8,_T1);\n    triangle_triangle(o,q,_T8,_T2);\n    triangle_triangle(o,q,_T8,_T3);\n    triangle_triangle(o,q,_T8,_T4);\n    triangle_triangle(o,q,_T8,_T5);\n    triangle_triangle(o,q,_T8,_T6);\n    triangle_triangle(o,q,_T8,_T7);\n    triangle_triangle(o,q,_T8,_T8);\n    triangle_triangle(o,q,_T8,_T9);\n    triangle_triangle(o,q,_T8,_T10);\n    triangle_triangle(o,q,_T8,_T11);\n    triangle_triangle(o,q,_T8,_T12);\n    triangle_triangle(o,q,_T9,_T1);\n    triangle_triangle(o,q,_T9,_T2);\n    triangle_triangle(o,q,_T9,_T3);\n    triangle_triangle(o,q,_T9,_T4);\n    triangle_triangle(o,q,_T9,_T5);\n    triangle_triangle(o,q,_T9,_T6);\n    triangle_triangle(o,q,_T9,_T7);\n    triangle_triangle(o,q,_T9,_T8);\n    triangle_triangle(o,q,_T9,_T9);\n    triangle_triangle(o,q,_T9,_T10);\n    triangle_triangle(o,q,_T9,_T11);\n    triangle_triangle(o,q,_T9,_T12);\n    triangle_triangle(o,q,_T10,_T1);\n    triangle_triangle(o,q,_T10,_T2);\n    triangle_triangle(o,q,_T10,_T3);\n    triangle_triangle(o,q,_T10,_T4);\n    triangle_triangle(o,q,_T10,_T5);\n    triangle_triangle(o,q,_T10,_T6);\n    triangle_triangle(o,q,_T10,_T7);\n    triangle_triangle(o,q,_T10,_T8);\n    triangle_triangle(o,q,_T10,_T9);\n    triangle_triangle(o,q,_T10,_T10);\n    triangle_triangle(o,q,_T10,_T11);\n    triangle_triangle(o,q,_T10,_T12);\n    triangle_triangle(o,q,_T11,_T1);\n    triangle_triangle(o,q,_T11,_T2);\n    triangle_triangle(o,q,_T11,_T3);\n    triangle_triangle(o,q,_T11,_T4);\n    triangle_triangle(o,q,_T11,_T5);\n    triangle_triangle(o,q,_T11,_T6);\n    triangle_triangle(o,q,_T11,_T7);\n    triangle_triangle(o,q,_T11,_T8);\n    triangle_triangle(o,q,_T11,_T9);\n    triangle_triangle(o,q,_T11,_T10);\n    triangle_triangle(o,q,_T11,_T11);\n    triangle_triangle(o,q,_T11,_T12);\n    triangle_triangle(o,q,_T12,_T1);\n    triangle_triangle(o,q,_T12,_T2);\n    triangle_triangle(o,q,_T12,_T3);\n    triangle_triangle(o,q,_T12,_T4);\n    triangle_triangle(o,q,_T12,_T5);\n    triangle_triangle(o,q,_T12,_T6);\n    triangle_triangle(o,q,_T12,_T7);\n    triangle_triangle(o,q,_T12,_T8);\n    triangle_triangle(o,q,_T12,_T9);\n    triangle_triangle(o,q,_T12,_T10);\n    triangle_triangle(o,q,_T12,_T11);\n    triangle_triangle(o,q,_T12,_T12);\n}\nvoid tri_boundaries (inout obj o, vec3 a, vec3 b, vec3 c) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    vec3 da = -velocity(o,a);\n    vec3 db = -velocity(o,b);\n    vec3 dc = -velocity(o,c);\n    \n    if (a.y < -.5) impulse(o, a, vec3(0,-a.y-.5,0) + K3*da);\n    if (b.y < -.5) impulse(o, b, vec3(0,-b.y-.5,0) + K3*db);\n    if (c.y < -.5) impulse(o, c, vec3(0,-c.y-.5,0) + K3*dc);\n    \n    if (a.x < -1.) impulse(o, a, vec3(-a.x-1.,0,0) + K3*da);\n    if (b.x < -1.) impulse(o, b, vec3(-b.x-1.,0,0) + K3*db);\n    if (c.x < -1.) impulse(o, c, vec3(-c.x-1.,0,0) + K3*dc);\n    \n    if (a.z < -1.) impulse(o, a, vec3(0,0,-a.z-1.) + K3*da);\n    if (b.z < -1.) impulse(o, b, vec3(0,0,-b.z-1.) + K3*db);\n    if (c.z < -1.) impulse(o, c, vec3(0,0,-c.z-1.) + K3*dc);\n    \n    if (a.x > +1.) impulse(o, a, vec3(1.-a.x,0,0) +  K3*da);\n    if (b.x > +1.) impulse(o, b, vec3(1.-b.x,0,0) +  K3*db);\n    if (c.x > +1.) impulse(o, c, vec3(1.-c.x,0,0) +  K3*dc);\n    \n    if (a.z > +1.) impulse(o, a, vec3(0,0,1.-a.z) +  K3*da);\n    if (b.z > +1.) impulse(o, b, vec3(0,0,1.-b.z) +  K3*db);\n    if (c.z > +1.) impulse(o, c, vec3(0,0,1.-c.z) +  K3*dc);\n    \n}\nvoid boundaries (inout obj o) {\n\n    tri_boundaries(o,_T1);\n    tri_boundaries(o,_T2);\n    tri_boundaries(o,_T3);\n    tri_boundaries(o,_T4);\n    tri_boundaries(o,_T5);\n    tri_boundaries(o,_T6);\n    tri_boundaries(o,_T7);\n    tri_boundaries(o,_T8);\n    tri_boundaries(o,_T9);\n    tri_boundaries(o,_T10);\n    tri_boundaries(o,_T11);\n    tri_boundaries(o,_T12);\n}\nvoid magnet_magnet(inout obj o, obj q) {\n    vec2 e = vec2(5e-3,0);\n    vec3 r = (o.m-q.m)*q.io;\n    float k = K;\n    \n    float b0 = dot(B(r,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bx = dot(B(r+e.xyy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float by = dot(B(r+e.yxy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bz = dot(B(r+e.yyx,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    \n    o.f += k*vec3(bx-b0,by-b0,bz-b0)/e.x;\n        \n    o.t += k*cross(vec3(1,0,0),B(r,vec3(_s_),vec3(0),vec3(1,0,0))*q.o);\n\n}\nMain {\n    \n    int x = int(U.x); // nth feature\n    int y = int(U.y); // nth object\n    if (x > 8 || y > N) discard;  \n    obj me = get(y);\n    \n    \n    me.f = vec3(0,-1e-3,0);\n    me.t = vec3(0);\n    \n    for (int i = min(0,iFrame); i < N; i++) if (i != y) { \n        \n        obj o = get(i);\n        \n        //magnet_magnet(me,o);\n        \n        if (length(o.m-me.m)<2.01*length(_s_)) cube_cube(me,o);\n    \n    }\n    \n    boundaries(me);\n    me.v = dt*me.f + me.v*.99;\n    me.m = dt*K5*me.f + dt*me.v + me.m;\n    me.s = dt*me.t + me.s;\n    me.o = me.o * matrix(K5*dt*me.s+dt*me.t);\n    me.o[0] = normalize(cross(me.o[1],me.o[2]));\n    me.o[1] = normalize(cross(me.o[2],me.o[0]));\n    me.o[2] = normalize(cross(me.o[0],me.o[1]));\n    if (iFrame < 1) {\n        \n        me = obj (\n            vec3(.1*sin(float(y)*123.4),float(y)*.5,.1*sin(float(y)*10.)),\n            rotationMatrix(3.14*.5+55.*float(y),0.6+float(y)*.2,0.),\n            vec3(0),\n            vec3(0.05*sin(float(y)*.3),0.1*cos(float(y)*.77),0),\n            mat3(1),\n            vec3(0),\n            vec3(0)\n        \n        );\n    \n    }\n    \n    Q = set(me,x);\n\n\n}\nobj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,\n        mat3(1),\n        vec3(0),\n        vec3(0)\n    );\n}\nvec4 set (obj o,int x) {\n    if (x==0) return vec4(o.m,1);\n    if (x==1) return vec4(o.o[0],1);\n    if (x==2) return vec4(o.o[1],1);\n    if (x==3) return vec4(o.o[2],1);\n    if (x==4) return vec4(o.v,1);\n    if (x==5) return vec4(o.s,1);\n    o.io = inverse(o.o);\n    if (x==6) return vec4(o.io[0],1);\n    if (x==7) return vec4(o.io[1],1);\n    if (x==8) return vec4(o.io[2],1);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 Q, in vec2 U, in vec3 rayOri, in vec3 rayDir )\n{\n    Q = texture(iChannel0,U/1024.);\n}", "cube_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "obj get (int i);vec4 set (obj o,int x);\n\nvoid triangle_triangle (inout obj o, inout obj q, vec3 a, vec3 b, vec3 c, vec3 e, vec3 g, vec3 h) {\n    vec3 _, f;\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    e = e*q.o+q.m;\n    g = g*q.o+q.m;\n    h = h*q.o+q.m;\n    if (line_triangle(a,b,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(b,c,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(c,a,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }    \n    \n    if (line_triangle(e,g,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(g,h,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    } \n    if (line_triangle(h,e,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n}\nvoid cube_cube(inout obj o, inout obj q) {\n    triangle_triangle(o,q,_T1,_T1);\n    triangle_triangle(o,q,_T1,_T2);\n    triangle_triangle(o,q,_T1,_T3);\n    triangle_triangle(o,q,_T1,_T4);\n    triangle_triangle(o,q,_T1,_T5);\n    triangle_triangle(o,q,_T1,_T6);\n    triangle_triangle(o,q,_T1,_T7);\n    triangle_triangle(o,q,_T1,_T8);\n    triangle_triangle(o,q,_T1,_T9);\n    triangle_triangle(o,q,_T1,_T10);\n    triangle_triangle(o,q,_T1,_T11);\n    triangle_triangle(o,q,_T1,_T12);\n    triangle_triangle(o,q,_T2,_T1);\n    triangle_triangle(o,q,_T2,_T2);\n    triangle_triangle(o,q,_T2,_T3);\n    triangle_triangle(o,q,_T2,_T4);\n    triangle_triangle(o,q,_T2,_T5);\n    triangle_triangle(o,q,_T2,_T6);\n    triangle_triangle(o,q,_T2,_T7);\n    triangle_triangle(o,q,_T2,_T8);\n    triangle_triangle(o,q,_T2,_T9);\n    triangle_triangle(o,q,_T2,_T10);\n    triangle_triangle(o,q,_T2,_T11);\n    triangle_triangle(o,q,_T2,_T12);\n    triangle_triangle(o,q,_T3,_T1);\n    triangle_triangle(o,q,_T3,_T2);\n    triangle_triangle(o,q,_T3,_T3);\n    triangle_triangle(o,q,_T3,_T4);\n    triangle_triangle(o,q,_T3,_T5);\n    triangle_triangle(o,q,_T3,_T6);\n    triangle_triangle(o,q,_T3,_T7);\n    triangle_triangle(o,q,_T3,_T8);\n    triangle_triangle(o,q,_T3,_T9);\n    triangle_triangle(o,q,_T3,_T10);\n    triangle_triangle(o,q,_T3,_T11);\n    triangle_triangle(o,q,_T3,_T12);\n    triangle_triangle(o,q,_T4,_T1);\n    triangle_triangle(o,q,_T4,_T2);\n    triangle_triangle(o,q,_T4,_T3);\n    triangle_triangle(o,q,_T4,_T4);\n    triangle_triangle(o,q,_T4,_T5);\n    triangle_triangle(o,q,_T4,_T6);\n    triangle_triangle(o,q,_T4,_T7);\n    triangle_triangle(o,q,_T4,_T8);\n    triangle_triangle(o,q,_T4,_T9);\n    triangle_triangle(o,q,_T4,_T10);\n    triangle_triangle(o,q,_T4,_T11);\n    triangle_triangle(o,q,_T4,_T12);\n    triangle_triangle(o,q,_T5,_T1);\n    triangle_triangle(o,q,_T5,_T2);\n    triangle_triangle(o,q,_T5,_T3);\n    triangle_triangle(o,q,_T5,_T4);\n    triangle_triangle(o,q,_T5,_T5);\n    triangle_triangle(o,q,_T5,_T6);\n    triangle_triangle(o,q,_T5,_T7);\n    triangle_triangle(o,q,_T5,_T8);\n    triangle_triangle(o,q,_T5,_T9);\n    triangle_triangle(o,q,_T5,_T10);\n    triangle_triangle(o,q,_T5,_T11);\n    triangle_triangle(o,q,_T5,_T12);\n    triangle_triangle(o,q,_T6,_T1);\n    triangle_triangle(o,q,_T6,_T2);\n    triangle_triangle(o,q,_T6,_T3);\n    triangle_triangle(o,q,_T6,_T4);\n    triangle_triangle(o,q,_T6,_T5);\n    triangle_triangle(o,q,_T6,_T6);\n    triangle_triangle(o,q,_T6,_T7);\n    triangle_triangle(o,q,_T6,_T8);\n    triangle_triangle(o,q,_T6,_T9);\n    triangle_triangle(o,q,_T6,_T10);\n    triangle_triangle(o,q,_T6,_T11);\n    triangle_triangle(o,q,_T6,_T12);\n    triangle_triangle(o,q,_T7,_T1);\n    triangle_triangle(o,q,_T7,_T2);\n    triangle_triangle(o,q,_T7,_T3);\n    triangle_triangle(o,q,_T7,_T4);\n    triangle_triangle(o,q,_T7,_T5);\n    triangle_triangle(o,q,_T7,_T6);\n    triangle_triangle(o,q,_T7,_T7);\n    triangle_triangle(o,q,_T7,_T8);\n    triangle_triangle(o,q,_T7,_T9);\n    triangle_triangle(o,q,_T7,_T10);\n    triangle_triangle(o,q,_T7,_T11);\n    triangle_triangle(o,q,_T7,_T12);\n    triangle_triangle(o,q,_T8,_T1);\n    triangle_triangle(o,q,_T8,_T2);\n    triangle_triangle(o,q,_T8,_T3);\n    triangle_triangle(o,q,_T8,_T4);\n    triangle_triangle(o,q,_T8,_T5);\n    triangle_triangle(o,q,_T8,_T6);\n    triangle_triangle(o,q,_T8,_T7);\n    triangle_triangle(o,q,_T8,_T8);\n    triangle_triangle(o,q,_T8,_T9);\n    triangle_triangle(o,q,_T8,_T10);\n    triangle_triangle(o,q,_T8,_T11);\n    triangle_triangle(o,q,_T8,_T12);\n    triangle_triangle(o,q,_T9,_T1);\n    triangle_triangle(o,q,_T9,_T2);\n    triangle_triangle(o,q,_T9,_T3);\n    triangle_triangle(o,q,_T9,_T4);\n    triangle_triangle(o,q,_T9,_T5);\n    triangle_triangle(o,q,_T9,_T6);\n    triangle_triangle(o,q,_T9,_T7);\n    triangle_triangle(o,q,_T9,_T8);\n    triangle_triangle(o,q,_T9,_T9);\n    triangle_triangle(o,q,_T9,_T10);\n    triangle_triangle(o,q,_T9,_T11);\n    triangle_triangle(o,q,_T9,_T12);\n    triangle_triangle(o,q,_T10,_T1);\n    triangle_triangle(o,q,_T10,_T2);\n    triangle_triangle(o,q,_T10,_T3);\n    triangle_triangle(o,q,_T10,_T4);\n    triangle_triangle(o,q,_T10,_T5);\n    triangle_triangle(o,q,_T10,_T6);\n    triangle_triangle(o,q,_T10,_T7);\n    triangle_triangle(o,q,_T10,_T8);\n    triangle_triangle(o,q,_T10,_T9);\n    triangle_triangle(o,q,_T10,_T10);\n    triangle_triangle(o,q,_T10,_T11);\n    triangle_triangle(o,q,_T10,_T12);\n    triangle_triangle(o,q,_T11,_T1);\n    triangle_triangle(o,q,_T11,_T2);\n    triangle_triangle(o,q,_T11,_T3);\n    triangle_triangle(o,q,_T11,_T4);\n    triangle_triangle(o,q,_T11,_T5);\n    triangle_triangle(o,q,_T11,_T6);\n    triangle_triangle(o,q,_T11,_T7);\n    triangle_triangle(o,q,_T11,_T8);\n    triangle_triangle(o,q,_T11,_T9);\n    triangle_triangle(o,q,_T11,_T10);\n    triangle_triangle(o,q,_T11,_T11);\n    triangle_triangle(o,q,_T11,_T12);\n    triangle_triangle(o,q,_T12,_T1);\n    triangle_triangle(o,q,_T12,_T2);\n    triangle_triangle(o,q,_T12,_T3);\n    triangle_triangle(o,q,_T12,_T4);\n    triangle_triangle(o,q,_T12,_T5);\n    triangle_triangle(o,q,_T12,_T6);\n    triangle_triangle(o,q,_T12,_T7);\n    triangle_triangle(o,q,_T12,_T8);\n    triangle_triangle(o,q,_T12,_T9);\n    triangle_triangle(o,q,_T12,_T10);\n    triangle_triangle(o,q,_T12,_T11);\n    triangle_triangle(o,q,_T12,_T12);\n}\nvoid tri_boundaries (inout obj o, vec3 a, vec3 b, vec3 c) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    vec3 da = -velocity(o,a);\n    vec3 db = -velocity(o,b);\n    vec3 dc = -velocity(o,c);\n    \n    if (a.y < -.5) impulse(o, a, vec3(0,-a.y-.5,0) + K3*da);\n    if (b.y < -.5) impulse(o, b, vec3(0,-b.y-.5,0) + K3*db);\n    if (c.y < -.5) impulse(o, c, vec3(0,-c.y-.5,0) + K3*dc);\n    \n    if (a.x < -1.) impulse(o, a, vec3(-a.x-1.,0,0) + K3*da);\n    if (b.x < -1.) impulse(o, b, vec3(-b.x-1.,0,0) + K3*db);\n    if (c.x < -1.) impulse(o, c, vec3(-c.x-1.,0,0) + K3*dc);\n    \n    if (a.z < -1.) impulse(o, a, vec3(0,0,-a.z-1.) + K3*da);\n    if (b.z < -1.) impulse(o, b, vec3(0,0,-b.z-1.) + K3*db);\n    if (c.z < -1.) impulse(o, c, vec3(0,0,-c.z-1.) + K3*dc);\n    \n    if (a.x > +1.) impulse(o, a, vec3(1.-a.x,0,0) +  K3*da);\n    if (b.x > +1.) impulse(o, b, vec3(1.-b.x,0,0) +  K3*db);\n    if (c.x > +1.) impulse(o, c, vec3(1.-c.x,0,0) +  K3*dc);\n    \n    if (a.z > +1.) impulse(o, a, vec3(0,0,1.-a.z) +  K3*da);\n    if (b.z > +1.) impulse(o, b, vec3(0,0,1.-b.z) +  K3*db);\n    if (c.z > +1.) impulse(o, c, vec3(0,0,1.-c.z) +  K3*dc);\n    \n}\nvoid boundaries (inout obj o) {\n\n    tri_boundaries(o,_T1);\n    tri_boundaries(o,_T2);\n    tri_boundaries(o,_T3);\n    tri_boundaries(o,_T4);\n    tri_boundaries(o,_T5);\n    tri_boundaries(o,_T6);\n    tri_boundaries(o,_T7);\n    tri_boundaries(o,_T8);\n    tri_boundaries(o,_T9);\n    tri_boundaries(o,_T10);\n    tri_boundaries(o,_T11);\n    tri_boundaries(o,_T12);\n}\nvoid magnet_magnet(inout obj o, obj q) {\n    vec2 e = vec2(5e-3,0);\n    vec3 r = (o.m-q.m)*q.io;\n    float k = K;\n    \n    float b0 = dot(B(r,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bx = dot(B(r+e.xyy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float by = dot(B(r+e.yxy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bz = dot(B(r+e.yyx,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    \n    o.f += k*vec3(bx-b0,by-b0,bz-b0)/e.x;\n        \n    o.t += k*cross(vec3(1,0,0),B(r,vec3(_s_),vec3(0),vec3(1,0,0))*q.o);\n\n}\nMain {\n    \n    int x = int(U.x); // nth feature\n    int y = int(U.y); // nth object\n    if (x > 8 || y > N) discard;  \n    obj me = get(y);\n    \n    \n    me.f = vec3(0,-1e-3,0);\n    me.t = vec3(0);\n    \n    for (int i = min(0,iFrame); i < N; i++) if (i != y) { \n        \n        obj o = get(i);\n        \n        //magnet_magnet(me,o);\n        \n        if (length(o.m-me.m)<2.01*length(_s_)) cube_cube(me,o);\n    \n    }\n    \n    boundaries(me);\n    me.v = dt*me.f + me.v*.995;\n    me.m = dt*K5*me.f + dt*me.v + me.m;\n    me.s = dt*me.t + me.s;\n    me.o = me.o * matrix(K5*dt*me.s+dt*me.t);\n    me.o[0] = normalize(cross(me.o[1],me.o[2]));\n    me.o[1] = normalize(cross(me.o[2],me.o[0]));\n    me.o[2] = normalize(cross(me.o[0],me.o[1]));\n    if (iFrame < 1) {\n        \n        me = obj (\n            vec3(.1*sin(float(y)*123.4),float(y)*.5,.1*sin(float(y)*10.)),\n            rotationMatrix(3.14*.5+55.*float(y),0.6+float(y)*.2,0.),\n            vec3(0),\n            vec3(0.05*sin(float(y)*.3),0.1*cos(float(y)*.77),0),\n            mat3(1),\n            vec3(0),\n            vec3(0)\n        \n        );\n    \n    }\n    \n    Q = set(me,x);\n\n\n}\nobj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,\n        mat3(1),\n        vec3(0),\n        vec3(0)\n    );\n}\nvec4 set (obj o,int x) {\n    if (x==0) return vec4(o.m,1);\n    if (x==1) return vec4(o.o[0],1);\n    if (x==2) return vec4(o.o[1],1);\n    if (x==3) return vec4(o.o[2],1);\n    if (x==4) return vec4(o.v,1);\n    if (x==5) return vec4(o.s,1);\n    o.io = inverse(o.o);\n    if (x==6) return vec4(o.io[0],1);\n    if (x==7) return vec4(o.io[1],1);\n    if (x==8) return vec4(o.io[2],1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3cDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 114, 114, 397], [398, 398, 430, 430, 507], [508, 508, 616, 616, 877], [878, 878, 943, 943, 1069], [1070, 1070, 1124, 1124, 1880]], "test": "untested"}
{"id": "dddcDf", "name": "AMARAH", "author": "zhonkvision", "description": "True Colour", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 2, "viewed": 188, "published": 3, "date": "1695627512", "time_retrieved": "2024-07-30T17:31:54.514564", "image_code": "// VISUAL | ZHONK VISION˚\n\nuniform sampler2D; // Audio input texture\n\nvec3 palette(float d) {\n    return mix(vec3(0.4, 5.7, 0.9), vec3(1.0, 0.0, 1.0), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.05;\n    for (int i = 0; i < 10; ++i) {\n        float t = angle * 1.89;\n        p.xz = rotate(p.xz, t * 1.89);\n        p.xy = rotate(p.xy, t * 1.89);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    \n    float SHEYTAN = length(p.xy) - 0.9; // Create a circular Sheytan shape\n    \n    return SHEYTAN;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.5;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 100.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    \n    // Use the red channel of the audio input texture to modulate the color\n    vec3 audioColorMod = texture(iChannel0, vec2(iTime * 0.01, 0.8)).rgb;\n    col *= audioColorMod;\n    \n    return vec4(col, 1.0 / (d * 80.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -160.0);\n    \n    // Remove rotation modulation\n    ro.xz = rotate(ro.xz, iTime * 0.2); // Keep a constant rotation speed\n    \n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    \n    fragColor = col;\n}\n", "image_inputs": [{"id": 34779, "src": "https://soundcloud.com/sonogang/sonocast6?si=36cc92eaae4345c6a7af9b96c5cda083&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddcDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 94, 94, 157], [159, 159, 189, 189, 269], [271, 271, 290, 290, 627], [629, 629, 656, 656, 1223], [1225, 1225, 1280, 1280, 1790]], "test": "untested"}
{"id": "Ds3yWj", "name": "Deterministic Nyan Particles", "author": "fenix", "description": "These particles are embued with the power of nyan cat, so they know how to assemble themselves into His likeness. Inspired by Pezzza's Work:\n\nhttps://youtu.be/watch?v=9IULfQH7E90\n\n*mouse: zoom*\n*alt: render shock direction field*\n*space: reset*\n", "tags": ["voronoi", "collision", "nyan", "simulation", "particles", "dynamics", "tracking", "physics", "sim", "determinism"], "likes": 54, "viewed": 484, "published": 3, "date": "1695623902", "time_retrieved": "2024-07-30T17:31:55.626591", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by Pezzza's Work on YouTube:\n//\n//      https://www.youtube.com/watch?v=9IULfQH7E90\n//\n//  I always wanted to try one of those determistic effects, such as those ball sorters:\n//\n//      dr2's Magic Ball Sorter      https://shadertoy.com/view/tsGyDy\n//\n//  I thought Pezzza's Work's idea of using the determinism to assemble an image seemed\n//  smart. His simulation looks better than mine, but he has the luxury of iterations.\n//\n//  Of course the way this works is determinism: the simulation is the same every time\n//  it runs, so we only have to run it once to find out where each particle will end\n//  up. This is why there is no image on the first run: we don't know yet where the\n//  particles will go.\n//\n//  I had to reuse the shock direction idea to make the particles stable enough for this\n//  to work. So here's a proof of concept for the same idea with a verlet simulation. The\n//  shock direction modifies the collision stiffness, so that lower particles are less\n//  able to be moved by particles above them. Press alt to render the shock directions.\n//\n//      *mouse to zoom*\n//      *alt to render shock direction field*\n//      *space to reset*\n//\n//  Buffer A, B, and C perform particle simulation. Only A updates the particle neighbors.\n//  Buffer D computes screen-space voronoi for render.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(fxParticle v, vec2 p, uint id, float sc, inout vec4 O)\n{\n    float e = 2. * sc / R.y;\n    float d = fxLinePointDist(v.pos, v.prev, p);\n    \n    vec3 color = v.color;\n    if (keyDown(KEY_ALT))\n        color *= sin(atan(abs(v.sd.y * .1), v.sd.x) + vec3(0, 11, 33));\n    O.xyz = mix(O.rgb, color, smoothstep(v.size + e, v.size - e, d));\n}\n\n// Character rendering from Shader Text for beginners by PrzemyslawZaworski:\n// https://www.shadertoy.com/view/4sBfRd\n#define C(c) O += char(U,64+c) ; U.x-=.5\n\n#define LF (U.y++)\n#define CR (U.x = (( uv.x - position.x)*64.0/FontSize))\n#define NL (CR,LF)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).xxxx;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    vec2 p = (u - .5 * R) / R.y;\n    float sc = 1.;\n    \n    if (iMouse.z > 0.)\n    {\n        sc = .25; // mouse zoom\n        p.xy *= .25;\n        p.xy += .6 * (iMouse.xy - .5 * R) / R.y;\n    }\n    \n    uvec4 old = fxGetClosest(ivec2(p * R.y + .5 * R.xy));\n    fxState s = fxGetState();\n    O.rgb = BACK_COLOR;\n\n    // render particles\n    if ((!s.init || s.frame < CAPTURE_FRAME) && s.frame > 1)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            uint id = old[i];\n            if (id == -1U || id >= g_MaxParticles) break;\n            fxParticle v = fxGetParticle(id);\n            renderParticle(v, p, id, sc, O);\n        }\n    }\n    \n    float d = sdScene(p, R);\n    O = mix(O, vec4(1), smoothstep(0., -1. / R.y, d)); // render border\n\n    if (s.init)\n    {\n        if (abs(p.x) < .4 && abs(p.y) < .1)\n        {\n            O *= .5; // render rectangle\n            const float FontSize = 4.;\n            const vec2 position = vec2(.31,.5 - FontSize / 128.0);\n            vec2 U = ( (p * R.y + .5 * R) / R - position)*64.0/FontSize;\n            C(16);C(12);C(5);C(1);C(19);C(5);C(-32);C(23);C(1);C(9);C(20); // \"PLEASE WAIT\"\n        }\n        \n        if (p.y < -.4 && p.x < ((float(s.frame) / float(CAPTURE_FRAME) - .5)) * R.x / R.y)\n            O *= .5; // progress bar\n    }\n    \n    O.a = 1.;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType);\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType);\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float PI = 3.141592653589793;\nconst int CAPTURE_FRAME = 1150; // what frame to trigger each particle to capture uv\nconst int RESET_FRAME = 2000; // how many frames before resetting on second+ runs\nconst vec3 BACK_COLOR = vec3(.6,.4,.6); // \nconst vec3 PAR_COLOR = BACK_COLOR + .2;\nconst uint IDEAL_MAX_PARTICLES = 6000U;\nconst float PARTICLE_SIZE = .005;\n\n#define R iResolution.xy\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float res; // tracks resolution changes\n    int frame; // simulation frame\n    bool init; // first initialization run\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nfxState fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    \n    fxState s;\n    s.res = data.x;\n    s.frame = floatBitsToInt(data.z);\n    s.init = data.w != 0.;\n    \n    return s;\n}\n\nvec4 fxPutState(fxState s)\n{\n    return vec4(s.res, 0, intBitsToFloat(s.frame), s.init ? 1 : 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0);\n}\n\n//returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// UTILITIES\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\n\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res)\n{\n    const float theta = 2.35;\n    const vec2 sc = vec2(sin(theta), cos(theta));\n    float d = sdArc((p * vec2(1, -1)), sc, 0.45, 0.01);\n    d = min(d, sdBox((p - vec2(-1.195, .794)) * rot2(-.5), vec2(1, .01)));\n    d = min(d, sdBox((p - vec2( 1.195, .794)) * rot2(.5), vec2(1, .01)));\n    return d;\n}\n\n// the outward normal of the scene at a point\nvec2 normScene(vec2 p, vec2 res)\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res); \n    float x0 = sdScene(p - d.xy, res); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res); \n    float y0 = sdScene(p - d.yx, res); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define SDUV 5U\n#define COLOR 6U\n#define NUM_PARTICLE_DATA_TYPES 7U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(R.x), X, Y)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2(index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec2 pos;     // position\n    vec2 prev;     // velocity\n    vec2 sd;      // shock direction\n    float size;\n    vec3 color;\n    vec2 uv;\n    \n    uvec4 nbs[4]; // neighbors\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 data0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 data1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 data2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 data3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 data4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 data5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, SDUV), 0);\n    vec4 data6 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, COLOR), 0);\n\n    fxParticle p;\n    p.nbs[0] = floatBitsToUint(data0);\n    p.nbs[1] = floatBitsToUint(data1);\n    p.nbs[2] = floatBitsToUint(data2);\n    p.nbs[3] = floatBitsToUint(data3);\n    p.pos = data4.xy;\n    p.prev = data4.zw;\n    p.sd = data5.xy;\n    p.size = data6.w;\n    p.color = data6.xyz;\n    p.uv = data5.zw;\n    \n    return p;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, p.prev);\n    case SDUV:  \n        return vec4(p.sd, p.uv);\n    case COLOR:  \n        return vec4(p.color, p.size);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n// PARTICLE SIM\n\nconst vec2 GRAVITY = vec2(0., -.00002);\nconst float COLLISION_STIFFNESS = .4;\nconst float SHOCK_STIFFNESS = 1.2; // reduces how much the shock direction affects the sim\nconst float MAX_SPEED = PARTICLE_SIZE * .9;\n\n// If not applied carefully, the shock direction can create the a situation where\n// the particles get shoved towards the center of a container. This hack biases\n// the shock direction towards vertical, ensuring we get smaller green and blue\n// areas and more red, and preventing particles from being shoved towards the center.\nconst vec2 SHOCK_BIAS = vec2(1, 1.1);\n\n#define updateParticle(A, B, C, D) updateParticleImpl(A, B, C, D, R, iChannel0)\nvec4 updateParticleImpl(fxState s, fxParticle p, uint id, uint dataType, vec2 res, sampler2D par)\n{\n    if (s.frame <= 0)\n    {\n        vec3 h1 = hash3((id) * uvec3(3, 6, 9));\n        //h1.x = pow(h1.x, 1.3);\n        h1 -= .5;\n        h1.y = h1.y * 6. + 3.5;\n        h1.x = h1.x * .8;\n        h1.x += sign(h1.x);\n\n        p.pos = h1.xy;\n        p.prev = p.pos;// - vec2(.003, -.003);\n        p.sd = vec2(0, 1);\n        p.size = PARTICLE_SIZE * (h1.z + 1.1);\n        if (s.init)\n        {\n            p.uv = vec2(0);\n            p.color = vec3(0);\n        }\n    }\n    else\n    {\n        vec2 vel = p.pos - p.prev;\n        p.prev = p.pos;\n        \n        float s2 = length2(vel);\n        if (s2 > MAX_SPEED * MAX_SPEED)\n            vel = MAX_SPEED * vel / sqrt(s2); // clamp velocity\n        if (p.pos.y > .5) vel *= .999; // damping up off the screen, so the particles don't fall too fast\n        p.pos = p.pos + vel + GRAVITY; // integrate position\n        \n        p.sd *= .5; // dissipate shock direction\n\n        vec2 nsd = p.sd; // new support direction\n        vec2 np = p.pos; // new particle position\n        for(int i = 0; i < 4; i++)\n        {\n            uvec4 nbs = p.nbs[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                uint cid = nbs[j];\n                if(cid==id || cid == -1U || cid >= g_MaxParticles) continue;\n\n                fxParticle n = fxGetParticleImpl(par, uint(res.x), cid);\n\n                vec2 dp = np - n.pos; // delta position\n                float d2 = length2(dp) + PARTICLE_SIZE * 1e-4;\n\n                if (d2 < sqr(PARTICLE_SIZE * 15.))\n                {\n                    float d = sqrt(d2);\n                    vec2 dir = dp / d; // direction\n                    \n                    nsd += n.sd; // diffuse shock direction\n                    \n                    if (d2 < sqr(p.size + n.size))\n                    {\n                       // position correction (reduce when shock direction disagrees)\n                       float stf = COLLISION_STIFFNESS * (SHOCK_STIFFNESS + dot(dir, p.sd)) / SHOCK_STIFFNESS;\n                       np = mix(np, n.pos + (p.size + n.size) * dir, stf);\n                    }\n                }\n            }\n        }\n\n        // limit velocity from collision\n        vec2 cd = np - p.pos; // collision delta\n        float nv2 = length2(cd); // squared speed from collision\n        if (nv2 > sqr(PARTICLE_SIZE))\n            np = PARTICLE_SIZE * cd / sqrt(nv2) + p.pos;\n            \n        p.pos = np;\n        \n        float sd2 = length2(nsd);\n        if (sd2 > 1e-9)\n            p.sd = mix(p.sd, nsd * SHOCK_BIAS / sqrt(sd2), .9); // record new shock direction\n\n        // handle boundary\n        float ds = sdScene(p.pos, res);\n        if (ds < p.size * 2.)\n        {\n            vec2 n = normScene(p.pos, res);\n            p.sd = n; // seed shock direction\n            \n            if (ds < p.size) // collide with boundary\n                p.pos -= n * (ds - p.size);\n        }\n        \n        if (s.init && s.frame == CAPTURE_FRAME)\n            p.uv = (p.pos + .5) * vec2(.15, 1); // record resting position\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id == -1U || id >= g_MaxParticles ||\n      \tid == currentId ||\n        any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C, D) voronoiParticleImpl(iChannel0, iChannel1, R, A, B, C, D)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, fxState s, fxParticle p, uint id, uint dataType)\n{\n    uvec4 closest = fxGetClosestImpl(vor, ivec2(p.pos * res.y + .5 * res));\n    uvec4 bestIds = uvec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (s.frame > 0)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, closest[i], dataType, p.pos);\n        }\n\n        uint searchIterations = 4U;\n        for(uint k = 0U; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash3(uvec3(id + k, id * k, k * uint(s.frame))).x;\n            //pick random id of particle\n            uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n            sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n        }\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n", "buffer_c_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n    {\n        O = updateParticle(s, p, id, dataType);\n        \n        if (dataType == COLOR)\n        {\n            // update particle color from uv\n            vec2 uv = p.uv;\n            if (s.frame > CAPTURE_FRAME)\n                uv.x += float(((s.frame - CAPTURE_FRAME) / 20) % 6) * .1559;\n            vec4 nyan = texture(iChannel2, uv, 0.);\n            O.rgb = mix(PAR_COLOR, nyan.rgb, nyan.a);\n        }\n    }\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n", "buffer_c_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(fxState s, vec2 u);\nvec4 updateState(fxState s);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(s);\n    else\n        O = voronoiScreen(s, u);\n}\n\nvec4 updateState(fxState s)\n{\n    if (iFrame <= 0 || R.x * R.y != abs(s.res))\n    {\n        s.res = -R.x * R.y;\n        s.frame = -1;\n        s.init = true;\n    }\n    else\n    {\n        s.res = abs(s.res);\n        s.frame++;\n\n        if (s.init && s.frame == CAPTURE_FRAME + 1 ||\n            s.frame == RESET_FRAME)\n        {\n            s.init = false;\n            s.frame = -1;\n        }\n        else if (keyClick(KEY_SPACE))\n            s.frame = -1;\n    }\n\n    return fxPutState(s);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u), length2(v.prev - u));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\nvec4 voronoiScreen(fxState s, vec2 u)\n{\n\tvec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (s.frame > 0)\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        int SEARCH_STEPS = int(2e4 / R.y);\n        const float SEARCH_RANGE = 20.;\n\n        for(int i = 0; i < SEARCH_STEPS; ++i)\n        {\n            vec2 h = hash3(uvec3(u, s.frame * 4 + i)).xy - .5;\n\n            sortNbs(fxGetClosest(ivec2(u + vec2(h * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        float h = hash3(uvec3(u, s.frame)).x;\n        uint id = uint(h*float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3yWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1631, 1631, 1707, 1707, 1986], [2243, 2243, 2270, 2270, 2445]], "test": "untested"}
{"id": "cdtcWX", "name": "Tangent Space Matrix CubeSphere", "author": "gehtsiegarnixan", "description": "I made this tangent space matirx from scratch for cubemapping. ", "tags": ["3d", "derivative", "mapping", "cubemapping", "matrix", "tangent", "cubesphere", "finitedifference", "tangentspace", "tbn"], "likes": 1, "viewed": 271, "published": 3, "date": "1695622674", "time_retrieved": "2024-07-30T17:31:56.576052", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis demo showcases the process of translating a vector between tangent \nand world space for cubemapping without relying on any vertices. This \napproach is particularly useful for tasks like transforming directions \nbetween world and tangent space in a cubemap.\n\nTo achieve this, it's essential to compute the normal, tangent, and \nbitangent vectors corresponding to your cubemap. The normal vector \npoints outward from the center of the cube, while the tangent vector \naligns with the direction of the cube's local +X axis in world space. \nSimilarly, the bitangent vector corresponds to the +Y direction of the \ncube.\n\nI couldn't find anyone else doing this for cubemaps, so I built two \nversions. First, I constructed the inverse of the cubemapping function \nand used it with the finite difference method to generate the \napproximate tangent and bitangent vectors. And second, I derived the \ntrue TBN matrix from the derivative of the cubemapping function. I \nomitted the correction part for the true Tangent as it's almost \nidentical but would becomes considerably more expensive and less \nlegible.\n\nThese vectors are combined within a 3x3 matrix (TBN). When this matrix \nis multiplied by a vector, it effectively transforms the vector to world \nspace. Conversely, the inverse of this matrix enables the translation \nof a vector from world space back to the tangent space of your cubemap.\n\nThe visual representation consists of two quiver plots. In red, we have \nthe derivative TBN quiver plot, while the finite difference TBN matrix \nis depicted in green on the sphere. These two representations are nearly \nidentical, resulting in arrows that are consistently yellow. The \nworldspace flow direction is shown with a RGB flowplot.\n\nSee here how I got to the math with my python script:\nhttps://pastebin.com/8mzdNrTt\n\nSee here how the quiverplot works:\nhttps://www.shadertoy.com/view/dssyzf\n\nSee here how the flow plot works:\nhttps://www.shadertoy.com/view/dlSyDw\n\nThis plot has mouse controls to look around. Play with the constants\nbelow to edit the visualized vectors.\n\nMaking this was quite a pain.\n*/\n\n// Define your custom direction here\n//#define DIRECTION vec3(1.,0.,0.)\n\n// enable DIRECTION is worldspace, disable DIRECTION is tangent space\n#define DIRECTIONIWORLDSPACE\n\n// holds cubemap params\nstruct cubemap {\n    vec2 uv; //texture coordinates\n    vec3 side; // vector pointing at the side of the cube\n};\n\n// Cubemap, that is folded so all but 6 edges align\ncubemap CubemapFolded(vec3 uvw) {\n    // bitmask for flipping some sides\n    vec3 sUVW = sign(uvw);\n\n    // intersect cube\n    vec3 n = abs(uvw);\n    vec3 v;\n    vec3 side;\n    if (n.x > n.y && n.x > n.z) {\n        // x sides\n        v = vec3(uvw.x, uvw.y, sUVW.x * uvw.z);\n        side = vec3(sUVW.x, 0., 0.);\n    } else if (n.y > n.z) {\n        // y sides\n        v = vec3(uvw.y, -uvw.x, sUVW.y * uvw.z);\n        side = vec3(0., sUVW.y, 0.);\n    } else {\n        // z sides\n        v = vec3(uvw.z, sUVW.z * uvw.x, uvw.y);\n        side = vec3(0., 0., sUVW.z);\n    }\n    \n    // project into face\n    vec2 uv = v.yz/v.x;\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    uv = 0.5+0.5*uv;\n    \n    return cubemap(uv, side);\n}\n\n// TBN Matrix from derivatives for the cubemapping above\nmat3 cubeTBNMatrixDerivative(vec3 normal) {\n    // bitmask for flipping some sides\n    vec3 sgn = sign(normal);\n    \n    // intersect cube\n    vec3 n = abs(normal);\n    vec3 tangent;\n    vec3 bitangent; // bitangent is not perpendicular to tangent!\n    \n    if (n.x > n.y && n.x > n.z) {\n        // x sides\n        tangent = vec3(- normal.y,                         // C\n                       (1.+ normal.y * normal.y)   *sgn.x, // B\n                       - normal.y * normal.z       *sgn.x  // A\n                       );\n        bitangent = vec3(- normal.z                *sgn.x, // C\n                         - normal.y * normal.z,            // A\n                         1.+ normal.z * normal.z           // B\n                         );\n    } else if (n.y > n.z) {\n        // y sides\n        tangent = vec3((1.+ normal.x * normal.x)   *sgn.y, // B\n                       - normal.x,                         // C\n                       - normal.x * normal.z       *sgn.y  // A\n                       ) * -1.; // flipped\n        bitangent = vec3(- normal.x * normal.z,            // A\n                         - normal.z                *sgn.y, // C\n                         1. + normal.x * normal.x          // B\n                         );\n    } else {\n        // z sides\n        tangent = vec3(1.+ normal.y * normal.y,            // B\n                       - normal.x * normal.y,              // A\n                       - normal.x                  *sgn.z  // C\n                       );\n        bitangent = vec3(- normal.x * normal.y     *sgn.z, // A\n                         (1.+ normal.x * normal.x) *sgn.z, // B\n                         - normal.y                        // C\n                         );\n    }\n    \n    // Normalize the vectors after branching\n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n    \n    return mat3(tangent, bitangent, normal);\n}\n\n// inverse of CubemapFolded function\nvec3 CubemapUnfolded(cubemap cube) {\n    vec2 uv = cube.uv;\n    vec3 side = cube.side;\n    \n    // rescale -1 to 1\n    uv = uv*2.-1.;\n    \n    // reverse Cass Everitt's piecewise quadratic warp \n    uv = sign(uv) * -1.108412 * (-1.451096 + sqrt(2.105679 - 1.804383 * abs(uv)));\n    \n    // recreate normal vector with side being up\n    float partial = sqrt((uv.x*uv.x) + (uv.y*uv.y) +1.);\n    vec3 normal = vec3(uv.x/partial, uv.y/partial, 1./partial);\n    \n    // flip normals to their sides\n    vec3 n = abs(side);\n    vec3 uvw;\n    if (n.x > 0.5) {\n        // x sides\n        uvw = vec3(normal.z * side.x, normal.x * side.x, normal.y);\n    } else if (n.y > 0.5) {\n        // y sides\n        uvw = vec3(-normal.x * side.y, normal.z * side.y, normal.y);\n    } else {\n        // z sides\n        uvw = vec3(normal.x, normal.y * side.z, normal.z * side.z);\n    }\n    \n    return uvw;\n}\n\n// TBN Matrix using finite difference for the cubemapping above\nmat3 cubeTBNMatrixFiniteDif(vec3 normal) {\n    // cubemapping\n    cubemap cube = CubemapFolded(normal);\n\n    // if you make this smaller it gets more accurate, \n    // but you may run into float errors, so KISS\n    float accuracy = 0.001;\n    \n    // make tangent\n    vec2 uOffsetUV = cube.uv + vec2(accuracy, 0.); // tiny offset in x dir\n    vec3 uNormalOffset = CubemapUnfolded(cubemap(uOffsetUV, cube.side));\n    vec3 tangent = normalize(uNormalOffset - normal);\n    \n    // make bitangent ! not orthogonal to tangnet !\n    vec2 vOffsetUV = cube.uv + vec2(0., accuracy); // tiny offset in y dir\n    vec3 vNormalOffset = CubemapUnfolded(cubemap(vOffsetUV, cube.side));\n    // vec3 bitangent = cross(normal, tangent); // WRONG not orthogonal!!!\n    vec3 bitangent = normalize(vNormalOffset - normal);\n    \n    return mat3(tangent, bitangent, normal);\n}\n\nvec3 TangentSpacePlot(vec3 normal, vec3 direction) {\n    // cubemapping\n    cubemap cube = CubemapFolded(normal);\n    vec2 uv = cube.uv;\n    \n    // tangent space matrix\n    mat3 tbnMatrixDer = cubeTBNMatrixDerivative(normal);\n    mat3 tbnMatrixFin = cubeTBNMatrixFiniteDif(normal);\n    \n    #ifdef DIRECTIONIWORLDSPACE\n        // translate world space vector to tangent space\n        vec3 dirWSDer = direction;\n        vec2 dirTSDer = vec3(inverse(tbnMatrixDer) * direction).xy;\n        \n        vec3 dirWSFin = direction;\n        vec2 dirTSFin = vec3(inverse(tbnMatrixFin) * direction).xy;\n    #else\n        // translate tangent space vector to world space\n        vec3 dirWSDer = tbnMatrixDer * vec3(direction.xyz);\n        vec2 dirTSDer = direction.xy;\n        \n        vec3 dirWSFin = tbnMatrixFin * vec3(direction.xyz);\n        vec2 dirTSFin = direction.xy;\n    #endif\n    \n    //Tangent space plot\n    float tsPlotDer = quiverPlot(uv, dirTSDer, 10.);    \n    float tsPlotFin = quiverPlot(uv, dirTSFin, 10.);\n    \n    // World Space flow plot\n    float time = iTime * 0.25;\n    vec3 wsPlot = flowPlot(normal, dirWSFin, time);\n    \n    // making joint version of all plots in a color\n    vec3 col = vec3(max(wsPlot.x, tsPlotDer), max(wsPlot.y, tsPlotFin), wsPlot.z);\n    return col;\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx = mm2(um.x*5.);\n    mat2 my = mm2(um.y*5.);\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float t = iSphere(ro,rd);\n    \n    // nice spinning animation while unset\n    #ifdef DIRECTION\n        vec3 direction = DIRECTION;\n    #else\n        float time = iTime * 0.5;\n        float c = cos(time);\n        float s = sin(time);\n        vec3 direction = vec3(c*s,s*s,c);\n    #endif\n    \n    vec3 col;\n    \n    if (t > 0.)\n    {\n    \tvec3 pos = ro+rd*t;\n        // Sphere mapping\n    \tcol = TangentSpacePlot(pos, direction);\n    } else {\n        // Background mapping\n        vec3 pos = rd;  \n        col = direction *0.5+0.5;\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "//_____________________Quiver Plot______________________________\n\n// Rotate coordinates in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n    float lineThickness = 0.03;    // Thickness of the arrow line\n    float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    float maxSize = 0.9;           // Maximum arrow length (1 should be the max)\n    float minSize = 0.2;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        return step(arrowDist, 0.0); // no AA\n        //float blur = (gridSize * 1.0)/(size * 720.);\n        //return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}\n\n//_____________________Flow Plot______________________________\n\n// 3D cube grid with lines in RGB for XYZ axes\nvec3 cubeGrid(vec3 uvw, float lineThickness) {\n    // Side distance of the cube\n    vec3 sideDistBig = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Smaller scaled side distance of the cube\n    float detailScale = 4.0;\n    uvw *= detailScale;\n    vec3 sideDistDetail = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Merge grids\n    vec3 joined = min(sideDistBig, sideDistDetail);\n    \n    // Create hard outlines of sides\n    return step(joined, vec3(lineThickness)); \n}\n\n// viszalizes 3D Vector\nvec3 flowPlot(vec3 uvw, vec3 direction, float time) {\n    // should probably be input paramters\n    float gridScale = 1.3;\n    float lineThickness = 0.02;\n    float vectorScale = 0.15;\n    \n    direction *= vectorScale;\n    \n    uvw *= gridScale;\n    \n    // Static grid (looks calmer)\n    vec3 grid = cubeGrid(uvw, lineThickness);\n    \n    // Animated grid\n    int count = 7;\n    for (int index = 1; index < count; index += 1) {\n        // Unique percentage of each individual grid \n        float percent = fract(float(index) / float(count - 1) + time);        \n        // Fading brightness\n        float brightness = 1.0 - percent;\n        \n        // Scale offset\n        vec3 offset = percent * direction;\n        \n        // Sample grid\n        vec3 aniGrid = cubeGrid(uvw - offset, lineThickness);\n        \n        // Apply brightness which fades with distance\n        aniGrid *= brightness;\n\n        // Add to the existing grid color output\n        grid = max(grid, aniGrid);\n    }\n    \n    return grid;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtcWX.jpg", "access": "api", "license": "mit", "functions": [[3503, 3555, 3588, 3627, 4484], [4486, 4543, 4586, 4625, 6439], [6441, 6478, 6514, 6514, 7361], [7363, 7427, 7469, 7488, 8280], [8282, 8282, 8334, 8353, 9571], [9718, 9718, 9739, 9739, 9791], [9793, 9793, 9832, 9832, 9985], [9987, 9987, 10044, 10044, 10993]], "test": "untested"}
{"id": "mdtcDN", "name": "3D Magnetic Blocks", "author": "wyatt", "description": "this was hard and still has some issues...", "tags": ["rigidbodyphysics"], "likes": 7, "viewed": 289, "published": 3, "date": "1695612759", "time_retrieved": "2024-07-30T17:31:57.818730", "image_code": "obj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,mat3(\n            A(6,i).xyz,\n            A(7,i).xyz,\n            A(8,i).xyz),\n        vec3(0),\n        vec3(0)\n    );\n}\nfloat absmin(float a, float b) {if (b < 0. ) return a; if (a < 0.) return b; if (b < a) return b; return a; }\nfloat tri (vec3 p, vec3 d, obj o, vec3 a, vec3 b, vec3 c) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    return iTriangle(p,d,a,b,c);//iTriple(p,d,a,b,c,.02,.02);\n}\nMain {\n    vec3 p = vec3(0,0,-1.2),\n         d = normalize(vec3(2.*(U-.5*R)/R.y,1));\n    float t = -1.2;\n    p.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    \n    \n    float x = 1e9;\n    x = absmin(x, iPlane(p-vec3(1,0,0),d,vec3(1,0,0)) );\n    x = absmin(x,iPlane(p-vec3(-1,0,0),d,vec3(1,0,0)));\n    x = absmin(x,iPlane(p-vec3(0,0,1),d,vec3(0,0,1)));\n    x = absmin(x,iPlane(p-vec3(0,0,-1),d,vec3(0,0,1)));\n    x = absmin(x,iPlane(p-vec3(0,-.5,0),d,vec3(0,1,0)));\n   for (int i = 0;  i < N; i++) {\n        obj o = get(i);\n        \n        x = absmin(x,tri(p,d,o,_T1));\n        x = absmin(x,tri(p,d,o,_T2));\n        x = absmin(x,tri(p,d,o,_T3));\n        x = absmin(x,tri(p,d,o,_T4));\n        x = absmin(x,tri(p,d,o,_T5));\n        x = absmin(x,tri(p,d,o,_T6));\n        x = absmin(x,tri(p,d,o,_T7));\n        x = absmin(x,tri(p,d,o,_T8));\n        x = absmin(x,tri(p,d,o,_T9));\n        x = absmin(x,tri(p,d,o,_T10));\n        x = absmin(x,tri(p,d,o,_T11));\n        x = absmin(x,tri(p,d,o,_T12));\n        \n        \n    }\n    \n    vec3 q = p + d*x;\n    vec3 b = vec3(0);\n    for (int i = min(0,iFrame); i < N; i++) {\n        obj o = get(i);\n\t\tvec3 r = (q-o.m)*o.io;\n\t\tb += B(r,vec3(1.01*_s_),vec3(0),vec3(1,0,0))*o.o;\n    }\n    \n     Q =  (sin(-2.+length(b)*.25+vec4(1,2,3,4)));\n     float s = abs(sin(b.x*5.));\n    Q *= smoothstep(.0,1.*fwidth(s),s);\n    vec3 no =normalize(vec3(R*vec2(dFdx(x),dFdy(x)),1));\n    Q.xyz *= .7+.5*no.z;\n    //Q = texture(iChannel0,floor((U)*.02)/R);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 7\n\n#define dt .08\n\n#define G 6e-4\n#define K  3e-5\n#define K1 .01\n#define K2 .1\n#define K3 .000\n\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define R iResolution.xy\n#define A(x,y) texelFetch(iChannel0,ivec2(x,y),0)\n\n#define _s_ vec3(.3,.2,.15)\n\n#define _a _s_*vec3(-1, -1,  1)\n#define _b _s_*vec3( 1, -1,  1)\n#define _c _s_*vec3(-1,  1,  1)\n#define _d _s_*vec3( 1,  1,  1)\n#define _e _s_*vec3(-1, -1, -1)\n#define _f _s_*vec3( 1, -1, -1)\n#define _g _s_*vec3(-1,  1, -1)\n#define _h _s_*vec3( 1,  1, -1)\n\n// Define the 12 triangles\n#define _T1  _a, _e, _b\n#define _T2  _b, _e, _f\n#define _T3  _b, _f, _d\n#define _T4  _d, _f, _h\n#define _T5  _d, _h, _c\n#define _T6  _c, _h, _g\n#define _T7  _c, _g, _a\n#define _T8  _a, _g, _e\n#define _T9  _c, _b, _d\n#define _T10 _c, _a, _b\n#define _T11 _g, _f, _h\n#define _T12 _g, _f, _e\n\n\n\nstruct obj {\n    vec3 m; // 0\n    mat3 o; // 1 2 3\n    vec3 v; // 4\n    vec3 s; // 5\n    \n    mat3 io; \n    \n    vec3 f; \n    vec3 t; \n};\n\nmat3 matrix (vec3 r) { \n   if (length(r)==0.) return mat3(1);\n   float a = length(r);\n   vec3 o = normalize(r);\n   float c = cos(a), t = 1.-c;\n   float s = sin(a);\n   return mat3(\n       t*o.x*o.x+c,t*o.x*o.y-o.z*s,t*o.x*o.z+o.y*s,\n       t*o.x*o.y+o.z*s,t*o.y*o.y+c,t*o.y*o.z-o.x*s,\n       t*o.x*o.z-o.y*s,t*o.y*o.z+o.x*s,t*o.z*o.z+c\n   \n   );\n}\nfloat iSphere (vec3 p, vec3 d, vec3 m, float r) {\n\n    p -= m;\n    \n    float b = 2.*dot(p,d);\n    float c = dot(p,p)-r*r;\n    float s = (b*b-4.*c);\n    if (s < 0.) return 1e9;\n    else return .5*(-b-sqrt(s));\n\n}\nfloat iSegment (vec3 p, vec3 d, vec3 a, vec3 b, float r) {    \n    vec3 q = p-a;\n    vec3 u = b-a;\n    float du = dot(d,u);\n    float uu = dot(u,u);\n    float qu = dot(q,u);\n    float dq = dot(d,q);\n    float qq = dot(q,q);\n    float a_ = 1. - du*du/uu;\n    float b_ = 2.*(dq - qu*du/uu);\n    float c_ = qq - qu*qu/uu - r*r;\n    float s = b_*b_-4.*a_*c_;\n    if (s < 0.) return 1e9;\n    float i = (-b_-sqrt(s))/(2.*a_);\n    float x = dot(p+d*i-a,u)/uu;\n    if (x < 0. || x > 1.) return 1e9;\n    return i;\n}\nfloat iPlane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\nfloat iTriangle (vec3 p, vec3 d, vec3 a, vec3 b, vec3 c) {\n    vec3 n = normalize(cross(b-a,c-a));\n    float i = -dot(p-a,n)/dot(d,n);\n    vec3 x = p + d*i;\n    float ab = dot(x-a,cross(n,normalize(b-a)));\n    float bc = dot(x-b,cross(n,normalize(c-b)));\n    float ca = dot(x-c,cross(n,normalize(a-c)));\n    if (ab<0.||bc<0.||ca<0.) return 1e9;\n    return i;\n}\n\nfloat iTriple (vec3 p, vec3 d, vec3 a, vec3 b, vec3 c, float r1, float r2) {\n       float i = 1e9;\n    \n     i = min(i,iSphere(p,d,a,r1));\n     i = min(i,iSphere(p,d,b,r1));\n     i = min(i,iSphere(p,d,c,r1));\n     \n     i = min(i,iSegment(p,d,a,b,r2));\n     i = min(i,iSegment(p,d,b,c,r2));\n     i = min(i,iSegment(p,d,c,a,r2));\n     \n     i = min(i,iTriangle(p,d,a,b,c));\n     return i;\n}\n\n\nfloat dSegment (vec3 p, vec3 a, vec3 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat dBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max((abs(p.x)-h.x)*h.y,(abs(p.y)-h.y)*h.x);\n\t\t}\nmat3 rotationMatrix(float a, float b, float c)\n{\n    float cosA = cos(a);\n    float sinA = sin(a);\n    float cosB = cos(b);\n    float sinB = sin(b);\n    float cosC = cos(c);\n    float sinC = sin(c);\n\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cosA, -sinA,\n        0.0, sinA, cosA\n    );\n\n    mat3 rotY = mat3(\n        cosB, 0.0, sinB,\n        0.0, 1.0, 0.0,\n        -sinB, 0.0, cosB\n    );\n\n    mat3 rotZ = mat3(\n        cosC, -sinC, 0.0,\n        sinC, cosC, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    // Combine the three rotation matrices\n    return rotZ * rotY * rotX;\n}\nvec3 velocity (obj o, vec3 p) {\n    return o.v+cross(o.s,p-o.m);\n}\nvoid impulse (inout obj o, vec3 p, vec3 f) {\n    vec3 r = p-o.m;\n    if (length(r)>0.) {\n        o.f += f*dot(normalize(f),normalize(-r))+f*cross(normalize(r),o.s);\n        o.t += cross(r,f)/(_s_);\n    } else o.f += f;\n}\nbool line_triangle (vec3 a, vec3 b, vec3 e, vec3 g, vec3 h, inout vec3 p, inout vec3 f) {\n    vec3 u = normalize(b-a);\n    float i = iTriangle (a,u,e,g,h);\n    if (i < 0. || i > length(a-b)) {\n        p = vec3(0), f = vec3(0);\n        return false;\n    } else {\n            p = a + u*i;\n            vec3 k = u;\n            if (length(p-b) > length(p-a)) k = -u;\n            f = normalize(cross(g-e,h-e));\n            f *= -K1*dot(k,f)*length(a-b);\n            return true;\n    }\n}\n\nvec3 integral (vec3 p, vec3 h, vec3 j, vec3 m) {\n\t\t    p -= h;\n\t\t    float L = length(p);\n\t\t    float X = p.x, Y = p.y, Z = p.z,\n\t\t          A = j.x, B = j.y, C = j.z;\n\t\t    vec3 bj = vec3(\n\t\t             B*(\n\t\t                 -sign(X)*abs(Z)*atan(-Y*abs(X)/L/abs(Z))\n\t\t                 +X/2.*(log(L-Y)-log(L+Y))\n\t\t                 +Y/2.*(log(L-X)-log(L+X))\n\t\t             ) + \n\t\t             C*(\n\t\t                 -sign(X)*abs(Y)*atan(-Z*abs(X)/L/abs(Y))\n\t\t                 +X/2.*(log(L-Z)-log(L+Z))\n\t\t                 +Z/2.*(log(L-X)-log(L+X))\n\t\t             )\n\t\t           , \n\t\t             C*(\n\t\t                 -sign(Y)*abs(X)*atan(-Z*abs(Y)/L/abs(X))\n\t\t                 +Y/2.*(log(L-Z)-log(L+Z))\n\t\t                 +Z/2.*(log(L-Y)-log(L+Y))\n\t\t             ) + \n\t\t             A*(\n\t\t                 -sign(Y)*abs(Z)*atan(-X*abs(Y)/L/abs(Z))\n\t\t                 +Y/2.*(log(L-X)-log(L+X))\n\t\t                 +X/2.*(log(L-Y)-log(L+Y))\n\t\t             )\n\t\t           ,\n\t\t             A*(\n\t\t                 -sign(Z)*abs(Y)*atan(-X*abs(Z)/L/abs(Y))\n\t\t                 +Z/2.*(log(L-X)-log(L+X))\n\t\t                 +X/2.*(log(L-Z)-log(L+Z))\n\t\t             ) + \n\t\t             B*(\n\t\t                 -sign(Z)*abs(X)*atan(-Y*abs(Z)/L/abs(X))\n\t\t                 +Z/2.*(log(L-Y)-log(L+Y))\n\t\t                 +Y/2.*(log(L-Z)-log(L+Z))\n\t\t             )\n\t\t         );\n\t\t   \n\t\t    A = m.x;\n\t\t    B = m.y;\n\t\t    C = m.z;\n\t\t    vec3 bm = -vec3(\n\t\t            +A*sign(X)*sign(Y)*atan(-Z*abs(Y)/L/abs(X))\n\t\t            -B*log((L-Z)/sqrt(X*X+Y*Y))\n\t\t            -C*sign(Y)*atan(L/abs(Y))\n\t\t            \n\t\t            +A*sign(X)*sign(Z)*atan(-Y*abs(Z)/L/abs(X))\n\t\t            -C*log((L-Y)/sqrt(X*X+Z*Z))\n\t\t            -B*sign(Z)*atan(L/abs(Z))\n\t\t          ,\n\t\t            +B*sign(Y)*sign(X)*atan(-Z*abs(X)/L/abs(Y))\n\t\t            -A*log((L-Z)/sqrt(X*X+Y*Y))\n\t\t            -C*sign(X)*atan(L/abs(X))\n\t\t            \n\t\t            +B*sign(Y)*sign(Z)*atan(-X*abs(Z)/L/abs(Y))\n\t\t            -C*log((L-X)/sqrt(Z*Z+Y*Y))\n\t\t            -A*sign(Z)*atan(L/abs(Z))\n\t\t          ,\n\t\t            +C*sign(Z)*sign(Y)*atan(-X*abs(Y)/L/abs(Z))\n\t\t            -B*log((L-X)/sqrt(Z*Z+Y*Y))\n\t\t            -A*sign(Y)*atan(L/abs(Y))\n\t\t            \n\t\t            +C*sign(Z)*sign(X)*atan(-Y*abs(X)/L/abs(Z))\n\t\t            -A*log((L-Y)/sqrt(Z*Z+X*X))\n\t\t            -B*sign(X)*atan(L/abs(X))\n\t\t    );\n\t\t         \n\t\t    return bj+bm;\n\n\t\t}\n\n\n\n\t\tvec3 B (vec3 p, vec3 h, vec3 j, vec3 m) {\n\t\t    return (\n\t\t      (\n\t\t        ( integral(p,vec3(+h.x,+h.y,+h.z),j,m) - integral(p,vec3(-h.x,+h.y,+h.z),j,m) ) \n\t\t        \n\t\t            -\n\t\t         \n\t\t        ( integral(p,vec3(+h.x,-h.y,+h.z),j,m) - integral(p,vec3(-h.x,-h.y,+h.z),j,m) ) \n\t\t      ) \n\t\t      \n\t\t          - \n\t\t      \n\t\t      (\n\t\t        ( integral(p,vec3(+h.x,+h.y,-h.z),j,m) - integral(p,vec3(-h.x,+h.y,-h.z),j,m) ) \n\t\t        \n\t\t            -\n\t\t         \n\t\t        ( integral(p,vec3(+h.x,-h.y,-h.z),j,m) - integral(p,vec3(-h.x,-h.y,-h.z),j,m) ) \n\t\t      )\n\t\t    );\n\t\t}", "buffer_a_code": "obj get (int i);vec4 set (obj o,int x);\n\nvoid triangle_triangle (inout obj o, inout obj q, vec3 a, vec3 b, vec3 c, vec3 e, vec3 g, vec3 h) {\n    vec3 _, f;\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    e = e*q.o+q.m;\n    g = g*q.o+q.m;\n    h = h*q.o+q.m;\n    if (line_triangle(a,b,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(b,c,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(c,a,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }    \n    \n    if (line_triangle(e,g,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(g,h,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    } \n    if (line_triangle(h,e,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n}\nvoid cube_cube(inout obj o, inout obj q) {\n    triangle_triangle(o,q,_T1,_T1);\n    triangle_triangle(o,q,_T1,_T2);\n    triangle_triangle(o,q,_T1,_T3);\n    triangle_triangle(o,q,_T1,_T4);\n    triangle_triangle(o,q,_T1,_T5);\n    triangle_triangle(o,q,_T1,_T6);\n    triangle_triangle(o,q,_T1,_T7);\n    triangle_triangle(o,q,_T1,_T8);\n    triangle_triangle(o,q,_T1,_T9);\n    triangle_triangle(o,q,_T1,_T10);\n    triangle_triangle(o,q,_T1,_T11);\n    triangle_triangle(o,q,_T1,_T12);\n    triangle_triangle(o,q,_T2,_T1);\n    triangle_triangle(o,q,_T2,_T2);\n    triangle_triangle(o,q,_T2,_T3);\n    triangle_triangle(o,q,_T2,_T4);\n    triangle_triangle(o,q,_T2,_T5);\n    triangle_triangle(o,q,_T2,_T6);\n    triangle_triangle(o,q,_T2,_T7);\n    triangle_triangle(o,q,_T2,_T8);\n    triangle_triangle(o,q,_T2,_T9);\n    triangle_triangle(o,q,_T2,_T10);\n    triangle_triangle(o,q,_T2,_T11);\n    triangle_triangle(o,q,_T2,_T12);\n    triangle_triangle(o,q,_T3,_T1);\n    triangle_triangle(o,q,_T3,_T2);\n    triangle_triangle(o,q,_T3,_T3);\n    triangle_triangle(o,q,_T3,_T4);\n    triangle_triangle(o,q,_T3,_T5);\n    triangle_triangle(o,q,_T3,_T6);\n    triangle_triangle(o,q,_T3,_T7);\n    triangle_triangle(o,q,_T3,_T8);\n    triangle_triangle(o,q,_T3,_T9);\n    triangle_triangle(o,q,_T3,_T10);\n    triangle_triangle(o,q,_T3,_T11);\n    triangle_triangle(o,q,_T3,_T12);\n    triangle_triangle(o,q,_T4,_T1);\n    triangle_triangle(o,q,_T4,_T2);\n    triangle_triangle(o,q,_T4,_T3);\n    triangle_triangle(o,q,_T4,_T4);\n    triangle_triangle(o,q,_T4,_T5);\n    triangle_triangle(o,q,_T4,_T6);\n    triangle_triangle(o,q,_T4,_T7);\n    triangle_triangle(o,q,_T4,_T8);\n    triangle_triangle(o,q,_T4,_T9);\n    triangle_triangle(o,q,_T4,_T10);\n    triangle_triangle(o,q,_T4,_T11);\n    triangle_triangle(o,q,_T4,_T12);\n    triangle_triangle(o,q,_T5,_T1);\n    triangle_triangle(o,q,_T5,_T2);\n    triangle_triangle(o,q,_T5,_T3);\n    triangle_triangle(o,q,_T5,_T4);\n    triangle_triangle(o,q,_T5,_T5);\n    triangle_triangle(o,q,_T5,_T6);\n    triangle_triangle(o,q,_T5,_T7);\n    triangle_triangle(o,q,_T5,_T8);\n    triangle_triangle(o,q,_T5,_T9);\n    triangle_triangle(o,q,_T5,_T10);\n    triangle_triangle(o,q,_T5,_T11);\n    triangle_triangle(o,q,_T5,_T12);\n    triangle_triangle(o,q,_T6,_T1);\n    triangle_triangle(o,q,_T6,_T2);\n    triangle_triangle(o,q,_T6,_T3);\n    triangle_triangle(o,q,_T6,_T4);\n    triangle_triangle(o,q,_T6,_T5);\n    triangle_triangle(o,q,_T6,_T6);\n    triangle_triangle(o,q,_T6,_T7);\n    triangle_triangle(o,q,_T6,_T8);\n    triangle_triangle(o,q,_T6,_T9);\n    triangle_triangle(o,q,_T6,_T10);\n    triangle_triangle(o,q,_T6,_T11);\n    triangle_triangle(o,q,_T6,_T12);\n    triangle_triangle(o,q,_T7,_T1);\n    triangle_triangle(o,q,_T7,_T2);\n    triangle_triangle(o,q,_T7,_T3);\n    triangle_triangle(o,q,_T7,_T4);\n    triangle_triangle(o,q,_T7,_T5);\n    triangle_triangle(o,q,_T7,_T6);\n    triangle_triangle(o,q,_T7,_T7);\n    triangle_triangle(o,q,_T7,_T8);\n    triangle_triangle(o,q,_T7,_T9);\n    triangle_triangle(o,q,_T7,_T10);\n    triangle_triangle(o,q,_T7,_T11);\n    triangle_triangle(o,q,_T7,_T12);\n    triangle_triangle(o,q,_T8,_T1);\n    triangle_triangle(o,q,_T8,_T2);\n    triangle_triangle(o,q,_T8,_T3);\n    triangle_triangle(o,q,_T8,_T4);\n    triangle_triangle(o,q,_T8,_T5);\n    triangle_triangle(o,q,_T8,_T6);\n    triangle_triangle(o,q,_T8,_T7);\n    triangle_triangle(o,q,_T8,_T8);\n    triangle_triangle(o,q,_T8,_T9);\n    triangle_triangle(o,q,_T8,_T10);\n    triangle_triangle(o,q,_T8,_T11);\n    triangle_triangle(o,q,_T8,_T12);\n    triangle_triangle(o,q,_T9,_T1);\n    triangle_triangle(o,q,_T9,_T2);\n    triangle_triangle(o,q,_T9,_T3);\n    triangle_triangle(o,q,_T9,_T4);\n    triangle_triangle(o,q,_T9,_T5);\n    triangle_triangle(o,q,_T9,_T6);\n    triangle_triangle(o,q,_T9,_T7);\n    triangle_triangle(o,q,_T9,_T8);\n    triangle_triangle(o,q,_T9,_T9);\n    triangle_triangle(o,q,_T9,_T10);\n    triangle_triangle(o,q,_T9,_T11);\n    triangle_triangle(o,q,_T9,_T12);\n    triangle_triangle(o,q,_T10,_T1);\n    triangle_triangle(o,q,_T10,_T2);\n    triangle_triangle(o,q,_T10,_T3);\n    triangle_triangle(o,q,_T10,_T4);\n    triangle_triangle(o,q,_T10,_T5);\n    triangle_triangle(o,q,_T10,_T6);\n    triangle_triangle(o,q,_T10,_T7);\n    triangle_triangle(o,q,_T10,_T8);\n    triangle_triangle(o,q,_T10,_T9);\n    triangle_triangle(o,q,_T10,_T10);\n    triangle_triangle(o,q,_T10,_T11);\n    triangle_triangle(o,q,_T10,_T12);\n    triangle_triangle(o,q,_T11,_T1);\n    triangle_triangle(o,q,_T11,_T2);\n    triangle_triangle(o,q,_T11,_T3);\n    triangle_triangle(o,q,_T11,_T4);\n    triangle_triangle(o,q,_T11,_T5);\n    triangle_triangle(o,q,_T11,_T6);\n    triangle_triangle(o,q,_T11,_T7);\n    triangle_triangle(o,q,_T11,_T8);\n    triangle_triangle(o,q,_T11,_T9);\n    triangle_triangle(o,q,_T11,_T10);\n    triangle_triangle(o,q,_T11,_T11);\n    triangle_triangle(o,q,_T11,_T12);\n    triangle_triangle(o,q,_T12,_T1);\n    triangle_triangle(o,q,_T12,_T2);\n    triangle_triangle(o,q,_T12,_T3);\n    triangle_triangle(o,q,_T12,_T4);\n    triangle_triangle(o,q,_T12,_T5);\n    triangle_triangle(o,q,_T12,_T6);\n    triangle_triangle(o,q,_T12,_T7);\n    triangle_triangle(o,q,_T12,_T8);\n    triangle_triangle(o,q,_T12,_T9);\n    triangle_triangle(o,q,_T12,_T10);\n    triangle_triangle(o,q,_T12,_T11);\n    triangle_triangle(o,q,_T12,_T12);\n}\nvoid tri_boundaries (inout obj o, vec3 a, vec3 b, vec3 c) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    vec3 da = -velocity(o,a);\n    vec3 db = -velocity(o,b);\n    vec3 dc = -velocity(o,c);\n    \n    if (a.y < -.5) impulse(o, a, vec3(0,-a.y-.5,0) + K3*da);\n    if (b.y < -.5) impulse(o, b, vec3(0,-b.y-.5,0) + K3*db);\n    if (c.y < -.5) impulse(o, c, vec3(0,-c.y-.5,0) + K3*dc);\n    \n    if (a.x < -1.) impulse(o, a, vec3(-a.x-1.,0,0) + K3*da);\n    if (b.x < -1.) impulse(o, b, vec3(-b.x-1.,0,0) + K3*db);\n    if (c.x < -1.) impulse(o, c, vec3(-c.x-1.,0,0) + K3*dc);\n    \n    if (a.z < -1.) impulse(o, a, vec3(0,0,-a.z-1.) + K3*da);\n    if (b.z < -1.) impulse(o, b, vec3(0,0,-b.z-1.) + K3*db);\n    if (c.z < -1.) impulse(o, c, vec3(0,0,-c.z-1.) + K3*dc);\n    \n    if (a.x > +1.) impulse(o, a, vec3(1.-a.x,0,0) +  K3*da);\n    if (b.x > +1.) impulse(o, b, vec3(1.-b.x,0,0) +  K3*db);\n    if (c.x > +1.) impulse(o, c, vec3(1.-c.x,0,0) +  K3*dc);\n    \n    if (a.z > +1.) impulse(o, a, vec3(0,0,1.-a.z) +  K3*da);\n    if (b.z > +1.) impulse(o, b, vec3(0,0,1.-b.z) +  K3*db);\n    if (c.z > +1.) impulse(o, c, vec3(0,0,1.-c.z) +  K3*dc);\n    \n}\nvoid boundaries (inout obj o) {\n\n    tri_boundaries(o,_T1);\n    tri_boundaries(o,_T2);\n    tri_boundaries(o,_T3);\n    tri_boundaries(o,_T4);\n    tri_boundaries(o,_T5);\n    tri_boundaries(o,_T6);\n    tri_boundaries(o,_T7);\n    tri_boundaries(o,_T8);\n    tri_boundaries(o,_T9);\n    tri_boundaries(o,_T10);\n    tri_boundaries(o,_T11);\n    tri_boundaries(o,_T12);\n}\nvoid magnet_magnet(inout obj o, obj q) {\n    vec2 e = vec2(1e-2,0);\n    vec3 r = (o.m-q.m)*q.io;\n    float k = K;\n    \n    float b0 = dot(B(r,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bx = dot(B(r+e.xyy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float by = dot(B(r+e.yxy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bz = dot(B(r+e.yyx,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    \n    o.f += k*vec3(bx-b0,by-b0,bz-b0)/e.x;\n        \n    o.t += k*cross(vec3(1,0,0),B(r,vec3(_s_),vec3(0),vec3(1,0,0))*q.o);\n\n}\nMain {\n    \n    int x = int(U.x); // nth feature\n    int y = int(U.y); // nth object\n    if (x > 8 || y > N) discard;  \n    obj me = get(y);\n    \n    \n    me.f = vec3(0,-G,0);\n    me.t = vec3(0);\n    \n    for (int i = min(0,iFrame); i < N; i++) if (i != y) { \n        \n        obj o = get(i);\n        \n        magnet_magnet(me,o);\n        \n        if (length(o.m-me.m)<2.01*length(_s_)) cube_cube(me,o);\n    \n    }\n    \n    boundaries(me);\n    me.v = dt*me.f + me.v*.999;\n    me.m = dt*.5*me.f + dt*me.v + me.m;\n    me.s = dt*me.t + me.s;\n    me.o = me.o * matrix(.5*dt*me.s+dt*me.t);\n    me.o[0] = normalize(cross(me.o[1],me.o[2]));\n    me.o[1] = normalize(cross(me.o[2],me.o[0]));\n    me.o[2] = normalize(cross(me.o[0],me.o[1]));\n    if (iFrame < 1) {\n        \n        me = obj (\n            vec3(.2*sin(float(y)*123.4),float(y)*.4,.2*sin(float(y)*10.)),\n            rotationMatrix(3.14*.5+55.*float(y),0.6+float(y)*.2,0.),\n            vec3(0),\n            vec3(0.05*sin(float(y)*.3),0.1*cos(float(y)*.77),0),\n            mat3(1),\n            vec3(0),\n            vec3(0)\n        \n        );\n    \n    }\n    \n    Q = set(me,x);\n\n\n}\nobj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,\n        mat3(1),\n        vec3(0),\n        vec3(0)\n    );\n}\nvec4 set (obj o,int x) {\n    if (x==0) return vec4(o.m,1);\n    if (x==1) return vec4(o.o[0],1);\n    if (x==2) return vec4(o.o[1],1);\n    if (x==3) return vec4(o.o[2],1);\n    if (x==4) return vec4(o.v,1);\n    if (x==5) return vec4(o.s,1);\n    o.io = inverse(o.o);\n    if (x==6) return vec4(o.io[0],1);\n    if (x==7) return vec4(o.io[1],1);\n    if (x==8) return vec4(o.io[2],1);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "obj get (int i);vec4 set (obj o,int x);\n\nvoid triangle_triangle (inout obj o, inout obj q, vec3 a, vec3 b, vec3 c, vec3 e, vec3 g, vec3 h) {\n    vec3 _, f;\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    e = e*q.o+q.m;\n    g = g*q.o+q.m;\n    h = h*q.o+q.m;\n    if (line_triangle(a,b,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(b,c,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(c,a,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }    \n    \n    if (line_triangle(e,g,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(g,h,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    } \n    if (line_triangle(h,e,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n}\nvoid cube_cube(inout obj o, inout obj q) {\n    triangle_triangle(o,q,_T1,_T1);\n    triangle_triangle(o,q,_T1,_T2);\n    triangle_triangle(o,q,_T1,_T3);\n    triangle_triangle(o,q,_T1,_T4);\n    triangle_triangle(o,q,_T1,_T5);\n    triangle_triangle(o,q,_T1,_T6);\n    triangle_triangle(o,q,_T1,_T7);\n    triangle_triangle(o,q,_T1,_T8);\n    triangle_triangle(o,q,_T1,_T9);\n    triangle_triangle(o,q,_T1,_T10);\n    triangle_triangle(o,q,_T1,_T11);\n    triangle_triangle(o,q,_T1,_T12);\n    triangle_triangle(o,q,_T2,_T1);\n    triangle_triangle(o,q,_T2,_T2);\n    triangle_triangle(o,q,_T2,_T3);\n    triangle_triangle(o,q,_T2,_T4);\n    triangle_triangle(o,q,_T2,_T5);\n    triangle_triangle(o,q,_T2,_T6);\n    triangle_triangle(o,q,_T2,_T7);\n    triangle_triangle(o,q,_T2,_T8);\n    triangle_triangle(o,q,_T2,_T9);\n    triangle_triangle(o,q,_T2,_T10);\n    triangle_triangle(o,q,_T2,_T11);\n    triangle_triangle(o,q,_T2,_T12);\n    triangle_triangle(o,q,_T3,_T1);\n    triangle_triangle(o,q,_T3,_T2);\n    triangle_triangle(o,q,_T3,_T3);\n    triangle_triangle(o,q,_T3,_T4);\n    triangle_triangle(o,q,_T3,_T5);\n    triangle_triangle(o,q,_T3,_T6);\n    triangle_triangle(o,q,_T3,_T7);\n    triangle_triangle(o,q,_T3,_T8);\n    triangle_triangle(o,q,_T3,_T9);\n    triangle_triangle(o,q,_T3,_T10);\n    triangle_triangle(o,q,_T3,_T11);\n    triangle_triangle(o,q,_T3,_T12);\n    triangle_triangle(o,q,_T4,_T1);\n    triangle_triangle(o,q,_T4,_T2);\n    triangle_triangle(o,q,_T4,_T3);\n    triangle_triangle(o,q,_T4,_T4);\n    triangle_triangle(o,q,_T4,_T5);\n    triangle_triangle(o,q,_T4,_T6);\n    triangle_triangle(o,q,_T4,_T7);\n    triangle_triangle(o,q,_T4,_T8);\n    triangle_triangle(o,q,_T4,_T9);\n    triangle_triangle(o,q,_T4,_T10);\n    triangle_triangle(o,q,_T4,_T11);\n    triangle_triangle(o,q,_T4,_T12);\n    triangle_triangle(o,q,_T5,_T1);\n    triangle_triangle(o,q,_T5,_T2);\n    triangle_triangle(o,q,_T5,_T3);\n    triangle_triangle(o,q,_T5,_T4);\n    triangle_triangle(o,q,_T5,_T5);\n    triangle_triangle(o,q,_T5,_T6);\n    triangle_triangle(o,q,_T5,_T7);\n    triangle_triangle(o,q,_T5,_T8);\n    triangle_triangle(o,q,_T5,_T9);\n    triangle_triangle(o,q,_T5,_T10);\n    triangle_triangle(o,q,_T5,_T11);\n    triangle_triangle(o,q,_T5,_T12);\n    triangle_triangle(o,q,_T6,_T1);\n    triangle_triangle(o,q,_T6,_T2);\n    triangle_triangle(o,q,_T6,_T3);\n    triangle_triangle(o,q,_T6,_T4);\n    triangle_triangle(o,q,_T6,_T5);\n    triangle_triangle(o,q,_T6,_T6);\n    triangle_triangle(o,q,_T6,_T7);\n    triangle_triangle(o,q,_T6,_T8);\n    triangle_triangle(o,q,_T6,_T9);\n    triangle_triangle(o,q,_T6,_T10);\n    triangle_triangle(o,q,_T6,_T11);\n    triangle_triangle(o,q,_T6,_T12);\n    triangle_triangle(o,q,_T7,_T1);\n    triangle_triangle(o,q,_T7,_T2);\n    triangle_triangle(o,q,_T7,_T3);\n    triangle_triangle(o,q,_T7,_T4);\n    triangle_triangle(o,q,_T7,_T5);\n    triangle_triangle(o,q,_T7,_T6);\n    triangle_triangle(o,q,_T7,_T7);\n    triangle_triangle(o,q,_T7,_T8);\n    triangle_triangle(o,q,_T7,_T9);\n    triangle_triangle(o,q,_T7,_T10);\n    triangle_triangle(o,q,_T7,_T11);\n    triangle_triangle(o,q,_T7,_T12);\n    triangle_triangle(o,q,_T8,_T1);\n    triangle_triangle(o,q,_T8,_T2);\n    triangle_triangle(o,q,_T8,_T3);\n    triangle_triangle(o,q,_T8,_T4);\n    triangle_triangle(o,q,_T8,_T5);\n    triangle_triangle(o,q,_T8,_T6);\n    triangle_triangle(o,q,_T8,_T7);\n    triangle_triangle(o,q,_T8,_T8);\n    triangle_triangle(o,q,_T8,_T9);\n    triangle_triangle(o,q,_T8,_T10);\n    triangle_triangle(o,q,_T8,_T11);\n    triangle_triangle(o,q,_T8,_T12);\n    triangle_triangle(o,q,_T9,_T1);\n    triangle_triangle(o,q,_T9,_T2);\n    triangle_triangle(o,q,_T9,_T3);\n    triangle_triangle(o,q,_T9,_T4);\n    triangle_triangle(o,q,_T9,_T5);\n    triangle_triangle(o,q,_T9,_T6);\n    triangle_triangle(o,q,_T9,_T7);\n    triangle_triangle(o,q,_T9,_T8);\n    triangle_triangle(o,q,_T9,_T9);\n    triangle_triangle(o,q,_T9,_T10);\n    triangle_triangle(o,q,_T9,_T11);\n    triangle_triangle(o,q,_T9,_T12);\n    triangle_triangle(o,q,_T10,_T1);\n    triangle_triangle(o,q,_T10,_T2);\n    triangle_triangle(o,q,_T10,_T3);\n    triangle_triangle(o,q,_T10,_T4);\n    triangle_triangle(o,q,_T10,_T5);\n    triangle_triangle(o,q,_T10,_T6);\n    triangle_triangle(o,q,_T10,_T7);\n    triangle_triangle(o,q,_T10,_T8);\n    triangle_triangle(o,q,_T10,_T9);\n    triangle_triangle(o,q,_T10,_T10);\n    triangle_triangle(o,q,_T10,_T11);\n    triangle_triangle(o,q,_T10,_T12);\n    triangle_triangle(o,q,_T11,_T1);\n    triangle_triangle(o,q,_T11,_T2);\n    triangle_triangle(o,q,_T11,_T3);\n    triangle_triangle(o,q,_T11,_T4);\n    triangle_triangle(o,q,_T11,_T5);\n    triangle_triangle(o,q,_T11,_T6);\n    triangle_triangle(o,q,_T11,_T7);\n    triangle_triangle(o,q,_T11,_T8);\n    triangle_triangle(o,q,_T11,_T9);\n    triangle_triangle(o,q,_T11,_T10);\n    triangle_triangle(o,q,_T11,_T11);\n    triangle_triangle(o,q,_T11,_T12);\n    triangle_triangle(o,q,_T12,_T1);\n    triangle_triangle(o,q,_T12,_T2);\n    triangle_triangle(o,q,_T12,_T3);\n    triangle_triangle(o,q,_T12,_T4);\n    triangle_triangle(o,q,_T12,_T5);\n    triangle_triangle(o,q,_T12,_T6);\n    triangle_triangle(o,q,_T12,_T7);\n    triangle_triangle(o,q,_T12,_T8);\n    triangle_triangle(o,q,_T12,_T9);\n    triangle_triangle(o,q,_T12,_T10);\n    triangle_triangle(o,q,_T12,_T11);\n    triangle_triangle(o,q,_T12,_T12);\n}\nvoid tri_boundaries (inout obj o, vec3 a, vec3 b, vec3 c) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    vec3 da = -velocity(o,a);\n    vec3 db = -velocity(o,b);\n    vec3 dc = -velocity(o,c);\n    \n    if (a.y < -.5) impulse(o, a, vec3(0,-a.y-.5,0) + K3*da);\n    if (b.y < -.5) impulse(o, b, vec3(0,-b.y-.5,0) + K3*db);\n    if (c.y < -.5) impulse(o, c, vec3(0,-c.y-.5,0) + K3*dc);\n    \n    if (a.x < -1.) impulse(o, a, vec3(-a.x-1.,0,0) + K3*da);\n    if (b.x < -1.) impulse(o, b, vec3(-b.x-1.,0,0) + K3*db);\n    if (c.x < -1.) impulse(o, c, vec3(-c.x-1.,0,0) + K3*dc);\n    \n    if (a.z < -1.) impulse(o, a, vec3(0,0,-a.z-1.) + K3*da);\n    if (b.z < -1.) impulse(o, b, vec3(0,0,-b.z-1.) + K3*db);\n    if (c.z < -1.) impulse(o, c, vec3(0,0,-c.z-1.) + K3*dc);\n    \n    if (a.x > +1.) impulse(o, a, vec3(1.-a.x,0,0) +  K3*da);\n    if (b.x > +1.) impulse(o, b, vec3(1.-b.x,0,0) +  K3*db);\n    if (c.x > +1.) impulse(o, c, vec3(1.-c.x,0,0) +  K3*dc);\n    \n    if (a.z > +1.) impulse(o, a, vec3(0,0,1.-a.z) +  K3*da);\n    if (b.z > +1.) impulse(o, b, vec3(0,0,1.-b.z) +  K3*db);\n    if (c.z > +1.) impulse(o, c, vec3(0,0,1.-c.z) +  K3*dc);\n    \n}\nvoid boundaries (inout obj o) {\n\n    tri_boundaries(o,_T1);\n    tri_boundaries(o,_T2);\n    tri_boundaries(o,_T3);\n    tri_boundaries(o,_T4);\n    tri_boundaries(o,_T5);\n    tri_boundaries(o,_T6);\n    tri_boundaries(o,_T7);\n    tri_boundaries(o,_T8);\n    tri_boundaries(o,_T9);\n    tri_boundaries(o,_T10);\n    tri_boundaries(o,_T11);\n    tri_boundaries(o,_T12);\n}\nvoid magnet_magnet(inout obj o, obj q) {\n    vec2 e = vec2(1e-2,0);\n    vec3 r = (o.m-q.m)*q.io;\n    float k = K;\n    \n    float b0 = dot(B(r,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bx = dot(B(r+e.xyy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float by = dot(B(r+e.yxy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bz = dot(B(r+e.yyx,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    \n    o.f += k*vec3(bx-b0,by-b0,bz-b0)/e.x;\n        \n    o.t += k*cross(vec3(1,0,0),B(r,vec3(_s_),vec3(0),vec3(1,0,0))*q.o);\n\n}\nMain {\n    \n    int x = int(U.x); // nth feature\n    int y = int(U.y); // nth object\n    if (x > 8 || y > N) discard;  \n    obj me = get(y);\n    \n    \n    me.f = vec3(0,-G,0);\n    me.t = vec3(0);\n    \n    for (int i = min(0,iFrame); i < N; i++) if (i != y) { \n        \n        obj o = get(i);\n        \n        magnet_magnet(me,o);\n        \n        if (length(o.m-me.m)<2.01*length(_s_)) cube_cube(me,o);\n    \n    }\n    \n    boundaries(me);\n    me.v = dt*me.f + me.v*.999;\n    me.m = dt*.5*me.f + dt*me.v + me.m;\n    me.s = dt*me.t + me.s;\n    me.o = me.o * matrix(.5*dt*me.s+dt*me.t);\n    me.o[0] = normalize(cross(me.o[1],me.o[2]));\n    me.o[1] = normalize(cross(me.o[2],me.o[0]));\n    me.o[2] = normalize(cross(me.o[0],me.o[1]));\n    if (iFrame < 1) {\n        \n        me = obj (\n            vec3(.2*sin(float(y)*123.4),float(y)*.4,.2*sin(float(y)*10.)),\n            rotationMatrix(3.14*.5+55.*float(y),0.6+float(y)*.2,0.),\n            vec3(0),\n            vec3(0.05*sin(float(y)*.3),0.1*cos(float(y)*.77),0),\n            mat3(1),\n            vec3(0),\n            vec3(0)\n        \n        );\n    \n    }\n    \n    Q = set(me,x);\n\n\n}\nobj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,\n        mat3(1),\n        vec3(0),\n        vec3(0)\n    );\n}\nvec4 set (obj o,int x) {\n    if (x==0) return vec4(o.m,1);\n    if (x==1) return vec4(o.o[0],1);\n    if (x==2) return vec4(o.o[1],1);\n    if (x==3) return vec4(o.o[2],1);\n    if (x==4) return vec4(o.v,1);\n    if (x==5) return vec4(o.s,1);\n    o.io = inverse(o.o);\n    if (x==6) return vec4(o.io[0],1);\n    if (x==7) return vec4(o.io[1],1);\n    if (x==8) return vec4(o.io[2],1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "obj get (int i);vec4 set (obj o,int x);\n\nvoid triangle_triangle (inout obj o, inout obj q, vec3 a, vec3 b, vec3 c, vec3 e, vec3 g, vec3 h) {\n    vec3 _, f;\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    e = e*q.o+q.m;\n    g = g*q.o+q.m;\n    h = h*q.o+q.m;\n    if (line_triangle(a,b,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(b,c,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(c,a,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }    \n    \n    if (line_triangle(e,g,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(g,h,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    } \n    if (line_triangle(h,e,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n}\nvoid cube_cube(inout obj o, inout obj q) {\n    triangle_triangle(o,q,_T1,_T1);\n    triangle_triangle(o,q,_T1,_T2);\n    triangle_triangle(o,q,_T1,_T3);\n    triangle_triangle(o,q,_T1,_T4);\n    triangle_triangle(o,q,_T1,_T5);\n    triangle_triangle(o,q,_T1,_T6);\n    triangle_triangle(o,q,_T1,_T7);\n    triangle_triangle(o,q,_T1,_T8);\n    triangle_triangle(o,q,_T1,_T9);\n    triangle_triangle(o,q,_T1,_T10);\n    triangle_triangle(o,q,_T1,_T11);\n    triangle_triangle(o,q,_T1,_T12);\n    triangle_triangle(o,q,_T2,_T1);\n    triangle_triangle(o,q,_T2,_T2);\n    triangle_triangle(o,q,_T2,_T3);\n    triangle_triangle(o,q,_T2,_T4);\n    triangle_triangle(o,q,_T2,_T5);\n    triangle_triangle(o,q,_T2,_T6);\n    triangle_triangle(o,q,_T2,_T7);\n    triangle_triangle(o,q,_T2,_T8);\n    triangle_triangle(o,q,_T2,_T9);\n    triangle_triangle(o,q,_T2,_T10);\n    triangle_triangle(o,q,_T2,_T11);\n    triangle_triangle(o,q,_T2,_T12);\n    triangle_triangle(o,q,_T3,_T1);\n    triangle_triangle(o,q,_T3,_T2);\n    triangle_triangle(o,q,_T3,_T3);\n    triangle_triangle(o,q,_T3,_T4);\n    triangle_triangle(o,q,_T3,_T5);\n    triangle_triangle(o,q,_T3,_T6);\n    triangle_triangle(o,q,_T3,_T7);\n    triangle_triangle(o,q,_T3,_T8);\n    triangle_triangle(o,q,_T3,_T9);\n    triangle_triangle(o,q,_T3,_T10);\n    triangle_triangle(o,q,_T3,_T11);\n    triangle_triangle(o,q,_T3,_T12);\n    triangle_triangle(o,q,_T4,_T1);\n    triangle_triangle(o,q,_T4,_T2);\n    triangle_triangle(o,q,_T4,_T3);\n    triangle_triangle(o,q,_T4,_T4);\n    triangle_triangle(o,q,_T4,_T5);\n    triangle_triangle(o,q,_T4,_T6);\n    triangle_triangle(o,q,_T4,_T7);\n    triangle_triangle(o,q,_T4,_T8);\n    triangle_triangle(o,q,_T4,_T9);\n    triangle_triangle(o,q,_T4,_T10);\n    triangle_triangle(o,q,_T4,_T11);\n    triangle_triangle(o,q,_T4,_T12);\n    triangle_triangle(o,q,_T5,_T1);\n    triangle_triangle(o,q,_T5,_T2);\n    triangle_triangle(o,q,_T5,_T3);\n    triangle_triangle(o,q,_T5,_T4);\n    triangle_triangle(o,q,_T5,_T5);\n    triangle_triangle(o,q,_T5,_T6);\n    triangle_triangle(o,q,_T5,_T7);\n    triangle_triangle(o,q,_T5,_T8);\n    triangle_triangle(o,q,_T5,_T9);\n    triangle_triangle(o,q,_T5,_T10);\n    triangle_triangle(o,q,_T5,_T11);\n    triangle_triangle(o,q,_T5,_T12);\n    triangle_triangle(o,q,_T6,_T1);\n    triangle_triangle(o,q,_T6,_T2);\n    triangle_triangle(o,q,_T6,_T3);\n    triangle_triangle(o,q,_T6,_T4);\n    triangle_triangle(o,q,_T6,_T5);\n    triangle_triangle(o,q,_T6,_T6);\n    triangle_triangle(o,q,_T6,_T7);\n    triangle_triangle(o,q,_T6,_T8);\n    triangle_triangle(o,q,_T6,_T9);\n    triangle_triangle(o,q,_T6,_T10);\n    triangle_triangle(o,q,_T6,_T11);\n    triangle_triangle(o,q,_T6,_T12);\n    triangle_triangle(o,q,_T7,_T1);\n    triangle_triangle(o,q,_T7,_T2);\n    triangle_triangle(o,q,_T7,_T3);\n    triangle_triangle(o,q,_T7,_T4);\n    triangle_triangle(o,q,_T7,_T5);\n    triangle_triangle(o,q,_T7,_T6);\n    triangle_triangle(o,q,_T7,_T7);\n    triangle_triangle(o,q,_T7,_T8);\n    triangle_triangle(o,q,_T7,_T9);\n    triangle_triangle(o,q,_T7,_T10);\n    triangle_triangle(o,q,_T7,_T11);\n    triangle_triangle(o,q,_T7,_T12);\n    triangle_triangle(o,q,_T8,_T1);\n    triangle_triangle(o,q,_T8,_T2);\n    triangle_triangle(o,q,_T8,_T3);\n    triangle_triangle(o,q,_T8,_T4);\n    triangle_triangle(o,q,_T8,_T5);\n    triangle_triangle(o,q,_T8,_T6);\n    triangle_triangle(o,q,_T8,_T7);\n    triangle_triangle(o,q,_T8,_T8);\n    triangle_triangle(o,q,_T8,_T9);\n    triangle_triangle(o,q,_T8,_T10);\n    triangle_triangle(o,q,_T8,_T11);\n    triangle_triangle(o,q,_T8,_T12);\n    triangle_triangle(o,q,_T9,_T1);\n    triangle_triangle(o,q,_T9,_T2);\n    triangle_triangle(o,q,_T9,_T3);\n    triangle_triangle(o,q,_T9,_T4);\n    triangle_triangle(o,q,_T9,_T5);\n    triangle_triangle(o,q,_T9,_T6);\n    triangle_triangle(o,q,_T9,_T7);\n    triangle_triangle(o,q,_T9,_T8);\n    triangle_triangle(o,q,_T9,_T9);\n    triangle_triangle(o,q,_T9,_T10);\n    triangle_triangle(o,q,_T9,_T11);\n    triangle_triangle(o,q,_T9,_T12);\n    triangle_triangle(o,q,_T10,_T1);\n    triangle_triangle(o,q,_T10,_T2);\n    triangle_triangle(o,q,_T10,_T3);\n    triangle_triangle(o,q,_T10,_T4);\n    triangle_triangle(o,q,_T10,_T5);\n    triangle_triangle(o,q,_T10,_T6);\n    triangle_triangle(o,q,_T10,_T7);\n    triangle_triangle(o,q,_T10,_T8);\n    triangle_triangle(o,q,_T10,_T9);\n    triangle_triangle(o,q,_T10,_T10);\n    triangle_triangle(o,q,_T10,_T11);\n    triangle_triangle(o,q,_T10,_T12);\n    triangle_triangle(o,q,_T11,_T1);\n    triangle_triangle(o,q,_T11,_T2);\n    triangle_triangle(o,q,_T11,_T3);\n    triangle_triangle(o,q,_T11,_T4);\n    triangle_triangle(o,q,_T11,_T5);\n    triangle_triangle(o,q,_T11,_T6);\n    triangle_triangle(o,q,_T11,_T7);\n    triangle_triangle(o,q,_T11,_T8);\n    triangle_triangle(o,q,_T11,_T9);\n    triangle_triangle(o,q,_T11,_T10);\n    triangle_triangle(o,q,_T11,_T11);\n    triangle_triangle(o,q,_T11,_T12);\n    triangle_triangle(o,q,_T12,_T1);\n    triangle_triangle(o,q,_T12,_T2);\n    triangle_triangle(o,q,_T12,_T3);\n    triangle_triangle(o,q,_T12,_T4);\n    triangle_triangle(o,q,_T12,_T5);\n    triangle_triangle(o,q,_T12,_T6);\n    triangle_triangle(o,q,_T12,_T7);\n    triangle_triangle(o,q,_T12,_T8);\n    triangle_triangle(o,q,_T12,_T9);\n    triangle_triangle(o,q,_T12,_T10);\n    triangle_triangle(o,q,_T12,_T11);\n    triangle_triangle(o,q,_T12,_T12);\n}\nvoid tri_boundaries (inout obj o, vec3 a, vec3 b, vec3 c) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    vec3 da = -velocity(o,a);\n    vec3 db = -velocity(o,b);\n    vec3 dc = -velocity(o,c);\n    \n    if (a.y < -.5) impulse(o, a, vec3(0,-a.y-.5,0) + K3*da);\n    if (b.y < -.5) impulse(o, b, vec3(0,-b.y-.5,0) + K3*db);\n    if (c.y < -.5) impulse(o, c, vec3(0,-c.y-.5,0) + K3*dc);\n    \n    if (a.x < -1.) impulse(o, a, vec3(-a.x-1.,0,0) + K3*da);\n    if (b.x < -1.) impulse(o, b, vec3(-b.x-1.,0,0) + K3*db);\n    if (c.x < -1.) impulse(o, c, vec3(-c.x-1.,0,0) + K3*dc);\n    \n    if (a.z < -1.) impulse(o, a, vec3(0,0,-a.z-1.) + K3*da);\n    if (b.z < -1.) impulse(o, b, vec3(0,0,-b.z-1.) + K3*db);\n    if (c.z < -1.) impulse(o, c, vec3(0,0,-c.z-1.) + K3*dc);\n    \n    if (a.x > +1.) impulse(o, a, vec3(1.-a.x,0,0) +  K3*da);\n    if (b.x > +1.) impulse(o, b, vec3(1.-b.x,0,0) +  K3*db);\n    if (c.x > +1.) impulse(o, c, vec3(1.-c.x,0,0) +  K3*dc);\n    \n    if (a.z > +1.) impulse(o, a, vec3(0,0,1.-a.z) +  K3*da);\n    if (b.z > +1.) impulse(o, b, vec3(0,0,1.-b.z) +  K3*db);\n    if (c.z > +1.) impulse(o, c, vec3(0,0,1.-c.z) +  K3*dc);\n    \n}\nvoid boundaries (inout obj o) {\n\n    tri_boundaries(o,_T1);\n    tri_boundaries(o,_T2);\n    tri_boundaries(o,_T3);\n    tri_boundaries(o,_T4);\n    tri_boundaries(o,_T5);\n    tri_boundaries(o,_T6);\n    tri_boundaries(o,_T7);\n    tri_boundaries(o,_T8);\n    tri_boundaries(o,_T9);\n    tri_boundaries(o,_T10);\n    tri_boundaries(o,_T11);\n    tri_boundaries(o,_T12);\n}\nvoid magnet_magnet(inout obj o, obj q) {\n    vec2 e = vec2(1e-2,0);\n    vec3 r = (o.m-q.m)*q.io;\n    float k = K;\n    \n    float b0 = dot(B(r,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bx = dot(B(r+e.xyy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float by = dot(B(r+e.yxy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bz = dot(B(r+e.yyx,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    \n    o.f += k*vec3(bx-b0,by-b0,bz-b0)/e.x;\n        \n    o.t += k*cross(vec3(1,0,0),B(r,vec3(_s_),vec3(0),vec3(1,0,0))*q.o);\n\n}\nMain {\n    \n    int x = int(U.x); // nth feature\n    int y = int(U.y); // nth object\n    if (x > 8 || y > N) discard;  \n    obj me = get(y);\n    \n    \n    me.f = vec3(0,-G,0);\n    me.t = vec3(0);\n    \n    for (int i = min(0,iFrame); i < N; i++) if (i != y) { \n        \n        obj o = get(i);\n        \n        magnet_magnet(me,o);\n        \n        if (length(o.m-me.m)<2.01*length(_s_)) cube_cube(me,o);\n    \n    }\n    \n    boundaries(me);\n    me.v = dt*me.f + me.v*.999;\n    me.m = dt*.5*me.f + dt*me.v + me.m;\n    me.s = dt*me.t + me.s;\n    me.o = me.o * matrix(.5*dt*me.s+dt*me.t);\n    me.o[0] = normalize(cross(me.o[1],me.o[2]));\n    me.o[1] = normalize(cross(me.o[2],me.o[0]));\n    me.o[2] = normalize(cross(me.o[0],me.o[1]));\n    if (iFrame < 1) {\n        \n        me = obj (\n            vec3(.2*sin(float(y)*123.4),float(y)*.4,.2*sin(float(y)*10.)),\n            rotationMatrix(3.14*.5+55.*float(y),0.6+float(y)*.2,0.),\n            vec3(0),\n            vec3(0.05*sin(float(y)*.3),0.1*cos(float(y)*.77),0),\n            mat3(1),\n            vec3(0),\n            vec3(0)\n        \n        );\n    \n    }\n    \n    Q = set(me,x);\n\n\n}\nobj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,\n        mat3(1),\n        vec3(0),\n        vec3(0)\n    );\n}\nvec4 set (obj o,int x) {\n    if (x==0) return vec4(o.m,1);\n    if (x==1) return vec4(o.o[0],1);\n    if (x==2) return vec4(o.o[1],1);\n    if (x==3) return vec4(o.o[2],1);\n    if (x==4) return vec4(o.v,1);\n    if (x==5) return vec4(o.s,1);\n    o.io = inverse(o.o);\n    if (x==6) return vec4(o.io[0],1);\n    if (x==7) return vec4(o.io[1],1);\n    if (x==8) return vec4(o.io[2],1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "obj get (int i);vec4 set (obj o,int x);\n\nvoid triangle_triangle (inout obj o, inout obj q, vec3 a, vec3 b, vec3 c, vec3 e, vec3 g, vec3 h) {\n    vec3 _, f;\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    e = e*q.o+q.m;\n    g = g*q.o+q.m;\n    h = h*q.o+q.m;\n    if (line_triangle(a,b,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(b,c,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(c,a,e,g,h ,_,f)) {\n        f += K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }    \n    \n    if (line_triangle(e,g,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n    if (line_triangle(g,h,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    } \n    if (line_triangle(h,e,a,b,c ,_,f)) {\n        f = -f+ K2*(velocity(q,_)-velocity(o,_));\n        impulse(o,_,f);\n    }\n}\nvoid cube_cube(inout obj o, inout obj q) {\n    triangle_triangle(o,q,_T1,_T1);\n    triangle_triangle(o,q,_T1,_T2);\n    triangle_triangle(o,q,_T1,_T3);\n    triangle_triangle(o,q,_T1,_T4);\n    triangle_triangle(o,q,_T1,_T5);\n    triangle_triangle(o,q,_T1,_T6);\n    triangle_triangle(o,q,_T1,_T7);\n    triangle_triangle(o,q,_T1,_T8);\n    triangle_triangle(o,q,_T1,_T9);\n    triangle_triangle(o,q,_T1,_T10);\n    triangle_triangle(o,q,_T1,_T11);\n    triangle_triangle(o,q,_T1,_T12);\n    triangle_triangle(o,q,_T2,_T1);\n    triangle_triangle(o,q,_T2,_T2);\n    triangle_triangle(o,q,_T2,_T3);\n    triangle_triangle(o,q,_T2,_T4);\n    triangle_triangle(o,q,_T2,_T5);\n    triangle_triangle(o,q,_T2,_T6);\n    triangle_triangle(o,q,_T2,_T7);\n    triangle_triangle(o,q,_T2,_T8);\n    triangle_triangle(o,q,_T2,_T9);\n    triangle_triangle(o,q,_T2,_T10);\n    triangle_triangle(o,q,_T2,_T11);\n    triangle_triangle(o,q,_T2,_T12);\n    triangle_triangle(o,q,_T3,_T1);\n    triangle_triangle(o,q,_T3,_T2);\n    triangle_triangle(o,q,_T3,_T3);\n    triangle_triangle(o,q,_T3,_T4);\n    triangle_triangle(o,q,_T3,_T5);\n    triangle_triangle(o,q,_T3,_T6);\n    triangle_triangle(o,q,_T3,_T7);\n    triangle_triangle(o,q,_T3,_T8);\n    triangle_triangle(o,q,_T3,_T9);\n    triangle_triangle(o,q,_T3,_T10);\n    triangle_triangle(o,q,_T3,_T11);\n    triangle_triangle(o,q,_T3,_T12);\n    triangle_triangle(o,q,_T4,_T1);\n    triangle_triangle(o,q,_T4,_T2);\n    triangle_triangle(o,q,_T4,_T3);\n    triangle_triangle(o,q,_T4,_T4);\n    triangle_triangle(o,q,_T4,_T5);\n    triangle_triangle(o,q,_T4,_T6);\n    triangle_triangle(o,q,_T4,_T7);\n    triangle_triangle(o,q,_T4,_T8);\n    triangle_triangle(o,q,_T4,_T9);\n    triangle_triangle(o,q,_T4,_T10);\n    triangle_triangle(o,q,_T4,_T11);\n    triangle_triangle(o,q,_T4,_T12);\n    triangle_triangle(o,q,_T5,_T1);\n    triangle_triangle(o,q,_T5,_T2);\n    triangle_triangle(o,q,_T5,_T3);\n    triangle_triangle(o,q,_T5,_T4);\n    triangle_triangle(o,q,_T5,_T5);\n    triangle_triangle(o,q,_T5,_T6);\n    triangle_triangle(o,q,_T5,_T7);\n    triangle_triangle(o,q,_T5,_T8);\n    triangle_triangle(o,q,_T5,_T9);\n    triangle_triangle(o,q,_T5,_T10);\n    triangle_triangle(o,q,_T5,_T11);\n    triangle_triangle(o,q,_T5,_T12);\n    triangle_triangle(o,q,_T6,_T1);\n    triangle_triangle(o,q,_T6,_T2);\n    triangle_triangle(o,q,_T6,_T3);\n    triangle_triangle(o,q,_T6,_T4);\n    triangle_triangle(o,q,_T6,_T5);\n    triangle_triangle(o,q,_T6,_T6);\n    triangle_triangle(o,q,_T6,_T7);\n    triangle_triangle(o,q,_T6,_T8);\n    triangle_triangle(o,q,_T6,_T9);\n    triangle_triangle(o,q,_T6,_T10);\n    triangle_triangle(o,q,_T6,_T11);\n    triangle_triangle(o,q,_T6,_T12);\n    triangle_triangle(o,q,_T7,_T1);\n    triangle_triangle(o,q,_T7,_T2);\n    triangle_triangle(o,q,_T7,_T3);\n    triangle_triangle(o,q,_T7,_T4);\n    triangle_triangle(o,q,_T7,_T5);\n    triangle_triangle(o,q,_T7,_T6);\n    triangle_triangle(o,q,_T7,_T7);\n    triangle_triangle(o,q,_T7,_T8);\n    triangle_triangle(o,q,_T7,_T9);\n    triangle_triangle(o,q,_T7,_T10);\n    triangle_triangle(o,q,_T7,_T11);\n    triangle_triangle(o,q,_T7,_T12);\n    triangle_triangle(o,q,_T8,_T1);\n    triangle_triangle(o,q,_T8,_T2);\n    triangle_triangle(o,q,_T8,_T3);\n    triangle_triangle(o,q,_T8,_T4);\n    triangle_triangle(o,q,_T8,_T5);\n    triangle_triangle(o,q,_T8,_T6);\n    triangle_triangle(o,q,_T8,_T7);\n    triangle_triangle(o,q,_T8,_T8);\n    triangle_triangle(o,q,_T8,_T9);\n    triangle_triangle(o,q,_T8,_T10);\n    triangle_triangle(o,q,_T8,_T11);\n    triangle_triangle(o,q,_T8,_T12);\n    triangle_triangle(o,q,_T9,_T1);\n    triangle_triangle(o,q,_T9,_T2);\n    triangle_triangle(o,q,_T9,_T3);\n    triangle_triangle(o,q,_T9,_T4);\n    triangle_triangle(o,q,_T9,_T5);\n    triangle_triangle(o,q,_T9,_T6);\n    triangle_triangle(o,q,_T9,_T7);\n    triangle_triangle(o,q,_T9,_T8);\n    triangle_triangle(o,q,_T9,_T9);\n    triangle_triangle(o,q,_T9,_T10);\n    triangle_triangle(o,q,_T9,_T11);\n    triangle_triangle(o,q,_T9,_T12);\n    triangle_triangle(o,q,_T10,_T1);\n    triangle_triangle(o,q,_T10,_T2);\n    triangle_triangle(o,q,_T10,_T3);\n    triangle_triangle(o,q,_T10,_T4);\n    triangle_triangle(o,q,_T10,_T5);\n    triangle_triangle(o,q,_T10,_T6);\n    triangle_triangle(o,q,_T10,_T7);\n    triangle_triangle(o,q,_T10,_T8);\n    triangle_triangle(o,q,_T10,_T9);\n    triangle_triangle(o,q,_T10,_T10);\n    triangle_triangle(o,q,_T10,_T11);\n    triangle_triangle(o,q,_T10,_T12);\n    triangle_triangle(o,q,_T11,_T1);\n    triangle_triangle(o,q,_T11,_T2);\n    triangle_triangle(o,q,_T11,_T3);\n    triangle_triangle(o,q,_T11,_T4);\n    triangle_triangle(o,q,_T11,_T5);\n    triangle_triangle(o,q,_T11,_T6);\n    triangle_triangle(o,q,_T11,_T7);\n    triangle_triangle(o,q,_T11,_T8);\n    triangle_triangle(o,q,_T11,_T9);\n    triangle_triangle(o,q,_T11,_T10);\n    triangle_triangle(o,q,_T11,_T11);\n    triangle_triangle(o,q,_T11,_T12);\n    triangle_triangle(o,q,_T12,_T1);\n    triangle_triangle(o,q,_T12,_T2);\n    triangle_triangle(o,q,_T12,_T3);\n    triangle_triangle(o,q,_T12,_T4);\n    triangle_triangle(o,q,_T12,_T5);\n    triangle_triangle(o,q,_T12,_T6);\n    triangle_triangle(o,q,_T12,_T7);\n    triangle_triangle(o,q,_T12,_T8);\n    triangle_triangle(o,q,_T12,_T9);\n    triangle_triangle(o,q,_T12,_T10);\n    triangle_triangle(o,q,_T12,_T11);\n    triangle_triangle(o,q,_T12,_T12);\n}\nvoid tri_boundaries (inout obj o, vec3 a, vec3 b, vec3 c) {\n    a = a*o.o+o.m;\n    b = b*o.o+o.m;\n    c = c*o.o+o.m;\n    vec3 da = -velocity(o,a);\n    vec3 db = -velocity(o,b);\n    vec3 dc = -velocity(o,c);\n    \n    if (a.y < -.5) impulse(o, a, vec3(0,-a.y-.5,0) + K3*da);\n    if (b.y < -.5) impulse(o, b, vec3(0,-b.y-.5,0) + K3*db);\n    if (c.y < -.5) impulse(o, c, vec3(0,-c.y-.5,0) + K3*dc);\n    \n    if (a.x < -1.) impulse(o, a, vec3(-a.x-1.,0,0) + K3*da);\n    if (b.x < -1.) impulse(o, b, vec3(-b.x-1.,0,0) + K3*db);\n    if (c.x < -1.) impulse(o, c, vec3(-c.x-1.,0,0) + K3*dc);\n    \n    if (a.z < -1.) impulse(o, a, vec3(0,0,-a.z-1.) + K3*da);\n    if (b.z < -1.) impulse(o, b, vec3(0,0,-b.z-1.) + K3*db);\n    if (c.z < -1.) impulse(o, c, vec3(0,0,-c.z-1.) + K3*dc);\n    \n    if (a.x > +1.) impulse(o, a, vec3(1.-a.x,0,0) +  K3*da);\n    if (b.x > +1.) impulse(o, b, vec3(1.-b.x,0,0) +  K3*db);\n    if (c.x > +1.) impulse(o, c, vec3(1.-c.x,0,0) +  K3*dc);\n    \n    if (a.z > +1.) impulse(o, a, vec3(0,0,1.-a.z) +  K3*da);\n    if (b.z > +1.) impulse(o, b, vec3(0,0,1.-b.z) +  K3*db);\n    if (c.z > +1.) impulse(o, c, vec3(0,0,1.-c.z) +  K3*dc);\n    \n}\nvoid boundaries (inout obj o) {\n\n    tri_boundaries(o,_T1);\n    tri_boundaries(o,_T2);\n    tri_boundaries(o,_T3);\n    tri_boundaries(o,_T4);\n    tri_boundaries(o,_T5);\n    tri_boundaries(o,_T6);\n    tri_boundaries(o,_T7);\n    tri_boundaries(o,_T8);\n    tri_boundaries(o,_T9);\n    tri_boundaries(o,_T10);\n    tri_boundaries(o,_T11);\n    tri_boundaries(o,_T12);\n}\nvoid magnet_magnet(inout obj o, obj q) {\n    vec2 e = vec2(1e-2,0);\n    vec3 r = (o.m-q.m)*q.io;\n    float k = K;\n    \n    float b0 = dot(B(r,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bx = dot(B(r+e.xyy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float by = dot(B(r+e.yxy,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    float bz = dot(B(r+e.yyx,.99*_s_,vec3(0),vec3(1,0,0))*q.o,vec3(1,0,0)*o.o);\n    \n    o.f += k*vec3(bx-b0,by-b0,bz-b0)/e.x;\n        \n    o.t += k*cross(vec3(1,0,0),B(r,vec3(_s_),vec3(0),vec3(1,0,0))*q.o);\n\n}\nMain {\n    \n    int x = int(U.x); // nth feature\n    int y = int(U.y); // nth object\n    if (x > 8 || y > N) discard;  \n    obj me = get(y);\n    \n    \n    me.f = vec3(0,-G,0);\n    me.t = vec3(0);\n    \n    for (int i = min(0,iFrame); i < N; i++) if (i != y) { \n        \n        obj o = get(i);\n        \n        magnet_magnet(me,o);\n        \n        if (length(o.m-me.m)<2.01*length(_s_)) cube_cube(me,o);\n    \n    }\n    \n    boundaries(me);\n    me.v = dt*me.f + me.v*.999;\n    me.m = dt*.5*me.f + dt*me.v + me.m;\n    me.s = dt*me.t + me.s;\n    me.o = me.o * matrix(.5*dt*me.s+dt*me.t);\n    me.o[0] = normalize(cross(me.o[1],me.o[2]));\n    me.o[1] = normalize(cross(me.o[2],me.o[0]));\n    me.o[2] = normalize(cross(me.o[0],me.o[1]));\n    if (iFrame < 1) {\n        \n        me = obj (\n            vec3(.2*sin(float(y)*123.4),float(y)*.4,.2*sin(float(y)*10.)),\n            rotationMatrix(3.14*.5+55.*float(y),0.6+float(y)*.2,0.),\n            vec3(0),\n            vec3(0.05*sin(float(y)*.3),0.1*cos(float(y)*.77),0),\n            mat3(1),\n            vec3(0),\n            vec3(0)\n        \n        );\n    \n    }\n    \n    Q = set(me,x);\n\n\n}\nobj get (int i) {\n    return obj(\n        A(0,i).xyz,\n        mat3(\n            A(1,i).xyz,\n            A(2,i).xyz,\n            A(3,i).xyz),\n        A(4,i).xyz,\n        A(5,i).xyz,\n        mat3(1),\n        vec3(0),\n        vec3(0)\n    );\n}\nvec4 set (obj o,int x) {\n    if (x==0) return vec4(o.m,1);\n    if (x==1) return vec4(o.o[0],1);\n    if (x==2) return vec4(o.o[1],1);\n    if (x==3) return vec4(o.o[2],1);\n    if (x==4) return vec4(o.v,1);\n    if (x==5) return vec4(o.s,1);\n    o.io = inverse(o.o);\n    if (x==6) return vec4(o.io[0],1);\n    if (x==7) return vec4(o.io[1],1);\n    if (x==8) return vec4(o.io[2],1);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtcDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 300], [301, 301, 333, 333, 410], [411, 411, 470, 470, 591]], "test": "untested"}
{"id": "cddcDX", "name": "the heart", "author": "Klaasvaakie", "description": "This ethereal digital tapestry is more than just pixels and algorithms; it's a heart in the guise of code, aching for its eternal love. Each fractal iteration is like a pulse, each swirl of color a sigh, painting a landscape of emotions that words struggl", "tags": ["love"], "likes": 2, "viewed": 150, "published": 3, "date": "1695593633", "time_retrieved": "2024-07-30T17:31:58.651503", "image_code": "// Heart function\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot(p-vec2(0.25,0.75), p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot(p-vec2(0.00,1.00), p-vec2(0.00,1.00)),\n                    dot(p-0.5*max(p.x+p.y,0.0), p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// Palette function\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        // Modify distance using sdHeart\n        d += sdHeart(uv) * 0.1;\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 46, 46, 325], [327, 347, 372, 372, 558], [560, 577, 634, 634, 1206]], "test": "untested"}
{"id": "DddyzS", "name": "Pixel Pulse", "author": "yotter", "description": "Discovered this cool effect by accident, then added colors. If you set offset to 0, you can see that it's really just zooming out over thin concentric rings", "tags": ["beginnerpixelcolor"], "likes": 1, "viewed": 187, "published": 3, "date": "1695586688", "time_retrieved": "2024-07-30T17:31:59.563066", "image_code": "float normSin(float x) {\n    return (sin(x) + 1.)/2.;\n}\n\nvec4 fadeColor(float i, float t) {\n    float rFactor = 1.0;\n    float gFactor = 1.4;\n    float bFactor = 1.3;\n    return vec4(i*normSin(rFactor*t), i*normSin(gFactor*t), i*normSin(bFactor*t), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float offSet = 10000.;\n    float speed = 0.03;\n    float density = 0.01;\n    float dateOffset = mix(-5000., 5000., (iDate.z + iDate.w/86400.) / 31.);\n    offSet += dateOffset;\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    \n    float offsetTime = speed * (iTime) + offSet;\n    float p = abs(sin(d*offsetTime));\n    float i = density / p;\n    fragColor = fadeColor(i+0.08*p, offsetTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DddyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 55], [57, 57, 91, 91, 256], [258, 258, 315, 315, 762]], "test": "untested"}
{"id": "cscyDf", "name": "Saturday hacking", "author": "mrange", "description": "Wanted to make the previous shader look a bit more like underwater travelling through glowing abstract \"algae\" \nSome glitches remains but now I need a break\n", "tags": ["underwater"], "likes": 50, "viewed": 1038, "published": 3, "date": "1695560993", "time_retrieved": "2024-07-30T17:32:00.584336", "image_code": "// CC0: Saturday hacking\n//  Wanted to make the previous shader look a bit more like underwater travelling\n//  through glowing abstract \"algae\" \n//  Some glitches remains but now I need a break\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define OFF6(n)     (vec2(1.0, 0.0)*ROT(n*tau/6.))\n#define SAT(x)      clamp(x,0.,1.)\n\n//#define APPROX_MATH\n\nconst float\n  pi        = acos(-1.)\n, tau       = 2.*pi\n, pi_2      = 0.5*pi\n, planeDist = .5\n, furthest  = 6.\n, fadeFrom  = 4.\n;\nconst vec3  \n  L  = vec3(0.299, 0.587, 0.114)\n, LD = normalize(vec3(0.0, 1.8, 1.0))\n;\n\nconst vec2 \n  pathA = vec2(.31, .41)\n, pathB = vec2(1.0,sqrt(0.5))\n;\n\nconst vec4 \n  U = vec4(0, 1, 2, 3)\n  ;\n  \nconst vec2 off6[6] = vec2[6](\n    OFF6(0.)\n  , OFF6(1.)\n  , OFF6(2.)\n  , OFF6(3.)\n  , OFF6(4.)\n  , OFF6(5.)\n  ); \n\nconst vec2 noff6[6] = vec2[6](\n    vec2(-1.0, 0.0)\n  , vec2(-0.5, 0.5)\n  , vec2( 0.5, 0.5)\n  , vec2( 1.0, 0.0)\n  , vec2( 0.5,-0.5)\n  , vec2(-0.5,-0.5)\n  ); \n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n\nvec3 offset(float z) {\n  return vec3(pathB*sin(pathA*z), z);\n}\n\nvec3 doffset(float z) {\n  return vec3(pathA*pathB*cos(pathA*z), 1.0);\n}\n\nvec3 ddoffset(float z) {\n  return vec3(-pathA*pathA*pathB*sin(pathA*z), 0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  co += 123.4;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  co += 123.4;\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n#ifdef APPROX_MATH\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = pi_2 - cosatan2 * pi_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat acos_approx(float x) {\n  return atan_approx(sqrt(1.0 - x*x), x);\n}\n#else\nfloat atan_approx(float y, float x) {\n  return atan(y, x);\n}\n\nfloat acos_approx(float x) {\n  return acos(x);\n}\n#endif\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos_approx( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n// License: CC BY-NC-SA 3.0, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\n// License: CC BY-NC-SA 3.0, author: BigWings, found: https://www.shadertoy.com/view/4sXBRn\nvec3 godray(vec3 bg, vec3 r) {\n  // Godrays \"borrowed\" from BigWings amazing Luminescence: https://www.shadertoy.com/view/4sXBRn\n  float x = atan_approx(r.x, r.z); \n  float y = pi*0.5-acos_approx(r.y);   \n    \n  x *= 0.5;\n  y *= 0.5;\n    \n  vec3 col = bg*(1.+y);\n    \n  float t = TIME;\n    \n  float a = sin(r.x);\n    \n  float beam = SAT(sin(10.*x+a*y*5.+t));\n  beam *= SAT(sin(7.*x+a*y*3.5-t));\n    \n  float beam2 = SAT(sin(42.*x+a*y*21.-t));\n  beam2 *= SAT(sin(34.*x+a*y*17.+t));\n    \n  beam += beam2;\n  \n  col += beam*.25*sqrt(bg);\n  return col;\n}\n\nvec2 coff(float h) {\n  float h0 = h;\n  float h1 = fract(h0*9677.0);\n  float t = 0.75*mix(0.5, 1.0, h0*h0)*(TIME+1234.5);\n  return mix(0.1, 0.2, h1*h1)*sin(t*vec2(1.0, sqrt(0.5)));\n}\n\nvec3 plane(vec3 ro, vec3 rd, vec3 pp, float pd, vec3 off, float n) {\n  float ppd = pp.z-ro.z;\n  vec2 p = (pp-off*U.yyx).xy;\n  float hh = hash(n);\n  p *= mix(1.125, 1.5, hh*hh);\n  \n  vec2 p2 = p;\n  mat2 rot = ROT(tau*0.125*n+0.0005*TIME); \n  p2 *= rot;\n  p2 += -vec2(0.0, hh*0.25*(ro.z-pp.z))*rot;\n  vec2 hp = p2;\n  hp += 0.5;\n  const float ga = 100.0;\n  const float z = 1.0/3.0;\n  hp /= z;\n  vec2 hn = hextile(hp);\n  \n  float h0 = hash(hn+n);\n  vec2 p0 = coff(h0);\n  \n  vec3 bcol = (1.0/3.0)*(1.0+cos(vec3(0.0, 1.0, 2.0) + 2.0*(p2.x+p2.x)-+0.33*n)); \n  vec3 col = vec3(0.0);\n\n  float mx = 0.00025+0.0005*max(pd- 1.5, 0.0);\n  \n  for (int i = 0; i < 6; ++i) {\n    float h1 = hash(hn+noff6[i]+n);\n    vec2 p1 = off6[i]+coff(h1);\n    \n    float h2 = h0+h1;\n    float fade = smoothstep(1.05, 0.85, distance(p0, p1)); \n\n    if (fade < 0.0125) continue;\n\n    vec2 p2 = 0.5*(p1+p0)+coff(h2);\n    float dd = bezier(hp, p0, p2, p1);\n    float gd = abs(dd);\n    gd *= sqrt(gd);\n    gd = max(gd, mx);\n\n    col += fade*0.002*bcol/(gd);\n  }\n\n  {  \n    float cd = length(hp-p0);\n    float gd = abs(cd);\n    gd *= (gd);\n    gd = max(gd, mx);\n    float fd = ppd;\n    fd -= 5.;\n    float fade = hash(floor(TIME*5.0+123.0*h0))>(fd+length(hn)) ? 1.0 : 0.125;\n    col += 0.0025*fade*sqrt(bcol)/(gd);\n  }\n  \n  col *= 1.25;  \n  return col;\n}\n\nfloat hf0(vec2 p) {\n  float h = (0.5+0.5*sin(p.x)*sin(p.y));\n  h *= h;\n  h *= h;\n  h *= h;\n  return -h;\n}\n\nfloat hf(vec2 p) {\n  const float aa = 0.66;\n  const mat2 pp = 2.03*ROT(1.0);\n  float a = 1.0;\n  float h = 0.0;\n  float ta = 0.0;\n  for (int i = 0; i < 3; ++i) {\n    p += a*0.05*TIME;\n    h += a*hf0(p);\n    a *= aa;\n    ta += a;\n    p *= pp;\n  }\n  return 0.1*h/ta;\n}\n\nvec3 nf(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = hf(p + e.yx) - hf(p - e.yx);\n  n.z = -2.0*e.x;\n  \n  return normalize(n);\n}\n\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1./RESOLUTION.xy;\n  float rdd = 2.0-0.25;\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 acol = vec3(0.0);\n\n  vec3 aro = ro;\n  float apd = 0.0;\n  vec3 ard = rd;\n\n  for (float i = 1.; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*i;\n\n    float lpd = (pz - aro.z)/ard.z;\n\n    {\n      vec3 pp = aro + ard*lpd;\n\n      vec3 nor = nf(pp.xy);\n      apd += lpd;\n\n      vec3 off = offset(pp.z);\n\n      float dz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*furthest, planeDist*fadeFrom, dz);\n      float fadeOut = smoothstep(0., planeDist*.1, dz);\n      float fadeOutRI = smoothstep(0., planeDist*1.0, dz);\n\n      float ri = mix(1.0, 0.9, fadeOutRI*fadeIn);\n      vec3 refr = refract(ard, nor, ri);\n\n      vec3 pcol = plane(ro, ard, pp, apd, off, nz+i);\n\n      pcol *= fadeOut*fadeIn;\n      pcol *= exp(-vec3(0.8, 0.9, .7)*apd);\n      acol += pcol;\n      aro = pp;\n      ard = refr;\n    }\n    \n  }\n\n  float lf = 1.001-dot(ard, LD);\n  lf *= lf;\n  acol += godray(0.025*vec3(0.0, 0.25, 1.0)/lf, rd);\n  return acol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 r = RESOLUTION.xy, q = fragCoord/RESOLUTION.xy, pp = -1.0+2.0*q, p = pp;\n  p.x *= r.x/r.y;\n\n  float tm  = 0.125*planeDist*TIME-0.1*sin(0.25*TIME-pp.y+pp.x)*length(pp);\n\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(U.xyx+ddro, ww));\n  vec3 vv = cross(ww, uu);\n  \n  vec3 col = color(ww, uu, vv, ro, p);\n  col -= (1.0/30.0)*U.zwx*(length(pp)+0.125);\n  float fade = min(-0.5*abs(pp.y)+0.125*TIME-1.5, 0.0);\n  col *= smoothstep(1.5, sqrt(0.5), length(pp)-fade);\n  col = aces_approx(col);\n  col = sqrt(col);\n  fragColor = vec4(col, 1);\n}\n\n\n", "image_inputs": [{"id": 34765, "src": "https://soundcloud.com/carbonbasedlifeforms/abiogenesis?si=2fd70ee2ecc8450e9b9a2bed741e4101&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cscyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1025, 1132, 1158, 1158, 1342], [1345, 1345, 1367, 1367, 1407], [1409, 1409, 1432, 1432, 1480], [1482, 1482, 1506, 1506, 1561], [1563, 1623, 1645, 1645, 1708], [1710, 1770, 1791, 1791, 1876], [2327, 2428, 2456, 2555, 2882], [2884, 2884, 2904, 2904, 2926], [2928, 3046, 3094, 3094, 4139], [4141, 4342, 4372, 4470, 4891], [4893, 4893, 4913, 4913, 5074], [5076, 5076, 5144, 5144, 6394], [6396, 6396, 6415, 6415, 6501], [6503, 6503, 6521, 6521, 6768], [6770, 6770, 6787, 6787, 6978], [6981, 6981, 7037, 7037, 8160], [8162, 8162, 8219, 8219, 8851]], "test": "untested"}
{"id": "cdccWf", "name": "exp001", "author": "bszmihaly", "description": "based on: https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["fractal"], "likes": 0, "viewed": 153, "published": 3, "date": "1695555999", "time_retrieved": "2024-07-30T17:32:01.536789", "image_code": "vec3 palette(float t)\n{\n\tvec3 a = vec3(1.188, -0.062, 1.228);\n\tvec3 b = vec3(-0.483, 0.722, -0.775);\n\tvec3 c = vec3(1.090, -0.399, 0.457);\n\tvec3 d = vec3(0.498, 0.358, 1.028);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n  \tvec2 uv0 = uv;\n  \tvec3 finalColor = vec3(0.0);\n  \t\n  \tfor (float i = 0.0; i < 3.0; i++){\n  \t\n  \t\tuv = fract(uv * 1.75) - 0.5;\n  \t\n  \t\tfloat d = length(uv) * exp(-length(uv0));\n  \t\n  \t\tvec3 col = palette(length(uv0) + i*0.3 + iTime/2.0);\n  \t\n  \t\td = sin(d*8.0 + iTime)/8.0;\n  \t\td = abs(d);\n  \t\n  \t\td = pow(0.0075/d, 1.2);\n  \t\n   \t\tfinalColor += col * d;\n  \t}\n  \t\n  \t\n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdccWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 218], [220, 220, 277, 277, 753]], "test": "untested"}
{"id": "Dd3yDX", "name": "Bloom (Gaussian Blur)", "author": "Kampfhund", "description": "Calculates the perceived luminance as described by this stackoverflow comment:\nhttps://stackoverflow.com/a/56678483\n\nThen blur the lightest values using a separated Gaussian Blur.\nLightness threshold adjustable in \"Buffer A\", blurAmount in \"Image\"\n", "tags": ["luminance", "gray", "grey"], "likes": 1, "viewed": 247, "published": 3, "date": "1695546718", "time_retrieved": "2024-07-30T17:32:02.295760", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord /iResolution.xy;\n    \n    //Adjust the amount of bloom here\n    float bloomAmount = 0.5;\n    \n    vec4 color = texture(iChannel0, uv) * bloomAmount + texture(iChannel1, uv);\n    \n    fragColor = color;\n    \n    \n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sRGBtoLin(float colorChannel)\n{\n    //This converts a gamma encoded RGB to a linear value.\n    \n    if(colorChannel <= 0.04045)\n    {\n        return colorChannel / 12.92;\n    }\n    else\n    {\n        return pow(((colorChannel + 0.055) / 1.055), 2.4);\n    }\n}\n\nfloat lumToPerLight(float luminance)\n{\n    //This transforms the luminance value to the perceptual lightness as seen by humans\n    if(luminance <= 216.0/24389.0)\n    {\n        return luminance * (24389.0/27.0);\n    }\n    else\n    {\n        return pow(luminance, (1.0 / 3.0)) * 116.0 - 16.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    //This calculates the luminance\n    float lum = (0.2126 * sRGBtoLin(color.r) + 0.7152 * sRGBtoLin(color.g) + 0.0722 * sRGBtoLin(color.b));\n    float perLight = lumToPerLight(lum) / 100.0;\n    \n    \n    //Adjust the lightness threshold here\n    if(perLight >= 0.85)\n    {\n    fragColor = vec4(perLight, perLight, perLight, 1.0);\n    }\n    else\n    {\n    fragColor = vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float kernelSize = 9.0;\n    //the -1.0 only if it's an odd number I think idk haven't tested\n    float halfKernelSize = (kernelSize-1.0) / 2.0;\n    \n    float[] gaussian = float[] (1.0, 8.0, 28.0, 56.0, 70.0, 56.0, 28.0, 8.0, 1.0);\n    //sum of all the values in the array\n    float sum = 256.0;\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n    vec2 currentCoordinate = vec2(0.0, 0.0);\n    \n    for(float i = -halfKernelSize; i <= halfKernelSize; i++)\n    {\n        currentCoordinate = vec2(fragCoord.x + i, fragCoord.y);\n        color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r * gaussian[int(i+halfKernelSize)];\n        color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g * gaussian[int(i+halfKernelSize)];\n        color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b * gaussian[int(i+halfKernelSize)];\n    }\n    \n    color = vec4(color.r / sum, color.g / sum, color.b / sum, 1.0);\n    fragColor = color;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float kernelSize = 9.0;\n    //the -1.0 only if it's an odd number I think idk haven't tested\n    float halfKernelSize = (kernelSize-1.0) / 2.0;\n    \n    float[] gaussian = float[] (1.0, 8.0, 28.0, 56.0, 70.0, 56.0, 28.0, 8.0, 1.0);\n    //sum of all the values in the array\n    float sum = 256.0;\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n    vec2 currentCoordinate = vec2(0.0, 0.0);\n    \n    for(float i = -halfKernelSize; i <= halfKernelSize; i++)\n    {\n        currentCoordinate = vec2(fragCoord.x, fragCoord.y + i);\n        color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r * gaussian[int(i+halfKernelSize)];\n        color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g * gaussian[int(i+halfKernelSize)];\n        color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b * gaussian[int(i+halfKernelSize)];\n    }\n    \n    color = vec4(color.r / sum, color.g / sum, color.b / sum, 1.0);\n    fragColor = color;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3yDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 295]], "test": "untested"}
{"id": "cdcyWX", "name": "UI Test 7", "author": "yasuo", "description": "UI Test 7\nIf you want to see the gradient color version, `POST_EFFECT 1` will work for you.", "tags": ["ui", "cineshader"], "likes": 29, "viewed": 1225, "published": 3, "date": "1695539485", "time_retrieved": "2024-07-30T17:32:03.500538", "image_code": "#define MAX_STEPS 4\n#define MAX_DIST 4.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b,kw) smoothstep(kw*antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n#define POST_EFFECT 0\n\nfloat rand (vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(40.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    //d = max(d2,d);\n    //d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.9;\n    p.y-=size*3.2;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.06;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat drawFont(vec2 p, int char){\n    p.y*=-1.;\n    float d = seg0(p)*checkChar(seg_0,char);\n    d += seg1(p)*checkChar(seg_1,char);\n    d += seg2(p)*checkChar(seg_2,char);\n    d += seg3(p)*checkChar(seg_3,char);\n    d += seg4(p)*checkChar(seg_4,char);\n    d += seg5(p)*checkChar(seg_5,char);\n    d += seg6(p)*checkChar(seg_6,char);\n    d += seg7(p)*checkChar(seg_7,char);\n    d += seg8(p)*checkChar(seg_8,char);\n    d += seg9(p)*checkChar(seg_9,char);\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float d = length(p.xz)-1.;\n    d = max((abs(p.y)-0.6),d);\n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n*-1.);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat bgItem0(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.05,0.005));\n    \n    float a = radians(-45.);\n    p.x-=0.005;\n    p.x = abs(p.x)-0.023;\n    p.y-=0.012;\n    float mask = B(p,vec2(0.02,0.01));\n    p.x = abs(p.x)-0.01;\n    p.y+=0.01;\n    mask = max(dot(p,vec2(cos(a),sin(a))),mask);\n    \n    d = max(-mask,d);\n    \n    p = prevP;\n    a = radians(45.);\n    p.x+=0.005;\n    p.x = abs(p.x)-0.023;\n    p.y+=0.012;\n    mask = B(p,vec2(0.02,0.01));\n    p.x = abs(p.x)-0.01;\n    p.y-=0.01;\n    mask = max(dot(p,vec2(cos(a),sin(a))),mask);\n    \n    d = max(-mask,d);\n    return d;\n}\n\nvec3 background(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n\n    p.x += mix(0.,-0.017,step(0.03,mod( p.y,0.06)));\n    p.x += iTime*0.01*mix(1.,-1.,step(0.03,mod( p.y,0.06)));\n    \n    p.x = mod(p.x,0.034)-0.017;\n    p.y = mod(p.y,0.03)-0.015;\n    \n    p*=Rot(radians(45.));\n    p = DF(p,1.);\n    p-=0.007;\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.0001,0.007));\n    \n    p = prevP;\n    p.y+=0.015;\n    p.y = mod(p.y,0.03)-0.015;\n    float d2 = abs(p.y)-0.0001;\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.05),S(d,-0.0003,w));\n    \n    p = prevP;\n    p.x += iTime*0.02*mix(1.,-1.,step(0.04,p.y));\n    p.x = mod(p.x,0.1)-0.05;\n    p.y =abs(p.y)-0.082;\n    d = bgItem0(p);\n\n    col += mix(col,vec3(0.1),S(d,0.0,w));\n    \n    return col;\n}\n\nfloat waveCircle(vec2 p, float s, float numW, float amp, float deg, float thickness){\n    float r = s+amp*cos(atan(p.y,p.x)*numW);\n    float d = abs(length(p)-r)-thickness;    \n    p*=Rot(radians(deg));\n    r = s+amp*cos(atan(p.y,p.x)*numW);\n    float d2 = abs(length(p)-r)-thickness;  \n    d = min(d,d2);    \n    return d;\n}\n\nfloat grid(vec2 p){\n    p = mod(p,0.004)-0.0002;\n    float d = min(abs(p.x)-0.00001,abs(p.y)-0.00001);\n    return d;\n}\n\nvec3 radar(vec2 p,vec3 col, float w){\n    vec2 prevP = p;\n    p*=Rot(radians(-25.0*iTime));\n    float a = -atan(p.x,p.y);\n    float d = length(p)-0.05;\n    \n    col = mix(col,vec3(1.)*a*0.01,S(d,0.0,w));\n    \n    d = length(p)-0.05;\n    a = radians(2.);\n    p.x = abs(p.x);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    p*=Rot(radians(-25.0*iTime));\n    d = max(p.y,d);\n    col = mix(col,vec3(0.2),S(d,0.0,w));\n    \n    return col;\n}\n\nvec3 centerUiItem(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n    p*=Rot(radians(20.*iTime*0.3));\n    float d = waveCircle(p,0.082,12.,0.003,16.,0.00001);\n    col = mix(col,vec3(1.),S(d,-0.0002,w));\n    \n    p = prevP;\n    p*=Rot(radians(-20.*iTime*0.4));\n    d = abs(length(p)-0.0645)-0.00001;\n    p = DF(p,30.);\n    p-=0.047;\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.0001,0.0017)); \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(-20.*iTime*0.4));\n    d2 = abs(length(p)-0.0665)-0.00001;\n    d = min(d,d2);\n\n    p = DF(p,10.);\n    p-=0.048;\n    p*=Rot(radians(45.));    \n    d2 = B(p,vec2(0.0001,0.0027)); \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(-20.*iTime*0.4));\n    p = DF(p,5.);\n    p-=0.045;\n    p*=Rot(radians(45.)); \n    d2 = B(p,vec2(0.0025,0.001)); \n    d = min(d,d2);    \n    \n    p = prevP;\n    p*=Rot(radians(30.*iTime*0.5));\n    d2 = abs(length(p)-0.05)-0.00001;\n    d = min(d,d2);  \n    p = DF(p,5.);\n    p-=0.037;\n    p*=Rot(radians(45.)); \n    d2 = B(p,vec2(0.0002,0.0023)); \n    d = min(d,d2);   \n    \n    p = prevP;\n    p*=Rot(radians(30.*iTime*0.5));\n    p = DF(p,20.);\n    p-=0.0365;\n    p*=Rot(radians(45.)); \n    d2 = B(p,vec2(0.0002,0.0013)); \n    d = min(d,d2);       \n    \n    col = mix(col,vec3(1.),S(d,-0.0002,w));\n    \n    \n    p = prevP;\n    d = max(length(p)-0.048,grid(p));\n    col = mix(col,vec3(0.05),S(d,0.0,w));    \n    \n    \n    p = prevP;\n    d = abs(length(p)-0.01)-0.00001;\n    d2 = abs(length(p)-0.023)-0.00001;\n    d = min(d,d2);  \n    d2 = abs(length(p)-0.035)-0.00001;\n    d = min(d,d2); \n    \n    p = DF(p,2.);\n    p-=0.021;\n    p*=Rot(radians(45.)); \n    d2 = B(p,vec2(0.0001,0.0195)); \n    d = min(d,d2);   \n    \n    col = mix(col,vec3(0.7),S(d,-0.0005,w));\n    \n    p = prevP;\n    p.y-= iTime*0.01;\n    p*=60.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    vec2 prevGr = gr;\n    float r = rand(id);\n    \n    d = length(gr-vec2(sin(r*5.)*0.25))-0.15*sin(r*(iTime+1.)*1.5);\n    d = max(length(prevP)-0.05,d);\n    col = mix(col,vec3(0.5),S(d,0.0,w));\n    \n    p = prevP;\n    p*=Rot(radians(45.+sin(iTime*0.3)*270.));\n    p.y = abs(p.y)-0.057;\n    p.y*=-1.;\n    d = Tri(p,vec2(0.002));\n    col = mix(col,vec3(0.5),S(d,0.0,w));\n    \n    p = prevP;\n    p = DF(p,30.);\n    p-=0.053;\n    d = length(p)-0.0003;\n    col = mix(col,vec3(0.2),S(d,0.0,w));    \n    \n    p = prevP;\n    p*=Rot(radians(-45.-sin(iTime*0.2)*180.));\n    p.y = abs(p.y)-0.073;\n    p.y*=-1.;\n    d = Tri(p,vec2(0.002));\n    col = mix(col,vec3(0.5),S(d,0.0,w));    \n\n    return col;\n}\n\nvec3 arrowItem(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x+=0.0035;\n    p.x+=iTime*0.02;\n    p.x = mod(p.x,0.018)-0.009;\n    p.x+=0.008;\n    p*=Rot(radians(-90.));\n    p.y*=0.75;\n    float d = Tri(p,vec2(0.01));\n    p.y+=0.005;\n    d = abs(max(-Tri(p,vec2(0.01)),d))-0.00005;\n\n    p = prevP;\n    d = max(abs(p.x)-0.138,d);\n    d = max(-(length(p)-0.085),d);\n\n    col = mix(col,vec3(0.5),S(d,0.0,w));  \n    return col;\n}\n\nvec3 rightTopItem(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n    p = DF(p,2.);\n    p-=0.01;\n    float d = B(p,vec2(0.001)); \n    \n    p = prevP;\n    \n    p*=Rot(radians(20.));\n    p = DF(p,2.);\n    p-=0.005+sin(iTime)*0.002+0.001;\n    \n    float d2 = B(p,vec2(0.001)); \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.+230.*sin(iTime*1.2)));\n    d2 = abs(length(p)-0.02)-0.00001;\n    d2 = max(abs(p.x)-0.01,d2);       \n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.5),S(d,0.0,w));\n    \n    return col;\n}\n\nvec3 rightBottomItem(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n    p*=20.;\n    p*=SkewX(0.4);\n    float d = drawFont(p-vec2(-0.09,0.0),int(mod(iTime*4.,10.)));\n    float d2 = drawFont(p-vec2(0.09,0.0),int(mod(iTime*8.,10.)));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.)+radians(-30.*iTime*0.5));\n    p = DF(p,4.);\n    p-=0.015;\n    p*=Rot(radians(45.)); \n    d2 =abs( length(prevP)-0.021)-0.003;\n    d2 = max(-B(p,vec2(0.0015,0.01)),d2);\n   \n    p = prevP;\n    p*=Rot(radians(45.)+radians(-30.*iTime*0.5));\n    float a = radians(70.);\n    p.x = abs(p.x);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d,d2);   \n    \n    p = prevP;\n    p*=Rot(radians(20.*iTime*1.2));\n    d2 = abs(length(p)-0.015)-0.00001;\n    p = DF(p,0.75);\n    p-=0.015;\n    p*=Rot(radians(45.)); \n    d2 = max(-B(p,vec2(0.003,0.01)),d2);\n    \n    d = min(d,d2); \n    col = mix(col,vec3(0.5),S(d,0.0,w));  \n    return col;\n}\n\nvec3 leftTopItem(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n    p.x+=iTime*0.01;\n    p.y-=0.0002;\n    p*=144.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    vec2 prevGr = gr;\n    float r = rand(id);\n\n    float d = B(gr,vec2(sin(r+3.*iTime*r)*r*0.4));\n    float mask = B(prevP,vec2(0.023,0.014));\n    d = max(mask,d);\n\n    gr-=0.5;\n    float d2 = min(abs(gr.x)-0.06,abs(gr.y)-0.06);\n    d2 = max(mask,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs( B(p,vec2(0.025,0.016)))-0.00001;\n    d2 = max(-(abs(p.x)-0.023),d2);\n    d2 = max(-(abs(p.y)-0.012),d2);\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.5),S(d,0.0,w));  \n    return col;\n}\n\nvec3 graphBar(vec2 p, vec3 col, float w, float speed, float start){\n    vec2 prevP = p;\n    float endTime = 5.;\n    float dist = 0.02;\n    float t = mod(start+iTime*speed,endTime);\n    float animVal = endTime*0.5;\n    float val = t/animVal;\n    if(t<endTime*0.5){\n        val=(t/animVal)*dist;\n    } else {\n        val=(1.-((t-animVal)/animVal))*dist;\n    }\n    \n    p.x+=0.021;\n    float d = B(p-vec2(dist,0.0),vec2(dist,0.002));\n    \n    col = mix(col,vec3(0.25),S(d,0.0,w));  \n    d = B(p-vec2(dist-val,0.0),vec2(dist-val,0.002));\n    \n    p = prevP;\n    p.x+=0.001;\n    float d2 = abs(B(p,vec2(dist+0.002,0.004)))-0.00001;\n    d2 = max(-(abs(p.x)-dist-0.001),d2);\n    d2 = max(-(abs(p.y)-0.003),d2);\n    d = min(d,d2);\n    col = mix(col,vec3(0.5),S(d,0.0,w));\n    return col;\n}\n\nvec3 leftBottomItem(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n\n    col = graphBar(p,col,w,2.,1.);\n    col = graphBar(p-vec2(0.,0.012),col,w,2.1,1.5);\n    col = graphBar(p-vec2(0.,-0.012),col,w,2.2,2.);\n    \n    return col;\n}\n\nvec3 graphic1(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.11;\n    p.y = abs(p.y)-0.08;\n    float d = B(p,vec2(0.0205,0.00001));\n    p.x+=0.031;\n    p.y+=0.006;\n    p*=Rot(radians(-30.));\n    float d2 = B(p,vec2(0.012,0.00001));\n    d = min(d,d2);\n    \n    p.x+=0.012;\n    p.y+=0.06;\n    p*=Rot(radians(25.));\n    d2 = B(p,vec2(0.012,0.00001));\n    p.x-=0.007;\n    d2 = max(-(abs(p.x)-0.002),d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.x = abs(p.x)-0.13;\n    p.y = abs(p.y)-0.02;\n    p.y = abs(p.y)-0.003;\n    d2 = B(p,vec2(0.0001));\n    d = min(d,d2);  \n    \n    p = prevP;\n    p.x = abs(p.x)-0.06;\n    p.y = abs(p.y)-0.077;\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.0008));\n    d = min(d,d2);  \n    d2 = abs(B(p,vec2(0.0026)))-0.0001;\n    d = min(d,d2);  \n    \n    col = mix(col,vec3(1.1),S(d,0.0,w));\n    \n    \n    return col;\n}\n\nvec3 mainUi(vec2 p, vec3 col, float w){\n    vec2 prevP = p;\n   \n    float d = B(p,vec2(0.14,0.09));\n    col = mix(col,vec3(0.02),S(d,0.0,w));\n    \n    col = graphic1(p,col,w);\n    col = arrowItem(p,col,w);\n    col = radar(p,col,w);\n    col = centerUiItem(p,col,w);\n    col = leftTopItem(p-vec2(-0.108,-0.053),col,w);\n    col = leftBottomItem(p-vec2(-0.108,0.049),col,w);\n    col = rightTopItem(p-vec2(0.105,-0.049),col,w);\n    col = rightBottomItem(p-vec2(0.105,0.049),col,w);\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col, float w){\n    col = vec3(0.);\n    vec2 uv = vec2(1.572*atan(p.x,p.z)/6.2832,p.y/4.);\n    col = background(uv,col,w);\n    col += mainUi(uv,col,w);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -0.01);\n    ro.xz *= Rot(radians(180.0));\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.3);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col,0.5/abs(dot(rd,p)) );\n    } else {\n        col = vec3(0.0);\n    }\n    \n    #if POST_EFFECT\n    // grabbed the Shane's effect from comment. Thank you so much! Much improved!\n    float falloff = smoothstep(.35, .85, length(fragCoord/iResolution.xy - .5));\n    col *= mix(vec3(1, 2, 4), vec3(1, 4, 2), falloff);\n    #endif\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[809, 809, 831, 831, 903], [905, 905, 927, 927, 1422], [1424, 1424, 1443, 1443, 1593], [1595, 1595, 1614, 1614, 1925], [1927, 1927, 1946, 1946, 2234], [2236, 2236, 2255, 2255, 2550], [2552, 2552, 2571, 2571, 2859], [2861, 2861, 2880, 2880, 3168], [3170, 3170, 3189, 3189, 3459], [3461, 3461, 3480, 3480, 3663], [3665, 3665, 3684, 3684, 3870], [3872, 3872, 3891, 3891, 4161], [4163, 4163, 4205, 4205, 4265], [4267, 4267, 4300, 4300, 4740], [4742, 4742, 4764, 4764, 4870], [4872, 4872, 4930, 4930, 5197], [5199, 5199, 5223, 5223, 5428], [5430, 5430, 5472, 5472, 5667], [5669, 5669, 5691, 5691, 6260], [6262, 6262, 6305, 6305, 7015], [7017, 7017, 7102, 7102, 7342], [7344, 7344, 7363, 7363, 7462], [7464, 7464, 7501, 7501, 7913], [7915, 7915, 7960, 7960, 10463], [10465, 10465, 10507, 10507, 10921], [10923, 10923, 10968, 10968, 11447], [11449, 11449, 11497, 11497, 12379], [12381, 12381, 12425, 12425, 13043], [13045, 13045, 13112, 13112, 13826], [13828, 13828, 13875, 13875, 14058], [14060, 14060, 14101, 14101, 14929], [14931, 14931, 14970, 14970, 15430], [15432, 15432, 15500, 15500, 15654], [15656, 15656, 15713, 15713, 16548]], "test": "untested"}
{"id": "mlXBRS", "name": "VolumetricTest_1", "author": "felipunkerito", "description": ".", "tags": ["3d", "volumetrics"], "likes": 5, "viewed": 203, "published": 3, "date": "1695534183", "time_retrieved": "2024-07-30T17:32:04.258512", "image_code": "#define PI acos(-1.)\n#define TWO_PI PI * 2.0\n#define QUARTER_PI PI * 0.25\n#define A1 0\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1030);\n    p3 += dot(p3, p3.zyx + 31.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(const in float a)\n{\n    vec2 sC = vec2(sin(a), cos(a));\n    return mat2(sC.x, -sC.y,\n                sC.y,  sC.x);\n}\n\nfloat map(vec3 p)\n{\n    vec3 oP = p;\n    //p.xy = mod(p.xy + .25, 0.5)-.25;\n    //p.z = abs(p.z-0.5)-0.2;\n    const float t = 2.;\n    float fre = t;\n    float am = 0.5;\n    for (int i = 0; i < 1; ++i)\n    {\n        vec2 pXY = p.xy;\n        //pXY *= rot(p.z*fre);\n        //p.z += am*(sin(p.z*fre) + 0.5*cos(pXY.y*fre));\n        //p.xy *= rot(exp(-p.z)*fre);\n        //p.z += am;\n        am *= 1.;\n        fre *= 2.;\n    }\n    //p.xz *= rot(p.y*20.);\n    float s = (p.z)*0.+0.;//length(p)-.8;\n    \n    float amp = 1.2, freq = 0.2, res = 0.;\n    for (int i = 0; i < 3; ++i)\n    {\n        vec3 pT = p;\n        //pT.zy *= rot(-float(3-i)*QUARTER_PI*iTime*0.012);\n        res += amp * (dot(texture(iChannel0, pT * freq + iTime*.005), vec4(0.25))*2.0-1.0);\n        amp *= .7;\n        freq *= 2.56;\n    }\n    //float c = abs(length(p.xz)-.25)-.1;\n    //s = max(s, -c);\n    float r;// = min(s -res*.05, res*.01);\n    \n    float repO = 1.;\n    float rep = 1. / repO;\n    float hRep = rep * 0.5;\n    \n    vec3 id = floor((p+hRep)*repO);\n    //if (/*hash13(id)*/id.x > 0.1)\n    {\n        //discard;\n        oP = p;//mod(p + hRep, rep) - hRep;\n    \n        //if (hash13(id) < 0.4)\n        {\n          //  r = 0.;//oP += 10000.+0.;\n        }\n        //else\n        {\n            r = oP.z-0.-rep*0.1;\n            r = r + res*rep*.3;\n        }\n    }\n    \n    \n    return r;\n}\n\nvec2 march(const in vec3 ro, const in vec3 rd, const in vec3 lDir, out vec3 res)\n{\n\n    const uint marchSteps = uint(512),\n               shadowSteps = uint(4);\n\n    float d = 0.0, t = 0.0;\n    float stepSize = 1. / float(marchSteps);\n    //float sigmaT = 1.0;\n    //float transparency = 1.0;\n    \n    float stepL = 1. / float(shadowSteps);\n    \n    vec3 lD = lDir * stepL;\n    vec3 rD = rd * stepSize;\n    \n    res = vec3(0.);\n    \n    //vec3 ligC = vec3(0.600,0.678,0.529);\n    \n    float curDensity = 0.;\n    float transmittance = 1.;\n    vec3 lightEnergy = vec3(0.);\n    \n    //float accumDist = 0.;\n    \n    vec3 bac = mix(vec3(0.996,0.867,0.584), vec3(0.408,0.596,0.973), rd.z+0.5);\n    \n    for (uint i = 0u; i < marchSteps; ++i)\n    {\n    \n        #if (A1 == 0)\n        vec3 p = ro + rd * t;\n        d = map(p);\n        \n        if (d < 0.001)\n        {\n             float sha = 0.0;\n             \n             vec3 pL = p;\n             \n             float lT = 0.;\n             \n             for (uint j = 0u; j < shadowSteps; ++j)\n             {\n                 pL = pL + lDir * lT;\n                 float lD = map(pL);\n                 sha += lD;\n                 \n                 lT += stepL;\n             }\n             \n            curDensity = (d*-1.);\n            float shadowTerm = exp(-sha * stepL);\n            float absorbedLight = clamp(shadowTerm * curDensity * 0.95, 0., 1.);\n            lightEnergy += vec3(1.000,0.678,0.655) * absorbedLight * transmittance;// * stepSize;\n            transmittance *= 1.-curDensity;\n        }\n        if (transmittance < 1e-3)\n        {\n            break;\n        }\n    \n        t += stepSize; \n    \n        #else\n        if (transparency < 1e-3)\n        {\n            break;\n        }\n        vec3 p = ro + rd * t;\n        d = map(p);\n        \n        if (d <= 0.0)\n        {\n\n            float sample_attenuation = exp(-stepSize * d * sigmaT);\n            transparency *= sample_attenuation;\n\n            float lT = 0.0;\n            float tau = 0.0;\n            float tt = 0.;\n            for (uint j = 0u; j < shadowSteps; ++j)\n            {\n                vec3 lP = p + lDir * tt;\n                tau += map(lP);\n                tt += stepL;\n            }\n            float lightRayAtt = exp(-tau * stepL);\n\n            res += lightRayAtt * transparency * stepSize;\n        \n        }\n        t += stepSize;\n        #endif\n    }\n    #if (A1 == 0)\n    res = lightEnergy;\n    #endif\n    //res = mix(res, bac*(1.-transmittance), lightEnergy);\n    res += bac * transmittance;\n    \n    //res = bac * transmittance + res;\n\n    return vec2(t, d);\n}\n\nvec3 shade(const in vec3 ro, const in vec3 rd)\n{\n    vec3 r = vec3(0);\n    vec2 mou = iMouse.xy / iResolution.xy;\n    float t = iTime*.1;\n    vec3 lDir = normalize(vec3(0.0, 0., -.0)+\n    vec3(sin(t)*2.2, 100., cos(t)*2.));\n    vec2 m = march(ro, rd, lDir, r);\n    return r;// vec3(m.x*.02);\n}\n\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (-iResolution.xy + fragCoord * 2.0) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0.0, 0.1, -1.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    #if 1\n\n    mat2 r = rot(mou.y*-PI*.05);\n\n    //ro.z += iTime *.2;\n    //rd.z += iTime *.2;\n\n    ro.yz *= r;\n    rd.yz *= r;\n    \n    r = rot(mou.x*TWO_PI);\n\n    ro.xy *= r;\n    rd.xy *= r;\n    \n    \n    \n    #endif\n    \n    \n\n    vec2 recRes = 1./iResolution.xy;\n    float mRecRes = max(recRes.x, recRes.y);\n    \n    float rat = iResolution.x/iResolution.y;\n    \n    float v = sdRoundedBox( uv, vec2(.87, 0.8)*vec2(rat, 1.), vec4(0.));\n\n    // Time varying pixel color\n    vec3 col0 = mix(vec3(1), vec3(0), smoothstep(0., mRecRes*150., v));\n\n    vec3 col = shade(ro, rd);\n\n    // Output to screen\n    \n    fragColor = mix(vec4(col, 1.), vec4(0.), vec4(1.-col0, 1.));\n    //fragColor = vec4(pow(col, vec3(1.)),1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 129, 152, 152, 255], [384, 384, 403, 403, 1744], [4650, 4650, 4705, 4705, 4862], [4864, 4864, 4921, 4972, 5882]], "test": "untested"}
{"id": "csdcW2", "name": "Latte Art", "author": "wyatt", "description": "Latte Art simulation. (Use the mouse to become a barista) ", "tags": ["fluid"], "likes": 25, "viewed": 273, "published": 3, "date": "1695501287", "time_retrieved": "2024-07-30T17:32:05.134170", "image_code": "// Fork of \"Shader Fluid\" by wyatt. https://shadertoy.com/view/mddyWn\n// 2023-09-23 13:52:35\n\nfloat segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    vec4 T(vec3 p ) {\n        return A(p.xz*.8*r.y+.5*r);\n    }\nfloat map (vec3 p, out bool b) {\n    b = false;\n    float d = 1e9;\n    d = min(d,length(p)-.65);\n    d = max(d,p.y);\n    d = max(d,-length(p)+.55);\n    d = min(d,length(vec2(length(p.xz)-.6,p.y))-.05);\n    d = min(d,max(-length(p)+.6,length(vec2( length(p.xy-vec2(.62,-.3))-.2,p.z))-.06));\n    d = min(d,segment(vec2(length(p.xz),p.y),vec2(0,-.8),vec2(.5,-.7))-.05);\n    d = min(d,segment(vec2(length(p.xz),p.y+.1-.2*length(p.xz)),vec2(.5,-.65),vec2(.9,-.6))-.05);\n    \n    float m = max(length(p)-.65,p.y+.1);\n    \n    if (m < d) {\n        b = true;\n        vec4 _ = T(p);\n        m -=  .01*_.z+.1*_.w;\n        d = m;\n    }\n    return d;\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-4,0);\n    bool b;\n    return normalize(vec3 (\n        map(p+e.xyy,b)-map(p-e.xyy,b),\n        map(p+e.yxy,b)-map(p-e.yxy,b),\n        map(p+e.yyx,b)-map(p-e.yyx,b)\n    ));\n}\nMain {\n //if (iFrame%8>0) discard;\n    vec3 p = vec3(0,-.3,-3.5);\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,4));\n    float t = -.8;\n    p.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    float m = 0.;\n    bool b;\n    for (float i = 0.; i < 60.; i++) {\n        m += map(p+d*m,b);\n        if (m > 10.) {m=10.;break;}\n    }\n    \n    if (b) {\n        vec3 q = p+d*m;\n        vec3 n = normal(q);\n        float t = T(q).z;\n        Q = vec4(.3,.1,.1,1);\n        float bb = 0.;\n        \n        Q += texture(iChannel1,reflect(d,n))*.5+.2*texture(iChannel2,reflect(d,n));\n        if (m==10.) Q = vec4(0);\n        Q = mix(Q,vec4(.3,.1,.1,1)+.84+.2*n.zzzz,min(10.*t,1.));\n     } else {\n        vec3 n = normal(p+d*m);\n        Q = vec4(1,.9,.8,1)*(.8+.2*n.y)*(.8+.1*texture(iChannel1,reflect(d,n))+.1*texture(iChannel2,reflect(d,n)));\n        if (m==10.) Q = .04+.16*sin(4.8+.3*U.x/R.x+vec4(1,2,3,4));\n    }\n    \n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U) \n\n#define density 1.\n#define gravity .5\n\n#define K .05\n\n\n\n#define r R", "buffer_a_code": "Main {\n\n    Q = A(U);\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n\n    Q.xy += .5*(0.25*(n.xy+e.xy+s.xy+w.xy)-Q.xy)-\n        .2*vec2(e.w-w.w,n.w-s.w);\n    Q.xy *= .999;\n    \n    if (length(U-.5*r)>.45*r.y) Q.xyz *= 0.;\n    \n    vec4 _m = A(vec2(.5));\n    vec2 mu = U-_m.xy;\n    vec2 dv = .004*(_m.xy-_m.zw);\n    if (length(dv)>.05) dv = .08*normalize(dv);\n    if (iMouse.z>0.&&iMouse.w < 1.) \n        Q =\n            mix(Q,\n            \n                vec4(Q.xy+dv,1.,Q.w+.04*exp(-100.*length(dv))),\n            \n                exp(-vec4(.002,.002,.02,.01)*dot(mu,mu))\n             );\n    \n    \n    \n    if (iFrame < 1 ) Q = vec4(0,0,0,.1);\n\n    \n    if (U.x < 1. && U.y < 1.) Q = A(U);\n    else if (U.x < 3. && U.y < 3.) Q = vec4(0);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    \n    for(int x=-1;x<=1;x++)\n    for(int y=-1;y<=1;y++)  if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n      {\n           float j = .5;//+.1*max(1.-q.w,0.);\n           float k = .5;//+.1*max(1.-Q.w,0.);\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ += vec4(Q.xyz,1)*wa+vec4(q.xyz,1)*wb;\n      }\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    \n    if (U.x < 1. && U.y < 1.) Q = A(U);\n    else if (U.x < 3. && U.y < 3.) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\n    Q = A(U);\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n\n    Q.xy += .5*(0.25*(n.xy+e.xy+s.xy+w.xy)-Q.xy)-\n        .2*vec2(e.w-w.w,n.w-s.w);\n    Q.xy *= .999;\n    \n    if (length(U-.5*r)>.45*r.y) Q.xyz *= 0.;\n    \n    vec4 _m = A(vec2(.5));\n    vec2 mu = U-_m.xy;\n    vec2 dv = .004*(_m.xy-_m.zw);\n    if (length(dv)>.05) dv = .08*normalize(dv);\n    if (iMouse.z>0.&&iMouse.w < 1.) \n        Q =\n            mix(Q,\n            \n                vec4(Q.xy+dv,1.,Q.w+.04*exp(-100.*length(dv))),\n            \n                exp(-vec4(.002,.002,.02,.01)*dot(mu,mu))\n             );\n    \n    \n    \n    if (iFrame < 1 ) Q = vec4(0,0,0,.1);\n\n    \n    if (U.x < 1. && U.y < 1.) Q = A(U);\n    else if (U.x < 3. && U.y < 3.) Q = vec4(0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "float segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    vec4 T(vec3 p ) {\n        return A(p.xz*.8*r.y+.5*r);\n    }\nfloat map (vec3 p, out bool b) {\n    b = false;\n    float d = 1e9;\n    d = min(d,length(p)-.65);\n    d = max(d,p.y);\n    d = max(d,-length(p)+.55);\n    d = min(d,length(vec2(length(p.xz)-.6,p.y))-.05);\n    d = min(d,max(-length(p)+.6,length(vec2( length(p.xy-vec2(.62,-.3))-.2,p.z))-.06));\n    d = min(d,segment(vec2(length(p.xz),p.y),vec2(0,-.8),vec2(.5,-.7))-.05);\n    d = min(d,segment(vec2(length(p.xz),p.y+.1-.2*length(p.xz)),vec2(.5,-.65),vec2(.9,-.6))-.05);\n    \n    float m = max(length(p)-.65,p.y+.1);\n    \n    if (m < d) {\n        b = true;\n        vec4 _ = T(p);\n        m -=  .01*_.z+.1*_.w;\n        d = m;\n    }\n    return d;\n}\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    \n    for(int x=-1;x<=1;x++)\n    for(int y=-1;y<=1;y++)  if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n      {\n           float j = .5;//+.1*max(1.-q.w,0.);\n           float k = .5;//+.1*max(1.-Q.w,0.);\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ += vec4(Q.xyz,1)*wa+vec4(q.xyz,1)*wb;\n      }\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    \n    if (U.x < 1. && U.y < 1.) {\n       U = iMouse.xy;\n       vec3 p = vec3(0,-.3,-3.5);\n        vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,4));\n        float t = -.8;\n        p.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        float m = 0.;\n        bool b;\n        for (float i = 0.; i < 60.; i++) {\n            m += map(p+d*m,b);\n            if (m > 10.) {m=10.;break;}\n        }\n        Q.zw = Q.xy;\n        Q.xy = (p + d*m).xz;\n        Q.xy = Q.xy*.8*r.y+.5*r;\n        if (Q.z < 1.) Q.zw = Q.xy;\n    }\n    else if (U.x < 3. && U.y < 3.) Q = vec4(0);\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 134, 134, 213], [218, 218, 235, 235, 277], [278, 278, 310, 310, 918], [919, 919, 941, 941, 1134]], "test": "untested"}
{"id": "mddcWB", "name": "1-4D RGBA Value Noise (fork)", "author": "fishy", "description": "99.999% made by afl_ext, I just replaced all the floats with vec4s. Also replaced the hash functions with those from here: https://www.shadertoy.com/view/4djSRW", "tags": ["procedural", "2d", "3d", "noise", "4d", "1d", "value"], "likes": 0, "viewed": 136, "published": 3, "date": "1695494755", "time_retrieved": "2024-07-30T17:32:05.881173", "image_code": "vec4 oct(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec4 oct(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 oct(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 oct(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 achnoise(float x){\n\tfloat p = floor(x);\n\tfloat fr = fract(x);\n\tfloat L = p;\n\tfloat R = p + 1.0;\n\t\n\tvec4 Lo = oct(L);\n\tvec4 Ro = oct(R);\n\t\n\treturn mix(Lo, Ro, fr);\n} \n\nvec4 achnoise(vec2 x){\n\tvec2 p = floor(x);\n\tvec2 fr = fract(x);\n\tvec2 LB = p;\n\tvec2 LT = p + vec2(0.0, 1.0);\n\tvec2 RB = p + vec2(1.0, 0.0);\n\tvec2 RT = p + vec2(1.0, 1.0);\n\t\n\tvec4 LBo = oct(LB);\n\tvec4 RBo = oct(RB);\n\tvec4 LTo = oct(LT);\n\tvec4 RTo = oct(RT);\n\t\n\tvec4 noise1d1 = mix(LBo, RBo, fr.x);\n\tvec4 noise1d2 = mix(LTo, RTo, fr.x);\n\t\n\tvec4 noise2d = mix(noise1d1, noise1d2, fr.y);\n\t\n\treturn noise2d;\n} \nvec4 achnoise(vec3 x){ \n\tvec3 p = floor(x);\n\tvec3 fr = fract(x);\n\tvec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n\tvec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n\tvec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n\tvec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\t                   \n\tvec3 LBF = p + vec3(0.0, 0.0, 1.0);\n\tvec3 LTF = p + vec3(0.0, 1.0, 1.0);\n\tvec3 RBF = p + vec3(1.0, 0.0, 1.0);\n\tvec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\t\n\tvec4 l0candidate1 = oct(LBZ);\n\tvec4 l0candidate2 = oct(RBZ);\n\tvec4 l0candidate3 = oct(LTZ);\n\tvec4 l0candidate4 = oct(RTZ);\n\t\n\tvec4 l0candidate5 = oct(LBF);\n\tvec4 l0candidate6 = oct(RBF);\n\tvec4 l0candidate7 = oct(LTF);\n\tvec4 l0candidate8 = oct(RTF);\n\t\n\tvec4 l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n\tvec4 l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n\tvec4 l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n\tvec4 l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\t\n\t\n\tvec4 l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n\tvec4 l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\t\n\t\n\tvec4 l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\t\n\treturn l3candidate1;\n} \n\n\nvec4 achnoise(vec4 x){ \n\tvec4 p = floor(x);\n\tvec4 fr = fract(x);\n\tvec4 LBZU = p + vec4(0.0, 0.0, 0.0, 0.0);\n\tvec4 LTZU = p + vec4(0.0, 1.0, 0.0, 0.0);\n\tvec4 RBZU = p + vec4(1.0, 0.0, 0.0, 0.0);\n\tvec4 RTZU = p + vec4(1.0, 1.0, 0.0, 0.0);\n\t                 \n\tvec4 LBFU = p + vec4(0.0, 0.0, 1.0, 0.0);\n\tvec4 LTFU = p + vec4(0.0, 1.0, 1.0, 0.0);\n\tvec4 RBFU = p + vec4(1.0, 0.0, 1.0, 0.0);\n\tvec4 RTFU = p + vec4(1.0, 1.0, 1.0, 0.0);\n\t                 \n\tvec4 LBZD = p + vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 LTZD = p + vec4(0.0, 1.0, 0.0, 1.0);\n\tvec4 RBZD = p + vec4(1.0, 0.0, 0.0, 1.0);\n\tvec4 RTZD = p + vec4(1.0, 1.0, 0.0, 1.0);\n\t                 \n\tvec4 LBFD = p + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 LTFD = p + vec4(0.0, 1.0, 1.0, 1.0);\n\tvec4 RBFD = p + vec4(1.0, 0.0, 1.0, 1.0);\n\tvec4 RTFD = p + vec4(1.0, 1.0, 1.0, 1.0);\n\t\n\tvec4 l0candidate1  = oct(LBZU);\n\tvec4 l0candidate2  = oct(RBZU);\n\tvec4 l0candidate3  = oct(LTZU);\n\tvec4 l0candidate4  = oct(RTZU);\n\t\n\tvec4 l0candidate5  = oct(LBFU);\n\tvec4 l0candidate6  = oct(RBFU);\n\tvec4 l0candidate7  = oct(LTFU);\n\tvec4 l0candidate8  = oct(RTFU);\n\t\n\tvec4 l0candidate9  = oct(LBZD);\n\tvec4 l0candidate10 = oct(RBZD);\n\tvec4 l0candidate11 = oct(LTZD);\n\tvec4 l0candidate12 = oct(RTZD);\n\t\n\tvec4 l0candidate13 = oct(LBFD);\n\tvec4 l0candidate14 = oct(RBFD);\n\tvec4 l0candidate15 = oct(LTFD);\n\tvec4 l0candidate16 = oct(RTFD);\n\t\n\tvec4 l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n\tvec4 l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n\tvec4 l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n\tvec4 l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\tvec4 l1candidate5 = mix(l0candidate9, l0candidate10, fr[0]);\n\tvec4 l1candidate6 = mix(l0candidate11, l0candidate12, fr[0]);\n\tvec4 l1candidate7 = mix(l0candidate13, l0candidate14, fr[0]);\n\tvec4 l1candidate8 = mix(l0candidate15, l0candidate16, fr[0]);\n\t\n\t\n\tvec4 l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n\tvec4 l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\tvec4 l2candidate3 = mix(l1candidate5, l1candidate6, fr[1]);\n\tvec4 l2candidate4 = mix(l1candidate7, l1candidate8, fr[1]);\n\t\n\t\n\tvec4 l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\tvec4 l3candidate2 = mix(l2candidate3, l2candidate4, fr[2]);\n\t\n\tvec4 l4candidate1 = mix(l3candidate1, l3candidate2, fr[3]);\n\t\n\treturn l4candidate1;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\tvec2 position = (uv) * 100.0;\n\n\tvec4 color = vec4(0);\n\t\n\tif(uv.x < 0.5 && uv.y < 0.5){\n\t\tcolor = achnoise(position.x);\t\n\t}\n\telse if(uv.x > 0.5 && uv.y < 0.5){\n\t\tcolor = achnoise(position);\t\n\t}\n\telse if(uv.x < 0.5 && uv.y > 0.5){\n\t\tcolor = achnoise(vec3(position, iTime));\t\n\t}\n\telse if(uv.x > 0.5 && uv.y > 0.5){\n\t\tcolor = achnoise(vec4(position, iMouse.x / iResolution.x, iTime));\t\n\t}\n\tfragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 167], [169, 169, 187, 187, 336], [338, 338, 356, 356, 505], [507, 507, 526, 526, 660], [662, 662, 685, 685, 831], [834, 834, 856, 856, 1238], [1240, 1240, 1262, 1262, 2336], [2340, 2340, 2362, 2362, 4645], [4648, 4648, 4705, 4705, 5172]], "test": "untested"}
{"id": "ddcyDj", "name": "water and wind", "author": "silica163", "description": "change some line and it become water", "tags": ["fbm", "water", "warp"], "likes": 0, "viewed": 188, "published": 3, "date": "1695484130", "time_retrieved": "2024-07-30T17:32:06.631168", "image_code": "#define PI 3.14159265\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nfloat w(float x,float a,float s,float offset){\n    float S = pow(a,s);\n    return sin(x*S+offset)/S;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float c = 0.;\n    float repeat = 6.;\n    float s = 10.;// scale factor\n    float t = iTime;\n    vec2 p = uv*2.;\n    \n    \n    for(float i = 0.;i < repeat;i++){\n        c += w(p.x+w(p.y+w(p.x,s,i,t*i),s,i,t-i),s,i,t*i*2.);\n        p = rot2D(PI/7.)*p;\n        p+=cos(c);\n        p.x = p.x + c;\n        p.y = p.y - c;\n        p += uv.xy*rot2D(PI/(i+.1));\n    }\n    \n    //c = w(uv.x,s,3.,iTime)+.5;\n    c = c*.2+.5;\n    vec3 col = mix(vec3(.6,.9,1),vec3(0,.2,1),c);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 121, 121, 177], [179, 179, 236, 236, 800]], "test": "untested"}
{"id": "cs3cD2", "name": "trying to warp", "author": "silica163", "description": " I don't sure what it is but it beautiful.", "tags": ["fbm", "warp", "warm"], "likes": 5, "viewed": 198, "published": 3, "date": "1695479372", "time_retrieved": "2024-07-30T17:32:11.519099", "image_code": "#define PI 3.14159265\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nfloat w(float x,float a,float s,float offset){\n    float S = pow(a,s);\n    return sin(x*S+offset)/S;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float c = 0.;\n    float repeat = 8.;\n    float s = 1.6;// scale factor\n    float t = iTime*.3;\n    vec2 p = uv*2.;\n    \n    \n    for(float i = 0.;i < repeat;i++){\n        c += w(p.x+w(p.y+w(p.x,s,i,t*i),s,i,t-i),s,i,t*i*2.);\n        p = rot2D(PI/7.)*p;\n        //p+=cos(c);\n        p.x = p.x + c;\n        p.y = p.y + c;\n        p += uv.yx*rot2D(PI/(i+.01));\n    }\n    \n    //c = w(uv.x,s,3.,iTime)+.5;\n    c = c*.2+.5;\n    vec3 col = mix(vec3(.6,.1,.4),vec3(1,.7,.4),c);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs3cD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 121, 121, 177], [179, 179, 236, 236, 808]], "test": "untested"}
{"id": "DscyWj", "name": "Wind Tunne MantaRay", "author": "ollj", "description": "200x100x100 Fluid simulation... \nhttps://www.shadertoy.com/view/4ls3zM (manta model)\nhttps://www.shadertoy.com/view/DdtcDS (fluid sim canvas (overstepping-adjusted)\n", "tags": ["fluid"], "likes": 16, "viewed": 363, "published": 3, "date": "1695453603", "time_retrieved": "2024-07-30T17:32:12.625142", "image_code": "vec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\n\nvec4 G (vec3 V, int i) {\n    if (V.x>R3.x) V.x-= R3.x, i+=1;\n    return H(_3D(V),i); \n}\nvec4 T (vec3 u, int i) {\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f,i);\n    vec4 _001 = G(vec3(f.xy,c.z),i);\n    vec4 _010 = G(vec3(f.x,c.y,f.z),i);\n    vec4 _011 = G(vec3(f.x,c.yz),i);\n    vec4 _100 = G(vec3(c.x,f.yz),i);\n    vec4 _101 = G(vec3(c.x,f.y,c.z),i);\n    vec4 _110 = G(vec3(c.xy,f.z),i);\n    vec4 _111 = G(c,i);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\n\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-4,0);\n    return normalize(vec3(\n        map(p+e.xyy,iTime)-map(p-e.xyy,iTime),\n        map(p+e.yxy,iTime)-map(p-e.yxy,iTime),\n        map(p+e.yyx,iTime)-map(p-e.yyx,iTime)\n    ));\n}\nMain {\n     //if(iFrame%8>0) discard;\n    vec3 p = vec3(0,-.2,-2.);\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,1.5));\n    float t = .2+.2*sin(.178*iTime);\n    if (iMouse.z>0.) {\n        t = 3.*iMouse.y/R.y-1.;\n        p.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        t = 3.*iMouse.x/R.x-1.;\n    }\n    p.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    float m = 0.;\n    float xy = iPlane(p,d,vec3(0,0,1));\n    vec3 p_xy = p + d*xy;\n    float xz = iPlane(p-vec3(0,-.7,0),d,vec3(0,1,0));\n    vec3 p_xz = p + d*xz;\n    for (float i = 0.; i < 300.; i++) {//more than 100 steps for understepping\n        m += map(p+m*d,iTime)*.2;  //understepping for distorted manta ray model\n    }\n    if (m < 100.) {\n        vec3 no = normal(p+m*d);\n        Q = vec4(.5)-.5*dot(no,.5*vec3(1,-1,1));\n        Q *= sin(-2.+8.*length(T(((p+(m-.05)*d+no*.01)*.5+.5)*R3-.1,0).xyzw-vec4(vel,0,0,0))+vec4(1,2,3,4));\n    } else Q = vec4(0);\n    {\n        vec4 txz =  T((p_xz*.5+.5)*R3-.5,2);\n        vec4 txy = T((p_xy*.5+.5)*R3-.5,2);\n        vec4 txz_v =  T((p_xz*.5+.5)*R3-.5,0);\n        vec4 txy_v = T((p_xy*.5+.5)*R3-.5,0);\n        txz += abs(txz_v-vec4(vel,0,0,0));\n        txy += abs(txy_v-vec4(vel,0,0,0));\n        if (xz>0.&&p_xz.y>-1.&&p_xz.y<1.&&p_xz.x>-1.&&p_xz.x<2.&&p_xz.z>-1.&&p_xz.z<1.) \n            Q = mix(Q,txz,.25+.25*sign(m-xz));\n       if (xy>0.&&p_xy.y>-1.&&p_xy.y<1.&&p_xy.x>-1.&&p_xy.x<2.&&p_xy.z>-1.&&p_xy.z<1.) \n            Q = mix(Q, txy,.25+.25*sign(m-xy));\n    }\n    //Q = abs(texture(iChannel0,d));\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U) \n\n\n    #define vel .4\n\n#define R3 vec3(100,100,100)\n#define R2 vec2(1000,1000)\nvec2 _3D (vec3 u) {\n    u = clamp(u,vec3(0),R3-1.);\n    u = floor(u);\n    return .5+u.xy+R3.xy*vec2(mod(u.z,R2.x/R3.x),floor(u.z*R3.x/R2.x));\n}\nvec3 _3D (vec2 u) {\n    u = floor(u);\n    return .5+vec3(mod(u,R3.xy),floor(u.x/R3.x)+R2.x/R3.x*floor(u.y/R3.y));\n}\n\n\n\n\nfloat iPlane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\n\nfloat segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment(vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float line (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\nfloat cylinder( vec3 p, vec2 h )\n\t\t{\n\t\t    h.y *= 0.5;\n\t\t    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat cylinder( vec3 p, float r, float h )\n\t\t{\n\t\t    return cylinder(p,vec2(r,h));\n\t\t}\n\t\tfloat sign_side (vec2 p1, vec2 p2, vec2 p3)\n        {\n            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n        }\n        float PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n        {\n            float d1, d2, d3;\n            bool has_neg, has_pos;\n        \n            d1 = sign_side(pt, v1, v2);\n            d2 = sign_side(pt, v2, v3);\n            d3 = sign_side(pt, v3, v1);\n        \n            has_neg = (d1 < 0.) || (d2 < 0.) || (d3 < 0.);\n            has_pos = (d1 > 0.) || (d2 > 0.) || (d3 > 0.);\n        \n            return float((has_neg && has_pos))*2.-1.;\n        }\n        float triangle (vec2 p, vec2 a, vec2 b, vec2 c) {\n            return PointInTriangle(p.xy,a,b,c)*min(segment(p,a,b),min(segment(p,b,c),segment(p,c,a)));\n        }\n        float triPrism(vec3 p, vec2 a, vec2 b, vec2 c, float h) {\n          vec2 d = vec2(triangle(p.xy,a,b,c),abs(p.z)-.5*h);\n          \n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\t\tfloat triPrism( vec3 p, vec2 h )\n        {\n          vec3 q = abs(p);\n          return max(q.z-.5*h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n        }\n        float segment ( vec3 p, vec3 a, vec3 b, float r )\n        {\n          vec3 pa = p - a, ba = b - a;\n          float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n          return length( pa - ba*h ) - r;\n        }\n\t\tfloat box(vec2 p, vec2 b) {\n\t\t\tvec2 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box( vec3 p, vec3 b )\n\t\t{\n\t\t    vec3 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box(vec3 p, float w, float h, float l) {return box(p,vec3(w,h,l));}\n\t\tfloat box(vec2 p, float w, float h) {return box(p,vec2(w,h));}\n\t\tfloat roundBox ( vec3 p, vec3 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return cylinder(p,vec2(r,b.z));\n\t\t}\n\t\tfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return length(p)-r;\n\t\t}\n\t\tfloat roundBox(vec3 p, float w, float h, float l, float r) {return roundBox(p,vec3(w,h,l),r);}\n\t\tfloat roundBox(vec2 p, float w, float h, float r) {return roundBox(p,vec2(w,h),r);}\n\t\t\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    // calculate deformed radius, not exact but fast estimate\n    float smallestSize = min(min(r.x,r.y),r.z);\n    vec3 deformedP = p/r;\n    float d = length(deformedP) - 1.0;\n    // renormalize - ish\n   \treturn d * smallestSize;\n}\n\nfloat wings(in vec3 p) \n{   \n    vec3 r = vec3(1.5, 0.15, 0.55);\n    float smallestSize = min(min(r.x,r.y),r.z);\n    \n    // scale and position\n    vec3 dp = p/r;\n    dp.z -= dp.x*dp.x*0.8; //bend backward\n    dp.z -= (dp.x-0.6)*(dp.x-0.5);\n    dp.y -= 0.6; // lift up\n    \n    // shape\n    float d = (dp.y*dp.y + dp.z*dp.z);\n    d += abs(dp.x);\n    d -= 1.0; // radius\n    \n    return d * smallestSize;\n}\n\n\nfloat softMin(float a, float b, float k)\n{\n    // Inigo's soft min implementation\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n      \nfloat mantabody(in vec3 p)\n{\n    // body\n    float d = sdEllipsoid(p, vec3(0.4,0.3,0.8));\n    \n    // wings\n    if (p.z < 1.0 && p.z > -1.4 &&\n       \tp.y < 1.0 && p.y > -0.2) \n    {\n    \td = softMin(d, wings(p), 0.4);\n    }\n    \n    vec3 flapsP;\n    vec3 flapsScale;\n    \n    // bottom flaps\n    if (p.x < 1.0 && \n        p.z < -0.2 && p.z > -1.4 &&\n       \tp.y < 0.2 && p.y > -0.2) \n    {\n        flapsP = p;\n    \tflapsP += vec3(-0.5-p.z*0.2,0.3-p.x*0.5,1.0-p.x*0.2);\n\t    flapsScale = vec3(.09,.08,.25);\n    \td = softMin(d, sdEllipsoid(flapsP,flapsScale),0.2);\n    }\n    \n    // dorsal fin\n    if (p.x < 0.2 && \n        p.z > 0.3 && p.z < 1.0 &&\n       \tp.y > 0.1 && p.y < 0.5) \n    {\n\t    flapsP = p;\n    \tflapsP += vec3(0.,-0.15- 0.2*p.z,-0.7);\n\t    flapsScale = vec3(.03,.1,.2);\n    \td = softMin(d, sdEllipsoid(flapsP,flapsScale),0.15);\n    }\n    \n    // tail\n    if (p.z>0.0) {    \n\t    float taild = length(p.xy);\n    \td = softMin(d,taild,0.1);\n        d = max(d, smoothstep(2.3,2.5,p.z));\n    }\n    \n    \n    return d;\n}\n              \nfloat hash( float n ){    return fract(sin(n)*43758.5453123);}\nfloat GetMantaScale(in float rowId, in float columnId){\n    // randomized scale factor based on cell\n\treturn 0.6 + 0.6*hash(7.*rowId + 11.* columnId);}\n\n\nfloat animatedManta(in vec3 p, in float rowId, in float columnId, float time) \n{   \n    float size = GetMantaScale(rowId, columnId);\n    \n    // animate\n    float timeloop = time * 2.5 / (size-0.25) + // loop speed\n        hash(rowId+3.*columnId) * 10.; // random offset\n    //p.y+= -sin(timeloop-0.5)*.25 * size;\n    //p.y+= sin(time*0.5 + hash(37.*rowId+11.*columnId)*17.) * 2.5;\n    \n \tvec3 mantap = p/size;\n    mantap.x = abs(mantap.x);    \n \n    float animation = sin(timeloop-3. - 1.3*mantap.z);\n    float animationAmount = pow(mantap.x,1.5);\n    // cap max deformation to reduce ray marching aliasing on wings\n    animationAmount = min(animationAmount, 2.5); \n    mantap.y += animation * (0.3*animationAmount + 0.15);\n    \n    float d = mantabody(mantap);\n    \n    return d*size;\n}\n        \n        \n        \nfloat wheels (vec3 p, float s) {\n    vec3 q = p;\n    p = abs(p)-vec3(.3,0,.3);\n    s *= 2.*sign(-q.z);\n    \n    if (q.x<0.) p.xz *= mat2(cos(s),sin(s),-sin(s),cos(s));\n    return max(cylinder(p,.1,.1),-cylinder(p-vec3(0,.0,0),.07,.15));\n}\nfloat map (vec3 p, float time) {\n    float osc=sin(time*.01)*.8;\n    return animatedManta(p.zyx*vec3(1,1,1)-vec3(osc,-.65,-.2),0.0 , 0.0 ,time*.1);\n    float d = 1e9;\n    float s = .2*sin(.2*time);\n    p.z += s;\n    p.y += 1.;\n    p *= .8;\n    p.xz *= mat2(cos(s),sin(s),-sin(s),cos(s));\n    float w = wheels(p-vec3(0,.2,0),.2*cos(.2*time));\n    d = min(d,roundBox(p-vec3(0,.3,0),vec3(1.,.2,.6),.02));\n    d = min(d,triPrism(p,vec2(-.3,.4),vec2(-.1,.4),vec2(-.1,.6),.45));\n    d = min(d,roundBox(p-vec3(.02,.5,0),vec3(.25,.2,.45),.02));\n    d = max(d,min(w-.06,-roundBox(p-vec3(.3,.4,0),vec3(.3,.14,.45),.02)));\n    d = min(max(d,-w+.05),w);\n    p.z = abs(p.z);\n    d = min(d,roundBox(p.zyx-vec3(.3,.44,-.25),vec3(.1,.05,.01),.01));\n    return d/.8-.014;\n}", "cube_a_code": "int face (vec3 dir){\n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        return 0;\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        return 1;\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        return 2;\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        return 3;\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        return 4;\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        return 5;\n    } else return -1;\n}\nvec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\nvec4 G (vec3 V, int i) {\n    if (V.x>R3.x) V.x-= R3.x, i+=1;\n    return H(_3D(V),i); \n}\nvec4 T (vec3 u, int i) {\n    u -= .5;\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f,i);\n    vec4 _001 = G(vec3(f.xy,c.z),i);\n    vec4 _010 = G(vec3(f.x,c.y,f.z),i);\n    vec4 _011 = G(vec3(f.x,c.yz),i);\n    vec4 _100 = G(vec3(c.x,f.yz),i);\n    vec4 _101 = G(vec3(c.x,f.y,c.z),i);\n    vec4 _110 = G(vec3(c.xy,f.z),i);\n    vec4 _111 = G(c,i);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\nvec4 F (vec3 u, int i) {\n    if (iFrame%4==0) {\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        return T(u,i);\n    } else {\n        return G(u,i);\n    }\n}\nvoid mainCubemap( out vec4 Q, in vec2 U, in vec3 _, in vec3 d )\n{\n    int f = face(d);\n    if (f < 2) {\n        vec3 V = _3D(U)+R3.x*vec3(f,0,0);\n        Q = F(V,0);\n        float k = 1./6.;\n        vec4\n            x_ = F(V+vec3(-1,0,0),0),\n            _x = F(V+vec3(+1,0,0),0),\n            y_ = F(V+vec3(0,-1,0),0),\n            _y = F(V+vec3(0,+1,0),0),\n            z_ = F(V+vec3(0,0,-1),0),\n            _z = F(V+vec3(0,0,+1),0);\n        Q.w = k*( (_x+x_+_y+y_+_z+z_).w - (_x.x-x_.x+_y.y-y_.y+_z.z-z_.z) );\n        Q.xyz -= k*vec3(_x.w-x_.w,_y.w-y_.w,_z.w-z_.w);\n\n        Q.xyz *= smoothstep(-.01/R3.x,0.,map( (V+.5)/R3*2.-1. ,iTime));\n\n        if (V.y < 1. || V.z < 1. || R3.y - V.y < 1. || R3.z - V.z < 1.) Q.xyz *= 0.;\n\n\n        if (V.x < 1.) Q.x = vel,Q.w*=.8;\n        if (R.x - V.x < 2.) Q.x = vel;\n\n\n        if (iFrame < 1) {\n\n            Q = vec4(vel,0,0,0);\n\n        }\n     } else {\n         vec3 V = _3D(U)+R3.x*vec3(f-2,0,0);\n         if (map( (V+.5)/R3*2.-1. ,iTime) < 0.) Q = vec4(1.5,.9,.2,1);\n         else if (V.x < 1.) Q = 2.*vec4(.5+.5*sign(cos(.4*V.y)*cos(.4*V.z)-.5));\n         else if (iFrame < 1) Q = vec4(0);\n         else if (iFrame % 10 == 0) {\n            V -= 2.*G(V,0).xyz;\n            V -= 2.*G(V,0).xyz;\n            V -= 2.*G(V,0).xyz;\n            V -= 2.*G(V,0).xyz;\n            Q = T(V,2);\n         } else {\n             Q = G(V,2);\n         }\n     }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 477], [479, 479, 503, 503, 566], [567, 567, 591, 591, 1194], [1196, 1196, 1218, 1218, 1422]], "test": "untested"}
{"id": "mdtyDS", "name": "warped", "author": "makscee", "description": "warp warp warp and then warp", "tags": ["fbm", "warp"], "likes": 4, "viewed": 241, "published": 3, "date": "1695424174", "time_retrieved": "2024-07-30T17:32:13.558646", "image_code": "#define pi 3.141592653589793\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x*c-vec.y*s, vec.x*s+vec.y*c);\n}\nfloat hash(vec2 p, float t)\n{\n    vec3 p3 = vec3(p, t);\n    p3  = fract(p3*0.1031);\n    p3 += dot(p3, p3.zyx+31.32);\n    return fract((p3.x+p3.y)*p3.z);\n}\nfloat noise(vec2 p, float t)\n{\n    vec4 b = vec4(floor(p), ceil(p));\n    vec2 f = smoothstep(0.0, 1.0, fract(p));\n    return mix(mix(hash(b.xy, t), hash(b.zy, t), f.x), mix(hash(b.xw, t), hash(b.zw, t), f.x), f.y);\n}\n#define num_octaves 1\nfloat fbm(vec2 v)\n{\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n    float t = 0.0;\n    for(int i = 0; i < num_octaves; i++)\n    {\n        t += atten;\n        value += noise(v*scale, float(i))*atten;\n        scale *= 2.0;\n        atten *= 0.5;\n        v = rotate(v, 0.125*pi);\n    }\n    return value/t;\n}\nvec2 fbm_vec(vec2 v, vec2 offset)\n{\n    return vec2(fbm(v), fbm(v + offset));\n}\nvec2 warp(vec2 v, float str, vec2 offset)\n{\n    return v + fbm_vec(v, offset) * str;\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xx - vec2(.4)) * (8.0 + sin(iTime * 0.1) * 2.);\n    uv = warp(uv, 2., vec2(iTime * 0.5));\n    uv = warp(uv, 1., vec2(sin(iTime * .5) * .5));\n    uv = warp(uv, length(uv + vec2(.5)) * .1 + sin(iTime * .022) * 2., vec2(iTime * .001, 0.));\n    uv = warp(uv, length(uv + vec2(.5)) * .2, vec2(sin(iTime * .5) * .5));\n    uv = warp(uv, .5 + sin(iTime * 0.5 + uv.x * 20.) * 2., vec2(iTime * .001, 0.));\n    uv = warp(uv, 2., vec2(sin(iTime * 0.2) * 1.5));\n    uv = warp(uv, 1. + sin(iTime * .45) * 2., vec2(iTime * .001, 0.));\n    float v = length(uv);\n    vec3 col = hsv2rgb(vec3(v * sin(iTime * .1) * .1 + iTime * .0153 , fbm(warp(uv, 1., vec2(0)) + vec2(2.)) * 1.1, length(warp(uv, 1., vec2(0))) * .1));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 63, 63, 154], [155, 155, 184, 184, 309], [310, 310, 340, 340, 526], [549, 549, 568, 568, 877], [878, 878, 913, 913, 957], [958, 958, 1001, 1001, 1044], [1045, 1045, 1067, 1067, 1236], [1237, 1237, 1294, 1294, 2064]], "test": "untested"}
{"id": "MtfXRj", "name": "Quadratic Bezier Sphere", "author": "demofox", "description": "Wrapping an explicit Bezier Rectangle around a sphere in polar coordinates.  Raytracing the bounding sphere, raymarching the intererior.", "tags": ["3d", "bezier", "polar"], "likes": 10, "viewed": 212, "published": 3, "date": "1695419620", "time_retrieved": "2024-07-30T17:32:14.780379", "image_code": "/*\n\nTODO:\n\n* fix NormalAtPos\n* make it work\n\n* make control points have good animation\n* make camera have good animation\n\n* can we make the grid more uniform by using this? https://www.shadertoy.com/view/ltl3D8\n\n* why calculate pos once outside the loop then again immediately inside the loop?\n\n* figure out a way to get a better time value when intersection found.\n\n* try to understand meaning of theta and phi and get intuition for why this works how it does\n\n* blog post\n\n*/\n\nconst float c_pi = 3.14159265359;\nconst float c_twoPi = c_pi * 2.0;\n\n#if 0\n\nfloat anim = sin(iTime) * 0.5 + 0.5;\n\nfloat CP00 = 1.0;\nfloat CP01 = 1.0;\nfloat CP02 = 1.0;\n\nfloat CP10 = 1.0;\nfloat CP11 = anim;\nfloat CP12 = 1.0;\n\nfloat CP20 = 1.0;\nfloat CP21 = 1.0;\nfloat CP22 = 1.0;\n\n#else\n\n#define CP00 (sin(iTime*0.3) * 0.5 + 0.5)\n#define CP01 (sin(iTime*0.1) * 0.5 + 0.5)\n#define CP02 (sin(iTime*0.7) * 0.5 + 0.5)\n\n#define CP10 (sin(iTime*0.2) * 0.5 + 0.5)\n#define CP11 (sin(iTime*0.4) * 0.5 + 0.5)\n#define CP12 (sin(iTime*0.8) * 0.5 + 0.5)\n\n#define CP20 (sin(iTime*0.5) * 0.5 + 0.5)\n#define CP21 (sin(iTime*0.9) * 0.5 + 0.5)\n#define CP22 (sin(iTime*0.6) * 0.5 + 0.5)\n\n#endif\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nvec3 SphericalToCartesian (float theta, float phi, float radius)\n{    \n    return vec3(\n        sin(phi) * cos(theta) * radius,\n        sin(phi) * sin(theta) * radius,\n        cos(phi) * radius\n    );\n}\n\n//=======================================================================================\nvec3 CartesianToSpherical (vec3 p)\n{   \n    float radius = length(p);\n    float theta = atan(p.y, p.x);\n    float phi = atan(length(p.xy), p.z);\n    return vec3(theta, phi, radius);\n}\n\n\n//=======================================================================================\nfloat QuadraticBezier (float A, float B, float C, float t)\n{\n    float s = 1.0 - t;\n    float s2 = s * s;\n    float t2 = t * t;\n    \n    return A*s2 + B*2.0*s*t + C*t2;\n}\n\n\n//=======================================================================================\nfloat DistanceAtPos(vec3 P)\n{\n    vec3 spherical = CartesianToSpherical(P);\n        \n\tfloat theta = spherical.x;  //-pi, +pi\n    float phi = spherical.y;    //-pi, +pi\n    float radius = spherical.z;\n    \n    // normalize each angle to a [0,1] value\n    theta = theta / (c_twoPi);\n    if (theta < 0.0)\n        theta += 1.0;  \n    \n    phi = phi / (c_twoPi);\n    if (phi < 0.0)\n        phi += 1.0;\n    \n    /*\n    if (theta > 0.45)\n        return 0.8;\n    else\n        return 0.5;\n    */\n    \n    // make the bezier surface\n    float CP0X = QuadraticBezier(CP00, CP01, CP02, theta);\n    float CP1X = QuadraticBezier(CP10, CP11, CP12, theta);\n    float CP2X = QuadraticBezier(CP20, CP21, CP22, theta);\n    \n    return QuadraticBezier(CP0X, CP1X,CP2X, phi);\n}\n\n//=======================================================================================\nvec3 NormalAtPos( vec3 p )\n{\n    /*\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n*/\n    \n    return normalize(p);\n}\n\n//=======================================================================================\nbool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec3 roo = rayPos - (boxMin+boxMax)*0.5;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, find and set the two collision times\n\tfloat collisionTime1 = -b - sqrt(discr);\n\tfloat collisionTime2 = -b + sqrt(discr);\n    \n    time = vec2( min(collisionTime1, collisionTime2),\n                 max(collisionTime1, collisionTime2));\n    \n    return time.y>time.x && time.y>0.0;\n}\n\n//=======================================================================================\nvec3 DiffuseColor (in vec3 pos)\n{\n    float radius = length(pos);\n\tfloat theta = atan(pos.y, pos.x);\n    float phi = acos(pos.z / radius);   \n    \n    // normalize each angle to a [0,1] value\n    theta = theta / (c_twoPi) + 0.5;\n    phi = phi / c_pi;    \n    \n\tbool whiteSquare = true;\n\n    if (mod(theta*26.0, 2.0) < 1.0)\n\t\twhiteSquare = !whiteSquare;\n\n\tif (mod(phi*26.0, 2.0) < 1.0)\n\t\twhiteSquare = !whiteSquare;\t\n    \n    return vec3(whiteSquare ? 1.0 : 0.4);\n}\n\n//=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos);\n\n    // diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n\n    // specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(dp, 15.0) * vec3(0.5);\t\n    \n    // reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    color += texture(iChannel0, reflection).rgb * 0.25;\n    \n    return color;\n}\n\n//=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectSphere(vec4(0.0,0.0,0.0,1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float deltaT = (timeMinMax.y - timeMinMax.x) / float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n        \n        height = DistanceAtPos(pos);\n        \n        float actualDist = length(pos);\n        \n        if (actualDist < height)\n        {\n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\ttime += deltaT;\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n\t}\n\t\n\tif (hitFound) {\n\t\t//time = time - deltaT + deltaT*(lastHeight-lastY)/(pos.y-lastY-height+lastHeight);\n\t\t//pos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time);\n        hitTime = time;\n\t}\n    else {\n        pixelColor += vec3(0.2);\n    }\n    \n\treturn pixelColor;\n}\n\n//=======================================================================================\nvec3 HandleControlPoints (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, inout float hitTime)\n{\n    float c_fullAngle = c_twoPi;\n    \n    vec2 cpHitTime;\n    if (RayIntersectSphere(vec4(SphericalToCartesian(0.0, 0.0, CP00), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }\n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle / 2.0, 0.0, CP01), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle, 0.0, CP02), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(1.0,0.0,0.0);\n    } \n    \n    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(0.0, c_fullAngle / 4.0, CP10), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }\n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle / 2.0, c_fullAngle / 4.0, CP11), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle, c_fullAngle / 4.0, CP12), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }     \n    \n    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(0.0, c_fullAngle / 2.0, CP20), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }\n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle / 2.0, c_fullAngle / 2.0, CP21), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle, c_fullAngle / 2.0, CP22), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    \n    return pixelColor;\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n    //----- camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.0;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\t\n\t\t\n\t// Objects\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = texture(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    pixelColor = HandleControlPoints(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1188, 1278, 1344, 1344, 1480], [1482, 1572, 1608, 1608, 1755], [1758, 1848, 1908, 1908, 2018], [2021, 2111, 2140, 2140, 2867], [2869, 2959, 2987, 3252, 3284], [3286, 3376, 3474, 3474, 3816], [3818, 3908, 3994, 4068, 4824], [4826, 4916, 4949, 4949, 5380], [5382, 5472, 5531, 5531, 6244], [6246, 6336, 6424, 6424, 7511], [7513, 7603, 7703, 7703, 9901], [9903, 9993, 10050, 10071, 11421]], "test": "untested"}
{"id": "DsdcRS", "name": "Grainy two", "author": "nicone1", "description": "https://www.shadertoy.com/view/Dd3czl", "tags": ["test"], "likes": 2, "viewed": 171, "published": 3, "date": "1695417815", "time_retrieved": "2024-07-30T17:32:15.843537", "image_code": "#define e 0.000001\n#define shape 0.1\n\nfloat hash(vec2 p)\n{\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 finalColor = vec3(0.0);\n    for (float i = -1.0; i <= 1.0; ++i)\n    {\n        for (float j = -1.0; j <= 1.0; ++j)\n        {\n            vec2 gv = vec2(\n            uv.x * 0.7 + hash(uv + fract(iTime) * e) * i,\n            uv.y * 0.7 + hash(uv + shape + fract(iTime) * e) * j\n            );\n\n            float d = length(gv);\n            vec3 col = vec3(0.01 / d);\n            finalColor += col;\n        } \n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 158], [160, 160, 215, 215, 753]], "test": "untested"}
{"id": "DdtcDS", "name": "Wind Tunnel Simulation", "author": "wyatt", "description": "200x100x100 Fluid simulation... ", "tags": ["fluid"], "likes": 40, "viewed": 386, "published": 3, "date": "1695417346", "time_retrieved": "2024-07-30T17:32:16.826908", "image_code": "vec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\n\nvec4 G (vec3 V, int i) {\n    if (V.x>R3.x) V.x-= R3.x, i+=1;\n    return H(_3D(V),i); \n}\nvec4 T (vec3 u, int i) {\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f,i);\n    vec4 _001 = G(vec3(f.xy,c.z),i);\n    vec4 _010 = G(vec3(f.x,c.y,f.z),i);\n    vec4 _011 = G(vec3(f.x,c.yz),i);\n    vec4 _100 = G(vec3(c.x,f.yz),i);\n    vec4 _101 = G(vec3(c.x,f.y,c.z),i);\n    vec4 _110 = G(vec3(c.xy,f.z),i);\n    vec4 _111 = G(c,i);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\n\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-4,0);\n    return normalize(vec3(\n        map(p+e.xyy,iTime)-map(p-e.xyy,iTime),\n        map(p+e.yxy,iTime)-map(p-e.yxy,iTime),\n        map(p+e.yyx,iTime)-map(p-e.yyx,iTime)\n    ));\n}\nMain {\n     if(iFrame%2>0) discard;\n    vec3 p = vec3(0,-.2,-2.);\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,1.5));\n    float t = .2+.2*sin(.178*iTime);\n    if (iMouse.z>0.) {\n        t = 3.*iMouse.y/R.y-1.;\n        p.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        t = 3.*iMouse.x/R.x-1.;\n    }\n    p.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    float m = 0.;\n    float xy = iPlane(p,d,vec3(0,0,1));\n    vec3 p_xy = p + d*xy;\n    float xz = iPlane(p-vec3(0,-.7,0),d,vec3(0,1,0));\n    vec3 p_xz = p + d*xz;\n    for (float i = 0.; i < 100.; i++) {\n        m += map(p+m*d,iTime);\n    }\n    if (m < 100.) {\n        vec3 no = normal(p+m*d);\n        Q = vec4(.5)-.5*dot(no,.5*vec3(1,-1,1));\n        Q *= sin(-2.+7.*length(T(((p+(m-.05)*d+no*.01)*.5+.5)*R3-.1,0).xyzw-vec4(vel,0,0,0))+vec4(1,2,3,4));\n    } else Q = vec4(0);\n    {\n        vec4 txz =  T((p_xz*.5+.5)*R3-.5,2);\n        vec4 txy = T((p_xy*.5+.5)*R3-.5,2);\n        vec4 txz_v =  T((p_xz*.5+.5)*R3-.5,0);\n        vec4 txy_v = T((p_xy*.5+.5)*R3-.5,0);\n        txz += abs(txz_v-vec4(vel,0,0,0));\n        txy += abs(txy_v-vec4(vel,0,0,0));\n        if (xz>0.&&p_xz.y>-1.&&p_xz.y<1.&&p_xz.x>-1.&&p_xz.x<2.&&p_xz.z>-1.&&p_xz.z<1.) \n            Q = mix(Q,txz,.25+.25*sign(m-xz));\n       if (xy>0.&&p_xy.y>-1.&&p_xy.y<1.&&p_xy.x>-1.&&p_xy.x<2.&&p_xy.z>-1.&&p_xy.z<1.) \n            Q = mix(Q, txy,.25+.25*sign(m-xy));\n    }\n    //Q = abs(texture(iChannel0,d));\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U) \n\n\n    #define vel .2\n\n#define R3 vec3(100,100,100)\n#define R2 vec2(1000,1000)\nvec2 _3D (vec3 u) {\n    u = clamp(u,vec3(0),R3-1.);\n    u = floor(u);\n    return .5+u.xy+R3.xy*vec2(mod(u.z,R2.x/R3.x),floor(u.z*R3.x/R2.x));\n}\nvec3 _3D (vec2 u) {\n    u = floor(u);\n    return .5+vec3(mod(u,R3.xy),floor(u.x/R3.x)+R2.x/R3.x*floor(u.y/R3.y));\n}\n\n\n\n\nfloat iPlane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\n\nfloat segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment(vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float line (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\nfloat cylinder( vec3 p, vec2 h )\n\t\t{\n\t\t    h.y *= 0.5;\n\t\t    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat cylinder( vec3 p, float r, float h )\n\t\t{\n\t\t    return cylinder(p,vec2(r,h));\n\t\t}\n\t\tfloat sign_side (vec2 p1, vec2 p2, vec2 p3)\n        {\n            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n        }\n        float PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n        {\n            float d1, d2, d3;\n            bool has_neg, has_pos;\n        \n            d1 = sign_side(pt, v1, v2);\n            d2 = sign_side(pt, v2, v3);\n            d3 = sign_side(pt, v3, v1);\n        \n            has_neg = (d1 < 0.) || (d2 < 0.) || (d3 < 0.);\n            has_pos = (d1 > 0.) || (d2 > 0.) || (d3 > 0.);\n        \n            return float((has_neg && has_pos))*2.-1.;\n        }\n        float triangle (vec2 p, vec2 a, vec2 b, vec2 c) {\n            return PointInTriangle(p.xy,a,b,c)*min(segment(p,a,b),min(segment(p,b,c),segment(p,c,a)));\n        }\n        float triPrism(vec3 p, vec2 a, vec2 b, vec2 c, float h) {\n          vec2 d = vec2(triangle(p.xy,a,b,c),abs(p.z)-.5*h);\n          \n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\t\tfloat triPrism( vec3 p, vec2 h )\n        {\n          vec3 q = abs(p);\n          return max(q.z-.5*h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n        }\n        float segment ( vec3 p, vec3 a, vec3 b, float r )\n        {\n          vec3 pa = p - a, ba = b - a;\n          float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n          return length( pa - ba*h ) - r;\n        }\n\t\tfloat box(vec2 p, vec2 b) {\n\t\t\tvec2 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box( vec3 p, vec3 b )\n\t\t{\n\t\t    vec3 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box(vec3 p, float w, float h, float l) {return box(p,vec3(w,h,l));}\n\t\tfloat box(vec2 p, float w, float h) {return box(p,vec2(w,h));}\n\t\tfloat roundBox ( vec3 p, vec3 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return cylinder(p,vec2(r,b.z));\n\t\t}\n\t\tfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return length(p)-r;\n\t\t}\n\t\tfloat roundBox(vec3 p, float w, float h, float l, float r) {return roundBox(p,vec3(w,h,l),r);}\n\t\tfloat roundBox(vec2 p, float w, float h, float r) {return roundBox(p,vec2(w,h),r);}\n\t\t\n        \n        \n        \n        \n        \nfloat wheels (vec3 p, float s) {\n    vec3 q = p;\n    p = abs(p)-vec3(.3,0,.3);\n    s *= 2.*sign(-q.z);\n    \n    if (q.x<0.) p.xz *= mat2(cos(s),sin(s),-sin(s),cos(s));\n    return max(cylinder(p,.1,.1),-cylinder(p-vec3(0,.0,0),.07,.15));\n}\nfloat map (vec3 p, float time) {\n    float d = 1e9;\n    float s = .1*sin(.2*time);\n    p.z += s;\n    p.y += 1.;\n    p *= .8;\n    p.xz *= mat2(cos(s),sin(s),-sin(s),cos(s));\n    float w = wheels(p-vec3(0,.2,0),.2*cos(.2*time));\n    d = min(d,roundBox(p-vec3(0,.3,0),vec3(1.,.2,.6),.02));\n    d = min(d,triPrism(p,vec2(-.3,.4),vec2(-.1,.4),vec2(-.1,.6),.45));\n    d = min(d,roundBox(p-vec3(.02,.5,0),vec3(.25,.2,.45),.02));\n    d = max(d,min(w-.06,-roundBox(p-vec3(.3,.4,0),vec3(.3,.14,.45),.02)));\n    d = min(max(d,-w+.05),w);\n    p.z = abs(p.z);\n    d = min(d,roundBox(p.zyx-vec3(.3,.44,-.25),vec3(.1,.05,.01),.01));\n    return d/.8-.014;\n}", "cube_a_code": "int face (vec3 dir){\n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        return 0;\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        return 1;\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        return 2;\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        return 3;\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        return 4;\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        return 5;\n    } else return -1;\n}\nvec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\nvec4 G (vec3 V, int i) {\n    if (V.x>R3.x) V.x-= R3.x, i+=1;\n    return H(_3D(V),i); \n}\nvec4 T (vec3 u, int i) {\n    u -= .5;\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f,i);\n    vec4 _001 = G(vec3(f.xy,c.z),i);\n    vec4 _010 = G(vec3(f.x,c.y,f.z),i);\n    vec4 _011 = G(vec3(f.x,c.yz),i);\n    vec4 _100 = G(vec3(c.x,f.yz),i);\n    vec4 _101 = G(vec3(c.x,f.y,c.z),i);\n    vec4 _110 = G(vec3(c.xy,f.z),i);\n    vec4 _111 = G(c,i);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\nvec4 F (vec3 u, int i) {\n    if (iFrame%4==0) {\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        return T(u,i);\n    } else {\n        return G(u,i);\n    }\n}\nvoid mainCubemap( out vec4 Q, in vec2 U, in vec3 _, in vec3 d )\n{\n    int f = face(d);\n    if (f < 2) {\n        vec3 V = _3D(U)+R3.x*vec3(f,0,0);\n        Q = F(V,0);\n        float k = 1./6.;\n        vec4\n            x_ = F(V+vec3(-1,0,0),0),\n            _x = F(V+vec3(+1,0,0),0),\n            y_ = F(V+vec3(0,-1,0),0),\n            _y = F(V+vec3(0,+1,0),0),\n            z_ = F(V+vec3(0,0,-1),0),\n            _z = F(V+vec3(0,0,+1),0);\n        if (iFrame%2==0)\n            Q.w -= .1*(Q.w-k*(_x.w+x_.w+_y.w-y_.w+_z.w-z_.w))+.5*(_x.x-x_.x+_y.y-y_.y+_z.z-z_.z) ;\n        else \n            Q.xyz -= .5*vec3(_x.w-x_.w,_y.w-y_.w,_z.w-z_.w);\n\n        Q.xyz *= smoothstep(-.01/R3.x,0.,map( (V+.5)/R3*2.-1. ,iTime));\n\n        if (V.y < 1.  || R3.y - V.y < 1. ) Q .y =0.;\n        if (V.z < 1.|| R3.z - V.z < 1.) Q.z = 0.;\n\n\n        if (V.x < 1.) Q.x = vel;\n        if (R.x - V.x < 1.) Q.x = vel;\n\n\n        if (iFrame < 1) {\n\n            Q = vec4(vel,0,0,0);\n\n        }\n     } else {\n         vec3 V = _3D(U)+R3.x*vec3(f-2,0,0);\n         if (map( (V+.5)/R3*2.-1. ,iTime) < 0.) Q = vec4(1.5,.9,.2,1);\n         else if (V.x < 1.) Q = 2.*vec4(.5+.5*sign(cos(.4*V.y)*cos(.4*V.z)-.5));\n         else if (iFrame < 1) Q = vec4(0);\n         else if (iFrame % 8 == 0) {\n         vec3 u = V;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n            Q = T(u,2);\n         } else {\n             Q = G(V,2);\n         }\n     }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 477], [479, 479, 503, 503, 566], [567, 567, 591, 591, 1194], [1196, 1196, 1218, 1218, 1422]], "test": "untested"}
{"id": "DdtcWB", "name": "Simple Sphere projection", "author": "jsulpis", "description": "Sphere projection (equirectangular projection) with ray casting.", "tags": ["raycasting", "sphere", "projection"], "likes": 4, "viewed": 265, "published": 3, "date": "1695413670", "time_retrieved": "2024-07-30T17:32:18.509409", "image_code": "//=======================================================================================//\n//\n// Simple Sphere projection\n// by Julien Sulpis (https://twitter.com/jsulpis)      \n// https://www.shadertoy.com/view/DdtcWB\n//\n//=======================================================================================//\n\n\n// Sphere params\n#define SPHERE_POSITION vec3(0, 1, 6)\n#define SPHERE_RADIUS 2.\n#define ROTATION_SPEED .3\n#define INFINITY 1e10\n#define PI acos(-1.)\n\n//===============================================//\n//  Generic utilities stolen from smarter people //\n//===============================================//\n\n// https://iquilezles.org/articles/intersectors/\n// sphere of size ra centered at point ce\nfloat sphIntersect(in vec3 ro, in vec3 rd, in vec3 ce, float ra) {\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra * ra;\n  float h = b * b - c;\n  if(h < 0.0)\n    return INFINITY; // no intersection\n  return -b - sqrt(h);\n}\n\n// Inigo Quilez - https://www.shadertoy.com/view/4djSDy\nfloat sphOcclusion(in vec3 pos, in vec3 nor, in vec3 origin, in float radius) {\n  vec3 di = origin - pos;\n  float l = length(di);\n  float nl = dot(nor, di / l);\n  float h = l / radius;\n  float h2 = h * h;\n  float k2 = 1.0 - h2 * nl * nl;\n\n  // above/below horizon\n  // EXACT: Quilez - https://iquilezles.org/articles/sphereao\n  float res = max(0.0, nl) / h2;\n\n  // intersecting horizon \n  if(k2 > 0.001) {\n    // EXACT : Lagarde/de Rousiers - https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    res = nl * acos(-nl * sqrt((h2 - 1.0) / (1.0 - nl * nl))) - sqrt(k2 * (h2 - 1.0));\n    res = res / h2 + atan(sqrt(k2 / (h2 - 1.0)));\n    res /= 3.141593;\n  }\n\n  return res;\n}\n\nmat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n      vec3(c, 0, s),\n      vec3(0, 1, 0),\n      vec3(-s, 0, c)\n  );\n}\n\n//================//\n//  Project code  //\n//================//\n\nstruct Hit {\n  float dist;\n  vec3 color;\n  vec3 normal;\n};\n\nvec2 sphereProjection(vec3 p, vec3 origin) {\n  vec3 dir = normalize(p - origin);\n  float longitude = atan(dir.x, dir.z); // ]-PI, PI]\n  float latitude = asin(dir.y); // [-PI/2, PI/2]\n\n  return vec2(\n    (longitude + PI) / (2. * PI), // ]0, 1]\n    (latitude + PI / 2.) / PI // [0, 1]\n  );\n}\n\nfloat sphereDist(in vec3 ro, in vec3 rd, out vec2 textureCoord) {\n  float simpleSphereDist = sphIntersect(ro, rd, SPHERE_POSITION, SPHERE_RADIUS);\n  vec3 intersection = ro + simpleSphereDist * rd;\n  vec3 intersectionWithRotation = (intersection - SPHERE_POSITION) * rotateY(iTime * ROTATION_SPEED) + SPHERE_POSITION;\n  \n  textureCoord = sphereProjection(intersectionWithRotation, SPHERE_POSITION); \n\n  float bump = length(vec3(texture(iChannel0, textureCoord))) * .02;\n  float dist = sphIntersect(ro, rd, SPHERE_POSITION, SPHERE_RADIUS + bump);\n  \n  return dist;\n}\n\nfloat sphereDist(in vec3 ro, in vec3 rd) {\n  vec2 tmp = vec2(0.);\n  return sphereDist(ro, rd, tmp);\n}\n\nvec3 getNormal(vec3 p) {\n  vec3 rd = SPHERE_POSITION - p;\n  float dist = sphereDist(p, rd);\n  vec2 e = vec2(.001, 0);\n\n  vec3 normal = dist - vec3(\n      sphereDist(p - e.xyy, rd), \n      sphereDist(p - e.yxy, rd), \n      sphereDist(p + e.yyx, rd)\n  );\n  return normalize(normal);\n}\n\nfloat checker(vec2 coord) {\n  float size = 6.;\n  float verticalStripes = step(fract(size * 2. * coord.x), 0.5) - 0.5;\n  float horizontalStripes = step(fract(size * coord.y), 0.5) - 0.5;\n  return step(verticalStripes * horizontalStripes, 0.0);\n}\n\nHit interspectObject(in vec3 ro, in vec3 rd) {\n  vec2 textureCoord = vec2(0.);\n  float dist = sphereDist(ro, rd, textureCoord);\n  vec3 intersection = ro + dist * rd;\n  \n  vec3 normal = getNormal(intersection);\n  vec3 color = vec3(texture(iChannel0, textureCoord));\n  //color = vec3(checker(textureCoord) + .03);\n  \n  float sphereAO = sphOcclusion(intersection, normal, SPHERE_POSITION, SPHERE_RADIUS);\n  color *= vec3(pow(sphereAO, 1.5));\n\n  return Hit(dist, color, normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;\n\n  vec3 ro = vec3(0, 1, 0);\n  vec3 rd = normalize(vec3(uv, 1));\n\n  // background\n  vec3 color = vec3(0.01);\n\n  // sphere\n  Hit hit = interspectObject(ro, rd);\n\n  color = mix(hit.color, color, step(INFINITY, hit.dist));\n\n  // gamma\n  color = pow(color, vec3(1.0 / 2.2));\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[624, 715, 781, 781, 964], [966, 1022, 1101, 1101, 1735], [1737, 1737, 1764, 1764, 1897], [2023, 2023, 2067, 2067, 2312], [2314, 2314, 2379, 2379, 2878], [2880, 2880, 2922, 2922, 2981], [2983, 2983, 3007, 3007, 3265], [3267, 3267, 3294, 3294, 3511], [3513, 3513, 3559, 3559, 3989], [3991, 3991, 4046, 4046, 4432]], "test": "untested"}
{"id": "DtBfD3", "name": "IADB gaussian to discrete", "author": "pyBlob", "description": "Inverse Alpha Deblending ([url=https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html]paper[/url]), forward and backward, showing tracks/source points/mean sources/...\nMouse: click (reset) + drag (forward paused toy)", "tags": ["gaussian", "discrete", "iadb"], "likes": 12, "viewed": 205, "published": 3, "date": "1695413226", "time_retrieved": "2024-07-30T17:32:20.031341", "image_code": "/* See *configuration* in Common for playing around. */\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    resolution = iResolution;\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    float alpha = clamp(root.x / float(nstep), 0., 1.);\n    vec4 tracks = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 stats = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    fragColor = vec4(1);\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0)/20.+.5; return;\n    //fragColor = tracks; return;\n    //fragColor = stats/float(targets.length()-1); return;\n\n    // target of a source point (scatterplot, one color per target)\n    float hasTarget = float(stats.y >= 0.);\n    blend(fragColor, vec4(hue(stats.y/float(targets.length()-1)),1), hasTarget);\n\n    // forward tracks (black lines)\n    blend(fragColor, vec4(0,0,0,1), (1. - tracks.x) * mix(1., .8, hasTarget));\n\n    // source distribution (red dot, red circle)\n    float r = length(fragCoord - world(vec2(0)));\n    blend(fragColor, vec4(1,0,0,1), 3. - r);\n    blend(fragColor, vec4(1,0,0,1), 1. - abs(3. * f() - r));\n\n    // forward track heads (green dots, pink lines)\n    for (int i=0 ; i<int(iResolution.x) ; ++i)\n    {\n        vec4 x = texelFetch(iChannel0, ivec2(i,1), 0);\n        vec2 x1 = predict_x1(x, alpha, method);\n        blend(fragColor, vec4(1,0,1,0.2), 1. - sdSegment(fragCoord, world(x.xy), world(x1)));\n        blend(fragColor, vec4(0,.5,0,1), 2.5 - length(fragCoord - world(x.xy)));\n    }\n\n    // mean destination (orange dot)\n    blend(fragColor, vec4(1,.2,0,1), 3. - length(fragCoord - world(mean_target())));\n\n    // expected source for each target (purple circles)\n    vec2 X0 = vec2(0);\n    for (int j=0 ; j<targets.length() ; ++j)\n    {\n        vec2 mean_x0 = texelFetch(iChannel2, ivec2(j+1,0), 0).zw;\n        blend(fragColor, vec4(0.5,0,1,1), 2. - abs(5. - length(fragCoord - world(mean_x0))));\n        X0 += mean_x0;\n    }\n    X0 /= float(targets.length());\n\n    // mean of expected sources, should be zero (orange circle)\n    blend(fragColor, vec4(1,.2,0,1), 2. - abs(5. - length(fragCoord - world(X0))));\n\n    // reverse tracks (green lines)\n    blend(fragColor, vec4(0,.2,0,1), 1. - tracks.y);\n\n    // reverse track heads (green dots)\n    for (int j=0 ; j<targets.length() ; ++j)\n    {\n        vec4 x = texelFetch(iChannel0, ivec2(j+1,0), 0);\n        //vec2 x0 = predict_x0(x, alpha, method);\n        //blend(fragColor, vec4(1,0,1,1), 1.5 - sdSegment(fragCoord, world(x.xy), world(x0)));\n        blend(fragColor, vec4(0,.5,0,1), 2.5 - length(fragCoord - world(x.xy)));\n    }\n\n    // targets (blue dots)\n    for (int i=0 ; i<targets.length() ; ++i)\n        blend(fragColor, vec4(0,.2,1,1), 3. - length(fragCoord - world(target(i))));\n\n    fragColor = sqrt(fragColor);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Each pixel is a particle, except (0, 0) which stores the simulation progress.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 index = ivec2(fragCoord);\n    vec4 x = rand(uvec4(iFrame * 0, fragCoord, 0));\n    vec4 n = boxMuller(x);\n\n    if (index == ivec2(0))\n        // (0, 0) simulation progress\n        fragColor = vec4(0, 0, 0, 0);\n    else if (index.y == 0)\n        // (x, 0) backward particles\n        fragColor = target(index.x - 1).xyxy;\n    else\n        // forward particles\n        fragColor = n.xyxy;\n\n    if (iFrame == 0 || iMouse.w > 0.)\n        return;\n\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    float da = 1. / float(nstep);\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (index == ivec2(0))\n    {\n        fragColor.x += 1.;\n    }\n    else if (index.y == 0)\n    {\n        fragColor = fragColor.xyxy;\n\n        float alpha = 1. - root.x / float(nstep);\n        if (alpha == 1.)\n            fragColor.xy = undo_last(fragColor.xy, da, method);\n        else if (alpha > 0.)\n            fragColor.xy -= da * tangent(fragColor.xy, alpha, method);\n    }\n    else// if (index.y < 100)\n    {\n        fragColor = fragColor.xyxy;\n        //fragColor.xy += n.xy * 0.01; return;\n\n        float alpha = root.x / float(nstep);\n        if (alpha < 1.)\n            fragColor.xy += da * tangent(fragColor.xy, alpha, method);\n     }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Particles tracks. (r: forward of (x, 1), g: backward)\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    resolution = iResolution;\n\n    fragColor = vec4(1);\n    if (iFrame == 0 || root.x == 0.)\n        return;\n\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    for (int i=0 ; i<int(iResolution.x) ; ++i)\n    {\n        vec4 n = texelFetch(iChannel0, ivec2(i, 1), 0);\n        vec2 a = world(n.xy);\n        vec2 b = world(n.zw);\n        fragColor.r = mix(fragColor.r, 0., 0.2 * clamp(1. - sdSegment(fragCoord, a, b), 0., 1.));\n    }\n    for (int i=0 ; i<targets.length() ; ++i)\n    {\n        vec4 n = texelFetch(iChannel0, ivec2(i+1, 0), 0);\n        vec2 a = world(n.xy);\n        vec2 b = world(n.zw);\n        fragColor.g = mix(fragColor.g, 0., 1. * clamp(1.5 - sdSegment(fragCoord, a, b), 0., 1.));\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float dot2(vec2 x) { return dot(x, x); }\n#define R(a) mat2(cos(a), sin(a), -sin(a), cos(a))\nconst float pi = radians(180.);\n\n/* configuration */\n\nconst int method = 0;  // 0: mix, 1: turn\nconst int nstep = 100; // deblending substeps\n\n/*\nUniform scaling only changes the intermediate trajectories\nand at which alpha the particles basically travel linearly\ntowards the targets!\nTranslation adds a constant velocity to the particles.\n*/\n// transform (skew, rotation, scale) applied to selected points\n#define T mat2(1,0,0,1)*R(0.)/1.\n\nconst vec2 radius = vec2(5);    // view paddng\nconst vec2 offset = vec2(0, 0); // translation of targets\n\n#if 1\n// explicit target datasets\nconst vec2 targets[] = vec2[](\n    //vec2(1, 0), vec2(0, 1)\n    //vec2(2, 0), vec2(0, 2)\n    //vec2(5, 0), vec2(0, 5)\n    //vec2(.5, -.5), vec2(-.5, .5)\n    T*vec2(5, 0), T*vec2(0, 5), T*vec2(-8, -3)//, T*vec2(-2, 0)\n    //T*vec2(-8, 0), T*vec2(3, 0), T*vec2(5, 0)\n    //vec2(0, -5), vec2(0, 2), vec2(0, 3)\n    //vec2(-5,0), vec2(-4,0), vec2(-3,-1), vec2(-2,0), vec2(-1,0), vec2(0), vec2(1,0), vec2(2,0), vec2(3,0), vec2(4,0), vec2(5,0)\n    //, vec2(0, 5)\n);\nvec2 target(int i) { return targets[i] + offset; }\n#else\n// procedural target dataset\nconst int H = 5;\nconst int W = 5;\nvec2 targets[H * W];\nvec2 target(int i) { return T*(vec2(i/W, i%W) - float(W/2)) + offset; }\n#endif\n\n/* iadb */\n\nvec2 tangent_mix(vec2 x, float alpha)\n{\n    // x = (1. - alpha) * x0 + alpha * x1\n    float ps = 0.;\n    vec2 t = vec2(0);\n    for (int i=0 ; i<targets.length() ; ++i)\n    {\n        vec2 x1 = target(i);\n        vec2 x0 = x1 - (x1 - x) / (1. - alpha);\n        float p = exp(-dot2(x0) / 2.);\n        t += p * (x1 - x0);\n        ps += p;\n    }\n    return t / ps;\n}\n\nvec2 tangent_turn(vec2 x, float alpha)\n{\n    // x = cos(alpha) * x0 + sin(alpha) * x1\n    alpha = pi / 2. * alpha;\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float ps = 0.;\n    vec2 t = vec2(0);\n    for (int i=0 ; i<targets.length() ; ++i)\n    {\n        vec2 x1 = target(i);\n        vec2 x0 = (x - s * x1) / c;\n        float p = exp(-dot2(x0) / 2.);\n        t += p * (-s * x0 + c * x1);\n        ps += p;\n    }\n    return pi / 2. * t / ps;\n}\n\nvec2 tangent(vec2 x, float alpha, int method)\n{\n    switch (method)\n    {\n    case 0: return tangent_mix(x, alpha);\n    case 1: return tangent_turn(x, alpha);\n    }\n}\n\nvec2 undo_last(vec2 x, float da, int method)\n{\n    switch (method)\n    {\n    case 0: return x * (1. - da);\n    case 1: return x;\n    }\n}\n\nvec2 predict_x1(vec4 x, float alpha, int method)\n{\n    switch (method)\n    {\n    case 0: return x.xy + (x.xy - x.zw) * (1. - alpha) * float(nstep);\n    case 1: return x.xy; // not implemented\n    }\n}\n\n/* setup */\n\nvec3 resolution;\nfloat f() { return resolution.y / (offset + 2. * radius + 2.).y; }\nvec2 world(vec2 x)\n{\n    return resolution.xy / 2. + f() * (x - offset / 2.);\n}\n\nvec3 hue(float x)\n{\n    return pow(cos(4. * pi / 3. * vec3(x, x-.5, x-1.)) / 2. + .5, vec3(2));\n}\n\nvec2 mean_target()\n{\n    float ps = float(targets.length());\n    vec2 x1 = vec2(0);\n    for (int i=0 ; i<targets.length() ; ++i)\n        x1 += target(i);\n    return x1 / ps;\n}\n\nvoid blend(inout vec4 fragColor, vec4 color, float f)\n{\n    fragColor = mix(fragColor, vec4(color.rgb, 1), color.a * clamp(f, 0., 1.));\n}\n\n/* random numbers */\n\nuvec4 pcg4d(uvec4 v)\n{\n    // https://www.shadertoy.com/view/XlGcRh\n    // http://www.jcgt.org/published/0009/03/02/\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    //v ^= v >> 16u;\n\n    return v;\n}\n\nvec4 rand(uvec4 x)\n{\n    return vec4(pcg4d(x)) / float(~0u);\n}\n\nvec4 boxMuller(vec4 x)\n{\n    vec2 a = 2. * pi * x.yw;\n    return sqrt(-2. * log(x.xz)).xxyy * vec4(cos(a), sin(a)).xzyw;\n}\n\n/* shapes */\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n", "buffer_c_code": "// Statistics.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 index = ivec2(fragCoord);\n    vec4 x = rand(uvec4(iFrame * 0, fragCoord, 0));\n    vec4 n = boxMuller(x);\n\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    float alpha = clamp(root.x / float(nstep), 0., 1.);\n    resolution = iResolution;\n\n    fragColor = vec4(0, -1, 0, 0);\n    if (iFrame == 0 || root.x == 0.)\n        return;\n\n    fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    if (index == ivec2(0))\n    // (0, 0)\n    {}\n    if (index.y == 0)\n    // (x, 0) expected source for each target -> .zw\n    {\n        if (index.x < targets.length()+1)\n        {\n            float total = 0.;\n            vec2 mean_x0 = vec2(0);\n            int k = 1;\n            for ( ; k<100 && k<int(iResolution.y) ; ++k)\n            for (int i=0 ; i<int(iResolution.x) ; ++i)\n            {\n                int closestTarget = int(texelFetch(iChannel2, ivec2(i,k), 0).x);\n                vec2 x0 = boxMuller(rand(uvec4(0, i,k, 0))).xy;\n                if (closestTarget == index.x-1)\n                {\n                    ++total;\n                    mean_x0 += x0;\n                }\n            }\n            mean_x0 /= total;\n            fragColor.zw = mean_x0;\n        }\n    }\n    else// if (index.y < 100)\n    // (x, y) when one-step predicting alpha=1, index of the closest target for each particle -> .x\n    {\n        vec2 x0 = boxMuller(rand(uvec4(0, index, 0))).xy;\n        vec4 x = texelFetch(iChannel0, index, 0).xyzw;\n        vec2 x1 = predict_x1(x, alpha, method);\n        int closestTarget = 0;\n        float r = length(x1 - target(0));\n        for (int j=1 ; j<targets.length() ; ++j)\n        {\n            float rj = length(x1 - target(j));\n            if (rj < r)\n                closestTarget = j, r = rj;\n        }\n        fragColor.x = float(closestTarget);\n    }\n\n    // draws index of predicted target at initial location of all particles -> .y\n    {\n        //int k = iFrame % (100-1) + 1;\n        int k = iFrame % (int(iResolution.y)-1) + 1;\n        for (int i=0 ; i<int(iResolution.x) ; ++i)\n        {\n            int closestTarget = int(texelFetch(iChannel2, ivec2(i,k), 0).x);\n            vec2 x0 = boxMuller(rand(uvec4(0, i,k, 0))).xy;\n            if (length(fragCoord - world(x0)) < 1.)\n                fragColor.y = float(closestTarget);\n        }\n    }\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 109, 109, 2763]], "test": "untested"}
{"id": "cddcWS", "name": "dsort", "author": "01000001", "description": "dumb method... fast ish but fails to converge and only works for uniform distribution\n", "tags": ["thing"], "likes": 1, "viewed": 43, "published": 3, "date": "1695410104", "time_retrieved": "2024-07-30T17:32:21.393697", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n\n    O = vec4(smoothstep(1./r.y, 0., abs(texture(iChannel0, vec2(uv.x, 0)).x-uv.y)));\n    \n    // Smoothstep is an intentional design choice to give randomized brightness to particles\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst int p = 5;\nvec3 nhash( uvec3 x ){\n    vec3 t = vec3(0);\n    for(int i = p; i-->0;){\n        t += hash(x + uvec3(i));\n    }\n    t /= float(p);\n    return t;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y < 1.){\n        vec2 r = iResolution.xy;\n        if (iFrame < 5){\n            O = vec4(0);\n            O.x = hash(uvec3(U.x, iDate.w, iDate.z)).x;\n        } else {\n            O = texture(iChannel0, U/iResolution.xy);\n         \n            // Single thread. Do whatever you want, then set c1 and c2\n            // Sort here\n            \n            // Do the square thingy that works fast\n            \n            int x = int(U.x);\n            int w = int(r.x);\n\n\n            vec3 h = hash(uvec3(iFrame, iTime, -iFrame));\n            int c = int(h.x * r.x);\n            \n            float t = texelFetch(iChannel0, ivec2(c, 0), 0).x\n                - float(c)/r.x;\n            int c2 = (c + \n                int(\n                    float(w>>1)*\n                        abs(t)\n                ) + iFrame%4\n            )%w;\n            \n\n            if (c2 < c){ c ^= c2; c2 ^= c; c^= c2; }// C2 always bigger\n            if (x==c){\n                float n = texelFetch(iChannel0, ivec2(c2, 0), 0).x;\n                if ( n < O.x) \n                    O.x = n;\n            }\n            \n            if (x==c2){\n                float n = texelFetch(iChannel0, ivec2(c, 0), 0).x;\n                if (n > O.x) \n                    O.x = n;\n            }\n        }\n    } else {\n        O = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddcWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 281]], "test": "untested"}
{"id": "Ds3yzl", "name": "rsort", "author": "01000001", "description": "compare random stuff and swap if the order check is correct", "tags": ["thing"], "likes": 1, "viewed": 39, "published": 3, "date": "1695409279", "time_retrieved": "2024-07-30T17:32:22.357121", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n\n    O = vec4(smoothstep(1./r.y, 0., abs(texture(iChannel0, vec2(uv.x, 0)).x-uv.y)));\n    \n    // Smoothstep is an intentional design choice to give randomized brightness to particles\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst int p = 5;\nvec3 nhash( uvec3 x ){\n    vec3 t = vec3(0);\n    for(int i = p; i-->0;){\n        t += hash(x + uvec3(i));\n    }\n    t /= float(p);\n    return t;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y < 1.){\n        vec2 r = iResolution.xy;\n        if (iFrame < 5){\n            O = vec4(0);\n            O.x = hash(uvec3(U.x, iDate.w, iDate.z)).x;\n        } else {\n            O = texture(iChannel0, U/iResolution.xy);\n         \n            // Single thread\n            // Sort here\n\n            vec3 h = hash(uvec3(iFrame, iTime, -iFrame));\n            int c = int(h.x * r.x);\n            int c2 = int(h.y * r.x);                        \n            if (c2 < c){ c ^= c2; c2 ^= c; c^= c2; }// C2 always bigger\n\n            int x = int(U.x);\n            if (x==c){\n                float n = texelFetch(iChannel0, ivec2(c2, 0), 0).x;\n                if ( n < O.x) O.x = n;\n            }\n            \n            if (x==c2){\n                float n = texelFetch(iChannel0, ivec2(c, 0), 0).x;\n                if (n > O.x) O.x = n;\n            }\n        }\n    } else {\n        O = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3yzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 281]], "test": "untested"}
{"id": "ds3yWS", "name": "nsort", "author": "01000001", "description": "neighbour check but with random sampling too. Massive speedup from pure random.", "tags": ["thing"], "likes": 1, "viewed": 41, "published": 3, "date": "1695409274", "time_retrieved": "2024-07-30T17:32:23.540956", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n\n    O = vec4(smoothstep(1./r.y, 0., abs(texture(iChannel0, vec2(uv.x, 0)).x-uv.y)));\n    \n    // Smoothstep is an intentional design choice to give randomized brightness to particles\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst int p = 5;\nvec3 nhash( uvec3 x ){\n    vec3 t = vec3(0);\n    for(int i = p; i-->0;){\n        t += hash(x + uvec3(i));\n    }\n    t /= float(p);\n    return t;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y < 1.){\n        vec2 r = iResolution.xy;\n        if (iFrame < 5){\n            O = vec4(0);\n            O.x = hash(uvec3(U.x, iDate.w, iDate.z)).x;\n        } else {\n            O = texture(iChannel0, U/iResolution.xy);\n         \n            // Single thread. Do whatever you want, then set c1 and c2\n            // Sort here\n            \n\n            vec3 h = hash(uvec3(iFrame, iTime, -iFrame));\n            int c = int(h.x * r.x);\n            \n            int c2 = (c+1)%int(r.x);                        \n            if (h.z > .5) c2 = int(h.y * r.x);\n            \n            \n            \n            // No coding after here if you're simulating single thread.\n            \n            \n            \n\n            if (c2 < c){ c ^= c2; c2 ^= c; c^= c2; }// C2 always bigger\n            int x = int(U.x);\n            if (x==c){\n                float n = texelFetch(iChannel0, ivec2(c2, 0), 0).x;\n                if ( n < O.x) O.x = n;\n            }\n            \n            if (x==c2){\n                float n = texelFetch(iChannel0, ivec2(c, 0), 0).x;\n                if (n > O.x) O.x = n;\n            }\n        }\n    } else {\n        O = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3yWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 281]], "test": "untested"}
{"id": "md3yDS", "name": "fsort", "author": "01000001", "description": "pretty fast", "tags": ["thing"], "likes": 1, "viewed": 36, "published": 3, "date": "1695409270", "time_retrieved": "2024-07-30T17:32:24.544274", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n\n    O = vec4(smoothstep(1./r.y, 0., abs(texture(iChannel0, vec2(uv.x, 0)).x-uv.y)));\n    \n    // Smoothstep is an intentional design choice to give randomized brightness to particles\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst int p = 5;\nvec3 nhash( uvec3 x ){\n    vec3 t = vec3(0);\n    for(int i = p; i-->0;){\n        t += hash(x + uvec3(i));\n    }\n    t /= float(p);\n    return t;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y < 1.){\n        vec2 r = iResolution.xy;\n        if (iFrame < 5){\n            O = vec4(0);\n            O.x = hash(uvec3(U.x, iDate.w, iDate.z)).x;\n        } else {\n            O = texture(iChannel0, U/iResolution.xy);\n         \n            // Single thread. Do whatever you want, then set c1 and c2\n            // Sort here\n            \n            \n            int x = int(U.x);\n            int w = int(r.x);\n\n\n            vec3 h = hash(uvec3(iFrame, iTime, -iFrame));\n            int c = int(h.x * r.x);\n            int c2 = (c + \n                int(\n                    float(w>>1)*\n                        (\n                            texelFetch(iChannel0, ivec2(c  , 0), 0).x\n                           -texelFetch(iChannel0, ivec2(c+1, 0), 0).x\n                        )\n                ) + iFrame%5 - 2\n            )%w;\n            \n\n            if (c2 < c){ c ^= c2; c2 ^= c; c^= c2; }// C2 always bigger\n            if (x==c){\n                float n = texelFetch(iChannel0, ivec2(c2, 0), 0).x;\n                if ( n < O.x) O.x = n;\n            }\n            \n            if (x==c2){\n                float n = texelFetch(iChannel0, ivec2(c, 0), 0).x;\n                if (n > O.x) O.x = n;\n            }\n        }\n    } else {\n        O = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3yDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 281]], "test": "untested"}
{"id": "DtlfDr", "name": "Reading a texture", "author": "janpitokiala", "description": "Now you can see what you sound like! Except you can't use videos in a sound shader.", "tags": ["sampling"], "likes": 0, "viewed": 100, "published": 3, "date": "1695383953", "time_retrieved": "2024-07-30T17:32:25.568535", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    ivec2 size = textureSize(iChannel0, 0);\n    return vec2(texelFetch(iChannel0, ivec2(samp%size.x, (samp/size.y)%size.y), 0).r);\n}", "sound_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "dl3XDS", "name": "OZORA FESTIVAL - SHIPPO PATTERN", "author": "POSTHELIOS", "description": "Certainly, let's go through this GLSL (OpenGL Shading Language) shader code.", "tags": ["fractal"], "likes": 17, "viewed": 596, "published": 3, "date": "1695379495", "time_retrieved": "2024-07-30T17:32:26.442199", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=iTime*6.5;\n        a=10.;\n        p=mod(p-a,a*2.)-a;\n        s=6.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*tan(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3XDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 859]], "test": "untested"}
{"id": "ms3czf", "name": "heptaplex-collapse noise", "author": "ENDESGA", "description": "stateless, seedless, magic-number-less\n\nusing bitwise operations to induce entropy via the not `~` operation, then invert-folding for maximum bitplane-chaos\n\nverified via: [url]https://www.shadertoy.com/view/Ddcyzs[/url]", "tags": ["noise", "random", "hash", "prng", "bitmagic", "hept", "hept32"], "likes": 7, "viewed": 307, "published": 3, "date": "1695334696", "time_retrieved": "2024-07-30T17:32:27.369719", "image_code": "// include a credit-comment if you use this:\n\n// @ENDESGA 2023\nuint noise(uint x, uint y, uint z) {\n    x = ~(~x - y - z) * ~(x - ~y - z) * ~(x - y - ~z);\n    y = ~(~x - y - z) * ~(x - ~y - z) * ~(x - y - ~z);\n    z = x ^ y ^ (~(~x - y - z) * ~(x - ~y - z) * ~(x - y - ~z));\n    return z ^ ~(~z >> 16);\n}\n\n///////\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n    i += iTime*100.;\n    o = vec4(\n        vec3(\n            noise(\n                uint(i.x),\n                uint(i.y),\n                uint(iTime)\n            )\n        )/float(0xffffffffu)\n        ,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3czf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 63, 99, 99, 304], [315, 315, 356, 356, 565]], "test": "untested"}
{"id": "Dd3czl", "name": "Grainy", "author": "nicone1", "description": "Visualize pseudo random of hash or something idk", "tags": ["hash"], "likes": 1, "viewed": 122, "published": 3, "date": "1695327015", "time_retrieved": "2024-07-30T17:32:28.293250", "image_code": "float hash(vec2 p)\n{\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 getBrush(\nvec2 uv, float xOffset, float yOffset, float xTurn, float yTurn, float intensity\n)\n{\n    vec2 gv = vec2(\n        uv.x + xOffset + hash(uv) * xTurn,\n        uv.y + yOffset + hash(uv) * yTurn\n    );\n    return vec3(intensity / length(gv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    col += getBrush(uv, 0.9, -0.2, -1.0, 1.0, 0.01) * vec3(1.0, 0.729, 0.471);\n    col += getBrush(uv, -0.5, -0.6, 1.8, 0.8, 0.04) * vec3(1.0, 0.471, 0.471) * hash(uv);\n    col += getBrush(uv, -0.2, 0.2, 0.0, 0.0, 0.05) * hash(uv) * 0.8;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3czl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 120], [122, 122, 221, 221, 376], [378, 378, 433, 433, 807]], "test": "untested"}
{"id": "mddyzj", "name": "Toroidal Coil", "author": "wyatt", "description": "Toroidal coil", "tags": ["sdf", "coil"], "likes": 17, "viewed": 468, "published": 3, "date": "1695325852", "time_retrieved": "2024-07-30T17:32:29.371367", "image_code": "float toroid (vec3 p, float r0, vec2 wh1, float r1) {\n    return roundbox(vec2(length(p.xy)-r0,p.z),wh1,r1);\n}\nvec3 normal_toroid(vec3 p,float r0, vec2 wh1, float r1) {\n    vec2 e = vec2(1e-5,0);\n    return normalize(vec3(\n        toroid(p+e.xyy,r0,wh1,r1)-toroid(p-e.xyy,r0,wh1,r1),\n        toroid(p+e.yxy,r0,wh1,r1)-toroid(p-e.yxy,r0,wh1,r1),\n        toroid(p+e.yyx,r0,wh1,r1)-toroid(p-e.yyx,r0,wh1,r1)\n    ));\n\n}\nfloat angleDiff(float a1, float a2) {\n    float diff = mod(a1 - a2, 2.0 * 3.14159265359);\n    return (diff > 3.14159265359) ? (diff - 2.0 * 3.14159265359) : diff;\n}\nfloat toroid_coil (vec3 p, float r0, vec2 wh1, float r1, float ta, float tb, float n, vec2 wh2, float r2) \n{\n    float b = wh2.x+r2;\nfloat a0 = atan(p.y,p.x);\n    float a1 = a0*n;\n    if (length(p.xy) == 0.) return p.z - wh1.y;\n    vec3 p0 = r0*vec3(cos(a0),sin(a0),0);\n    vec3 q = p-p0;\n    float a2 = atan(q.z,(dot(normalize(vec3(p.xy,0)),q)));\n    a0 += angleDiff (a2,a1)/n;\n    a1 = a0*n;\n    p0 = r0*vec3(cos(a0),sin(a0),0);\n    q = p-p0;\n    vec2 v = length(q)*vec2(cos(a1),sin(a1));\n    vec4 sq = squircle(v,wh1.x+b,wh1.y+b,r1+.5*b);\n    vec3 p1 = p0 + sq.z*vec3(normalize(p.xy),0) + abs(sq.w)*sin(a1)*vec3(0,0,1) ;\n\n    vec3 x = -sq.x*normalize(vec3(0,0,1))+sq.y*vec3(normalize(p.xy),0);\n    vec3 z = sq.y*normalize(vec3(0,0,1))+sq.x*vec3(normalize(p.xy),0);\n    vec3 y = cross(x,z);\n    vec2 u = vec2(\n        dot(p-p1,x),\n        dot(p-p1,y)\n    )*length(p1.xy)/r0;\n    return roundbox(u,wh2,r2);\n\n}\n\nfloat map (vec3 p, out vec3 q) {\n\n    float n = 3.+round(mod(iTime*123.,5.));\n    \n    float r0 = .6;\n    vec2 wh1 = vec2(.2,.5);\n    float r1 = .0;\n\n    vec2 wh2 = vec2(.1,.2);\n    float r2 = .01;\n    \n   float d = toroid_coil(p,r0,wh1,r1, 0.,360.,  n, wh2, r2);\n    float d1 = toroid(p,r0,wh1-.022,.5*r1);\n    q = (.5+max(sin(10.*iTime+vec3(3,2,1)),-.5));\n    float d2 = min(d,d1);\n    float d3 = abs(p.y+.7+.1*sin(.78*iTime)+.002*exp(-3.*d2)*sin(80.*(d2*exp(-.5*d2))))-.1;\n    if (d3 < d1 && d3 < d) {\n        q = vec3(.0);\n        return (d3);\n    }\n    if (d < d1) {\n        q *= 2.;\n        return d;\n    } \n    q = 1.-q;\n    return d1;\n    \n}\nfloat map (vec3 p) {\n    vec3 q ;\n    return map(p,q);\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-3,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n    ));\n}\nfloat smooth_map (vec3 p) {\n    return smoothstep(-.01,+.01,map(p));\n}\nvec3 grad (vec3 p) {\n    vec2 e = vec2(.005,0);\n    float o = smooth_map(p-e.xyy);\n    return vec3(\n        smooth_map(p+e.xyy)-o,\n        smooth_map(p+e.yxy)-o,\n        smooth_map(p+e.yyx)-o\n    )/e.x;\n}\n#define AA 1\nMain {\n    if ((iFrame)%160>0) discard;\n    Q = vec4(0);\n    for (int x = -AA; x <= AA; x++)\n    for (int y = -AA; y <= AA; y++) {\n    vec3 p = vec3(0,-.2,-1.5);\n    vec2 u = 2.*(U+.5*vec2(x,y)/float(AA*2-1)-.5*R)/R.y;\n    vec3 d = normalize(vec3(u,1));\n    float t = .4+.5*sin(2.*iTime);\n    p.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    \n    vec3 \n        p_refract = p, p_reflect = p,\n        d_refract = d, d_reflect = d,\n        q_reflect = vec3(0),\n        q_refract = vec3(0);\n    for (float i = min(iTime,0.0); i < 400.; i++) {\n        if( p_refract.x>1000.0 ) break;\n        vec3 q;\n        {\n            float m = min(abs(map(p_reflect,q)),1.);\n            m = .5*m;\n            if (m < .01) {\n                m = .002;\n                d_reflect = normalize(d_reflect+.001*grad(p_reflect));\n                q_reflect += .1*q;\n            }\n            p_reflect += m*d_reflect;\n        }\n        {\n            float m = min(abs(map(p_refract,q)),1.);\n            m = .5*m;\n            if (m < .01) {\n                d_refract = normalize(d_refract-.001*grad(p_refract));\n                q_refract += .01*q;\n                m = .003;\n            }\n            p_refract += m*d_refract;\n        }\n    }\n    Q += (.2*vec4(.6+.4*q_reflect,1)*texture(iChannel0,p_reflect)+\n        0.3*vec4(.3+.7*q_refract,1)*texture(iChannel0,p_refract))/float((AA*2+1)*(AA*2+1));\n    }\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\nfloat segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment(vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float line (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float smin( float a, float b, float k )\n        {\n            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n            return mix( b, a, h ) - k*h*(1.0-h);\n        }\n        float add (float a, float b) {\n            return min(a,b);\n        }\n\t\tfloat subtract(float a, float b) {\n\t\t    return max(a,-b+1e-6);\n\t\t}\n\t    float cylinder( vec3 p, vec2 h )\n\t\t{\n\t\t    h.y *= 0.5;\n\t\t    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat cylinder( vec3 p, float r, float h )\n\t\t{\n\t\t    return cylinder(p,vec2(r,h));\n\t\t}\n\t\tfloat sign_side (vec2 p1, vec2 p2, vec2 p3)\n        {\n            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n        }\n        float PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n        {\n            float d1, d2, d3;\n            bool has_neg, has_pos;\n        \n            d1 = sign_side(pt, v1, v2);\n            d2 = sign_side(pt, v2, v3);\n            d3 = sign_side(pt, v3, v1);\n        \n            has_neg = (d1 < 0.) || (d2 < 0.) || (d3 < 0.);\n            has_pos = (d1 > 0.) || (d2 > 0.) || (d3 > 0.);\n        \n            return float((has_neg && has_pos))*2.-1.;\n        }\n        float triangle (vec2 p, vec2 a, vec2 b, vec2 c) {\n            return PointInTriangle(p.xy,a,b,c)*min(segment(p,a,b),min(segment(p,b,c),segment(p,c,a)));\n        }\n        float triPrism(vec3 p, vec2 a, vec2 b, vec2 c, float h) {\n          vec2 d = vec2(triangle(p.xy,a,b,c),abs(p.z)-.5*h);\n          \n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\t\tfloat triPrism( vec3 p, vec2 h )\n        {\n          vec3 q = abs(p);\n          return max(q.z-.5*h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n        }\n        float segment ( vec3 p, vec3 a, vec3 b, float r )\n        {\n          vec3 pa = p - a, ba = b - a;\n          float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n          return length( pa - ba*h ) - r;\n        }\n\t\tfloat box(vec2 p, vec2 b) {\n\t\t\tvec2 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box( vec3 p, vec3 b )\n\t\t{\n\t\t    vec3 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box(vec3 p, float w, float h, float l) {return box(p,vec3(w,h,l));}\n\t\tfloat box(vec2 p, float w, float h) {return box(p,vec2(w,h));}\n\t\tfloat roundBox ( vec3 p, vec3 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return cylinder(p,vec2(r,b.z));\n\t\t}\n\t\tfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return length(p)-r;\n\t\t}\n\t\tfloat roundBox(vec3 p, float w, float h, float l, float r) {return roundBox(p,vec3(w,h,l),r);}\n\t\tfloat roundBox(vec2 p, float w, float h, float r) {return roundBox(p,vec2(w,h),r);}\n\t\t\n\t\t#define roundbox roundBox\n\t\t#define round_box roundBox\n        \n        \n        \n        float circle(float theta, vec2 u, float r) {\n            float b = -2.*u.x*cos(theta)-2.*u.y*sin(theta);\n            float c = u.x*u.x+u.y*u.y-r*r;\n            float det = b*b-4.*c;\n            if (det>=0.)\n                return  .5*(-b + sqrt(det));\n            else return 1e9;\n        }\n        vec3 circle3(float theta, vec2 u, float r) {\n            vec2 d = vec2(cos(theta),sin(theta));\n            float b = -2.*u.x*d.x-2.*u.y*d.y;\n            float c = u.x*u.x+u.y*u.y-r*r;\n            float det = b*b-4.*c;\n            if (det>=0.) {\n                float i = .5*(-b + sqrt(det));\n                vec2 v = normalize(d*i-u);\n                return vec3(-v.y,v.x,i);\n            }\n            else return vec3(0,0,1e9);\n        }\n        float line(float theta, float r, float a) {\n            return r/float(cos(a-theta));\n        } \n        #define pi 3.14159265359\n        float arctan(float y, float x) {\n            float a = atan(y,x);\n            if (a < 0.) a = 2.*pi+a;\n            return a;\n        }\n        vec4 squircle (vec2 p, float w, float h, float r) {\n            float theta = arctan(p.y,p.x);\n            h = max(h,1e-9), w = max(w,1e-9);\n            h *= .5; w *= .5;\n            h -= r; w-= r;\n            if (p.x>=w&&p.y>=h){\n                return vec4(normalize(vec2(-p.y+h,p.x-w)),vec2(w,h)+r*normalize(p-vec2(w,h)));\n            }\n            if (p.x<=-w&&p.y>=h) {\n                return vec4(normalize(vec2(-p.y+h,p.x+w)),vec2(-w,h)+r*normalize(p-vec2(-w,h)));\n            }\n            if (p.x<=-w&&p.y<=-h) {\n                return vec4(normalize(vec2(-p.y-h,p.x+w)),vec2(-w,-h)+r*normalize(p-vec2(-w,-h)));\n            }\n            if (p.x>=w&&p.y<-h) {\n                return vec4(normalize(vec2(-p.y-h,p.x-w)),vec2(w,-h)+r*normalize(p-vec2(w,-h)));\n            }\n            \n            vec2 i = vec2(max(w-h,0.),max(h-w,0.));\n            if (p.x>+i.x&&abs(p.x)-i.x>abs(p.y)-i.y) return vec4(0,1,w+r,p.y);\n            if (p.y>+i.y&&abs(p.x)-i.x<abs(p.y)-i.y) return vec4(-1,0,p.x,h+r);\n            if (p.x<-i.x&&abs(p.x)-i.x>abs(p.y)-i.y) return vec4(0,-1,-w-r,p.y);\n            if (p.y<-i.y&&abs(p.x)-i.x<abs(p.y)-i.y) return vec4(1,0,p.x,-h-r);\n            \n            \n        }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 110], [111, 111, 168, 168, 415], [416, 416, 453, 453, 580], [581, 581, 689, 689, 1491], [1493, 1493, 1525, 1525, 2142], [2143, 2143, 2163, 2163, 2199], [2200, 2200, 2222, 2222, 2390], [2391, 2391, 2418, 2418, 2461], [2462, 2462, 2482, 2482, 2666]], "test": "untested"}
{"id": "cdccRl", "name": "Oversaturated web", "author": "mrange", "description": "CC0: Oversaturated web\nBit of tinkering thursday night\nNot entirely happy with the colors but good enough for now\nThis a deriative of BigWing's: https://www.shadertoy.com/view/lscczl", "tags": ["planes", "web"], "likes": 32, "viewed": 903, "published": 3, "date": "1695324560", "time_retrieved": "2024-07-30T17:32:30.438514", "image_code": "// CC0: Oversaturated web\n//  Bit of tinkering thursday night\n//  Not entirely happy with the colors but good enough for now\n//  This a deriative of BigWing's: https://www.shadertoy.com/view/lscczl\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define ROT(a)     mat2(cos(a), sin(a), -sin(a), cos(a))\n#define OFF6(n)    (vec2(1.0, 0.0)*ROT(n*tau/6.))\n\n#define BEZIER\nconst float\n  pi        = acos(-1.)\n, tau       = 2.*pi\n, planeDist = .5\n, furthest  = 6.\n, fadeFrom  = 4.\n, cutOff    = .975\n;\nconst vec3  L  = \n  vec3(0.299, 0.587, 0.114)\n;\n\nconst vec2 \n  pathA = vec2(.31, .41)\n, pathB = vec2(sqrt(2.0), 1.0)\n;\n\nconst vec4 \n  U = vec4(0, 1, 2, 3)\n  ;\n  \nconst vec2 off6[6] = vec2[6](\n    OFF6(0.)\n  , OFF6(1.)\n  , OFF6(2.)\n  , OFF6(3.)\n  , OFF6(4.)\n  , OFF6(5.)\n  ); \n\nconst vec2 noff6[6] = vec2[6](\n    vec2(-1.0, 0.0)\n  , vec2(-0.5, 0.5)\n  , vec2( 0.5, 0.5)\n  , vec2( 1.0, 0.0)\n  , vec2( 0.5,-0.5)\n  , vec2(-0.5,-0.5)\n  ); \n\nvec3 offset(float z) {\n  return vec3(pathB*sin(pathA*z), z);\n}\n\nvec3 doffset(float z) {\n  return vec3(pathA*pathB*cos(pathA*z), 1.0);\n}\n\nvec3 ddoffset(float z) {\n  return vec3(-pathA*pathA*pathB*sin(pathA*z), 0.0);\n}\n\nfloat tanh_approx(float x) {\n  float x2 = x*x;\n  return clamp(x*(27. + x2)/(27.+9.*x2), -1., 1.);\n}\n\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  p = p.yx;\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  co += 1.234;\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec2 coff(float h) {\n  float h0 = h;\n  float h1 = fract(h0*9677.0);\n  float t = 0.75*mix(0.5, 1.0, h0*h0)*(TIME+1234.5);\n  return mix(0.1, 0.2, h1*h1)*sin(t*vec2(1.0, sqrt(0.5)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  // Based on: https://en.wikipedia.org/wiki/Alpha_compositing\n  return mix(back, front.xyz, front.w);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.-front.w))/w;\n  return w > 0. ? vec4(xyz, w) : vec4(0.);\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  vec2 p = (pp-off*U.yyx).xy;\n  vec2 p2 = p;\n  p2 *= ROT(tau*0.1*n+0.05*TIME);\n  p2 += + 0.125*(ro.z-pp.z)*vec2(1.0)*ROT(tau*hash(vec2(n)));\n  vec2 hp = p2;\n  hp += 0.5;\n  const float ga = 100.0;\n  const float z = 1.0/3.0;\n  hp /= z;\n  vec2 hn = hextile(hp);\n  \n  float h0 = hash(hn+n);\n  vec2 p0 = coff(h0);\n  \n  vec3 bcol = 0.5*(1.0+cos(vec3(0.0, 1.0, 2.0) + 2.0*(p2.x*p2.y+p2.x)-+0.33*n)); \n  vec3 col = vec3(0.0);\n  \n  for (int i = 0; i < 6; ++i) {\n    float h1 = hash(hn+noff6[i]+n);\n    vec2 p1 = off6[i]+coff(h1);\n    \n    float h2 = h0+h1;\n    float fade = smoothstep(1.05, 0.85, distance(p0, p1)); \n\n    if (fade < 0.0125) continue;\n\n#ifdef BEZIER\n    vec2 p2 = 0.5*(p1+p0)+coff(h2);\n    float dd = bezier(hp, p0, p2, p1);\n#else\n    float dd = segment(hp, p0, p1);\n#endif\n    float gd = abs(dd);\n    gd *= sqrt(gd);\n    gd = max(gd, 0.0005);\n\n    col += fade*0.002*bcol/(gd);\n  }\n\n  {  \n    float cd = length(hp-p0);\n    float gd = abs(cd);\n    gd *= (gd);\n    gd = max(gd, 0.0005);\n    col += 0.0025*sqrt(bcol)/(gd);\n  }\n  \n  {\n    float hd = hexagon(hp, 0.485);\n    float gd = abs(hd);\n    gd = max(gd, 0.005);\n    col += 0.0005*bcol*bcol/(gd);\n  }\n  \n  float l = dot(col, L);  \n\n  return vec4(col, tanh_approx(sqrt(l)+dot(p, p)));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1./RESOLUTION.xy;\n  float rdd = 2.0;\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  float nz = floor(ro.z / planeDist);\n\n  vec4 acol = vec4(0);\n  bool cutOut = false;\n\n  vec3 skyCol = vec3(0.0);\n\n  float maxpd = 0.;\n\n  for (float i = 1.; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*i;\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0. && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      maxpd = pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+i);\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*furthest, planeDist*fadeFrom, nz);\n      float fadeOut = smoothstep(0., planeDist*.1, nz);\n      pcol.w *= fadeOut*fadeIn;\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1. : acol.w;\n      break;\n    }\n\n  }\n\n  return alphaBlend(skyCol, acol);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 r = RESOLUTION.xy, q = fragCoord/r.xy, pp = -1.0+2.0*q, p = pp;\n  p.x *= r.x/r.y;\n\n  float tdist = length(pp);\n  float tm  = 0.2*planeDist*TIME+0.1*tdist;\n\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(U.xyx+ddro, ww));\n  vec3 vv = cross(ww, uu);\n  vec3 col = color(ww, uu, vv, ro, p);\n  col -= 0.02*U.zwx*(length(pp)+0.125);\n  col *= smoothstep(1.5, 1.0, length(pp));\n  col *= smoothstep(0.0, 10.0, TIME-2.0*(q.x-q.x*q.y));\n  col = aces_approx(col);\n  col = sqrt(col);\n  fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": 34748, "src": "https://soundcloud.com/dom-in-ator/carbon-based-lifeforms-7?in=dom-in-ator/sets/carbon-based-lifeforms-world-of-sleepers-2015-remastered&si=4152c69d0d2f484fbd2267c97cc26775&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdccRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[944, 944, 966, 966, 1006], [1008, 1008, 1031, 1031, 1079], [1081, 1081, 1105, 1105, 1160], [1162, 1162, 1190, 1190, 1261], [1264, 1365, 1393, 1492, 1819], [1821, 1939, 1971, 1971, 2169], [2171, 2231, 2252, 2252, 2337], [2339, 2339, 2359, 2359, 2381], [2383, 2501, 2541, 2541, 2660], [2662, 2780, 2828, 2828, 3866], [3868, 3868, 3888, 3888, 4049], [4051, 4158, 4184, 4184, 4368], [4370, 4370, 4410, 4473, 4515], [4517, 4517, 4557, 4557, 4712], [4714, 4714, 4782, 4782, 6027], [6029, 6029, 6085, 6085, 7136], [7138, 7138, 7194, 7194, 7793]], "test": "untested"}
{"id": "mdcczX", "name": "Blinking Cat", "author": "Lewie4", "description": "A blinking cat made with sdfs", "tags": ["loop", "cat", "silhouette"], "likes": 11, "viewed": 152, "published": 3, "date": "1695292544", "time_retrieved": "2024-07-30T17:32:31.184520", "image_code": "// SDFs: https://iquilezles.org/articles/distfunctions2d/\n\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    return vec2(cos(rotation) * (uv.x) + sin(rotation) * (uv.y),\n                    cos(rotation) * (uv.y) - sin(rotation) * (uv.x));\n}\n\nfloat sdCircle(vec2 uv, float r)\n{\n    return (length(uv) - r);\n}\n\nfloat sdVesica(vec2 uv, float r, float d)\n{\n    uv = abs(uv);\n    float b = sqrt(r*r-d*d);\n    return (((uv.y-b)*d>uv.x*b) ? length(uv-vec2(0.0,b))\n                             : length(uv-vec2(-d,0.0))-r);\n}\n\nfloat sdEquilateralTriangle(vec2 uv, float r)\n{\n    const float k = sqrt(3.0);\n    uv.x = abs(uv.x) - r;\n    uv.y = uv.y + r/k;\n    if(uv.x+k*uv.y>0.0 ) uv = vec2(uv.x-k*uv.y,-k*uv.x-uv.y)/2.0;\n    uv.x -= clamp(uv.x, -2.0*r, 0.0 );\n    return -length(uv)*sign(uv.y);\n}\n\nfloat sdSegment(vec2 uv, vec2 a, vec2 b)\n{\n    vec2 pa = uv-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage(out vec4 Out, in vec2 UV)\n{\n    UV = (UV+UV-iResolution.xy)/iResolution.y;\n    Out -= Out;\n\n    // Face\n    float cat =0.;\n    float temp = sdCircle(UV, .46);                               // Face\n\n    temp = min(temp,sdCircle(UV+vec2(.25,.14),.28));              // Left Cheek\n    temp = min(temp,sdCircle(UV+vec2(.23,.1),.3));                // Left Cheek Top\n    \n    temp = min(temp,sdCircle(UV+vec2(-.25,.14),.28));             // Right Cheek\n    temp = min(temp,sdCircle(UV+vec2(-.23,.1),.3));               // Right Cheek Top\n    \n    temp = min(temp,sdCircle(UV+vec2(0,.31),.2));                        // Chin\n    temp = min(temp,sdCircle((UV+vec2(0,.225))*vec2(1,2),.5));           // Chin+\n    \n    temp = min(temp,sdVesica(rotateUV(UV+vec2(.27,-.19), 0.38), .7, .5));     // Left Ear\n    temp = min(temp,sdVesica(UV+vec2(.39,-.085), .6,.5));                     // Left Ear Bottom    \n    \n    temp = min(temp,sdVesica(rotateUV(UV+vec2(-.27,-.19), -0.38), .7, .5));   // Right Ear\n    temp = min(temp,sdVesica(UV+vec2(-.39,-.085), .6,.5));                    // Right Ear Bottom  \n    \n    temp = smoothstep(0.,.005,temp);\n    cat = 1. - temp;\n\n    //Eyes\n    temp = sdVesica(rotateUV(UV+vec2(.21,.045), 0.95), 0.15, .07 +.1 * smoothstep(0.,1.,sin((iTime)*1.5)*3.-2.));\n    temp = min(temp, sdVesica(rotateUV(UV+vec2(-.21,.045), -0.95), 0.15, .07 +.1 * smoothstep(0.,1.,sin(iTime*1.5)*3.-2.)));\n\n    //Nose\n    temp = min(temp, sdEquilateralTriangle(rotateUV(UV+vec2(0,.25),3.14), 0.02)-.03);\n    temp = smoothstep(0.,.01, temp);\n    cat = min(cat, temp);\n\n    // Whiskers\n    temp = sdSegment(UV, vec2(.2,-.25), vec2 (.6,-.16));\n    temp = min(temp, sdSegment(UV, vec2(.22,-.275), vec2 (.58,-.26)));\n    temp = min(temp, sdSegment(UV, vec2(.2,-.3), vec2 (.56,-.36)));\n    temp = min(temp,sdSegment(UV, vec2(-.2,-.25), vec2 (-.6,-.16)));\n    temp = min(temp, sdSegment(UV, vec2(-.22,-.275), vec2 (-.58,-.26)));\n    temp = min(temp, sdSegment(UV, vec2(-.2,-.3), vec2 (-.56,-.36)));\n    temp = smoothstep(0.,.007,temp);\n    cat = abs(cat - temp);\n    \n    Out = mix(vec4(.212,.114,.196,1.), vec4(.945,0.910,0.902,1.), cat);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 99, 99, 236], [238, 238, 272, 272, 303], [305, 305, 348, 348, 513], [515, 515, 562, 562, 784], [786, 786, 828, 828, 948], [950, 950, 992, 992, 3100]], "test": "untested"}
{"id": "dd3yzX", "name": "Metallic Flowers", "author": "dr2", "description": "Just some old flowers... (mouse rotates, zooms)", "tags": ["flower"], "likes": 14, "viewed": 251, "published": 3, "date": "1695289791", "time_retrieved": "2024-07-30T17:32:31.983384", "image_code": "// \"Metallic Flowers\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (flowers from \"Losing Focus\")\n\n#define AA  1   // (= 0/1) optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, gLim, szFac, rotAng, rotAngF, dTwist, vuAz;\nint nFrame, idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (nFrame, 0)\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a, r, h, sk;\n  dMin = dstFar / szFac;\n  p.xz -= HexToPix (gId);\n  p.xz = Rot2D (p.xz, rotAngF);\n  p.z -= 0.1;\n  p /= szFac;\n  q = p;\n  h = 1.5;\n  d = 0.8 * max (length (Rot2D (q.xz - vec2 (0., 0.07), 4. * pi * dTwist * q.y / h) -\n     vec2 (0., 0.03)) - (0.06 - 0.015 * q.y / h + 0.005 * sin (4. * pi * q.y)), abs (q.y - h) - h);\n  DMINQ (1);\n  qq = p;\n  qq.xz = Rot2D (qq.xz, rotAng);\n  qq.y -= 3.1;\n  qq.yz = Rot2D (qq.yz, 0.3 * pi + 0.1 * rotAng);\n  q = qq;\n  r = length (q.xz);\n  d = max (r - 0.25, abs (q.y) - 0.1 * (1. - 1.5 * r));\n  DMINQ (2);\n  d = length (q - vec3 (0., clamp (q.y, -0.2, 0.), 0.)) - 0.15;\n  DMINQ (3);\n  sk = 1.;\n  for (int k = 0; k < 2; k ++) {\n    q = qq;\n    q.xz = Rot2D (q.xz, sk * pi / 12.);\n    a = atan (q.z, - q.x);\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * a / (2. * pi) + 0.5) / 6.));\n    q.x += 0.2;\n    q.y -= 0.01 * sk + 0.4 * dot (q.xz, q.xz);\n    sk = - sk;\n    q.z *= 2.5;\n    d = 0.5 * max (length (q.xz + vec2 (0.4, 0.)) - 0.5, abs (q.y) - 0.03 * (1.2 - length (q.xz)));\n    DMINQ (4);\n  }\n  q = qq;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (12. * ((r > 0.) ? atan (q.z, - q.x) /\n     (2. * pi) : 0.) + 0.5) / 12.));\n  q.y -= 0.15;\n  q.x = abs (q.x + 0.04 + 0.4 * q.y * (1. + 2. * q.y)) - 0.02;\n  d = 0.8 * PrCylDf (q.xzy, 0.003, 0.17);\n  DMINQ (5);\n  return szFac * dMin;\n}\n\nvoid SetFlwConf ()\n{\n  float s;\n  s = length (vec3 (gId.xy, gId.x + gId.y)) / gLim;\n  szFac = 0.65 * (1. - 0.2 * s * s + 0.2 * (Hashfv2 (17. * gId + 99.) - 0.5));\n  s = Hashfv2 (23. * gId + 99.) - 0.5;\n  dTwist = sign (s);\n  s = max (0.1, abs (s)) * dTwist;\n  rotAngF = 0.2 * pi * s;\n  rotAng = vuAz + 0.3 * pi * (sin (pi * s * (tCur + 10.)) + s) - rotAngF;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 1e-4;\n  if (rd.z == 0.) rd.z = 1e-4;\n  eps = 1e-3;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2]));\n  dHit = 0.;\n  gId = PixToHex (ro.xz);\n  pM = HexToPix (gId);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SetFlwConf ();\n      cNu = false;\n    }\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= gLim) d = ObjDf (ro + dHit * rd);\n    else d = dstFar;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      gId = PixToHex (ro.xz + dHit * rd.xz);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz);\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= gLim) {\n      if (gId != gIdP) {\n        gIdP = gId;\n        SetFlwConf ();\n      }\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n      d += h;\n    } else d += 0.2;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd, a;\n  a = atan (rd.z, - rd.x) / (2. * pi) + 0.5;\n  if (rd.y > -0.02 && rd.y < 0.04 * mix (Fbm1 (128. * (a + 1.)), Fbm1 (128. * a), a)) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return 0.8 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, r, a, sh, hue, glit;\n  bool isBg;\n  gLim = 20.;\n  isBg = true;\n  glit = 0.;\n  vf = vec2 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz);\n    vn = ObjNf (ro);\n    hue = Hashfv2 (gId * vec2 (17., 27.) + 0.5);\n    if (idObj >= 2) {\n      r = length (qHit.xz);\n      a = (r > 0.) ? atan (qHit.z, - qHit.x) / (2. * pi) : 0.;\n    }\n    if (idObj == 1) {\n      col4 = vec4 (0.7, 0.4, 0., 0.1);\n      vf = vec2 (64., 2.);\n    } else if (idObj == 2) {\n      col4 = vec4 (HsvToRgb (vec3 (fract (hue + 0.6), 1., 0.7)) *\n         (0.7 + 0.3 * SmoothBump (0.2, 0.8, 0.005, fract (32. * r + a))), 0.1);\n      vf = vec2 (32., 1.);\n    } else if (idObj == 3) {\n      col4 = vec4 (HsvToRgb (vec3 (fract (hue + 0.1), 0.7, 1.)) *\n         (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, fract (8. * a))), 0.1);\n      vf = vec2 (64., 1.);\n    } else if (idObj == 4) {\n      col4 = vec4 (HsvToRgb (vec3 (fract (hue), 0.7 + 0.3 * fract (7. * hue), 1.)), 0.05);\n      col4.rgb *= 1. - 0.1 * SmoothBump (0.05, 0.95, 0.01, fract (16. * a));\n      glit = 512. * step (0.01, max (0., dot (vn, sunDir))) *\n         pow (max (0., dot (sunDir, reflect (rd, vn))), 16.) *\n         pow (1. - 0.6 * abs (dot (normalize (sunDir - rd), VaryNf (1024. * ro, vn, 2.))), 8.);\n      vf = vec2 (128., 0.1);\n    } else if (idObj == 5) {\n      col4 = vec4 (mix (vec3 (0.9, 0.9, 0.2), vec3 (1., 0.1, 0.1), step (0.16, qHit.y)),\n         0.1 - step (0.16, qHit.y));\n    }\n  } else if (rd.y < 0.) {\n    isBg = false;\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    col4 = 0.9 * mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.),\n       smoothstep (0.2, 0.8, Fbm2 (0.5 * ro.xz)));\n    gId = PixToHex (ro.xz);\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= gLim) col4 *= 0.7 +\n       0.3 * smoothstep (0.1, 0.2, length (ro.xz - vec2 (0., 0.1) - HexToPix (gId)));\n    qHit = ro;\n    vn = vec3 (0., 1., 0.);\n    vf = vec2 (1., (1. - smoothstep (0.4, 0.7, dstObj / dstFar)));\n  }\n  if (! isBg) {\n    if (vf.y > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       step (0.95, sh) * (glit + col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n    if (dstObj >= dstFar) col = mix (col, 0.8 * vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr, zmFac;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  zmFac = 4.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    zmFac += 3. * abs (az);\n    el += pi * mPtr.y;\n  } else {\n    az += 0.7 * pi * sin (0.005 * pi * tCur);\n    el += 0.02 * pi * sin (0.021 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.02 * pi);\n  vuAz = az;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -40.);\n  sunDir = vuMat * normalize (vec3 (0.7, 1.5, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.2 * pi * cos (0.03 * pi * tCur));\n  dstFar = 80.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1. / sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (mod (p + vec2 (0., 1.), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3yzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[821, 821, 843, 843, 2197], [2199, 2199, 2219, 2219, 2558], [2560, 2560, 2593, 2593, 3792], [3794, 3794, 3815, 3815, 4070], [4072, 4072, 4109, 4109, 4582], [4584, 4584, 4618, 4618, 5447], [5449, 5449, 5484, 5484, 8036], [8038, 8038, 8091, 8091, 9325], [9327, 9327, 9369, 9369, 9420], [9422, 9422, 9444, 9444, 9482], [9484, 9484, 9508, 9508, 9740], [9742, 9742, 9766, 9766, 9826], [9828, 9828, 9852, 9852, 9969], [9971, 9971, 10007, 10007, 10213], [10215, 10215, 10245, 10245, 10358], [10360, 10360, 10417, 10417, 10500], [10534, 10534, 10558, 10558, 10633], [10635, 10635, 10659, 10659, 10727], [10729, 10729, 10753, 10753, 10880], [10882, 10882, 10907, 10907, 11053], [11055, 11055, 11080, 11080, 11264], [11266, 11266, 11288, 11288, 11442], [11444, 11444, 11465, 11465, 11620], [11622, 11622, 11651, 11651, 11863], [11865, 11865, 11904, 11904, 12156]], "test": "untested"}
{"id": "cs3czf", "name": "Translucent Noisy Blob", "author": "alphardex", "description": "A translucent noisy blob, but maybe the lighting is a bit off and don't know why.", "tags": ["raymarching"], "likes": 14, "viewed": 481, "published": 3, "date": "1695286611", "time_retrieved": "2024-07-30T17:32:32.870013", "image_code": "const float PI=3.14159265359;\n\nconst float TWO_PI=6.28318530718;\n\nmat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nmat4 rotation3d(vec3 axis,float angle){\n    axis=normalize(axis);\n    float s=sin(angle);\n    float c=cos(angle);\n    float oc=1.-c;\n    \n    return mat4(\n        oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.,\n        oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,0.,\n        oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,0.,\n        0.,0.,0.,1.\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nvec3 rotate(vec3 v,vec3 axis,float angle){\n    return(rotation3d(axis,angle)*vec4(v,1.)).xyz;\n}\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159-.85373472095314*r;\n}\n\nvec3 fade(vec3 t){\n    return t*t*t*(t*(t*6.-15.)+10.);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0=floor(P);// Integer part for indexing\n    vec3 Pi1=Pi0+vec3(1.);// Integer part + 1\n    Pi0=mod289(Pi0);\n    Pi1=mod289(Pi1);\n    vec3 Pf0=fract(P);// Fractional part for interpolation\n    vec3 Pf1=Pf0-vec3(1.);// Fractional part - 1.0\n    vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);\n    vec4 iy=vec4(Pi0.yy,Pi1.yy);\n    vec4 iz0=Pi0.zzzz;\n    vec4 iz1=Pi1.zzzz;\n    \n    vec4 ixy=permute(permute(ix)+iy);\n    vec4 ixy0=permute(ixy+iz0);\n    vec4 ixy1=permute(ixy+iz1);\n    \n    vec4 gx0=ixy0*(1./7.);\n    vec4 gy0=fract(floor(gx0)*(1./7.))-.5;\n    gx0=fract(gx0);\n    vec4 gz0=vec4(.5)-abs(gx0)-abs(gy0);\n    vec4 sz0=step(gz0,vec4(0.));\n    gx0-=sz0*(step(0.,gx0)-.5);\n    gy0-=sz0*(step(0.,gy0)-.5);\n    \n    vec4 gx1=ixy1*(1./7.);\n    vec4 gy1=fract(floor(gx1)*(1./7.))-.5;\n    gx1=fract(gx1);\n    vec4 gz1=vec4(.5)-abs(gx1)-abs(gy1);\n    vec4 sz1=step(gz1,vec4(0.));\n    gx1-=sz1*(step(0.,gx1)-.5);\n    gy1-=sz1*(step(0.,gy1)-.5);\n    \n    vec3 g000=vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100=vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010=vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110=vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001=vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101=vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011=vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111=vec3(gx1.w,gy1.w,gz1.w);\n    \n    vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\n    g000*=norm0.x;\n    g010*=norm0.y;\n    g100*=norm0.z;\n    g110*=norm0.w;\n    vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\n    g001*=norm1.x;\n    g011*=norm1.y;\n    g101*=norm1.z;\n    g111*=norm1.w;\n    \n    float n000=dot(g000,Pf0);\n    float n100=dot(g100,vec3(Pf1.x,Pf0.yz));\n    float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));\n    float n110=dot(g110,vec3(Pf1.xy,Pf0.z));\n    float n001=dot(g001,vec3(Pf0.xy,Pf1.z));\n    float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));\n    float n011=dot(g011,vec3(Pf0.x,Pf1.yz));\n    float n111=dot(g111,Pf1);\n    \n    vec3 fade_xyz=fade(Pf0);\n    vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\n    vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);\n    float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);\n    return 2.2*n_xyz;\n}\n\nfloat pow5(const in float v){\n    float v2=v*v;\n    return v2*v2*v;\n}\n\nvec3 schlick(const in vec3 f0,const in float f90,const in float VoH){\n    float f=pow5(1.-VoH);\n    return f+f0*(f90-f);\n}\n\nvec3 fresnel(vec3 f0,vec3 normal,vec3 view){\n    return schlick(f0,1.,dot(view,normal));\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nvec3 distort(vec3 p){\n    float frequency=1.7;\n    float offset=cnoise(p/frequency+iTime*.5);\n    float t=(p.y+offset)*PI*12.;\n    float noise=(sin(t)*p.x+cos(t)*p.z)*2.;\n    p+=noise*.01;\n    return p;\n}\n\nvec2 map(vec3 p){\n    p-=vec3(0.,0.,-2.);\n    \n    // orbit\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    p.yz=rotate(p.yz,-mouse.y*PI+1.);\n    p.xz=rotate(p.xz,-mouse.x*TWO_PI);\n    \n    p=distort(p);\n    \n    vec2 d=vec2(1e10,0.);\n    float d1=sdSphere(p,1.5);\n    d=opUnion(d,vec2(d1,2.));\n    return d*.5;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h=.0001;\n    const vec2 k=vec2(1,-1);\n    return normalize(k.xyy*map(p+k.xyy*h).x+\n    k.yyx*map(p+k.yyx*h).x+\n    k.yxy*map(p+k.yxy*h).x+\n    k.xxx*map(p+k.xxx*h).x);\n}\n\nvec3 render(vec2 uv){\n    vec3 col=vec3(0.);\n    \n    uv=(uv-.5)*2.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(0.,0.,1.);\n    vec3 rd=normalize(vec3(uv,0.)-ro);\n    \n    float depth=0.;\n    for(int i=0;i<64;i++){\n        vec3 p=ro+rd*depth;\n        vec2 t=map(p);\n        float d=t.x;\n        float m=t.y;\n        depth+=d;\n        \n        if(d<.01){\n            // col=vec3(1.);\n            vec3 normal=calcNormal(p);\n            // col=normal;\n            \n            // fresnel\n            vec3 viewDir=normalize(ro-p);\n            col=fresnel(vec3(0.),normal,viewDir);\n            \n            break;\n        }\n    }\n    \n    return col;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 col=render(uv);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=2.;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs3czf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 95, 95, 200], [202, 202, 241, 241, 634], [636, 636, 668, 668, 702], [704, 704, 746, 746, 799], [1246, 1246, 1267, 1267, 1307], [1309, 1309, 1330, 1330, 1370], [1372, 1372, 1394, 1394, 1431], [1433, 1433, 1461, 1461, 1510], [1512, 1512, 1530, 1530, 1569], [1571, 1595, 1617, 1617, 3806], [4003, 4003, 4047, 4047, 4093], [4095, 4095, 4127, 4127, 4153], [4155, 4155, 4189, 4189, 4214], [4216, 4216, 4247, 4247, 4278], [4280, 4280, 4301, 4301, 4484], [4486, 4486, 4503, 4503, 4796], [4798, 4798, 4826, 4826, 5012], [5014, 5014, 5035, 5035, 5678], [5680, 5680, 5715, 5715, 5796], [5798, 5798, 5851, 5851, 6176]], "test": "untested"}
{"id": "DdcyRf", "name": "Exponential Colormap", "author": "beans_please", "description": "See the Desmos graphs, play with v", "tags": ["colormap", "exponential"], "likes": 4, "viewed": 172, "published": 3, "date": "1695281747", "time_retrieved": "2024-07-30T17:32:33.708770", "image_code": "// https://www.desmos.com/calculator/n4mfhffj1n\nfloat f(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\nvec3 colormap(float x)\n{\n    //float t = .1 * iTime;\n    //float t = .75 - 1.1 * x;\n    //float t = .25 * x;\n    float t = .6 + .8 * x;\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 10. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(-.04, 1., x);\n    vec3 c = vec3(\n        f(x, tone.r),\n        f(x, tone.g),\n        f(x, tone.b)\n    );\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = colormap(uv.x);\n    col = pow(col, vec3(.45));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdcyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 48, 75, 75, 184], [186, 186, 210, 294, 654], [656, 656, 713, 713, 848]], "test": "untested"}
{"id": "ds3cDn", "name": "Shock Propagation ala Erleben", "author": "fenix", "description": "15k particles behaving like rigid bodies. The stability depends on a technique inspired by the \"shock propagation\" idea of Professor Kenny Erleben.\n\n*shift to render velocities*\n*alt to render local wall velocity field*\n*space to reset*", "tags": ["2d", "voronoi", "collision", "simulation", "particles", "dynamics", "tracking", "physics"], "likes": 48, "viewed": 480, "published": 3, "date": "1695274069", "time_retrieved": "2024-07-30T17:32:34.919533", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by Kenny Erleben's 2007 paper \"Velocity-Based Shock Propagation for Multibody\n//  Dynamics Animation\"\n//\n//      https://dl.acm.org/doi/10.1145/1243980.1243986\n//\n//  This is definitely only inspired by the original shock propagation idea. As described\n//  in the paper, the way I understand it, it would fit into an traditional iterative\n//  solver, freezing objects sequentially as you get farther from a boundary. But to use\n//  this idea in a shader, I have to manage with a single iteration.\n//\n//  So, the way it works is that each particle keeps track of a \"shock direction\" that\n//  tells it the direction to the nearest wall. Green is to the right, blue to the left,\n//  and red is supported from below. The shock direction is seeded from the walls and\n//  diffuses through the particles. Particles resist collision impules and position\n//  correction against their shock direction. That's where the stability comes from:\n//  particles \"below\" other particles are heavier. When particles get compressed in\n//  an area, they are able to flow along the shock directions to a clear space.\n//\n//  I claim this is at least conceptually similar to the original shock propagation idea.\n//  In both cases, we're giving solver priority to objects closer to the ground. Maybe\n//  there's a better name for this method, but until I find one I'll keep comparing it to\n//  Erleben's shock propagation. :) I've used a more primitive method for stability in\n//  some shaders already, like\n//\n//      Candy Avalanche                https://shadertoy.com/view/dlfSz4\n//\n//  In that shader, solver priority is determined entirely by particle height. This works\n//  for that application, but it creates artifacts when you try to use it for a bunch of\n//  particles resting in a container with walls on all sides; the particles can end up\n//  pushing each other up the walls. With the shock directions, the particles near the\n//  side walls can resist motions towards the walls instead of only downwards. The\n//  smoothness of the shock direction field can then prevent artifacts.\n//\n//  An additional hack is needed to handle the moving boundary. The \"local wall velocity\"\n//  is also seeded at wall collisions and diffused through the particles. This prevents\n//  us from relying on collisions only to move around the particles in the bucket and in\n//  front of the bulldozer wall. Hold down the alt key to see the wall velocities.\n//\n//      *shift to render velocities*\n//      *alt to render local wall velocity field*\n//      *space to reset*\n//\n//  Buffer A, B, and C perform particle simulation. Only A updates the particle neighbors.\n//  Buffer D computes screen-space voronoi for render.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(fxParticle v, vec2 p, uint id, inout vec4 O)\n{\n    float e = 2. / R.y;\n    float d = fxLinePointDist(v.pos, v.pos - v.vel, p);\n    \n    vec3 color = v.sd == vec2(0) ? vec3(1, 0, 0) : sin(atan(abs(v.sd.y * .1), v.sd.x) + vec3(0, 11, 33));\n    color *= (id % 2U == 0U) ? .7 : 1.;\n    color = mix(color, vec3(1), .3);\n    if (keyDown(KEY_ALT))\n        color = 5000. * length(v.wv) * sin(atan(v.wv.y, abs(v.wv.x)) + vec3(0, 11, 33));\n    if (keyDown(KEY_SHIFT))\n        color = pow(abs(v.vel.yxx) * 1e3, vec3(.3));\n    O.xyz = mix(O.rgb, color, smoothstep(PARTICLE_SIZE + e, PARTICLE_SIZE - e, d));\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    vec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 old = fxGetClosest(ivec2(u));\n    fxState s = fxGetState();\n    O = vec4(.2);\n\n    // render particles\n    for (int i = 0; i < 4; ++i)\n    {\n        uint id = old[i];\n        if (id == -1U || id >= g_MaxParticles) break;\n        fxParticle v = fxGetParticle(id);\n        renderParticle(v, p, id, O);\n    }\n    \n    float d = sdScene(p, R, s.t);\n    \n    O = mix(O, vec4(1), smoothstep(0., -1. / R.y, d));\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, 0.);\n    else\n        O = voronoiParticle(p, id, dataType);\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, DT / 3.);\n    else\n        O = fxSaveParticle(p, dataType); // skip voronoi update on buffers B and C (only one is needed)\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const uint IDEAL_MAX_PARTICLES = 15000U;\nconst float PARTICLE_SIZE = .003;\nconst float PI = 3.141592653589793;\nconst float DT = .0002; // bucket animation increment (t cycles from 0 to 1)\n\n// If not applied carefully, the shock direction can create the a situation where\n// the particles get shoved towards the center of a container. This hack biases\n// the shock direction towards vertical, ensuring we get smaller green and blue\n// areas and more red, and preventing particles from being shoved towards the center.\nconst vec2 SHOCK_BIAS = vec2(1, 1.1);\n\n#define R iResolution.xy\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float res;  // tracks resolution changes\n    float t;    // animation time\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nfxState fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    \n    fxState s;\n    s.res = data.x;\n    s.t = data.y;\n    \n    return s;\n}\n\nvec4 fxPutState(fxState s)\n{\n    return vec4(s.res, s.t, 0, 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0);\n}\n\n//returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define SDAV 5U\n#define NUM_PARTICLE_DATA_TYPES 6U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(R.x), X, Y)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec2 pos;     // position\n    vec2 vel;     // velocity\n    vec2 sd;      // shock direction\n    vec2 wv;      // local wall velocity\n    \n    uvec4 nbs[4]; // neighbors\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, SDAV), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = floatBitsToUint(particleData0);\n    particle.nbs[1] = floatBitsToUint(particleData1);\n    particle.nbs[2] = floatBitsToUint(particleData2);\n    particle.nbs[3] = floatBitsToUint(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.sd = particleData5.xy;\n    particle.wv = particleData5.zw;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, p.vel);\n    case SDAV:  \n        return vec4(p.sd, p.wv);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n// UTILITIES\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\n\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// the animation of the buckets\nvec2 path(float t)\n{\n    // piecewise, linear for beginning and end\n    if (t < .25) return vec2(.5, -3. * t + .65);\n    if (t > .5) return vec2(1.6 - 3. * t, -.4);\n    \n    // bezier to turn the corner smoothly\n    t *= 4.;\n    t -= 1.;\n    vec2 a = vec2(.5, t * -.2 - .1);\n    vec2 b = vec2(.5 - .4 * t, -.4);\n    return mix(a, b, t);\n}\n\n// signed distance field of one bucket\nfloat sdBucket(vec2 p, float t)\n{\n    vec2 cp = path(t); // bucket location\n    \n    float r = max(0., t - .35); // rotation angle\n    r = -4. * sqrt(r);\n    \n    const float theta = 2.0;\n    const vec2 sc = vec2(sin(theta), cos(theta));\n    return sdArc((p * vec2(1, -1) - cp) * rot2(r), sc, 0.2, 0.01);\n}\n\nconst float BULLDOZER_HEIGHT = .25;\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res, float t)\n{\n    // walls and floor\n    float d = p.x + .5 * res.x / res.y;\n    d = min(d, .5 * res.x / res.y - p.x);\n    d = min(d, p.y + .5);\n    \n    // square leaky bucket\n    d = min(d, sdBox(p - vec2(-.75, -.05), vec2(.01,  .1 )));\n    d = min(d, sdBox(p - vec2(-.45, -.05), vec2(.01,  .1 )));\n    d = min(d, sdBox(p - vec2(-.685, -.15), vec2(.075, .01)));\n    d = min(d, sdBox(p - vec2(-.515, -.15), vec2(.075, .01)));\n    \n    // slanted walls\n    d = min(d, sdBox((p - vec2(-.28,  .03)) * rot2(-.8), vec2(.2, .01)));\n    d = min(d, sdBox((p - vec2( .05, -.05)) * rot2(.8), vec2(.2, .01)));\n    \n    // moving buckets\n    float t2 = fract(t + .5);\n    d = min(d, min(sdBucket(p, t), sdBucket(p, t2)));\n    \n    // bulldozer walls\n    float t3 = fract(t + .9);\n    float t4 = fract(t + .4);\n    d = min(d, sdBox(p - vec2(-1. + t3 * 1.8, min(-.5, 1.05 - 2. * t3)), vec2(.01, BULLDOZER_HEIGHT)));\n    d = min(d, sdBox(p - vec2(-1. + t4 * 1.8, min(-.5, 1.05 - 2. * t4)), vec2(.01, BULLDOZER_HEIGHT)));\n \n    return d;\n}\n\n// the outward normal of the scene at a point\nvec2 normScene( vec2 p, vec2 res, float t )\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res, t); \n    float x0 = sdScene(p - d.xy, res, t); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res, t); \n    float y0 = sdScene(p - d.yx, res, t); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// the velocity of the scene at a point\nvec2 velScene(vec2 p, float t)\n{\n    // bucket 1\n    if (sdBucket(p, t) < .01)\n        return (path(t) - path(t + DT / 3.)) * vec2(-1, 1);\n\n    // bucket 2\n    float t2 = fract(t + .5);\n    if(sdBucket(p, t2) < .01)\n        return (path(t2) - path(t2 + DT / 3.)) * vec2(-1, 1);\n        \n    // bulldozer walls\n    float t3 = fract(t + .9);\n    float t4 = fract(t + .4);\n    if (sdBox(p - vec2(-0.995 + t3 * 1.8, -.5), vec2(.02, BULLDOZER_HEIGHT)) < 0. ||\n        sdBox(p - vec2(-0.995 + t4 * 1.8, -.5), vec2(.02, BULLDOZER_HEIGHT)) < 0.)\n        return vec2(7e-5, 0);\n        \n    return vec2(0);\n}\n\n// PARTICLE SIM\n\nconst vec2 GRAVITY = vec2(0., -.00001);\nconst float COLLISION_STIFFNESS = .3;\nconst float BOUNDARY_ELASTICITY = 1.5;\nconst float BOUNDARY_DIST = PARTICLE_SIZE;\nconst float MAX_SPEED = PARTICLE_SIZE * .5;\n\n#define updateParticle(A, B, C, D, E) updateParticleImpl(A, B, C, D, E, iFrame, R, iChannel0, iMouse)\nvec4 updateParticleImpl(fxState s, fxParticle p, uint id, uint dataType, float toff, int iFrame, vec2 res, sampler2D par, vec4 iMouse)\n{\n    if (iFrame == 0 || s.res < 0.)\n    {\n        // init particles\n        vec3 h1 = hash3((id + uvec3(iFrame)) * uvec3(3, 6, 9));\n        //h1.x = pow(h1.x, 1.3);\n        h1 -= .5;\n        h1.y = h1.y * .3 - .2;\n        h1.x *= res.x / res.y;\n\n        p.pos = h1.xy;\n        p.vel = vec2(0);\n        p.sd = vec2(0, 1);\n        p.wv = vec2(0);\n    }\n    else\n    {\n        p.vel = p.vel + GRAVITY; // integrate velocity\n        \n        if (length(p.vel) > MAX_SPEED)\n            p.vel = normalize(p.vel) * MAX_SPEED; // clamp velocity\n\n        p.pos += p.vel; // integrate position\n        p.sd *= .5; // dissipate shock direction\n\n        vec2 imp = vec2(0); // collision impulse\n        vec2 nsd = p.sd; // new support direction\n        vec2 wv = p.wv; // wall velocity\n        float nt = 1.01; // wall velocity normalization factor (above one to create damping)\n        bool col = false; // was there a collision\n        for(int i = 0; i < 4; i++)\n        {\n            uvec4 nbs = p.nbs[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                uint cid = nbs[j];\n                if(cid==id || cid == -1U || cid >= g_MaxParticles) continue;\n\n                fxParticle n = fxGetParticleImpl(par, uint(res.x), cid);\n\n                vec2 dp = p.pos - n.pos;\n                float d2 = length2(dp) + PARTICLE_SIZE * 1e-4;\n\n                if (d2 < sqr(PARTICLE_SIZE * 5.))\n                {\n                    vec2 dir = dp / sqrt(d2);\n                    \n                    nsd += n.sd; // diffuse shock direction\n                    \n                    float wv2 = length2(n.wv);\n                    if (wv2 > 1e-12)\n                    {\n                        float x = max(0., dot(n.wv / sqrt(wv2), dir) + .3);\n                        nt += x;    // normalization\n                        wv += n.wv * x;  // diffuse wall velocity\n                    }\n                    \n                    if (d2 < sqr(PARTICLE_SIZE * 2.))\n                    {\n                        col = true;\n                        \n                        // position correction (ignore if shock direction disagrees)\n                        if (dot(p.sd, dir) > -.2)\n                            p.pos = mix(p.pos, n.pos + 2. * PARTICLE_SIZE * dir, COLLISION_STIFFNESS);\n                        \n                        // collision impulse\n                        vec2 rv = n.vel - p.vel;\n                        imp += max(0., dot(rv, dir)) * dir;\n                    }\n                }\n            }\n        }\n\n        float sd2 = length2(nsd);\n        if (sd2 > 1e-9)\n            p.sd = mix(p.sd, nsd * SHOCK_BIAS / sqrt(sd2), .9); // record new shock direction\n\n        p.wv = wv / nt; // record new local wall velocity\n        \n        if (dot(p.sd, imp) < -.2) // resist impulses against the shock direction\n            imp *= .5;\n\n        p.vel += imp; // apply collision impulse\n        \n        // handle mouse input\n        if (iMouse.z > 0.)\n        {\n            vec2 m = (iMouse.xy - .5 * res) / res.y;\n            const float MOUSE_RANGE = .05;\n            if (distance(m, p.pos) < MOUSE_RANGE)\n            {\n                const float MOUSE_STRENGTH = .01;\n                p.vel += (p.pos - m) * MOUSE_STRENGTH;\n            }\n        }\n\n        // handle boundary\n        float ds = sdScene(p.pos, res, s.t + toff);\n        if (ds < BOUNDARY_DIST * 2.)\n        {\n            vec2 n = normScene(p.pos, res, s.t + toff);\n            p.sd = n; // seed shock direction\n            p.wv = velScene(p.pos, s.t + toff); // seed wall velocity\n            \n            if (ds < BOUNDARY_DIST) // collide with boundary\n            {\n                p.pos -= n * (ds - BOUNDARY_DIST);\n                p.vel -= BOUNDARY_ELASTICITY * min(0., dot(p.vel, n)) * n;\n                col = true;\n            }            \n        }\n        \n        if (col) p.pos += p.wv; // travel with local wall velocity if we collided with anything\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id == -1U || id >= g_MaxParticles ||\n      \tid == currentId ||\n        any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C) voronoiParticleImpl(iChannel0, iChannel1, R, iFrame, A, B, C)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, int iFrame, fxParticle p, uint id, uint dataType)\n{\n    uvec4 closest = fxGetClosestImpl(vor, ivec2(p.pos * res.y + .5 * res));\n    uvec4 bestIds = uvec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    for (int i = 0; i < 4; ++i)\n    {\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n        sort0(par, uint(res.x), bestIds, bestDists, id, closest[i], dataType, p.pos);\n    }\n\n    uint searchIterations = 4U;\n    for(uint k = 0U; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash3(uvec3(id + k, id * k, k * uint(iFrame))).x;\n        //pick random id of particle\n        uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n        sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n", "buffer_c_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, 2. * DT / 3.);\n    else\n        O = fxSaveParticle(p, dataType); // skip voronoi update on buffers B and C (only one is needed)\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(vec2 u);\nvec4 updateState(fxState s);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(s);\n    else\n        O = voronoiScreen(u);\n}\n\nvec4 updateState(fxState s)\n{\n    if (iFrame == 0 || R.x * R.y != abs(s.res) || keyDown(KEY_SPACE))\n    {\n        s.res = -R.x * R.y;\n        s.t = 0.;\n    }\n    else\n    {\n        s.res = abs(s.res);\n        s.t = fract(s.t + DT);\n    }\n\n    return fxPutState(s);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u), length2(v.pos - v.vel - u));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\nvec4 voronoiScreen(vec2 u)\n{\n\tvec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        int SEARCH_STEPS = int(2e4 / R.y);\n        const float SEARCH_RANGE = 20.;\n\n        for(int i = 0; i < SEARCH_STEPS; ++i)\n        {\n            vec2 h = hash3(uvec3(u, iFrame * 4 + i)).xy - .5;\n\n            sortNbs(fxGetClosest(ivec2(u + vec2(h * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        float h = hash3(uvec3(u, iFrame)).x;\n        uint id = uint(h*float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3cDn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3004, 3004, 3070, 3070, 3620], [3622, 3622, 3658, 3658, 4138]], "test": "untested"}
{"id": "cd3cRX", "name": "_sun_", "author": "lilak", "description": "I think 1/x looks like the sun", "tags": ["simple"], "likes": 3, "viewed": 131, "published": 3, "date": "1695267563", "time_retrieved": "2024-07-30T17:32:35.740339", "image_code": "// sun or 1/x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 10.;\n    vec2 center = iResolution.xy/2.;\n    \n    vec3 col = size * vec3(1. / length(fragCoord - center));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd3cRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 14, 71, 71, 230]], "test": "untested"}
{"id": "Dd3yRX", "name": "Quaternion Julia Density", "author": "wyatt", "description": "what a beautiful thing! ", "tags": ["fractal"], "likes": 15, "viewed": 233, "published": 3, "date": "1695265901", "time_retrieved": "2024-07-30T17:32:36.499310", "image_code": "\nMain {\n    Q = vec4(1.,.7,1.1,1)*A(U)/float(iFrame);\n    \n    Q *= 1.+6.*fwidth(length(Q));\n    Q = pow(max(Q,0.),vec4(1.25));\n    if (length(Q.xyz)>0.) \n    Q.xyz = normalize(Q.xyz) * .8*atan(2.4*length(Q)); else Q = vec4(0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U) \n#define A(U) texture(iChannel0,(U)/R)\nvec4 mul (vec4 a, vec4 b) {\n    \n    // (a + bi + cj + dk) * (e + f*i + g*j + h*k)\n    \n    return vec4 (\n        \n        a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w  ,\n    \n        a.x*b.y + b.x*a.y + a.z*b.w - a.w*b.z  ,\n        \n        a.x*b.w + b.x*a.z + a.w*b.y - b.w*a.y  ,\n       \n        a.x*b.z + b.x*a.w + a.y*b.z - b.y*a.z\n    \n    ); \n    \n\n}\nvec4 fractal (vec4 u) {\n    vec4 c = vec4(0);\n    vec4 q = u;\n    for (float i = 0.; i < 120.; i++) {\n        u = mul(u,u) - vec4(.8,.15,0,.0);\n        if (length(u) < 20.) \n            c += 2.*max(sin(sqrt(1.+i*10.)+vec4(1,2,3,4)),0.)*exp(-300.*dot(u,u));\n        else break;\n    }\n    return 7.*(c);\n\n}\n", "buffer_a_code": "\n\nMain {\n    Q = A(U);\n    U = 2.*(U+vec2(sin(422.*iTime),sin(1453.*iTime))-.5*R)/R.y;\n    vec3 p = vec3(0,0,-2.8);\n    vec3 d = normalize(vec3(U,3));\n    float t = .3;\n    p.x -= .1;\n    p.xy *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.xy *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    t = .2;\n    p.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    \n    p += d*(2.9+.7*(fract(.5+float(iFrame)/500.))*2.-1.);\n    Q += fractal(vec4(p,0));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3yRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdtcR2", "name": "modified fractal", "author": "pwf", "description": "from https://www.shadertoy.com/view/mtyGWy\n\nwith iMouse.x thrown in there so I can smuggle audio reactivity in", "tags": ["fractal"], "likes": 1, "viewed": 104, "published": 3, "date": "1695262122", "time_retrieved": "2024-07-30T17:32:37.369981", "image_code": "/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*iMouse.x + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 394, 419, 419, 603], [605, 645, 702, 702, 1193]], "test": "untested"}
{"id": "dsccRj", "name": "Scotopic approx.", "author": "FordPerfect", "description": "Approximations for luminous efficiency function for scotopic (i.e. produced by rod cells, under low-light conditions) vision.", "tags": ["spectrum", "wavelength", "cie", "scotopic"], "likes": 4, "viewed": 253, "published": 3, "date": "1695229646", "time_retrieved": "2024-07-30T17:32:38.266584", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Couple of functions related to scotopic vision\n// (see https://en.wikipedia.org/wiki/Scotopic_vision).\n// Unlike color matching functions for photopic vision\n// (e.g. https://www.shadertoy.com/view/msXyDH),\n// there doesn't seem to be many readily available\n// on Shadertoy, as of this writing.\n\n// The provided functions are:\n//   wavelength2scotopic - for when you have spectral data.\n//   xyz2scotopic - for when you don't, and have to make do with XYZ/RGB.\n\n// WARNING: the actual displayed image is highly fake, due to liberties\n// taken. The functions themselves should be decent enough, though.\n\n//==============================================================================\n// RGB<->XYZ conversions, from https://en.wikipedia.org/wiki/SRGB\n// Operate on linear RGB.\n\nvec3 xyz2rgb(vec3 xyz)\n{\n    return mat3( // WARNING: column-major.\n        +3.2404542, -0.9692660, +0.0556434,\n        -1.5371385, +1.8760108, -0.2040259,\n        -0.4985314, +0.0415560, +1.0572252)*xyz;\n}\n\nvec3 rgb2xyz(vec3 rgb)\n{\n    return mat3( // WARNING: column-major.\n        0.4124, 0.2126, 0.0193,\n        0.3576, 0.7152, 0.1192,\n        0.1805, 0.0722, 0.9505)*rgb;\n}\n\n//==============================================================================\n// sRGB<->linear conversions, from https://en.wikipedia.org/wiki/SRGB\n// NOTE: in floating point (1.055-1.0)!=0.055, but whatever.\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvec3 srgb2linear(vec3 rgb)\n{\n    return mix(rgb/12.92,pow((rgb+0.055)/1.055,vec3(2.4)),step(0.04045,rgb));\n}\n\n//==============================================================================\n// Approximation of scotopic luminous efficiency function,\n// CIE (1951) Scotopic V'(lambda) (see http://www.cvrl.org/lumindex.htm)\n// Input is in nanometers.\n// Max. abs. error: ~0.043.\n\nfloat wavelength2scotopic(float lambda)\n{\n    float t=lambda-507.0;\n    //t*=mix(0.01692040668,0.01919261909,step(0.0,t)); // <-- old version, error ~0.061.\n    t*=mix(0.01650,0.01919,step(0.0,t));\n    return exp(-t*t);\n}\n\n//==============================================================================\n// Scotopic luminous flux approximation from XYZ,\n// see http://integral.physics.muni.cz/rawtran/.\n\nfloat xyz2scotopic(vec3 xyz) {return max(0.0,dot(xyz,vec3(-0.80498,1.18214,0.36169)));}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 rgb=texture(iChannel0,uv).rgb;\n    \n    rgb=srgb2linear(rgb); // Do we need this?\n    vec3 xyz=rgb2xyz(rgb);\n    float v=xyz2scotopic(xyz);\n    float a=0.25*iTime;\n    // Mesopic weighting factor. In reality it depends\n    // on luminance (possibly both global and local) of the scene.\n    float t=smoothstep(0.0,1.0,0.5+dot(2.0*uv-1.0,vec2(cos(a),sin(a))));\n    // NOTE: the \"night color\" below, assigned to\n    // the scotopic component is chosen pretty arbitrarily.\n    // Charitably put, it tries to approximate\n    // the Purkinje effect (https://en.wikipedia.org/wiki/Purkinje_effect),\n    // but really, it is just a random fake, chosen to look okay-ish.\n    // Better designed models of Purkinje effect do exist, though.\n    // This also doesn't deal with the *rest* of the\n    // tone-mapping, at all.\n    vec3 night=vec3(0.375,0.75,1.0);\n    rgb=mix(v*night,rgb,t);\n    rgb=linear2srgb(rgb); // Shadertoy seems to treat output as sRGB.\n    if(false) // Render plot.\n    {\n        float lambda=mix(350.0,750.0,uv.x);\n        float d=wavelength2scotopic(lambda)-2.0*uv.y;\n        rgb+=exp(-1e5*d*d);\n    }\n    fragColor=vec4(rgb,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsccRj.jpg", "access": "api", "license": "public-domain", "functions": [[848, 848, 872, 872, 1054], [1056, 1056, 1080, 1080, 1226], [1441, 1441, 1469, 1469, 1553], [1555, 1555, 1583, 1583, 1663], [1934, 1934, 1975, 1975, 2155], [2338, 2338, 2368, 2368, 2425], [2509, 2509, 2563, 2563, 3755]], "test": "untested"}
{"id": "Ds3yz2", "name": "sleepee", "author": "suttree", "description": "wandering", "tags": ["prototype"], "likes": 0, "viewed": 310, "published": 3, "date": "1695224667", "time_retrieved": "2024-07-30T17:32:44.050121", "image_code": "#define PI 3.14159265359\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 palette( in float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 1.0);\n    vec3 d = vec3(0.50, 0.20, 0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 1.-fract(Hash21(vec2(1., 2.5)));\n    \n    vec2 gv = uv;\n    gv *= fract(gv)*.3;\n    \n    float t = iTime*.05*(Hash21(vec2(.3, 2.7)));\n    gv *= Rot(t);\n    \n    float d = length(uv) * .5-length(uv); // change colour and pattern\n    d = length(uv) * 1.-fract(abs(gv.x * gv.y*450.));\n    vec3 col = palette(d);\n    \n    float rays = fract(gv.x * gv.y*150.);\n    rays = 1.*cos(abs(gv.x * gv.y*250.));\n    col += smoothstep(.2, .8, rays);\n    \n    // Time varying pixel color\n    col += 0.25 + 1.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3yz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 107], [109, 109, 131, 131, 225], [227, 227, 255, 255, 438], [440, 440, 497, 497, 1153]], "test": "untested"}
{"id": "dddyRB", "name": "Weird eclipse", "author": "Razakhel", "description": "Unvoluntary \"eclipse\" shader. Change the VERSION definition by any one defined at the top of the file for different results", "tags": ["sphere", "glow"], "likes": 3, "viewed": 47, "published": 3, "date": "1695215443", "time_retrieved": "2024-07-30T17:32:45.416468", "image_code": "#define ROTATING_EDGE 0\n#define SIDEWAYS      1\n\n#define VERSION ROTATING_EDGE\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 normalizedUv = (fragCoord / iResolution.xy);\n    vec2 centeredUv   = normalizedUv * 2.0 - 1.0;\n    centeredUv.x     *= iResolution.x / iResolution.y;\n    \n    float sphereDist = abs(dot(centeredUv, centeredUv) - 0.5);\n#if VERSION == ROTATING_EDGE\n    sphereDist      += abs(centeredUv.x + sin(iTime) * 0.7); // Comment to get a horizontal line going up & down\n    sphereDist      += abs(centeredUv.y + cos(iTime) * 0.7); // Comment to get a vertical line going sideways\n    // Comment both to get a glowing circle\n#elif VERSION == SIDEWAYS\n    sphereDist      += (sin(centeredUv.x) * cos(centeredUv.y) * sin(iTime)) * 0.75 + 0.5;\n#endif\n    sphereDist       = 0.05 / sphereDist; // Fake bloom\n#if VERSION == ROTATING_EDGE\n    sphereDist       = log(sphereDist) * 0.15 + 0.5; // Smoothing the image's lighting\n#endif\n    \n    vec3 color = vec3(sphereDist);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 135, 135, 1037]], "test": "untested"}
{"id": "msdcRS", "name": "X's and O's", "author": "Lewie4", "description": "Looping checkerboard motion", "tags": ["glow", "loop"], "likes": 3, "viewed": 116, "published": 3, "date": "1695210462", "time_retrieved": "2024-07-30T17:32:46.473642", "image_code": "#define scale 5.\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    u = u/iResolution.y;\n    O -= O;\n\n    u *= scale;\n    \n    vec2 grid = mod(floor(u),2.);\n    u.x += (smoothstep(0.,1.,min(mod(iTime,6.),1.)) + smoothstep(0.,1.,max(min(mod(iTime,6.)-3.,1.),0.))) *((grid.y * 2.) - 1.);\n    u.y += (smoothstep(0.,1.,max(min(mod(iTime,6.)-1.5,1.),0.)) + smoothstep(0.,1.,max(min(mod(iTime,6.)-4.5,1.),0.))) *((grid.x * 2.) - 1.);\n    \n    vec2 suv = (fract(abs(u))-.5)*2.;\n    \n    float o = abs(length(suv)-.5);\n    o = smoothstep(.05, 0., o) + smoothstep(.15, -.15, o);\n    \n    float x = distance(abs(suv.x), abs(suv.y));    \n    x = smoothstep(.06, 0., x) + smoothstep(.15, -.15, x);\n    x *= smoothstep(0.,.2,clamp(1.-length(suv),0.,1.));\n    \n    vec2 guv= abs(mod(floor(u), 2.));\n    float cb = mod(guv.x+guv.y,2.);    \n    \n    vec4 col = cos(iTime + vec4(0.,1.,2.,0.)) + 1.;\n    \n    O = mix(o,x,cb) * col * 2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 57, 57, 914]], "test": "untested"}
{"id": "mdfyWB", "name": "Test: Ray marching (Mitsync)", "author": "Mitsync", "description": "Ray marching test. The entire scene is defined in `float sdf()`. Closer objects are brighter, ", "tags": ["test", "ray", "marching"], "likes": 1, "viewed": 164, "published": 3, "date": "1695202322", "time_retrieved": "2024-07-30T17:32:47.352292", "image_code": "// MitSync, 2023\n\n#define M_PI 3.1415926535897932384626433832795\n\n#define MARCH_THRESH 0.0001\n#define ITERATIONS 250\n#define REFLECTIONS 3\n#define FOV 0.8\n#define NORMAL_H 0.05\n\nconst vec3 camera_pos = vec3(2.5, 0.0, 0.0);\nconst vec3 camera_dir = vec3(-1.0, 0.0, 0.0);\nconst vec4 amb_light = vec4(0.500,0.500,0.500,1.0);\nconst vec4 sky_color = vec4(0.639,0.682,1.000,1.0);\n\n// Planes are defined in a vec4 as the coefficients abcd in (a*x + b*y + c*z - d = DISTANCE)\nconst vec4[] planes = vec4[]                       (vec4(1.0, 0.0, 0.0, -3.0), vec4(1.0, 0.0, 0.0, 3.0));\n// Spheres are defined in a vec4 as their center position and radius\nconst vec4[] spheres = vec4[]                      (vec4(0.0, 0.0, 0.0, 1.00), vec4(0.0, 1.0, 1.0, 0.5), vec4(0.0, -1.0, 1.0, 0.5),\n                                                    vec4(-1.0, -1.0, -1.0, 0.5), vec4(1.0, 1.0, -1.0, 0.5));\n\n// Colors are defined per primitive (same index) as a vec4 where xyz = albedo and w = specular\nconst vec4[] planes_color = vec4[planes.length()]  (vec4(1.000,1.000,1.000,1.0), vec4(1.000,1.000,1.000,1.0));\nconst vec4[] spheres_color = vec4[spheres.length()](vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.5, 1.0),\n                                                    vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.5, 1.0));\n\nstruct MarchReturn {\n    vec3 pos;\n    vec3 norm;\n    vec3 albedo;\n    float specular;\n};\n\nvec4 col4(in float f) {\n    return vec4(f, f, f, 1.0);\n}\n\nfloat sdf_sphere(in vec3 pos, in vec4 sphere) {\n    return length(pos-sphere.xyz)-sphere.w;\n}\nfloat sdf_plane(in vec3 pos, in vec4 plane) {\n    return abs(dot(pos, plane.xyz)-plane.w);\n}\n// SDF is generated from lists of primitives\nfloat sdf(in vec3 pos) {\n    float d = 9999.;\n    // Loop over all spheres in scene\n    for (int i = 0; i < spheres.length(); i++) {\n        d = min(d, sdf_sphere(pos, spheres[i]));\n    }\n    // Loop over all planes in scene\n    for (int i = 0; i < planes.length(); i++) {\n        d = min(d, sdf_plane(pos, planes[i]));\n    }\n    return d;\n}\n\n// Normal function of scene, computed by derivative of SDF\nvec3 normal(in vec3 pos) {\n    vec3 norm;\n    norm.x = sdf(pos + vec3(NORMAL_H, 0.0, 0.0));\n    norm.y = sdf(pos + vec3(0.0, NORMAL_H, 0.0));\n    norm.z = sdf(pos + vec3(0.0, 0.0, NORMAL_H));\n    return normalize(norm);\n}\n\n// Color function of scene, alpha is shininess\nvec4 color(in vec3 pos) {\n    // If we ask the color of air, return a hot magenta to indicate something went wrong\n    if (sdf(pos) > MARCH_THRESH) return vec4(1.0, 0.0, 1.0, 0.0);\n    \n    for (int i = 0; i < spheres.length(); i++) {\n        if (sdf_sphere(pos, spheres[i]) <= MARCH_THRESH) return spheres_color[i];\n    }\n    // Loop over all planes in scene\n    for (int i = 0; i < planes.length(); i++) {\n        if (sdf_plane(pos, planes[i]) <= MARCH_THRESH) return planes_color[i];\n    }\n    \n    //vec4 col = pos.y > 0. ? vec4(0.5, 0.5, 0.0, 1.0) : vec4(0.0, 0.5, 0.5, 1.0);\n    //vec4 col = vec4(abs(pos/2.), 1.0);\n    vec4 col = vec4(normal(pos), 1.0);\n    //vec4 col = vec4(0.5, 0.5, 0.5, 0.3);\n    \n    // Everything further than the camera is a shiny checkerboarded mirror\n    //vec4 mirror = vec4(vec3(mod(floor(pos.y)+floor(pos.z), 2.0) == 1. ? 1.0 : 0.5), 1.0);\n    vec4 mirror = vec2(0.5, 1.0).xxxy;\n    return (abs(pos.x) > camera_pos.x) ? mirror : col;\n}\n\nvec4 raycast(in vec3 pos, in vec3 dir) {\n    // Total distance of ray, set to 0.0 if we didn't hit anything.\n    float total_distance = 0.0;\n    float d = 0.0;\n    for (int j = 0; j < ITERATIONS; j++) {\n        d = sdf(pos);\n        // If we're shooting off\n        if (d > 100.) {\n            total_distance = 0.0;\n            break;\n        }\n        // If we've hit something, we're done\n        if (d < MARCH_THRESH) break;\n        // March one step forward\n        pos += dir * d;\n        total_distance += d;\n    }\n    return vec4(pos, total_distance);\n}\n\nvec4 march(in vec3 pos, in vec3 dir) {\n    // List of hits and how many there are (always at most REFLECTIONS)\n    vec4[REFLECTIONS] hit_col_list;\n    float[REFLECTIONS] hit_angle_list;\n    int hits = 0;\n    \n    float tot_d = 0.0;\n    \n    // Reused variable\n    vec4 raycast_results;\n    \n    for (int i = 0; i < REFLECTIONS; i++) {\n        raycast_results = raycast(pos, dir);\n        // If we didn't hit anything, no more reflections\n        if (raycast_results.w == 0.0) break;\n        tot_d += raycast_results.w;\n        \n        // Store color, we use this later to calculate final color backwards\n        hit_col_list[i] = color(raycast_results.xyz);\n        hit_angle_list[i] = -dot(normal(raycast_results.xyz), dir);\n        hits++;\n        // If the object we hit isn't reflective, no more reflections\n        if (hit_col_list[i].w < 0.01) break;\n        \n        // Reflect and march a tiny bit forward because otherwise we get stuck\n        pos = raycast_results.xyz;\n        dir = reflect(dir, normal(pos));\n        pos += dir * 0.001;\n    }\n    \n    // Calculate color by following the reflections backwards\n    vec4 ray_color = sky_color;\n    for (int i = hits-1; i >= 0; i--) {\n        ray_color = (amb_light * hit_col_list[i] * hit_angle_list[i]) + (ray_color * hit_col_list[i] * hit_col_list[i].w);\n    }\n    \n    //ray_color = color(pos);\n    //return col4(tot_d/20.);\n    return vec4(ray_color.xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates ((0,0) is center, y goes from -1 to 1, aspect ratio preserved)\n    vec2 uv = ((2.0 * fragCoord)-iResolution.xy) / iResolution.y;\n    vec2 mouse_uv = ((2.0 * iMouse.xy)-iResolution.xy) / iResolution.y;\n\n    // Calculate direction of ray through this pixel (not accurate but good enough for now)\n    vec3 dir = camera_dir + vec3(0.0, FOV*(uv));\n\n    // March the ray and output returned color\n    fragColor = march(camera_pos - 2.*vec3(0.0, mouse_uv), normalize(dir));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1417, 1417, 1440, 1440, 1473], [1475, 1475, 1522, 1522, 1568], [1569, 1569, 1614, 1614, 1661], [1662, 1707, 1731, 1731, 2048], [2050, 2109, 2135, 2135, 2330], [2332, 2379, 2404, 2493, 3350], [3352, 3352, 3392, 3460, 3912], [5343, 5343, 5400, 5499, 5905]], "test": "untested"}
{"id": "dsjcRw", "name": "Tut/Doc: Audio (Mitsync)", "author": "Mitsync", "description": "Audio input is weird, so this shader provides unofficial documentation of the Shadertoy audio inputs, especially the provided FFT.", "tags": ["fft", "wave", "spectrum", "tutorial", "audio", "demo", "visualiser", "input", "docs", "documentation"], "likes": 4, "viewed": 167, "published": 3, "date": "1695202198", "time_retrieved": "2024-07-30T17:32:48.199028", "image_code": "// Mitsync, 2023\n\n/*\n    I did some experiments with the audio inputs in Shadertoy and accidentally wrote documentation for it.\n    Most of this is purely theoretical and does not matter if you just want to draw a pretty graph.\n        The most important part for that is how the frequency axis works:\n            UV coordinates 0.0-1.0 correspond to 0 - 11/12 kHz, linearly.\n            Make this logarithmic to get prettier graphs, as done in helper function `fft_log()` below.\n    If you use code from this file it would be nice if you linked back here :)\n    All testing done in Google Chrome on Windows 10, using signals generated in Audacity:\n        Filetype: uncompressed WAV, samplerate: 44.1 and 48 kHz, sample format: 32-bit float\n    \n    Basics:\n        Audio inputs are accesible in shaders as a 512x2 texture with a single color channel (red).\n        The top row (y-coordinate 1) is the 512 most recent audio samples. Use this to draw a waveform.\n        The bottom row (y-coordinate 0) is 512 points of spectrum between 0 and 11/12 kHz. Use this to draw a spectrum/equaliser.\n        The stored values are medium precision floats between 0.0 and 1.0 inclusive for both the wave and FFT rows.\n            This means silence is a constant value of 0.5 (DC offset).\n        The easiest way to access values is using the `texture()` function:\n            For samples: `texture(iChannelX, vec2(x, 1.0)).r`\n            For spectrum: `texture(iChannelX, vec2(x, 0.0)).r`\n            Where `x` is a float between 0.0 and 1.0 inclusive. Replace `iChannelX` with the channel you're using. The `.r` makes these return a float.\n            Note that this does linear interpolation if you ask a value between two measured values (samples or bins).\n                This can't be disabled with the channel settings, use `texelFetch()` instead.\n        Another way is using the `texelFetch()` function:\n            For samples: `texelFetch(iChannelX, ivec2(x, 1), 0).r`\n            For spectrum: `texelFetch(iChannelX, ivec2(x, 0), 0).r`\n            Where `x` is an integer between 0 and 511 inclusive. Replace `iChannelX` with the channel you're using. The `.r` makes these return a float.\n                Eg: `int x = int(x_float*512.)`\n            This does not do interpolation (as you can only input integers).\n        Or just use the helper functions below. :)\n        All inputs get converted to the samplerate of the audio output on your device before they reach the shader:\n            Setting output to 44.1 kHz (in Windows in my case) means the FFT goes between 0 and 11 kHz for both 44.1 kHz AND 48 kHz sources.\n            The current samplerate is available in the uniform `iSampleRate` (even outside sound shaders, unlike what the official documentation implies)\n        You can import custom audio using this Chrome extension and just dropping a file on one of the input channels:\n            https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n            Supported filetypes depend on OS and browser.\n\n    FFT specifics:\n        The bottom row (y-coordinate 0) is 512 points of spectrum of the incoming audio signal.\n        The frequency axis is linear between 0 and 1/4 samplerate inclusive (so usually 11025 Hz or 12000 Hz):\n            Minimum UV coordinate (0.0) corresponds to 0 Hz (DC component, this is not removed!).\n            Maximum UV coordinate (1.0) corresponds to 1/4 times the output samplerate (so usually 11025 Hz or 12000 Hz).\n            Frequency resolution (bin size) is 21.5 Hz at 44.1 kHz samplerate, 23.4 Hz at 48 kHz samplerate.\n                These are approximately the differences between F#4 (370.0 Hz), G4 (392.0 Hz), and G#4 (415.3 Hz),\n                    Notes below that can't be accurately distinguished from neighbors.\n            All this implies Shadertoy is resampling, then doing a 2048-point FFT, but only making the first 512 points available.\n                (These are by far the most interesting anyway, we're not losing much)\n                This also means frequencies between 1/4 and 3/4 samplerate do NOT cause aliasing!\n                Frequencies above 3/4 samplerate DO cause aliasing (be careful with pure squarewaves for example).\n        Amplitude is linear with dB power between -87 and -17 dB:\n            Minimum returned value (0.0) corresponds to a signal power of -87 dB or lower.\n            Maximum returned value (1.0) corresponds to -17 dB or higher.\n            Values inbetween are linear with amplitude in dB.\n            Note: values are clipped! It is not possible to measure amplitudes outside this range!\n                Spectrum clipping is common, even (especially!) with properly mastered audio!\n            Amplitude is smoothed over time by what looks like decaying peak-hold.\n                A 0 dB sine takes approximately 0.5 seconds to drop below minimum amplitude (-87 dB).\n        Window is unknown but acts as follows:\n            A pure 0 dB sine at an exact bin frequency (aligned to the pixels) is 5 bins wide (total).\n            A pure 0 dB sine exactly between bins is also 5/6 pixels wide but with 5 extra bins of sidelobe on both sides.\n                So 15 bins around centre have significant value.\n            Harmonics are not surpressed (which is the correct way to do it).\n    \n    Contents of this demo:\n        Comments with example inputs and outputs assume constants as defined at the top of this file\n        Several helper functions for accessing and converting the audio data:\n            Getting amplitude of wave\n            Conversion between musical note, octave and frequency\n    \n    Useful links:\n        Table of notes and frequencies, also coupled to piano, organ and MIDI notes:\n            https://www.inspiredacoustics.com/en/MIDI_note_numbers_and_center_frequencies\n        More may come later\n*/\n\n\n\n/*  ------------------------\n      MACROS AND CONSTANTS\n    ------------------------*/\n\n// Constants\n#define INPUT iChannel0\n#define SAMPLERATE iSampleRate\n// These brackets are required because the preprocessor is dumb\n#define MAX_F (0.25*SAMPLERATE)\n// Reference note for the conversions between note/octave and frequency, a good default is C4, aka middle C, 261.63 Hz\n#define REF_NOTE 261.63\n\n// Macros\n#define ILN10 0.4343\n\n/*  --------------------\n      HELPER FUNCTIONS\n    --------------------*/\n\n// GETTING WAVE DATA\n// Get wave amplitude at UV coordinate (input between 0.0 and 1.0 inclusive)\nfloat wave(in float x)                  {  return texture(INPUT, vec2(x, 1.0)).r;  }\n// Get wave amplitude of sample, so not interpolated (input between 0 and 511 inclusive)\nfloat wave(in int s)                    {  return texelFetch(INPUT, ivec2(s, 0), 1).r;  }\n\n// GETTING FFT DATA\n// Get FFT at UV coordinate (input between 0.0 and 1.0 inclusive)\nfloat fft(in float x)                   {  return texture(INPUT, vec2(x, 0.0)).r;  }\n// Get FFT of frequency bin, so not interpolated (input between 0 and 511 inclusive)\nfloat fft(in int bin)                   {  return texelFetch(INPUT, ivec2(bin, 0), 0).r;  }\n// Get FFT of frequency (input between 0.0 and MAX_F)\nfloat fft_freq(in float freq)           {  return fft(freq/MAX_F);  }\n// Get FFT of log UV coordinate, between 50 and 10000 Hz (input between 0.0 and 1.0 inclusive) (!! use this one for pretty graphs !!)\nfloat fft_log(in float x)               {  return fft(50. * pow(10.0, 2.3*x) / MAX_F);  }\n\n// CONVERTING AMPLITUDE REPRESENTATIONS\n// Convert the amplitude returned from FFT to decibel power or amplitude\nfloat fft_to_db(in float val)           {  return 70.*val - 87.;  }\nfloat fft_to_amplitude(in float val)    {  return pow(10., fft_to_db(val)/10.);  }\n\n// Convert between decibel power and amplitude\nfloat amplitude_to_db(in float amp)     {  return 20.*log(amp)*ILN10;  }\nfloat db_to_amplitude(in float db)      {  return pow(10., db/20.);  }\n\n// CONVERTING FREQUENCY REPRESENTATIONS\n// Convert between octave relative to REF_NOTE and frequency (0.=C4, -1.=C3, (2./12.)=D4, etc.)\n// This is similar to volt/octave in modular synthesis\nfloat octave_to_freq(in float octave)   {  return REF_NOTE * exp2(octave);  }\nfloat freq_to_octave(in float freq)     {  return log2(freq / REF_NOTE);  }\n\n// Convert between note relative to REF_NOTE and frequency (0.=C4, -12.=C3, 2.=D4, etc.)\nfloat note_to_freq(in float note)       {  return REF_NOTE * exp2(note/12.);  }\nfloat freq_to_note(in float freq)       {  return log2(freq / REF_NOTE) * 12.;  }\n\n// Convert between note and octave (note 12. is octave 1., note -18. is octave -1.5)\nfloat note_to_octave(in float note)     {  return note / 12.;  }\nfloat octave_to_note(in float octave)   {  return octave * 12.;  }\n\n// Round frequency to that of nearest note\nfloat round_to_note(in float freq)      {  return note_to_freq(round(freq_to_note(freq)));  }\n\n// OTHER\n// Construct a grayscale colour from a single float\nvec4 col(in float val)                  {  return vec4(val, val, val, 1.0);  }\n// Construct a RG colour from a vec2\nvec4 col(in vec2 val)                   {  return vec4(val, 0.0, 1.0);  }\n// Construct a RGB colour from a vec3\nvec4 col(in vec3 val)                   {  return vec4(val, 1.0);  }\n\n// TODO: note with sum harmonics???\n// Summed power at first through fourth harmonics of this frequency (in dB)\nfloat freq_harmonic_power(in float freq) {\n    vec4 amp;\n    amp.x = fft_to_amplitude(fft_freq(freq));\n    amp.y = fft_to_amplitude(fft_freq(2. * freq));\n    amp.z = fft_to_amplitude(fft_freq(3. * freq));\n    amp.w = fft_to_amplitude(fft_freq(4. * freq));\n    return amplitude_to_db(amp.x + amp.y + amp.z + amp.w);\n}\n// Get FFT amplitude of note\nfloat fft_note(in float note)           {  return fft_freq(note_to_freq(note));  }\n\n// Get approximate total volume by summing FFT\nfloat total_power() {\n    float sum = 0.0;\n    for (int i = 32; i < 512; i += 8) {\n        sum += fft(i);\n    }\n    return 8. * sum / 480.;\n}\n\n\n\n/*  -----------------------\n      MAIN IMAGE FUNCTION\n    -----------------------*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float avg_pwr = total_power();\n\n    float note = 72.*uv.x - 24.;\n    float p_cont = fft_note(note);\n    float p_note = fft_note(round(note));\n    \n    vec3 p_neighbors;\n    p_neighbors.x = fft_note(round(note)-1.0);\n    p_neighbors.y = fft_note(round(note));\n    p_neighbors.z = fft_note(round(note)+1.0);\n    float p_rel = dot(p_neighbors, vec3(-0.45, 1.0, -0.45));\n    p_rel = p_rel/(uv.x+1.);\n    \n    // Contrived example\n    float amp_c4 = fft_to_amplitude(fft_freq(note_to_freq(0.0)));\n    \n    fragColor = abs(uv.y-p_cont) < 0.005 ? col(1.0) : (abs(uv.y-p_rel) < 0.005 ? col(1.0) : col(pow(p_rel*1., 7.)));\n    fragColor += abs(uv.y-avg_pwr) < 0.005 ? col(1.0) : col(0.0);\n    //fragColor = col(fft(uv.x));\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6394, 6492, 6533, 6533, 6576], [6577, 6666, 6707, 6707, 6755], [6757, 6843, 6884, 6884, 6927], [6928, 7013, 7054, 7054, 7104], [7105, 7159, 7200, 7200, 7228], [7229, 7363, 7404, 7404, 7452], [7454, 7567, 7608, 7608, 7634], [7635, 7635, 7676, 7676, 7717], [7719, 7766, 7807, 7807, 7838], [7839, 7839, 7880, 7880, 7909], [7911, 8102, 8143, 8143, 8179], [8180, 8180, 8221, 8221, 8255], [8257, 8346, 8387, 8387, 8425], [8426, 8426, 8467, 8467, 8507], [8509, 8594, 8635, 8635, 8658], [8659, 8659, 8700, 8700, 8725], [8727, 8770, 8811, 8811, 8863], [8865, 8926, 8967, 8967, 9004], [9005, 9042, 9083, 9083, 9115], [9116, 9154, 9195, 9195, 9222], [9224, 9336, 9378, 9378, 9652], [9653, 9682, 9723, 9723, 9764], [9766, 9813, 9834, 9834, 9954], [10043, 10043, 10100, 10150, 10915]], "test": "untested"}
{"id": "mdccDN", "name": "circular_sine", "author": "Dolfun", "description": " todo: use domain repetition", "tags": ["sdf", "sine", "polar"], "likes": 5, "viewed": 84, "published": 3, "date": "1695167320", "time_retrieved": "2024-07-30T17:32:49.130537", "image_code": "#define NUM_ITERS 2\n#define PI 3.14159265359\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n\n    return a + b*cos(6.28318*(c*t + d));\n}\n\nfloat r(float r0, float a, float n, float phi, float theta) {\n    return r0*(1.0 + a*sin(n*theta + phi));\n}\n\nfloat r1(float r0, float a, float n, float phi, float theta) {\n    return r0*a*n*cos(n*theta + phi);\n}\n\nfloat r2(float r0, float a, float n, float phi, float theta) {\n    return -r0*a*n*n*sin(n*theta + phi);\n}\n\nfloat dist_sq(float r0, float a, float n, float phi, float theta, vec2 v) {\n    float rv = r(r0, a, n, phi, theta);\n    return dot(v, v) + rv*rv - 2.0*rv*(v.x*cos(theta)+v.y*sin(theta));\n}\n\nfloat dist1(float r0, float a, float n, float phi, float theta, vec2 v) {\n    float rv = r(r0, a, n, phi, theta);\n    float rv1 = r1(r0, a, n, phi, theta);\n    return rv*rv1 - rv1*(v.x*cos(theta)+v.y*sin(theta)) + rv*(v.x*sin(theta)-v.y*cos(theta));\n}\n\nfloat dist2(float r0, float a, float n, float phi, float theta, vec2 v) {\n    float rv = r(r0, a, n, phi, theta);\n    float rv1 = r1(r0, a, n, phi, theta);\n    float rv2 = r2(r0, a, n, phi, theta);\n    return rv1*rv1 + rv*rv2 + (rv-rv2)*(v.x*cos(theta)+v.y*sin(theta)) + 2.0*rv1*(v.x*sin(theta)-v.y*cos(theta));\n}\n\n#define NUM_TRIALS 2\nfloat sdf_csin(float r0, float a, float n, float phi, vec2 v) {\n    float ep = 0.001;\n    if (dist_sq(r0, a, n, phi, atan(v.y, v.x), v) <= ep * ep) return 0.0;\n    \n    float theta0 = (floor(n * atan(v.y, v.x) / PI)) * PI / n;\n    float d = 1e9;\n    for (int i = -NUM_TRIALS; i <= NUM_TRIALS; ++i) {\n        float theta = theta0 + float(i) * PI / (2.0 * n);\n        for (int j = 0; j < NUM_ITERS; ++j) {\n            theta -= dist1(r0, a, n, phi, theta, v) / dist2(r0, a, n, phi, theta, v);\n        }\n        d = min(d, dist_sq(r0, a, n, phi, theta, v));\n    }\n    \n    return sqrt(d);\n}\n\n#define N 18\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float ar = iResolution.z;\n    float t = iTime;\n    \n    float r0 = 0.25;\n    float rd = 0.1;\n    float a = 0.1;\n    float n = 10.0;\n        \n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; ++i) {\n        float phi = 0.2 * t * float(N - i);\n        if (i % 2 == 0) phi *= -1.0;\n        float n1 = n + float(i * 4);\n        float a1 = a * sin(2.5 * t + float(i) * 2.0 * PI / float(N)) / float(i + 1);\n        float sdf = sdf_csin(r0 + float(i) * rd, a1, n1, phi, uv);\n        float d = 0.003 / sdf;\n        color += vec3(d) * palette(length(uv) + 0.25 * t);\n    }\n    \n    float m = sqrt(1.0 + ar * ar) + 0.25;\n    color *= 2.0 - smoothstep(0.0, 0.25, abs(length(uv) - mod(0.25 * t, m)));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdccDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 69, 69, 252], [254, 254, 315, 315, 361], [363, 363, 425, 425, 465], [467, 467, 529, 529, 572], [574, 574, 649, 649, 762], [764, 764, 837, 837, 1015], [1017, 1017, 1090, 1090, 1330], [1353, 1353, 1416, 1416, 1939], [1954, 1954, 2009, 2009, 2814]], "test": "untested"}
{"id": "DsccRS", "name": "Tuesday tinkering", "author": "mrange", "description": "CC0: Tuesday tinkering\nExperimenting with hextiling, beziers and glow\n", "tags": ["glow"], "likes": 47, "viewed": 763, "published": 3, "date": "1695155833", "time_retrieved": "2024-07-30T17:32:50.212644", "image_code": "// CC0: Tuesday tinkering\n//   Experimenting with hextiling, beziers and glow\n\n\n// Less calming, more flickering\n// #define FLICKER\n\n// Applies mobius transform tinkering\n// #define DISTORT\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)     mat2(cos(a), sin(a), -sin(a), cos(a))\n#define OFF6(n)    (vec2(1.0, 0.0)*ROT(n*TAU/6.))\n\nconst vec2 off6[6] = vec2[6](\n    OFF6(0.)\n  , OFF6(1.)\n  , OFF6(2.)\n  , OFF6(3.)\n  , OFF6(4.)\n  , OFF6(5.)\n  ); \n\nconst vec2 noff6[6] = vec2[6](\n    vec2(-1.0, 0.0)\n  , vec2(-0.5, 0.5)\n  , vec2( 0.5, 0.5)\n  , vec2( 1.0, 0.0)\n  , vec2( 0.5,-0.5)\n  , vec2(-0.5,-0.5)\n  ); \n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  p = p.yx;\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  co += 1.234;\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec2 coff(float h) {\n  float h0 = h;\n  float h1 = fract(h0*9677.0);\n  float h2 = fract(h0*8677.0);\n  float t = mix(0.5, 1.0, h2*h2)*TIME+1234.5*h0;\n  return mix(0.1, 0.2, h1*h1)*sin(t*vec2(1.0, sqrt(0.5)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\n\nvec2 transform(vec2 p) {\n  p *= 2.0;\n  vec2 sp0 = toSmith(p-0.);\n  vec2 sp1 = toSmith(p+vec2(1.0)*ROT(0.12*TIME));\n  vec2 sp2 = toSmith(p-vec2(1.0)*ROT(0.23*TIME));\n  p = fromSmith(sp0+sp1-sp2);\n  return p;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  float aa = 4.0/RESOLUTION.y;\n  \n  vec2 hp = p;\n#ifdef DISTORT\n  vec2 nhp = transform(hp+aa);\n  hp = transform(hp);\n  float scale = distance(nhp, hp);\n#else\n  hp *= 3.0;\n#endif\n\n  const float ga = 100.0;\n  hp += ga*sin(vec2(1.0, sqrt(0.5))*TAU*(TIME-300.0)/(8.0*ga));\n  vec2 hn = hextile(hp);\n  \n  float h0 = hash(hn);\n  vec2 p0 = coff(h0);\n  \n  vec3 bcol = 0.5*(1.0+cos(vec3(0.0, 1.0, 2.0) + dot(p, p)-0.5*TIME)); \n  vec3 col = vec3(0.0);\n  \n#ifdef DISTORT\n  float mx = 0.0005+0.01*scale;\n#else\n  const float mx = 0.0005;\n#endif\n\n  for (int i = 0; i < 6; ++i) {\n    float h1 = hash(hn+noff6[i]);\n    vec2 p1 = off6[i]+coff(h1);\n    \n#if defined(FLICKER)    \n    float fade = (smoothstep(1.05, 0.9, dot2(p0-p1))) > hash(floor(TIME*30.0)+h2) ? 1.0 : 0.0;\n#else\n    float fade = smoothstep(1.05, 0.85, distance(p0, p1)); \n#endif\n    if (fade < 0.025) continue;\n    \n    float h2 = h0+h1;\n    vec2 p2 = 0.5*(p1+p0)+coff(h2);\n    \n    float dd = bezier(hp, p0, p2, p1);\n    float gd = abs(dd);\n    gd *= sqrt(gd);\n    gd = max(gd, mx);\n    col += fade*0.002*bcol/(gd);\n  }\n\n  {  \n    float cd = length(hp-p0);\n    float gd = abs(cd);\n    gd *= (gd);\n    gd = max(gd, mx);\n    col += 0.0025*sqrt(bcol)/(gd);\n  }\n  \n  {\n    float hd = hexagon(hp, 0.485);\n    float gd = abs(hd);\n    gd = max(gd, mx*10.0);\n    col += 0.0005*bcol*bcol/(gd);\n  }\n\n#ifdef DISTORT\n  col += scale*(bcol);\n#endif\n\n  col *= smoothstep(1.75, 0.5, length(pp));\n  col = aces_approx(col);  \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsccRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[692, 793, 821, 920, 1247], [1249, 1367, 1399, 1399, 1597], [1599, 1659, 1680, 1680, 1765], [1767, 1827, 1849, 1849, 1897], [1899, 1899, 1919, 1919, 1941], [1943, 2061, 2109, 2109, 3147], [3149, 3149, 3169, 3169, 3357], [3359, 3466, 3492, 3492, 3676], [3678, 3678, 3701, 3781, 3920], [3922, 3922, 3947, 4026, 4165], [4168, 4168, 4192, 4192, 4376], [4380, 4380, 4436, 4436, 6063]], "test": "untested"}
{"id": "dsdyDM", "name": "Red planet with ring revised", "author": "Raukie", "description": "a red planet with ring", "tags": ["space", "planet", "ring"], "likes": 2, "viewed": 149, "published": 3, "date": "1695146279", "time_retrieved": "2024-07-30T17:32:51.173076", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Calculate the center of the screen\n    vec2 center = vec2(0.5,0.5);\n    \n    // Calculate the radius of the circle (half the screen height)\n     float radius = 0.3f;\n\n    // Calculate the vector from the current pixel to the center\n    vec2 toCenter = (fragCoord.xy / iResolution.xy - center) * vec2(iResolution.x / iResolution.y, 1.0);\n\n    // Calculate the distance from the current pixel to the center\n    float aspect =  min(iResolution.x / iResolution.y, 1.0);\n    float distance = length(toCenter) * aspect;\n\n    // Check if the pixel is inside the circle\n   \n    float depth = 1.0 - (distance / radius);\n\n    float a = pow(depth, 0.3);\n    float depthMin = clamp(a, 0.0, 1.0);\n    //lighting outside of the sphere\n    float b = depthMin + pow(min(depth, 0.0),1.0);\n    \n    //ring around the planet equetor\n    float distanceY = iResolution.y / 2.0 - fragCoord.y * aspect;\n    float distanceX = abs(iResolution.x / 2.0 - fragCoord.x) * aspect;\n    float depthX = 1.3 - (distanceX/(iResolution.x*0.5f));\n    float r = pow(clamp(depthX, 0.0, 1.0),0.9);\n    float t = 1.0;\n    float blue = 0.0;\n    if(distanceY > 0.0 || depth < 0.01){\n         float depthRing = 1.0f - abs(distanceY * t) / (iResolution.y * (r));\n        float c = pow(depthRing, 2.0);\n        float noiseRing = texture(iChannel3, (fragCoord.xy+sign(distanceY)*vec2((iTime*10.0), iTime*2.0))*(0.0072)).x*1.0;\n        c+=noiseRing*pow(c,10.0);\n        c = clamp(c, 0.0, 1.0);\n        c -= (1.0*0.01 * pow((iResolution.y / 2.0 / abs(distanceY)), 0.2));\n        blue = c;\n    }\n    float noise = texture(iChannel3, (fragCoord.xy+vec2(iTime*10.0, 0.0))*0.01).x*0.1;\n    b += noise;\n    blue = clamp(blue, 0.0, 1.0);\n    fragColor = vec4(b-blue*pow(blue,50.0), 0.0, blue, 1.0); \n    \n    \n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsdyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 97, 1819]], "test": "untested"}
{"id": "mddcWM", "name": "Arabesque knots 11 (music)", "author": "jarble", "description": "An arabesque knot pattern with interlaced knots.\nClick and drag to move around.", "tags": ["fractal", "music", "knot", "interlace", "arabesque"], "likes": 6, "viewed": 310, "published": 3, "date": "1695143810", "time_retrieved": "2024-07-30T17:32:51.948004", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.*1.5;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = uv.y > uv.x;\n    bool b1 = b;\n    for(int k = 0; k < 9; k++){\n        \n\n        b1 = uv.y>uv.x || !b1;\n        //if(b)\n        uv =\n            abs(.5+uv+t2)\n            //(max(abs(uv-t2),abs(t2)*2.))\n            //min(abs(.5+uv+t2),abs(-.5+uv+t2))\n            //max(abs(.5+uv+t2),abs(-.5+uv+t2))\n            //abs(.5+uv+t2*(1.+mod(floor(uv.y),2.)/2.))\n            //abs(.5+uv+t2+pow(floor(uv.x),2.)/1.5)\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        \n        //if((t2.x)>(t2.y) || k%2 == 0) uv /= 1.5;\n\n        //k += int(uv.x>uv.y);\n        //uv += float(int(iTime)/3);\n        \n        //uv += sign(uv-uv.yx)/2.+.5;\n        //uv += floor(uv*1.5); //another interesting pattern\n        \n        //if(t2.x<t2.y)\n        b =\n            uv.y>uv.x||t2.x>t2.y/2.\n            //uv.y>uv.x\n            //(b && uv.y<uv.x)||(!b && t2.y<t2.x)\n            //(uv.y>uv.x||t2.y<t2.x)&&!b\n            //uv.y>uv.x*float(t2.y>t2.x)\n            //uv.y>uv.x*float(t2.y>t2.x) //makes a braided pattern\n            //uv.y>uv.x+float(!b1)\n            //uv.y*float(!b1)>uv.x\n        ;\n        \n        //uv *= -sign(uv.x-.5);\n        if(b) uv = uv.yx;\n        //else {k += 1; uv *= 1.5; col=col.yzx;}\n        //uv.x += sign(t2.x-t2.y);\n        //uv.x -= sign(uv.x-uv.y);\n        \n        //uv.x -= t1_(floor(uv),floor(uv));\n        \n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5)-sign(t2)\n            //-triangle_wave(uv+float(!b)-.5)\n        ;\n        //if(t2.y<t2.x) t2 = t2*1.5; else t2=t2/1.5;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx+float(!b))\n            //t2-triangle_wave(uv.yx+floor(uv.x*2.))\n        ;\n        //if(t2.y>t2.x)\n        \n        if(uv.y<uv.x||b)\n        //if(uv.y*float(col.x<col.y)<uv.x||b)\n        col =\n            vec3(col.zx,max(uv.x-uv.y,0.))\n            //abs(vec3(col.zx,max(uv.x-uv.y,-float(b)/2.)))\n            //vec3(col.yz,max(uv.x-uv.y,0.))\n            //vec3(col.zx,max(uv.x-uv.y,col.x))\n            //abs(sign(uv.x-uv.y)/2.-vec3(col.zx,max(uv.x-uv.y,0.)))\n        ;\n        //uv /= 1.+mod(uv.x,2.);\n        //if(t2.x>t2.y) col=col.yzx;\n\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod(float a, float b){\n    return\n        mod(floor(a),b)\n        //mod(mod(8.+floor(a/2.),8.+floor(a)),b)\n    ;\n}\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.;\n  time = (time + floor(time*s1)/s1);\n  float\n  t=\n      (((time)/s1+max(fract(-time/2.),fract(time))/8.))/4./(1.+fmod(time*4.-floor(time/s1),2.)),\n  t1 = fmod(t,2.)\n  ;\n  t *=\n      (s1*s1)\n  ;\n  float a=\n      16.*pow(fract(-t),2.)\n  ,\n  nb = time*pow(2.,(1.+t1)*(2.+fmod(t/(1.+t1),s1)+1. + fmod(floor(t/s1),2.))/7.+4.5);\n  return\n      log(1.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a)\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 107], [109, 109, 136, 136, 297], [414, 414, 440, 440, 529], [531, 531, 588, 588, 3110]], "test": "untested"}
{"id": "csdyW7", "name": "Funky Tris", "author": "Lewie4", "description": "First submission", "tags": ["triangle", "glow", "loop"], "likes": 21, "viewed": 340, "published": 3, "date": "1695138580", "time_retrieved": "2024-07-30T17:32:53.263487", "image_code": "#define count 24.\n\nvec2 Rot(vec2 uv, float amount)\n{\n    float rot = iTime * amount;\n    return vec2(uv.y*sin(rot)+uv.x*cos(rot), uv.y*cos(rot)-uv.x*sin(rot));\n}\n\n\nfloat TriSDF(vec2 uv, float r)\n{\n    const float k = sqrt(3.);\n    uv.x = abs(uv.x) - r;\n    uv.y = uv.y + r/k;\n    if(uv.x+k*uv.y>0.) uv=vec2(uv.x-k*uv.y,-k*uv.x-uv.y)/2.;\n    uv.x -= clamp(uv.x,-2.*r, 0.);\n    return -length(uv)*sign(uv.y);\n}\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    u = (u+u-iResolution.xy)/iResolution.y;\n    O -= O;\n    \n    for(float i = 0.; i < count; i++)\n    {\n        vec2 ruv = Rot(u,i*0.2);\n        float scale = 3.5*fract(iTime/3.5 + i*1./count);//0.5;\n        float tri = abs(TriSDF(ruv, 3.5*fract((i*1./count)+iTime*.2)));\n        tri = smoothstep(0.01,0.,tri)+smoothstep(0.2,0.,tri)*.15;\n        vec3 col = vec3(cos(i+iTime+vec3(0.,1.,2.))+1.2);\n        O += vec4(tri * col, 0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 52, 52, 161], [164, 164, 196, 196, 408], [410, 410, 449, 449, 888]], "test": "untested"}
{"id": "ddccW7", "name": "funny UI animation", "author": "jcyuan", "description": "saw some topic in the chat group, so made it as a demo", "tags": ["animation", "ui"], "likes": 1, "viewed": 79, "published": 3, "date": "1695127113", "time_retrieved": "2024-07-30T17:32:54.221924", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float w = length(fwidth(uv)) / 2.;\n\n    float ball = length(uv - vec2(0., sin(iTime * 2.) * .2 + .2)) - .2;\n    float rect = uv.y;\n    \n    const float k = .1;\n    float h = clamp(.5 - .5 * (rect + ball) / k, 0., 1.);\n    float d = mix(rect, -ball, h) + k * h * (1. - h);\n    d = min(ball, d + .072);\n    \n    vec3 col = vec3(smoothstep(-w, w, d));\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddccW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 507]], "test": "untested"}
{"id": "ddcyW7", "name": "Red planet with ring", "author": "Raukie", "description": "a red planet with ring", "tags": ["space", "planet", "ring"], "likes": 4, "viewed": 162, "published": 3, "date": "1695126421", "time_retrieved": "2024-07-30T17:32:55.105562", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Calculate the center of the screen\n    vec2 center = vec2(0.5,0.5);\n    \n    // Calculate the radius of the circle (half the screen height)\n     float radius = 0.3f;\n\n    // Calculate the vector from the current pixel to the center\n    vec2 toCenter = (fragCoord.xy / iResolution.xy - center) * vec2(iResolution.x / iResolution.y, 1.0);\n\n    // Calculate the distance from the current pixel to the center\n    float aspect =  min(iResolution.x / iResolution.y, 1.0);\n    float distance = length(toCenter) * aspect;\n\n    // Check if the pixel is inside the circle\n   \n    float depth = 1.0 - (distance / radius);\n\n    float a = pow(depth, 0.3);\n    float depthMin = clamp(a, 0.0, 1.0);\n    //lighting outside of the sphere\n    float b = depthMin + pow(min(depth, 0.0),1.0);\n    \n    //ring around the planet equetor\n    float distanceY = iResolution.y / 2.0 - fragCoord.y * aspect;\n    float distanceX = abs(iResolution.x / 2.0 - fragCoord.x) * aspect;\n    float depthX = 1.3 - (distanceX/(iResolution.x*0.5f));\n    float r = pow(clamp(depthX, 0.0, 1.0),0.9);\n    float t = 1.0;\n    float blue = 0.0;\n    if(distanceY > 0.0 || depth < 0.01){\n         float depthRing = 1.0f - abs(distanceY * t) / (iResolution.y * (r));\n        float c = pow(depthRing, 2.0);\n        float noiseRing = texture(iChannel3, (fragCoord.xy+sign(distanceY)*vec2((iTime*10.0), iTime*2.0))*(0.0072)).x*1.0;\n        c+=noiseRing*pow(c,10.0);\n        blue = c;\n    }\n    float noise = texture(iChannel3, (fragCoord.xy+vec2(iTime*10.0, 0.0))*0.01).x*0.1;\n    b += noise;\n    \n    fragColor = vec4(b-blue*pow(blue,50.0), 0.0, blue, 1.0); \n    \n    \n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 97, 1682]], "test": "untested"}
{"id": "dtSfzR", "name": "Painting with Code Demo", "author": "ircss", "description": "demo for a presentation I gave. Blog post here: https://shahriyarshahrabi.medium.com/painting-with-code-a42263b578cb", "tags": ["procedural", "2d", "painting", "sunflowers"], "likes": 168, "viewed": 6988, "published": 3, "date": "1695120319", "time_retrieved": "2024-07-30T17:32:56.207615", "image_code": "#define smoothing      0.006\n#define TWO_PI 6.28318530718\n#define lineSize       0.01\n#define skyColor  vec3(101., 164., 208.)/255.\n#define skyButton vec3(178., 208., 232.)/255.\n#define MountainsLayerOneCol vec3(50., 118., 165.)/255.\n#define MountainsLayerTwoCol vec3(46., 94., 130.)/255.\n#define MountainLayerThreecol vec3(26., 65., 74.)/255.\n#define MountainLayerFourCol vec3(14., 49., 55.)/255.\n#define SunflowerInsideOne    vec3(203., 77., 23.)/255.\n#define SunflowerInsideTwo    vec3(134., 71., 48.)/255.\n#define SunflowerInsideThree  vec3(158., 159., 33.)/255.\n#define SunflowerLeavesOne    vec3(247., 214., 0.)/255.\n#define SunflowerHighlight    vec3(247., 218., 63.)/255.\n#define SunflowerLeavesTwo    vec3(236., 168., 3.)/255.\n#define SunflowerStem         vec3(97., 128., 52.)/255.\n#define SunflowerStemBright   vec3(176., 186., 53.)/255.\n#define FieldDark             vec3(44., 62., 40.)/255.\n#define FieldMid              vec3(94., 121., 62.)/255.\n#define Clouddark             vec3(177., 203., 229.)/255.\n#define CloudLight            vec3(250., 251., 253.)/255.\nfloat TriangularWave(float x)\n{\n return abs(fract(x) - 0.5) * 4. - 1.;\n}\n\n\nfloat randOneD(float x){\nreturn fract(sin(x *52.163)*268.2156);}\n\n\nfloat ConcateClouds(float amplitude, float period, float translateX, float translateY, float Seed, float x)\n{\n\n  Seed = randOneD(Seed);\n  float toReturn = 0.;\n  for(int i = 0; i< 6; i++){\n     toReturn += sin( (x + Seed *6. + translateX  + float(i) *(0.125+  Seed *6.)) * period * TWO_PI) *  amplitude;\n     amplitude *= 0.5;\n     period *= 2.;\n  }\n  return toReturn + translateY ;\n}\n\n\nfloat ConcateTriangularWaves(float amplitude, float period, float translateX, float translateY, float Seed, float x)\n{\n\n  Seed = randOneD(Seed);\n  float toReturn = 0.;\n  for(int i = 0; i< 5; i++){\n     toReturn += TriangularWave( (x + Seed *6. + translateX  + float(i) *(0.125+  Seed *6.)) * period) *  amplitude + translateY ;\n     amplitude *= 0.85;\n     period *= 1.25;\n  }\n  return toReturn;\n}\n\nvoid DrawLine(float m, float c, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n\n    vec2  xy   = vec2(uv.x, uv.x * m + c); \n    float d    = distance(xy, uv);\n    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size + smoothing, d));\n    \n}\nvoid DrawHalfVectorWithLength(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n          m   += step(len, vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.01, d)+ m, 0. ,1.)); \n}\n\nvoid DrawStemLeave(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    uv.y += pow(vUv/len, 2.)*4.;\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n          m   += step(len, vUv/v2);\n          \n          size *= smoothstep(0.5, 0.0, abs(vUv - 0.5)/len) *0.5;\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.01, d)+ m, 0. ,1.)); \n}\n\n\nvoid DrawPetals(vec2 uv, inout vec3 col, float seed, float offset, vec3 petalColor)\n{\n     float leavesSpread = 0.35;\n     vec2  petalSpace = vec2(fract((offset+ uv.x)* 6.28318530718 *leavesSpread), uv.y);\n     float petalSpaceID = floor((uv.x+offset)* 6.28318530718 * leavesSpread);\n     float petalLength = 1.;\n     float petalThickness = smoothstep(-0.01, 1., pow( (1.-(petalSpace.y / petalLength)), 0.85)) *0.9\n                          - smoothstep(0.7,0., petalSpace.y / petalLength);\n     petalSpace.x += sin((petalSpace.y + randOneD(petalSpaceID + seed) * TWO_PI )*4. )*0.3 * smoothstep(0.5, 1., (petalSpace.y / petalLength));                  \n     \n     vec3 drawnLeaves = col;\n     DrawHalfVectorWithLength(vec2(0.5, 0.), vec2(0.,1.), 1., petalSpace, petalThickness,  petalColor, col);\n     \n}\n\n\nvoid DrawSunFlower(vec2 uv, float seed, inout vec3 col, float mask)\n{\n\n    float noisetexture =  pow((texture(iChannel0,uv*0.8)).x ,   2.)*0.1;\n    \n    DrawHalfVectorWithLength(vec2(0.), vec2(0.,-1.), 7., uv, 0.15, SunflowerStem + noisetexture, col);\n    \n    DrawStemLeave(vec2(0.,-2.+ randOneD(seed+5.125) *-2.),\n    normalize(vec2(max(0.2,randOneD(seed+712.125)),(randOneD(seed+81.215) -0.3) * 0.3)), 5., uv, 0.3 +randOneD(seed+12.125) *0.4 , SunflowerStemBright + noisetexture, col);\n    \n        DrawStemLeave(vec2(0.,-3.+ randOneD(seed+61.125) *-2.),\n    normalize(vec2(-1.0 * max(0.2,randOneD(seed+4.25)),(randOneD(seed+73.25) -0.3) * 0.3)), 5., uv, 0.3 + randOneD(seed+0.125) * 0.4, SunflowerStem + noisetexture, col);\n    \n    uv = vec2(atan(uv.y,uv.x), length(uv) * 0.55);\n     vec3 DrawnFlower= col;\n    vec2 fUV = fract(uv* 4.);\n    vec2 iUV = floor(uv* 4.);\n    \n    \n     vec2 disToCenter = abs( fUV - vec2(0.5));\n     \n     DrawPetals(uv, DrawnFlower, 53.126 + seed, +0.4 + randOneD(seed), SunflowerLeavesTwo + noisetexture);\n     DrawPetals(uv, DrawnFlower, 0. + seed, randOneD(seed+7.125)*-0.5, SunflowerLeavesOne + noisetexture);\n\n     \n     DrawnFlower = mix(DrawnFlower, SunflowerInsideOne    + noisetexture *1.4,smoothstep(lineSize, lineSize + smoothing, 0.45 - uv.y));\n     DrawnFlower = mix(DrawnFlower, \n     mix(SunflowerInsideTwo, SunflowerInsideThree, noisetexture*5. * smoothstep(lineSize, lineSize + smoothing, 0.16 - uv.y)),\n     smoothstep(lineSize, lineSize + smoothing, 0.20 - uv.y));\n     DrawnFlower = mix(DrawnFlower, SunflowerInsideThree  + noisetexture,smoothstep(lineSize, lineSize + smoothing, 0.075 - uv.y));\n     \n     col = mix(col, DrawnFlower, mask);\n     \n\n}\n\n\nvoid DrawSunFlowerField(vec2 OG_UV, float seed, vec2 offset, float fieldMask, float totalMovementSpeed, inout vec3 col,float tiling)\n{\n\n     \n     OG_UV += offset;\n     OG_UV.x += iTime *totalMovementSpeed;\n     vec2  flowerRepeatedSpace = vec2(fract(OG_UV.x*tiling), OG_UV.y*tiling);\n     vec2  idFlowerCoord = vec2(floor(OG_UV.x*tiling), seed*21.215);\n     flowerRepeatedSpace -= vec2(0.5) + vec2(0.15,0.5) *(randOneD (dot(idFlowerCoord , vec2(1.126, 26.6))) - 0.5) ;\n     flowerRepeatedSpace *= 4. + 0.2 *(randOneD (dot(idFlowerCoord , vec2(8.136, 5.316))) - 0.5);\n     \n     DrawSunFlower(flowerRepeatedSpace, randOneD (dot(idFlowerCoord , vec2(21.126, 8.3216))), col,fieldMask );\n    \n}\n\nfloat mapLinear(float a, float b, float x){ return (b-x)/(b-a);}\n\n\nvoid DrawMountain(float movementSpeed, vec2 uv, inout vec3 col, float amplitude, float period, float translateY, float funcOffset, float translateX , float Seed\n, vec3 mountainColor){\n    \n    float movement = iTime  * movementSpeed;\n    \n    mountainColor +=(1.-texture(iChannel0,(uv + vec2(movement, 0.))*1.5)).x*0.1;\n    \n    float mountainOne = ConcateTriangularWaves(amplitude, period, translateX + movement , translateY, Seed, uv.x); \n    col = mix(col, mountainColor ,smoothstep(lineSize, lineSize + smoothing, mountainOne +funcOffset - uv.y));\n    \n\n}\n\nvoid DrawCloudLayer(inout vec3 col, float seed, vec2 uv, float tilingCloud, float amplitude, float period, float offsetY, float offsetX ){\n    \n    uv.x += offsetX;\n    \n    float noise = pow((texture(iChannel0,uv*1.1)).x ,   2.)*0.1;\n    \n    seed+=floor(uv.x *tilingCloud);\n    \n    vec2 cloudsCoord = vec2(fract(uv.x*tilingCloud), uv.y);\n    cloudsCoord.x -= 0.5;\n    cloudsCoord.y += -0.8 + (randOneD(floor(uv.x *tilingCloud)) - 0.5)* 0.25;\n    \n    float Contcatedcloud = ConcateClouds(amplitude, period, offsetX*0.1, offsetY, seed, cloudsCoord.x);\n    \n    \n    Contcatedcloud *= smoothstep(0.5, 0.4, abs(cloudsCoord.x));\n    vec3 cloudColor = mix(Clouddark, CloudLight, smoothstep(0.3,0.9, cloudsCoord.y/ Contcatedcloud));\n    cloudColor += noise;\n    col = mix( col, cloudColor, smoothstep(0., smoothing, Contcatedcloud - cloudsCoord.y) \n    * smoothstep(0.0,smoothing*5., cloudsCoord.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    \n    uv.x *=iResolution.x/iResolution.y;\n    uv *= 5.;\n   \n    \n\n    \n    vec3 col = mix(skyButton, skyColor, smoothstep(0., 1.5, uv.y)) ;\n    \n \n    \n    col += pow((texture(iChannel0,uv*1.2)).x ,   2.)*0.05;\n\n    \n    \n    \n    \n    float totalMovementSpeed = 0.15;\n    \n    float movement =  iTime  * totalMovementSpeed;\n    \n      DrawCloudLayer(col, 12.21, uv,  0.015, 0.5, 5., +0.0 ,movement * 0.1 );\n     DrawCloudLayer(col, 0.,     uv,  0.015, 0.7, 8.76, -0.05 ,movement * 0.16 );\n     \n     \n    DrawMountain(totalMovementSpeed * 0.2, uv, col, 0.2, 0.12, -0.11, 1.25, 1.216, 1.,MountainsLayerOneCol);\n    DrawMountain(totalMovementSpeed * 0.5, uv, col, 0.16, 0.16, -0.12, 0.85, 0., 2.125, MountainsLayerTwoCol);\n    DrawMountain(totalMovementSpeed * 1., uv, col, 0.5, 0.08, -0.135, 0.4, -0.612, 52.125, MountainLayerThreecol);\n    DrawMountain(totalMovementSpeed * 1., uv, col, 0.5, 0.08, -0.135, 0.4, 0., 2.723, MountainLayerFourCol);\n    \n  \n     \n     \n     float fieldMask = smoothstep(lineSize, lineSize + smoothing*4., 0.1 - uv.y);\n     \n     vec3 fieldBaseColor = col;\n     fieldBaseColor = mix(FieldMid + pow((texture(iChannel0,(uv + vec2(movement * 4.7,0.))*1.2)).x ,   2.)*0.05   ,\n              SunflowerLeavesOne + pow((texture(iChannel0,(uv + vec2(movement*1.,0.))*1.2)).x ,   2.)*0.05\n              , smoothstep(-0.2, 0.0, uv.y));\n     fieldBaseColor = mix(fieldBaseColor,\n     FieldDark + pow((texture(iChannel0,(uv + vec2(movement*6.2,0.))*1.2)).x ,   2.)*0.05\n     , smoothstep(-0.6, -1.4, uv.y));\n     \n    \n     \n     col = mix(col,  fieldBaseColor ,fieldMask);\n     \n     \n     \n     \n\n vec2 OG_UV = fragCoord/iResolution.xy;\n      OG_UV.x *=iResolution.x/iResolution.y;\n    \n      \n      DrawSunFlowerField(OG_UV, 0., vec2(0.51,-0.48),    fieldMask,  totalMovementSpeed, col, 90.);\n      totalMovementSpeed *= 1.1;\n      DrawSunFlowerField(OG_UV, 6.621, vec2(0.51,-0.46), fieldMask,  totalMovementSpeed, col, 50.);\n      totalMovementSpeed *= 1.1;\n      DrawSunFlowerField(OG_UV, 7.23, vec2(0.51,-0.43),  fieldMask,  totalMovementSpeed, col, 29.);\n      totalMovementSpeed *= 1.1;\n      DrawSunFlowerField(OG_UV, 12.6, vec2(0.51,-0.4),   fieldMask,  totalMovementSpeed, col, 22.);\n      totalMovementSpeed *= 1.1;\n      DrawSunFlowerField(OG_UV, -7.21, vec2(0.51,-0.35), fieldMask,  totalMovementSpeed, col, 15.);\n      totalMovementSpeed *= 1.1;\n      DrawSunFlowerField(OG_UV, 2.125, vec2(0.51,-0.3),  fieldMask,  totalMovementSpeed, col, 12.);\n      totalMovementSpeed *= 1.2;\n      DrawSunFlowerField(OG_UV, 1., vec2(1.126,-0.2),    fieldMask,  totalMovementSpeed, col, 8.);\n      totalMovementSpeed *= 1.2;\n      DrawSunFlowerField(OG_UV, 5., vec2(0.,-0.05),      fieldMask,  totalMovementSpeed, col, 4.);\n      totalMovementSpeed *= 1.3;\n      DrawSunFlowerField(OG_UV, 71.612, vec2(0.,0.1),    fieldMask,  totalMovementSpeed, col, 3.);\n     \n    \n     \n     \n    // Output to screen\n    fragColor = vec4(col,1.0); \n    \n    /*\n//--------------------------------------------------    \n// SLIDE Three Domain Repition \n  vec2 uv = fragCoord/iResolution.xy;\n   float y = uv.y;\n    uv -= vec2(0.5,0.5);\n    \n    uv.x *=iResolution.x/iResolution.y;\n    uv *= 5.;\n   \n    \n    \n    \n    vec3 col = vec3( 0.0);\n    \n    vec2 fUV = fract(uv* 4.);\n    vec2 iUV = floor(uv* 4.);\n    \n    \n   vec2 disToCenter = abs( fUV - vec2(0.5));\n    \n  \n    \n    if(max(disToCenter.x, disToCenter.y)> 0.45) col = vec3(0.1);\n    \n\n     \n    col = vec3(fract(uv.x), fract(uv.y), 0. ) ;\n\n\n     \n    // Output to screen\n    fragColor = vec4(col,1.0); */\n    \n    \n//--------------------------------------------------    \n// SLIDE TWO SUPER IMPOSITION WAVES\n /* vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    \n    uv.x *=iResolution.x/iResolution.y;\n    uv *= 5.;\n   \n    \n    \n    \n    vec3 col = vec3( 0.0);\n    \n    vec2 fUV = fract(uv* 4.);\n    vec2 iUV = floor(uv* 4.);\n    \n    \n   vec2 disToCenter = abs( fUV - vec2(0.5));\n    \n  \n    \n    if(max(disToCenter.x, disToCenter.y)> 0.45) col = vec3(0.1);\n    \n     \n    float curveOne =  sin((uv.x+ iTime) *0.75 )* 0.7 ;\n    col = mix(vec3(0.1,0.9,0.), col,smoothstep(lineSize, lineSize + smoothing, abs(curveOne + 1.5 - uv.y)));\n     \n    float curveTwo =  sin((uv.x+ iTime) *3.)* 0.25 ;\n    col = mix(vec3(0.9,0.3,0.), col,smoothstep(lineSize, lineSize + smoothing, abs(curveTwo + 0.1 - uv.y)));\n     \n     \n    col = mix(vec3(1.,0.86,0.), col,smoothstep(lineSize, lineSize + smoothing, abs(curveTwo + curveOne -1.5 - uv.y)));\n     \n    // Output to screen\n    fragColor = vec4(col,1.0); */\n    \n//--------------------------------------------------\n/*\n\n// SLIDE ONE\n// DRAWING THE FILLING GRID\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *=iResolution.x/iResolution.y;\n    \n    uv -= vec2(0.8,0.45);\n    \n    uv *= 1.2;\n    vec2 fUV = fract(uv* 16.);\n    vec2 iUV = floor(uv* 16.);\n    \n    vec3 col = vec3( 0.5);\n     col = mix(col, vec3( iUV.xy/16.,0.), (((iUV.x+8.) + (iUV.y + 7.)*16.)< mod(iTime * 60., 296.)) ? 1.: 0.  );\n\n    vec2 disToCenter = abs( fUV - vec2(0.5));\n    \n    if(max(disToCenter.x, disToCenter.y)> 0.45) col = vec3(1.);\n    if(iUV.x >= 9. || iUV.y >= 9. || iUV.x <= -8. || iUV.y <= -8.) col = vec3(0.);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);*/\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1076, 1076, 1107, 1107, 1148], [1151, 1151, 1175, 1175, 1215], [1218, 1218, 1327, 1327, 1601], [1604, 1604, 1722, 1722, 2001], [2003, 2003, 2095, 2095, 2266], [2267, 2267, 2394, 2394, 2739], [2741, 2741, 2857, 2857, 3311], [3314, 3314, 3399, 3399, 4118], [4121, 4121, 4190, 4190, 5826], [5829, 5829, 5963, 5963, 6520], [6522, 6522, 6565, 6565, 6586], [6589, 6589, 6772, 6772, 7148], [7150, 7150, 7288, 7288, 8049], [8051, 8051, 8108, 8108, 13460]], "test": "untested"}
{"id": "mscyWM", "name": "Ziggurat of Hilbert", "author": "dr2", "description": "Perhaps the ancients discovered the Hilbert curve first (mouseable)", "tags": ["fractal", "architecture", "babylon"], "likes": 33, "viewed": 326, "published": 3, "date": "1695118003", "time_retrieved": "2024-07-30T17:32:57.375493", "image_code": "// \"Ziggurat of Hilbert\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nvec3 HsvToRgb (vec3 c);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst int nBall = 41;\nvec3 bPos[nBall], pNeb[2], sunDir, qHit;\nvec2 gId, gIdL, csFlor;\nfloat tCur, dstFar, hbSize, wexSize, hInd, cHt, bRad, vFac, iQuad, hFac;\nint nFrame, idObj, ballNum;\nconst int idPil = 1, idWal = 2, idRamp = 3, idPyr = 4, idWalEx = 5, idGrnd = 6, idBall = 10;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nint HilXy2D (ivec2 p, int n)\n{ // (Hilbert indexing from \"Hilbert's Path\" - with bit ops)\n  ivec2 r;\n  int j, td, d;\n  d = 0;\n  td = 1;\n  for (j = n >> 1; j > 1; j >>= 1) td <<= 1;\n  for (j = n >> 1; j >= 1; j >>= 1) {\n    r = (p / td) & 1;\n    d += j * j * ((r.y == 0) ? 3 * r.x : (3 * r.x) ^ 1);\n    if (r.y == 0) {\n      if (r.x != 0) p = n - 1 - p;\n      p = p.yx;\n    }\n    td >>= 1;\n  }\n  return d;\n}\n\nivec2 HilD2Xy (int d, int n)\n{\n  ivec2 p, r;\n  int j, td;\n  td = d;\n  p = ivec2 (0);\n  for (j = 1; j < n; j <<= 1) {\n    r.x = (td >> 1) & 1;\n    r.y = ((r.x == 0) ? td : td ^ 1) & 1;\n    if (r.y == 0) {\n      if (r.x != 0) p = j - 1 - p;\n      p = p.yx;\n    }\n    p += j * r;\n    td >>= 2;\n  }\n  return p;\n}\n\n#define HT(v) 4. * hFac * (1. - Maxv2 (abs ((v) / hbSize - 1.)))\n\nvoid SetGParm ()\n{\n  vec2 gIdLL, g;\n  float bb, iq, hi;\n  int ic, ib;\n  ib = int (hbSize);\n  gIdL = gId;\n  iQuad = step (hbSize, gIdL.x) + 2. * step (hbSize, gIdL.y);\n  if (gIdL.x >= hbSize) gIdL.x -= hbSize;\n  if (gIdL.y >= hbSize) gIdL.y -= hbSize;\n  gIdLL = gIdL;\n  if (iQuad < 2.) gIdLL.y = hbSize - 1. - gIdLL.y;\n  ic = HilXy2D (ivec2 (gIdLL), ib);\n  hInd = float (ic) + iQuad * hbSize * hbSize;\n  if (iQuad < 2.) hInd = 2. * hbSize * hbSize - 1. - hInd;\n  cHt = HT (gId + 0.5);\n  bb = hbSize * hbSize;\n  for (int k = 0; k < 2; k ++) {\n    hi = mod (hInd + 1e-3 + sign (float (k) - 0.5), 4. * bb);\n    iq = step (bb, abs (hi - 2. * bb)) + 2. * step (2. * bb, hi);\n    ic = int (mod (mod (hi, bb) * ((iq == 0. || iq == 3.) ? 1. : -1.), bb));\n    g = (vec2 (HilD2Xy (ic, ib)) + 0.5) * vec2 ((iq == 1. || iq == 3.) ? 1. : -1.,\n       (iq == 2. || iq == 3.) ? 1. : -1.);\n    pNeb[k].xz = g - (gId + 0.5) + hbSize;\n    pNeb[k].y = HT (pNeb[k].xz + gId + 0.5);\n  }\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q, qq, ds;\n  float dMin, d, h, hf, sx;\n  dMin = dstFar;\n  p.y -= 0.7;\n  if (Minv2 (gIdL) >= 0. && Maxv2 (gIdL) < hbSize) {\n    q = p;\n    hf = dot (vec2 (q.y, - Maxv2 (abs (q.xz - hbSize)) + hbSize), csFlor) + 0.3;\n    d = abs (hf) - 0.05;\n    DMINQ (idPyr);\n    q = p;\n    q.xz -= hbSize * vec2 (step (abs (abs (iQuad - 2.) - 1.), 0.), step (2., iQuad)) + gIdL + 0.5;\n    if (iQuad < 2.) q.z *= -1.;\n    d = max (SmoothMax (PrBox2Df (q.xz, vec2 (0.2)), q.y - cHt - 0.2, 0.01), - hf);\n    DMINQ (idPil);\n    qq = q;\n    qq.y -= 0.07;\n    q = qq;\n    d = min (PrBox2Df (q.xz - 0.5 * pNeb[0].xz * vec2 (1., sign (iQuad - 1.5)), vec2 (0.2)),\n       PrBox2Df (q.xz - 0.5 * pNeb[1].xz * vec2 (1., sign (iQuad - 1.5)), vec2 (0.2)));\n    d = max (SmoothMax (hf - 0.2, SmoothMax (- PrBox2Df (q.xz, vec2 (0.45)), - d, 0.01), 0.01), - hf);\n    DMINQ (idWal);\n    for (int k = 0; k < 2; k ++) {\n      ds = vec3 (pNeb[k].xz * vec2 (1., sign (iQuad - 1.5)), pNeb[k].y + cHt + 0.05).xzy;\n      q = qq - 0.5 * ds;\n      q.xz = mix (q.xz, q.zx, step (abs (ds.z), abs (ds.x)));\n      sx = (abs (ds.x) > abs (ds.z)) ? sign (ds.x) : sign (ds.z);\n      d = SmoothMax (PrBox2Df (q.xz, vec2 (0.1, 0.3)), - dot (q.yz, CosSin (atan (pNeb[k].y - cHt,\n         -0.55 * sx))) * sx - 0.01, 0.01);\n      d = max (SmoothMax (d, 0.23 - length (vec2 (abs (q.z) + 0.12, max (q.y + 0.4, 0.))),\n         0.01), - hf);\n      DMINQ (idRamp);\n    }\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  float dHit, d, s, sb, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 1e-4;\n  if (rd.z == 0.) rd.z = 1e-4;\n  rdi.xz = 1. / rd.xz;\n  eps = 0.002;\n  cNu = true;\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    if (cNu) {\n      gId = floor (p.xz);\n      sb = Minv2 ((gId + step (0., rd.xz) - ro.xz) * rdi.xz);\n      SetGParm ();\n      cNu = false;\n    }\n    d = GObjDf (p);\n    s = max (dHit, sb);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 2e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = floor (p.xz);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGParm ();\n    }\n    h = GObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - vec3 (vec2 (hbSize), 0.15).xzy;\n  q.xz = mix (q.xz, q.zx, step (abs (q.z), abs (q.x)));\n  d = SmoothMax (PrBox2Df (vec2 (q.x, abs (q.z) - (hbSize + 0.1)), vec2 (hbSize + 4.1, 0.1)),\n     abs (q.y) - 0.35, 0.02);\n  DMINQ (idWalEx);\n  q.y -= 0.65;\n  d = SmoothMax (PrBox2Df (vec2 (q.x, abs (q.z) - wexSize), vec2 (wexSize + 0.2, 0.2)),\n     abs (q.y) - 1., 0.02);\n  if (abs (q.x) < wexSize - 0.5) d = SmoothMax (d, min (0.5 - length (vec2 (abs (fract (q.x +\n     0.5) - 0.5) + 0.2, max (q.y - 0.2, 0.))), q.y + 0.7), 0.02);\n  DMINQ (idWalEx);\n  q = p;\n  q.xz -= vec2 (hbSize);\n  d = q.y;\n  DMINQ (idGrnd);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 2e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid BPos ()\n{  // (from \"Looping Hilbertian Saltation\")\n  vec3 bp[2];\n  vec2 g;\n  float tc, t, bb, iq;\n  int ib, ic;\n  ib = int (hbSize);\n  bb = hbSize * hbSize;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    tc = 1e-3 + vFac * tCur + (float (k) / float (nBall)) * 4. * bb;\n    for (int j = 0; j < 2; j ++) {\n      t = mod (tc + float (j), 4. * bb);\n      iq = step (bb, abs (t - 2. * bb)) + 2. * step (2. * bb, t);\n      ic = int (mod (mod (t, bb) * ((iq == 0. || iq == 3.) ? 1. : -1.), bb));\n      g = (vec2 (HilD2Xy (ic, ib)) + 0.5) * vec2 ((iq == 1. || iq == 3.) ? 1. : -1.,\n         (iq == 2. || iq == 3.) ? 1. : -1.);\n      bp[j].xz = g + hbSize;\n      bp[j].y = HT (bp[j].xz) + 0.7;\n    }\n    t = clamp (1.3 * fract (tc) - 0.15, 0., 1.);\n    bPos[k] = mix (bp[0], bp[1], t);\n    bPos[k].y += bRad + 0.2 + 2. * t * (1. - t);\n  }\n}\n\nvec4 BallHit (vec3 ro, vec3 rd)\n{\n  vec3 u, vn;\n  float dMin, d, b, w;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    u = ro - bPos[k];\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + bRad * bRad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vn = (u + d * rd) / bRad;\n        ballNum = k;\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec3 u;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    u = ro - bPos[k];\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + bRad * bRad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return 0.5 + 0.5 * smoothstep (0., rng, dMin);\n}\n\nfloat BlkHitSil (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 BallCol (int k)\n{\n  return HsvToRgb (vec3 (fract (4. * float (k) / float (nBall)), 0.7, 1.));\n}\n\nfloat GrndHt (vec2 p)\n{\n  float s, h;\n  s = PrBox2Df (qHit.xz, vec2 (wexSize));\n  h = (s < 0.) ? 0.03 * (0.5 - 0.5 * sin (8. * pi * s)) :  0.2 * Fbm2 (0.05 * p);\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = 0.7 * (0.8 + 0.5 * ff) * (vec3 (1.) - vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  sd = max (dot (rd, sunDir), 0.);\n  fd = smoothstep (0.01, 0.1, rd.y);\n  skCol = mix (vec3 (0.8, 0.8, 0.75), vec3 (0.3, 0.4, 0.7), 0.3 + 0.7 * fd) +\n     step (0.1, sd) * vec3 (1., 1., 0.9) * min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n  col = mix (skCol, clCol, 0.1 + 0.9 * f * fd);\n  return 0.9 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitG;\n  vec2 b, vf;\n  float dstObj, dstObjG, db, s, sh;\n  int idObjG;\n  hFac = (hbSize == 8.) ? 1.5 : 1.;\n  csFlor = CosSin (- ((hbSize == 4.) ? 0.24 : 0.2) * pi);\n  vFac = 0.5;\n  bRad = 0.2;\n  BPos ();\n  db = BlkHitSil (ro - vec3 (vec2 (hbSize), 2.5 * hFac + 0.7).xzy, rd, vec3 (vec2 (hbSize + 0.2),\n     2.7 * hFac).xzy);\n  if (db < dstFar) {\n    dstObjG = GObjRay (ro, rd);\n    idObjG = idObj;\n    qHitG = qHit;\n    db4 = BallHit (ro, rd);\n  } else {\n    dstObjG = dstFar;\n    db4.x = dstFar;\n  }\n  dstObj = ObjRay (ro, rd);\n  if (min (db4.x, dstObjG)  < min (dstObj, dstFar)) {\n    if (db4.x < dstObjG) {\n      dstObj = db4.x;\n      idObj = idBall + ballNum;\n    } else {\n      dstObj = dstObjG;\n      idObj = idObjG;\n      qHit = qHitG;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjG) {\n      vn = GObjNf (ro);\n    } else if (idObj < idBall) {\n      vn = (idObj == idGrnd) ? GrndNf (ro) : ObjNf (ro);\n    } else {\n      vn = db4.yzw;\n    }\n    vf = vec2 (0.);\n    if (idObj == idPil) {\n      col4 = vec4 (1., 1., 1., 0.1);\n      s = length (qHit.xz);\n      if (s < 0.2) col4 *= 0.93 + 0.07 * sin (32. * pi * s);\n    } else if (idObj == idRamp) {\n      col4 = vec4 (0.95, 1., 0.95, 0.1);\n      if (vn.y > 0.99) col4 *= 0.8 + 0.2 * smoothstep (0.07, 0.1, abs (fract (16. * qHit.z) - 0.5));\n      else if (vn.y > 0.1) col4 *= 0.8 + 0.2 * smoothstep (0.07, 0.1, abs (fract (16. * qHit.y) - 0.5));\n    } else if (idObj == idWal) {\n      col4 = 0.9 * vec4 (1., 0.95, 0.95, 0.1);\n    } else if (idObj == idWalEx) {\n      col4 = 0.9 * vec4 (1., 0.95, 0.95, 0.1);\n      vf = vec2 (16., 0.5);\n    } else if (idObj == idPyr) {\n      col4 = 0.8 * vec4 (1., 1., 0.9, 0.1);\n      vf = vec2 (32., 0.3);\n    } else if (idObj == idGrnd) {\n      col4 = 0.9 * vec4 (1., 1., 0.8, 0.);\n      s = PrBox2Df (qHit.xz, vec2 (wexSize));\n      col4 *= 1. - 0.07 * ((s < 0.) ? (0.5 - 0.5 * sin (8. * pi * s)) : Fbm2 (0.05 * ro.xz));\n      vf = vec2 (8., 0.5);\n      col4 *= 1. - 0.1 * Fbm2 (16. * ro.xz);\n    } else if (idObj >= idBall) {\n      col4 = vec4 (BallCol (idObj - idBall), -1.);\n    }\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      sh = min (min (GObjSShadow (ro + 0.01 * vn, sunDir), ObjSShadow (ro + 0.01 * vn, sunDir)),\n         BallHitSh (ro + 0.01 * vn, sunDir, 8.));\n      col = col4.rgb * (0.15 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.7 * sh * max (dot (vn, sunDir), 0.)) +\n        col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    } else col = col4.rgb * (0.4 + 0.6 * max (- dot (vn, rd), 0.));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    col = 0.9 * vec3 (1., 1., 0.8) * (0.15 + 0.7 * sunDir.y);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) {\n    col *= 1. - 0.15 * smoothstep (0.5, 0.7, Fbm2 (0.05 * ro.xz - 0.05 * tCur));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  zmFac = 5.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    zmFac += smoothstep (0.2, 0.5, abs (az)) * min (4. * abs (az), 4.);\n    el = pi * mPtr.y;\n  }\n  el -= 0.12 * pi;\n  el = clamp (el, -0.5 * pi, -0.03 * pi);\n  vuMat = StdVuMat (el, az);\n  hbSize = 8.; //4.;\n  wexSize = hbSize + 4.;\n  ro = vuMat * vec3 (0., 0.5, -6. * hbSize);\n  ro.xz += hbSize;\n  ro.y = max (ro.y, 0.1);\n  dstFar = 300.;\n  sunDir = normalize (vec3 (0.8, 0.9, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscyWM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[943, 943, 973, 1032, 1349], [1351, 1351, 1381, 1381, 1659], [1727, 1727, 1745, 1745, 2692], [2694, 2694, 2717, 2717, 4156], [4158, 4158, 4192, 4192, 4826], [4828, 4828, 4850, 4850, 5107], [5109, 5109, 5147, 5147, 5524], [5526, 5526, 5548, 5548, 6223], [6225, 6225, 6258, 6258, 6441], [6443, 6443, 6464, 6464, 6720], [6722, 6722, 6759, 6759, 6988], [7830, 7830, 7863, 7863, 8241], [8243, 8243, 8290, 8290, 8614], [8616, 8616, 8661, 8661, 8843], [8845, 8845, 8867, 8867, 8945], [8947, 8947, 8970, 8970, 9122], [9124, 9124, 9146, 9146, 9290], [9292, 9292, 9324, 9324, 10016], [10018, 10018, 10053, 10053, 13034], [13036, 13036, 13092, 13092, 14288], [14290, 14290, 14323, 14323, 14412], [14414, 14414, 14459, 14459, 14551], [14553, 14553, 14598, 14598, 14636], [14638, 14638, 14662, 14662, 14784], [14786, 14786, 14808, 14808, 14835], [14837, 14837, 14859, 14859, 14886], [14888, 14888, 14910, 14910, 14948], [14950, 14950, 14972, 14972, 15010], [15012, 15012, 15048, 15048, 15254], [15256, 15256, 15286, 15286, 15399], [15433, 15433, 15457, 15457, 15584], [15586, 15586, 15611, 15611, 15795], [15797, 15797, 15818, 15818, 15973], [15975, 15975, 16004, 16004, 16216], [16218, 16218, 16257, 16257, 16509]], "test": "untested"}
{"id": "csccW7", "name": "Pixel Cavern", "author": "rcargou", "description": "Thoses are not voxels by any mean, but a bunchs of rounded boxes elongated along Y axis with domain repetition, its makes it able to have smooth heights variation while keeping a voxely feelings. Enjoy :)\nIqs voronoi: https://www.shadertoy.com/view/ldl3W8", "tags": ["raymarching"], "likes": 49, "viewed": 619, "published": 3, "date": "1695117384", "time_retrieved": "2024-07-30T17:32:58.542373", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nvec2 guv;\nvec4 id = vec4(0.);\nvec2 map( in vec3 pos )\n{\n   \n //pos=abs(pos);\n// pos.xy*=rotate2d(iTime / 5.);\n //pos.xy=abs(pos.xy);\n     pos.x+=3.1;\n          \n     float sh = sin(pos.z / 12. + iTime) * 4.;\n     pos.y+= sh;\n\n\n     pos.xy *= rotate2d(-(pos.z) * .1 *   .02);\n vec3 p2 = pos;\n    vec2 res = vec2( 1e10, 0.0 ); pos.z+=iTime * 43.5;\n    vec2 uv = pos.xz;\n    uv.y += step(.0, pos.y) * 200.;\n    uv.x += step(.0, pos.y) * 200.;\n\n    guv = uv;\n     \n    //pos.y += pos.z / 3.;\n    pos.y+=.0;\n   \n    pos.y = abs(pos.y - .0);\n    id.x = pow((pos.y - sh), 1.) / 16.;\n   //pos.y*=-1.;\n    float d = 35.+ 5.*sin(iTime);;\n    float dd = 7.;\n id.z = 1.*smoothstep(d-dd,d, pos.y) * smoothstep(d+dd,d, pos.y);\n\n    pos.y-=0.5;\n    float r = 1.3;// + abs(sin(iTime ));\n    float s = r/2.;\n    id.y = hash22(floor(pos.xz / r)).x;\n   \n    float off = 0.;\n    if (mod(floor(id.y * 121.), 32.) == 1.)\n        off = 0.2; \n    pos.xz = mod(pos.xz, r) - r/ 2.;\n    float s2= 2.;\n\n    \n    pos.y -= 33.5 + 5.*sin(iTime);\n    //pos.xy /= 4.5;\n    //r = 1.;\n    float f = 1.;\n    float h = 5.*(texture(iChannel0, vec2(iTime / 64.,0.)+f*(floor((uv.xy) / r) * r)  / 522. - vec2(.5)).x + .0);\n    float h2 = 1.25*(texture(iChannel2, 1.5*f*(floor((uv.xy) / r) * r)  / 522. - vec2(.5)).x + .0);\n    float r2 = 11.;\n    vec2 pp = mod(guv, r2) - r2/2.;\n   // h += 2.*smoothstep(5., 1., .6*length(pp));\n    float quant = 15.;\n    //h2=pow(h2, 2.) / 4.;\n  \n    h = .5*(h+pow(h/2., 2.)) + off;\n    float beat = pow( abs(sin(iTime / 1.)), 3.);\n    h = .1+5.*floor(h * quant) / quant + (h2*2.) * beat;\n    // h = pow(h, 1.05);\n    //id.x =h / 8.;//\n    if ((res.x = box(pos, vec3(s, h, s), .2)) < .0f )\n        res.y = 1.0f;\n\n    return res;\n}\n\nconst float maxHei = 0.8;\nfloat hit = 0.;\nfloat hidist = .1;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 2000.0;\n    float lastid = -1.;\n   // float id;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<100 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t);\n            \n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            } else if( abs(h.x)<(0.002*t) && id.y != lastid)\n            { \n            \n///                hit =1.;\n            }\n            t += h.x * .5;\n            lastid = id.y;\n        }\n    }\n\n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 getLight(vec3 p) {\n    float r = 30.;\n  //  return vec3(mod(p.x, 12.), 0., 90. + cos(iTime / 2.) * 172.);\n    return vec3(floor( (p.x +r/2.) / r) * r  + sin(iTime), 0., 120. + cos(iTime / 2.) * 122.);\n}\n\nvec3 light(vec3 p, vec3 rd, vec3 n, vec3 lightPos, vec3 lightCol) {\n    \n    float radius = .003;\n    float l = length(lightPos - p);\n    float ndotl = max(0., dot(n, normalize(lightPos - p)) );\n    return lightCol * ndotl / max(1., l*l*radius);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n    return light(p, rd, n, getLight(p), 1.*vec3(.9, .1, .84));\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    float bloom = 0.;\n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + res.x * rd;\n    vec3 n = calcNormal(p);\n    float ao = calcAO(p,n); \n    vec3 albedo = texture(iChannel2, guv/ 2. + p.y).xyz;\n    vec3 pminusl = normalize(-p-normalize(vec3(11.0f, 11.0f, 0.0f)));\n    vec3 bg = 1.*vec3(1.13, .54, 2.3);\n    float shadow = 1.;//.5+.5*calcSoftshadow(p, normalize(vec3(.0f, .0f, -1.0f)), .1, 5.);\n    vec3 ref = reflect(normalize(p-ro), n);\n    float spec = pow(max(0., dot(ref, vec3(.0f, .0f, -1.0f)) ), 5.) * .5;\n    albedo = vec3(.5);\n\n    float v = .8*voronoi(.01*guv.xy + vec2(0. + -iTime / 8., 0.), iTime / 2.).y * 1.1;\n    albedo = .5*pal( id.x+iTime/12. + guv.y / 200., vec3(0.5,0.5,.5),vec3(0.5,0.5,0.5),vec3(.5,.5,.5),vec3(0.0,0.33,0.67) );\n    vec3 albedo2 = .5*pal( id.x-iTime/6., vec3(0.5,0.51,0.5),vec3(0.1,0.5,0.2),vec3(.2,1.,.2),vec3(0.0,0.33,0.67) );\n   vec3 reff = reflect(rd, n);\n   \n   vec3 refcol = texture(iChannel1, reff.xz / 2.).xyz;\n\n   if (mod(floor(id.y * 121.), 32.) == 1.) {\n \n       albedo*=5.;\n       bloom = 10.;\n       \n       }\n\n   //ao=.1;\n   \n    col = bg;\n    if (res.x > .0f) {\n    \tcol = vec3(ao/5.) + 1.*shadow*albedo * max(.1, dot(pminusl, \n                             calcNormal(ro + rd*t)) );\n        col *= vec3(0.5);                         \n         //col += lights(p, rd,n);\n         col+=bg*spec;\n          col += albedo2*id.z / 1.2;\n        col*=1.5+(v*v*v/.01) * albedo;\n        //col=pow(refcol * vec3(.2,.2,.7),vec3(2.) ) * 2.;\n       // col += vec3(pow(id.w, .5)) * vec3(0., 1., 0.);\n        col = mix(col, bg, min(1., pow(res.x / 450., 1.5) ));\n        \n        bloom += id.z * 10.;\n        //col *= 1.+ smoothstep(1.2, 2.5, abs( p.y - .1) ) ;\n       \n                      }    \n    // return albedo;\n    //return vec3(id.w);\n   \treturn vec3(col);\n    return abs(n / 10.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, -sin(iTime) / 15., -0.0f);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0., 0.5, .5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p.xy,.5) ) * ca;\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col / 1., vec3(.8545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\tvec2 q = fragCoord / iResolution.xy;\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 1.5 );\n   // tot = vec3(voronoi(p.xy*8., iTime));\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\nvec3 voronoi( in vec2 x , float time)\n{\n\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n\t\n        o = 0.5 + 0.5*sin( time + 6.2831*o );\n    \n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n\n        o = 0.5 + 0.5*sin( time + 6.2831*o );\n\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( 1.1-pow(md,.1));\n    return vec3( md, mr );\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat box(vec3 position, vec3 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0) - cornerRadius;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}", "buffer_a_code": "\nvec3 helix(vec2 uv) {\n        // Normalized pixel coordinates (from 0 to 1)\n    float time = iTime *.4;\n    uv.x *= cos(uv.y*2.14f);\n    uv.x += sin(time * .9f) *.07f;\n    vec3 col = vec3(.0f);\n    uv *= 1.0f;\n    float i = .0f;\n      //float music = texture(iChannel0, vec2(.17f, .25f)).x;\n    float m = texture(iChannel1, vec2(.5f)).y;\n    float m1 = texture(iChannel1, vec2(.5f)).x;\n   \n    float l = mod(length(uv) + time /10.0f, 0.1f + 0.002f) +0.00f;\n    float k = floor(length(uv)*10.0f + + time / 0.7f) ;\n    \n       float a = atan(uv.y, uv.x) + sin(length(uv * 7.0f * sin(time) * sin(time))  * 1.0f);\n   // col = col * .5f + .41f * length(cos(a * 4.0f));\n    float level = 20.0f + floor(length(uv) * 10.0f);\n    level = 5.0f;\n    float h = 1.0f + cos(time*5.0f + a * level);\n    h = pow(h, 1.0f + 0.5f*m);\n    float b = length(l- 0.05f);\n   // b = pow(b, h/4.0f) / 50.0f;\n \n   col.xz +=  vec2(b*b*400.0f, b*b*200.0f);\n    col.gb +=  .5f * vec2(.5f*pow(b*b*400.0f, (1.0f + sin(time)) * 100.5f * h / (m*m)));\n    col.y +=  b*10.0f;\n    col.z += b*b*b*8000.0f*m*m*m;\n   //  col.y = l / 10.0f;\n    col.x *= h;\n    float beta = min(floor((1.0f - .5f*pow(h*h*b*b*400.0f, 10.5f * 1.0f))) * .1f * (2.5f +sin(time * 20.0f + 10.0f*length(uv))), 100.8f);\n   beta = max(beta , .0f);\n    beta *= beta * beta * m;\n    col.rgb +=2.0f *  vec3(0.8, .8f, .0f) * vec3(max(beta, .0f));\n//col.x += 1.0f / length();\n    col.g /= min(2.0f, 10.1f * (length(uv)));\n    return (col * 1.2f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(.0f);\n    for (float i = 0.0f; i < 1.0f; i += 1.0f) {\n\t\tvec2 uv = ((vec2(.0f * i) + fragCoord) - iResolution.xy /2.0f)/iResolution.yy;\n   \n    \t\tcol += helix(uv / (1.2f  + .5f + sin(0.0f / 2.0f)));\n    \n    }\n    \n    fragColor = vec4(col / 1.0f,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csccW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 279, 356, 1947], [2011, 2011, 2051, 2051, 2673], [2676, 2721, 2799, 2822, 3163], [3165, 3211, 3243, 3243, 3453], [3457, 3457, 3499, 3499, 3815], [3818, 3818, 3870, 3870, 4047], [4048, 4048, 4071, 4071, 4255], [4257, 4257, 4324, 4324, 4504], [4506, 4506, 4544, 4544, 4609], [4611, 4611, 4649, 4649, 6546]], "test": "untested"}
{"id": "mdcyR7", "name": "Oil projector", "author": "sh1boot", "description": "Simulate an oil projector with constant-volume blobs of liquid being stirred around.\n\nYet another do-over of:\nhttps://www.shadertoy.com/view/3dsBWN\nhttps://www.shadertoy.com/view/clBcDt\nhttps://www.shadertoy.com/view/Dl2fWz", "tags": ["blur", "threshold", "palette", "antialias", "blob", "bicubic", "lava", "gpmipmap"], "likes": 5, "viewed": 231, "published": 3, "date": "1695075606", "time_retrieved": "2024-07-30T17:33:06.565920", "image_code": "bool keydown(int key) {\n    return (texelFetch(iChannel3, ivec2(key,0), 0).x >= 0.5);\n}\n\n\n// a smooth maximum of all the channels down to a scalar\n// which we need to form a smooth intersection of two\n// channels so we don't get dFdx() artefacts.\nfloat foldheight(vec4 x) {\n    const float k = 8.0;\n    return log2(dot(exp2(x*k), vec4(1))) / k;\n}\n// an attempt at blending two different alpha equations\nfloat smoothmin(float x, float y) {\n    const float k = -8.0;\n    return log2(exp2(x*k) + exp2(y*k)) / k;\n}\nvec4 meniscus(vec4 x, vec2 uv) {\n    float height = foldheight(x) * 3.0;\n    height = smoothclamp(height, -1.0, 1.0);\n    // Shade the edge according to the direction it's facing.\n    float shade = cos(atan(dFdy(height), dFdx(height)) + 1.1) * 0.5 + 0.5;\n    // Alpha should be derived from slope, but that's quarter resolution,\n    // so height looks a bit smoother.\n    float alpha = min(1.0 - height, 1.0);\n\n    // Except when a peninsula isn't high enough to zero alpha, in which case\n    // we need to tamp it down some more based on slope rather than absolute\n    // height.\n    float squish = length(vec2(dFdx(height), dFdy(height)) / fwidth(uv));\n    squish = clamp(squish * 0.05, 0.0, 1.0);\n    alpha = smoothmin(alpha, squish);\n    // ... but it doesn't really work.\n    \n    return clamp(vec4(vec3(shade), alpha), 0.0, 1.0);\n}\n\n\nvec4 pal16(vec4 x) {\n    // Convert saturated (ie., approximately binary) xyzw values\n    // into a 16-colour palette.  In this case, an approximation\n    // of the C64 colour palette.  Why the C64?  I do not know.\n    // I just wanted to do away with that RGB-filter look that\n    // comes out otherwise.\n    vec3 lut[16] = vec3[16](\n        vec3(0., 0., 0.), vec3(1., 1., 1.), vec3(0., 1., 0.), vec3(.5, 0., 0.),\n        vec3(.6, 1., .9), vec3(.7, .3, .7), vec3(0., .7, .4), vec3(0., 0., .6),\n        vec3(.9, .9, .5), vec3(.8, .5, .3), vec3(1., .5, .5), vec3(.2, .2, .2),\n        vec3(.5, .5, .5), vec3(.6, 1., .7), vec3(0., .5, 1.), vec3(.8, .8, .8));\n     vec3 colour = vec3(0);\n     for (int i = 1; i < 16; ++i) {\n         float w = 1.0;\n         for (int j = 0; j < 4; ++j) {\n             w *= (i >> j & 1) != 0 ? x[j] : 1.0 - x[j];\n         }\n         colour += lut[i] * w;\n     }\n     return vec4(colour, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x + 0.5;\n\n    // Read the blurred feedback buffer, using bicubic interpolation\n    // to avoid scaling artefacts, and threshold it into a flat puddle\n    // of colour.\n    vec4 threshold = texture(iChannel1, 1.0 - 0.5 / iChannelResolution[1].xy);\n    vec4 colour = bicubictex(iChannel0, uv * dimension / iChannelResolution[0].xy,\n                             iChannelResolution[0].xy);\n    // Calculate a shading for the edge for a little bit of depth.\n    vec4 meniscus = meniscus(colour - threshold, uv);\n    // threshold, with anti-aliasing\n    colour = aastep(threshold, colour);\n\n    // debug stuff\n    if (keydown(49)) colour = texture(iChannel1, uv * dimension / iChannelResolution[1].xy);\n    if (keydown(50)) colour = texture(iChannel0, uv * dimension / iChannelResolution[0].xy);\n    if (keydown(51)) colour = cubetex(iChannel2, uv * dimension / iChannelResolution[2].xy, 0);\n    if (keydown(52)) colour = cubetex(iChannel2, uv * dimension / 16.0 / iChannelResolution[2].xy, 1);\n    if (keydown(53)) colour = cubetex(iChannel2, uv * dimension / 256.0 / iChannelResolution[2].xy, 2);\n    if (keydown(54)) colour = cubetex(iChannel2, uv * dimension / iChannelResolution[2].xy, 3);\n    if (keydown(55)) colour = cubetex(iChannel2, uv * dimension / iChannelResolution[2].xy, 4);\n    if (keydown(56)) colour = cubetex(iChannel2, uv * dimension / iChannelResolution[2].xy, 4);\n    if (keydown(57)) colour = cubetex(iChannel2, uv * dimension / iChannelResolution[2].xy, 4);\n    if (keydown(48) && uv.x > 0.90) {\n        vec4 mask = 1.0 - smoothstep(0.40, 0.42, abs((uv.x - 0.9) * 40.0 - vec4(0.5,1.5,2.5,3.5)));\n        colour = mask * smoothstep(-0.01, 0.01, threshold * iResolution.y - fragCoord.y);\n        meniscus = vec4(0);\n    }\n    // zero out the meniscus shading if there's nothing to shade\n    meniscus *= max(max(colour.x, colour.y), max(colour.z, colour.w));\n\n    colour = pal16(colour);\n    if (!keydown(16)) colour = mix(colour, meniscus, meniscus.a);\n    fragColour = colour;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// size of one edge of the feedback buffer\nconst float dimension = 128.0;\n\n// target ratio of full versus empty pixels\nconst float setpoint = 0.12;\n\n// how blurry to make things\nconst float blur_radius = (0.25 * dimension);\n\n// filter size for blurring\nconst int blur_taps = 11;\n\n// everybody's favourite constant\nconst float tau = 6.28318530718;\n\n// anti-alias a threshold operation based on the local gradient\nfloat aastep(float threshold, float value) {\n    float delta = 0.7 * fwidth(value);\n    return smoothstep(-delta, delta, value - threshold);\n}\nvec4 aastep(vec4 threshold, vec4 value) {\n    vec4 delta = 0.7 * fwidth(value);\n    return smoothstep(-delta, delta, value - threshold);\n}\n\n// clamp coordinate to centre of edge pixel rather than edge of texture,\n// to avoid interpolating into unused data\nvec2 pixelclamp(vec2 uv) {\n    const float halfpix = 0.5 / dimension;\n    return clamp(uv, halfpix, 1.0 - halfpix);\n}\n\n// smoothstep, but with result between lo and hi rather than 0 and 1\nfloat smoothclamp(float x, float lo, float hi) {\n    return lo + smoothstep(lo, hi, x) * (hi - lo);\n}\nvec4 smoothclamp(vec4 x, float lo, float hi) {\n    return lo + smoothstep(lo, hi, x) * (hi - lo);\n}\n\n// convert texture coordinate and face into cubemap direction\nvec3 cubedir(vec2 uv, int face) {\n    vec3 dir = vec3(uv * 2.0 - 1.0, 1.0);\n    dir.y = -dir.y;\n    switch (face) {\n    case 1: dir = vec3(-dir.x, dir.y,-dir.z); break;\n    case 2: dir = vec3( dir.x, dir.z,-dir.y); break;\n    case 3: dir = vec3( dir.x,-dir.z, dir.y); break;\n    case 4: dir = vec3( dir.z, dir.y,-dir.x); break;\n    case 5: dir = vec3(-dir.z, dir.y, dir.x); break;\n    }\n    return dir;\n}\n// texture from cubemap\nvec4 cubetex(samplerCube tex, vec2 uv, int face) {\n    return texture(tex, cubedir(uv, face));\n}\nvec4 cubetexLod(samplerCube tex, vec2 uv, int face, float lod) {\n    return textureLod(tex, cubedir(uv, face), lod);\n}\n\n// the four weight coefficients for cubic interpolation\nvec2 w0(vec2 a) { return a * (a * (-a + 3.0) - 3.0) + 1.0; }\nvec2 w1(vec2 a) { return a * a * (3.0 * a - 6.0) + 4.0; }\nvec2 w2(vec2 a) { return a * (a * (-3.0 * a + 3.0) + 3.0) + 1.0; }\nvec2 w3(vec2 a) { return a * a * a; }\n// and a bicubic sampler using four linear interpolated samples\n// and the above weights\nvec4 bicubictex(sampler2D tex, vec2 uv, vec2 dims) {\n\tuv = uv * dims + 0.5;\n\tvec2 fuv = fract(uv);\n    uv = floor(uv) - 0.5;\n\n    vec2 g0 = w0(fuv) + w1(fuv);\n    vec2 g1 = w2(fuv) + w3(fuv);\n    vec2 h00 = w1(fuv) / g0 - 1.0;\n    vec2 h11 = w3(fuv) / g1 + 1.0;\n    vec2 h10 = vec2(h11.x, h00.y);\n    vec2 h01 = vec2(h00.x, h11.y);\n\n    vec2 s = 1.0 / dims;\n    return ((texture(tex, (uv + h00) * s) * g0.x\n           + texture(tex, (uv + h10) * s) * g1.x) * g0.y\n          + (texture(tex, (uv + h01) * s) * g0.x\n           + texture(tex, (uv + h11) * s) * g1.x) * g1.y) / 36.0;\n}\nvec4 bicubiccubetex(samplerCube tex, vec2 uv, int face) {\n\tuv = uv * 1024.0 + 0.5;\n\tvec2 fuv = fract(uv);\n    uv = floor(uv) - 0.5;\n\n    vec2 g0 = w0(fuv) + w1(fuv);\n    vec2 g1 = w2(fuv) + w3(fuv);\n    vec2 h00 = w1(fuv) / g0 - 1.0;\n    vec2 h11 = w3(fuv) / g1 + 1.0;\n    vec2 h10 = vec2(h11.x, h00.y);\n    vec2 h01 = vec2(h00.x, h11.y);\n\n    const vec2 s = 1.0 / vec2(1024.0);\n    return ((cubetex(tex, (uv + h00) * s, face) * g0.x\n           + cubetex(tex, (uv + h10) * s, face) * g1.x) * g0.y\n          + (cubetex(tex, (uv + h01) * s, face) * g0.x\n           + cubetex(tex, (uv + h11) * s, face) * g1.x) * g1.y) / 36.0;\n}\n\n// gaussian blur function\nfloat pdf(float x) {\n#if 0\n    // pdf for s=0.1667: `sum(uniform(-.5,.5, 3)/3)`\n    return 2.39365*exp(-18. * x * x);\n#else\n    // pdf for s=0.144: `sum(uniform(-.5,.5, 4)/4)`\n    return 2.77043 * exp(-24.1126 * x * x);\n#endif\n}\nvec4 gausstex(sampler2D tex, vec2 uv, vec2 dir) {\n    vec2 lo = 0.5 * abs(dir);\n    vec2 hi = dimension * abs(dir) - lo;\n    hi = mix(hi, vec2(1), equal(dir, vec2(0)));\n    vec4 sum = vec4(0);\n    float den = 0.0;\n    for (int i = -blur_taps; i <= blur_taps; i++) {\n        float f = float(i);\n        float w = pdf(f / blur_radius);\n        vec2 p = clamp(uv + dir * f, lo, hi);\n        sum += texture(tex, p) * w;\n        den += w;\n    }\n    return sum / den;\n}\n", "buffer_a_code": "// something interesting to get when the texture coordinate goes\n// out of range (this keeps the buffer seeded even when it might\n// become empty.\nvec4 outfill(vec2 uv, float t) {\n    uv -= 0.5;\n    vec4 c = cos(atan(uv.y, uv.x) + t * vec4(-0.3,0.4,-0.5,0.6)) * 0.3;\n    return clamp(c, 0.0, 1.0);\n}\n\n// sample from a buffer or the outfill value if out of bounds\nvec4 edgefill(sampler2D tex, vec2 uv, vec4 outfill) {\n    if (pixelclamp(uv) != uv) return outfill;\n    return texture(tex, uv* dimension / iChannelResolution[0].xy);\n}\nvec4 edgefill(samplerCube tex, vec2 uv, int face, vec4 outer) {\n    if (pixelclamp(uv) != uv) return outer;\n    return cubetex(tex, uv * dimension / 1024.0, face);\n}\n\n#define cs(a) vec2(cos(a), sin(a))\n#define csmat(a) mat2x2(cos(a), -sin(a), sin(a), cos(a))\n\n// swish coordinates around a bit for feedback\nvec2 warp0(vec2 uv, float t) {\n    const mat2x2 turn = csmat(0.001) * 1.001;\n    vec2 wobble = cos(uv.yx * vec2(16,15) + t) * 0.0018;\n    vec2 o = 0.5 + cs(t * 1.3) * .25;\n    uv = (uv - o) * turn + o; \n    return uv + wobble;\n}\n\n// swish, but differently\nvec2 warp1(vec2 uv, float t) {\n    const mat2x2 turn = csmat(0.001) * 0.999;\n    vec2 wobble = cos(uv.yx * vec2(17,16) + t) * 0.0018;\n    vec2 o = 0.5 - cs(t * 0.76) * .25;\n    uv = (uv - o) * turn + o; \n    return uv + wobble;\n}\n\n// decide which swish function to use (or blend them together)\nvec4 churn(vec2 uv, float t) {\n    uv -= 0.5;\n    vec4 ox = uv.x + cos(t * .4*vec4(0.5,-0.5, 0.4,0.3)) * 0.25;\n    vec4 oy = uv.y + sin(t * .4*vec4(0.4, 0.4,-0.3,0.4)) * 0.25;\n\n    vec4 t4 = t * vec4(-0.15,0.24,0.23,-0.32);\n    ox = ox * cos(t4) - oy * sin(t4);\n\n    return smoothstep(-0.15, 0.15, ox);\n}\n\nvec4 updatethreshold(vec4 threshold) {\n    // we keep a threshold value in one corner of buffer A,\n    // and depending on the number of set pixels we get in\n    // the cubemap we increment or decrement it to try to\n    // get to the setpoint.\n#if 0 // need to set mipmaps on ichannel1 for this version.\n    const float mmfix = (1024.0 * 1024.0) / (dimension * dimension);\n    vec4 median = cubetexLod(iChannel1, vec2(0.5), 0, 99.9) * mmfix;\n#else\n    vec4 median = vec4(0);\n    float divisor = 0.0;\n    for (int i = 0; i < int(dimension) / 16; ++i) {\n        for (int j = 0; j < int(dimension) / 16; ++j) {\n            vec2 o = vec2(i, j);\n            median += cubetex(iChannel1, o / 1024.0, 1);\n            divisor += 1.0;\n        }\n    }\n    median /= divisor;\n#endif\n    vec4 adj = smoothclamp(median - setpoint, -0.15, 0.15);\n    return threshold + adj * 0.125;\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    if (all(greaterThan(fragCoord, iResolution.xy - 1.0))) {\n        vec2 tc = 1.0 - 0.5 / iResolution.xy;\n        vec4 threshold = texture(iChannel0, tc);\n        threshold = updatethreshold(threshold);\n        if (iFrame == 0) threshold = vec4(0.5);\n        fragColour = clamp(threshold, 0.01, 0.99);\n        return;\n    }\n    if (max(fragCoord.x, fragCoord.y) > dimension) discard;\n    vec2 uv = fragCoord / dimension;\n\n    vec4 outer = outfill(uv, iTime);\n    vec4 churn = churn(uv, iTime);\n    vec2 uv0 = warp0(uv, iTime);\n    vec2 uv1 = warp1(uv, iTime);\n    vec4 colour = mix(edgefill(iChannel0, uv0, outer),\n                      edgefill(iChannel0, uv1, outer),\n                      churn);\n    vec4 quant = mix(edgefill(iChannel1, uv0, 0, outer),\n                     edgefill(iChannel1, uv1, 0, outer),\n                     churn);\n    // blend a little of the quantised buffer into the feedback\n    // buffer to gently encourage it towards wider dynamic range.\n    colour = mix(colour, quant, 0.01);\n\n    // where colours overlap, encourage them to separate a bit.\n    vec4 repel = colour.yzwx + colour.zwxy + colour.wxyz * 1.5;\n    colour -= repel * 0.0003;\n\n    fragColour = clamp(colour, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// blur horizontally\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    if (max(fragCoord.x, fragCoord.y) > dimension) discard;\n    vec2 uv = fragCoord;\n    vec2 s = 1.0 / iChannelResolution[0].xy;\n    fragColour = gausstex(iChannel0, uv * s, vec2(s.x, 0.0));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// blur verically\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    if (max(fragCoord.x, fragCoord.y) > dimension) discard;\n    vec2 uv = fragCoord;\n    vec2 s = 1.0 / iChannelResolution[0].xy;\n    fragColour = gausstex(iChannel0, uv * s, vec2(0.0, s.y));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// figure out which cube face we're rendering\nint cubeface(vec3 dir) {\n    vec3 adir = abs(dir);\n    vec3 m = vec3(greaterThan(adir, max(adir.yzx, adir.zxy)));\n    return int(dot(m, vec3(4, 2, 0)))\n        +  int(dot(m, dir) < 0.0);\n}\n\n// Read blurred version of feedback buffer, and threshold\n// it to give a count of 'set' pixels which can be read\n// from the mipmap.\nvoid mainCubemap(out vec4 fragColour, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    int f = cubeface(rayDir);\n    fragColour = vec4(0);\n    if (f == 0) {\n        if (max(fragCoord.x, fragCoord.y) > dimension) discard;\n        vec2 s0 = 1.0 / iChannelResolution[0].xy;\n        vec2 s1 = 1.0 / iChannelResolution[1].xy;\n\n        vec4 threshold = texture(iChannel1, 1.0 - 0.5 * s1);\n        vec4 colour = texture(iChannel0, fragCoord * s0);\n\n        fragColour = smoothstep(-0.125, 0.125, colour - threshold);\n    } else {\n        float scale = float(1 << (f * 4));\n        fragCoord = (fragCoord - 0.5) * scale + 0.5;\n        if (max(fragCoord.x, fragCoord.y) > dimension) discard;\n        vec4 sum = vec4(0);\n        for (int i = 0; i < 16; ++i) {\n            for (int j = 0; j < 16; ++j) {\n                vec2 uv = (fragCoord + vec2(i,j)) / iChannelResolution[2].xy;\n                sum += cubetex(iChannel2, uv, f - 1);\n            }\n        }\n        fragColour = sum / 256.0;\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 87], [90, 247, 273, 273, 346], [347, 403, 438, 438, 510], [511, 511, 543, 543, 1348], [1351, 1351, 1371, 1656, 2272], [2275, 2275, 2331, 2331, 4391]], "test": "untested"}
{"id": "ds3cD4", "name": "Smooth Noise Diagram", "author": "ircss", "description": "a diagram demonstrating how to generate smooth noise from a high frequency function for demonstrative porpuses. ", "tags": ["smoothnoise", "maths", "diagram"], "likes": 6, "viewed": 267, "published": 3, "date": "1695068666", "time_retrieved": "2024-07-30T17:33:07.907334", "image_code": "#define smoothing      0.006\n#define lineSize       0.01\n#define animationTime fract(iTime * 0.025)\nvoid DrawLine(float m, float c, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n\n    vec2  xy   = vec2(uv.x, uv.x * m + c); \n    float d    = distance(xy, uv);\n    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size + smoothing, d));\n    \n}\nvoid DrawHalfVectorWithLength(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n          m   += step(len, vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.01, d)+ m, 0. ,1.)); \n}\n\nfloat baseWaveFunc(float x)\n{\n    float t  = smoothstep(0.05, 0.15, animationTime)  ;\n    float t2 = smoothstep(0.175, 0.25, animationTime)  ;\n    float t3 = smoothstep(0.275, 0.325, animationTime)  ;\n    float t4 = smoothstep(0.35, 0.425, animationTime)  ;\n      \n    return sin(x*(mix(3., 8., t) + mix(0., 8., t2) + mix(0., 20., t3) + mix(0., 100., t4) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    \n    uv.x *=iResolution.x/iResolution.y;\n    uv *= 5.;\n   \n    \n    \n    \n    vec3 col = vec3( 0.0);\n    \n    vec2 fUV = fract(uv* 4.);\n    vec2 iUV = floor(uv* 4.);\n    \n    \n   vec2 disToCenter = abs( fUV - vec2(0.5));\n    \n  \n    \n    if(max(disToCenter.x, disToCenter.y)> 0.45) col = vec3(0.1);\n    \n    \n    DrawHalfVectorWithLength(vec2(-5.,0.), vec2(1.,0.), 10., uv, 0.001, vec3(1.), col);\n    DrawHalfVectorWithLength(vec2(0.,-5.), vec2(0.,1.), 10., uv, 0.001, vec3(1.), col);\n    \n    \n    float drawInterpolation = smoothstep(0.455, 0.65, animationTime);\n    uv.x += smoothstep(0.55, 1.3, animationTime) * 22.5;\n    float sampleRate = 0.8;\n     uv.x*= sampleRate;\n    float sinus = baseWaveFunc(uv.x);\n    \n    float spaceFloor = floor(uv.x);\n    float spaceFrac  = fract(uv.x); \n    \n    float sampleThis  = baseWaveFunc((spaceFloor +0.5     )) ;\n    float sampleRight = baseWaveFunc((spaceFloor +0.5 + 1.)) ;\n    float sampleLeft  = baseWaveFunc((spaceFloor +0.5 - 1.)) ;\n    \n    vec2 samplePoint = vec2(spaceFloor + 0.5,      sampleThis) ;\n    \n    float line = mix(sampleLeft, sampleThis, smoothstep(-0.5, 0.5, spaceFrac));\n    line = mix(line, sampleRight, smoothstep(0.5, 1.5, spaceFrac));\n    \n    col = mix(vec3(1.,0.86,0.), col,min(1.,smoothstep(lineSize, lineSize + smoothing, \n     abs(sinus - uv.y) ) + smoothstep(0.455, 0.475, animationTime) ) );\n    \n        col = mix(col, vec3(0.,0.3,1.), \n        smoothstep(0.12, 0.1, length((samplePoint-  uv)   * vec2(1., sampleRate)) ));\n    \n    \n    \n    col = mix(vec3(0., 1., 0.), col,min(1., smoothstep(0.0, 0.1, max(0., uv.x - ( -5. + drawInterpolation* 20.)))\n    + smoothstep(0.01,0.02, abs(uv.y - line)))); \n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3cD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 192, 192, 363], [364, 364, 491, 491, 836], [838, 838, 867, 867, 1198], [1200, 1200, 1257, 1257, 3069]], "test": "untested"}
{"id": "dd3yW4", "name": "First fractal shader", "author": "Illia", "description": "First shader, based on the tutorial", "tags": ["fractal"], "likes": 1, "viewed": 138, "published": 3, "date": "1695058516", "time_retrieved": "2024-07-30T17:33:09.194891", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b * cos( 6.28318 * (c * t + d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.5 + iTime);\n\n        d = sin(7. * d + iTime) / 7.;\n        d = abs(d);\n        d = .005 / d;\n\n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3yW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 217], [219, 219, 276, 276, 742]], "test": "untested"}
{"id": "msyGzw", "name": "Monochrome Test", "author": "theTDC", "description": "dailyrake.ca", "tags": ["monochrome"], "likes": 4, "viewed": 141, "published": 3, "date": "1695056011", "time_retrieved": "2024-07-30T17:33:10.242091", "image_code": "// Simple monochrome shader.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n   // Set the output pixel the same as the input pixel from Britney's video.\n    fragColor = texture(iChannel0, uv);\n    \n    // Alpha shouldn't matter.\n    float colVal = fragColor.r + fragColor.g + fragColor.b;\n    colVal /= 3.;\n        \n    if(colVal > 0.5){\n        colVal = 1.;\n    } else{\n        colVal = 0.;\n    }\n    \n    fragColor = vec4(colVal, colVal, colVal, 1);\n\n}\n\n", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 86, 86, 506]], "test": "untested"}
{"id": "mdtcR4", "name": "OWL", "author": "misol101", "description": "Hooo... Ho-hoooo!!\n\nFullscreen recommended.\n\nPress and hold mouse for quicker animation.", "tags": ["2d", "cute", "cartoon", "painting", "heart", "vector", "animal", "owl"], "likes": 12, "viewed": 303, "published": 3, "date": "1695051510", "time_retrieved": "2024-07-30T17:33:11.764022", "image_code": "// Eperimenting with 2d drawing in shaders\n\n// Long live the OWL!!\n\n// misol101 2023\n\nconst float PI = 3.1416;\nconst float flyMod = 25.9;\n\nvoid eye(inout vec3 col, vec2 uv, bool isLeft, vec2 move, float pupilSize) {\n    vec2 eyePos = vec2(0.21 * (isLeft? 1. : -1.), 0.22);\n    vec3 eyeCol = vec3(0.99, 0.54, 0.03);\n    const float eyeSize = 0.15;\n\n    float centDist = length(uv - eyePos);\n    eyeCol *= 1. - smoothstep(eyeSize-0.02, eyeSize-0.015, centDist); // black outline\n    eyeCol = mix(col, eyeCol, 1. - smoothstep(eyeSize-0.006, eyeSize, centDist)); // AA\n    float centDistP = length(uv+move - eyePos);\n    eyeCol *= smoothstep(eyeSize*(pupilSize-0.03), eyeSize*pupilSize, centDistP); // pupil\n\n    // Twinkles\n    const float HLSize = 0.04, HLSize2 = 0.028;\n    vec2 eyeHLPos = eyePos + vec2(-0.045, 0.045) - move * 0.8;\n    vec2 eyeHLPos2 = eyeHLPos + vec2(-0.029, 0.029);\n\n    float HLDist = length(uv - eyeHLPos); // big twinkle\n    if (HLDist < HLSize)\n        eyeCol = mix(eyeCol, vec3(1.), 1. - smoothstep(HLSize-0.02, HLSize-0.016, HLDist));\n\n    HLDist = length(uv - eyeHLPos2);     // small twinkle\n    if (HLDist < HLSize2)\n        eyeCol = mix(eyeCol, vec3(1.), 1. - smoothstep(HLSize2-0.02, HLSize2-0.016, HLDist));\n\n    col = (centDist < eyeSize) ? eyeCol : col;\n}\n\nvoid lid(inout vec3 col, vec2 uv, bool isLeft, float progress) {\n    vec2 lidPos = vec2(0.21 * (isLeft? 1. : -1.), 0.18);\n    vec3 lidCol = vec3(0.73, 0.44, 0.33)*2.5;\n    const vec2 lidSize = vec2(0.15, 0.2);\n\n    vec2 centDist = abs(uv - lidPos);\n    col = (centDist.x < lidSize.x && centDist.y > lidSize.y*progress && centDist.y < lidSize.y) ? lidCol : col;\n}\n\nvoid brow(inout vec3 col, vec2 uv, bool isLeft, float frown) {\n    vec2 browPos = vec2(0.21 * (isLeft? 1. : -1.), 0.315);\n    vec3 browCol = vec3(0., 0., 0.);\n    const float browSize = 0.18;\n    uv.y += abs(uv.x-browPos.x)*frown;\n\n    float ydist = (uv.y - browPos.y)*1.5;\n    float centDist = length(vec2(uv.x - browPos.x, ydist ));\n    browCol *= 1. - smoothstep(browSize-0.035, browSize-0.015, centDist);\n    browCol = mix(col, browCol, 1. - smoothstep(browSize-0.009, browSize, centDist)); // AA*3\n    browCol = mix(col, browCol, 1.-smoothstep(browSize-0.026, browSize-0.035, centDist));\n    browCol = mix(col, browCol, smoothstep(0.11, 0.115, ydist));\n\n    col = (centDist < browSize && centDist > browSize - 0.035 && ydist > 0.09) ? browCol : col;\n}\n\nvoid beak(inout vec3 col, vec2 uv) {\n    vec2 beakPos = vec2(0.0, 0.04);\n    float beakW = 0.068;\n    vec3 beakCol = vec3(0.97, 0.67, 0.12);\n\n    float beakHLw = -0.0015;\n\n    float beakHLx = (uv.x - beakPos.x);\n    float tlt = beakHLw + 0.004 + (beakPos.y -uv.y)*0.3;\n    if (beakHLx < beakHLw && beakHLx > tlt)\n        beakCol = mix(beakCol, vec3(1.), max(0.,1.0-beakHLw/(tlt*0.3)*1.));\n\n    float beakLW = abs(uv.x - beakPos.x) / beakW;\n\n    float breakPosY = beakPos.y + 0.065;\n    beakW -= max(uv.y, 0.1) - breakPosY;\n    if (uv.y < breakPosY)\n        beakW -= 0.35 * (breakPosY - uv.y);\n    \n    float beakX = abs(uv.x - beakPos.x) / beakW;\n\n    float rel = beakX/beakLW;\n    beakCol *= 1. - smoothstep(1.-0.39*rel, 1.-0.3*rel, beakX); // outline\n    beakCol = mix(col, beakCol, 1. - smoothstep(1.-0.1*rel, 1.-0.05*rel, beakX)); // AA\n\n    col = (beakX < 1.0) ? beakCol : col;\n}\n\nvoid face(inout vec3 col, vec2 uv, bool isLeft, vec3 faceCol, float faceSize, bool outline, float faceY) {\n    float sideMul = isLeft? 1. : -1.;\n    vec2 facePos = vec2(0.21 * sideMul, faceY);\n\n    float centDist = length(uv - facePos);\n\n    if (uv.y > facePos.y) {\n        float ls = (uv.x*sideMul + facePos.x*(sideMul*-1.) - faceSize) * 0.27;\n        faceSize -= ls * (uv.y - facePos.y)*2.;\n    }\n\n    if (outline)\n        faceCol *= 1. - smoothstep(faceSize-0.02, faceSize-0.015, centDist); // outline\n    faceCol = mix(col, faceCol, 1. - smoothstep(faceSize-0.006, faceSize, centDist)); // AA\n\n    col = (centDist < faceSize && uv.x * sideMul > 0.) ? faceCol : col;\n}\n\nvoid body(inout vec3 col, vec2 uv, bool isLeft, vec3 bodyCol, float bodySize, bool outline, float stretchMul) {\n    float sideMul = isLeft? 1. : -1.;\n    vec2 bodyPos = vec2(0.21 * sideMul, -0.09);\n\n    float centDist = length(uv - bodyPos);\n\n    float ls = (uv.x*sideMul + bodyPos.x*(sideMul*-1.) - bodySize) * 0.23;\n    bodySize -= ls * abs(uv.y - bodyPos.y)*stretchMul;\n\n    if (outline)\n        bodyCol *= 1. - smoothstep(bodySize-0.02, bodySize-0.015, centDist); // outline\n    bodyCol = mix(col, bodyCol, 1. - smoothstep(bodySize-0.006, bodySize, centDist)); // AA\n\n    col = (centDist < bodySize && uv.x * sideMul > 0.) ? bodyCol : col;\n}\n\nvoid claw(inout vec3 col, vec2 uv, vec2 clawPos, float clawSize, float clawH, vec3 clawCol, float tilt, bool isLeft, bool outline) {\n    float sideMul = isLeft? 1. : -1.;\n    clawPos.x *= sideMul;\n\n    uv.x += (uv.y-clawPos.y) * tilt;\n    float centDist = length(vec2((uv.x - clawPos.x)*clawH, uv.y - clawPos.y));\n    \n    if (outline)\n        clawCol *= 1. - smoothstep(clawSize-0.025, clawSize-0.02, centDist); // outline\n    clawCol = mix(col, clawCol, 1. - smoothstep(clawSize-0.006, clawSize, centDist)); // AA\n\n    col = (centDist < clawSize && uv.x * sideMul > 0.) ? clawCol : col;\n}\n\nvoid wing(inout vec3 col, vec2 uv, vec2 wingPos, float wingSize, float wingH, vec3 wingCol, float tilt, bool isLeft, bool outline, float rot) {\n    float sideMul = isLeft? 1. : -1.; \n    wingPos.x *= sideMul;\n\n    uv.x += (uv.y-wingPos.y) * tilt;\n    float centDist = length(vec2((uv.x - wingPos.x)*wingH + 0.07*cos( rot+atan(uv.y,uv.x*sideMul)*25.), uv.y - wingPos.y));\n\n    if (outline)\n        wingCol *= 1. - smoothstep(wingSize-0.03, wingSize-0.025, centDist); // outline\n    wingCol = mix(col, wingCol, 1. - smoothstep(wingSize-6./iResolution.y, wingSize, centDist)); // AA\n\n    col = (centDist < wingSize && uv.x * sideMul > 0.) ? wingCol : col;\n}\n\n// from https://www.shadertoy.com/view/lsKSWR by Ippokratis\nfloat vignette(vec2 FC, float extent, float intensity) {\n\tvec2 uv = FC.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * intensity;\n    return pow(vig, extent);\n}\n\n// from https://www.shadertoy.com/view/XsfGRn by iq\nvoid heart(inout vec3 col, vec2 uv, vec2 hpos, float scale, vec3 hcol, bool anim, float time) {\n    vec2 p = (uv - hpos) / scale;\n\t\n    if (anim) {\n        float tt = mod(time,1.5)/1.5;\n        float ss = pow(tt,.2)*0.5 + 0.5;\n        ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n        p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n    }\n\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n    \n    col = mix( col, hcol, max(0.,smoothstep( -0.02, 0.02, d-r+0.15) -0.4 ));\n}\n\nfloat hash1(float n) {\n    return fract(sin(n)*138.5453123);\n}\n\nvoid animSingle(inout float result, float time, float startTime, float endTime, bool neg) {\n    if (time > startTime && time < endTime) {\n        result = (neg ? -1. : 1.) * (time-startTime) / (endTime-startTime); \n    }\n}\n\nvoid animate(float speed, out float eyeMove, out float browMove, out float headMove, out float clawMove, out float clawMove2, out float pupilSize, out float pupilSize2, out float blinkL, out float blinkR, out float flyMove) {\n    float iT = iTime * speed;\n    float time = mod(iT, 14.);\n\n    animSingle(eyeMove, time, 0.3, 4.3, false);\n    animSingle(eyeMove, time, 10.3, 13.3, true);\n\n    animSingle(browMove, time, 1.3, 4.3, false);\n    animSingle(browMove, time, 6.3, 8.3, true);\n\n    animSingle(headMove, time, 1.3, 6.3, false);\n    animSingle(headMove, time, 9.3, 10.8, true);\n\n    float ctime = mod(iT, 12.);\n    animSingle(clawMove, ctime, 1.3, 2.7, true);\n    animSingle(clawMove2, ctime, 6.3, 7.4, true);\n\n    float ptime = mod(iT, 32.); \n    animSingle(pupilSize, ptime, 20.3, 25.4, true);\n    animSingle(pupilSize2, ptime, 5.2, 8.2, true);\n    \n    float btime = mod(iT, 15.);\n    float blink = 0.4 * speed;\n    if ((int(floor(iT / 15.)) % 4) == 2)\n        animSingle(blinkL, btime, 4.3, 4.3+blink, true);\n    animSingle(blinkL, btime, 14.3, 14.3+blink, true);\n    animSingle(blinkR, btime, 14.3, 14.3+blink, true);\n\n    float ftime = mod(iT, flyMod); \n    animSingle(flyMove, ftime, flyMod-14., flyMod-0.1, false);\n}\n\nvoid mainImage( out vec4 O, in vec2 FC ) {\n    // don't ask... :)\n    vec2 uv = (FC*1.35)/iResolution.y - 0.67;\n    uv.y += 0.03;\n    uv.x += (1. - iResolution.x/iResolution.y) * 0.67;\n\n\tvec3 col = mix( vec3(1.0,0.8,0.3), vec3(0.58, 0.99, 0.99), sqrt(uv.y+0.67) );\n\n    // hearts\n    const vec3 hcol = vec3(0.3,0.8,0.7);\n    for (float j = 0.; j < 6.; j++) {\n        vec2 hpos = vec2(-0.9 + mod((j-1.) * 0.9,2.4) + sin(iTime+0.4*j)*0.1, 1.0 - mod(hash1(j)*1.5 + iTime*(0.3+hash1(j)*0.3), 1.8));\n        if (length(hpos-uv) < 0.4)\n            heart(col, uv, hpos, 0.2 + hash1(j)*0.1, hcol, true, iTime + .7*j);\n    }\n    vec3 bgcol = col;\n    \n    // entrance on start\n    //uv/=0.5 + min(0.5, smoothstep(0.0, 2.0, iTime) ); uv.y += sin(-PI*0.5-max(0.,1.-iTime/1.)*(PI-0.5)) * ((max(0.,1.-iTime))*2.8);\n    \n    // animate\n    float speed = 1., em = 0., bm=0., hm=0., cm=0., cm2=0., ps=0., ps2=0., bL=0., bR=0., fm=0.;\n    if (iMouse.z > 0.) {\n        speed = 3.0;\n    }\n    animate(speed, em, bm, hm, cm, cm2, ps, ps2, bL, bR, fm);\n\n    float fmS = pow(smoothstep(0.,1.,fm), 0.9);\n    if ((int(iTime/flyMod)-1) % 3 == 0)\n        uv *= 1. - sin(iTime * 1.5) * (sin(fm*PI*2.) * 0.22); // scale while flying\n    uv.x += sin(PI * 6. * fmS) * 0.2 * (mod(floor(iTime*speed / flyMod)+1.,2.)*2.-1.); // flying x\n    uv.y += sin(iTime * 1.5) * (0.005 + sin(fmS*PI) * 0.02); // flying y\n\n    float tilt = 0.15;\n    if (uv.y < 0.15 && abs(uv.x) < 0.8) {\n        // wings\n        vec3 wingCol = vec3(0.73, 0.44, 0.031);\n        vec2 wingPos = vec2(0.41, -0.16);\n        float flyMove = PI * 2. * fmS * 12.;\n        wing(col, uv, wingPos, 0.3, 0.95, wingCol, tilt, true, true, 1.93+sin(iTime*speed + flyMove));\n        wing(col, uv, wingPos, 0.3, 0.95, wingCol, -tilt, false, true, -1.23+sin(iTime*speed*0.9 + flyMove));\n        //bgcol = col; // don't shadow wings\n\n        // body\n        vec3 bodyCol = vec3(0.73, 0.44, 0.03);\n        body(col, uv, false, bodyCol, 0.34, true, 2.);\n        body(col, uv, true, bodyCol, 0.34, true, 2.);\n\n        bodyCol = vec3(0.73, 0.44, 0.33)*2.5;\n        body(col, uv, false, bodyCol, 0.24, false, 4.);\n        body(col, uv, true, bodyCol, 0.24, false, 4.);\n    }\n\n    if (uv.y > -0.25 && abs(uv.x) < 0.6) {\n        float headMove = sin(hm * PI * 1.2)*0.2*(1.-abs(hm)) * abs(hm);\n        uv.x += headMove;\n\n        // face shadow\n        vec3 faceShCol = vec3(0., 0., 0.0), coltemp=col;\n        float faceY = 0.125;\n        face(coltemp, uv, false, faceShCol, 0.34, false, faceY);\n        face(coltemp, uv, true, faceShCol, 0.34, false, faceY);\n        if (col != bgcol)\n            col = mix(col, coltemp, 0.33);\n\n        // face\n        faceY = 0.2;\n        vec3 faceCol = vec3(0.73, 0.44, 0.03);\n        face(col, uv, false, faceCol, 0.34, true, faceY);\n        face(col, uv, true, faceCol, 0.34, true, faceY);\n\n        faceCol = vec3(0.73, 0.44, 0.33)*2.5;\n        face(col, uv, false, faceCol, 0.268, false, faceY);\n        face(col, uv, true, faceCol, 0.268, false, faceY);\n\n        // eyes\n        float pupilSize = 0.7 + max(-1.559,sin(ps*PI*1.)*0.65) + max(-0.11,sin(ps2*PI*1.)*0.15);\n        vec2 eyeMove = vec2( max(-0.159,sin(em*PI*1.)*0.04), sin(em*PI)*0.011);\n        eye(col, uv, false, eyeMove, pupilSize);\n        eye(col, uv, true, eyeMove, pupilSize);\n\n        lid(col, uv, true, cos(bL*PI*2.)*0.5+0.5);\n        lid(col, uv, false, cos(bR*PI*2.)*0.5+0.5);\n\n        beak(col, uv);\n\n        // brows\n        float browMove = -sin(bm*PI*1.)*0.3;\n        brow(col, uv, false, browMove);\n        brow(col, uv, true, browMove);\n\n        uv.x -= headMove;\n    }\n\n    // claws\n    vec3 clawCol = vec3(1., 0.54, 0.03);\n    vec2 clawPos = vec2(0.21, -0.495);\n    tilt = 0.25;\n    \n    if(abs(clawPos.y-uv.y) < 0.1 && abs(uv.x) < 0.25) {\n        vec2 clawMove = vec2( sin(cm * PI * 1.1)*0.15*(1.-abs(cm)) * abs(cm), sin(cm*PI)*0.005);\n        vec2 clawMove2 = vec2( sin(cm2*PI)*0.005, sin(cm2 * PI * 1.5)*0.15*(1.-abs(cm2)) * abs(cm2));\n        for (float i = 0.; i<3.; i++) {\n            claw(col, uv+clawMove*(i+0.2)*0.25, clawPos, 0.07, 1.75, clawCol*0.7, tilt, true, true);\n            claw(col, uv+clawMove*(i+0.2)*0.25, clawPos+vec2(0.,0.008), 0.045, 1.75, clawCol, tilt, true, false);\n\n            claw(col, uv+clawMove2*(0.15+i*0.2)*1.35, clawPos, 0.07, 1.75, clawCol*0.7, -tilt, false, true);\n            claw(col, uv+clawMove2*(0.15+i*0.2)*1.35, clawPos+vec2(0.,0.008), 0.045, 1.75, clawCol, -tilt, false, false);\n            clawPos += vec2(-0.06, -0.01);\n            tilt -= 0.09;\n        }\n    }\n\n    // post processing\n    float vig = 1.;\n    vig = vignette(FC, 0.08, 75.0);\n\n    O = vec4(col*vig,1.0);\n}\n", "image_inputs": [{"id": 34783, "src": "https://soundcloud.com/jazzguitarclub/its-playtime?in=jazzguitarclub/sets/happy-guitar-songs-for", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 215, 215, 1288], [1290, 1290, 1354, 1354, 1652], [1654, 1654, 1716, 1716, 2410], [2412, 2412, 2448, 2448, 3296], [3298, 3298, 3404, 3404, 3969], [3971, 3971, 4082, 4082, 4616], [4618, 4618, 4750, 4750, 5208], [5210, 5210, 5353, 5353, 5864], [5866, 5926, 5982, 5982, 6111], [6113, 6165, 6260, 6260, 6744], [6746, 6746, 6768, 6768, 6808], [6810, 6810, 6901, 6901, 7032]], "test": "untested"}
{"id": "mddcR4", "name": "Blobby Lights IV", "author": "Dem0g", "description": "Fourth Iteration of Blobby Lights. Added a more \"gel\" like appearance this time. Has a Fruitiger Aero feel.\n", "tags": ["simple", "colorful", "blob", "ambient", "fruitiger", "aero"], "likes": 0, "viewed": 121, "published": 3, "date": "1695050163", "time_retrieved": "2024-07-30T17:33:12.891009", "image_code": "#define LINES 10.0\n#define COLORS 5.0\n#define METABLOBS 5.0\n#define SUBBLOBS 5.0\n#define FF 1.0\n#define SMOOTHNESS 1.5\n#define EXPOSURE 0.9\n#define RING 1.\n#define RING_SIZE 0.299\n\nfloat rand(float x) {\n    return fract(sin(dot(vec2(x,x),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 cubic_hermite(vec2 p0, vec2 p1, vec2 v0, vec2 v1, float t) {\n    float sq = t*t;\n    float cu = t*t*t;\n    \n    float h1 = 2.*cu-3.*sq+1.;\n    float h2 = -2.*cu+3.*sq;\n    float h3 = cu - 2.*sq + t;\n    float h4 = cu - sq;\n    return h1*p0+h2*p1+h3*v0+h4*v1;\n}\n\n//sinc comb. Good start: sharpness of 10\nfloat comb(float phase, float density, float sharpness){\n    float signed_mod = mod(phase,density) - density/2.0;\n    float sinc = sin(signed_mod * sharpness)/(signed_mod*sharpness);\n    return pow(sinc,SMOOTHNESS);\n}\n\nvec2 random_path(float t, float seed){\n    vec2 pos0 = random2(vec2(seed,floor(t)));\n    vec2 pos1 = random2(vec2(seed,floor(t+1.)));\n    vec2 vel0 = random2(vec2(floor(t),seed));\n    vec2 vel1 = random2(vec2(floor(t+1.),seed));\n    return cubic_hermite(pos0,pos1,vel0,vel1,fract(t));\n}\n\nvec2 combed_path(float t, float seed, float comb) {\n    float offset = max(0.5,2.0*comb);\n    vec2 pos0 = random2(vec2(seed,floor(t)));\n    vec2 pos1 = random2(vec2(seed,floor(t+1.)));\n    float a0 = atan(pos0.x,pos0.y);\n    float a1 = atan(pos1.x,pos1.y);\n    float r0 = length(pos0)*offset;\n    float r1 = length(pos1)*offset;\n    pos0.x = r0 * cos(a0);\n    pos0.y = r0 * sin(a0);\n    pos1.x = r1 * cos(a1);\n    pos1.y = r1 * sin(a1);\n    vec2 vel0 = random2(vec2(floor(t),seed));\n    vec2 vel1 = random2(vec2(floor(t+1.),seed));\n    return cubic_hermite(pos0,pos1,vel0,vel1,fract(t));\n}\n\nfloat blob(vec2 uv, vec2 pos, float brightness, float spotlight, float cutoff){\n    float d = distance(uv,pos);\n    float mul = 2.0*(d*d*d)/(cutoff*cutoff*cutoff) - 3.0*(d*d)/(cutoff*cutoff) + 1.0;\n    float res = mul*brightness*exp(-spotlight*d);\n    return d < cutoff ? res : 0.0;\n}\n\nfloat clean_blob(vec2 uv, vec2 pos, float brightness, float spotlight, float cutoff){\n    float res = blob(uv,pos,brightness,spotlight,cutoff);\n    return res > 0.8 ? 0.8 : res;\n}\n\nvec3 mass(vec2 _uv,float metablobs, float subblobs, vec3 col, float ring_strength,float dispersion){\n    float a = 1.3;//+noise(vec2(iTime*0.01,1.0))*10.;\n    float b = 4.0;//+noise(vec2(iTime*0.01,2.0))*10.;\n    float c = 10.0;\n    float seed = rand(3.0*col.x+5.0*col.y+7.0*col.z);\n    float blob_field = 0.0;\n    vec2 uv = _uv * rotate2d(iTime*(0.5-seed)*0.1);\n    for(float i = 0.0; i<metablobs; i = i + 1.0){\n    float t = iTime * 0.03 * FF + (i)*1.0/(metablobs);\n    vec2 pos = combed_path(t, i+seed,comb(iTime*0.05*FF+i,metablobs,0.3));\n    for( float j = 0.0; j<subblobs; j = j + 1.0){\n        float index = (seed+i*metablobs+j);\n        col = mix( col, vec3(0.0), 0.12);\n        vec2 offset = dispersion*random_path(t, index);\n        float blob = clean_blob( uv, pos+offset, a, b, c);\n        blob_field += blob;\n        }\n    }\n    float ring = (blob_field < RING && blob_field > RING-RING_SIZE) \n               ? (RING-blob_field)/RING_SIZE\n               : 0.0;\n    float blob = (blob_field > RING-RING_SIZE) ? blob_field : 0.0;\n    blob = blob < 0.2 && blob != 0.0 ? 0.2 : blob;\n    float blob_count = metablobs+subblobs;\n    vec3 res = col *(ring * ring_strength + blob);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv *= 3.;\n    uv *= rotate2d(0.08*iTime);\n\n    float field = 0.0;\n    vec3 color_field = vec3(1.0,0.8,0.1);\n    vec2 light_pos = vec2(0.0);\n    float slow = iTime*0.1;\n    vec3 light_color = vec3(\n        1.0+1.0*noise(vec2(slow)),\n        1.0+1.0*noise(vec2(slow,-3.0)),\n        1.0+1.0*noise(vec2(5.0,slow)));\n    light_color = mix(light_color, vec3(0.0), 0.5*noise(uv*1.0+vec2(0.25*iTime)));\n    color_field = light_color*blob(uv, light_pos, 0.9, 0.0, 100.0);\n    \n    //color_field += 40.0*mass(uv,4.,10.,vec3(0.0,0.9,0.0),15.0,0.5);\n    color_field -= 1.0*mass(uv,4.,4.,vec3(1.0,0.0,0.0),2.0,0.3);\n    color_field -= 10.0*mass(uv,4.,10.,vec3(0.0,1.0,0.0),2.0,0.3);\n    color_field -= 30.0*mass(uv,4.,10.,vec3(0.0,0.0,1.0),5.0,0.5);\n\n    //vec3 col = vec3(field);\n    vec3 col = color_field;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 202, 202, 313], [315, 315, 337, 337, 476], [479, 564, 586, 586, 990], [992, 992, 1020, 1020, 1106], [1108, 1108, 1173, 1173, 1373], [1375, 1416, 1472, 1472, 1633], [1635, 1635, 1673, 1673, 1921], [1923, 1923, 1974, 1974, 2512], [2514, 2514, 2593, 2593, 2798], [2800, 2800, 2885, 2885, 2979], [2981, 2981, 3081, 3081, 4184], [4186, 4186, 4243, 4293, 5180]], "test": "untested"}
{"id": "csccWN", "name": "SSAA Plotter", "author": "01000001", "description": "little fiddle", "tags": ["thingy"], "likes": 0, "viewed": 54, "published": 3, "date": "1695049458", "time_retrieved": "2024-07-30T17:33:13.748716", "image_code": "const float samples = float(2<<7);\n\n\n\nfloat func(vec2 uv){\n    float x = mod(uv.x*uv.y*20., 1.);\n    \n    return x;\n\n}\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U-r)/r.y;\n    \n    \n    float x = 0.;\n    \n    if (iFrame%120 < 60){\n    \n    for(float i = 0.; i<samples; i++){\n        x += func(uv + (hash(uvec3(uv, i+iTime)).xy*2.-1.)/r.y);\n    }\n    \n    x/=samples;\n    \n    }else{\n    \n    x = func(uv);\n    \n    }\n    \n    O = vec4(x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csccWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 118], [149, 149, 171, 171, 304], [357, 357, 395, 395, 721]], "test": "untested"}
{"id": "DstcWn", "name": "Raytraced Rolling Ball", "author": "Shane", "description": "Using a pseudo path tracing technique to produce a simple realtime scene lit up with multiple emitters.", "tags": ["global", "illumination", "ball", "tracing", "realtime", "path", "quad", "rolling", "faux", "emissive"], "likes": 140, "viewed": 3216, "published": 3, "date": "1695046049", "time_retrieved": "2024-07-30T17:33:14.824838", "image_code": "/*\n\n    Raytraced Rolling Ball\n    ----------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n \n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 3.5, coc = 2.;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 1.);\n    //dof *= smoothstep(0., .25, length(uv - .5));\n\n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such, appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(dof);\n}\n\n \n/*\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x, 6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the one's you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bokeh(sampler2D iCh, vec2 uv){\n\n    \n    vec4 colOrig = texture(iCh, uv);\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 3.5, coc = 1.25;\n    // Linear distance from either side of the focal point.\n    float l = abs(colOrig.w - focD - coc) - coc;\n \n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.3, 1., abs(uv.y - .5)*2.);\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .5);\n    ra *= smoothstep(0., .1, length(uv - .5) - .25);\n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 1.6;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.5);\n        \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        ////////\n         \n        // Polygons, if desired. Comment out the line above and comment in\n        // the \"rot2\" formula above, if using it.\n        //const float N = 6.;\n        //float ra = rnd2.y;\n        //float a = (floor(ra*N) + .5)*6.2831859/N;\n        //vec2 offs  = mix(rot2(a)*vec2(0, 1), rot2(a + 6.2831859/N)*vec2(0, 1), \n        //                 fract(ra*N));\n        //offs *= 6.*sqrt(rnd2.x);\n        ////////\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.5);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        vec4 bokeh = pow(col, vec4(2));\n\t\ttot += bokeh*col*col;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field.\n    \n    // Not entirely correct, but no one will notice here. :)\n\treturn mix(colOrig, colOrig*.25 + tot/div*4., ra);\n}\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n     // Retrieving the stored color only.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Depth of field.\n    vec4 col = DpthFld(iChannel0, uv).xyzz;\n    \n    \n   \n    // Mixing in some bokeh. I thought it was a bit much for\n    // this example (The \"bokeh\" function would need to be \n    // commented back in first).\n    //vec4 col2 = bokeh(iChannel0, uv);\n    //col = mix(col, col2, .35);\n    \n     \n    /*\n    // Chromatic aberration. Not for this example, but interesting.\n    #if 0\n    const float focD = 3.5, coc = 1.25;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iChannel0, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 1.);\n    vec2 e = ra*4./iResolution.xy;\n    #else\n    vec2 e = 4./iResolution.xy;\n    #endif\n    vec4 colX = texture(iChannel0, uv + e.xy);\n    vec4 col = texture(iChannel0, uv);\n    vec4 colZ = texture(iChannel0, uv - e.xy);\n    col = vec4(colX.x, col.y, colZ.z, 1);\n    */\n\n    // Subtle vignette. Designers use them to frame things and guide\n    // the viewer's eyes toward the center... or something like that.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n    // Colored vignette.\n    col = mix(col, col.yzxw, smoothstep(.35, .6, length(uv - .5)));\n\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Raytraced Rolling Ball\n    ----------------------\n    \n    Using a pseudo path tracing technique to produce a simple realtime scene \n    lit up with multiple emitters.\n    \n    Some time ago, Xor wrote a minimal shader featuring a glitch texture that\n    I was pretty taken with, and figured it'd look interesting in some kind of \n    globally illuminated setting, so I quickly repurposed an old example and \n    put this together the same day... then got side tracked (probably by some \n    other Shadertoy post) and forgot about it. :)\n    \n    Anyway, I came across it today, so quickly tidied it up and added commnents.\n    Rolling spheres down a corridor are a bit of a raytracing cliche, but \n    they're visually effective. There's nothing in here that hasn't been covered \n    before, but someone might get something out of it.\n    \n    I wanted the code to be partly readable, so didn't optimize things as much\n    as I probably should have. However, I'll tweak it later.\n    \n    \n    \n    Based on:\n    \n    // Beautiful in its simplicity. Less is more, as they say. \n    Gltch [291 Chars] - Xor\n    https://www.shadertoy.com/view/mdfGRs\n    \n    // A lot of the realtime path tracing demos out there\n    // are based on elements from this example.\n    past racer by jetlag - w23\n    https://www.shadertoy.com/view/Wts3W7\n\n    \n\n*/\n\n\n// Sample number and blend number: The trick is to find a balance between the\n// two, or use a faster computer. :)\n\n// Number of samples: My computer can handle more. If yours is struggling, you \n// can lower this. Naturally, sample number is proportional to noise quality.\n#define sampNum 12\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // Depending on your machine, this should be faster than\n    // the block below it.\n    return texture(iChannel1, f*vec2(.2483, .1437)).x;\n    /*\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n    */\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// Random seed.\nvec2 seed = vec2(.183, .257);\n\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash22(){\n\n    // I should probably use a \"uvec2\" seed, but I hacked this from an old\n    // example. I'll update it later.\n    seed = fract(seed + vec2(.7123, .6457));\n    uvec2 p = floatBitsToUint(seed);\n    \n    // Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n    // Faster than \"full\" xxHash and good quality.\n    p = 1103515245U*((p>>1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n/*\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec3 hash23(vec2 f){\n\n\tuvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx); \n    \n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32>>16);\n    \n    // See: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); \n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n// IQ's box routine.\nfloat sBox(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir( in float seed, in vec3 n){\n\n    vec2 rnd = hash22();\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n\n// Sphere normal.\nvec3 sphereNorm(vec3 p, float id, vec4 sph){\n   \n    return (p - sph.xyz)/sph.w; \n}\n \n// Hitting a number of walls from the inside: You could simply raytrace four\n// planes, but this is a little more concise. I was too lazy to write my own\n// routine, so quickly adapted a working one (sadly, not many of those around) \n// from one of PublicIntI's examples. At some stage, I'll get in amongst it and \n// rewrite one, or find one of my older routines. Alternatively, if someone\n// knows of a concise reliable function or sees a way to tidy the following up, \n// feel free to let me know. :)\n//\n// crystal exhibit(pathtraced) - public_int_i \n// https://www.shadertoy.com/view/wljSRz\n//\n// Ray-box intersection: The function take in the ray origin (offset if needed)\n// the unit direction ray and the box dimensions, then returns the distance and \n// normal.\n//\nvec4 boxIntersect(vec3 ro, vec3 rd, vec3 dim) {\n\n    const float maxT = 1e8; // Maximum distance.\n \n    vec3 minD = (ro + dim)/rd, maxD = (ro - dim)/rd;\n\tminD = -(minD - step(vec3(-1e-6), minD)*(minD + maxT));\n\tmaxD = -(maxD - step(vec3(-1e-6), maxD)*(maxD + maxT));\n\tminD = min(minD, maxD);\n    \n    // Result: Distance and normal.\n    vec4 res = vec4(maxT, 0, 0, 0);\n    \n    // Performing some ray-plane intersections, modified to handle\n    // two planes at once. I'd imagine you could cleverly combine this\n    // into just one test, but I'm not clever, so I'll leave that to \n    // someone else. :D\n    \n    // We don't need the left and right walls for this example.\n    if (minD.x<maxT){\n        float pd = abs(ro.y + rd.y*minD.x) - dim.y;\n        if(pd<0.) res = vec4(minD.x, -sign(rd.x), 0, 0);\n    }\n    \n    // Top and bottom surfaces, or ceiling and floor, if you prefer.\n    if (minD.y<maxT){\n        float pd = abs(ro.x + rd.x*minD.y) - dim.x;\n        if(pd<0.) res = vec4(minD.y, 0., -sign(rd.y), 0.);\n    }\n\n    \n    // Return the distance and normal.\n    return res;\n}\n \n \n// Sphere intersection: Pretty standard, and adapted from one\n// of IQ's formulae.\nvec2 sphereIntersect(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n    if(b > 0.) return vec2(1e8, 0.);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif(h<0.) return vec2(1e8, 0.);\n\treturn vec2(-b - sqrt(h), 1.); \n    \n}\n\n\n// Sphere position and radius.\nconst float ballRad = .5;\nvec4 sph4 = vec4(0, ballRad - 1., 1., ballRad);\n\n// Hacking in a normal for the box equation.\nvec3 boxNrm;\n\n// Scene normal logic: Not that exciting for this example. :)\nvec3 getNorm(vec3 p, float id){\n    \n    return (id<.5)? sphereNorm(p, id, sph4) : boxNrm; \n}\n\n\n// Intersection logic for all objects.\nvec3 intersect(vec3 ro, vec3 rd){\n    \n    // Containers for two objects. Usually there'd be more.\n    vec2[2] q;\n    \n    // The sphere.\n    q[0] = sphereIntersect(ro, rd, sph4);//vec2(1e5);//\n    //q[0].x = 1e5;\n\n    // The box tube object, or 4 walls at once, if you prefer. :)\n    vec4 bx = boxIntersect(ro - vec3(0, 1.5 - 1., -.5*0.), rd, vec3(2, 1.5, 1e8));\n    q[1] = vec2(bx.x, 1);\n    boxNrm = bx.yzw; \n   \n    \n    // Returning the object distance, a hit ID (inside surface, etc, and redundant \n    // for this example) and the object ID used for materials and so forth.\n    return q[0].x<q[1].x? vec3(q[0], 0) : vec3(q[1], 1);\n    \n    /*\n    // For more objects, you need to do a little more work.\n    vec3 d = vec3(1e5);\n    \n    for(int i = 0; i<2; i++){\n       if(q[i].x< d.x) d = vec3(q[i], i);\n    }\n        \n    return d;\n    */\n    \n}\n\n\n// The wall and floor pattern, which is just something quick and effective\n// that I picked up from Xor's example, here:\n//\n// Gltch [291 Chars] - Xor\n// https://www.shadertoy.com/view/mdfGRs\nvec3 distField2(vec2 p, float scl, float rndZ, float oID){\n    \n    // Edge width.\n    float ew = .0125; \n     \n    // Outer boundaries, prior to partitioning.\n    vec2 pp = abs(fract(p) - .5);\n    float sq = abs(max(pp.x, pp.y) - .5) - ew*2.;\n    \n    // Scale.\n    vec2 sc = vec2(1, 1)/scl; \n \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    \n    // Rounded square.\n    float d = sBox(p, sc/2. - ew, .1*min(sc.x, sc.y)*0.);\n    //float d = length(p) - sc.x/2. + ew;\n   \n    // Randomly rotated and scaled lines.\n    if(hash21(ip + rndZ*.123 + oID + .055)<.65){\n        float f = scl*4.;\n        //float n = floor((floor(hash21(ip + .043)*64.)*2.) + 1.)*3.14159/4.;\n        float n = floor(hash21(ip + rndZ*.401 + oID + .043)*64.)*3.14159/4.;\n        vec2 uv = rot2(n)*(p + vec2(f/2., 0));\n        float g = (abs(fract(uv.x*f + n*f*0.) - .5) - .175)/f;\n        d = max(d, g);\n        \n    }\n    \n    if(oID==0.) d = max(d, -sq);\n    \n    // Putting a hole in it just to break things up.\n    //d = max(d, -(length(p) - .2*sc.x));\n    \n    // Rings.\n    //d = abs(d + .1*sc.x) - .1*sc.x;\n    \n    \n    \n    // Returning the distance and local cell ID. Note that the \n    // distance has been rescaled by the scaling factor.\n    return vec3(d, ip*sc);\n}\n\n\n// A simple rotated stripey pattern, like above.\nvec3 distField(vec2 p, float scl, float oID){\n    \n\n    //Noise macro\n    #define N(u) hash21(floor(u) + oID*.123) //texture(iChannel0, (u)/64.).x\n   \n    \n    p *= scl;\n    float rnd = N(p);\n    \n    \n    vec2 p2 = p/(rnd + .1);\n    \n    vec2 pp = fract(p2) - .5;\n    float sq = (abs(max(abs(pp.x), abs(pp.y)) - .5) - 1./40.)/2.*(rnd + .1);;\n    rnd = N(p2);\n    // Random quarter turn rotation.\n    float n = floor(rnd*64.)*3.14159/4.;\n    vec2 id = rnd + ceil(p2);\n    // Random stripe frequency.\n    float f = 1./N(id)/3.14159; \n    //float f = 4.;\n\n    // Random quarter rotation stripes of random frequency.\n    //float g = ceil(cos((rot2(n)*p).x*f));\n    //float g = cos((rot2(n)*p).x*f);\n    float g = (abs(fract((rot2(n)*p).x*f) - .5) - .25)/f; \n\n    g = max(g, -sq); \n    \n    return vec3(g, id);\n\n}\n\n\n// IQ's signed square formula with some roundness thrown in. \nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better version of this that I'll have to find.\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nvec4 cubeMap(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? -1 : 1, p.y<.0? -1 : 1, p.z<0.? -1 : 1);\n    \n    ivec3 faceID = (idF + 1)/2 + ivec3(0, 2, 4);\n    \n    return f.x>.5? vec4(p.yz/p.x, idF.x, faceID.x) : \n           f.y>.5? vec4(p.xz/p.y, idF.y, faceID.y) : vec4(p.xy/p.z, idF.z, faceID.z); \n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n     \n    float sf = 1./iResolution.y;\n        \n    // Screen pixel coordinates.\n    float iRes = iResolution.y;\n    vec2 seed0 = fract(iTime/vec2(111.13, 57.61))*vec2(-.143, .457);\n    vec2 uv0 = (fragCoord - iResolution.xy*.5)/iRes;\n    \n  \n    float FOV = 1.; // FOV - Field of view.\n    vec3 ro = vec3(0, 0, iTime*2. + sin(iTime)*.125);\n    // \"Look At\", \"forward\" and \"up\" vectors.\n    vec3 lk = ro + vec3(0, -.01, .25);\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt); \n\n    \n    // Camera.\n    mat3 mCam = mat3(rgt, up, fwd);\n    // There are ways to rotate the camera all at once, but these will do.\n    mCam *= rot(vec3(0, .05, 0)); \n    mCam *= rot(vec3(0, 0, -sin(iTime/2.)*.25)); \n    mCam *= rot(vec3(-cos(iTime/2.)*.25, 0, 0)); \n    \n    // Mouse driven camera movement.\n    if(iMouse.z>0.){\n        vec2 ms = (iMouse.xy/iResolution.xy - .5)*vec2(3.14159/2.);\n        mCam *= rot(vec3(0, ms.y/2., -ms.x));\n    }\n    \n    // Positioning the rolling ball.\n    sph4.x -= cos(iTime/2.)*.25; // Left to right.\n    sph4.z = ro.z + 4.; // In front of the camera.\n    \n    // Accumulative color.\n    vec3 aCol = vec3(0);\n    \n    float gT = 1e8;\n    float avgT = 0.;\n    \n    \n    for(int j = min(0, iFrame); j<sampNum; j++){\n        \n        // Seed value and jitter.\n        seed = uv0 + seed0 + vec2(j*57, j*27)/1321.;\n        vec2 jit = hash22()*2. - 1.;\n        \n        // Jittered UV coordinate.\n        vec2 uv = uv0 - jit/iResolution.y;\n\n        // Using the above to produce the unit ray-direction vector.\n        vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n\n        // Camera position. Initially set to the ray origin.\n        vec3 cam = ro;\n        // Surface postion. Also initially set to the ray origin.\n        vec3 sp = ro;\n\n        vec3 col = vec3(0);\n        \n        // Emissive, throughput and sample colors.\n        vec3 emissive = vec3(0);\n        vec3 through = vec3(1);\n        vec3 sCol = vec3(0);\n        \n        // Fog.\n        float fogD = 1e8;\n       \n        \n        // Just three bounces. More looks better, but the extra randomess\n        // requires more samples. For static scenes, that's not a problem,\n        // but this is a realtime one.\n        for(int i = min(0, iFrame); i<3; i++){\n\n            \n            vec3 scene = intersect(sp, rd); // Scene intersection.\n\n            float t = scene.x; // Scene distance.\n            float retVal = scene.y; // Redundant here, but used when refraction is involved.\n            float id = scene.z;// Object ID.\n            \n            // Set the fog distance on the first pass.\n            if(i==0){ \n                fogD = t;\n                avgT += t/float(sampNum);\n               if(j==0) gT = fogD;\n               \n            }\n\n            sp += rd*t; // Advance the ray position.\n\n  \n            if(t<1e8){\n\n                \n                vec3 sn = getNorm(sp, id); // Normal.\n\n                vec3 oCol = vec3(0), emissive = vec3(0); // Object color, and emissivity.\n\n                emissive = vec3(0);\n                float rough = 0.;\n\n               \n                if(id<.5) { \n                   \n                    // Placing an offset subdivided grid pattern on the sphere,\n                    // then randomly lighting up random cells.\n \n                    // Texture coordinates.\n                    vec3 txP = sp - sph4.xyz;\n                    // Rotation.\n                    txP.xy *= rot2(sph4.x/(sph4.w)/2.);\n                    txP.yz *= rot2(-sph4.z/(sph4.w));\n                    \n                    // An icosahedral mapping would probably look nicer, but I\n                    // wanted to do something different for this example.\n                    vec4 q3 = cubeMap(txP);\n                    float faceID = q3.w;\n                    \n                    // Distance field pattern:\n                    // Returns the distance field and cell ID.\n                    //vec3 d3 = distField((q3.xy/2. + .5), 2., q3.z);\n                    vec3 d3 = distField2((q3.xy/2. + .5), 6., q3.z, faceID);\n                    // Distance field isoline boundary.\n                    d3.x = smoothstep(0., sf, d3.x);\n\n                    float rnd2 = hash21(d3.yz + q3.z*.051 + faceID + .024);;\n                    float sRnd = rnd2;\n                    rnd2 = smoothstep(.4, .45, sin(6.2831*rnd2 + iTime/1.));\n                  \n \n                    // Render the pattern on the walls, ceiling and floor.\n                    vec3 wCol = .5 + .5*cos(6.2831*hash21(d3.yz + q3.z*5.51 + \n                                            faceID + .374)/2. + vec3(0, 1, 2)*1.1 - 0.);\n                    oCol = mix(vec3(.9, .95, 1)*(hash21(d3.yz + q3.z*2.035 + \n                                                faceID + .144)*.5 + .5), vec3(.1), d3.x);\n           \n                    wCol = wCol*vec3(4, 2, 1);  \n                   \n                    // Classier toned down colors.\n                    //wCol = mix(vec3(1), vec3(1, .4, .2), hash21(d3.yz + .14));\n                    // Flipping colors.\n                    //wCol =  mix(wCol, wCol.zyx, hash21(d3.yz + .14));   \n                    \n             \n                    emissive = mix(wCol*(rnd2*.785 + .015)*3.*vec3(1, .97, .92), \n                                    vec3(.005), d3.x);\n                     // Roughness.\n                    rough = hash21(d3.yz + q3.z + .11);\n                    //rough = smoothstep(.2, .8, rough)*.25;\n                    rough = rough*rough*.3 + .025;\n                    \n                    // Individual pixel roughness.\n                    rough *= hash31(sp + .51)*.5 + .75;\n                    //rough = min(rough + hash31(sp + .31)*.025, 1.);\n                    \n                   \n                    if(hash21(d3.yz + faceID + .063)<.5){\n                        oCol = vec3(1)*dot(oCol, vec3(.299, .587, .114));\n                        emissive = vec3(1)*dot(emissive, vec3(.299, .587, .114));\n                    }\n \n                   \n       \n          \n               }\n               else {\n\n                   \n                    // Producing a wall and floor pattern, coloring it, and using\n                    // parts to act as emitters.\n                    \n                    // Back wall or not.\n                    float sgn = (abs(sn.z)>.5)? 1. : -1.;\n                    // Wall ID.\n                    float wID = sgn < 0.? sp.y<0.? 0. : 2. : sp.z<0.? 1. : 3.;\n                    \n                    // UV coordinates for the walls and floors.\n                    vec2 q = sgn>.5? sp.xy : abs(sn.x)>.5? sp.yz : sp.xz;\n                    \n                    // Vertical strips and horizontal wall strips.\n                    float strip = abs(mod(sp.z, 4.) - 2.) - 3./6.;\n                    float yStrip = abs(sp.y - .5) - 1.5 + 1./6.;\n                    \n                    \n                    // Distance field pattern:\n                    // Returns the distance field and cell ID.\n                    vec3 d3;\n                    // \n                    if(strip<0. && yStrip<0.) d3 = distField2(q, 6., wID, id);\n                    else if(abs(sn.y)>.5) d3 = distField(q, 4., wID);\n                    else d3 = distField(q, 2., wID);\n                    \n                    //d3 = distField(q, 2., wID);\n                    \n                    // Distance field isoline boundary.\n                    d3.x = smoothstep(0., sf, d3.x);\n             \n \n                    // Cell and wall based colors.\n                    vec3 wCol = .5 + .5*cos(6.2831*hash21(d3.yz + wID*.054 + .274)/2. +\n                                            vec3(0, 1, 2)*1.1 - 1.5*1.);\n                    vec3 wCol2 = .5 + .5*cos(6.2831*hash21(d3.yz + wID*.054 + .273)/2. + \n                                             vec3(0, 1, 2)*1.1);\n   \n                    // Vertical colors and greyscale areas.\n                    if(strip>0.) wCol = vec3(1)*dot(wCol2, vec3(.299, .587, .114));\n                    else wCol = wCol2*vec3(4, 2, 1);\n\n                    // Greyscale the wall entirely.\n                    //wCol = vec3(1)*dot(wCol, vec3(.299, .587, .114));\n                    // Flipping wall colors.\n                    //wCol =  mix(wCol, wCol.zyx, hash21(d3.yz + .14));\n                    // Classier toned down colors.\n                    //wCol = mix(vec3(1), vec3(1, .4, .2), hash21(d3.yz + .14));\n                    \n   \n                    \n                    // The wall color pattern.\n                    oCol = mix(vec3(.9, .95, 1)*(hash21(d3.yz + wID*.054 + .174)*.5 + .5), \n                                                 vec3(.1), d3.x);\n\n                   \n                    // Emissivity.\n                    float rnd2 = hash21(d3.yz + .067); \n                    // Periodically blinking emissive colors.\n                    rnd2 = smoothstep(.4, .47, sin(6.2831*rnd2 + iTime/1.)*.5);\n                  \n                    // Pattern based emissivity -- It doesn't always have to be object \n                    // based. Only adding emissivity to the left and right wall strips.\n                    if(abs(sn.y)<.5 && yStrip<0.)\n                       emissive = mix(wCol*rnd2*4.*vec3(1, .97, .92), vec3(.005), d3.x);\n                    // More orange light.\n                    //if(abs(mod(sp.z, 4.) - 2.)<.5) \n                    //     emissive *= mix(wCol2*6.*vec3(1, .97, .92), vec3(.0), d3.x); \n                  \n                   \n                    // Dark strips.\n                    if(abs(sn.x)>.5 && abs(yStrip - .015) - .015<0.){ oCol *= 0.; }   \n      \n                     \n                    // Roughness.\n                    rough = hash21(d3.yz + wID*.021 + .11);\n                    rough = rough*rough*.3 + .025;\n                    // Individual pixel roughness.\n                    rough *= hash31(sp + .41)*.5 + .75;\n                     \n                }\n                \n                // Different emissivity variations.\n                //emissive = mix(emissive, emissive.zyx, .7).yxz;\n                //emissive = mix(emissive.zyx, emissive, uv0.y*1.5 + .5);\n                //emissive = vec3(1)*dot(emissive, vec3(.299, .587, .114));\n  \n                   \n  \n                // I definitely like the more natural way in which colors are applied\n                // when rendering this way. We only add surface color when it's been\n                // hit by a ray that has visited a light source at some point.\n                sCol += emissive*through;\n                // Applying this bounce's color to future bounces. For instance, if we\n                // hit a pink emitter then hit another surface later, that surface will\n                // incorporate a bit of pink into it.\n                through *= oCol;\n\n \n                vec3 ref = reflect(rd, sn); // Purely reflected vector.\n                vec3 rrd = cosDir(0., sn); // Random half hemisphere vector.\n                //vec3 rrd = normalize(hash23() - .5); // Less evenly distributed.\n\n         \n                // Mimicking surface inconsistancies with fuzzy reflections.\n                // Rougher surfaces have a greater chance of randomly reflecting at any \n                // direction and smoother surfaces are more likely to purely reflect.\n                //float rChance = step(rough*2. + .4, hash21(uv + vec2(i*277, j*113) + \n                //                     fract(iTime*.977 + .137)));\n                //rd = (mix(rrd, ref, rChance));\n                //rd = normalize(mix(ref, rrd, rough));\n             \n               \n                //rd = normalize(ref + rrd*rough);\n                rd = normalize(mix(ref, rrd, rough));\n                // Not sure this line matters too much, but with the fake random\n                // bounce above, I guess rays could head into the surface, so \n                // it's there, just in case.\n                if(dot(rd, sn)<0.) rd = -rd; \n\n\n                sp += sn*1e-5;\n                //rd = ref; // Pure reflection override.\n\n            } \n            \n            \n             if(aCol.x>1e5) break; // Attempting to reduce compile time. \n        }\n      \n        // Applying some fog, if necessary. You don't actually see this, but\n        // I want it there for completeness.\n        sCol = mix(vec3(0), sCol, 1./(1. + fogD*fogD*.02));\n\n        \n        // Accumulate the sample color.\n        aCol += sCol;\n        \n        if(sCol.x>1e5) break; // Attempting to reduce compile time.\n        \n        \n    }\n    \n    // Average color over all samples.\n    aCol /= float(sampNum);\n    \n    \n  \n    \n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./2.;//1./(1. + length(uv0)*3.); \n    fragColor = mix(preCol, vec4(max(aCol, 0.), avgT), blend);\n    \n    // No temporal blur, for comparisson.\n    //fragColor = vec4(max(aCol, 0.), 1);\n    \n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 888, 925, 971, 1747], [5712, 5712, 5766, 5794, 7249]], "test": "untested"}
{"id": "cd3yWN", "name": "Colorized Fake Sphere 3d", "author": "timmaffett", "description": "i just added visualizing XY.x as color\nfrom forked:\noriginal shader was forked from FabriceNeyret2.\nI forked it trying to make yhis 3d. Its not easy...\n", "tags": ["3d", "distortions", "dots", "short", "golf", "loopless"], "likes": 3, "viewed": 194, "published": 3, "date": "1695045905", "time_retrieved": "2024-07-30T17:33:16.227089", "image_code": "// Fork of \"Fake Sphere 3d\" by davidmachadosf. https://shadertoy.com/view/md3cDH\n// 2023-09-18 14:01:29\n\n// loopless + golfing 533 \"Sphere fake 3d\" by SnackEater. https://shadertoy.com/view/dljfWW\n// 272 without Jacobians -  288 with approx J  - 308 with exact J\n\n#define VISUALIZE_XY_Y_ALSO   0\n\nvec4 hsb2rgb( in vec4 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return vec4(c.z * mix( vec3(1.0), rgb, c.y), 1.);\n}\n\n\n#define ROT mat2(cos( iTime +vec4(.5,33,11,0.)))\n\nvoid mainImage( out vec4 COR, vec2 XY ) {\n\n    bool esq = int(XY.y)%2==0;\n    //if (!esq) {\n    //     XY.y = XY.y-1.;\n    //    return;\n   // }\n    \n\n    vec3  R = iResolution, P;\n    XY = ( 2.*XY - R.xy );\n    XY /= R.y;\n    \n    \n    float S = (1.+sin(iTime/1000.))*.05,\n          Z = 1. - dot(XY,XY);\n    \n    //COR = vec4(esq?1.:0., esq?0.:1., 0., 1.);\n    COR *= 0.;\n    Z > 0.                                                         // if on sphere\n      ? \n        P = vec3( XY, pow(Z,.5) ),                                    // 3D point on front half-sphere\n        P.yz *= ROT,\n        P.xz *= ROT,                                                 // rotate on sphere\n        XY =  vec2( atan(length(P.xy),P.z), atan(P.x,P.y) ),        // get parameterization\n        COR.g= 1. - length( ( mod( XY + S , 2.*S ) -S )               // draw blob at grid centers\n                          // / fwidth(XY) ) * 140./R.y                // compensate distorsion with Jacobian (approx)\n                          * inverse(transpose(mat2(dFdx(XY),dFdy(XY)))) )  * 1e2/R.y  // ( precise )\n      : S\n      ;\n      \n#if VISUALIZE_XY_Y_ALSO\n  COR = COR.g * hsb2rgb( vec4( (XY.x/5.+XY.y/10.0)*iTime/10.0, 0.9, 0.9, 1.0));\n#else\n  // XY.x only\n  COR = COR.g * hsb2rgb( vec4( (XY.x/5.)*iTime/10.0, 0.9, 0.9, 1.0));\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd3yWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 324, 324, 567], [620, 620, 661, 661, 1936]], "test": "untested"}
{"id": "DstcDH", "name": "Volcanic Eruption!", "author": "wyatt", "description": "fluid dynamics", "tags": ["fluid"], "likes": 14, "viewed": 387, "published": 3, "date": "1695019080", "time_retrieved": "2024-07-30T17:33:17.780934", "image_code": "// Fork of \"Shader Fluid\" by wyatt. https://shadertoy.com/view/mddyWn\n// 2023-09-18 04:40:16\n\nMain {\n    vec4 f = A(U);\n    Q = atan(4.*f.wwww/density)*(sin(-2.-.04*f.w+f.z*1.28+vec4(1,2,3,4)));\n    vec4 _;\n    float v = volcano (U,R,_);\n    if (v < 0.) {\n        vec2 u = +.1*sin(iTime*359.)+.1*vec2(1,-1)*sin(iTime*743.2);\n        Q = .3*Q+.6*texture(iChannel3,3.*(U+3.*u)/R);\n        Q = .9*Q+.4*texture(iChannel2,(U+u)/R);\n        Q = .9*Q+.4*texture(iChannel3,2.*(U+2.*u)/R);\n        float df = fwidth(Q.x);\n        if (abs(df) < .1)\n         Q *= df*3.+.5;\n    } else {\n        float a = .1+.01*iTime;\n        U *= 1.3*mat2(cos(a),-sin(a),sin(a),cos(a));\n        a = 1.2+.001*iTime;\n        vec4 bg = .7*texture(iChannel2,(U)/R);\n        U *= 1.3*mat2(cos(a),-sin(a),sin(a),cos(a));\n        bg = .7*bg+.3*texture(iChannel2,(U)/R);\n        U *= 1.3*mat2(cos(a),-sin(a),sin(a),cos(a));\n        bg = .7*bg+.3*texture(iChannel2,(U)/R);\n        bg = sin(-.1+pow(bg*1.6,vec4(6.))*vec4(2,3,3,4));\n        Q = mix(bg,Q,clamp(f.w*4.,0.,1.));\n    }\n    \n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U) \n\n#define density 1.5\n#define gravity 40.\n\n#define K .004*min(float(iFrame)/60.,60.)\n\n#define T0 2.6\n\n\n\nfloat volcano (vec2 U, vec2 r, out vec4 Q) {\n\n    float x = (U.x-.5*r.x)/r.x;\n    \n    float y = .25+exp(-20.*(sqrt(abs(x))*abs(x)))-\n             .01*sin(x*10.+19.*sin(x*32.)+12.*sin(3.*x))-\n             .05*sin(x*3.+2.*sin(x*22.)+1.*sin(13.*x))-\n             .9*exp(-pow(abs(x)*200.,12.));\n    vec2 v = U-vec2(.5,.04)*r;\n    float m = -sign(length(v)-.09*r.y-r.y*.1*atan(10.5*sin(atan(v.y,v.x))));\n    float h = sign(U.y-.6*r.y*y);\n    if (h >= m) {\n        Q = vec4(0);\n        return h;\n    } else {\n        Q = vec4(0,0,T0,7.);\n        return m;\n    }\n\n}", "buffer_a_code": "Main {\n\t\t\t\tQ = A(U);\n                vec2 v0 = Q.xy;\n\t\t\t\tfor(int x=-1;x<=1;x++)\n                for(int y=-1;y<=1;y++) \n                if (abs(x)!=abs(y)) {\n\t\t\t        vec2 xy = vec2(x,y);\n\t\t\t        vec4 a = A(U+xy);\n\t\t\t        Q.xy -= K*a.w*(a.w/density-1.+.2*a.z)*xy;\n                    Q.xy += K*(a.xy-v0)*exp(-1.5*a.z);\n\t\t\t    }\n\n\t\t\t    float G = gravity/R.y;\n\n\t\t\t    Q.y -= G;\n\n\n\n                vec4 _;\n                float s = volcano(U,R,_);\n                Q.xy *= .5+.5*s;\n                \n                \n\t\t\t\tif(U.x<1.||U.y<1.||\n\t\t\t\t   R.x-U.x<2.||R.y-U.y<2.) Q.xy *= 0.;\n                   \n                   \n    \n                    \n\n\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void fix (inout vec2 a, inout vec2 b) ;\nvec2 vel (vec2 v);\nvoid XY (vec4 a, inout vec4 dQ, vec2 U, int x, int y, int X, int Y, inout float n) {\n    vec4 _;\n    vec2 w = U+vec2(x+X,y+Y);\n    if (volcano(w,R,_)>0.&&w.x>1.&&w.y>1.&&R.x-w.x>2.&&R.y-w.y>1.) {\n        vec2 u = vec2(x,y)+vel(a.xy);\n        vec4 b = A(U+vec2(x,y)+vec2(X,Y));\n        vec2 v = vec2(x,y)+vec2(X,Y)+vel(b.xy);\n        float w = (.5+.5*clamp(1.-b.w*(b.z/T0),0.,1.))*length(vec2(X,Y));\n        v = u+w*(v-u);\n        float l = length(u-v);\n        fix(u,v);\n        float L = length(u-v);\n        if (l>0.) dQ += a.w*vec4(a.xyz,1)*L/l;\n        n ++;\n    }\n}\nvoid xy (inout vec4 Q, vec2 U, int x, int y) {\n    vec4 a = A(U+vec2(x,y));\n    float n = 0.;\n    vec4 dQ = vec4(0);\n    XY(a,dQ,U,x,y,1,0,n);\n    XY(a,dQ,U,x,y,0,1,n);\n    XY(a,dQ,U,x,y,-1,0,n);\n    XY(a,dQ,U,x,y,0,-1,n);\n    if (n>0.) Q += dQ/n;\n}\nMain {\n\n\n    \n    Q = vec4(0);\n    vec4 _;\n    \n    xy(Q,U,0,0);\n    xy(Q,U,0,1);\n    xy(Q,U,1,0);\n    xy(Q,U,0,-1);\n    xy(Q,U,-1,0);\n    \n    \n    if (Q.w>0.) Q.xyz /= Q.w;\n    Q = Q;\n    \n    \n                float s = volcano(U,R,_);\n                Q.xy *= .5+.5*s;\n\n}\n\nvec2 vel (vec2 v) {return .5*v*inversesqrt(1.+dot(v,v));}\nvoid fix (inout vec2 a, inout vec2 b) {\n\n    vec2 t;\n    {\n        vec2 u = (b-a);\n        float _1 = clamp(-(a.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(a.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(a.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(a.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        t = a+u*i;\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n    }\n    {\n        vec2 u = (a-b);\n        float _1 = clamp(-(b.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(b.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(b.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(b.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n        a = clamp(b+u*i,-.5,.5);\n    }   b = clamp(t,-.5,.5);\n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\t\t\t\tQ = A(U);\n                vec2 v0 = Q.xy;\n\t\t\t\tfor(int x=-1;x<=1;x++)\n                for(int y=-1;y<=1;y++) \n                if (abs(x)!=abs(y)) {\n\t\t\t        vec2 xy = vec2(x,y);\n\t\t\t        vec4 a = A(U+xy);\n\t\t\t        Q.xy -= K*a.w*(a.w/density-1.+.2*a.z)*xy;\n                    Q.xy += K*(a.xy-v0)*exp(-1.5*a.z);\n\t\t\t    }\n\n\t\t\t    float G = gravity/R.y;\n\n\t\t\t    Q.y -= G;\n\n                vec4 _;\n                float s = volcano(U,R,_);\n                Q.xy *= .5+.5*s;\n                if (_.w<1.) Q.z *= .999975;\n\n\t\t\t\tif(U.x<1.||U.y<1.||\n\t\t\t\t   R.x-U.x<2.||R.y-U.y<2.) Q.xy *= 0.;\n                   \n                   \n                   \n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q = vec4(-1,0,2., \n    density);\n\n\n        if (iFrame < 1) {\n\t\t\t\t\n\t\t\t\t\tQ = _;\n\t\t\t\t\t\n\t\t\t\t\t\n\n\t\t\t\t}\n\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void fix (inout vec2 a, inout vec2 b) ;\nvec2 vel (vec2 v);\nvoid XY (vec4 a, inout vec4 dQ, vec2 U, int x, int y, int X, int Y, inout float n) {\n    vec4 _;\n    vec2 w = U+vec2(x+X,y+Y);\n    if (volcano(w,R,_)>0.&&w.x>1.&&w.y>1.&&R.x-w.x>2.&&R.y-w.y>1.) {\n        vec2 u = vec2(x,y)+vel(a.xy);\n        vec4 b = A(U+vec2(x,y)+vec2(X,Y));\n        vec2 v = vec2(x,y)+vec2(X,Y)+vel(b.xy);\n        float w = (.5+.5*clamp(1.-b.w*(b.z/T0),0.,1.))*length(vec2(X,Y));\n        v = u+w*(v-u);\n        float l = length(u-v);\n        fix(u,v);\n        float L = length(u-v);\n        if (l>0.) dQ += a.w*vec4(a.xyz,1)*L/l;\n        n ++;\n    }\n}\nvoid xy (inout vec4 Q, vec2 U, int x, int y) {\n    vec4 a = A(U+vec2(x,y));\n    float n = 0.;\n    vec4 dQ = vec4(0);\n    XY(a,dQ,U,x,y,1,0,n);\n    XY(a,dQ,U,x,y,0,1,n);\n    XY(a,dQ,U,x,y,-1,0,n);\n    XY(a,dQ,U,x,y,0,-1,n);\n    if (n>0.) Q += dQ/n;\n}\nMain {\n\n\n    \n    Q = vec4(0);\n    vec4 _;\n    \n    xy(Q,U,0,0);\n    xy(Q,U,0,1);\n    xy(Q,U,1,0);\n    xy(Q,U,0,-1);\n    xy(Q,U,-1,0);\n    \n    \n    if (Q.w>0.) Q.xyz /= Q.w;\n    Q = Q;\n    \n    \n                float s = volcano(U,R,_);\n                Q.xy *= .5+.5*s;\n\n}\n\nvec2 vel (vec2 v) {return .5*v*inversesqrt(1.+dot(v,v));}\nvoid fix (inout vec2 a, inout vec2 b) {\n\n    vec2 t;\n    {\n        vec2 u = (b-a);\n        float _1 = clamp(-(a.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(a.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(a.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(a.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        t = a+u*i;\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n    }\n    {\n        vec2 u = (a-b);\n        float _1 = clamp(-(b.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(b.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(b.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(b.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n        a = clamp(b+u*i,-.5,.5);\n    }   b = clamp(t,-.5,.5);\n    \n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DsccDH", "name": "Ring - distance 2D", "author": "iq", "description": "Distance to a section of a ring.", "tags": ["2d", "sdf", "distancefunction", "distance", "distanefield"], "likes": 45, "viewed": 1726, "published": 3, "date": "1694997339", "time_retrieved": "2024-07-30T17:33:18.845089", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Distance to a section of a ring.\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and https://iquilezles.org/articles/distfunctions2d\n\n\nfloat sdRing( in vec2 p, in vec2 n, in float r, in float th )\n{\n    p.x = abs(p.x);\n    \n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-th*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-th*0.5)))*sign(p.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  \n    // animation\n    float t = 3.14159*(0.5+0.5*cos(iTime*0.52));\n    vec2 cs = vec2(cos(t),sin(t));\n    const float ra = 0.5;\n    const float th = 0.2;\n    \n    // distance\n    float d = sdRing(p, cs, ra, th);\n        \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-25.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = sdRing(m, cs, ra, th);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsccDH.jpg", "access": "api", "license": "mit", "functions": [[1256, 1256, 1319, 1319, 1496], [1498, 1498, 1555, 1591, 2459]], "test": "untested"}
{"id": "Dd3cDH", "name": "holy mobius donut", "author": "mds2", "description": "forked from an earlier shader, and minimally modified mostly for my own amusement.\n\nOriginal shader illustrated what a bagel looked like after being sliced by two mobius strips.\n\nEnvironment map chosen to make the setting more holy.\n", "tags": ["mobius", "slice", "bagel"], "likes": 2, "viewed": 169, "published": 3, "date": "1694980539", "time_retrieved": "2024-07-30T17:33:19.808513", "image_code": "const float max_dist = 10.0;\n\n\nfloat to_toroid_sdf(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  return to_toroid;\n}\n\nfloat sdf(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  float angle = atan(pt.x, pt.z);\n  vec2 p1 = vec2(sin(0.5 * angle), cos(0.5 *angle));\n  vec2 p2 = vec2(cos(0.5 * angle), -sin(0.5 *angle));\n  float d1 = dot(vec2(to_toroid_spine, pt.y), p1);\n  float d2 = dot(vec2(to_toroid_spine, pt.y), p2);\n  float max_angle_dist = min(max(d1, d2), max(-d1, -d2));\n  return max(to_toroid, max_angle_dist);\n}\n\nfloat sdf_other_side(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  float angle = atan(pt.x, pt.z);\n  vec2 p1 = vec2(sin(0.5 * angle), cos(0.5 *angle));\n  vec2 p2 = vec2(cos(0.5 * angle), -sin(0.5 *angle));\n  float d1 = dot(vec2(to_toroid_spine, pt.y), p1);\n  float d2 = dot(vec2(to_toroid_spine, pt.y), p2);\n  float max_angle_dist = min(max(-d1, d2), max(d1, -d2));\n  return max(to_toroid, max_angle_dist);\n}\n\nfloat rough_raycast(in vec3 orig, in vec3 dir) {\n  float accum = 0.0;\n  float d = to_toroid_sdf(orig);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.9 * d;\n    vec3 pt = orig + accum * dir;\n    d = to_toroid_sdf(pt);\n    if (abs(d) < 1.0e-2) {\n      return accum;\n    }\n    if (d > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\n\nfloat raycast(in vec3 orig, in vec3 dir, float start_guess) {\n  float accum = start_guess;\n  if (accum > max_dist) {\n    return accum;\n  }\n  float d = sdf(orig + accum * dir);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.7 * d;\n    vec3 pt = orig + accum * dir;\n    d = sdf(pt);\n    if (abs(d) < 1.0e-6) {\n      return accum;\n    }\n    if (accum > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\nfloat raycast_other_side(in vec3 orig, in vec3 dir, float start_guess) {\n  float accum = start_guess;\n  if (accum > max_dist) {\n    return accum;\n  }\n  float d = sdf_other_side(orig + dir * accum);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.7 * d;\n    vec3 pt = orig + accum * dir;\n    d = sdf_other_side(pt);\n    if (d < 1.0e-6) {\n      return accum;\n    }\n    if (d > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\n\nvec3 get_norm(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nvec3 get_norm_other_side(in vec3 pt) {\n  float f = sdf_other_side(pt);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf_other_side(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf_other_side(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf_other_side(pt + vec3(0.0, 0.0, h)) - f));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float uv_scale = min(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / uv_scale;\n    \n    vec3 orig = vec3(0.0, 0.0, -1.5);\n    vec3 ray = normalize(2.0 * vec3(uv, 0) - orig);\n    \n    float theta_tilt = 2.0 * iMouse.y / iResolution.y - 1.0;\n    theta_tilt *= 3.141592654 * 0.5;\n    float ct = cos(theta_tilt);\n    float st = sin(theta_tilt);\n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                       0.0, ct, -st,\n                       0.0, st, ct);\n    \n    float phi_yaw = 3.0 * 3.141592654 * (2.0 * iMouse.x / iResolution.x - 1.0);\n    float cp = cos(phi_yaw);\n    float sp = sin(phi_yaw);\n    mat3 yaw = mat3(cp, 0.0, -sp,\n                    0.0, 1.0, 0.0,\n                    sp, 0.0, cp);\n    orig = yaw * tilt * orig;\n    ray = yaw * tilt * ray;\n    \n    float bright = 0.95;\n    \n    vec3 overlay = vec3(0.5);\n    \n    vec3 col = vec3(0.0);\n    \n    float start_guess = rough_raycast(orig, ray);\n\n    float dist = raycast(orig, ray, start_guess);\n    if (dist < max_dist) {\n      overlay = vec3(0.0);\n      vec3 n = get_norm(orig + dist * ray);\n      // pixel color\n      vec3 bounce = normalize(reflect(ray, n));\n      col = smoothstep(vec3(0.0), vec3(1.0), texture(iChannel1, bounce).rgb) + 0.2 * bounce;\n      bright = 1.0;\n    } else {\n      col = texture(iChannel0, normalize(ray)).rgb;\n      bright = 0.5;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(bright * col + overlay,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3cDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 64, 64, 198], [200, 200, 223, 223, 679], [681, 681, 715, 715, 1171], [1173, 1173, 1221, 1221, 1533], [1536, 1536, 1597, 1597, 1963], [1965, 1965, 2037, 2037, 2416], [2419, 2419, 2446, 2446, 2668], [2670, 2670, 2708, 2708, 2974], [2977, 2977, 3034, 3034, 4532]], "test": "untested"}
{"id": "dlBfRt", "name": "Cup SDF by Lurker", "author": "lurker", "description": "sdf", "tags": ["sdf"], "likes": 4, "viewed": 208, "published": 3, "date": "1694978131", "time_retrieved": "2024-07-30T17:33:20.692151", "image_code": "const int MAXSTEP = 500;\nconst float MAXDIST = 200.0;\nconst float TOL = 0.001;\nconst float PI = 3.1415;\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n\treturn triW / (triW.x + triW.y + triW.z);\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Camera matrix.\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(cameraPos - lookAtPoint); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\n\treturn mat3(cr, cu, cd);\n}\n\nstruct sdfCol\n{\n    float sdf;\n    vec4 col;\n};\n\nfloat sdSphere( in vec3 p, in float r, in vec3 offset )\n{\n    return length( p - offset ) - r;\n}\n\nfloat sdFloor( in vec3 p )\n{\n    return p.y + 3.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x, p.z);\n  return length(q)-t.y;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat length2( vec3 p ) { p=p*p; return sqrt(p.x+p.y+p.z); }\nfloat length2( vec2 p ) { p=p*p; return sqrt(p.x+p.y); }\n\nfloat length4( vec3 p ) { p=p*p; p=p*p; return pow(p.x+p.y+p.z, 1.0/4.0); }\nfloat length4( vec2 p ) { p=p*p; p=p*p; return pow(p.x+p.y, 1.0/4.0); }\n\nfloat length6( vec3 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y+p.z, 1.0/6.0); }\nfloat length6( vec2 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y, 1.0/6.0); }\n\nfloat length8( vec3 p ) { p=p*p; p=p*p; p=p*p; return pow(p.x+p.y+p.z, 1.0/8.0); }\nfloat length8( vec2 p ) { p=p*p; p=p*p; p=p*p; return pow(p.x+p.y, 1.0/8.0); }\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length4(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length4(max(d,0.0)) - 0.05;\n}\n\nfloat sdf( in vec3 p )\n{\n    float cyl1 = sdCappedCylinder( p + vec3(0.0, 0.0, 1.0), 0.5, 0.5 );\n    float cyl2 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.38, 0.4 );\n    \n    float cyl3 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.2, 0.4 );\n    float water = cyl3 + 0.02*sin(2.0*p.x + 3.0*p.y + 4.0*p.z + iTime*2.0);\n    \n    float cup = opSmoothSubtraction(cyl2, cyl1, 0.1);\n    \n    float handle = sdTorus( p + vec3(-0.5, 0.0, 1.0), vec2(0.38, 0.08) );\n    handle = opSmoothSubtraction(cyl1, handle, 0.08);\n    \n    float contents = max(water, cyl2);\n    \n    float bgfloor = sdFloor(p);\n    \n    return min(min(opSmoothUnion(cup, handle, 0.08), contents), bgfloor);\n}\n\nsdfCol sdfWithCol( in vec3 p )\n{\n    float cyl1 = sdCappedCylinder( p + vec3(0.0, 0.0, 1.0), 0.5, 0.5 );\n    float cyl2 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.38, 0.4 );\n    \n    float cyl3 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.2, 0.4 );\n    float water = cyl3 + 0.02*sin(2.0*p.x + 3.0*p.y + 4.0*p.z + iTime*2.0);\n    \n    float cup = opSmoothSubtraction(cyl2, cyl1, 0.1);\n    \n    float handle = sdTorus( p + vec3(-0.5, 0.0, 1.0), vec2(0.38, 0.08) );\n    handle = opSmoothSubtraction(cyl1, handle, 0.08);\n    \n    // three main components\n    float cuphandle = opSmoothUnion(cup, handle, 0.08);\n    float contents = max(water, cyl2);\n    float bgfloor = sdFloor(p);\n    \n    vec4 col = vec4( 0.0, 0.0, 0.0, 1.0 );\n    float curMin = 0.0;\n    // step 1\n    if (cuphandle < contents)\n    {\n        col = vec4( 1.0, 0.0, 0.0, 1.0 );\n        curMin = cuphandle;\n    }\n    else\n    {\n        col = vec4( 0.0, 0.0, 1.0, 1.0 );\n        curMin = contents;\n    }\n\n    return sdfCol( curMin, col );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    float e = 0.0005;\n    float dx = sdf(vec3( p.x + e, p.y, p.z )) - sdf(vec3( p.x - e, p.y, p.z ));\n    float dy = sdf(vec3( p.x, p.y + e, p.z )) - sdf(vec3( p.x, p.y - e, p.z ));\n    float dz = sdf(vec3( p.x, p.y, p.z + e )) - sdf(vec3( p.x, p.y, p.z - e ));\n    return normalize(vec3( dx, dy, dz ));\n}\n\nvec3 trace( in vec3 org, in vec3 dir, out bool hit )\n{\n    hit = false;\n    float totalDist = 0.0;\n    float dist = 0.0;\n    vec3 p = org;\n    for ( int step = 0; step < MAXSTEP; step++ )\n    {\n        dist = sdf( p );\n        if ( dist < TOL )\n        {\n            hit = true;\n            break;\n        }\n        \n        p += dir * dist;\n        totalDist += dist;\n        if ( totalDist > MAXDIST )\n        {\n            break;\n        }\n    }\n    \n    return p;\n}\n\nvec3 traceWithCol( in vec3 org, in vec3 dir, out bool hit, out vec4 col )\n{\n    hit = false;\n    float totalDist = 0.0;\n    sdfCol dist;\n    vec3 p = org;\n    for ( int step = 0; step < MAXSTEP; step++ )\n    {\n        sdfCol dist = sdfWithCol( p );\n        if ( dist.sdf < TOL )\n        {\n            hit = true;\n            col = dist.col;\n            break;\n        }\n        \n        p += dir * dist.sdf;\n        totalDist += dist.sdf;\n        if ( totalDist > MAXDIST )\n        {\n            col = vec4( 1.0, 0.0, 1.0, 1.0 );\n            break;\n        }\n    }\n\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 mouse = iMouse;\n    mouse.xy = (mouse.xy / iResolution.xy);\n    \n    \n    vec4 col = vec4( 0.0, 0.0, 0.0, 1.0 );\n    vec3 lightPos = vec3( 2.0, 4.0, 4.0 );\n    \n    vec3 lp = vec3( 0.0, 0.0, -1.0 );\n    vec3 ro = vec3( 1.0, 1.5, 1.0 );\n    \n    // Camera rotation with mouse\n    if ( mouse.z > 0.0 )\n    {\n        ro = vec3( 0.0, 0.0, 3.5 );\n        ro.xz = lp.xz + rotate2d(mix(-PI/2.0, PI/2.0, mouse.x)) * ro.xz;\n        ro.yz = lp.yz + rotate2d(mix(-PI/6.0, PI/2.0, mouse.y)) * ro.yz;\n    }\n    \n    \n    vec3 dir = camera( ro, lp ) * normalize( vec3( uv.xy, -1.0 ) );\n    bool hit = false;\n    float todist = 0.0;\n    // vec3 p = trace( ro, dir, hit );\n    vec3 p = traceWithCol( ro, dir, hit, col );\n    if ( hit )\n    {\n        \n        // lighting\n        vec3 lightDir = normalize( lightPos - p );\n        vec3 normal = calcNormal( p );\n        float dif = clamp( dot( normal, lightDir ), 0.2, 1.0 );\n        \n        vec3 tx = getTriplanarWeights( normal );\n        if ( col == vec4( 0.0, 0.0, 1.0, 1.0 ) )\n        {\n            // water texture\n            vec4 cx = texture( iChannel0, p.yz );\n            vec4 cy = texture( iChannel0, p.zx );\n            vec4 cz = texture( iChannel0, p.xy );\n            col = dif * (tx.x * cx + tx.y + cy + tx.z * cz);\n        }\n        else\n        {\n            // cup wood texture\n            vec4 cx = texture( iChannel1, p.yz );\n            vec4 cy = texture( iChannel1, p.zx );\n            vec4 cz = texture( iChannel1, p.xy );\n            col = dif * (tx.x * cx + tx.y + cy + tx.z * cz);\n        }\n    }\n    else\n        col = texture( iChannel2, dir );\n\n\n    fragColor = col;\n    \n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Water caustics by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .3;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 p = mod(uv*TAU*1.0, TAU)-250.0;\n\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.6), 0.0, 1.0);\n    \n\tfragColor = vec4(colour, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 146, 146, 212], [214, 214, 242, 242, 312], [314, 352, 379, 379, 526], [528, 566, 593, 593, 740], [742, 780, 807, 807, 954], [956, 976, 993, 993, 1087], [1089, 1107, 1154, 1154, 1364], [1415, 1415, 1472, 1472, 1511], [1513, 1513, 1541, 1541, 1565], [1567, 1567, 1600, 1600, 1666], [1668, 1668, 1720, 1720, 1819], [1821, 1821, 1879, 1879, 1979], [1981, 1981, 2040, 2040, 2139], [2141, 2141, 2166, 2166, 2201], [2202, 2202, 2227, 2227, 2258], [2260, 2260, 2285, 2285, 2335], [2336, 2336, 2361, 2361, 2407], [2409, 2409, 2434, 2434, 2486], [2487, 2487, 2512, 2512, 2560], [2562, 2562, 2587, 2587, 2644], [2645, 2645, 2670, 2670, 2723], [2725, 2725, 2777, 2777, 2893], [2895, 2895, 2919, 2919, 3573], [3575, 3575, 3607, 3607, 4585], [4587, 4587, 4617, 4617, 4923], [4925, 4925, 4979, 4979, 5394], [5396, 5396, 5471, 5471, 5977], [5980, 5980, 6037, 6037, 7750]], "test": "untested"}
{"id": "mddyWn", "name": "Shader Fluid", "author": "wyatt", "description": "fluid dynamics and surface tension", "tags": ["fluid"], "likes": 17, "viewed": 374, "published": 3, "date": "1694959885", "time_retrieved": "2024-07-30T17:33:29.461704", "image_code": "Main {\n    vec4 a = A(U);\n    Q = atan(a.wwww/density)*(sin(-2.+a.z*a.z*3.5+vec4(1,2,3,4)));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U) \n\n#define density 1.\n#define gravity .5\n\n#define K .05\n\n\n\n", "buffer_a_code": "Main {\n\t\t\t\tQ = A(U);\n\t\t\t\tfor(int x=-1;x<=1;x++)\n                for(int y=-1;y<=1;y++) \n                if (abs(x)!=abs(y)) {\n\t\t\t        vec2 xy = vec2(x,y);\n\t\t\t        vec4 a = A(U+xy);\n\t\t\t        Q.xy -= K*a.w*(a.w/density-1.)*xy;\n\t\t\t    }\n\n\t\t\t    float G = gravity/R.y;\n\n\t\t\t    Q.y -= G;\n    \n                    \n\n\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void fix (inout vec2 a, inout vec2 b) ;\nvec2 vel (vec2 v);\nvoid XY (vec4 a, inout vec4 dQ, vec2 U, int x, int y, int X, int Y, inout float n) {\n    vec4 _;\n    vec2 w = U+vec2(x+X,y+Y);\n    if (w.x>1.&&w.y>10.&&R.x-w.x>1.&&R.y-w.y>1.) {\n        vec2 u = vec2(x,y)+vel(a.xy);\n        vec4 b = A(U+vec2(x,y)+vec2(X,Y));\n        vec2 v = vec2(x,y)+vec2(X,Y)+vel(b.xy);\n        float w = (.5+.5*clamp(1.-b.w,0.,1.))*length(vec2(X,Y));\n        v = u+w*(v-u);\n        float l = length(u-v);\n        fix(u,v);\n        float L = length(u-v);\n        if (l>0.) dQ += a.w*vec4(a.xyz,1)*L/l;\n        n ++;\n    }\n}\nvoid xy (inout vec4 Q, vec2 U, int x, int y) {\n    vec4 a = A(U+vec2(x,y));\n    float n = 0.;\n    vec4 dQ = vec4(0);\n    XY(a,dQ,U,x,y,1,0,n);\n    XY(a,dQ,U,x,y,0,1,n);\n    XY(a,dQ,U,x,y,-1,0,n);\n    XY(a,dQ,U,x,y,0,-1,n);\n    if (n>0.) Q += dQ/n;\n}\nMain {\n\n\n    \n    Q = vec4(0);\n    vec4 _;\n    \n    xy(Q,U,0,0);\n    xy(Q,U,0,1);\n    xy(Q,U,1,0);\n    xy(Q,U,0,-1);\n    xy(Q,U,-1,0);\n    \n    \n    if (Q.w>0.) Q.xyz /= Q.w;\n    Q = Q;\n    \n    \n\n}\n\nvec2 vel (vec2 v) {return .5*v*inversesqrt(1.+dot(v,v));}\nvoid fix (inout vec2 a, inout vec2 b) {\n\n    vec2 t;\n    {\n        vec2 u = (b-a);\n        float _1 = clamp(-(a.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(a.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(a.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(a.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        t = a+u*i;\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n    }\n    {\n        vec2 u = (a-b);\n        float _1 = clamp(-(b.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(b.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(b.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(b.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n        a = clamp(b+u*i,-.5,.5);\n    }   b = clamp(t,-.5,.5);\n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\t\t\t\tQ = A(U);\n\t\t\t\tfor(int x=-1;x<=1;x++)\n                for(int y=-1;y<=1;y++) \n                if (abs(x)!=abs(y)) {\n\t\t\t        vec2 xy = vec2(x,y);\n\t\t\t        vec4 a = A(U+xy);\n\t\t\t        Q.xy -= K*a.w*(a.w/density-1.)*xy;\n\t\t\t    }\n\n\t\t\t    float G = gravity/R.y;\n\n\t\t\t    Q.y -= G;\n\n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q = vec4(-1,0,.5+.4*sin(.2*iTime), \n    .5*density);\n        \n            if (U.y<10.||R.y-U.y<1.||R.x-U.x<1.||U.x<1.) Q *= 0.;\n            if (R.x-U.x<3.||U.x<3.||U.y<15.) Q.xy *= .6;\n\n        if (iFrame < 1) {\n\t\t\t\t\n\t\t\t\t\tQ = vec4(0);\n\n\t\t\t\t\tQ.z = floor(U.x/R.x*20.)/20.;\n                       \n                       \n                    if (length(U-vec2(.5,.7)*R) < .12*R.y) \n                        Q.w = .8*density,Q.y = -4.,Q.z = .2+U.y/R.y;\n                    \n                    if (U.y < .35*R.y) Q.w = density*.9+(.35*R.y-U.y)*G*.01*K;\n\t\t\t\t\t\n\t\t\t\t\t\n\n\t\t\t\t}\n\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void fix (inout vec2 a, inout vec2 b) ;\nvec2 vel (vec2 v);\nvoid XY (vec4 a, inout vec4 dQ, vec2 U, int x, int y, int X, int Y, inout float n) {\n    vec4 _;\n    vec2 w = U+vec2(x+X,y+Y);\n    if (w.x>1.&&w.y>10.&&R.x-w.x>1.&&R.y-w.y>1.) {\n        vec2 u = vec2(x,y)+vel(a.xy);\n        vec4 b = A(U+vec2(x,y)+vec2(X,Y));\n        vec2 v = vec2(x,y)+vec2(X,Y)+vel(b.xy);\n        float w = (.5+.5*clamp(1.-b.w,0.,1.))*length(vec2(X,Y));\n        v = u+w*(v-u);\n        float l = length(u-v);\n        fix(u,v);\n        float L = length(u-v);\n        if (l>0.) dQ += a.w*vec4(a.xyz,1)*L/l;\n        n ++;\n    }\n}\nvoid xy (inout vec4 Q, vec2 U, int x, int y) {\n    vec4 a = A(U+vec2(x,y));\n    float n = 0.;\n    vec4 dQ = vec4(0);\n    XY(a,dQ,U,x,y,1,0,n);\n    XY(a,dQ,U,x,y,0,1,n);\n    XY(a,dQ,U,x,y,-1,0,n);\n    XY(a,dQ,U,x,y,0,-1,n);\n    if (n>0.) Q += dQ/n;\n}\nMain {\n\n\n    \n    Q = vec4(0);\n    vec4 _;\n    \n    xy(Q,U,0,0);\n    xy(Q,U,0,1);\n    xy(Q,U,1,0);\n    xy(Q,U,0,-1);\n    xy(Q,U,-1,0);\n    \n    \n    if (Q.w>0.) Q.xyz /= Q.w;\n    Q = Q;\n    \n    \n\n}\n\nvec2 vel (vec2 v) {return .5*v*inversesqrt(1.+dot(v,v));}\nvoid fix (inout vec2 a, inout vec2 b) {\n\n    vec2 t;\n    {\n        vec2 u = (b-a);\n        float _1 = clamp(-(a.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(a.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(a.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(a.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        t = a+u*i;\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n    }\n    {\n        vec2 u = (a-b);\n        float _1 = clamp(-(b.x-.5)/u.x,0.,1.);\n        float _2 = clamp(-(b.x+.5)/u.x,0.,1.);\n        float _3 = clamp(-(b.y-.5)/u.y,0.,1.);\n        float _4 = clamp(-(b.y+.5)/u.y,0.,1.);\n        float i = max(min(_1,_3),min(_2,_4));\n        if (u.x == 0.) i = max(_3,_4);\n        else if (u.y == 0.) i = max(_1,_2);\n        a = clamp(b+u*i,-.5,.5);\n    }   b = clamp(t,-.5,.5);\n    \n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cdtyDr", "name": "Cornell-ish box", "author": "AArt1256", "description": "Another path-tracer! :D", "tags": ["sphere", "pathtracer", "cornell"], "likes": 5, "viewed": 213, "published": 3, "date": "1694953459", "time_retrieved": "2024-07-30T17:33:30.523864", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );    \n    vec3 col = data.xyz/data.w;\n    \n\tfragColor = vec4( pow(col, vec3(0.45)), 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct HitInfo {\n    bool hit;\n    float dst;\n    vec3 point;\n    vec3 normal;\n    vec3 col;\n    vec3 mat;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nHitInfo RaySphere(Ray ray, vec3 center, float radius) {\n    HitInfo hitInfo;\n    hitInfo.hit = false;\n    vec3 offsetRayOrigin = ray.origin - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - (radius * radius);\n    float disc = b*b-4.*a*c;\n    float  dst = (-b - sqrt(disc)) / (2. * a);\n    if (dst >= 0.) {\n        hitInfo.hit = true;\n        hitInfo.dst = dst;\n        hitInfo.point = ray.origin + ray.dir * dst;\n        hitInfo.normal = normalize(hitInfo.point - center);\n    }\n    return hitInfo;\n}\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\n#define sphere(pos,rad,Col,Mat) hitInfo = RaySphere(ray,pos,rad); if (hitInfo.hit && hitInfo.dst < closestHit.dst) { closestHit = hitInfo; closestHit.col = Col; closestHit.mat = Mat; }\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    vec2 i = (-iResolution.xy + 2.0*fragCoord + hash2(g_seed))/iResolution.y;\n    vec3 viewPoint = vec3(i, 1);\n    Ray ray;\n    float rotx = 0.;\n    float roty = 0.;\n    ray.origin = vec3(0,0,2.);\n    ray.dir = normalize(viewPoint - ray.origin);\n    ray.dir *= rotate_x(roty);\n    ray.dir *= rotate_y(rotx);\n    vec3 lit = vec3(0.);\n    vec3 col = vec3(1.);\n    HitInfo closestHit;\n    HitInfo hitInfo;\n    for (int j = 0; j <= 8; j++) {\n        closestHit.dst = 1e5;\n        sphere(vec3(0,0,-110.),100.,vec3(1,1,1),vec3(0));\n        sphere(vec3(0,-100,-10),100.,vec3(1,.4,0),vec3(0));\n        sphere(vec3(0,110,-10),100.,vec3(1,1,1),vec3(0));\n        sphere(vec3(-110,0,-10),100.,vec3(1,0,0),vec3(0));\n        sphere(vec3(110,0,-10),100.,vec3(0,0,1),vec3(0));\n        \n        sphere(vec3(0,15,-4),6.,vec3(1. ,1.,1),vec3(1,0,0));\n\n        sphere(vec3(0,0,0),.5,vec3(1. ,1.,1),vec3(0,.7,0));\n        sphere(vec3(-1.2,0,0),.5,vec3(0,1,0),vec3(0));\n        sphere(vec3(1.2,0,0),.5,vec3(0,0,1),vec3(0));\n        if (closestHit.hit) {\n            ray.origin = closestHit.point;\n            vec3 dif = normalize(closestHit.normal + random_in_unit_sphere(g_seed));\n            vec3 spec = reflect(ray.dir, closestHit.normal);\n            ray.dir = mix(dif,spec,closestHit.mat.y);\n            lit += col * closestHit.mat.x;\n            col *= closestHit.col.xyz;\n        } else break;\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n    C = data;\n    if (iFrame == 0) C = vec4(0);\n    else C += vec4(lit,1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 235]], "test": "untested"}
{"id": "ms3cWn", "name": "Sin Interference Cineshader", "author": "natet", "description": "sin interference but cineshader and colourful", "tags": ["cineshader"], "likes": 1, "viewed": 940, "published": 3, "date": "1694912092", "time_retrieved": "2024-07-30T17:33:31.627912", "image_code": "float map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n\tvec2 centre = iResolution.xy*0.5;\n    float distCentre = distance(fragCoord.xy,centre);\n    float dCSin = sin(distCentre*0.05);\n    \n    vec2 anim = vec2(map(sin(iTime),-1.0,1.0,0.0,iResolution.x),map(sin(iTime*1.25),-1.0,1.0,0.0,iResolution.y));\n    float distMouse = distance(fragCoord.xy,anim);\n    float dMSin = sin(distMouse*0.05);\n    \n    float greycol = (((dMSin * dCSin) + 1.0) * 0.5);\n    greycol = greycol*map(d,0.0,1.4142135623730951,0.5,0.0);\n    \n    #ifdef IS_CINESHADER\n    fragColor = vec4(col, greycol);\n    #else\n\tfragColor = vec4(greycol*col.x,greycol*col.y,greycol*col.z,1.0);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3cWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 138], [140, 140, 197, 247, 1173]], "test": "untested"}
{"id": "DscyWr", "name": "fractal!", "author": "01000001", "description": "cool huh? Kinda made it by accident LOL. Really simple code! Original intention was to create a maze generator, but as you can see, my logic was flawed and it branched :D\n\nSee only new pixels https://www.shadertoy.com/view/mscyDH", "tags": ["fractal"], "likes": 7, "viewed": 219, "published": 3, "date": "1694906026", "time_retrieved": "2024-07-30T17:33:32.477640", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    O = texture(iChannel0, U/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U ){\n\nif (iFrame < 20){\n\n    O = vec4(0);\n    if (U == vec2(.5)){\n        O += 1.;\n    }\n\n} else {\n\n    O = texelFetch(iChannel0, ivec2(U), 0);\n    \n    int sum = 0;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            sum += int(texelFetch(iChannel0, ivec2(U) + ivec2(x, y), 0).x);\n        }\n    }\n    \n    \n    O = sum==1?vec4(1):O;\n\n}}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 85]], "test": "untested"}
{"id": "cs3yWr", "name": "LowRes WorldMap", "author": "Blindman67", "description": "World map as equirectangular projection", "tags": ["worldmap"], "likes": 5, "viewed": 205, "published": 3, "date": "1694904303", "time_retrieved": "2024-07-30T17:33:33.690397", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord / iResolution.xy);\n    fragColor = texture(iChannel0, mod(vec2(0.5, -1.0) * uv + vec2(0.0, 1.0), vec2(float(IMG_SIZE.x) / iResolution.x, float(IMG_SIZE.y) / iResolution.y)) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//---------------------------------------------------------------------------------------------------------------------------------\n// Work by Blindman67. \n// PainterV3 Image Export: localProcessImage.SaveShaderToyImage('BlankMap-Equirectangular.svg', unnamedPallet);\n// The map shows the whole world in an equirectangular projection\n// The map is squashed to fit compression format 256,256. Scale width by 2 to correct\n//---------------------------------------------------------------------------------------------------------------------------------\n\n// Image: Creative Commons CC0 1.0 Universal Public Domain Dedication\nconst uvec3 IMG_SIZE = uvec3(256u, 256u, 1u);  // x, y, palletSize\nconst vec3 pallet[1] = vec3[](vec3(1.000, 1.000, 1.000));\nconst uint img[1410] = uint[](\n    0x1000100u, 0x1000100u, 0x1000100u, 0x1000100u, 0x1000100u, 0x106010cu, 0x112011cu, 0x12c013cu, 0x14a015eu, 0x16e017au, 0x19001a8u, 0x1bc01c8u, 0x1e001f8u, 0x2140233u, 0x2470263u, 0x28102a0u,\n    0x2bd02ccu, 0x2df02f3u, 0x307031bu, 0x32d0339u, 0x3490359u, 0x367037bu, 0x38b03a1u, 0x3b503c7u, 0x3d503e5u, 0x3f10401u, 0x40f041fu, 0x42d043bu, 0x4450451u, 0x45f0469u, 0x46f0475u, 0x481048du,\n    0x49904a5u, 0x4b504c5u, 0x4d504e7u, 0x4f7050bu, 0x51d0531u, 0x53f0551u, 0x5630571u, 0x57f058du, 0x597059fu, 0x5a905b3u, 0x5bd05c5u, 0x5cf05ddu, 0x5e705f3u, 0x5ff060bu, 0x6190625u, 0x633063du,\n    0x6490657u, 0x6650673u, 0x6850697u, 0x6a906b9u, 0x6c506d3u, 0x6e506f1u, 0x6fb0707u, 0x7130721u, 0x72f073fu, 0x74d075bu, 0x76b0777u, 0x783078du, 0x79b07a7u, 0x7b307bdu, 0x7c707d1u, 0x7dd07ebu,\n    0x7f707ffu, 0x80f081fu, 0x82b083du, 0x8490855u, 0x85f0867u, 0x873087bu, 0x8850893u, 0x89f08a7u, 0x8ab08afu, 0x8b708bfu, 0x8c908d5u, 0x8df08e9u, 0x8f508ffu, 0x9090911u, 0x9190921u, 0x9290933u,\n    0x93b0943u, 0x94b0953u, 0x95b0961u, 0x967096du, 0x9730979u, 0x97f0985u, 0x98b0991u, 0x99909a1u, 0x9a909b3u, 0x9bb09c1u, 0x9c909cfu, 0x9d509ddu, 0x9e109e5u, 0x9e909f3u, 0x9f909ffu, 0xa050a09u,\n    0xa0d0a11u, 0xa150a19u, 0xa1b0a1du, 0xa1f0a23u, 0xa250a27u, 0xa2b0a2du, 0xa2f0a31u, 0xa350a37u, 0xa370a37u, 0xa370a37u, 0xa370a37u, 0xa370a37u, 0xa370a37u, 0xa370a39u, 0xa3b0a3du, 0xa3f0a4bu,\n    0xa510a59u, 0xa5f0a69u, 0xa730a7bu, 0xa810a8bu, 0xa970a9du, 0xaa50aabu, 0xaaf0ab3u, 0xab70abdu, 0xac30acdu, 0xadb0ae3u, 0xae70aedu, 0xaf10af7u, 0xaf90afcu, 0xafd0afeu, 0xaff0b00u, 0xb010b02u,\n    0x60010200u, 0x1010100u, 0x1010700u, 0x46010d00u, 0xb010100u, 0x1011000u, 0x40011300u, 0x1011d00u, 0x3010200u, 0x3d010100u, 0x2011100u, 0x3012300u, 0x31010100u, 0x1a010100u, 0x3c010400u, 0x2010200u,\n    0x1010a00u, 0x1012400u, 0x2f010100u, 0x1010100u, 0x4010200u, 0x15010400u, 0x39010100u, 0x1011200u, 0x5012100u, 0x15010100u, 0x2010100u, 0x1010600u, 0x2e010100u, 0x1010400u, 0x35010300u, 0x5010600u,\n    0x1010600u, 0x5012300u, 0x16010600u, 0x35010400u, 0x1010200u, 0x30010200u, 0x4010300u, 0x1010200u, 0x1010400u, 0x1010900u, 0x1012500u, 0x17010200u, 0x1010300u, 0x1010100u, 0x37010400u, 0x2e010300u,\n    0x7010100u, 0x6010100u, 0x1010700u, 0x5012400u, 0x19010300u, 0x2010200u, 0x38010100u, 0x2a010300u, 0xe010100u, 0x5010600u, 0x6012600u, 0x17010200u, 0x3c010400u, 0x29010200u, 0x1010100u, 0x1010200u,\n    0x2010100u, 0x2010500u, 0x2010400u, 0x3010100u, 0x2010100u, 0x8012200u, 0x3a010500u, 0x17010900u, 0x2b010100u, 0x2010300u, 0x1010300u, 0x1010200u, 0x1010100u, 0x2010100u, 0x1010200u, 0x3010400u,\n    0xf011c00u, 0x37010500u, 0x12011000u, 0x10010700u, 0x2d010100u, 0x1010500u, 0x4010200u, 0x1010200u, 0x1010900u, 0x10011c00u, 0x34010400u, 0x13011200u, 0x12010300u, 0x3010300u, 0x27010500u, 0x3010100u,\n    0x27011b00u, 0x35010200u, 0x15011200u, 0x13010100u, 0x27010700u, 0x6010100u, 0x3010300u, 0x1010300u, 0x2010800u, 0xf011900u, 0x35010200u, 0x11011700u, 0x1010300u, 0x3010200u, 0x1010100u, 0x9010200u,\n    0x27010900u, 0x1010100u, 0x1010200u, 0x2010400u, 0x1010300u, 0x1010200u, 0x1010300u, 0x1010200u, 0x10011700u, 0x35010300u, 0x9010200u, 0x6012200u, 0x26010400u, 0x1010a00u, 0x3010300u, 0x1010100u,\n    0x3010200u, 0x1010800u, 0xd011700u, 0x35010300u, 0xa010200u, 0x2010100u, 0x1010200u, 0x1012200u, 0x7010400u, 0x1010200u, 0x2002601u, 0x2000201u, 0xa000301u, 0x1000101u, 0x3000201u, 0x3000101u,\n    0x6000101u, 0x2000b01u, 0x18003401u, 0x3000901u, 0x3000101u, 0x1000101u, 0x26000201u, 0x3000101u, 0x9001401u, 0x1000f01u, 0x5001801u, 0xa000501u, 0x3000201u, 0xf000a01u, 0x14000201u, 0x1002101u,\n    0x4001101u, 0x2000801u, 0x3000101u, 0x3d000d01u, 0xe000901u, 0x2000701u, 0xb000301u, 0x3000601u, 0x2000101u, 0x9000901u, 0x1000201u, 0x13002001u, 0x6001401u, 0x2000401u, 0x4000101u, 0x3d000601u,\n    0x1000101u, 0x1000c01u, 0x11000201u, 0xc000201u, 0xa000201u, 0x2000201u, 0x2000401u, 0x3000401u, 0x6000b01u, 0x13001f01u, 0xc000901u, 0x1000801u, 0x3000201u, 0x3000101u, 0x3e000101u, 0x5000101u,\n    0x6000100u, 0x9012400u, 0x1010200u, 0x2010200u, 0x5010200u, 0x1010200u, 0x1010100u, 0x2010300u, 0x5010400u, 0xb011300u, 0x1d010100u, 0x1010f00u, 0xa010100u, 0x1010900u, 0x1010300u, 0x1014b00u,\n    0x3000801u, 0x23000301u, 0x1000101u, 0x4000101u, 0x1000101u, 0x1000101u, 0x5000101u, 0x3000401u, 0x1000201u, 0x6000901u, 0xe002201u, 0x11000301u, 0x2000201u, 0x11000101u, 0x4b000400u, 0x8013a00u,\n    0x6010700u, 0x6010f00u, 0x22011300u, 0x2010100u, 0x2011100u, 0x1014c00u, 0x7000301u, 0x2000101u, 0x38000601u, 0x9000601u, 0xd000d01u, 0x1001401u, 0xe000101u, 0x5000201u, 0x13000101u, 0x4d000101u,\n    0x6000201u, 0x39000901u, 0x4000201u, 0x2000701u, 0xa000101u, 0x1000901u, 0x1000101u, 0x5001301u, 0xf000401u, 0x64000301u, 0x3000401u, 0x3a000401u, 0x8000201u, 0x1000701u, 0x9000c01u, 0x7001201u,\n    0x7000301u, 0x7000101u, 0x1000101u, 0x64000401u, 0x1000901u, 0x33000101u, 0x4000201u, 0x2000201u, 0x5000a01u, 0x8000d01u, 0x5001201u, 0x8000201u, 0x8000101u, 0x64000601u, 0x1000701u, 0x32000201u,\n    0x2000101u, 0x1000601u, 0x6000901u, 0x8000e01u, 0x3001201u, 0x8000201u, 0x6f000b01u, 0x34000e01u, 0x3000101u, 0x1000a01u, 0x6002301u, 0x8000201u, 0x70000a01u, 0x34000601u, 0x1000301u, 0x4000301u,\n    0x2000b01u, 0x6002201u, 0x8000301u, 0x65000101u, 0x9000a01u, 0x33000c01u, 0x4000401u, 0x1000b01u, 0x5002101u, 0x9000301u, 0x60000301u, 0x1000101u, 0x7000b01u, 0x9000101u, 0x28000b01u, 0x6000f01u,\n    0x4002201u, 0x9000301u, 0x60000501u, 0x6000901u, 0x1000101u, 0xc000201u, 0x23000d01u, 0x5000301u, 0x1000e01u, 0x1002201u, 0xa000301u, 0x2000201u, 0x5a000501u, 0x2000d01u, 0x6000a01u, 0x1f000c01u,\n    0x6000301u, 0x1003101u, 0xa000401u, 0x59000101u, 0x3000401u, 0x2000d01u, 0x1000201u, 0x3000b01u, 0x1000101u, 0x1d000b01u, 0x7000101u, 0x3003101u, 0x2000201u, 0x4000401u, 0x55000c01u, 0x2000101u,\n    0x1001001u, 0x4000b01u, 0x1000101u, 0x1d000b01u, 0xa002901u, 0x1000801u, 0x1000201u, 0x4000301u, 0x1000101u, 0x53000c01u, 0x3001001u, 0x1000101u, 0x1000e01u, 0x1d000b01u, 0xb002801u, 0x2000a01u,\n    0x4000301u, 0x1000101u, 0x52000c01u, 0x5000f01u, 0x1001101u, 0x20000801u, 0xb002801u, 0x2000b01u, 0x3000301u, 0x53000d01u, 0x5000d01u, 0x2001201u, 0x21000701u, 0xc002701u, 0x2000801u, 0x1000101u,\n    0x2000501u, 0x52000d01u, 0x5002301u, 0x22000301u, 0xd002701u, 0x3000701u, 0x1000801u, 0x52000d01u, 0x5002301u, 0x22000201u, 0x10002301u, 0x2000101u, 0x2000701u, 0x1000401u, 0x2000101u, 0x53000d01u,\n    0x5002201u, 0x1000101u, 0x21000301u, 0xf002201u, 0x2000301u, 0x2000601u, 0x5e000b01u, 0x2002201u, 0x1000101u, 0x21000301u, 0x10002101u, 0x2000201u, 0x3000301u, 0x61000101u, 0x1000901u, 0x2002501u,\n    0x21000201u, 0x10002101u, 0x2000201u, 0x4000201u, 0x61000101u, 0x1000901u, 0x1002501u, 0x21000201u, 0x10002001u, 0x2000201u, 0x5000201u, 0x61000101u, 0x1000901u, 0x1002601u, 0x30000101u, 0x1002501u,\n    0x67000101u, 0x1000901u, 0x1002501u, 0x30000201u, 0x1002401u, 0x1000401u, 0x63000101u, 0x1000801u, 0x1002601u, 0x1000101u, 0x28000201u, 0x1000401u, 0x1002601u, 0x1000101u, 0x64000101u, 0x1002701u,\n    0x1000101u, 0x26000101u, 0x2000401u, 0x4002301u, 0x67002901u, 0x29000401u, 0x4002201u, 0x67002801u, 0x2a000501u, 0x3002401u, 0x65002801u, 0x2a000201u, 0x1002901u, 0x1c000101u, 0x9000201u, 0x3c000301u,\n    0x1002801u, 0x2b000101u, 0x1002a01u, 0x17000101u, 0x2000201u, 0x8000201u, 0x3d002801u, 0x29000101u, 0x2002b01u, 0x9000101u, 0xc000201u, 0xb000201u, 0x3d002801u, 0x28000101u, 0x2002c01u, 0xa000101u,\n    0xb000301u, 0x9000301u, 0x3d002801u, 0x27000201u, 0x1002d01u, 0x7000101u, 0x2000201u, 0x9000801u, 0x5000301u, 0x3c000401u, 0x3002801u, 0x26002b01u, 0x9000101u, 0x2000201u, 0x3000201u, 0x8000801u,\n    0x6000201u, 0x3c000401u, 0x3002801u, 0x25002c01u, 0x9000401u, 0x1000101u, 0x2000301u, 0x6000a01u, 0x5000301u, 0x38000601u, 0x3002801u, 0x25002c01u, 0x9000401u, 0x1000101u, 0x3000301u, 0x6000301u,\n    0x2000401u, 0x5000401u, 0x36000701u, 0x1002801u, 0x24002e01u, 0x7000501u, 0x1000301u, 0x2000201u, 0x7000101u, 0x4000301u, 0x6000401u, 0x35002801u, 0x23002e01u, 0x7000601u, 0x1000301u, 0x3000101u,\n    0x3000101u, 0x1000101u, 0xf000201u, 0x31000101u, 0x5000701u, 0x1002801u, 0x23002e01u, 0x7000601u, 0x1000401u, 0x1000201u, 0x2000201u, 0x11000301u, 0x2f000101u, 0x4000901u, 0x2002801u, 0x21000101u,\n    0x1002e01u, 0x7000b01u, 0x1000201u, 0x2000301u, 0x10000301u, 0x2e000201u, 0x1000201u, 0x2000801u, 0x2002901u, 0x20003001u, 0x6001001u, 0x2000101u, 0x11000301u, 0x2e000501u, 0x2000801u, 0x1002901u,\n    0x21002f01u, 0x6000a01u, 0x2000401u, 0x1000301u, 0x10000301u, 0x2e000101u, 0x1000401u, 0x1000701u, 0x2002901u, 0x21003101u, 0x3000401u, 0x1000101u, 0x4000201u, 0x1000801u, 0x11000101u, 0x32000301u,\n    0x2000501u, 0x3002a01u, 0x20003101u, 0x1000401u, 0x7001001u, 0x1000101u, 0x3d000401u, 0x2000501u, 0x3002a01u, 0x20003101u, 0x1000301u, 0x9000901u, 0x1000701u, 0x3c000501u, 0x2000201u, 0x6002a01u,\n    0x20003101u, 0xd000901u, 0x1000501u, 0x1000101u, 0x3c000501u, 0x1000301u, 0x5002b01u, 0x1e003201u, 0xc001201u, 0x3c000801u, 0x1000101u, 0x2002c01u, 0x1c003201u, 0xe001101u, 0x3d000601u, 0x3002d01u,\n    0x1b003101u, 0x11000401u, 0x2000901u, 0x3d000601u, 0x2002d01u, 0x1a003201u, 0x12000301u, 0x3000801u, 0x3d000601u, 0x1002d01u, 0x1a003201u, 0x13000201u, 0x6000101u, 0x1000201u, 0x3e002d01u, 0x2000101u,\n    0x16003301u, 0x14000101u, 0x48002e01u, 0x1000101u, 0x11000201u, 0x3003301u, 0x29000101u, 0x33002e01u, 0x1000101u, 0xd000201u, 0x1000501u, 0x2003101u, 0x20000101u, 0x9000201u, 0x32002f01u, 0x1000101u,\n    0xb000901u, 0x2003101u, 0x2a000201u, 0x32002f01u, 0x1000101u, 0xa000a01u, 0x2002f01u, 0x22000101u, 0xa000101u, 0x32002f01u, 0x2000101u, 0x9000b01u, 0x1002f01u, 0x22000101u, 0xa000201u, 0x30003001u,\n    0x1000101u, 0x9000b01u, 0x1002f01u, 0x22000201u, 0xa000401u, 0x2d003001u, 0x1000101u, 0x9000b01u, 0x1002e01u, 0x23000201u, 0xa000301u, 0x1000101u, 0x2c003101u, 0x1000101u, 0x8003a01u, 0x24000101u,\n    0xb000201u, 0x1000701u, 0x25003101u, 0x1000201u, 0x7003a01u, 0x24000101u, 0xa000201u, 0x2000801u, 0x24000101u, 0x1003401u, 0x7003901u, 0x25000201u, 0xe000701u, 0x23000201u, 0x1003501u, 0x6000a01u,\n    0x2002d01u, 0x25000201u, 0xf000701u, 0x22000201u, 0x1003501u, 0x6000901u, 0x1000101u, 0x3002b01u, 0x26000201u, 0xe000701u, 0xf000101u, 0xf003501u, 0x6000601u, 0x1000601u, 0x1002b01u, 0x26000201u,\n    0xe000701u, 0xd000401u, 0xd003501u, 0x6000501u, 0x2000701u, 0x1002a01u, 0x26000201u, 0xd000b01u, 0xa000301u, 0xb001101u, 0x1002301u, 0x7000401u, 0x2000701u, 0x2002901u, 0x26000201u, 0xd000a01u,\n    0xa000501u, 0x9000301u, 0x1001101u, 0x1002401u, 0x6000401u, 0x2000b01u, 0x2002501u, 0x26000301u, 0xc000a01u, 0x9000701u, 0x8000201u, 0x1003601u, 0x7000101u, 0x4000901u, 0x1000101u, 0x3002401u,\n    0x27000201u, 0xb000c01u, 0x8000701u, 0x8000201u, 0x1003701u, 0xb000701u, 0x1000301u, 0x1002601u, 0x27000201u, 0xb000c01u, 0x7000801u, 0x8000a01u, 0x2003801u, 0x9003301u, 0x27000301u, 0x9000d01u,\n    0x7000801u, 0x9000901u, 0x2003a01u, 0x7003301u, 0x28000201u, 0x7000f01u, 0x6000901u, 0x1000101u, 0x7000901u, 0x2003b01u, 0x1000201u, 0x3000201u, 0x1003001u, 0x28000201u, 0x7000f01u, 0x5000a01u,\n    0x1000101u, 0x8000801u, 0x1003e01u, 0x7002f01u, 0x28000201u, 0x6001001u, 0x5000c01u, 0x8000801u, 0x1003f01u, 0x6002f01u, 0x29000101u, 0x5001201u, 0x4000c01u, 0x8004001u, 0x5002f01u, 0x2a000101u,\n    0x3001301u, 0x4000d01u, 0x7000a01u, 0x1004101u, 0x4002f01u, 0x2a001701u, 0x4000d01u, 0x1000101u, 0x6000901u, 0x1004201u, 0x3000801u, 0x1002601u, 0x2a001701u, 0x4000d01u, 0x1000101u, 0x5000a01u,\n    0x2004301u, 0x2000701u, 0x1002801u, 0x29000501u, 0x1001101u, 0x4000d01u, 0x1000201u, 0x4004301u, 0x2000601u, 0x5002501u, 0x2a000101u, 0x4001201u, 0x3000d01u, 0x1000201u, 0x4000801u, 0x4004301u,\n    0x2000501u, 0xa002101u, 0x2f001201u, 0x2001201u, 0x2000701u, 0x1000401u, 0x1004401u, 0x2000101u, 0x1000201u, 0xb002101u, 0x2e001201u, 0x2001201u, 0x1000801u, 0x1004501u, 0x4000101u, 0xb002101u,\n    0x2e001201u, 0x1000f01u, 0x1000301u, 0x1000801u, 0x1000401u, 0x2004601u, 0x1000201u, 0xd002001u, 0x2d001501u, 0x2000c01u, 0x1001001u, 0x3004901u, 0xe002001u, 0x2c001501u, 0x2000c01u, 0x1000f01u,\n    0x1000101u, 0x2004901u, 0xe002101u, 0x2b001601u, 0x1000d01u, 0x1001001u, 0x1004901u, 0xf002001u, 0x9000201u, 0x20001601u, 0x1000d01u, 0x2000901u, 0x1000501u, 0x1004901u, 0x12001e01u, 0x6000501u,\n    0x1e002201u, 0x1000201u, 0x2000901u, 0x3004901u, 0x12001f01u, 0x1000901u, 0x1e002201u, 0x1000201u, 0x2000801u, 0x3004901u, 0x13002901u, 0x1d002201u, 0x2000101u, 0x2000801u, 0x2004901u, 0x13002a01u,\n    0x1b002401u, 0x2000101u, 0x1000701u, 0x3004801u, 0x14002a01u, 0x1b002401u, 0x2000101u, 0x2000501u, 0x5004801u, 0x15002a01u, 0x19002601u, 0x2000101u, 0x1000501u, 0x5000601u, 0x1004801u, 0x15002a01u,\n    0x18002701u, 0x2000501u, 0x7000201u, 0x1000101u, 0x1000101u, 0x1004701u, 0x15002b01u, 0x18002701u, 0x3000401u, 0x6000401u, 0x1000201u, 0x1004701u, 0x17002801u, 0x18002901u, 0x2000401u, 0x6003f01u,\n    0x1000701u, 0x18002701u, 0x18002901u, 0x3000401u, 0x5000301u, 0x2000501u, 0x2000101u, 0x1004701u, 0x1a002501u, 0x17002a01u, 0x3000401u, 0x5000201u, 0x2000301u, 0x1000301u, 0x1000201u, 0x1004701u,\n    0x1b002501u, 0x16002b01u, 0x3000301u, 0x5000101u, 0x2000b01u, 0x3004701u, 0x1d002301u, 0x15002c01u, 0x5000101u, 0x4000201u, 0x1000101u, 0x1000201u, 0x1000101u, 0x2000101u, 0x7004701u, 0x1e002301u,\n    0x14002c01u, 0x3000601u, 0x1000401u, 0x1000701u, 0x9004601u, 0x20002201u, 0x14002d01u, 0x2000b01u, 0x1000901u, 0x7000401u, 0x2004701u, 0x20002101u, 0x14002e01u, 0x1001701u, 0x5000401u, 0x1004701u,\n    0x20002201u, 0x12004401u, 0x1000201u, 0x9004701u, 0x20002201u, 0x13002f01u, 0x2000101u, 0x1001301u, 0x7000501u, 0x1004801u, 0x1f002201u, 0x13002f01u, 0x6001201u, 0x5004801u, 0x1f002301u, 0x12003201u,\n    0x4001101u, 0x3000101u, 0x2004801u, 0x1f002301u, 0x12003601u, 0x1000201u, 0x2000201u, 0x1000a01u, 0x2000201u, 0x1004801u, 0x1f002301u, 0x12003801u, 0x1000301u, 0x1000f01u, 0x2000701u, 0x1004901u,\n    0x1e002301u, 0x12003901u, 0x1001301u, 0x2004901u, 0x1d002401u, 0x13004901u, 0x1d002401u, 0x13004901u, 0x1c002501u, 0x13004001u, 0x4000401u, 0x1004a01u, 0x1b002401u, 0x14003f01u, 0x5000401u, 0x1004a01u,\n    0x1b002401u, 0x14000501u, 0x1003901u, 0x4000401u, 0x2004a01u, 0x1b002401u, 0x14000501u, 0x2003501u, 0x2000101u, 0x4000401u, 0x3004b01u, 0x1a002401u, 0x14000401u, 0x3003501u, 0x7000401u, 0x3004b01u,\n    0x1a002401u, 0x13000401u, 0x4003401u, 0x9000301u, 0x3004c01u, 0x19002401u, 0x13000301u, 0x4003501u, 0xa000201u, 0x3001801u, 0x1004d01u, 0x17002501u, 0x12000401u, 0x4003501u, 0xb000101u, 0x4004e01u,\n    0x16002501u, 0x11000501u, 0x4003401u, 0x11001601u, 0x1004e01u, 0x16002501u, 0x11000501u, 0x4003301u, 0x12004e01u, 0x16002501u, 0x11000501u, 0x4003301u, 0x13004e01u, 0x16002501u, 0x10000601u, 0x4003101u,\n    0x15004e01u, 0x16002601u, 0xf000601u, 0x3003101u, 0x17004e01u, 0x15002701u, 0xf000601u, 0x3003001u, 0x18000b01u, 0x1004e01u, 0x15002701u, 0xf000601u, 0x3002f01u, 0x19004e01u, 0x14002901u, 0xe000601u,\n    0x3002f01u, 0x1a004e01u, 0x12002b01u, 0xe000601u, 0x3002f01u, 0x1a004e01u, 0x11002c01u, 0xe000601u, 0x3002e01u, 0x1c004e01u, 0x10002d01u, 0xe000701u, 0x2002f01u, 0x1b004e01u, 0x10002d01u, 0xd003901u,\n    0x1b004e01u, 0x10002d01u, 0xd003901u, 0x1c004e01u, 0x10002d01u, 0xd003901u, 0x1c004e01u, 0x10002d01u, 0xd003901u, 0x1c004e01u, 0x10002e01u, 0xb003a01u, 0x1c004d01u, 0x10002f01u, 0xb003a01u, 0x1c004d01u,\n    0x10002f01u, 0xa003b01u, 0x1c004d01u, 0xf003101u, 0x9003c01u, 0x1b004d01u, 0xf003101u, 0x9003c01u, 0x1b004d01u, 0xe003201u, 0x8003d01u, 0x9000201u, 0xf004d01u, 0xe003201u, 0x7003e01u, 0x7000601u,\n    0xd004d01u, 0xe003201u, 0x7003d01u, 0x7000701u, 0xd004d01u, 0xd003301u, 0x5003f01u, 0x4000b01u, 0x1000101u, 0x9004d01u, 0xd003401u, 0x1004201u, 0x3000d01u, 0xa004d01u, 0xb008a01u, 0x9001001u,\n    0x1004c01u, 0xc008901u, 0x1000101u, 0x8001001u, 0x1004c01u, 0xc008b01u, 0x7001101u, 0x2004c01u, 0xc008b01u, 0x7001201u, 0x1004c01u, 0xb008d01u, 0x2000101u, 0x2001301u, 0x3004c01u, 0xa00a501u,\n    0x4004c01u, 0x800a801u, 0x2004c01u, 0x800a901u, 0x1004c01u, 0x6000101u, 0x1009301u, 0x2001101u, 0x2000101u, 0x1004c01u, 0x6009501u, 0x2001101u, 0x2004b01u, 0x7009501u, 0x2001001u, 0x2004b01u,\n    0x7009501u, 0x1001101u, 0x2004b01u, 0x700a501u, 0x4004b01u, 0x700a501u, 0x3004b01u, 0x600a501u, 0x3004b01u, 0x500a601u, 0x3004b01u, 0x500a701u, 0x1004b01u, 0x7004b01u, 0x6004b01u, 0x5004b01u,\n    0x5006101u, 0x1004b01u, 0x4004b01u, 0x4004c01u, 0x3000601u, 0x2004c01u, 0x3004c01u, 0x4004c01u, 0x4004e01u, 0x3001501u, 0x1004f01u, 0x2005601u, 0x1005501u, 0x1005301u, 0x2005101u, 0x3005201u,\n    0x2005001u, 0x5001f01u, 0x4000301u, 0x3000701u, 0x1000301u, 0x5004f01u, 0x3005101u, 0x7001201u, 0x2a005101u, 0x1004e01u, 0x10000101u, 0x1000801u, 0x2e005101u, 0x1004b01u, 0x15000601u, 0x33004d01u,\n    0x1000301u, 0x2004501u, 0x1000301u, 0x16000501u, 0x38004d01u, 0x2000101u, 0x4003701u, 0x1000b01u, 0x1a000301u, 0x3e004e01u, 0x6003001u, 0xe000301u, 0x1c000301u, 0x41004c01u, 0x9002401u, 0x38000201u,\n    0x45003801u, 0x2001101u, 0x1000201u, 0x6002401u, 0x38000201u, 0x47003701u, 0x1000701u, 0x2000b01u, 0x3000101u, 0x5002101u, 0x3a000101u, 0x47003901u, 0x1c002001u, 0x81000201u, 0x1002701u, 0x8000901u,\n    0x1c001d01u, 0x1000301u, 0x80001f01u, 0x13000701u, 0x1a002001u, 0x80001a01u, 0x39001e01u, 0x82001601u, 0x3a001b01u, 0x88001901u, 0x31002001u, 0x89001001u, 0x3c001b01u, 0x8d000201u, 0x2001001u, 0x39001401u,\n    0x4000601u, 0x8e000b01u, 0x3000401u, 0x34000701u, 0x2000d01u, 0x5000601u, 0x8c000c01u, 0x3000701u, 0x34000301u, 0x2000201u, 0x1000301u, 0x1000601u, 0x6000801u, 0x88001501u, 0x35000801u, 0x4000401u,\n    0x6000801u, 0x8a001101u, 0x3f001301u, 0x90001301u, 0x3f000a01u, 0x3000301u, 0x92001301u, 0x41000401u, 0x9e000601u, 0x7000301u, 0x45000101u, 0xa2000901u, 0xf5000900u, 0xf5000900u, 0xfe00fe00u, 0xfe00fe00u,\n    0xfe00fe00u, 0xfe000900u);\n\nuint GetNextShort(uint idx) { return (img[(idx + 1u) >> 1] >> (16u * (idx & 1u))) & 0xFFFFu; }\nuint GetShort(uint idx) { return (img[idx >> 1] >> (16u * ((idx + 1u) & 1u))) & 0xFFFFu; }\nvec4 ImagePixel(in vec2 fragCoord) {\n    uint x = uint(fragCoord.x);\n    uint y = uint(fragCoord.y);\n    if (y < IMG_SIZE.y && x < IMG_SIZE.x) {\n        uint row = GetShort(y);\n        uint nextRow = GetNextShort(y);\n        if (row == nextRow || row == 0u) { return vec4(0); }\n        uint run = GetShort(row);\n        uint px = run >> 8;\n        while (row < nextRow && px < x) {\n            row += 1u;\n            if (row == nextRow) { return vec4(0); }\n            run = GetShort(row);\n            px += run >> 8;\n        }\n        uint colIdx = run & 0xFFu;\n        return colIdx == IMG_SIZE.z ? vec4(0) : vec4(pallet[colIdx], 1);\n    }\n    return  vec4(0);\n}\n\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = iFrame == 0 ? ImagePixel(fragCoord ) : texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs3yWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 260]], "test": "untested"}
{"id": "mstyzM", "name": "SoftUni - Waving Quad", "author": "angle_", "description": "Using 2D rotation to make our Quad rotate against the pivot of the screen.\n", "tags": ["wavingquad"], "likes": 1, "viewed": 133, "published": 3, "date": "1694877998", "time_retrieved": "2024-07-30T17:33:34.575032", "image_code": "vec4 TRIANGLE(vec3 color, vec3 background, vec2 v0, vec2 v1, vec2 v2, vec2 uv);\n\n// Rotation matrix around the X axis.\nmat2 Rotate2D(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    \n    return mat2(cosAngle, -sinAngle,\n                    sinAngle, cosAngle);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0; 1] - for the width and height of the screen\n    vec2 screen_uv = fragCoord/iResolution.xy;\n\t\n    // [0; 1] - Color - Red, Green, Blue\n    vec3 color = vec3(0.0);\n    \n    vec4 VERTEX_BUFFER[4] = vec4[]\n    (\n        vec4(0.7, 0.75, 1.0, 1.0), //top-right\n        vec4(0.3, 0.25, 0.0, 0.0), //bottom-left\n        vec4(0.7, 0.25, 0.0, 1.0), //bottom-right\n        vec4(0.3, 0.75, 1.0, 0.0)  //top-left\n        \n    );\n\n    ivec3 INDEX_BUFFER[2] = ivec3[]\n    (\n        ivec3(0, 1, 2),\n        ivec3(0, 1, 3)\n    );\n    \n    // Index Buffer Render\n    for(int i = 0; i < 2; i += 1) {\n        ivec3 idx = INDEX_BUFFER[i];\n        \n        float mils = (iDate.w) * 1.0 ;\n        vec2 v0 =  Rotate2D(sin(mils) * 0.78539816339) * vec2(VERTEX_BUFFER[idx.x].xy);                \n        vec2 v1 =  Rotate2D(sin(mils) * 0.78539816339) * vec2(VERTEX_BUFFER[idx.y].xy);\n        vec2 v2 =  Rotate2D(sin(mils) * 0.78539816339) * vec2(VERTEX_BUFFER[idx.z].xy);\n        \n        vec2 v0_uv = vec2(VERTEX_BUFFER[idx.x].zw);                \n        vec2 v1_uv = vec2(VERTEX_BUFFER[idx.y].zw);\n        vec2 v2_uv = vec2(VERTEX_BUFFER[idx.z].zw);\n        \n        // Channel X, Y, Z = v0, v1, v2 barycentric weights, \n        // Channel W = 0.0 -> miss || 1.0 -> hit\n        vec4 result = TRIANGLE(vec3(0.0), color, v0,  v1,  v2 , screen_uv);\n        \n        if(result.w == 1.0) {\n            vec2 vertex_uv = v0_uv * result.x + v1_uv * result.y + v2_uv * result.z;\n            \n            // Bary Render\n            color = result.xyz;\n            \n            //UV Render\n            //color = vec3(vertex_uv, 0.0);\n            \n            //Texture Render\n            vertex_uv.x = vertex_uv.x * iChannelResolution[0].x;\n            vertex_uv.y = vertex_uv.y * iChannelResolution[0].y;\n            //color = texelFetch(iChannel0, ivec2(vertex_uv), 0).xyz;\n            \n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\nfloat TRIANGLE_sign(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nvec3 barycentrics(vec2 p, vec2 a, vec2 b, vec2 c){\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float den = v0.x * v1.y - v1.x * v0.y;\n    float x = (v2.x * v1.y - v1.x * v2.y) / den;\n    float z = (v0.x * v2.y - v2.x * v0.y) / den;\n    //Няма смисъл да го изчисляваме трето ако\n    // x + y + z = 1.0\n    float y = 1.0f - x - z; \n    \n    return vec3(x, y, z);\n}\n\nvec4 TRIANGLE(vec3 color, vec3 background, vec2 v0, vec2 v1, vec2 v2, vec2 uv)\n{\n    bool b1 = TRIANGLE_sign(uv, v0, v1) < 0.0f;\n    bool b2 = TRIANGLE_sign(uv, v1, v2) < 0.0f;\n    bool b3 = TRIANGLE_sign(uv, v2, v0) < 0.0f;\n    \n    vec3 bary_res = barycentrics(uv, v0, v1, v2);\n    if((b1 == b2) && (b2 == b3)) return vec4(bary_res, 1.0);\n    return vec4(background, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 119, 147, 147, 298], [2283, 2283, 2331, 2331, 2407], [2409, 2409, 2459, 2459, 2809], [2811, 2811, 2891, 2891, 3187]], "test": "untested"}
{"id": "csdczn", "name": "Joukowsky Transform", "author": "mla", "description": "The Joukowsky transform acting on a circle. Mouse sets circle parameters.", "tags": ["complex", "transform", "joukowsky"], "likes": 28, "viewed": 376, "published": 3, "date": "1694866347", "time_retrieved": "2024-07-30T17:33:35.423763", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Joukowsky Transform, mla, 2023\n//\n// A circle under the Joukowsky transform. This is double branched so both\n// branches are shown, in different colours.\n//\n// Mouse sets circle location\n// c: show/hide untransformed circle\n// g: show/hide grid axes\n// x: toggle transform\n// z: zoom out\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 dogrid(vec3 color, vec2 w, float px, vec3 c) {\n  vec2 uv = rotate(w,0.25*iTime);\n  float ldist = length(uv);\n  ldist *= 10.0;\n  ldist -= round(ldist);\n  ldist /= 10.0;\n  ldist = abs(ldist);\n  float t = atan(uv.y,uv.x);\n  t /= PI;\n  t *= 20.0;\n  t = round(t);\n  t /= 20.0;\n  t *= PI;\n  ldist = min(ldist,line(uv,vec2(0),vec2(cos(t),sin(t))));\n  color = mix(c,color,0.75+0.25*smoothstep(0.002,0.004+px,abs(ldist)));\n  return color;\n}\n\nfloat R = 1.2;\n\nvec3 docircle(vec3 color, vec2 w, float px, vec3 c) {\n  float ldist = length(w)-R;\n  color = mix(c,color,smoothstep(0.0,px,abs(ldist)-0.01));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1.5;//exp(iTime);\n  if (key(CHAR_Z)) scale *= 2.0;\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 ci = vec2(0,1);\n  z *= scale;\n  vec2 t = cpow(cmul(z,z)-vec2(4,0),0.5);\n  vec2 w1 = z, w2 = z;\n  if (!key(CHAR_X)) {\n    w1 = 0.5*(z-t); // Inverse Joukowsky\n    w2 = 0.5*(z+t); // The other branch\n  }\n  vec2 mousepos = 0.4*vec2(cos(0.5*iTime),sin(0.49*iTime)); // Circle location\n  if (iMouse.x > 0.0) mousepos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  w1 -= mousepos; w2 -= mousepos;\n  vec3 color = vec3(0);\n  if (!key(CHAR_G)) {\n    float mdist = min(abs(z.x),abs(z.y));\n    color = mix(vec3(1),color,0.75+0.25*smoothstep(0.01,0.02,mdist));\n    float pdist = distance(abs(z),vec2(round(abs(z.x)),0));\n    color = mix(vec3(1),color,0.5+0.5*smoothstep(0.04,0.05,pdist));\n  }\n  if (!key(CHAR_C)) color = docircle(color,z-mousepos,fwidth(z.x),vec3(0.4));\n  float px1 = fwidth(w1.x);\n  float px2 = fwidth(w2.x);\n  color = dogrid(color,w1,px1,vec3(0,1,0));\n  color = dogrid(color,w2,px2,vec3(0,1,1));\n  color = docircle(color,w1,px1,vec3(1,1,0));\n  color = docircle(color,w2,px2,vec3(1,0,0));\n  color = pow(color, vec3(0.4545));\n  if (alert) color.g = 1.0;\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI =  3.141592654;\nconst float TWOPI =  2.0*PI;\n\n// Debugging aids\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n//#define assert(x)\n\nvec2 rotate(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nvec2 rotate(vec2 p, float t) {\n  vec2 r = rotate(t);\n  r = normalize(r);\n  return p * r.x + vec2(p.y, -p.x) * r.y;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  return length(p-b*h);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 clog(float x) {\n  return clog(vec2(x,0));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 cexp(float k, vec2 z) {\n  // return k^z\n  return cexp(cmul(clog(k),z));\n}\n\nvec2 catan(vec2 z) {\n  vec2 iz = vec2(-z.y,z.x);\n  vec2 t = clog(cdiv(vec2(1,0)-iz,vec2(1,0)+iz));\n  return 0.5*vec2(-t.y,t.x);\n}\n\nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n  return cexp(cmul(clog(z),w));\n}\n\nvec2 cpow(vec2 z, float x) {\n  return cexp(x*clog(z));//+vec2(0,-TWOPI));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[460, 460, 511, 511, 896], [914, 914, 967, 967, 1073], [1075, 1075, 1128, 1128, 2354]], "test": "untested"}
{"id": "DdtyRM", "name": "Simple God Rays Effect", "author": "alphardex", "description": "A simple god rays effect.", "tags": ["noise", "godrays"], "likes": 7, "viewed": 347, "published": 3, "date": "1694853065", "time_retrieved": "2024-07-30T17:33:36.371230", "image_code": "// https://github.com/MaxBittker/glsl-voronoi-noise/blob/master/2d.glsl\nconst mat2 myt=mat2(.12121212,.13131313,-.13131313,.12121212);\nconst vec2 mys=vec2(1e4,1e6);\n\nvec2 rhash(vec2 uv){\n    uv*=myt;\n    uv*=mys;\n    return fract(fract(uv/mys)*uv);\n}\n\nvec3 hash(vec3 p){\n    return fract(sin(vec3(dot(p,vec3(1.,57.,113.)),\n    dot(p,vec3(57.,113.,1.)),\n    dot(p,vec3(113.,1.,57.))))*\n43758.5453);\n}\n\nfloat voronoi2d(const in vec2 point){\nvec2 p=floor(point);\nvec2 f=fract(point);\nfloat res=0.;\nfor(int j=-1;j<=1;j++){\n    for(int i=-1;i<=1;i++){\n        vec2 b=vec2(i,j);\n        vec2 r=vec2(b)-f+rhash(p+b);\n        res+=1./pow(dot(r,r),8.);\n    }\n}\nreturn pow(1./res,.0625);\n}\n\nvec2 cart2polar(vec2 uv){\nfloat phi=atan(uv.y,uv.x);\nfloat r=length(uv);\nreturn vec2(phi,r);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\nvec2 uv=fragCoord/iResolution.xy;\n\nvec2 p=uv;\np.x*=iResolution.x/iResolution.y;\n\nuv=(uv-.5)*2.;\nuv.x*=iResolution.x/iResolution.y;\n\nvec3 col=vec3(0.);\n// float noise=voronoi2d(uv*3.);\n// col=vec3(noise);\n\nuv.y-=2.;\nuv/=50.;\nuv=cart2polar(uv);\ncol=vec3(uv.x);\n\nfloat n1=voronoi2d((vec2(uv.x,0.)+.04*iTime)*10.);\ncol=vec3(n1);\nfloat n2=voronoi2d((vec2(.1,uv.x)+.04*iTime*1.5)*10.);\ncol=vec3(n2);\nfloat n3=min(n1,n2);\ncol=vec3(n3);\n\n// col=vec3(1.);\nfloat mask=smoothstep(.15,.86,p.y);\nfloat alpha=n3*mask*.8;\n\ncol=mix(vec3(0.,.412,.580),vec3(1.),alpha);\n\nfragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 186, 186, 250], [252, 252, 270, 270, 399], [681, 681, 706, 706, 775], [777, 777, 830, 830, 1409]], "test": "untested"}
{"id": "ddccz7", "name": "Arabesque rug", "author": "jarble", "description": "An arabesque rug pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "knot", "arabesque"], "likes": 6, "viewed": 206, "published": 3, "date": "1694851607", "time_retrieved": "2024-07-30T17:33:37.273816", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = uv.y > uv.x;\n    bool b1 = b;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(-.5+uv+t2)\n            //min(abs(.5+uv+t2),abs(-.5+uv+t2))\n            //max(abs(.5+uv+t2),abs(-.5+uv+t2))\n            //abs(.5+uv+t2*(1.+mod(floor(uv.y),2.)/2.))\n            //abs(.5+uv+t2+pow(floor(uv.x),2.)/1.5)\n        ;\n        //if((t2.x)>(t2.y) || k%2 == 0) uv /= 1.5;\n\n        //k += int(uv.x>uv.y);\n        //uv += float(int(iTime)/3);\n        \n        //uv += sign(uv-uv.yx)/2.+.5;\n        //uv += floor(uv*1.5); //another interesting pattern\n        b =\n            uv.y>uv.x||t2.y<t2.x\n            //uv.y>uv.x*float(t2.y>t2.x)\n            //uv.y>uv.x*float(t2.y>t2.x) //makes a braided pattern\n            //uv.y>uv.x+float(!b1)\n            //uv.y*float(!b1)>uv.x\n        ;\n        if(b) uv = uv.yx;\n        //else {k += 1; uv *= 1.5; col=col.yzx;}\n\n        t2 =\n            triangle_wave(uv-1.5)*float(b)\n        ;\n        //if(t2.y<t2.x) t2 = t2*1.5; else t2=t2/1.5;\n\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx+floor(uv.x*2.))\n        ;\n        if(b)\n        //if(uv.y<uv.x||b)\n        col =\n            vec3(col.zx,max(col.y,max(uv.x-uv.y,0.)))\n            //vec3(col.zx,max(uv.x-uv.y,col.x))\n            //abs(sign(uv.x-uv.y)/2.-vec3(col.zx,max(uv.x-uv.y,0.)))\n        ;\n        //uv /= 1.+mod(uv.x,2.);\n        //if(t2.x>t2.y) col=col.yzx;\n\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//remix of https://www.shadertoy.com/view/css3D8\n\nfloat fmod(float a, float b){\n    //a += fmod2(a,2.);\n    \n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        //mod(floor(a),b)\n        mod(mod(floor(a),b+floor(b/4.)),b)\n        //mod(floor(a)*floor(-a/b),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n\n#define fmax1(x,y,z) max(fmod(x,z),fmod(y,z))\n\nvec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  float s1 =\n      4.,\n      //5./(1.+fmod(time/2.,2.)), //varying tempo\n  s2 = 8.,\n  m4 = fmax1(time+floor(time),time,2.),\n  t= //varying tempo\n      time/(1.+m4)\n      //time/(1.+fmod(floor(time*s1),2.))\n      //time/(1.+fmod(time/s1+floor(time*s1),2.))*2.\n      //time/(1.+fmod(time*s1+floor(time),2.))\n      //time*(1.+fmod(time*s1,2.))/2.\n  ,\n  m1 =\n      fmax1(t/s1,t,s2)\n      //fmod(t/s1+floor(t*s1),s2)\n      //fmod(t*s1+floor(t/s1),s2)\n  ,\n  //m4 = fmod(t*s1,s1),\n  m3 =\n      fmax1(t/(m1+.5),t,s2);\n      //fmod(t*(s1+m4)/(m1+.5),s2);\n      //fmod((t+m1)*s1/(m4+.5),s2);\n      //fmod(t*s1/abs(2.5-m1),s2);\n  \n  //m1 = fmod(t/s1,s2),\n  \n  //t += m3/2.;\n  t /=  //varying tempo\n      (1.+fmod(t/s1+floor(t+.5),2.))\n      //(1.+fmod((floor(t/s1)+t/s1)/2.+floor(t*s1),2.))\n  ;\n  //t += s1*s1;\n  t *=\n      s1*s1*(1.+fmod(floor(t*s1*2.)/s1,2.))/(1.+fmod(floor(t*s1/2.)/s1,2.))\n      //s1*s1\n  ;\n  \n    float m2 =\n      1. + fmod((t/s1+floor(t/s1)),s1)\n      //1. + fmod(t/s1,8./(1.+fmod(t/s1,2.)))\n      //1. + fmod(t/s1,s1/2.)*fmod(t/s1/2.,s1/2.)\n      //1. + min(fmod(time,s1),t)\n  ;\n  \n  //m3 = mod(floor(t/s1),1.+s1+m3);\n  //m2 = mod(floor(t/s1*2.),s1-m2);\n  \n  //t /= max(m2,m1+m3+1.);\n  \n  float a=\n      //32.*((1.-sqrt(fract(t/s1))))\n      16.*pow((1.-(fract(t/s1)/2.)),2.)\n  ,\n  \n  nb = time*tempo*pow(2.,(m3+m2)/5.+5.5);\n\n  return log(.125+abs(.5-vec2(fract(nb*.998)\n   ,fract(nb)))*a);\n\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddccz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 107], [109, 109, 136, 136, 297], [299, 299, 356, 356, 2093]], "test": "untested"}
{"id": "csccz7", "name": "coiled grove 2", "author": "elenzil", "description": "if my poor ancient laptop can run it at 26 I figure it's probably okay.", "tags": ["tree", "twist", "rope", "braid", "understepping", "grove"], "likes": 49, "viewed": 381, "published": 3, "date": "1694839708", "time_retrieved": "2024-07-30T17:33:38.379859", "image_code": "const uint  march_MaxSteps  = 250u;\nconst float march_epsilon   = 0.01;\n      float march_understep = 0.3;\nconst float normal_epsilon  = 0.05;\n\nconst bool  do_Shadows      = true;\nconst bool  do_Reflections  = true;\n\n\nfloat gMapCount = 0.0;\n\nfloat sdScene(in vec3 p) {\n\n    gMapCount += 1.0;\n\n    float d = 1e9;\n    \n    vec3 q = p;\n    \n    q.xz *= rot2(q.y * 0.05);\n    q.xz = abs(q.xz) -  9.0 * smoothstep( 0.0, 40.0, q.y);        \n    q.xz *= rot2(q.y * -0.05 + iTime * 0.4);\n    q.xz = abs(q.xz) -  3.8 * smoothstep( 5.0, 30.0, q.y);\n    q.xz *= rot2(q.y *  0.05 - iTime * 0.7);\n    q.xz = abs(q.xz) -  1.5 * smoothstep(15.0, 40.0, q.y);\n    q.xz *= rot2(q.y * -0.1 + iTime * 0.3);\n    q.xz = abs(q.xz) -  0.75 * smoothstep(30.0, 50.0, q.y);\n\n    const float height = 50.0;\n    float rad = 1.0 - 0.85 * smoothstep(5.0, height, q.y);\n    rad += 0.3 * smoothstep(height - 1.0, height, q.y);\n    d = min(d, sdVerticalCapsule(q, height, rad));\n\n    if (dot(p.xz, p.xz) < 50.0) {\n        d = smin(d, p.y, 5e0);\n    }\n    \n    return d;\n}\n\nvec3 gradScene(in vec3 p) {\n    if (p.y < march_epsilon) {\n        // cheat for floor\n        return vY;\n    }\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * normal_epsilon) - d,\n        sdScene(p + vY * normal_epsilon) - d,\n        sdScene(p + vZ * normal_epsilon) - d\n    );\n}\n\nvec3 normalScene(in vec3 p) {\n    return normalize(gradScene(p));\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd, out bool outOfSteps) {\n\n    // analytic ground plane in addition to the raymarched one.\n    float pt = rayVsPlane(ro, rd, vY, 0.0);\n    \n    outOfSteps = false;\n\n    float t = 0.0;\n\n    for (uint n = 0u; n < march_MaxSteps; ++n) {\n        vec3  p = ro + t * rd;\n        float d = sdScene(p);\n        if (d < march_epsilon) {\n            return min(pt, t);\n        }\n        if (dot(p.xz, p.xz) > 12000.0) {\n            return pt;\n        }\n        \n        t += d * march_understep;\n    }\n   \n    // next time we call this, use less precision.\n    march_understep = mix(march_understep, 1.0, 0.5);\n    \n    outOfSteps = true;\n    return pt;\n}\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.5, 1.9));\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(rd, lightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float a = atan(rd.z, rd.x);\n    \n    c = mix(c, v1, smoothstep(0.06 + (1.0 - d) * 0.01 * cos(a * 13.0), 0.0, abs(rd.y)));\n    return c;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    bool outOfSteps;\n    float t = rayVsScene(ro, rd, outOfSteps);\n    if (t > 1e8) {\n        return sky(ro, rd);\n    }\n    \n    vec3 p;\n    vec3 n;\n    \n    p = ro + t * rd;\n    n = normalScene(p);\n    \n    vec3 c = v1 * (saturate(dot(n, lightDir)));\n\n    // shadow and one reflection bounce\n    ro = p + n * march_epsilon * 1.5;\n    \n    if (do_Shadows) {\n        // shadow\n        t = rayVsScene(ro, lightDir, outOfSteps);\n        p = ro + t * lightDir;\n\n        if (t < 1e9 || outOfSteps) {\n            c *= 0.4;\n        }\n    }\n\n    if (do_Reflections) {\n        // reflect\n        float fres = mix(0.01, 0.8, smoothstep(0.9, 0.1, abs(dot(rd, n))));\n\n        vec3 c2;\n        rd = reflect(rd, n);\n        t = rayVsScene(ro, rd, outOfSteps);\n        if (t > 1e8) {\n            c2 = sky(ro, rd);\n        }\n        else {\n            p = ro + t * rd;\n            n = normalScene(p);\n            c2 = v1 * (saturate(dot(n, lightDir)));\n        }\n\n        c = mix(c, c2, fres);\n    }\n    \n    return c;\n}\n\nvec3 getRayDir(in vec2 xy, in vec3 ro, in vec3 lookTo, in float fov) {\n    vec3 camFw = normalize(lookTo - ro);\n    vec3 camRt = normalize(cross(camFw, vY));\n    vec3 camUp = cross(camRt, camFw);\n    \n    vec3 rd;\n    rd = camFw + fov * (camRt * xy.x + camUp * xy.y);\n    rd = normalize(rd);\n    \n    return rd;\n}\n\nbool gHeatMap = false;\nvoid readKeyboard() {\n    gHeatMap = bool(texelFetch(iChannel0, ivec2(49, 2), 0).x);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    const float zoom = 0.8;\n    \n    vec2 xy = (XY * 2.0 - RES) / MINRES / zoom;\n    \n    const float heatMapSize = 0.4;\n    bool isHeatMap = gHeatMap && XY.x < RES.x * heatMapSize && XY.y < RES.y * heatMapSize;\n    if (isHeatMap) {\n        xy = (XY * 2.0 - RES * heatMapSize) / MINRES / heatMapSize / zoom;\n    }\n    \n    vec2 M = iMouse.xy;\n    if (length(M) < 100.0) {\n        M = RES/2.0;\n        M.x += iTime * 13.0 + 0.7 * RES.x / 2.0;\n        M.y *= 1.5 + 0.3 * sin(iTime * 0.05);\n    }\n    \n    vec3 ro = vec3(0.0, 40.0 - 50.0 * (M.y / RES.y - 0.5), -40.0);\n    ro.xz *= rot2(3.141 + (M.x / RES.x - 0.5) * -7.0);\n    vec3 lt = vY * 32.0;\n    vec3 rd = getRayDir(xy, ro, lt, 0.8);\n    \n    RGBA.rgb = render(ro, rd);\n    \n    if (isHeatMap) {\n        float h = saturate(gMapCount / 500.0);\n        vec3 cool = vec3(0.0, 0.0, 0.7);\n        vec3 warm = vec3(1.0, 0.9, 0.0);\n        RGBA.rgb = mix(cool, warm, h);\n    }\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(1.0/2.2));\n    \n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 vX = vec3(1.0, 0.0, 0.0);\nconst vec3 vY = vX.yxy;\nconst vec3 vZ = vX.yyx;\nconst vec3 v0 = vX.yyy;\nconst vec3 v1 = vX.xxx;\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2  saturate(vec2  v) { return clamp(v, 0.0, 1.0); }\nvec3  saturate(vec3  v) { return clamp(v, 0.0, 1.0); }\n\nfloat sqr(float a) {\n    return a * a;\n}\n\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n//--------------------------------------------------------------------------------\n\n// iq\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    if (t < 0.0) {\n        t = 1e9;\n    }\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csccz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 268, 268, 1037], [1039, 1039, 1066, 1066, 1338], [1340, 1340, 1369, 1369, 1407], [1409, 1409, 1472, 1537, 2092], [2149, 2149, 2183, 2183, 2518], [2520, 2520, 2557, 2557, 3562], [3564, 3564, 3634, 3634, 3877], [3902, 3902, 3923, 3923, 3988], [3990, 3990, 4033, 4033, 5072]], "test": "untested"}
{"id": "mdtyzN", "name": "Sphere fake 3d - loopless & golf", "author": "FabriceNeyret2", "description": "making loopless the costly SnackEater's shader https://shadertoy.com/view/dljfWW\n+ golfing.   → at least 342 x faster, and cost independent of amount of dots.\nJacobian (O.x line ) : generic method to draw fair disc dots in distorted field.", "tags": ["3d", "distortions", "dots", "short", "golf", "loopless"], "likes": 43, "viewed": 596, "published": 3, "date": "1694807455", "time_retrieved": "2024-07-30T17:33:39.253524", "image_code": "// loopless + golfing 533 \"Sphere fake 3d\" by SnackEater. https://shadertoy.com/view/dljfWW\n// 272 without Jacobians -  288 with approx J  - 308 with exact J\n// --- Unlooping reasoning: -------------------------------------------\n//     usually it's easy (e.g. for 2D patterns) : one just has to solve which loop counter is closest:\n//     with a term like length(U-P), we must have P ~ U + P constraints (grid sampled, interval, etc).\n//     Here it's a bit involved:\n//     dot → U ~ P.xy → reverse rot on U → reverse P to a,b\n//     trick is to complete U with U.z = sqrt(r² - [U|²)\n\n/**/\n\n#define r  mat2(cos( iTime +vec4(0,33,11,0)))\n\nvoid mainImage( out vec4 O, vec2 U )\n{   \n    vec3  R = iResolution, P;\n          U = ( U+U - R.xy ) / R.y;                                // normalize coordinates\n    float s = .04365,                                              // s+s = 2Pi/72 = 5° steps\n          z = 1. - dot(U,U);\n    O *= 0.;             \n    z > 0.                                                         // if on sphere\n      ? P = vec3( U, sqrt(z) ),                                    // 3D point on front half-sphere\n        P.yz *= r,\n        P.xz *= r,                                                 // rotate on sphere\n        U =  vec2( atan(length(P.xy),P.z), atan(P.x,P.y) ),        // get parameterization\n        O.x = 1. - length( ( mod( U + s , s+s ) -s )               // draw blob at grid centers\n                       //  / fwidth(U) ) * 140./R.y                // compensate distorsion with Jacobian (approx)\n                           * inverse(transpose(mat2(dFdx(U),dFdy(U)))) )  * 1e2/R.y  // ( precise )\n      : s;\n}\n\n\n\n\n/**  // 289 chars  -5 by timedstamp , -25 by Fab\n\n#define r *= mat2(cos( iTime +vec4(0,33,11,0)))\n\nvoid mainImage( out vec4 O, vec2 U )\n{   \n    vec3  R = iResolution, P;\n    float z = 1. - dot( U = ( U+U - R.xy ) / R.y , U );\n    O *= 0.;             \n    z > 0.\n      ? P = vec3( U, sqrt(z) ),\n        P.yz r,\n        P.xz r, \n        O.x = 1. - length(  inverse(mat2(dFdx(U),dFdy(U)))\n                           *( fract( U = atan( vec2(length(P.xy),P), P.zy )*11.45 + .5 ) -.5 )\n                         ) *1e2/R.y \n      : z;\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[648, 648, 686, 686, 1665]], "test": "untested"}
{"id": "clSBzt", "name": "Uniform (Hemi)Sphere Sampling", "author": "piyushslayer", "description": "Uniform random points sample in a Unit Hemisphere. Set HEMISPHERE to 0 to enable sampling points on a Unit Sphere.", "tags": ["raytracing", "raymarching", "sdf", "pathtracing", "sampling", "pdf"], "likes": 18, "viewed": 531, "published": 3, "date": "1694806086", "time_retrieved": "2024-07-30T17:33:40.033438", "image_code": "#define PI     3.1415926535\n#define TWO_PI 6.2831853071\n\n#define HEMISPHERE   1      // Disabling this generates uniform random points on a unit sphere. \n#define MAX_POINTS   1024.0 // Max number of generated points.\n#define COLOR_POINTS 1      // Enable/Disable random coloring for each point. \n\n// From quality hashes collection by nimitz: https://www.shadertoy.com/view/Xt3cDn\nuint BaseHash(uvec2 p) \n{\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\nvec3 Hash3(inout float seed) \n{\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 RandomPointInUnitSphere(inout float seed, inout vec3 hash, in float rotationOffset) \n{\n    hash = Hash3(seed);\n#if HEMISPHERE\n    vec3 s = hash * vec3(TWO_PI, 1.0, 1.0) - vec3(rotationOffset, 0.0, 0.0);\n#else\n    vec3 s = hash * vec3(TWO_PI, 2.0, 1.0) - vec3(rotationOffset, 1.0, 0.0);\n#endif\n    float theta = s.x;\n    float sinPhi = sqrt(1.0 - s.y * s.y); // s.y --> cos(phi)\n    float r = pow(s.z, 0.3333333334); // Cuberoot to evenly spread out the points from the center along the radius. \n    \n    return r * vec3(cos(theta) * sinPhi, s.y, sin(theta) * sinPhi);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n#if HEMISPHERE\n    uv.y += 0.2;\n#endif\n    uv *= 3.0;\n    \n    vec4 m = iMouse / iResolution.y;\n    \n    float currentTime = floor(iTime * MAX_POINTS * 0.1);\n    float timeThreshold = MAX_POINTS * 1.3;\n    float rOffset = iTime * 0.1;\n\n    vec3 outColor = vec3(0.0);\n    \n    float numPoints = min(MAX_POINTS, mod(currentTime, timeThreshold));\n    float hashSeed = floor(currentTime / timeThreshold);\n    \n    if (m.z > 0.0)\n    {\n        rOffset = -m.x * 4.0;\n    }\n    \n    vec3 point;\n    vec2 pointUv;\n    vec3 hash;\n    for (float i = 0.0; i < numPoints; ++i)\n    {\n        point = RandomPointInUnitSphere(hashSeed, hash, rOffset);\n        pointUv = uv * (point.z * 0.25 + 0.75);\n        \n        outColor += 4e-5 / pow(length(pointUv - point.xy), 1.6) * ((1.0 - point.z) * 1.6 + 0.8) \n#if COLOR_POINTS\n        * hash.zyx * 0.32\n#else\n        * 0.16\n#endif\n        ;\n    }\n    \n    float t = fragCoord.x + fragCoord.y * iTime;\n    fragColor = vec4(pow(outColor, vec3(1.0 / 2.2)) - Hash3(t).xxx * 0.04, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 380, 405, 405, 533], [535, 535, 566, 566, 751], [753, 753, 844, 844, 1327]], "test": "untested"}
{"id": "ddtyzH", "name": "GPU Plays the Piano - 2", "author": "pikachuchujelly", "description": "The world famous piano-playing graphics card continues his recital by playing \"Maple Leaf Rag\" by Scott Joplin.", "tags": ["sound", "music", "audio", "piano", "ragtime"], "likes": 23, "viewed": 634, "published": 3, "date": "1694800734", "time_retrieved": "2024-07-30T17:33:41.217273", "image_code": "#define HUGE 1000000.0\n#define PI 3.14159265359\n\nbool isNotePlaying(int note)\n{\n    //return false;\n    return texelFetch(iChannel1, ivec2(note, 0), 0).r != 0.;\n}\n\n// computes the ray direction of a screen pixel\nvec3 perspectiveRay(vec2 pixel)\n{\n      float x = -1.0 + 2.0*(pixel.x / iResolution.x);\n      float z = -1.0 + 2.0*(pixel.y / iResolution.y);\n      z *= iResolution.y / iResolution.x;  // aspect ratio\n      float y = 1.0;\n      return normalize(vec3(x,y,z));\n}\n\n// rotation about the z axis\nvec3 rotateYaw(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(v.x * c - v.y * s, v.y * c + v.x * s, v.z);\n}\n\n// rotation about the x axis\nvec3 rotatePitch(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(v.x, v.y * c - v.z * s, v.z * c + v.y * s);\n}\n\n// rotation about the y axis\nvec3 rotateRoll(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(v.x * c - v.y * s, v.y, v.z * c + v.x * s);\n}\n\nvec3 lightDir = normalize(vec3(1,1,-1.5));\n\nfloat calcLight(vec3 normal, vec3 rd, float shininess)\n{\n    float ambient  = 0.5;\n    float diffuse  = max(dot(-lightDir,normal), 0.0);\n    float specular = max(dot(-lightDir,reflect(rd, normal)), 0.0);\n    specular *= specular*specular*specular*specular*specular*specular*specular*specular;\n    return ambient + diffuse + specular * shininess;\n}\n\n// subtracts distance b from a\nfloat sdfSubtract(float a, float b)\n{\n    return max(a, -b);\n}\n\n// based on Inigo Quilez's SDF functions\nfloat sdfBox(vec3 p, vec3 center, vec3 b)\n{\n    vec3 q = abs(p-center) - b;\n    return length(max(q,0.0)) + min(max(max(q.x,q.y),q.z),0.0);\n}\n\n// like sdfBox, but specifying minimum and maximum bounds\nfloat sdfBoxBounds(vec3 p, vec3 bmin, vec3 bmax)\n{\n    return sdfBox(p, .5*(bmin+bmax), .5*(bmax-bmin));\n}\n\nint whiteKeyToNote(float key)\n{\n    int octave = int(floor(key / 7.));\n    key = mod(key, 7.);\n    int note = int(key) * 2;\n    if (key >= 3.)\n        note--;\n    return octave * 12 + note + 39;\n}\n\nint blackKeyToNote(float key)\n{\n    int octave = int(floor(key / 7.));\n    key = mod(key, 7.);\n    int note = int(key) * 2 + 1;\n    if (key >= 2.)\n        note--;\n    return octave * 12 + note + 39;\n}\n\nfloat sdfBlackKey(vec3 p, float key)\n{\n    key = clamp(key, -23., 26.);\n    // if this is the spot between B-C or E-F with no black key, choose the closest black key instead\n    if (mod(key,7.) == 2. || mod(key,7.) == 6.)\n        key += fract(p.x) >= .5 ? 1. : -1.;\n    int note = blackKeyToNote(key);\n    float z = isNotePlaying(note) ? .1 : .5;\n    return sdfBox(p, vec3(key+.5,1.,z), vec3(.25, 1., .5));\n}\n\nfloat sdfWhiteKey(vec3 p, float key)\n{\n    key = clamp(key, -23., 28.);\n    int note = whiteKeyToNote(key);\n    float z = isNotePlaying(note) ? -.5 : 0.;\n    return sdfBox(p, vec3(key,0.,z), vec3(.45, 2., .5))-.05;\n}\n\nfloat sdfWhiteKeys(vec3 p)\n{\n    float key = round(p.x);  // get nearest key\n    //return sdfWhiteKey(p, key);\n    // If key is pressed, we need to SDF the neighboring keys as well.\n    float a = sdfWhiteKey(p, key - 1.);\n    float b = sdfWhiteKey(p, key);\n    float c = sdfWhiteKey(p, key + 1.);\n    return min(min(a, b), c);\n}\n\nfloat sdfBlackKeys(vec3 p)\n{\n    float key = round(p.x-.5);  // get nearest key\n    return sdfBlackKey(p, key);\n}\n\nfloat globalSdf(vec3 p, out vec3 color)\n{\n    vec3 bmin = vec3(-25.5, -2.5, -4);\n    vec3 bmax = vec3(30, 30, 4);\n    color = vec3(.1,.1,.1);\n    float d;\n    float dCutout;\n\n    d = sdfBoxBounds(p, bmin, bmax);\n    // middle part\n    d = min(d, sdfBoxBounds(p, bmin + vec3(1, 10, -20), bmax + vec3(-1, -1, 15)));\n    // back of piano body\n    d = min(d, sdfBoxBounds(p, bmin + vec3(0, 9, 8+13), bmax + vec3(0, 0, 15)));\n    // left leg\n    d = min(d, sdfBox(p, vec3(bmin.x+3., bmin.y+3., -4 - 10), vec3(1, 1, 10)));\n    // right leg\n    d = min(d, sdfBox(p, vec3(bmax.x-3., bmin.y-3., -4 - 10), vec3(1, 1, 10)));\n    // cut out keyboard area\n    bmin.y--;bmax.z++;\n    bmin.x += 2.;\n    bmax.x -= 2.;\n    bmax.y = 2.;\n    bmin.z = -.5;\n    dCutout = sdfBox(p, .5*(bmin+bmax), .5*(bmax-bmin));\n    d = sdfSubtract(d, dCutout);\n\n    if (dCutout < 0.)  // optimization: only SDF the keys if we're in the cutout\n    {\n        float dBlack = sdfBlackKeys(p);\n        d = min(d, dBlack);\n        float dWhite = sdfWhiteKeys(p);\n        if (dWhite <= d)\n            color = vec3(.8, .8, .8);\n        d = min(d, dWhite);\n    }\n    return d;\n}\n\nvec3 calcNormal(vec3 p, float d)\n{\n    float e = 0.0001;\n    vec3 dummy;\n    vec3 n = vec3(\n        globalSdf(p + vec3(e,0,0), dummy),\n        globalSdf(p + vec3(0,e,0), dummy),\n        globalSdf(p + vec3(0,0,e), dummy));\n    return normalize(n - d);\n}\n\n// basic environment mapping with a cubemap texture\nvec4 env(vec3 rd)\n{\n    return texture(iChannel0, rd.xzy * vec3(1,1,-1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 ro;  // ray origin\n    vec3 rd;  // ray direction\n    float yaw = PI/8.;\n    float pitch = -PI/8.;\n\n    ro = vec3(18, -18, 15);\n\n    rd = perspectiveRay(fragCoord);\n    rd = rotateYaw(rotatePitch(rd, pitch), yaw);\n\n    fragColor = env(rd);\n\n    // ray march the piano\n    float t = 0.;\n    for (int i = 0; i < 30; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec4 color;\n        float d = globalSdf(p, color.rgb);\n        if (d < 0.05)\n        {\n            vec3 normal = calcNormal(p, d);\n            vec3 refl = reflect(rd, normal);\n            color = mix(color, env(refl), 0.25);\n            fragColor.rgb = color.rgb * calcLight(normal, rd, 0.5);\n            break;\n        }\n        t += d;\n        if (t > 100.)\n            break;\n    }\n    //fragColor = texture(iChannel1, vec2(fragCoord.x / iResolution.x, 0));\n    \n    // fade out\n    float time = iTime;\n    if (time >= 177.0)\n        fragColor.rgb = mix(fragColor.rgb, vec3(0), (time - 177.0) / 3.);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// \"It's never right to play ragtime fast!\" - Scott Joplin\n// ...but here in ShaderToy, we're only allowed 3 minutes of music :)\n#define BPM 98.0\n\n#define BEAT (60./BPM)     // length of a quarter note in seconds\n#define MEASURE (2.*BEAT)  // length of a measure (2/4 time)\n\nfloat timeTrack(float time)\n{\n    time -= .5;  // pickup measure\n    if (time >= 16.*MEASURE)\n    {\n        time -= 16.*MEASURE;\n        if (time >= 15.*MEASURE) time += MEASURE;  // 2nd ending\n    }\n    if (time >= 33.*MEASURE)\n    {\n        time -= 16.*MEASURE;\n        if (time >= 32.*MEASURE) time += MEASURE;  // 2nd ending\n    }\n    if (time >= 34.*MEASURE)\n    {\n        time -= 34.*MEASURE;  // back to the beginning\n        if (time >= 15.*MEASURE) time = 50.*MEASURE + time - 15.*MEASURE;  // to trio\n    }\n    if (time >= 67.*MEASURE)\n    {\n        time = 51.*MEASURE + time - 67.*MEASURE;  // repeat trio\n        if (time >= 66.*MEASURE) time = 67.*MEASURE + time - 66.*MEASURE;  // 2nd ending\n    }\n    if (time >= 84.*MEASURE)\n    {\n        time = 68.*MEASURE + time - 84.*MEASURE;\n        if (time >= 83.*MEASURE) time += MEASURE;  // 2nd ending\n    }\n\n    return time;\n}\n\n// Right hand\n#define CHANNEL1 \\\nDYN(F) \\\n/*1*/  R(.25) N(.25,Gs4) CHORD2(.25,Ds4,Ds5) N(.25,Gs4) N(.25,C5) CHORD2(.5,Ds4,Ds5) N(.25,G4) \\\n/*2*/  CHORD2(.25,Ds4,Ds5) N(.25,G4) N(.25,As4) CHORD2(1.25,Ds4,Ds5) \\\n/*3*/  R(.25) N(.25,Gs4) CHORD2(.25,Ds4,Ds5) N(.25,Gs4) N(.25,C5) CHORD2(.5,Ds4,Ds5) N(.25,G4) \\\n/*4*/  CHORD2(.25,Ds4,Ds5) N(.25,G4) N(.25,As4) CHORD2(.5,Ds4,Ds5) R(.5) CHORD2(.25,Ds4,Ds5) \\\n/*5*/  R(.25) N(.25,Gs4) N(.25,B4) CHORD2(.25,E4,E5) R(.25) CHORD2(.25,Ds4,Ds5) R(.25) CHORD2(.25,Ds4,Ds5) \\\n/*6*/  R(.25) N(.25,Gs4) N(.25,B4) CHORD2(.25,E4,E5) R(.25) CHORD2(.25,Ds4,Ds5) R(.5) \\\n/*7*/  DYN(P) R(2.) \\\n/*8*/  R(.25) N(.25,Gs4) N(.25,B4) N(.25,Gs5) R(.25) N(.25,Gs5) N(.25,B5) N(.25,Gs6) \\\n/*9*/  CRESC(2.,MF,F) CHORD2(.5,Gs5,Gs6) CHORD2(.5,Gs5,Gs6) CHORD2(.5,Gs5,Gs6) CHORD2(.25,Gs5,Gs6) CHORD2(.5,Gs5,Gs6) \\\n/*10*/ N(.25,Ds6) N(.25,F6) N(.25,C6) N(.25,Ds6) CHORD2(.5,Gs5,F6) CHORD2(.5,E5,Gs5) \\\n/*11*/ N(.25,As5) CHORD2(.25,E5,B5) N(.25,Gs5) N(.25,As5) CHORD2(.5,Ds5,C6) N(.25,Gs5) \\\n/*12*/ CHORD2(.25,Ds5,C6) N(.25,Gs5) CHORD2(.5,Ds5,As5) CHORD2(.5,Ds5,Gs5) R(.25) CHORD2(.75,Gs4,Gs5) \\\n/*13*/ CHORD2(.5,Gs4,Gs5) CHORD2(.5,Gs4,Gs5) CHORD2(.25,Gs4,Gs5) CHORD2(.5,Gs4,Gs5) \\\n/*14*/ N(.25,Ds5) CHORD2(.25,Gs4,F5) N(.25,C5) N(.25,Ds5) CHORD2(.5,Gs4,F5) CHORD2(.5,E4,Gs4) \\\n/*15*/ N(.25,As4) CHORD2(.25,E4,B4) N(.25,Gs4) N(.25,As4) CHORD2(.5,Ds4,C5) N(.25,Gs4) \\\n/*16 - 1st ending*/ CHORD2(.25,Ds4,C5) N(.25,Gs4) CHORD2(.5,Ds4,As4) CHORD2(.5,Ds4,Gs4) R(.5) \\\n/*17 - 2nd ending*/ CHORD2(.25,Ds4,C5) N(.25,Gs4) CHORD2(.5,Ds4,As4) CHORD2(.5,Ds4,Gs4) R(.5) \\\n/*18*/ DYN(F) R(.25) N(.25,G5) CHORD2(.25,Ds5,Ds6) N(.25,G5) N(.25,As5) CHORD2(.5,D5,D6) N(.25,G5) \\\n/*19*/ CRESC(2.,F,MF) CHORD2(.25,Cs5,Cs6) N(.25,G5) N(.25,As5) CHORD2(.5,C5,C6) N(.25,Ds5) CHORD2(.25,As4,As5) N(.25,Ds5) \\\n/*20*/ R(.25) N(.25,C5) CHORD2(.25,Gs4,Gs5) N(.25,C5) N(.25,Ds5) CHORD2(.5,F4,F5) N(.25,C5) \\\n/*21*/ CHORD2(.25,Gs4,Gs5) N(.25,C5) N(.25,Ds5) CHORD2(.5,F4,F5) N(.25,C5) CHORD2(.5,F4,F5) \\\n/*22*/ DYN(F) R(.25) N(.25,Ds5) CHORD2(.25,G4,G5) N(.25,As4) N(.25,Cs5) CHORD2(.5,F4,F5) N(.25,Ds5) \\\n/*23*/ CRESC(2.,F,MF) CHORD2(.25,G4,G5) N(.25,As4) N(.25,Cs5) CHORD2(.5,F4,F5) N(.25,Cs5) CHORD2(.5,F4,F5) \\\n/*24*/ R(.25) N(.25,C5) CHORD2(.25,Gs4,Gs5) N(.25,C5) N(.25,Ds5) CHORD2(.5,F4,F5) N(.25,C5) \\\n/*25*/ CHORD2(.25,Gs4,Gs5) N(.25,C5) N(.25,Ds5) CHORD2(.5,F4,F5) N(.25,C5) CHORD2(.5,F4,F5) \\\n/*26*/ DYN(F) R(.25) N(.25,G5) CHORD2(.25,Ds5,Ds6) N(.25,G5) N(.25,As5) CHORD2(.5,D5,D6) N(.25,G5) \\\n/*27*/ CRESC(2.,F,MP) CHORD2(.25,Cs5,Cs6) N(.25,G5) N(.25,As5) CHORD2(.5,C5,C6) N(.25,Ds5) CHORD2(.25,As4,As5) N(.25,Ds5) \\\n/*28*/ R(.25) N(.25,C5) CHORD2(.25,Gs4,Gs5) N(.25,C5) N(.25,Ds5) CHORD2(.5,F4,F5) N(.25,C5) \\\n/*29*/ CRESC(2.,MP,F) CHORD2(.5,Gs4,Gs5) CHORD2(.5,Gs4,Gs5) CHORD2(.5,G4,G5) CHORD2(.5,Fs4,Fs5) \\\n/*30*/ R(.25) N(.25,F4) N(.25,A4) N(.25,C5) N(.25,F5) N(.25,C5) N(.25,A4) N(.25,F4) \\\n/*31*/ R(.25) N(.25,F4) N(.25,As4) N(.25,Cs5) CHORD2(.5,F4,F5) CHORD3(.5,F4,As4,Cs5) \\\n/*32*/ CHORD4(.5,D4,F4,Gs4,C5) R(.25) CHORD4(.25,D4,F4,Gs4,C5) R(.25) CHORD2(.5,Cs4,As4) N(.25,Ds4) \\\n/*33 - 1st ending*/ CHORD2(.5,C4,Gs4) CHORD2(.5,Ds4,Ds5) CHORD2(.5,Ds4,Ds5) CHORD2(.5,Ds4,Ds5) \\\n/*34 - 2nd ending*/ CRESC(2.,F,FF) R(.25) N(.25,Gs4) N(.25,C5) N(.25,Ds5) CHORD2(.5,Gs4,Gs5) R(.5) \\\nAT(50.*2.) \\\n/*50*/ DYN(F) CHORD2(.25,Ds4,C5) N(.25,Gs4) CHORD2(.5,Ds4,As4) CHORD2(.5,Ds4,Gs4) CHORD2(.5,Gs4,Gs5) \\\n/* Trio */ \\\n/*51*/ DYN(MF) CHORD4(.75,Gs4,C5,Ds5,Gs5) CHORD4(.5,As4,C5,Ds5,Gs5) CHORD2(.25,C5,Ds5) N(.5,As4) \\\n/*52*/ CRESC(2.,MF,MP) CHORD4(.75,Gs4,C5,Ds5,Gs5) CHORD4(.5,As4,C5,Ds5,Gs5) CHORD2(.25,C5,Ds5) N(.25,As4) CHORD2(.25,C5,Ds5) \\\n/*53*/ N(.25,Gs4) N(.25,Cs5) N(.25,As4) N(.25,Cs5) N(.25,F5) N(.25,Gs4) N(.25,Cs5) N(.25,F5) \\\n/*54*/ CRESC(2.,MP,MF) N(.25,As4) N(.25,Cs5) N(.25,F5) N(.5,Gs4) N(.25,F5) N(.25,As4) N(.25,F5) \\\n/*55*/ CHORD4(.75,Gs4,C5,Ds5,Gs5) CHORD4(.5,As4,C5,Ds5,Gs5) CHORD2(.25,C5,Ds5) N(.5,As4) \\\n/*56*/ CRESC(2.,MF,MP) CHORD4(.75,Gs4,C5,Ds5,Gs5) CHORD4(.5,As4,C5,Ds5,Gs5) CHORD2(.25,C5,Ds5) N(.25,As4) CHORD2(.25,C5,Ds5) \\\n/*57*/ N(.25,Gs4) N(.25,Cs5) N(.25,As4) N(.25,Cs5) N(.25,F5) N(.25,Gs4) N(.25,Cs5) N(.25,F5) \\\n/*58*/ CRESC(2.,MP,MF) N(.25,As4) N(.25,Cs5) N(.25,F5) N(.5,Gs4) N(.25,F5) N(.25,A4) CHORD2(.25,Ds5,F5) \\\n/*59*/ CHORD4(.75,As4,D5,F5,As5) CHORD4(.5,C5,D5,F5,As5) CHORD2(.25,D5,F5) N(.5,C5) \\\n/*60*/ CHORD4(.75,As4,D5,F5,As5) CHORD4(.5,C5,D5,F5,As5) CHORD2(.25,D5,F5) N(.25,C5) CHORD2(.25,D5,F5) \\\n/*61*/ CRESC(4.,MF,F) R(.25) N(.25,Ds5) CHORD2(.25,As4,As5) N(.25,Ds5) N(.25,Fs5) CHORD2(.5,C5,C6) N(.25,Ds5) \\\n/*62*/ CHORD2(.25,As4,As5) N(.25,Ds5) N(.25,Fs5) CHORD2(.5,C5,C6) N(.25,Ds5) CHORD2(.5,As4,As5) \\\n/*63*/ DYN(FF) CHORD3(.5,Cs5,E5,Cs6) CHORD3(.5,Cs5,E5,Cs6) CRESC(1.,FF,F) CHORD3(.5,C5,E5,C6) CHORD3(.5,As4,E5,As5) \\\n/*64*/ CHORD2(.25,Gs4,F5) N(.25,Cs5) N(.25,Ds5) CHORD2(.5,As4,Fs5) N(.25,As4) CHORD2(.5,Gs4,F5) \\\n/*65*/ CRESC(2.,F,MF) CHORD2(.25,G4,F5) N(.25,Cs5) N(.25,Ds5) CHORD2(.5,Fs4,F5) N(.25,C5) CHORD2(.25,G4,Ds5) CHORD2(.5,F4,Cs5) \\\n/*66 - 1st ending*/ DYN(FF) CHORD2(.5,Gs4,Gs5) N(.25,F5) CHORD2(.25,Gs4,Gs5) N(.25,F5) CHORD2(.25,Gs4,Gs5) N(.25,F5) \\\n/*67 - 2nd ending*/ /*CHORD2(.25,F4,Cs5)*/ R(.25) N(.25,Cs5) N(.25,F5) N(.25,Gs5) CHORD2(.5,Cs5,Cs6) R(.5) \\\n/*68*/ DYN(F) CHORD2(.5,Gs4,Gs5) CHORD2(.5,Gs4,F5) CHORD2(.5,Gs4,Gs5) CHORD2(.5,Gs4,F5) \\\n/*69*/ CHORD2(.5,F5,Gs5) CHORD2(.25,F5,As5) CHORD2(.5,F5,C6) N(.25,As5) N(.25,Gs5) N(.25,F5) \\\n/*70*/ N(.25,Ds5) N(.5,F5) CHORD2(1.25,Gs4,C5) \\\n/*71*/ R(.25) N(.25,Ds5) CHORD2(.25,Gs4,F5) N(.25,C5) N(.25,Ds5) CHORD2(.5,Gs4,F5) N(.25,C5) \\\n/*72*/ CHORD2(.5,G4,Ds5) N(.25,F5) CHORD2(1.25,G4,As4) \\\n/*73*/ R(.25) N(.25,Cs5) CHORD2(.25,G4,F5) N(.25,As4) N(.25,Cs5) CHORD2(.5,G4,F5) CRESC(4.25,P,F) CHORD2(.5,Gs4,C5) \\\n/*74*/ N(.25,Ds5) CHORD2(.25,Gs4,F5) N(.25,C5) N(.25,Ds5) CHORD2(.5,Gs4,F5) CHORD2(.5,Gs4,C5) \\\n/*75*/ N(.25,Ds5) CHORD2(.25,Gs4,F5) N(.25,C5) N(.25,Ds5) CHORD2(.5,Gs4,F5) N(.25,Ds5) \\\n/*76*/ CHORD2(.5,Gs4,Gs5) CHORD2(.5,Gs4,F5) CHORD2(.5,Gs4,Gs5) CHORD2(.5,Gs4,F5) \\\n/*77*/ CHORD2(.5,F5,Gs5) CHORD2(.25,F5,As5) CHORD2(.5,F5,C6) N(.25,As5) N(.25,Gs5) N(.25,F5) \\\n/*78*/ N(.5,Gs5) N(.5,F5) N(.25,Ds5) N(.5,Gs5) CHORD2(.5,Gs4,C5) \\\n/*79*/ N(.25,Ds5) CHORD2(.25,Gs4,F5) N(.25,C5) N(.25,Ds5) CHORD2(.5,Gs4,F5) CHORD2(.5,F4,Gs4) \\\n/*80*/ N(.25,As4) CHORD2(.5,F4,Gs4) CHORD2(.5,E4,Gs4) CHORD2(.25,E4,As4) CHORD2(.5,Ds4,Gs4) \\\n/*81*/ N(.25,As4) CHORD2(.25,Ds4,C5) N(.25,Gs4) N(.25,As4) CHORD2(.5,Ds4,C5) CHORD2(.5,D4,Gs4) \\\n/*82*/ N(.25,As4) CHORD2(.25,D4,C5) N(.25,Gs4) R(.25) CHORD2(.5,Cs4,As4) N(.25,Ds4) \\\n/*83 - 1st ending*/ CHORD2(.5,C4,Gs4) CHORD2(.5,Ds4,Ds5) CHORD2(.5,Ds4,Ds5) CHORD2(.5,Ds4,Ds5) \\\n/*84 - 2nd ending*/ CHORD2(.5,C4,Gs4) DYN(FF) CHORD3(.5,G4,Cs5,Ds5) CHORD4(.5,Gs4,C5,Ds5,Gs5) \\\n\n// Left hand\n#define CHANNEL2 \\\nAT(-0.5) \\\nDYN(F) \\\nCHORD2(.5,Ds2,Ds3) \\\n/*1*/  CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C3) CHORD3(.5,Ds3,Gs3,C3) CHORD2(.5,A2,A3) \\\n/*2*/  CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Cs3) CHORD3(.5,Ds3,G3,Cs3) CHORD2(.5,Ds2,Ds3) \\\n/*3*/  CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C3) CHORD3(.5,Ds3,Gs3,C3) CHORD2(.5,A2,A3) \\\n/*4*/  CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Cs3) CHORD3(.5,Ds3,G3,Cs3) CHORD2(.5,Ds2,Ds3) \\\n/*5*/  CHORD2(1.,E2,E3) CHORD2(.5,Ds2,Ds3) CHORD2(.5,Ds2,Ds3) \\\n/*6*/  CHORD2(1.,E2,E3) CHORD2(.5,Ds2,Ds3) R(.5) \\\n/*7*/  DYN(P) N(.25,Gs1) N(.25,Gs2) N(.25,B2) N(.25,Gs3) N(.25,Gs2) N(.25,Gs3) N(.25,B3) N(.25,Gs4) \\\n/*8*/  CRESC(2.,P,MF) N(.25,Gs3) R(.75) N(.25,Gs4) R(.75) \\\n/*9*/  CRESC(2.,MF,F) CHORD4(.5,D4,F4,Gs4,B4) CHORD4(.5,D4,F4,Gs4,B4) CHORD4(.5,D4,F4,Gs4,B4) CHORD4(.5,D4,F4,Gs4,B4) \\\n/*10*/ CHORD3(.5,Ds4,Gs4,C5) CHORD3(.5,Ds4,Gs4,C5) CHORD3(.5,Ds4,Gs4,C5) CHORD3(.5,Ds4,Gs4,C5) \\\n/*11*/ CHORD3(.5,E4,Gs4,B4) CHORD3(.5,E4,Gs4,B4) CHORD3(.5,Ds4,Gs4,C5) CHORD3(.5,Ds4,Gs4,C5) \\\n/*12*/ CHORD3(.5,Ds4,Gs4,C5) CHORD3(.5,Ds4,G4,Cs5) CHORD2(.5,Gs4,C5) R(.5) \\\n/*13*/ CHORD4(.5,D3,F3,Gs3,B3) CHORD4(.5,D3,F3,Gs3,B3) CHORD4(.5,D3,F3,Gs3,B3) CHORD4(.5,D3,F3,Gs3,B3) \\\n/*14*/ CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,Gs3,C4) \\\n/*15*/ CHORD3(.5,E3,Gs3,B3) CHORD3(.5,E3,Gs3,B3) CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,Gs3,C4) \\\n/*16 - 1st ending*/ CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,G3,Cs4) CHORD2(.5,Gs3,C4) CHORD2(.5,Ds2,Ds3) \\\n/*17 - 2nd ending*/ CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,G3,Cs4) CHORD2(.5,Gs3,C4) CHORD2(.5,A2,A3) \\\n/*18*/ DYN(F) CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Ds4) CHORD2(.5,Ds2,Ds3) CHORD3(.5,Ds3,G3,Ds4) \\\n/*19*/ CRESC(2.,F,MF) CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Ds4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,G2,G3) \\\n/*20*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Ds3,Ds3) CHORD3(.5,Ds3,Gs3,C4) \\\n/*21*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Gs2,Gs3) CHORD2(.5,A2,A3) \\\n/*22*/ DYN(F) CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Ds4) CHORD2(.5,Ds2,Ds3) CHORD3(.5,Ds3,G3,Ds4) \\\n/*23*/ CRESC(2.,F,MF) CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Ds4) CHORD2(.5,As2,As3) CHORD2(.5,B2,B3) \\\n/*24*/ CHORD2(.5,C3,C4)   CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Ds2,Ds3) CHORD3(.5,Ds3,Gs3,C4) \\\n/*25*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Gs2,Gs3) CHORD2(.5,A2,A3) \\\n/*26*/ DYN(F) CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Ds4) CHORD2(.5,Ds2,Ds3) CHORD3(.5,Ds3,G3,Ds4) \\\n/*27*/ CRESC(2.,F,MP) CRESC(2.,F,MF) CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Ds4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,G2,G3) \\\n/*28*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Ds3,Ds3) CHORD3(.5,Ds3,Gs3,C4) \\\n/*29*/ CRESC(2.,MP,F) CHORD2(.5,Gs2,Gs3) CHORD2(.5,Gs2,Gs3)    CHORD2(.5,G2,G3)   CHORD2(.5,Fs2,Fs3) \\\n/*30*/ CHORD2(.5,F2,F3)   CHORD2(.5,F2,F3)      CHORD2(.5,A2,A3)   CHORD2(.5,A2,A3) \\\n/*31*/ CHORD2(.5,As2,As3) CHORD3(.5,F3,As3,Cs4) CHORD3(.5,F3,As3,Cs4) CHORD3(.5,F3,As3,Cs4) \\\n/*32*/ CHORD3(.5,As2,F3,As3) CHORD3(.5,As2,F3,As3) CHORD2(.5,Ds2,Ds3) CHORD2(.5,G2,G3) \\\n/*33 - 1st ending*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,A2,A3) \\\n/*34 - 2nd ending*/ CRESC(2.,F,FF) CHORD2(.5,Gs2,Gs3) CHORD3(.5,Gs3,C4,Ds4) CHORD3(.5,Gs3,C4,Ds4) CHORD2(.5,Ds2,Ds3) \\\nAT(50.*2.) \\\n/*50*/ DYN(F) CHORD3(.5,Ds3,Gs3,C4) CHORD3(.5,Ds3,G3,Cs4) CHORD2(.5,Gs3,C4) R(.5) \\\n/* Trio */ \\\n/*51*/ DYN(MF) CHORD2(.5,Ds2,Ds3) CHORD3(.5,Gs3,C4,Fs4) CHORD2(.5,Fs2,Fs3) CHORD3(.5,Gs3,C4,Fs4) \\\n/*52*/ CRESC(2.,MF,MP) CHORD2(.5,Fs2,Fs3) CHORD3(.5,Gs3,C4,Fs4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,C2,C3) \\\n/*53*/ CHORD2(.5,Cs2,Cs3) CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,Gs2,Gs3) CHORD3(.5,Gs3,Cs4,F4) \\\n/*54*/ CRESC(2.,MP,MF) CHORD2(.5,F2,F3)   CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,Cs2,Cs3) CHORD2(.5,D2,D3) \\\n/*55*/ CHORD2(.5,Ds2,Ds3) CHORD3(.5,Gs3,C4,Fs4) CHORD2(.5,Fs2,Fs3) CHORD3(.5,Gs3,C4,Fs4) \\\n/*56*/ CRESC(2.,MF,MP) CHORD2(.5,Fs2,Fs3) CHORD3(.5,Gs3,C4,Fs4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,C2,C3) \\\n/*57*/ CHORD2(.5,Cs2,Cs3) CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,Gs2,Gs3) CHORD3(.5,Gs3,Cs4,F4) \\\n/*58*/ CRESC(2.,MP,MF) CHORD2(.5,F2,F3)   CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,Cs2,Cs3) CHORD2(.5,C2,C3) \\\n/*59*/ CHORD2(.5,As1,As2) CHORD3(.5,As3,D4,Gs4) CHORD2(.5,D2,D3)   CHORD3(.5,As3,D4,Gs4) \\\n/*60*/ CHORD2(.5,F2,F3)   CHORD3(.5,As3,D4,Gs4) CHORD2(.5,As2,As3) CHORD3(.5,As3,D4,Gs4) \\\n/*61*/ CRESC(4.,MF,F) CHORD2(.5,Ds2,Ds3) CHORD3(.5,As3,Ds4,Fs4) CHORD2(.5,Fs2,Fs3) CHORD3(.5,As3,Ds4,Fs4) \\\n/*62*/ CHORD2(.5,Ds2,Ds3) CHORD3(.5,As3,Ds4,Fs4) CHORD2(.5,Fs2,Fs3) CHORD3(.5,As3,Ds4,Fs4) \\\n/*63*/ DYN(FF) N(.25,G3) N(.5,As3) N(.25,Cs4) CRESC(1.,FF,F) N(.25,E4) N(.25,Cs4) N(.25,As3) N(.25,G3) \\\n/*64*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Gs3,Cs4,F4) N(.5,As2) CHORD3(.5,Gs3,As3,D4) \\\n/*65*/ CRESC(2.,F,MF) CHORD3(.5,Ds3,As3,Cs4) CHORD3(.5,Ds3,As3,Cs4) CHORD2(.5,Gs3,C4) CHORD2(.5,Gs3,C4) \\\n/*66 - 1st ending*/ CHORD2(.5,Cs3,Cs4) CHORD3(.5,Gs3,Cs4,F4) DYN(FF) CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,D2,D3) \\\n/*67 - 2nd ending*/ CHORD2(.5,Cs3,Cs4) CHORD2(.5,Gs2,Gs3) CHORD2(.5,Cs2,Cs3) CHORD2(.5,C3,C4) \\\n/*68*/ DYN(F) CHORD2(.5,Cs3,Cs4) CHORD3(.5,Gs3,Cs4,F4) CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,C3,C4) \\\n/*69*/ CHORD2(.5,Cs3,Cs4) CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,As2,As3) CHORD2(.5,B2,B3) \\\n/*70*/ CHORD2(.5,C3,C4)   CHORD3(.5,Gs3,C4,Ds4) CHORD3(.5,Gs3,C4,Ds4) CHORD2(.5,Ds2,Ds3) \\\n/*71*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,A2,A3) \\\n/*72*/ CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Ds4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,A2,A3) \\\n/*73*/ CHORD2(.5,As2,As3) CHORD3(.5,Ds3,G3,Cs4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,G2,G3) \\\n/*74*/ CRESC(4.,P,F) CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Ds2,Ds3) CHORD3(.5,Ds3,Gs3,C4) \\\n/*75*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,As2,As3) CHORD2(.5,C3,C4) \\\n/*76*/ CHORD2(.5,Cs3,Cs4) CHORD3(.5,Gs3,Cs4,F4) CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,C3,C4) \\\n/*77*/ CHORD2(.5,Cs3,Cs4) CHORD3(.5,Gs3,Cs4,F4) CHORD2(.5,As2,As3) CHORD2(.5,B2,B3) \\\n/*78*/ CHORD2(.5,C3,C4)   CHORD3(.5,Gs3,C4,Ds4) CHORD3(.5,Gs3,C4,Ds4) CHORD2(.5,Ds2,Ds3) \\\n/*79*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Ds2,Ds3) CHORD3(.5,Ds3,Gs3,C4) \\\n/*80*/ CHORD2(.5,Cs2,Cs3) CHORD2(.5,Cs2,Cs3)    CHORD2(.5,As1,As2) CHORD2(.5,D2,D3) \\\n/*81*/ CHORD2(.5,Ds2,Ds3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,Ds2,Ds3) CHORD2(.5,E2,E3) \\\n/*82*/ CHORD2(.5,F2,F3)   CHORD2(.5,F2,F3)      CHORD2(.5,G2,G3)   CHORD2(.5,G2,G3) \\\n/*83 - 1st ending*/ CHORD2(.5,Gs2,Gs3) CHORD3(.5,Ds3,Gs3,C4) CHORD2(.5,As2,As3) CHORD2(.5,Cs3,Cs4) \\\n/*84 - 2nd ending*/ CHORD2(.5,Gs2,Gs3) DYN(FF) CHORD2(.5,Ds2,Ds3) CHORD2(.5,Gs1,Gs2) \\\nR(1000.) N(.5,C3)  // Notes get stuck with some Intel graphics cards. Adding a random note at the end fixes this problem somehow?", "buffer_a_code": "/**\n * To determine if a note is being played, sample this buffer texture at (note, 0).\n * If the red component is 1, the note is being played. If it is 0, the note is not being played.\n */\n\n// piano note indexes\n#define A0 0\n#define As0 1\n#define B0 2\n#define C1 3\n#define Cs1 4\n#define D1 5\n#define Ds1 6\n#define E1 7\n#define F1 8\n#define Fs1 9\n#define G1 10\n#define Gs1 11\n#define A1 12\n#define As1 13\n#define B1 14\n#define C2 15\n#define Cs2 16\n#define D2 17\n#define Ds2 18\n#define E2 19\n#define F2 20\n#define Fs2 21\n#define G2 22\n#define Gs2 23\n#define A2 24\n#define As2 25\n#define B2 26\n#define C3 27\n#define Cs3 28\n#define D3 29\n#define Ds3 30\n#define E3 31\n#define F3 32\n#define Fs3 33\n#define G3 34\n#define Gs3 35\n#define A3 36\n#define As3 37\n#define B3 38\n#define C4 39\n#define Cs4 40\n#define D4 41\n#define Ds4 42\n#define E4 43\n#define F4 44\n#define Fs4 45\n#define G4 46\n#define Gs4 47\n#define A4 48\n#define As4 49\n#define B4 50\n#define C5 51\n#define Cs5 52\n#define D5 53\n#define Ds5 54\n#define E5 55\n#define F5 56\n#define Fs5 57\n#define G5 58\n#define Gs5 59\n#define A5 60\n#define As5 61\n#define B5 62\n#define C6 63\n#define Cs6 64\n#define D6 65\n#define Ds6 66\n#define E6 67\n#define F6 68\n#define Fs6 69\n#define G6 70\n#define Gs6 71\n#define A6 72\n#define As6 73\n#define B6 74\n#define C7 75\n#define Cs7 76\n#define D7 77\n#define Ds7 78\n#define E7 79\n#define F7 80\n#define Fs7 81\n#define G7 82\n#define Gs7 83\n#define A7 84\n#define As7 85\n#define B7 86\n#define C8 87\n\n#define TEST\n\n#ifdef TEST\n#define N(len, pitch) noteA=(t>=x&&t<x+len*.8*60.0/BPM)?pitch:noteA;x+=len*60.0/BPM;\n#else\n#define N(len, pitch) if(note==pitch&&t>=x&&t<x+len*0.8*60.0/BPM)return true; x+=len*60.0/BPM;\n#endif\n#define R(len) x+=len*60.0/BPM;\n\n#define AT(time) x=time*60.0/BPM;\n\n#define GRACE(a)        x-=0.05*60.0/BPM;N(0.05,a)\n#define GRACE2(a, b)    x-=0.10*60.0/BPM;N(0.05,a)N(0.05,b)\n#define GRACE3(a, b, c) x-=0.15*60.0/BPM;N(0.05,a)N(0.05,b)N(0.05,c)\n#ifdef TEST\n#define CHORD2(len, a, b) \\\n    noteA=(t>=x&&t<x+len*.8*60.0/BPM)?a:noteA; \\\n    noteB=(t>=x&&t<x+len*.8*60.0/BPM)?b:noteB; \\\n    x+=len*60.0/BPM;\n#define CHORD3(len, a, b, c) \\\n    noteA=(t>=x&&t<x+len*.8*60.0/BPM)?a:noteA; \\\n    noteB=(t>=x&&t<x+len*.8*60.0/BPM)?b:noteB; \\\n    noteC=(t>=x&&t<x+len*.8*60.0/BPM)?c:noteC; \\\n    x+=len*60.0/BPM;\n#define CHORD4(len, a, b, c, d) \\\n    noteA=(t>=x&&t<x+len*.8*60.0/BPM)?a:noteA; \\\n    noteB=(t>=x&&t<x+len*.8*60.0/BPM)?b:noteB; \\\n    noteC=(t>=x&&t<x+len*.8*60.0/BPM)?c:noteC; \\\n    noteD=(t>=x&&t<x+len*.8*60.0/BPM)?d:noteD; \\\n    x+=len*60.0/BPM;\n#else\n#define CHORD2(len, a, b)       N(len, a) x-=len*60.0/BPM; N(len, b)\n#define CHORD3(len, a, b, c)    N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c)\n#define CHORD4(len, a, b, c, d) N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c) x-=len*60.0/BPM; N(len, d)\n#endif\n\n// unused\n#define DYN(volume)\n#define CRESC(len, start, end)\n\nbool isNotePlayingCh1(float t, int note)\n{\n    float x = 0.;\n    int noteA = -1;\n    int noteB = -1;\n    int noteC = -1;\n    int noteD = -1;\n\n    CHANNEL1\n\n#ifdef TEST\n    return note == noteA || note == noteB || note == noteC || note == noteD;\n#else\n    return false;\n#endif\n}\n\nbool isNotePlayingCh2(float t, int note)\n{\n    float x = 0.;\n    int noteA = -1;\n    int noteB = -1;\n    int noteC = -1;\n    int noteD = -1;\n\n    CHANNEL2\n\n#ifdef TEST\n    return note == noteA || note == noteB || note == noteC || note == noteD;\n#else\n    return false;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int note = int(fragCoord.x);\n    float t = iTime + iTimeDelta;  // Frames tend to render a bit late, so compensate based on the frame rate.\n    t = timeTrack(t);\n    fragColor = vec4(0);\n    if (fragCoord.y <= 1.)\n        fragColor.r = (isNotePlayingCh1(t, note) || isNotePlayingCh2(t, note)) ? 1. : 0.;\n}", "buffer_a_inputs": [], "sound_code": "// Note frequencies\n\n#define FREQ_C(oct)  (16.35*exp2(float(oct)))\n#define FREQ_Cs(oct) (17.32*exp2(float(oct)))\n#define FREQ_D(oct)  (18.35*exp2(float(oct)))\n#define FREQ_Ds(oct) (19.45*exp2(float(oct)))\n#define FREQ_E(oct)  (20.60*exp2(float(oct)))\n#define FREQ_F(oct)  (21.83*exp2(float(oct)))\n#define FREQ_Fs(oct) (23.12*exp2(float(oct)))\n#define FREQ_G(oct)  (24.50*exp2(float(oct)))\n#define FREQ_Gs(oct) (25.96*exp2(float(oct)))\n#define FREQ_A(oct)  (27.50*exp2(float(oct)))\n#define FREQ_As(oct) (29.14*exp2(float(oct)))\n#define FREQ_B(oct)  (30.87*exp2(float(oct)))\n\n#define PI 3.14159265359\n\nfloat attenuate(float t)\n{\n    return exp2(-8.0*t);\n}\n\n// The built-in sin function has some precision issues at large x values, which results in\n// annoying high pitched buzzing sounds. Keeping x within 0 and 2pi fixes that.\nfloat better_sin(float x)\n{\n    return sin(mod(x, 2.0*PI));\n}\n\n// This doesn't sound exactly like a piano, but it's good enough for me!\nfloat piano(float time,float freq)\n{\n    float sampleX = 0.;\n    int maxHarm = 7;\n    if (freq > 800.0) maxHarm = 5;  // make high notes less bright\n    if (freq > 1600.0) maxHarm = 3;\n    for (int i = 1; i <= maxHarm; i++)\n        sampleX += better_sin(PI*2.0 * freq * float(i) * time) / float(i);\n    return sampleX;\n}\n\n// note\n#define N(len, note) note=(t>=x)?x:note;x+=len*60.0/BPM;\n// rest\n#define R(len) x+=len*(60.0/BPM);\n\n#define GRACE(a)        x-=0.05*(60.0/BPM);N(0.05,a)\n#define GRACE2(a, b)    x-=0.10*(60.0/BPM);N(0.05,a)N(0.05,b)\n#define GRACE3(a, b, c) x-=0.15*(60.0/BPM);N(0.05,a)N(0.05,b)N(0.05,c)\n#define CHORD2(len, a, b)       N(len, a) x-=len*60.0/BPM; N(len, b)\n#define CHORD3(len, a, b, c)    N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c)\n#define CHORD4(len, a, b, c, d) N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c) x-=len*60.0/BPM; N(len, d)\n\n#define AT(time) x=time*60.0/BPM;\n\n// Dynamics\n#define PP 0.1\n#define P  0.2\n#define MP 0.25\n#define MF 0.5\n#define F  0.65\n#define FF 1.0\n#define DYN(d) if(t>=x)volume=d;\n#define CRESC(len, a, b) if (t>=x)volume=mix(a, b, min(1.0,(t-x)/((len)*60.0/BPM)));\n\n#define PLAYNOTES(note, freq) if(note>-10.)a+=piano(t-note,freq)*volume*attenuate(t-note);\n\nfloat channel1(float t)\n{\n    float x = 0.0;\n    float a = 0.0;\n    // I tried using an array here, but it was too slow, and this managed to be faster somehow.\n    float A3=-10.,Ds3=-10.,\n          C4=-10.,Cs4=-10.,D4=-10.,Ds4=-10.,E4=-10.,F4=-10.,Fs4=-10.,G4=-10.,Gs4=-10.,A4=-10.,As4=-10.,B4=-10.,\n          C5=-10.,Cs5=-10.,D5=-10.,Ds5=-10.,E5=-10.,F5=-10.,Fs5=-10.,G5=-10.,Gs5=-10.,A5=-10.,As5=-10.,B5=-10.,\n          C6=-10.,Cs6=-10.,D6=-10.,Ds6=-10.,E6=-10.,F6=-10.,Fs6=-10.,G6=-10.,Gs6=-10.,A6=-10.,As6=-10.,B6=-10.,\n          C7=-10.,D7=-10.,E7=-10.;\n    float volume = 0.0;\n\n    CHANNEL1\n\n    PLAYNOTES(A3,  FREQ_A(3))\n    PLAYNOTES(Ds3, FREQ_Ds(3))\n    PLAYNOTES(C4,  FREQ_C(4))\n    PLAYNOTES(Cs4, FREQ_Cs(4))\n    PLAYNOTES(D4,  FREQ_D(4))\n    PLAYNOTES(Ds4, FREQ_Ds(4))\n    PLAYNOTES(E4,  FREQ_E(4))\n    PLAYNOTES(F4,  FREQ_F(4))\n    PLAYNOTES(Fs4, FREQ_Fs(4))\n    PLAYNOTES(G4,  FREQ_G(4))\n    PLAYNOTES(Gs4, FREQ_Gs(4))\n    PLAYNOTES(A4,  FREQ_A(4))\n    PLAYNOTES(As4, FREQ_As(4))\n    PLAYNOTES(B4,  FREQ_B(4))\n    PLAYNOTES(C5,  FREQ_C(5))\n    PLAYNOTES(Cs5, FREQ_Cs(5))\n    PLAYNOTES(D5,  FREQ_D(5))\n    PLAYNOTES(Ds5, FREQ_Ds(5))\n    PLAYNOTES(E5,  FREQ_E(5))\n    PLAYNOTES(F5,  FREQ_F(5))\n    PLAYNOTES(Fs5, FREQ_Fs(5))\n    PLAYNOTES(G5,  FREQ_G(5))\n    PLAYNOTES(Gs5, FREQ_Gs(5))\n    PLAYNOTES(A5,  FREQ_A(5))\n    PLAYNOTES(As5, FREQ_As(5))\n    PLAYNOTES(B5,  FREQ_B(5))\n    PLAYNOTES(C6,  FREQ_C(6))\n    PLAYNOTES(Cs6, FREQ_Cs(6))\n    PLAYNOTES(D6,  FREQ_D(6))\n    PLAYNOTES(Ds6, FREQ_Ds(6))\n    PLAYNOTES(E6,  FREQ_E(6))\n    PLAYNOTES(F6,  FREQ_F(6))\n    PLAYNOTES(Fs6, FREQ_Fs(6))\n    PLAYNOTES(G6,  FREQ_G(6))\n    PLAYNOTES(Gs6, FREQ_Gs(6))\n    PLAYNOTES(A6,  FREQ_A(6))\n    PLAYNOTES(As6, FREQ_As(6))\n    PLAYNOTES(B6,  FREQ_B(6))\n    PLAYNOTES(C7,  FREQ_C(7))\n    PLAYNOTES(D7,  FREQ_D(7))\n    PLAYNOTES(E7,  FREQ_E(7))\n\n    return a;\n}\n\nfloat channel2(float t)\n{\n    float x = 0.0;\n    float a = 0.0;\n    float volume = 0.0;\n\n    // I tried using an array here, but it was too slow, and this managed to be faster somehow.\n    float Gs1=-10.,A1=-10.,As1=-10.,\n          C2=-10.,Cs2=-10.,D2=-10.,Ds2=-10.,E2=-10.,F2=-10.,Fs2=-10.,G2=-10.,Gs2=-10.,A2=-10.,As2=-10.,B2=-10.,\n          C3=-10.,Cs3=-10.,D3=-10.,Ds3=-10.,E3=-10.,F3=-10.,Fs3=-10.,G3=-10.,Gs3=-10.,A3=-10.,As3=-10.,B3=-10.,\n          C4=-10.,Cs4=-10.,D4=-10.,Ds4=-10.,E4=-10.,F4=-10.,Fs4=-10.,G4=-10.,Gs4=-10.,B4=-10.,\n          C5=-10.,Cs5=-10.,Ds5=-10.,E5=-10.;\n\n    CHANNEL2\n\n    PLAYNOTES(Gs1, FREQ_Gs(1))\n    PLAYNOTES(A1,  FREQ_A(1))\n    PLAYNOTES(As1, FREQ_As(1))\n    PLAYNOTES(C2,  FREQ_C(2))\n    PLAYNOTES(Cs2, FREQ_Cs(2))\n    PLAYNOTES(D2,  FREQ_D(2))\n    PLAYNOTES(Ds2, FREQ_Ds(2))\n    PLAYNOTES(E2,  FREQ_E(2))\n    PLAYNOTES(F2,  FREQ_F(2))\n    PLAYNOTES(Fs2, FREQ_Fs(2))\n    PLAYNOTES(G2,  FREQ_G(2))\n    PLAYNOTES(Gs2, FREQ_Gs(2))\n    PLAYNOTES(A2,  FREQ_A(2))\n    PLAYNOTES(As2, FREQ_As(2))\n    PLAYNOTES(B2,  FREQ_B(2))\n    PLAYNOTES(C3,  FREQ_C(3))\n    PLAYNOTES(Cs3, FREQ_Cs(3))\n    PLAYNOTES(D3,  FREQ_D(3))\n    PLAYNOTES(Ds3, FREQ_Ds(3))\n    PLAYNOTES(E3,  FREQ_E(3))\n    PLAYNOTES(F3,  FREQ_F(3))\n    PLAYNOTES(Fs3, FREQ_Fs(3))\n    PLAYNOTES(G3,  FREQ_G(3))\n    PLAYNOTES(Gs3, FREQ_Gs(3))\n    PLAYNOTES(A3,  FREQ_A(3))\n    PLAYNOTES(As3, FREQ_As(3))\n    PLAYNOTES(B3,  FREQ_B(3))\n    PLAYNOTES(C4,  FREQ_C(4))\n    PLAYNOTES(Cs4, FREQ_Cs(4))\n    PLAYNOTES(D4,  FREQ_D(4))\n    PLAYNOTES(Ds4, FREQ_Ds(4))\n    PLAYNOTES(E4,  FREQ_E(4))\n    PLAYNOTES(F4,  FREQ_F(4))\n    PLAYNOTES(Fs4, FREQ_Fs(4))\n    PLAYNOTES(G4,  FREQ_G(4))\n    PLAYNOTES(Gs4, FREQ_Gs(4))\n    PLAYNOTES(B4,  FREQ_B(4))\n    PLAYNOTES(C5,  FREQ_C(5))\n    PLAYNOTES(Cs5, FREQ_Cs(5))\n    PLAYNOTES(Ds5, FREQ_Ds(5))\n    PLAYNOTES(E5,  FREQ_E(5))\n\n    return a;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    time = timeTrack(time);\n\n    vec2 sound = vec2(0);\n\n    float right = channel1(time) * 0.25;\n    float left = channel2(time) * 0.25;\n\n    // mix the channels\n    sound += left * vec2(0.7, 0.3);\n    sound += right * vec2(0.3, 0.7);\n    \n    return sound;\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 79, 99, 162], [164, 212, 245, 245, 472], [474, 503, 540, 540, 654], [656, 685, 724, 724, 838], [840, 869, 907, 907, 1021], [1067, 1067, 1123, 1123, 1414], [1416, 1447, 1484, 1484, 1509], [1511, 1552, 1595, 1595, 1693], [1695, 1753, 1803, 1803, 1859], [1861, 1861, 1892, 1892, 2057], [2059, 2059, 2090, 2090, 2259], [2261, 2261, 2299, 2299, 2669], [2671, 2671, 2709, 2709, 2887], [2889, 2889, 2917, 2917, 3217], [3219, 3219, 3247, 3247, 3332], [3334, 3334, 3375, 3375, 4469], [4471, 4471, 4505, 4505, 4723], [4725, 4777, 4796, 4796, 4852], [4854, 4854, 4909, 4909, 5886]], "test": "untested"}
{"id": "mddyR4", "name": "harmonicVoronoi Cineshader", "author": "natet", "description": "harmonicVoronoi adapted for cineshader. Version on cineshader has lambert-phong shading on the 2.5D surface displaced by the voronoi.", "tags": ["voronoi", "harmonic", "cineshader"], "likes": 0, "viewed": 1369, "published": 3, "date": "1694793759", "time_retrieved": "2024-07-30T17:33:42.105897", "image_code": "vec2 points[4] = vec2[4](vec2(.5,.05), vec2(.5,.33), vec2(.5,.66), vec2(.5,.95));\n\n\nfloat scalarSin(float time){\n    return (sin(time)+1.0)*0.5;\n}\n\n//https://gist.github.com/sketchpunk/778c8aa561ca62142beecf849ad2cd57\nvec3 vecQuatRotation(vec4 q, vec3 v){ \n  return v + cross(2.0 * q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uv = vec3(vec2(fragCoord/iResolution.y),0.0);\n\n    float minDist = 1.0;\n    for(int i = 0; i < points.length(); i++){\n        points[i].x = scalarSin(iTime * (1.0/float(i+1)));\n        float dist = distance(points[i],uv.xy);\n        minDist = min(dist,minDist);\n    }\n\n    minDist = pow(1.0-minDist,3.0);\n    \n    #ifdef IS_CINESHADER\n    uv.z = minDist;\n\n    //Calculate Normal from height\n    float scale = 1.0;\n    float Nx = (minDist * (uv.x + 1.0, uv.y) - minDist * (uv.x - 1.0, uv.y)) / (2.0 * scale);\n    float Ny = (minDist * (uv.x, uv.y + 1.0) - minDist * (uv.x, uv.y - 1.0)) / (2.0 * scale);\n    float Nz = 1.0 / sqrt(1.0 + pow(Nx,2.0) + pow(Ny,2.0));\n\n    vec3 normal = vec3(Nx, Ny, Nz);\n\n    vec3 lightPos = vec3(cos(iTime),0.0,1.0);\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    // Calculate time\n    float t = d * d * 25.0 - iTime * 3.0;\n    // Time varying surface color\n    vec3 surfaceColour = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n    vec3 lightColour = vec3(1.0);\n    vec3 specularStrength = vec3(1.0);\n    float shininess = 512.0;\n\n    vec3 lambertian = max(dot(lightPos, normal), 0.0)*surfaceColour*lightColour;\n\n    // Calculate the view vector\n    vec3 viewVector = vecQuatRotation(iCamQuat,iCamPos);\n\n    vec3 viewDir = normalize(viewVector - uv);\n    vec3 lightDir = normalize(lightPos - uv);\n    vec3 halfDir = normalize(viewDir + lightDir);\n\n    float specular = pow(max(dot(normal, halfDir), 0.0), shininess);\n    vec3 specularColour = specularStrength * specular * lightColour;\n\n    // Output to screen\n    fragColor = vec4(lambertian+specularColour,minDist);\n    #else\n    fragColor = vec4(minDist,minDist,minDist,1.0);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 112, 112, 146], [148, 218, 255, 255, 318], [320, 320, 377, 427, 2158]], "test": "untested"}
{"id": "DdtyRN", "name": "Graph Paper Fluid", "author": "wyatt", "description": "Oh no! I spilled on my notebook!", "tags": ["fluid"], "likes": 40, "viewed": 464, "published": 3, "date": "1694787842", "time_retrieved": "2024-07-30T17:33:43.050372", "image_code": "Main {\n    if ((int(U.x+U.y)+iFrame)%2==0) discard;\n    \n    Q = vec4(0);\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        \n        vec2 V = B(U+vec2(x,y)/2.).xy;\n        {\n            vec2 s = abs(sin(V*.004));\n            float z = min(s.x,s.y);\n\n            Q += vec4(.25)/25.*(smoothstep(1.*fwidth(z),0.,z));\n        }\n        {\n            vec2 s = abs(sin(V*.016));\n            float z = min(s.x,s.y);\n\n            Q += vec4(.25)/25.*(smoothstep(1.*fwidth(z),0.,z));\n        }\n        {\n            vec2 s = abs(sin(V*.064));\n            float z = min(s.x,s.y);\n\n            Q += vec4(.25)/25.*(smoothstep(1.*fwidth(z),0.,z));\n        }\n        \n        {\n            vec2 s = abs(sin(V*.256));\n            float z = min(s.x,s.y);\n\n            Q += vec4(.25)/25.*(smoothstep(1.*fwidth(z),0.,z));\n        }\n        \n        {\n            float z = abs(V.y/R.y-.3);\n\n            Q += vec4(1,1,0,1)/25.*(smoothstep(1.*fwidth(z),0.,z));\n        }\n        \n        {\n            float z = abs(V.x/R.x-.3);\n\n            Q += vec4(0,1,1,1)/25.*(smoothstep(1.*fwidth(z),0.,z));\n        }\n    }\n    Q = 1.-Q;\n    \n    //Q *= 1.-.005*length(vec2(fwidth(B(U).x),fwidth(B(U).x)));\n    vec4 a = A(U);\n    Q *= .9+.1*vec4(a.x-a.y,a.x,a.y,1);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 T (vec2 U) {\n    if (iFrame % 4 == 0) {\n        U -= .5*v(A(U).xy);\n        U -= .5*v(A(U).xy);\n        U -= .5*v(A(U).xy);\n        U -= .5*v(A(U).xy);\n    }\n    return A(U);\n}\nMain {\n    \n    Q = T(U);\n    vec4 n = T(U+vec2(0,1));\n    vec4 e = T(U+vec2(1,0));\n    vec4 s = T(U-vec2(0,1));\n    vec4 w = T(U-vec2(1,0));\n    \n    Q.xy -= .5*vec2(e.z-w.z,n.z-s.z);\n    \n    \n    if (iMouse.z>0.&&length(U-iMouse.xy) < 10.) Q.y = .6;\n\n    if (iFrame < 1) {\n        vec2 v = normalize(U-.5*R);\n        Q.xy = vec2(v.y,-v.x)*.1+v*sin(6.*atan(U.y-.5*R.y,U.x-.5*R.x));\n        \n        Q.xy *= 2.*exp(-10.*length(U-.5*R)/R.y);\n    }\n\n    if (U.x < 2.||R.x-U.x<2.||U.y < 2.||R.y-U.y<2.) Q.xy *= 0., Q.z *= .9;\n\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 T (vec2 U) {\n    return A(U);\n}\nMain {\n    \n    Q = T(U);\n    vec4 n = T(U+vec2(0,1));\n    vec4 e = T(U+vec2(1,0));\n    vec4 s = T(U-vec2(0,1));\n    vec4 w = T(U-vec2(1,0));\n    \n    Q.z -= .5*(e.x-w.x+n.y-s.y);\n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, vec2 U)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n\nvec2 v (vec2 u) {\n    return u*inversesqrt(.1+dot(u,u));\n}", "buffer_c_code": "Main {\n    if (iFrame % 4 == 0) {\n        U -= .5*v(A(U).xy);\n        U -= .5*v(A(U).xy);\n        U -= .5*v(A(U).xy);\n        U -= .5*v(A(U).xy);\n    }\n    \n        Q = B(U);\n        \n        if (iFrame < 1) Q = vec4(U,0,0);\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ddtczH", "name": "Arabesque knots 10 (music)", "author": "jarble", "description": "An arabesque knot pattern with interlaced knots.\nClick and drag to move around.", "tags": ["fractal", "music", "knot", "interlace", "arabesque"], "likes": 3, "viewed": 198, "published": 3, "date": "1694753173", "time_retrieved": "2024-07-30T17:33:43.922041", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nbool braid_pattern(vec2 uv,vec2 t2,bool b,bool b1){\n    return\n        //(uv.y>uv.x || t2.y>t2.x)\n        (uv.y>uv.x||!b)\n        //b||!b1\n        //(uv.y>uv.x||b)\n        //true\n        //(!(uv.y<uv.x) || t2.y>t2.x*float(b1))\n        //((uv.y<uv.x) || t2.y<t2.x)\n        //((uv.y*float(!b1)>uv.x) || t2.y>t2.x)\n        //((uv.y*float(b1)>uv.x*float(b)) || t2.y*float(b1)>t2.x*float(b))\n        //((uv.y>uv.x*float(b1)) || t2.y>t2.x*float(b1))\n        //b1 && ((uv.y>uv.x) || t2.y>t2.x) || !b1 && ((uv.y<uv.x) || t2.y<t2.x)   \n        //t2.y<t2.x\n        //(!b1 || t2.y>t2.x*float(!b1))\n   ;\n}\n\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = uv.y>uv.x;\n    bool b1 = t2.y>t2.x;\n    for(int k = 0; k < 6; k++){\n        //if(braid_pattern(uv,t2,b,b1)||!b1)\n        uv =\n            abs(.5+uv+t2)\n            //abs(.5+uv+t2)*sign(uv-uv.yx)\n            //abs(.5+uv*sign(uv.y+.5)-t2)\n            //abs(-.5+uv*sign(uv.x-.5)-t2)\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n\n        //Braiding patterns\n        b1 =\n            braid_pattern(uv,t2,b,b1)||!b1\n        ;\n        \n        //uv.x += t1_(floor(uv),floor(uv));\n        \n        //if(t2.x>t2.y)\n        b =\n            uv.y>uv.x*float(b1)\n        ;\n        if(b||t2.x>t2.y) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        if(\n            b1\n            //b1||t2.x>t2.y\n            //b1||t2.x<t2.y\n        )\n        col =\n            vec3(col.zx,max(uv.x-uv.y,col.y))\n            //abs(vec3(col.zx,max(uv.x-uv.y,-float(b)/2.)))\n            //vec3(col.xy,max(uv.x-uv.y,col.z)).yzx\n        ;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod(float a, float b){\n    /*\n    for(float i = 0.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/8.),8.)*i;\n    }\n    */\n    \n    //divide by powers of 2 to get an interesting rhythm\n    a -= mod(floor(a/128.),128.);\n    a -= mod(floor(a/64.),64.);\n    a -= mod(floor(a/32.),32.);\n    a -= mod(floor(a/16.),16.);\n    a -= mod(floor(a/8.),8.);\n    a -= mod(floor(a/4.),4.);\n    a -= mod(floor(a/2.),2.);\n\n    //a += mod(floor((a)/2.)*13.,2.);\n    //a += mod(floor((a)/2.)*17.,2.);\n    return mod(floor(-a),b);\n}\n\n//#define fmod(a,b) mod(floor(a)+floor((a)/2.)*2.+floor((a)/4.)*3.+floor((a)/8.)*5.+floor((a)/16.)*7.,b)\n\n\n\n\n\n//some other rhythms:\n\n//#define fmod(a,b) min(mod(floor(a)+floor((a)/2.)*2.+floor((a)/4.)*3.+floor((a)/8.)*5.+floor((a)/16.)*7.,b),mod(floor(a),b))\n//#define fmod(a,b) mod(floor(a),b)\n//#define fmod(a,b) mod(floor(a)+floor((a)/2.)+floor((a)/4.)+floor((a)/8.),b)\n//#define fmod(a,b) mod(floor(a)+floor((a)/2.)+floor(a*pow(2.,mod(floor(a),3.))),b)\n\nvec2 mainSound(int samp, float time){\n  \n  //time /= 64.*2.;\n  float s1 =\n      8.;\n  time = (time + floor(time*s1)/s1)/2.;\n  float\n  t= //varying tempo\n      (((time)/s1+max(fract(-time/2.),fract(time))/8.))/4./(1.+fmod(time*4.-floor(time/s1),2.)),\n  t1 = fmod(t,2.)\n  ;\n  t *=\n      (s1*s1)\n  ;\n  float a= //instruments\n      16.*pow(fract(-t),2.)\n  ,\n  nb = time*pow(2.,(1.+t1)*(2.+fmod(t/(1.+t1),s1)+1. + fmod(floor(t/s1),2.))/7.+5.);\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2*s1)*a)\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 195, 195, 737], [855, 855, 881, 881, 970], [973, 973, 1030, 1030, 2388]], "test": "untested"}
{"id": "mdtyz8", "name": "Arabesque knots 9 (music)", "author": "jarble", "description": "A zellij tile pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "arabesque", "sitar"], "likes": 5, "viewed": 197, "published": 3, "date": "1694740557", "time_retrieved": "2024-07-30T17:33:44.760798", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .5;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = uv.x>uv.y;\n    bool b1 = uv.x>uv.y;\n    vec2 uv1 = uv;\n    for(int k = 0; k < 6; k++){\n        b1 = uv.x*float(b1)>uv.y;\n        uv =\n            //abs(.5+uv/1.5+t2)\n            abs(.5+uv/1.5+t2)\n            //abs(.5+uv/1.5+t2+mod(floor(uv1.x),2.))\n            //abs(.5+uv+t2/1.5)\n            //abs(.5+uv+t2)/1.5\n        ;\n        b =\n            uv.y*float(b1)>uv.x\n            //uv.y>uv.x*float(b1)\n            //uv.y*float(b1)>uv.x\n        ;\n        if(b) uv = uv.yx;\n\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5+float(k/3))\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx+float(k/3))\n        ;\n        col =\n            //vec3(abs(.5-col.zx),max(uv.x-uv.y,0.))\n            //abs(vec3(col.zx,max(uv.y-uv.x,col.y)))\n            vec3(abs(col.zx/2.),2.*max(uv.x-uv.y,0.))\n        ;\n        uv1 += uv/1.5;\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod(float a, float b){\n    a = floor(a/(1. + mod(floor(a/4.),2.)) + mod(-b/2.,2.));\n    return\n        mod(mod(a,b)*mod(floor(a/b),b),b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    return (1.+fmod(time/5.,2.))/(1.+fmod(time/3.,2.));\n}\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.,\n  tempo1 =\n      //1.\n      //divide by prime numbers to get an interesting rhythm\n      prime_rhythm(time)\n  ,\n  t = s1*time/8./tempo1,\n  t4 = t/2./prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod(t4,2.),\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6,s1/2.)/2.),\n  m2 =\n      1. + fmod(t/t3/2.,s1/2.),\n  a=\n      (1.-log(fract(t/2./prime_rhythm(time+14.))/2.))*(1.-log(fract(t/prime_rhythm(time+7.))/4.)),\n  nb =\n      t*pow(2.,(m3+m2-t1*4.)/7.+7.5)*tempo1\n  ;\n  return\n      log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 193], [195, 195, 252, 252, 1501]], "test": "untested"}
{"id": "mstyR8", "name": "coiled grove", "author": "elenzil", "description": "why not.\nfollow-up: https://www.shadertoy.com/view/csccz7", "tags": ["twist", "rope", "braid", "understepping"], "likes": 22, "viewed": 252, "published": 3, "date": "1694738727", "time_retrieved": "2024-07-30T17:33:45.603545", "image_code": "const uint  march_MaxSteps  = 250u;\nconst float march_epsilon   = 0.01;\n      float march_understep = 0.2;\nconst float normal_epsilon  = 0.05;\n\nconst bool  do_Shadows      = true;\nconst bool  do_Reflections  = true;\n\n\nfloat gMapCount = 0.0;\n\nfloat sdScene(in vec3 p) {\n\n    gMapCount += 1.0;\n\n    float d = 1e9;\n    \n    vec3 q = p;\n        \n    q.xz = abs(q.xz);\n    q.xz -= 9.0;\n    \n    q.xz *= rot2(q.y * q.y * 0.006 - iTime * 0.1);\n    q.xz *= 2.0 * (0.5 +  smoothstep(10.0, 50.0, q.y));\n    \n    q.xz = abs(q.xz);\n    q.xz -= 4.0;\n\n    float fade = smoothstep(1.0, 15.0, q.y);\n    q.xz *= rot2(q.y * 0.5  - iTime);\n    q.x = abs(q.x);\n    q.x -= 2.0 * fade;\n    \n    d = min(d, sdDisk(q.xz, 1.0));\n    \n    d += fade * 0.015 * (sin(q.x * 10.0) + sin(q.z * 10.0));\n\n    d = smin(d, p.y, 4.5);\n\n    return d;\n}\n\nvec3 gradScene(in vec3 p) {\n    if (p.y < march_epsilon) {\n        // cheat for floor\n        return vY;\n    }\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * normal_epsilon) - d,\n        sdScene(p + vY * normal_epsilon) - d,\n        sdScene(p + vZ * normal_epsilon) - d\n    );\n}\n\nvec3 normalScene(in vec3 p) {\n    return normalize(gradScene(p));\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd, out bool outOfSteps) {\n\n    // analytic ground plane in addition to the raymarched one.\n    float pt = rayVsPlane(ro, rd, vY, 0.0);\n    \n    outOfSteps = false;\n\n    float t = 0.0;\n\n    for (uint n = 0u; n < march_MaxSteps; ++n) {\n        vec3  p = ro + t * rd;\n        float d = sdScene(p);\n        if (d < march_epsilon) {\n            return min(pt, t);\n        }\n        if (dot(p.xz, p.xz) > 40000.0) {\n            return pt;\n        }\n        \n        t += d * march_understep;\n    }\n   \n    // next time we call this, use less precision.\n    march_understep = mix(march_understep, 1.0, 0.5);\n    \n    outOfSteps = true;\n    return pt;\n}\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.5, 1.9));\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(rd, lightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float a = atan(rd.z, rd.x);\n    \n    c = mix(c, v1, smoothstep(0.06 + (1.0 - d) * 0.01 * cos(a * 13.0), 0.0, abs(rd.y)));\n    return c;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    bool outOfSteps;\n    float t = rayVsScene(ro, rd, outOfSteps);\n    if (t > 1e8) {\n        return sky(ro, rd);\n    }\n    \n    vec3 p;\n    vec3 n;\n    \n    p = ro + t * rd;\n    n = normalScene(p);\n    \n    vec3 c = v1 * (saturate(dot(n, lightDir)));\n\n    // shadow and one reflection bounce\n    ro = p + n * march_epsilon * 2.0;\n    \n    if (do_Shadows) {\n        // shadow\n        t = rayVsScene(ro, lightDir, outOfSteps);\n        p = ro + t * lightDir;\n\n        if (t < 1e9 || outOfSteps) {\n            c *= 0.4;\n        }\n    }\n\n    if (do_Reflections) {\n        // reflect\n        float fres = mix(0.01, 0.8, smoothstep(0.9, 0.1, abs(dot(rd, n))));\n\n        vec3 c2;\n        rd = reflect(rd, n);\n        t = rayVsScene(ro, rd, outOfSteps);\n        if (t > 1e8) {\n            c2 = sky(ro, rd);\n        }\n        else {\n            p = ro + t * rd;\n            n = normalScene(p);\n            c2 = v1 * (saturate(dot(n, lightDir)));\n        }\n\n        c = mix(c, c2, fres);\n    }\n    \n    return c;\n}\n\nvec3 getRayDir(in vec2 xy, in vec3 ro, in vec3 lookTo, in float fov) {\n    vec3 camFw = normalize(lookTo - ro);\n    vec3 camRt = normalize(cross(camFw, vY));\n    vec3 camUp = cross(camRt, camFw);\n    \n    vec3 rd;\n    rd = camFw + fov * (camRt * xy.x + camUp * xy.y);\n    rd = normalize(rd);\n    \n    return rd;\n}\n\nbool gHeatMap = false;\nvoid readKeyboard() {\n    gHeatMap = bool(texelFetch(iChannel0, ivec2(49, 2), 0).x);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    const float zoom = 0.8;\n    \n    vec2 xy = (XY * 2.0 - RES) / MINRES / zoom;\n    \n    const float heatMapSize = 0.4;\n    bool isHeatMap = gHeatMap && XY.x < RES.x * heatMapSize && XY.y < RES.y * heatMapSize;\n    if (isHeatMap) {\n        xy = (XY * 2.0 - RES * heatMapSize) / MINRES / heatMapSize / zoom;\n    }\n    \n    vec2 M = iMouse.xy;\n    if (length(M) < 100.0) {\n        M = RES/2.0;\n        M.x += iTime * 7.0;\n    }\n    \n    vec3 ro = vec3(0.0, 8.0, -30.0);\n    ro.xz *= rot2(3.141 + (M.x / RES.x - 0.5) * -7.0);\n    vec3 lt = vY * (0.0 - 20.0 * (M.y / RES.y - 1.0));\n    vec3 rd = getRayDir(xy, ro, lt, 0.5);\n    \n    RGBA.rgb = render(ro, rd);\n    \n    if (isHeatMap) {\n        float h = saturate(gMapCount / 500.0);\n        vec3 cool = vec3(0.0, 0.0, 0.7);\n        vec3 warm = vec3(1.0, 0.9, 0.0);\n        RGBA.rgb = mix(cool, warm, h);\n    }\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(1.0/2.2));\n    \n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 vX = vec3(1.0, 0.0, 0.0);\nconst vec3 vY = vX.yxy;\nconst vec3 vZ = vX.yyx;\nconst vec3 v0 = vX.yyy;\nconst vec3 v1 = vX.xxx;\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2  saturate(vec2  v) { return clamp(v, 0.0, 1.0); }\nvec3  saturate(vec3  v) { return clamp(v, 0.0, 1.0); }\n\nfloat sqr(float a) {\n    return a * a;\n}\n\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n//--------------------------------------------------------------------------------\n\n// iq\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    if (t < 0.0) {\n        t = 1e9;\n    }\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 268, 268, 814], [816, 816, 843, 843, 1115], [1117, 1117, 1146, 1146, 1184], [1186, 1186, 1249, 1314, 1869], [1926, 1926, 1960, 1960, 2295], [2297, 2297, 2334, 2334, 3339], [3341, 3341, 3411, 3411, 3654], [3679, 3679, 3700, 3700, 3765], [3767, 3767, 3810, 3810, 4782]], "test": "untested"}
{"id": "csdcz8", "name": "Blue Monday", "author": "insurgentes300", "description": "circles movement", "tags": ["circles", "palette", "basics"], "likes": 1, "viewed": 161, "published": 3, "date": "1694729876", "time_retrieved": "2024-07-30T17:33:46.554004", "image_code": "vec3 palette  ( float t ){\n\n    vec3 a = vec3 (0.5, 0.5, 0.5);\n    \n    vec3 b = vec3 (0.5, 0.5, 0.5);\n    \n    vec3 c = vec3 (1.0, 1.0, 1.0);\n    \n    vec3 d = vec3 (0.263, 0.416, 0.557);\n    \n\n    return a + b * cos ( 6.28318*(c*t*d));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n\n    float d = length(uv);\n    \n    //vec3 col  = vec3(1.0, 0.0, 0.0);\n    \n    vec3 col = palette(d + iTime);\n    \n    d = sin(d*8. + iTime * 5. )/8.;\n    \n    d = abs(d);\n    \n    d = 0.02 / d;\n    \n    col *= d;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdcz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 239], [244, 244, 301, 301, 617]], "test": "untested"}
{"id": "ms3yzH", "name": "React logo", "author": "jsulpis", "description": "Animated logo of React.js\n\nCredits to munrocket who did the original version (https://www.shadertoy.com/view/td3czf)", "tags": ["bezier", "logo", "curves", "glow", "react"], "likes": 8, "viewed": 267, "published": 3, "date": "1694722147", "time_retrieved": "2024-07-30T17:33:47.376804", "image_code": "//====================================================================================\n//\n// React logo \n// by Julien Sulpis (https://twitter.com/jsulpis)\n// https://www.shadertoy.com/view/ms3yzH\n//\n// forked from Magic Loader by Krischan (https://www.shadertoy.com/view/fsGGWG)\n//\n//====================================================================================\n\n#define SCALE 0.5\n#define SPEED 0.5\n#define INTENSITY 15.0\n#define LENGTH 1.8\n#define RADIUS 0.020\n#define FADING 0.05\n#define GLOW 6.\n#define COLOR vec3(0.0, 0.84, 0.97)\n\n#define PI 3.1415926535 \n\n// optimized 2d version of https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 circle(float t){\n    float x = SCALE * sin(t);\n    float y = SCALE * cos(t);\n    return vec2(x, y);\n}\n\nfloat mapcircle(vec2 pos, float delay){\n    float t = fract(-SPEED * iTime + delay);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = circle(t * 2.*PI);\n    vec2 p2 = circle((dl + t) * 2.*PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = circle((i * dl + t) * 2.*PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nmat2 rotate2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 deformation = vec2(.5, 1.3);\n    \n    float dist1 = mapcircle(rotate2D(-PI/3.) * uv * deformation, .0);\n    float dist2 = mapcircle(rotate2D(PI/3.) * uv * deformation, 1.);\n    float dist3 = mapcircle(uv * deformation, .5);\n    \n    float col1 = pow(RADIUS/dist1, GLOW);\n    float col2 = pow(RADIUS/dist2, GLOW);\n    float col3 = pow(RADIUS/dist3, GLOW);\n\t\n    float center = smoothstep(.18, .05, length(uv));\n    \n\tvec3 col = (col1 + col2 + col3 + center) * COLOR * (2. * GLOW);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3yzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 633, 682, 682, 1257], [1259, 1259, 1280, 1280, 1365], [1367, 1367, 1406, 1406, 1897], [1899, 1899, 1927, 1927, 2011], [2014, 2014, 2070, 2070, 2667]], "test": "untested"}
{"id": "ddcczH", "name": "Noise in circle(GDSMBCZY)", "author": "GDSMBCZY", "description": "IDK", "tags": ["public"], "likes": 1, "viewed": 188, "published": 3, "date": "1694720167", "time_retrieved": "2024-07-30T17:33:48.292356", "image_code": "float rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat Circle(vec2 uv, float r, float blur){\n    float d = length(uv);\n    d = smoothstep(r, r-blur, d);\n   \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // EDIT STUFF HERE\n    //how large the circle is\n    const float Size = .88;\n    //how close the circle is to white, does nothing past 1.0\n    const float Brightness = .8;\n    //takes values from 0.0 to 1.0, is in RGB\n    const vec3 Color = vec3(0.1, 0.4, 0.3);\n   \n   \n    // THE CODE\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uv0 = uv;\n    vec3 col = Color;\n    float d = 0.;\n\n    d = Circle(uv, Size, Size);\n   \n    float t = iTime;\n\n    d -= rand(vec2(d+t*uv.y, d+t*uv.x));\n\n    d = smoothstep(d+1., 1.4, d);\n   \n    col += vec3(d*Brightness);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 89], [91, 91, 134, 134, 214], [216, 216, 273, 326, 924]], "test": "untested"}
{"id": "Dt2fWd", "name": "GPU Plays the Piano - 1", "author": "pikachuchujelly", "description": "Welcome to tonight's piano recital!\n\nTonight, you will hear \"Rondo alla turca\", movement 3 from Piano Sonata No. 11, K. 331 by Wolfgang Amadeus Mozart, performed by the world's greatest pianist: your graphics card!", "tags": ["raymarching", "sound", "music", "audio", "classical"], "likes": 16, "viewed": 279, "published": 3, "date": "1694712622", "time_retrieved": "2024-07-30T17:33:49.260767", "image_code": "#define HUGE 1000000.0\n#define PI 3.14159265359\n\nbool isNotePlaying(int note)\n{\n    //return false;\n    return texelFetch(iChannel1, ivec2(note, 0), 0).r != 0.;\n}\n\n// computes the ray direction of a screen pixel\nvec3 perspectiveRay(vec2 pixel)\n{\n      float x = -1.0 + 2.0*(pixel.x / iResolution.x);\n      float z = -1.0 + 2.0*(pixel.y / iResolution.y);\n      z *= iResolution.y / iResolution.x;  // aspect ratio\n      float y = 1.0;\n      return normalize(vec3(x,y,z));\n}\n\n// rotation about the z axis\nvec3 rotateYaw(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(v.x * c - v.y * s, v.y * c + v.x * s, v.z);\n}\n\n// rotation about the x axis\nvec3 rotatePitch(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(v.x, v.y * c - v.z * s, v.z * c + v.y * s);\n}\n\n// rotation about the y axis\nvec3 rotateRoll(vec3 v, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(v.x * c - v.y * s, v.y, v.z * c + v.x * s);\n}\n\nvec3 lightDir = normalize(vec3(1,1,-1.5));\n\nfloat calcLight(vec3 normal, vec3 rd, float shininess)\n{\n    float ambient  = 0.5;\n    float diffuse  = max(dot(-lightDir,normal), 0.0);\n    float specular = max(dot(-lightDir,reflect(rd, normal)), 0.0);\n    specular *= specular*specular*specular*specular*specular*specular*specular*specular;\n    return ambient + diffuse + specular * shininess;\n}\n\n// subtracts distance b from a\nfloat sdfSubtract(float a, float b)\n{\n    return max(a, -b);\n}\n\n// based on Inigo Quilez's SDF functions\nfloat sdfBox(vec3 p, vec3 center, vec3 b)\n{\n    vec3 q = abs(p-center) - b;\n    return length(max(q,0.0)) + min(max(max(q.x,q.y),q.z),0.0);\n}\n\n// like sdfBox, but specifying minimum and maximum bounds\nfloat sdfBoxBounds(vec3 p, vec3 bmin, vec3 bmax)\n{\n    return sdfBox(p, .5*(bmin+bmax), .5*(bmax-bmin));\n}\n\nint whiteKeyToNote(float key)\n{\n    int octave = int(floor(key / 7.));\n    key = mod(key, 7.);\n    int note = int(key) * 2;\n    if (key >= 3.)\n        note--;\n    return octave * 12 + note + 39;\n}\n\nint blackKeyToNote(float key)\n{\n    int octave = int(floor(key / 7.));\n    key = mod(key, 7.);\n    int note = int(key) * 2 + 1;\n    if (key >= 2.)\n        note--;\n    return octave * 12 + note + 39;\n}\n\nfloat sdfBlackKey(vec3 p, float key)\n{\n    key = clamp(key, -23., 26.);\n    // if this is the spot between B-C or E-F with no black key, choose the closest black key instead\n    if (mod(key,7.) == 2. || mod(key,7.) == 6.)\n        key += fract(p.x) >= .5 ? 1. : -1.;\n    int note = blackKeyToNote(key);\n    float z = isNotePlaying(note) ? .1 : .5;\n    return sdfBox(p, vec3(key+.5,1.,z), vec3(.25, 1., .5));\n}\n\nfloat sdfWhiteKey(vec3 p, float key)\n{\n    key = clamp(key, -23., 28.);\n    int note = whiteKeyToNote(key);\n    float z = isNotePlaying(note) ? -.5 : 0.;\n    return sdfBox(p, vec3(key,0.,z), vec3(.45, 2., .5))-.05;\n}\n\nfloat sdfWhiteKeys(vec3 p)\n{\n    float key = round(p.x);  // get nearest key\n    //return sdfWhiteKey(p, key);\n    // If key is pressed, we need to SDF the neighboring keys as well.\n    float a = sdfWhiteKey(p, key - 1.);\n    float b = sdfWhiteKey(p, key);\n    float c = sdfWhiteKey(p, key + 1.);\n    return min(min(a, b), c);\n}\n\nfloat sdfBlackKeys(vec3 p)\n{\n    float key = round(p.x-.5);  // get nearest key\n    return sdfBlackKey(p, key);\n}\n\nfloat globalSdf(vec3 p, out vec3 color)\n{\n    vec3 bmin = vec3(-25.5, -2.5, -4);\n    vec3 bmax = vec3(30, 30, 4);\n    color = vec3(.1,.1,.1);\n    float d;\n    float dCutout;\n\n    d = sdfBoxBounds(p, bmin, bmax);\n    // middle part\n    d = min(d, sdfBoxBounds(p, bmin + vec3(1, 10, -20), bmax + vec3(-1, -1, 15)));\n    // back of piano body\n    d = min(d, sdfBoxBounds(p, bmin + vec3(0, 9, 8+13), bmax + vec3(0, 0, 15)));\n    // left leg\n    d = min(d, sdfBox(p, vec3(bmin.x+3., bmin.y+3., -4 - 10), vec3(1, 1, 10)));\n    // right leg\n    d = min(d, sdfBox(p, vec3(bmax.x-3., bmin.y-3., -4 - 10), vec3(1, 1, 10)));\n    // cut out keyboard area\n    bmin.y--;bmax.z++;\n    bmin.x += 2.;\n    bmax.x -= 2.;\n    bmax.y = 2.;\n    bmin.z = -.5;\n    dCutout = sdfBox(p, .5*(bmin+bmax), .5*(bmax-bmin));\n    d = sdfSubtract(d, dCutout);\n\n    if (dCutout < 0.)  // optimization: only SDF the keys if we're in the cutout\n    {\n        float dBlack = sdfBlackKeys(p);\n        d = min(d, dBlack);\n        float dWhite = sdfWhiteKeys(p);\n        if (dWhite <= d)\n            color = vec3(.8, .8, .8);\n        d = min(d, dWhite);\n    }\n    return d;\n}\n\nvec3 calcNormal(vec3 p, float d)\n{\n    float e = 0.0001;\n    vec3 dummy;\n    vec3 n = vec3(\n        globalSdf(p + vec3(e,0,0), dummy),\n        globalSdf(p + vec3(0,e,0), dummy),\n        globalSdf(p + vec3(0,0,e), dummy));\n    return normalize(n - d);\n}\n\n// basic environment mapping with a cubemap texture\nvec4 env(vec3 rd)\n{\n    return texture(iChannel0, rd.xzy * vec3(1,1,-1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 ro;  // ray origin\n    vec3 rd;  // ray direction\n    float yaw = PI/8.;\n    float pitch = -PI/8.;\n\n    ro = vec3(18, -18, 15);\n\n    rd = perspectiveRay(fragCoord);\n    rd = rotateYaw(rotatePitch(rd, pitch), yaw);\n\n    fragColor = env(rd);\n\n    // ray march the piano\n    float t = 0.;\n    for (int i = 0; i < 30; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec4 color;\n        float d = globalSdf(p, color.rgb);\n        if (d < 0.05)\n        {\n            vec3 normal = calcNormal(p, d);\n            vec3 refl = reflect(rd, normal);\n            color = mix(color, env(refl), 0.25);\n            fragColor.rgb = color.rgb * calcLight(normal, rd, 0.5);\n            break;\n        }\n        t += d;\n        if (t > 100.)\n            break;\n    }\n    //fragColor = texture(iChannel1, vec2(fragCoord.x / iResolution.x, 0));\n    \n    // fade out\n    float time = iTime;\n    if (time >= 176.0)\n        fragColor.rgb = mix(fragColor.rgb, vec3(0), (time - 176.0) / 3.);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BPM 120.0\n\nfloat timeTrack(float time)\n{\n    // Handle the numerous repeats in this piece\n    // Unfortunately, ShaderToy seems to cut out all sound after 3 minutes, no matter\n    // what I do, so we're skipping a few repeats that would normally be performed.\n    if (time >= 8.0)  time -= 8.0;   // repeat A section\n    if (time >= 24.0) time -= 16.0;  // repeat B section\n    if (time >= 32.0) time -= 8.0;   // repeat C section\n    if (time >= 40.0) time -= 8.0;   // repeat D section\n    //if (time >= 56.0) time -= 16.0;  // repeat E section\n    if (time >= 56.0)\n    {\n        time = 24.0 + (time - 56.0);  // go back to C section\n        //if (time >= 32.0) time -= 8.0;  // and repeat C section\n        if (time >= 32.0) // done with that?\n        {\n            time -= 32.0;  // then, go back to the beginning!\n            //if (time >= 8.0)  time -= 8.0;   // repeat A section\n            //if (time >= 24.0) time -= 16.0;  // repeat B section\n            if (time >= 24.0) time = 56.0 + (time - 24.0);  // done with that? now coninue where we left off at measure 56\n        }\n    }\n    if (time >= 64.0) time -= 8.0;  // repeat C variation\n    \n    return time;\n}\n\n// Right hand\n#define CHANNEL1 \\\n/* A section */ \\\nDYN(P) \\\nN(.25, B4) N(.25, A4) N(.25, Gs4) N(.25, A4)  \\\nN(1.,  C5) N(.25, D5) N(.25, C5)  N(.25, B4)  N(.25, C5)  \\\nN(1.,  E5) N(.25, F5) N(.25, E5)  N(.25, Ds5) N(.25, E5) \\\nCRESC(2.0, P, MF) \\\nN(.25, B5) N(.25, A5) N(.25, Gs5) N(.25, A5)  N(.25, B5)  N(.25, A5)  N(.25, Gs5) N(.25, A5)  \\\nN(1.,  C6) N(.5,  A5) N(.5,  C6)  \\\nGRACE2(G5, A5) N(.5, B5) CHORD2(.5, Fs5, A5) CHORD2(.5, E5, G5) CHORD2(.5, Fs5, A5)  \\\nGRACE2(G5, A5) N(.5, B5) CHORD2(.5, Fs5, A5) CHORD2(.5, E5, G5) CHORD2(.5, Fs5, A5)  \\\nCRESC(2.0, MF, P) \\\nGRACE2(G5, A5) N(.5, B5) CHORD2(.5, Fs5, A5) CHORD2(.5, E5, G5) CHORD2(.5, Ds5, Fs5)  \\\nN(1., E5) \\\n/* B section */ \\\nDYN(MF) \\\nCHORD2(.5, C5, E5) CHORD2(.5, D5, F5) \\\nCHORD2(.5, E5, G5) CHORD2(.5, E5, G5) N(.25, A5) N(.25, G5) N(.25, F5) N(.25, E5) \\\nCHORD2(.5, B4, D5) N(.5, G4) DYN(P) CHORD2(.5, C5, E5) CHORD2(.5, D5, F5) \\\nCHORD2(.5, E5, G5) CHORD2(.5, E5, G5) N(.25, A5) N(.25, G5) N(.25, F5) N(.25, E5) \\\nCHORD2(1., B4, D5) DYN(MF) CHORD2(.5, A4, C5) CHORD2(.5, B4, D5) \\\nCHORD2(.5, C5, E5) CHORD2(.5, C5, E5) N(.25, F5) N(.25, E5) N(.25, D5) N(.25, C5) \\\nCHORD2(.5, Gs4, B4) N(.5, E4) DYN(P) CHORD2(.5, A4, C5) CHORD2(.5, B4, D5) \\\nCHORD2(.5, C5, E5) CHORD2(.5, C5, E5) N(.25, F5) N(.25, E5) N(.25, D5) N(.25, C5) \\\nCHORD2(1., Gs4, B4) \\\n/* A' section */ \\\nDYN(P) \\\nN(.25, B4) N(.25, A4) N(.25, Gs4) N(.25, A4) \\\nN(1.,  C5) N(.25, D5) N(.25, C5) N(.25, B4) N(.25, C5) \\\nN(1.,  E5) N(.25, F5) N(.25, E5) N(.25, Ds5) N(.25, E5) \\\nCRESC(2.0, P, MF) \\\nN(.25, B5) N(.25, A5) N(.25, Gs5) N(.25, A5) N(.25, B5) N(.25, A5) N(.25, Gs5) N(.25, A5) \\\nN(1., C6) N(.5, A5) N(.5, B5) \\\nN(.5, C6) N(.5, B5) N(.5, A5) N(.5, Gs5) \\\nN(.5, A5) N(.5, E5) N(.5, F5) N(.5, D5) \\\nCRESC(2.0, MF, P) \\\nN(1., C5) N(.125, C5) N(.125, B4) N(.125, C5) N(.125, B4) N(.125, C5) N(.125, B4) N(.125, A4) N(.125, B4) \\\nN(1., A4) \\\n/* C section */ \\\nDYN(F) \\\nCHORD2(.5, A4, A5) CHORD2(.5, B4, B5) \\\nCHORD2(1., Cs5, Cs6) CHORD2(.5, A4, A5) CHORD2(.5, B4, B5) \\\nCHORD2(.5, Cs5, Cs6) CHORD2(.5, B4, B5) CHORD2(.5, A4, A5) CHORD2(.5, Gs4, Gs5) \\\nCHORD2(.5, Fs4, Fs5) CHORD2(.5, Gs4, Gs5) CHORD2(.5, A4, A5) CHORD2(.5, B4, B5) \\\nCHORD2(.5, Gs4, Gs5) CHORD2(.5, E4, E5) CHORD2(.5, A4, A5) CHORD2(.5, B4, B5) \\\nCHORD2(1., Cs5, Cs6) CHORD2(.5, A4, A5) CHORD2(.5, B4, B5) \\\nCHORD2(.5, Cs5, Cs6) CHORD2(.5, B4, B5) CHORD2(.5, A4, A5) CHORD2(.5, Gs4, Gs5) \\\nCHORD2(.5, Fs4, Fs5) CHORD2(.5, B4, B5) CHORD2(.5, Gs4, Gs5) CHORD2(.5, E4, E5) \\\nCHORD2(1., A4, A5) \\\n/* D section */ \\\nDYN(P) \\\nN(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, B5) \\\nCRESC(6.0, P, F) \\\nN(.25, A5) N(.25, B5) N(.25, A5) N(.25, Gs5) N(.25, Fs5) N(.25, A5) N(.25, Gs5) N(.25, Fs5) \\\nN(.25, F5) N(.25, Fs5) N(.25, Gs5) N(.25, F5) N(.25, Cs5) N(.25, Ds5) N(.25, F5) N(.25, Cs5) \\\nN(.25, Fs5) N(.25, F5) N(.25, Fs5) N(.25, Gs5) N(.25, A5) N(.25, Gs5) N(.25, A5) N(.25, B5) \\\nCRESC(2.0, F, P) \\\nN(.25, Cs6) N(.25, C6) N(.25, Cs6) N(.25, C6) N(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, B5) \\\nN(.25, A5) N(.25, B5) N(.25, A5) N(.25, Gs5) N(.25, Fs5) N(.25, A5) N(.25, Gs5) N(.25, Fs5) \\\nN(.25, E5) N(.25, Fs5) N(.25, Gs5) N(.25, E5) N(.25, Cs5) N(.25, Ds5) N(.25, E5) N(.25, Cs5) \\\nCRESC(2.0, P, PP) \\\nN(.25, Ds5) N(.25, E5) N(.25, Fs5) N(.25, Ds5) N(.25, C5) N(.25, Cs5) N(.25, Ds5) N(.25, C5) \\\nN(1., Cs5) \\\n/* E section */ \\\nDYN(F) \\\nN(.25, E5) N(.25, D5) N(.25, Cs5) N(.25, B4) \\\nN(.25, A4) N(.25, B4) N(.25, Cs5) N(.25, D5) N(.25, E5) N(.25, Fs5) N(.25, Gs5) N(.25, A5) \\\nN(.25, A5) N(.25, Gs5) N(.25, Fs5) N(.25, E5) N(.25, E5) N(.25, D5) N(.25, Cs5) N(.25, B4) \\\nN(.25, A4) N(.25, B4) N(.25, Cs5) N(.25, D5) N(.25, E5) N(.25, Fs5) N(.25, Gs5) N(.25, A5) \\\nCRESC(1.0, F, P) N(.5, As5) N(.5, B5) DYN(F) N(.25, E5) N(.25, D5) N(.25, Cs5) N(.25, B4) \\\nN(.25, A4) N(.25, B4) N(.25, Cs5) N(.25, D5) N(.25, E5) N(.25, Fs5) N(.25, Gs5) N(.25, A5) \\\nN(.25, A5) N(.25, Gs5) N(.25, Fs5) N(.25, E5) N(.25, E5) N(.25, D5) N(.25, Cs5) N(.25, B4) \\\nN(.25, Cs5) N(.25, E5) N(.25, A4) N(.25, Cs5) N(.25, B4) N(.25, D5) N(.25, Gs4) N(.25, B4) \\\nN(1., A4) \\\n/* D' section */ \\\nDYN(P) \\\nN(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, B5) \\\nN(.25, A5) N(.25, B5) N(.25, A5) N(.25, Gs5) N(.25, Fs5) N(.25, A5) N(.25, Gs5) N(.25, Fs5) \\\nN(.25, F5) N(.25, Fs5) N(.25, Gs5) N(.25, F5) N(.25, Cs5) N(.25, Ds5) N(.25, F5) N(.25, Cs5) \\\nCRESC(6.0, P, F) N(.25, Fs5) N(.25, F5) N(.25, Fs5) N(.25, Gs5) N(.25, A5) N(.25, Gs5) N(.25, A5) N(.25, B5) \\\nN(.25, Cs6) N(.25, C6) N(.25, Cs6) N(.25, C6) N(.25, Cs6) N(.25, C6) N(.25, Cs6) N(.25, As5) \\\nCRESC(6.0, F, P) N(.25, D6) N(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, D6) N(.25, Cs6) \\\nN(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, A5) N(.25, Gs5) N(.25, A5) N(.25, B5) N(.25, Gs5) \\\nN(.25, A5) N(.25, B5) N(.25, Cs6) N(.25, Fs5) N(.25, F5) N(.25, Fs5) N(.25, Gs5) N(.25, F5) \\\nN(1., Fs5) \\\n/* C' section */ \\\nDYN(F) \\\nN(.25, A4) N(.25, A5) N(.25, B4) N(.25, B5) \\\nN(.25, Cs5) N(.25, Cs6) R(.5) N(.25, A4) N(.25, A5) N(.25, B4) N(.25, B5) \\\nN(.25, Cs5) N(.25, Cs6) N(.25, B4) N(.25, B5) N(.25, A4) N(.25, A5) N(.25, Gs4) N(.25, Gs5) \\\nN(.25, Fs4) N(.25, Fs5) N(.25, Gs4) N(.25, Gs5) N(.25, A4) N(.25, A5) N(.25, B4) N(.25, B5) \\\nN(.25, Gs4) N(.25, Gs5) N(.25, E4) N(.25, E5) N(.25, A4) N(.25, A5) N(.25, B4) N(.25, B5) \\\nN(.25, Cs5) N(.25, Cs6) R(.5) N(.25, A4) N(.25, A5) N(.25, B4) N(.25, B5) \\\nN(.25, Cs5) N(.25, Cs6) N(.25, B4) N(.25, B5) N(.25, A4) N(.25, A5) N(.25, Gs4) N(.25, Gs5) \\\nN(.25, Fs4) N(.25, Fs5) N(.25, B4) N(.25, B5) N(.25, Gs4) N(.25, Gs5) N(.25, E4) N(.25, E5) \\\nCHORD2(1., A4, A5) \\\n/* Coda */ \\\nCHORD2(.75, Cs5, Cs6) CHORD2(.25, Cs5, Cs6) \\\nCHORD4(2., Cs5, E5, A5, Cs6) \\\nCHORD4(2., Cs5, E5, A5, Cs6) \\\nN(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) \\\nCHORD3(2., Fs5, A5, D6) \\\nGRACE(D6) CHORD3(.5, E5, A5, Cs6) GRACE(D6) CHORD3(.5, E5, A5, Cs6) GRACE(D6) CHORD3(.5, E5, A5, Cs6) GRACE(D6) CHORD3(.5, E5, A5, Cs6) \\\nCHORD3(1.5, E5, Gs5, B5) N(.5, E6) \\\nCHORD4(2., Cs5, E5, A5, Cs6) \\\nCHORD4(2., Cs5, E5, A5, Cs6) \\\nN(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) \\\nCHORD3(2., Fs5, A5, D6) \\\nGRACE(D6) CHORD3(2., E5, A5, Cs6) \\\nGRACE(D6) CHORD3(.5, E5, Gs5, B5) GRACE(D6) CHORD3(.5, E5, Gs5, B5) GRACE(D6) CHORD3(.5, E5, Gs5, B5) GRACE(D6) CHORD3(.5, E5, Gs5, B5) \\\nDYN(MP) \\\nN(1., A5) \\\nGRACE2(E5, A5) N(0.75, Cs6) N(0.25, Cs6) \\\nGRACE2(E5, A5) N(2., Cs6) \\\nGRACE2(E5, A5) N(2., Cs6) \\\nN(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) \\\nN(2., D6) \\\nGRACE(D6) N(0.5, Cs6) GRACE(D6) N(0.5, Cs6) GRACE(D6) N(0.5, Cs6) GRACE(D6) N(0.5, Cs6) \\\nN(1.5, B5) N(.5, E6) \\\nDYN(F) \\\nCHORD4(2., Cs5, E5, A5, Cs6) \\\nCHORD4(2., Cs5, E5, A5, Cs6) \\\nN(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) N(.25, D6) N(.25, Cs6) N(.25, B5) N(.25, Cs6) \\\nCHORD3(2., Fs5, A5, D6) \\\nGRACE(D6) CHORD3(2., E5, A5, Cs6) \\\nGRACE(D6) CHORD3(.5, E5, Gs5, B5) GRACE(D6) CHORD3(.5, E5, Gs5, B5) GRACE(D6) CHORD3(.5, E5, Gs5, B5) GRACE(D6) CHORD3(.5, E5, Gs5, B5) \\\nCHORD4(1.5, A4, Cs5, E5, A5) CHORD2(.5, Cs5, Cs6) \\\nCHORD2(1.5, A4, A5) CHORD2(.5, E5, E6) \\\nCHORD2(1.5, A4, A5) CHORD2(.5, Cs5, Cs6) \\\nCHORD2(.5, A4, A5) CHORD2(.5, Cs5, Cs6) \\\nCHORD2(.5, A4, A5) CHORD2(.5, E5, E6) \\\nCHORD2(1., A4, A5) DYN(FF) CHORD4(1., A4, Cs5, E5, A5) \\\nCHORD4(1., A4, Cs5, E5, A5)\n\n#define OSTINATO(a, b, c) N(.25, a) N(.25, c) N(.25, b) N(.25, c)\n\n// Left hand\n#define CHANNEL2 \\\n/* A section */ \\\nDYN(P) \\\nR(1.) \\\nN(.5, A3) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) \\\nN(.5, A3) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) \\\nCRESC(2.0, P, MF) \\\nN(.5, A3) CHORD2(.5, C4, E4) N(.5, A3) CHORD2(.5, C4, E4) \\\nN(.5, A3) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) \\\nN(.5, E3) CHORD2(.5, B3, E4) CHORD2(.5, B3, E4) CHORD2(.5, B3, E4) \\\nN(.5, E3) CHORD2(.5, B3, E4) CHORD2(.5, B3, E4) CHORD2(.5, B3, E4) \\\nCRESC(2.0, MF, P) \\\nN(.5, E3) CHORD2(.5, B3, E4) N(.5, B2) N(.5, B3) \\\nN(2., E3) \\\n/* B section */ \\\nDYN(MF) \\\nN(.5, C3) N(.5, C4) N(.5, E3) N(.5, E4) \\\nN(2., G3) \\\nDYN(P) \\\nN(.5, C3) N(.5, C4) N(.5, E3) N(.5, E4) \\\nN(2., G3) \\\nDYN(MF) \\\nN(.5, A2) N(.5, A3) N(.5, C3) N(.5, C4) \\\nN(2., E3) \\\nDYN(P) \\\nN(.5, A2) N(.5, A3) N(.5, C3) N(.5, C4) \\\nN(2., E3) \\\n/* A' section */ \\\nDYN(P) \\\nN(.5, A3) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) \\\nN(.5, A3) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) CHORD2(.5, C4, E4) \\\nCRESC(2.0, P, MF) \\\nN(.5, A3) CHORD2(.5, C4, E4) N(.5, A3) CHORD2(.5, C4, E4) \\\nN(.5, F3) CHORD2(.5, A3, Ds4) CHORD2(.5, A3, Ds4) CHORD2(.5, A3, Ds4) \\\nN(.5, E3) CHORD2(.5, A3, E4) N(.5, D3) CHORD2(.5, F3, B3) \\\nN(.5, C3) CHORD2(.5, E3, A3) N(.5, D3) CHORD2(.5, F3, B3) \\\nCRESC(2.0, MF, P) \\\nCHORD2(.5, E3, A3) CHORD2(.5, E3, A3) CHORD2(.5, E3, Gs3) CHORD2(.5, E3, Gs3) \\\nCHORD2(1., A2, A3) \\\n/* C section */ \\\nR(1.) \\\nDYN(F) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(D2, Fs2, A2) N(.5, D3) N(.5, D3) GRACE3(Ds2, Fs2, A2) N(.5, Ds3) N(.5, Ds3) \\\nGRACE3(E2, Gs2, B2) N(.5, E3) N(.5, E3) N(.5, E3) N(.5, E3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(D2, Fs2, A2) N(.5, D3) N(.5, D3) GRACE3(E2, Gs2, B2) N(.5, E3) N(.5, E3) \\\nN(2., A2) \\\n/* D section */ \\\nDYN(P) \\\nCRESC(6.0, P, F) \\\nN(.5, Fs3) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) \\\nN(.5, Gs3) CHORD2(.5, B3, Cs4) CHORD2(.5, B3, Cs4) CHORD2(.5, B3, Cs4) \\\nN(.5, Fs3) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) \\\nCRESC(4.0, F, P) \\\nN(.5, F3) CHORD2(.5, Gs3, Cs4) CHORD2(.5, Gs3, Cs4) CHORD2(.5, Gs3, Cs4) \\\nN(.5, Fs3) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) \\\nN(.5, Gs3) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) \\\nCRESC(2.0, P, PP) \\\nN(.5, Gs3) CHORD2(.5, Ds4, Fs4) CHORD2(.5, Ds4, Fs4) CHORD2(.5, Ds4, Fs4) \\\nCHORD2(2., Cs4, E4) \\\n/* E section */ \\\nDYN(F) \\\nN(.5, A3) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) \\\nN(.5, B3) CHORD2(.5, D4, E4) N(.5, Gs3) CHORD2(.5, D4, E4) \\\nN(.5, A3) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) \\\nCRESC(1.0, F, P) N(.5, E3) CHORD2(.5, Gs3, D4) DYN(F) CHORD2(.5, Gs3, D4) CHORD2(.5, Gs3, D4) \\\nN(.5, A3) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) CHORD2(.5, Cs4, E4) \\\nN(.5, B3) CHORD2(.5, D4, E4) N(.5, Gs3) CHORD2(.5, D4, E4) \\\nN(.5, A3) N(.5, Fs3) N(.5, D3) N(.5, E3) \\\nN(.5, A2) N(1.5, A3) \\\n/* D' section */ \\\nDYN(P) \\\nN(.5, Fs3) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) \\\nN(.5, Gs3) CHORD2(.5, B3, Cs4) CHORD2(.5, B3, Cs4) CHORD2(.5, B3, Cs4) \\\nCRESC(6.0, P, F) N(.5, Fs3) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) CHORD2(.5, A3, Cs4) \\\nN(.5, Cs3) CHORD2(.5, Gs3, Cs4) CHORD2(.5, G3, Cs4) CHORD2(.5, Fs3, Cs4) \\\nN(.5, B2) CHORD2(.5, Fs3, B3) CHORD2(.5, Fs3, B3) CHORD2(.5, Fs3, B3) \\\nCRESC(6.0, F, P) N(.5, B2) CHORD2(.5, Gs3, B3) CHORD2(.5, Gs3, B3) CHORD2(.5, Gs3, B3) \\\nN(.5, Cs3) CHORD2(.5, Fs3, A3) N(.5, Cs3) CHORD2(.5, Gs3, B3) \\\nCHORD2(2., Fs3, A3) \\\n/* Coda */ \\\nAT(64.0) \\\nR(1.0) \\\nDYN(F) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(D2, Fs2, A2) N(.5, D3) N(.5, D3) N(.5, D3) N(.5, D3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(E2, Gs2, B2) N(.5, E3) N(.5, E3) N(.5, E3) N(.5, E3) \\\n/* again */ \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(D2, Fs2, A2) N(.5, D3) N(.5, D3) N(.5, D3) N(.5, D3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(E2, Gs2, B2) N(.5, E3) N(.5, E3) N(.5, E3) N(.5, E3) \\\nDYN(P) \\\nOSTINATO(A3, Cs4, E4) OSTINATO(A3, Cs4, E4) \\\nOSTINATO(A3, Cs4, E4) OSTINATO(A3, Cs4, E4) \\\nOSTINATO(A3, Cs4, E4) OSTINATO(A3, Cs4, E4) \\\nOSTINATO(A3, Cs4, E4) OSTINATO(A3, Cs4, E4) \\\nOSTINATO(A3, D4, Fs4) OSTINATO(A3, D4, Fs4) \\\nOSTINATO(A3, Cs4, E4) OSTINATO(A3, Cs4, E4) \\\nOSTINATO(E3, Gs3, E4) OSTINATO(E3, Gs3, E4) \\\nDYN(F) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(D2, Fs2, A2) N(.5, D3) N(.5, D3) N(.5, D3) N(.5, D3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(E2, Gs2, B2) N(.5, E3) N(.5, E3) N(.5, E3) N(.5, E3) \\\n/* end */ \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) N(.5, A3) N(.5, A3) \\\nGRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) GRACE3(A2, Cs3, E3) N(.5, A3) N(.5, A3) \\\nN(1., A2) DYN(FF) CHORD4(1., A2, Cs3, E3, A3) \\\nCHORD4(1., A2, Cs3, E3, A3)", "buffer_a_code": "/**\n * To determine if a note is being played, sample this buffer texture at (note, 0).\n * If the red component is 1, the note is being played. If it is 0, the note is not being played.\n */\n\n// piano note indexes\n#define A0 0\n#define As0 1\n#define B0 2\n#define C1 3\n#define Cs1 4\n#define D1 5\n#define Ds1 6\n#define E1 7\n#define F1 8\n#define Fs1 9\n#define G1 10\n#define Gs1 11\n#define A1 12\n#define As1 13\n#define B1 14\n#define C2 15\n#define Cs2 16\n#define D2 17\n#define Ds2 18\n#define E2 19\n#define F2 20\n#define Fs2 21\n#define G2 22\n#define Gs2 23\n#define A2 24\n#define As2 25\n#define B2 26\n#define C3 27\n#define Cs3 28\n#define D3 29\n#define Ds3 30\n#define E3 31\n#define F3 32\n#define Fs3 33\n#define G3 34\n#define Gs3 35\n#define A3 36\n#define As3 37\n#define B3 38\n#define C4 39\n#define Cs4 40\n#define D4 41\n#define Ds4 42\n#define E4 43\n#define F4 44\n#define Fs4 45\n#define G4 46\n#define Gs4 47\n#define A4 48\n#define As4 49\n#define B4 50\n#define C5 51\n#define Cs5 52\n#define D5 53\n#define Ds5 54\n#define E5 55\n#define F5 56\n#define Fs5 57\n#define G5 58\n#define Gs5 59\n#define A5 60\n#define As5 61\n#define B5 62\n#define C6 63\n#define Cs6 64\n#define D6 65\n#define Ds6 66\n#define E6 67\n#define F6 68\n#define Fs6 69\n#define G6 70\n#define Gs6 71\n#define A6 72\n#define As6 73\n#define B6 74\n#define C7 75\n#define Cs7 76\n#define D7 77\n#define Ds7 78\n#define E7 79\n#define F7 80\n#define Fs7 81\n#define G7 82\n#define Gs7 83\n#define A7 84\n#define As7 85\n#define B7 86\n#define C8 87\n\n#define TEST\n\n#ifdef TEST\n#define N(len, pitch) noteA=(t>=x&&t<x+len*.8*60.0/BPM)?pitch:noteA;x+=len*60.0/BPM;\n#else\n#define N(len, pitch) if(note==pitch&&t>=x&&t<x+len*0.8*60.0/BPM)return true; x+=len*60.0/BPM;\n#endif\n#define R(len) x+=len*60.0/BPM;\n\n#define AT(time) x=time;\n\n#define GRACE(a)        x-=0.1*60.0/BPM;N(0.1,a)\n#define GRACE2(a, b)    x-=0.2*60.0/BPM;N(0.1,a)N(0.1,b)\n#define GRACE3(a, b, c) x-=0.3*60.0/BPM;N(0.1,a)N(0.1,b)N(0.1,c)\n#ifdef TEST\n#define CHORD2(len, a, b) \\\n    noteA=(t>=x&&t<x+len*.8*60.0/BPM)?a:noteA; \\\n    noteB=(t>=x&&t<x+len*.8*60.0/BPM)?b:noteB; \\\n    x+=len*60.0/BPM;\n#define CHORD3(len, a, b, c) \\\n    noteA=(t>=x&&t<x+len*.8*60.0/BPM)?a:noteA; \\\n    noteB=(t>=x&&t<x+len*.8*60.0/BPM)?b:noteB; \\\n    noteC=(t>=x&&t<x+len*.8*60.0/BPM)?c:noteC; \\\n    x+=len*60.0/BPM;\n#define CHORD4(len, a, b, c, d) \\\n    noteA=(t>=x&&t<x+len*.8*60.0/BPM)?a:noteA; \\\n    noteB=(t>=x&&t<x+len*.8*60.0/BPM)?b:noteB; \\\n    noteC=(t>=x&&t<x+len*.8*60.0/BPM)?c:noteC; \\\n    noteD=(t>=x&&t<x+len*.8*60.0/BPM)?d:noteD; \\\n    x+=len*60.0/BPM;\n#else\n#define CHORD2(len, a, b)       N(len, a) x-=len*60.0/BPM; N(len, b)\n#define CHORD3(len, a, b, c)    N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c)\n#define CHORD4(len, a, b, c, d) N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c) x-=len*60.0/BPM; N(len, d)\n#endif\n\n// unused\n#define DYN(volume)\n#define CRESC(len, start, end)\n\nbool isNotePlayingCh1(float t, int note)\n{\n    float x = 0.;\n    int noteA = -1;\n    int noteB = -1;\n    int noteC = -1;\n    int noteD = -1;\n\n    CHANNEL1\n\n#ifdef TEST\n    return note == noteA || note == noteB || note == noteC || note == noteD;\n#else\n    return false;\n#endif\n}\n\nbool isNotePlayingCh2(float t, int note)\n{\n    float x = 0.;\n    int noteA = -1;\n    int noteB = -1;\n    int noteC = -1;\n    int noteD = -1;\n\n    // The left hand parts are identical for C and C', so just repeat that\n    if (t >= 56.0 && t < 64.0)\n        t = 24.0 + (t - 56.0);\n\n    CHANNEL2\n\n#ifdef TEST\n    return note == noteA || note == noteB || note == noteC || note == noteD;\n#else\n    return false;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int note = int(fragCoord.x);\n    float t = timeTrack(iTime);\n\n    fragColor = vec4(0);\n    if (fragCoord.y <= 1.)\n        fragColor.r = (isNotePlayingCh1(t, note) || isNotePlayingCh2(t, note)) ? 1. : 0.;\n}", "buffer_a_inputs": [], "sound_code": "// Note frequencies\n\n#define FREQ_C(oct)  (16.35*exp2(float(oct)))\n#define FREQ_Cs(oct) (17.32*exp2(float(oct)))\n#define FREQ_D(oct)  (18.35*exp2(float(oct)))\n#define FREQ_Ds(oct) (19.45*exp2(float(oct)))\n#define FREQ_E(oct)  (20.60*exp2(float(oct)))\n#define FREQ_F(oct)  (21.83*exp2(float(oct)))\n#define FREQ_Fs(oct) (23.12*exp2(float(oct)))\n#define FREQ_G(oct)  (24.50*exp2(float(oct)))\n#define FREQ_Gs(oct) (25.96*exp2(float(oct)))\n#define FREQ_A(oct)  (27.50*exp2(float(oct)))\n#define FREQ_As(oct) (29.14*exp2(float(oct)))\n#define FREQ_B(oct)  (30.87*exp2(float(oct)))\n\n#define PI 3.14159265359\n\nfloat attenuate(float t)\n{\n    return exp2(-8.0*t);\n}\n\n// The built-in sin function has some precision issues at large x values, which results in\n// annoying high pitched buzzing sounds. Keeping x within 0 and 2pi fixes that.\nfloat better_sin(float x)\n{\n    return sin(mod(x, 2.0*PI));\n}\n\n// This doesn't sound exactly like a piano, but it's good enough for me!\nfloat piano(float time,float freq)\n{\n    float sampleX = 0.;\n    int maxHarm = 7;\n    if (freq > 800.0) maxHarm = 5;  // make high notes less bright\n    for (int i = 1; i <= maxHarm; i++)\n        sampleX += better_sin(PI*2.0 * freq * float(i) * time) / float(i);\n    return sampleX;\n}\n\n// note\n#define N(len, note) note=(t>=x)?x:note;x+=len*60.0/BPM;\n// rest\n#define R(len) x+=len*(60.0/BPM);\n\n#define GRACE(a)        x-=0.1*(60.0/BPM);N(0.1,a)\n#define GRACE2(a, b)    x-=0.2*(60.0/BPM);N(0.1,a)N(0.1,b)\n#define GRACE3(a, b, c) x-=0.3*(60.0/BPM);N(0.1,a)N(0.1,b)N(0.1,c)\n#define CHORD2(len, a, b)       N(len, a) x-=len*60.0/BPM; N(len, b)\n#define CHORD3(len, a, b, c)    N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c)\n#define CHORD4(len, a, b, c, d) N(len, a) x-=len*60.0/BPM; N(len, b) x-=len*60.0/BPM; N(len, c) x-=len*60.0/BPM; N(len, d)\n\n#define AT(time) x=time;\n\n// Dynamics\n#define PP 0.1\n#define P  0.2\n#define MP 0.25\n#define MF 0.5\n#define F  0.65\n#define FF 1.0\n#define DYN(d) if(t>=x)volume=d;\n#define CRESC(len, a, b) if (t>=x)volume=mix(a, b, min(1.0,(t-x)/((len)*60.0/BPM)));\n\n#define PLAYNOTES(note, freq) if(note>=0.)a+=piano(t-note,freq)*volume*attenuate(t-note);\n\nfloat channel1(float t)\n{\n    float x = 0.0;\n    float a = 0.0;\n    // I tried using an array here, but it was too slow, and this managed to be faster somehow.\n    float C4=-1.,Cs4=-1.,D4=-1.,Ds4=-1.,E4=-1.,F4=-1.,Fs4=-1.,G4=-1.,Gs4=-1.,A4=-1.,As4=-1.,B4=-1.,\n          C5=-1.,Cs5=-1.,D5=-1.,Ds5=-1.,E5=-1.,F5=-1.,Fs5=-1.,G5=-1.,Gs5=-1.,A5=-1.,As5=-1.,B5=-1.,\n          C6=-1.,Cs6=-1.,D6=-1.,E6=-1.;\n    float volume = 0.0;\n\n    CHANNEL1\n\n    PLAYNOTES(C4,  FREQ_C(4))\n    PLAYNOTES(E4,  FREQ_E(4))\n    PLAYNOTES(Fs4, FREQ_Fs(4))\n    PLAYNOTES(G4,  FREQ_G(4))\n    PLAYNOTES(Gs4, FREQ_Gs(4))\n    PLAYNOTES(A4,  FREQ_A(4))\n    PLAYNOTES(As4, FREQ_As(4))\n    PLAYNOTES(B4,  FREQ_B(4))\n    PLAYNOTES(C5,  FREQ_C(5))\n    PLAYNOTES(Cs5, FREQ_Cs(5))\n    PLAYNOTES(D5,  FREQ_D(5))\n    PLAYNOTES(Ds5, FREQ_Ds(5))\n    PLAYNOTES(E5,  FREQ_E(5))\n    PLAYNOTES(F5,  FREQ_F(5))\n    PLAYNOTES(Fs5, FREQ_Fs(5))\n    PLAYNOTES(G5,  FREQ_G(5))\n    PLAYNOTES(Gs5, FREQ_Gs(5))\n    PLAYNOTES(A5,  FREQ_A(5))\n    PLAYNOTES(As5, FREQ_As(5))\n    PLAYNOTES(B5,  FREQ_B(5))\n    PLAYNOTES(C6,  FREQ_C(6))\n    PLAYNOTES(Cs6, FREQ_Cs(6))\n    PLAYNOTES(D6,  FREQ_D(6))\n    PLAYNOTES(E6,  FREQ_E(6))\n\n    return a;\n}\n\nfloat channel2(float t)\n{\n    float x = 0.0;\n    float a = 0.0;\n    float volume = 0.0;\n\n    // I tried using an array here, but it was too slow, and this managed to be faster somehow.\n    float D2=-1.,Ds2=-1.,E2=-1.,Fs2=-1.,Gs2=-1.,A2=-1.,B2=-1.,\n          C3=-1.,Cs3=-1.,D3=-1.,Ds3=-1.,E3=-1.,F3=-1.,Fs3=-1.,G3=-1.,Gs3=-1.,A3=-1.,B3=-1.,\n          C4=-1.,Cs4=-1.,D4=-1.,Ds4=-1.,E4=-1.,Fs4=-1.;\n\n    // The left hand parts are identical for C and C', so just repeat that\n    if (t >= 56.0 && t < 64.0)\n        t = 24.0 + (t - 56.0);\n\n    CHANNEL2\n\n    PLAYNOTES(D2,  FREQ_D(2))\n    PLAYNOTES(Ds2, FREQ_Ds(2))\n    PLAYNOTES(E2,  FREQ_E(2))\n    PLAYNOTES(Fs2, FREQ_Fs(2))\n    PLAYNOTES(Gs2, FREQ_Gs(2))\n    PLAYNOTES(A2,  FREQ_A(2))\n    PLAYNOTES(B2,  FREQ_B(2))\n    PLAYNOTES(C3,  FREQ_C(3))\n    PLAYNOTES(Cs3, FREQ_Cs(3))\n    PLAYNOTES(D3,  FREQ_D(3))\n    PLAYNOTES(Ds3, FREQ_Ds(3))\n    PLAYNOTES(E3,  FREQ_E(3))\n    PLAYNOTES(F3,  FREQ_F(3))\n    PLAYNOTES(Fs3, FREQ_Fs(3))\n    PLAYNOTES(G3,  FREQ_G(3))\n    PLAYNOTES(Gs3, FREQ_Gs(3))\n    PLAYNOTES(A3,  FREQ_A(3))\n    PLAYNOTES(B3,  FREQ_B(3))\n    PLAYNOTES(C4,  FREQ_C(4))\n    PLAYNOTES(Cs4, FREQ_Cs(4))\n    PLAYNOTES(D4,  FREQ_D(4))\n    PLAYNOTES(Ds4, FREQ_Ds(4))\n    PLAYNOTES(E4,  FREQ_E(4))\n    PLAYNOTES(Fs4, FREQ_Fs(4))\n\n    return a;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    time = timeTrack(time);\n\n    vec2 sound = vec2(0);\n\n    float right = channel1(time) * 0.25;\n    float left = channel2(time) * 0.25;\n\n    // mix the channels\n    sound += left * vec2(0.7, 0.3);\n    sound += right * vec2(0.3, 0.7);\n    \n    return sound;\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2fWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 79, 99, 162], [164, 212, 245, 245, 472], [474, 503, 540, 540, 654], [656, 685, 724, 724, 838], [840, 869, 907, 907, 1021], [1067, 1067, 1123, 1123, 1414], [1416, 1447, 1484, 1484, 1509], [1511, 1552, 1595, 1595, 1693], [1695, 1753, 1803, 1803, 1859], [1861, 1861, 1892, 1892, 2057], [2059, 2059, 2090, 2090, 2259], [2261, 2261, 2299, 2299, 2669], [2671, 2671, 2709, 2709, 2887], [2889, 2889, 2917, 2917, 3217], [3219, 3219, 3247, 3247, 3332], [3334, 3334, 3375, 3375, 4469], [4471, 4471, 4505, 4505, 4723], [4725, 4777, 4796, 4796, 4852], [4854, 4854, 4909, 4909, 5886]], "test": "untested"}
{"id": "ms3cz8", "name": "Through the Neon Tunnel", "author": "fouad", "description": "Inspired by \"Neon Squircles\" by @kishimisu (2022) - https://www.shadertoy.com/view/mdjXRd", "tags": ["tunnel"], "likes": 11, "viewed": 367, "published": 3, "date": "1694712149", "time_retrieved": "2024-07-30T17:33:50.196266", "image_code": "/* \"Neon Squircles\" by @kishimisu (2022) - https://www.shadertoy.com/view/mdjXRd\n   [262 chars]\n   \n   No raymarching this time as I wanted to stay\n   below 300 chars, I tried to reduce the number\n   of instructions to the minimum to avoid having\n   a body with brackets in the for loop.\n   \n   The layout of the code was inspired by @Xor's \n   codegolfing shaders: for(..; ..; O.rgb += *magic*); \n*/\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2 r = iResolution.xy, u = (F+F-r)/r.y;    \n    O.rgb*=0.;\n    for (float i; i<15.; O.rgb +=\n    .0035/(abs(length(u*u)-i*.0275)+.003)                   // shape distance\n    * (sin(i*5.+vec3(0,1,3))+1.)                            // color\n    * smoothstep(.35,.4,abs(abs(mod(iTime,2.)-i*.1)-1.)) // animation\n    ) u*=mat2(cos((iTime+i++)*(i< 2.0 ? .0 :.03)+ vec4(0,33,11,0)));   // rotation\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3cz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 401, 437, 437, 838]], "test": "untested"}
{"id": "Dd3yz8", "name": "Magnet Swirls [117 Chars]", "author": "SnoopethDuckDuck", "description": "asdfasdfasdfasdf", "tags": ["golf"], "likes": 11, "viewed": 238, "published": 3, "date": "1694706117", "time_retrieved": "2024-07-30T17:33:51.041007", "image_code": "// -2 thanks to Fabrice 😺\nvoid mainImage( out vec4 o, vec2 f ){\n    f /= iResolution.y;\n    o.xy = tan(f*8.+f.y*5.);\n    o = cos((iTime+atan(o.x,o.y))*8. + f.xxxx*2e2);\n}\n\n// or try:\n// atan(3.*o.x-o.y)\n// atan(o.y/tan(o.x/o.y))\n// atan(o.x-o.y*cos(iTime-1./(o.y)))", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3yz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 66, 66, 173]], "test": "untested"}
{"id": "clSBWd", "name": "2D Physics (analytic springs)", "author": "TDM", "description": "Analytic solution of Hooke's law for spring system with 3 springs.\nSee springSystemModel() which takes state of the current spring and two neighbours and calculates advanced state. ", "tags": ["2d", "simulation", "physics", "analytic", "spring", "law", "hookes"], "likes": 14, "viewed": 428, "published": 3, "date": "1694704048", "time_retrieved": "2024-07-30T17:33:52.036346", "image_code": "/*\n * \"2D Physics (analytic springs)\" by Alexander Alekseev aka TDM - 2023\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst vec3 COLOR = vec3(72, 143, 240) / 255.;\n\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    return step(dist-w,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse.y = 0.0;\n    \n    vec3 c = vec3(1.0);\n        \n    // objects\n    for(int i = 0; i < NUM_OBJECTS-1; i++) {\n        vec2 body = getBody(iChannel0, i);\n        vec2 b1 = getBody(iChannel0, i+1);\n        vec2 pos_ss0 = toScreenspace(i,body.x);\n        vec2 pos_ss1 = toScreenspace(i+1,b1.x);\n        \n        float ba = line(uv,pos_ss0,pos_ss1,BALL_SIZE);\n        c = mix(c,COLOR,ba);\n        \n        vec2 mid = (pos_ss0 + pos_ss1) * 0.5;\n        ba = line(uv,\n            mid,\n            mid+vec2(0.0,-2.0),\n            BALL_SIZE);\n        c = mix(c,COLOR,ba * 0.2 - min(uv.y,0.0)*0.005);\n    }\n    \n    // final\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * \"2D Physics (analytic springs)\" by Alexander Alekseev aka TDM - 2023\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com \n */\n \nconst int NUM_OBJECTS = 64;\nconst float OBJECTS_GAP = 0.5 * (8.0 / float(NUM_OBJECTS));\nconst float BALL_SIZE = OBJECTS_GAP / 2.0;\n\n/*\n * Dynamics\n */\n \nconst float k = 100.0;\nconst float damp = 0.45;\n\nvec2 springSystemModel(float t, vec2 b0, vec2 b1, vec2 b2) {\n    float rh = sqrt(3.*k);\n    float rp = sqrt(k);\n    \n    vec2 CH = vec2(b0.x - (b1.x+b2.x)/2., \n                  (b0.y - (b1.y+b2.y)/2.) / rh);\n    vec2 CP = vec2((b1.x+b2.x)/2.,\n                   (b1.y+b2.y)/(2.*rp));\n                   \n    vec2 exph = vec2(cos(rh*t), sin(rh*t));\n    vec2 expp = vec2(cos(rp*t), sin(rp*t));\n       \n    float x  = dot(CH, exph) + \n               dot(CP, expp);\n    float dx = dot(CH, rh*exph.yx*vec2(-1.0,1.0)) + \n               dot(CP, rp*expp.yx*vec2(-1.0,1.0));\n    \n    return vec2(x,dx) * exp(-t * damp); // new state\n}\n\n/*\n * body\n */\n\nvec2 getBody(sampler2D buf, int i) {\n    return texelFetch(buf, ivec2(i,0), 0).xy;\n}\n\nvoid initBody(int id, inout vec2 body) {\n    body = vec2(0.0);\n}\n\n/*\n * store\n */\n\nvoid storeBody(in int id, in vec2 b, inout vec4 col, in vec2 uv) {\n    col = vec4(b,0.0,0.0);\n}\n\n/**\n * coords\n */\n \nvec2 toScreenspace(int id, float y) {\n    float x = -float(NUM_OBJECTS-1) * 0.5 * OBJECTS_GAP + \n    float(id) * OBJECTS_GAP;\n    return vec2(x,y);\n}", "buffer_a_code": "/*\n * \"2D Physics (analytic springs)\" by Alexander Alekseev aka TDM - 2023\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;\n    \n    // load    \n    vec2 body = getBody(iChannel0, id);\n    if(iFrame == 0) {\n        initBody(id, body); // init\n    } else {\n    \n        float dt = iTimeDelta;\n\n        // mouse\n        if(iMouse.z > 0.5) {\n            vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n            mouse.x *= iResolution.x / iResolution.y;\n            vec2 pos_ss = toScreenspace(id,body.x);\n            vec2 dir = pos_ss.xy - mouse;\n\n            float t = abs(dir.x);\n            body.y += -k * 0.5 * dt * smoothstep(0.2,0.0,t);\n        }\n\n        // spring\n        vec2 bl = getBody(iChannel0, id-1);\n        vec2 br = getBody(iChannel0, id+1);\n        body = springSystemModel(dt, body, bl, br);\n    }\n    \n    // store\n    storeBody(id, body, fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n * \"2D Physics (analytic springs)\" by Alexander Alekseev aka TDM - 2023\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;     \n    float dt = iTimeDelta;\n\n    // spring\n    vec2 body = getBody(iChannel0, id);\n    vec2 bl = getBody(iChannel0, id-1);\n    vec2 br = getBody(iChannel0, id+1);\n    body = springSystemModel(dt, body, bl, br);\n        \n    // store\n    storeBody(id, body, fragColor, fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSBWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[243, 243, 290, 290, 460], [462, 462, 519, 519, 1375]], "test": "untested"}
{"id": "DlSfWm", "name": "An occult kraken pit", "author": "Cewein", "description": "A Kraken pit with a black hole in the middle. made with raymarching, and a procedural starmap in the background.", "tags": ["raytracing", "raymarching", "reflection", "shadow", "water", "light", "star", "demo", "blackhole", "kraken", "octopus", "tentacle", "ligth"], "likes": 24, "viewed": 365, "published": 3, "date": "1694689960", "time_retrieved": "2024-07-30T17:33:52.996778", "image_code": "// Shader made by Maximilien \"Cewein\", september 2023\n//\n// This is a raymarch scene of eigth tentacle in a water pit\n// around a black hole, the black hole deform the direction of the rays\n//\n//\n// Possible improvement :\n// \t\t- Anti-Aliasing (but heave on perf)\n//\t\t- try to add some global illumination\n//\n// main help came from here : \n// https://iquilezles.org/articles/distfunctions/\n// https://mercury.sexy/hg_sdf/\n//\n//\n\n\n///// CONSTANT /////\n\n#define MAX_STEP 256\n#define MAX_DIST 100.0\n\nvec3 blackHolePos = vec3(0.0,3.0,0.0);\n\n///// RAY MARCHING FUNCTION /////\n\nvec2 map(vec3 pos)\n{\n    vec2 dm = vec2(0.0,0.5);\n    \n    float total = 0.0;\n    \n    //black hole\n    float sphere = distance(pos, blackHolePos)-0.35;\n    total = sphere;\n    \n    \n    //floor + hole in the ground\n    float ground = pos.y;\n    float cylinder = sdCylinder(pos, vec3(0.0,0.0,4.5));\n    ground = max(ground,-cylinder);\n    \n    if( total > ground) dm.y = 2.5;\n    total = min(total,ground);\n    \n    ground = abs(pos.y+1.0);\n    if( total > ground) dm.y = 4.5;\n    total = min(total,ground);\n    \n    //tentacle\n    float tentacle = Tentacle((pos - vec3(0.,-3.,0.))*0.4,8.0, iTime, iChannel0);\n    if( total > tentacle) dm.y = 3.5;\n    \n    dm.x = min(total,tentacle);\n    \n    return dm;\n}\n\n//raymarching loop\nhitPayload trace(hitPayload p)\n{\n    float dist = 0.0;\n    for(int i = 0; i < MAX_STEP; i++)\n    {\n        p.pos = p.pos + dist * p.dir;\n        vec2 tmp = map(p.pos);\n        \n        if(tmp.x < 0.00001) return p;\n        \n        p.nbStep = i;\n        \n        dist = tmp.x;\n        p.totalDist += tmp.x;\n        p.mat = tmp.y;\n\n        if(p.totalDist > MAX_DIST) \n        {\n            p.mat = -1.0;\n            break;\n        }\n        \n        //add lensing, very basic but do the trick\n        //we interpolate the original direction and the direction troward\n        //the blackhole at each step based on the distance\n        //of the point to the blackhole\n        float inter = distance(p.pos, blackHolePos);\n        inter = smoothstep(-9.5,2.5,inter);\n        p.dir = mix(normalize(blackHolePos-p.pos),p.dir,inter);\n    }\n    \n    return p;\n}\n\n///// SHADING FUNCTION /////\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(map(pos + e.xyy).x-map(pos-e.xyy).x,\n                          map(pos + e.yxy).x-map(pos-e.yxy).x,\n                          map(pos + e.yyx).x-map(pos-e.yyx).x)\n                    );\n}\n\n\n//since the tentacle came out of the water\n//add a \"watery\" effect \nvec3 Water( vec3 rayDir )\n{\n\n    vec3 WaterKeyColor  = vec3( 0.19, 0.92, 0.98 );\n    vec3 WaterFillColor = vec3( 0.1, 0.06, 0.28 );\n    \n    rayDir.xy *= rot(-80.0); \n    vec3 color = mix( WaterKeyColor, WaterFillColor, clamp( -1.2 * rayDir.y + 0.6 ,0.0,1.0) );\n    return color;\n}\n\n//thanks for the stars, check this shader out, it contain midgar\n//https://www.shadertoy.com/view/XllXWN\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*250.)-0.5;\n        vec3 id = floor(p*250.);\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*smoothstep(-0.1, 0., p.y);\n}\n\n\n//this is the function that translate a material to the correct color\nvec3 getColor(hitPayload p)\n{\n    vec3 color = stars(p.dir);\n    vec3 dm = vec3(p.mat);\n  \n    vec3 newWorldPos;\n    hitPayload pNew;\n    \n    \n    if(p.mat > 4.0 && p.mat < 5.0)\n    {\n        color = vec3(0.60);\n        int nbStep;\n        vec3 rdref = refract(p.dir,p.normal,0.9);\n        p.pos -= p.normal*0.1;\n        pNew = trace(p);\n        p.pos += p.normal*0.1;\n        newWorldPos = pNew.pos;\n        dm.xy = vec2(pNew.mat);\n    }\n    \n    p.mat = dm.y;\n    \n    //prevent tilling in the water pit\n    if(dm.z < 4.0 || dm.z > 5.0)\n    {\n        if(p.mat > 2.0 ) //floor\n        {\n            //floor tilling \n            if(mod(floor(p.pos.xz*0.25), 2.0) == vec2(0.) || mod(floor(p.pos.xz*0.25), 2.0) == vec2(1.))\n                color = vec3(0.6);\n            else\n                color = vec3(0.3);\n\n        }\n    }\n    \n    //tentacle shading\n    //explanation is a bit more ditail here since\n    //the code look a bit messy\n    if(p.mat > 3.0)\n    {\n        \n        // Calculate the background color\n        vec3 background = Water(p.dir) * 0.3;\n\n        // Calculate the specular occlusion based on the distance from the black hole\n        float specOcc = clamp(0.5 * length(p.pos - vec3(blackHolePos)), 0.0, 1.0);\n\n        // Define color constants\n        vec3 c1 = vec3(0.67, 0.1, 0.05);    // Reddish color\n        vec3 c2 = vec3(0.1, 0.06, 0.28);    // Dark blue color\n\n        // Calculate the base color based on the normal\n        vec3 baseColor = mix(c1, p.normal.y > 0.0 ? c1 : c2, smoothstep(vec3(0.0), vec3(0.8), p.normal));\n\n        // Calculate the reflection vector\n        vec3 reflVec = reflect(p.dir, p.normal);\n\n        // Calculate the Fresnel term\n        float fresnel = clamp(pow(1.2 + dot(p.dir, p.normal), 5.0), 0.0, 1.0);\n\n        // Combine components to determine the final color based on the specular occlusion\n        color = mix(\n            0.8 * baseColor + 0.6 * Water(reflVec) * mix(0.04, 1.0, fresnel * specOcc),\n            background,\n            0.9 + dot(p.dir, p.normal) * specOcc\n        );\n    }\n    if(dm.z > 4.0 && dm.z < 5.0) //water pit\n    {\n        color *= 4.5/((distance(newWorldPos,p.pos)-0.1)*20.);\n\n    }\n\n    return color;\n}\n\n\n///// RENDERING FUNCTION /////\n\n//this is the quick way to obtain a invervse view matrix\n//go to common to see alternative way with a long process\nmat4 getInvViewMatrix(vec3 ro, vec3 at)\n{\n    vec3 ww = normalize(at-ro); //front\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0))); // rigth;\n    vec3 vv = normalize(cross(uu,ww)); // up;\n    \n    return mat4(uu,0.,\n                vv,0.,\n                -ww,0.,\n                0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy - 1.0)/iResolution.y;\n    \n    //init camera para\n    float angle = 5.0*iMouse.x/iResolution.x;\n    float height = 5.0*iMouse.y/iResolution.y;\n    \n    //if screen has not been clicked yet\n    if(iMouse.x == 0.0 )\n    {\n        angle = 89.95;\n        height = 0.5;\n\n    }\n    \n    //ray origin and look at point\n    vec3 ro = vec3(10.0 * cos(angle), 4.0*height, 10.0 * sin(angle));\n    vec3 at = vec3(0.0,4.0,0.0);\n    \n    //ray direction\n    vec3 rd = normalize(getInvViewMatrix(ro,at) * vec4(uv,-1.5,1.0)).xyz;\n    \n    //init scope variable\n    vec3 color = vec3(0.0);\n    \n    //Using a struct make the code cleaner and\n    //will also shorten many function \n    hitPayload p = hitPayload(\n        ro, //postion aka origin at first\n        rd, //ray direction\n        vec3(0.0), //normal\n        -1.0, //material\n        0, //number of step\n        0.0 //total distance\n    );\n        \n    \n    //preform ray-marching\n    p = trace(p);\n    \n    //compute normal and get color\n    p.normal = calcNormal(p.pos);\n    color = getColor(p);\n    \n    //perform color grading before shadow (prefere this way)\n    color = pow(color,vec3(0.4545));\n    \n    /***** SHADOW *****/\n    //change the direction throward the bh\n    p.dir =  normalize(blackHolePos - p.pos);\n    \n    //apply shadow on everything exect the sky\n    if(p.mat > 0.0)\n    {\n        color *= clamp(dot(p.normal, p.dir), 0.0, 1.0 );\n        color *= smoothstep(50.0,20.0,length(p.pos.xz));\n    }\n    \n    //trace the shadow troward the blackhole\n    //if anyhing else that the sky or bh is hit then it in shadow\n    p.pos += p.normal*0.001;\n    p = trace(p);\n    if(p.mat > 1.0) color *= 0.3;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///// STRUCTURE /////\n\nstruct hitPayload\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 normal;\n    float mat;\n    int nbStep;\n    float totalDist;\n};\n\n\n///// CONSTANTE /////\n\nconst float PI = atan(1.0)*4.0;\n\n///// SDF FUNCION /////\n//https://iquilezles.org/articles/distfunctions/\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n///// SDF OPERATION /////\n// https://iquilezles.org/articles/distfunctions/\n\nfloat opUnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat opSubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nmat2 rot(in float a)\n{\n    a *= 0.0174533;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n///// DOMAIN REPETITION /////\n\n// found on the demogroup website : https://mercury.sexy/hg_sdf/\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n///// TENTACLE /////\n//based on this shader : https://www.shadertoy.com/view/MdsBz2\n//modify to not use smooth and saturate and small tweek to rotate the whole sdf\n\nfloat Tentacle( vec3 p , float nbTentacle, float iTime, sampler2D iChannel0)\n{    \n\n    //polar mod and rotation + displacement in world\n    float c = pModPolar(p.xz,nbTentacle);\n    p.xy *= rot(-60.0 + cos(sin(iTime + c))*3.0);\n    p.y += 0.6;\n    \n    float scale = 1.0 - 2.5 * clamp( abs( p.y ) * 0.25,0.,1. );    \n    \n    p -= vec3( 1.0, -0.5, 0.0 );\n    \n    //controle the length\n    p.xy *= rot(60.0);\n    p.x -= sin( p.y * 5.0 + iTime * 1.6 ) * 0.05;\n    p.z -= cos( p.x * 5.0 + iTime * 1.6 ) * 0.02;\n\n    vec3 t = p;    \n\n    float ret = sdCapsule( p, vec3( 0.0, -1000.0, 0.0 ), vec3( 0.0, 1000.0, 0.0 ), 0.25 * scale );\n    \n    p.z = abs( p.z );\n    p.y = mod( p.y + 0.08, 0.16 ) - 0.08;\n    p.z -= 0.12 * scale;\n    float tent = sdCapsule( p, vec3( 0.0, 0.0, 0.0 ), vec3( -0.4 * scale, 0.0, 0.0 ), 0.1 * scale );\n    \n    float pores = sdSphere( p - vec3( -0.4 * scale, 0.0, 0.0 ), mix( 0.04, 0.1, scale ) );\n    tent = opSubstractRound( tent, pores, 0.01 );\n  \n    ret = opUnionRound( ret, tent, 0.05 * scale );\n    ret += textureLod( iChannel0, vec2( t.xy * 0.5 ), 0. ).x * 0.02;\n\n    return ret;\n}\n\n\n///// PSEUDO-RANDOM FUNCTION /////\n\n//quick and poor function\nfloat frand(vec2 st)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 hash33(vec3 p){\n    p  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n    return fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n\n///// MATRIX OPERATION /////\n\n// matrix operations\nmat4 translate(vec3 t)\n{\n \treturn mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(t,1.)\n        );\n}\nmat4 translateInv(vec3 t)\n{\n \treturn translate(-t);   \n}\n\nmat4 scale(vec3 s)\n{\n \treturn mat4(\n        vec4(s.x,0.,0.,0.),\n        vec4(0.,s.y,0.,0.),\n        vec4(0.,0.,s.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\nmat4 scaleInv(vec3 s)\n{\n \treturn scale(1./s);   \n}\n\nmat4 rightToLeft()\n{\n    // 1 0 0  0\n    // 0 1 0  0\n    // 0 0 -1 0\n    // 0 0 0  1\n \treturn scale(vec3(1.,1.,-1.));\n}\n\nmat4 rightToLeftInv()\n{\n    // same matrix\n    return rightToLeft();\n}\n\t\n\nmat4 ortho(float l, float r, float b, float t, float n, float f)\n{\n\n    \n       // translation and scale\n    return scale(vec3(2./(r-l),2./(t-b),2./(f-n))) * \n                 translate(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.));\n    \n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f)\n{\n    return translateInv(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.)) *\n        scaleInv(vec3(2./(r-l),2./(t-b),2./(f-n)));\n}\n\nmat4 projection(float n, float f)\n{\n \t// n 0 0 0\t0\n    // 0 n 0 0\t0\n    // 0 0 n+f\t-fn\n    // 0 0 1\t0\n    return mat4(\n        vec4(n,0.,0.,0.),\n        vec4(0.,n,0.,0.),\n        vec4(0.,0.,n+f,1.),\n        vec4(0.,0.,-f*n,0.)\n        );\n}\n\nmat4 projectionInv(float n, float f)\n{\n \t// 1/n \t0 \t0 \t\t0\n    // 0 \t1/n\t0 \t\t0\n    // 0\t0\t0 \t\t1\n    // 0\t0\t-1/fn\t(f+n)/fn\n    \n    return mat4(\n        vec4(1./n,0.,0.,0.),\n        vec4(0.,1./n,0.,0.),\n        vec4(0.,0.,0.,-1./(f*n)),\n        vec4(0.,0.,1.,(f+n)/(f*n))\n        );\n}\n\n\nmat4 perspective(float fov, float aspect, float n, float f)\n{\n \t   float l = 1.0 / tan(fov*n);\n       float b = l/aspect;\n    \n    \treturn ortho(-l,l,-b,b,n,f)*\n            projection(n,f)*rightToLeft();\n}\n\n\nmat4 perspectiveInv(float fov, float aspect,float n, float f)\n{\n     float l = 1.0 / tan(fov*n);\n       float b = l/aspect;\n    \n    return rightToLeftInv()*\n        projectionInv(n,f)*\n        orthoInv(-l,l,-b,b,n,f);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[571, 571, 591, 591, 1277], [1279, 1298, 1330, 1330, 2150], [2182, 2182, 2209, 2209, 2452], [2455, 2523, 2550, 2550, 2804], [2912, 2912, 2935, 2935, 2966], [2968, 2968, 2991, 2991, 3610], [3613, 3683, 3712, 3712, 5877], [5912, 6027, 6068, 6068, 6327], [6329, 6329, 6386, 6386, 8122]], "test": "untested"}
{"id": "msccRn", "name": "ooooh", "author": "Yety", "description": "This is pretty close to what i wanted to achieve.\n\nplay with columns and waves in Buffer C to get some nice effects. \nor swap from a circle distance function to any other distance function.", "tags": ["diffusion"], "likes": 0, "viewed": 204, "published": 3, "date": "1694670242", "time_retrieved": "2024-07-30T17:33:54.072901", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    uv.x -= .5;\n    uv.x *= aspect;\n    uv.x += .5;\n\n    vec4 arrow = texture(iChannel0, uv);\n    fragColor = texture(iChannel1, uv+arrow.yz);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 cuv = (uv-.5);\n    vec2 nuv = normalize(uv);\n    \n    vec4 v = vec4(0,0,0,0);\n    \n    //circle distance\n    float d = sqrt(cuv.x*cuv.x + cuv.y*cuv.y)*2.-.5;\n    //angle\n    float a = (atan(cuv.y, cuv.x)+3.14159)/2./3.14159;\n    \n    float d2 = (.125 - (d-.125) * (d-.125))*8.;\n    \n    if(d2 <= 0.)\n        fragColor = vec4(0,0,0,1);\n    else {\n        float d3 = d2 * d2;\n        fragColor = vec4(d3, d3 * nuv.x, d3 * nuv.y, a);\n    }\n   \n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 cuv = (uv-.5);\n    vec2 nuv = normalize(uv);\n    \n    vec4 v = vec4(0,0,0,0);\n    \n    //line distance\n    float d = cuv.y*2.;\n    //x\n    float a = cuv.x;\n    \n    float d2 = d * d;\n    d2 = (.125 - d2)*8.;\n    \n    if(d2 <= 0.)\n        fragColor = vec4(0,0,0,1);\n    else {\n        float d3 = d2 * d2;\n        fragColor = vec4(d3, 0, d*2., a);\n    }\n   \n}", "buffer_b_inputs": [], "buffer_c_code": "float modulo(float a, float b){\n   return (a)-(floor((a)/(b))*(b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //my goal is for buffer A to represent any distance function. maybe in the future it can include negative values.\n    //then this program should take any 0-1 values and produce an animation representing inward flow where inward means it heads toward the \n\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    //ichannel0 has yz component representing distance from the circle.\n    //x represents scalar distance from the circle\n    \n    //circle distance function\n    vec4 arrow = texture(iChannel0, uv);\n    //line distance function\n    //vec4 arrow = texture(iChannel1, uv);\n    float d = arrow.x;\n    float dx = arrow.y;\n    float dy = arrow.z;\n    float angle = arrow.w;\n    \n    float columns = 100.;\n    float waves = 25.;\n\n    float arrowColumns  = mod(angle*columns, 1.)-.5;\n    int arrowIndex = int(angle*columns);\n    \n    if(arrowColumns < 0.)\n        arrowColumns *= -1.;\n    arrowColumns = sqrt(arrowColumns);\n    \n\n    \n    //rolling value 0-1\n    float roll = modulo(iTime-d-float(arrowIndex)/(columns/waves), 1.)-.5;\n    \n    float roll2 = roll * roll;\n    \n    float redVal = roll2*d;\n    \n\n\n    if(arrow.x > 0.)\n        // Output to screen\n        fragColor = vec4(redVal, redVal*dx,redVal*dy,1.);\n    else \n        fragColor = vec4(0.,0.,0.,0.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msccRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 299]], "test": "untested"}
{"id": "ms3yRr", "name": "Fork Flower puz milana 344", "author": "milana", "description": "Try to match the given flower patterns!\n\nBrownie points: how do you change the color of the flower from the center?", "tags": ["circle"], "likes": 1, "viewed": 112, "published": 3, "date": "1694666824", "time_retrieved": "2024-07-30T17:33:54.959530", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n    vec2 p = (2.0 * uv-iResolution.xy);\n    p = rotatePoint2d(p, vec2(0.0, 0.0), iTime);\n\n    float a = atan(p.x,p.y);\n\n    float radModifier1 = cos(a * 8.f) * 90.0f * bias(cos(iTime), 0.5);\n\n    float radModifier2 = triangle(a, 0.3f, 0.8f) * 400.f * gain(sin(iTime), 0.8);\n\n    float d = length(center - uv) - (radius - radModifier1 - radModifier2);\n    float t = clamp(d, 0.0, 1.0);\n    \n    return vec4(color, 1.0 - t);\n\n}\n\n/*\n * Your work here!\n */\nfloat computeRadius(vec2 uv)\n{\n    float radius = 0.25 * iResolution.y;\n    \n    // Centered uv\n    vec2 uvCenter = (2.0f * uv - iResolution.xy);\n    // Get pixel angle around the center\n    float a = atan(uvCenter.x,uvCenter.y);\n    \n    return radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = vec2(iResolution.x * 0.4, iResolution.y * 0.5);\n\tfloat radius = computeRadius(uv);\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(230.0, 230.0, 250.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(255.f, 255.f, 255.f);\n    vec3 black = rgb(0.f, 0.f, 0.f);\n    vec4 layer2 = circle(uv, vec2(iResolution.x * 0.6, iResolution.y * 0.5), \n        radius, black);\n\tvec4 layer3 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n    fragColor = mix(fragColor, layer3, layer3.a);\n\n}", "image_inputs": [], "common_code": "/*\n * Toolbox functions! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */ \nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\nfloat gain(float g, float t) {\n    if (t < 0.5f) {\n        return bias(1.f - g, 2.f * t) / 2.f;\n    } else {\n        return 1.f - bias(1.f - g, 2.f - 2.f * t) / 2.f;\n    }\n}\n\n/*\n * Basic Utilities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */\n\nfloat triangle(float x, float freq, float amp) {\n    float modTerm = mod((x * freq), amp);\n    float halfAmp = 0.5f * amp;\n    return abs(modTerm - halfAmp);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\n/*\n * Make a vec3 color from rgb values [0, 255]\n */\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3yRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 130, 191, 191, 617], [619, 645, 675, 675, 900], [902, 902, 959, 959, 1519]], "test": "untested"}
{"id": "md3yRr", "name": "Puzzle 2 milana 142", "author": "milana", "description": "Try to match the given flower patterns!\n\nBrownie points: how do you change the color of the flower from the center?", "tags": ["circle"], "likes": 0, "viewed": 120, "published": 3, "date": "1694665174", "time_retrieved": "2024-07-30T17:33:55.791306", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n    // Get distance of point from center, get difference from given radius\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n    // If point is smaller than radius, set color alpha to 1, otherwise 0\n\treturn vec4(color, 1.0 - t);\n}\n\n/*\n * Your work here!\n */\n\nfloat computeRadius(vec2 uv)\n{\n    float radius = 0.25 * iResolution.y;\n            \n    // Centered uv\n    vec2 uvCenter = (2.0f * uv - iResolution.xy);\n    \n    uvCenter = rotatePoint2d(uvCenter, vec2(0.0, 0.0), iTime);\n    // Get pixel angle around the center\n    float a = atan(uvCenter.x,uvCenter.y);  \n    \n    float time = sin(iTime * 2.5) * 0.75;\n\n    radius *= time * triangle(a / 4.f, 10.f, 2.f);\n    radius += 150.f;\n    \n    return radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = computeRadius(uv);\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "/*\n * Toolbox functions! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */ \nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\n/*\n * Basic Utilities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */\n\nfloat triangle(float x, float freq, float amp) {\n    float modTerm = mod((x * freq), amp);\n    float halfAmp = 0.5f * amp;\n    return abs(modTerm - halfAmp);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\n/*\n * Make a vec3 color from rgb values [0, 255]\n */\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3yRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 130, 191, 266, 449], [478, 478, 508, 508, 931], [933, 933, 990, 990, 1333]], "test": "untested"}
{"id": "cdcyRr", "name": "2DPGA + CIRCLE, SEGMENT, TANGENT", "author": "ENDESGA", "description": "CIRCLE: CYAN\nSEGMENT: MAGENTA\nTANGENT: YELLOW", "tags": ["algebra", "geometric", "projective", "pga"], "likes": 9, "viewed": 208, "published": 3, "date": "1694662999", "time_retrieved": "2024-07-30T17:33:56.722815", "image_code": "// 2D PROJECTIVE GEOMETRIC ALGEBRA\n// copyright ENDESGA 2023\n\n#define M iMouse.xy\n#define W iResolution.x\n#define H iResolution.y\n#define point vec2\n#define pair vec4\n#define line vec3\n#define circle vec3\n#define EPSILON 0.0001\n#define INFINITY 1e7\n#define AA( uv ) ( 0.5 * ( dFdx( uv.x ) + dFdy( uv.y ) ) )\n\n#define CYAN vec4( 0, 1, 1, 1 )\n#define MAGENTA vec4( 1, 0, 1, 1 )\n#define YELLOW vec4( 1, 1, 0, 1 )\n\n// line that joins two points\nline join( point P1, point P2 )\n{\n\treturn vec3( P1.y - P2.y, P2.x - P1.x, P1.x * P2.y - P1.y * P2.x );\n}\n\n// point that meets two lines\npoint meet( line L1, line L2 ) {\n    return point( L1.y * L2.z - L1.z * L2.y, L1.z * L2.x - L1.x * L2.z ) / ( L1.x * L2.y - L1.y * L2.x );\n}\n\n// perpendicular bisector between two points\nline bisect( point P1, point P2 ) {\n    return line( 2. * ( P1 - P2 ), dot( P2, P2 ) - dot( P1, P1 ) );\n}\n\n// circle that links three points\ncircle link(in point a, in point b, in point c) {\n    point t = b - a;\n    b = c - a;\n    float d = 2. * (t.x * b.y - t.y * b.x);\n    c = t * dot(b, b);\n    b *= dot(t, t);\n    t = point(b.y - c.y,c.x - b.x) / d;\n    return circle(t + a, length(t));\n}\n\n// \"distance\" between line and point\nfloat dist( line L, point P )\n{\n\treturn ( P.x * L.x + P.y * L.y );\n}\n\n// \"distance\" between point and line\nfloat dist( point P, line L )\n{\n\treturn ( dist( L, P ) + L.z ) / ( L.x * L.x + L.y * L.y );\n}\n\n// project point to line\npoint project( point P, line L )\n{\n\treturn P - ( dist( P, L ) * L.xy );\n}\n\n// project line to point\nline project( line L, point P )\n{\n\treturn line( L.xy, -( P.x * L.x + P.y * L.y ) );\n}\n\n// reflect point across line (2x projection)\npoint mirror( point P, line L )\n{\n\treturn P - ( 2. * dist( P, L ) * L.xy );\n}\n\n// reflect line across point (2x projection)\nline mirror(line L, point P) {\n    return line(L.xy, L.z - 2. * ( ( L.x * L.x + L.y * L.y ) * dist( P, L )));\n}\n\n// pair of points tangent of a point and circle\n// thanks mla, elenzil, jeyko: https://www.shadertoy.com/view/DtBBWc\n// simplified by me\npair tangents(point P, circle C)\n{\n    P -= C.xy;\n    float d = dot( P, P ) / ( C.z * C.z );\n    P = P / d;\n    point t = ( vec2( -P.y, P.x ) * sqrt( d - 1. ) );\n    return pair( P + C.xy + t, P + C.xy - t );\n}\n\n// line from the tangents of a point and circle\nline segment(point P, circle C)\n{\n    pair t = tangents( P, C );\n    return join( t.xy, t.zw );\n}\n\n// pair of points that intersect a circle\npair intersect(line L, circle C)\n{\n    point p = project(C.xy,L);\n    float d = distance(C.xy,p);\n    vec2 n = normalize(vec2(-L.y, L.x)) * sqrt(C.z * C.z - d * d);\n    return pair(p - n, p + n);\n}\n\n//\n\nvec4 draw_col = vec4( 0 );\n\nvoid draw_line( in vec2 uv, in line L, in vec4 line_col )\n{\n\tfloat dist = abs( dist( L, uv ) + L.z ) / length( L.xy );\n\tfloat aa = AA( uv );\n\tdraw_col = mix( draw_col, line_col, smoothstep( aa, -aa, dist - 1.5 ) );\n}\n\nvoid draw_point( in vec2 uv, point P, in vec4 point_col )\n{\n\tfloat dist = length( uv - P );\n\tfloat aa = AA( uv );\n\tdraw_col = mix( draw_col, point_col, smoothstep( aa, -aa, dist - 7.5 ) );\n}\n\nvoid draw_circle(in vec2 uv, in circle C, in vec4 circle_col) {\n    float aa = AA( uv );\n    draw_col = mix( draw_col, circle_col, smoothstep( aa, -aa, abs(length(uv - C.xy) - C.z) - 1.5 ) );\n    draw_point( uv, point( C.x, C.y ), circle_col * .5 );\n}\n\nvoid mainImage( out vec4 col, in vec2 uv )\n{\n    // I prefer working in pixel space rather than normalised\n    point p_mouse = (iMouse.z <= 0.) ? point((W/2.)+(sin(iTime)*( W / 5. ))+( W / 10. ),(H/2.)+(sin(iTime)*( H / 5. ))+( H / 10. )) : M;\n    point p_1a = point( ( W / 10. ), ( H / 2. ) - ( sin( iTime * 2. ) * ( H / 4. ) ) );\n\tpoint p_1b = point( ( W / 2. ) - ( cos( iTime * 2. ) * ( W / 4. ) ), ( H / 10. ) );\n    line l_1 = join(p_1a,p_1b);\n    point p_3 = point( W-( W / 10. ), H-( H / 10. ));\n    circle c_1 = link( p_mouse, p_1a, p_1b );\n    \n    pair t_ab = tangents( p_3, c_1 );\n    point t_a = t_ab.xy, t_b = t_ab.zw;\n    \n    draw_point( uv, p_mouse, CYAN );\n    draw_point( uv, p_1a, CYAN );\n    draw_point( uv, p_1b, CYAN );\n    draw_circle( uv, c_1, CYAN );\n    draw_circle( uv, link( p_3, p_mouse, t_b ), CYAN );\n    draw_point( uv, p_3, YELLOW );\n    \n    draw_line( uv, segment(p_3,c_1), MAGENTA );\n    draw_line( uv, join(p_3,t_a), YELLOW );\n    draw_line( uv, join(p_3,t_b), YELLOW );\n    draw_point( uv, t_a, MAGENTA );\n    draw_point( uv, t_b, MAGENTA );\n\n\tcol = draw_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 441, 474, 474, 545], [547, 577, 609, 609, 717], [719, 764, 799, 799, 869], [871, 905, 954, 954, 1156], [1158, 1195, 1226, 1226, 1263], [1265, 1302, 1333, 1333, 1395], [1397, 1422, 1456, 1456, 1495], [1497, 1522, 1555, 1555, 1607], [1609, 1654, 1687, 1687, 1731], [1733, 1778, 1808, 1808, 1889], [1891, 2028, 2062, 2062, 2238], [2240, 2288, 2321, 2321, 2385], [2387, 2429, 2463, 2463, 2626], [2660, 2660, 2719, 2719, 2876], [2878, 2878, 2937, 2937, 3068], [3070, 3070, 3133, 3133, 3321], [3323, 3323, 3367, 3429, 4422]], "test": "untested"}
{"id": "ddccRn", "name": "Tor Loading Bar", "author": "01000001", "description": "doodle. idk I was bored waiting for Tor to launch", "tags": ["doodle", "thingy"], "likes": 1, "viewed": 49, "published": 3, "date": "1694654521", "time_retrieved": "2024-07-30T17:33:57.574538", "image_code": "void mainImage( out vec4 O, vec2 U ){\n\n    vec2 uv = U/iResolution.xy;\n    \n    uv.y = 1.0-uv.y;\n\n    O = mix(vec4(1, 0, 1, 1), vec4(0, .8, 1, 1), smoothstep(0., 1., uv.x))*.9;\n    \n    float t = mod(iTime*.2,1.);\n    O *= uv.y<.03 && mod(iTime, 2.) < 1.8?1.:1./(uv.y*(mod(iTime, 2.)>1.8?10.:60.));\n    O *= vec4(uv.x < t);\n    O *= uv.y<.03?1.:uv.x+.1 < t?1.:sqrt(1.-pow((-uv.x + t)*10.-1., 2.));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddccRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 404]], "test": "untested"}
{"id": "ds3cRn", "name": "it cool", "author": "TheMaxee", "description": "I followed a tutorial and I tested something but it's cool, so there you go", "tags": ["cool"], "likes": 0, "viewed": 92, "published": 3, "date": "1694654285", "time_retrieved": "2024-07-30T17:33:58.403322", "image_code": "vec3 palette( float t ) { \n    vec3 a = vec3(0.500, 0.500, 0.500); \n    vec3 b = vec3(-0.532, -0.422, 0.318);\n    vec3 c = vec3(-1.362, 1.000, 1.000);\n    vec3 d = vec3(-1.222, -0.002, 3.138);\n\n    return a + b+cos(6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    \n    vec3 col = palette(d);\n    \n    d = sin(d*0.5 + iTime*1.)/8.;\n\n    d = 0.02 / d;\n    \n    col *= d * 8.5;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3cRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 235], [237, 237, 294, 294, 550]], "test": "untested"}
{"id": "clBfWV", "name": "Loading Screen(GDSMBCZY)", "author": "GDSMBCZY", "description": "I was trying stuff with noise and then this happened. It looks like a loading screen.", "tags": ["public"], "likes": 0, "viewed": 127, "published": 3, "date": "1694640771", "time_retrieved": "2024-07-30T17:33:59.273994", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat Circle(vec2 uv, float r, float blur){\n    float d = length(uv);\n    d = smoothstep(r, r-blur, d);\n    \n    return rand(vec2(d, d));\n    //return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uv0 = uv;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float d = Circle(uv, 1.3, 1.3);\n    \n    //d *= sin(iTime*5.);\n    \n    d -= rand(vec2(d, d+rand(vec2(iTime, -iTime))));\n    \n    d = smoothstep(uv0.x+1., iTime/10., d);\n    \n    col += vec3(d, d, d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [89, 89, 132, 132, 244], [246, 246, 303, 303, 700]], "test": "untested"}
{"id": "clBfRt", "name": "woven strings", "author": "77Tigers", "description": "any feedback on how to make it look nicer is welcome! (thank you shane)\n(also if anyone is still getting a black screen please tell me)", "tags": ["woven", "strings"], "likes": 4, "viewed": 181, "published": 3, "date": "1694640050", "time_retrieved": "2024-07-30T17:34:00.149653", "image_code": "#define EPS 0.001\n#define PI 3.1419526535\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\n// rotate around axis\nvec3 rot_around(vec3 v, vec3 axis, float deg) {\n    vec3 height_v = axis * dot(v, axis);\n    vec3 proj_v = v - height_v;\n    return height_v + cos(deg) * proj_v + sin(deg) * cross(axis, proj_v);\n}\n\n// nicked this from https://www.shadertoy.com/view/MtsGWH, thanks iq\n// \"p\" point apply texture to\n// \"n\" normal at \"p\"\n// \"k\" controls the sharpness of the blending in the\n//     transitions areas.\n// \"s\" texture sampler\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k ) {\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvec2 get_dists(vec3 r) {\n    // 1 and 2 represent the two diagonals\n    vec3 r1 = mat3x3(\n        cos(PI * 0.25), sin(PI * 0.25), 0.0,\n        -sin(PI * 0.25), cos(PI * 0.25), 0.0,\n        0.0, 0.0, 1.0\n    ) * r;\n    \n    vec3 r2 = r1.yxz;\n    \n    vec3 r1_floor = vec3(mod(r1.x - 1., 2.) - 1., r1.yz);\n    vec3 r2_floor = vec3(mod(r2.x - 1., 2.) - 1., r2.yz);\n    \n    float dist1 = length(r1_floor.xz - vec2(0.0, 0.5 *\n        -cos((r1.y * .5 + floor(r1.x * .5 - .5)) * PI)\n    )) - 0.5;\n    float dist2 = length(r2_floor.xz - vec2(0.0, 0.5 *\n        cos((r2.y * .5 + floor(r2.x * .5 - .5)) * PI)\n    )) - 0.5;\n    \n    // neighbours\n    dist1 = min(length(r1_floor.xz + vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        -cos((r1.y * .5 + 1. + floor(r1.x * .5 - .5)) * PI)\n    )) - 0.5, dist1);\n    dist1 = min(length(r1_floor.xz - vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        -cos((r1.y * .5 - 1. + floor(r1.x * .5 - .5)) * PI)\n    )) - 0.5, dist1);\n    dist2 = min(length(r2_floor.xz + vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        cos((r2.y * .5 + 1. + floor(r2.x * .5 - .5)) * PI)\n    )) - 0.5, dist2);\n    dist2 = min(length(r2_floor.xz - vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        cos((r2.y * .5 - 1. + floor(r2.x * .5 - .5)) * PI)\n    )) - 0.5, dist2);\n    \n    return vec2(dist1, dist2);\n}\n\nfloat sdf (vec3 r) {\n    // 1 and 2 represent the two diagonals\n    vec2 dists = get_dists(r);\n    \n    float dist1 = dists.x;\n    float dist2 = dists.y;\n    \n    // floor\n    float distf = r.z + 0.7;\n    \n    return min(min(dist1, dist2) * .6, distf);\n}\n\nfloat sdf (ray r) {\n    return sdf(r.pos);\n}\n\n// sdf norm\n// thanks to shane for feedback\nvec3 sdfn (vec3 pos) {\n    float f = sdf(pos);\n    vec2 e = vec2(EPS * 10.0, 0.0);\n    \n    return normalize(vec3(\n        (f - sdf(pos + e.xyy)),\n        (f - sdf(pos + e.yxy)),\n        (f - sdf(pos + e.yyx))\n    ));\n}\n\n// keep going until too far or too close\n// thanks to shane for feedback\nvoid march (inout ray r) {\n    for (int i = 0; i < 500; i++) {\n        float dist = sdf(r);\n        \n        if (dist < EPS || dist > 100.) {\n            return;\n        }\n        r.pos += dist * r.dir;\n    }\n}\n\nvec3 col (ray r) {\n    vec3 base_col = vec3(0.0);\n    \n    vec3 norm = sdfn(r.pos);\n    vec3 rfl = reflect(r.dir, norm);\n    float sq2 = sqrt(2.);\n    vec2 mcoords = mod(r.pos.xy - sq2 * .25, sq2 * .5) - sq2 * .25;\n    \n    vec2 dists = get_dists(r.pos);\n    float dist1 = dists.x;\n    float dist2 = dists.y;\n    \n    if (r.pos.z <= -.69) {\n        base_col = vec3(1.0);\n        \n        // vec3(0.2) + sin(30. * (r.pos.x)) * sin(30. * (r.pos.y)) * .2 +\n        if (length(mcoords) < .3 && length(mcoords) > .15) {\n            base_col = vec3(0.8, 0.4, 0.0) * .1 + .9 * 1.;\n        }\n        vec3 result = base_col + .1 * texture(iChannel1, rfl).rgb * dot(norm, vec3(1.0, 1.0, 1.0));\n        result += min(dist1 * dist1 * 1. - .5, 0.);\n        result += min(dist2 * dist2 * 1. - .5, 0.);\n        result = clamp(result, 0.0, 1.0);\n        return sqrt(result);\n    } else {\n        if (dist1 < 0.01) {\n            base_col = boxmap(iChannel0, mat3x3(1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0) * r.pos * .5, norm, 0.5 ).rgb;\n        } else {\n            base_col = 0.75 * boxmap(iChannel0, mat3x3(1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 0.0, 0.0, 1.0) * r.pos * .5, norm, 0.5 ).rgb;\n        }\n    }\n    if (dist1 > 0.01) {\n        base_col *= min(.3 + dist1 * 1.5, 1.0);\n    }\n    if (dist2 > 0.01) {\n        base_col *= min(.3 + dist2 * 1.5, 1.0);\n    }\n    if (dist1 < 0.01 && dist2 < 0.01) {\n        base_col = vec3(0.0);\n    }\n    return .9 * base_col;\n    \n}\n\nvec3 trace (inout ray r) {\n    march(r);\n    float d = sdf(r);\n    \n    if (d > 100.) {\n        return vec3(1.0, 1.0, 1.0);\n    } else if (d < EPS) {\n        return col(r);\n    } else {\n        return vec3(0.5);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.0*(fragCoord - vec2(iResolution.x/2.0, iResolution.y/2.0))/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    ray r = ray(vec3(25. * vec2(cos(iTime * 0.1), sin(iTime * 0.1)), 5.0), rot_around(\n        normalize(vec3(p, 1.)),\n        vec3(1., 0., 0.),\n        PI * (1.0 )//+ 0.05 * sin(iTime) - 0.05)\n    ));\n    \n    col = trace(r);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 110, 157, 157, 306], [308, 530, 595, 616, 820], [822, 822, 846, 889, 2102], [2104, 2104, 2124, 2167, 2358], [2360, 2360, 2379, 2379, 2404], [2406, 2450, 2472, 2472, 2669], [2671, 2744, 2770, 2770, 2954], [2956, 2956, 2974, 2974, 4410], [4412, 4412, 4438, 4438, 4631], [4633, 4633, 4690, 4690, 5112]], "test": "untested"}
{"id": "dl2BDd", "name": "Fractal Basic Test", "author": "insurgentes300", "description": "fractal use in glsl", "tags": ["fractal", "basics"], "likes": 4, "viewed": 128, "published": 3, "date": "1694637904", "time_retrieved": "2024-07-30T17:34:01.138010", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 normalizedCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n    \n    float angle = iTime * 0.1;\n    \n    for (float i = 0.0; i < 48.0; i += 1.0) {\n        normalizedCoord = abs(normalizedCoord);\n        normalizedCoord -= 0.5;\n        normalizedCoord *= 1.1;\n        normalizedCoord *= mat2 (\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n            \n        );\n        \n    \n    }\n    \n    fragColor = vec4(length(normalizedCoord),\n    length(normalizedCoord + vec2(0.2, -0.3)),\n    length(normalizedCoord + vec2(-0.4, 0.1)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2BDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 626]], "test": "untested"}
{"id": "dtjfWd", "name": "Checkerboard 8x8 Pattern", "author": "bronnie", "description": "Fullscreen checkerboard pattern", "tags": ["checkerboard", "fullscreen", "pattern", "mask"], "likes": 0, "viewed": 123, "published": 3, "date": "1694636608", "time_retrieved": "2024-07-30T17:34:01.901968", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    //uv.x *= iResolution.x / iResolution.y;\n    \n    float size = 8.0;\n    \n    //vec2 Pos = size*uv;\n    vec2 Pos = floor(size*uv);     // floor effectively does steps\n    //vec2 Pos = floor((.75+0.25*sin(0.25*iTime))*size*uv);\n    \n    float PatternMask = mod(Pos.x + mod(Pos.y, 2.0), 2.0);\n    vec4 res = PatternMask * vec4(1.0, 1.0, 1.0, 1.0);\n    \n    res.w = 1.0;\n    //res.w = uv.x*uv.y;\n    fragColor = res;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 516]], "test": "untested"}
{"id": "mlBBWd", "name": "Fork Flower puz Zaleki 651", "author": "Zaleki", "description": "Try to match the given flower patterns!\n\nBrownie points: how do you change the color of the flower from the center?", "tags": ["circle"], "likes": 0, "viewed": 105, "published": 3, "date": "1694630657", "time_retrieved": "2024-07-30T17:34:02.837467", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n    // Get distance of point from center, get difference from given radius\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n    // If point is smaller than radius, set color alpha to 1, otherwise 0\n\treturn vec4(color, 1.0 - t);\n}\n\n/*\n * Your work here!\n */\nfloat computeRadius(vec2 uv)\n{\n    float radius = 0.25 * iResolution.y;\n    \n    // Centered uv\n    vec2 uvCenter = (2.0f * uv - iResolution.xy);\n    // Get pixel angle around the center\n    float a = atan(uvCenter.x, uvCenter.y);\n    \n    float t = 2.0 * sin(iTime * 0.5);\n    \n    float e = exp(-(t * t) / 0.5);\n    \n    float sinFunc = sin(a * 20.0) * 45.0 * e;\n    \n    return radius + sinFunc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = computeRadius(uv);\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 215.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "/*\n * Toolbox functions! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */ \nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\n/*\n * Basic Utilities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */\n\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\n/*\n * Make a vec3 color from rgb values [0, 255]\n */\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 130, 191, 266, 449], [451, 477, 507, 507, 877], [879, 879, 936, 936, 1279]], "test": "untested"}
{"id": "ct2fDt", "name": "Fork Fork Flowe Zaleki 124", "author": "Zaleki", "description": "Try to match the given flower patterns!\n\nBrownie points: how do you change the color of the flower from the center?", "tags": ["circle"], "likes": 0, "viewed": 125, "published": 3, "date": "1694620039", "time_retrieved": "2024-07-30T17:34:03.713125", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{   \n    // Get distance of point from center, get difference from given radius\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n    // If point is smaller than radius, set color alpha to 1, otherwise 0\n\treturn vec4(color, 1.0 - t);\n}\n\n/*\n * Your work here!\n */\nfloat computeRadius(vec2 uv)\n{\n    float radius = 0.25 * iResolution.y;\n    float timeScale = 1.0;\n    \n    // Centered uv\n    vec2 uvCenter = (2.0f * uv - iResolution.xy);\n    // Get pixel angle around the center\n    float a = atan(uvCenter.x, uvCenter.y) + iTime + length(uvCenter) / 100.0 * sin(iTime * timeScale * Pi / 4.0);\n    \n    float d = length(uv);\n    \n    float triangle = abs(a - 1.0);\n    \n    float freq = 5.0;\n    \n    return radius + abs(fract((a / Pi) * freq * 0.5) - 0.5) * 175.0 * sin(iTime * timeScale);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n    \n\tfloat radius = computeRadius(uv);\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 215.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "/*\n * Toolbox functions! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */ \nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\n/*\n * Basic Utilities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */\n\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\n/*\n * Make a vec3 color from rgb values [0, 255]\n */\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nconst float Pi = 3.1415926535897932;", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2fDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 130, 191, 269, 452], [454, 480, 510, 510, 1007], [1009, 1009, 1066, 1066, 1414]], "test": "untested"}
{"id": "cljBWt", "name": "Fork Flower puz Zaleki 338", "author": "Zaleki", "description": "Try to match the given flower patterns!\n\nBrownie points: how do you change the color of the flower from the center?", "tags": ["circle"], "likes": 0, "viewed": 142, "published": 3, "date": "1694620033", "time_retrieved": "2024-07-30T17:34:04.478080", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{   \n    // Get distance of point from center, get difference from given radius\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n    // If point is smaller than radius, set color alpha to 1, otherwise 0\n\treturn vec4(color, 1.0 - t);\n}\n\n/*\n * Your work here!\n */\nfloat computeRadius(vec2 uv)\n{\n    float radius = 0.25 * iResolution.y;\n    float timeScale = 1.0;\n    \n    // Centered uv\n    vec2 uvCenter = (2.0f * uv - iResolution.xy);\n    // Get pixel angle around the center\n    float a = atan(uvCenter.x, uvCenter.y) - iTime;\n    \n    float d = length(uv);\n    \n    float triangle = abs(a - 1.0);\n    \n    float freq = 5.0;\n    \n    return radius + abs(fract((a / Pi) * freq * 0.5) - 0.5) * 175.0 * sin(iTime * timeScale);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n    \n\tfloat radius = computeRadius(uv);\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 215.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "/*\n * Toolbox functions! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */ \nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\n/*\n * Basic Utilities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */\n\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\n/*\n * Make a vec3 color from rgb values [0, 255]\n */\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nconst float Pi = 3.1415926535897932;", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 130, 191, 269, 452], [454, 480, 510, 510, 944], [946, 946, 1003, 1003, 1351]], "test": "untested"}
{"id": "Dt2BDt", "name": "Flower Puzzle 3", "author": "IwakuraRein", "description": "CIS 566 Lab 01", "tags": ["2d"], "likes": 0, "viewed": 99, "published": 3, "date": "1694618656", "time_retrieved": "2024-07-30T17:34:05.307862", "image_code": "#define PI   3.1415926535897932384626433832795\n#define PI_2 1.5707963267948966192313216916398\n#define PI_4 0.78539816339744830961566084581988\n\n// https://www.pcg-random.org/\nuint pcg(inout uint state)\n{\n  uint prev = state * 747796405u + 2891336453u;\n  uint word = ((prev >> ((prev >> 28u) + 4u)) ^ prev) * 277803737u;\n  state     = prev;\n  return (word >> 22u) ^ word;\n}\n// [0, 1)\nfloat rand(inout uint seed)\n{\n  uint r = pcg(seed);\n  return uintBitsToFloat(0x3f800000u | (r >> 9)) - 1.0f;\n}\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n    if (d < -rad * 0.5) return vec4(0.0);\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n    vec2 uv2 = uv-center;\n    float angle = atan(uv2.y, uv2.x) + iTime;\n    if (angle > PI) angle -= PI;\n    float saw = (angle + PI) * 4.0 / PI;\n    saw = saw - float(int(saw));\n    saw *= PI_2;\n    if (saw > PI_4) saw += PI_2;\n    radius += (sin(saw) * 50.0 + sin(iTime * 2.0) * 50.0) * sin(iTime);\n    \n\t// Circle\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2BDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 174, 202, 202, 371], [372, 382, 411, 411, 492], [493, 539, 576, 576, 625], [627, 706, 761, 761, 901], [903, 903, 960, 960, 1606]], "test": "untested"}
{"id": "ct2BDt", "name": "M3 Colors", "author": "Ric3cir121", "description": "An approximation of M3 Material Design Colors\n\nIs there anything wrong? Let me know!", "tags": ["color", "material", "material", "android", "monet"], "likes": 0, "viewed": 129, "published": 3, "date": "1694618469", "time_retrieved": "2024-07-30T17:34:06.216432", "image_code": "/*\nEstimated colors from top to bottom:\nsystem_accent1_0\nsystem_accent2_0\nsystem_accent3_0\nsystem_neutral1_0\nsystem_neutral2_0\n*/\n\nvec3 hsl_rgb(vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n    return c.z+c.y*(rgb-.5)*(1.-abs(2.*c.z-1.));\n}\nvoid mainImage(out vec4 o,vec2 u){\n    int v = int((u.y/iResolution.y)*5.);\n    \n    // hue, chroma and tone (also called hue, saturation and brightness)\n    float hue = mod(iTime/20.,1.) + (v==2?.17:.0);\n    float saturation = v==0?.08:(v==1?.04:(v==2?.24:(v==3?.16:.36))); // chroma\n    float brightness = floor(u.x/iResolution.x*10.)/9.; // tone\n    \n    vec3 col = hsl_rgb(vec3(hue,saturation,brightness));\n    o = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2BDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 152, 152, 270], [271, 271, 305, 305, 704]], "test": "untested"}
{"id": "mlSBDd", "name": "Flower Puzzle 2", "author": "IwakuraRein", "description": "CIS 566 Lab 01", "tags": ["2d"], "likes": 0, "viewed": 91, "published": 3, "date": "1694616825", "time_retrieved": "2024-07-30T17:34:07.112038", "image_code": "#define PI   3.1415926535897932384626433832795\n#define PI_2 1.5707963267948966192313216916398\n#define PI_4 0.78539816339744830961566084581988\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n    \n    vec2 uv2 = uv-center;\n    \n    float angle = atan(uv2.y, uv2.x) + iTime;\n    float saw = (angle + PI) * 2.5 / PI;\n    saw = saw - float(int(saw));\n    saw *= PI_2;\n    if (saw > PI_4) saw += PI_2;\n    radius += sin(saw) * 100.0 * sin(iTime);\n    \n\t// Circle\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 189, 226, 226, 275], [277, 356, 411, 411, 509], [511, 511, 568, 568, 1164]], "test": "untested"}
{"id": "dtSBDd", "name": "Get The Ball!", "author": "wyatt", "description": "Fun N-body simulation. (Interactive)", "tags": ["nbody"], "likes": 44, "viewed": 452, "published": 3, "date": "1694616767", "time_retrieved": "2024-07-30T17:34:08.136299", "image_code": "Main {\n    if ((int(U.x+U.y)+I)%2==0) {\n    \n        Q = vec4(0);\n        float d = 1e9;\n        float w = 0.;\n        for (float i = 0.; i < N; i++) {\n            vec4 a = A(vec2(i,0));\n            a.xy = a.xy*R.y+vec2(.5*R.x-.5*R.y,0);\n            vec4 _ = init(i,float(I)/60.);\n            float _d = length(U-a.xy)-_.z*R.y;\n            if (_d < d) d = _d, w = i;\n        }\n        \n        Q = 1.-smoothstep(2.,0.,d)*(.5+.5*sin(1.5+floor(w/T)+w/T+vec4(1,2,3,4)));\n        Q *= smoothstep(0.,2.,abs(d)-1.);\n    } else discard;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T 350.\n#define N (T*2. + 1.)\n\n#define R iResolution.xy\n#define I iFrame\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n\n#define Main void mainImage(out vec4 Q, in vec2 U) \n#define pi 3.14159265359\n\nvec4 init (float i, float t) {\n    vec4 o = vec4(0);\n    if (i < T) {\n        float s = i/T;\n        o.z = .002+.02*(1.-i/T);\n        o.xy = vec2(.25+.1*(1.-s)*sin(4.*6.2*s*s-.4*t)+o.z*cos(pi*i),.9*s);\n        o.w = 1.;\n    } else if (i < 2.*T) {\n        i -= T;\n        float s = i/T;\n        o.z = .002+.02*(1.-i/T);\n        o.xy = vec2(.75+.1*(1.-s)*cos(4.*6.2*s*s+.4*t)+o.z*cos(pi*i),.9*s);\n        o.w = 2.;\n    } else {\n        o.xy = vec2(.5,.8);\n        o.z = .04;\n        o.w = 3.;\n    }\n    return o;\n}", "buffer_a_code": "Main {\n    U = floor(U);\n    if (U.y>1.||U.x>=N) discard;\n    Q = A(U);\n    vec4 Q0 = Q;\n    vec4 O = init(U.x,float(I)/60.);\n    \n    vec2 f = vec2(0,-3e-4*O.z);\n    for (float i = 0.; i < N; i++) {\n        vec4 q = A(vec2(i,0));\n        vec4 o = init(i,float(I)/60.);\n        vec2 r = q.xy-Q.xy;\n        float l = length(r);\n        float L = length(o.xy-O.xy);\n        \n        if (l > 0. && O.w == o.w) {\n        \n                f -= r/l*(L-l)/T*o.z*exp(-50.*L)*500.;\n        \n        }\n        if (L > 1.7*(o.z+O.z) || o.w != O.w) {\n            \n                \n                f += .1*r/l*clamp(l-1.1*(o.z+O.z+.005),-1.,0.);\n            \n        }\n        \n    }\n    \n    if (U.x < 2.*T) {\n        vec4 q = A(vec2(2.*T,0));\n        vec2 r = Q.xy - q.xy;\n        float l = length(r);\n        if (l>0.)\n        f -= .0001*r/l*exp(-2.*l);\n    }\n     \n     if (iMouse.z>0.) {\n        vec2 r = Q.xy - (iMouse.xy/R.y-vec2(.5*R.x-.5*R.y,0)/R.y);\n        float l = length(r);\n        if (l > 0.) \n        f += .001*r/l*exp(-2.*l);\n    }\n    {\n        float m = (.01+O.z*O.z);\n        if (O.w == 3.) m = .1;\n        f = f/m;\n        f = .03*f*inversesqrt(1.+dot(f,f));\n        Q.zw += f;\n        Q.xy += f + .03*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n        \n        \n        if (Q.y - O.z< 0.) Q.y = O.z, Q.w = abs(Q.w);\n        if (Q.x - O.z< .5-.5*R.x/R.y) \n            Q.x = .5-.5*R.x/R.y + O.z, Q.z = abs(Q.z);\n        if (Q.x + O.z> .5+.5*R.x/R.y) \n            Q.x = .5+.5*R.x/R.y- O.z, Q.z = -abs(Q.z);\n        if (Q.y + O.z> 1.) Q.y = 1.-O.z, Q.w = -abs(Q.w);\n        \n    }\n    if (U.x < 2.*T)\n    Q = mix(Q0,Q,clamp(mod(U.x,T)-10.,0.,1.));\n    \n    if (I < 1) {\n    \n        Q = vec4(init (U.x,0.).xy, 0,0);\n        \n    }\n    \n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    U = floor(U);\n    if (U.y>1.||U.x>=N) discard;\n    Q = A(U);\n    vec4 Q0 = Q;\n    vec4 O = init(U.x,float(I)/60.);\n    \n    vec2 f = vec2(0,-3e-4*O.z);\n    for (float i = 0.; i < N; i++) {\n        vec4 q = A(vec2(i,0));\n        vec4 o = init(i,float(I)/60.);\n        vec2 r = q.xy-Q.xy;\n        float l = length(r);\n        float L = length(o.xy-O.xy);\n        \n        if (l > 0. && O.w == o.w) {\n        \n                f -= r/l*(L-l)/T*o.z*exp(-50.*L)*500.;\n        \n        }\n        if (L > 1.7*(o.z+O.z) || o.w != O.w) {\n            \n                \n                f += .1*r/l*clamp(l-1.1*(o.z+O.z+.005),-1.,0.);\n            \n        }\n        \n    }\n    \n    if (U.x < 2.*T) {\n        vec4 q = A(vec2(2.*T,0));\n        vec2 r = Q.xy - q.xy;\n        float l = length(r);\n        if (l>0.)\n        f -= .0001*r/l*exp(-2.*l);\n    }\n     \n     if (iMouse.z>0.) {\n        vec2 r = Q.xy - (iMouse.xy/R.y-vec2(.5*R.x-.5*R.y,0)/R.y);\n        float l = length(r);\n        if (l > 0.) \n        f += .001*r/l*exp(-2.*l);\n    }\n    {\n        float m = (.01+O.z*O.z);\n        if (O.w == 3.) m = .1;\n        f = f/m;\n        f = .03*f*inversesqrt(1.+dot(f,f));\n        Q.zw += f;\n        Q.xy += f + .03*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n        \n        \n        if (Q.y - O.z< 0.) Q.y = O.z, Q.w = abs(Q.w);\n        if (Q.x - O.z< .5-.5*R.x/R.y) \n            Q.x = .5-.5*R.x/R.y + O.z, Q.z = abs(Q.z);\n        if (Q.x + O.z> .5+.5*R.x/R.y) \n            Q.x = .5+.5*R.x/R.y- O.z, Q.z = -abs(Q.z);\n        if (Q.y + O.z> 1.) Q.y = 1.-O.z, Q.w = -abs(Q.w);\n        \n    }\n    if (U.x < 2.*T)\n    Q = mix(Q0,Q,clamp(mod(U.x,T)-10.,0.,1.));\n    \n    if (I < 1) {\n    \n        Q = vec4(init (U.x,0.).xy, 0,0);\n        \n    }\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    U = floor(U);\n    if (U.y>1.||U.x>=N) discard;\n    Q = A(U);\n    vec4 Q0 = Q;\n    vec4 O = init(U.x,float(I)/60.);\n    \n    vec2 f = vec2(0,-3e-4*O.z);\n    for (float i = 0.; i < N; i++) {\n        vec4 q = A(vec2(i,0));\n        vec4 o = init(i,float(I)/60.);\n        vec2 r = q.xy-Q.xy;\n        float l = length(r);\n        float L = length(o.xy-O.xy);\n        \n        if (l > 0. && O.w == o.w) {\n        \n                f -= r/l*(L-l)/T*o.z*exp(-50.*L)*500.;\n        \n        }\n        if (L > 1.7*(o.z+O.z) || o.w != O.w) {\n            \n                \n                f += .1*r/l*clamp(l-1.1*(o.z+O.z+.005),-1.,0.);\n            \n        }\n        \n    }\n    \n    if (U.x < 2.*T) {\n        vec4 q = A(vec2(2.*T,0));\n        vec2 r = Q.xy - q.xy;\n        float l = length(r);\n        if (l>0.)\n        f -= .0001*r/l*exp(-2.*l);\n    }\n     \n     if (iMouse.z>0.) {\n        vec2 r = Q.xy - (iMouse.xy/R.y-vec2(.5*R.x-.5*R.y,0)/R.y);\n        float l = length(r);\n        if (l > 0.) \n        f += .001*r/l*exp(-2.*l);\n    }\n    {\n        float m = (.01+O.z*O.z);\n        if (O.w == 3.) m = .1;\n        f = f/m;\n        f = .03*f*inversesqrt(1.+dot(f,f));\n        Q.zw += f;\n        Q.xy += f + .03*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n        \n        \n        if (Q.y - O.z< 0.) Q.y = O.z, Q.w = abs(Q.w);\n        if (Q.x - O.z< .5-.5*R.x/R.y) \n            Q.x = .5-.5*R.x/R.y + O.z, Q.z = abs(Q.z);\n        if (Q.x + O.z> .5+.5*R.x/R.y) \n            Q.x = .5+.5*R.x/R.y- O.z, Q.z = -abs(Q.z);\n        if (Q.y + O.z> 1.) Q.y = 1.-O.z, Q.w = -abs(Q.w);\n        \n    }\n    if (U.x < 2.*T)\n    Q = mix(Q0,Q,clamp(mod(U.x,T)-10.,0.,1.));\n    \n    if (I < 1) {\n    \n        Q = vec4(init (U.x,0.).xy, 0,0);\n        \n    }\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    U = floor(U);\n    if (U.y>1.||U.x>=N) discard;\n    Q = A(U);\n    vec4 Q0 = Q;\n    vec4 O = init(U.x,float(I)/60.);\n    \n    vec2 f = vec2(0,-3e-4*O.z);\n    for (float i = 0.; i < N; i++) {\n        vec4 q = A(vec2(i,0));\n        vec4 o = init(i,float(I)/60.);\n        vec2 r = q.xy-Q.xy;\n        float l = length(r);\n        float L = length(o.xy-O.xy);\n        \n        if (l > 0. && O.w == o.w) {\n        \n                f -= r/l*(L-l)/T*o.z*exp(-50.*L)*500.;\n        \n        }\n        if (L > 1.7*(o.z+O.z) || o.w != O.w) {\n            \n                \n                f += .1*r/l*clamp(l-1.1*(o.z+O.z+.005),-1.,0.);\n            \n        }\n        \n    }\n    \n    if (U.x < 2.*T) {\n        vec4 q = A(vec2(2.*T,0));\n        vec2 r = Q.xy - q.xy;\n        float l = length(r);\n        if (l>0.)\n        f -= .0001*r/l*exp(-2.*l);\n    }\n     \n     if (iMouse.z>0.) {\n        vec2 r = Q.xy - (iMouse.xy/R.y-vec2(.5*R.x-.5*R.y,0)/R.y);\n        float l = length(r);\n        if (l > 0.) \n        f += .001*r/l*exp(-2.*l);\n    }\n    {\n        float m = (.01+O.z*O.z);\n        if (O.w == 3.) m = .1;\n        f = f/m;\n        f = .03*f*inversesqrt(1.+dot(f,f));\n        Q.zw += f;\n        Q.xy += f + .03*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n        \n        \n        if (Q.y - O.z< 0.) Q.y = O.z, Q.w = abs(Q.w);\n        if (Q.x - O.z< .5-.5*R.x/R.y) \n            Q.x = .5-.5*R.x/R.y + O.z, Q.z = abs(Q.z);\n        if (Q.x + O.z> .5+.5*R.x/R.y) \n            Q.x = .5+.5*R.x/R.y- O.z, Q.z = -abs(Q.z);\n        if (Q.y + O.z> 1.) Q.y = 1.-O.z, Q.w = -abs(Q.w);\n        \n    }\n    if (U.x < 2.*T)\n    Q = mix(Q0,Q,clamp(mod(U.x,T)-10.,0.,1.));\n    \n    if (I < 1) {\n    \n        Q = vec4(init (U.x,0.).xy, 0,0);\n        \n    }\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtBfWd", "name": "Flower Puzzle 1", "author": "IwakuraRein", "description": "CIS 566 Lab 01", "tags": ["2d"], "likes": 0, "viewed": 103, "published": 3, "date": "1694616217", "time_retrieved": "2024-07-30T17:34:08.989019", "image_code": "/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n\t\n    vec2 uv2 = uv-center;\n    float angle = atan(uv2.y, uv2.x);\n    radius += sin(angle * 20.0) * 50.0 * pow(sin(iTime * 0.5), 6.0);\n    \n\t// Circle\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 83, 83, 132], [134, 213, 268, 268, 366], [368, 368, 425, 425, 905]], "test": "untested"}
{"id": "clSBDd", "name": "Ray-line segment intersection", "author": "jeyko", "description": ".", "tags": ["ray", "line", "intersection"], "likes": 7, "viewed": 236, "published": 3, "date": "1694609367", "time_retrieved": "2024-07-30T17:34:09.848721", "image_code": "\nvec2 rayLineIntersect(\n    vec2 ro,\n    vec2 rd,\n    vec2 A,\n    vec2 B,\n    out vec2 norm\n){\n    // dot(N, ro + rd * k - A) = 0\n    // dot(N, ro - A) + dot(N,rd*k) = 0\n    // dot(N,rd*k) = -dot(N, ro - A)\n    // k * dot(N,rd) = -dot(N, ro - A)\n    // k = -dot(N, ro - A) / dot(N,rd)\n    \n    \n    vec2 Tan = (B - A);\n    vec2 N = vec2(Tan.y,-Tan.x);\n    \n    \n    float k = -dot(N, ro - A)/dot(N,rd);\n    \n    if(k < 0.){\n        return vec2(0);\n    }\n    \n    vec2 p = ro + rd * k;\n    \n    float proj = dot(Tan, p - A);\n    \n    if(proj < 0. || proj > dot(Tan,Tan)){\n        return vec2(0);\n    }\n    \n    norm = -N;\n    if(dot(-rd, norm) < 0.0){\n        norm = -norm;\n    }\n    \n    return ro + rd * k;\n}\n\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define pi acos(-1.)\n\n// From iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 ro = -vec2(0.5,0.);\n    \n    vec2 rd = normalize(vec2(muv - ro));\n    \n    if(iFrame == 0){\n        //ro = vec2(0.4);\n        rd = normalize(-ro);\n    }\n    \n    vec2 A = vec2(sin(iTime),cos(iTime))*0.2;\n    vec2 B = vec2(sin(iTime + 3.14),cos(iTime + 3.14))*0.2;\n    \n    vec2 norm;\n    \n    vec2 c = rayLineIntersect(\n        ro, rd, A, B, norm\n    );\n    float sd = 1000.0;\n    \n    sd = min(sd, length(ro - uv) - 0.02);\n    sd = min(sd, length(c - uv) - 0.02);\n    sd = min(sd, sdSegment(uv,A,B) - 0.002);\n    sd = min(sd, sdSegment(uv,ro,c) - 0.002);\n    \n    sd = min(sd, sdSegment(uv,c,c + norm*0.3) - 0.002);\n    \n    \n    \n    col += smoothstep(fwidth(uv.y),0.,sd);\n    \n    col = 1.-col;\n    col = pow(col,vec3(0.454545));\n    C = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 94, 284, 709], [787, 798, 849, 849, 968], [970, 970, 1010, 1010, 1924]], "test": "untested"}
{"id": "clBfWt", "name": "Radar Circle", "author": "MaxShaders", "description": "Radar", "tags": ["radar"], "likes": 0, "viewed": 151, "published": 3, "date": "1694604575", "time_retrieved": "2024-07-30T17:34:10.610683", "image_code": "#define PI 3.141592653\n\nfloat distToSegment( vec2 ps1, vec2 ps2, vec2 point)\n{\n    vec2 pa = point - ps1;\n    vec2 ba = ps2 - ps1;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = fragCoord.xy;\n    vec2 midpoint = iResolution.xy / 2.0;\n    vec3 col = vec3(0);\n    const vec3 green = vec3(0.0, 1.0, 0.0);\n    const vec3 blue = vec3(0.35,0.76,0.83);\n    float lineThickness = 1.0;\n    float rayLen = sqrt(pow(iResolution.x, 2.0) + pow(iResolution.y, 2.0));\n    float radius = min(iResolution.x, iResolution.y) * 0.45;\n    \n    const float period = 5.0;\n    float angle = 0.0;\n    float rotPercent = mod(-iTime, period) / period;\n    angle = 2.0 * PI * rotPercent;\n    vec2 rayDir = vec2(cos(angle), sin(angle));\n    vec2 rayPerp = vec2(-sin(angle), cos(angle));\n    vec2 pixelDir = normalize(pixel - midpoint);\n    \n    //Trail\n    if(dot(rayDir, pixelDir) > 0.0 && dot(pixelDir, rayPerp) > 0.0)\n    {\n        col = green * pow(dot(rayDir, pixelDir), 1.0) * 0.4;\n        \n    }\n    \n    //Ray\n    float distToRay = distToSegment(midpoint, midpoint + rayDir * rayLen, pixel);\n    if(distToRay <= lineThickness)\n    {\n        col = green * (lineThickness / distToRay) ;//- 3.0 * ( distance(pixel, midpoint) / radius);\n    }\n    \n    //Circle\n    if(true)\n    {\n        float distToCircle = abs(distance(midpoint, pixel) - radius);\n        if(distToCircle <= lineThickness * 2.0)\n        {\n            col += green * (1.0 - (distToCircle / (lineThickness * 2.0)));\n        }\n    \n        if(distance(midpoint, pixel) > radius + 2.)\n        {\n            col = vec3(0.0);\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 78, 78, 221], [223, 223, 280, 280, 1738]], "test": "untested"}
{"id": "mt2BDV", "name": "sRGB Dithering", "author": "ttg", "description": "Comparison of various wrong, good, better and best sRGB dithering/quantization.\n\nMouse up/down: select method,\nMouse left to right selects mode: temporal, average over time, plot proportionate error, average longer time.", "tags": ["dithering", "srgb"], "likes": 8, "viewed": 237, "published": 3, "date": "1694587233", "time_retrieved": "2024-07-30T17:34:11.725702", "image_code": "/*\n\nsRGB Dithering\nhttps://www.shadertoy.com/view/mt2BDV\n\nComparison of various wrong, good, better and best sRGB dithering/quantization.\n\nMouse up/down: select method,\nMouse left to right selects mode:\n  temporal, average over time, plot proportionate error, average longer time.\n\n\nCopyright 2023-2024 Theron Tarigo.  All rights reserved.\n\nThis shader may be copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this shader is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/mt2BDV\", is displayed within the source.\n\n*/\nvec3 description (int method, bool isadj, bool isprop, vec2 uv);\n\nvoid mainImage (out vec4 ImgOut, vec2 f) {\n  vec2 R = iResolution.xy;\n  ivec2 I = ivec2(f);\n  ivec2 N = ivec2(R);\n  int rs = N.y/nrows;\n  int rb = I.y/rs*rs;\n  int i = nrows-1-I.y/rs;\n  vec2 u = f/R;\n\n  vec3 O = vec3(0.);\n  \n  int my = int(iMouse.y);\n  int methodsel=nrows-1-my/rs;\n  if(iMouse.y==0.)methodsel=8;\n  int rbm = (nrows-1-methodsel)*rs;\n  \n  if(u.x<.5) {\n    O = texture(iChannel0,u*vec2(2,1)).rrr;\n    //if(I.y==rbm+rs/2) O.g=1.;\n    ImgOut.rgb = O;\n    /* re-render the visual reference gradient at high quality using the best dither option */ if(i==9) for(int c=0;c<2;c++) ImgOut[c]=display_dither(8,hash(I.x+N.x*I.y)^iFrame,64,EOTF(O[c]));\n  } else {\n    u.x=u.x*2.-1.;\n    vec4 d = texelFetch(iChannel1,ivec2(u.x*R.x,rbm),0);\n    float y,t,s=exp2(3.-float(nbits));\n    \n    if(u.x<.03&&abs(float(rbm+rs/2-I.y)/R.y)<.5*u.x) O.g=1.;\n    \n    bool isadj = (methodsel>=5&&methodsel<=7);\n    bool isprop = (iMouse.x/R.x>.8);\n    \n    O+=description(methodsel,isadj,isprop,u);\n    \n    if(isprop) d=.5*d/d.w;\n    \n    y=u.y; t=1./R.y;\n    // grey plot: exact value\n    if (t>abs(-y+d.w)) O+=.1;\n    // blue plot: average result\n    if (t>abs(-y+d.x)) O.b++;\n    \n    y=(u.y*2.-1.)*.2*s; t=.4/R.y*s;\n    // grey plot: zero line\n    if (t>abs(-y)) O+=.1;\n    // red plot: error\n    if (t>abs(-y+d.x-d.w)) O.r++;\n    \n    y=u.y*.1*s*s; t=.1/R.y*s*s;\n    // green plot: variance (noise)\n    if (t>abs(-y+d.y)) O.g++;\n    ImgOut.rgb = IEOTF(O);\n  }\n}\n\nconst uint[] str_method =\n  STRING8(8, M,e,t,h,o,d,_,_);\n  \nconst uint[] str_method0 =\n  STRING16(9, N,o,_,d,i,t,h,e,r,_,_,_,_,_,_,_);\nconst uint[] str_method1 =\n  STRING32(17, R,P,D,F,_,b,e,f,o,r,e,_,I,E,O,T,F,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);\nconst uint[] str_method2 =\n  STRING32(17, T,P,D,F,_,b,e,f,o,r,e,_,I,E,O,T,F,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);\nconst uint[] str_method3 =\n  STRING32(16, R,P,D,F,_,a,f,t,e,r,_,I,E,O,T,F,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);\nconst uint[] str_method4 =\n  STRING32(32, T,P,D,F,_,a,f,t,e,r,_,I,E,O,T,F,_,lp,w,i,t,h,_,c,l,i,p,p,i,n,g,rp);\nconst uint[] str_method5 =\n  STRING32(30, T,P,D,F,_,a,f,t,e,r,_,I,E,O,T,F,_,lp,n,o,_,c,l,i,p,p,i,n,g,rp,_,_);\nconst uint[] str_method6 =\n  STRING32(31, T,P,D,F,cm,_,h,a,c,k,y,_,l,i,n,e,a,r,_,q,u,a,n,t,i,z,a,t,i,o,n,_);\nconst uint[] str_method7 =\n  STRING32(31, R,P,D,F,cm,_,o,p,t,i,c,a,l,l,y,_,l,i,n,e,a,r,_,q,u,a,n,t,i,z,pe,_);\nconst uint[] str_method8 =\n  STRING32(24, V,a,r,i,a,n,c,e,_,p,r,o,b,a,b,i,l,i,t,y,_,m,i,x,_,_,_,_,_,_,_,_);\nconst uint[] str_method9 =\n  STRING32(17, E,x,a,c,t,_,lp,r,e,f,e,r,e,n,c,e,rp,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);\n\nconst uint[] str_key0 =\n  STRING8(7, A,v,e,r,a,g,e,_);\nconst uint[] str_key1 =\n  STRING8(5, E,r,r,o,r,_,_,_);\nconst uint[] str_key2 =\n  STRING8(8, V,a,r,i,a,n,c,e);\n\nconst uint[] str_scaleabs =\n  STRING16(14, A,b,s,o,l,u,t,e,_,s,c,a,l,e,_,_);\nconst uint[] str_scaleprop =\n  STRING32(19, P,r,o,p,o,r,t,i,o,n,a,t,e,_,s,c,a,l,e,_,_,_,_,_,_,_,_,_,_,_,_,_);\nconst uint[] str_adjusted =\n  STRING16(8, A,d,j,u,s,t,e,d,_,_,_,_,_,_,_,_);\n\nvec3 description (int method, bool isadj, bool isprop, vec2 u) {\n#define tex iChannel2\n  u.y=1.-u.y;\n  u*=vec2(36,20);\n  u.x-=2.;\n  float x=u.x;\n  vec3 v=vec3(0);\n  if(method<9) {\n    u.x=x;\n    v+= draw_string(tex,u, str_method), u.x-=6.+1.;\n    v+= draw_string(tex,u,uint[2](1u,uint(0x30+method)));\n    u.y--;\n  }\n  u.x=x;\n  if(method==0) v+= draw_string(tex,u,str_method0);\n  if(method==1) v+= draw_string(tex,u,str_method1);\n  if(method==2) v+= draw_string(tex,u,str_method2);\n  if(method==3) v+= draw_string(tex,u,str_method3);\n  if(method==4) v+= draw_string(tex,u,str_method4);\n  if(method==5) v+= draw_string(tex,u,str_method5);\n  if(method==6) v+= draw_string(tex,u,str_method6);\n  if(method==7) v+= draw_string(tex,u,str_method7);\n  if(method==8) v+= draw_string(tex,u,str_method8);\n  if(method==9) v+= draw_string(tex,u,str_method9);\n  v*=.2;\n  u.y--;\n  v+= vec3(0,0,1)*draw_string(tex,u,str_key0), u.x-=7.+2.;\n  v+= vec3(1,0,0)*draw_string(tex,u,str_key1), u.x-=5.+2.;\n  v+= vec3(0,1,0)*draw_string(tex,u,str_key2), u.x-=8.+2.;\n  u.y--;\n  u.x=x;\n  if(isadj) v+= vec3(.2)*draw_string(tex,u,str_adjusted), u.x-=8.+1.;\n  if(isprop) v+= vec3(.2)*draw_string(tex,u,str_scaleprop);\n  else       v+= vec3(.2)*draw_string(tex,u,str_scaleabs);\n  return v;\n}\n\n/*\nCopyright 2023-2024 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// config tests\n\nconst int nbits = 4;\n\n#define EOTF srgb_eotf\n#define IEOTF srgb_ieotf\n\n//#define EOTF gamma22_eotf\n//#define IEOTF gamma22_ieotf\n\n\n\n#define T vec4\n\nT srgb_ieotf (T c) {\n  return mix(12.92*c,1.055*pow(c,T(1./2.4))-.055,step(.0031308,c));\n}\n\nT srgb_eotf (T e) {\n  return mix(e/12.92,pow((e+.055)/1.055,T(2.4)),step(.04045,e));\n}\n\nT gamma22_ieotf (T c) {\n  return pow(c,T(1./2.2));\n}\n\nT gamma22_eotf (T e) {\n  return pow(e,T(2.2));\n}\n\n// generics\n#define OVERLOAD_VECN(N) \\\n  float N (float v) { return N(vec4(v)).x; } \\\n  vec2 N (vec2 v) { return N(v.xyxx).xy; } \\\n  vec3 N (vec3 v) { return N(v.xyzx).xyz; }\nOVERLOAD_VECN(srgb_ieotf)\nOVERLOAD_VECN(srgb_eotf)\nOVERLOAD_VECN(gamma22_ieotf)\nOVERLOAD_VECN(gamma22_eotf)\n\n#undef T\n\nuint hash_triple32(uint x) {\n  // https://nullprogram.com/blog/2018/07/31/\n  x ^= x >> 17;\n  x *= 0xED5AD4BBu;\n  x ^= x >> 11;\n  x *= 0xAC4C1B51u;\n  x ^= x >> 15;\n  x *= 0x31848BABu;\n  x ^= x >> 14;\n  return x;\n}\n#define hash hash_triple32\nint hash(int x) { return int(hash(uint(x))); }\n\n\nfloat probmix(float A, float B, float C, float var, float rnd) {\n  float PB = clamp((A*C+var)/((B-A)*(B-C)),0.,.75);\n  float PA = mix(C,B,PB)/(C-A);\n  /* float PC = 1.-PA-PB; */\n  \n  // sanity check probabilities\n  // some fail, but with insignificant consequence\n  //if(PA<0.||PC<0.)return 10.;\n  //if(PA>1.||PC>1.)return 10.;\n\n  if(rnd<PA)\n    return A;\n  if(rnd<PA+PB)\n    return B;\n  /* if(rnd<PA+PB+PC) */ // cum prob = 1\n    return C;\n}\n\nconst int nrows = 10;\n\nfloat display_dither (int method, int seed, int nlevels, float x) {\n\n  float qres = 1./float(nlevels-1);\n  vec2 rnd = .5*unpackSnorm2x16(hash(uint(seed)));\n  \n  // noise with rectangular probability density function\n  float rpdf = rnd.x;\n  \n  // noise with triangular probability density function\n  float tpdf = rnd.x+rnd.y;\n\n  float r;\n  if (method==0) {\n    // no dither\n    return IEOTF(x);\n  }\n  if (method==1) {\n    // bad: RPDF dither before IEOTF\n    float xd = x + rpdf*.05;\n    return IEOTF(xd);\n  }\n  if (method==2) {\n    // bad: TPDF dither before IEOTF\n    float xd = x + tpdf*.05;\n    return IEOTF(xd);\n  }\n  if (method==3) {\n    // bad: RPDF dither in the space that will be quantized\n    float y = IEOTF(x);\n    y += rpdf*qres;\n    return y;\n  }\n  if (method==4) {\n    // bad: TPDF dither in the space that will be quantized\n    //      with no avoidance of clipping\n    float y = IEOTF(x);\n    y += tpdf*qres;\n    return y;\n  }\n  if (method==5) {\n    // good: TPDF dither in the space that will be quantized\n    // Note that with 8 bit depth, errors are imperceptible.\n    // Any further refinement yields especially high accuracy, or\n    // else improvements noticeable only at lower bit depths.\n    // 6 bits is common for low cost LCDs.\n    x *= (1.-qres);\n    float y = IEOTF(x);\n    y += tpdf*qres;\n    return y;\n  }\n  if (method==6) {\n    // better: quantized space TPDF dither, hacky linear quantization\n    x *= (1.-qres);\n    float y = IEOTF(x);\n    y += tpdf*qres;\n    float yl = floor(y/qres)*qres;\n    float yh = yl+qres;  /* ceil(y/bitres)*bitres */\n    y = 2.*EOTF(y) > EOTF(yl)+EOTF(yh) ? yh : yl;\n    return y;\n  }\n  if (method==7) {\n    // bad: quantized space RPDF dither, optically linear quantization\n    x *= (1.-qres);\n    float y = IEOTF(x);\n    // lower possible value\n    float yc = floor(y/qres)*qres;\n    // delta to upper possible value\n    float yd = qres;\n    // what fraction is optical intensity between these values\n    float f = (x-EOTF(yc))/(EOTF(yc+yd)-EOTF(yc));\n    // select value depending on random threshold\n    y = f-.5>rpdf ? yc+yd : yc;\n    return y;\n  }\n  if (method==8) {\n     // best: probabilistic mix of 3 quantized values for carefully controlled variance\n    float y = IEOTF(x);\n    float yb = round(y/qres)*qres;\n    float A = EOTF(clamp(yb-qres,0.,1.));\n    float B = EOTF(yb);\n    float C = EOTF(clamp(yb+qres,0.,1.));\n    float d = (EOTF(y+.01*qres)-x)/.01; // derivative\n    float var = d*d*.25;\n    //float var = sqrt(x)*.0001;\n    float xd = x+probmix(A-x,B-x,C-x,var,rnd.x+.5);\n    y = IEOTF(xd);\n    y = round(y/qres)*qres;\n    return y;\n  }\n}\n\n\n\n\n////////////////////////////////////////\n\n/*\n\nGLSL character printing library for octaviogood font texture.\nhttps://www.shadertoy.com/view/Wd2SDt\n\nCopyright 2019 Theron Tarigo.  All rights reserved.\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/Wd2SDt\", is displayed prominently\nwithin the source.\n\n*/\n\nconst struct CCDS_T {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CCDS = CCDS_T(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n0x7fu);\n\n#define U4CHAR4(a,b,c,d) ((CCDS.a)+(CCDS.b<<8)+(CCDS.c<<16)+(CCDS.d<<24))\n\n#define STRING8(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7) )\n\n#define STRING16(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af) )\n\n#define STRING32(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf) )\n\n#define STRING64(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df))\n\n#define STRING80(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df,\\\n  e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df),\\\n      U4CHAR4(e0,e1,e2,e3),U4CHAR4(e4,e5,e6,e7),U4CHAR4(e8,e9,ea,eb),U4CHAR4(ec,ed,ee,ef))\n\n#define DEF_DRAW_STRING(N) \\\nfloat draw_string (sampler2D sampler,                    \\\n                   in vec2 uv, const uint[1+N] string) { \\\n  int i = int(uv.x);                                     \\\n  int strlen = min(int(string[0]),N*4);                  \\\n  if (uv.x<0.||i>=strlen) return 0.;                     \\\n  int code = int( (string[i/4+1]>>((i%4)*8)) &0xFFu);    \\\n  if (uv.y<0.||uv.y>1.) return 0.;                       \\\n  uv.x=fract(uv.x)/2.+.25; uv.y=1.-uv.y;                 \\\n  uv+=vec2(code%16,15-code/16);                          \\\n  return texture(sampler, uv/16.).r;                   }\nDEF_DRAW_STRING(1)\nDEF_DRAW_STRING(2)\nDEF_DRAW_STRING(4)\nDEF_DRAW_STRING(8)\nDEF_DRAW_STRING(16)\nDEF_DRAW_STRING(20)\n#undef DEF_DRAW_STRING\n\n    \n/*\nCopyright 2019 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n\n// end of \"GLSL character printing library\"\n////////////////////////////////////////", "buffer_a_code": "/*\n\nhttps://www.shadertoy.com/view/mt2BDV\n\nThis shader may be copied under the terms of the ISC License; see end of file.  As an exception, the full permission notice may be omitted where this shader is copied within Shadertoy.com and the full URL, \"https://www.shadertoy.com/view/mt2BDV\", is displayed within the source.\n\n*/\n\n\n\nvoid mainImage (out vec4 O, vec2 f) {\n  vec2 R = iResolution.xy;\n  ivec2 I = ivec2(f);\n  ivec2 N = ivec2(R);\n  int rs = N.y/nrows;\n  int i = nrows-1-I.y/rs;\n  int seed = I.x+N.x*I.y;\n  seed = hash(seed)^iFrame;\n\n  float x = f.x/R.x;\n  x=x*x*x;\n\n  int nlevels=1<<nbits;\n  float bitres = 1./(exp2(float(nbits))-1.);\n  float y = display_dither(i,seed,nlevels,x);\n\n  // quantize\n  float qres = 1./float(nlevels-1);\n  y = round(y/qres)*qres;\n  y = clamp(y,0.,1.);\n\n  if (i>=5&&i<=7) {\n    x *= (1.-qres);\n  }\n\n  if (i==9) { // reference level\n    y = IEOTF(x);\n  }\n\n  O.x = y;\n  O.w = x;\n}\n\n/*\nCopyright 2023 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/", "buffer_a_inputs": [], "buffer_b_code": "void mainImage (out vec4 O, vec2 f) {\n  vec2 R = iResolution.xy;\n  ivec2 I = ivec2(f);\n  ivec2 N = ivec2(R);\n  int rs = N.y/nrows;\n  int rb = I.y/rs*rs;\n  int i = nrows-1-I.y/rs;\n\n  O = texelFetch(iChannel0,I,0);\n  vec4 d = texelFetch(iChannel1,I,0);\n  vec4 v = vec4(0.);\n  v.rgb = EOTF(d.rgb);\n  \n  if(I.y==rb) {\n    v = vec4(0.);\n    for (int i=0;i<rs;i++) {\n      float x = EOTF(texelFetch(iChannel1,ivec2(I.x,rb+i),0).r);\n      v.x += x;\n      v.y += x*x;\n    }\n    v /= float(rs);\n    v.y -= v.x*v.x;\n    v.w = d.w;\n  }\n  float M=iMouse.x/R.x;\n  O = M<.4?v:mix(O,v,M<.95?.01:.001);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2BDV.jpg", "access": "api", "license": "isc", "functions": [[686, 686, 728, 728, 2142], [3691, 3691, 3755, 3755, 4951]], "test": "untested"}
{"id": "mtjfW3", "name": "Green and black rug (music)", "author": "jarble", "description": "A fractal rug pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "rug"], "likes": 6, "viewed": 182, "published": 3, "date": "1694581190", "time_retrieved": "2024-07-30T17:34:12.516588", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 8; k++){\n        bool b = uv.x>uv.y;\n        uv =\n            abs(.5+uv+t2)/1.5\n            //abs(.5+uv+t2/1.5)\n            //abs(.5+uv+t2)/1.5\n        ;\n        \n        //WOW!\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        \n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        b = uv.y>uv.x || !b;\n        if(b) uv = uv.yx;\n\n        t2 =\n            triangle_wave(uv-.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        //adds more detail\n        //if(uv.x>-.25)\n        col =\n            vec3(col.zx,max(uv.x-uv.y*float(b),0.))\n        ;\n    }\n    fragColor = vec4((col*2.),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "void distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a += mod(floor(a/2.),b);\n    }\n}\n\nfloat fmod(float a, float b){\n    //distort(a,b);\n    \n    //a += abs(mod((a),3.)-mod((a),5.));\n    //a += 2.*floor(1.+mod(floor(a/2.),2.))/(1.+mod(floor(a/4.),2.));\n    //a -= mod(floor(a/2.)/2.,2.)*2.;\n    //a += mod(floor(floor(b/2.)+floor(a/4.)),4.);\n    a += mod(-b/2.,2.);\n    //a /= (1. + mod(floor(a)/2.,2.));\n    //a += mod(-a*2.,2.)/2.;\n    return\n        //floor(mod(mod(a,1.+abs(mod(a,5.)-mod(a,3.))),b))\n        //mod(floor(floor(a)/1.5)+floor(floor(a)/2.),b)\n        floor(mod(mod(floor(a/2.)*3.,b)*mod(floor(a/2.)*5.,b),b))\n        //floor(mod(mod(floor(a)*3.,b/3.+3.)*mod(floor(a)*5.,b/5.+5.),b))\n        //mod(mod(floor(a)+2.,b)*mod(floor((a/2.)/b),b)+2.,b)\n        //floor(mod(mod(floor(a)/b,b)*mod(floor((a)/b)+2.,b)+2.,b))\n        //floor(mod((mod(floor(a),b))*mod(floor(a/b*2.)/2.,b),8.))\n    ;\n}\n\nfloat fmod1(float a, float b){\n    //change the notes without changing the rhythm\n    //a += mod(-b/2.,2.);\n    return\n        fmod(a,b)\n        //fmod(a,b-fmod(a/2.,2.))\n        //fmod(floor(a)*5.,b+fmod(floor(a/8.)*3.,b))\n    ;\n}\n\nfloat prime_rhythm(float time){\n    return (1.+fmod(time/5.,2.))/(1.+fmod(time/3.,2.));\n    //return (1.+fmod(time/2.,2.))*(1.+fmod(time/3.,2.))/(1.+fmod(time/5.,2.))/(1.+fmod(time/7.,2.))*(1.+fmod(time/11.,2.));\n}\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.,\n  tempo1 =\n      //1.\n      //divide by prime numbers to get an interesting rhythm\n      prime_rhythm(time)\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod(t4,2.),\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6,s1/2.)/2.),\n      //floor(2.*fmod(floor(t6)*3.,s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.),\n  a=\n      (1.-log(1./16./2.+fract(t/2./prime_rhythm(time+14.))/2.))*(1.-log(1./16./2.+fract(t/prime_rhythm(time+7.))/4.)),\n  nb =\n      t*pow(2.,(m3+m2-t1*4.)/7.+7.5)*tempo1/2.\n  ;\n  return\n      (log(1./8.+abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //a/8.*log(1./8.+abs(a/8.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n      //abs(log(1.+a)-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n      //abs(1.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 193], [195, 195, 252, 252, 1212]], "test": "untested"}
{"id": "ctjfDc", "name": "Fork Discoteq 3 (+ flim)", "author": "beans_please", "description": "Discoteq 3\nadded flim ( https://www.shadertoy.com/view/dd2yDz )", "tags": ["blur", "lines", "smoothstep", "sinusoidal", "beautiful", "discoteque"], "likes": 6, "viewed": 315, "published": 3, "date": "1694574459", "time_retrieved": "2024-07-30T17:34:13.472033", "image_code": "#define S smoothstep\n#define R iResolution.xy\n#define T iTime\n\nfloat c(vec2 u) { return  S( 5./R.y, 0., abs(length(u) - .25)); }\nfloat t (float s) { return .5 + sin(T * s) * .5; }\nmat2 r (float a) { return mat2(cos(a), sin(-a), sin(a), cos(a)); }\n\nvec3 render(vec2 I)\n{\n    vec2 u =(I-.5*R)/R.y*r(T*.3);\n    vec4 O = vec4(0);\n    for (float i = 0.; i < 1.; i += 1./50.) {\n        float n = cnoise(vec3(u * 2.5  + i * .3, .9 * T + i * 1.2));\n        float l = c(u + n * .14);\n        vec3 c = mix(vec3(t(.4), t(.8), t(3.)), vec3(t(.8), t(1.2), t(.5)), i);\n        O += vec4(l * c * .3, i);\n    }\n    return O.rgb;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    // Linear RGB\n    vec3 col = pow(render(I), vec3(2.2));\n\n    // Saturation\n    col = mix(vec3(dot(col, vec3(1. / 3.))), col, 1.2);\n\n    // flim\n    col = flim_transform(col, -.5, iChannel0);\n\n    // Output\n    O = vec4(col, 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat lerp(float a, float b, float t)\n{\n    return a + t * (b - a);\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return a + t * (b - a);\n}\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n", "buffer_a_code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 80, 80, 128], [129, 129, 148, 148, 179], [180, 180, 198, 198, 246], [248, 248, 269, 269, 614], [616, 616, 657, 675, 891]], "test": "untested"}
{"id": "DljBD3", "name": "reaction diffusion with video ", "author": "mds2", "description": "reaction diffusion but with a video input as a continually applied additive term.\n\nThis is just a slightly more intense version of the shader it was forked from.", "tags": ["mouse", "cellular", "reaction"], "likes": 5, "viewed": 407, "published": 3, "date": "1694562613", "time_retrieved": "2024-07-30T17:34:14.335724", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    \n    \n    mat3 blowout = mat3(1.66666667, -0.33333333, -0.33333333,\n                        -0.33333333,  1.66666667, -0.3333333,\n                        -0.33333333, -0.33333333,  1.6666666);\n    vec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n\n    float weight = 1.0; // play with this value\n    blowout = weight * blowout + (1.0 - weight) * mat3(1.0, 0.0, 0.0,\n                                                       0.0, 1.0, 0.0,\n                                                       0.0, 0.0, 1.0);\n    \n    vec3 dir = blowout * (col - cent);\n    \n    vec3 maxes = (step(vec3(0.0), dir) - col)/dir;\n    \n    float amount = min(maxes.x, min(maxes.y, maxes.z));\n    \n    col = col + dir * amount;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float diffuse_weight = 0.5; // higher means less diffusion.  set greater than 0 and less than 1\nconst float react_weight = 0.24; // reaction speed : don't exceed 0.25.  higher is faster reaction\n\n// in the function \"greatest\" there are two calls to \"color_to_val_4\"\n// change those to \"color_to_val_1\", \"color_to_val_2\" etc to get different effects\n\nvec2 to_uv(in vec2 in_pixels, in vec2 offset) {\n    return mod(in_pixels + offset, iResolution.xy) / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    \n    vec4 color = texture(iChannel1, to_uv(p, vec2(0.0)));\n    \n    // color.rg = mod(10.0 * to_uv(p), vec2(1.0));\n    color.b = 1.0 - 0.5 * color.r - 0.5 * color.g;\n    \n    \n   \n    \n    color = diffuse_weight * texture(iChannel0, to_uv(p, vec2(0.0)));\n    \n    color.rgb = mix(smoothstep(vec3(0.0), vec3(1.0), texture(iChannel2, to_uv(p, vec2(0.0))).rgb), color.rgb, 0.945);\n\n    \n    float w = 0.25 * (1.0 - diffuse_weight);\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(1.1, 0.0))).rgb;\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(0.0, 1.1))).rgb;\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(-1.1, 0.0))).rgb;\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(0.0, -1.1))).rgb;\n    \n    \n    color.rgb = color.rgb + react_weight * (1.0 * color.rgb * color.gbr - color.rgb * color.brg);//  + 0.005;\n    \n    color.a = 1.0;\n    \n    color.rgb = max(vec3(0.0), min(vec3(1.0), color.rgb));\n    \n    float delta = 1.5 - dot(color.rgb, vec3(1.0));\n\n    color += 0.005 * delta;\n \n    fragColor = vec4(color.rgb,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1039]], "test": "untested"}
{"id": "DlBBDc", "name": "WavesPoint", "author": "insurgentes300", "description": "waving of a circle", "tags": ["points"], "likes": 9, "viewed": 254, "published": 3, "date": "1694542343", "time_retrieved": "2024-07-30T17:34:15.280198", "image_code": "precision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy ) -1.0;\n\n\tvec3 col = vec3(0);\n\t\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat r = float(i)*0.01;\t\t\n\t\t\n\t\t\n\t\tcol += vec3(1.0)/(3.0+3000.0*(abs(length(sin(p.x*3237.0+p.y*100.888)*0.050+p.xy-vec2(0,sin(-iTime+float(i)*0.03)*float(i)*0.008))-r))); \n\t\t\n\t}\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 406]], "test": "untested"}
{"id": "DtBBWc", "name": "tangent to circle - Plotz", "author": "elenzil", "description": "Fork of \"Point to line tangent to circle\" by jeyko. https://shadertoy.com/view/DtSBD3.\n\nLeft Top side: Original\nLeft Bot: ENDESGA\nRight: Mike Plot'z\n\nThis approach was suggested by Mike Plotz.\nIt uses a two sqrt()s and zero trig fn()'s.\n", "tags": ["line", "intersection", "circle", "sampling"], "likes": 6, "viewed": 228, "published": 3, "date": "1694540833", "time_retrieved": "2024-07-30T17:34:16.059116", "image_code": "// Fork of \"Point to line tangent to circle\" by jeyko. https://shadertoy.com/view/DtSBD3\n// 2023-09-12 17:26:58\n\n/*\n    solve right triangle, formed by point (ro), circle center (C) and unknown point.\n    beta is the angle on ro.\n    \n    ro\n    rd\n    R\n    C\n\n\n    l = sqrt(dot(ro-C,ro-C))\n\n    l2 = R2 + u2\n\n    u = sqrt(l2 - r2)\n\n    sin(beta) = R/l\n    beta = asin(R/l)\n*/\n\n// From iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv;\n    \n    float t = iTime * 0.3;\n    \n    if (length(iMouse.xy) < 30.0) {\n        muv.x = cos(t * 1.23 + 3.0);\n        muv.y = sin(t * 1.34 + 0.2);\n        muv *= 0.4;\n    }\n    else {\n        muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    }\n\n    vec3 col = vec3(0);\n    \n    vec2 ro = muv*1.;\n    if(iFrame == 0){\n        ro = vec2(0.4);\n    }\n    \n    float R = 0.25;\n    vec2 c = vec2(cos(t), sin(t)) * 0.2;\n    \n    float sd = 1000.0;\n    \n    sd = min(sd, length(ro - uv) - 0.02);\n    sd = min(sd, abs(length(uv - c) - R) - 0.001);\n    \n    vec2 tanPosA;\n    vec2 tanPosB;\n\n    bool hasTans;\n    \n    if (uv.x < 0.0) {\n        if (uv.y > 0.0) {\n            hasTans = CircleTangents(\n                c,\n                R,\n                ro,\n                tanPosA,\n                tanPosB);\n        }\n        else {\n            hasTans = CircleTangents_edg(\n                c,\n                R,\n                ro,\n                tanPosA,\n                tanPosB);\n        }\n    }\n    else {\n        hasTans = CircleTangents_Plotz(\n            c,\n            R,\n            ro,\n            tanPosA,\n            tanPosB);\n    }\n    \n        \n    if (hasTans) {\n        sd = min(sd, length(tanPosA - uv) - 0.01);\n        sd = min(sd,sdSegment( uv, ro, tanPosA ) - 0.004);\n        sd = min(sd, length(tanPosB - uv) - 0.01);\n        sd = min(sd,sdSegment( uv, ro, tanPosB ) - 0.004);\n    }\n\n    \n    col += smoothstep(fwidth(uv.y),0.,sd);\n    \n    col = 1.-col;\n    if (abs(U.x - iResolution.x / 2.0) <= 0.6) {\n        col = vec3(0.4);\n    }\n    if (U.x < iResolution.x / 2.0) {\n        if (abs(U.y - iResolution.y / 2.0) <= 0.7) {\n            col = vec3(0.4);\n        }\n    }\n    col = pow(col,vec3(0.454545));\n    C = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Original C# source code here:\n// https://github.com/elenzil/tangents/blob/master/tangents/Assets/Scripts/TangentCtlr.cs#L78C39-L102\n// thanks to Mike Plotz for suggesting this direction.\nbool CircleTangents_Plotz(in vec2 center, in float r, in vec2 p, out vec2 tanPosA, out vec2 tanPosB) {\n    p -= center;\n\n    float P = length(p);\n\n    // if p is inside the circle, there ain't no tangents.\n    if (P <= r) {\n      return false;\n    }\n\n    float a = r * r                       / P;    \n    float q = r * sqrt((P * P) - (r * r)) / P;\n\n    vec2 pN  = p / P;\n    vec2 pNP = vec2(-pN.y, pN.x);\n    vec2 va  = pN * a;\n\n    tanPosA = va + pNP * q;\n    tanPosB = va - pNP * q;\n\n    tanPosA += center;\n    tanPosB += center;\n\n    return true;\n}\n\n\n\nbool CircleTangents_edg(in vec2 c, in float R, in vec2 p, out vec2 tanPosA, out vec2 tanPosB)\n{\n  p -= c;\n  float t = dot(p,p)/(R*R);\n  if(t<1.) return false;\n  p = p/t;\n  vec2 n = vec2(-p.y,p.x) * sqrt(t-1.);\n  tanPosA = p+c+n;\n  tanPosB = p+c-n;\n  return true;\n}\n\n\n\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\nbool CircleTangents(in vec2 c, in float R, in vec2 p, out vec2 tanPosA, out vec2 tanPosB)\n{\n    float l = length(c - p);\n    float u = sqrt(l*l - R*R);\n    \n    float beta = asin(R/l);\n    float alpha = pi - pi/2.0 - beta;\n    \n    vec2 rd = normalize(c - p);\n    \n    rd *= rot(beta);\n    tanPosA = p + rd * u;\n    \n    rd *= rot(-beta*2.0);\n    tanPosB = p + rd * u;\n    \n    return true;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[379, 390, 441, 441, 560], [562, 562, 602, 602, 2421]], "test": "untested"}
{"id": "dt2fWG", "name": "Snakes in Snakes", "author": "martymarty", "description": "Using the snake function from https://www.shadertoy.com/view/DtjBWR made Snakes in Snakes. The snake number is the size of a new snake function in that spot and then iterated. At stage 5 and 6 chaotic patterns emerge, from aliasing I think. ", "tags": ["2d", "animated", "complex", "chaotic"], "likes": 12, "viewed": 264, "published": 3, "date": "1694539754", "time_retrieved": "2024-07-30T17:34:16.920812", "image_code": "float superLogicSnake(vec2 p, float s){\n    float r = min(min(p.x,p.y),min(s-p.x-1.0,s-p.y-1.0));\n    float h = float(p.y>p.x);\n    float l = 4.0*(r+h)*(s-r-h);\n    l += sign(0.5-h)*(p.x+p.y-2.0*r);\n    return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x -= .5*(iResolution.x-iResolution.y);\n    vec2 uv = fragCoord/iResolution.y;\n    float xMask = 1.0-abs(floor(uv.x));\n    float size = 2.0;\n    float area = size*size;\n    vec2 tilePos = uv*size;\n    float flip = -1.0;\n    float crazy = floor(log(mod(iTime*0.45,12.7)+1.0)*2.0);\n    float snake1 = superLogicSnake(floor(tilePos),size);\n    for( ; crazy > 0.0 ; crazy--){\n        \n        size = flip > 0.0 ? area-ceil(snake1)+2.0 : ceil(snake1)+2.0;\n\n        flip *= -1.0;\n        area = size*size;\n        tilePos = fract(tilePos)*size;\n        snake1 = superLogicSnake(floor(tilePos),size);\n    }\n\n    snake1 = mod(snake1+floor(iTime*15.0),area)/(area-1.0);\n    vec3 col =vec3(snake1);\n    col *= xMask;\n\nfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2fWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 214], [216, 216, 273, 273, 1023]], "test": "untested"}
{"id": "DtSBD3", "name": "Point to line tangent to circle", "author": "jeyko", "description": ".", "tags": ["line", "intersection", "circle", "sampling"], "likes": 18, "viewed": 203, "published": 3, "date": "1694534616", "time_retrieved": "2024-07-30T17:34:18.073729", "image_code": "/*\n    solve right triangle, formed by point (ro), circle center (C) and unknown point.\n    beta is the angle on ro.\n    \n    ro\n    rd\n    R\n    C\n\n\n    l = sqrt(dot(ro-C,ro-C))\n\n    l2 = R2 + u2\n\n    u = sqrt(l2 - r2)\n\n    sin(beta) = R/l\n    beta = asin(R/l)\n*/\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define pi acos(-1.)\n\n// From iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 ro = muv*1.;\n    if(iFrame == 0){\n        ro = vec2(0.4);\n    }\n    \n    float R = 0.25;\n    vec2 c = vec2(0.);\n    \n    float sd = 1000.0;\n    \n    sd = min(sd, length(ro - uv) - 0.02);\n    sd = min(sd, abs(length(uv - c) - R) - 0.001);\n    \n    \n    float l = length(c - ro);\n    float u = sqrt(l*l - R*R);\n    \n    float beta = asin(R/l);\n    float alpha = pi - pi/2.0 - beta;\n    \n    vec2 rd = normalize(c - ro);\n    rd *= rot(beta);\n    \n    float circ_circumf = 2. * pi * R;\n    float cone_circumf = circ_circumf * (2. * alpha / (2.*pi));\n    \n    \n    sd = min(sd, length(ro + rd*u - uv) - 0.01);\n    sd = min(sd,sdSegment( uv, ro, ro + rd*u ) - 0.004);\n    \n    rd *= rot(-beta*2.0);\n    \n    sd = min(sd, length(ro + rd*u - uv) - 0.01);\n    sd = min(sd,sdSegment( uv, ro, ro + rd*u ) - 0.004);\n    \n    \n    col += smoothstep(fwidth(uv.y),0.,sd);\n    \n    col = 1.-col;\n    col = pow(col,vec3(0.454545));\n    C = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 352, 403, 403, 522], [524, 524, 564, 564, 1660]], "test": "untested"}
{"id": "dt2BDV", "name": "Golf of Life 🏌️🦠 [190 Chars]", "author": "SnoopethDuckDuck", "description": "joiwroiwuevowirmcwrlwlrebvwoiure", "tags": ["game", "life", "onetweet", "of", "golf"], "likes": 14, "viewed": 195, "published": 3, "date": "1694529044", "time_retrieved": "2024-07-30T17:34:19.217671", "image_code": "M;\n    o = vec4(T);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 o, vec2 u ) { int i\n\n#define T int(texelFetch(iChannel0, ivec2(u+vec2(i%3,i++/3)-1.), 0))", "buffer_a_code": "// -10 thanks to coyote! [61/190] 🚂\nM \n   ,n;      \n   for (;i<9;)\n       n += T;\n   \n   i = 4;\n \n   o = iFrame < 1 ? u.yyyy\n                  : vec4(n==3 || n-T==3);\n}\n\n\n// Original [73/200] \n/*\nM     \n   ,n;\n    \n   for (;i<9;i++)\n       n += T;\n   \n   i = 4;\n   \n   o = iFrame < 1 ? 0.*o + u.y\n                  : vec4(n-T==3 || T>0 && n-T==2);\n}\n//*/", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2BDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtGGWK", "name": "Ray-Tracing Triangles", "author": "Zi7ar21", "description": "The triangles were made painstakingly by hand! It wasn't too hard placing the triangles and getting them to render, but placing the vertices in a standard order (e.g. GL_TRIANGLE_STRIP) sure was.", "tags": ["ray", "tracing", "traced", "tracer", "rt", "trace"], "likes": 9, "viewed": 294, "published": 3, "date": "1694483554", "time_retrieved": "2024-07-30T17:34:20.103303", "image_code": "#pragma debug(on)\n#pragma optimize(off)\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n#define exposure 2.0\n\n#define fov 1.0\n\nstruct intersection\n{\n    bool  hit; // Hit\n    int   id ; // Triangle ID\n    float t  ; // Intersection\n    vec3  n  ; // Normal\n    vec2  uv ; // UV\n};\n\n// triangle intersection from https://iquilezles.org/articles/intersectors (modified)\nintersection triIntersect(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, rd  );\n\n    float d = 1.0 / dot(rd, n);\n\n    float u = d * dot(-q, v2v0);\n    float v = d * dot( q, v1v0);\n    float t = d * dot(-n, rov0);\n\n    if(u < 0.0 || u > 1.0 || v < 0.0 || (u + v) > 1.0)\n    {\n        t = -1.0;\n    }\n\n    intersection output_data;\n\n    output_data.hit = t > 0.0     ;\n    output_data.t   = t           ;\n    output_data.n   = normalize(n);\n    output_data.uv  = vec2(u, v)  ;\n\n    return output_data;\n}\n\nbool AABB(vec3 ro, vec3 rd, vec3 b_min, vec3 b_max)\n{\n    vec3 t1 = (b_min - ro) / rd;\n    vec3 t2 = (b_max - ro) / rd;\n\n    vec3 Tmin = min(t1, t2);\n    vec3 Tmax = max(t1, t2);\n\n    float tMin = max(max(Tmin.x, Tmin.y), Tmin.z);\n    float tMax = min(min(Tmax.x, Tmax.y), Tmax.z);\n\n    return tMin <= tMax && tMin > 0.0;\n}\n\nintersection compareIntersection(intersection t, intersection t_)\n{\n    if(t_.hit)\n    {\n        if(t.hit)\n        {\n            intersection output_data;\n\n            output_data.hit = true;\n\n            if(t.t < t_.t)\n            {\n                /*\n                output_data.id = t.id;\n                output_data.t  = t.t ;\n                output_data.n  = t.n ;\n                output_data.uv = t.uv;\n                */\n                output_data = t;\n            }\n            else\n            {\n                /*\n                output_data.id = t_.id;\n                output_data.t  = t_.t ;\n                output_data.n  = t_.n ;\n                output_data.uv = t_.uv;\n                */\n                output_data = t_;\n            }\n\n            return output_data;\n        }\n\n        return t_;\n    }\n\n    return t;\n}\n\nintersection trace(vec3 ro, vec3 rd)\n{\n    const int num_tris = 4;\n\n    /*\n    // GL_TRIANGLE_STRIP\n    // https://en.wikipedia.org/wiki/Triangle_strip\n    // 72 bytes\n    const vec3[] vert = vec3[] (\n    vec3(-1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0),\n    vec3(-1.0,  1.0, -1.0),\n    vec3( 1.0,  1.0, -1.0)\n    );\n    */\n\n    // 144 bytes\n    const vec3[] vert = vec3[] (\n    vec3(-1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3(-1.0, -1.0, -1.0),\n\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0, -1.0),\n\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0),\n    vec3(-1.0,  1.0, -1.0),\n\n    vec3(-1.0,  1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0),\n    vec3( 1.0,  1.0, -1.0)\n    );\n\n    vec3 bound_min = vert[0];\n    vec3 bound_max = vert[0];\n\n    for(int i = 1; i < 3 * num_tris; i++)\n    {\n        bound_min = min(bound_min, vert[i]);\n        bound_max = max(bound_max, vert[i]);\n    }\n\n    intersection output_data;\n\n    output_data.hit = false    ;\n    output_data.id  = -1       ;\n    output_data.t   = -1.0     ;\n    output_data.n   = vec3(0.0);\n    output_data.uv  = vec2(0.0);\n\n    //st_assert(AABB(ro, rd, bound_min, bound_max), 0);\n\n    if( AABB(ro, rd, bound_min, bound_max) )\n    {\n        for(int i = 0; i < num_tris; i++)\n        {\n            int index = 3 * i;\n\n            intersection input_data = triIntersect(ro, rd, vert[index + 0], vert[index + 1], vert[index + 2]);\n\n            input_data.id = i;\n\n            output_data = compareIntersection(output_data, input_data);\n        }\n    }\n\n    return output_data;\n}\n\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x * c - vec.y * s, vec.x * s + vec.y * c);\n}\n\nfloat hash13(vec3 p3)\n{\n    p3 *= 0.1031;\n    p3  = fract(p3);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract( (p3.x + p3.y) * p3.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize( vec3(fov * uv, -1.0) );\n\n    ro = vec3(rotate(ro.xz, iTime), ro.y).xzy;\n    rd = vec3(rotate(rd.xz, iTime), rd.y).xzy;\n\n    intersection t = trace(ro, rd);\n\n    if(t.hit)\n    {\n        vec3 h = ro + rd * t.t;\n\n        vec3 a = vec3(1.0, 0.0, 1.0);\n\n        if(t.id == 0 || t.id == 1)\n        {\n            a = mod(floor(4.0*h.x) + (4.0 * h.z), 2.0) < 1.0 ? vec3(0.400, 0.400, 0.400) : vec3(0.800, 0.800, 0.800);\n        }\n        if(t.id == 2 || t.id == 3)\n        {\n            a = vec3(0.8);\n        }\n\n        vec3 l = vec3(0.0, 0.5, 0.0);\n\n        vec3 c = l - h;\n\n        vec3 d = normalize(c);\n\n        float f = 1.0 / max(dot(c, c), 0.001);\n\n        fragColor.rgb = a * dot(t.n, f * d);\n        //fragColor.rgb = vec3(t.uv, 0.0);\n    }\n    else\n    {\n        fragColor.rgb = vec3(0.0);\n    }\n\n    #ifdef exposure\n    fragColor.rgb = clamp(1.0 - exp(-max(fragColor.rgb, 0.0) * exposure), 0.0, 1.0);\n    #endif\n\n    fragColor.rgb += hash13( vec3(fragCoord, iFrame) ) / 64.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 368, 440, 440, 1002], [1004, 1004, 1057, 1057, 1327], [1329, 1329, 1396, 1396, 2166], [3802, 3802, 3836, 3836, 3939], [3941, 3941, 3964, 3964, 4082], [4084, 4084, 4141, 4141, 5319]], "test": "untested"}
{"id": "DlSBDK", "name": "Red and green rug (music)", "author": "jarble", "description": "A fractal rug pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "rug"], "likes": 4, "viewed": 152, "published": 3, "date": "1694471741", "time_retrieved": "2024-07-30T17:34:21.035810", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = uv.y>uv.x;\n    for(int k = 0; k < 6; k++){\n        \n        //uv.y -= t1_(floor(uv),floor(uv));\n\n        \n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        \n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        \n        \n        \n        \n        uv =\n            //abs(.5+uv/1.5+t2)\n            abs(.5+uv+t2/1.5)\n            //abs(.5+uv+t2)/1.5\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n        \n        \n        \n        b =\n            uv.y>uv.x\n            //uv.y>uv.x || t2.y<t2.x\n        ;\n        if(b) uv = uv.yx;\n        col =\n            vec3(col.zx,max(uv.x-uv.y,0.))\n        ;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod(float a, float b){\n    //a += floor(a/(2.+b*b*4.));\n    //a += (abs(mod(a,3.)-mod(a,5.)));\n    a += mod(-b/2.,2.);\n    return\n        floor(mod(mod(floor(a/2.)*5.,b)*mod(floor(a/2.)*3.,b),b))\n        //floor(mod(floor(a)*1.5,b))\n    ;\n}\n\nfloat prime_rhythm(float time){\n    return (1.+fmod(time/5.,2.))/(1.+fmod(time/3.,2.));\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time)\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod(t4,2.),\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6,s1/2.)/2.),\n  m2 =\n      1. + fmod(t/t3/2.,s1/2.),\n  a=\n      (1.-log(fract(t/2./prime_rhythm(time+14.))/2.))*(1.-log(fract(t/prime_rhythm(time+7.))/4.)),\n  nb =\n      t*pow(2.,(m3+m2-t1*4.)/7.+7.5)*tempo1/2.\n  ;\n  return\n      log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 193], [310, 310, 336, 336, 425], [427, 427, 484, 484, 1472]], "test": "untested"}
{"id": "clBfWK", "name": "Ok forest(GDSMBCZY)", "author": "GDSMBCZY", "description": "I tried following the Over the Moon tutorial from The Art Of Code. But got lazy.", "tags": ["gdsmbczy"], "likes": 0, "viewed": 125, "published": 3, "date": "1694470205", "time_retrieved": "2024-07-30T17:34:22.019180", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\nfloat TaperBox(vec2 p, float widthBottom, float widthTop, float yBottom, float yTop, float blur){\n    float m = S(-blur, blur, p.y-yBottom);\n    m *= S(blur, -blur, p.y-yTop);\n    \n    p.x = abs(p.x);\n    \n    float width = mix(widthBottom, widthTop, (p.y-yBottom)/(yTop-yBottom));\n    \n    m *= S(blur, -blur, p.x-width);\n    return m;\n}\n\nvec4 Tree(vec2 uv, float x, float y, vec3 col, float blur){\n    uv -= vec2(x, y);\n    \n    float m = TaperBox(uv, 0.03, 0.03, 0.0, 0.25, blur); //trunk\n    m += TaperBox(uv, 0.2, 0.1, 0.25, 0.5, blur); //canopy 1\n    m += TaperBox(uv, 0.15, 0.05, 0.5, 0.75, blur); //canopy 2\n    m += TaperBox(uv, 0.1, 0.0, 0.75, 1.0, blur); //top\n    \n    \n    float shadow = TaperBox(uv-vec2(0.25, 0.0), 0.1, 0.5, 0.15, 0.25, blur);\n    shadow += TaperBox(uv-vec2(0.25, 0.0), 0.1, 0.5, 0.45, 0.5, blur);\n    shadow += TaperBox(uv-vec2(0.25, 0.0), 0.1, 0.5, 0.70, 0.75, blur);\n    \n    col -= shadow * 0.5;\n    //m = 1.0;\n    return vec4(col, m);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv.x += iTime/8.;\n    //uv.y += 0.5;\n    uv *= 5.0;\n    \n    vec4 col = vec4(0.0);\n    float blur = 0.001;\n    \n    //helps create multipule trees\n    float id = floor(uv.x);\n    float n = fract(sin(id*196.91)*925.72)*2.0-1.0;\n    uv.x = fract(uv.x)-0.5;\n    float x = n/5.;\n    float y = n/4.;\n    vec4 tree = Tree(uv*vec2(1.+n*.2), x, y, vec3(0.0, 0.5, 0.0), blur);\n    \n    //col.rg = uv;\n    \n    col = mix(col, tree, tree.a); //draws trees\n    \n    col += S(blur, -blur, uv.y-n/4.); //floor\n    col += vec4(0.0, 0.0, 0.3, 1.0);\n    \n    float thickness = 1.0/iResolution.y;\n    //if(abs(uv.x)<thickness){col.g=1.0;}\n    //if(abs(uv.y)<thickness){col.r=1.0;}\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 134, 134, 375], [377, 377, 436, 436, 1010], [1013, 1013, 1070, 1070, 1831]], "test": "untested"}
{"id": "dtjfWG", "name": "Swirly Portal", "author": "m039", "description": "A simple swirly portal effect.", "tags": ["swirl", "vortex", "portal"], "likes": 3, "viewed": 154, "published": 3, "date": "1694463857", "time_retrieved": "2024-07-30T17:34:23.045436", "image_code": "void Unity_Twirl(vec2 UV, vec2 Center, float Strength, vec2 Offset, out vec2 Out)\n{\n    vec2 delta = UV - Center;\n    float angle = Strength * length(delta);\n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\n    Out = vec2(x + Center.x + Offset.x, y + Center.y + Offset.y);\n}\n\nvec2 unity_voronoi_noise_randomVector(vec2 UV, float offset)\n{\n    mat2 m = mat2(15.27, 47.63, 99.41, 89.98);\n    UV = fract(sin(UV * m) * 46839.32);\n    return vec2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5);\n}\n\nvoid Unity_Voronoi(vec2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)\n{\n    vec2 g = floor(UV * CellDensity);\n    vec2 f = fract(UV * CellDensity);\n    float t = 8.0;\n    vec3 res = vec3(8.0, 0.0, 0.0);\n\n    for(int y=-1; y<=1; y++)\n    {\n        for(int x=-1; x<=1; x++)\n        {\n            vec2 lattice = vec2(x,y);\n            vec2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);\n            float d = distance(lattice + offset, f);\n            if(d < res.x)\n            {\n                res = vec3(d, offset.x, offset.y);\n                Out = res.x;\n                Cells = res.y;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Parameters.\n\n    vec3 color = vec3(195.0 / 255.0, 84.0 / 255.0, 205.0 / 255.0) * 3.0;\n    float strength = 10.0;\n    float speed = 0.2;\n    float brightness = 1.5;\n    float cellDensity = 6.0;\n    \n    // Shader.\n    \n    vec2 twirlResult;\n    float voronoiResult;\n    float voronoiCells;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float offset = iTime * speed;\n \n    Unity_Twirl(uv, vec2(0.5, 0.5), strength, vec2(offset), twirlResult);\n    Unity_Voronoi(twirlResult, 2.0, cellDensity, voronoiResult, voronoiCells);\n    \n    voronoiResult = pow(voronoiResult, brightness);\n    \n    // Output to screen\n    fragColor = vec4(voronoiResult * color, voronoiResult);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 83, 83, 343], [345, 345, 407, 407, 566], [568, 568, 667, 667, 1237], [1239, 1239, 1296, 1319, 2029]], "test": "untested"}
{"id": "DljfRt", "name": "First shader(GDSMBCZY)", "author": "GDSMBCZY", "description": "This is the first shader I have made.", "tags": ["gdsmbczy"], "likes": 1, "viewed": 126, "published": 3, "date": "1694462076", "time_retrieved": "2024-07-30T17:34:23.964978", "image_code": "vec3 palette(float t){\n    vec3 a = vec3(0.806, 0.333, 0.292);\n    vec3 b = vec3(0.167, 0.751, -3.204);\n    vec3 c = vec3(0.988, 0.522, 1.255);\n    vec3 d = vec3(0.578, 1.648, -0.652);\n\n    return a + b * cos(6.28318*(c*t*d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++){\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.5 + iTime * 0.5);\n\n        d = sin(d * 8.0 + iTime*5.)/8.0;\n        d = abs(d);\n\n        d = pow(0.02/d, 2.0);\n\n        finalColor = col * d;\n        }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 228], [231, 231, 288, 288, 783]], "test": "untested"}
{"id": "mt2BWy", "name": "Zoom out (GDSMBCZY)", "author": "GDSMBCZY", "description": "I was just messing around and got this.", "tags": ["gdsmbczy"], "likes": 1, "viewed": 95, "published": 3, "date": "1694461989", "time_retrieved": "2024-07-30T17:34:24.811714", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv -= 0.5;\n    uv.x -= 0.4;\n    uv *= 2.0;\n    vec2 uv0 = uv;\n    vec3 col = vec3(0.5, 0.5, 1.0);\n    float d = length(uv);    \n   \n    d = sin(d*iTime+iTime);\n    d = smoothstep(uv0.x, uv0.y/10000., d);\n   \n   \n    col *= d;\n   \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2BWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 406]], "test": "untested"}
{"id": "cljfWG", "name": "Fork take ugly, Arrangemon 752", "author": "Arrangemonk", "description": "it ugly ", "tags": ["domaintransform"], "likes": 3, "viewed": 194, "published": 3, "date": "1694442761", "time_retrieved": "2024-07-30T17:34:29.279768", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx * 0.5;\n    vec3 col = texture(iChannel0,uv).rgb*0.5;\n    float time1 = sin(iTime * .1) * 10.;\n    float time2 = cos(iTime * .1) * 10.;\n\n    col += texture(iChannel1,uv+ \n     vec2(time1 *.05,0.) +0.5 * texture(iChannel0,uv+ \n     vec2(0.,time2 *.025) + 0.25 *texture(iChannel0,0.5*uv+\n     vec2(time1 *.0125,-time2 *.0125) + 0.125 *texture(iChannel0,.25*uv).rg).rb).gb).rgb;\n\n    col = normalize(col *.2 + vec3(0,0,.8));\n    \n    col = texture(iChannel2,col).rgb;\n    fragColor = vec4(col,1.0);\n    \n    fragColor = vec4(col * col * 8.,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat r = textureLod( iChannel0, (fragCoord) / iResolution.xy, 0.0 ).r;\nfloat g = textureLod( iChannel0, (fragCoord +64.) / iResolution.xy, 0.0 ).r;\nfloat b = textureLod( iChannel0, (fragCoord + 256.) / iResolution.xy, 0.0 ).r;\nfragColor = vec4(r,g,b,1);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 640]], "test": "untested"}
{"id": "mljBzG", "name": "vurpo is at nordlicht 2023", "author": "vurpo", "description": "aaa", "tags": ["demoscene"], "likes": 1, "viewed": 135, "published": 3, "date": "1694437142", "time_retrieved": "2024-07-30T17:34:30.180360", "image_code": "#define PI 3.1415926538\n\n//21*6\nconst int text[126] = int[126](\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,\n    0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,\n    0,0,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n);\n\nfloat indexText(vec2 coords) {\n    float x = clamp(coords.x+10.5, 0.0, 20.9);\n    float y = clamp(coords.y+2.5, 0.0, 5.9);\n    return float(text[int(y)*21+int(x)]);\n}\n\nfloat triangle(float x) {\n    return abs(-1.0+(sign(x)*mod(x,2.0)));\n}\n\nfloat transition(float x) {\n    float xmod = mod(x,20.0);\n    return smoothstep(9.0,10.0,xmod)*(1.0-smoothstep(19.0,20.0,xmod));\n}\n\nvec3 trans(float x) {\n    vec3 c[3] = vec3[3](\n        vec3(1.0, 1.0, 1.0),\n        vec3(1.0,.67,.72),\n        vec3(.4,.85,1.0)\n    );\n    vec3 col = c[int(2.0*triangle(x)+0.5)];\n    return col;\n}\n\nvec3 rainbow(float x) {\n  vec3 c = vec3(x, 0.5, 1.0);\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 blue(float x) {\n  return vec3(\n      sin(x*PI)*0.3+0.7,\n      sin(x*PI)*0.2+0.8,\n      1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv_0 = fragCoord/iResolution.xx*2.0-vec2(1.0, iResolution.y/iResolution.x);\n    vec2 uv = uv_0*(length(uv_0)*0.5+0.5);\n    //vec2 uv = vec2(uv_0.x*cos(iTime)+uv_0.y*sin(iTime), uv_0.y*cos(iTime)-uv_0.x*sin(iTime));\n    float angle = atan(uv.y, uv.x);\n    float len = length(uv);\n  \n    float x = mod(\n        len*7.0\n        -iTime*5.0\n        +0.4*sin(1.1*iTime+11.0*angle+sin(len*11.0+4.0*iTime))\n        +0.8*sin(-4.3*iTime+7.0*angle+sin(len*19.0-8.0*iTime)), 6.0)\n        +1.0*sin(len*3.0)/(2.0*len)\n    ;//*0.5+0.5;\n    \n    vec4 color1;\n    vec4 color2;\n    vec4 color3;\n    switch (int(mod(iTime/5.0, 3.0))) {\n    case 0:\n        color1 = vec4(rainbow(x), 1.0);\n        color2 = vec4(trans(x), 1.0);\n        color3 = vec4(blue(x), 1.0);\n        break;\n    case 1:\n        color1 = vec4(trans(x), 1.0);\n        color2 = vec4(blue(x), 1.0);\n        color3 = vec4(rainbow(x), 1.0);\n        break;\n    case 2:\n        color1 = vec4(blue(x), 1.0);\n        color2 = vec4(trans(x), 1.0);\n        color3 = vec4(trans(x), 1.0);\n        break;\n    }\n    \n    float textMask = (1.0-indexText(uv*vec2(15.0,-15.0)+vec2(cos(uv.y*5.0+iTime*2.0), sin(uv.x*5.0+iTime*2.0))));\n    float transition = smoothstep(0.0, 0.5, mod(iTime, 5.0));\n\n    // Output to screen\n    vec4 color = (transition*color1\n    +(1.0-transition)*color3);\n    vec4 textColor = 0.4*(transition*color3\n    +(1.0-transition)*color2);\n    fragColor = textMask*color+(1.0-textMask)*textColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 379, 379, 515], [517, 517, 542, 542, 587], [589, 589, 616, 616, 719], [721, 721, 742, 742, 917], [919, 919, 942, 942, 1135], [1137, 1137, 1157, 1157, 1236], [1238, 1238, 1295, 1295, 2758]], "test": "untested"}
{"id": "mdSfRw", "name": "PerfTest Cubemapping", "author": "gehtsiegarnixan", "description": "Wrapping of a tiling texture around a sohere with minimal distortions, using mulitple methods. \nUsing a performance test designed to tank your FPS to see which operation is faster.", "tags": ["test", "cubemap", "performance", "speed"], "likes": 2, "viewed": 192, "published": 3, "date": "1694425199", "time_retrieved": "2024-07-30T17:34:31.120845", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis performance test aims to compare cubemapping implementations.\n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n\nWhile it's possible to improve Mips using derivatives, I have not \nimplemented this optimization in these versions, cubemapping inherently \nfaces challenges with mapping on at least six edges. Therefore, I have \nnot implemented Mip optimization for these implementations.\n*/\n\n// Number of repeats of the test, 4000 should be enough for RTX3080\n#define REPEAT 1\n\n// switch between the test cases\n// 0 = Cubemap using if ~ 81 fps\n// 1 = Folded Cubemap using if ~ 44 fps\n// 2 = Cubemap using a Mask ~ 61 fps\n// 3 = Cubemap using a Mask v2 ~ 62 fps\n// 4 = folded Cubemap using a Mask  ~ 37 fps\n#define TEST 1\n\n// smallest float to avoid float errors\n#define TINY (1.0 / float(0xffffffffU))\n\n// Default Cubemap using if from IG https://www.shadertoy.com/view/ltl3D8\nvec2 CubemapIf(vec3 uvw) {\n    // intersect cube\n    vec3 n = abs(uvw);\n    vec3 v = (n.x>n.y && n.x>n.z) ? uvw.xyz: \n             (n.y>n.z) ?            uvw.yzx:\n                                    uvw.zxy;\n    // project into face\n    vec2 uv = v.yz/v.x;\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using if, that is folded so all but 6 edges align\nvec2 CubemapFoldedIf(vec3 uvw) {\n    // bitmask for flipping some sides\n    vec3 sUVW = sign(uvw);\n\n    // intersect cube\n    vec3 n = abs(uvw);\n    vec3 v = (n.x>n.y && n.x>n.z) ? vec3(uvw.x, uvw.y, sUVW.x * uvw.z): \n             (n.y>n.z) ?            vec3(uvw.y, -uvw.x, sUVW.y * uvw.z):\n                                    vec3(uvw.z, sUVW.z * uvw.x, uvw.y);\n                                    \n    // edge distance\n    //float eDist = clamp(-(n.z - max(n.x, n.y)), 0., 1.) + \n    //              clamp(n.z - max(n.x, uvw.y), 0., 1.);\n                  \n    // project into face\n    vec2 uv = v.yz/v.x;\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using if, that is folded so all but 6 edges align\nvec2 CubemapMostlyFoldedIf(vec3 uvw) {\n    // bitmask for flipping some sides\n    vec3 sUVW = sign(uvw);\n\n    // intersect cube\n    vec3 n = abs(uvw);\n    vec3 v = (n.x>n.y && n.x>n.z) ? vec3(uvw.x, uvw.y, sUVW.x * uvw.z): \n             (n.y>n.z) ?            vec3(uvw.y, -uvw.x, sUVW.y * uvw.z):\n                                    vec3(uvw.z, uvw.x, uvw.y);\n                                    \n    // edge distance\n    //float eDist = clamp(-(n.z - max(n.x, n.y)), 0., 1.) + \n    //              clamp(n.z - max(n.x, uvw.y), 0., 1.);\n                  \n    // project into face\n    vec2 uv = v.yz/v.x;\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using masks instead of If\nvec2 CubemapMask(vec3 uvw) {\n    // Cube Masks\n    vec3 aUVW = abs(uvw);\n    vec3 mask = vec3(aUVW.x - max(aUVW.y, aUVW.z),\n                     aUVW.y - max(aUVW.x, aUVW.z),\n                     aUVW.z - max(aUVW.x, aUVW.y));\n    mask = clamp(mask, 0., 1.);\n    //float eDist = max(mask.x, max(mask.y, mask.z)); // edge distance\n    vec3 bitMask = step(TINY,mask);\n\n    // project into face without if\n    vec2 uv = vec2((uvw.yz * bitMask.x)/uvw.x + \n                   (uvw.zx * bitMask.y)/uvw.y + \n                   (uvw.xy * bitMask.z)/uvw.z);\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using masks instead of If\nvec2 CubemapMaskv2(vec3 uvw) {\n    // Cube Masks\n    vec3 aUVW = abs(uvw);\n    vec3 mask = vec3(max(aUVW.y, aUVW.z),\n                     max(aUVW.x, aUVW.z),\n                     max(aUVW.x, aUVW.y));\n    //float eDist = max(mask.x, max(mask.y, mask.z)); // edge distance\n    vec3 bitMask = step(mask,aUVW);\n\n    // project into face without if\n    vec2 uv = vec2((uvw.yz * bitMask.x)/uvw.x + \n                   (uvw.zx * bitMask.y)/uvw.y + \n                   (uvw.xy * bitMask.z)/uvw.z);\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using masks instead of If, that is folded so all but 6 edges align\nvec2 CubemapFoldedMask(vec3 uvw) {\n    // Cube Masks\n    vec3 aUVW = abs(uvw);\n    vec3 mask = vec3(aUVW.x - max(aUVW.y, aUVW.z),\n                     aUVW.y - max(aUVW.x, aUVW.z),\n                     aUVW.z - max(aUVW.x, aUVW.y));\n    \n    // edge distance\n    //float eDist = clamp(-mask.z, 0., 1.) + \n    //              clamp(aUVW.z - max(aUVW.x, uvw.y), 0., 1.);\n                  \n    mask = clamp(mask, 0., 1.);\n    vec3 bitMask = step(TINY,mask);\n\n    // bitmask for flipping some sides\n    vec3 sUVW = sign(uvw);\n\n    // project into face without if\n    vec2 uv = vec2((vec2(uvw.y, sUVW * uvw.z) * bitMask.x)/uvw.x + \n                   (vec2(-uvw.x, sUVW.y * uvw.z) * bitMask.y)/uvw.y + \n                   (vec2(sUVW.z * uvw.x, uvw.y) * bitMask.z)/uvw.z);\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 dir = sphereNormals(uv);\n\n    // if you get around 144 fps use a higher repeat value\n    vec2 test;\n    for(int i=0; i<REPEAT; i++) {\n        vec3 aDIR = dir + (float(i)/float(REPEAT)); // permutation each iteration\n    \n        // use which ever you wish to test\n        #if TEST == 0\n            test += CubemapIf(aDIR);\n        #elif TEST == 1\n            test += CubemapFoldedIf(aDIR);\n        #elif TEST == 2\n            test += CubemapMask(aDIR);\n        #elif TEST == 3\n            test += CubemapMaskv2(aDIR);\n        #else\n            test += CubemapFoldedMask(aDIR);\n        #endif   \n    }\n    \n    vec4 col = texture(iChannel0, test);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926536\n\n// sphere normals form morgan3d https://www.shadertoy.com/view/4dsGD2\nvec3 sphereNormals(vec2 uv) \n{\n    float theta = (1.0 - uv.y) * PI;\n\tfloat phi   = uv.x * PI * 2.0;\n    \n    float sinTheta = sin(theta);    \n    \n    // Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = vec3(sinTheta * sin(phi),\n                    cos(theta), \n                    sinTheta * cos(phi));\n    return dir;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSfRw.jpg", "access": "api", "license": "mit", "functions": [[2294, 2368, 2394, 2416, 2900], [2902, 2963, 2995, 3034, 3846], [3848, 3909, 3947, 3986, 4789], [4791, 4828, 4856, 4874, 5652], [5654, 5691, 5721, 5739, 6458], [6460, 6538, 6572, 6590, 7581]], "test": "untested"}
{"id": "DtSBWy", "name": "PerfTest Normal from Height", "author": "gehtsiegarnixan", "description": "Performance test to check how to make normalmaps the fastest from a heightmap. It seems the one using derivatives is waaay faster than anything else so use that.", "tags": ["test", "performance", "heightmap", "normal", "height", "speed"], "likes": 2, "viewed": 219, "published": 3, "date": "1694424245", "time_retrieved": "2024-07-30T17:34:32.227885", "image_code": "/*\nThis performance test aims to compare Height to Normal implementations. \n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 3000 should be enough for RTX3080\n#define REPEAT 1\n\n// switch between the test cases\n// 0 = NoxWings normal gen using derivatives ~ 108 fps\n// 1 = NoxWings normal gen using 3 texture samples ~ 40 fps\n// 2 = dmmn also using 3 texture samples ~ 42 fps\n#define TEST 0\n\n// NoxWings normal gen using derivatives\n// https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormalDerivative(sampler2D heightMap, vec2 uv, float strength) {\n    float height = texture(heightMap, uv).r;\n    vec2 xy = -vec2(dFdx(height), dFdy(height)) * (iResolution.xy/iChannelResolution[0].xy);\n    \n    return normalize(vec3(xy*strength, 1.));\n}\n\n// NoxWings normal gen using 3 texture samples\n// https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal3Sample(sampler2D heightMap, vec2 uv, float strength) {\n    vec2 s = 1.0/iChannelResolution[0].xy;\n    \n    float textureOffset = 1.0;\n    \n    float p = texture(heightMap, uv).x;\n    float h1 = texture(heightMap, uv + s * vec2(textureOffset,0)).x;\n    float v1 = texture(heightMap, uv + s * vec2(0,textureOffset)).x;\n       \n  \tvec2 xy = (p - vec2(h1, v1));\n    \n    return normalize(vec3(xy*strength, 1.));\n}\n\n// dmmn also using 3 texture samples\n// https://www.shadertoy.com/view/MsScRt\nvec3 HeightToNormal3Sample2(sampler2D heightMap, vec2 uv, float strength) {\n  vec2 s = 1. / iResolution.xy;\n    \n  float height = texture(heightMap, uv).x;\n    \n  vec2 dxy = height - vec2(\n      texture(heightMap, uv + vec2(s.x, 0.)).x, \n      texture(heightMap, uv + vec2(0., s.y)).x\n  );\n    \n  vec2 xy = dxy / s;\n  return normalize(vec3(xy*strength, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // if you get around 144 fps use a higher repeat value\n    vec3 test;\n    for(int i=0; i<REPEAT; i++) {\n        float mut = (float(i)/float(REPEAT)); // permutation each iteration\n            \n        // use which ever you wish to test\n        #if TEST == 0\n            test += HeightToNormalDerivative(iChannel0, uv + mut, 50.);\n        #elif TEST == 1\n            test += HeightToNormal3Sample(iChannel0, uv + mut, 50.);\n        #else\n            test += HeightToNormal3Sample2(iChannel0, uv + mut, 0.1);\n        #endif\n    }\n    \n    // Output to screen\n    fragColor = vec4((test*.5+.5), 1.);\n}\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// make square tiling of barycentric weights\nvec3 baryWeights(vec2 uv) {\n    // make individual weights for pattern\n    float weightA = min(uv.x, uv.y);\n    float weightB = min(1.-uv.x, 1.-uv.y);\n    float weightC = 1. - weightA - weightB;\n    \n    // Join weights together\n    return vec3(weightA, weightB, weightC);\n}\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[836, 918, 995, 995, 1185], [1187, 1275, 1349, 1349, 1704], [1706, 1784, 1859, 1859, 2144]], "test": "untested"}
{"id": "DtBfDG", "name": "take ugly, make it more ugly", "author": "Arrangemonk", "description": "it ugly ", "tags": ["domaintransform"], "likes": 5, "viewed": 150, "published": 3, "date": "1694422504", "time_retrieved": "2024-07-30T17:34:33.148424", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    vec3 col = texture(iChannel0,uv).rgb*0.2;\n    float time1 = sin(iTime * .1) * 10.;\n    float time2 = cos(iTime * .1) * 10.;\n\n    col += texture(iChannel0,uv+ \n     vec2(time1 *.05,0.) +0.5 * texture(iChannel0,uv+ \n     vec2(0.,time2 *.025) + 0.25 *texture(iChannel0,0.5*uv+\n     vec2(time1 *.0125,-time2 *.0125) + 0.125 *texture(iChannel0,.25*uv).rg).rb).gb).rgb;\n\n    \n    fragColor = vec4(col * col * col * 4.,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat r = textureLod( iChannel0, (fragCoord) / iResolution.xy, 0.0 ).r;\nfloat g = textureLod( iChannel0, (fragCoord +64.) / iResolution.xy, 0.0 ).r;\nfloat b = textureLod( iChannel0, (fragCoord + 256.) / iResolution.xy, 0.0 ).r;\nfragColor = vec4(r,g,b,1);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 521]], "test": "untested"}
{"id": "DtBfWG", "name": "Mandelbox-Faced Cube", "author": "dr2", "description": "Each cube face shows a different view of the Mandelbox interior", "tags": ["fractal", "mandelbox"], "likes": 13, "viewed": 220, "published": 3, "date": "1694418017", "time_retrieved": "2024-07-30T17:34:34.013112", "image_code": "// \"Mandelbox-Faced Cube\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 10 in \"Mandelbox\" series; others listed in \"Compleat Mandelbox 2\" (cllfD2).\n*/\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv2 (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, ltDirEx, pathMid;\nvec2 qBlk;\nfloat dstFar, tCur, pathRad, cFace;\nint nFrame;\nconst float pi = 3.1415927;\n\nfloat ObjDf (vec3 p)\n{\n  vec4 q4, q4o;\n  vec3 q;\n  float d;\n  const float mScale = 2.8;\n  const int nIter = 12;\n  q = p;\n  q4o = vec4 (6. * (fract (q / 6. + 0.5) - 0.5), 1.);\n  q4 = q4o;\n  for (int j = 0; j < nIter; j ++) {\n    q4.xyz = 2. * clamp (q4.xyz, -1., 1.) - q4.xyz;\n    q4 = mScale * q4 / clamp (dot (q4.xyz, q4.xyz), 0.25, 1.) + q4o;\n  }\n  d = length (q4.xyz) / q4.w;\n  d = max (d, - PrTorusDf ((p - pathMid).xzy, 0.02, pathRad));\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi, eps;\n  eps = 0.0005;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    h = ObjDf (ro + s * rd);\n    if (h < eps || s > dstFar) {\n      sHi = s;\n      break;\n    }\n    sLo = s;\n    s += h;\n  }\n  if (h < eps) {\n    for (int j = VAR_ZERO; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (ObjDf (ro + s * rd) > eps) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = 1e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dstObj, att;\n  dstObj = ObjRay (ro, rd);\n  col = vec3 (0.);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    att = exp2 (- 8. * max (dstObj - 4., 0.));\n    col = att * HsvToRgb (vec3 (cFace / 10., 0.2, 1.)) *\n       (0.2 + 0.8 * step (0.9, abs (vn4.w) / 256.)) * (0.3 + 0.7 * max (dot (vn, ltDir), 0.));\n  }\n  if (dstObj >= dstFar || Maxv3 (col) < 0.01) col = 4. * StarPat (rd, 64.);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrkPath (float t)\n{\n  return pathMid + vec3 (Rot2D (vec2 (0., pathRad), 2. * pi * t / pathRad), 0.).xzy;\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd;\n  float el, az, zmFac, vuTr;\n  vuTr = 0.02 * tCur + 0.3 * cFace;\n  pathRad = mix (1.5, 2.5, 0.5 + 0.5 * sin (0.03 * pi * vuTr));\n  pathMid = vec3 (0., 0.7 * sin (0.05 * pi * vuTr), 0.);\n  ro = TrkPath (vuTr);\n  vd = normalize (TrkPath (vuTr + 0.1) - ro);\n  az = atan (vd.z, - vd.x) - 0.5 * pi;\n  el = 0.;\n  vuMat = StdVuMat (el, az);\n  zmFac = 15.;\n  rd = normalize (vec3 (fCoord, zmFac));\n  rd.xy = Rot2D (rd.xy, 0.5 * pi * vuTr);\n  rd = vuMat * rd;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -1.));\n  fCol = ShowScene (ro, rd);\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, float bSize)\n{\n  vec3 v, tm, tp, u, vn;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, vn), dot (u.yzx, vn)) / bSize;\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn;\n  float dstObj;\n  db4 = BlkHit (ro, rd, 3.);\n  dstObj = db4.x;\n  if (dstObj < dstFar) {\n    vn = db4.yzw;\n    cFace = dot (vn, vec3 (4., 2., 1.)) + 4.;\n    if (Maxv2 (abs (qBlk)) < 0.97) {\n      ExMain (col, qBlk);\n    } else {\n      col = vec3 (0.5) * (0.2 + 0.8 * max (dot (vn, ltDirEx), 0.)) +\n         0.3 * pow (max (dot (ltDirEx, reflect (rd, vn)), 0.), 32.);\n    }\n  } else {\n    col = StarPat (rd, 16.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  zmFac = 4.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 2. * abs (az);\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.07 * pi * tCur;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -22.);\n  dstFar = 100.;\n  ltDirEx = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ((length (uv) > 0.99) ? vec3 (0.82) : ExShowScene (ro, rd));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBfWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[679, 679, 701, 701, 1134], [1136, 1136, 1169, 1169, 1623], [1625, 1625, 1647, 1647, 1977], [1979, 1979, 2014, 2014, 2467], [2469, 2469, 2504, 2504, 3000], [3002, 3002, 3026, 3026, 3113], [3115, 3115, 3160, 3160, 3726], [3728, 3728, 3773, 3773, 4257], [4259, 4259, 4296, 4296, 4772], [4774, 4774, 4830, 4830, 5938], [5940, 5940, 5986, 5986, 6043], [6045, 6045, 6067, 6067, 6094], [6096, 6096, 6118, 6118, 6145], [6147, 6147, 6169, 6169, 6207], [6209, 6209, 6231, 6231, 6269], [6271, 6271, 6307, 6307, 6513], [6515, 6515, 6545, 6545, 6658], [6660, 6660, 6691, 6691, 6755], [6757, 6757, 6781, 6781, 6903], [6937, 6937, 6961, 6961, 7088], [7090, 7090, 7115, 7115, 7299], [7301, 7301, 7322, 7322, 7477]], "test": "untested"}
{"id": "mt2BRt", "name": "occlusion͏", "author": "01000001", "description": "Little experiment I did, making use of the fact that objects in its own repeating field will never intersect. This should be generalizable to any composite signed distance function, but its not great. Simple cases work, but nothing else does.", "tags": ["raymarching", "basic", "experiment"], "likes": 3, "viewed": 96, "published": 3, "date": "1694401950", "time_retrieved": "2024-07-30T17:34:34.773080", "image_code": "int maxSteps = 512;\nfloat maxDepth = 500.;\nfloat minDist = 0.001;\nvec3 lightDir = vec3(.5, -.4, 1.);\n\nconst float aoScale = 0.8;\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n    lightDir = normalize(lightDir);\n\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U - r)/r.y;\n    vec2 muv = iMouse.xy == vec2(0)?vec2(0):(2.*iMouse.xy - r)/r.y;\n    \n    float depth = 0.0;\n    vec3 camDir = vec3(-sin(-muv.x)*cos(muv.y), cos(-muv.x)*cos(muv.y), sin(muv.y));\n    vec3 o = vec3(0, 0, -.5) - camDir*6.;\n    vec3 camRight = normalize(cross(camDir, vec3(0, 0, 1)));\n    vec3 camUp = (cross(camRight, camDir));\n    vec3 dirV = normalize(camDir*2. + camRight * uv.x + camUp * uv.y);\n    vec3 p;\n    \n    for (int i = 0; i++ < maxSteps;){\n    \n        p = o + dirV * depth;\n        float d = DF(p).x;\n        \n        depth += d;\n        \n        if (depth > maxDepth){\n            depth = maxDepth;\n            break;\n        }\n        \n        if (d < minDist){\n            break;\n        }\n    }\n    \n    vec3 norma = norm(p, depth * 1e-4, 0);\n    vec3 normb = norm(p, depth * 1e-4, 1);\n    \n    O*=0.;\n    \n    float light = 1.;\n    \n    float f = smoothstep(0., 1.,-dot(norma, normb)*.5+.5);\n    \n    float ao = sqrt(DF(p).y);\n    \n    O = vec4(.7);\n    light *= min(1., ao/f / aoScale);\n    light *= (dot(norma, lightDir) * .3 + .5) / (depth*.2);\n    O.xyz *= light;    \n    \n    O = pow(O, vec4(1./2.4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define update;     if (x < one){\\\n        three = two;\\\n        two = one;\\\n        one = x;\\\n    } else if (x < two) { \\\n        three = two; \\\n        two = x; \\\n    } else if (x < three) { \\\n        three = x; \\\n    } \\\n        \n    \n#define rot(x) mat2(cos(x + vec4(0, 33, 11, 0)))\n    \nfloat boxDF( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 DF(vec3 p){\n    float one   = 1e20;\n    float two   = 1e20;\n    float three = 1e20;\n    float x = 0.;\n    vec3 d = p;\n            \n    \n    // Make this procedural iterations\n    \n    \n    for (float i = 0.; i++<5.;){\n        d = p;\n        d.y -= i;\n        d.xy *= rot(i/2.);\n        d.yz *= rot(i/5.);\n        d = mod(d, 10./i)-5./i;\n\n        x = boxDF(d, vec3(exp(-i/2.))*2.);\n        update;\n\n    }\n    /*\n    d = p;\n    d.yz *= rot(.8);\n    d.xy *= rot(1.);\n    d = mod(d, 6.)-3.;\n    \n    x = boxDF(d, vec3(1));\n    update;\n    \n    \n    d = p;\n    d.yz *= rot(.2);\n    d.xy *= rot(1.2);\n    d = mod(d, 4.)-2.;\n    \n    x = boxDF(d, vec3(.5));\n    update;\n*/\n\n    return vec3(one, two, three);\n}\n\nvec3 norm(vec3 p, float eps, int i){\n    return vec3(\n        DF(p + vec3(eps, 0, 0))[i] - DF(p - vec3(eps, 0, 0))[i],\n        DF(p + vec3(0, eps, 0))[i] - DF(p - vec3(0, eps, 0))[i],\n        DF(p + vec3(0, 0, eps))[i] - DF(p - vec3(0, 0, eps))[i]\n    )/(2.*eps);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2BRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 170, 170, 1396]], "test": "untested"}
{"id": "DtjBWW", "name": "simple noise 1", "author": "drennan", "description": "describe your shader", "tags": ["noise"], "likes": 1, "viewed": 133, "published": 3, "date": "1694394405", "time_retrieved": "2024-07-30T17:34:35.710574", "image_code": "//PARAMETERS. These can be anything you want, just adjust them until the noise looks random enough\nconst float variant1 = 56.2327467238;\nconst float variant2 = 4029.9435394853;\nconst float scale = 1.;\n\nfloat hash21(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat RNG(vec2 UV)\n{\n    //Basic RNG, copied from the approach by The Art of Code (Martijn Steinrucken)\n    //https://www.youtube.com/watch?v=zXsWftRdsvU&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5&index=18\n    return fract(sin(UV.x * variant1 + UV.y * variant2) * 5647.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    \n    float c = RNG(uv*scale);\n    \n    //Testing out hash21, suggested by nextrix. To go back to the old RNG, comment the line below\n    c = hash21(uv*scale);\n    \n    // Output to screen\n    fragColor = vec4(c,c,c, 1.0);\n}\n\n//It's literally just a RNG. I don't see why I should have to restrict, license this or force you to credit me for it.\n//Use this however you want. Commercial or non-commercial, I don't really care.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 224, 224, 312], [314, 314, 334, 516, 585], [587, 587, 644, 694, 1020]], "test": "untested"}
{"id": "Dl2Bzd", "name": "Transformer Circuit", "author": "wyatt", "description": "2D Transformer Circuit. It was not sufficient to place two wires next to each other (The secondary circuit would act like a capacitor) , it was necessary to place Iron boxes around the coupled wires two get the secondary to flow.", "tags": ["maxwell", "wire", "em"], "likes": 31, "viewed": 282, "published": 3, "date": "1694392981", "time_retrieved": "2024-07-30T17:34:36.662030", "image_code": "// Fork of \"Inductor Circuit\" by wyatt. https://shadertoy.com/view/ct2Bzc\n// 2023-09-10 23:43:33\n\n// Fork of \"Superconduction\" by wyatt. https://shadertoy.com/view/ct2BR3\n// 2023-09-10 05:32:08\n\n// Fork of \"Transverse Antenna\" by None. https://shadertoy.com/view/-1\n// 2023-09-09 23:08:59\n\n// Fork of \"Transverse Antenna\" by wyatt. https://shadertoy.com/view/dt2fRK\n// 2023-09-09 23:08:39\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 12:47:03\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 02:41:53\n\nMain {\n   vec4 a = .25*(A(U+vec2(0,1))+A(U+vec2(1,1))+A(U+vec2(1,0))+A(U+vec2(0,0)));\n    vec4 b = B(U);\n    \n    \n        \n        \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    float q = (n.y-s.y+e.x-w.x);\n    \n    \n    \n    b = .7*atan(100.*b);\n    \n    Q = length(b.xy)*(.5+.5*sin(-1.+atan(b.x,b.y)+vec4(1,2,3,4)));\n    \n    Q += 1.*max(vec4(-q,0,q,1),0.);\n    \n   if (roundbox(U-vec2(.262,.5)*R,vec2(.05,.18)*R,1.)<0.) Q = vec4(1.,.5,.3,1);\n   else if (L) {\n        Q = atan(abs(3e0*a.z))*abs(sin(-3.+abs(3e0*a.z)+vec4(1,2,3,4)));\n    }else {\n       float l = length(a.xy);\n        a *= 100.;\n        if (!(W)) {\n            Q = 1.-(1.-.75*atan(.1*l)*max(sin(-2.+.04*l+vec4(1,2,3,4)),0.))*(1.-exp(-5.*length(a.xy)))*\n                smoothstep(0.,2.*fwidth(cos(6.*atan(a.x,a.y))),abs(cos(6.*atan(a.x,a.y))));\n        }\n    }\n    \n    \n    if (U.x<52.||U.y<52.||R.x-U.x<52.||R.y-U.y<52.)\n        Q *= 0.;\n        \n        //Q = .5+(B(U))*1e2;\n    //Q = .1*max(vec4(-q,0,q,1),0.);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\n#define X .005\n#define Y .01\n\n#define Wire max(roundbox(U-vec2(.55,.5)*R,vec2(.6,.65)*R,0.),-roundbox(U-vec2(.55,.5)*R,vec2(.55,.55)*R,0.))\n\n#define Cap roundbox(U-vec2(.74,.5)*R,vec2(.1,.08)*R,0.)\n\n#define Gap roundbox(U-vec2(.7375,.5)*R,vec2(.03,.5)*R,0.)\n\n#define Sep roundbox(U-vec2(.5,.5)*R,vec2(.002,1.)*R,0.)\n\n#define Middle roundbox(U-vec2(.5,.5)*R,vec2(.05,.6)*R,0.)\n\n#define L max(roundbox(U-vec2(.5,.5)*R,vec2(.12,.4)*R,0.),-Sep+.025*R.x)<0.\n\n#define W max(min(Wire,Middle),-Sep) < 0.\n\n\nfloat f (float x) {\n    // Change the input signal here!\n    return smoothstep(0.,1.,x)*sin(.5*x);\n}\nfloat ln (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\nfloat roundbox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max(abs(p.x)-h.x,abs(p.y)-h.y);\n\t\t}", "buffer_a_code": "#define F 0\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    if ((iFrame*2+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x += .5/eps*(s.z-n.z) + b.x;\n        Q.y += .5/eps*(e.z-w.z) + b.y ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y)-b.z;\n    }\n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n        \n        \n    \n    \n    \n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    \n    Q = B(U);\n    vec4 a = A(U);\n    \n    if (W) \n    {\n        Q.xy -= X*a.xy+Y*Q.xy;\n    \n        Q.xy += 100.*vec2(0,1)*exp(-length(U-vec2(.263,.5)*R))*\n        \n            sin(20.*float(iFrame)/60./R.y);\n        \n    }\n    \n    if (L) \n    {\n        Q.z -= a.z+Q.z;\n    }\n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define F 1\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    if ((iFrame*2+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x += .5/eps*(s.z-n.z) + b.x;\n        Q.y += .5/eps*(e.z-w.z) + b.y ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y)-b.z;\n    }\n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n        \n        \n    \n    \n    \n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    \n    Q = B(U);\n    vec4 a = A(U);\n    \n    if (W) \n    {\n        Q.xy -= X*a.xy+Y*Q.xy;\n    \n        Q.xy += 100.*vec2(0,1)*exp(-length(U-vec2(.263,.5)*R))*\n        \n            sin(20.*float(iFrame)/60./R.y);\n        \n    }\n    \n    if (L) \n    {\n        Q.z -= a.z+Q.z;\n    }\n    \n\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2Bzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cljBRt", "name": "fryin' pans", "author": "elenzil", "description": "black and white design for screen-printing a cookbook cover", "tags": ["printing", "pan", "lineart", "screenprint", "silkscreen", "pans", "skillet", "frying"], "likes": 16, "viewed": 179, "published": 3, "date": "1694377790", "time_retrieved": "2024-07-30T17:34:37.684297", "image_code": "// Fork of \"draft - fryin' pans\" by elenzil. https://shadertoy.com/view/DtSBRc\n// 2023-09-10 20:28:44\n\n// A collection of frying pans to use for silkscreening\n// the cover of a cookbook.\n//\n// Pretty gruesome code.\n// In this one I tried out using Globals for things like\n// current Pixel Coordinate, current Color, etc,\n// in order to simplify the function signatures.\n// But I won't be doing it that way again.\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n      float zoom = 0.8;\n      float eps;\n      vec2  P;\n      vec2  Q;\n      float C;\n      float W;\n      \nconst vec2 vX = vec2(1.0, 0.0);\nconst vec2 vY = vX.yx;\nconst vec2 v0 = vX.yy;\nconst vec2 v1 = vX.xx;\n\nvec2 grad(in float value) {\n    return vec2(dFdx(value), dFdy(value));\n}\nfloat gradmag(in float value) {\n    return length(grad(value));\n}\n\nvoid fill(in float d, in vec2 col) {\n    float b = smoothstep(eps, -eps, d);\n    C = mix(C, col.x, col.y * b);\n}\n\nvoid outl(in float d, in vec2 col) {\n          d = abs(d) - (W * eps);\n//        d = 2e-3 * d / gradmag(d);\n    float b = smoothstep(eps, -eps, d);\n    C = mix(C, col.x, col.y * b);\n}\n\nfloat sdEllipse_2(in vec2 cen, in vec2 ab) { return sdEllipse(cen - P, ab); }\n\nfloat sdCircle(in vec2 cen, in float rad) { return distance(P, cen) - rad; }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 cen, in vec2 b ) {    vec2 d = abs(cen - P)-b;    return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdPan(\n    float rad,\n    float handle_length,\n    bool lipL,\n    bool lipR,\n    bool circ,\n    bool hole\n    ) {\n    float d = 1e9;\n    \n    vec2 QQ = Q;\n    QQ.x += (rad + handle_length) / 2.0;\n    QQ.x -= 0.5;\n    \n    float ellipse_offset = rad + handle_length * 1.1;\n    float ellipse_length = handle_length * 0.3;\n    \n    if (hole) {\n        QQ.x -= ellipse_offset + ellipse_length * 0.5;\n        QQ *= rot2_deg(5.0 * sin(iTime * 10.0 / rad));\n        QQ.x += ellipse_offset + ellipse_length * 0.5;\n    }\n\n    // basic circle of the pan  \n    P = QQ;\n    d = min (d, sdCircle(v0, rad));\n    \n    // ears of the pan\n    if (lipL) {\n        d = smin(d, sdCircle(vec2(-0.02, -rad), rad / 0.7 * 0.1), 2e-1);\n    }\n    if (lipR) {\n        d = smin(d, sdCircle(vec2(-0.02,  rad), rad / 0.7 * 0.1), 2e-1);\n    }\n    \n    // pan handle\n    P = QQ;\n    // taper space a little\n    P.y = mix(P.y, P.y * 0.8, P.x);\n    \n    d = smin(d, sdBox(vX * (rad + handle_length / 2.0), vec2(handle_length, 0.0)) - 0.1, 1e-1);\n\n    // outline\n//  d = min(d, abs(d - 6.0 * W * eps) - 2.0 * W * eps);\n\n    // cut an ellipse in the end of the handle\n    if (hole) {\n        P.y = mix(P.y * 1.4, P.y, (P.x - ellipse_offset) * 4.0);\n\n        d = max(d, -sdEllipse_2(vX * ellipse_offset, vec2(ellipse_length, 0.05)));\n    }\n    \n    // cut a circle in the pan to indicate the bottom\n    if (circ) {\n        P = QQ;\n        d = max (d, -(abs(sdCircle(v0, rad * 0.8)) - W * eps));\n    }\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    zoom = 0.445;\n    // normalized coordinate\n    float cellSize = 400.0;\n  //  XY += RES / MINRES * iTime * 50.0;\n    XY.y -= iTime * 50.0;\n    \n    // color\n    C    = 1.0;\n\n    float d = 1e9;\n\n    // epsilon for AA\n    eps  = 2.0 / cellSize / zoom;\n\n    // line width (in eps's)\n    W    = 2.0;\n\n    for (uint pass = 0u; pass <= 1u; ++pass) {\n        if (pass == 1u) {\n            XY += cellSize / 2.0;\n        }\n    \n        vec2 xy = mod(XY, cellSize);\n        Q = (xy * 2.0 - cellSize) / cellSize / zoom;\n        Q *= rot2_deg(90.0);\n        Q.x += 0.1;\n\n        vec2  cellIndx = vec2(XY / cellSize);\n        uvec2 cellIndxU = uvec2(abs(cellIndx));\n        \n        uint S = pass * 100u;\n    \n        float hash1 = whangHashNoise(cellIndxU.x, cellIndxU.y, S++);\n        float hash2 = whangHashNoise(cellIndxU.x, cellIndxU.y, S++);\n        float hash3 = whangHashNoise(cellIndxU.x, cellIndxU.y, S++);\n        float hash4 = whangHashNoise(cellIndxU.x, cellIndxU.y, S++);\n        float hash5 = whangHashNoise(cellIndxU.x, cellIndxU.y, S++);\n        float hash6 = whangHashNoise(cellIndxU.x, cellIndxU.y, S++);\n\n        float panSize = 1.0 + 0.8 * (hash1 - 0.5);\n        float panHndl = panSize * (0.5 + 0.3 * hash2);\n        bool  lipL    = hash3 < 0.5;\n        bool  lipR    = hash4 < 0.5;\n        bool  circ    = lipL || lipR || hash5 < 0.8;\n        bool  hole    = hash6 < 0.9;\n\n        d = min(d, sdPan(panSize, panHndl, lipL, lipR, circ, hole));\n    }\n  \n    fill(d, vec2(0.0, 1.0));\n    outl(d, vec2(0.5, 0.0));\n\n    vec3 BG = vec3(1.0, 1.0, 0.95);\n    vec3 FG = vec3(0.1, 0.1, 0.20);\n\n    RGBA.rgb = mix(BG, FG, 1.0 - C);\n    RGBA.a   = 1.0;\n    \n    // view distance field\n    // RGBA.rgb = mix(RGBA.rgb, vec3(0.4, 0.3, 0.1), sin(d * 100.0) * 0.5 + 0.5);\n}", "image_inputs": [], "common_code": "float sdEllipse( in vec2 p, in vec2 ab )\n{\n    if (abs(ab.x - ab.y) < 1e-3) {\n        return length(p) - ab.x;\n    }\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if (d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n// SebH\n// https://www.shadertoy.com/view/ldjczd\nfloat whangHashNoise(uint u, uint v, uint s)\n{\n    uint seed = (u*1664525u + v) + s;\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return value;\n}\n\n\nmat2 rot2_deg(float deg) {\n    float rads = deg / 360.0 * 3.14159265359 * 2.0;\n    return mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n}\n\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljBRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[692, 692, 719, 719, 764], [765, 765, 796, 796, 830], [832, 832, 868, 868, 944], [946, 946, 982, 982, 1129], [1131, 1131, 1175, 1175, 1208], [1210, 1210, 1253, 1253, 1286], [1288, 1339, 1377, 1377, 1461], [1463, 1463, 1582, 1582, 2953], [2956, 2956, 3001, 3001, 4770]], "test": "untested"}
{"id": "ctSfRd", "name": "Ionic Plasma", "author": "wyatt", "description": "A gas where positive and negative particles have disassociated. ", "tags": ["maxwell", "wire", "em"], "likes": 17, "viewed": 329, "published": 3, "date": "1694356811", "time_retrieved": "2024-07-30T17:34:38.780366", "image_code": "// Fork of \"Superconduction\" by wyatt. https://shadertoy.com/view/ct2BR3\n// 2023-09-10 14:06:26\n\n// Fork of \"Transverse Antenna\" by None. https://shadertoy.com/view/-1\n// 2023-09-09 23:08:59\n\n// Fork of \"Transverse Antenna\" by wyatt. https://shadertoy.com/view/dt2fRK\n// 2023-09-09 23:08:39\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 12:47:03\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 02:41:53\n\nMain {\n   vec4 a = .25*(A(U+vec2(0,1))+A(U+vec2(1,1))+A(U+vec2(1,0))+A(U+vec2(0,0)));\n    \n    \n    vec4 b = B(U);\n        \n    vec4 n = .25*(A(U+vec2(0,2))+A(U+vec2(1,2))+A(U+vec2(1,1))+A(U+vec2(0,1)));\n    vec4 e = .25*(A(U+vec2(1,1))+A(U+vec2(2,1))+A(U+vec2(2,0))+A(U+vec2(1,0)));\n    vec4 s = .25*(A(U+vec2(0,0))+A(U+vec2(1,0))+A(U+vec2(1,-1))+A(U+vec2(0,-1)));\n    vec4 w = .25*(A(U+vec2(-1,1))+A(U+vec2(0,1))+A(U+vec2(0,0))+A(U+vec2(-1,0)));\n    \n    float q = (n.y-s.y+e.x-w.x);\n    \n    Q = .5+.25*vec4(-q,-abs(q),q,1);\n    \n    Q *= 1.-2.*vec4(b.x+b.y,b.x,-b.y,0);\n    Q = Q*Q*1.5;\n    //Q = a;\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\n#define K 1.\n\nfloat f (float x) {\n    // Change the input signal here!\n    return smoothstep(0.,1.,x)*sin(.5*x);\n}\nfloat ln (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\nfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max(abs(p.x)-h.x,abs(p.y)-h.y);\n\t\t}", "buffer_a_code": "#define F 0\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*2+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x += .5/eps*(s.z-n.z) + b.x-b.z;\n        Q.y += .5/eps*(e.z-w.z) + b.y-b.w;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y);\n    }\n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n        \n        \n    if (iMouse.z>0.) {\n        Q.xy += exp(-.1*length(U-iMouse.xy))\n            *.1*vec2(sin(iTime),cos(iTime));\n        \n    }\n    \n    \n        \n    if (iFrame < 2 && length(U-.5*R) < 150.) Q.z += smoothstep(1.,0.,float(iFrame)/60.);\n    \n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 f (vec2 v) {return v*inversesqrt(1.+10.*dot(v,v));}\nMain {\n    \n    Q = B(U);\n    vec4 a = A(U);\n    vec2 u = U, v = U;\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    Q = vec4(B(u).xy,B(v).zw);\n    Q.xy -= .02*K*a.xy-(1.-K)*Q.xy;\n    Q.zw += .02/4000.*K*a.xy-(1.-K)*Q.zw;\n    \n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define F 1\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*2+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x += .5/eps*(s.z-n.z) + b.x-b.z;\n        Q.y += .5/eps*(e.z-w.z) + b.y-b.w;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y);\n    }\n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n        \n        \n    if (iMouse.z>0.) {\n        Q.xy += exp(-.1*length(U-iMouse.xy))\n            *.1*vec2(sin(iTime),cos(iTime));\n        \n    }\n    \n    \n        \n    if (iFrame < 2 && length(U-.5*R) < 150.) Q.z += smoothstep(1.,0.,float(iFrame)/60.);\n    \n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec2 f (vec2 v) {return v*inversesqrt(1.+10.*dot(v,v));}\nMain {\n    \n    Q = B(U);\n    vec4 a = A(U);\n    vec2 u = U, v = U;\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    u -= .5*f(B(u).xy);\n    v -= .5*f(B(v).zw);\n    Q = vec4(B(u).xy,B(v).zw);\n    Q.xy -= .02*K*a.xy-(1.-K)*Q.xy;\n    Q.zw += .02/4000.*K*a.xy-(1.-K)*Q.zw;\n    \n    \n\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ct2Bzc", "name": "Capacitor Circuit", "author": "wyatt", "description": "Here an inductor (the boxes on the right) resists changes in the current. After a while the battery is disconnected.", "tags": ["maxwell", "wire", "em"], "likes": 28, "viewed": 310, "published": 3, "date": "1694328136", "time_retrieved": "2024-07-30T17:34:39.609150", "image_code": "// Fork of \"Superconduction\" by wyatt. https://shadertoy.com/view/ct2BR3\n// 2023-09-10 05:32:08\n\n// Fork of \"Transverse Antenna\" by None. https://shadertoy.com/view/-1\n// 2023-09-09 23:08:59\n\n// Fork of \"Transverse Antenna\" by wyatt. https://shadertoy.com/view/dt2fRK\n// 2023-09-09 23:08:39\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 12:47:03\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 02:41:53\n\nMain {\n   vec4 a = .25*(A(U+vec2(0,1))+A(U+vec2(1,1))+A(U+vec2(1,0))+A(U+vec2(0,0)));\n    vec4 b = B(U);\n    \n    \n        \n        \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    float q = (n.y-s.y+e.x-w.x);\n    \n    \n    \n    b = .7*atan(500.*b);\n    \n    Q = length(b.xy)*(.5+.5*sin(-1.+atan(b.x,b.y)+vec4(1,2,3,4)));\n    \n    Q += 1.*max(vec4(-q,0,q,1),0.);\n    \n   if (roundbox(U-vec2(.262,.5)*R,vec2(.05,.18)*R,1.)<0.) Q = vec4(1.,.5,.3,1);\n   else if (L) {\n        Q = atan(abs(1e2*a.z))*(.5+.5*sin(-2.+abs(1e2*a.z)+vec4(1,2,3,4)));\n    }else {\n       float l = length(a.xy);\n        a *= 100.;\n        if (!(W)) {\n            Q = 1.-(1.-.75*atan(.1*l)*max(sin(-2.+.04*l+vec4(1,2,3,4)),0.))*(1.-exp(-5.*length(a.xy)))*\n                smoothstep(0.,2.*fwidth(cos(6.*atan(a.x,a.y))),abs(cos(6.*atan(a.x,a.y))));\n        }\n    }\n    \n    \n    if (U.x<52.||U.y<52.||R.x-U.x<52.||R.y-U.y<52.)\n        Q *= 0.;\n        \n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\n#define K .1\n\n#define Wire max(roundbox(U-.5*R,vec2(.5,.65)*R,0.),-roundbox(U-.5*R,vec2(.45,.55)*R,0.))\n\n#define Cap roundbox(U-vec2(.74,.5)*R,vec2(.15,.12)*R,0.)\n\n#define Gap roundbox(U-vec2(.7375,.5)*R,vec2(.2,.02)*R,0.)\n\n#define L false\n//max(roundbox(U-vec2(.7375,.5)*R,vec2(.1,.3)*R,0.),-Gap)<0.\n\n#define W max(min(Wire,Cap),-Gap) < 0.\n\nfloat f (float x) {\n    // Change the input signal here!\n    return smoothstep(0.,1.,x)*sin(.5*x);\n}\nfloat ln (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\nfloat roundbox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max(abs(p.x)-h.x,abs(p.y)-h.y);\n\t\t}", "buffer_a_code": "#define F 0\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    if ((iFrame*2+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x += .5/eps*(s.z-n.z) + b.x;\n        Q.y += .5/eps*(e.z-w.z) + b.y ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y)-b.z;\n    }\n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n        \n        \n    \n    \n    \n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    \n    Q = B(U);\n    vec4 a = A(U);\n    \n    if (W) \n    {\n        Q.xy -= K*a.xy+(1.-K)*Q.xy;\n    \n        Q.xy += 100.*vec2(0,1)*exp(-length(U-vec2(.263,.5)*R))*\n        \n            smoothstep(0.,1.,float(iFrame)/60.);//*\n            //smoothstep(102.,101.,float(iFrame)/60.);\n        \n    }\n    \n    if (L) \n    {\n        Q.z -= a.z+Q.z;\n    }\n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define F 1\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    if ((iFrame*2+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x += .5/eps*(s.z-n.z) + b.x;\n        Q.y += .5/eps*(e.z-w.z) + b.y ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y)-b.z;\n    }\n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n        \n        \n    \n    \n    \n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    \n    Q = B(U);\n    vec4 a = A(U);\n    \n    if (W) \n    {\n        Q.xy -= K*a.xy+(1.-K)*Q.xy;\n    \n        Q.xy += 100.*vec2(0,1)*exp(-length(U-vec2(.263,.5)*R))*\n        \n            smoothstep(0.,1.,float(iFrame)/60.);//*\n            //smoothstep(102.,101.,float(iFrame)/60.);\n        \n    }\n    \n    if (L) \n    {\n        Q.z -= a.z+Q.z;\n    }\n    \n\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2Bzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DlBXzK", "name": "flow map noise", "author": "lanx06", "description": "https://www.youtube.com/watch?v=SA6Y3L-X0Po&ab_channel=PolyToots", "tags": ["map", "flow", "force"], "likes": 2, "viewed": 187, "published": 3, "date": "1694323224", "time_retrieved": "2024-07-30T17:34:40.378094", "image_code": "#define T iTime*0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col; \n    \n    vec2 uu=vec2(noises(uv,5),noises(uv+vec2(1.0),5));\n    //uu=vec2(0.6);\n    col.xy=uu;\n    //uu.x=abs(sin(uv.x*10.0));\n    uu=(uu-0.5)*2.0;\n    float power=0.1;\n    vec2 ua=uv+uu*fract(T)*power;\n    vec2 ub=uv+uu*fract(T+0.5)*power; \n    \n    vec3 a=texture(iChannel0,ua).xyz;\n    vec3 b=texture(iChannel0,ub).xyz;\n    //col.xy=ua; \n    col=mix(a,b,abs((fract(T)-0.5)*2.0));\n    \n    //col=mix(a,b,abs(sin(T)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define fc fragCoord.xy\n#define tx(offset)(texture( iChannel0,( (fragCoord.xy+offset) /iResolution.xy) ) )\n#define PI 3.1415926538\nvec2 dir8[8]=vec2[](vec2(1.0,0.0),vec2(1.0,1.0),vec2(0.0,1.0),vec2(-1.0,1.0),vec2(-1.0,0.0),vec2(-1.0,-1.0),vec2(0.0,-1.0),vec2(1.0,-1.0));\nfloat dir8w[8]=float[](0.2,0.05,0.2,0.05,0.2,0.05,0.2,0.05);\n\nfloat sin_lerp(float a,float b,float t){\n    float tem=(1.0-cos(t*PI))/2.0;\n    return a*(1.0-tem)+b*tem;\n}\nvec2 sin_lerp(vec2 a,vec2 b,float t){\n    float tem=(1.0-cos(t*PI))/2.0;\n    return a*(1.0-tem)+b*tem;\n}\nfloat random(float seed){\n    return fract(sin(seed+1.) * 43758.5453);\n}\nvec2 random(vec2 p){\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return vec2(random(p.x),random(p.y));\n}\nvec2 lerp(vec2 a,vec2 b,float t){\n    return sin_lerp(a,b,t);\n    //return mix(a,b,t);\n}\nvec2 noise(vec2 uv){\n    vec2 v0=random(floor(uv));\n    vec2 v1=random(floor(uv)+vec2(1,0));\n    vec2 v2=random(floor(uv)+vec2(1,1));\n    vec2 v3=random(floor(uv)+vec2(0,1));\n    vec2 dtt=uv-floor(uv);\n    vec2 x1 =lerp(v0,v1,dtt.x);\n    vec2 x2 =lerp(v3,v2,dtt.x);\n    vec2 o=lerp(x1,x2,dtt.y);\n    //return v2;\n    return o;   \n}\nfloat noises(vec2 uv,int level){\n    float c=0.0;\n    float scale=10.0;\n    float t=2.0;\n    for(int i=0;i<10;i++){\n        if(i>level)\n            break;\n        c+=noise(uv*scale).x/t;\n        scale*=2.0;\n        t*=2.0;\n    }\n    return c;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 611]], "test": "untested"}
{"id": "ct2BR3", "name": "Superconduction", "author": "wyatt", "description": "A region of zero resistance. Initial condition is an inductive loop. Mouse creates a capacitive vector. ", "tags": ["maxwell", "wire", "em"], "likes": 15, "viewed": 256, "published": 3, "date": "1694309366", "time_retrieved": "2024-07-30T17:34:41.438261", "image_code": "// Fork of \"Transverse Antenna\" by None. https://shadertoy.com/view/-1\n// 2023-09-09 23:08:59\n\n// Fork of \"Transverse Antenna\" by wyatt. https://shadertoy.com/view/dt2fRK\n// 2023-09-09 23:08:39\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 12:47:03\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 02:41:53\n\nMain {\n   vec4 a = .25*(A(U+vec2(0,1))+A(U+vec2(1,1))+A(U+vec2(1,0))+A(U+vec2(0,0)));\n    \n    \n    vec4 b = B(U);\n        \n    vec4 n = .25*(A(U+vec2(0,2))+A(U+vec2(1,2))+A(U+vec2(1,1))+A(U+vec2(0,1)));\n    vec4 e = .25*(A(U+vec2(1,1))+A(U+vec2(2,1))+A(U+vec2(2,0))+A(U+vec2(1,0)));\n    vec4 s = .25*(A(U+vec2(0,0))+A(U+vec2(1,0))+A(U+vec2(1,-1))+A(U+vec2(0,-1)));\n    vec4 w = .25*(A(U+vec2(-1,1))+A(U+vec2(0,1))+A(U+vec2(0,0))+A(U+vec2(-1,0)));\n    \n    float q = (n.y-s.y+e.x-w.x);\n    \n    Q = .5+4.*vec4(-q,-abs(q),q,1);\n    \n    Q *= 1.-8.*vec4(b.x+b.y,b.x,-b.y,0);\n    \n    //Q = a;\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\n#define K 1.\n\nfloat f (float x) {\n    // Change the input signal here!\n    return smoothstep(0.,1.,x)*sin(.5*x);\n}\nfloat ln (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\nfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max(abs(p.x)-h.x,abs(p.y)-h.y);\n\t\t}", "buffer_a_code": "#define F 0\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x += .5/eps*(s.z-n.z) + b.x;\n        Q.y += .5/eps*(e.z-w.z) + b.y ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y);\n    }\n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n        \n        \n    if (iMouse.z>0.) {\n        Q.xy += exp(-.1*length(U-iMouse.xy))\n            *.1*vec2(sin(iTime),cos(iTime));\n        \n    }\n    \n    \n        \n    if (iFrame < 2 && length(U-.5*R) < 50.) Q.z += smoothstep(1.,0.,float(iFrame)/60.);\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    \n    Q = B(U);\n    vec4 a = A(U);\n    Q.xy -= .02*K*a.xy+(1.-K)*Q.xy;\n    \n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2BR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdSBW3", "name": "Dynamic Grid 0", "author": "samansepehri", "description": "This is an interactive grid renderer. You can change the block size by clicking at different positions on the frame.", "tags": ["mouse", "grid", "checkerboard", "block"], "likes": 0, "viewed": 129, "published": 3, "date": "1694305339", "time_retrieved": "2024-07-30T17:34:42.265050", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 blockSize = iMouse.xy; // abs(cos(iTime + 100.)) * 500. + 1.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(ivec2(fragCoord/blockSize)) / (iResolution.xy / blockSize);\n\n    //uv = vec2(ivec2(uv));\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = vec3(uv.xy, 0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 478]], "test": "untested"}
{"id": "cdsBDN", "name": "Mirror_Cube", "author": "jakobkruse", "description": "descr", "tags": ["test"], "likes": 1, "viewed": 159, "published": 3, "date": "1694305195", "time_retrieved": "2024-07-30T17:34:43.025017", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.16,0.716,0.117);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 1.87; i++) {\n        uv = fract(uv + sin(iTime)) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.7 + iTime*.1 );\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 208], [210, 210, 267, 267, 762]], "test": "untested"}
{"id": "dtBBRc", "name": "Psychedelic spins", "author": "rcargou", "description": "have fun", "tags": ["sdf", "psychedelic", "sphericalcoordinates", "symetry"], "likes": 79, "viewed": 3296, "published": 3, "date": "1694299780", "time_retrieved": "2024-07-30T17:34:44.101140", "image_code": "// bloom from https://www.shadertoy.com/view/lstSRS\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    \n    color += GetBloom(uv) * 0.12;\n    \n    color *= 2.0;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n   // fragColor = texture(iChannel1, uv) * 10111.;\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 HUEtoRGB(in float hue)\n{\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5)) * (exp(1.43876719683e5/(T*L)) - 1.);\n    return 1. - exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n// Smooth minimum function. Hardcoded with the smoothing value \"0.25.\"\nfloat sminP(in float a, in float b , float s){\n    \n    float h = clamp(2.*(b - a) + 0.5, 0.0, 1.0);\n    return (b - s*h)*(1. - h) + a*h;\n    \n}\nfloat smin0( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 sphericalToCartesian(vec3 p) {\n    return vec3(p.x * sin(p.y) * cos(p.z),\n                p.x * sin(p.y) * sin(p.z),\n                p.x * cos(p.y));\n}\n\nvec3 cartestianToSpherical(vec3 p) {\n    float d = length(p);\n    return vec3 ( d, acos(p.z / d), sign(p.y) * acos(p.x / length(p.xy)) );\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat hash11( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\nvec3 hash13(float n) {\n    float n1 = n;\n    float n2 = hash11(n);\n    float n3 = hash11(n2);\n    return vec3(hash11(n1),hash11(n2),hash11(n3));\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}", "buffer_a_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\n// play with thoses\nint sym = 1;\nint iqheart = 0;\nint megamod = 0;\n\nfloat yuid = 0.;\nfloat sdTunnelDepth(in vec3 p, out vec3 matData, float time, float tid) {\nvec3 l = p;\n//p.y+=cos(p.x * 4.) / 4.;\nfloat ty = 5.5;\np.z = mod(p.z + time*-18., ty)-ty/2.;\nif (sym ==1) {\np.xz = -abs(p.xz);\np.xy *= rotate2d(iTime);\np.xz = -abs(p.xz);\n\np.xy *= rotate2d(iTime / 4. + 12.);\np.xz = -abs(p.xz);\np.xy *= rotate2d(iTime / 8. + 3.);\np.xz = -abs(p.xz);\n\np.xy *= rotate2d(iTime/ -3. + 4.);\np.xz = -abs(p.xz);\np.xy *= rotate2d(iTime / - 7. + 5.);\np.xz = -abs(p.xz);\n}\n//p.zyx*=2.;\nfloat b =.0;\n    p.xy *= rotate2d(p.z/ 1.5)/1.;\n \n    p.xy*=rotate2d(time * 2.);\n    float r = 4.;//+sin(iTime) ;\n    p = cartestianToSpherical(p);\n   // p.z *= 6.+sin(time) * 5.;\n   float a = p.z;\n    p.z *= 3.;p.z+=time * -12.;\n    \n        p = sphericalToCartesian(p);\n        if (megamod==1)\n    p= mod(p, r) - r/2.;\n   // p.xyz = abs(p.xyz);\n    //p.x = abs(p.x);\n    p.z+=time * -6.;\n//    p.xy *= rotate2d(p.z/ 3.5 + time);\n    // global transformation\n  //  float u = 3.+cos(iTime / 120.) * 3., v = 2.*sin(iTime);\n    float u = 3.;\n    float v = 1.;\n    if (tid==0.){\n    p.x += sin(p.z*6. * u) / 11.+sin(p.z/11. + 1.7) / 2. * v;\n    p.y += cos(p.z*1. * u + time*3.) / 2. * v;\n    p.y += sin(p.z*2.  * u+ cos(time*6.)*2.) / 4. * v;\n   // p.xy *= rotate2d(time * 2.);\n     p.x += cos(p.z*.5 * u) / 24. * v;\n      //p.z += cos(iTime) * 2. * v;\n\n     }\n     \n    vec3 p1 = p;\n    vec3 p2 = p;\n \n    // spherical space\n    vec3 ps = cartestianToSpherical(p1);\n    float id = floor(ps.z / .2245);\n    matData.x = ps.z/2.+p.z/2. + time / .1;\n    if (tid==0.)\n    matData.x += 1.;\n//    matData.x = (ps.z+a)*.1+time/2.;//1.*( (ps.z + a)/13. +  p.z*0. + iTime*0.);//(ps.z + a) / 12. + iTime / 4. + p.z * 2.*sin(time / -25.);//3.;//id / .32;\n   // ps.z *=1.5 + sin(iTime)/2.;\n   \n   ps.z*=2.;\n   \n    //matData.y = mod(ps.z + time*100., 12.) - 6. ;\n    ps.z = mod(ps.z, .2245) -1.7;    \n    \n    p1 = sphericalToCartesian(ps);\n    matData.y = id;\n    p1.y+=1.5;\n    //if (mod(floor( (sin(iTime/ 12.) * 32.)),2.) == 0.)\n      // return length(p1.xy) - .05;\n    // Per cylinder transformation\n   // p1.xy *= rotate2d(id + time);\n   vec3 p4 = p1;\n    p1.x += cos(p.z*3.5 * hash11(id / 32.) * 21.14) / 12.;\n \n     p1.y+=cos(p.z * 2.* hash11(id / 12.)) / 5.;\n     float rep = .051;\n     p.z+=sin(p.x * 1.) / 2.5;\n    p.z+=time*-1.;\n    \n    p.z = mod(p.z, rep) - rep/2.;   \n    \n    float tdist = sdTorus(p.xzy, vec2(1.5,.0005));\n  //  return tdist;\n  \n  vec3 pp = p2;\n  r = .92;\n  pp.xy*=rotate2d(time * -12.);\n  pp.x-=11.5;\n  \n  pp = mod(pp, r) - r/2.;\n    float  ppdist = length(pp) - .02;\n    return min( min(length(p1.xy) - .05 /*+ sin(iTime) /10.*/, tdist), ppdist);\n\n}\n\nfloat sdTunnel(in vec3 p, out vec3 matData) {\n\n    float time = iTime / 2.;\n    float d1 =  sdTunnelDepth(p, matData, -time/ 6. + yuid*330.1123, 0.);\n    \n    return d1;\n    float d2 =  sdTunnelDepth(p * vec3(.4, .4, .5), matData, time / 7. + 1., 1.);\n     matData.z = 1.;\n   //  if (mod(floor( (sin(iTime/ 2.) * 32.)),2.) == 0.)\n     return d1;\n     //return d2;\n     if (d1<d2)\n     matData.z = 1.;\n    // if (sin(iTime) < -.3)\n    ;// d1=d2;\n    return min(d2,d1);\n}\n\nvec2 map( in vec3 pos , out vec3 matData)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    float d = 0.;\n     vec3 matData_tmp;\n     if ((d = sdTunnel(pos, matData_tmp)) < res.x) {\n        res.x = d;\n        res.y = 1.;\n        matData=matData_tmp;\n    }\n    \n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 matData)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = .11;\n    float tmax = 30.0;\n\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<150 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t, matData );\n            if( abs(h.x)<(0.01*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x * .3;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 t;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy,t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,t ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    vec3 t;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos,t ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getcol(float x1) {\n\nfloat x2= mod(iTime / 3. + yuid * 4., 7.) + 0.;\nfloat x = fract(x1 / 1.);\n//x2=0.;\n    vec3 cols[7] = vec3[7] (pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) ),\n    pal( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )\n    );\n    return mix( cols[int(x2)], cols[int(mod(x2, 7.)) + 1] , fract(x2));\n}\n\nvec3 render( in vec3 ro, in vec3 rd,vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    \n    vec3 matData;\n    vec2 res = castRay(ro,rd, matData);\n    float t = res.x;\n\tfloat m = res.y;\n    //  vec3 albedo = hash13(matData.x);\n    float i = matData.x;\n    vec3 nor = calcNormal(ro + rd * res.x);\n    float ao = calcAO(ro+rd*res.x, nor);\n   // vec3 albedo = pal( i, vec3(0.5,.5,0.5),vec3(.5,0.5,0.501),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    vec3 albedo = getcol(i);\n    \n  float idL = floor(mod(iTime, 14.));\n    if (res.x > .0f) {\n    \tcol = vec3(0.) + albedo* vec3(.9f, .5f, .5f) * max(.1f, dot(normalize((ro+ t * rd) - normalize(vec3(100.0f, 1000.0f, 100.0f))), \n             nor) );\n        col *= exp(res.x*-.1);   \n\n        //col *= 1.+15. * smoothstep(.1, .0,abs(matData.y - 1.));\n       \n       if (int(matData.y) % 22 == 0)\n            col *= 5. + 10.*float(sym);\n        else if (int(matData.y) % 8 == 0)\n            col *= 2. + 5.*float(sym);\n            \n     } else {\n        col = .3*pow(texture(iChannel0, uv/1. + vec2(iTime / 16., 0.)).xyz, vec3(5.)).xyz;\n     }\n    return col * (1.+ smoothstep(.1, .05, length(uv)) * 20. * float(sym==1));//*ao *ao*4.;\n   \treturn vec3(col*abs(nor));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .0f, -4.0f);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\nif (iqheart == 1) {\nfloat rr = 2.;\n//p.y-=iTime * 2.;\nvec2 ids;\np.y += -iTime * 2. + float(p.x>0.);\n ids = hash22(floor(p / rr));\nyuid= ids.x;\n\np = mod(p, rr) - rr/2.;\n}\n    // ray direction\n    vec3 rd = normalize( vec3(p.xy,.5) );\n\n    // render\t\n    vec3 col = render( ro, rd, p.xy );\n\n    // gamma\n   col = pow( col, vec3(1.2545) );\n   //  col = pow( col, vec3(.809545) );\n    \n    fragColor = vec4( saturate(col), 1.0 );\n    \n    //\tp = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x)/1.5;\n\t\n    // background color\n    vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    // animate\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\n    // shape\n\tp.y -= 0.25;\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n    \n\t// color\n\tfloat s = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.4*r;\n\ts = 0.3 + 0.7*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(2,0.2*r,0.3) / 15. * s / .5;\n\t\n//     col = mix( col, hcol, smoothstep( -0.01, 0.01, d-r) );\nif(iqheart==1)\n    col = mix(hcol / 4.,col,min(1., max(0.0,5.*(d-r ))));\n    fragColor = vec4(saturate(col),.0);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 1.12)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 290], [292, 292, 346, 346, 1283], [1285, 1285, 1314, 1314, 1359], [1361, 1361, 1390, 1390, 1442], [1444, 1444, 1506, 1506, 1615], [1617, 1617, 1648, 1648, 1954], [1956, 1956, 1983, 1983, 2562], [2564, 2564, 2621, 2621, 3226]], "test": "untested"}
{"id": "DlBBRc", "name": "Transformer", "author": "wyatt", "description": "Operation of a transformer!", "tags": ["maxwell", "wire", "em"], "likes": 20, "viewed": 265, "published": 3, "date": "1694283480", "time_retrieved": "2024-07-30T17:34:44.929926", "image_code": "// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 16:34:49\n\nMain {\n   vec4 H = .25*(A(U+vec2(0,1))+A(U+vec2(1,1))+A(U+vec2(1,0))+A(U+vec2(0,0)));\n    Q = vec4(1);\n    if (T) {\n        Q = sin(-2.+1000.*length(A(U).xy)+vec4(1,2,3,4));\n    } else {\n        \n        H *= 169.;\n         Q *=(1.-exp(-length(H.xy)))*(1.-\n             vec4(smoothstep(0.,2.*fwidth(cos(H.x)),abs(cos(H.x))))*\n             vec4(smoothstep(0.,2.*fwidth(cos(H.y)),abs(cos(H.y)))));\n    } \n    \n    \n    if (U.x<52.||U.y<52.||R.x-U.x<52.||R.y-U.y<52.)\n        Q *= 0.;\n        \n        \n    if (WA||WB||WC||WD) \n   {\n    \n        Q = .01*vec4(H.w,.25*abs(H.w),-H.w,1);\n    \n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\n#define Ro .01\n#define Xi .1\n\n\nfloat f (float x) {\n    // Change the input signal here!\n    return 10.*smoothstep(0.,1.,x)*sin(.02*x);\n}\n\n\nfloat roundbox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max(abs(p.x)-h.x,abs(p.y)-h.y);\n\t\t}\n        \n        \n#define WA roundbox(U-vec2(.24,.5)*R,vec2(.01*R.y,.25*R.y),.01*R.x)<0.\n#define WB roundbox(U-vec2(.37,.5)*R,vec2(.01*R.y,.25*R.y),.01*R.x)<0.\n#define WC roundbox(U-vec2(.64,.5)*R,vec2(.01*R.y,.25*R.y),.01*R.x)<0.\n#define WD roundbox(U-vec2(.77,.5)*R,vec2(.01*R.y,.25*R.y),.01*R.x)<0.\n#define T max(roundbox(U-.5*R,vec2(.5,.6)*R,.05*R.y),-roundbox(U-.5*R,vec2(.3,.3)*R,.003*R.y))<0.", "buffer_a_code": "#define F 0\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*2+F)%2==0) {\n        // dB/dt = -curl E\n        Q.x -=+.5/mu*(n.z-s.z)+Xi*b.x;\n        Q.y -=-.5/mu*(e.z-w.z)+Xi*b.y;\n    } else {\n        // dE/dt = curl B - j\n        Q.z -= .5/eps*(n.x-s.x-e.y+w.y) + Ro*Q.w;\n    }\n    Q.w += Q.z;\n    if (WA) Q.w += f((float(iFrame)/60.))/R.y;\n    else if (WB) Q.w +=-f((float(iFrame)/60.))/R.y;\n    else if (WC) ;\n    else if (WD) ;\n    else Q.w = 0.;\n    \n    \n    \n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\n    Q = B(U);\n    \n    vec4 a = A(U);\n    if (T)\n    Q.xy = a.xy;\n\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define F 1\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*2+F)%2==0) {\n        // dB/dt = -curl E\n        Q.x -=+.5/mu*(n.z-s.z)+Xi*b.x;\n        Q.y -=-.5/mu*(e.z-w.z)+Xi*b.y;\n    } else {\n        // dE/dt = curl B - j\n        Q.z -= .5/eps*(n.x-s.x-e.y+w.y) + Ro*Q.w;\n    }\n    Q.w += Q.z;\n    if (WA) Q.w += f((float(iFrame)/60.))/R.y;\n    else if (WB) Q.w +=-f((float(iFrame)/60.))/R.y;\n    else if (WC) ;\n    else if (WD) ;\n    else Q.w = 0.;\n    \n    \n    \n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\n    Q = B(U);\n    \n    vec4 a = A(U);\n    if (T)\n    Q.xy = a.xy;\n\n\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dt2fRK", "name": "Transverse Antenna", "author": "wyatt", "description": "same as https://www.shadertoy.com/view/ctBBzV\nbut the electric field is in the plane of the screen and the magnetic field is into/out of the page. ", "tags": ["maxwell", "wire", "em"], "likes": 23, "viewed": 291, "published": 3, "date": "1694265564", "time_retrieved": "2024-07-30T17:34:45.777657", "image_code": "// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 12:47:03\n\n// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-09 02:41:53\n\nMain {\n   vec4 E = .25*(A(U+vec2(0,1))+A(U+vec2(1,1))+A(U+vec2(1,0))+A(U+vec2(0,0)));\n    \n    E *= 100.;\n   \n             Q = vec4(1)*(1.-exp(-.5*length(E.xy)))*\n             smoothstep(2.*fwidth(12.*atan(E.x,E.y)),0.,abs(sin(12.*atan(E.x,E.y))));\n                \n    \n    \n    if (U.x<52.||U.y<52.||R.x-U.x<52.||R.y-U.y<52.)\n        Q *= 0.;\n        \n        \n    if (roundBox(U-vec2(.35,.5)*R,vec2(.04,.5)*R,3.)<0. || \n            roundBox(U-vec2(.65,.5)*R,vec2(.04,.5)*R,3.)<0.) \n   {\n    \n        Q = 10.*vec4(E.w,.25*abs(E.w),-E.w,1);\n    \n    }\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\n#define K .5\n\nfloat f (float x) {\n    // Change the input signal here!\n    return smoothstep(0.,1.,x)*sin(.5*x);\n}\n\n\nfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max(abs(p.x)-h.x,abs(p.y)-h.y);\n\t\t}", "buffer_a_code": "#define F 0\nMain {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*4+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x -= .5/eps*(n.z-s.z) + 0.;\n        Q.y += .5/eps*(e.z-w.z) + Q.w ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y);\n    }\n    Q.w -= K*Q.y+(1.-K)*Q.w;\n    \n    if (roundBox(U-vec2(.35,.5)*R,vec2(.04,.5)*R,3.)<0.) Q.w += K*f((float(iFrame)/60.))/10.;\n    else if (roundBox(U-vec2(.65,.5)*R,vec2(.04,.5)*R,3.)<0.) ;\n    else Q.w = 0.;\n    \n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define F 1\nMain {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*4+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x -= .5/eps*(n.z-s.z) + 0.;\n        Q.y += .5/eps*(e.z-w.z) + Q.w ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y);\n    }\n    Q.w -= K*Q.y+(1.-K)*Q.w;\n    \n    if (roundBox(U-vec2(.35,.5)*R,vec2(.04,.5)*R,3.)<0.) Q.w += K*f((float(iFrame)/60.))/10.;\n    else if (roundBox(U-vec2(.65,.5)*R,vec2(.04,.5)*R,3.)<0.) ;\n    else Q.w = 0.;\n    \n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define F 2\nMain {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*4+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x -= .5/eps*(n.z-s.z) + 0.;\n        Q.y += .5/eps*(e.z-w.z) + Q.w ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y);\n    }\n    Q.w -= K*Q.y+(1.-K)*Q.w;\n    \n    if (roundBox(U-vec2(.35,.5)*R,vec2(.04,.5)*R,3.)<0.) Q.w += K*f((float(iFrame)/60.))/10.;\n    else if (roundBox(U-vec2(.65,.5)*R,vec2(.04,.5)*R,3.)<0.) ;\n    else Q.w = 0.;\n    \n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define F 3\nMain {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if ((iFrame*4+F)%2==0) {\n        // dE/dt = -curl B-j\n        Q.x -= .5/eps*(n.z-s.z) + 0.;\n        Q.y += .5/eps*(e.z-w.z) + Q.w ;\n    } else {\n        // dB/dt = curl E\n        Q.z -= .5/mu*(n.x-s.x-e.y+w.y);\n    }\n    Q.w -= K*Q.y+(1.-K)*Q.w;\n    \n    if (roundBox(U-vec2(.35,.5)*R,vec2(.04,.5)*R,3.)<0.) Q.w += K*f((float(iFrame)/60.))/10.;\n    else if (roundBox(U-vec2(.65,.5)*R,vec2(.04,.5)*R,3.)<0.) ;\n    else Q.w = 0.;\n    \n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2fRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dt2BRK", "name": "Dropping out of warp", "author": "robinpdev", "description": "VDrop2 -> Tunnel remix - left mouse = warp speed", "tags": ["2d", "tunnel", "starfield", "drops"], "likes": 12, "viewed": 616, "published": 3, "date": "1694264459", "time_retrieved": "2024-07-30T17:34:46.623396", "image_code": "// V-Drop - Del 19/11/2019 - (Tunnel mix - Enjoy)\n// vertical version: https://www.shadertoy.com/view/tdGXWm\n#define PI 3.14159\n\nfloat vDrop(vec2 uv,float t)\n{\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p)+exp(-iTime)*0.9+0.1;\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    if (iMouse.z>0.5)\n    \tp.y *= 0.5;\n    float t =  iTime*0.4;\n    vec3 col = vec3(1.55,0.65,.225) * vDrop(p,t);\t// red\n    col += vec3(0.55,0.75,1.225) * vDrop(p,t+0.33);\t// blue\n    col += vec3(0.45,1.15,0.425) * vDrop(p,t+0.66);\t// green\n\tfragColor = vec4(col*(d*d), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2BRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 159, 159, 607], [609, 609, 666, 666, 1100]], "test": "untested"}
{"id": "Dt2fzV", "name": "golf123random", "author": "chenxianming", "description": "try it fullscreen.", "tags": ["golf", "cineshader"], "likes": 4, "viewed": 718, "published": 3, "date": "1694263009", "time_retrieved": "2024-07-30T17:34:47.507033", "image_code": "#define I iResolution\n#define PI 3.1415926\n#define T( s ) fract( iTime * s ) * PI * 4.\n\n// smax\nfloat s(float a, float b, float c) {\n  float d = clamp(.5 + .5 * (-b + a) / c, 0., 1.);\n  return -(mix(-b, -a, d) - c * d * (1. - d));\n}\n\nmat2 rot(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\nfloat cs( vec3 p ){\n    p.xy *= rot( PI * -.25 );\n    p.yz *= rot( PI * .25 );\n    p.xy *= rot( T( .025 ) );\n    p.xy *= rot( p.z * 40. );\n    \n    float d = abs( p.x ) - .2;\n    \n    d = -min( -d, -( abs( p.y ) - .2 ) );\n    \n    p.xy *= 1.5;\n    \n    float s2 = abs( p.x ) - .2;\n    s2 = min( -s2, -( abs( p.y ) - .2 ) );\n    d = max( d, s2 );\n    \n    \n    return max( d, abs( p.z ) - 1. );\n}\n\nfloat cd( vec3 p ){\n    p.xy *= rot( PI * -.25 );\n    p.yz *= rot( PI * .25 );\n    \n    p = mod( p, .01 ) - .005;\n    return length( p * vec3( 1., .6, 1. ) ) - .001;\n}\n\n// sdf\nfloat df(vec3 p) {\n    p.xz *= rot( T( .0025 ) );\n    p.xy *= -rot( T( .0025 ) );\n    p.xz *= rot( PI * .25 );\n    p.xy *= rot( PI * .125 );\n    float k = 0.;\n    \n    for( float i = 0.; i < 7.; i++ ){\n        p.xz *= rot( i );\n        k += .8;\n        p = abs( p ) - .5;\n        p.xy *= rot( i * k * ( i - k ) );\n        p.xy = abs( p.xy ) - .5;\n        p.yz *= rot( i * k * ( i - k ) );\n        p.x = abs( p.x ) - k * .121;\n    }\n    \n    return clamp( s( cs( p ), -cd( p ), .06 ), 0., 1. );\n}\n\n// calcNormal (IQ)\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( (fragCoord/I.xy - .5) * 2. ) * vec2( I.x / I.y, 1. );\n    \n    vec3 c, p, o = vec3( 0., 0., -1. ), r = vec3( u * .1, 1. );\n    float t, d, i;\n    c += .1;\n    \n    for( ; i < 64.; i++ )\n        p = o + r * t,\n        d = df( p ),\n        t += d;\n    \n    if( d < 1e-3 )\n        c += vec3( clamp(dot( l( p ) , vec3(.4, 1., -.5)), 0.0, 1.0) );\n\n    // Output to screen\n    fragColor = vec4(sqrt( c ),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2fzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 96, 132, 132, 232], [234, 234, 253, 253, 315], [317, 317, 336, 336, 712], [714, 714, 733, 733, 881], [883, 890, 908, 908, 1385], [1387, 1406, 1425, 1425, 1621], [1623, 1623, 1680, 1730, 2151]], "test": "untested"}
{"id": "mtSBzV", "name": "Arabesque knots 8 (music)", "author": "jarble", "description": "A zellij tile pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "rug", "gamelan"], "likes": 8, "viewed": 343, "published": 3, "date": "1694233458", "time_retrieved": "2024-07-30T17:34:48.604100", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //abs(1.-abs(f1((a1)*(a2.x+a2.y))-.5))\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    bool b = uv.x>uv.y;\n    bool b1 = uv.x>uv.y;\n    vec2 t3 = t2;\n    vec2 uv1 = uv;\n    for(int k = 0; k < 9; k++){\n        \n        //uv -= triwave1_(uv);\n        \n        //uv.y -= t1_(floor(uv),floor(uv))/2.;\n\n        //uv = uv/1.5-.5;\n\n        //uv.y -= mod(floor(uv.x),2.)/2.;\n        b1 = uv.x*float(b1)>uv.y;\n        //uv += binary_digit(k,1)/2.;\n        //uv += binary_digit(k,2)/2.;\n        //uv += binary_digit(k,3)/2.;\n        //if(!b)\n        uv =\n            abs(.5+uv/1.5+t2)\n            //-sign(uv-t2*1.5)-abs(.5+uv/1.5+t2)\n            //abs(.5+uv/1.5+t2)*r\n            //abs(.5+uv/1.5+t2)+sign(uv.y-uv.x)/2.\n            //abs(max(uv,t2)+t2)\n            //abs(.5+abs(uv-t2)/1.5-t2) //looks better zoomed out\n            //abs(.5+uv/1.5+max(t2/1.5,uv))\n            //abs(.5+uv/1.5+t2)*sign(-uv+uv.yx/2.)\n            //abs(.5+uv+t2/1.5)\n            //abs(.5+uv+t2)/1.5\n        ;\n        \n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        \n        //if(t2.y>t2.x)\n        //if(t2.y>t2.x||col.x<col.y)\n        b =\n            uv.y>uv.x\n            //uv.y>uv.x||t2.y<t2.x\n            //uv.y>uv.x*float(col.x<col.y||t2.x<t2.y)\n            //uv.y*float(b1)>uv.x\n        ;\n        vec2 uv1 = uv;\n        //if(b||t2.x>t2.y)\n        if(b)\n        uv =\n            uv.yx\n            //uv.yx+1./3.\n        ;\n        //else uv -= t1_(floor(uv),floor(uv))/1.5;\n        \n        //uv.x += sign(t2.y-t2.x);\n        //uv.x += sign(uv.y-uv.x);\n        //uv *= -1.;\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5)+floor(t2)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n            \n            //WOW!\n            //t2-triangle_wave(uv.yx)+fract(t2/1.5)\n            \n            //abs(abs(t2)-.5)-triangle_wave(uv.yx)\n        ;\n        \n        //\n        t3 =\n            -triangle_wave(uv-.5)\n        ;\n        //t3 = min(t2,t3);\n        uv1 =\n            t2-triangle_wave(uv1.yx)\n            \n            //WOW!\n            //sqrt(t2)-sqrt(triangle_wave(uv.yx))\n        ;\n        //uv1 = min(uv,uv1);\n        \n        \n        \n        if(\n            //b\n            true\n            //uv.y<uv.x||b\n            //uv.y>uv.x||b\n            //t2.y>t2.x||b\n            //t2.y<t2.x||b\n        )\n        col =\n            vec3(col.zx,max(uv.x-uv.y,0.))\n            \n            //WOW!\n            //vec3(col.zx,max(uv1.x-uv1.y,uv.y-uv.x))\n            //vec3(col.zx,abs(min(uv.x-uv.y,1.)-max(t2.x-t2.y,0.)))\n\n            \n            //vec3(col.xy,max(uv.x+uv.y+1.,0.)).yzx\n            //vec3(col.xy,max(0.,max(uv.x-uv.y,0.))).yzx\n            //vec3(col.zx,max(uv.x-uv.y*float(b),0.))\n            //abs(vec3(col.zx,max(uv.x-uv.y,-col.y)))\n            //vec3(col.zx,max(col.y,max(-uv.x+uv.y,0.)))\n            \n            //vec3(col.xz,max(uv.x-uv.y,0.))\n        ;\n        //else uv.x +=.5;\n        //col.zx = abs(.5-col.zx);\n        //uv.x += float(uv.x<uv.y);\n        //t2.x += 1./2.;\n        //uv -= (floor(uv+floor(iTime)));\n        }\n        return col;\n        }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 16.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n\n    \n    mat2 r = rotate2D(0.785398);\n    vec3 col = fractal(uv);\n\n    \n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "int collatz(int initial, int steps){\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\nfloat fibonacci(float nthNumber_) {\n        int nthNumber = int(nthNumber_);\n        int previouspreviousNumber, previousNumber = 0, currentNumber = 1;\n        for (int i = 1; i < nthNumber ; i++) {\n\n            previouspreviousNumber = previousNumber;\n\n            previousNumber = currentNumber;\n\n            currentNumber = previouspreviousNumber + previousNumber;\n\n        }\n        return float(currentNumber);\n}\n\nfloat m1(float a, float b, float c){\n    return floor(floor(floor(a)/b)/c);\n}\n\nfloat mod1(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a/8.),8.); i++){\n        a += mod(floor(a/8.),b)*i;\n    }\n    */\n    return\n        mod(a,b)\n        //mod(a-mod(a*2.,b),b)\n        //mod(a+floor((a/2.-b)/2.),b)\n        //mod(a+floor(a/2.),b)\n        //mod(a+floor(b*13./7.),b)\n        //floor(mod(floor(a+floor(a)/8.),b))\n        //mod(a-fibonacci(a/32.),b)\n        //mod(a+mod(a-mod(a,3.),5.)+mod(a+mod(a,5.),3.),b)\n        //mod(a-mod(a-mod(a,5.),3.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    \n    //a += mod(floor(a/8.),2.)*4.;\n    \n    //a += collatz(a/8./8.,b)*4.;\n    //a += collatz(mod(a,8.),8.);\n    \n    //a = (a/2. + floor(a))/4.;\n    \n    //a -= fibonacci(a/64.);\n    \n    //a += float(int(a)>>int(b));\n    //a += floor(a/4.);\n    //a += fibonacci(mod(a,8.));\n    //a += m1(a,1.+b*b,4.);\n    //a += m1(a,5.+b,3.+b);\n    //a += float(fibonacci(int(mod(a,8.))));\n\n    //a += abs(mod((a),3.)-mod((a),5.));\n    //a += 2.*floor(1.+mod(floor(a/2.),2.))/(1.+mod(floor(a/4.),2.));\n    //a -= mod(floor(a/2.)/2.,2.)*2.;\n    float m1 =\n        floor(mod1(b/2.,2.))\n        //floor(mod1(collatz(mod(a,16.)+b/2.,16.),2.))\n;\n    \n    a +=\n        //floor(mod(b/2.,2.))+mod(floor(a+3.),4.-b)\n        m1\n        //floor(mod(b/2.,2.))\n        //mod(b/2.+binary_digit(int(a),1),2.)\n        //mod((b/2.+floor(a/4.)),4.)\n    ;\n    float\n    a2 = mod1(floor(a),b),\n    a3 =\n        mod1(floor(a/(b)),b)\n        //mod1(floor((a+floor((b*3.+m1)/4.))/(b)),b)\n        //mod1(floor(floor(a/4.)*b/4.+(a2)/(b)),b)\n    ;\n    \n    //a -= mod(floor(a+b),3.);\n    //a += m1(a,5.+b,3.+b);\n    \n    //a += m1(a,3.,7.);\n    \n    //a += mod(-a*2.,2.)/2.;\n    return\n        mod1(a2*a3,b)\n        //mod1(a2*(a3+floor(a/4.*sign(a2-a3))),b)\n        //mod(floor((1.+a3)/(1.+a2)),b)\n        //mod(-mod(-floor(a),b)*mod(-floor((a)/b),b),b)\n        //mod(floor(a-mod(a,3.)),b)\n        //floor(mod(a/floor(1.+mod(-a/2.+b,2.)),b))\n        //floor(mod(mod(floor(a)/(1.+mod(floor(-a/2.),2.)),b)*mod(floor((a)/b),b),b))\n        //floor(mod((a/(1.+mod(floor(-a/2.),2.))),b))\n        //floor(mod(mod(floor(a),b)*mod(a/b,b),b))\n        //floor(mod(mod(floor(a),2.)+mod(a/2.,6.),b))\n        //mod(floor(mod(a,8./b))*3.,b)\n        //floor(mod(mod(a,1.+abs(mod(a,5.)-mod(a,3.))),b))\n        //mod(floor(floor(a)/1.5)+floor(floor(a)/2.),b)\n        //floor(mod(mod(floor(a/2.)*3.,b)*mod(floor(a/2.)*5.,b),b))\n        //floor(mod(mod(floor(a)*3.,b/3.+3.)*mod(floor(a)*5.,b/5.+5.),b))\n        //mod(mod(floor(a)+2.,b)*mod(floor((a/2.)/b),b)+2.,b)\n        //floor(mod(mod(floor(a)/b,b)*mod(floor((a)/b)+2.,b)+2.,b))\n        //floor(mod((mod(floor(a),b))*mod(floor(a/b*2.)/2.,b),8.))\n    ;\n}\n\n\nfloat prime_rhythm(float time){\n    \n    //time += mod(time,5.)-mod(time,3.);\n    //time += mod(floor(time/8.),2.)*4.;\n    \n    //time += mod(-time,5.)+mod(-time,3.)+mod(-time,2.);\n    //time += mod(time/8.,5.) - mod(time/8.,3.);\n    \n    //time = (time/2. + floor(time))/4.;\n    \n    //time += fibonacci(mod(time/8.,8.));\n    \n    return\n        (1.+fmod(time/5.,2.))/(1.+fmod(time/3.,2.))\n        //(1.+fmod(time/8.,2.))/(1.+fmod(time/4.,2.))\n        //(1.+fmod(time/5.,2.))/(1.+fmod(-time/3.,2.))\n    ;\n    //return (1.+fmod(time/2.,2.))*(1.+fmod(time/3.,2.))/(1.+fmod(time/5.,2.))/(1.+fmod(time/7.,2.))*(1.+fmod(time/11.,2.));\n}\n\nfloat fmod1(float a, float b){\n    //a += collatz(a/8.,8.);\n    //change the notes without changing the rhythm\n    //a += mod(-b/2.,2.);\n    //a += prime_rhythm(a);\n    return\n        fmod(a,b)\n        //fmod(a,b-fmod(a/2.,2.))\n        //fmod(floor(a)*5.,b+fmod(floor(a/8.)*3.,b))\n    ;\n}\n\n//#define fract1(a) pow(fract(a),2.)\n//#define fract1(a) pow(fract(a),1.+fract(a))\n//#define fract1(a) (1.-fract(-a)*fract(-a))\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n//#define fract1(a) pow(fract(a),3.)\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\n\nvec2 mainSound1(int samp, float time,float scale, int instrument,float duration){\n  float s1 =\n      8.,\n  tempo1 =\n      //1.\n      //divide by prime numbers to get an interesting rhythm\n      prime_rhythm(time)\n      //prime_rhythm(time+collatz(time,time))\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 =\n      fmod(t4,2.)\n      //fmod(t4+collatz(t4,16.),2.)\n  ,\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6+mod(t6/8.,3.)-mod(t6/8.,2.),s1/2.)/2.),\n      //floor(fmod(t6+floor(t6/8.),s1/2.)/2.),\n      //floor(2.*fmod(floor(t6)*3.,s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.);\n  \n  duration *= tempo1;\n\n  vec2\n  a= vec2(\n      //-log(fract(t/prime_rhythm(time+7.))/4.)*4.\n      //-log(fract(t/2./prime_rhythm(time+14.))*fract(t/prime_rhythm(time+7.))/8.)*4.\n      \n      //sitar\n      //-(log(1./64./4.+fract1(t/2./prime_rhythm(time+14.))/16.)),-(log(1./64./4.+fract1(t/prime_rhythm(time+7.))/16.))\n      \n      -vec2(log(1./64.+fract1(t/2./prime_rhythm(time+14.))/8./duration),log(1./64.+fract1(t/prime_rhythm(time+7.))/8./duration))\n      \n      //steel drum / gamelan\n      //(1.-log(1./64./4.+fract1(t/2./prime_rhythm(time+14.))/2.)),(1.-log(1./64./4.+fract1(t/prime_rhythm(time+7.))/2.))\n      \n      //hurdy-gurdy\n      //(1.-log(1./32.+abs(1./32.-fract1(t/2./prime_rhythm(time+14.))*2.))),(1.-log(1./4.+2.*abs(1./32.-fract1(t/prime_rhythm(time+7.)))))\n\n  ),\n  nb = vec2(\n      t*pow(2.,(m3+m2-t1*4.)/7.+scale)*tempo1\n      //t*pow(2.,(m3-m2*2.+t1)/7.+6.5)*tempo1\n      \n      //airhorn remix\n      //abs(t*(pow(2.,(m3+m2-t1*4.)/7.+7.5)*tempo1/2.)-a/16.)*2.\n  ),\n  sitar =\n  //log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.)),\n  a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.))) \n  ,gamelan = a/16./4.*abs(log(1./4.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n  ,\n  steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,oud = a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n  ,banjo = a/16./8.*abs(log(1./2.+a*abs(1./8.-.5*abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  -log(1./2.+a*abs(abs(1./2.-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))\n  ,guitar = a/16./8.*abs(\n      log(1./2.+a*abs(1./8.-.125/2.*abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))))\n      -log(1./2.+a*abs(1./8.-.5*abs(1./2.-vec2(fract1(nb.x*.998),fract1(nb.y)))))\n  )\n  ,drum = abs(oud*2.-gamelan/2.)/1.5\n  ,synth_drum = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ,synth_drum1 = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4./m2))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.*m2)))\n  ,harp =\n      a/16./4.*abs(\n      synth(1./4.,a,1./8.,1.,nb*4.,2.)\n      + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n  ;\n  switch(instrument){\n  case 1:\n  \n  return\n      gamelan\n      //banjo\n      //oud\n      //steel_drum\n      //sitar\n      //hurdy-gurdy\n      //(abs(log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.))-log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))))\n\n      //log(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))*a)\n      \n      //abs(log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      //abs(1.+log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      \n      //log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.)))))\n  ;\n  case 2: return sitar;\n  case 3: return oud;\n  case 4: return steel_drum;\n  case 5: return banjo;\n  case 6: return guitar;\n  case 7: return drum;\n  case 8: return synth_drum;\n  case 9: return synth_drum1;\n  default: return sitar;\n  }\n}\n\nvec2 mainSound1(int samp, float time,float scale, int instrument){\n    return mainSound1(samp,time,scale,instrument,1.);\n}\n\nvec2 mainSound(int a,float b){\n    return\n        //drum\n        //abs(mainSound1(a,b,6.5,1)-mainSound1(a,b,6.5,4)/8.)\n        \n        //abs(mainSound1(a,b,6.5,1,1./2.)-mainSound1(a,b,5.5,1,1.)/2.)\n        \n        (mainSound1(a,b,5.,1,1./4.)-mainSound1(a,b,6.,1,1./2.))\n        \n        //sounds like sitar (using synth drum)\n        //abs(mainSound1(a,b,5.5,8,1./2.)-mainSound1(a,b,6.5,8,1.)/2.)\n        \n        //sounds like sitar (using oud)\n        //abs(mainSound1(a,b,7.75,3,1./2.)-mainSound1(a,b,6.75,3,1.)/2.)\n        \n        //mainSound1(a,b,6.5,1,1.)\n        \n        //abs(mainSound1(a,b,6.5,3,2./2.)+mainSound1(a,b,7.5,3,2.)/2.)/2.\n        \n        //some interesting distortion\n        //abs(mainSound1(a,b+(1.-abs(fract1(b/2.)-.5))/64./32.,6.5,1)+mainSound1(a,b,6.5,1))/2.\n        \n        //abs(mainSound1(a,b,6.5,3)+mainSound1(a,b/2.,6.5,3))/2.\n        \n        //(mainSound1(a,b/2.,7.5,4)+mainSound1(a,b,6.5,3))/2.\n        //(mainSound1(a,b,5.5,4)+mainSound1(a,b*2.,6.5,3))/2.\n        \n        //gong remix (using oud)\n        //abs(mainSound1(a,b,6.5,3)-mainSound1(a,b,6.,3)/2.)\n        \n        //mainSound1(a,b/2.,6.5,1)+mainSound1(a,b,5.5,3)/2.+mainSound1(a,b*2.,4.5,1)/4.+mainSound1(a,b*4.,3.5,1)/8.\n        //(mainSound1(a,b,6.5,1)+mainSound1(a,b/2.,7.5,1)+mainSound1(a,b/4.,8.5,1))\n    ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 240], [357, 357, 383, 383, 472], [474, 474, 507, 507, 541], [543, 543, 567, 567, 619], [621, 621, 643, 643, 3720], [3722, 3722, 3779, 3779, 4129]], "test": "untested"}
{"id": "dtjfWm", "name": "planet 0000", "author": "ArolaunTech", "description": "A simple planet.\n\nWait a few minutes for the clouds to appear.", "tags": ["space", "planet"], "likes": 10, "viewed": 177, "published": 3, "date": "1694219383", "time_retrieved": "2024-07-30T17:34:49.745050", "image_code": "/*=======Constants=======*/\n\n//Lighting constants\nconst float ambient = 0.1; //Ambient light.\nconst float sundot = 0.999; //Controls sun size. Smaller = Larger sun.\n\nconst vec3 suncolor = vec3(1.0, 1.0, 1.0);\n\n//Atmospheric constants\nconst float scatterOutStrength = 200.0; //Out-scattering strength\nconst float scatterInStrength = 60.0; //In-scattering strength\nconst float mieScatterStrength = 100.0; //Mie scattering strength\n\nconst float cloudDensity = 1000.0;\n\nconst float cloudLowAlt = 0.005;\nconst float cloudHighAlt = 0.025;\n\nconst float cloudAvgAlt = (cloudLowAlt + cloudHighAlt)/2.0;\nconst float cloudReciprocalDiff = 1.0/(cloudHighAlt-cloudLowAlt);\n\nconst vec3 atmcol = vec3(0.11, 0.41, 1.0); //Blue color of atmo (DO NOT CHANGE)\nconst vec3 rcol = exp(-0.15*atmcol);\n\nconst float atmoradius = 1.1;\n\n//Render constants\nconst vec3 center = vec3(-0.0, 0.0, 2.5);\n\n/*\n * ================================\n *            Sun Sizes\n * ================================\n *\n * 0.866 gives a 60 degree wide sun\n * 0.906 gives a 50 degree wide sun\n * 0.940 gives a 40 degree wide sun\n * 0.966 gives a 30 degree wide sun\n * 0.985 gives a 20 degree wide sun\n * 0.991 gives a 15 degree wide sun\n * 0.996 gives a 10 degree wide sun\n * 0.999 gives a  5 degree wide sun\n * 0.9994 gives a 4 degree wide sun\n * 0.9997 gives a 3 degree wide sun\n * 0.9998 gives a 2 degree wide sun\n * 0.99996 gives a 1 degree wide sun\n * 0.99999 gives a realistic 0.5 degree wide sun\n *\n */\n\nfloat press(vec3 p) {\n    float alt = sqrt(dot(p,p))-1.0;\n    return exp(-50.0*alt);\n}\n\nfloat magnitude(vec3 p) {\n    return sqrt(dot(p,p));\n}\n\nfloat opticalDepth(vec3 p, vec3 dir, float radius) {\n    float ltca = dot(dir, -p);\n    float ld = sqrt(dot(p,p)-ltca*ltca);\n    float lthc = sqrt(radius*radius-ld*ld);\n    \n    float ldepth = ltca + lthc;\n    \n    float samples = 5.0;\n    float ret = 0.0;\n    \n    for (float i = 0.0; i < 1.001; i += 1.0/samples) {\n        vec3 pos = p + dir*ldepth*i;\n        ret += press(pos)*ldepth/samples;\n    }\n    return ret;\n}\n\nfloat rayleighPhase(float c) {\n    return 1.0 + c*c;\n}\n\nfloat miePhase(float c) {\n    float g = 0.75;\n    return pow(1.0-g,3.0)*(1.0+c*c)/(2.0*(1.0+g*g-2.0*g*c));\n}\n\nfloat cloudPhase(float c) {\n    return 0.2+0.8*sqrt(1.0-c*c);\n}\n\nfloat cloudFunc(vec3 pos) {\n    vec3 np = pos-center;\n    np += 0.01*simplex3d(100.0*pos+iTime);\n    np = normalize(np);\n    float alt = magnitude(pos-center)-1.0;\n    float altMult = exp(-10.0*cloudReciprocalDiff*cloudReciprocalDiff*pow(alt-cloudAvgAlt,2.0));\n    \n    float density = texture(iChannel3, vec2(0.5+atan(np.x,np.z)/(2.0*pi),0.5+atan(np.y)/pi)).x;\n\n    return altMult*(min(density,0.8)-0.5);\n}\n\nfloat apos(float a, float b) {\n    if (a == b) {\n        return a;\n    }\n    \n    float dnm = a/(a-b);\n    float d = min(1.0, max(dnm, 0.0));\n    if (a > 0.0 && b > 0.0) {\n        return b * (1.0-dnm) * (1.0 - pow(a/b, 2.0))/2.0;\n    }\n    return (max(b, 0.0) * (1.0 - d) + max(a, 0.0) * d)/2.0;\n}\n\nfloat simpson(float s, float m, float e) {\n    return s + 4.0*m + e;\n}\n\n//float occludedPart(vec3 dir, vec3 pos, float sdot) {\n//    int samples = 20;\n//    float add = 1.0/float(samples);\n//    float ret = 0.0;\n//    for (int i = 0; i < samples; i++) {\n//        vec3 rdir = normalize(dir+sqrt(1.0-sdot*sdot)*random3(vec3(dir.x, i, iTime)));\n//        float ctca = dot(rdir, -pos);\n//        float cd = sqrt(dot(pos,pos)-ctca*ctca);\n//        if (cd > 0.95 || ctca < 0.0) {\n//            float amult = min(1.0,10.0*(cd-0.95));\n//            \n//            if (ctca < 0.0) {\n//                amult = 1.0;\n//            }\n//            \n//            ret += add*amult;\n//        }\n//    }\n//    return ret;\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Constants\n    \n    float radius = 1.0;\n    \n    //vec3 lightdir = normalize(vec3(sin(iTime/5.0),0.0,-cos(iTime/5.0)));\n    vec3 lightdir = normalize(vec3(0.01,0.0,-0.01));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float m = min(iResolution.x, iResolution.y);\n    \n    vec2 uv = fragCoord/m;\n    vec2 xy = 2.0*uv-vec2(iResolution.x/m, iResolution.y/m);\n\n    // Direction\n    float vFOV = 60.0;\n    vFOV /= 2.0;\n    \n    vec3 D = normalize(vec3(tan(vFOV*3.14159/180.0)*xy,1.0));\n    \n    //Sphere\n    float tca = dot(center, D);\n    float d = sqrt(dot(center, center)-tca*tca);\n    float thc = sqrt(radius*radius-d*d);\n    vec3 norm = normalize((D*(tca-thc))-center);\n    \n    float cloudRegionStartD = 0.0;\n    float cloudRegionEndD = 0.0;\n    \n    float lowRegionStartD = 0.0;\n    float lowRegionEndD = 0.0;\n    \n    float hcthc = 0.0;\n\n    if (d < 1.0 + cloudHighAlt) {\n        hcthc = sqrt(pow(radius+cloudHighAlt,2.0)-d*d);\n        cloudRegionStartD = max(tca - hcthc, 0.0);\n        cloudRegionEndD = tca + hcthc;\n        \n        if (d < 1.0 + cloudLowAlt) {\n            hcthc = sqrt(pow(radius+cloudLowAlt,2.0)-d*d);\n            lowRegionStartD = max(tca - hcthc, 0.0);\n            lowRegionEndD = tca + hcthc;\n        }\n    }\n    \n    vec3 coord = norm;\n    float thccopy = thc;\n    \n    coord *= mat3(\n        cos(iTime/5.0), 0.0, sin(iTime/5.0),\n        0.0, 1.0, 0.0,\n        sin(-iTime/5.0), 0.0, cos(iTime/5.0)\n    );\n    \n    //Background\n    vec3 col = vec3(0.0);\n    float dotp = dot(D, lightdir);\n    if (dotp > sundot) {\n        col = vec3(pow(2.0*(dotp-sundot)/(1.0-sundot),6.0));\n    }\n    \n    //Lighting\n    if (d < radius && tca >= 0.0) {\n        float specnoise = 1.0+0.07*simplex3d(40.0*coord+iTime);\n        norm *= specnoise*0.05+0.95;\n        \n        float spherenoise = simplexfract(coord);\n        vec3 spherecolor = vec3(0.0,0.05/max(abs(spherenoise)*2.0,0.1),specnoise);\n        vec3 specular = vec3(pow(max(dot(norm, normalize(lightdir - D)),0.0), 100.0));\n        if (spherenoise > 0.0) {\n            spherecolor = vec3(0.0, 0.7*(0.5*simplex3d(coord*3.0)+1.0-0.6*abs(coord.y/radius)), 0.4);\n            if (spherenoise < 0.05) {\n                spherecolor = 20.0*((spherenoise)*spherecolor+(0.05-spherenoise)*vec3(1.0,1.0,0.5));\n            }\n            if (spherenoise > 0.5) {\n                spherecolor = vec3(0.5);\n            }\n            if (spherenoise > 0.6+0.07*simplex3d(coord*30.0+0.4)) {\n                spherecolor = vec3(1.0);\n            }\n            if (dot(lightdir, norm) > -sqrt(radius*radius-spherenoise*spherenoise)) {\n                vec3 dirY = vec3(0.0, 0.006, 0.0);\n                vec3 dirZ = 0.006*norm;\n                vec3 dirX = 0.006*normalize(cross(dirY, dirZ));\n                dirY = 0.006*normalize(cross(dirZ,dirX));\n            \n                float normX = simplexfract(coord+dirX)-simplexfract(coord-dirX);\n                float normY = simplexfract(coord+dirY)-simplexfract(coord-dirY);\n                float normZ = simplexfract(coord+dirZ)-simplexfract(coord-dirZ);\n                norm = 0.7*norm+0.2*normalize(dirX*normX + dirY*normY + dirZ*normZ);\n                norm = normalize(norm);\n            }\n            \n            specular = vec3(0.0);\n        }\n        vec3 diffuse = vec3(max(dot(lightdir, norm),ambient))*spherecolor;\n\n        col = diffuse*1.0+0.5*specular;\n    }\n    \n    if (d <= atmoradius) {\n        //Calc atmo\n        thc = sqrt(atmoradius*atmoradius-d*d);\n        vec3 sp = D*(tca-thc);\n        if (thc > tca) {\n            sp = vec3(0.0);\n        }\n        float depth = magnitude(D*(tca+thc) - sp);\n        if (d < radius && tca > 0.0) {\n            depth = magnitude(D*(tca-thccopy)-sp);\n        }\n        \n        //float samples = 5.0; //Low quality\n        float samples = 10.0; //Medium atmospheric quality\n        //float samples = 20.0; //High quality\n        \n        float cloudSamples = 15.0;\n        float subSamples = 1.0;\n        \n        float totalCloudDepth = cloudRegionEndD - cloudRegionStartD;\n        \n        float dtrue = d;\n        \n        if (tca < 0.0) {\n            dtrue = sqrt(dot(center, center));\n        }\n        \n        if (dtrue < 1.0 + cloudLowAlt) {\n            totalCloudDepth -= lowRegionEndD - lowRegionStartD;\n            totalCloudDepth /= 2.0;\n        }\n        \n        float cloudRegionAddm = totalCloudDepth*samples/(cloudSamples*depth);\n        \n        float addm = 1.0;\n        \n        for (float i = 0.0001; i < 1.0; i += 0.0) {\n        \n            vec3 pos = sp + D*depth*i*0.9998;\n            float dense = press(pos-center);\n            \n            float ltca = dot(lightdir, center-pos);\n            float ld = sqrt(dot(center-pos,center-pos)-ltca*ltca);\n            float lthc = sqrt(atmoradius*atmoradius-ld*ld);\n            \n            float pmss = 0.0;\n            float alt = magnitude(pos-center)-1.0;\n            \n            //Cloud generation\n            \n            float cloudf = cloudFunc(pos);            \n            //col = 0.9*col+0.1*vec3(protoMult/ceil(protoMult));\n            if (alt > cloudHighAlt) {\n                addm = 1.0;\n            }\n            \n            if (alt <= cloudLowAlt && tca < 0.0) {\n                addm = (lowRegionEndD - lowRegionStartD)*samples/(subSamples*depth);\n            }\n            \n            float cctca = 0.0;\n            hcthc = 0.0;\n            if (alt <= cloudHighAlt && alt > cloudLowAlt) {\n                cctca = dot(center-pos, lightdir);\n                float ccd = sqrt(dot(center-pos, center-pos)-cctca*cctca);\n                hcthc = sqrt(pow(radius+cloudHighAlt,2.0)-ccd*ccd);\n            \n                addm = cloudRegionAddm;\n                float cf2 = cloudFunc(pos + D*depth*addm/samples);\n                float simp = (max(0.0,cloudf)+max(0.0,cf2));\n                pmss += mieScatterStrength*(cctca+hcthc)*cloudDensity*1.0*pow(simp,2.0);\n            }\n            \n            if (ld >= 0.99 || ltca <= 0.0) {\n                if (ltca < 0.0) {\n                    ld = sqrt(dot(center-pos,center-pos));\n                }\n                float lm = min(1.0, 100.0*(ld-0.99));\n                \n                float sinFactor = 2.0*sqrt(1.0-pow(dot(D,lightdir),2.0));\n                sinFactor += sqrt(0.5-0.5*dot(D,lightdir));\n                sinFactor /= 3.0;\n                \n                //if (D.y < 0.0) {\n                //    sinFactor = log(9.0-8.0*dot(D,lightdir))/log(17.0);\n                //}\n                \n                float od = opticalDepth(pos-center, lightdir, atmoradius);\n                vec3 outColor = pow(rcol, vec3(scatterOutStrength*od));\n                \n                col += scatterInStrength*min(lm,1.0)*sinFactor*outColor*rayleighPhase(dot(D,lightdir))*dense*atmcol*depth*addm/samples;\n                col += mieScatterStrength*outColor*min(lm,1.0)*dense*miePhase(dot(D,lightdir))*depth*addm/samples;\n                \n                col *= exp(-5000.0*(cctca+hcthc)*pmss*od*depth*addm/samples);\n                col += 7.0*pmss*outColor*min(lm,1.0)*cloudPhase(dot(D,lightdir))*depth*addm/(samples*max((cctca+hcthc),1.0));\n                \n         \n                //col += cctca+hcthc;\n                \n                //col *= exp(-50.0*pmss*od*depth*addm/samples);\n                //if (pmss > 0.0) {\n                //    col += vec3(0.1);\n                //}\n            }\n            col *= pow(rcol, vec3(depth*dense*scatterOutStrength*addm/samples));\n            i += addm/samples;\n        }\n        \n        //col = vec3(pmss);\n    }\n\n    // Output to screen\n    \n    //if (d < 1.0+cloudHighAlt) {\n    //    col = vec3(cloudRegionEndD);\n    //}\n    \n    //col = 10.0*(texture(iChannel3, fragCoord/iResolution.xy).xyz-0.5);\n    //col = texture(iChannel3, fragCoord/iResolution.xy).xyz;\n    \n    //col.x = 0.0;\n    //col.y = 0.0;\n    //col.z = 0.0;\n    \n    //col = norm;\n    \n    fragColor = vec4(pow(1.0-exp(-1.2*pow(col*suncolor,vec3(2.1))), vec3(0.5)),1.0); //Color filter for smoother colors\n    //fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Noise maker\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //float m = min(iResolution.x, iResolution.y);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 2.0*pi;\n    uv.y -= 0.5;\n    uv.y *= pi;\n    \n    vec3 coord = vec3(cos(uv.y)*sin(uv.x),sin(uv.y),cos(uv.y)*cos(uv.x));\n    \n    //vec3 diff = windChangeSpeed*iTime*timeRate;\n    vec3 diff = vec3(cos(windChangeSpeed*iTime*timeRate), windChangeSpeed*iTime*timeRate*0.2, sin(windChangeSpeed*iTime*timeRate));\n    \n    fragColor = vec4(vec3(simplex3d(4.0*coord+diff)+0.0*simplex3d(16.0*coord+diff)),1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "//Curl noise maker\nfloat noisev(vec2 uv) {\n    return texture(iChannel0, uv).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 wx = uv;\n    \n    wx.y -= 0.5;\n    wx.y *= pi;\n    \n    float gradStep = 0.01;\n    \n    vec2 uvr = uv+vec2(gradStep,0.0);\n    vec2 uvl = uv-vec2(gradStep,0.0);\n    vec2 uvt = uv+vec2(0.0,gradStep);\n    vec2 uvb = uv-vec2(0.0,gradStep);\n    \n    uvr.x = mod(uvr.x, 1.0);\n    uvl.x = mod(uvl.x, 1.0);\n    uvt.x = mod(uvt.x, 1.0);\n    uvb.x = mod(uvb.x, 1.0);\n    \n    vec2 grad = vec2(noisev(uvr)-noisev(uvl),noisev(uvt)-noisev(uvb));\n    \n    fragColor = vec4(-grad.y/cos(wx.y),grad.x,noisev(uv),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Weather maker\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 wx = fragCoord/iResolution.xy;\n    \n    vec2 uv = wx;\n    \n    uv.x *= 2.0*pi;\n    uv.y -= 0.5;\n    uv.y *= pi;\n    \n    vec3 coord = vec3(cos(uv.y)*sin(uv.x),sin(uv.y),cos(uv.y)*cos(uv.x));\n    \n    float temp = sqrt(1.0-pow(2.0*uv.y/pi,2.0));\n    \n    vec4 cv = texture(iChannel0,wx);\n    \n    cv.y += 0.0005*(temp-cv.y);\n    float maxW = exp((cv.y-1.0)*3.0);\n    \n    vec2 adjustCoord = wx-cloudMoveSpeed*timeRate*texture(iChannel1,wx).xy;\n    adjustCoord.x = mod(adjustCoord.x, 0.999);\n    vec4 pt = texture(iChannel0, adjustCoord);\n    \n    //float pMult = 0.4*exp(-pow(1.0/3.0*sin(3.0*uv.y),2.0))+1.6;\n    float pMult = 2.0;\n    \n    if (iTime < 0.1) { //Page loading heartstart\n        pt = vec4(2.0*vec3(exp(-pow(1.0/3.0*sin(3.0*uv.y),2.0))),1.0);\n    }\n    \n    cv = (1.0-cloudMoveMult)*cv + pt*cloudMoveMult;\n    \n    float dcz = 0.01*(maxW-cv.z);\n    \n    cv.z += max(dcz,0.0);\n    \n    dcz = 0.0015*(maxW/pMult-cv.z);\n    \n    cv.z += dcz;\n    cv.x += -min(dcz,0.0);\n    cv.x *= 0.999;\n    fragColor = cv;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Cloud generation consts\nconst float timeRate = 1.0;\n\nconst float cloudMoveSpeed = 0.01;\n\nconst float cloudMoveMult = 0.1;\n\nconst float cloudDiffuseRate = 0.99995;\nconst float cloudAdditionRate = 0.000055;\n\nconst float windChangeSpeed = 0.1;\n\n/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright © 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat simplexfract(vec3 p) {\n    float persistence = 0.37;\n    float detail = 3.0;\n    int octaves = 4;\n    float sp = 1.0;\n    float sd = 1.5;\n    \n    float spherenoise = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        spherenoise += sp*simplex3d(p*sd);\n        sp *= persistence;\n        sd *= detail;\n    }\n    spherenoise -= 0.1;\n    spherenoise += 3.0*simplex3d(p)*simplex3d(p+3.0)*(1.0-abs(simplex3d(10.0*p)));\n    \n    return spherenoise;\n}\n\n#define pi 3.14159", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1464, 1464, 1485, 1485, 1550], [1552, 1552, 1577, 1577, 1606], [1608, 1608, 1660, 1660, 2027], [2029, 2029, 2059, 2059, 2083], [2085, 2085, 2110, 2110, 2193], [2195, 2195, 2222, 2222, 2258], [2260, 2260, 2287, 2287, 2667], [2669, 2669, 2699, 2699, 2966], [2968, 2968, 3010, 3010, 3038], [3680, 3680, 3737, 3753, 11789]], "test": "untested"}
{"id": "ctBBzV", "name": "Antenna Simulation", "author": "wyatt", "description": "The skin effect is where the current tends towards the sides of the wire at high frequency. The color indicates the current. Here An emitter induces a current in a receiver. Imagine wires going into the screen. ", "tags": ["maxwell", "wire", "em"], "likes": 25, "viewed": 264, "published": 3, "date": "1694215339", "time_retrieved": "2024-07-30T17:34:52.971423", "image_code": "// Fork of \"Simulation vs Prediction\" by wyatt. https://shadertoy.com/view/dtffDM\n// 2023-09-08 21:37:53\n\nMain {\n    float _ = .01;\n    /*if (true) {\n        vec2 r = U-emitter*R;\n        vec2 u = normalize(r);\n        float l = length(r);\n            float x = ((float(iFrame-10)-sqrt(mu*eps)*2.*l)/60.);\n         float dj= eps*(f(x)+df(x));\n\n         Q += 25.*pi*vec4(\n             dj*u.y,\n            -dj*u.x,\n            mu*df(x),\n            1\n        )/(55.+l);\n    }\n    if (true) {\n        vec2 r = U-reciever*R;\n        vec2 u = normalize(r);\n        float l = length(r);\n        float dr = sqrt(mu*eps)*2.*length(emiter*R-reciever*R);\n            float x = ((float(iFrame-20)-sqrt(mu*eps)*2.*l - dr)/60.);\n         float dj= eps*(f(x)+df(x));\n\n         Q += 25.*pi*25.* pi/dr*vec4(\n             dj*u.y,\n            -dj*u.x,\n            mu*df(x),\n            1\n        )/(55.+l);\n    }\n    if (!true) {\n        vec2 r = U-vec2(.3,.3)*R;\n        vec2 u = normalize(r);\n        float l = length(r);\n        float x = ((float(iFrame-10)-sqrt(mu*eps)*2.*l)/60.);\n        vec2 m = g(x);\n        vec2 dm = dg(x)+.5*ddg(x);\n        Q += pi*vec4(\n            .15*vec2(u.y,-u.x)*dm.x*u.y+\n            .15*vec2(-u.y,u.x)*dm.y*u.x+\n            6.*(+2.*m/l-4.*u*dot(u,m)/l)\n            ,\n            .25*(u.y*dm.x-u.x*dm.y),\n            1.\n        )/(55.+l);\n    }\n    vec2 u = U;\n    u -= .5*R;\n    float a = -3.+1.*iTime;\n    u *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    //if (sign(u.x)<0.) */\n    \n    vec4 H = .25*(A(U+vec2(0,1))+A(U+vec2(1,1))+A(U+vec2(1,0))+A(U+vec2(0,0)));\n    \n   \n    H.z *= 5.;\n    Q = 1.-vec4(1)*smoothstep(0.,2.*fwidth(H.z),abs(cos(+1.57+H.z)));\n    //Q *= 1.-exp(-10000.*length(H.w));  \n    //Q.xy += H.xy;\n    if (U.x<50.||U.y<50.||R.x-U.x<55.||R.y-U.y<55.)\n            Q *= .0;\n    if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.)\n        Q *= 0.;\n    if (length(U-emitter*R) < P*R.y || length(U-reciever*R) < P*R.y) \n        Q = mix(atan(vec4(-H.w,.25*abs(H.w),H.w,1)),vec4(1),.0*Q);\n        \n    // Q = abs(H)*vec4(.001,.001,.003,1);\n     \n     \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define emitter vec2(.65,.5)\n#define reciever vec2(.35,.5)\n\n#define P .1\n\n\n#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\nfloat f (float x) {\n    // Change the input signal here!\n    return 10.*smoothstep(0.,1.,x)*asin(.9*cos(x*.25+10.*sin(.02*x)));\n}\nfloat df (float x) {\n    float e = .1;\n    return (f(x+e)-f(x-e))/(2.*e);\n}\nfloat ddf (float x) {\n    float e = .1;\n    return (df(x+e)-df(x-e))/(2.*e);\n}\n\n\nvec2 g (float x) {\n    // Change the input signal here!\n    \n    return vec2(50.*asin(.9*sin(3.1+2.*x)),\n                50.*asin(.9*sin(3.1+1.5*x)))*step(0.,x);\n}\nvec2 dg (float x) {\n    float e = .1;\n    return (g(x+e)-g(x-e))/(2.*e);\n}\nvec2 ddg (float x) {\n    float e = .1;\n    return (dg(x+e)-dg(x-e))/(2.*e);\n}", "buffer_a_code": "Main {\n    {\n        Q = A(U);\n        vec4 n = A(U+vec2(0,1));\n        vec4 e = A(U+vec2(1,0));\n        vec4 s = A(U-vec2(0,1));\n        vec4 w = A(U-vec2(1,0));\n        if (length(U-emitter*R) < P*R.y) Q.w += 1./R.y*f(float(iFrame*4+0)/R.x);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n        if ((iFrame*4+0)%2==0) {\n            // dB/dt = -curl E\n            Q.x -= .5/mu*(n.z-s.z);\n            Q.y += .5/mu*(e.z-w.z);\n        } else {\n            // dE/dt = curl B - j\n            Q.z -= .5/eps*(n.x-s.x-e.y+w.y) - Q.w;\n        }\n        Q.w -= 2.*Q.z/R.y;\n        if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n            Q *= .97;\n        if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.)\n            Q *= 0.;\n        if (length(U-emitter*R) < P*R.y);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n    } \n        \n    \n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    {\n        Q = A(U);\n        vec4 n = A(U+vec2(0,1));\n        vec4 e = A(U+vec2(1,0));\n        vec4 s = A(U-vec2(0,1));\n        vec4 w = A(U-vec2(1,0));\n        if (length(U-emitter*R) < P*R.y) Q.w += 1./R.y*f(float(iFrame*4+1)/R.x);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n        if ((iFrame*4+1)%2==0) {\n            // dB/dt = -curl E\n            Q.x -= .5/mu*(n.z-s.z);\n            Q.y += .5/mu*(e.z-w.z);\n        } else {\n            // dE/dt = curl B - j\n            Q.z -= .5/eps*(n.x-s.x-e.y+w.y) - Q.w;\n        }\n        Q.w -= 2.*Q.z/R.y;\n        if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n            Q *= .97;\n        if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.)\n            Q *= 0.;\n        if (length(U-emitter*R) < P*R.y);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n    } \n        \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    {\n        Q = A(U);\n        vec4 n = A(U+vec2(0,1));\n        vec4 e = A(U+vec2(1,0));\n        vec4 s = A(U-vec2(0,1));\n        vec4 w = A(U-vec2(1,0));\n        if (length(U-emitter*R) < P*R.y) Q.w += 1./R.y*f(float(iFrame*4+2)/R.x);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n        if ((iFrame*4+2)%2==0) {\n            // dB/dt = -curl E\n            Q.x -= .5/mu*(n.z-s.z);\n            Q.y += .5/mu*(e.z-w.z);\n        } else {\n            // dE/dt = curl B - j\n            Q.z -= .5/eps*(n.x-s.x-e.y+w.y) - Q.w;\n        }\n        Q.w -= 2.*Q.z/R.y;\n        if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n            Q *= .97;\n        if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.)\n            Q *= 0.;\n        if (length(U-emitter*R) < P*R.y);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n    } \n        \n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    {\n        Q = A(U);\n        vec4 n = A(U+vec2(0,1));\n        vec4 e = A(U+vec2(1,0));\n        vec4 s = A(U-vec2(0,1));\n        vec4 w = A(U-vec2(1,0));\n        if (length(U-emitter*R) < P*R.y) Q.w += 1./R.y*f(float(iFrame*4+3)/R.x);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n        if ((iFrame*4+3)%2==0) {\n            // dB/dt = -curl E\n            Q.x -= .5/mu*(n.z-s.z);\n            Q.y += .5/mu*(e.z-w.z);\n        } else {\n            // dE/dt = curl B - j\n            Q.z -= .5/eps*(n.x-s.x-e.y+w.y) - Q.w;\n        }\n        Q.w -= 2.*Q.z/R.y;\n        if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n            Q *= .97;\n        if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.)\n            Q *= 0.;\n        if (length(U-emitter*R) < P*R.y);\n        else if (length(U-reciever*R) > P*R.y) Q.w *= 0.;\n    } \n        \n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DtBBRK", "name": "Fork Varonoi PauloFalca 388", "author": "PauloFalcao", "description": "This shader has been generated using Material Maker (and cleaned up manually).\nIt shows a modified Voronoi node that accepts inputs for density and randomness (the density is shown as BW background, and randomness is a checkerboard).", "tags": ["materialmaker"], "likes": 5, "viewed": 183, "published": 3, "date": "1694210684", "time_retrieved": "2024-07-30T17:34:53.854063", "image_code": "// Made an example that uses an input image using the original RodzLabs Code\n// Original code by RodzLabs here - https://www.shadertoy.com/view/mt2fRy\n\nconst float density = 10.000000000;\nconst float randomness = 1.000000000;\n\nfloat in_density(vec2 uv){\n    vec4 c=texture(iChannel0,uv);\n    return (c.x+c.y+c.z)/3.0;\n}\n\nfloat in_randomness(vec2 uv){\n    vec4 c=texture(iChannel1,uv);\n    return (c.x+c.y+c.z)/3.0;\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14, 3.14))) * 43758.5);\n}\n\n// Based on https://www.shadertoy.com/view/ldl3W8\n// The MIT License\n// Copyright  2013 Inigo Quilez\nvec2 voronoi_cell_offset(int i, int np, vec2 seed, vec2 offset, vec2 size) {\n\tfloat rows = round(sqrt(float(np)));\n\tfloat rowsize = float(np)/rows;\n\tfloat row = floor(float(i)/rowsize);\n\tfloat firstcol = ceil(row*float(np)/rows);\n\tfloat cols = ceil((row+1.0)*float(np)/rows) - firstcol;\n\tvec2 c1 = vec2((float(i) - firstcol)/cols, float(row)/float(rows));\n\tvec2 c2 = vec2(((float(i+1) - firstcol))/cols, (row+1.0)/rows);\n\treturn c1+(randomness*in_randomness(offset+0.5*(c1+c2)*size)*(seed-vec2(0.5))+vec2(0.5))*(c2-c1);\n}\n\n\nvec4 variable_voronoi(vec2 x, vec2 size, vec2 stretch, vec2 seed) {\n\tx *= size;\n\tvec2 n = floor(x);\n\tvec2 f = fract(x);\n\n\tvec2 mg, mr, mc;\n\tfloat md = 8.0;\n\tfor (int j=-1; j<=1; j++)\n\tfor (int i=-1; i<=1; i++) {\n\t\tvec2 g = vec2(float(i),float(j));\n\t\tvec2 s = seed + mod(n + g + size, size);\n\t\tint np = max(1, int(in_density(fract((n + g + vec2(0.5)) / size))*density));\n\t\tfor (int p = 0; p < np; ++p) {\n\t\t\ts = rand2(s);\n\t\t\tvec2 o = voronoi_cell_offset(p, np, s, fract((n + g)/size), vec2(1.0)/size);\n\t\t\tvec2 c = g + o;\n\t\t\tvec2 r = c - f;\n\t\t\tvec2 rr = r*stretch;\n\t\t\tfloat d = dot(rr,rr);\n\n\t\t\tif (d<md) {\n\t\t\t\tmc = c;\n\t\t\t\tmd = d;\n\t\t\t\tmr = r;\n\t\t\t\tmg = g;\n\t\t\t}\n\t\t}\n\t}\n\n\tmd = 8.0;\n\tfor (int j=-2; j<=2; j++)\n\tfor (int i=-2; i<=2; i++) {\n\t\tvec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 s = seed + mod(n + g + size, size);\n\t\tint np = max(1, int(in_density(fract((n + g + vec2(0.5)) / size))*density));\n\t\tfor (int p = 0; p < np; ++p) {\n\t\t\ts = rand2(s);\n\t\t\tvec2 o = voronoi_cell_offset(p, np, s, fract((n + g)/size), vec2(1.0)/size);\n\t\t\tvec2 r = g + o - f;\n\t\t\tvec2 rr = (mr-r)*stretch;\n\t\t\tif (dot(rr,rr)>0.00001)\n\t\t\t\tmd = min(md, dot(0.5*(mr+r)*stretch, normalize((r-mr)*stretch)));\n\t\t}\n\t}\n\treturn vec4(mc+n, length((x-(mc+n))*stretch), md);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=fragCoord/iResolution.xy;\n\n    fragColor = vec4(vec3(variable_voronoi(uv,vec2(32.0,32.0),vec2(1.0,1.0),vec2(0.190681249)).z),1.0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 253, 253, 319], [321, 321, 350, 350, 416], [418, 418, 438, 438, 574], [1201, 1201, 1268, 1268, 2434], [2437, 2437, 2492, 2492, 2637]], "test": "untested"}
{"id": "ctSBRV", "name": "Noise Fireflies", "author": "leon", "description": "Noise patterns research", "tags": ["noise"], "likes": 21, "viewed": 303, "published": 3, "date": "1694209811", "time_retrieved": "2024-07-30T17:34:54.721744", "image_code": "\n// Noise Fireflies\n// Leon Denise\n// 2023/09/08\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// gyroid pattern\nfloat gyroid (vec3 p)\n{\n    return dot(sin(p),cos(p.yzx));\n}\n\n// noise\nfloat fbm (vec2 p)\n{\n    vec3 q = vec3(p, 0.);\n    float result = 0., a = .5;\n    for (float i = 0.; i < 4.; ++i, a /= 2.)\n    {\n        q += (result-.5)*.5;\n        result += abs(gyroid(q/a)*a);\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    p += iTime * 0.1;\n    \n    // animate\n    vec2 q = p*.5;\n    vec2 cell = floor(q);\n    float t = iTime*(.5+pow(hash12(cell), 4.)*2.);\n    vec2 anim = vec2(fract(t), floor(t));\n    vec2 offset = mix(\n        hash23(vec3(cell, anim.y)),\n        hash23(vec3(cell, anim.y+1.)),\n        smoothstep(.0,1.,anim.x));\n    q += (offset-.5)*.1;\n    \n    // shape\n    vec2 e = vec2(.3,0);\n    float diff = abs(fbm(p+e.yx)-fbm(p-e.yx))/e.x;\n    float shape = smoothstep(.001,.0, diff-1.);\n    \n    // color\n    float circle = length(fract(q)-.5);\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*5.5+floor(diff-circle*10.)*.5);\n    vec3 color = shape * tint;\n    color += (1.-circle) * .02 * tint / circle;\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 107, 129, 129, 246], [247, 247, 269, 269, 388], [390, 408, 431, 431, 468], [470, 479, 499, 499, 701], [703, 703, 760, 779, 1606]], "test": "untested"}
{"id": "clSfRK", "name": "Noise Flowers", "author": "leon", "description": "Noise patterns research", "tags": ["noise"], "likes": 22, "viewed": 273, "published": 3, "date": "1694207923", "time_retrieved": "2024-07-30T17:34:55.604383", "image_code": "\n// Noise Flowers\n// Leon Denise\n// 2023/09/08\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// gyroid pattern\nfloat gyroid (vec3 p)\n{\n    return dot(sin(p),cos(p.yzx));\n}\n\n// noise\nfloat fbm (vec2 p)\n{\n    vec3 q = vec3(p, 0);\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i, a /= 2.)\n    {\n        q += (result-.5);\n        result += gyroid(q/a)*a;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    p += iTime * 0.1;\n    \n    // displace\n    vec2 q = p*.5;\n    float circle = length(fract(q)-.5);\n    p += mix(.0, 2., hash12(floor(q)))*normalize(fract(p)-fract(q-.5)) * smoothstep(.5,.2,circle);\n    \n    // shape\n    vec2 e = vec2(.3,0);\n    float diff = abs(fbm(p+e.yx)-fbm(p-e.yx))/e.x;\n    float shape = smoothstep(.001,.0,diff*.05-.04);\n    \n    // color\n    vec3 tint = .5+.5*cos(vec3(1,2,3)+floor(diff*1.+uv.x*6.+iTime-circle*10.));\n    vec3 color = shape * tint;\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 105, 127, 127, 244], [246, 264, 287, 287, 324], [326, 335, 355, 355, 548], [550, 550, 607, 626, 1237]], "test": "untested"}
{"id": "DlSBzK", "name": "celeste dream block", "author": "JohnKranz", "description": "practice of a shader beginner, perfect in 320*180", "tags": ["2d", "celeste", "fakeparticle"], "likes": 3, "viewed": 137, "published": 3, "date": "1694207476", "time_retrieved": "2024-07-30T17:34:56.423195", "image_code": "\n// hash function from \"Hash without sine\" by Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat blinkLevel(int size, float frameNum){\n    if(size == 1){\n        return floor(mod(frameNum, 2.));\n    }else if(size == 2){\n        float num = ceil(mod(frameNum, 4.));\n        if(num > 2.){\n            return 4. - num;\n        }else{\n            return num;\n        }\n    }else{\n        return 0.;\n    }\n}\n\nvec3 blinkColor(int id){\n    if(id == 0){\n        return vec3(.8,0.,0.);\n    }else if(id == 1){\n        return vec3(1.,.2,.8);\n    }else if(id == 2){\n        return vec3(0.,.8,0.);\n    }else if(id == 3){\n        return vec3(.4,1.,.4);\n    }else if(id == 4){\n        return vec3(0.,0.,1.);\n    }else if(id == 5){\n        return vec3(0.,.8,1.);\n    }else if(id == 6){\n        return vec3(1.,1.,0.);\n    }\n    return vec3(0.);\n}\n\n\nvec4 blink(vec2 p){\n    vec2 pixelUnit = vec2(1.) / iResolution.xy;\n    vec2 whRatio = vec2(iResolution.x / iResolution.y,1.);\n    vec4 l = vec4(0.);\n    float whAvg = (iResolution.x + iResolution.y) / iResolution.y * 90.;\n    for (float i = 0.; i < 320.; i += 1.) {\n        float z = hash(i*.1);\n        l.rgb = blinkColor(int(hash(i*.4) * 7.));\n        float offset = hash(i*.5) * 3.;\n        int size = int(3.*z*z);\n        int depth = (3 - size) * 100;\n        float level = blinkLevel(size, iTime / 0.2f + offset) + 1.;\n        float invDepth = 1./float(depth);\n        vec2 pos = fract(vec2(hash(i*.2), hash(i*.3)) + 100.*iMouse.xy/iResolution.xy*invDepth);\n        pos -= mod(pos,pixelUnit) + pixelUnit / 2.;\n        vec2 delta = (p - pos) * whRatio;\n        float range = abs(delta.x) + abs(delta.y);\n\n        float inRange = (level - 2.) / whAvg;\n        float outRange = level / whAvg;\n\n        l.a = step(inRange, range) * step(range, outRange);\n\n        if(l.a > 0.){\n            return l;\n        }\n    }\n    return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    fragColor = blink(p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 99, 120, 120, 205], [207, 207, 250, 250, 518], [520, 520, 544, 544, 945], [948, 948, 967, 967, 1988], [1990, 1990, 2045, 2045, 2113]], "test": "untested"}
{"id": "mljfzy", "name": "Noise Worlds", "author": "leon", "description": "Brush patterns research", "tags": ["noise"], "likes": 30, "viewed": 288, "published": 3, "date": "1694204465", "time_retrieved": "2024-07-30T17:34:57.294864", "image_code": "\n// Noise Worlds\n// Leon Denise\n// 2023/09/08\n\n// gyroid pattern\nfloat gyroid (vec3 p)\n{\n    return dot(sin(p),cos(p.yzx));\n}\n\n// noise\nfloat fbm (vec2 p)\n{\n    vec3 q = vec3(p, 0);\n    float result = 0., a = .5;\n    for (float i = 0.; i < 4.; ++i, a /= 2.)\n    {\n        q += (result-.5);\n        result += gyroid(q/a)*a;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 p = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    p += iTime * 0.1;\n    \n    // shape\n    float e = .3;\n    float diff = abs(fbm(p+vec2(0,e))-fbm(p-vec2(0,e)))/e;\n    float circle = length(fract(p*.5)-.5);\n    float thin = smoothstep(.5,.0,circle) * 2.;\n    float shape = smoothstep(.01/thin,0.,diff-thin+.1);\n    fragColor = vec4(shape);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 65, 88, 88, 125], [127, 136, 156, 156, 349], [351, 351, 408, 427, 783]], "test": "untested"}
{"id": "dlBfDw", "name": "graphing calculator thingy", "author": "ThePlaneGuy45", "description": "only supports y=x functions rn :/", "tags": ["calculator"], "likes": 4, "viewed": 135, "published": 3, "date": "1694204210", "time_retrieved": "2024-07-30T17:34:58.189473", "image_code": "/*\n\nFUNCTION EDITOR IN COMMON TAB\n\n>>>>>>>by ThePlaneGuy45<<<<<<<<\n\ncredits to Ingo Quilez for their Segment SDF: https://www.shadertoy.com/view/3tdSDj\n\n*/\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\n\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n    \n} // From Inigo Quilez (https://www.shadertoy.com/view/3tdSDj)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 c = fragCoord - iResolution.xy/2.0;\n    c /= iResolution.x;\n    c *= 10.0;\n    vec2 m = iMouse.xy;\n    m.x -= iResolution.x/2.0;\n    m /= iResolution.y;\n    m *= vec2(10.0, 5.0);\n    \n    if(abs(mod(c.x+m.x/m.y, 1.0/m.y)) < 0.01 || abs(mod(c.y, 1.0/m.y)) < 0.01) {\n    \n        fragColor = vec4(0.3, 0.3, 0.4, 1.0);\n    \n    }\n    \n    if(abs(c.x+m.x/m.y) < 0.015) {\n    \n        fragColor = vec4(0.7, 0.5, 0.5, 1.0);\n    \n    }\n    \n    if(abs(c.y) < 0.015) {\n    \n        fragColor = vec4(0.5, 0.7, 0.5, 1.0);\n    \n    }\n\n    float dist;\n    float y;\n    float prev;\n    float close = 10000.0;\n    vec4 fc = fragColor;\n    \n    for(float x = -10.0; x < 10.0; x+=STEP) {\n    \n        y = f(x*m.y + m.x)/m.y;\n        dist = sdSegment(c, vec2(x, y), vec2(x-STEP, prev));\n        if(dist<=0.02 && dist<close){close=dist;fragColor=mix(fc, vec4(1.0), \n        \n            smoothstep(1.0, 0.0, close * 50.0)\n            \n        );}\n        prev = y;\n    \n    }\n    \n}", "image_inputs": [], "common_code": "#if __LINE__<15\n#define iTime 0.0\n#endif\n#define STEP 0.05\n#define PI 3.141592653589793238462643383279\n\n#define EQU 3\n\nfloat f(float x) {switch(EQU) {\n\n\ncase 0:\n    x /= 2.0;\n    float xx = pow(x, x);\n    return 2.0 * abs(sin(xx) / pow(2.0, (xx - PI / 2.0) / PI));\ncase 1:\n    return (sin(PI*x)+sin(2.0*x))/2.0;\ncase 2:\n    return x*x;\ncase 3:\n    return (sin(PI*(x-iTime))+sin(2.0*(x+iTime)))/2.0;\n    \n}}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 209, 209, 334], [397, 397, 454, 454, 1472]], "test": "untested"}
{"id": "ml2Bzy", "name": "Torus but Spiralized", "author": "Varyemez", "description": "torus but spiralized", "tags": ["spiraltorus"], "likes": 4, "viewed": 133, "published": 3, "date": "1694201251", "time_retrieved": "2024-07-30T17:34:58.954427", "image_code": "const int MAX_STEP = 15;\nconst float SURFACE_DIST = 0.02;\nconst float PI = radians(180.);\n\nconst vec2 torusr = vec2(0.85, 0.15)*0.5;\n\nmat2 rot2d(float r)\n{\n    float s = sin(r), c = cos(r);\n    return mat2(c,-s,s,c);\n}\nfloat random(vec2 s)\n{\n    return fract(sin(dot(s, vec2(362.485, 123.445))*764.346)*2647.9752);\n}\n\nfloat plane(vec3 p)\n{\n    return abs(p.y);\n}\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\nfloat torus(vec3 p, float a, float b)\n{\n    return length(vec2(length(p.xz)-a, p.y))-b;\n}\nfloat cube(vec3 p, float r)\n{\n    p = abs(p);\n    return length(max(p-r, 0.));\n}\n\nfloat map(vec3 p)\n{\n    p = fract(p);\n    p -= 0.5;\n    float t0 = torus(p, torusr.x, torusr.y);\n    p.xy *= rot2d(PI*0.5);\n    p.z -= 0.5;\n    float t1 = torus(p, torusr.x, torusr.y);\n    p.z += 1.;\n    float t2 = torus(p, torusr.x, torusr.y);\n    return min(min(t0, t1), t2);\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(0.05, 0.);\n    float d = map(p);\n    return -normalize(vec3(\n        d-map(p+e.xyy),\n        d-map(p+e.yxy),\n        d-map(p+e.yyx)\n    ));\n}\n\nfloat raymarch(vec3 vo, vec3 dir)\n{\n    float d = 0.;\n    for (int i = 0; i < MAX_STEP; i++)\n    {\n        vec3 p = vo + dir*d;\n        p.y -= 1.;\n        p.xy *= rot2d(p.z*0.75);\n        p.y += 1.;\n        float cd = map(p);\n        if (cd < SURFACE_DIST)\n            break;\n        d += cd;\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n    vec3 r0 = vec3(0.,1.,0.);\n    vec3 dir = normalize(vec3(uv.xy, 1.));\n    r0.z += iTime*0.45;\n    float d = raymarch(r0, dir);\n    vec3 p = r0 + dir*d;\n\n    fragColor = vec4(0.3, 0., 1., 1.) / max(0.5, d);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2Bzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 155, 155, 218], [219, 219, 241, 241, 316], [318, 318, 339, 339, 362], [363, 363, 394, 394, 420], [421, 421, 460, 460, 510], [511, 511, 540, 540, 591], [593, 593, 612, 612, 872], [874, 874, 899, 899, 1059], [1061, 1061, 1096, 1096, 1375], [1377, 1377, 1432, 1432, 1762]], "test": "untested"}
{"id": "mt2fRy", "name": "Varonoi", "author": "RodzLabs", "description": "This shader has been generated using Material Maker (and cleaned up manually).\nIt shows a modified Voronoi node that accepts inputs for density and randomness (the density is shown as BW background, and randomness is a checkerboard).", "tags": ["materialmaker"], "likes": 10, "viewed": 190, "published": 3, "date": "1694200528", "time_retrieved": "2024-07-30T17:34:59.882944", "image_code": "// Generated using Material Maker\n// The MIT License\n// Copyright © 2023 Rodolphe Suescun\n\n#define SEED_VARIATION 0.0\n\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14, 3.14))) * 43758.5);\n}\n\nconst float p_o675333283391_amount1 = 1.000000000;\nconst float p_o675350060610_value = 0.020000000;\nconst float p_o675350060610_width = 0.020000000;\nconst float seed_o675249397878 = 0.190681249;\nconst float p_o675249397878_scale_x = 8.000000000;\nconst float p_o675249397878_scale_y = 8.000000000;\nconst float p_o675249397878_stretch_x = 1.000000000;\nconst float p_o675249397878_stretch_y = 1.000000000;\nconst float p_o675249397878_density = 20.000000000;\nconst float p_o675249397878_randomness = 1.000000000;\nconst float p_o675232619757_default_in1 = 1.000000000;\nconst float p_o675232619757_default_in2 = 0.000000000;\nconst float p_o675215842546_sides = 6.000000000;\nconst float p_o675215842546_radius = 0.900000000;\nconst float p_o675215842546_edge = 0.60000000;\nconst float p_o675417169501_x_scale = 2.000000000;\nconst float p_o675417169501_y_scale = 2.000000000;\nconst vec4 p_o675366837491_color = vec4(0.078431375, 0.000000000, 1.000000000, 1.000000000);\n\nvec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nfloat shape_polygon(vec2 uv, float sides, float size, float edge) {\n\tuv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n\tfloat angle = atan(uv.x, uv.y)+3.14159265359;\n\tfloat slice = 6.28318530718/sides;\n\treturn clamp((1.0-(cos(floor(0.5+angle/slice)*slice-angle)*length(uv))/size)/edge, 0.0, 1.0);\n}\n\nfloat wave_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat mix_xor(float x, float y) {\n\treturn min(x+y, 2.0-x-y);\n}\n\nfloat o675249397878_input_in_density(vec2 uv, float _seed_variation_) {\nfloat o675215842546_0_1_f = shape_polygon((uv), p_o675215842546_sides, p_o675215842546_radius*1.0, p_o675215842546_edge*1.0);\nfloat o675232619757_0_clamp_false = p_o675232619757_default_in1-o675215842546_0_1_f;\nfloat o675232619757_0_clamp_true = clamp(o675232619757_0_clamp_false, 0.0, 1.0);float o675232619757_0_1_f = o675232619757_0_clamp_false;\n\nreturn o675232619757_0_1_f;\n}\nfloat o675249397878_input_in_randomness(vec2 uv, float _seed_variation_) {\nfloat o675417169501_0_1_f = mix_xor(wave_square(p_o675417169501_x_scale*uv.x), wave_square(p_o675417169501_y_scale*uv.y));\n\nreturn o675417169501_0_1_f;\n}\n\n// Based on https://www.shadertoy.com/view/ldl3W8, The MIT License, Copyright © 2013 Inigo Quilez\nvec2 voronoi_cell_offset_o675249397878(int i, int np, vec2 seed, vec2 offset, vec2 size, float _seed_variation_) {\n\tfloat rows = round(sqrt(float(np)));\n\tfloat rowsize = float(np)/rows;\n\tfloat row = floor(float(i)/rowsize);\n\tfloat firstcol = ceil(row*float(np)/rows);\n\tfloat cols = ceil((row+1.0)*float(np)/rows) - firstcol;\n\tvec2 c1 = vec2((float(i) - firstcol)/cols, float(row)/float(rows));\n\tvec2 c2 = vec2(((float(i+1) - firstcol))/cols, (row+1.0)/rows);\n\treturn c1+(p_o675249397878_randomness*o675249397878_input_in_randomness((offset+0.5*(c1+c2)*size), 0.0)*(seed-vec2(0.5))+vec2(0.5))*(c2-c1);\n}\nvec4 voronoi_o675249397878(vec2 x, vec2 size, vec2 stretch, vec2 seed, float _seed_variation_) {\n\tx *= size;\n\tvec2 n = floor(x);\n\tvec2 f = fract(x);\n\n\tvec2 mg, mr, mc;\n\tfloat md = 8.0;\n\tfor (int j=-1; j<=1; j++)\n\tfor (int i=-1; i<=1; i++) {\n\t\tvec2 g = vec2(float(i),float(j));\n\t\tvec2 s = seed + mod(n + g + size, size);\n\t\tint np = max(1, int(o675249397878_input_in_density((fract((n + g + vec2(0.5)) / size)), 0.0)*p_o675249397878_density));\n\t\tfor (int p = 0; p < np; ++p) {\n\t\t\ts = rand2(s);\n\t\t\tvec2 o = voronoi_cell_offset_o675249397878(p, np, s, fract((n + g)/size), vec2(1.0)/size, _seed_variation_);\n\t\t\tvec2 c = g + o;\n\t\t\tvec2 r = c - f;\n\t\t\tvec2 rr = r*stretch;\n\t\t\tfloat d = dot(rr,rr);\n\n\t\t\tif (d<md) {\n\t\t\t\tmc = c;\n\t\t\t\tmd = d;\n\t\t\t\tmr = r;\n\t\t\t\tmg = g;\n\t\t\t}\n\t\t}\n\t}\n\n\tmd = 8.0;\n\tfor (int j=-2; j<=2; j++)\n\tfor (int i=-2; i<=2; i++) {\n\t\tvec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 s = seed + mod(n + g + size, size);\n\t\tint np = max(1, int(o675249397878_input_in_density((fract((n + g + vec2(0.5)) / size)), 0.0)*p_o675249397878_density));\n\t\tfor (int p = 0; p < np; ++p) {\n\t\t\ts = rand2(s);\n\t\t\tvec2 o = voronoi_cell_offset_o675249397878(p, np, s, fract((n + g)/size), vec2(1.0)/size, _seed_variation_);\n\t\t\tvec2 r = g + o - f;\n\t\t\tvec2 rr = (mr-r)*stretch;\n\t\t\tif (dot(rr,rr)>0.00001)\n\t\t\t\tmd = min(md, dot(0.5*(mr+r)*stretch, normalize((r-mr)*stretch)));\n\t\t}\n\t}\n\treturn vec4(mc+n, length((x-(mc+n))*stretch), md);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o675249397878_0_xyzw = voronoi_o675249397878(((UV)), vec2(p_o675249397878_scale_x, p_o675249397878_scale_y), vec2(p_o675249397878_stretch_y, p_o675249397878_stretch_x), vec2((seed_o675249397878+_seed_variation_)), _seed_variation_);float o675249397878_1_1_f = o675249397878_0_xyzw.w;\nvec3 o675350060610_0_false = clamp((vec4(vec3(o675249397878_1_1_f), 1.0).rgb-vec3(p_o675350060610_value))/max(0.0001, p_o675350060610_width)+vec3(0.5), vec3(0.0), vec3(1.0));\nvec3 o675350060610_0_true = vec3(1.0)-o675350060610_0_false;\nvec4 o675350060610_0_1_rgba = vec4(o675350060610_0_true, vec4(vec3(o675249397878_1_1_f), 1.0).a);\nvec4 o675366837491_0_1_rgba = p_o675366837491_color;\nfloat o675215842546_0_1_f = 0.9*shape_polygon((fract(UV)), p_o675215842546_sides, p_o675215842546_radius*1.0, p_o675215842546_edge*1.0);\no675215842546_0_1_f += 0.1*o675249397878_input_in_randomness(UV, 0.0);\nfloat o675232619757_0_clamp_false = p_o675232619757_default_in1-o675215842546_0_1_f;\nfloat o675232619757_0_clamp_true = clamp(o675232619757_0_clamp_false, 0.0, 1.0);float o675232619757_0_1_f = o675232619757_0_clamp_false;\nvec4 o675333283391_0_b = vec4(vec3(o675232619757_0_1_f), 1.0);\nvec4 o675333283391_0_l;\nfloat o675333283391_0_a;\n\no675333283391_0_l = o675366837491_0_1_rgba;\no675333283391_0_a = p_o675333283391_amount1*(dot((o675350060610_0_1_rgba).rgb, vec3(1.0))/3.0);\no675333283391_0_b = vec4(blend_normal(UV, o675333283391_0_l.rgb, o675333283391_0_b.rgb, o675333283391_0_a*o675333283391_0_l.a), min(1.0, o675333283391_0_b.a+o675333283391_0_a*o675333283391_0_l.a));vec4 o675333283391_0_1_rgba = o675333283391_0_b;\nfragColor = o675333283391_0_1_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2fRy.jpg", "access": "api", "license": "mit", "functions": [[121, 121, 141, 141, 277], [1240, 1240, 1301, 1301, 1342], [1344, 1344, 1411, 1411, 1636], [1638, 1638, 1666, 1666, 1706], [1708, 1708, 1741, 1741, 1770], [1772, 1772, 1843, 1843, 2222], [2223, 2223, 2297, 2297, 2451], [3155, 3155, 3251, 3251, 4567], [4568, 4568, 4623, 4623, 6459]], "test": "untested"}
{"id": "ctjBDm", "name": "Year of Truchets #054", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nI dont think I have the layering correct, and totally doing it my own special / messed up way. But always fun trying to figure something!", "tags": ["truchet", "multiscale", "quadtree", "recreation"], "likes": 31, "viewed": 285, "published": 3, "date": "1694185964", "time_retrieved": "2024-07-30T17:35:01.156540", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #054\n    09/06/2023  @byt3_m3chanic\n    \n    Trying to multiscale on my own / using @Shanes neighbor loop\n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\n// @Shane 2/2 hash.\nvec2 hash22(vec2 p) { float n = sin(dot(p,vec2(57,27)));return fract(vec2(274134,32768)*n);}\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq hsv2rgb palettes & box\nvec3 hsv(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n    return c.z * mix( vec3(1),rgb,c.y);\n}\n\nfloat box( vec2 p, vec2 b){ vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 suv= uv;\n\n    // upscale\n    uv*=2.5;\n    \n    // turn and move\n    uv *= rot(-T*.08);\n    uv.x -= T*.35;\n\n    // threshold values\n    const vec2 rndX[4]=vec2[4]( vec2(.35, .55), vec2(.5, .25), vec2(.5, .5), vec2(.5, .7));\n    // distance field values.\n    vec4 d=vec4(1e5), s=vec4(1e5), b=vec4(1e5), e=vec4(1e5), f=vec4(1e5);\n    // start level\n    float level=1., grid = 1e5;\n         \n    // Main loop and neighbor checking from @Shane's shader.\n    // https://www.shadertoy.com/view/4t3BW4\n        \n    for(int k=0; k<4; k++){\n        vec2 id = floor(uv*level);\n        float frnd = hash22(id).x;\n        \n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n            \n                // neighboring cell ID.\n                vec2 neighbors = vec2(i,j);\n                vec2 home = id+neighbors;\n                vec2 rnd = hash22(home);\n      \n                // neighboring cell hash values.\n                vec2 rnd2 = hash22(floor(home/2.));\n                vec2 rnd4 = hash22(floor(home/4.));\n                vec2 rnd8 = hash22(floor(home/8.));\n\n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rnd2.y<rndX[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rnd2.y<rndX[1].y || rnd4.y<rndX[0].y)) continue;\n                // If any of the three previous larger tiles have been rendered, continue.\n                if(k==3 && (rnd2.y<rndX[2].y || rnd4.y<rndX[1].y  || rnd8.y<rndX[0].y )) continue;\n\n                // threshold\n                if(rnd.y<rndX[k].y) {\n     \n                    vec2 p = uv -(id+.5+neighbors)/level;\n                    if(rnd.x<rndX[k].x) p.x = -p.x;\n  \n                    float bx = (.5)/level;\n                    float tk = .16666/level;\n                    float hf = .5/level;\n                    float qf = .25/level;\n                    float df = qf/3.;\n                    float mf = .05/level;\n                    \n                    float square = box(p,vec2(bx));\n                    vec2 pv = length(p-vec2(hf,-hf))<length(p+vec2(hf,-hf))? p-vec2(hf,-hf):p+vec2(hf,-hf);\n   \n                    // truchet\n                    float cd = abs(length(pv)-hf)-tk;\n                    \n                    // all the dots\n                    float bc = length(abs(p)-hf)-tk;\n                    float bd = min(length(vec2(abs(p.x)-hf,p.y))-tk,length(vec2(p.x,abs(p.y)-hf))-tk);\n                    float be = min(length(vec2(abs(p.x)-hf,abs(p.y)-qf))-df,length(vec2(abs(p.x)-qf,abs(p.y)-hf))-df);\n                    \n                    // alt title\n                    if(rnd.x>.8) cd = min(length(p.x),length(p.y))-tk;\n                    // rnd blank\n                    if(rnd.x<.1&&(k<3)) cd = 1e5;\n                    \n                    cd = max(cd,square);\n                    cd = min(cd,bd);\n         \n                    if(mod(float(k),2.)==0.) cd = min(cd,bc);\n\n                    grid = min(grid, abs(square)-.0025/2.);\n                    s[k] = min(s[k], square);\n                    d[k] = min(d[k], cd);\n                    b[k] = min(b[k], bd);\n                    e[k] = min(e[k], be);\n                    f[k] = min(f[k], bc);\n                }\n            }\n        }    \n        \n        level*=2.;\n    }\n    \n    float px = fwidth(uv.x/2.);\n    float ml = 1e5;\n\n    float cvv = uv.x + .25*sin(uv.y*PI2+T*.4);\n    cvv += uv.y + .25*sin(uv.x*PI+T*.3);\n    vec3 cb = (suv.x>0.)? vec3(.8) : hsv(vec3(floor(cvv*6.)*2.045,1.,.5));\n        \n    vec3 C = vec3(.005);\n\n    C = mix(C,vec3(.05),smoothstep(px,-px,grid));\n    \n    vec4 tk = vec4(1e5);\n    for(int k=0; k<4; k++){\n\n        \n        if(mod(float(k),2.)==0.){\n            d[k]=max(min(d[k],-s[k]),-e[k]);\n            tk.x=min(tk.x,-d[k]);\n            C = mix(C,cb,smoothstep(-px,px,d[k]));\n        }else {\n            tk.x=min(tk.x,d[k]);\n            C = mix(C,cb,smoothstep(px,-px,d[k]));\n        }\n\n    }\n    \n    if(suv.x<0.) C = mix(C,vec3(1),smoothstep(px,-px,abs(tk.x)-.005));   \n    if(suv.x<0.) C = mix(C,vec3(1),smoothstep(px,-px,abs(tk.x+.06)-.0075));\n    if(M.z>0.) C = mix(C,vec3(.7),smoothstep(px,-px,grid));\n    if(suv.x>0.&&suv.x<.0025) C = vec3(1);\n    \n    // Output to screen\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjBDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[458, 478, 499, 499, 570], [571, 571, 591, 591, 636], [638, 667, 685, 685, 795], [797, 797, 824, 824, 893], [895, 895, 936, 936, 5317]], "test": "untested"}
{"id": "DlBfRy", "name": "physics͏", "author": "01000001", "description": "arrow keys / wasd\n\nbeen wanting to do this for a while so I cobbled together a quick prototype during, ironically, a physics lecture.\n\nsee the indentation in the ground - bound SDFs do not work properly. Yet. I'll see if I can find a solution. ", "tags": ["raymarching", "test", "basic", "physics"], "likes": 6, "viewed": 152, "published": 3, "date": "1694182207", "time_retrieved": "2024-07-30T17:35:02.080069", "image_code": "int maxSteps = 512;\nfloat maxDepth = 500.;\nfloat minDist = 0.001;\nvec3 lightDir = vec3(.8, -.3, .8);\nvec3 spherePos = vec3(0);\nfloat hardness = 10.;\nfloat shadow = .2;\n\nfloat pDF(vec3 p){ // Physics distance function\n    return length(p-spherePos)-1.0;\n}\n\nfloat rDF(vec3 p){ // Render distance function\n    return min(\n        pDF(p), \n        DF(p)\n    );\n}\n\nvec3 rnorm(vec3 p, float eps){ // Render normal\n    return vec3(\n        rDF(p + vec3(eps, 0, 0)) - rDF(p - vec3(eps, 0, 0)),\n        rDF(p + vec3(0, eps, 0)) - rDF(p - vec3(0, eps, 0)),\n        rDF(p + vec3(0, 0, eps)) - rDF(p - vec3(0, 0, eps))\n    )/(2.*eps);\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n    spherePos = texelFetch(iChannel0, ivec2(0), 0).xyz;\n    lightDir = normalize(lightDir);\n\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U - r)/r.y;\n    vec2 muv = (iMouse.xy == vec2(0)?vec2(0):(2.*iMouse.xy - r)/r.y - vec2(0, 1))*vec2(1, .5);\n    \n    float depth = 0.0;\n    vec3 camDir = vec3(-sin(-muv.x)*cos(muv.y), cos(-muv.x)*cos(muv.y), sin(muv.y));\n    vec3 o = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).xyz\n        + vec3(0, 0, -.5) - camDir*(8.);// + length(texelFetch(iChannel0, ivec2(.5, 1.5), 0).xyz*10.));\n        // Cool idea but needs smoothing\n    vec3 camRight = normalize(cross(camDir, vec3(0, 0, 1)));\n    vec3 camUp = (cross(camRight, camDir));\n    vec3 dirV = normalize(camDir*2. + camRight * uv.x + camUp * uv.y);\n    vec3 p;\n    \n    for (int i = 0; i++ < maxSteps;){\n    \n        p = o + dirV * depth;\n        float d = rDF(p);\n        \n        depth += d;\n        \n        if (depth > maxDepth){\n            depth = maxDepth;\n            break;\n        }\n        \n        if (d < minDist){\n            break;\n        }\n    }\n    \n    vec3 norm = rnorm(p, depth * .001);\n    \n    vec3 l;\n    float ldepth = minDist;\n    float light = 5.;\n    float b = 1e20;\n    float c = 1e20;\n    float ph = 1e20;\n    float w = 1./hardness;\n    \n    for (int i = 0; i++ < maxSteps;){\n    \n        l = p + norm*minDist + lightDir * ldepth;\n        float d = rDF(l);\n        if (d < b){\n            c = b;\n            b = d;\n        }\n                                \n        float y = (i == 0)?0.:d*d/(2.0*ph);\n        float a = sqrt(d*d-y*y);\n        c = min( c, a/(w*max(0.0,ldepth-y)) );\n        ph = d;\n        ldepth += d;\n\n        if (ldepth > maxDepth){\n            ldepth = maxDepth;\n            break;\n        }\n        \n        if (d < minDist){\n            c = 0.;\n            break;\n        }\n    }\n        \n    O = vec4(.1, .4, .9, 1);\n    light *= smoothstep(0., 1., c+shadow);    \n    light *= max(0., (dot(norm, lightDir))) / depth;\n    O.xyz *= light;    \n    \n    O = pow(O, vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define update;     if (x < minDist) minDist = x;\n    \n#define rot(x) mat2(cos(x + vec4(0, 33, 11, 0)))\n    \nfloat boxDF( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat DF(vec3 p){\n    float minDist = 1e20;\n    float x = 0.;\n    \n    \n    x = length(p-vec3(5, 0, -6)) - 5.;\n    update;\n    \n    \n    x = max(boxDF(p-vec3(-2.5, 8, 0), vec3(3)), -length(p-vec3(0, 5,2.8))+5.);\n    update;\n\n\n    //x = max(boxDF(p-vec3(-10, 17, -5), vec3(6)), -length(p-vec3(-11, 17, 3))+5.);\n        \n    x = max(p.z + 2., -length(p-vec3(-11, 17, 0))+5.);\n    update;\n        \n    p.y -= 1.;\n    p.xy *= rot(1.);\n    x = boxDF(p-vec3(0, 1.5, -2.2), vec3(1));\n    update;\n    \n    \n    p.z += .8;\n    p.yz *= rot(.3);\n    x = boxDF(p-vec3(0, -1., -2), vec3(1));\n    update;\n    \n    \n\n    return minDist;\n}\n\n\n\nvec3 pnorm(vec3 p, float eps){ // Physics normal\n    return vec3(\n        DF(p + vec3(eps, 0, 0)) - DF(p - vec3(eps, 0, 0)),\n        DF(p + vec3(0, eps, 0)) - DF(p - vec3(0, eps, 0)),\n        DF(p + vec3(0, 0, eps)) - DF(p - vec3(0, 0, eps))\n    )/(2.*eps);\n}", "buffer_a_code": "#define lt  37\n#define up  38\n#define rt  39\n#define dn  40\n#define lup 87\n#define llt 65\n#define ldn 83\n#define lrt 68\n\n\nfloat elasticity = .7;\nfloat drag = .05;\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y < 2. && U.x < 1.){\n        vec3 P;\n        vec3 V;\n        \n        vec2 r = iResolution.xy;\n        vec2 muv = iMouse.xy == vec2(0)?vec2(0):(2.*iMouse.xy - r)/r.y;\n        vec3 camDir = vec3(-sin(-muv.x)*cos(muv.y), cos(-muv.x)*cos(muv.y), sin(muv.y));\n        vec3 camRight = normalize(cross(camDir, vec3(0, 0, 1))) * length(camDir.xy);\n        \n        if (iFrame < 20){\n            P = vec3(0, 1, 1);\n            V = vec3(0, 0, 0);\n            if (U.y ==  .5) O.xyz = P;\n            if (U.y == 1.5) O.xyz = V;\n        } else {\n            P = texelFetch(iChannel0, ivec2(U.x, 0), 0).xyz;\n            V = texelFetch(iChannel0, ivec2(U.x, 1), 0).xyz; // Expandable to more physics things\n            // Process\n            \n            V.z -= 0.01;\n            \n            float d = DF(P);\n            if (d < 1.){\n                vec3 norm = pnorm(P, 0.0001);\n                V = V*(1.-elasticity) + reflect(V, norm)*elasticity;\n                V -= V*drag;\n                \n                // Solves intersections\n                P += min((DF(P+V*.5)-1.), .0) * -norm;\n            }\n            \n            V.xy += (camRight.xy * (\n                -texelFetch(iChannel3, ivec2(lt, 0), 0).x-texelFetch(iChannel3, ivec2(llt, 0), 0).x+\n                 texelFetch(iChannel3, ivec2(rt, 0), 0).x+texelFetch(iChannel3, ivec2(lrt, 0), 0).x)+ \n            camDir.xy * (\n                 texelFetch(iChannel3, ivec2(up, 0), 0).x+texelFetch(iChannel3, ivec2(lup, 0), 0).x\n                -texelFetch(iChannel3, ivec2(dn, 0), 0).x-texelFetch(iChannel3, ivec2(ldn, 0), 0).x\n            ))*0.02;\n            \n            \n            P = P+V*.5;\n\n            if (U.y ==  .5) O.xyz = P;\n            if (U.y == 1.5) O.xyz = V;\n        }\n    } \n    \n    if (U == vec2(.5, 2.5)){\n        O = mix(texelFetch(iChannel0, ivec2(U), 0), texelFetch(iChannel0, ivec2(0), 0), .1);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 187, 216, 254], [256, 256, 274, 302, 358], [360, 360, 390, 407, 624], [626, 626, 666, 666, 2689]], "test": "untested"}
{"id": "mtSfzG", "name": "Pathtracer thingy", "author": "AArt1256", "description": "Inspired by Sebastian Lague's tutorial. sorry :(", "tags": ["pathtracer"], "likes": 7, "viewed": 204, "published": 3, "date": "1694161721", "time_retrieved": "2024-07-30T17:35:03.011579", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );    \n    vec3 col = data.xyz/data.w;\n    \n\tfragColor = vec4( pow(col, vec3(0.45)), 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct HitInfo {\n    bool hit;\n    float dst;\n    vec3 point;\n    vec3 normal;\n    vec3 col;\n    vec3 mat;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nHitInfo RaySphere(Ray ray, vec3 center, float radius) {\n    HitInfo hitInfo;\n    hitInfo.hit = false;\n    vec3 offsetRayOrigin = ray.origin - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - (radius * radius);\n    float disc = b*b-4.*a*c;\n    float  dst = (-b - sqrt(disc)) / (2. * a);\n    if (dst >= 0.) {\n        hitInfo.hit = true;\n        hitInfo.dst = dst;\n        hitInfo.point = ray.origin + ray.dir * dst;\n        hitInfo.normal = normalize(hitInfo.point - center);\n    }\n    return hitInfo;\n}\n\n#define sphere(pos,rad,Col,Mat) hitInfo = RaySphere(ray,pos,rad); if (hitInfo.hit && hitInfo.dst < closestHit.dst) { closestHit = hitInfo; closestHit.col = Col; closestHit.mat = Mat; }\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    vec2 i = (-iResolution.xy + 2.0*fragCoord + hash2(g_seed))/iResolution.y;\n    vec3 viewPoint = vec3(i, 1);\n    Ray ray;\n    ray.origin = vec3(0,0,7.);\n    ray.dir = normalize(viewPoint - ray.origin);\n    vec3 lit = vec3(0.);\n    vec3 col = vec3(1.);\n    HitInfo closestHit;\n    HitInfo hitInfo;\n    for (int j = 0; j <= 8; j++) {\n        closestHit.dst = 1e3;\n        sphere(vec3(0,-100,-10),100.,vec3(1,0,0),vec3(0));\n        \n        sphere(vec3(-10,10,9),10.,vec3(1. ,1.,1),vec3(1,0,0));\n        sphere(vec3(6,10,9),3.,vec3(1. ,1.,1),vec3(0.2,0,0));\n\n        sphere(vec3(0,0,0),.5,vec3(1. ,1.,1),vec3(0,.7,0));\n        sphere(vec3(-1.1,0,0),.5,vec3(0,1,0),vec3(0));\n        sphere(vec3(1.1,0,0),.5,vec3(0,0,1),vec3(0));\n        if (closestHit.hit) {\n            ray.origin = closestHit.point;\n            vec3 dif = normalize(closestHit.normal + random_in_unit_sphere(g_seed));\n            vec3 spec = reflect(ray.dir, closestHit.normal);\n            ray.dir = mix(dif,spec,closestHit.mat.y);\n            lit += col * closestHit.mat.x;\n            col *= closestHit.col.xyz;\n        } else break;\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n    C = data;\n    if (iFrame == 0) C = vec4(0);\n    else C += vec4(lit,4.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 235]], "test": "untested"}
{"id": "ct2Bzm", "name": "Same-Color Bars (332 chars)", "author": "fenix", "description": "The aqua-colored bars are the same color the whole time, as \"proven\" when they animate together and the stripes are removed. Code golfing encouraged! Inspired by this video:\n\nhttps://youtu.be/QTC-0F3gJhQ?si=cCPUi2ueBIwROnxW", "tags": ["optical", "illusion", "codegolf", "reproduction"], "likes": 10, "viewed": 194, "published": 3, "date": "1694144427", "time_retrieved": "2024-07-30T17:35:03.823408", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  The aqua-colored bars are the same color the whole time, as \"proven\" when they animate\n//  together and the stripes are removed. Code golfing encouraged! Inspired by this video:\n//\n//      https://youtu.be/QTC-0F3gJhQ?si=cCPUi2ueBIwROnxW\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u /= iResolution.xy;\n    \n    vec4 p = vec4(.9,.3,.9,0),\n         o = vec4(.9,.6,.2,0),\n         g = vec4(.5, 1,.6,0);\n    \n    float t = 1. - abs(fract(iTime / 8.) - .5) * 2.,\n          a = clamp(t, .5, .75) - .5,\n          b = clamp(t, .75, 1.) - .75;\n    \n    O = fract(u.x * 45.) > .5 ?\n        abs(u.y - .3 - .4 * a) < .1 ?\n            t * 4. < u.x ? p : g :\n            u.y > .5 && u.y < .5 + .8 * b ? g : p :\n        abs(u.y - .7 + .4 * a) > .1 ?\n            u.y > .5 - .8 * b && u.y < .5 ? g : o :\n            t * 4. < 2. - u.x ? o : g;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2Bzm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[543, 543, 579, 579, 1130]], "test": "untested"}
{"id": "mtjfDm", "name": "cool animation", "author": "saboofa", "description": "lines", "tags": ["procedural", "2d", "noise"], "likes": 2, "viewed": 172, "published": 3, "date": "1694135003", "time_retrieved": "2024-07-30T17:35:04.682113", "image_code": "//11:02:13\n\n#define time iTime*0.15\n#define tau 6.2831853\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\n\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 6.;i++)\n\t{\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\n\t\tz = z*2.;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat dualfbm(in vec2 p)\n{\n    //get two rotated fbm calls and displace the domain\n\tvec2 p2 = p*.7;\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\n\tbasis = (basis-.5)*.2;\n\tp += basis;\n\t\n\t//coloring\n\treturn fbm(p*makem2(time*1.2));\n}\n\nfloat circ(vec2 p) \n{\n\tfloat r = length(p);\n\tr = log(sqrt(r));\n\treturn abs(mod(r*4.,tau)-0.14)*3.+0.0;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//setup system\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*=4.;\n\t\n    float rz = dualfbm(p);\n\t\n\t//rings\n\tp /= exp(mod(time*7.,3.14159));\n\trz *= pow(abs((0.1-circ(p))),.9);\n\t\n\t//final color\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\n\tcol=pow(abs(col),vec3(.89));\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 87, 87, 152], [153, 153, 178, 178, 214], [216, 216, 238, 238, 389], [391, 391, 417, 473, 631], [633, 633, 654, 654, 738], [740, 740, 797, 813, 1120]], "test": "untested"}
{"id": "dljfWm", "name": "triangular symmetry", "author": "sympou", "description": "triangular domain repetition using symmetry.\nonly requires one read of the sdf !", "tags": ["sdfdomainrepetitiontrihex"], "likes": 13, "viewed": 218, "published": 3, "date": "1694128739", "time_retrieved": "2024-07-30T17:35:05.576720", "image_code": "#define triSize 1.\n\nvec2 triRepeat( in vec2 p ) {\n\n    //we first repeat the space inside hexagons in a grid,\n    //then we divide the hexagons into 6 symmetrical triangles\n    //(this is the method i found, there might be another one !)\n    \n    const vec2 n      = vec2(0.57735026919, 1.73205080757); // 1./sqrt(3.), sqrt(3.)\n    const vec2 offset = vec2(0.57735026919, 0.33333333333); // 1./sqrt(3.), 1/3          \n    \n    p /= triSize;\n    p += offset;\n\n    // hexagonal repetition\n    \n    p  = vec2(mod(p.x,n.y), mod(p.y + ceil(p.x*n.x), 2.) - 1.);\n    p -= vec2(n.y, min(sign(p.y)*2.,0.) + 1.) * max(sign(p.x*n.y + abs(p.y) - 2.), 0.);\n\n    // radial symmetry (6)\n    \n    p.y = abs(p.y);\n    vec2 p2 = p + vec2(p.y,-p.x)*n.y;\n    p = abs( p - p2 * max(sign(p2.y)*0.5, 0.) );\n    \n    //\n    \n    p -= offset;\n    p *= triSize;\n\n    return p;\n}\n\nfloat getVal( in vec2 p ) {\n    \n    //just put this line at the beginning of the sdf function\n    p = triRepeat(p);\n\n    p += vec2(cos(iTime),sin(iTime))*0.1;\n\n    //box sdf from iq\n    vec2 d = abs(p) - 0.1;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = 1.5*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 1.5*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n\tfloat d = getVal(p);\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 ) {\n        d = getVal(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 237, 852], [854, 854, 881, 948, 1125], [1127, 1127, 1184, 1184, 1817]], "test": "untested"}
{"id": "dlBBDm", "name": "First shader by Rafael Shepard", "author": "likeavenus", "description": "Very first shader...\nbig thanks to @kishimisu\nhttps://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["learning"], "likes": 1, "viewed": 297, "published": 3, "date": "1694105208", "time_retrieved": "2024-07-30T17:35:06.390545", "image_code": "vec3 pal( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    uv = uv * 1.;\n    \n    float d = distance(fract(uv), vec2(0.5));\n    \n    vec3 col = pal(length(uv0) - iTime);\n    \n    \n    d = sin(d * 8. - iTime) / 8.;\n    d=abs(d);\n    \n    d = 0.01 / d;\n    finalColor += col * d;\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 208], [212, 212, 269, 269, 656]], "test": "untested"}
{"id": "dtjfDD", "name": "test-april", "author": "aprilxoxo", "description": "box", "tags": ["box"], "likes": 0, "viewed": 121, "published": 3, "date": "1694082284", "time_retrieved": "2024-07-30T17:35:07.152507", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an oriented box.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l*0.5,th);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat opRound( in vec2 p, in vec2 a, in vec2 b, float th, in float r )\n{\n  return sdOrientedBox(p, a, b, th) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    // animation\n    vec2 v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n\n\tfloat d = opRound( p, v1, v2, th, 0.2 );\n\n    // distance\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = opRound(m, v1, v2, th, 0.2);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjfDD.jpg", "access": "api", "license": "mit", "functions": [[1241, 1241, 1307, 1307, 1522], [1524, 1524, 1596, 1596, 1639], [1641, 1641, 1698, 1734, 2597]], "test": "untested"}
{"id": "dtSfDD", "name": "Gaussian Splatting 3", "author": "iq", "description": "500 gaussian splats, 4000 bytes (before compression)", "tags": ["2d", "compression", "image", "gaussian", "fitting", "splatting", "gaussiansplatting"], "likes": 142, "viewed": 10911, "published": 3, "date": "1694073644", "time_retrieved": "2024-07-30T17:35:08.106955", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Remake of my 500 gaussian splats from 2010 (see link #2 below), but using\n// anysotropic gaussians instead. Info: https://iquilezles.org/articles/genetic\n//\n// Gaussian Splatting 1: https://www.shadertoy.com/view/4df3D8\n// Gaussian Splatting 2: https://www.shadertoy.com/view/MdfGDH\n// Gaussian Splatting 3: https://www.shadertoy.com/view/dtSfDD\n\n\n// 500 gaussians = 4000 bytes (before delta coding and entropy compression)\nconst uint data[] = uint[](\n0x003b55ffu,0x810992c6u,0x0fcdff07u,0xc6f12a17u,0x008e3effu,0x8500ce3fu,0x018e0bfdu,0x8efd586au,\n0x004cff29u,0x8100ee22u,0x003c9cfeu,0x8101b10eu,0x0c75b904u,0x7b09c1abu,0x05cbff0eu,0x7ef92429u,\n0x000dabffu,0x8100108cu,0x405d180eu,0x619afa30u,0x00a90a51u,0x814e5bc0u,0xf1e804a7u,0x48b5a935u,\n0x000efe50u,0x81fcd6e4u,0x0000930cu,0x8903b056u,0x0087fd88u,0x8100f329u,0x44c66f17u,0x7fb54919u,\n0x011323fau,0x80fd2468u,0x000d65f8u,0x81009462u,0x2893fd0au,0x6cee4f52u,0x00294186u,0x81024979u,\n0x4d381e42u,0x59b2b9c7u,0x01c50446u,0x8103f5afu,0x018d18ffu,0x80fd122au,0x006f033cu,0x8501ab9du,\n0x2174ab36u,0x7175f37du,0xffcdd005u,0x81015445u,0x947aed6du,0x576bcb40u,0x01d6d1d1u,0x7f380d75u,\n0x1242042fu,0x83079fb4u,0x009bab5eu,0x8101ecf6u,0x053b6e28u,0x7d4eeb7au,0x0bc93bfau,0x7b79974eu,\n0x0d2852c9u,0x79f346c3u,0xf4438809u,0x8509bf1eu,0x0175eb17u,0x7f5d878eu,0x0068c786u,0x8100253du,\n0x00bd0244u,0x81033db3u,0x0091074cu,0x811f373bu,0x00b30c36u,0x814697d7u,0x0084fd19u,0x81015cccu,\n0x006d8011u,0x81736a71u,0x95b23380u,0x376af074u,0x008e78fau,0x8100869bu,0x008f0452u,0x81031f3cu,\n0x09880465u,0x7b2b2a89u,0xffcb7b03u,0x81014c40u,0x0041a625u,0x8926cb42u,0x608fb112u,0x69883ae1u,\n0x9425070eu,0x871dd128u,0x10c3045eu,0x7f335046u,0x01420bcdu,0x7effbfaau,0x42ba3418u,0x64cb68a7u,\n0x20b40231u,0x7cf9ddb2u,0x0060481au,0x8117a747u,0x52e3eb17u,0x65abfcc2u,0x1b8f27c9u,0x73e09975u,\n0x794d125fu,0x613904c4u,0x17820876u,0x75170e9cu,0x00020636u,0x81133964u,0x6b773977u,0x4d4fb2d0u,\n0x03c115d2u,0x7eff591eu,0x003bfe14u,0x83016faeu,0x0047a104u,0x81033928u,0x40951402u,0x6ec19069u,\n0xb31e920bu,0x554f537cu,0xbb7f04a5u,0x7341b2f0u,0x89e43a0bu,0x5b76e036u,0x13018519u,0x7773ec6bu,\n0x00b506d8u,0x81019f4fu,0x00c226f7u,0x810ba38eu,0x0176217du,0x7efd6795u,0x1bd917b9u,0x7aefe87fu,\n0x00750a45u,0x830193a7u,0x5e88b60eu,0x5b4a367fu,0x26b50346u,0x80fa11b8u,0xed8d0a4cu,0x731356a9u,\n0x00940904u,0x8105b921u,0x24d21be2u,0x6f93de89u,0x8c540b66u,0x733888d3u,0xffc44d08u,0x81016c73u,\n0x0d41c133u,0x78f51dacu,0xff09023cu,0x80dd6069u,0xff080465u,0x81016670u,0xf7fe6643u,0x80ffd815u,\n0x26883413u,0x6d56e7d5u,0x80e60d2du,0x6756283du,0x08122502u,0x7d8db261u,0x3a83c807u,0x83375e4au,\n0xcab50737u,0x7b356f51u,0x00fb289eu,0x811137f0u,0x4c3d0b37u,0x675ea826u,0x31902b05u,0x75425425u,\n0x005b25d2u,0x8301e363u,0x00083113u,0x813337a4u,0xe73b3106u,0x791b04a4u,0x0aa5dc18u,0x7b575722u,\n0xa2ca089eu,0x6d5f3ec8u,0x00670f3cu,0x815b21b7u,0x00f40c30u,0x810b2565u,0x55d31576u,0x59aa285au,\n0x7ef1fe8au,0xa0c003ffu,0x01b60cd2u,0x7f05c4c2u,0x121c0d56u,0x77c6312du,0x32bd1c02u,0x94e983ffu,\n0x746e1003u,0x75506528u,0xff03041fu,0x7f01b300u,0x2c3a0f2au,0x7142de2fu,0x98861b0au,0x7b5936dfu,\n0x15a41403u,0x7f260e3du,0x00ee21f5u,0x810034dcu,0x00f62503u,0x811e95e0u,0x00d2ff06u,0x8114db5du,\n0x0c9b0623u,0x7b4335beu,0x01b409dfu,0x90fd7b9au,0x0c025e27u,0x7be72780u,0x9e471bb1u,0x515bb974u,\n0x833e080bu,0x8b29cce6u,0x00452d42u,0x810ff984u,0x00f50310u,0x8302004au,0xd4cc0a6cu,0x3b2bff79u,\n0x00c211e3u,0x8103b9a4u,0xe6aa3a08u,0x6ce7b88cu,0x9ff61144u,0x6b546affu,0xfecd0724u,0x66ff74a4u,\n0xfb5324a3u,0x4d0746e3u,0xfec46c07u,0x750300acu,0x60952905u,0x7d2f1fdcu,0x080e05e0u,0x82fd7294u,\n0xf63c3e05u,0x790af36cu,0x00a30610u,0x81230e2eu,0x5126730au,0x695b1cd1u,0x8f050767u,0x6169eedcu,\n0x00a21a2bu,0x81037275u,0x9e86901fu,0x575bfc8fu,0xb2513313u,0x8729311au,0x0082db06u,0x8d03b246u,\n0xafb40542u,0x9d4f3c4du,0x00e01315u,0x812f23cbu,0xffd7390bu,0x7f03c2e2u,0xee511905u,0x6313ab44u,\n0x2928100au,0x79633dceu,0xe2767108u,0x6b1d354bu,0x67f31812u,0x599a65c6u,0x14924c07u,0x8541c663u,\n0xcbbd470bu,0x693740a7u,0x00bcb9adu,0x81002bf4u,0x00af4b05u,0x810706d0u,0xda260b1bu,0x432725c4u,\n0x0904f309u,0x873f8850u,0xffd00846u,0x710130cdu,0x006a9d0bu,0x8102c51bu,0x8f11350du,0x5b5e5a3eu,\n0x02c39329u,0x7f83dd20u,0x5a75680cu,0x658ee648u,0x7bbd1206u,0x7f49d8fcu,0x26690613u,0x73530e3eu,\n0x0016213du,0x810fd27bu,0x17912803u,0x88edc45eu,0x00fd0554u,0x81172ac5u,0x19e1171au,0x738f1bc9u,\n0x0e81bb04u,0x7f033bb3u,0x134105f7u,0x86fffe45u,0xf80f046au,0x65070ed3u,0x85470b22u,0x6566f5deu,\n0x00068bf0u,0x8100101bu,0x9dd46f0cu,0x635384a7u,0x18c18033u,0x75c50f1bu,0x63381531u,0x717520e6u,\n0x3a7f3f80u,0x63ba8a9cu,0x2cbc9004u,0x96f181fau,0x00370422u,0x8101a906u,0x0099e914u,0x81018962u,\n0x7397131du,0x73485afdu,0x00026402u,0x81038a43u,0x3bf72803u,0x7152da22u,0x00050faau,0x810567f5u,\n0x01044607u,0x7f02864bu,0x004bc14bu,0x81027909u,0x01be9104u,0x7f3b4f46u,0x37be065bu,0x6dc9aea8u,\n0xa4010e10u,0x970f72d1u,0x03b82d19u,0x7f5b957fu,0x7f380932u,0x5b710564u,0x2dce4a23u,0x732bf357u,\n0x00843405u,0x8102644au,0x007d3affu,0x81000cf0u,0x00fb1c98u,0x810151ebu,0x00497a08u,0x81271eb8u,\n0xffcb3804u,0x81012e12u,0x3fba6438u,0x618ac581u,0xb6d20828u,0x754928d0u,0xe44f4116u,0x5d146d40u,\n0x2e280707u,0x733c6941u,0x0247264eu,0x7f42f87au,0x03701236u,0x7f0b9184u,0x0d79d905u,0x7f8ac4d2u,\n0x0b8c032du,0x7af94441u,0x00050577u,0x8101af1eu,0x0402a408u,0x8103adaeu,0x77ec2408u,0x616671d3u,\n0x07d81606u,0x7d1641c6u,0x209f1f08u,0x753a2833u,0x00a0109du,0x8125eaceu,0x6b1e2207u,0x714886dfu,\n0x0132137au,0x7f2263a8u,0x276a5714u,0x7543e87au,0xeff9116au,0x7312df49u,0x1a7b07d5u,0x80fd79fdu,\n0xb08a0b73u,0x67387b38u,0xc1fa0214u,0x910b12b8u,0x00dc4402u,0x810f1baau,0x18f1061bu,0x75420848u,\n0x00474d0fu,0x81031e9cu,0xc0d30475u,0x773d6ec3u,0xff86a50bu,0x5703f505u,0xd4d22a04u,0x6d2b2735u,\n0x334f0d07u,0x6f5b1233u,0x0a502e67u,0x7b3b0191u,0x82cd4c0cu,0x5f7ef177u,0x008a3a03u,0x8702204fu,\n0x700e16adu,0x7b70a386u,0xff0d0505u,0x80ff9e40u,0x02fd608au,0x7efcc9edu,0x3a7b0336u,0x7cfd83f1u,\n0xb3e61427u,0x2d4a473du,0x526e0d68u,0x694f78dau,0x07bcb10cu,0x80f977d2u,0x006a3615u,0x8106e7b9u,\n0xcdca1930u,0x9731030eu,0x224a3c08u,0x717ef29cu,0xebde1e62u,0x270690f9u,0xb7772653u,0x6d3baad1u,\n0x00f0120au,0x8101b0eeu,0xff89300eu,0x80dad31au,0x3b07151eu,0x73437cd7u,0x15333726u,0x773ec056u,\n0x00125f11u,0x81559a7au,0xe8730a37u,0x830e935fu,0x00e77c25u,0x81225992u,0x768a4e0cu,0x4f821966u,\n0x22350681u,0x80f9d9acu,0x0baeb409u,0x7b2746d9u,0x5a05590bu,0x618db96bu,0x00981c71u,0x81018f34u,\n0x0178e409u,0x7efd8f9fu,0x7789d90bu,0x5f860eacu,0x7ed90a11u,0x578176a7u,0xfb24082au,0x8305152eu,\n0x02c17309u,0x7f33834cu,0x003b0c5eu,0x8301bab0u,0x65bc1868u,0x655eb187u,0xf8930e54u,0x7706bb41u,\n0x00bda030u,0x81012dd5u,0xb63d0541u,0x9b49275bu,0xeefb5c0eu,0x7313feefu,0x2aae6107u,0x6d5de873u,\n0x003a0f18u,0x810325d0u,0x20012803u,0x850b7e43u,0xb4990c7bu,0x694aaf4bu,0xe7cb0803u,0x7d19b4eau,\n0x004413d3u,0x8301b681u,0x00b95818u,0x810186d0u,0x37946762u,0x657ffd2cu,0xff4d5202u,0x80f54030u,\n0x017aa314u,0x8104fd77u,0x4fad540fu,0xc8b2dd3bu,0x425a0a3eu,0x69bba38fu,0x0ba8061bu,0x7b325dd3u,\n0x41e0185fu,0x67b9d486u,0xff510808u,0x7f0314b1u,0x00c5035bu,0x8102ebbau,0xffc6940cu,0x6cfee4dcu,\n0x0a0d3d06u,0x8309f858u,0x5eb73a09u,0x534e1527u,0xbb913016u,0x85451eefu,0xfc40190eu,0x6503a682u,\n0xe13f1c0bu,0x87120307u,0x46c10426u,0x714e901eu,0x00091057u,0x81030e72u,0x292f2147u,0x6dd43b9du,\n0x9643a009u,0x5f6b4f1fu,0x0043540cu,0x81032f64u,0x8b7e4c09u,0x3b651d5bu,0x00787a0bu,0x81025bb7u,\n0x502e1e3eu,0x6dae46f4u,0x3d5b3514u,0x63765065u,0x00ca5008u,0x81035ee3u,0x01f20f75u,0x7f01f724u,\n0x8bde152du,0x75613340u,0x09036504u,0x8303c843u,0x9a94142eu,0x5f5aef87u,0x1ed70b1eu,0x774307d9u,\n0x9c06105bu,0x5353a713u,0x005c0b1fu,0x8106ea38u,0xe9515e16u,0x2d16734eu,0x0802ab11u,0x80fbee50u,\n0xfbd30e22u,0x7af1d67fu,0xc30f0c74u,0x693b351du,0xfd8e3c12u,0x6903af29u,0x00e79e36u,0x81007371u,\n0x35b34e19u,0x6778dafeu,0x1a11b614u,0x7743b58au,0x0201410bu,0x7efeb5b8u,0xec6e411du,0x6513ad2du,\n0xda895a1bu,0x9123faf7u,0x4dd43b1au,0x5b779323u,0x03420a7au,0x80ff964bu,0x649b2e10u,0x655e5232u,\n0x0ae64111u,0x7b2ec648u,0xba6f060cu,0x86fb0d33u,0x567e1cb4u,0x558a8f10u,0xebca1205u,0x6517136du,\n0x130a370eu,0x76fa6f5fu,0x2010a41eu,0x7341de7eu,0xefca1701u,0x88cd2a11u,0x00935d05u,0x8101a06au,\n0x00e60627u,0x81036b11u,0x00e006d6u,0x8105eac5u,0x1d936516u,0x7731d670u,0x02e1870du,0x7f032d16u,\n0xbe961137u,0x613ed891u,0xec4c1c31u,0x6912bf50u,0x8fdb0b0eu,0x71591ad5u,0xa371072cu,0x6f58e6f5u,\n0x00070531u,0x81035f23u,0x00421a8cu,0x8103d99au,0xb4e40a06u,0x8d19d926u,0x00b78728u,0x810e20a2u,\n0xea063b80u,0x6913fef6u,0x00540341u,0x8101846eu,0xee9c0c20u,0x29128665u,0xb41e2709u,0x6f489756u,\n0xef480e8bu,0x810f1501u,0xb48c4413u,0x494b5304u,0x60464509u,0x7f55cef9u,0x97e7173au,0x675878e6u,\n0x1775081du,0x754b7b07u,0x7078320fu,0x5f6ab433u,0x06ef153eu,0x7f1f56c2u,0x8d75121cu,0x5f56a7ceu,\n0xe6f72883u,0x7b18e732u,0xff4c2716u,0x81029b00u,0x73b2c412u,0x7978cd6au,0xfd7c0721u,0x8100e0fdu,\n0xce162647u,0x672ea360u,0xde6a120fu,0x7921cf14u,0x00e03c21u,0x81032b81u,0x673c470au,0x599a0af8u,\n0x122c08beu,0x7d2ba277u,0xff9e300bu,0x8102c318u,0x3bbe8321u,0x63c4cd5cu,0x001b1a3bu,0x81025bb2u,\n0x00002605u,0x8105b730u,0x02783c07u,0x7efe7d3fu,0xb6562e16u,0x8149292du,0x505a3b0au,0x693dfaceu,\n0x1f971939u,0x7164e13du,0x09110555u,0x7f17592bu,0x06a96006u,0x81019ba9u,0x65d51016u,0x7b65393bu,\n0xcdc80905u,0x7933254cu,0xb67f6808u,0x4349e4a6u,0xa3fc3846u,0x6b43e10eu,0xbd712f06u,0x63422abcu,\n0x21f2562fu,0x6f909ba1u,0x0290e30au,0x7f057c77u,0x01b69513u,0x810177b9u,0xb1134162u,0x6d3bfecdu,\n0x1bec3b0eu,0x7728ff4au,0xf5890a2fu,0x8308e318u,0x0d414f12u,0x850b8f53u,0xfe7b0312u,0x48fa212du,\n0x8f850973u,0x8f29c2f4u,0x098b04a4u,0x7efd3e43u,0x0db32257u,0x7b2dc98cu,0x52883e02u,0x6d388b45u,\n0x61682e19u,0x659e4999u,0x12ad166au,0x7748cb49u,0xaa444607u,0x71431542u,0xff02061du,0x810353ceu,\n0x5a0b1828u,0x59a27ad2u,0x02874f10u,0x830a7852u,0x5d110427u,0x7561012au,0xee3f840au,0x7712aaf1u,\n0x0003e119u,0x810fd45du,0xa530520bu,0x5d5ad291u,0x05160747u,0x7eff6935u,0x000f8ef8u,0x810029c2u,\n0xe13c0a14u,0x8d1e26c2u,0x5f3d3f04u,0x6f56faafu,0x4c8da314u,0x6776667eu,0xfc2a0804u,0x7d01b2f5u,\n0xe7bf2017u,0x591a8ed1u,0x00a3a00eu,0x8101d2bau,0xa39c0d16u,0x415e1abbu,0xff06230cu,0x4701d095u,\n0x030b1d98u,0x7f0cb32fu,0x003e5806u,0x8112e8aeu,0xff841006u,0x81034db8u,0xff7b103eu,0x7f02cc9au,\n0x3dfa2e0cu,0x6d617b57u,0xe9347404u,0x6716f900u,0x02fb7e65u,0x81008fcbu,0x00760ddbu,0x81025ed3u,\n0x00a53512u,0x8110e979u,0x00fd2f05u,0x81017964u,0xa1d31128u,0x475e5ab8u,0x00f6f00fu,0x81017995u,\n0xe9646a15u,0x0b16ccc6u,0x00472731u,0x8101bcbcu,0xdc0d0856u,0x7522f4c0u,0x72900b8cu,0x6758ab71u,\n0x04c125d6u,0x7f2a0495u,0x58606611u,0x558244fau,0x3631030bu,0x753c6114u,0xd2050407u,0x7b29b319u,\n0x79ff0810u,0x9cdac749u,0x00870727u,0x8126eca3u,0x99206a10u,0x614e9a92u,0x0072410au,0x8102793bu,\n0x025e3c09u,0x7f0e39b9u,0xff040930u,0x78fe3d25u,0x57e52ebcu,0x5582e32au,0x00bd4109u,0x8103390du,\n0x6829141au,0x5d920d66u,0x03687a2cu,0x7f1e4999u,0x0052180au,0x810334e2u,0xc3031309u,0x6d3b62ffu,\n0x07dd0f6eu,0x7d3ab53du,0x91891c07u,0x834d1d18u,0x58636228u,0x6757c288u,0xf5f92009u,0x57092b5au,\n0xa9971f0fu,0x67475891u,0x303c2302u,0x81098dccu,0x00ab5c1du,0x811b119fu,0x004f4e3bu,0x8100f485u,\n0x00e37919u,0x8105c544u,0xe2f51605u,0x7b1d4b49u,0x00f27930u,0x8100b182u,0x059b35c1u,0x7d52f2e5u,\n0x8e845329u,0x51727097u,0x1488246fu,0x77d62b17u,0x4cae1026u,0x69530593u,0xff0a8b04u,0x81024e21u,\n0xa9041a4cu,0x6b3fbb18u,0x0a0d24a1u,0x7b52531eu,0xa4867416u,0x674af101u,0x32182618u,0x7344bcceu,\n0xba4e6119u,0x5d46e8cdu,0x701e1208u,0x5f5f1ee6u,0xb2eb2532u,0x5b4700feu,0x007c0e05u,0x8101aedfu,\n0x30759e0cu,0x71491f58u,0x00c83419u,0x81026129u,0xd5882005u,0x632a6c43u,0xfffb1074u,0x8102a4deu,\n0x15493925u,0x75424683u,0xac45c10eu,0x654ea6dcu,0x92c73d37u,0x5b5e808fu,0x87852596u,0x5d56cadeu,\n0xee840b4du,0x6d120b06u,0xff231110u,0x7b01c8f9u,0x416e4816u,0x5f6eccd1u,0xbf504227u,0x6736daf9u,\n0x00ca2009u,0x813e1913u,0x006f0ee9u,0x810119dbu,0xfe84060eu,0x7f01b513u,0x6c82092fu,0x7568ef11u,\n0x562e0429u,0x6f45fec6u,0xb7c31e0fu,0x654b8091u,0xffb70b13u,0x7b0220e7u,0x00745e17u,0x8100a56du,\n0x01e1bb4bu,0x8100b1feu,0x298e0714u,0x73531172u,0xff83083au,0x8101bf01u,0xe3c13e0bu,0x7d19cb0eu,\n0xc4465332u,0x6b32aca0u,0x7bb70d5cu,0x576e28afu,0x80f8071eu,0x5b5b5715u,0xa7340c35u,0x6558b75bu,\n0x34af206au,0x6d521caau,0x013d781du,0x81024307u,0x12d82f1au,0x7b3a7658u,0x08fc133cu,0x851b7493u,\n0x3f721b04u,0x714685ddu,0x0049a841u,0x8100e9c2u,0x9bdc0620u,0x6f3882d7u,0x00477457u,0x8100760du,\n0x01490414u,0x7f2ddf05u,0x543f041cu,0x7342e1e6u,0xa071071bu,0x69561f05u,0x31c4a90cu,0x7b26250cu,\n0x19781102u,0x83230a44u,0x2bed0b0eu,0x7d614f41u,0x2fc10a03u,0x82fd8dcbu,0x006e1407u,0x810a28fdu,\n0xff5a0476u,0x80fe1c31u,0x41365d0eu,0x6b5246b1u,0x4d285d12u,0x67523abdu,0x7e303a0du,0x6552b94du);\n\n// gaussian falloff at center c, radii r and angle a.\nfloat gaussian( in vec2 p, in vec2 c, vec2 r, float a, float anim )\n{\n    p -= c                               + anim*250.0*cos( 0.5*iTime + 10.0*c.yx );\n    float an = float(a)*(6.283185/256.0) + anim*0.01*c.x;\n    float co = cos(an);\n    float si = sin(an);\n    p = mat2x2(co,-si,si,co)*p;\n    p /= r;\n    return exp( -4.0*dot(p,p) );\n}\n\nuint clamp8( uint x ) // clamp x to [0..255], respecting under/overflow direction\n{\n    return ((x&0xffffff00u)==0u) ? x : ((x>>31)-1u)&0xffu;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // image coordinates\n    vec2 p = 256.0 + 256.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // animation\n    float t    = mod( max(0.0,iTime-0.1), 12.0 );\n    int   base = int( max(0.0,500.0-125.0*t) );\n    float anim = smoothstep( 1.0, 0.0, abs(t-8.0) );\n\n    // background color\n    vec3 col = vec3(255.0);\n    \n    // 500 gaussians splats\n    for( int i=base; i<500; i++ )\n    {\n        // read 8 bytes per gaussian\n        uint whag = data[2*i+0];\n        uint xyrb = data[2*i+1];\n        \n        // unpack data\n        uint x = (xyrb>> 0)&511u; // position x : 9 bits\n        uint y = (xyrb>> 9)&511u; // position y : 9 bits\n        uint w = (whag>> 0)&255u; // width      : 8 bits\n        uint h = (whag>> 8)&255u; // height     : 8 bits\n        uint a = (whag>>16)&255u; // angle      : 8 bits\n        uint g = (whag>>24)&255u; // green      : 8 bits\n        uint u = (xyrb>>16)&508u; // red-green  : 7 bits\n        uint v = (xyrb>>23)&508u; // blue-green : 7 bits\n        uint r = clamp8(g+u-256u);\n        uint b = clamp8(g+v-256u);\n\n        // compute gaussian\n        float f = gaussian( p, vec2(x,y), vec2(w,h), float(a), anim );\n        \n        // splat it\n        col = mix( col, vec3(r,g,b), f );\n    }\n\n    // frame\n    if( abs(p.x-256.0)>255.0 ) col = vec3(0.0);\n\n    fragColor = vec4(col/255.0,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSfDD.jpg", "access": "api", "license": "mit", "functions": [[13661, 13715, 13784, 13784, 14053], [14055, 14055, 14138, 14138, 14199], [14201, 14201, 14258, 14283, 15591]], "test": "untested"}
{"id": "clScRG", "name": "Flowing Water 3D", "author": "fenix", "description": "Inspired by \"Screen Space Fluid Rendering for Games\"\n\nhttps://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\n\n*mouse to control camera*\n*space to pause/resume sim*\n(see Image tab for more keyboard controls)", "tags": ["3d", "simulation", "fluid", "particles", "shadows", "dynamics", "lights", "physics", "surface", "deferred"], "likes": 37, "viewed": 509, "published": 3, "date": "1694064977", "time_retrieved": "2024-07-30T17:35:09.324700", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  This shader was inspired by Simon Green's 2010 paper about fluid rendering, titled\n//  \"Screen Space Fluid Rendering for Games\":\n//\n//      https://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\n//\n//  Honestly, it was a head-slapping moment when I read this paper. I had struggled with\n//  rendering 3D fluids before, because I had been trying to render the particles with\n//  ray marching, blending the particles with smooth minimum functions, like this attempt:\n//\n//      Boiling Mercury Hourglass 3D    https://shadertoy.com/view/sdcBWs\n//\n//  But Mr Green's paper points out, it's possible to blur the particles in screen space,\n//  and I've already used that technique in previous 2D shaders, like this shader's\n//  namesake, and one of my more popular shaders,\n//\n//      Flowing Water                   https://shadertoy.com/view/7s3Bz2\n//\n//  The basic idea is, particles simulate in buffer A. Buffer B then computes voronoi\n//  tracking, and buffer C renders the particles into a G buffer, sort of. It does render\n//  depth, but it also renders \"density\" which is just the particles overdrawn with\n//  each other (press D to toggle). Then buffer D blurs both the depth buffer, and the\n//  density, passing thru the unblurred depth as well. The Image tab reconstructs the\n//  normals from the blurred depth buffer, and applies lighting and reflection/refraction.\n//\n//  The refraction is only one-sided...I'm not attempting to reconstruct the back-side\n//  geometry of the water in this shader. It's probably possible, maybe by splitting\n//  the voronoi into four particles for the front side and four for the back. Maybe\n//  I'll try that in the next shader.\n//  \n//  The particle sim isn't that much different from my previous ones. Particles track\n//  the 16 closest neighbors, for collision and viscosity application. If there weren't\n//  constant motion, it probably wouldn't look that great since it wouldn't be very\n//  stable. But, it works well enough here.\n//\n//  I implemented the 8-neighbor screen-space voronoi tracking from my recent shader\n//\n//      Packed Voronoi Tracking        https://shadertoy.com/view/DtsBWM\n//\n//  But, with tuning I was able to get the old four-neighbor search working equally well,\n//  and it is slightly cheaper, for me. Try disabling FOUR_NBS in the common tab to try it.\n//\n//  Probably the two biggest challenges were the blurring process and the reconstruction\n//  of the normals. And the problems are intertwined, because they depend on each other.\n//  I tried lots of different blurring strategies, including ones using the mip map\n//  hardware, but that usually resulted in magnifying small artifacts.  I also tried\n//  implementing the blur using what I hoped was an approximation of the \"bilateral\n//  filter\" from the paper, but it didn't work for me. What I ended up with is a very\n//  simple but expensive Gaussian blur which enabled me to control it per-pixel, giving\n//  me the fewest rendering artifacts.\n//\n//  It appears that the blur pass is the most expensive thing in the shader, and in the\n//  paper they talk about the importance of the blur operation to be separable, which I\n//  think means two passes in different directions. But I tried that (I did one direction\n//  blur in Buffer D, and then the other direction when sampling Buffer D from the Image\n//  tab), and while it was definitely faster, I wasn't able to defeat the horrible\n//  artifacts I got.\n//\n//  There are a lot of keyboard/debug controls. Generally, you can disable various parts\n//  of the rendering (R for refraction, S for specular, and D for density, B for blur). \n//  There are three debug renderer modes (Z for depth, N for normal, P for \"paint\", i.e.\n//  opaque rendering, M for \"mercury\" i.e. reflective), all of which are compatible with\n//  toggling the blur (B). Turning off the blur makes the shader run faster, and the\n//  cheapest overall mode is (Z) depth render with blur disabled, since this also skips\n//  normal reconstruction. Use the mouse and the up/down arrow keys to control the camera,\n//  and press C to resume camera motions after you've clicked.\n//\n//  I also tried adding noise to the normal, since I believe this was recommended in the\n//  paper. Maybe I didn't do it right, but I think I like the shinier water better. Press\n//  O to try it.\n//\n//  * mouse to control camera * \n//  * 8 to disable/enable four-neighbor mode *\n//  * B to disable/enable blur\n//  * C to resume camera motion after mouse click\n//  * D to disable/enable density render\n//  * O to enable/disable blue noise\n//  * P to enable/disable \"paint\" (opaque) mode\n//  * R to disable/enable refraction\n//  * S to disable/enable specular\n//  * M to enable/disable \"mercury\" (reflect) mode\n//  * N to debug render normals\n//  * Z to debug render depth\n//  * space to pause/resume sim *\n//  * up/down to zoom camera *\n//\n//  One detail you might miss...the wood has a bump map, which you might notice in the\n//  underside of the top shelf, or on the side walls when they reflect the background.\n//  It seems to be cheap enough not to impact the shader performance, but it can be turned\n//  off with FANCY_WOOD below. \n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer of just the particles\n//  Buffer D blurs depth and density\n//  Image performs final composite render\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 LIGHT_DIR = normalize(vec3(1));\n\n#define FANCY_WOOD 1\n\n// blue noise from paniq's Hilber R1 Blue Noise \n// https://www.shadertoy.com/view/3tB3z3\n\n// from https://www.shadertoy.com/view/XtGBDW\nuint hilbert_index( uvec2 Position )\n{   \n    const uint LEVEL = 15U;\n    const uint WIDTH = (1U << LEVEL);\n    const uint AREA = WIDTH * WIDTH;\n    uvec2 Regions;\n\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return Index;\n}\n\n// mapping each pixel to a hilbert curve index, then taking a value from the Roberts R1 quasirandom sequence for it\nfloat hilbert_r1_blue_noise(uvec2 p) {\n    #if 1\n    uint x = hilbert_index( p ) % (1u << 17u);\n    #else\n    //p = p ^ (p >> 1);\n    uint x = pack_morton2x16( p ) % (1u << 17u);    \n    //x = x ^ (x >> 1);\n    x = inverse_gray32(x);\n    #endif\n    // based on http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n    const float phi = 2.0/(sqrt(5.0)+1.0);\n\treturn fract(0.5+phi*float(x));\n}\n\n// generate normal from blurred depth buffer\nvec3 reconstructNormal(fxState s, vec2 u, float cbz, mat3 w2c)\n{\n    const vec2 e = vec2(1, 0);\n    float lbz = fxGetGBuffer(u + e.xy).bz; // left blurred z, etc\n    float rbz = fxGetGBuffer(u - e.xy).bz;\n    float ubz = fxGetGBuffer(u + e.yx).bz;\n    float dbz = fxGetGBuffer(u - e.yx).bz;\n\n    // discard the larger of the two deltas in each direction, to reduce edge artifacts\n    float dx1 = cbz - lbz, dx2 = rbz - cbz;\n    float dx = abs(dx1) < abs(dx2) ? dx1 : dx2;\n    float dy1 = cbz - dbz, dy2 = ubz - cbz;\n    float dy = abs(dy1) < abs(dy2) ? dy1 : dy2;\n    \n    vec2 gr = vec2(dx, dy); // gradient\n    float noise = s.noise ? 1e-2 * hilbert_r1_blue_noise(uvec2(u)) : 0.;\n    vec3 sn = normalize(vec3(gr, 3e-2 + noise)); // screen-space normal\n    \n    return sn * w2c; // world space normal\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nbool boxIntersection(vec3 ro, vec3 rd, vec3 rad)\n{\n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\t\n    return tN < tF && tF > 0.;\n}\n\n// simple ray marching loop for rendering the shelves, returns (position, t)\nvec4 march(vec3 p, vec3 rd)\n{\n    float t = 0.;\n    for (int x = 0; x < 256; ++x)\n    {\n        float d = sdScene(p);\n        if (d < .001) return vec4(p, t);\n        p += rd * d;\n        t += d;\n    }\n    return vec4(1e6);\n}\n\n// from iq's Screen space bump mapping: https://www.shadertoy.com/view/ldSGzR\nvec3 doBump(vec3 dpdx, vec3 dpdy, vec3 nor, \n            float dbdx, float dbdy,\n            float scale)\n{\n    vec3  u = cross(dpdy, nor);\n    vec3  v = cross(nor, dpdx);\n    float d = dot(dpdx, u);\n\t\n\tvec3 surfGrad = dbdx * u + dbdy*v;\n    return normalize(abs(d) * nor - sign(d) * scale * surfGrad);\n}\n\n#define CUBE(u) pow(texture(iChannel0, u).rgb, vec3(2.2))\n\n// lighting calculations used by both scene render functions\nvec3 light(vec2 uv, vec3 rd, vec3 n)\n{\n    vec3 col = texture(iChannel3, uv).rgb * .1;\n\n#if FANCY_WOOD\n    vec3 rfl = reflect(rd, n);\n    float fre = 1. - max(dot(n, -rd), 0.);//pow(1. - max(dot(n, rd), 0.), 60.);\n    fre = pow(fre, 5.);\n    vec3 spec = fre * CUBE(rfl) * .2;\n    vec3 diff = textureLod(iChannel0, n, 4.).rgb; // low-mip cube sample\n#else\n    float diff = max(0., dot(n, LIGHT_DIR)) * .6 + .4;\n    float spec = 0.;\n#endif\n\n    return col * diff + spec;\n}\n\n// scene render (without particles), applies bump map to wood\nvec4 renderBump(fxState s, vec3 ro, vec3 rd, vec3 ddx_rd, vec3 ddy_rd)\n{\n    vec4 mr = march(ro, rd); // march result\n    if (mr.w > 1e5)\n        return vec4(CUBE(rd), 1e6);\n    else\n    {\n        vec3 nor = NORM(sdScene, mr.xyz);\n        if (s.normal) return vec4(nor, mr.w);\n        vec2 uv = uvScene(mr.xyz) / iChannelResolution[3].xy;\n\n#if FANCY_WOOD\n        vec3 ddx_pos = ro - ddx_rd * dot(ro - mr.xyz, nor) / dot(ddx_rd, nor);\n        vec3 ddy_pos = ro - ddy_rd * dot(ro - mr.xyz, nor) / dot(ddy_rd, nor);\n        vec3 dposdx = ddx_pos - mr.xyz;\n        vec3 dposdy = ddy_pos - mr.xyz;\n        float l = .1;\n\n        vec3 mate = texture(iChannel3, uv, l).xyz;\n        float signal = dot(mate,vec3(.33));\n        vec2 uvx = uvScene(ddx_pos) / iChannelResolution[3].xy;\n        vec2 uvy = uvScene(ddy_pos) / iChannelResolution[3].xy;\n        float dsignaldx = dot(texture(iChannel3, uvx, l).xyz, vec3(.33)) - signal;\n        float dsignaldy = dot(texture(iChannel3, uvy, l).xyz, vec3(.33)) - signal;\n\n        vec3 n = doBump(dposdx, dposdy, nor, dsignaldx, dsignaldy, .05);\n#else\n        vec3 n = nor;\n#endif // FANCY_WOOD\n\n        vec3 col = light(uv, rd, n);\n        return vec4(col, mr.w);\n    }\n}\n\n// reflected/refracted render, skips bump map (also no particles)\nvec3 render(fxState s, vec3 ro, vec3 rd)\n{\n    vec4 mr = march(ro, rd); // march result\n    if (mr.w > 1e5)\n        return CUBE(rd);\n    else\n    {\n        vec3 n = NORM(sdScene, mr.xyz);\n        if (s.normal) return n;\n        \n        vec2 uv = uvScene(mr.xyz) / iChannelResolution[3].xy;\n        vec3 col = light(uv, rd, n);\n\n        return col;\n    }\n}\n\nconst float IR_AIR = 1.;\nconst float IR_WATER = 1.33;\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    \n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, int(R.x), ro, fwd, lft, up); // camera basis\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up); // ray direction\n\n    // set up differntial rays for bump mapping\n\tvec3 ddx_rd = fxCalcRay(u + vec2(1, 0), R, fwd, lft, up);\n\tvec3 ddy_rd = fxCalcRay(u + vec2(0, 1), R, fwd, lft, up);\n\n    vec4 rr = renderBump(s, ro, rd, ddx_rd, ddy_rd); // render scene with bump map\n    O.rgb = rr.rgb;\n    \n    if (boxIntersection(ro - BBOX_CENTER, rd, BBOX_EXTENTS * .5))\n    {\n        fxGBufferPixel pix = fxGetGBuffer(u); // render water\n        \n        if (pix.t < rr.w) // check depth vs. scene\n        {\n            if (s.depth) { O.rgb = sin(pix.bz * .5 + vec3(0, 11, 33)) * .5 + .5; return; } // debug depth render\n            \n            mat3 w2c = inverse(mat3(-lft, up, -fwd)); // world to camera rotation matrix\n            vec3 n = reconstructNormal(s, u, pix.bz, w2c);\n\n            if (s.normal && s.ref) { O.rgb = n; return; } // debug render normal\n\n            vec3 hit = pix.t * rd + ro; // ray hit water position\n            vec3 rfl = reflect(rd, n); // reflected ray\n\n            if (s.paint) // \"paint\" (opaque) mode\n            {\n                float diff = max(0., dot(n, LIGHT_DIR)) + .4;\n                O.rgb = diff * vec3(.8, .2, .3) * .6 * .4;\n            }\n            else if (s.mercury)\n                O.rgb = render(s, hit, rfl);\n            else\n            {\n                if (s.ref)\n                {\n                    vec3 rfr = refract(rd, n, IR_AIR/IR_WATER); // refracted ray direction\n                    O.rgb = render(s, hit, rfr); // render refrected light\n                }\n\n                float den = s.density ? pix.d : 0.; // density\n                O.rgb *= 1. - smoothstep(.0, 4., den) * vec3(.5, .3, .1); // compute density color\n            }\n\n            float fre = 1. - max(dot(n, rd), 0.); // fresnel\n            fre = pow(fre, 50.);\n            vec3 spec = fre * render(s, hit, rfl); // render specular light\n            if (s.spec && !s.mercury) O.rgb += spec * .3;\n        }\n    }\n\n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = u / R;\n    uv *=  1. - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.; // multiply with sth for intensity\n    vig = pow(vig, .15); // change pow for modifying the extend of the  vignette\n    O *= vig;\n    \n    if (!s.normal) O.rgb = pow(ACESFilm(O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_COLL_SIZE = .25;\nconst float PARTICLE_RENDER_SIZE = .5;\nconst vec3 BBOX_MIN = vec3(-15, -100, -2.5);\nconst vec3 BBOX_MAX = vec3( 15,  100,  2.5);\nconst vec3 BBOX_EXTENTS = BBOX_MAX - BBOX_MIN;\nconst vec3 BBOX_CENTER = (BBOX_MIN + BBOX_MAX) * .5;\n#define R     iResolution.xy\n\n// set to zero for eight-neigbor voronoi search. four-neighbor seems faster enough to me to enable by default\n#define FOUR_NBS 1\n\n// PARTICLES\n\n// enum for the data types making up the structure of each particle\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define VEL 5U\n#define NUM_PARTICLE_DATA_TYPES 6U\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(uint wd, uint id, uint typ)\n{\n    uint idx = id * NUM_PARTICLE_DATA_TYPES + typ;\n    return ivec2(idx % wd, idx / wd);\n}\n\nstruct fxParticle\n{\n    uvec4 nbs[4];\n    vec3 pos;\n    vec3 vel;\n};\n\n// get the particle corresponding to the id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D smp, uint wd, uint id)\n{\n    vec4 data0 = texelFetch(smp, fxLocFromID(wd, id, UL_NEIGHBORS), 0);\n    vec4 data1 = texelFetch(smp, fxLocFromID(wd, id, UR_NEIGHBORS), 0);\n    vec4 data2 = texelFetch(smp, fxLocFromID(wd, id, LL_NEIGHBORS), 0);\n    vec4 data3 = texelFetch(smp, fxLocFromID(wd, id, LR_NEIGHBORS), 0);\n    vec4 data4 = texelFetch(smp, fxLocFromID(wd, id, POS), 0);\n    vec4 data5 = texelFetch(smp, fxLocFromID(wd, id, VEL), 0);\n\n    fxParticle p;\n    p.nbs[0] = uvec4(data0);\n    p.nbs[1] = uvec4(data1);\n    p.nbs[2] = uvec4(data2);\n    p.nbs[3] = uvec4(data3);\n    p.pos = data4.xyz;\n    p.vel = data5.xyz;\n    \n    return p;\n}\n\n// write the correct channel of the particle\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D smp, uint wd, uint id, uint typ)\n{\n    return texelFetch(smp, fxLocFromID(wd, id, typ), 0);\n}\n\n// global variables, initialized via computeMaxParticles\nconst uint IDEAL_MAX_PARTICLES = 0x3ffeU;\nuint g_MaxParticles = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\n// must be called in each buffer before g_MaxParticles is valid\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 r)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(r.x * r.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec2 lastMouse;\n    vec2 camAngle;\n    float camOrbit;\n    float res;\n    bool normal;\n    bool sim;\n    bool spec;\n    bool depth;\n    bool ref;\n    bool density;\n    bool blur;\n    bool eightNbs;\n    bool paint;\n    bool camMotion;\n    bool mercury;\n    bool noise;\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1) // channel 1 is Buffer B\nfxState fxGetStateImpl(sampler2D smp)\n{\n    vec4 data0 = texelFetch(smp, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(smp, ivec2(1, 0), 0);\n    vec4 data2 = texelFetch(smp, ivec2(2, 0), 0);\n    vec4 data3 = texelFetch(smp, ivec2(3, 0), 0);\n    vec4 data4 = texelFetch(smp, ivec2(4, 0), 0);\n    \n    fxState s;\n    s.camMotion = data0.x != 0.;\n    s.lastMouse = data0.yz;\n    s.camAngle = data3.yz;\n    s.res = data1.y;\n    s.normal = data1.z != 0.;\n    s.sim = data2.x != 0.;\n    s.spec = data2.y != 0.;\n    s.depth = data2.z != 0.;\n    s.ref = data2.w != 0.;\n    s.density = data3.x != 0.;\n    s.blur = data0.w != 0.;\n    s.camOrbit = data1.w;\n    s.eightNbs = data3.w != 0.;\n    s.paint = data1.x != 0.;\n    s.mercury = data4.x != 0.;\n    s.noise = data4.y != 0.;\n        \n    return s;\n}\n\nvec4 fxPutState(fxState s, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(s.camMotion ? 1 : 0, s.lastMouse, s.blur ? 1 : 0);\n    else if (ifc == ivec2(1, 0))\n        return vec4(s.paint ? 1. : 0., s.res, s.normal ? 1 : 0, s.camOrbit);\n    else if (ifc == ivec2(2, 0))\n        return vec4(s.sim ? 1 : 0, s.spec ? 1 : 0, s.depth ? 1 : 0, s.ref ? 1 : 0);\n    else if (ifc == ivec2(3, 0))\n        return vec4(s.density ? 1 : 0, s.camAngle, s.eightNbs ? 1 : 0);\n    else\n        return vec4(s.mercury ? 1 : 0, s.noise ? 1 : 0, 0, 0);\n}\n\nbool isStatePixel(ivec2 ifc)\n{\n    return ifc.y == 0 && ifc.x >= 0 && ifc.x < 5;\n}\n\n// CAMERA\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nvoid fxCalcCamera(fxState s, int resolutionWidth, out vec3 ro, out vec3 fwd, out vec3 lft, out vec3 up)\n{\n    vec3 ta = vec3(0);\n    \n    ro = vec3(0, 1, 1) * s.camOrbit;\n    ro.yz *= rotate(s.camAngle.y + .6);\n    ro.xz *= rotate(s.camAngle.x * 2.);\n    ro += ta;\n    \n    fwd = normalize(ta - ro);\n    lft = -normalize(cross(fwd, vec3(0.0,1.0,0.0)));\n    up = normalize(cross(lft, fwd));\n}\n\nmat4 fxCalcCameraMat(vec3 ro, vec3 fwd, vec3 lft, vec3 up)\n{\n    return mat4(vec4(-.5 * lft, 0),\n                vec4(-.5 * up , 0),\n                vec4(fwd      , 0),\n                vec4(ro       , 1));\n}\n\nvec3 fxCalcRay(vec2 u, vec2 r, vec3 fwd, vec3 lft, vec3 up)\n{\n\tvec2 s = (u - .5 * r.xy) / r.y;\n\treturn normalize(fwd - s.x * lft - s.y * up);\n}\n\n// G BUFFER\n\nstruct fxGBufferPixel\n{\n    float d; // density\n    float t; // distance from camera\n    float z; // z depth\n    float bz; // blurred z depth\n};\n\nvec4 fxSaveGBuffer(fxGBufferPixel pix)\n{\n    return vec4(pix.d, pix.t, pix.z, pix.bz);\n}\n\n#define fxGetGBuffer(X) fxGetGBufferImpl(iChannel2, X, R)\nfxGBufferPixel fxGetGBufferImpl(sampler2D smp, vec2 u, vec2 r)\n{\n    vec4 p = texture(smp, u/r);\n    \n    fxGBufferPixel pix;\n    pix.d = p.x;\n    pix.t = p.y;\n    pix.z = p.z;\n    pix.bz = p.w;\n    \n    return pix;\n}\n\n// MISC\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_8     56\n#define KEY_B     66\n#define KEY_C     67\n#define KEY_D     68\n#define KEY_M     77\n#define KEY_N     78\n#define KEY_O     79\n#define KEY_P     80\n#define KEY_R     82\n#define KEY_S     83\n#define KEY_Z     90\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1./float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/spherefunctions/\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.) return vec2(-1, -1);\n\treturn vec2(-b - sqrt( h ), -b + sqrt( h ));\n}\n\n// VORONOI\n\n#if FOUR_NBS\n\n// returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X) // channel 1 is Buffer B\n#define fxGetClosestLight(X) fxGetClosestImpl(iChannel3, X) // channel 3 is buffer D\nuvec4 fxGetClosestImpl(sampler2D smp, ivec2 v)\n{\n    return uvec4(texelFetch(smp, v, 0));\n}\n\n#else // FOUR_NBS\n\nuvec4 pack2(uvec4 a, uvec4 b)\n{\n    return (a & 0xffffU) | ((b & 0xffffU) << 16);\n}\n\nvoid unpack2(uvec4 p, out uvec4 a, out uvec4 b)\n{\n    a = p & 0xffffU;\n    b = (p & 0xffff0000U) >> 16;\n}\n\n// returns the ids of the eight closest particles from the input\n#define fxGetClosest(X, Y, Z) fxGetClosestImpl(iChannel1, X, Y, Z) // channel 1 is Buffer B\n#define fxGetClosestLight(X, Y, Z) fxGetClosestImpl(iChannel3, X, Y, Z) // channel 3 is buffer D\nvoid fxGetClosestImpl(sampler2D smp, ivec2 v, out uvec4 a, out uvec4 b)\n{\n    uvec4 x = floatBitsToUint(texelFetch(smp, v, 0));\n    unpack2(x, a, b);\n}\n\nvec4 fxSaveClosest(uvec4 a, uvec4 b)\n{\n    return uintBitsToFloat(pack2(a, b));\n}\n\n#endif // FOUR_NBS\n\n// SCENE\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nconst float THICK = 1.;\n\nfloat sdScene(vec3 p)\n{\n    float d = sdBox(p, BBOX_EXTENTS * .5 + THICK);\n    float side = abs(mod(p.y, 20.) - 10.) > 5. ? 12.5: -12.5;\n    p.y = mod(p.y, 10.0);\n    const vec3 CUTOUT_A = vec3(BBOX_EXTENTS.x, 10. - THICK, BBOX_EXTENTS.z + 3.) * .5;\n    d = max(d, -sdBox(p - vec3(0, 5., 0), vec3(CUTOUT_A)));\n    const vec3 CUTOUT_B = vec3(5., 20, BBOX_EXTENTS.z + 3.) * .5;\n\n    d = max(d, -sdBox(p - vec3(side, 7.5, 0), vec3(CUTOUT_B)));\n    return d;\n}\n\nfloat sdPhysicsScene(vec3 p)\n{\n    float d = sdBox(p, BBOX_EXTENTS + THICK);\n    float side = abs(mod(p.y, 20.) - 10.) > 5. ? 12.5: -12.5;\n    p.y = mod(p.y, 10.0);\n    const vec3 CUTOUT_A = vec3(BBOX_EXTENTS.x, 10. - THICK, BBOX_EXTENTS.z) * .5;\n    d = max(d, -sdBox(p - vec3(0, 5., 0), vec3(CUTOUT_A)));\n    const vec3 CUTOUT_B = vec3(5., 20, BBOX_EXTENTS.z) * .5;\n\n    d = max(d, -sdBox(p - vec3(side, 7.5, 0), vec3(CUTOUT_B)));\n    return d;\n}\n\nconst vec2 e = vec2(1e-4, 0);\n\n#define NORM(S, p) normalize(vec3(S(p + e.xyy) - S(p - e.xyy), \\\n                                  S(p + e.yxy) - S(p - e.yxy), \\\n                                  S(p + e.yyx) - S(p - e.yyx)))\n\nvec2 uvScene(vec3 p)\n{\n    if (abs(p.z) > BBOX_MAX.z + .9)\n    {\n        if (abs(p.x) > BBOX_MAX.x - THICK) return p.yx * 40.;\n        return p.xy * 40.;\n    }\n    if (abs(p.x) > BBOX_MAX.x - THICK) return p.yz * 40.;\n    return p.xz * 40.;\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nvec3 GRAVITY = vec3(0,-.0005,0); // strength of gravity\nconst float VISCOSITY = .003; // how viscous is the fluid\nconst float VISCOSITY_RADIUS = PARTICLE_COLL_SIZE * 8.; // how far away to apply viscosity\n\nvoid particleStep(inout fxParticle p, fxState s, uint id, vec2 u);\nvec4 neighborUpdate(fxParticle p, fxState s, uint typ, ivec2 ifc, uint id);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n    uint idx = uint(ifc.x + ifc.y * int(R.x));\n    uint id = idx / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    uint typ = idx - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles();\n    if(id >= g_MaxParticles) return;\n\n    fxState s = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (s.sim)\n    {\n        if (typ < POS)\n        {\n            O = neighborUpdate(p, s, typ, ifc, id);\n            return;\n        }\n        else\n        {\n            particleStep(p, s, id, u);\n        }\n    }\n        \n    O = fxSaveParticle(p, typ);\n}\n\n// PARTICLE UPDATE\n\nvoid particleStep(inout fxParticle p, fxState s, uint id, vec2 u)\n{\n    if (iFrame == 0 || s.res < 0.)\n    {\n        // init\n        vec3 h = hash3( uvec3(u, iFrame) ) - .5;\n        vec3 sb = BBOX_EXTENTS;\n        sb.y = 30.;\n        p.pos = h * sb + vec3(0, 0, 0);\n        p.vel = vec3(0);//.08 * w, .10, .0) * .3;\n        \n        return;\n    } \n    \n    if (p.pos.y < -20.)\n    {\n        // reset particles that fall too far back to the top\n        vec3 h = hash3( uvec3(u, iFrame) ) - .5;\n        float w = (id % 2U) == 0U ? -1. : 1.;\n        vec3 sb = BBOX_EXTENTS;\n        sb.y = 10.;\n        p.pos = h * sb + vec3(0, 20., 0.);\n        p.vel = vec3(0);//.08 * w, .10, .0) * .3;\n    }\n\n    p.vel += GRAVITY;\n\n    // collide with neighbors\n    vec3 np = p.pos; // new pos\n    vec3 visc = vec3(0); // viscosity impulse\n    vec3 imp = vec3(0); // collision impulse\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            uint ri = ((uint(i + iFrame) + id) * 7U) % 4U; // randomize the order we process neighbors to avoid directional effects\n            uint nid = p.nbs[ri][j];\n            if (nid == -1U) break;\n            \n            fxParticle nb = fxGetParticle(nid);\n            float d2 = length2(nb.pos - p.pos);\n            \n            if (d2 < 1e-6) continue; // skip particles too close, because we lack a clear direction\n            if (d2 > VISCOSITY_RADIUS * VISCOSITY_RADIUS) break; // no need to search farther once we've reached viscosity radius\n            \n            float d = sqrt(d2);\n            \n            visc += (nb.vel - p.vel) * smoothstep(VISCOSITY_RADIUS, 0., d) * VISCOSITY; // compute viscosity\n\n            // collision\n            if (d < PARTICLE_COLL_SIZE * 2.)\n            {\n                // position correction\n                vec3 dir = normalize(p.pos - nb.pos);\n                np = nb.pos + dir * PARTICLE_COLL_SIZE * 2.;\n\n                vec3 relVel = p.vel - nb.vel;\n                float normVel = min(0., dot(relVel, dir));\n                \n                imp -= dir * normVel; // collisio impulse\n            }\n        }\n    }\n    \n    // update the position and velocity as affected by neighbors\n    p.pos = np;\n    p.vel += visc + imp;\n\n    // damping\n    p.vel *= .9995; // damping\n    const float MAX_SPEED = .9; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n    \n    // integrate\n    p.pos += p.vel;\n\n    // collide with boundary\n    float d = sdPhysicsScene(p.pos);\n    if (d < PARTICLE_COLL_SIZE)\n    {\n        vec3 sn = NORM(sdPhysicsScene, p.pos);\n        p.pos = p.pos + (PARTICLE_COLL_SIZE - d) * sn;\n        p.vel -= min(0., dot(sn, p.vel)) * sn;\n    }\n}\n\n// NEIGHBOR UPDATE\n\nbool iscoincidence(in uvec4 ids, uint cid, uint sid)\n{\n    return sid == cid || any(equal(ids,uvec4(sid)));\n}\n\nvoid insertion_sort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid sortParticle(inout uvec4 ids, inout vec4 ds, uint typ, uint pid, uint sid, in fxParticle p)\n{\n    if(iscoincidence(ids, pid, sid)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(sid, POS).xyz; \n\n    vec3 dx = nbX - p.pos;\n    \n    uint dir = uint(2.*(atan(dx.x, dx.z)+PI)/PI); \n    if(dir != typ) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(ids, ds, sid, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState s, uint typ, ivec2 ifc, uint id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    uvec4 ids = uvec4(-1U);\n    vec4 ds = vec4(1e6);\n\n    if (iFrame > 0 && s.res > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                uint nid = p.nbs[i][j];\n                if (nid == -1U) break;\n                sortParticle(ids, ds, typ, id, nid, p);\n\n                // consider neighbors' closest neighbor\n                for (uint x = 0U; x < 4U; ++x)\n                {\n                    uint nbNid = uint(fxGetParticleData(nid, x));\n                    if (nbNid != -1U)\n                        sortParticle(ids, ds, typ, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int iter = iFrame < 10 ? 8 : 3;\n        for(int k = 0; k < iter; k++)\n        {\n            uint h = hash(uvec4(ifc.x, ifc.y * int(R.x), iFrame, k)).x;\n            uint hi = h % uint(g_MaxParticles);\n            sortParticle(ids, ds, typ, id, hi, p);\n        }\n    }\n    \n    return vec4(ids);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer plus persistent state handling\n// ---------------------------------------------------------------------------------------\n\nvoid updateState(inout fxState s);\nvec4 voronoi(fxState s, vec2 u);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    fxState s = fxGetState();\n    \n    ivec2 ifc = ivec2(u);\n    if(isStatePixel(ifc))\n    {\n        updateState(s);\n        \n        O = fxPutState(s, ifc);\n    }\n    else\n        O = voronoi(s, u);\n}\n\nvoid updateState(inout fxState s)\n{\n    if (iFrame == 0 || // bootstrap\n        abs(s.res) != R.x * R.y) // detect resolution change\n    {\n        s.res = -R.x * R.y;\n        s.camAngle = vec2(0, .7);\n        s.normal = false;\n        s.sim = true;\n        s.spec = true;\n        s.ref = true;\n        s.density = true;\n        s.blur = true;\n        s.eightNbs = true;\n        s.paint = false;\n        s.camMotion = true;\n        s.mercury = false;\n        s.noise = false;\n        s.camOrbit = 20.;\n    }\n    else\n    {\n        // update persistent state\n        s.res = abs(s.res); // positive res means, don't reset\n\n        if (iMouse.z > 0.)\n        {\n            if (iMouse.w < 0.)\n            {\n                vec2 d = s.lastMouse - iMouse.xy / R;\n                s.camAngle.x += .5 * d.x;\n                s.camAngle.y += .2 * d.y;\n            }\n            \n            s.camMotion = false;\n            s.lastMouse = iMouse.xy / R;\n        }\n\n        if (keyClick(KEY_8)) s.eightNbs = !s.eightNbs;\n        if (keyClick(KEY_B)) s.blur = !s.blur;\n        if (keyClick(KEY_C)) s.camMotion = true;\n        if (keyClick(KEY_D)) s.density = !s.density;\n        if (keyClick(KEY_O)) s.noise = !s.noise;\n        if (keyClick(KEY_P)) s.paint = !s.paint;\n        if (keyClick(KEY_R)) s.ref = !s.ref;\n        if (keyClick(KEY_S)) s.spec = !s.spec;\n        if (keyClick(KEY_M)) s.mercury = !s.mercury;\n        if (keyClick(KEY_N)) s.normal = !s.normal;\n        if (keyClick(KEY_Z)) s.depth = !s.depth;\n        if (keyClick(KEY_SPACE)) s.sim = !s.sim;\n        if (keyDown(KEY_UP)) s.camOrbit -= .1;\n        if (keyDown(KEY_DOWN)) s.camOrbit += .1;\n\n        if (s.camMotion)\n        {\n            s.camAngle.x += .005 * s.camAngle.y;\n            s.camAngle.y -= .005 * s.camAngle.x;\n            s.camAngle = mix(s.camAngle, normalize(s.camAngle) * .2, .005);\n        }\n    }\n}\n\nfloat distance2Particle(uint id, vec2 u, mat4 w2c, vec3 ro, vec3 rd)\n{\n    // compute screen space position\n    vec3 wp = fxGetParticleData(id, POS).xyz;\n    vec3 sp = (w2c * vec4(wp,1.0)).xyz;\n    sp.xy /= sp.z;\n    \n    vec2 t = sphIntersect(ro, rd, vec4(wp, PARTICLE_RENDER_SIZE));\n    if (t.x < 0.) return 1e9; // don't consider particles that aren't hit by this ray\n\n    return length2(sp.xy - u) + t.x * .0002;\n}\n\n#if FOUR_NBS\n// four-neighbor voronoi search, enable to compare\n\nvoid insertion_sort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvec4 voronoi(fxState s, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n    int wd = int(R.x);\n\tvec2 p = (2. * u - R.xy) / R.y;\n\n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, wd, ro, fwd, lft, up);\n\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(ro, fwd, lft, up);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    uvec4 new = uvec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        uvec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            uint id = old[j];\n            if (id == -1U) break;\n            if (id >= g_MaxParticles) continue;\n            float dis2 = distance2Particle(id, p, w2c, ro, rd);\n            insertion_sort(new, dis, id, dis2);\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            #if 0\n            uvec4 h = hash(uvec4(ifc.x, ifc.y * 3, iFrame, j));\n            uvec4 nbs = uvec4(fxGetParticleData(id, h.x % 4U));\n            uint nid = nbs[h.y % 4U];\n\n            if (nid >= 0U && nid < g_MaxParticles)\n            {\n                float dis2 = distance2Particle(nid, p, w2c, ro, rd);\n                insertion_sort(new, dis, nid, dis2);\n            }\n            #endif\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint rng = 16u;\n        uint cnt = max(2U, uint(R.y / 200.));\n\n        for(uint i = 0u; i < cnt; ++i)\n        {\n            uvec4 h0 = hash(uvec4(ifc, iFrame, i) * i);\n            uvec4 old = fxGetClosest(ifc + ivec2( h0.xy % rng - rng / 2u));      \n\n            for (int j = 0; j < 1; j++)\n            {\n                uint id = old[j];\n                if (id == -1U) break;\n                if (id >= g_MaxParticles) continue;\n                float dis2 = distance2Particle(id, p, w2c, ro, rd);\n                insertion_sort(new, dis, id, dis2);\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 2;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            uint id = hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x % g_MaxParticles;\n            insertion_sort(new, dis, id, distance2Particle(id, p, w2c, ro, rd));\n        }\n    }\n    \n    return vec4(new);\n}\n\n#else // FOUR_NBS\n// eight-neighbor voronoi search, enabled by default\n\nvoid insertionSort(inout uvec4 i, inout vec4 d, inout uint i_, inout float d_)\n{\t\n    uint ip = i_;\n    float dp = d_;\n    if     (d_ < d[0])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(ip,i.xyz),    d = vec4(dp,d.xyz);\n    else if(d_ < d[1])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.x,ip,i.yz), d = vec4(d.x,dp,d.yz);\n    else if(d_ < d[2])            \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xy,ip,i.z), d = vec4(d.xy,dp,d.z);\n    else if(d_ < d[3])           \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xyz,ip),    d = vec4(d.xyz,dp);\n}\n\nvoid insertionSort2(inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, uint id, vec2 p, mat4 w2c, vec3 ro, vec3 rd)\n{\n    if (any(equal(uvec4(id),na)) || any(equal(uvec4(id),nb))) return; // don't insert the same id twice\n    \n    float d = distance2Particle(id, p, w2c, ro, rd);\n    insertionSort(na, da, id, d);\n    insertionSort(nb, db, id, d);\n}\n\n// consider a new set of four candidate particles to insert into our arrays\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, mat4 w2c, vec3 ro, vec3 rd)\n{\n    for (int j = 0; j < 4; j++)\n        insertionSort2(na, nb, da, db, old[j], p, w2c, ro, rd);\n}\n\n// consider a new set of eignt candidate particles to insert into our arrays\nvoid sortNbs2(uvec4 a, uvec4 b, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, vec2 p, mat4 w2c, vec3 ro, vec3 rd)\n{\n    sortNbs(a, p, na, nb, da, db, w2c, ro, rd);\n    sortNbs(b, p, na, nb, da, db, w2c, ro, rd);\n}\n\nvec4 voronoi(fxState s, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n\tvec2 p = (2. * u - R) / R.y;\n\n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, int(R.x), ro, fwd, lft, up);\n\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(ro, fwd, lft, up);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    uvec4 na = uvec4(-1), nb = uvec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 da = vec4(1e6), db = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        uvec4 oa, ob;\n        fxGetClosest(ifc, oa, ob);      \n        sortNbs2(oa, ob, na, nb, da, db, p, w2c, ro, rd);\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint rng = 16u;\n        uint cnt = uint(R.y / 100.);\n\n        for(uint i = 0u; i < cnt; ++i)\n        {\n            uvec4 h0 = hash(uvec4(ifc, iFrame, i) * i);\n            uvec4 oa, ob;\n            fxGetClosest(ifc + ivec2( h0.xy % rng - rng / 2u), oa, ob);      \n            sortNbs2(oa, ob, na, nb, da, db, p, w2c, ro, rd);     \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            uint id = uint(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % g_MaxParticles;\n            insertionSort2(na, nb, da, db, id, p, w2c, ro, rd);\n        }\n    }\n    \n    if (!s.eightNbs) nb = uvec4(-1);\n    return fxSaveClosest(na, nb);\n}\n#endif // FOUR_NBS\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n// draw one particle\nvoid renderParticle(uint id, vec3 fwd, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    fxParticle p = fxGetParticle(id);\n    vec2 t = sphIntersect(ro, rd, vec4(p.pos, PARTICLE_RENDER_SIZE));\n    vec3 hit = ro + rd * t.x;\n    float z = t.x; // construct z from t\n    pix.d += t.y - t.x;\n        \n    if (z > 0.)\n    {\n        if (z < pix.t)\n        {\n            pix.bz = pix.z = z * dot(fwd, -rd);\n            pix.t = z;\n        }\n    }\n}\n\n// draw a sett of four particles\nvoid renderFourParticles(uvec4 ids, vec3 fwd, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = ids[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        renderParticle(id, fwd, ro, rd, pix);\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(fxGetState(), int(R.x), ro, fwd, lft, up);\n\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up);\n    \n    fxGBufferPixel pix;\n    pix.z = 1e6;\n    pix.t = 1e6;\n    pix.d = 0.;\n\n    // render particles\n#if FOUR_NBS\n    uvec4 clo = fxGetClosest(ivec2(u));\n    renderFourParticles(clo, fwd, ro, rd, pix);\n#else\n    uvec4 oa, ob;\n    fxGetClosest(ivec2(u), oa, ob);      \n    renderFourParticles(oa, fwd, ro, rd, pix);\n    renderFourParticles(ob, fwd, ro, rd, pix);\n#endif\n\n    O = fxSaveGBuffer(pix);\n}\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Density and depth gaussian blur\n// ---------------------------------------------------------------------------------------\n\n// clips the boundaries of particles, making individual particles look smaller\n// this helps balance out the fact that we render them deeply intersecting, so\n// if we don't make them smaller when separated, they would appear to gain volume\nconst float MIN_DEPTH = .8;\n\n// how far apart a nearby particle can be, in z depth, before it can be blured with us\n// too low, and you will see particle boundaries not blurring together\n// too high, and foreground particles will merge too much with background particles\nconst float BLUR_TOLERANCE_REL = .1;\nconst float BLUR_TOLERANCE_ABS = PARTICLE_RENDER_SIZE * .5;\n\n// kernel from Gaussian Blur by mrharicot\n// https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(float x, float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nfloat invnormpdf(float n, float sigma)\n{\n\treturn sqrt(-2. * log(n * sigma / 0.39894) * sigma * sigma);\n}\n\nvec4 blur(vec2 u)\n{\n    fxGBufferPixel pix = fxGetGBuffer(u);\n    if (pix.d < MIN_DEPTH) return vec4(1e6);\n\n    float sigma = .25 * iResolution.y / abs(pix.z); // blur falloff depends on resolution and depth\n\n    const float kMin = .0001; // min kernel value we care about sampling\n    int mSize = int(ceil(invnormpdf(kMin, sigma))); // compute convolution size that reaches kMin\n    int kSize = (mSize - 1) / 2;\n    pix.d = 0.;\n    pix.bz = 0.;\n\n    float Z = 0.;\n\n    for (int i = -kSize; i <= kSize; ++i)\n    {\n        for (int j = -kSize; j <= kSize; ++j)\n        {\n            float k = normpdf(float(i), sigma) * normpdf(float(j), sigma);\n            if (k < kMin) continue; // save the texture fetch when the kernel is small anyway\n            fxGBufferPixel n = fxGetGBuffer(u + vec2(i, j));\n            \n            if (abs(n.z - pix.z) < BLUR_TOLERANCE_ABS ||\n                abs((n.z - pix.z) / pix.z) < BLUR_TOLERANCE_REL) // exclude pixels not near our z depth\n            {\n                pix.d += k * n.d;\n                pix.bz += k * n.z;\n                Z += k;\n            }\n        }\n    }\n\n    pix.bz /= Z;\n    pix.d /= Z;\n    return fxSaveGBuffer(pix);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState s = fxGetState();\n    if (!s.blur)\n    {\n        fxGBufferPixel pix = fxGetGBuffer(u);\n        if (pix.d < MIN_DEPTH)\n            O = vec4(1e6);\n        else\n            O = fxSaveGBuffer(pix);\n    }\n    else\n        O = blur(u);\n}\n\n", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clScRG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[5916, 5962, 6000, 6000, 6611], [6613, 6729, 6767, 6767, 7150], [7152, 7197, 7261, 7261, 8000], [8002, 8051, 8101, 8101, 8337], [8339, 8416, 8445, 8445, 8641], [8643, 8721, 8828, 8828, 9025], [9086, 9147, 9185, 9185, 9617], [9619, 9681, 9753, 9753, 10886], [10888, 10954, 10996, 10996, 11310], [11367, 11451, 11474, 11474, 11634], [11636, 11636, 11672, 11672, 14213]], "test": "untested"}
{"id": "cljfWD", "name": "interpolation͏", "author": "01000001", "description": "bap", "tags": ["thing"], "likes": 1, "viewed": 90, "published": 3, "date": "1694062613", "time_retrieved": "2024-07-30T17:35:10.095639", "image_code": "float scale = 25.;\nint types = 5;\n\nfloat bicubic(float a, float b, float c, float d, float t){\n    t += 1.;\n    float one   = t-1.;\n    float two   = t-2.;\n    float three = t-3.;\n    //return (-(t-1.)*(t-2.)*(t-3.)*a + t*(t-1.)*(t-2.)*d + 3.*t*(t-2.)*(t-3.)*b - 3.*t*(t-1.)*(t-3.)*c)/6.;\n    // https://www.desmos.com/calculator/5d6ph151vi interactive :D\n    return (-one*two*three*a + t*one*two*d + 3.*t*two*three*b - 3.*t*one*three*c)/6.;\n}\n\nvec4 bicubic(vec4 a, vec4 b, vec4 c, vec4 d, float t){\n    return vec4(\n        bicubic(a.x, b.x, c.x, d.x, t),\n        bicubic(a.y, b.y, c.y, d.y, t),\n        bicubic(a.z, b.z, c.z, d.z, t),\n        bicubic(a.w, b.w, c.w, d.w, t)\n    );\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    //scale = scale + sin(iTime*.3)*scale*.5;\n    \n    vec2 uv = U / iResolution.y * scale;\n\n    O = texelFetch(iChannel0, ivec2(uv+.5), 0);\n    \n    vec2 miniUV = uv - floor(uv);\n\n    \n    float x = mod(iTime, float(types));\n    if (x < 1.) return; // Point filter\n    \n    //*\n    if (x < 2.){\n\n        // Worse than bilinear!\n\n        vec4 col11 = texelFetch(iChannel0, ivec2(floor(uv)), 0);\n        vec4 col21 = texelFetch(iChannel0, ivec2(ceil(uv.x), floor(uv.y)), 0);\n        vec4 col12 = texelFetch(iChannel0, ivec2(floor(uv.x), ceil(uv.y)), 0);\n        vec4 col22 = texelFetch(iChannel0, ivec2(ceil(uv)), 0);\n        \n        miniUV.x = miniUV.x < .5?sqrt(miniUV.x*2.)*.5:sqrt(2. -2.*miniUV.x)*-.5+1.;\n        miniUV.y = miniUV.y < .5?sqrt(miniUV.y*2.)*.5:sqrt(2. -2.*miniUV.y)*-.5+1.;\n\n        O = mix(mix(col11, col21, miniUV.x), mix(col12, col22, miniUV.x), miniUV.y);\n        \n        \n        return;\n    }\n    \n\n    \n    if (x < 3.){\n\n        // Bilinear\n        // Basic, disgusting\n        vec4 col11 = texelFetch(iChannel0, ivec2(floor(uv)), 0);\n        vec4 col21 = texelFetch(iChannel0, ivec2(ceil(uv.x), floor(uv.y)), 0);\n        vec4 col12 = texelFetch(iChannel0, ivec2(floor(uv.x), ceil(uv.y)), 0);\n        vec4 col22 = texelFetch(iChannel0, ivec2(ceil(uv)), 0);\n\n        vec2 miniUV = uv - floor(uv);\n\n        O = mix(mix(col11, col21, miniUV.x), mix(col12, col22, miniUV.x), miniUV.y);\n                \n        return;\n    }\n    \n    if (x < 4.){\n        \n        // Basic Quadratic thingy\n        \n        \n        vec4 col11 = texelFetch(iChannel0, ivec2(floor(uv)), 0);\n        vec4 col21 = texelFetch(iChannel0, ivec2(ceil(uv.x), floor(uv.y)), 0);\n        vec4 col12 = texelFetch(iChannel0, ivec2(floor(uv.x), ceil(uv.y)), 0);\n        vec4 col22 = texelFetch(iChannel0, ivec2(ceil(uv)), 0);\n        \n        miniUV.x = miniUV.x < .5?miniUV.x*miniUV.x*2.:4.*miniUV.x -2.*miniUV.x*miniUV.x-1.;\n        miniUV.y = miniUV.y < .5?miniUV.y*miniUV.y*2.:4.*miniUV.y -2.*miniUV.y*miniUV.y-1.;\n\n        O = mix(mix(col11, col21, miniUV.x), mix(col12, col22, miniUV.x), miniUV.y);\n        \n        \n        return;\n        \n        \n        \n        // .... I actually prefer this over bicubic\n        \n        \n    }//*/\n    \n    /*\n    if (x > 1. && x < 4.){\n        \n        float t = (x-1.) * .5 + .5;\n        \n        vec4 col11 = texelFetch(iChannel0, ivec2(floor(uv)), 0);\n        vec4 col21 = texelFetch(iChannel0, ivec2(ceil(uv.x), floor(uv.y)), 0);\n        vec4 col12 = texelFetch(iChannel0, ivec2(floor(uv.x), ceil(uv.y)), 0);\n        vec4 col22 = texelFetch(iChannel0, ivec2(ceil(uv)), 0);\n        \n        miniUV.x = miniUV.x < .5?pow(miniUV.x*2., t)*.5:pow(2. -2.*miniUV.x, t)*-.5+1.;\n        miniUV.y = miniUV.y < .5?pow(miniUV.y*2., t)*.5:pow(2. -2.*miniUV.y, t)*-.5+1.;\n\n        O = mix(mix(col11, col21, miniUV.x), mix(col12, col22, miniUV.x), miniUV.y);\n        \n        \n        return;\n    }//*/\n\n            \n    if (x < 5.){\n\n        // Bicubic\n        vec4 c00 = texelFetch(iChannel0, ivec2(floor(uv)+vec2(-1, -1)), 0);\n        vec4 c01 = texelFetch(iChannel0, ivec2(floor(uv)+vec2(-1,  0)), 0);\n        vec4 c02 = texelFetch(iChannel0, ivec2(floor(uv.x)-1., ceil(uv.y)), 0);\n        vec4 c03 = texelFetch(iChannel0, ivec2(floor(uv.x)-1., ceil(uv.y)+1.), 0);\n        \n        vec4 c10 = texelFetch(iChannel0, ivec2(floor(uv)+vec2(0, -1)), 0);\n        vec4 c11 = texelFetch(iChannel0, ivec2(floor(uv)), 0);\n        vec4 c12 = texelFetch(iChannel0, ivec2(floor(uv.x), ceil(uv.y)), 0);\n        vec4 c13 = texelFetch(iChannel0, ivec2(floor(uv.x), ceil(uv.y)+1.), 0);\n\n        vec4 c20 = texelFetch(iChannel0, ivec2(ceil(uv.x), floor(uv.y)-1.), 0);\n        vec4 c21 = texelFetch(iChannel0, ivec2(ceil(uv.x), floor(uv.y)), 0);\n        vec4 c22 = texelFetch(iChannel0, ivec2(ceil(uv)), 0);\n        vec4 c23 = texelFetch(iChannel0, ivec2(ceil(uv)+vec2(0, 1)), 0);\n\n        vec4 c30 = texelFetch(iChannel0, ivec2(ceil(uv.x) + 1., floor(uv.y)-1.), 0);\n        vec4 c31 = texelFetch(iChannel0, ivec2(ceil(uv.x) + 1., floor(uv.y)), 0);\n        vec4 c32 = texelFetch(iChannel0, ivec2(ceil(uv.x) + 1., ceil(uv.y)), 0);\n        vec4 c33 = texelFetch(iChannel0, ivec2(ceil(uv.x) + 1., ceil(uv.y)+1.), 0);\n        \n        // That's quite a bit more memory access 😅\n        \n        vec4 c0 = bicubic(c00, c01, c02, c03, miniUV.y);\n        vec4 c1 = bicubic(c10, c11, c12, c13, miniUV.y);\n        vec4 c2 = bicubic(c20, c21, c22, c23, miniUV.y);\n        vec4 c3 = bicubic(c30, c31, c32, c33, miniUV.y);\n        \n        O = bicubic(c0, c1, c2, c3, miniUV.x);\n        \n        \n        // Add a slash at the start of the line below to see what the bicubic formula does :)\n        /*\n        uv.x /= 8.;\n        O*= abs(uv.y-(bicubic(0., 1., .1, 1., uv.x-2.)*5.+8.));\n        \n        O*= abs(uv.x - 1.);\n        O*= abs(uv.x - 2.);\n        O*= abs(uv.x - 3.);\n        O*= abs(uv.x - 4.);\n        //*/\n        \n        return;\n    }\n    \n    O *= 0.; // Black if none evaluated\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 94, 94, 443], [445, 445, 499, 499, 684], [686, 686, 723, 770, 5729]], "test": "untested"}
{"id": "DljfWW", "name": "rgb mountain", "author": "schmanu", "description": "Simple shader using a gradient, added RGB pattern from original.", "tags": ["2d", "gradient", "wallpaper"], "likes": 6, "viewed": 162, "published": 3, "date": "1694056809", "time_retrieved": "2024-07-30T17:35:10.867574", "image_code": "float pi = 3.14159;\nfloat r(float x){ return fract(sin(dot(vec2(x), vec2(12.9898, 78.233))) * 412.5453); }\nfloat i(vec2 a, vec2 b, float x) { return ((a.y-b.y)/(a.x-b.x))*(x-b.x)+b.y; }\nfloat c(vec2 p, vec2 o, float r) { return 1.-smoothstep (r, r+.002, length(p-o)-r); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = iTime;\n    float sx = iTime + 5.;\n    float m = .4;\n    vec3 upper = vec3(m*cos(x)+m,m*cos(x+pi/2.)+m,m*cos(x+3.*pi/2.)+m);\n    vec3 lower  = vec3(m*cos(sx)+m,m*cos(sx+pi/2.)+m,m*cos(sx+3.*pi/2.)+m);\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    float f = floor((uv.x)*50.+1.);\n    float o = cos(uv.x*10.)*.1-.05+i(vec2(f,r(f)),vec2(f+1.,r(f+1.)),uv.x*50.+1.)*.06-0.03;\n    float l = 1.-smoothstep(0.,0.002,uv.y-(o));\n    float v = cos(uv.x*9.)*.08-.089+i(vec2(f,r(f+5.8)),vec2(f+1.,r(f+6.8)),uv.x*50.+1.)*.04-0.02;\n    float p = 1.-smoothstep(0.,0.002,uv.y-(v));\n    vec3 col = mix(upper, lower,uv.y*5.);\n    col = mix(vec3(.05), col, c(uv, vec2(0.), .1));\n    col = mix(col, mix(vec3(1.), vec3(.5, .8, .8),-uv.y*10.), l);\n    col = mix(col, vec3(.05), p);\n    col = mix(vec3(.05), col, c(uv, vec2(0.), .14));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 37, 37, 106], [107, 107, 141, 141, 185], [186, 186, 220, 220, 271], [273, 273, 330, 330, 1211]], "test": "untested"}
{"id": "DllfRj", "name": "Kuvina Converter", "author": "RayWorld", "description": "A simple shader to replace a color with one from a reduced palette from this video: \nhttps://youtu.be/gnUYoQ1pwes?t=2501 ", "tags": ["palettereduction"], "likes": 0, "viewed": 88, "published": 3, "date": "1694051227", "time_retrieved": "2024-07-30T17:35:11.638513", "image_code": "const vec3[] colors = vec3[](\n    vec3(170.0/255.0, 34.0/255.0, 68.0/255.0),\n    vec3(255.0/255.0, 51.0/255.0, 68.0/255.0),\n    vec3(255.0/255.0, 170.0/255.0, 153.0/255.0),\n    vec3(255.0/255.0, 153.0/255.0, 0.0/255.0),\n    vec3(255.0/255.0, 204.0/255.0, 0.0/255.0),\n    vec3(221.0/255.0, 153.0/255.0, 0.0/255.0),\n    vec3(255.0/255.0, 238.0/255.0, 0.0/255.0),\n    vec3(255.0/255.0, 255.0/255.0, 221.0/255.0),\n    vec3(136.0/255.0, 170.0/255.0, 0.0/255.0),\n    vec3(187.0/255.0, 238.0/255.0, 0.0/255.0),\n    vec3(0.0/255.0, 153.0/255.0, 68.0/255.0),\n    vec3(51.0/255.0, 221.0/255.0, 51.0/255.0),\n    vec3(187.0/255.0, 255.0/255.0, 187.0/255.0),\n    vec3(0.0/255.0, 238.0/255.0, 170.0/255.0),\n    vec3(0.0/255.0, 153.0/255.0, 170.0/255.0),\n    vec3(17.0/255.0, 238.0/255.0, 238.0/255.0),\n    vec3(187.0/255.0, 255.0/255.0, 255.0/255.0),\n    vec3(68.0/255.0, 187.0/255.0, 255.0/255.0),\n    vec3(17.0/255.0, 17.0/255.0, 153.0/255.0),\n    vec3(68.0/255.0, 102.0/255.0, 255.0/255.0),\n    vec3(187.0/255.0, 204.0/255.0, 255.0/255.0),\n    vec3(204.0/255.0, 51.0/255.0, 255.0/255.0),\n    vec3(221.0/255.0, 187.0/255.0, 255.0/255.0),\n    vec3(119.0/255.0, 0.0/255.0, 136.0/255.0),\n    vec3(255.0/255.0, 102.0/255.0, 238.0/255.0),\n    vec3(255.0/255.0, 170.0/255.0, 221.0/255.0),\n    vec3(255.0/255.0, 85.0/255.0, 170.0/255.0),\n    vec3(0.0/255.0, 0.0/255.0, 0.0/255.0),\n    vec3(102.0/255.0, 102.0/255.0, 102.0/255.0),\n    vec3(170.0/255.0, 170.0/255.0, 170.0/255.0),\n    vec3(221.0/255.0, 221.0/255.0, 221.0/255.0),\n    vec3(255.0/255.0, 255.0/255.0, 255.0/255.0),\n    vec3(244.0/255.0, 212.0/255.0, 164.0/255.0),\n    vec3(221.0/255.0, 170.0/255.0, 119.0/255.0),\n    vec3(170.0/255.0, 102.0/255.0, 68.0/255.0),\n    vec3(119.0/255.0, 51.0/255.0, 34.0/255.0)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(uv.xy, clamp(0.5 - 0.55 * cos(iTime / 5.0), 0.0, 1.0));\n    \n    //pallete reduction\n    int closest = 0;\n    float closestDist = 10.0;\n    float dist = 0.0;\n    for (int i = 0; i < 36; i++) {\n        dist = distance(col, colors[i]);\n        if (dist < closestDist) {\n            closest = i;\n            closestDist = dist;\n        }\n    }\n    col = colors[closest];\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1754, 1754, 1811, 1861, 2388]], "test": "untested"}
{"id": "mlBfDW", "name": "Cartoon Water Render", "author": "Supercooldude", "description": "WASD to move (doesnt look like antrhing becasue there are no markers n stuff\nArrow keys to look around\nf & g to adjust fov", "tags": ["cartoon", "water"], "likes": 4, "viewed": 141, "published": 3, "date": "1694047435", "time_retrieved": "2024-07-30T17:35:12.493228", "image_code": "float epsilon = 0.1;\n\n\n\n\n\nvec2 hash(vec2 p)\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat height(vec2 point)\n{\n    return (noise(point + iTime * vec2(0, 2.0)) + 1.0) * 0.25 + (noise(point + iTime * vec2(2.0, 0)) + 1.0) * 0.25;\n}\n\nvec3 getNormal(vec2 pos)\n{\n    float currentHeight = height(pos);\n    return vec3((height(pos + vec2(epsilon, 0.0)) - currentHeight) * -1.0, epsilon / 10.0, (height(pos + vec2(0.0, epsilon)) - currentHeight) * -1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int stepCount = 64;\n    vec2 uv = fragCoord/iResolution.x;\n    float ar = iResolution.y/iResolution.x;\n    \n    vec3 sunDir = normalize(vec3(sin(iTime * 0.1), 0.2, cos(iTime * 0.1)));\n    \n    vec3 startPos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 rot = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    \n    vec3 pos = startPos;\n    vec3 dir = normalize(vec3(uv.x - 0.5, uv.y - 0.5 * ar, texelFetch(iChannel0, ivec2(0, 0), 0).w));\n\n    \n    vec3 old = dir;\n    dir.y = old.y * cos(rot.y) + old.z * sin(rot.y);\n    dir.z = old.z * cos(rot.y) + old.y * -sin(rot.y);\n    old = dir;\n    dir.x = old.x * cos(rot.x) + old.z * sin(rot.x);\n    dir.z = old.z * cos(rot.x) + old.x * -sin(rot.x);\n\n    float initialMove = startPos.y - 2.0;\n\n    int rendertype = 0;\n    \n    int marchStep = 0;\n    float distStep = 0.02;\n    bool stop = false;\n    pos += dir * initialMove;\n    while (marchStep < stepCount && !stop)\n    {\n        if (pos.y < height(pos.xz))// || (pos.y > 2.0 && dir.y > 0.0))\n        {\n            rendertype = 1;\n            stop = true;\n        }\n        if (pos.y > 25.0 && dir.y > 0.0)\n        {\n            rendertype = 2;\n            stop = true;\n        }\n        pos += dir * distStep;\n        distStep += 0.04;\n        marchStep++;\n    }\n    vec3 endCol;\n    float bg = 1.0;\n    \n    if (rendertype == 1)\n    {\n        bg = 0.0;\n        vec3 col = vec3(0.0, 0.5, 1.0) + vec3(pos.y) * 0.5;\n        float brightness = 0.5 + 0.5 * dot(getNormal(pos.xz), sunDir);\n        endCol = col * brightness;\n    }\n    \n    if (rendertype == 2)\n    {\n\n        if (noise(pos.xz * 0.1 + iTime * vec2(0.1, 0.1)) > 0.0)\n        {\n            bg = 1.0 - sqrt(noise(pos.xz * 0.1 + iTime * vec2(0.1, 0.1)));\n            endCol = vec3(sqrt(noise(pos.xz * 0.1 + iTime * vec2(0.1, 0.1))));\n        }\n    }\n    \n\n       endCol += bg * vec3(0.0, 0.6, 0.99) + vec3(0.0, 0.4, 0.0) * dot(dir, vec3(0.0, 1.0, 0.0));//bg * vec3(0.5 + 0.25 * dot(dir, vec3(0.0, 1.0, 0.0)), 0.75 + 0.25 * dot(dir, vec3(0.0, 1.0, 0.0)), 1.0);\n       endCol.rgb += bg * vec3(1.0, 1.0, -0.6) * (max(dot(dir, sunDir), 0.99) - 0.99) * 50.0;\n\n    fragColor = vec4(endCol, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\n\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_Q = 81;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipos = ivec2(int(fragCoord.x), int(fragCoord.y));\n    if ((ipos.x == 0 || ipos.x == 1) && ipos.y == 0)\n    {\n        vec4 pos = (texelFetch(iChannel0, ivec2(0, 0), 0));\n        vec3 rot = vec3(texelFetch(iChannel0, ivec2(1, 0), 0));\n        \n        float xAxis = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r;\n        xAxis -= texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r;\n        \n        float yAxis = texelFetch(iChannel1, ivec2(KEY_E, 0), 0).r;\n        yAxis -= texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).r;\n        \n        float zAxis = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r;\n        zAxis -= texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r;\n        \n        float hAxis = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r;\n        hAxis -= texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        \n        float vAxis = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n        vAxis -= texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n        \n        float zoomAxis = texelFetch(iChannel1, ivec2(KEY_F, 0), 0).r;\n        zoomAxis -= texelFetch(iChannel1, ivec2(KEY_G, 0), 0).r;\n        \n        pos.x += (cos(rot.x) * xAxis + sin(rot.x) * zAxis) * iTimeDelta * 5.0;\n        pos.y = min(max(pos.y + yAxis * iTimeDelta * 5.0, 2.0), 20.0);\n        pos.z += (cos(rot.x) * zAxis + -sin(rot.x) * xAxis) * iTimeDelta * 5.0;\n        pos.w = min(max(pos.w + iTimeDelta * zoomAxis, 0.1), 10.0);\n\n        rot.x += iTimeDelta * hAxis;\n        rot.y += iTimeDelta * vAxis;\n        \n        \n        \n        rot.y = min(max(rot.y, -1.5707), 1.5707);\n        if (ipos.x == 0)\n        {\n            fragColor = pos;\n        }\n        else\n        {\n            fragColor = vec4(rot, 0.0);\n        }\n    }\n    \n    if (iFrame == 0)\n    {\n\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        if (ipos.x == 0 && ipos.y == 0)\n        {\n            fragColor = vec4(0.0, 3.0, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 160], [162, 162, 183, 183, 662], [664, 664, 690, 690, 808], [810, 810, 836, 836, 1028], [1030, 1030, 1087, 1087, 3241]], "test": "untested"}
{"id": "dtBfWW", "name": "signed distanced shapes", "author": "parweb", "description": "signed distanced shapes", "tags": ["sdshape"], "likes": 1, "viewed": 95, "published": 3, "date": "1694034555", "time_retrieved": "2024-07-30T17:35:13.256188", "image_code": "// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat Capsule(vec3 position, vec3 bottom, vec3 top, float radius) {\n    vec3 size = top - bottom;\n    vec3 dist = position - bottom;\n    \n    float cylinder = dot(size, dist) / dot(size, size);\n    cylinder = clamp(cylinder, 0., 1.);\n    \n    vec3 capsule = bottom + cylinder * size;\n    \n    return length(position - capsule) - radius;\n}\n\nfloat Torus(vec3 position, vec2 radius) {    \n    float base = length(position.xz) - radius.x;\n    return length(vec2(base, position.y))-radius.y;\n}\n\nfloat Box(vec3 position, vec3 size) {    \n    return length(max(abs(position) - size, 0.));\n}\n\nfloat Plane(vec3 position) {    \n    return position.y;\n}\n\nfloat Sphere(vec3 position, vec4 size) {\n    return length(position - size.xyz) - size.w;\n}\n\nfloat GetDist(vec3 position) {\n    float plane = Plane(position-vec3(0, -1, 0));\n    \n    float sphere = Sphere(position-vec3(4, .5, 3), vec4(0, 1, 6, 1));\n    float capsule = Capsule(position, vec3(2, 1, 6), vec3(0, 2, 6), sin(iTime)+1.);\n    float torus = Torus(position-vec3(0, .5, 6), vec2(2, .2));\n    float box = Box(position-vec3(-2, 1, 3), vec3(.2, 1, .2));\n    \n    float scene = plane;\n    \n    scene = min(scene, capsule);\n    scene = min(scene, torus);\n    scene = min(scene, sphere);\n    scene = min(scene, box);\n    \n    return scene;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 3, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1.5, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBfWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[349, 349, 416, 416, 687], [689, 689, 730, 730, 837], [839, 839, 876, 876, 932], [934, 934, 962, 962, 991], [993, 993, 1033, 1033, 1084], [1086, 1086, 1116, 1116, 1636], [1638, 1638, 1672, 1672, 1878], [1880, 1880, 1904, 1904, 2093], [2095, 2095, 2119, 2119, 2424], [2426, 2426, 2483, 2483, 2864]], "test": "untested"}
{"id": "DlBfDW", "name": "AiAi (Super Monkey Ball)", "author": "pikachuchujelly", "description": "Modeling a character using ray marching\nUse the mouse to move the camera.", "tags": ["3d", "raymarching", "ball", "monkey", "gaming"], "likes": 16, "viewed": 220, "published": 3, "date": "1694025036", "time_retrieved": "2024-07-30T17:35:14.199665", "image_code": "#define HUGE 1000000.0\n#define PI 3.14159\n\nvec3 ballPos;\nvec3 lightDir = normalize(vec3(1,2,-2));\n\n// computes the ray direction of a screen pixel\nvec3 perspectiveRay(vec2 pixel)\n{\n    float x = -1.0 + 2.0*(pixel.x / iResolution.x);\n    float y = 1.0;\n    float z = -1.0 + 2.0*(pixel.y / iResolution.y);\n    x *= iResolution.x / iResolution.y;\n    return normalize(vec3(x,y,z));\n}\n\nvec3 rotateYaw(vec3 v, float angle)\n{\n    return vec3(\n        v.x*cos(angle) - v.y*sin(angle),\n        v.y*cos(angle) + v.x*sin(angle),\n        v.z);\n}\n\nvec3 rotatePitch(vec3 v, float angle)\n{\n    return vec3(\n        v.x,\n        v.y*cos(angle) - v.z*sin(angle),\n        v.z*cos(angle) + v.y*sin(angle));\n}\n\nvec3 rotatePitchAbout(vec3 v, vec3 about, float angle)\n{\n    return rotatePitch(v - about, angle) + about;\n}\n\nvec3 rotateYawAbout(vec3 v, vec3 about, float angle)\n{\n    return rotateYaw(v - about, angle) + about;\n}\n\nfloat calcLight(vec3 normal, vec3 rd, float shininess)\n{\n    float ambient  = 0.3;\n    float diffuse  = max(dot(-lightDir,normal), 0.0);\n    float specular = max(dot(-lightDir,reflect(rd, normal)), 0.0);\n    specular *= specular*specular*specular*specular*specular*specular*specular*specular;\n    return ambient + diffuse + specular * shininess;\n}\n\nfloat raycastFloor(vec3 ro, vec3 rd, out vec2 hit)\n{\n    if (rd.z >= 0.0)\n        return HUGE;\n    float t = -ro.z / rd.z;\n    if (t < 0.0)\n        return HUGE;\n    hit = vec2(ro.x+rd.x*t, ro.y+rd.y*t);\n    return t;\n}\n\nfloat raycastSphere(vec3 ro, vec3 rd, vec3 center, float radius, out vec3 normal)\n{\n    vec3 sc = center;  // sphere center\n    float sr = radius;  // sphere radius\n\n    // Imagine a plane that is perpendicular to the ray and intersects the sphere's center.\n    // ts is the distance along the ray to that plane.\n    float ts = dot(sc-ro, rd);\n    if (ts < 0.0)\n        return HUGE;\n    // distance squared between point at ts and the sphere center\n    float r2 = (dot(sc-ro,sc-ro) - ts*ts);\n    if (r2 > sr*sr)\n        return HUGE;\n    float t = ts - sqrt(sr*sr - r2);  // distance along ray to where it intersects the sphere\n    vec3 hit = ro + rd * t;\n    normal = normalize(hit-sc);\n    return t;\n}\n\n// like raycastSphere, but intersects with the far surface of the sphere\nfloat raycastSphereInner(vec3 ro, vec3 rd, vec3 center, float radius, out vec3 normal)\n{\n    vec3 sc = center;  // sphere center\n    float sr = radius;  // sphere radius\n\n    // Imagine a plane that is perpendicular to the ray and intersects the sphere's center.\n    // ts is the distance along the ray to that plane.\n    float ts = dot(sc-ro, rd);\n    if (ts < 0.0)\n        return HUGE;\n    // distance squared between point at ts and the sphere center\n    float r2 = (dot(sc-ro,sc-ro) - ts*ts);\n    if (r2 > sr*sr)\n        return HUGE;\n    float t = ts + sqrt(sr*sr - r2);  // distance along ray to where it intersects the sphere\n    vec3 hit = ro + rd * t;\n    normal = normalize(sc-hit);\n    return t;\n}\n\n// Returns true or false to select the pattern for the floor position\nbool checker(vec2 floorPos)\n{\n    return mod(floor(floorPos.x) + floor(floorPos.y), 2.0) < 1.0;\n}\n\nfloat sphereSdf(vec3 pos, vec3 sphereCenter, float radius)\n{\n    return distance(pos, sphereCenter) - radius;\n}\n\n// Credit to Inigo Quilez for the SDF functions (https://iquilezles.org/articles/distfunctions/)\n\n// slow...\nfloat ellipsoidSdf(vec3 pos, vec3 center, vec3 radius)\n{\n    vec3 p = pos - center;\n    float k0 = length(p/radius);\n    float k1 = length(p/(radius*radius));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat cylinderSdf(vec3 pos, vec3 center, float height, float radius)\n{\n    vec3 p = pos - center;\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(radius,height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat roundConeSdf(vec3 pos, vec3 center, float r1, float r2, float h)\n{\n    vec3 p = pos - center;\n    // sampling independent computations (only depend on shape)\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n\n    // sampling dependant computations\n    vec2 q = vec2( length(p.xy), p.z );\n    float k = dot(q,vec2(-b,a));\n    if( k<0.0 ) return length(q) - r1;\n    if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat capsuleSdf(vec3 pos, vec3 a, vec3 b, float r)\n{\n    vec3 p = pos;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n/*\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n*/\n\n// The built-in 2-argument atan function is incredibly slow (at least on my Intel HD 3000).\n// The single argument version is much faster.\nfloat atan_fast(float a, float b)\n{\n    float result = atan(a / b);\n    if (b < 0.0)\n        result += PI;\n    return result;\n}\n\n// samples a 2D x,y position and returns a value between 0 and 1\nfloat spiral(vec2 pos)\n{\n\tfloat radius = length(pos);\n\tfloat angle = /*atan*/atan_fast(pos.y, pos.x) + PI*0.75;\n    float x = radius * 4.0 - angle;\n    // make it like a wave with sharp peaks\n    x = fract(x / (2.0*PI));\n    return 1.0 + 4.0 * x * (x - 1.0);\n}\n\nfloat animLimbAngle(void)\n{\n    return sin(iTime * 3.0 * PI);\n}\n\nfloat animEars(void)\n{\n    float t = fract(iTime / 3.0) * 3.0;\n    t *= 50.0;\n    if (t >= 4.0 * PI)\n        t = 0.0;\n    return sin(t);\n}\n\nfloat animBlink(void)\n{\n    const float blinkSpeed = 0.1;\n    const float frequency = 3.5;\n    float t = fract(iTime / frequency) * frequency;\n\n    return 2.0 * max((blinkSpeed-abs(t-blinkSpeed))/blinkSpeed, 0.0);\n}\n/*\nvec3 mirrored(vec3 v)\n{\n    return vec3(abs(v.x),v.y,v.z);\n}\n*/\n/*\nfloat cylinderSdf(vec3 pos, vec3 center, float height, float radius)\n{\n    vec3 p = pos - center;\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(radius,height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n*/\n\nfloat xzdiscSdf(vec3 pos, vec3 center, float radius, float s)\n{\n    radius -= s;\n    vec3 p = pos - center;\n    //float height = 0.5;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(radius,0.0);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - s;\n}\n\nfloat globalSdf(vec3 pos, out vec3 color)\n{\n    pos.y -= ballPos.y;\n    pos.z -= 2.0;\n\n    vec3 bodyColor  = vec3(0.3, 0.2, 0.1);\n    vec3 skinColor  = vec3(0.8, 0.7, 0.6);\n    vec3 shirtColor = vec3(0.8, 0.4, 0.2);\n    vec3 eyeColor   = vec3(0.1, 0.1, 0.1);\n    vec3 white      = vec3(1.0, 1.0, 1.0);\n\n    color = bodyColor;\n\n    vec3 ear      = vec3(5.0,  0.0, 14.0);\n    vec3 shoulder = vec3(1.5,  0.0, 10.0);\n    vec3 elbow    = vec3(3.5,  0.0,  8.0);\n    vec3 hand     = vec3(4.5, -1.0,  6.0);\n    vec3 hip      = vec3(2.0,  0.0,  4.0);\n    vec3 knee     = vec3(2.1, -0.5,  2.0);\n    vec3 ankle    = vec3(2.2,  0.0,  0.0);\n    vec3 toes     = vec3(2.2, -2.0, -0.5);\n\n    // Animate limbs\n    float angle = animLimbAngle();\n    pos.x += angle * 0.25;  // make body shake a little bit\n    if (pos.x < 0.0)\n        angle = -angle;  // cheap trick to make the two sides animate opposite from each other\n    elbow = rotatePitchAbout(elbow, shoulder, angle);\n    hand = rotatePitchAbout(hand, shoulder, angle);\n    knee = rotatePitchAbout(knee, hip, -angle);\n    ankle = rotatePitchAbout(ankle, hip, -angle);\n    toes = rotatePitchAbout(toes, hip, -angle);\n    // Animate ears\n    ear = rotateYawAbout(ear, vec3(2,0,14), animEars() * 0.15);\n    // Animate blinking\n    float blink = animBlink();\n\n    vec3 posMirrored = vec3(abs(pos.x), pos.y, pos.z);\n\n    float d = HUGE;\n\n    // head\n    float dHead = cylinderSdf(pos, vec3(0, 0, 15), 1.0, 0.8) - 2.0;\n    dHead = opSmoothUnion(dHead, ellipsoidSdf(pos, vec3(0, -1, 12.5), vec3(2.5, 2.0, 1.0)), 2.0);\n    // hair tuft\n    float dTuft = opSmoothUnion(\n        sphereSdf(pos, vec3(0, -1.5, 18.2), 0.5),\n        capsuleSdf(pos, vec3(0, 0, 18.5), vec3(0, 1, 19), 0.0),\n        2.5);\n    dHead = min(dHead, dTuft);\n    //dHead = HUGE;\n    d = min(d, dHead);\n    // ears\n    float dEar = xzdiscSdf(posMirrored, ear, 2.5, 0.5);\n    if (dEar < 0.1 && posMirrored.y < ear.y)\n    {\n        // Cut out the swirl in the iear\n        // Doing this breaks the SDF a bit, but it approximates the look very well.\n        dEar += 0.5 * spiral(ear.xz - posMirrored.xz);\n    }\n    //dEar = HUGE;\n    d = min(d, dEar);\n    // body\n    float dBody = roundConeSdf(pos, vec3(0,0,6.5), 3.2, 2.2, 3.0);\n    //dBody = HUGE;\n    d = min(d, dBody);\n    // arms\n    float dArm = min(\n        capsuleSdf(posMirrored, shoulder, elbow, 0.5),\n        capsuleSdf(posMirrored, elbow, hand, 0.5));\n    //dArm = HUGE;\n    d = min(d, dArm);\n    // legs\n    float dLeg = min(\n        capsuleSdf(posMirrored, hip, knee, 0.6),\n        capsuleSdf(posMirrored, knee, ankle, 0.6));\n    //dLeg = HUGE;\n    d = min(d, dLeg);\n    // hands\n    float dHand = sphereSdf(posMirrored, hand, 1.0);\n    //dHand = HUGE;\n    d = min(d, dHand);\n    // feet\n    float dFoot = sphereSdf(posMirrored, ankle, 1.0);\n    dFoot = opSmoothUnion(dFoot, capsuleSdf(posMirrored, toes - vec3(0.5,0,0), toes + vec3(0.5,0,0), 0.5), 2.0);\n    //dFoot = HUGE;\n    d = min(d, dFoot);\n\n    // colors\n    if (dHead <= d && pos.y < -1.0)\n    {\n        if (pos.y < -1.0)\n        {\n            vec3 eye = vec3(1.2 * sign(pos.x), -2.0, 14.7);\n            vec3 dist = pos - eye;\n            dist.z *= 0.6;\n            if (pos.z <= eye.z + 1.0 - blink\n             && dist.x*dist.x + dist.z*dist.z < 0.25 && abs(dist.z)*2.0 > -dist.x)\n                color = eyeColor;\n            // mouth\n            else if (pos.z < 13.3 && abs(pos.x*pos.x*pos.x*pos.x*0.5*0.5*0.5*0.5 - pos.x*pos.x*0.5*0.5 - pos.z + 13.0) < 0.1)\n                color = vec3(0.2, 0.2, 0.2);\n            else if (pos.z < 15.0 || distance(pos, eye) < 2.2)\n                color = skinColor;\n        }\n    }\n    if (dEar <= d)\n    {\n        if (pos.y < ear.y + 0.1)\n            color = skinColor;\n    }\n    if (dBody <= d)\n    {\n        if (pos.z > 6.5)\n        {\n            color = shirtColor;\n            // letter A\n            vec2 letter = posMirrored.xz;\n            letter.y = (letter.y - 8.0) / 2.0;\n            if (pos.y < 0.0\n             && letter.y >= 0.0 && letter.y <= 1.0\n             && letter.x < 1.2 - letter.y)\n            {\n                if ((letter.x > 0.6 - letter.y)\n                 || (letter.y >= 0.2 && letter.y <= 0.4))\n                color = white;\n            }\n        }\n        // random trick I found by accident to color the butt\n        else if (pos.y > 0.0 && dEar + 0.3 < dHead)\n            color = skinColor;\n    }\n    if (dArm <= d)\n    {\n        if (distance(posMirrored, shoulder) < 2.5)\n            color = shirtColor;\n    }\n    if (dHand <= d || dFoot <= d)\n        color = skinColor;\n    return d;\n}\n\nvec3 calcNormal(vec3 pos, float d)\n{\n    float epsilon = 0.001;\n    vec3 dummy;\n    vec3 v = vec3(\n        globalSdf(pos - vec3(epsilon, 0.0, 0.0), dummy),\n        globalSdf(pos - vec3(0.0, epsilon, 0.0), dummy),\n        globalSdf(pos - vec3(0.0, 0.0, epsilon), dummy));\n    return normalize(d - v);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // ball motion\n    ballPos = vec3(0.0, -40.0*iTime, 12.0);\n    float ballRadius = 40.0/PI;\n\n    // camera motion\n    float yaw = -iTime * 0.25;\n    float pitch = -0.6;\n    if (iMouse.z > 0.0)\n    {\n        yaw = 3.0 * (iMouse.x - abs(iMouse.z)) / iResolution.x;\n        pitch = 3.0 * (iMouse.y - abs(iMouse.w)) / iResolution.y;\n        pitch = clamp(pitch, -3.14159/2.0, 0.0);\n    }\n\n    // ray origin\n    vec3 ro = vec3(0,-20,0);\n    ro = rotatePitch(ro, pitch);\n    ro = rotateYaw(ro, yaw);\n    ro.y += ballPos.y;\n    ro.z += ballPos.z;\n    // ray direction\n    vec3 rd = perspectiveRay(fragCoord);\n    rd = rotatePitch(rd, pitch);\n    rd = rotateYaw(rd, yaw);\n    rd = normalize(rd);\n\n    vec3 normal;\n\n    vec3 sky = mix(vec3(1,1,1),rd.z > 0.0 ? vec3(0,0,1) /*sky*/ : vec3(0,0.5,0) /*land*/,abs(rd.z));\n    vec3 color = sky;\n    float tBall;\n\n    // draw floor\n    vec2 floorPos;\n    float tFloor;\n    if ((tFloor = raycastFloor(ro, rd, floorPos)) < HUGE && abs(floorPos.x) < 60.0)\n    {\n        vec2 uv = fract(floorPos / 10.0);\n        color = checker(floorPos / 10.0) ? vec3(0.2, 0.4, 0.2) : vec3(0.3, 0.6, 0.3);\n        color *= 0.6 + texture(iChannel0, uv).r * 0.4;\n\n        float light;\n        if (raycastSphere(vec3(floorPos, 0.0), -lightDir, ballPos, ballRadius, normal) < HUGE)\n            light = 0.5;  // ball shadow\n        else\n            light = calcLight(vec3(0, 0, 1), rd, 0.3);\n\n        color *= light;\n\n        // fade out with sky to avoid aliasing artifacts\n        float fadeStart = 200.0;\n        float fadeEnd = 400.0;\n        color = mix(color, sky, clamp((tFloor-fadeStart)/(fadeEnd-fadeStart),0.0,1.0));\n\n    }\n    // draw ball inner surface\n    if ((tBall = raycastSphereInner(ro, rd, ballPos, ballRadius-0.3, normal)) < HUGE)\n    {\n        float light = calcLight(normal, rd, 0.8);\n        normal = rotatePitch(normal, ballPos.y/ballRadius);\n        vec3 ballColor = normal.z > 0.0 ? vec3(1.0,0.2,0.2) : vec3(0.8);\n        color = mix(color, ballColor * light, 0.5);\n    }\n\n    // Ray-march the monkey. Since the monkey is always inside the ball, we only need to do this if the ray actually touches the ball.\n    if (tBall < HUGE)\n    {\n        float t = 0.0;\n        for (int i = 0; i < 30; i++)\n        {\n            vec3 pos = ro + rd * t;\n            vec3 objColor;\n            float d = globalSdf(pos, objColor);\n            if (d < 0.1)\n            {\n                if (tFloor < t)\n                    break;\n                color = objColor;\n                vec3 normal = calcNormal(pos, d);\n                color *= calcLight(normal, rd, 0.5);\n                break;\n            }\n            t += d;\n            if (t > 30.0)\n                break;\n        }\n    }\n\n    // draw ball outer surface\n    if (raycastSphere(ro, rd, ballPos, ballRadius, normal) < HUGE)\n    {\n        float light = calcLight(normal, rd, 0.8);\n        normal = rotatePitch(normal, ballPos.y/ballRadius);\n        vec3 ballColor = normal.z < 0.0 ? vec3(1.0,0.2,0.2) : vec3(0.8);\n        color = mix(color, ballColor * light, 0.5);\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 147, 180, 180, 380], [382, 382, 419, 419, 534], [536, 536, 575, 575, 690], [692, 692, 748, 748, 800], [802, 802, 856, 856, 906], [908, 908, 964, 964, 1255], [1257, 1257, 1309, 1309, 1475], [1477, 1477, 1560, 1560, 2179], [2181, 2254, 2342, 2342, 2961], [2963, 3033, 3062, 3062, 3130], [3132, 3132, 3192, 3192, 3243], [3343, 3354, 3410, 3410, 3547], [3549, 3549, 3619, 3619, 3767], [3769, 3769, 3841, 3841, 4227], [4229, 4229, 4282, 4282, 4427], [4429, 4429, 4479, 4479, 4578], [4901, 5040, 5075, 5075, 5167], [5169, 5234, 5258, 5258, 5494], [5496, 5496, 5523, 5523, 5559], [5561, 5561, 5583, 5583, 5699], [5701, 5701, 5724, 5724, 5916], [6210, 6210, 6273, 6273, 6465], [6467, 6467, 6510, 6510, 11049], [11051, 11051, 11087, 11087, 11352], [11354, 11354, 11409, 11428, 14504]], "test": "untested"}
{"id": "DtBfWR", "name": "Year of Truchets #053", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\ninspired by : https://twitter.com/BlockRoni/status/1688260517767315457\n", "tags": ["truchet", "multiscale", "quadtree", "recreation"], "likes": 21, "viewed": 201, "published": 3, "date": "1694024110", "time_retrieved": "2024-07-30T17:35:14.970604", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #053\n    09/06/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\n// @Shane 2/2 hash.\nvec2 hash22(vec2 p) { float n = sin(dot(p,vec2(57,27)));return fract(vec2(272144,32768)*n);}\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq hsv2rgb palettes & box\nvec3 hsv(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n    return c.z * mix( vec3(1),rgb,c.y);\n}\nfloat box( vec2 p, vec2 b){ vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec3 C = vec3(.095);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    uv +=T*vec2(.08,.05);\n    uv*= R.x<1300.? 2.25 : 3.5;\n    \n    vec2 vuv = uv;\n    \n    // threshold values\n    const vec2 rndX[4]=vec2[4]( vec2(.5, .45), vec2(.5, .25), vec2(.5, .75), vec2(.5, 1));\n\n    // distance field values.\n    vec4 d=vec4(1e5), s=vec4(1e5), b=vec4(1e5);\n    // hash values\n    vec4 hd=vec4(1e5), hs=vec4(1e5), hb=vec4(1e5);\n    float level=1.;\n         \n    // Main loop and neighbor checking from @Shane's shader.\n    // https://www.shadertoy.com/view/4t3BW4\n        \n    for(int k=0; k<4; k++){\n        vec2 id = floor(vuv*level);\n        float frnd = hash22(id).x;\n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n            \n                // neighboring cell ID.\n                vec2 neighbors = vec2(i,j);\n                vec2 home = id+neighbors;\n                vec2 rnd = hash22(home);\n                \n                // neighboring cell hash values.\n                vec2 rnd2 = hash22(floor(home/2.));\n                vec2 rnd4 = hash22(floor(home/4.));\n                vec2 rnd8 = hash22(floor(home/8.));\n\n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rnd2.y<rndX[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rnd2.y<rndX[1].y || rnd4.y<rndX[0].y)) continue;\n                // If any of the three previous larger tiles have been rendered, continue.\n                if(k==3 && (rnd2.y<rndX[2].y || rnd4.y<rndX[1].y  || rnd8.y<rndX[0].y )) continue;\n\n                // threshold\n                if(rnd.y<rndX[k].y) {\n     \n                    vec2 p = vuv -(id+.5+neighbors)/level;\n                    if(rnd.x<rndX[k].x) p.x = -p.x;\n  \n                    float bx = (.43-(level*.015))/level;\n                    float square = box(p,vec2(bx))-(.075/level);\n\n                    float tk = k<3?.1/level:.075/level;\n                    float hf = .50/level;\n                    float qf = .25/level;\n                    float mf = .05/level;\n                    \n                    vec2 pv = length(p-vec2(hf,-hf))<length(p+vec2(hf,-hf))? p-vec2(hf,-hf):p+vec2(hf,-hf);\n   \n                    float cd = abs(length(pv)-hf)-tk;\n                    if(rnd.x>.8) cd = min(length(p.x)-tk,length(p.y)-tk);\n                    \n                    float bd = length(abs(p)-hf)-qf;\n                    \n                    float fk = float(k);\n                    float trnd = fract(fk+rnd.x*43.72);\n                    \n                    if(trnd>.7) cd=abs(cd)-mf;\n                    if(trnd<.15) cd=abs(abs(cd)-mf)-(.025/level);\n                    \n                    cd = max(square,cd);\n                    bd = max(square,bd);\n                    \n                    s[k] = min(s[k], square);\n                    d[k] = min(d[k], cd);\n                    b[k] = min(b[k], bd);\n                    \n                    hd[k] = fract((trnd*53.1)+rnd.x+frnd);\n                    hs[k] = fract((rnd2.y+trnd+rnd.x+frnd)*47.3);\n                    hb[k] = fract(rnd2.x*19.7+rnd.x+frnd);\n                }\n            }\n        }    \n        \n        level*=2.;\n    }\n    \n    float px = fwidth(vuv.x);\n    float ft = .4+T*.1;\n    \n    for(int k=0; k<4; k++){\n        C = mix(C,C*.5,smoothstep(.01+px,-px,s[k]-.0005));\n        \n        vec3 ca = hsv(vec3((ft+hs[k])*.15,1.,.5));\n        vec3 cb = hsv(vec3((ft+hd[k])*.35,1.,.6));\n        vec3 cc = hsv(vec3((ft+hb[k])*.25,1.,.3));\n\n        C = mix(C,ca,smoothstep(px,-px,s[k]));\n        if(k<3) C = mix(C,cc,smoothstep(px,-px,b[k]));\n        C = mix(C,cb,smoothstep(px,-px,d[k]));\n        \n        C = mix(C,vec3(.05),smoothstep(px,-px,abs(s[k])-.0025));\n    }\n\n    // Output to screen\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBfWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[423, 443, 464, 464, 535], [536, 536, 556, 556, 601], [603, 632, 650, 650, 760], [761, 761, 788, 788, 857], [859, 859, 900, 900, 4768]], "test": "untested"}
{"id": "ct2BW1", "name": "jsort͏", "author": "01000001", "description": "jump sort. check far, then closer, then closer, until done", "tags": ["thing"], "likes": 1, "viewed": 43, "published": 3, "date": "1694003355", "time_retrieved": "2024-07-30T17:35:15.818338", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n\n    O = vec4(smoothstep(1./r.y, 0., abs(texture(iChannel0, vec2(uv.x, 0)).x-uv.y)));\n    \n    // Smoothstep is an intentional design choice to give randomized brightness to particles\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst int p = 5;\nvec3 nhash( uvec3 x ){\n    vec3 t = vec3(0);\n    for(int i = p; i-->0;){\n        t += hash(x + uvec3(i));\n    }\n    t /= float(p);\n    return t;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y < 1.){\n        if (iFrame < 5){\n            O = vec4(0);\n            O.x = hash(uvec3(U.x, iDate.w, iDate.z)).x;\n        } else {\n            O = texture(iChannel0, U/iResolution.xy);\n         \n            \n            // Assuming we have a GPU, this is great.\n            // Sort here\n\n            int c = int(iResolution.x)>>int(max(1., float(iFrame-6)/10.));\n\n            bool d = (int(U.x) + iFrame*c)%(2*c) >= c;\n\n            float v = texelFetch(iChannel0, ivec2(int(U.x) + (d?c:-c), 0), 0).x;\n\n            if (v == 0.) return;\n\n            O.x = (v < O.x && d) || (v > O.x && !d)?v:O.x;\n\n        }\n    } else {\n        O = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2BW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 281]], "test": "untested"}
{"id": "dlBfD1", "name": "Blood Dissolving Effect", "author": "djvperrucho", "description": "Experience the mesmerizing 'Blood Dissolving Effect' shader. Watch as crimson hues dissolve into captivating patterns. This dynamic visual display is a stunning mix of artistry and illusion.", "tags": ["abstract", "blood", "halloween", "dissolving"], "likes": 5, "viewed": 245, "published": 3, "date": "1693998753", "time_retrieved": "2024-07-30T17:35:16.580300", "image_code": "#define TAU 6.28318530718\n\n#define TILING_FACTOR 1.0\n#define MAX_ITER 8\n\n\nfloat waterHighlight(vec2 p, float time, float foaminess)\n{\n    vec2 i = vec2(p);\n\tfloat c = 0.05;\n    float foaminess_factor = mix(1.1, 6.0, foaminess);\n\tfloat inten = .005 * foaminess_factor;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (0.9 - (5.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 0.9/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));\n\t}\n\tc = 0.2 + c / (inten * float(MAX_ITER));\n\tc = 1.17-pow(c, 1.7);\n    c = pow(abs(c), 15.0);\n\treturn c / sqrt(foaminess_factor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * 0.02+23.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_square = vec2(uv.x * iResolution.x / iResolution.y, uv.y);\n    float dist_center = pow(1.0*length(uv - 0.5), 0.5);\n    \n    float foaminess = smoothstep(0.9, 8.0, dist_center);\n    float clearness = 0.9 + 0.5*smoothstep(0.5, 0.1, dist_center);\n    \n\tvec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;\n    \n    float c = waterHighlight(p, time, foaminess);\n    \n    vec3 water_color = vec3(0.5, 0.0, 0.0);\n\tvec3 color = vec3(c);\n    color = clamp(color + water_color, 0.0, 1.0);\n    \n    color = mix(water_color, color, clearness);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 133, 133, 626], [629, 629, 687, 687, 1339]], "test": "untested"}
{"id": "dlBBD1", "name": "Golden Chocolate Waves", "author": "djvperrucho", "description": "Explore 'Golden Chocolate Waves,' a captivating shader. This visual masterpiece blends golden chocolate tones with flowing waves for a mesmerizing experience. Immerse yourself in this luxurious and relaxing world of color and energy.", "tags": ["waves", "abstract", "chocolate", "gold"], "likes": 16, "viewed": 569, "published": 3, "date": "1693996960", "time_retrieved": "2024-07-30T17:35:17.346252", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 6.*(( fragCoord.xy-.5* iResolution.xy )/iResolution.y)-.5 ;\n    vec2 i = p;\n\tfloat c = 0.0;\n\tfloat r = length(p+vec2(sin(iTime),sin(iTime*.300+5.))*0.5);\n\tfloat d = length(p);\n\tfloat rot = d+iTime+p.x*.700; \n\tfor (float n = 0.0; n < 4.0; n++) {\n\t\tp *= mat2(cos(rot-sin(iTime/5.0)), sin(rot), -sin(cos(rot)-iTime), cos(rot))*-0.2;\n\t\tfloat t = r-iTime/(n+3.0);\n\t\ti -= p + vec2(cos(t - i.x-r) + sin(t + i.y),sin(t - i.y) + cos(t + i.x)+r);\n\t\tc += 1.2/length(vec2((sin(i.x+t)/.15), (cos(i.y+t)/.15)));\n\t}\n\tc /= 6.0;\n\tfragColor = vec4(vec3(c)*vec3(3.0, 2.0, 1.1)-0.35, .1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 641]], "test": "untested"}
{"id": "mlSBD1", "name": "Smoke blue waves", "author": "djvperrucho", "description": "Step into the captivating realm of 'Abyssal Currents,' an abstract visual masterpiece that evokes the essence of swirling depths and dynamic waves. This unique shader melds fluidity and enigma, crafting an ever-shifting, mesmerizing display. Immerse yours", "tags": ["wave", "ocean", "abstract", "blue", "smoke"], "likes": 10, "viewed": 277, "published": 3, "date": "1693994971", "time_retrieved": "2024-07-30T17:35:18.116194", "image_code": "#define TAU 6.28318530718\n\n#define TILING_FACTOR 1.0\n#define MAX_ITER 8\n\n\nfloat waterHighlight(vec2 p, float time, float foaminess)\n{\n    vec2 i = vec2(p);\n\tfloat c = 0.0;\n    float foaminess_factor = mix(1.0, 6.0, foaminess);\n\tfloat inten = .005 * foaminess_factor;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (0.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));\n\t}\n\tc = 0.2 + c / (inten * float(MAX_ITER));\n\tc = 1.17-pow(c, 1.4);\n    c = pow(abs(c), 8.0);\n\treturn c / sqrt(foaminess_factor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * 0.1+23.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_square = vec2(uv.x * iResolution.x / iResolution.y, uv.y);\n    float dist_center = pow(1.0*length(uv - 0.5), 1.0);\n    \n    float foaminess = smoothstep(0.4, 8.0, dist_center);\n    float clearness = 0.9 + 0.5*smoothstep(0.5, 0.1, dist_center);\n    \n\tvec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;\n    \n    float c = waterHighlight(p, time, foaminess);\n    \n    vec3 water_color = vec3(0, 0, 0.3);\n\tvec3 color = vec3(c);\n    color = clamp(color + water_color, 0.0, 1.0);\n    \n    color = mix(water_color, color, clearness);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 133, 133, 624], [627, 627, 685, 685, 1332]], "test": "untested"}
{"id": "dtBfW1", "name": "Smoke waves", "author": "djvperrucho", "description": "Discover 'Smoke Wave' – an abstract masterpiece of swirling smoke and dynamic waves. This mesmerizing shader combines fluidity and mystery, creating a hypnotic display of colors and shapes. Immerse yourself in its enchanting dance of elements, where smoke", "tags": ["waves", "abstract", "smoke", "gray", "dark"], "likes": 7, "viewed": 284, "published": 3, "date": "1693993607", "time_retrieved": "2024-07-30T17:35:18.879154", "image_code": "#define TAU 6.28318530718\n\n#define TILING_FACTOR 1.0\n#define MAX_ITER 8\n\n\nfloat waterHighlight(vec2 p, float time, float foaminess)\n{\n    vec2 i = vec2(p);\n\tfloat c = 0.0;\n    float foaminess_factor = mix(1.0, 6.0, foaminess);\n\tfloat inten = .005 * foaminess_factor;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (0.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));\n\t}\n\tc = 0.2 + c / (inten * float(MAX_ITER));\n\tc = 1.17-pow(c, 1.4);\n    c = pow(abs(c), 8.0);\n\treturn c / sqrt(foaminess_factor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * 0.02+23.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_square = vec2(uv.x * iResolution.x / iResolution.y, uv.y);\n    float dist_center = pow(1.0*length(uv - 0.5), 0.5);\n    \n    float foaminess = smoothstep(0.4, 8.0, dist_center);\n    float clearness = 0.9 + 0.5*smoothstep(0.5, 0.1, dist_center);\n    \n\tvec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;\n    \n    float c = waterHighlight(p, time, foaminess);\n    \n    vec3 water_color = vec3(0.01, 0.01, 0.01);\n\tvec3 color = vec3(c);\n    color = clamp(color + water_color, 0.0, 1.0);\n    \n    color = mix(water_color, color, clearness);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 133, 133, 624], [627, 627, 685, 685, 1340]], "test": "untested"}
{"id": "ctSfDh", "name": "Basketball Bounce", "author": "pikachuchujelly", "description": "My very first shader (written by a noob)! Features a ray-cast bouncing basketball, along with shadows and reflections.", "tags": ["raycasting", "ball"], "likes": 10, "viewed": 256, "published": 3, "date": "1693973500", "time_retrieved": "2024-07-30T17:35:19.640119", "image_code": "#define HUGE 1000000.0\n\nvec3 ballPos;\nfloat ballRadius = 2.0;\nvec3 lightDir = normalize(vec3(1,2,-2));\n\n// computes the ray direction of a screen pixel\nvec3 perspectiveRay(vec2 pixel)\n{\n    float x = -1.0 + 2.0*(pixel.x / iResolution.x);\n    float y = 1.0;\n    float z = -1.0 + 2.0*(pixel.y / iResolution.y);\n    x *= iResolution.x / iResolution.y;\n    return normalize(vec3(x,y,z));\n}\n\nvec3 rotateYaw(vec3 v, float angle)\n{\n    return vec3(\n        v.x*cos(angle) - v.y*sin(angle),\n        v.y*cos(angle) + v.x*sin(angle),\n        v.z);\n}\n\nvec3 rotatePitch(vec3 v, float angle)\n{\n    return vec3(\n        v.x,\n        v.y*cos(angle) - v.z*sin(angle),\n        v.z*cos(angle) + v.y*sin(angle));\n}\n\nfloat calcLight(vec3 normal, vec3 rd, float shininess)\n{\n    float ambient  = 0.3;\n    float diffuse  = max(dot(-lightDir,normal), 0.0);\n    float specular = max(dot(-lightDir,reflect(rd, normal)), 0.0);\n    specular *= specular*specular*specular*specular*specular*specular*specular*specular;\n    return ambient + diffuse + specular * shininess;\n}\n\nfloat raycastSphere(vec3 ro, vec3 rd, out vec3 normal)\n{\n    vec3 sc = ballPos;  // sphere center\n    float sr = ballRadius;  // sphere radius\n\n    // Imagine a plane that is perpendicular to the ray and intersects the sphere's center.\n    // ts is the distance along the ray to that plane.\n    float ts = dot(sc-ro, rd);\n    if (ts < 0.0)\n        return HUGE;\n    // distance squared between point at ts and the sphere center\n    float r2 = (dot(sc-ro,sc-ro) - ts*ts);\n    if (r2 > sr*sr)\n        return HUGE;\n    float t = ts - sqrt(sr*sr - r2);  // distance along ray to where it intersects the sphere\n    vec3 hit = ro + rd * t;\n    normal = normalize(hit-sc);\n    return t;\n}\n\nfloat raycastFloor(vec3 ro, vec3 rd, out vec2 hit)\n{\n    if (rd.z >= 0.0)\n        return HUGE;\n    float t = -ro.z / rd.z;\n    hit = vec2(ro.x+rd.x*t, ro.y+rd.y*t);\n    return t;\n}\n\n// Returns true or false to select the pattern for the floor position\nbool checker(vec2 floorPos)\n{\n    return mod(floor(floorPos.x) + floor(floorPos.y), 2.0) < 1.0;\n}\n\n// Returns true if the floor position is in the shadow of the ball\nbool shadow(vec3 floorPos)\n{\n    vec3 dummy;\n    return raycastSphere(floorPos, -lightDir, dummy) < HUGE;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // ball physics\n    float t = fract(iTime);\n    float bounce = ceil(fract(iTime/4.0)*4.0);\n    float z = -t*(t-1.0)*50.0/bounce;\n    ballPos = vec3(0.0, 6.0*iTime, 2.0+z);\n\n    float cameraAngle = 0.5*iTime;\n    // ray origin\n    vec3 ro = rotateYaw(vec3(0,-10,4),cameraAngle);\n    ro.y += ballPos.y;\n    // ray direction\n    vec3 rd = perspectiveRay(fragCoord);\n    rd = normalize(rotateYaw(rd,cameraAngle));\n\n    // do the ray trace\n    vec2 floorHit;\n    vec3 nSphere;\n    float rt;\n    float tFloor;\n    vec3 color;\n    vec3 floorColor;\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 sky = mix(vec3(1,1,1),vec3(0,0,1),max(rd.z, 0.0));\n        color = sky;\n        if (raycastSphere(ro, rd, nSphere) < HUGE)\n        {\n            // compute rotated normal for ball pattern\n            vec3 n = rotatePitch(nSphere, ballPos.y/ballRadius);\n            if (abs(n.x) < 0.05 || abs(n.z) < 0.05\n             || abs(n.x*n.x-n.z*n.z-0.2) < 0.05)\n                color = vec3(0,0,0);  // black\n            else\n                color = vec3(1.0,0.5,0.0);  // orange\n            color *= calcLight(nSphere, rd, 0.5);\n        }\n        else if ((rt = raycastFloor(ro, rd, floorHit)) < HUGE)\n        {\n            tFloor = rt;\n            floorColor = checker(floorHit) ? vec3(0.9,0.8,0.4) : vec3(0.8,0.7,0.3);\n            if (shadow(vec3(floorHit,0)))\n                floorColor *= 0.3;\n            else\n                floorColor *= calcLight(vec3(0,0,1), rd, 0.3);\n            // now trace the reflected ray\n            ro = vec3(floorHit, 0.0);\n            rd = reflect(rd,vec3(0,0,1));\n            continue;\n        }\n        else\n            color = sky;\n        if (i == 0)\n            break;\n        else\n        {\n            // blend reflected color with floor color\n            color = mix(floorColor, color, 0.35);\n            // fade out with sky to avoid aliasing artifacts\n            float fadeStart = 20.0;\n            float fadeEnd = 40.0;\n            color = mix(color, sky, clamp((tFloor-fadeStart)/(fadeEnd-fadeStart),0.0,1.0));\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 152, 185, 185, 385], [387, 387, 424, 424, 539], [541, 541, 580, 580, 695], [697, 697, 753, 753, 1044], [1046, 1046, 1102, 1102, 1726], [1728, 1728, 1780, 1780, 1908], [1910, 1980, 2009, 2009, 2077], [2079, 2146, 2174, 2174, 2253], [2255, 2255, 2310, 2330, 4411]], "test": "untested"}
{"id": "ml2fDz", "name": "sort͏", "author": "01000001", "description": "thingy", "tags": ["thing"], "likes": 2, "viewed": 44, "published": 3, "date": "1693970671", "time_retrieved": "2024-07-30T17:35:20.402082", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n\n    O = vec4(smoothstep(1./r.y, 0., abs(texture(iChannel0, vec2(uv.x, 0)).x-uv.y)));\n    \n    // Smoothstep is an intentional design choice to give randomized brightness to particles\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y == .5){\n         if (iFrame < 20){\n             O = vec4(0);\n             O.x = hash(uvec3(U.x, iDate.w, iDate.z)).x;\n         } else {\n             O = texture(iChannel0, U/iResolution.xy);\n         \n             // Assuming we have a GPU, this is a naïve method but it works\n             // Sort here\n             \n             bool d = (int(U.x) + iFrame)%2 == 1;\n             \n             float v = texelFetch(iChannel0, ivec2(U.x + (d?1.:-1.) - .5, 0), 0).x;\n             \n             if (v == 0.) return;\n             \n             O.x = (v < O.x && d) || (v > O.x && !d)?v:O.x;\n         \n         \n         }\n    } else {\n        O = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2fDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 281]], "test": "untested"}
{"id": "ctSBWh", "name": "Rectangular Representation", "author": "wyatt", "description": "Representing a shape as closely as possible with the fewest rectangular sections. (they have to be rectangular because that's integrable)", "tags": ["sdf"], "likes": 23, "viewed": 228, "published": 3, "date": "1693966914", "time_retrieved": "2024-07-30T17:35:21.170029", "image_code": "#define R iResolution.xy\nfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y);\n\t\t    vec2 q = p-clamp(p,-h+r,h-r);\n\t\t    if (length(q)>0.) return length(q) - r ;\n            else return max(abs(p.x)-h.x,abs(p.y)-h.y);\n\t\t}\nfloat map (vec2 p ) {\n     p -= .5*R;\n     p.xy *= mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n     return max(roundBox(p,(.4+.1*sin(iTime))*R,(.05+.05*sin(.333*iTime))*R.x),-length(p)+(.03*sin(1.2*iTime)+.07)*R.x);\n}\nvoid mainImage( out vec4 Q, in vec2 U)\n{\n    \n    \n    {\n        float d = map(U);\n        Q = (1.-.25*exp(-3.*abs(sin(d/3.))))*max(vec4(-sign(d),.5,sign(d),1),0.);\n    }\n    \n    vec2 s = vec2(40);\n    vec2 l = floor(U/s+iTime)*s-iTime*s;\n    vec2 h = ceil (U/s+iTime)*s-iTime*s;\n    vec4 q = vec4(l,h);\n    \n    float a = map(q.xy);\n    float b = map(q.xw);\n    float c = map(q.zy);\n    float d = map(q.zw);\n    \n    if (a>0.&&b>0.&&c>0.&&d>0.) return; \n    else if (a>0.&&b>0.&&c>0.) {\n        q.xy = q.xy+max(a*sqrt(.5),max(b,c));\n    } else if (a>0.&&b>0.&&d>0.) {\n        q.xw = q.xw-vec2(-1,1)*max(b*sqrt(.5),max(a,d));\n    } else if (a>0.&&c>0.&&d>0.) {\n        q.zy = q.zy+vec2(-1,1)*max(c*sqrt(.5),max(a,d));\n    } else if (b>0.&&c>0.&&d>0.) {\n        q.zw = q.zw-max(d*sqrt(.5),max(b,c));\n    } else if (a>0.&&b>0.) {\n        q.x = q.x + max(a,b);\n    } else if (c>0.&&d>0.) {\n        q.z = q.z - max(c,d);\n    } else if (a>0.&&c>0.) {\n        q.y = q.y + max(a,c);\n    } else if (b>0.&&d>0.) {\n        q.w = q.w - max(b,d);\n    } \n    {\n        float d = roundBox(U-.5*(q.xy+q.zw),q.zw-q.xy,0.);\n        Q *= smoothstep(0.,1.,abs(d))-.2*smoothstep(1.,0.,d);\n    }\n      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 71, 71, 248], [249, 249, 270, 270, 474], [475, 475, 515, 515, 1659]], "test": "untested"}
{"id": "Dl2fWz", "name": "Oil Projector v3", "author": "sh1boot", "description": "A performance-improved do-over of Oil projector v2: https://www.shadertoy.com/view/clBcDt\n\nBasically the feedback buffer doesn't need much resolution at all (one might almost get away with 32x32 with bicubic sampling).\n\nUses cubemap for stable mimpmaps.", "tags": ["blobs", "threshold", "lava", "feedback", "gpmipmap"], "likes": 3, "viewed": 217, "published": 3, "date": "1693960638", "time_retrieved": "2024-07-30T17:35:22.123480", "image_code": "// Here we sample the blurred version of the feedback buffer,\n// and threshold it against its overall average value (the\n// deepest mipmap offset).\n//\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec4 pal(in vec4 i, in vec2 uv) {\n    const vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5), c = vec3(1.0,1.0,1.0), d = vec3(0.0,0.33,0.67);\n    \n    const vec3 c64pal[16] = vec3[16](\n        vec3(0., 0., 0.), vec3(1., 1., 1.), vec3(0., 1., 0.), vec3(.5, 0., 0.),\n        vec3(.6, 1., .9), vec3(.7, .3, .7), vec3(0., .7, .4), vec3(0., 0., .6),\n        vec3(.9, .9, .5), vec3(.8, .5, .3), vec3(1., .5, .5), vec3(.2, .2, .2),\n        vec3(.5, .5, .5), vec3(.6, 1., .7), vec3(0., .5, 1.), vec3(.8, .8, .8)\n    );\n    vec3 result = vec3(0);\n    vec4 j = vec4(1.) - i;\n    for (int k = 0; k < 16; ++k) {\n        vec4 w4 = mix(i, j, equal(k & ivec4(8, 4, 2, 1), ivec4(0)));\n        float w = w4.x * w4.y * w4.z * w4.w;\n#if 0\n        result += w * pal(float(k) / 16.0, vec3(0.5),vec3(0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n#else\n        result += w * c64pal[k];\n#endif\n    }\n    return vec4(result, 1.0);\n}\n\n// Anti-aliasing version of a simple threshold.  Look at the slope\n// of the underlying curve being thresholded to figure out how much\n// of the pixel the threshold boundary would capture, so that we\n// don't get aliasing around the horizon.\n//\nvec4 aastep(vec4 threshold, vec4 f) {\n    vec4 margin = clamp(fwidth(f) * 0.7, 0.0, 0.4);\n    return smoothstep(threshold - margin, threshold + margin, f);\n}\nvec4 aastep(float threshold, vec4 f) {\n    return aastep(vec4(threshold), f);\n}\n\n\nvec2 w0(vec2 a) { return (a * (a * (-a + 3.0) - 3.0) + 1.0) / 6.0; }\nvec2 w1(vec2 a) { return (a * a * (3.0 * a - 6.0) + 4.0) / 6.0; }\nvec2 w2(vec2 a) { return (a * (a * (-3.0 * a + 3.0) + 3.0) + 1.0) / 6.0; }\nvec2 w3(vec2 a) { return (a * a * a) / 6.0; }\n\nvec4 texbicubic(sampler2D tex, vec2 uv, vec2 tsc) {\n    bool linear = texelFetch(iChannel3, ivec2(32,0),0).x >= 0.5;  // space\n    if (linear) return texture(tex, uv * tsc);\n\n    // If you zoom in or set `dimension` very low, then you'll see\n    // line segments rolling around the edges of the curve.  That's\n    // the linear interpolation of a low-resolution buffer, and\n    // bicubic sampling fixes that very nicely.\n    //\n    // Also, the meniscus shading brings out artefacts you shouldn't\n    // otherwise be able to see, so this would help a lot there.\n\n    uv *= dimension;\n    tsc /= dimension;\n    uv += 0.5;\n\n\tvec2 iuv = floor(uv);\n\tvec2 fuv = fract(uv);\n\n    vec2 g0 = w0(fuv) + w1(fuv);\n    vec2 g1 = w2(fuv) + w3(fuv);\n    vec2 h0 = -1.0 + w1(fuv) / (w0(fuv) + w1(fuv));\n    vec2 h1 = 1.0 + w3(fuv) / (w2(fuv) + w3(fuv));\n\n\tvec2 p00 = iuv + h0 - 0.5;\n\tvec2 p10 = iuv + vec2(h1.x, h0.y) - 0.5;\n\tvec2 p01 = iuv + vec2(h0.x, h1.y) - 0.5;\n\tvec2 p11 = iuv + h1 - 0.5;\n\n    return (textureLod(tex, p00 * tsc, 0.0) * g0.x  +\n            textureLod(tex, p10 * tsc, 0.0) * g1.x) * g0.y +\n           (textureLod(tex, p01 * tsc, 0.0) * g0.x  +\n            textureLod(tex, p11 * tsc, 0.0) * g1.x) * g1.y;\n}\n\nfloat hmax(vec4 x) {\n    x.xy = max(x.xy, x.zw);\n    return max(x.x, x.y);\n}\n\nfloat hsmoothmax(vec4 x) {\n    float k = 3.0;\n    return log(dot(exp(x * k), vec4(1))) / k;\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord)\n{\n    // Unlike the other buffers, here we want to fill the whole\n    // output, so we'll be upscaling the feedback buffer.\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x + 0.5;\n    // dimension fixup, because we only use a sub-rectangle of each\n    // texture in the pipeline, but want to address that\n    // sub-rectangle as [0,1)\n    vec2 tsc = dimension / iChannelResolution[0].xy;\n\n    vec4 colour = texbicubic(iChannel0, uv, tsc);\n    vec4 threshold = texture(iChannel1, 1.0 - 0.5 / iChannelResolution[1].xy);\n    vec4 meniscus = colour - threshold;\n    colour = aastep(threshold, colour);\n\n    bool lshift = texelFetch(iChannel3, ivec2(16,0),0).x >= 0.5;\n    if (lshift) {\n#if 1\n        tsc = dimension / iChannelResolution[1].xy;\n        colour = texture(iChannel1, uv * tsc);\n#else\n        tsc = dimension / iChannelResolution[2].xy;\n        colour = texcube(iChannel2, 0, uv * tsc);\n#endif\n        if (uv.x >= 0.8) {\n            vec4 fullness = texcubeLod(iChannel2, 0, vec2(0.5), 99.9) * mipmapfix;\n            float y = fragCoord.y / iResolution.y;\n            vec4 l = abs(uv.x * 20.0 - 16.5 - vec4(0.0, 1.0, 2.0, 3.0));\n            vec4 ll = 1.0 - aastep(0.05, l);\n            l = 1.0 - aastep(0.45, l);\n            colour = aastep(y, threshold) * l;\n            colour.yzwx += \n                    (aastep(y, max(fullness, setpoint))\n                   - aastep(y, min(fullness, setpoint))) * ll;\n        }\n    }\n    float alpha = hmax(colour);\n    colour = pal(colour, uv);\n\n#if 1\n    // shade the meniscus a little...\n    const float thinness = 4.0;\n    float meni = smoothstep(-1.0, 1.0, hsmoothmax(meniscus * thinness)) * 2.0 - 1.0;\n    vec4 shine = vec4(cos(atan(dFdy(meni), dFdx(meni)) + 1.2) * 0.5 + 0.5);\n    colour = mix(colour, shine, alpha * (1.0 - meni) * 0.75);\n#endif\n    fragColour = colour;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Length of one side of the feedback buffer (square).  The rest of\n// each buffer is left unused, but still has to be zeroed for\n// mipmaps and interpolation.\nconst float dimension = 128.0;\n\n// Volume of each blob colour to aim for.\nconst vec4 setpoint = vec4(0.15);\n\n// since we don't write the whole buffer, the deepest mipmap will be\n// averaged over the valid data plus a whole lot of black.  This is\n// the ratio needed to compensate for that.\nconst float mipmapfix = 1024.0 * 1024.0 / (dimension * dimension);\n\n// Number of samples to read for a gaussian blur.  This is done in\n// two passes and the buffer is reduced resolution, so it's not a\n// large cost, but we also don't need many taps.\nconst int blur_taps = 7;\n// Strength of gaussian blur curve.\nconst vec4 blur_radius = vec4(0.03, 0.08, 0.05, 0.13) * 2.0;\n\nconst float tau = 2.0 * 3.14159265358979;\n\n// Sample from one face of a cubemap.\nvec4 texcubeLod(samplerCube tex, int face, vec2 uv, float lod) {\n    uv = 2.0 * uv - 1.0;\n    switch (face) {\n    case 0: return textureLod(tex, vec3( uv.x,-uv.y,  1.0), lod);\n    case 1: return textureLod(tex, vec3(-uv.x,-uv.y, -1.0), lod);\n    case 2: return textureLod(tex, vec3( uv.x,  1.0, uv.y), lod);\n    case 3: return textureLod(tex, vec3( uv.x, -1.0,-uv.y), lod);\n    case 4: return textureLod(tex, vec3(  1.0,-uv.y,-uv.x), lod);\n    case 5: return textureLod(tex, vec3( -1.0,-uv.y, uv.x), lod);\n    }\n}\n\nvec4 texcube(samplerCube tex, int face, vec2 uv) {\n    return texcubeLod(tex, face, uv, 0.0);\n}\n\nvec2 dimclamp(vec2 uv) {\n    // incoming coordinate should be [0,1) representing coordinates\n    // in the first `dimension` pixels of the image.  We need to\n    // clamp these to the centre of the pixels at the two extremes\n    // in order to avoid interpolating into out-of-bounds data.\n    const float lo = 0.5 / dimension;\n    const float hi = 1.0 - lo;\n    return clamp(uv, lo, hi);\n}\n\nvec4 pdf(vec4 x) {\n#if 0\n    // pdf for s=0.1667: `sum(uniform(-.5,.5, 3)/3)`\n    return 2.39365 * exp(-18. * x * x);\n#else\n    // pdf for s=0.144: `sum(uniform(-.5,.5, 4)/4)`\n    return 2.77043 * exp(-24.1126 * x * x);\n#endif\n}\n\nvec4 texblur(sampler2D tex, vec2 uv, vec2 v, vec2 tsc) {\n    const float lod = 0.0;\n    vec4 sum = vec4(0);\n    vec4 den = vec4(0);\n\n    for (int i=-blur_taps; i <= blur_taps; i++) {\n        float f = float(i) / dimension;\n        vec4 w = pdf(f / blur_radius);\n        vec2 ofs = v * f;\n        sum += textureLod(tex, dimclamp(uv + ofs) * tsc, lod) * w;\n        den += w;\n    }\n    return sum / den;\n}\n", "cube_a_code": "// Threshold the blurred buffer into a square POT texture (for more\n// predictable mipmapping), so that we can use the mipmap as an area\n// estimate.\n//\n// We should probably do several passes, here, with different biases\n// on the threshold to see how far off the true value we are.\n//\n\n// See which face index we're updating.\nint face(vec3 dir) {\n    vec3 absdir = abs(dir);\n    vec3 gt = vec3(greaterThan(absdir, max(absdir.yzx, absdir.zxy)));\n    return int(dot(vec3(4, 2, 0), gt)) + int(dot(dir, gt) < 0.0);\n}\n\nvoid mainCubemap(out vec4 fragColour, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec2 uv = fragCoord / dimension;\n#if 1 // WINDOWS\n    fragColour = vec4(0);\n#else\n    if (iFrame == 0) fragColour = vec4(0);\n#endif\n    if (face(rayDir) != 0 || uv != fract(uv)) return;\n    vec2 tsc = dimension / iChannelResolution[0].xy;\n    vec4 colour = texture(iChannel0, uv * tsc);\n    vec4 threshold = texture(iChannel1, 1.0 - 0.5 / iChannelResolution[0].xy);\n\n    colour = smoothstep(-0.001, 0.001, colour - threshold);\n\n    fragColour = colour;\n}", "cube_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Generic feedback buffer with swirly patterns.\n//\n// We use all four channels to represent four slices of 'liquid'\n// which don't interact (much).  We use two stirring operations\n// (`swish0()` and `swish1()`) and share these between the four\n// layers with constantly-changing weights (`spinners`) between\n// the two.  This has dual effects of pushing several liquids in\n// the same direction sometimes, and halves the number of texture\n// fetches which would be required if every liquid had\n// independent flow.\n//\n// For a bit more complexity, where liquids overlap they squeeze\n// each other a little bit by (`decay()`).\n\n// A straight, blurred boundary which rotates around an axis which\n// itself circles the centre.  Separate parameters for each plane.\nvec4 spinners(vec2 uv, float t) {\n    uv -= 0.5;\n    vec4 ta = t * vec4(-113, 123, -133, 143) * 0.0009 * tau;\n    vec4 tb = t * vec4(-177, -137, 157, 127) * 0.0004 * tau;\n    vec4 cx = uv.x + cos(ta) * 0.3;\n    vec4 cy = uv.y - sin(ta) * 0.3;\n    vec4 th = mod(atan(cy, cx) + tb + tau, tau);\n    vec4 r = sqrt(cx * cx + cy * cy);\n    return smoothstep(-0.4, 0.4, (cos(th) - sin(th)) * r);\n}\n\n// Shove things around a bit to make swirly patterns\nvec2 swish0(vec2 uv, float t) {\n    uv += vec2(sin(t + uv.y * 16.1), cos(uv.x * 17.1)) * 0.0015;\n\n    vec2 o = vec2(sin(t * 0.567), cos(t * -0.521)) * 0.3 + 0.5;\n    const float c = cos(0.0019), s = sin(0.0019);\n    uv = (uv - o) * mat2(c, s, -s, c) * 0.9996 + o;\n\n    return uv;\n}\n\n// Shove things around a bit, but slightly differently\nvec2 swish1(vec2 uv, float t) {\n    uv += vec2(sin(t + uv.y * 13.1), cos(uv.x * 14.1)) * 0.0019;\n\n    vec2 o = vec2(sin(t * 0.367), cos(t * -0.321)) * 0.3 + 0.5;\n    const float c = cos(0.0015), s = -sin(0.0015);\n    uv = (uv - o) * mat2(c, s, -s, c) * 0.9996 + o;\n\n    return uv;\n}\n\n// When reading from outside the feedback buffer, fall back on a\n// rotating pattern so that there's always something present to\n// seed the buffer to be non-empty.\nvec4 texborder(sampler2D tex, vec2 uv, float t, vec2 tsc) {\n    if (uv == dimclamp(uv)) return texture(tex, uv * tsc);\n    uv -= 0.5;\n    vec4 th = atan(uv.y, uv.x) * 9.0 + t * vec4(0.8, 0.7, 0.9, 0.5);\n    return max(vec4(0), cos(th) * 0.4 - 0.1);\n}\n\nvec4 texborder(samplerCube tex, int face, vec2 uv, float t, vec2 tsc) {\n    if (uv == dimclamp(uv)) return texcube(tex, face, uv * tsc);\n    uv -= 0.5;\n    vec4 th = atan(uv.y, uv.x) * 9.0 + t * vec4(2.8, 1.7, 2.9, 3.5);\n    return max(vec4(0), cos(th) * 0.4 - 0.1);\n}\n\n// the main feebback operation.\nvec4 feedback(sampler2D tex, vec2 uv, float t, vec2 tsc) {\n    return mix(texborder(tex, swish0(uv, t), t, tsc),\n               texborder(tex, swish1(uv, t), t, tsc),\n               spinners(uv, t));\n}\n\nvec4 feedback(samplerCube tex, int face, vec2 uv, float t, vec2 tsc) {\n    return mix(texborder(tex, face, swish0(uv, t), t, tsc),\n               texborder(tex, face, swish1(uv, t), t, tsc),\n               spinners(uv, t));\n}\n\n// Decay where there's overlap.\nvec4 repel(vec4 c) {\n    return 1.0 - (c.yzwx + c.zwxy) * 0.019 - c.wxyz * 0.015;\n}\n\n\nvec4 updateThreshold() {\n    if (iFrame == 0) return vec4(0.05);\n\n    vec4 fullness = texcubeLod(iChannel1, 0, vec2(0.5), 99.9) * mipmapfix;\n    // TODO: use more faces of iChannel1 to get a better estimate\n    // of where the threshold should be.\n\n    vec4 incr = clamp(fullness - setpoint, -0.2, 0.2);\n\n    vec4 threshold = texture(iChannel0, 1.0 - 0.5 / iChannelResolution[0].xy);\n    threshold = mix(threshold, threshold + incr, 0.02);\n    threshold = clamp(threshold, 0.001, 0.999);\n    return threshold;\n}\n\n// A generic feedback buffer implementation.\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / dimension;\n    if (iFrame == 0) fragColour = vec4(0);\n\n    // Maintain a filtered copy of the threshold in an unused\n    // corner of buffer A:\n    if (all(greaterThanEqual(fragCoord, iResolution.xy - 1.0))) {\n        fragColour = updateThreshold();\n    }\n    if (uv != fract(uv)) return;\n\n    vec2 tsc0 = dimension / iChannelResolution[0].xy;\n    vec2 tsc1 = dimension / iChannelResolution[1].xy;\n\n    vec4 colour = feedback(iChannel0, uv, iTime, tsc0);\n    vec4 quantised = feedback(iChannel1, 0, uv, iTime, tsc1);\n\n    // Mix in a little feedback from the thresholded version to\n    // encourage the buffer to become more saturated.\n    colour = mix(colour, quantised, 0.035);\n\n    // A little interaction between layers.\n    colour *= repel(colour);\n    \n    fragColour = colour;    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// First pass of a gaussian blur of the feedback buffer\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    vec2 uv = fragCoord / dimension;\n    if (iFrame == 0) fragColour = vec4(0);\n    if (uv != fract(uv)) return;\n    vec2 tsc = dimension / iChannelResolution[0].xy;\n\n    fragColour = texblur(iChannel0, uv, vec2(0.0, 1.0), tsc);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Second pass of a gaussian blur of the feedback buffer\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    vec2 uv = fragCoord / dimension;\n    if (iFrame == 0) fragColour = vec4(0);\n    if (uv != fract(uv)) return;\n    vec2 tsc = dimension / iChannelResolution[0].xy;\n\n    fragColour = texblur(iChannel0, uv, vec2(1.0, 0.0), tsc);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2fWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 218, 218, 267], [269, 269, 302, 302, 1177], [1179, 1424, 1461, 1461, 1581], [1582, 1582, 1620, 1620, 1661], [1664, 1664, 1681, 1681, 1732], [1733, 1733, 1750, 1750, 1798], [1799, 1799, 1816, 1816, 1873], [1874, 1874, 1891, 1891, 1919], [1921, 1921, 1972, 1972, 3132], [3134, 3134, 3154, 3154, 3210], [3212, 3212, 3238, 3238, 3305], [3307, 3307, 3363, 3485, 5203]], "test": "untested"}
{"id": "dljBWz", "name": "Exit the Matrix Fork", "author": "GesChen", "description": "Circuit fractal applied to a KIFS structure and a transparent cube\n\nfork-applied my own twists and decreased quality for efficient rendering as screensaver", "tags": ["raymarching", "fractal", "texture"], "likes": 12, "viewed": 325, "published": 3, "date": "1693954266", "time_retrieved": "2024-07-30T17:35:22.895416", "image_code": "float det=.001,t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 path(float t)\n    {\n    vec3 p=vec3(vec2(sin(t*.1),cos(t*.05))*10.,t);\n    p.x+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\n    return p;\n}\n\nfloat fractal(vec2 p)\n{\n    p=abs(5.-mod(p*.2,10.))-5.;\n    float ot=1000.;\n    for (int i=0; i<7; i++)\n    {\n        p=abs(p)/clamp(p.x*p.y,.25,2.)-1.;\n        if(i>0)ot=min(ot,abs(p.x)+.7*fract(abs(p.y)*.05+t*.05+float(i)*.3));\n        \n    }\n    ot=exp(-10.*ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c=abs(p)-l;\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat de(vec3 p)\n{\n    boxhit=0.;\n    vec3 p2=p-adv;\n    p2.xz*=rot(t*.3);\n    p2.xy*=rot(t*.1);\n    p2.yz*=rot(t*.15);\n    float b=box(p2,vec3(1.));\n    p.xy-=path(p.z).xy;\n    float s=sign(p.y);\n    p.y=-abs(p.y)-3.;\n    p.z=mod(p.z,20.)-10.;\n    for (int i=0; i<5; i++)\n    {\n        p=abs(p)-1.;\n        p.xz*=rot(radians(s*-45.));\n        p.yz*=rot(radians(90.));\n    }\n    float f=-box(p,vec3(5.,5.,10.));\n    float d=min(f,b);\n    if (d==b) boxp=p2, boxhit=1.;\n    return d*.7;\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 p,n,g=vec3(0.);\n    float d, td=0.;\n    for (int i=0; i<60; i++)\n    {\n        p=from+td*dir;\n        d=de(p)*(1.-hash(gl_FragCoord.xy+t)*.3);\n        if (d<det && boxhit<.5) break;\n        td+=max(det,abs(d));\n        float f=fractal(p.xy)+fractal(p.xz)+fractal(p.yz);\n        //boxp*=.5;\n        float b=fractal(boxp.xy)+fractal(boxp.xz)+fractal(boxp.yz);\n        vec3 colf=vec3(f*f,f,f*f*f);\n        vec3 colb=vec3(b*2.+.1,b*.1+.02,b*b*.2+.01);\n        g+=colf/(3.+d*d*2.)*exp(-.0015*td*td)*step(5.,td)/2.*(1.-boxhit);\n        g+=colb/(10.+d*d*20.)*boxhit*.5;\n    }\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up) \n{\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    t=iTime*7.;\n    vec3 from=path(t);\n    adv=path(t+6.+sin(t*.1)*3.);\n    vec3 dir=normalize(vec3(uv,.7));\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from, dir);\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 63, 63, 180], [183, 183, 202, 202, 261], [263, 263, 287, 287, 407], [409, 409, 432, 432, 691], [693, 693, 720, 720, 809], [811, 811, 829, 829, 1297], [1300, 1300, 1333, 1333, 1927], [1929, 1929, 1962, 1962, 2068], [2071, 2071, 2128, 2128, 2403]], "test": "untested"}
{"id": "DtjBWR", "name": "Super Logic Snake", "author": "martymarty", "description": "This a snake or spiral formula. It's a function that takes 2d coordinates and maps it to a 1d spiral around a square. I added interactivity, click to reposition the snake. Increase the size and speed with the levers on the side.", "tags": ["2d", "interactive", "spiral", "snake", "experiments"], "likes": 7, "viewed": 187, "published": 3, "date": "1693942416", "time_retrieved": "2024-07-30T17:35:23.661368", "image_code": "#define minSize 3.0\n#define maxSize 20.0\n\n\nfloat superLogicSnake(vec2 pos, float size){\n    float center = (size-1.0)*0.5;\n    float ring =  min(center-abs(pos.x-center),center-abs(pos.y-center));\n    if(pos.x == (size-ring-1.0) || pos.y == ring){\n        return 4.0*ring*(size-ring)+pos.x+pos.y-2.0*ring;\n    }\n    else {\n        return 4.0*(ring+1.0)*(size-(ring+1.0))-(pos.x+pos.y-2.0*ring);\n    }  \n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 size_rate_time = fetchData(iChannel0, COMMON_SIZE_RATE_TIME).xyz;\n    \n    fragCoord.x = fragCoord.x -0.5*(iResolution.x-iResolution.y);\n    vec2 relMouse = iMouse.xy;\n    relMouse.x = relMouse.x - 0.5*(iResolution.x-iResolution.y);\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float xMask = 1.0-abs(floor(uv.x));\n    relMouse = relMouse/iResolution.y;\n    relMouse *= xMask;\n    vec3 col = vec3(0.0);\n    float size = floor(minSize + size_rate_time.x*(maxSize-minSize));\n    float area = size*size;\n    float rate = 1.6;\n    vec2 mosPos = floor(relMouse.xy*size);\n    float mousesnake = -superLogicSnake(mosPos,size)-1.0;\n    if( uv.x < 0.0){\n        float pct = 1.0 - abs(uv.y-size_rate_time.x)*50.0;\n        \n        col = vec3(.6*pct,1.0*pct,0.0);\n    }\n    else if(uv.x > 1.0){\n        float pct = 1.0 - abs(uv.y-size_rate_time.y)*50.0;\n\n        col = vec3(0.75*pct,0.6*pct,0.0);\n    }\n    else{\n        vec2 tilePos = floor(uv*size);\n        float snake = superLogicSnake(tilePos,size);\n        float time = floor(size_rate_time.z*rate*size);\n        snake = mod(snake-time+mousesnake, area)/(area-1.0);\n        col = vec3(pal(snake, vec3(-0.672, 0.728, 0.098),vec3(1.418, -0.381, 0.198),\n                              vec3(1.568, 2.588, 1.000), vec3(0.008, 0.838, 0.667)));\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* Took and modified code for common variables from \n        https://www.shadertoy.com/view/tdGBDG\n   \n*/\nconst ivec2 COMMON_SIZE_RATE_TIME = ivec2(0, 0);\n\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (storeData(fragCoord, COMMON_SIZE_RATE_TIME)) {\n        fragColor = vec4(0.15, 0.15, 0.5, 1.0); // Initial value\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, COMMON_SIZE_RATE_TIME)) {\n            fragColor = fetchData(iChannel0, COMMON_SIZE_RATE_TIME); // Load value from previous frame\n\n            // Update:\n            if (iMouse.z > 0.0) {\n            \n                float x = (iMouse.x - 0.5*(iResolution.x-iResolution.y))/iResolution.y;\n                if( x < 0.0) {\n                    fragColor.x = (iMouse.y-1.0)/iResolution.y;\n                    fragColor.z += iTimeDelta*(0.1+3.0*fragColor.y);\n                }\n                else if(x > 1.0){\n                    fragColor.y = (iMouse.y-1.0)/iResolution.y;\n                    fragColor.z += iTimeDelta*(0.1+3.0*fragColor.y);\n                }\n                else{\n                    if(fragColor.w == 1.0){\n                        fragColor.z = 0.0;\n                        fragColor.w = 0.0;\n                    }\n                    else{\n                        fragColor.z += iTimeDelta*(0.1+3.0*fragColor.y);;\n                    }\n                }\n            }\n\n            else {\n                // Otherwise fade back to blue\n                fragColor.w = 1.0;\n                fragColor.z +=iTimeDelta*(0.1+3.0*fragColor.y);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 87, 87, 404], [406, 406, 474, 474, 517], [519, 519, 576, 576, 1908]], "test": "untested"}
{"id": "DlSfDz", "name": "Path Tracing v1", "author": "FrederickAmpsUp", "description": "A GLSL port of a C path tracer I wrote a while back\nNew and \"improved\" version: https://www.shadertoy.com/view/mtSBDw", "tags": ["raytracer", "sphere", "pathtracer"], "likes": 8, "viewed": 289, "published": 3, "date": "1693934426", "time_retrieved": "2024-07-30T17:35:24.608834", "image_code": "//#define RETRO\n\nvec3 nonlocalDenoise(vec2 fragTexCoord, sampler2D img, float sigma, int patchSize) {\n    vec2 texelSize = 1.0 / vec2(textureSize(img, 0));\n\n    vec3 centralColor = texture(img, fragTexCoord).rgb;\n    vec3 denoisedColor = vec3(0.0);\n\n    float totalWeight = 0.0;\n\n    for (int i = -patchSize; i <= patchSize; i++) {\n        for (int j = -patchSize; j <= patchSize; j++) {\n            vec2 offset = vec2(float(i), float(j)) * texelSize;\n            vec3 neighborColor = texture(img, fragTexCoord + offset).rgb;\n\n            // Compute the similarity between centralColor and neighborColor\n            float similarity = exp(-dot(centralColor - neighborColor, centralColor - neighborColor) / (2.0 * sigma * sigma));\n\n            denoisedColor += similarity * neighborColor;\n            totalWeight += similarity;\n        }\n    }\n\n    denoisedColor /= totalWeight;\n\n    return denoisedColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = round(fragCoord/iResolution.xy * 100.0) / 100.0;\n#ifndef RETRO\n    uv = fragCoord/iResolution.xy;\n#endif\n    vec4 texColor;\n    if (texture(iChannel2, vec2(32.0 / float(textureSize(iChannel2, 0).x), 0.0)).x == 0.0) {\n        texColor = vec4(nonlocalDenoise(uv, iChannel0, 0.1, 10), 1.0);\n    } else {\n        texColor = texture(iChannel0, uv);\n    }\n    \n    fragColor = texColor;\n    fragColor = vec4(flim(fragColor.rgb, 0.), 1.0);\n#ifdef RETRO\n    fragColor.r = round(fragColor.r * 8.0) / 8.0;\n    fragColor.g = round(fragColor.g * 8.0) / 8.0;\n    fragColor.b = round(fragColor.b * 4.0) / 4.0;\n#endif\n\n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Material {\n    vec3 color;\n    vec3 emission;\n    \n    float diffuse;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    \n    Material mat;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\nstruct RayHit {\n    bool hit;\n\n    vec3 position;\n    vec3 normal;\n\n    Sphere object;\n};\n\n#define RAY_MISS RayHit (false, vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), Sphere(vec3(0.0), 0.0, Material(vec3(0.0),vec3(0.0),0.0)))\n#define MAX_BOUNCES 5\n\n#define DOF_BLUR 0.1\n\n#define DOF_DEPTH 1.0\n#define SCENE_SIZE  9\n\nSphere SCENE[SCENE_SIZE] = Sphere[SCENE_SIZE](\n    Sphere(vec3(0.5, -0.2, 1.0), 0.3, Material(vec3(1.0, 1.0, 1.0), vec3(0.0), 1.0)),\n    Sphere(vec3(-0.5, -0.2, 1.2), 0.3, Material(vec3(0.8, 0.8, 0.8), vec3(0.0), 0.0)),\n    Sphere(vec3(0.3, -0.2, 1.3), 0.3, Material(vec3(0.0, 0.0, 0.0), vec3(5.0, 5.0, 5.0), 0.5)),\n    Sphere(vec3(0.0, -9999.5, 0.0), 9999.0, Material(vec3(1.0, 1.0, 1.0), vec3(0.0), 1.0)),\n    Sphere(vec3(10000.0, 0.0, 0.0), 9999.0, Material(vec3(0.0, 0.0, 1.0), vec3(0.0), 0.5)),\n    Sphere(vec3(-10000.0, 0.0, 0.0), 9999.0, Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 0.9)),\n    Sphere(vec3(0.0, 0.0, 10000.5), 9999.0, Material(vec3(1.0, 0.0, 0.0), vec3(0.0), 0.5)),\n    Sphere(vec3(0.0, 0.0, -10000.5), 9999.0, Material(vec3(1.0, 1.0, 1.0), vec3(0.0), 1.0)),\n    Sphere(vec3(0.0, 10000.0, 0.0), 9999.0, Material(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 1.0))\n);\n\n#define ANTIALIAS_BLUR 0.002\n\nfloat state = 0.0;\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453) * 2.0 - 1.0; }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n#define EYE vec3(0.0, 0.0, 0.2)\n\n\nRay camera_ray(vec2 uv, vec3 cam_dir) {\n    vec3 eye = vec3(EYE.x + rand(uv * float(++state)) * DOF_BLUR, EYE.y + rand(uv * float(++state)) * DOF_BLUR, EYE.z);\n    \n    vec3 screen_plane = vec3(uv + ANTIALIAS_BLUR * vec2(rand(uv * float(++state)),rand(uv * float(++state))), 1.0) + EYE;\n    vec3 focus_plane = screen_plane * DOF_DEPTH;\n    Ray ret = Ray( eye, normalize(focus_plane - eye) );\n    return ret;\n}\n\n\n/*\n\n * Generates a camera ray.\n * UV is normalized in the range [-1, 1].\n * Euler is the camera direction in radian euler angles.\n\n */\n/*\nvec3 project(vec2 uv, vec3 axis, vec3 angle) {\n    vec2 screen_center_xz = vec2(cos(angle.y), sin(angle.y));\n    float screen_center_dist_y_axis = cos(angle.x) + cos(angle.z);\n    screen_center_xz *= screen_center_dist_y_axis;\n\n    vec3 screen_center = normalize(vec3(screen_center_xz.x, sin(angle.x) + sin(angle.z), screen_center_xz.y));\n    return screen_center + vec3(uv, 0.0);\n}\n\nRay camera_ray(vec2 uv, vec3 euler) {\n    vec2 antialias_offset = vec2(rand(uv * float(++state)), rand(uv * float(++state))) * ANTIALIAS_BLUR;\n    uv += antialias_offset;\n    \n    vec3 eye = EYE;\n    \n    vec3 screen_pos = project(uv, eye, euler);\n    \n    Ray ret;\n    ret.origin = eye;\n    ret.direction = normalize(screen_pos - eye);\n    \n    return ret;\n}\n*/\nfloat intersect_sphere(Sphere obj, Ray r) {\n    vec3 oc = r.origin - obj.center;\n    if (length(oc) < obj.radius) return -1.0;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc, oc) - obj.radius*obj.radius;\n    float discriminant = half_b*half_b - a*c;\n\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-half_b - sqrt(discriminant)) / a;\n    }\n}\n\nRayHit scene_intersect(Ray ray) {\n    float min_dist = float(1.0e38);\n\n    Sphere obj;\n    Sphere closest;\n    float dist;\n    for (uint i = uint(0); i < uint(SCENE_SIZE); ++i) {\n        obj = SCENE[i];\n        dist = intersect_sphere(obj, ray);\n\n        if (dist > 0.0 && dist < min_dist) {\n            min_dist = dist;\n            closest = obj;\n        }\n    }\n    if (min_dist == float(1.0e38)) return RAY_MISS;\n\n    vec3 position =  ray.origin + ray.direction * min_dist;\n    RayHit ret = RayHit( true, position, normalize(position - closest.center), closest );\n\n    return ret;\n}\n\nvec3 v_lerp(vec3 v1, vec3 v2, float t) {\n    return (v2 - v1) * t + v1;\n}\n\nvec3 rand_hemis_dir(vec3 dir) {\n    vec3 rand_dir = normalize(vec3(rand(dir * float(++state)), rand(dir * float(++state)), rand(dir * float(++state))));\n    return rand_dir * (sign(dot(dir, rand_dir)) * 2.0 - 1.0);\n}\n\nvoid init_state(float time) {\n    state = time;\n}\n\nfloat clip(float x, float a, float b) {\n    if (x < a) return a;\n    if (x > b) return b;\n               return x;\n}\n\n#define SUN vec3(1.0, 0.7, 1.0)\n\nvec3 sky_color(vec3 direction) {\n    vec3 sky_blue = vec3(0.380, 0.769, 0.961);\n\n    float sun = pow(clamp(dot(direction, normalize(SUN)), 0.0, 1.0), 500.0) * 100.0;\n    vec3 sunCol = vec3(sun, sun * 0.9, 0.0);\n\n    vec3 ret = sky_blue + sunCol;\n\n    return ret;\n}\n\n\nvec3 ray_shader(Ray ray, uint x, uint y) {\n    vec3 color = vec3(1.0);\n    vec3 light = vec3(0.0);\n\n    for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n        RayHit intersect = scene_intersect(ray);\n        if (!intersect.hit) {\n            vec3 sky = sky_color(ray.direction);\n            light = light + sky * color;\n            break;\n        };\n\n        Material mat;\n        mat = intersect.object.mat;\n        \n        light = light + mat.emission * color;\n        color = color * mat.color;\n\n        ray.origin = intersect.position + intersect.normal * 0.001;\n        ray.direction = v_lerp(reflect(ray.direction, intersect.normal), normalize(intersect.normal + normalize(vec3(rand(float(++state)), rand(float(++state)), rand(float(++state))))), mat.diffuse);\n    }\n    return light;\n}\n\n#define flim(x,y) flim_transform(iChannel1,x,y)\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float pe = 4.3; const vec3 fpff = vec3(1); const float fpffs = 0.;\nconst float egr = 1.05; const float egg = 1.12; const float egb = 1.045;\nconst float grr = .5; const float ggr = 2.; const float gbr = .1;\nconst float grm = 1.; const float ggm = 1.; const float gbm = 1.; const float flsi = -10.;\nconst float flsa = 22.; const float fsx = .44; const float fsy = .28;\nconst float fssx = .591; const float fssy = .779; const float fe = 6.;\nconst float fd = 5.; const vec3 pb = vec3(1); const float pfe = 6.;\nconst float pfd = 27.5; const float bp = -1.; const vec3 pff = vec3(1);\nconst float pffs = 0.; const float ms = 1.02;\nfloat wrap(float i, float s, float e){return s + mod(i - s, e - s);}\nfloat lerp(float a, float b, float t){return a + t * (b - a);}\nvec3 lerp(vec3 a, vec3 b, float t){return a + t * (b - a);}\nfloat mrc(float i, float is, float ie, float os, float oe){\n    float t = clamp((i - is) / (ie - is), 0., 1.);\n    float v = os + t * (oe - os);\n    return v; }\nvec3 rth(vec3 rgb){\n    float ca, ci, h, s, v, cd;\n    vec3 c;\n    ca = max(rgb[0], max(rgb[1], rgb[2]));\n    ci = min(rgb[0], min(rgb[1], rgb[2]));\n    cd = ca - ci;\n    v = ca;\n    if (ca != 0.) s = cd / ca;\n    else s = 0.0; h = 0.0;\n    if (s == 0.) h = 0.0; \n    else{\n        c = (vec3(ca) - rgb.xyz) / cd;\n\n        if (rgb.x == ca) h = c[2] - c[1];\n        else if (rgb.y == ca) h = 2.+ c[0] - c[2];\n        else h = 4.+ c[1] - c[0];\n        h /= 6.0;\n        if (h < 0.) h += 1.0; }\n    return vec3(h, s, v); }\nvec3 htr(vec3 hsv){\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n    if (s == 0.) rgb = vec3(v, v, v);\n    else {\n        if (h == 1.) h = 0.0;\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.- s);\n        q = v * (1.- (s * f));\n        t = v * (1.- (s * (1.- f)));\n        if (i == 0.) rgb = vec3(v, t, p);\n        else if (i == 1.) rgb = vec3(q, v, p);\n        else if (i == 2.) rgb = vec3(p, v, t);\n        else if (i == 3.) rgb = vec3(p, q, v);\n        else if (i == 4.) rgb = vec3(t, p, v);\n        else rgb = vec3(v, p, q); }\n    return rgb; }\nvec3 bhs(vec3 col, float hue, float sat, float value){\n    vec3 hsv = rth(col);\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n    return htr(hsv); }\nfloat rgb_avg(vec3 i){\n    return (i.x + i.y + i.z) / 3.0; }\nfloat rgb_sum(vec3 i){\n    return i.x + i.y + i.z; }\nfloat rgb_max(vec3 i){\n    return max(max(i.x, i.y), i.z); }\nfloat rgb_min(vec3 i){\n    return min(min(i.x, i.y), i.z); }\nvec3 uo(vec3 i, float bp, float wp){\n    float mono = rgb_avg(i);\n    float mono2 = mrc(mono, bp / 1000., 1.- (wp / 1000.), 0., 1.);\n    return i * (mono2 / mono); }\n// https://www.desmos.com/calculator/khkztixyeu\nfloat ss(float i, float tx, float ty, float sx, float sy){\n    i = clamp(i, 0., 1.);\n    tx = clamp(tx, 0., 1.);\n    ty = clamp(ty, 0., 1.);\n    sx = clamp(sx, 0., 1.);\n    sy = clamp(sy, 0., 1.);\n    float slope = (sy - ty) / (sx - tx);\n    if (i < tx){\n        float toe_pow = slope * tx / ty;\n        return ty * pow(i / tx, toe_pow); }\n    if (i < sx){\n        float intercept = ty - (slope * tx);\n        return slope * i + intercept; }\n    float shoulder_pow = -slope / (((sx - 1.) / pow(1.- sx, 2.)) * (1.- sy));\n    return (1.- pow(1.- (i - sx) / (1.- sx), shoulder_pow)) * (1.- sy) + sy; }\nfloat dmf(float mono, float max_density){\n    float offset = pow(2., flsi);\n    float fac = mrc(log2(mono + offset), flsi, flsa, 0., 1.);\n    fac = ss(fac, fsx, fsy, fssx, fssy);\n    fac *= max_density;\n    fac = pow(2., -fac);\n    return clamp(fac, 0., 1.); }\nvec3 cl(vec3 i, vec3 sensitivity_tone, vec3 dye_tone, float max_density){\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n    float mono = dot(i, sensitivity_tone_norm);\n    float mixFac = dmf(mono, max_density);\n    return lerp(dye_tone_norm, vec3(1.), mixFac); }\nvec3 rgbd(vec3 i, float e, float max_density){\n    i *= pow(2., e);\n    vec3 result = cl(i, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n    result *= cl(i, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n    result *= cl(i, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n    return result; }\nvec3 emr(float ph, float s, float r, float m){\n    vec3 result = htr(vec3(wrap(ph + (r / 360.), 0., 1.), 1./ s, 1.));\n    result /= rgb_sum(result);\n    result *= m;\n    return result; }\nmat3 gem(float rs,float gs,float bs,float rr,float gr, float br, float rm, float gm, float bm){\n    mat3 m;\n    m[0] = emr(0., rs, rr, rm);\n    m[1] = emr(1./ 3., gs, gr, gm);\n    m[2] = emr(2./ 3., bs, br, bm);\n    return m; }\nvec3 nap(vec3 i, vec3 bex){\n    i = rgbd(i, fe, fd);\n    i *= bex;\n    i = rgbd(i, pfe, pfd);\n    return i; }\nbool flm(sampler2D mc, out mat3 em, out mat3 emi){\n    const float valid_w = 2.0;\n    vec4 row;\n    row = texelFetch(mc, ivec2(0, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(1, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(2, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[2] = row.xyz;\n    row = texelFetch(mc, ivec2(3, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(4, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(5, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[2] = row.xyz;\n    return true; }\nvec3 flim_transform(sampler2D mc, vec3 i, float e){\n    i = max(i, 0.);\n    i *= pow(2., pe + e);\n    i = min(i, 5000.);\n    mat3 em, emi;\n    if (!flm(mc, em, emi)){ return vec3(1, 0, 1); }\n    vec3 bex = pb * em;\n    const float big = 10000000.0;\n    vec3 white_cap = nap(vec3(big, big, big), bex);\n    i = lerp(i, i * fpff, fpffs);\n    i *= em;\n    i = nap(i, bex);\n    i *= emi;\n    i = max(i, 0.);\n    i /= white_cap;\n    if (bp == -1.){\n        vec3 black_cap = nap(vec3(0.), bex);\n        black_cap /= white_cap;\n        i = uo(i, rgb_avg(black_cap) * 1000., 0.);\n    }else{ i = uo(i, bp, 0.); }\n    i = lerp(i, i * pff, pffs);\n    i = clamp(i, 0., 1.);\n    float mono = rgb_avg(i);\n    float mixFac = (mono < 0.5) ? mrc(mono, 0.05, 0.5, 0., 1.) : mrc(mono, 0.5, 0.95, 1., 0.);\n    i = lerp(i, bhs(i, 0.5, ms, 1.), mixFac);\n    i = clamp(i, 0., 1.);\n    i = pow(i, vec3(1./ 2.2));\n    return i; }\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n", "buffer_a_code": "#define SAMPLES float(100)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    \n    init_state(uv.x+2.0*uv.y+iTime);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Ray cam = camera_ray(uv, normalize(vec3(iMouse.x, iMouse.y, 1.0)));\n    Ray cam = camera_ray(uv, vec3(0.0,3.141,0.0));\n    \n    vec3 col = vec3(0.0);\n    float i = 0.0;\n    while (i++ < SAMPLES)\n        col += ray_shader(cam, uint(fragCoord.x), uint(fragCoord.y));\n    \n    fragColor = mix(texture(iChannel0, (fragCoord/iResolution.xy)), vec4(col / SAMPLES, 1.0), 1.0 / float(iFrame + 1));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 O, in vec2 U){\n    const float w = 2.0;\n    if (ivec2(U).x > 5 || ivec2(U).y > 0)\n        return;\n    vec4 p = texelFetch(iChannel0, ivec2(U), 0);\n    O = p;\n    bool n = (p.w != w) || (iTime == 0.0) || (iFrame < 1);\n    if (!n)\n        return;\n    mat3 e = gem(egr,egg,egb,grr,ggr,gbr,grm,ggm,gbm);\n    mat3 ei = inverse(e);\n    if (ivec2(U) == ivec2(0, 0)) {\n        O = vec4(e[0], w);\n    } if (ivec2(U) == ivec2(1, 0)) {\n        O = vec4(e[1], w);\n    } if (ivec2(U) == ivec2(2, 0)) {\n        O = vec4(e[2], w);\n    }\n    if (ivec2(U) == ivec2(3, 0)) {\n        O = vec4(ei[0], w);\n    } if (ivec2(U) == ivec2(4, 0)) {\n        O = vec4(ei[1], w);\n    } if (ivec2(U) == ivec2(5, 0)) {\n        O = vec4(ei[2], w);\n    }}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 101, 101, 906], [908, 908, 965, 1015, 1640]], "test": "untested"}
{"id": "cl2fWR", "name": "Finite Source", "author": "wyatt", "description": "Integral over a square source of uniform current (left)\nIntegral over a square source of uniform magnetic moment (right)", "tags": ["field", "magnetic", "em"], "likes": 22, "viewed": 433, "published": 3, "date": "1693933428", "time_retrieved": "2024-07-30T17:35:25.372792", "image_code": "vec2 point_source (vec2 u, vec2 m) {\n    return 4.*normalize(u)*dot(m,normalize(u))/dot(u,u)-2.*m/dot(u,u);\n}\nMain {\n\n        vec2 H = \n            integral(U.x-.3*R.x,U.y-.5*R.y,.05*R.x)/300. + \n            integral(U.x-.7*R.x,U.y-.5*R.y,0.,-1.,.05*R.x)/10.;\n        \n        H.xy += 100.*point_source(U-.5*R,vec2(0.,-1.));\n        Q = clamp(.7+vec4(H.x,H.x+H.y,H.y,0),0.,1.)*(.7-\n                .25*smoothstep(120.*fwidth(H.x),0.,abs(sin(H.x*100.)))-\n                .25*smoothstep(120.*fwidth(H.y),0.,abs(sin(H.y*100.)))+\n                .5*smoothstep(80.*fwidth(length(H.xy)),0.,abs(sin(length(H.xy)*60.))));\n    \n    \n        //Q = vec4(0);\n        //Q.xy = .001*charge(U.x-.5*R.x,U.y-.5*R.y,100.,100.);\n    //Q.xy = H;\n}", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\n\nvec2 integral (float X, float Y, float d) {\n    \n    return vec2(\n    \n        ( -.5*(d+X)*log((+d-Y)*(+d-Y)+(d+X)*(d+X))\n          -.5*(d-X)*log((+d-Y)*(+d-Y)+(d-X)*(d-X))\n          -(+d-Y)*(atan((d+X)/(+d-Y))+atan((d-X)/(+d-Y)))\n        )\n           \n          -\n          \n        ( -.5*(d+X)*log((-d-Y)*(-d-Y)+(d+X)*(d+X))\n          -.5*(d-X)*log((-d-Y)*(-d-Y)+(d-X)*(d-X))\n          -(-d-Y)*(atan((d+X)/(-d-Y))+atan((d-X)/(-d-Y)))\n        )\n        \n          ,\n          \n          \n        ( -.5*(+d-Y)*log((+d-Y)*(+d-Y)+(d+X)*(d+X))\n          +.5*(+d-Y)*log((+d-Y)*(+d-Y)+(d-X)*(d-X))\n          -(d+X)*atan((+d-Y)/(d+X))+(d-X)*atan((+d-Y)/(d-X))\n        )\n           \n          -\n          \n        ( -.5*(-d-Y)*log((-d-Y)*(-d-Y)+(d+X)*(d+X))\n          +.5*(-d-Y)*log((-d-Y)*(-d-Y)+(d-X)*(d-X))\n          -(d+X)*atan((-d-Y)/(d+X))+(d-X)*atan((-d-Y)/(d-X))\n        )\n    \n    );\n\n}\n\n\n\n\n\nvec2 integral (float X, float Y, float A, float B, float d) {\n    \n    return vec2 (\n        (\n            (B*log((-d-Y)*(-d-Y)+(+d-X)*(+d-X))+2.*A*atan((+d-X)/(-d-Y))) - \n            (B*log((-d-Y)*(-d-Y)+(-d-X)*(-d-X))+2.*A*atan((-d-X)/(-d-Y)))\n        ) - (\n            (B*log((+d-Y)*(+d-Y)+(+d-X)*(+d-X))+2.*A*atan((+d-X)/(+d-Y))) - \n            (B*log((+d-Y)*(+d-Y)+(-d-X)*(-d-X))+2.*A*atan((-d-X)/(+d-Y)))\n        )  , \n         (\n            (A*log((+d-Y)*(+d-Y)+(-d-X)*(-d-X))+2.*B*atan((+d-Y)/(-d-X))) - \n            (A*log((-d-Y)*(-d-Y)+(-d-X)*(-d-X))+2.*B*atan((-d-Y)/(-d-X)))\n        ) - (\n            (A*log((+d-Y)*(+d-Y)+(+d-X)*(+d-X))+2.*B*atan((+d-Y)/(+d-X))) - \n            (A*log((-d-Y)*(-d-Y)+(+d-X)*(+d-X))+2.*B*atan((-d-Y)/(+d-X)))\n        )\n    );\n\n}\n\nvec2 integral (vec2 r, vec2 _00, vec2 _01, vec2 _10, vec2 _11, float A, float B) {\n    \n    return vec2 (\n        (\n            (B*log((_11.y-r.y)*(_11.y-r.y)+(_11.x-r.x)*(_11.x-r.x))+2.*A*atan((_11.x-r.x)/(_11.y-r.y))) - \n            (B*log((_01.y-r.y)*(_01.y-r.y)+(_01.x-r.x)*(_01.x-r.x))+2.*A*atan((_01.x-r.x)/(_01.y-r.y)))\n        ) - (\n            (B*log((_10.y-r.y)*(_10.y-r.y)+(_10.x-r.x)*(_10.x-r.x))+2.*A*atan((_10.x-r.x)/(_10.y-r.y))) - \n            (B*log((_00.y-r.y)*(_00.y-r.y)+(_00.x-r.x)*(_00.x-r.x))+2.*A*atan((_00.x-r.x)/(_00.y-r.y)))\n        ) , \n         (\n            (A*log((_11.y-r.y)*(_11.y-r.y)+(_11.x-r.x)*(_11.x-r.x))+2.*B*atan((_11.y-r.y)/(_11.x-r.x))) - \n            (A*log((_01.y-r.y)*(_01.y-r.y)+(_01.x-r.x)*(_01.x-r.x))+2.*B*atan((_01.y-r.y)/(_01.x-r.x)))\n        ) - (\n            (A*log((_10.y-r.y)*(_10.y-r.y)+(_10.x-r.x)*(_10.x-r.x))+2.*B*atan((_10.y-r.y)/(_10.x-r.x))) - \n            (A*log((_00.y-r.y)*(_00.y-r.y)+(_00.x-r.x)*(_00.x-r.x))+2.*B*atan((_00.y-r.y)/(_00.x-r.x)))\n        ) \n    );\n\n}\n\n\n\nvec2 charge (float X, float Y, float x, float y) {\n\n    return vec2 (\n        \n        (\n           (+y+(X- +x)*atan((Y- +y)/(X- +x)) + .5*(Y- +y)*log((X- +x)*(X- +x)+(Y- +y)*(Y- +y))) - \n           (-y+(X- +x)*atan((Y- -y)/(X- +x)) + .5*(Y- -y)*log((X- +x)*(X- +x)+(Y- -y)*(Y- -y))) \n        ) - (\n           (+y+(X- -x)*atan((Y- +y)/(X- -x)) + .5*(Y- +y)*log((X- -x)*(X- -x)+(Y- +y)*(Y- +y))) - \n           (-y+(X- -x)*atan((Y- -y)/(X- -x)) + .5*(Y- -y)*log((X- -x)*(X- -x)+(Y- -y)*(Y- -y))) \n        ) ,\n        (\n           (+x+(Y- +y)*atan((X- +x)/(Y- +y)) + .5*(X- +x)*log((X- +x)*(X- +x)+(Y- +y)*(Y- +y))) - \n           (-x+(Y- +y)*atan((X- -x)/(Y- +y)) + .5*(X- -x)*log((X- -x)*(X- -x)+(Y- +y)*(Y- +y))) \n        ) - (\n           (+x+(Y- -y)*atan((X- +x)/(Y- -y)) + .5*(X- +x)*log((X- +x)*(X- +x)+(Y- -y)*(Y- -y))) - \n           (-x+(Y- -y)*atan((X- -x)/(Y- -y)) + .5*(X- -x)*log((X- -x)*(X- -x)+(Y- -y)*(Y- -y))) \n        )\n    \n    \n    );\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2fWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 109]], "test": "untested"}
{"id": "dtBfWz", "name": "laplacian of gaussian", "author": "Zi7ar21", "description": "asdf test", "tags": ["log"], "likes": 1, "viewed": 173, "published": 3, "date": "1693932828", "time_retrieved": "2024-07-30T17:35:26.151709", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n    fragColor = texture(iChannel3, fragCoord/iResolution.xy);\n\n    /*\n    fragColor.rgb =\n    (  -1.0/560.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(4, 0), 0).rgb+\n    (   8.0/315.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(3, 0), 0).rgb+\n    (  -1.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(2, 0), 0).rgb+\n    (   8.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(1, 0), 0).rgb+\n    (-205.0/ 72.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, 0), 0).rgb+\n    (   8.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(1, 0), 0).rgb+\n    (  -1.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(2, 0), 0).rgb+\n    (   8.0/315.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(3, 0), 0).rgb+\n    (  -1.0/560.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(4, 0), 0).rgb+\n    (  -1.0/560.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(0, 4), 0).rgb+\n    (   8.0/315.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(0, 3), 0).rgb+\n    (  -1.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(0, 2), 0).rgb+\n    (   8.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)-ivec2(0, 1), 0).rgb+\n    (-205.0/ 72.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, 0), 0).rgb+\n    (   8.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, 1), 0).rgb+\n    (  -1.0/  5.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, 2), 0).rgb+\n    (   8.0/315.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, 3), 0).rgb+\n    (  -1.0/560.0)*texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, 4), 0).rgb;\n    */\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sigma 1.0\n\n#define PI 3.1415926535\n\nfloat LoG(float x, float y) {\n    float r2 = x*x+y*y;\n    return (1.0/(PI*sigma*sigma*sigma*sigma))*(1.0-(r2/(2.0*sigma*sigma)))*exp(-r2/(2.0*sigma*sigma));\n}\n\nfloat g(float x) {\n    return (1.0/(2.506628274631000502415765284811045253006986740609938316629923576*sigma))*exp(-(x*x)/(2.0*sigma*sigma));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texture(iChannel0, fragCoord/iResolution.xy).rgb, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n\n    for(int i = -9; i <= 9; i++) {\n        fragColor += g(float(i))*vec4(texelFetch(iChannel0, ivec2(fragCoord)+ivec2(i, 0), 0).rgb, 1.0);\n    }\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n\n    for(int i = -9; i <= 9; i++) {\n        fragColor += g(float(i))*vec4(texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, i), 0).rgb, 1.0);\n    }\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n\n    for(int i = -7; i <= 7; i++) {\n        for(int j = -7; j <= 7; j++) {\n            fragColor += -LoG(float(i),float(j))*vec4(texelFetch(iChannel0, ivec2(fragCoord)+ivec2(i, j), 0).rgb, 1.0);\n        }\n    }\n\n    //fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1762]], "test": "untested"}
{"id": "dtBfDz", "name": "Circular Button.", "author": "ianbryant", "description": "Just a quick mod on jonobr1's circle shader to make it look like a button.", "tags": ["circle", "button"], "likes": 5, "viewed": 171, "published": 3, "date": "1693930738", "time_retrieved": "2024-07-30T17:35:26.937608", "image_code": "/**\n   Original circle shader author:\n * @author jonobr1 / http://jonobr1.com/\n */\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(d>-0.1*rad ? color+dot(normalize(uv-pos),vec2(-1,1))*vec3(0.1,0.1,0.1) : color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 130, 167, 167, 216], [218, 297, 352, 352, 523], [525, 525, 582, 582, 924]], "test": "untested"}
{"id": "mlSfWR", "name": "Wind Walker Mechanics", "author": "dr2", "description": "Wind walkers with chain drive; mouse selects view, rotates and zooms", "tags": ["chain", "strandbeest", "linkage"], "likes": 35, "viewed": 384, "published": 3, "date": "1693923749", "time_retrieved": "2024-07-30T17:35:27.890061", "image_code": "// \"Wind Walker Mechanics\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  One or more wind walkers (from \"Wind Walker\" and \"Wind Walker Herd\")\n  with added chain drive.\n  Leg from the Strandbeest, with partly reversed direction:\n  see https://en.wikipedia.org/wiki/Jansen's_linkage\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir, qHit, lBase;\nvec2 cId;\nfloat tCur, dstFar, bGrid, grLim, wlkSpd, wlkScl, vAxHt, chnEl;\nint nFrame, idObj;\nconst int idBas = 1, idLnkT = 2, idLnk = 3, idAx = 4, idWhl = 5, idVane = 6, idStruc = 7,\n   idGrnd = 8, idSprk = 11, idPin = 12, idPlt = 13;\nconst float s_a = 38.0, s_b = 41.5, s_c = 39.3, s_d = 40.1, s_e = 55.8, s_f = 39.4,\n   s_g = 36.7, s_h = 65.7, s_i = 49.0, s_j = 50.0, s_k = 61.9, s_l = 7.8, s_m = 15.0;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nstruct Leg {\n  vec2 v[8], cs[10], cswAng;\n  float wAng;\n};\nstruct Walker {\n  Leg leg[2];\n  vec2 csVane;\n  float szFac;\n};\nWalker wlk;\n\n#define ACOSR(x, y, z) acos (((x) * (x) + (y) * (y) - (z) * (z)) / (2. * (x) * (y)))\n#define ATANV(v) atan ((v).y, (v).x)\n\nvoid ObjState ()\n{ //  (Leg from the Strandbeest: see https://en.wikipedia.org/wiki/Jansen's_linkage)\n  float a[10], aa, g, s, t;\n  wlk.szFac = wlkScl / (1. + 0.3 * Maxv2 (abs (cId)));\n  t = tCur * wlkScl / wlk.szFac;\n  wlk.leg[0].wAng = - wlkSpd * t;\n  wlk.leg[1].wAng = wlk.leg[0].wAng + pi;\n  for (int k = 0; k < 2; k ++) {\n    wlk.leg[k].v[0] = vec2 (0., 0.);\n    wlk.leg[k].v[1] = wlk.leg[k].v[0] + vec2 (s_a, s_l);\n    wlk.leg[k].v[2] = wlk.leg[k].v[1] + Rot2D (vec2 (s_m, 0.), wlk.leg[k].wAng);\n    aa = ATANV (wlk.leg[k].v[2] - wlk.leg[k].v[0]);\n    s = length (wlk.leg[k].v[2] - wlk.leg[k].v[0]);\n    a[0] = aa + ACOSR (s, s_b, s_j);\n    wlk.leg[k].v[3] = wlk.leg[k].v[0] + Rot2D (vec2 (s_b, 0.), a[0]);\n    a[1] = aa - ACOSR (s, s_c, s_k);\n    wlk.leg[k].v[4] = wlk.leg[k].v[0] + Rot2D (vec2 (s_c, 0.), a[1]);\n    a[2] = ACOSR (s_b, s_d, s_e) + a[0];\n    wlk.leg[k].v[5] = wlk.leg[k].v[0] + Rot2D (vec2 (s_d, 0.), a[2]);\n    s = length (wlk.leg[k].v[5] - wlk.leg[k].v[4]);\n    g = ACOSR (s, s_c, s_d) + ACOSR (s, s_g, s_f) + pi + a[1];\n    wlk.leg[k].v[6] = wlk.leg[k].v[4] + Rot2D (vec2 (s_g, 0.), g);\n    wlk.leg[k].v[7] = wlk.leg[k].v[4] + Rot2D (vec2 (s_i, 0.), g + ACOSR (s_g, s_i, s_h));\n    a[3] = ACOSR (s_d, s_e, s_b) + a[2] - pi;\n    a[4] = ATANV (wlk.leg[k].v[4] - wlk.leg[k].v[6]);\n    a[5] = ATANV (wlk.leg[k].v[5] - wlk.leg[k].v[6]);\n    a[6] = ATANV (wlk.leg[k].v[7] - wlk.leg[k].v[6]);\n    a[7] = ATANV (wlk.leg[k].v[7] - wlk.leg[k].v[4]);\n    a[8] = ATANV (wlk.leg[k].v[3] - wlk.leg[k].v[2]);\n    a[9] = ATANV (wlk.leg[k].v[4] - wlk.leg[k].v[2]);\n    for (int m = 0; m < 10; m ++) wlk.leg[k].cs[m] = CosSin (- a[m]);\n    wlk.leg[k].cswAng = CosSin (- wlk.leg[k].wAng);\n  }\n  wlk.csVane = CosSin (4. * t);\n  chnEl = atan (vAxHt - s_l, - lBase.x);\n}\n\nvoid LinkDf (vec3 p, vec2 v, vec2 cs, float l, int id, inout float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xy = Rot2Cs (q.xy - v, cs);\n  d = max (PrCaps2Df (q.yx - vec2 (0., 0.5 * l), 2., 0.5 * l), abs (q.z) - 0.5);\n  DMINQ (id);\n}\n\nfloat ChainDf (vec3 p, float aRot, float wgFac, float dMin)\n{\n  vec3 q, sp;\n  float d, wlRad, cRad, cLen, nTh, nSp, wlThk, lnkLen, lnkWid, lnkThk, wlGap, bx, by, ds, a, r;\n  wlRad = 1.;\n  cRad = 0.04;\n  nTh = 32.;\n  nSp = 6.;\n  wlThk = 0.05;\n  lnkLen = 2. * pi * wlRad / nTh;\n  lnkWid = 1.4 * cRad;\n  lnkThk = 0.15 * wlThk;\n  wlGap = wgFac * lnkLen;\n  cLen = 1.9 * wlThk;\n  sp.xz = sign (p.xz);\n  bx = wlGap - abs (p.x);\n  q = p;\n  q.x = abs (q.x) - wlGap;\n  q.xz = Rot2D (q.xz, aRot * sp.x);\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  d = min (max (abs (r - 0.96 * wlRad) - 0.09 * wlRad, abs (q.y) - wlThk),\n     max (r - 0.25 * wlRad, abs (q.y) - 1.5 * wlThk));\n  d = min (d, max (PrBox2Df (vec2 (dot (q.xz, sin (2. * pi * floor (nSp * a + 0.5) / nSp +\n     vec2 (0., 0.5 * pi))), q.y), vec2 (0.05, wlThk)), r - wlRad));\n  q.xz = Rot2D (q.xz, 2. * pi * floor (nTh * a + 0.5) / nTh);\n  d = SmoothMax (d, - PrCaps2Df (vec2 (q.z, q.x + wlRad + 0.1), 0.045, 0.08), 0.01);\n  DMINQ (idSprk);\n  q.x += wlRad;\n  d = max (PrCylDf (q.xzy, cRad, cLen), bx);\n  DMINQ (idPin);\n  q = p;\n  q.xz -= vec2 (aRot * wlRad, wlRad) * sp.z;\n  q.x = mod (q.x + 0.5 * lnkLen, lnkLen) - 0.5 * lnkLen;\n  d = max (PrCylDf (q.xzy, cRad, cLen), - bx);\n  DMINQ (idPin);\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    by = (1.3 + 0.3 * float (k)) * wlThk;\n    ds = 0.5 + float (k);\n    q = p;\n    q.xz -= vec2 (aRot * wlRad + ds * lnkLen, wlRad) * sp.z;\n    q.x = mod (q.x + lnkLen, 2. * lnkLen) - lnkLen;\n    d = max (SmoothMax (PrCaps2Df (q.zx, lnkWid, 0.5 * lnkLen), abs (abs (q.y) - by) - lnkThk, 0.002), - bx);\n    DMINQ (idPlt);\n    q = p;\n    q.x = abs (q.x) - wlGap;\n    q.xz = Rot2D (q.xz, (aRot + ds * 2. * pi / nTh) * sp.x);\n    q.xz = Rot2D (q.xz, 2. * pi * floor (0.5 * nTh * atan (q.z, - q.x) / (2. * pi) + 0.5) / (0.5 * nTh));\n    q.x += wlRad;\n    d = max (SmoothMax (PrCaps2Df (q.xz, lnkWid, 0.5 * lnkLen), abs (abs (q.y) - by) - lnkThk, 0.002), bx);\n    DMINQ (idPlt);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{ // (Based on \"Wind Walker\")\n  vec3 q, ps;\n  float dMin, d, sx, chnSzFac;\n  int kx, kz;\n  p.xz -= bGrid * (cId + 0.5);\n  dMin = dstFar / wlk.szFac;\n  p /= wlk.szFac;\n  p.y -= lBase.y;\n  p.xz = Rot2Cs (p.xz, CosSin (0.25 * pi));\n  p.xz = vec2 (p.z, - p.x);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    kx = k / 2;\n    kz = k - 2 * kx;\n    sx = sign (float (kx) - 0.5);\n    ps = p;\n    ps.z *= (sign (float (kz) - 0.5)) * sx;\n    ps.xz += vec2 (lBase.x * sx, lBase.z);\n    q = ps;\n    q.z -= 4.;\n    q.xy = Rot2Cs (q.xy - wlk.leg[kz].v[1], wlk.leg[kz].cswAng);\n    d = PrCylAnDf (q, s_m, 2., 1.);\n    q.xy = (abs (q.x) > abs (q.y)) ? q.xy : q.yx;\n    d = min (d, max (PrBox2Df (q.xy, vec2 (s_m, 1.8)), abs (q.z) - 0.8));\n    DMINQ (idWhl);\n    for (int j = VAR_ZERO + 2; j <= 7; j ++) {\n      q = ps - vec3 (wlk.leg[kz].v[j], 0.2);\n      d = PrCylDf (q, ((j < 7) ? 1.5 : 2.5), ((j == 2) ? 5. : 3.));\n      DMINQ (idAx);\n    }\n    LinkDf (ps, wlk.leg[kz].v[0], wlk.leg[kz].cs[0], s_b, idLnkT, dMin);\n    LinkDf (ps, wlk.leg[kz].v[0], wlk.leg[kz].cs[2], s_d, idLnkT, dMin);\n    LinkDf (ps, wlk.leg[kz].v[5], wlk.leg[kz].cs[3], s_e, idLnkT, dMin);\n    LinkDf (ps, wlk.leg[kz].v[6], wlk.leg[kz].cs[4], s_g, idLnkT, dMin);\n    LinkDf (ps, wlk.leg[kz].v[6], wlk.leg[kz].cs[6], s_h, idLnkT, dMin);\n    LinkDf (ps, wlk.leg[kz].v[4], wlk.leg[kz].cs[7], s_i, idLnkT, dMin);\n    ps.z -= 1.4;\n    LinkDf (ps, wlk.leg[kz].v[0], wlk.leg[kz].cs[1], s_c, idLnk, dMin);\n    LinkDf (ps, wlk.leg[kz].v[6], wlk.leg[kz].cs[5], s_f, idLnk, dMin);\n    LinkDf (ps, wlk.leg[kz].v[2], wlk.leg[kz].cs[8], s_j, idLnk, dMin);\n    ps.z += 2.8;\n    LinkDf (ps, wlk.leg[kz].v[2], wlk.leg[kz].cs[9], s_k, idLnk, dMin);\n  }\n  q = p;\n  q.x -= 20.;\n  d = max (PrCaps2Df (vec2 (q.y, q.x - 5.), 2.5, lBase.x + 40.), abs (q.z) - lBase.z + 7.);\n  d = max (d, - PrBox2Df (vec2 (abs (q.x + 20. - s_a) - lBase.x, q.z), vec2 (17., 11.)));\n  d = max (d, 3. - length (vec2 (q.y + 5., abs (q.z) - 8.)));\n  DMINQ (idBas);\n  q = p;\n  q.x = abs (q.x) - lBase.x;\n  d = PrCylDf (q, 1.5, lBase.z + 2.);\n  DMINQ (idAx);\n  q = p;\n  q.xy -= vec2 (s_a, s_l);\n  q.x = abs (q.x) - lBase.x;\n  d = PrCylDf (q, 1.5, lBase.z - 2.);\n  DMINQ (idAx);\n  q = p;\n  q.xy -= vec2 (s_a, s_l - 1.5);\n  d = max (PrCaps2Df (q.xy, 4.5, 2.), abs (q.z) - lBase.z + 7.);\n  DMINQ (idStruc);\n  q.x = abs (q.x) - lBase.x;\n  d = max (PrCaps2Df (q.xy, 4.5, 2.), abs (abs (q.z) - 0.55 * lBase.z) - 0.25 * lBase.z);\n  DMINQ (idStruc);\n  q = p;\n  q.z = abs (abs (q.z) - 27.5);\n  q -= vec3 (s_a, 32., 24.);\n  d = max (PrCaps2Df (q.xy, 4., 28.), abs (q.z) - 1.5);\n  DMINQ (idStruc);\n  q = p;\n  q.xy -= vec2 (s_a, vAxHt);\n  d = PrCylDf (q, 2.5, lBase.z - 5.);\n  DMINQ (idAx);\n  q.xy = Rot2Cs (q.xy, wlk.csVane);\n  d = max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y);\n  q.xy = Rot2Cs (q.xy, CosSin (2. * pi / 3.));\n  d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n  q.xy = Rot2Cs (q.xy, CosSin (2. * pi / 3.));\n  d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n  q.z = abs (q.z) - 27.5;\n  d = max (d, abs (q.z) - 21.);\n  DMINQ (idVane);\n  chnSzFac = 12.76;\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (s_a, s_l, 8.);\n  dMin = chnSzFac * ChainDf (vec3 (q.xy, - q.z).xzy / chnSzFac, - wlk.leg[0].wAng,\n     24., dMin / chnSzFac);\n  q = p;\n  q.xy -= vec2 (s_a - 0.5 * lBase.x, 0.5 * (vAxHt + s_l));\n  dMin = chnSzFac * ChainDf (vec3 (Rot2D (q.xy, chnEl), - q.z).xzy / chnSzFac,\n     - wlk.leg[0].wAng - chnEl, 16., dMin / chnSzFac);\n  return wlk.szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 rdi, p;\n  bool cNu;\n  float dHit, d, s, sb, eps;\n  if (rd.x == 0.) rd.x = 1e-4;\n  if (rd.z == 0.) rd.z = 1e-4;\n  rdi.xz = 1. / rd.xz;\n  eps = 1e-4;\n  cNu = true;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    if (cNu) {\n      cId = floor (p.xz / bGrid);\n      sb = Minv2 ((bGrid * (cId + step (0., rd.xz)) - ro.xz) * rdi.xz);\n      ObjState ();\n      cNu = false;\n    }\n    d = (Maxv2 (abs (cId)) <= grLim) ? ObjDf (p) : dstFar;\n    s = max (dHit, sb);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps || p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    if (Maxv2 (abs (cId)) <= grLim) {\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.3 * bGrid;\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else if (rd.y < 0.) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return 0.8 * col;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  if (idObj == idBas) {\n    col4 = vec4 (0.7, 0.8, 0.7, 0.05) * (0.9 +\n       0.1 * smoothstep (0.1, 0.13, fract (8. * abs (qHit.z) / 50. + 0.5)));\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.8, 0.9, 0.8, 0.05);\n  } else if (idObj == idLnkT) {\n    col4 = vec4 (0.85, 0.85, 0.9, 0.1) * (0.8 + 0.2 * smoothstep (0.18, 0.22, abs (qHit.y)));\n  } else if (idObj == idLnk) {\n    col4 = vec4 (0.95, 0.95, 1., 0.1) * (0.8 + 0.2 * smoothstep (0.18, 0.22,\n       abs (abs (qHit.y) - 0.8)));\n  } else if (idObj == idAx) {\n    col4 = vec4 (0.8, 0.7, 0.2, 0.1);\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.8, 0.6, 0.1, 0.1);\n  } else if (idObj == idVane) {\n    col4 = mix (vec4 (1., 1., 1., 0.), vec4 (HsvToRgb (vec3 (fract (0.4 + 0.7 * Hashfv2 (cId *\n       vec2 (1.5, 2.5) + 1.1)), 0.6, 1.)), 0.), smoothstep (0.25, 0.3, abs (abs (qHit.z) - 12.)));\n  } else if (idObj == idSprk) {\n    col4 = vec4 (0.8, 0.6, 0.1, 0.1);\n  } else if (idObj == idPin) {\n    col4 = vec4 (0.65, 0.7, 0.8, 0.1);\n  } else if (idObj == idPlt) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n  }\n  return col4;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, q;\n  float dstObj, dstGrnd, sh, t;\n  bool isBg;\n  wlkScl = 0.07;\n  lBase = vec3 (60., 86., 60.);\n  vAxHt = 60.;\n  wlkSpd = 1.5;\n  dstGrnd = dstFar;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    q = ro;\n    q.xz += wlkSpd * tCur;\n    t = 1. - smoothstep (0.5, 0.7, dstGrnd / dstFar);\n    vn4 = RippleNorm (0.25 * q.xz, vec3 (0., 1., 0.), 4. * t);\n    vn = vn4.xyz;\n    col4 = vec4 (0.8, 0.7, 0.4, 0.) * (1. - 0.15 * t * Fbm2 (32. * q.xz)) *\n       mix (1., 0.97 + 0.03 * smoothstep (0.1, 0.3, vn4.w), 2. * t);\n  } else {\n    col = SkyBgCol (ro, rd);\n    isBg = true;\n  }\n  if (! isBg) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, normalize (sunDir * vec3 (-1., 0., -1.))), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       step (0.95, sh) * col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    if (dstObj >= dstFar) col = mix (col, 0.8 * vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, azm, zmFac, asp, sr;\n  int vuId, regId;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 50.;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  az = 0.;\n  azm = 0.;\n  el = (vuId == 0) ? -0.11 * pi : -0.09 * pi;\n  if (mPtr.z > 0. && vuId == regId) {\n    azm = 2.5 * pi * msw.x;\n    az += azm;\n    el += 0.5 * pi * msw.y;\n  } else {\n    az = mod (az + 0.01 * pi * tCur + pi, 2. * pi) - pi;\n    el += 0.05 * pi * sin (0.015 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.03 * pi);\n  vuMat = StdVuMat (el, az);\n  if (length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01,\n     fract (tCur / 60.))) vuId = 1 - vuId;\n  zmFac = 4.;\n  if (vuId == 0)zmFac = 2.5 * (zmFac + 4. * abs (azm));\n  bGrid = 20.;\n  grLim = (vuId == 0) ? 0. : 1.;\n  ro = vec3 (0., 0., -100.);\n  ro.y = (vuId == 0) ? 6. : 3.;\n  ro = vuMat * ro;\n  ro.xz += 0.5 * bGrid;\n  dstFar = 300.;\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (vec2 (p.x, sign (p.y) * (max (0., abs (p.y) - h)))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (mod (p + vec2 (0., 1.), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSfWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1761, 1761, 1779, 1862, 3535], [3537, 3537, 3611, 3611, 3770], [3772, 3772, 3833, 3833, 5779], [5781, 5781, 5803, 5831, 9331], [9333, 9333, 9366, 9366, 10079], [10081, 10081, 10102, 10102, 10357], [10359, 10359, 10396, 10396, 10864], [10866, 10866, 10900, 10900, 11726], [11728, 11728, 11744, 11744, 12839], [12841, 12841, 12866, 12866, 13245], [13247, 13247, 13291, 13291, 13490], [13492, 13492, 13527, 13527, 14768], [14788, 14788, 14844, 14844, 17287], [17289, 17289, 17322, 17322, 17411], [17413, 17413, 17455, 17455, 17506], [17508, 17508, 17561, 17561, 17622], [17624, 17624, 17668, 17668, 17744], [17746, 17746, 17768, 17768, 17795], [17797, 17797, 17819, 17819, 17846], [17848, 17848, 17893, 17893, 17985], [17987, 17987, 18032, 18032, 18070], [18072, 18072, 18129, 18129, 18212], [18214, 18214, 18250, 18250, 18456], [18458, 18458, 18488, 18488, 18601], [18603, 18603, 18634, 18634, 18698], [18700, 18700, 18724, 18724, 18846], [18880, 18880, 18904, 18904, 18979], [18981, 18981, 19005, 19005, 19073], [19075, 19075, 19099, 19099, 19226], [19228, 19228, 19253, 19253, 19399], [19401, 19401, 19426, 19426, 19610], [19612, 19612, 19634, 19634, 19788], [19790, 19790, 19811, 19811, 19966]], "test": "untested"}
{"id": "DtXfzB", "name": "Fast Torus", "author": "ruudhelderman", "description": "3D projection of the interior of a torus, calculated by solving a cubic equation.\nPros: efficient - no 'for' loops (except for oversampling).\nCons: complex math; less flexible than raymarching.\nSimilar shader: https://www.shadertoy.com/view/4sBGDy", "tags": ["torus", "tokamak"], "likes": 6, "viewed": 216, "published": 3, "date": "1693922731", "time_retrieved": "2024-07-30T17:35:28.682941", "image_code": "// Fast Torus\n// by Ruud Helderman, August-September 2023 - MIT License\n\n// A torus is such a simple mathematical object that you can do\n// a 3D projection by solving a quartic or even a cubic equation.\n// Pros: efficient - no 'for' loops (except for oversampling).\n// Cons: complex math; less flexible than raymarching.\n\nconst float PI = 3.1415926536;\n\n//---------------------------------------------------------------------------------------\n// Torus\n//---------------------------------------------------------------------------------------\n\n// Torus, centered at (0, 0, 0), with center axis along the Z axis.\n// Formula: (x^2 + y^2 + z^2 + R^2 - r^2)^2 = 4R^2(x^2 + y^2)\n// (see https://en.wikipedia.org/wiki/Torus)\n\nconst float R = 3.0;   // major radius (distance between center axis and center of tube)\nconst float r = 2.0;   // minor radius (radius of tube)\n\n// Given a point on the surface of the torus, get its skin coordinates.\nvec2 torus_to_skin(vec3 p)\n{\n    return atan(p.yz, vec2(p.x, length(p.xy) - R)) / PI;\n}\n\n// Given a point on the surface of the torus, get its normal vector (normalized).\nvec3 torus_normal(vec3 p)\n{\n    return (vec3(normalize(p.xy) * R, 0) - p) / r;\n}\n\n// Dot product of normal vector with ray from source. Used for lighting.\nfloat torus_normal_dot(vec3 p, vec3 source)\n{\n    return dot(torus_normal(p), normalize(source - p));\n}\n\n//---------------------------------------------------------------------------------------\n// Ray\n//---------------------------------------------------------------------------------------\n\n// Formula: y = uv.x * (x+R+r), z = uv.y * (x+R+r)\n\n// Camera is located at surface of torus (on negative part of X axis).\n// That location greatly simplifies our calculation as we already know one intersection\n// between ray and torus, leaving us with only a cubic equation to solve.\nconst vec3 camera = vec3(-R-r, 0, 0);\n\n// Camera looks inside (toward center axis), along X axis in positive direction.\n// Given the X coordinate of a point on the ray, calculate the remaining coordinates.\nvec3 ray_point(float x, vec2 uv)\n{\n    return vec3(x, (x - camera.x) * uv);\n}\n\n//---------------------------------------------------------------------------------------\n// Solve cubic equation\n//---------------------------------------------------------------------------------------\n\nfloat cubic_1_root(float q, float sd)\n{\n    vec2 v = vec2(sd, -sd) - q;\n    v = sign(v) * pow(abs(v), vec2(1.0/3.0));\n    return v.x + v.y;\n}\n\nfloat cubic_smallest_of_3_roots(float p, float sp, float q)\n{\n    return -2.0 * sp * cos(acos(q / (p * sp)) / 3.0);\n}\n\n// Calculate the smallest real root of the depressed cubic equation x^3-3px+2q=0\nfloat cubic_smallest_real_root(float p, float q)\n{\n    float d = q*q - p*p*p;\n    return d > 0.0 ? cubic_1_root(q, sqrt(d)) : cubic_smallest_of_3_roots(p, sqrt(p), q);\n}\n\n//---------------------------------------------------------------------------------------\n// Intersect ray with torus\n//---------------------------------------------------------------------------------------\n\n// Calculate coordinates of intersection between ray and torus\nvec3 intersect_torus(vec2 uv)\n{\n    vec2 uv2 = uv*uv;\n    float k = uv2.x + uv2.y;\n    \n    vec2 v = mat4x2(1, 2, -1, -5, -3, -9, -3, 18) * vec4(R*R+r*r, R*r, R*r*k, R*R*uv2.y);\n    \n    float p = 4.0/9.0*v.x;\n    float q = 4.0/27.0*(R+r)*v.y;\n    \n    float x = (cubic_smallest_real_root(p, q) - (R+r)*(k-1.0/3.0)) / (k+1.0);\n    \n    return ray_point(x, uv);\n}\n\n//---------------------------------------------------------------------------------------\n// Skin of torus\n//---------------------------------------------------------------------------------------\n\nconst float number_of_skins = 10.0;\nconst float time_between_transitions = 5.0;\nconst float transition_duration = 0.4;\nconst float animation_speed = 0.03;\n\nfloat transition_step(float n)\n{\n    return smoothstep(0.0, transition_duration / time_between_transitions, n);\n}\n\nfloat timeslot(float n)\n{\n    float m = mod(-n, number_of_skins);\n    return transition_step(m) - transition_step(m - 1.0);\n}\n\nfloat square_wave(float x)\n{\n    return 0.5 + 0.5 * tanh(16.0 * cos(2.0 * PI * x));\n}\n\nfloat squares(vec2 uv, float n)\n{\n    vec2 s = tanh(n * sin(12.0 * PI * uv));\n    return s.x * s.y;\n}\n\nvec3 skin_toothpaste(vec2 uv)\n{\n    return mix(vec3(0.2, 0.4, 1), vec3(1), square_wave(dot(uv, vec2(1, 3))));\n}\n\nvec3 skin_grid(vec2 uv)\n{\n    return mix(vec3(0), vec3(1, 0.3, 0.3), abs(squares(uv, 8.0)));\n}\n\nvec3 skin_morph(vec2 uv, float t)\n{\n    return mix(vec3(0.8, 0, 1), vec3(0.4, 0, 0.5), square_wave(length(sin(t * 0.25) + sin(8.0 * PI * uv))));\n}\n\nvec3 skin_eight(vec2 uv)\n{\n    return mix(vec3(0.5), vec3(1), square_wave(uv.x + uv.y));\n}\n\nvec3 skin_checkered(vec2 uv)\n{\n    return mix(vec3(0.8, 0.6, 0), vec3(0.6, 0.4, 0), squares(uv, 32.0));\n}\n\nvec3 skin_wired(vec2 uv)\n{\n    return mix(vec3(0), vec3(0.6, 0.8, 1), 0.5 + 0.5 * sin(32.0 * PI * (uv.x + uv.y)));\n}\n\nvec3 skin_channel(vec2 uv, sampler2D s)\n{\n    return texture(s, acos(cos(uv * PI)) / PI).rgb;\n}\n\n// Every few seconds a different skin\nvec3 skin(vec2 uv, float t)\n{\n    uv += t * animation_speed;\n    float s = t / time_between_transitions;\n    //s = 2.0;        // uncomment and specify number to stick to that skin\n    vec3 c = vec3(0);\n    float a;\n    a = timeslot(--s); if (a > 0.0) c += a * skin_toothpaste(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_grid(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_morph(uv, t);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_eight(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_checkered(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_wired(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel0);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel1);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel2);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel3);\n    return c;\n}\n\n//---------------------------------------------------------------------------------------\n// Projection of torus onto 2D screen\n//---------------------------------------------------------------------------------------\n\n// Light source is at the same point as the camera;\n// helps keep the implementation simple (no visible shadow of the axis on the outer wall).\n\nconst float dark = 0.3;\nconst float light = 1.0;\n\n// Find a balance between horizontal and vertical resolution while maintaining aspect ratio.\nfloat average(vec2 res)\n{\n    return 0.5 * (res.x + res.y);\n}\n\n// Convert from pixels to normalized centered coordinates, roughly [-1, 1]\nvec2 normalize_screen(vec2 uv, vec2 res)\n{\n    return (2.0 * uv - res) / average(res);\n}\n\n// Get the color of the pixel at the given screen coordinates and the given time\nvec3 projection(vec2 uv, float t)\n{\n    vec3 p = intersect_torus(normalize_screen(uv, iResolution.xy));\n    return skin(torus_to_skin(p), t) * mix(dark, light, torus_normal_dot(p, camera));\n}\n\n//---------------------------------------------------------------------------------------\n// Anti-aliasing\n//---------------------------------------------------------------------------------------\n\n// Easy adaptive sampling, by Fabrice Neyret\n// https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\nvec3 oversampled_projection(vec2 uv)\n{\n    vec3 color = projection(uv, iTime);\n    if (fwidth(length(color)) > .01)\n    {\n        for (int k = 0; k < 9; k += k==3?2:1)\n        {\n            color += projection(uv + vec2(k%3-1,k/3-1)/3.0, iTime);\n        }\n        color /= 9.0;\n        //color.r++;        // uncomment to see where the oversampling occurs\n    }\n    return color;\n}\n\n//---------------------------------------------------------------------------------------\n// Main\n//---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(oversampled_projection(fragCoord), 1);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXfzB.jpg", "access": "api", "license": "mit", "functions": [[866, 938, 966, 966, 1025], [1027, 1109, 1136, 1136, 1189], [1191, 1264, 1309, 1309, 1367], [1881, 2048, 2082, 2082, 2125], [2332, 2332, 2371, 2371, 2473], [2475, 2475, 2536, 2536, 2592], [2594, 2675, 2725, 2725, 2844], [3055, 3118, 3149, 3149, 3480], [3836, 3836, 3868, 3868, 3949], [3951, 3951, 3976, 3976, 4076], [4078, 4078, 4106, 4106, 4163], [4165, 4165, 4198, 4198, 4266], [4268, 4268, 4299, 4299, 4379], [4381, 4381, 4406, 4406, 4475], [4477, 4477, 4512, 4512, 4623], [4625, 4625, 4651, 4651, 4715], [4717, 4717, 4747, 4747, 4822], [4824, 4824, 4850, 4850, 4940], [4942, 4942, 4983, 4983, 5037], [5039, 5077, 5106, 5106, 5981], [6396, 6489, 6514, 6514, 6550], [6552, 6627, 6669, 6669, 6715], [6717, 6798, 6833, 6833, 6989], [7308, 7308, 7346, 7346, 7689], [7880, 7880, 7935, 7935, 7997]], "test": "untested"}
{"id": "dtjfz1", "name": "My Third Pathtraced Scene", "author": "oneshade", "description": "Following @demofox's third tutorial. Drag with the mouse to rotate the camera.", "tags": ["globalillumination", "pathtracer", "stochastic"], "likes": 19, "viewed": 345, "published": 3, "date": "1693900332", "time_retrieved": "2024-07-30T17:35:29.631405", "image_code": "// Based on https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n// and https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy\n// and https://blog.demofox.org/2020/06/14/casual-shadertoy-path-tracing-3-fresnel-rough-refraction-absorption-orbit-camera/\n// And yes, I am sticking with my uncreative naming scheme :)\n\n// https://64.github.io/tonemapping/#uncharted-2\nvec3 Uncharted2(in vec3 color) {\n    color *= 2.0;\n\n    float A = 0.15, B = 0.50, C = 0.10;\n    float D = 0.20, E = 0.02, F = 0.30;\n    color = (((A * color + C * B) * color + D * E) / ((A * color + B) * color + D * F)) - E / F;\n\n    float whiteMax = 4.0;\n    color /= (((A * whiteMax + C * B) * whiteMax + D * E) / ((A * whiteMax + B) * whiteMax + D * F)) - E / F;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(pow(Uncharted2(fragColor.rgb), vec3(0.4545)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Settings\n#define MAX_BOUNCES 16\n#define CAMERA_POSITION vec3(0.0, 2.0, 0.25)\n#define LENS_DISTANCE 1.0\n#define APERTURE_RADIUS 0.04\n#define FOCUS_DISTANCE 3.0\n\n// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n#define EPSILON 0.001\n\n// Structs\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct HitInfo {\n    bool fromInside;\n    float hitDist;\n    vec3 hitPos;\n    vec3 surfNor;\n    vec2 surfUv;\n    int objId;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n    vec3 absorption;\n    vec3 emission;\n    float specularAmount;\n    float specularRoughness;\n    float refractionAmount;\n    float refractionRoughness;\n    float refractiveIndex;\n};\n\n// Defaults\nHitInfo noHit() {\n    HitInfo hit;\n    hit.fromInside = false;\n    hit.hitDist = -1.0;\n    hit.hitPos = vec3(0.0);\n    hit.surfNor = vec3(0.0);\n    hit.surfUv = vec2(0.0);\n    hit.objId = -1;\n    return hit;\n}\n\nMaterial baseMaterial() {\n    Material mtl;\n    mtl.albedo = vec3(0.0);\n    mtl.specular = vec3(0.0);\n    mtl.absorption = vec3(0.0);\n    mtl.emission = vec3(0.0);\n    mtl.specularAmount = 0.0;\n    mtl.specularRoughness = 0.0;\n    mtl.refractionAmount = 0.0;\n    mtl.refractionRoughness = 0.0;\n    mtl.refractiveIndex = 1.0;\n    return mtl;\n}\n\n// Schlick aproximation\nfloat getFresnel(in float n1, in float n2, in vec3 normal, in vec3 incident, in float f0, in float f90) {\n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2) {\n        float n = n1 / n2;\n        float sinT2 = n * n * (1.0 - cosX * cosX);\n        if (sinT2 > 1.0) return f90; // Total internal reflection\n        cosX = sqrt(1.0 - sinT2);\n    }\n\n    float x = 1.0 - cosX;\n    float x2 = x * x;\n    return mix(f0, f90, mix(r0, 1.0, x2 * x2 * x));\n}\n\n// RNG utilities\nuint wangHash(inout uint seed) {\n    seed = (seed ^ 61u) ^ (seed >> 16u);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4);\n    seed *= 668265261u;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rand01(inout uint state) {\n    return float(wangHash(state)) / 4294967296.0;\n}\n\nvec2 randInUnitDisc(inout uint state) {\n    float a = rand01(state) * TAU;\n    return vec2(cos(a), sin(a)) * sqrt(rand01(state));\n}\n\nvec3 randUnitVec(inout uint state) {\n    float z = rand01(state) * 2.0 - 1.0;\n    float a = rand01(state) * TAU;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// Camera basis matrix\nmat3 getCameraBasis(in vec2 an) {\n    mat3 matrix;\n    vec2 c = cos(an), s = sin(an);\n    matrix[0] = vec3(c.x, 0.0, s.x);\n    matrix[1] = vec3(s.x * -s.y, c.y, c.x * s.y);\n    matrix[2] = vec3(s.x * c.y, s.y, -c.x * c.y);\n    return matrix;\n}\n\n// Replaces the current hit with a new one if it is closer\nvoid addRayHit(inout HitInfo curHit, in HitInfo newHit, in int objId) {\n    if (newHit.hitDist > 0.0 && (curHit.hitDist < 0.0 || newHit.hitDist < curHit.hitDist)) {\n        curHit = newHit;\n        curHit.objId = objId;\n    }\n}\n\n// Transformations\nmat4 Translate(in vec3 t) {\n    mat4 matrix = mat4(1.0);\n    matrix[3].xyz = t;\n    return matrix;\n}\n\nmat4 Scale(in vec3 s) {\n    mat4 matrix = mat4(1.0);\n    matrix[0][0] = s.x;\n    matrix[1][1] = s.y;\n    matrix[2][2] = s.z;\n    return matrix;\n}\n\nmat4 Rotate(in float a, in int i, in int j) {\n    mat4 matrix = mat4(1.0);\n    float co = cos(a), si = sin(a);\n    matrix[i][i] = co;\n    matrix[i][j] = si;\n    matrix[j][i] = -si;\n    matrix[j][j] = co;\n    return matrix;\n}\n\n// Primitive intersectors\n// Ray vs. Plane intersection\nHitInfo planeIsect(in Ray ray, in mat4 mat) {\n    HitInfo hit = noHit();\n    mat4 matInv = inverse(mat);\n    ray.orig = (matInv * vec4(ray.orig, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    hit.hitDist = -ray.orig.y / ray.dir.y;\n    hit.hitPos = ray.orig + ray.dir * hit.hitDist;\n    hit.fromInside = ray.orig.y < 0.0;\n    hit.surfNor = transpose(matInv)[1].xyz * sign(ray.orig.y);\n    hit.surfUv = hit.hitPos.xz;\n    hit.hitPos = (mat * vec4(hit.hitPos, 1.0)).xyz;\n\n    return hit;\n}\n\n// Ray vs. Sphere intersection\nHitInfo sphereIsect(in Ray ray, in mat4 mat) {\n    HitInfo hit = noHit();\n    mat4 matInv = inverse(mat);\n    ray.orig = (matInv * vec4(ray.orig, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.orig, ray.dir);\n    float c = dot(ray.orig, ray.orig) - 1.0;\n\n    float dis = b * b - a * c;\n    if (dis < 0.0) return hit;\n\n    hit.hitDist = (-b - sign(c) * sqrt(dis)) / a;\n    hit.hitPos = ray.orig + ray.dir * hit.hitDist;\n    hit.fromInside = c < 0.0;\n    hit.surfNor = (transpose(matInv) * vec4(hit.hitPos, 0.0)).xyz * sign(c);\n    hit.surfUv = vec2(atan(hit.hitPos.z, hit.hitPos.x), atan(hit.hitPos.y, length(hit.hitPos.xz)));\n    hit.hitPos = (mat * vec4(hit.hitPos, 1.0)).xyz;\n\n    return hit;\n}\n\n// Not so primitive intersectors\n// Ray vs. Bilinear Patch intersection\nfloat cross2D(in vec2 a, in vec2 b) { return a.x * b.y - a.y * b.x; }\nHitInfo patchIsect(in Ray ray, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in bool solid) {\n    HitInfo hit = noHit();\n    vec2 m = ray.dir.yz / ray.dir.x;\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 ip = p.yz - p.x * m, iq = q.yz - q.x * m, ir = r.yz - r.x * m;\n    vec2 ia = (a.yz - ray.orig.yz) - (a.x - ray.orig.x) * m;\n\n    // Reversed coefficients (solving for 1/x seems most stable)\n    float qa = cross2D(iq, ia);\n    float qb = cross2D(ip, ia) + cross2D(iq, ir);\n    float qc = cross2D(ip, ir);\n\n    float dis = qb * qb - 4.0 * qa * qc;\n    if (dis > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(dis) - qb);\n        vec2 u = -(ia.x + ir.x * v) / (ip.x * v + iq.x);\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ray.orig.x) / ray.dir.x;\n\n        // Check the validity of both intersections\n        bvec2 valid = bvec2(\n            t.x > 0.0 && u.x >= 0.0 && u.x <= 1.0 && v.x >= 0.0 && v.x <= 1.0,\n            t.y > 0.0 && u.y >= 0.0 && u.y <= 1.0 && v.y >= 0.0 && v.y <= 1.0\n        );\n\n        // Choose closest intersection in the patch\n        if (valid.y && (!valid.x || t.y < t.x)) {\n            u = u.yx;\n            v = v.yx;\n            t = t.yx;\n            valid = valid.yx;\n        }\n\n        if (valid.x) {\n            hit.hitDist = t.x;\n            hit.hitPos = ray.orig + ray.dir * t.x;\n            hit.surfNor = cross(p * u.x + r, p * v.x + q);\n            float viewAngle = dot(hit.surfNor, -ray.dir);\n            hit.fromInside = solid && viewAngle < 0.0;\n            hit.surfNor *= sign(viewAngle);\n            hit.surfUv = vec2(u.x, v.x);\n        }\n    }\n\n    return hit;\n}\n\nHitInfo traceRay(in Ray ray) {\n    HitInfo hit = noHit();\n\n    addRayHit(hit, planeIsect(ray, mat4(1.0)), 1);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.7, -3.0)) * Scale(vec3(0.4))), 2);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.5, 1.5, -5.0)) * Scale(vec3(0.75))), 3);\n\n    mat4 jellyMat = Translate(vec3(0.0, 1.5, -4.5)) * Rotate(-0.25, 2, 1) * Scale(vec3(0.75));\n    mat4 topTwist = Rotate(-1.5, 0, 2);\n    mat4 bottomTwist = Rotate(0.0, 0, 2);\n    float wiggle = 0.5;\n    vec3 v0 = (jellyMat * bottomTwist * vec4(-1.0, -1.0 + wiggle, -1.0, 1.0)).xyz;\n    vec3 v1 = (jellyMat * bottomTwist * vec4(-1.0, -1.0 - wiggle,  1.0, 1.0)).xyz;\n    vec3 v2 = (jellyMat *    topTwist * vec4(-1.0,  1.0 - wiggle, -1.0, 1.0)).xyz;\n    vec3 v3 = (jellyMat *    topTwist * vec4(-1.0,  1.0 + wiggle,  1.0, 1.0)).xyz;\n    vec3 v4 = (jellyMat * bottomTwist * vec4( 1.0, -1.0 - wiggle, -1.0, 1.0)).xyz;\n    vec3 v5 = (jellyMat * bottomTwist * vec4( 1.0, -1.0 + wiggle,  1.0, 1.0)).xyz;\n    vec3 v6 = (jellyMat *    topTwist * vec4( 1.0,  1.0 + wiggle, -1.0, 1.0)).xyz;\n    vec3 v7 = (jellyMat *    topTwist * vec4( 1.0,  1.0 - wiggle,  1.0, 1.0)).xyz;\n    addRayHit(hit, patchIsect(ray, v7, v5, v4, v6, true), 4);\n    addRayHit(hit, patchIsect(ray, v2, v0, v1, v3, true), 4);\n    addRayHit(hit, patchIsect(ray, v2, v3, v7, v6, true), 4);\n    addRayHit(hit, patchIsect(ray, v1, v0, v4, v5, true), 4);\n    addRayHit(hit, patchIsect(ray, v6, v4, v0, v2, true), 4);\n    addRayHit(hit, patchIsect(ray, v3, v1, v5, v7, true), 4);\n\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.3, 1.5, -3.0)) * Scale(vec3(0.75))), 5);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.0, 1.5, -2.0)) * Scale(vec3(0.75))), 6);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.0, 1.2, -1.0)) * Scale(vec3(0.25))), 7);\n\n    return hit;\n}\n\nMaterial getMaterial(in vec2 surfUv, in int objId) {\n    Material mtl = baseMaterial();\n\n    if (objId == 1) {\n        mtl.albedo = vec3(mod(floor(surfUv.x) + floor(surfUv.y), 2.0));\n        mtl.specular = vec3(1.0, 0.4, 0.2);\n        mtl.specularAmount = 0.5;\n        mtl.specularRoughness = 0.7;\n    }\n\n    if (objId == 2) {\n        mtl.absorption = vec3(0.0, 0.0, 2.0);\n        mtl.specular = vec3(1.0);\n        mtl.specularAmount = 0.1;\n        mtl.specularRoughness = 0.3;\n        mtl.refractionAmount = 0.9;\n        mtl.refractionRoughness = 0.5;\n        mtl.refractiveIndex = 1.5;\n    }\n\n    if (objId == 3) {\n        mtl.specular = vec3(1.0);\n        mtl.absorption = vec3(1.0, 0.5, 0.0);\n        mtl.specularAmount = 0.1;\n        mtl.refractionAmount = 0.9;\n        mtl.refractiveIndex = 1.5;\n    }\n\n    if (objId == 4) {\n        surfUv *= 8.0;\n        mtl.albedo = vec3(mod(floor(surfUv.x) + floor(surfUv.y), 2.0));\n    }\n\n    if (objId == 5) {\n        mtl.albedo = vec3(0.9, 0.25, 0.25);\n        mtl.specular = vec3(0.8);\n        mtl.specularAmount = 0.02;\n    }\n\n    if (objId == 6) {\n        mtl.albedo = vec3(0.9, 0.25, 0.25);\n        mtl.specular = vec3(0.8);\n        mtl.absorption = vec3(0.0, 1.5, 3.0);\n        mtl.specularAmount = 0.02;\n        mtl.refractionAmount = 0.98;\n        mtl.refractiveIndex = 1.5;\n    }\n\n    if (objId == 7) {\n        mtl.albedo = vec3(0.0, 1.0, 0.0);\n        mtl.specular = vec3(0.0, 1.0, 0.0);\n        mtl.specularAmount = 1.0;\n        mtl.specularRoughness = 0.5;\n    }\n\n    return mtl;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate a seed value\n    uint rngState = (uint(fragCoord.x) * 1973u + uint(fragCoord.y) * 9277u + uint(iFrame) * 26699u) | 1u;\n\n    // Read the current average sample\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Reset on mouse down\n    if (iMouse.z > 0.0) fragColor = vec4(0.0);\n\n    // Jitter within the pixel for antialiasing\n    fragCoord += vec2(rand01(rngState), rand01(rngState));\n    vec2 viewportCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - viewportCenter) / iResolution.y;\n\n    // Calculate a ray for the pixel\n    vec2 mouse = (iMouse.xy - viewportCenter) / iResolution.y;\n    if (iMouse.xy == vec2(0.0)) mouse = vec2(0.07, -0.04);\n    mat3 camBasis = getCameraBasis(mouse * TAU);\n\n    // Adding depth of field as a bonus\n    // Based on this lesson https://pathtracing.home.blog/depth-of-field/\n    Ray primaryRay = Ray(CAMERA_POSITION, camBasis * normalize(vec3(uv, LENS_DISTANCE)));\n    vec3 aperturePoint = camBasis * vec3(randInUnitDisc(rngState) * APERTURE_RADIUS, 0.0);\n    Ray ray = Ray(primaryRay.orig + aperturePoint, normalize(primaryRay.dir * FOCUS_DISTANCE - aperturePoint));\n\n    // Pathtrace!\n    vec3 acc = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {\n        HitInfo hit = traceRay(ray);\n        if (hit.hitDist < 0.0) {\n            acc += pow(texture(iChannel1, ray.dir).rgb, vec3(2.2)) * throughput;\n            break;\n        }\n\n        hit.surfNor = normalize(hit.surfNor);\n        Material mtl = getMaterial(hit.surfUv, hit.objId);\n\n        // If the ray hit inside, some light gets absorbed\n        if (hit.fromInside) throughput *= exp(-mtl.absorption * hit.hitDist);\n\n        // Initial chances of reflecting or refracting\n        float specularChance = mtl.specularAmount;\n        float refractionChance = mtl.refractionAmount;\n\n        if (specularChance > 0.0) {\n            // Adjust specular chance to account for the Fresnel effect\n            specularChance = getFresnel(\n                hit.fromInside ? mtl.refractiveIndex : 1.0,\n                hit.fromInside ? 1.0 : mtl.refractiveIndex,\n                ray.dir, hit.surfNor, mtl.specularAmount, 1.0\n            );\n\n            // Make sure diffuse / refraction ratio is the same\n            // Diffuse chance is implied (1 - specularChance - refractionChance)\n            float correctionRatio = (1.0 - specularChance) / (1.0 - mtl.specularAmount);\n            refractionChance *= correctionRatio;\n        }\n\n        // Choose whether to diffuse, reflect, or refract\n        float doSpecular = 0.0;\n        float doRefraction = 0.0;\n        float rayProbability = 1.0 - specularChance - refractionChance;\n        float selector = rand01(rngState);\n        if (specularChance > 0.0 && selector < specularChance) {\n            doSpecular = 1.0;\n            rayProbability = specularChance;\n        } else if (refractionChance > 0.0 && selector < specularChance + refractionChance) {\n            doRefraction = 1.0;\n            rayProbability = refractionChance;\n        }\n\n        // Step to the intersection and push off the surface a tiny bit\n        ray.orig = hit.hitPos + hit.surfNor * (doRefraction == 1.0 ? -EPSILON : EPSILON);\n\n        // Calculate a new ray direction\n        // Diffuse uses a random reflection from a cosine distribution about the normal\n        // Specular uses the perfect reflection across the normal\n        // Refraction uses the perfect refraction across the normal\n        // Squaring the roughness is just a convention to make roughness appear more linear\n        vec3 diffuseRay = normalize(hit.surfNor + randUnitVec(rngState));\n        vec3 specularRay = reflect(ray.dir, hit.surfNor);\n        specularRay = normalize(mix(specularRay, diffuseRay, mtl.specularRoughness * mtl.specularRoughness));\n        vec3 refractionRay = refract(ray.dir, hit.surfNor, hit.fromInside ? mtl.refractiveIndex : 1.0 / mtl.refractiveIndex);\n        refractionRay = normalize(mix(refractionRay, normalize(-hit.surfNor + randUnitVec(rngState)), mtl.refractionRoughness * mtl.refractionRoughness));\n        ray.dir = mix(diffuseRay, specularRay, doSpecular);\n        ray.dir = mix(ray.dir, refractionRay, doRefraction);\n\n        // Accumulate light emission from the surface\n        acc += mtl.emission * throughput;\n\n        // Update the throughput for diffuse and specular reflections only\n        if (doRefraction == 0.0) throughput *= mix(mtl.albedo, mtl.specular, doSpecular);\n\n        // Adjust the throughput to account for the actions that got discarded\n        throughput /= max(EPSILON, rayProbability);\n\n        // Russian roulette optimization\n        // Increases the chance of terminating as the throughput decreases\n        // Surviving samples get boosted to make up for the eliminated ones\n        float stopChance = max(throughput.r, max(throughput.g, throughput.b));\n        if (rand01(rngState) > stopChance) break;\n        throughput /= stopChance;\n    }\n\n    // Combine the new sample with the current average\n    fragColor.w += 1.0;\n    fragColor.rgb = mix(fragColor.rgb, acc, 1.0 / fragColor.w);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 452, 484, 484, 838], [840, 840, 895, 895, 1034]], "test": "untested"}
{"id": "mlSBzm", "name": "Ray Marcher (The Better One)", "author": "Supercooldude", "description": "Rays March\nArrow keys & WASD to move", "tags": ["3d", "raymarching", "cool"], "likes": 0, "viewed": 122, "published": 3, "date": "1693885821", "time_retrieved": "2024-07-30T17:35:30.404339", "image_code": "float marchEpsilon = 0.001;\nfloat epsilonNormal = 0.001;\n\n\nfloat dist(vec3 point)\n{\n    return distance(fract(point), vec3(0.5, 0.5, 0.5)) * 0.5;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec3 normal;\n    \n    normal.x = dist(pos + vec3(epsilonNormal, 0.0, 0.0));\n    normal.x -= dist(pos + vec3(-epsilonNormal, 0.0, 0.0));\n    \n    normal.y = dist(pos + vec3(0.0, epsilonNormal, 0.0));\n    normal.y -= dist(pos + vec3(0.0, -epsilonNormal, 0.0));\n    \n    normal.z = dist(pos + vec3(0.0, 0.0, epsilonNormal));\n    normal.z -= dist(pos + vec3(0.0, 0.0, -epsilonNormal));\n    \n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int stepCount = 255;\n    vec2 uv = fragCoord/iResolution.x;\n    float ar = iResolution.y/iResolution.x;\n    \n    vec3 sunDir = normalize(vec3(sin(iTime * 0.1), 1.0, cos(iTime * 0.1)));\n    \n    vec3 startPos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 rot = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    \n    vec3 pos = startPos;\n    vec3 dir = normalize(vec3(uv.x - 0.5, uv.y - 0.5 * ar, 1.0));\n\n    \n    vec3 old = dir;\n    dir.y = old.y * cos(rot.y) + old.z * sin(rot.y);\n    dir.z = old.z * cos(rot.y) + old.y * -sin(rot.y);\n    old = dir;\n    dir.x = old.x * cos(rot.x) + old.z * sin(rot.x);\n    dir.z = old.z * cos(rot.x) + old.x * -sin(rot.x);\n\n    \n\n    \n    \n    int marchStep = 0;\n    int endStepCount = 0;\n    while (marchStep < stepCount)\n    {\n        float dist = dist(pos);\n\n\n        if (dist < marchEpsilon)\n        {\n            endStepCount = marchStep;\n            marchStep = stepCount;\n        }\n        pos += dir * dist;\n        marchStep++;\n    }\n    vec3 endCol;\n    if (marchStep == stepCount + 1)\n    {\n        vec3 col = vec3(1.0, 1.0, 1.0);\n        float brightness = (0.5 + 0.5 * dot(getNormal(pos), sunDir)) * (1.0 - float(endStepCount) / float(stepCount));\n        endCol = col * brightness;\n    }\n    else\n    {\n       endCol = vec3(0.5 + 0.25 * dot(dir, vec3(0.0, 1.0, 0.0)), 0.75 + 0.25 * dot(dir, vec3(0.0, 1.0, 0.0)), 1.0);\n    }\n\n    fragColor = vec4(endCol, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\n\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_Q = 81;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipos = ivec2(int(fragCoord.x), int(fragCoord.y));\n    if ((ipos.x == 0 || ipos.x == 1) && ipos.y == 0)\n    {\n        vec3 pos = vec3(texelFetch(iChannel0, ivec2(0, 0), 0));\n        vec3 rot = vec3(texelFetch(iChannel0, ivec2(1, 0), 0));\n        \n        float xAxis = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r;\n        xAxis -= texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r;\n        \n        float yAxis = texelFetch(iChannel1, ivec2(KEY_E, 0), 0).r;\n        yAxis -= texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).r;\n        \n        float zAxis = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r;\n        zAxis -= texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r;\n        \n        float hAxis = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r;\n        hAxis -= texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        \n        float vAxis = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n        vAxis -= texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n        \n        pos.x += (cos(rot.x) * xAxis + sin(rot.x) * zAxis) * iTimeDelta;\n        pos.y += yAxis * iTimeDelta;\n        pos.z += (cos(rot.x) * zAxis + -sin(rot.x) * xAxis) * iTimeDelta;\n\n        rot.x += iTimeDelta * hAxis;\n        rot.y += iTimeDelta * vAxis;\n        \n        rot.y = min(max(rot.y, -1.5707), 1.5707);\n        if (ipos.x == 0)\n        {\n            fragColor = vec4(pos, 0.0);\n        }\n        else\n        {\n            fragColor = vec4(rot, 0.0);\n        }\n    }\n    \n    if (iFrame == 0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 83, 83, 147], [149, 149, 175, 175, 598], [600, 600, 657, 657, 2077]], "test": "untested"}
{"id": "dlBBzm", "name": "2.5D Subdivision [154 Chars]", "author": "SnoopethDuckDuck", "description": "maybe could be done with bitwise operators?", "tags": ["pixel", "25d", "subdivision"], "likes": 24, "viewed": 235, "published": 3, "date": "1693875979", "time_retrieved": "2024-07-30T17:35:31.168296", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    u /= iResolution.xy;         \n    O *= 0.;\n    O.r++;\n    for (float t = .05*iTime, i; i++ < 6.; u = fract(u+u+.25)) \n        u.x < .5 ? u+=t, O-- : O=-O,\n        u.y < .5 ? u-=t, O++ : O--;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 235]], "test": "untested"}
{"id": "mtjfzW", "name": "3D Noise Buffer", "author": "dominionxvii", "description": "Quick technique to be able to encode a 3D texture in a 2D Buffer, then to read it back\nWith raymarching exemples\n", "tags": ["raymarching", "clouds", "worleynoise", "3dtexture", "3dbuffer"], "likes": 2, "viewed": 172, "published": 3, "date": "1693846182", "time_retrieved": "2024-07-30T17:35:31.931256", "image_code": "vec4 ViewAsSlice(vec3 uv3, vec3 bufferSize)\n{\n    float x = Convert3DTo1D(uv3,  bufferSize);\n    vec2 uv3D = Convert1DTo2D(x, iResolution.xy) / iResolution.xy;\n    return vec4(texture(iChannel0, uv3D));\n}\n\nvec4 ViewAsRayMarching(vec2 uv, vec3 bufferSize, float density, int fbmCount, float dir)\n{\n    //view ray marching\n    int stepCount = 64;\n    float stepSize = 0.05;\n\n    vec3 ro = vec3(0, 0, dir * iTime * 1.5);   \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));;\n\n    vec4 colorSum = vec4(0);\n    for(int i = 0; i < stepCount; i++)\n    {\n        vec3 pos = ro + rd * float(i) * stepSize;\n\n        float noiseSize = 32.;\n        \n        float freq = 1.;\n        float amp = 1.;\n        \n        for(int j = 0; j < fbmCount; j++)\n        {\n            float x = Convert3DTo1D(pos * noiseSize * freq,  bufferSize);\n            vec2 channelResolution = iChannelResolution[0].xy;\n            vec2 uv3D = Convert1DTo2D(x, channelResolution.xy) / channelResolution.xy; //must match buffer A resolution\n            \n            vec4 sampleColor = vec4(texture(iChannel0, uv3D));\n            colorSum += sampleColor * stepSize * density * amp;\n            \n            freq *= 2.0;\n            amp *= 0.5;\n        }\n    }\n    \n    return colorSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    vec3 bufferSize = vec3(64.); //must match Buffer A size's value\n\n    if(fragCoord.x < iResolution.x / 2.0)\n    {   \n        //view a slice\n        vec3 uv3 = vec3(fragCoord / 4., iTime * 16.);\n        fragColor = ViewAsSlice(uv3, bufferSize);\n    }\n    else \n    {       \n        vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n        bool upperHalf = (fragCoord.y > iResolution.y / 2.0);\n        int fbmCount = upperHalf ? 1 : 3;\n        float density = upperHalf ? 0.5 : 0.25;\n        float dir = upperHalf ? -1. : 1.;\n        fragColor = ViewAsRayMarching(uv, bufferSize, density, fbmCount, dir);     \n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 size = vec3(64.);\n    float zoom = 1.0 / 16.;\n    \n    float i = Convert2DTo1D(fragCoord, iResolution.xy);\n    vec3 pos = Convert1DTo3D(i, size.xyz);\n    \n    float noise = PeriodicalCellularNoise(pos, zoom, size);\n    fragColor = vec4(1. - noise, 0, 0 ,0);\n}", "buffer_a_inputs": [], "common_code": "float Repeat(float t, float len)\n{\n    return clamp(t - floor(t / len) * len, 0., len);\n}\nvec2 Repeat(vec2 t, vec2 size)\n{\n    return vec2(Repeat(t.x, size.x), Repeat(t.y, size.y));\n}\n\nvec3 Repeat(vec3 t, vec3 size)\n{\n    return vec3(\n        Repeat(t.x, size.x),\n        Repeat(t.y, size.y),\n        Repeat(t.z, size.z)\n    );\n}\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return t;\n}\n\nvec3 NextVec3(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    float z = NextFloat(state);\n\n    return vec3(x, y, z);\n}\n\n\n//Convert functions based on https://www.shadertoy.com/view/XddXW7\n\nfloat Convert2DTo1D(vec2 p, vec2 s) \n{\n    //p = Repeat(p, s);\n    p = mod(p, s);\n    return floor(p.y) * s.x + p.x;\n}\n\nvec2 Convert1DTo2D(float p, vec2 size)\n{\n    float x = mod(p, size.x);\n    float y = (p - x) / size.x + 0.5;\n    return vec2(x, y);\n}\n\nfloat Convert3DTo1D(vec3 p, vec3 size)\n{\n    //p = Repeat(p, size);\n    p = mod(p, size);\n    return floor(p.z) * size.x * size.y + floor(p.y) * size.x + p.x;\n}\n\nvec3 Convert1DTo3D(float p, vec3 size)\n{\n    float x = mod(p, size.x);\n    float y = mod((p - x) / size.x, size.y);\n    float z = (p - x - floor(y) * size.x) / (size.x * size.y);\n    return vec3(x, y + 0.5, z + 0.5);\n}\n\n\n//\nfloat PeriodicalCellularNoise(vec3 p, float scale, vec3 size)\n{\n    p *= scale;\n    vec3 mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 cellIndex = mainCell + vec3(x, y, z);\n        \n        vec3 repeatCellIndex = Repeat(cellIndex, size * scale);\n        uint seed = uint(137. + repeatCellIndex.x * 11. + repeatCellIndex.y * 17. + repeatCellIndex.z * 13.);\n        uint state = WangHash(seed);\n        \n        vec3 cellPoint = cellIndex + NextVec3(state);\n        float dist = distance(p, cellPoint);\n        minDist = min(minDist, dist);\n    }\n\n    return minDist;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 204], [206, 206, 296, 320, 1247], [1249, 1249, 1306, 1306, 1937]], "test": "untested"}
{"id": "dl2fzz", "name": "Extruded Bauhaus Truchet Pattern", "author": "Shane", "description": "An extruded Bauhaus Truchet pattern with a simplistic Cook-Torrance diffuse and specular lighting scheme applied to give the vague appearance of hard ceramic and metal tiles.", "tags": ["raymarch", "truchet", "brdf", "cook", "torrance", "traversal", "bdrf", "bauhaus"], "likes": 129, "viewed": 4751, "published": 3, "date": "1693835063", "time_retrieved": "2024-07-30T17:35:32.916622", "image_code": "/*\n\n    Extruded Bauhaus Truchet Pattern\n    --------------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.5 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 2.5, coc = .5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Extruded Bauhaus Truchet Pattern\n    --------------------------------\n    \n    This is an extruded Bauhaus Truchet pattern with a very simplistic \n    Cook-Torrance diffuse and specular lighting scheme applied to give \n    the vague appearance of hard ceramic and metal tiles.\n    \n    When not path tracing, I tend to get a bit lazy with material lighting \n    routines. Most of the time, I can make things look the way I want by\n    tweaking the diffuse and specular powers. However, if you want a bit \n    more material realism, it's probably a good idea to drop in some kind \n    of BRDF (bidirectional reflectance distribution function) routine, \n    which is what I've done here.\n    \n    I hacked a very basic BRDF routine together pretty quickly some time \n    ago, and it works well enough for the purpose of this example, but I \n    wouldn't use it for anything other than a basic introduction. By the\n    way, if you're an expert on the process, and I've made a mistake that\n    can't be ignored, feel free to let me know.\n    \n    The Bauhaus pattern itself is nothing special. You can find them in\n    abundance online, but I haven't seen them in variable heightmap form, \n    so I thought it'd be fun to do that. Technically speaking, the example\n    is interesting in the sense that every cell is only rendered once, \n    which is made possible using a cell wall intersection trick that I've\n    covered previously.\n    \n    I've included a heap of define options below, for anyone interested in\n    playing around with different design settings.\n    \n\n\n    Other examples:\n\n    // A much nicer implementation.\n    Disney Principled BRDF - markusm\n    https://www.shadertoy.com/view/XdyyDd\n\n\n*/\n \n\n// Paint on some edging.\n#define EDGES\n\n// Put some rivet holes on random objects.\n#define HOLES\n\n// Ratio of metallic tiles to dielectric (non-conducting) ones.\n// Values range from zero (no metallic tiles) to one (all metallic).\n#define METAL_AMOUNT .35 // Range: [0, 1].\n\n// The color variety... I wasn't sure what to call this. Lower\n// numbers mean fewer colors. Changing the variety of colors used\n// changes the feel. I prefer fewer, but everyone's different.\n//\n// Greyscale 0, One color: 1, Two colors: 2, Four colors, 3\n#define COLOR_VARIETY 2\n\n// An override to display random material values and colors.\n//#define RANDOM_MATERIALS\n\n// Swizzle the palette from orange to purple based colors.\n//#define SWIZZLE_PALETTE\n\n// Relative amount of metallic tiles that are gold. For initial\n// design reasons, the default is undefined.\n//#define GOLD_AMOUNT .35 // Range: [0, 1].\n\n// Subtle textured lines.\n//#define LINES\n\n \n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n \n// Hacked together from IQ, Nimitz and Fabrice's hash functions.\nvec3 hash23(in vec2 f){\n     \n    uvec2 p = floatBitsToUint(f);\n    uint  n = 1103515245U*((p.x)^(p.y>>3U));\n    // Converting a uint to a uvec3:\n    // These numbers came from here:\n    // Quality hashes collection WebGL2 - Nimitz.\n    // https://www.shadertoy.com/view/Xt3cDn\n    uvec3 u3 = uvec3(1, 16807U, 48271U);\n    return vec3(((u3*n) >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n    \n    // Dave Hoskins's reliable hash function.\n\t//vec3 p3 = fract(f.xyx*vec3(.1031, .1030, .0973));\n    //p3 += dot(p3, p3.yxz + 423.123);\n    //return fract((p3.xxy+p3.yzz)*p3.zyx);\n     \n}\n \n \n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n    \n// Height map value, which is just the pixel's greyscale value.\n//vec3 hm3(in vec2 p){ return texture(iChannel2, p*563.837, -100.).xyz; }\nvec3 hm3(in vec2 p){ return hash23(p); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n \n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nfloat scale = 1./1.5;\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n \n \nvec2 gIP;\n\n// An extended square grid 2D Truchet routine: Split into square tiles\n// as per usual, then produce the distance fields and ID for simple \n// shapes inside them. The kinds of shapes you render is up to you.\n//\n// This is 2D function called once per raymarching iteration, so it \n// needs to be reasonably quick, but not blindingly fast. I also wanted\n// it to be a little bit readable, so I didn't go out of my way to \n// tweak it. If speed was the goal, then I'd be more inclined to render\n// it to a backbuffer, rather than turn it into an unreadable mess, but\n// to each their own.\nvoid tr(inout vec2 oP, inout vec3 d, inout vec2[3] id, int oID){\n\n\n    vec2 p = oP;\n    \n    // Row and column offset variable.\n    vec2 offs = vec2(0);\n    // Row and column ID.\n    vec2 ii = floor(p/scale);\n    /*\n    // Offset columns.\n    if(mod(ii.x, 2.)<.5){ \n        p.y -= scale/2.;\n        offs.y += .5;\n    } \n    */ \n    /*\n    // Offset rows.\n    if(mod(ii.y, 2.)<.5){ \n        p.x -= scale/2.;\n        offs.x += .5;\n    } */\n    \n    \n    #ifndef RANDOM_MATERIALS\n    // Animated offset columns.\n    // Time, beginning at random intervals.\n    float t = iTime/8. + hash21(vec2(2, ii.x));\n    float iT = floor(t); // Integer time increments to keep track of position.\n    float fT = t - iT; // Fractional time increment used for animation.\n    \n    // Smoothly slide the columns at random time intervals. \n    float dir = mod(ii.x, 2.)<.5? -1. : 1.;\n    p.y += dir*(smoothstep(0., .0625, fT) + .25)*scale;\n    offs.y = dir*(iT + .25); \n    #endif\n   \n    // Positional cell ID and local coordinates. If you didn't want to shift\n    // rows and columns, you wouldn't need any of the code above, nor would you\n    // need the three lines below.\n    vec2 ip = floor(p/scale);\n    p -= (ip + .5)*scale;\n    \n    \n    ip += offs; // Update the positional cell ID with the sliding offset.\n    gIP = ip; // Record the ID for usage elsewhere.\n    oP = p; // Record the local position.\n \n\n     \n    // Random local coordinate rotation.\n    float rnd = hash21(ip + .05);\n    p *= rot2(floor(rnd*64.)*3.14159/2.);\n   \n     // A second random number that determines what kind of tile to draw.\n    float rnd2 = hash21(ip + .1);\n\n    \n    // Three distances and IDs, to represent up to three shapes per cell.\n    d = vec3(1e5);\n    id = vec2[3](vec2(0), vec2(0), vec2(0));\n    \n    \n    // Based on the random choice above, render one of three types of\n    // tiles. I hacked this together to get the job done, so there'd no\n    // doubt be more efficient ways to do this, but this seems fast \n    // enough on my machine, and it's readable enough, so it'll do.\n    if(rnd2<.3){\n    \n        // Triangles.\n         \n        // Square boundary.\n        vec2 q = abs(p);\n        float sq = max(q.x, q.y) - .5*scale;\n        \n        // The diagonal center line.\n        q = p;\n        d.x = (p.x + p.y)*.7071;\n        id[0] = ip - .25; // ID for this side of the line.\n\n        // The other side of the diagonal line.\n        d.y = max(sq, -d.x);\n        id[1] = ip + .25; // ID for the other side.\n        \n        // Use the square boundary to render the other two lines.\n        // This will leave you with two triangles... Probably not\n        // real distance field values, but no one will notice.\n        d = max(d, sq);\n        \n        oID = 0; // Record the overall square cell ID.\n        \n        \n    }\n    else if(rnd2<.5){\n    \n        // Square with central circle tile.\n        \n        // Circle.\n        vec2 q = p;\n        d.x = length(q) - 1./2.*.7071*scale + .05;\n        id[0] = ip; // Center ID for the circle.\n\n        // The remainder of the rectangle.\n        q = abs(p);\n        d.y = max(q.x - .5*scale, q.y - .5*scale);\n        d.y = max(d.y, -d.x);\n        id[1] = ip + vec2(-.25, 0); // Off to the side for the remainder.\n        \n        oID = 1; // Square cell ID.\n    }\n    else {\n    \n        // Three circular arcs.\n    \n        // Square boundary.\n        vec2 q = abs(p);\n        float sq = max(q.x, q.y) - .5*scale;\n        \n        float qrtr = length(p - .5*scale) - .5*scale; // Quarter.\n        float semi = length(p - .5*scale) - 1.*scale; // Semi circle.\n    \n        d.x = qrtr; // Inner quarter.\n        id[0] = ip - .25;\n        \n        d.y = max(semi, -qrtr); // Middle arc.\n        id[1] = ip + vec2(0);\n        \n        \n        \n        d.z = max(sq, -semi); // Outer quarter.\n        id[2] = ip + .25;\n        \n        // Using the square boundary to form the three bounded arcs.\n        d = max(d, sq);\n        \n        oID = 2; // Square cell ID.\n    \n    }\n\n    \n    // Shape border line width.\n    float lw = .015*scale;\n    d += lw;\n    \n    \n    // Rivet offset distance.\n    float rvO = (1./2. - 1./4.*.7071)*scale;\n    \n    // Rivet nole distance.\n    float rv;\n   \n    // Rivet holes.\n    if(oID == 1){\n        // Square corner holes.\n        vec2 q = abs(p) - rvO;\n        rv = length(q);\n    }\n    else {\n        \n        // Triangle holes and corner arc holes.\n        vec2 q = p;\n        rv = length(q - rvO);\n        rv = min(rv, length(q + rvO));\n        \n        if(oID == 2){\n           // Central arc rivet position.\n           vec2 arcR = vec2(rvO, -(1.*scale - lw)/4.);\n           rv = min(rv, min(length(p - arcR), length(p.yx - arcR)));\n           \n        }    \n    } \n    \n    // Smaller rivet holes when using edging.\n    #ifdef EDGES\n    float hw = .035;\n    #else\n    float hw = .045;\n    #endif\n \n    // Use CSG for some random rivet holes.\n    #ifdef HOLES\n    if(hash21(ip + .08)<.35){\n       d = max(d, -(rv - hw*scale));\n    }\n    #endif\n \n}\n\n  \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // 2D Truchet distance, for the extrusion cross section.\n    vec3 d; vec2[3] id; int oID;\n    vec2 gP = p.xy;\n    tr(gP, d, id, oID);\n \n    // Extrude the 2D Truchet object along the Z-plane.\n    //vec3 h3 = vec3(hm(id[0]), hm(id[1]), hm(id[2]))*.25 + .05;\n    // A bit of face beveling to reflect the light a little more.\n    vec3 bev = min(-d*6., .2)*.03; // 03;\n    vec3 h3 = hm3(gIP)*.25 + .05;\n    float obj = opExtrusion(d.x, p.z, h3.x, .015) - bev.x; \n    obj = min(obj, opExtrusion(d.y, p.z, h3.y, .015) - bev.y); \n    if(oID==0) obj = min(obj, opExtrusion(d.z, p.z, h3.z, .015) - bev.z); \n  \n    // Directional ray collision with the square cell boundaries.\n    vec2 rC = (gDir.xy*scale - gP)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .0015; // Adding a touch to advance to the next cell.\n \n     \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.7, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = m(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*PI);\n  \n}\n////////////////////\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.5, 1, 1.5);\n    //vec3(-2.5, 2.5, -1.25);\n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n    \n    // Mouse camera movement.\n    if(iMouse.z>1.){\n        r.yz *= rot2(-.5*(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        r.xz *= rot2(-.25*(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);\n    } \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(r)*.5;\n    gRd = r; \n\n    \n    // Raymarch.\n    for(int i = min(iFrame, 0); i<96; i++){ \n        \n        vec3 p = o + r*t;\n        d = m(p); // Surface distance.\n        // Surface hit -- No far plane break, since it's just the floor.\n        if(abs(d)<.001) break; \n        t += min(d*.9, gCD);  // Advance the overall distance closer to the surface.\n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n \n \n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    \n        // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.05); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    /*\n    // Old diffuse and specular calculations.\n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    float fr = pow(max(1. + dot(r, n), 0.), 2.); // Fresnel.\n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    */\n    \n    // 2D Truchet face distace -- Used to render borders, etc.\n    //scale *= 3.;\n    vec3 d3; vec2[3] vID; int oID;\n    vec2 p2 = p.xy;\n    tr(p2, d3, vID, oID);\n    \n    // Minimum tile object index.\n    int index = (d3.x<d3.y && d3.x<d3.z)? 0 : d3.y<d3.z? 1 : 2;\n    // 2D object face distance and ID.\n    float obj2D = d3[index];\n    vec2 id = vID[index]*scale;\n    \n    // Object heights.\n    vec3 h3 = hm3(gIP)*.25 + .05;\n    float h = h3[index];\n\n \n    // Texture position.\n    vec3 txP = vec3(p2, p.z);\n    vec3 txN = n;\n    vec3 tx = tex3D(iChannel1, txP/2., txN);//vec3(.25);//\n\n    \n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 24.;\n    float pat = (abs(fract((p2.x - p2.y)*lSc - .5) - .5) - .125)/lSc;\n    #endif  \n    \n\n  \n    // Standard material properties: Roughness, matType and reflectance.\n    //\n    float roughness = .2; // Lower roughness reflects more light, as expected.\n    float matType = 0.; // Dielectric (non conducting): 0, or metallic: 1.\n    float reflectance = .5; // Reflective strength.\n    \n    \n    // Object color.\n    vec3 oCol = vec3(0);\n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n    \n       // Floor -- Redundant here, but I've included it anyway.\n       oCol = vec3(.125);\n       matType = 1.; // Metallic material.\n       roughness = .5;\n       \n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Truchet:\n\n        // Noise texture, used for a hacky scratched surface look.\n        // Usually, you'd tailor this to specific material needs.\n        vec3 txR = txP;\n        txR.xy *= rot2(-3.14159/6.);\n        vec3 rTx = tex3D(iChannel2, txR*vec3(.5, 3, .5), txN);\n        float rGr = dot(rTx, vec3(.299, .587, .114));\n \n        \n        // The tile base color.\n         \n        float sRnd = hash21(id + .01); // Random tile component value.\n        \n        //sRnd = id.x;\n        vec3 sCol = .5 + .45*cos(6.2831*sRnd/8. + (vec3(0, 1, 2) + .05));//vec3(1, .15, .45);\n        sCol = pow(sCol, vec3(1.5));\n        \n        #if COLOR_VARIETY >= 2\n        if(hash21(id + .27)<.35) sCol = sCol.zyx; //yzx\n        #endif\n        \n        #if COLOR_VARIETY >= 3\n            #ifdef SWIZZLE_PALETTE\n            if(hash21(id + .15)<.35) sCol = mix(sCol, sCol.yxz, .5);\n            #else\n            if(hash21(id + .15)<.35) sCol = mix(sCol, sCol.xzy, .5);\n            #endif\n        #endif\n \n        // Face rim and face distance values for edge rendering. \n        float b = abs(obj2D) - .01;\n        float pH = p.z + h - .04;\n        b = max(b, (p.z + h - .02));\n        \n        float sf = .01; // Smoothing factor.\n        float ew = .02; // Edge width.\n        \n        #ifdef RANDOM_MATERIALS\n        float rRnd = hash21(gIP + .11);\n        sCol = .5 + .45*cos(6.2831*rRnd + vec3(0, 1, 2)*hash21(gIP + .4)*1.5);\n        #endif\n        \n        #ifdef EDGES\n        \n            float rW = .035; // Rim width.\n            \n            oCol = sCol;\n            oCol = mix(oCol*.8, oCol*.15, (1. - smoothstep(0., sf, pH)));\n            oCol = mix(oCol, mix(min(sCol*1.4, 1.), vec3(1), .2), (1. - smoothstep(0., sf, pH + ew)));\n            oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, obj2D + rW)));\n\n            #ifdef LINES\n            // If applicable, apply lines to the inner face color.\n            sCol = mix(sCol*1.15, sCol*.7, (1. - smoothstep(0., sf, pat)));\n            #endif\n            oCol = mix(oCol, sCol, (1. - smoothstep(0., sf, obj2D + rW + ew)));\n        #else\n        \n            oCol.xyz = sCol;\n            #ifdef LINES\n            // If applicable, apply lines to the inner face color.\n            pat = max(pat, pH + .02);\n            oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, abs(pH + .02) - ew/2.)));\n            oCol = mix(oCol*1.1, oCol.xyz*.7, (1. - smoothstep(0., sf, pat)));\n            #endif\n            \n        #endif          \n          \n        \n        // Greyscale value, calculated prior to gradient coloring.\n        float gr = dot(oCol.xyz, vec3(.299, .587, .114));\n        \n        // Subtle face color gradient.\n        oCol = mix(oCol, oCol.xzy, clamp(-p2.y - .125, 0., 1.));\n        //oCol.xyz = mix(oCol.xyz, oCol.xzy, clamp(obj2D/scale*3. + .5, 0., 1.));\n\n        #if COLOR_VARIETY == 0\n        oCol.xyz = vec3(gr*sqrt(gr)*1.5);\n        #endif\n        \n        #ifdef SWIZZLE_PALETTE\n        oCol = oCol.yzx;\n        #endif\n   \n      \n        #ifndef RANDOM_MATERIALS   \n        if(hash21(id + .2)<METAL_AMOUNT){\n        //if(hash21(gIP + .2)<.25){ // gPI: Square cell ID.\n        //if(mod(floor(gIP.x) + floor(gIP.y), 2.)>.5){ \n            \n            \n            // Metal material.\n            \n            // Mostly grey with tiny leftover color residue.\n            oCol = mix(oCol, vec3(gr), .9);\n             \n            // Gold. Interesting, but a bit much for this example,\n            // so the default is set to zero.\n            #ifdef GOLD_AMOUNT\n            if(hash21(id + .43)<GOLD_AMOUNT) oCol.xyz *= vec3(1, .75, .4)*2.5;\n            #endif\n\n            matType = 1.; // Metallic material.\n            oCol.xyz *= tx*1. + .5;\n            roughness = .6;\n            //roughness *= gr*2.;\n            roughness *= rGr*.6 + .4;\n            \n            // Metallic materials look dark when compared to their non-conducting \n            // dielectric equivalent, so for design sake, we're artificially \n            // inflating the brightness.\n            //sCol *= 1.5;\n        }\n        else {\n        \n            // Dielectic material.\n            \n            roughness = .3;\n            roughness *= (rGr*.4 + .6);\n            oCol *= tx*.6 + .9;\n             \n        }\n        #endif\n        \n        #ifdef RANDOM_MATERIALS\n        roughness = hash21(gIP + .31)*(rGr*.5 + .5);\n        matType = step(.5, hash21(gIP + .32));\n        reflectance = hash21(gIP + .33);\n        oCol *= tx*2.5 + .2;// + .5;\n        #endif\n        \n        \n        \n    }\n\n    /*\n    // Requires \"St Peter's Basillica\" cube map loaded into \"iChannel3\".\n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel3, -ref.yzx, 1.); refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    //spRef = mix(spRef/4., spRef, 1. - smoothstep(0., .01, d + .05));   \n    float rf = (matType < .5)? .25 : 2.;//mix(.25, 4., 1. - smoothstep(0., .01, d + .05));\n    oCol += oCol*reflectance*spRef*refTx.zyx*rf; //smoothstep(.03, 1., spRef) \n    */\n\n\n    // I wanted to use a little more than a constant for ambient light this \n    // time around, but without having to resort to sophisticated methods, then I\n    // remembered Blackle's example, here:\n    // Quick Lighting Tech - blackle\n    // https://www.shadertoy.com/view/ttGfz1\n    float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; // Studio.\n    //float am = length(sin(n*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -n.z); // Outdoor.\n \n    // Cook-Torrance based lighting.\n    vec3 ct = BRDF(oCol, n, ld, -r, matType, roughness, reflectance);\n        \n    // Combining the ambient and microfaceted terms to form the final color:\n    // None of it is technically correct, but it does the job. Note the hacky \n    // ambient shadow term. Shadows on the microfaceted metal doesn't look \n    // right without it... If an expert out there knows of simple ways to \n    // improve this, feel free to let me know. :)\n    c.xyz = (oCol*am*(sh*.5 + .5) + ct*(sh))*ao*at;\n     \n \n    // Save the linear color to the backbuffer.\n    c = vec4(max(c.xyz, 0.), t);  \n\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2fzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 907, 944, 990, 1731], [1854, 1854, 1908, 1935, 2302]], "test": "untested"}
{"id": "clBfzD", "name": "2D PROJECTIVE GEOMETRIC ALGEBRA", "author": "ENDESGA", "description": "big thanks to sudgylacmoe's video: [url]https://youtu.be/0i3ocLhbxJ4[/url]", "tags": ["algebra", "geometric", "projective", "pga"], "likes": 10, "viewed": 346, "published": 3, "date": "1693806867", "time_retrieved": "2024-07-30T17:35:33.697534", "image_code": "#define M iMouse.xy\n#define W iResolution.x\n#define H iResolution.y\n#define line vec3\n#define point vec2\n#define EPSILON 0.0001\n#define INFINITY 1e7\n#define AA( uv ) ( 0.5 * ( dFdx( uv.x ) + dFdy( uv.y ) ) )\n\n#define CYAN vec4( 0, 1, 1, 1 )\n#define MAGENTA vec4( 1, 0, 1, 1 )\n#define YELLOW vec4( 1, 1, 0, 1 )\n\n// line that joins two points\nline join( point P1, point P2 )\n{\n\treturn vec3( P1.y - P2.y, P2.x - P1.x, P1.x * P2.y - P1.y * P2.x );\n}\n\n// point that meets two lines\npoint meet( line L1, line L2 ) {\n    return point( L1.y * L2.z - L1.z * L2.y, L1.z * L2.x - L1.x * L2.z ) / ( L1.x * L2.y - L1.y * L2.x );\n}\n\n// \"distance\" between line and point\nfloat dist( line L, point P )\n{\n\treturn ( P.x * L.x + P.y * L.y );\n}\n\n// \"distance\" between point and line\nfloat dist( point P, line L )\n{\n\treturn ( dist( L, P ) + L.z ) / ( L.x * L.x + L.y * L.y );\n}\n\n// project point to line\npoint project( point P, line L )\n{\n\treturn P - ( dist( P, L ) * L.xy );\n}\n\n// project line to point\nline project( line L, point P )\n{\n\treturn line( L.xy, -( P.x * L.x + P.y * L.y ) );\n}\n\n// reflect point across line (2x projection)\npoint mirror( point P, line L )\n{\n\treturn P - ( 2. * dist( P, L ) * L.xy );\n}\n\n// reflect line across point (2x projection)\nline mirror(line L, point P) {\n    return line(L.xy, L.z - dot(L.xy, 2.0 * (P - project(P, L))));\n}\n\n\n//\n\nvec4 draw_col = vec4( 0 );\n\nvoid draw_line( in vec2 uv, in line L, in vec4 line_col )\n{\n\tfloat dist = abs( dist( L, uv ) + L.z ) / length( L.xy );\n\tfloat aa = AA( uv );\n\tdraw_col = mix( draw_col, line_col, smoothstep( aa, -aa, dist - 2. ) );\n}\n\nvoid draw_point( in vec2 uv, point P, in vec4 point_col )\n{\n\tfloat dist = length( uv - P );\n\tfloat aa = AA( uv );\n\tdraw_col = mix( draw_col, point_col, smoothstep( aa, -aa, dist - 12. ) );\n}\n\nvoid mainImage( out vec4 col, in vec2 uv )\n{\n\tpoint P11 = point( 32, 32 );\n\tpoint P12 = M;\n\tpoint P21 = point( 64, ( H / 2. ) - ( sin( iTime * 2. ) * 64. ) );\n\tpoint P22 = point( ( W / 2. ) - ( cos( iTime * 2. ) * 64. ), 64 );\n\n\tline L1 = join( P11, P12 );\n\tline L2 = join( P21, P22 );\n\n\tpoint PM1 = meet( L1, L2 );\n\tpoint PP0 = point( ( W / 2. ) + ( sin( iTime ) * 64. ), ( H - 128. ) + ( cos( iTime ) * 64. ) );\n\tpoint PP1 = project( PP0, L1 );\n\tline LP1 = mirror( L1, PP0 );\n\tline LP2 = join( PP1, P22 );\n\n\tdraw_line( uv, L1, CYAN );\n\tdraw_line( uv, L2, MAGENTA );\n\tdraw_line( uv, LP1, CYAN );\n\tdraw_line( uv, join( PP0, PP1 ), YELLOW );\n\tdraw_line( uv, LP2, MAGENTA );\n\n\tdraw_point( uv, P11, MAGENTA );\n\tdraw_point( uv, P12, CYAN );\n\tdraw_point( uv, mirror( P12, LP2 ), CYAN );\n\tdraw_point( uv, P21, MAGENTA );\n\tdraw_point( uv, P22, MAGENTA );\n\n\tdraw_point( uv, PM1, YELLOW );\n\tdraw_point( uv, PP0, YELLOW );\n\tdraw_point( uv, PP1, YELLOW );\n\n\tcol = draw_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 341, 374, 374, 445], [447, 477, 509, 509, 617], [619, 656, 687, 687, 724], [726, 763, 794, 794, 856], [858, 883, 917, 917, 956], [958, 983, 1016, 1016, 1068], [1070, 1115, 1148, 1148, 1192], [1194, 1239, 1269, 1269, 1338], [1373, 1373, 1432, 1432, 1588], [1590, 1590, 1649, 1649, 1780], [1782, 1782, 1826, 1826, 2746]], "test": "untested"}
{"id": "DtjfRh", "name": "Star Wars: The Force Awakens", "author": "dean_the_coder", "description": "Live long and prosper.", "tags": ["3d", "raymarching", "reflections", "scifi", "movie"], "likes": 53, "viewed": 883, "published": 3, "date": "1693759802", "time_retrieved": "2024-07-30T17:35:34.643006", "image_code": "// 'Star Wars: The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/DtjfRh\n// YouTube: https://youtu.be/WMf8LMZy3l0\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - SDF fine details only modelled when ray is near a surface.\n//   - Using bump maps over SDF displacement where possible.\n//     (Displacing an SDF is much more expensive at the code is\n//     ever time the ray moves, whereas a bump is only applied once\n//     when the ray has hit a surface.)\n//   - AA only applied on pixels where the neighbouring\n//     pixel is a significantly different color.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define CHROMATIC\t0.003\n#define LENS\t0.005\n\n#define _res iResolution\n#define _tex0 iChannel0\n\nvec2 fisheye(vec2 uv) {\n\tuv -= 0.5;\n\tuv *= pow(dot(uv, uv), LENS);\n\treturn uv + 0.5;\n}\n\n// Thnx Dave_Hoskins\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .1030, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n\tp += 353.627;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat film(vec2 uv) {\n\t// Film grain.\n\tfloat c = (h21(uv * _res.xy) - 0.5) / 64.;\n\n\t// Lens dust.\n\tuv *= 4.;\n\tfloat sm = 0.1;\n\tfor (int i = 0; i < 3; i++, uv++) {\n\t\tvec2 p = fract(uv) - 0.5,\n\t\t     id = floor(uv);\n\t\tfloat s = h21(id) * sm;\n\t\tp += h22(id) * (1.0 - sm) * 0.5;\n\t\tc = max(c, smoothstep(s, s * 0.5, length(p)) * 0.02);\n\t\tsm *= 0.5;\n\t\tuv *= 2.282;\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord / _res.xy;\n\n\t// Lens distortion.\n\tuv = fisheye(uv);\n\n\t// Chromatic aberration.\n\tvec2 ca = (uv - 0.5) * CHROMATIC;\n\tfragColor = vec4(texture(_tex0, uv + ca).r, texture(_tex0, uv).g, texture(_tex0, uv - ca).ba);\n\tif (fragColor.w > 0.0) fragColor.rgb += film(uv * vec2(1, _res.y / _res.x));\n\n\t// Color correction.\n\tfragColor = pow(fragColor, vec4(0.4545));\n\n\t// Vignette.\n\tuv -= 0.5;\n\tfragColor *= 1.0 - 0.5 * dot(uv, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34626, "src": "https://soundcloud.com/planewhitenoise/plane-engine", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// 'Star Wars: The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/DtjfRh\n// YouTube: https://youtu.be/WMf8LMZy3l0\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n//#define AA    // Disable if your GPU is melting.\n\n#define LIGHT_RGB\tvec3(2, 1.6, 1.4)\n#define R\t_res\n#define Z0\tmin(_t, 0.)\n#define I0\tmin(int(_t), 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S\tsmoothstep\n#define S01(a)\tS(0., 1., a)\n\n#define _res iResolution\n#define _tex0 iChannel0\n#define _t iTime\n\nfloat t, xw, roll,\n      fade = 1.;\nvec2 g;\nvec3 lp, xp;\n\nstruct Hit {\n\tfloat d, id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, float id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat mul2(vec2 v) { return v.x * v.y; }\n\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h31(vec3 p) {\n\tp = fract(p * .3183099 + .1);\n\tp *= 17.;\n\treturn fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat h21(vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat n21(vec2 p) {\n\tvec2 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(h21(i), h21(i + vec2(1, 0)), f.x), mix(h21(i + vec2(0, 1)), h21(i + 1.), f.x), f.y);\n}\n\nfloat n31(vec3 p) {\n\tvec3 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(mix(h31(i), h31(i + vec3(1, 0, 0)), f.x), mix(h31(i + vec3(0, 1, 0)), h31(i + vec3(1, 1, 0)), f.x), f.y), mix(mix(h31(i + vec3(0, 0, 1)), h31(i + vec3(1, 0, 1)), f.x), mix(h31(i + vec3(0, 1, 1)), h31(i + 1.), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p, float roughness) {\n\tint octaves = 4;\n\tfloat sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\tfor (int i = I0; i < octaves; i++) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nvec3 randomPos(float seed) {\n\tvec4 s = vec4(seed, 0, 1, 2);\n\treturn vec3(h21(s.xy), h21(s.xz), h21(s.xw)) * 1e2 + 1e2;\n}\n\nfloat fbmDistorted(vec3 p, float roughness, float distortion) {\n\tp += (vec3(n31(p + randomPos(0.)), n31(p + randomPos(1.)), n31(p + randomPos(2.))) * 2. - 1.) * distortion;\n\treturn fbm(p, roughness);\n}\n\nfloat sabs(float f) { return sqrt(f * f + .1); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 ryz(vec3 p, float a) {\n\tp.yz *= rot(a);\n\treturn p;\n}\n\nvec3 dx(vec3 p, float e) {\n\tp.x += e;\n\treturn p;\n}\n\nvec3 dy(vec3 p, float e) {\n\tp.y += e;\n\treturn p;\n}\n\nvec3 dz(vec3 p, float e) {\n\tp.z += e;\n\treturn p;\n}\n\nvec3 ay(vec3 p, float d) { return vec3(p.x, abs(p.y) - d, p.z); }\n\nvec3 az(vec3 p) { return vec3(p.xy, abs(p.z) + .05); }\n\nfloat weld(float a, float b, float r) {\n\t// Thanks Mercury - http://mercury.sexy/hg_sdf/\n\treturn min(min(a, b), (a - r + b) * .70711);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float r) {\n\tp.x -= clamp(p.x, 0., .3);\n\treturn length(p) - r;\n}\n\nfloat hex3D(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.zy -= 2. * min(dot(k.xy, p.zy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.zy - vec2(clamp(p.z, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.x - h.y);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nfloat greeble(vec3 p) {\n\tfloat h = .005,\n\t      d = p.y;\n\tfor (float i = 1.; i <= 3.; i++) {\n\t\tvec3 q = p;\n\t\tq.xz = fract(p.xz) - .5;\n\t\tvec2 r = h22(floor(p.xz) + i * 2.2);\n\t\td = min(d, box(q, vec3(.05 + .35 * r, h * (.5 + .5 * fract(r.x * 157.324))).xzy));\n\t\th *= 1.5;\n\t\tp.xz *= 1.5;\n\t\tp.xz += .5 / i;\n\t}\n\n\treturn d * .8;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 skyCol(float y) { return pow(vec3(max(1. - y * .5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7))); }\n\nvec3 sky(vec3 rd) {\n\tvec3 p,\n\t     col = skyCol(rd.y);\n\tfloat den,\n\t      d = 10. / rd.y;\n\tif (d < 0.) return col;\n\tp = rd * d + vec3(4, .2, 1) * t * .2;\n\tp.xz *= .2;\n\tden = 1.;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.06 * fbm(p, .5));\n\n\treturn mix(col, LIGHT_RGB, S(.8, 1., den) * (1. - sat(d / 1e2)));\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) / 1.73205;\n}\n\nfloat texScratches(vec3 p) {\n\tfloat sh = S(.85, 1., n31(p * vec3(80, 12, 1)));\n\tp.xy = p.yx * mat2(.76031, .64956, -.64956, .76031);\n\treturn max(sh, S(.85, 1., n31(p * vec3(80, 10, 1))));\n}\n\nfloat taperHex(vec3 p, float w, float h1, float h2, float l, float s, float wt) {\n\tw *= 1. - (p.x / l + .5) * wt;\n\treturn max(hex3D(p, vec2(w * .5, l * .5) - s) - s, abs(p.y) - mix(h1, h2, p.x / l + .5) * .5);\n}\n\nfloat wing(inout vec3 op) {\n\top.x += .25;\n\top.z = abs(op.z);\n\top = ryz(ay(dz(op, -.26), .02), xw * -.2);\n\tvec3 q,\n\t     p = op;\n\n\t// Wing.\n\tfloat d, l,\n\t      f = .05;\n\tf += p.z * .1;\n\tf += .065 * step(p.z, .5);\n\td = box(dx(p, -f), vec3(.4 - f, .005, 1.6));\n\tp.x -= .15;\n\tp.z -= .4;\n\n\t// Engine.\n\tf = .2 - .05 * S(.2, 0., p.x);\n\td = weld(d, max(cyl(p, vec2(f, .45)), -p.y - .005), .04 * step(0., p.y));\n\n\t// Exhaust.\n\tq = p - vec3(-.72, .16, 0);\n\tf = .04 - .003 * sat(sin(atan(q.y, q.z) * 16.)) * S(.05, .04, q.x);\n\tf += .003 * S(.02, .03, abs(abs(q.x - .15) - .05));\n\tf = cap(q, f);\n\tl = length(q + vec3(.06, 0, 0));\n\tf = max(f, .08 - l);\n\td = weld(d, f, .015);\n\tg.x += .02 / (.01 + l * l * 10.) * S(.05, -.05, q.x);\n\n\t// Inlet.\n\td = smin(d, -max(max(length(p.yz) - .17, -.02 - p.y), abs(p.x - .45) - .05), -.05);\n\n\t// Gunz.\n\tp -= vec3(.05, .026, 1.2);\n\td = min(d, cyl(p, vec2(.03 - .01 * S(.31, .32, abs(p.x)), .33)));\n\tp.x -= .5;\n\td = min(d, cyl(p, vec2(step(p.x, 0.) * .005, .4)));\n\tp.x -= .32;\n\tp.yz *= mat2(.49757, .86742, -.86742, .49757);\n\tf = length(p.xy);\n\treturn min(d, max(max(max(f - .04, .045 - f), p.x), abs(p.z) - .006)) * .95;\n}\n\nfloat mountains(vec3 p) {\n\tp.z = abs(p.z);\n\tp += vec3(32. * t * .3, 2, -45);\n\tfloat d = length(p.yz);\n\t\n\tif (d < 13.0)\n\t    d -= fbm(vec3(p.x * .5, 0, p.z) * .1, .4) * 12.;\n\treturn smin(d, p.y + 2., 8.) * .9;\n}\n\nHit sdf(vec3 p) {\n\tp.x += .5;\n\t\n\tvec3 q,\n\t     op = p;\n\tHit h;\n\th.d = 1e7;\n\tU(h, mountains(p), 7., p);\n\t\n\t// Movement.\n\tp -= xp * vec3(1, 2, 1);\n\tp.yz *= rot(roll);\n\n\t// Rear body.\n\tfloat f, d = taperHex(az(p), .6, .7, .5, .9, 0., .19);\n\td = smin(d, max(box(p, vec3(.45, .35, .2)), -p.y), .02);\n\td = max(d, abs(p.z) + p.y * .45 - .3);\n\td = max(d, p.y - p.x * .2 - .38);\n\td = max(d, -p.y - p.x * .1 - .24);\n\n\t// Rear end bit.\n\td = weld(d, box(ay(dy(dx(p, .4), -.05), .1), vec3(.12, .08, .08)), .02);\n\n\t// Wings.\n\tq = p;\n\tif (abs(p.z) < 7.0)\n\t    U(h, wing(q), 3.005, q);\n\n\t// Fuselage.\n\tq = p;\n\tq.x -= 1.7;\n\td = min(d, taperHex(q, .4, .36, .21, 2.5, 0., .3));\n\n\t// Nose.\n\tq.x -= 1.45;\n\tf = taperHex(q, .32, .26, .05, .6, .03, .4);\n\tf = max(f, q.y * .5 - q.x - .25);\n\tq.y -= .1;\n\tf = max(f, -box(q, vec3(.15, .04, .06)));\n\td = min(d, f);\n\n\t// BB-8\n\tq = p - vec3(.15, .37, 0);\n\tf = box(q, vec3(.23, .05, .1));\n\td = max(d, -f);\n\t\n\tif (f < 0.1)\n\t    f = max(f, greeble(dy(p, -.32) * vec3(6, 1, 6)));\n\td = min(d, f);\n\tf = length(p - vec3(.25, .31, 0));\n\td = max(d, .082 - f);\n\tU(h, d, 2.005, p);\n\tq = p - vec3(.25, .37, 0);\n\tU(h, f - .05, 8.01, q);\n\tq.xz *= rot(n21(vec2(t, t)) * 2.5 - 1.8);\n\tU(h, length(q) - .03, 8.01, q);\n\td = max(cyl(dy(q, -.015), vec2(0, .032)), -q.x);\n\td = min(d, cyl(dy(q.yxz, .01), vec2(-.008, .06)));\n\tU(h, d, 6.045, q);\n\n\t// Cockpit.\n\tq = p;\n\tq.xy -= vec2(.865, .16);\n\td = taperHex(q, .35, .4, .02, .8, 0., .4);\n\tU(h, d, 6.045, p);\n\n\t// Water level.\n\tp = op;\n\td = p.y + 2.;\n\n\t// Water plume.\n\tif (xp.y < 0.8) {\n    \tq = p.zyx;\n    \tq.z += 2. + xp.y * 10.;\n    \tq.x = sabs(q.x) - 2. * (1. - xp.y) + q.z * .3;\n    \tq.xy *= rot(-.4 * (1. - xp.y));\n    \tq.y += 5. + S(-4., 0., p.x) + xp.y * 4.;\n    \tf = cyl(q, vec2(4, sin((p.x + sign(p.z) * 4.) * .2 + t * 5.5) * .2));\n    \td = smin(d, f, 1. + 2. * S(0., -6., p.x) + sat(abs(p.z) * .5));\n    \tg.y += .01 / (.1 + f * f) * S(-.2, .1, q.x);\n\t}\n\n\tU(h, d, 4.3, p);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float d) {\n\tfloat h = d * .05;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\n\tfloat s = 1.,\n\t      l = .01,\n\t      mxL = length(p - lp);\n\tfor (float i = Z0; i < 30.; i++) {\n\t\tfloat d = sdf(l * ld + p).d;\n\t\ts = min(s, mix(50., 7., .8) * d / l);\n\t\tl += max(.03, d);\n\t\tif (mxL - l < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(mul2(.2 + .8 * ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, inout vec3 n, Hit h, float fogAdjust) {\n\tif (h.id == 0.) return sky(rd);\n\tfloat _ao, sha, fogY, fg,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, l, col, uv,\n\t     ld = normalize(lp - p);\n\n\t// Calculate ambient occlusion and shadows.\n\t_ao = ao(p, n);\n\tsha = shadow(p, ld, n);\n\n\tif (h.id == 6.045) {\n\t\tc = vec3(-.01);\n\t\tshine = 1.5 + n31(h.p * 40.);\n\t}\n\telse if (h.id == 2.005 || h.id == 3.005) {\n\t\tshine = 5.;\n\t\tspe = 150.;\n\t\tc = vec3(.03);\n\n\t\t// Orange.\n\t\tfloat f,\n\t\t      b = 0.;\n\t\tif (h.id == 2.005) {\n\t\t\t// Fuselage.\n\t\t\tif (abs(h.p.y - .035) < .04 && h.p.x > -.42 && h.p.x < 2.875 + h.p.y * .6) b = S(1., .995, sin(h.p.x * 5.));\n\t\t\telse b = float(abs(h.p.x - 2.2) < .2 && h.p.y > .09);\n\t\t}\n\t\telse {\n\t\t\t// Wings.\n\t\t\tif (abs(h.p.x - .52) < .02 && h.p.z < 1.) b = 1.;\n\t\t\telse b = float(abs(h.p.z - 1.1) < .35 && h.p.x - abs(h.p.z) * .15 > 0.);\n\n\t\t\tif (abs(h.p.x - .6) < .02 && h.p.z < 1.) c = vec3(.1, .1, .15);\n\t\t}\n\n\t\tb *= .5 + .5 * n31(h.p * 40.);\n\t\tc = mix(c, vec3(.4, .12, .01), b);\n\n\t\t// BB-8's nest.\n\t\tif (abs(h.p.x - .145) < .21 && abs(h.p.z) < .088 && h.p.y > .334) c *= 8.;\n\n\t\t// Dirt/scratches.\n\t\tf = texScratches(h.p.zyx * vec3(2, 12, 15) + 13.34);\n\t\tc += f * .1;\n\t\tshine *= 1. + f * 5.;\n\t\tc *= .1 + .9 * n31(h.p * 8.);\n\t}\n\telse if (h.id == 4.3) {\n\t\tc = vec3(.07, .12, .1);\n\n\t\t// Bump map the surface detail.\n\t\tfloat f = n31((p + vec3(t * 32., t, 0)) * vec3(1, 1, 10)) - .5;\n\t\tn = normalize(n + f * .1);\n\n\t\t// Plume.\n\t\tf = S(0., 1., h.p.y + 2.);\n\t\tf += S(.8, 1., h.p.y + 2.);\n\t\tc += vec3(.2 + 1. * fbmDistorted(p + vec3(t * 9.6, 0, 0), f, 3. * f)) * f;\n\t\tn = normalize(dz(n, sin(p.z * 8. * (1. - xp.y)) * f * .5));\n\t}\n\telse if (h.id == 7.) c = vec3(.1, .12, .06);\n\telse{\n\t\tc = vec3(.35, .35, .4);\n\t\tif (abs(h.p.y + .015) < .005 || abs(abs(h.p.y - .015) - .015) < .002 || length(h.p.yz + vec2(.06, 0)) < .03) c = vec3(.32, .1, .08);\n\t\telse if (abs(h.p.y - .036) < .002) c *= .5;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\n\tl.x *= fakeEnv(ld * 4.); // Light mask.\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl.yz *= _ao; // Ambient occlusion.\n\tl *= vec3(1, .6, .2); // Light contributions (key, reverse, sky).\n\n\t// Apply tinted shadows.\n\tl.x *= .1 + .9 * sha;\n\tvec3 skyTop = pow(vec3(max(.5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7)));\n\tc += skyTop * (1. - sha) * .2;\n\n\t// Specular (Blinn-Phong)\n\tshine *= sha; // No specular in the shadows.\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine;\n\n\t// Light falloff.\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\n\t// Combine the lights (key, reverse, sky).\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * skyTop) * c, skyTop, S(.6, 1., 1. + dot(rd, n)) * .02);\n\n\t// Simple fog layer.\n\tfogY = -1.; // Fog surface Y.\n\tuv = vec3(p.xz, fogY) * .4 + t * vec3(32, 0, .2); // Fog uv.\n\tfloat fogTex = fbm(uv, .5); // Depth (distance) from fogY to max fog.\n\tfogY -= (1. - fogTex) * .3; // Surface deviation.\n\tfg = S(0., -.3, p.y - fogY);\n\n\tfg *= .1 + .3 * fogTex; // Fog texture.\n\tfg *= 1. - sat(-rd.y); // Shallow angle = More fog.\n\n\t// Distance Fog.\n\tfg += (1. - exp(dot3(p - ro) / -fogAdjust * 1e-4));\n\n\treturn mix(pow(vec3(max(1., 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7))), col, 1. - sat(fg));\n}\n\nvec3 xwingPos() {\n\tvec3 p = vec3(0, .8 + .2 * sin(t * .5), sin(t) + sin(t * .3));\n\tfloat f = S(14., 10., t) + S(18., 20., t) * 1.1;\n\tp.zy *= f;\n\troll = (cos(t) + .3 * cos(t * .3)) * .1;\n\txw = S(12., 14., t);\n\tp.xz *= .1 + .9 * S(3., 6., t);\n\treturn p;\n}\n\nfloat addFade() { return min(1., abs(t)); }\n\nvec4 march(vec3 ro, vec3 rd) {\n\tg = vec2(0);\n\tfade = addFade();\n\txp = xwingPos();\n\tlp = vec3(0, .001, -20);\n\tlp.yz *= mat2(.41305, -.91071, .91071, .41305);\n\tlp.xz *= mat2(.4536, -.89121, .89121, .4536);\n\n\t// March the scene.\n\tvec3 n,\n\t     p = ro,\n\t     col = vec3(0);\n\tfloat i, dof,\n\t      d = 1.;\n\tHit h;\n\tfor (i = Z0; i < 1e2; i++) {\n\t\tif (d > 1e2) {\n\t\t\th.id = 0.;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tdof = sat(d / 1e2);\n\n\t// Brighten scene when facing the sun.\n\tcol += .2 * dof * LIGHT_RGB * S(.5, 1., pow(sat(dot(rd, normalize(lp))), 3.));\n\n\t// Engine glow.\n\tcol += g.x * vec3(1, .2, .25) * (.7 + .5 * n31(dx(p, 10.8 * t)));\n\tcol += g.y * LIGHT_RGB;\n\n\tn = N(p, d);\n\n\tcol += lights(p, ro, rd, n, h, 1.);\n\tif (fract(h.id) > 0.) {\n\t\t// We hit a reflective surface, so march reflections.\n\t\tfloat opac = 1.,\n\t\t      refl = fract(h.id);\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < 64.; i++) {\n\t\t\tif (d > 20.) {\n\t\t\t\th.id = 0.;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\topac *= refl;\n\t\tn = N(p, d);\n\t\tcol += opac * (1. - col) * lights(p, ro, rd, n, h, .2);\n\t}\n\n\treturn max(vec4(0), vec4(col, dof));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(_t, 60.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col,\n\t     lookAt = vec3(0, 1.6, 0),\n\t     ro = vec3(0, 1.001, 0);\n\tro.x += 4. * (S(10., 14., t) - S(20., 24., t) * 1.5);\n\tlookAt.y -= S(10., 14., t) - S(32., 35., t);\n\tro.z = mix(.12, .3, S(0., 7., t)) * -20.;\n\tro.yz *= rot(mix(.4, .14, S(4., 6., t)) * -1.57);\n\tro.xz *= rot((mix(.25, .54, S(5., 10., t)) * 2. - 1.) * -3.1415);\n\tro += vec3(1, .5, 2) * S(25., 30., t);\n\n\t// View bob.\n\tro += .5 * sin(t * vec3(.9, .7, .3));\n\tvec4 rgbz = march(ro, rayDir(ro, lookAt, uv));\n\tcol = rgbz.rgb;\n\t\n#ifdef AA\n\tif (fwidth(col.r) > .1) {\n\t\tfor (float dx = -.5; dx <= .5; dx++) {\n\t\t\tfor (float dy = -.5; dy <= .5; dy++)\n\t\t\t\tcol += march(ro, rayDir(ro, lookAt, uv + vec2(dx, dy) / R.xy)).rgb;\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n#endif\n\n\tfragColor = vec4(col * fade, sat(rgbz.w));\n}", "buffer_a_inputs": [], "buffer_b_code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define BLUR 6.0\n\n#define _res iResolution\n#define _tex0 iChannel0\n\nfloat h31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 333.3456);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / _res.xy;\n\n    // Apply basic depth of field blur.\n    vec4 col = texture(_tex0, uv);\n    float blur = smoothstep(0.5, 1.0, col.w) * BLUR;\n    \n    if (blur > 0.0) {\n        float samples = 40.0;\n        for (float i = 0.0; i < samples; i++) {\n            float a = 3.1415 * 2.0 / samples * i;\n            vec2 tuv = uv + vec2(blur * h31(vec3(uv, i)), 0) * mat2(cos(a), sin(a), -sin(a), cos(a)) / _res.xy;\n            col += texture(_tex0, tuv);\n        }\n        \n        col /= samples + 1.0;\n    }\n    \n    fragColor = col;    \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjfRh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1169, 1169, 1192, 1192, 1255], [1257, 1278, 1296, 1296, 1417], [1419, 1419, 1438, 1438, 1585], [1587, 1587, 1608, 1624, 1962], [1964, 1964, 2016, 2016, 2459]], "test": "untested"}
{"id": "dlBfz1", "name": "Diamond Gradient", "author": "dominionxvii", "description": "Simple way to have a diamond tiling + a cool way to sample a gradient", "tags": ["gradientdiamondtiling"], "likes": 1, "viewed": 159, "published": 3, "date": "1693757847", "time_retrieved": "2024-07-30T17:35:35.415939", "image_code": "float SpicyGradientTime(vec2 uv, float t)\n{\n    //Use the uv to offset value to sample the gradient\n    t += uv.y * 0.1 + sin(uv.x * 25. + t * 5.) * 0.005 + sin(uv.y * 150. + t * 5.) * 0.005;\n    t = fract(t);\n    return t;\n}\n\nvec2 DiamondUV(vec2 uv)\n{\n    uv.x *= 1.5; //form stretched diamond\n    \n    vec2 diamondUV = Rotate(uv, radians(45.));\n    diamondUV = Quantize(diamondUV, vec2(25.));\n    diamondUV = Rotate(diamondUV, -radians(45.));\n    \n    return diamondUV;\n}\n\nvec4 SampleGradient(float t)\n{\n    t = fract(t);\n    \n    const int size = 8;  \n    vec4 cols[size] = vec4[size]\n    (\n        GetCol(86, 167, 204),\n        GetCol(179, 225, 232),\n        GetCol(66, 214, 255),\n        GetCol(235, 214, 163),\n        GetCol(255, 163, 163),\n        GetCol(95, 237, 194), \n        GetCol(29, 26, 176),\n        GetCol(96, 63, 204)\n    );\n    \n    float sizeT = t * float(size);\n    int id1 = int(sizeT);\n    int id2 = (id1 + 1);\n    \n    float tt = unlerp(sizeT, float(id1), float(id2));\n    tt = easeInOutCubic(tt);\n    return mix(cols[id1], cols[id2 % size], tt);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec2 diamondUV = DiamondUV(uv);\n      \n    /*\n    //To visualize diamond uv\n    fragColor = vec4(diamondUV, 0.0, 0.0);\n    return;\n    */\n    \n    float spiceItUpTime = SpicyGradientTime(diamondUV, iTime * 0.05);\n    vec4 bg = SampleGradient(spiceItUpTime);\n\n    fragColor = bg;\n}", "image_inputs": [], "common_code": "vec4 GetCol(int r, int g, int b)\n{\n    return vec4(r, g, b, 255.) / 255.;\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec2 Quantize(vec2 x, vec2 resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nvec2 Rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c);\n}\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 99, 225], [227, 227, 252, 252, 473], [475, 475, 505, 505, 1075], [1077, 1077, 1134, 1134, 1480]], "test": "untested"}
{"id": "dlBBz1", "name": "Adjustable pixel shader", "author": "dasbente", "description": "I've not done a lot of shader programming before so this may not be the most idiosyncratic or efficient way to implement this, but it works reasonably well.\nSize of the color channels of each pixel and height of the pixels can be adjusted via variables.", "tags": ["2d", "postprocessing", "pixelshader"], "likes": 2, "viewed": 483, "published": 3, "date": "1693756479", "time_retrieved": "2024-07-30T17:35:36.188873", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int channelWidth = 1; // width of a single color channel in pixels\n    int channelHeight = 3; // height of color channels in pixels\n    int hGap = 1; // horizontal distance between two neighboring pixels\n    int vGap = 1; // vertical distance between two neighboring pixels\n\n    float columns = float(channelWidth * 3 + hGap);\n    float pixelHeight = float(channelHeight + vGap);\n\n    vec2 sampleRes = vec2(iResolution.x / columns, iResolution.y / pixelHeight);\n    vec2 pixel = vec2(floor(fragCoord.x / columns), floor(fragCoord.y / pixelHeight));\n    vec2 sampleUv = pixel / sampleRes;\n\n    // color of sample point\n    vec3 col = texture(iChannel0, sampleUv).xyz;\n    \n    int column = int(fragCoord.x) % (channelWidth * 3 + hGap);\n\n    // set color based on which channel this fragment corresponds to\n    if (column < channelWidth * 1) col = vec3(col.x, 0.0, 0.0);\n    else if (column < channelWidth * 2) col = vec3(0.0, col.y, 0.0);\n    else if (column < channelWidth * 3) col = vec3(0.0, 0.0, col.z);\n    else col = vec3(0.0, 0.0, 0.0);\n\n    // offset every other column of pixels\n    int height = int(pixelHeight);\n    if (int(pixel.x) % 2 == 0) {\n        if (int(fragCoord.y) % height >= height - vGap) col = vec3(0.0, 0.0, 0.0);\n    } else {\n        if (int(fragCoord.y) % height < vGap) col = vec3(0.0, 0.0, 0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1449]], "test": "untested"}
{"id": "dlBBR1", "name": "Zoomed Fractal [299 Chars]", "author": "SnoopethDuckDuck", "description": "modified from zadgy's shader, golfing welcome :)", "tags": ["3d", "fractal"], "likes": 34, "viewed": 320, "published": 3, "date": "1693753969", "time_retrieved": "2024-07-30T17:35:36.958814", "image_code": "// -9 thanks to Fabrice 🐭\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float i,\n          j,\n          z,\n          t = .1*iTime, \n          d = 9.; \n \n    for(vec3 p, \n             R = iResolution,\n             n = normalize(2.+cos(t*vec3(7,8,9))); \n        i++<1e2 && d>.1; \n        O.rgb = -log(p*p)/i // log2 for more brightness\n        ) {    \n        // Set p = (uv, z) then rotate p around n by t radians\n        p = mix(dot(n, p = vec3(33.*(U+U-R.xy)/R.y, z - 2e2)) * n, \n                p, \n                cos(t))\n          + cross(n,p)*sin(t);\n        \n        // Do abs fractal magic then rotate around n by pi\n        for(j = 40.; j > .2; j *= .5)\n             p = reflect(abs(abs(p)-j), n);\n             \n        z += d = length(p)-.4;                     \n    }\n}\n\n// Original [308]\n/*\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float i,\n          z,\n          t = .1*iTime, \n          d = 9.; \n \n    for(vec3 p, \n             R = iResolution,\n             n = normalize(2.+cos(t*vec3(7,8,9))); \n        i++<1e2 && d>.1; \n        O.rgb = -log(p*p)/i\n        ) {    \n        // Set p = (uv, z) then rotate p around n by t radians\n        p = mix(dot(n, p = vec3(33.*(U+U-R.xy)/R.y, z - 2e2)) * n, \n                p, \n                cos(t))\n          + cross(n,p)*sin(t);\n        \n        // Do abs fractal magic then rotate around n by pi\n        for(float j = 40.; j > .2; j *= .5)\n             p = 2. * dot( n, p = abs(abs(p)-j) ) * n - p;\n             \n        z += d = length(p)-.4;                     \n    }\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 68, 68, 780]], "test": "untested"}
{"id": "dtSBR1", "name": "Audio Reactive Fractal", "author": "FaustianBargainForTop", "description": "Just a test with making fractals react to an audio input. Need to fine tune", "tags": ["fractal", "audio", "dub"], "likes": 6, "viewed": 203, "published": 3, "date": "1693752960", "time_retrieved": "2024-07-30T17:35:37.719779", "image_code": "#define freq(f) texture(iChannel0, vec2(f, 0.25)).x * 0.8\nfloat avgFreq(float start, float end, float step) {\n    float div = 0.0;\n    float total = 0.0;\n    for (float pos = start; pos < end; pos += step) {\n        div += 1.0;\n        total += freq(pos);\n    }\n    return total / div;\n}\n\n\nvec3 palette( float t ) {\n\n    float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.2);\n    float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\n    float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.85);\n    \n    vec3 a = vec3(0.5, 0.5, 0.5)/sin(bassFreq);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557)/sin(bassFreq/2.);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 coll = palette(length(uv));\n     \n    vec3 col = vec3(0);\n    \n    float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.2);\n    float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\n    float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.85);\n    \n    float a = .7853982;\n    float s = sin(a);\n    float c = cos(a);\n    uv *= mat2(c, -s, s, c);\n    uv *= 20.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor( uv);\n    \n    float m = 0.-bassFreq;\n    float t = iTime+sin(medFreq);\n    \n    \n    \n    for(float y=-1. ; y<=1. ; y++) {\n        for(float x=-1. ; x<=1. ; x++) {\n            vec2 offs = vec2(x, y);\n            \n            float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.85);\n            float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\n            float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.85);\n           \n            \n            float d = length(gv-offs)+mix(.1, .5, sin(medFreq));\n            float dist = length(id+offs)*.4;\n            \n            float r = mix(.3, 1.5, sin(dist-t)*.5+.5)+mix(.1, .8, sin(bassFreq));\n            m += smoothstep(r,r*.9, d)-sin(bassFreq/6.);\n            \n            }\n        }\n    float y=-1. ; y<=1. ; y++;    \n    float x=-1. ; x<=1. ; x++;    \n    vec2 offs = vec2(x, y); \n   \n    float dist = length(id+offs)*.4;\n    //col.rg = gv;\n    col += mod(m, 1.2);\n    col *= coll + sin(dist-t)*medFreq;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 34625, "src": "https://soundcloud.com/deepheads/congi-occult-feat-segilola", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 109, 109, 287], [290, 290, 315, 315, 704], [708, 708, 765, 765, 2221]], "test": "untested"}
{"id": "mlBfzh", "name": "A simple raymarched egg", "author": "mrange", "description": "So I was messing around build a raymarched for a terminal window\n(Silly idea) so I needed a simple raytracer that look \"ok\" in \n80x60 resolution\nBuild this simple raymarched egg\n", "tags": ["simple", "egg"], "likes": 12, "viewed": 262, "published": 3, "date": "1693752662", "time_retrieved": "2024-07-30T17:35:38.644308", "image_code": "// CC0: A simple raymarched egg\n//  So I was messing around build a raymarched for a terminal window\n//  (Silly idea) so I needed a simple raytracer that look \"ok\" in \n//  80x60 resolution\n//  Build this simple raymarched egg\n//  Thought it could be nice to share as I believe shadertoy benefit\n//  both from overworked glass shaders like my last but also simpler ones\n//  like this\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float PI                  = acos(-1.)   ;\nconst float TAU                 = 2.0*PI      ;\nconst float TOLERANCE           = 1.0E-2      ;\nconst float MAX_RAY_LENGTH      = 20.         ;\nconst float NORM_OFF            = 0.001       ;\nconst float MAX_RAY_MARCHES     = 50.0        ;\nconst float MAX_SHADOW_MARCHES  = 25.0        ;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 SUNDIR           = normalize(vec3(1.0, 1.2, 1.0))   ;\nconst vec3 SKYDIR           = normalize(vec3(-1.0, 3.0, -1.0))   ;\nconst vec3 SKYCOL           = HSV2RGB(vec3(0.55, 0.8, 0.8));   \nconst vec3 GROUNDCOL        = HSV2RGB(vec3(0.15, 0.8, 0.8));   \nconst vec3 EGGCOL           = HSV2RGB(vec3(50./360., 0.24, 1.0));\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat egg(vec2 p, vec2 dim) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = dim.x - dim.y;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                            length(vec2(p.x+r,p.y    )) - 2.0*r) - dim.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat egg(vec3 p, vec3 dim) {\n  // More specifically this is the opRevolution from IQ's article that allows\n  //  to use a 2D distance field and rotate it around Y axis to produce a 3D distance field\n  //  Very useful.\n  vec2 q = vec2(length(p.xz) - dim.z, p.y);\n  return egg(q, dim.xy);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// Distance field functio for egg\nfloat df(vec3 p) {\n  // Add a bounce to it\n  float ft = fract(TIME)-0.5;\n  p.y += -(0.25-ft*ft);\n  return egg(p, 3.0*vec3(1.0, 0.5, 0.))-0.25;\n}\n\n// Raymarcher function with a small tweak to make normals around edges less horrible\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t     = 0.0;\n  vec2 nti = vec2(MAX_RAY_MARCHES,0);\n\n  float i;\n  for (i = 0.0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) break;\n    float d = df(ro + rd*t);\n    if (d<nti.x) nti = vec2(d,t);\n    if (d < TOLERANCE) break;\n    t += d;\n  }\n\n// This is the tweak\n  if(i==MAX_RAY_MARCHES) t = nti.y;\n\n  return t;\n}\n\n\n// Computes the normal of the egg by basically derivate the distance field\n//  and normalize the derivate\nvec3 normal(vec3 pos) {\n  vec2 eps = vec2(NORM_OFF, 0.0);\n  return normalize(vec3(\n      df(pos+eps.xyy)-df(pos-eps.xyy)\n    , df(pos+eps.yxy)-df(pos-eps.yxy)\n    , df(pos+eps.yyx)-df(pos-eps.yyx))\n    );\n}\n\n// Common way to cheat soft-shadows around a distance field.\nfloat softShadow(vec3 ps, vec3 ld, float mint, float k) {\n  \n  float res = 1.0;\n  float t = mint*6.0;\n  for (float i=0.; i<MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = df(p);\n    res = min(res, k*d/t);\n    if (res < TOLERANCE) break;\n    t += max(d, mint);\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\n// Computes the color given a ray origin and a ray direction\nvec3 color(vec3 ro, vec3 rd) {\n  const vec4 pdim = vec4(normalize(vec3(0.0, 1.0, 0.0)), 3.);\n  float tp = rayPlane(ro, rd, pdim);\n\n  float te = rayMarch(ro, rd);\n\n  vec3 col = vec3(0.0);\n  if (te < MAX_RAY_LENGTH && (tp < 0.0 || te < tp)) {\n    // We hit the Egg\n    vec3 ep = ro+rd*te;\n    vec3 en = normal(ep);\n    \n    // Simple diffuse\n    float sunDif = max(dot(en, SUNDIR), 0.0);\n    // Fake diffuse from the sky, should sample the sky randomly and accumulate\n    //  but that's expensive!\n    float skyDif = max(dot(en, SKYDIR), 0.0);\n    \n    col += 0.1*GROUNDCOL+ sunDif+skyDif*sqrt(SKYCOL);\n    col *= EGGCOL;\n  } else if (tp > 0.) {\n    // We hit the Ground\n    vec3 gp = ro+rd*tp;\n    vec3 gn = pdim.xyz;\n\n    // Simple diffuse\n    float sunDif = max(dot(gn, SUNDIR), 0.0);\n    // Fake diffuse from the sky, should sample the sky randomly and accumulate\n    //  but that's expensive!\n    float skyDif = max(dot(gn, SKYDIR), 0.0);\n\n    float sf = softShadow(gp, SUNDIR, 0.1, 8.0);\n    col += 1.5*sf*sunDif+0.25*skyDif*sqrt(SKYCOL);\n    col *= GROUNDCOL;\n\n    // Fade out horizon, fine-tuned, no brain cells involved\n    col *= tanh(40.0*(rd.y*rd.y)+0.125);\n  } else {\n    //  We hit the sky\n    col += SKYCOL;\n\n    // Make horizon more white, fine-tuned, no brain cells involved\n    col += 0.1/max(sqrt(rd.y), 0.2);\n  }\n\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 2.0, 10.0);\n  ro.xz *= ROT(0.1*TIME);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  // Common way to set up orthagonal vectors that allows us to construct the ray direction\n  //  from the the pixel pos\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = color(ro, rd);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[990, 990, 1012, 1012, 1158], [1780, 1875, 1904, 1904, 2174], [2176, 2269, 2298, 2487, 2558], [2560, 2652, 2694, 2694, 2741], [2743, 2777, 2795, 2819, 2921], [2923, 3008, 3042, 3042, 3374], [3377, 3483, 3506, 3506, 3689], [3691, 3752, 3809, 3809, 4065], [4067, 4128, 4158, 4158, 5494], [5496, 5496, 5553, 5553, 6156]], "test": "untested"}
{"id": "dtSfRh", "name": "Shuffle gradient - random walk 3", "author": "FabriceNeyret2", "description": "not a black dots random walk: color dots are moving, sliding puzzle-like :-)\ninspiration: https://twitter.com/junkiyoshi/status/1697571241513910691\nmissing: soft swap of disc.\nadapted from  cellular automata random walk  https://shadertoy.com/view/dtsBWs\n", "tags": ["short", "cellularautomata", "reproduction"], "likes": 18, "viewed": 337, "published": 3, "date": "1693750205", "time_retrieved": "2024-07-30T17:35:39.395300", "image_code": "// variant of https://shadertoy.com/view/dtsBWs\n\nM // O = sqrt( T(u)); \n     u*=C/R; O = sqrt( T(u) * smoothstep(1.5*(C/R).y,0.,length(fract(u)-.5)-.25)); \n //  if (u.y<5.) O = vec4( u.x/R.x < textureLod(iChannel0,vec2(.5),99.).w ); // shows propotion of dots\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(u)   fract(1e4*sin(dot(u+iTime,vec2(71.3,-93.7))))          // random\n#define D(u)   ( D = iFrame%2<1 ? e : e.yx, H(mod(u,C)[1-(iFrame%2)]+d-d)<.5 ? -D : D ) // random move\n#define hue(v) ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )         // hue\n //#define mod(u,C) vec2(ivec2(u+C)%ivec2(C))\n\nM\n    O = T(u);\n    vec2  e = vec2(1,0), d,D; \n    if (iFrame<1) { O = H(u) < .05 ? O-O : vec4( hue((u/C).x), 1 ) ; return; } // .w=0: random seeds .rgb: color gradient\n    if (iFrame<2) { (T(u+e)+T(u+e.yx)+T(u+1.)).w < 3.? O.w=1. :0.; return; } // neighbors forbidden\n    if (iFrame%6>1) return;                                           // slow down\n    O.w < 1. ? O = T(u+D(u)) : O;                                     // pull color\n    for (int k=1; k<9; k+=2 )                                         // check neiborhood\n        d = vec2(k%3,k/3%3) - 1.,                                     // local neighbor direction\n        D(u+d)==d && T(u+d).w < 1. ? O-=O : O;                        // comming here → pull black\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy//\n#define C floor(50.*R/R.y)//\n#define T(U) texelFetch( iChannel0, ivec2(U+C) % ivec2(C), 0 )       //\n#define M void mainImage( out vec4 O, vec2 u ) {\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdKfRR", "name": "Soyombo", "author": "sharavsambuu", "description": "Soyombo, the national symbol of Mongolia.", "tags": ["flag", "soyombo", "mongolia"], "likes": 4, "viewed": 308, "published": 3, "date": "1693745367", "time_retrieved": "2024-07-30T17:35:40.331796", "image_code": "/*\n * @Author Sharavsambuu Gunchinish\n * https://github.com/sharavsambuu/leisure-software-renderer\n * \n * References :\n *\n * - https://en.wikipedia.org/wiki/Flag_of_Mongolia\n * - Indian flag by piyushslayer \n *   https://www.shadertoy.com/view/3lyGRd\n *\n */\n\n#define PI               3.1415926535\n#define MONGOLIAN_RED    vec3(0.855, 0.125, 0.192)\n#define MONGOLIAN_BLUE   vec3(0.0  , 0.4  , 0.698)\n#define MONGOLIAN_YELLOW vec3(1.0  , 0.827, 0.0  )\n\n// Hash by Dave_Hoskins\nfloat hash(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint  n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) / float(0xffffffffU);\n}\n\nfloat noise(vec2 t)\n{\n\treturn texture(iChannel0,t/iChannelResolution[0].xy).x;\n}\n\nconst vec3  positions[325] = vec3 [325](vec3(0.11369219140352504, 0.7428709688492116, 0), vec3(0.095009798870189, 0.7114055291300527, 0), vec3(0.05973449191579793, 0.6851026423160318, 0), vec3(0.020403139214037632, 0.6713366688704161, 0), vec3(-0.021263512554389342, 0.6713366688704161, 0), vec3(-0.061578149073693335, 0.6851026423160318, 0), vec3(-0.09697636650527736, 0.7114055291300486, 0), vec3(-0.11565875903861329, 0.7428709688492116, 0), vec3(-0.11688786381054343, 0.7652409885613711, 0), vec3(-0.10803830945264736, 0.7888398001824302, 0), vec3(-0.09169121598597833, 0.8266962271578713, 0), vec3(-0.08185837781053823, 0.8581613093192751, 0), vec3(-0.08062927303860822, 0.8720501932420925, 0), vec3(-0.08062927303860822, 0.8801622847368288, 0), vec3(-0.07116516629474728, 0.8713127303789348, 0), vec3(-0.06034904430176331, 0.8506637702105112, 0), vec3(-0.06010322334737716, 0.8384956329684048, 0), vec3(-0.06895277770527311, 0.814896821347354, 0), vec3(-0.07780233206316924, 0.7888398001824302, 0), vec3(-0.07485248061053734, 0.7809735296420771, 0), vec3(-0.06600292625264127, 0.7751967372140081, 0), vec3(-0.057153371894745154, 0.7722468857613767, 0), vec3(-0.04682889181053326, 0.7738447219648861, 0), vec3(-0.037979337452637256, 0.7836775601403252, 0), vec3(-0.033431649796496064, 0.8016224898104967, 0), vec3(-0.029498514526320078, 0.8232547337964694, 0), vec3(-0.026179931642109078, 0.8402163796491078, 0), vec3(-0.021263512554389227, 0.8539823530947235, 0), vec3(-0.0133972420140372, 0.8709439989473498, 0), vec3(-0.008480822926317235, 0.8866765400280598, 0), vec3(-0.008480822926317235, 0.8963864677263054, 0), vec3(-0.0133972420140372, 0.9052360220841994, 0), vec3(-0.02200097541754717, 0.9187561745754319, 0), vec3(-0.02691739450526702, 0.9354719994736749, 0), vec3(-0.02531955830175806, 0.9572271539368372, 0), vec3(-0.007620449585965872, 0.9847591008280686, 0), vec3(0.0027040304982458487, 0.9904129827789522, 0), vec3(-0.003195672407017983, 0.9727138740631559, 0), vec3(-0.0028269409754389254, 0.9572271539368372, 0), vec3(0.006022613382457196, 0.9395280452210409, 0), vec3(0.022492617326319016, 0.9198623688701626, 0), vec3(0.03330873931930287, 0.9041298277894606, 0), vec3(0.03416911265965406, 0.8955260943859539, 0), vec3(0.02433627448421379, 0.8660275798596281, 0), vec3(0.014257615354388048, 0.8294002576561154, 0), vec3(0.020157318259652054, 0.8077680136701466, 0), vec3(0.03281709741053102, 0.789208531614003, 0), vec3(0.045599787038603304, 0.7803589772561088, 0), vec3(0.05764501380351689, 0.7770403943718965, 0), vec3(0.06452800052632493, 0.7770403943718965, 0), vec3(0.06846113579650097, 0.7802360667789193, 0), vec3(0.06944441961404502, 0.7881023373192682, 0), vec3(0.06833822531930801, 0.7949853240420761, 0), vec3(0.06440509004913232, 0.8008850269473429, 0), vec3(0.05850538714386808, 0.8099804022596242, 0), vec3(0.05653881950877977, 0.8178466727999771, 0), vec3(0.058259566189482276, 0.8271878690666459, 0), vec3(0.062192701459658085, 0.8409538425122616, 0), vec3(0.06833822531930824, 0.8557030997754225, 0), vec3(0.07227136058948405, 0.8655359379508616, 0), vec3(0.07165680820351913, 0.8768437018526206, 0), vec3(0.06280725384562301, 0.8925762429333225, 0), vec3(0.07141098724913308, 0.8949115419999816, 0), vec3(0.09009337978246915, 0.8801622847368248, 0), vec3(0.0919370369403645, 0.8691003417894532, 0), vec3(0.08800390167018879, 0.8543510845262963, 0), vec3(0.08554569212632841, 0.8345624976982202, 0), vec3(0.09341196266668014, 0.8148968213473378, 0), vec3(0.10717793611229612, 0.7877336058876873, 0), vec3(0.11504420665264808, 0.7670846457192677, 0), vec3(0.18338243197195608, 0.4172807125124858, 0), vec3(0.15585048508072416, 0.35336726437212485, 0), vec3(0.10287606941054118, 0.3022365058598344, 0), vec3(0.036996053635092986, 0.2756878427861481, 0), vec3(-0.03699605363509328, 0.2756878427861481, 0), vec3(-0.10287606941054131, 0.3022365058598344, 0), vec3(-0.15499011174037353, 0.35336726437212485, 0), vec3(-0.1815387748140616, 0.4172807125124858, 0), vec3(-0.1815387748140616, 0.48844587880723145, 0), vec3(-0.15499011174037353, 0.5513760431300472, 0), vec3(-0.10287606941054131, 0.602383891165144, 0), vec3(-0.03699605363509328, 0.6289325542388384, 0), vec3(0.036996053635092986, 0.6289325542388384, 0), vec3(0.10287606941054118, 0.602383891165144, 0), vec3(0.15585048508072416, 0.5513760431300472, 0), vec3(0.18338243197195608, 0.48844587880723145, 0), vec3(0.2659782726456526, 0.31243807546685454, 0), vec3(0.2227137846737164, 0.22984223479316035, 0), vec3(0.1415928697263361, 0.16359348758613224, 0), vec3(0.049164190877199886, 0.129178553972093, 0), vec3(-0.04904128040000738, 0.12905564349489929, 0), vec3(-0.14048667543159973, 0.16248729329139755, 0), vec3(-0.22160759037897979, 0.22873604049842566, 0), vec3(-0.2658553621684598, 0.31231516498966494, 0), vec3(-0.250860283950914, 0.32731024320720903, 0), vec3(-0.19284653871581778, 0.2751962008773776, 0), vec3(-0.11762532667370154, 0.23918343105982898, 0), vec3(-0.039945905087725275, 0.2214843223440368, 0), vec3(0.040068815564918064, 0.2214843223440368, 0), vec3(0.11873152096843832, 0.23918343105982898, 0), vec3(0.19395273301055413, 0.2751962008773776, 0), vec3(0.25098319442810624, 0.32731024320720903, 0), vec3(0.2007742644947657, 0.06372872486681957, 0), vec3(0.037180419350882433, -0.03226435782090942, 0), vec3(-0.03718041935088272, -0.03226435782090942, 0), vec3(-0.20077426449476615, 0.06372872486681957, 0), vec3(-0.21750545320266332, 0.08554533456857871, 0), vec3(-0.08737398547457423, 0.08554533456857871, 0), vec3(0.08737398547457383, 0.08554533456857871, 0), vec3(0.2175054532026629, 0.08554533456857871, 0), vec3(0.48217780202814, -1, 0), vec3(0.3280480636281176, -1, 0), vec3(0.29301857762811273, -0.9878088170434229, 0), vec3(0.29301857762811273, -0.8998202791828795, 0), vec3(0.29301857762811273, -0.6565266714841562, 0), vec3(0.29301857762811273, -0.25792799394726096, 0), vec3(0.29301857762811273, -0.014634386248537634, 0), vec3(0.29301857762811273, 0.07335415161199754, 0), vec3(0.3280480636281176, 0.08554533456857871, 0), vec3(0.48217780202814, 0.08554533456857871, 0), vec3(0.517207288028145, 0.07335415161199754, 0), vec3(0.517207288028145, -0.014634386248537634, 0), vec3(0.517207288028145, -0.25792799394726096, 0), vec3(0.517207288028145, -0.6565266714841562, 0), vec3(0.517207288028145, -0.8998202791828795, 0), vec3(0.517207288028145, -0.9878088170434229, 0), vec3(0.21570788747371517, -0.16814189035777072, 0), vec3(0.08665188642106494, -0.16814189035777072, 0), vec3(-0.08665188642106529, -0.16814189035777072, 0), vec3(-0.21570788747371555, -0.16814189035777072, 0), vec3(-0.23598811621056057, -0.1558508426384706, 0), vec3(-0.23598811621056057, -0.10177023267354901, 0), vec3(-0.21570788747371555, -0.08947918495424889, 0), vec3(-0.08665188642106529, -0.08947918495424889, 0), vec3(0.08665188642106494, -0.08947918495424889, 0), vec3(0.21570788747371517, -0.08947918495424889, 0), vec3(0.2359881162105603, -0.10177023267354901, 0), vec3(0.2359881162105603, -0.1558508426384706, 0), vec3(0.22787602471582227, -0.4687809175718467, 0), vec3(0.19444437491932645, -0.5454770553402863, 0), vec3(0.13077674773335224, -0.6029991586666059, 0), vec3(0.050147474694744266, -0.6324976731929277, 0), vec3(-0.050270385171937174, -0.6300394636490709, 0), vec3(-0.11221726567720922, -0.5808752727718707, 0), vec3(-0.11578166951580632, -0.5081122702736116, 0), vec3(-0.08235001971931014, -0.46484778230167434, 0), vec3(-0.02261552780351198, -0.4424780754525437, 0), vec3(0.038348068884216026, -0.42477896673675564, 0), vec3(0.09808256080001453, -0.3981073931858634, 0), vec3(0.13151421059651036, -0.3440267832209498, 0), vec3(0.13421824109475644, -0.28822542657532524, 0), vec3(0.12241883528422855, -0.2557770605963803, 0), vec3(0.13495570395791456, -0.2508606415086667, 0), vec3(0.1762536242947627, -0.28527557512270185, 0), vec3(0.21103728934038157, -0.34083111081393125, 0), vec3(0.22971968187371797, -0.39687828841394324, 0), vec3(0.10816121992984028, -0.344641335606918, 0), vec3(0.07669613776843229, -0.3898723912139457, 0), vec3(0.017699108715792014, -0.41076717233676074, 0), vec3(-0.04523105560702419, -0.4264997134174666, 0), vec3(-0.10508845800001508, -0.45120471933326045, 0), vec3(-0.13753682397896727, -0.5092184645683464, 0), vec3(-0.1411012278175642, -0.5644052688280028, 0), vec3(-0.13716809254738832, -0.5880040804490618, 0), vec3(-0.1543755593544085, -0.5843167661332604, 0), vec3(-0.18977377678599247, -0.5489185487016841, 0), vec3(-0.21570788747371544, -0.5004918206876379, 0), vec3(-0.22849057710178744, -0.44936106217535565, 0), vec3(-0.22590945708073448, -0.37979373208412337, 0), vec3(-0.1924778072842383, -0.3050641619507821, 0), vec3(-0.12819562771229925, -0.24938571578234292, 0), vec3(-0.04854963849123507, -0.22087048507357032, 0), vec3(0.04682889181053326, -0.2232057841402335, 0), vec3(0.10484263704562916, -0.27040340738234336, 0), vec3(0.2157078874737155, -0.7620453161543526, 0), vec3(0.08665188642106518, -0.7620453161543526, 0), vec3(-0.08665188642106494, -0.7620453161543526, 0), vec3(-0.21570788747371533, -0.7620453161543526, 0), vec3(-0.23598811621056034, -0.7497542684350524, 0), vec3(-0.23598811621056034, -0.6956736584701306, 0), vec3(-0.21570788747371533, -0.6833826107508307, 0), vec3(-0.08665188642106494, -0.6833826107508307, 0), vec3(0.08665188642106518, -0.6833826107508307, 0), vec3(0.2157078874737155, -0.6833826107508307, 0), vec3(0.23598811621056062, -0.6956736584701306, 0), vec3(0.23598811621056062, -0.7497542684350524, 0), vec3(-0.3280480636281175, -1, 0), vec3(-0.4821778020281399, -1, 0), vec3(-0.517207288028145, -0.9878088170434229, 0), vec3(-0.517207288028145, -0.8998202791828795, 0), vec3(-0.517207288028145, -0.6565266714841562, 0), vec3(-0.517207288028145, -0.25792799394726096, 0), vec3(-0.517207288028145, -0.014634386248537634, 0), vec3(-0.517207288028145, 0.07335415161199754, 0), vec3(-0.4821778020281399, 0.08554533456857871, 0), vec3(-0.3280480636281175, 0.08554533456857871, 0), vec3(-0.29301857762811256, 0.07335415161199754, 0), vec3(-0.29301857762811256, -0.014634386248537634, 0), vec3(-0.29301857762811256, -0.25792799394726096, 0), vec3(-0.29301857762811256, -0.6565266714841562, 0), vec3(-0.29301857762811256, -0.8998202791828795, 0), vec3(-0.29301857762811256, -0.9878088170434229, 0), vec3(0.20077426449476593, -0.8369592520034761, 0), vec3(0.037180419350882773, -0.9329523346912132, 0), vec3(-0.03718041935088249, -0.9329523346912132, 0), vec3(-0.20077426449476593, -0.8369592520034761, 0), vec3(-0.2175054532026631, -0.815142642301725, 0), vec3(-0.08737398547457395, -0.815142642301725, 0), vec3(0.08737398547457406, -0.815142642301725, 0), vec3(0.21750545320266315, -0.815142642301725, 0), vec3(0.05518680425965708, -0.2921585618455056, 0), vec3(0.024705005915793016, -0.2675764664069056, 0), vec3(-0.028638141185969003, -0.2675764664069056, 0), vec3(-0.05911993952983301, -0.2921585618455056, 0), vec3(-0.05911993952983301, -0.3360376022034033, 0), vec3(-0.028638141185969003, -0.3616029814595525, 0), vec3(0.024705005915793016, -0.3616029814595525, 0), vec3(0.05518680425965708, -0.3360376022034033, 0), vec3(0.05518680425965708, -0.5143807046104472, 0), vec3(0.024705005915793016, -0.48979860917184714, 0), vec3(-0.028638141185969003, -0.48979860917184714, 0), vec3(-0.05911993952983301, -0.5143807046104472, 0), vec3(-0.05911993952983301, -0.5582597449683446, 0), vec3(-0.028638141185969003, -0.5838251242244941, 0), vec3(0.024705005915793016, -0.5838251242244941, 0), vec3(0.05518680425965708, -0.5582597449683446, 0), vec3(-0.517207288028145, 0.08554533456857871, 0), vec3(-0.517207288028145, -1, 0), vec3(-0.29301857762811256, -1, 0), vec3(-0.29301857762811256, 0.08554533456857871, 0), vec3(-0.2713863336421449, 0.3588982358458106, 0), vec3(-0.23795468384564872, 0.08554533456857871, 0), vec3(-0.23795468384564847, -0.815142642301725, 0), vec3(-0.23598811621056057, -0.08947918495424889, 0), vec3(-0.23598811621056057, -0.16814189035777072, 0), vec3(-0.23598811621056034, -0.6833826107508307, 0), vec3(-0.23598811621056034, -0.7620453161543526, 0), vec3(-0.2300884133052965, -0.42379568291921443, 0), vec3(-0.20452303404915242, -0.5260571999437871, 0), vec3(-0.1848573576982725, 0.4532934823300343, 0), vec3(-0.18289079006318465, 0.19173998686333193, 0), vec3(-0.16322511371230433, -0.27433654265252394, 0), vec3(-0.1553588431719526, 0.25467015118614766, 0), vec3(-0.14159286972633628, -0.5496560115648461, 0), vec3(-0.1337265991859843, -0.596853634806956, 0), vec3(-0.1317600315508964, 0.579153810975666, 0), vec3(-0.1317600315508964, 0.32546658604931245, 0), vec3(-0.11996062574036823, -0.5378566057543206, 0), vec3(-0.11799405810528031, 0.7600787485192663, 0), vec3(-0.10029494938948824, 0.8072763717613801, 0), vec3(-0.08062927303860833, 0.6971478690809445, 0), vec3(-0.08062927303860822, 0.8820059418947255, 0), vec3(-0.08062927303860822, 0.870206536084196, 0), vec3(-0.07669613776843223, 0.7935103983157644, 0), vec3(-0.07669613776843205, -0.43362852109465777, 0), vec3(-0.07079643486316822, 0.7777778572350584, 0), vec3(-0.06293016432281597, -0.5358900381192222, 0), vec3(-0.06293016432281597, -0.31366789535428063, 0), vec3(-0.058997029052640156, 0.8407080215578784, 0), vec3(-0.05309732614737615, 0.7718781543297958, 0), vec3(-0.05309732614737604, -0.45132762981044583, 0), vec3(-0.035398217431584084, 0.7915438306806741, 0), vec3(-0.027531946891232117, 0.9449361062175372, 0), vec3(-0.027531946891232117, 0.8348083186526116, 0), vec3(-0.01769910871579213, 0.911504456421043, 0), vec3(-0.01769910871579213, 0.862340265543843, 0), vec3(-0.00786627054035214, 0.8938053477052509, 0), vec3(-0.003933135270175927, -0.21730608123497075, 0), vec3(-0.003933135270175927, 0.9646017825684156, 0), vec3(-0.0019665676350879057, -0.5870207966315126, 0), vec3(-0.0019665676350879057, -0.48672584724202217, 0), vec3(-0.0019665676350879057, -0.36479865386657107, 0), vec3(-0.0019665676350879057, -0.2645037044770806, 0), vec3(-1.722646319018345e-16, -0.054080967522668555, 0), vec3(-1.722646319018345e-16, 0.21927193375456333, 0), vec3(-1.722646319018345e-16, 0.12487668727033963, 0), vec3(-1.722646319018345e-16, 0.6322511371230426, 0), vec3(-1.722646319018345e-16, 0.27236925990193583, 0), vec3(-1.722646319018345e-16, 0.6696159221897131, 0), vec3(1.1484308793455633e-16, -0.9547689443929723, 0), vec3(0.007866270540352082, 1, 0), vec3(0.003933135270176041, -0.6361849875087209, 0), vec3(0.013765973445615972, 0.9292035651368312, 0), vec3(0.01573254108070405, 0.838741453922784, 0), vec3(0.027531946891231944, 0.7954769659508466, 0), vec3(0.03539821743158391, 0.8977384829754234, 0), vec3(0.049164190877200115, -0.4021634389332458, 0), vec3(0.05309732614737615, 0.7777778572350544, 0), vec3(0.05506389378246412, 0.8997050506105135, 0), vec3(0.058997029052640156, -0.5358900381192222, 0), vec3(0.058997029052640156, -0.31366789535428063, 0), vec3(0.05703046141755219, 0.8210423452069959, 0), vec3(0.06096359668772812, 0.8053098041262898, 0), vec3(0.06489673195790416, 0.8485742920982273, 0), vec3(0.06686329959299213, 0.7777778572350544, 0), vec3(0.06882986722808009, 0.7935103983157604, 0), vec3(0.06882986722808032, -0.4159294123788615, 0), vec3(0.07276300249825612, 0.8682399684491057, 0), vec3(0.07866270540352002, 0.6971478690809445, 0), vec3(0.08456240830878425, 0.8407080215578702, 0), vec3(0.09242867884913633, 0.870206536084192, 0), vec3(0.1002949493894883, 0.8013766688561093, 0), vec3(0.11209435520001619, -0.3117013277191987, 0), vec3(0.11209435520001643, -0.24287146049111197, 0), vec3(0.11602749047019201, 0.7600787485192663, 0), vec3(0.13176003155089616, 0.579153810975666, 0), vec3(0.13176003155089616, 0.32546658604931245, 0), vec3(0.13569316682107244, -0.3077681924490181, 0), vec3(0.15732541080704004, 0.25467015118614766, 0), vec3(0.16519168134739234, -0.5771879584560775, 0), vec3(0.18682392533336029, 0.4532934823300343, 0), vec3(0.18485735769827222, 0.19370655449841812, 0), vec3(0.19469019587371272, -0.31170132771919046, 0), vec3(0.23795468384564836, 0.08554533456857871, 0), vec3(0.2379546838456486, -0.815142642301725, 0), vec3(0.23205498094038438, -0.42379568291920644, 0), vec3(0.2359881162105603, -0.16814189035777072, 0), vec3(0.2359881162105603, -0.08947918495424889, 0), vec3(0.23598811621056062, -0.7620453161543526, 0), vec3(0.23598811621056062, -0.6833826107508307, 0), vec3(0.2713863336421442, 0.3588982358458106, 0), vec3(0.29301857762811273, 0.08554533456857871, 0), vec3(0.29301857762811273, -1, 0), vec3(0.517207288028145, -1, 0), vec3(0.517207288028145, 0.08554533456857871, 0));\nconst ivec3 triangles[307] = ivec3[307](ivec3(0, 1, 294), ivec3(0, 294, 304), ivec3(1, 48, 49), ivec3(1, 49, 294), ivec3(1, 298, 48), ivec3(2, 3, 47), ivec3(2, 47, 287), ivec3(2, 287, 298), ivec3(3, 278, 47), ivec3(4, 5, 22), ivec3(4, 22, 278), ivec3(5, 250, 259), ivec3(5, 259, 22), ivec3(6, 7, 20), ivec3(6, 20, 21), ivec3(6, 21, 250), ivec3(7, 248, 255), ivec3(7, 255, 20), ivec3(8, 9, 19), ivec3(8, 19, 255), ivec3(8, 255, 248), ivec3(9, 18, 19), ivec3(9, 249, 18), ivec3(10, 11, 16), ivec3(10, 16, 17), ivec3(10, 17, 249), ivec3(11, 14, 15), ivec3(11, 15, 16), ivec3(11, 252, 14), ivec3(12, 13, 14), ivec3(12, 14, 252), ivec3(13, 251, 14), ivec3(15, 258, 16), ivec3(17, 253, 249), ivec3(18, 249, 253), ivec3(21, 259, 250), ivec3(22, 23, 46), ivec3(22, 46, 278), ivec3(23, 261, 284), ivec3(23, 284, 46), ivec3(24, 25, 45), ivec3(24, 45, 261), ivec3(25, 44, 45), ivec3(25, 263, 44), ivec3(26, 27, 283), ivec3(26, 44, 263), ivec3(26, 283, 44), ivec3(27, 265, 283), ivec3(28, 29, 43), ivec3(28, 43, 283), ivec3(28, 283, 265), ivec3(29, 42, 43), ivec3(29, 266, 42), ivec3(30, 31, 40), ivec3(30, 40, 41), ivec3(30, 41, 266), ivec3(31, 264, 282), ivec3(31, 282, 40), ivec3(32, 33, 39), ivec3(32, 39, 264), ivec3(33, 262, 39), ivec3(34, 35, 37), ivec3(34, 37, 268), ivec3(34, 38, 262), ivec3(34, 268, 38), ivec3(35, 36, 37), ivec3(35, 280, 36), ivec3(38, 39, 262), ivec3(39, 282, 264), ivec3(41, 42, 266), ivec3(41, 285, 42), ivec3(45, 284, 261), ivec3(46, 47, 278), ivec3(48, 298, 287), ivec3(50, 51, 68), ivec3(50, 68, 69), ivec3(50, 69, 294), ivec3(51, 295, 301), ivec3(51, 301, 68), ivec3(52, 53, 67), ivec3(52, 67, 301), ivec3(52, 301, 295), ivec3(53, 292, 67), ivec3(54, 55, 291), ivec3(54, 67, 292), ivec3(54, 291, 67), ivec3(56, 57, 66), ivec3(56, 66, 291), ivec3(57, 293, 299), ivec3(57, 299, 66), ivec3(58, 59, 65), ivec3(58, 65, 299), ivec3(58, 299, 293), ivec3(59, 64, 65), ivec3(59, 297, 64), ivec3(60, 61, 62), ivec3(60, 62, 63), ivec3(60, 63, 297), ivec3(61, 288, 62), ivec3(63, 64, 297), ivec3(63, 300, 64), ivec3(66, 67, 291), ivec3(69, 304, 294), ivec3(70, 71, 310), ivec3(71, 305, 310), ivec3(71, 306, 305), ivec3(72, 73, 83), ivec3(72, 83, 305), ivec3(72, 305, 306), ivec3(73, 82, 83), ivec3(73, 276, 82), ivec3(73, 277, 276), ivec3(74, 75, 80), ivec3(74, 80, 81), ivec3(74, 81, 276), ivec3(74, 276, 277), ivec3(75, 246, 80), ivec3(76, 77, 239), ivec3(76, 239, 246), ivec3(78, 79, 239), ivec3(79, 245, 239), ivec3(80, 246, 245), ivec3(84, 85, 310), ivec3(84, 310, 305), ivec3(86, 87, 100), ivec3(86, 100, 101), ivec3(86, 101, 320), ivec3(87, 308, 100), ivec3(87, 311, 308), ivec3(88, 89, 98), ivec3(88, 98, 99), ivec3(88, 99, 311), ivec3(89, 274, 98), ivec3(89, 275, 274), ivec3(90, 91, 97), ivec3(90, 97, 274), ivec3(90, 274, 275), ivec3(91, 96, 97), ivec3(91, 240, 96), ivec3(92, 93, 95), ivec3(92, 95, 242), ivec3(92, 242, 240), ivec3(93, 94, 95), ivec3(93, 230, 94), ivec3(96, 240, 242), ivec3(99, 308, 311), ivec3(102, 103, 108), ivec3(102, 108, 109), ivec3(102, 109, 313), ivec3(103, 104, 108), ivec3(103, 273, 104), ivec3(104, 105, 107), ivec3(104, 107, 108), ivec3(105, 106, 107), ivec3(105, 231, 106), ivec3(110, 111, 124), ivec3(110, 124, 125), ivec3(110, 125, 323), ivec3(111, 112, 113), ivec3(111, 113, 124), ivec3(111, 322, 112), ivec3(113, 114, 124), ivec3(114, 115, 122), ivec3(114, 122, 123), ivec3(114, 123, 124), ivec3(115, 116, 121), ivec3(115, 121, 122), ivec3(116, 117, 118), ivec3(116, 118, 119), ivec3(116, 119, 121), ivec3(117, 321, 118), ivec3(119, 120, 121), ivec3(119, 324, 120), ivec3(126, 127, 135), ivec3(126, 135, 136), ivec3(126, 136, 137), ivec3(126, 137, 316), ivec3(127, 128, 134), ivec3(127, 134, 135), ivec3(128, 129, 133), ivec3(128, 133, 134), ivec3(129, 130, 132), ivec3(129, 132, 133), ivec3(129, 234, 130), ivec3(130, 131, 132), ivec3(131, 233, 132), ivec3(135, 317, 136), ivec3(138, 139, 148), ivec3(138, 148, 315), ivec3(139, 218, 148), ivec3(139, 289, 218), ivec3(139, 309, 289), ivec3(140, 141, 225), ivec3(140, 225, 289), ivec3(140, 289, 309), ivec3(141, 224, 225), ivec3(141, 281, 224), ivec3(142, 143, 222), ivec3(142, 222, 223), ivec3(142, 223, 281), ivec3(143, 247, 222), ivec3(144, 145, 221), ivec3(144, 221, 256), ivec3(144, 256, 247), ivec3(145, 220, 221), ivec3(145, 260, 220), ivec3(146, 147, 270), ivec3(146, 220, 260), ivec3(146, 270, 220), ivec3(147, 219, 270), ivec3(147, 296, 219), ivec3(148, 149, 155), ivec3(148, 155, 315), ivec3(148, 218, 296), ivec3(149, 154, 155), ivec3(149, 307, 312), ivec3(149, 312, 154), ivec3(150, 151, 152), ivec3(150, 152, 153), ivec3(150, 153, 307), ivec3(151, 303, 152), ivec3(153, 312, 307), ivec3(156, 157, 217), ivec3(156, 217, 290), ivec3(156, 290, 302), ivec3(157, 216, 217), ivec3(157, 286, 216), ivec3(158, 159, 271), ivec3(158, 216, 286), ivec3(158, 271, 216), ivec3(159, 215, 271), ivec3(159, 254, 215), ivec3(160, 161, 167), ivec3(160, 167, 237), ivec3(160, 168, 169), ivec3(160, 169, 214), ivec3(160, 214, 254), ivec3(160, 237, 168), ivec3(161, 165, 238), ivec3(161, 166, 167), ivec3(161, 238, 166), ivec3(161, 243, 165), ivec3(162, 163, 164), ivec3(162, 164, 165), ivec3(162, 165, 243), ivec3(163, 244, 164), ivec3(169, 241, 257), ivec3(169, 257, 214), ivec3(170, 171, 213), ivec3(170, 213, 257), ivec3(170, 257, 241), ivec3(171, 212, 213), ivec3(171, 267, 212), ivec3(172, 173, 210), ivec3(172, 210, 211), ivec3(172, 211, 267), ivec3(173, 302, 210), ivec3(174, 175, 183), ivec3(174, 183, 184), ivec3(174, 184, 185), ivec3(174, 185, 318), ivec3(175, 176, 182), ivec3(175, 182, 183), ivec3(176, 177, 181), ivec3(176, 181, 182), ivec3(177, 178, 180), ivec3(177, 180, 181), ivec3(177, 236, 178), ivec3(178, 179, 180), ivec3(179, 235, 180), ivec3(183, 319, 184), ivec3(186, 187, 200), ivec3(186, 200, 201), ivec3(186, 201, 228), ivec3(187, 188, 189), ivec3(187, 189, 200), ivec3(187, 227, 188), ivec3(189, 190, 200), ivec3(190, 191, 198), ivec3(190, 198, 199), ivec3(190, 199, 200), ivec3(191, 192, 197), ivec3(191, 197, 198), ivec3(192, 193, 194), ivec3(192, 194, 197), ivec3(193, 226, 194), ivec3(194, 195, 197), ivec3(195, 196, 197), ivec3(195, 229, 196), ivec3(202, 203, 208), ivec3(202, 208, 209), ivec3(202, 209, 314), ivec3(203, 204, 208), ivec3(203, 279, 204), ivec3(204, 205, 207), ivec3(204, 207, 208), ivec3(205, 206, 207), ivec3(205, 232, 206), ivec3(210, 302, 290), ivec3(211, 272, 267), ivec3(212, 267, 272), ivec3(214, 215, 254), ivec3(218, 219, 296), ivec3(222, 247, 256), ivec3(223, 269, 281), ivec3(224, 281, 269), ivec3(239, 245, 246));\nconst int   len            = 307;\n\nbool sameSide(vec3 p1, vec3 p2, vec3 a, vec3 b) \n{\n    vec3 cp1 = cross(b-a, p1-a);\n    vec3 cp2 = cross(b-a, p2-a);\n    return dot(cp1, cp2) >= 0.0;\n}\n\nbool pointInTriangle(vec3 p, vec3 a, vec3 b, vec3 c) \n{\n    return sameSide(p, a, b, c) && sameSide(p, b, a, c) && sameSide(p, c, a, b);\n}\n\nbool inPath(vec2 p) \n{\n    for (int i=0; i<len; i++) \n    {\n        ivec3 triangle = triangles[i];\n        vec3 a = positions[triangle[0]];\n        vec3 b = positions[triangle[1]];\n        vec3 c = positions[triangle[2]];\n        if (pointInTriangle(vec3(p, 0.0), a, b, c)) \n        {\n            return true;\n        }\n    }\n  \n    return false;\n}\n\n      \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    float step = 1.0 / iResolution.y;\n    fragColor = vec4(MONGOLIAN_BLUE, 1.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = fragCoord / iResolution.xy;\n    \n    float w = sin((uv.x + uv.y - iTime * 2.95 + sin(8.5 * uv.x + 4.5 * uv.y) * PI * 0.09) * PI * 0.4);\n    \n    uv   *= 2.0;\n    uv   -= vec2(1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    uv   *= 1.4;\n    uv   *= 1. + (0.036 - .036 * w);\n    \n    if (inPath(uv)) \n    {\n        fragColor = vec4(MONGOLIAN_YELLOW, 1.0);\n    }\t\n    \n    fragColor += w * 0.225;\n    fragColor -= noise(fragCoord.xy)*0.045;\n    \n    float v = 16. * st.x * (1. - st.x) * st.y * (1. - st.y); // vignette\n\tfragColor *= 1. - .6 * exp2(-1.75 * v);\n    fragColor = clamp(fragColor - hash(fragCoord) * 0.004, 0., 1.);\n    \n    fragColor.rgb -= mod(fragCoord.y, 0.8)<1.0 ? 0.02 : 0.0;\n    fragColor.rgb -= mod(fragCoord.x, 0.8)<1.0 ? 0.02 : 0.0;\n    \n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[451, 475, 495, 495, 636], [638, 638, 659, 659, 718], [23763, 23763, 23813, 23813, 23914], [23916, 23916, 23971, 23971, 24054], [24056, 24056, 24078, 24078, 24404], [24413, 24413, 24468, 24468, 25370]], "test": "untested"}
{"id": "dtsBWs", "name": "random walk 2", "author": "FabriceNeyret2", "description": " random walk with simple cellular automata. Color = initial uv.\nCollisions are avoided with a simple trick ( otherwise markers would vanish over time) : only horiz/vertic motion on even/odd frame, same random direction along the same line.", "tags": ["2tweets", "short", "cellularautomata"], "likes": 19, "viewed": 308, "published": 3, "date": "1693743323", "time_retrieved": "2024-07-30T17:35:41.101737", "image_code": "M O = sqrt(T(u)); \n// if (u.y<5.) O = vec4( u.x/R.x < textureLod(iChannel0,vec2(.5),99.).w ); // shows propotion of dots\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(u) fract(1e4*sin(dot(u+iTime,vec2(71.3,-93.7))))            // random\nM\n    O = T(u);\n    vec2  e = vec2(1,0), d,D, U = u/R; \n // float H;\n    if (iFrame<1) { O = H(u) < .1 ? vec4( U, 1.-.7*length(U), 1 ) : O-O; return; } // .w: random seeds .rgb: color gradient\n    if (iFrame<2) { (T(u+e)+T(u+e.yx)+T(u+1.)).w > 0.? O-=O :O; return; } // neighbors forbidden\n\n    O-=O; // O.rgb +=.5; // O.rgb += 1.-vec3(U, 1.-.7*length(U));     // background color\n    \n // for (int k; k<9; k++ )                                            // check neiborhood\n    for (int k=1; k<9; k+=2 )                                         // (cross is sufficient )\n // for (int h=int(9.*H(u+.5)),k=h; k<h+9; k++ )                      // avoid order bias\n        d = vec2(k%3,k/3%3) - 1.,                                     // local neighbor direction\n     // H = H(u+d), D = H<.5 ? e : e.yx, fract(H*2.)<.5 ? D = -D : D, // random move from there\n        D = iFrame%2<1 ? e : e.yx, H(mod(u+d,R)[1-(iFrame%2)]+d-d)<.5 ? D = -D : D, \n        D==-d ? O += T(u+d) : O;                                      // comming here → pull color\n     // D==-d && T(u+d).w > 0. ? O = T(u+d) : O;                      // ( avoid collisions to mix colors )\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy//\n#define T(U) texelFetch( iChannel0, ivec2(U+R) % ivec2(R), 0 )       //\n#define M void mainImage( out vec4 O, vec2 u ) {\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ml2fzR", "name": "2D Weather Simulation", "author": "Zi7ar21", "description": "I have little idea how Navier-Stokes works, but I do know that this is just a toy model. Trying to use my best numerical techniques and basic knowledge about weather to make something cool.", "tags": ["simulation", "fluid", "navier", "stokes"], "likes": 10, "viewed": 319, "published": 3, "date": "1693708940", "time_retrieved": "2024-07-30T17:35:42.037236", "image_code": "// Fork of \"Navier-Stokes Fluid Simulation\" by Zi7ar21. https://shadertoy.com/view/flyfzw\n// 2023-09-03 02:02:40\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.y > 0.5 * iResolution.y) {\n        fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0).xxx, 1.0);\n        fragColor = vec4(abs(fragColor.rgb) * (fragColor.x > 0.0 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0)), 1.0);\n        //fragColor.rgb *= 2.0;\n    }\n    else {\n        fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz, 1.0);\n    }\n\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz, 1.0);\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyw, 1.0);\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); fragColor = vec4(length(fragColor.xy), fragColor.z, fragColor.w, 1.0);\n\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    //fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).zzz, 1.0);\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).www, 1.0);\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).zww, 1.0);\n\n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    //fragColor = vec4(vec3(fbm(10.0*uv)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float dot2(vec2 v) { return dot(v,v); }\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat dot2(vec4 v) { return dot(v,v); }\n\n// Do more pressure passes across multiple frames\n#define STEP_INTERVAL 4\n\nvec4 texelFetch_repeat(sampler2D _sampler, ivec2 _coord, int _lod) {\n    // no idea why the -1 is neccesary but the pressure is slightly wrong without it\n    // maybe textureSize() is wrong?\n    ivec2 _textureSize = textureSize(_sampler, _lod) - 1;\n\n    // :sob: in GLSL, the % operator is undefined if one or both input integers are negative\n    // so we blasphemously convert our integers to floats and back and use the float modulo\n    //_coord.x = int(mod(float(_coord.x), float(_textureSize.x)));\n    //_coord.y = int(mod(float(_coord.y), float(_textureSize.y)));\n    //return texelFetch(_sampler, _coord, _lod);\n\n    // fixed! https://www.alecjacobson.com/weblog/?p=1140\n    return texelFetch(_sampler, ((_coord % _textureSize) + _textureSize) % _textureSize, _lod);\n}\n\n// If defined, PCG will be used for Random Number Generation\n// http://www.pcg-random.org/\n//#define USE_PCG_RANDOM\n\n// ##### Constants #####\n\n/*\nhttps://float.exposed/\nhttp://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n*/\n\n/*\nIt's convenient to make constant floating-point variables with the best possible precision so you don't need to type them everywhere,\nand precomputing their inverses allows you to change division (which is slow) into multiplication e.g. x / PI = INV_PI * x\n*/\n\n//const float     PI = glm::uintBitsToFloat(0x40490FDBU); // Pi\n//const float INV_PI = glm::uintBitsToFloat(0x3EA2F983U); // 1 / Pi\n//const float     TAU = glm::uintBitsToFloat(0x40C90FDBU); // 2 * Pi = \"Tau\"\n//const float INV_TAU = glm::uintBitsToFloat(0x3E22F983U); // 1 / (2 * Pi)\n\nconst float     PI = 3.1415926535897932384626433832795028841971693993751058209749445923; // Pi\nconst float INV_PI = 0.3183098861837906715377675267450287240689192914809128974953346881; // 1 / Pi\n\nconst float     TAU = 6.2831853071795864769252867665590057683943387987502116419498891846; // 2 * Pi = \"Tau\"\nconst float INV_TAU = 0.1591549430918953357688837633725143620344596457404564487476673441; // 1 / (2 * Pi)\n\n// 2^32 (but slightly different, so 32-bit RNG doesn't ever reach 0.0 or 1.0)\n// I know I said \"C++11 lacks a real way to do this\" earlier but there's no real way to get the closest\n// but still *slightly* different float besides using hexadecimal\nconst float     RNG32_MAX = uintBitsToFloat(0x4F7FFFFFU); // Actual: 0x4F800000U\nconst float INV_RNG32_MAX = uintBitsToFloat(0x2F7FFFFFU); // Actual: 0x2F800000U\n\n// ##### Random Number Generator #####\n\n#ifdef USE_PCG_RANDOM\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\nstruct rng_state_t {\n    uvec4 seed;\n};\n\nvoid init_rng(inout rng_state_t rng_state, vec2 pixel_coord, vec2 res, int frame_number) {\n    uvec2 coord = uvec2(pixel_coord);\n\n    rng_state.seed = uvec4(coord, uint(frame_number), coord.x + coord.y);\n\n    //rng_state.seed = uvec4(frame, frame * 15843, frame * 31 + 4566, frame * 2345 + 58585);\n}\n\n// http://www.pcg-random.org/\nuvec4 pcg4d(uvec4 v) {\n\tv = v * 0x0019660Du + 0x3C6EF35Fu;\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n    v = v ^ (v >> 16u);\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n\n    return v;\n}\n\nfloat rand(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * float(rng_state.seed.x);\n}\n\nvec2 rand2(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec2(rng_state.seed.xy);\n}\n\nvec3 rand3(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec3(rng_state.seed.xyz);\n}\n\nvec4 rand4(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec4(rng_state.seed);\n}\n#else\nstruct rng_state_t {\n    uint seed;\n};\n\nvoid init_rng(inout rng_state_t rng_state, vec2 pixel_coord, vec2 res, int frame_number) {\n    pixel_coord = floor(pixel_coord);\n\n    rng_state.seed = uint(frame_number) * uint(res.x * res.y) + uint(pixel_coord.x + res.x * pixel_coord.y) + 1u;\n}\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\n// this hash in particular is remarkable because it's a statistically perfect 32-bit integer hash (of this kind)\nuint triple32(uint x) {\n    x ^= x >> 17u;\n    x *= 0xED5AD4BBu;\n    x ^= x >> 11u;\n    x *= 0xAC4C1B51u;\n    x ^= x >> 15u;\n    x *= 0x31848BABu;\n    x ^= x >> 14u;\n    return x;\n}\n\nfloat rand(inout rng_state_t rng_state) {\n    rng_state.seed = triple32(rng_state.seed);\n\n    return INV_RNG32_MAX * float(rng_state.seed);\n}\n\nvec2 rand2(inout rng_state_t rng_state) {\n    vec2 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    return v;\n}\n\nvec3 rand3(inout rng_state_t rng_state) {\n    vec3 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    v.z = rand(rng_state);\n    return v;\n}\n\nvec4 rand4(inout rng_state_t rng_state) {\n    vec4 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    v.z = rand(rng_state);\n    v.w = rand(rng_state);\n    return v;\n}\n#endif\n\nvec2 udir2(inout rng_state_t rng_state) {\n    float z = rand(rng_state);\n    float t = TAU * z;\n    float c = cos(t), s = sin(t);\n    return vec2(c, s);\n}\n\nvec3 udir3(inout rng_state_t rng_state) {\n    vec2 z = rand2(rng_state);\n    vec2 t = vec2(TAU * z.x, acos(2.0 * z.y - 1.0));\n    vec2 c = cos(t), s = sin(t);\n    return vec3(c.x * s.y, s.x * s.y, c.y);\n}\n\n// Box-Muller Transform\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 nrand2(float sigma, vec2 mean, inout rng_state_t rng_state) {\n    vec2 z = rand2(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.x   )) * vec2(cos(TAU * z.y), sin(TAU * z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean, inout rng_state_t rng_state) {\n    vec4 z = rand4(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.xxy )) * vec3(cos(TAU * z.z), sin(TAU * z.z), cos(TAU * z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean, inout rng_state_t rng_state) {\n    vec4 z = rand4(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.xxyy)) * vec4(cos(TAU * z.z), sin(TAU * z.z), cos(TAU * z.w), sin(TAU * z.w));\n}\n\nvec2 pixel_filter(vec2 coord, float width, rng_state_t rng_state) {\n    return coord + width * (rand2(rng_state) - 0.5); // box filter, uniform over entire pixel\n    //return nrand2(width, coord, rng_state); // normal filter, normal distribution\n}\n\n// psrdnoise: https://github.com/stegu/psrdnoise\n/* BEGIN SNIPPET */\nfloat mpsrdnoise(vec2 x, float alpha)\n{\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\n    xw = vec3(v0.x, v1.x, v2.x);\n    yw = vec3(v0.y, v1.y, v2.y);\n    iu = floor(xw + 0.5*yw + 0.5);\n    iv = floor(yw + 0.5);\n\n\t// Hash permutation carefully tuned to stay within the range\n\t// of exact representation of integers in a half-float.\n\t// Tons of mod() operations here, sadly.\n\tvec3 iu_m49 = mod(iu, 49.0);\n\tvec3 iv_m49 = mod(iv, 49.0);\n\tvec3 hashtemp = mod(14.0*iu_m49 + 2.0, 49.0);\n\thashtemp = mod(hashtemp*iu_m49 + iv_m49, 49.0);\n\tvec3 hash = mod(14.0*hashtemp + 4.0, 49.0);\n\thash = mod(hash*hashtemp, 49.0);\n\t\n\tvec3 psi = hash*0.1282282715750936015699038115624286891509048734438818702438752895 + alpha; // 0.1282283 is 2*pi/49\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\t//vec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\t//vec2 dn0 = w4.x*g0 + dw.x*x0;\n\t//vec2 dn1 = w4.y*g1 + dw.y*x1;\n\t//vec2 dn2 = w4.z*g2 + dw.z*x2;\n\t//gradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n/* END SNIPPET */\n\nfloat fbm(vec2 x) {\n    return\n    0.5333333333333333 * mpsrdnoise(1.0 * x, 0.0)+\n    0.2666666666666667 * mpsrdnoise(2.0 * x, 1.0)+\n    0.1333333333333333 * mpsrdnoise(4.0 * x, 2.0)+\n    0.0666666666666667 * mpsrdnoise(8.0 * x, 3.0);\n}", "buffer_a_code": "vec4 texture_linear_clamp(sampler2D _sampler, vec2 _P) {\n    // texture() maps texels from ivec2(0) to ivec2(texture_size) to vec2(1.0 / texture_size) to vec2(1.0 - 1/texture_size)\n    // this maps texels from ivec2(0)\n\n    ivec2 _textureSize = textureSize(_sampler, 0).xy - ivec2(1, 1);\n\n    _P *= vec2(_textureSize);\n\n    vec2 _f = fract(_P);\n\n    vec4 _texel00 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(0, 0), ivec2(0), _textureSize), 0);\n    vec4 _texel10 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(1, 0), ivec2(0), _textureSize), 0);\n    vec4 _texel01 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(0, 1), ivec2(0), _textureSize), 0);\n    vec4 _texel11 = texelFetch(_sampler, clamp(ivec2(_P) + ivec2(1, 1), ivec2(0), _textureSize), 0);\n\n    return mix(mix(_texel00, _texel10, _f.x), mix(_texel01, _texel11, _f.x), _f.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    rng_state_t rng_state;\n\n    init_rng(rng_state, fragCoord, iResolution.xy, iFrame);\n\n    //fragCoord = floor(fragCoord);\n\n    if(iFrame < 1) {\n        //fragColor = vec4(texture(iChannel2, mod(fragCoord / 4096.0, 1.0)).xy - 0.5, texture(iChannel2, mod(fragCoord / 512.0, 1.0)).z, 0.0);\n        //fragColor.x += 0.5;\n        fragColor = vec4(1.0*(fragCoord.y/iResolution.y), 0.0, 0.8*(1.0 - (fragCoord.y / iResolution.y)), 0.0);\n\n        /*\n        if(fragCoord.y > 0.25 * iResolution.y && fragCoord.y < 0.75 * iResolution.y) {\n            fragColor.x += 1.0;\n            fragColor.z += 1.0;\n        }\n        else {\n            fragColor.x -= 1.0;\n            fragColor.z += 0.0;\n        }*/\n        \n        /*\n        if(fragCoord.x < 0.5 * iResolution.x) {\n            fragColor.x += 0.0;\n            fragColor.y += 1.0;\n            fragColor.z += 1.0;\n        }\n        else{\n            fragColor.x -= 0.0;\n            fragColor.y -= 1.0;\n            fragColor.z += 0.0;\n        }\n        */\n\n        //fragColor.xy += 0.1 * (texture(iChannel2, fragCoord / 512.0).xy - 0.5);\n        fragColor.xy += nrand2(0.1, vec2(0), rng_state);\n\n        if(fragCoord.y < 20.0*fbm(vec2(0.01*fragCoord.x,0.0))+20.0) {\n            fragColor = vec4(0.0, 0.0,\n            2.0-0.01*fragCoord.y,\n            max(1.0-fragCoord.y/30.0, 0.0));\n        }\n\n        return;\n    }\n\n    if((iFrame % STEP_INTERVAL) != 0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n        return;\n    }\n\n    //fragColor = texture_linear_clamp(iChannel1, mod(floor(fragCoord) / 255.0, 1.0));\n\n    const float h = 1.0;\n    //fragColor = texture(iChannel1, (fragCoord) / iResolution.xy);\n    //fragColor = texture(iChannel1, (fragCoord - (1.0 * fragColor.xy)) / iResolution.xy);\n    vec2 k1 = texelFetch(iChannel1, ivec2(fragCoord), 0).xy;\n    vec2 k2 = texture(iChannel1, (fragCoord - 0.5 * h * k1) / iResolution.xy).xy;\n    vec2 k3 = texture(iChannel1, (fragCoord - 0.5 * h * k2) / iResolution.xy).xy;\n    vec2 k4 = texture(iChannel1, (fragCoord - h * k3) / iResolution.xy).xy;\n    fragColor = texture(iChannel1, (fragCoord - (h/3.0*(0.5*k1+k2+k3+0.5*k4))) / iResolution.xy);\n    \n\n    // vorticy injection\n    //fragColor.xy += texelFetch(iChannel0, ivec2(fragCoord), 0).z*0.05*(texture(iChannel2, (fragCoord + vec2(69.0*sin(iTime * 123.0), 42.0*cos(iTime*456.0))) / 512.0).xy - 0.5);\n    fragColor.xy += nrand2(fragColor.z*0.00025, vec2(0), rng_state);\n\n    float temp_grad =\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 4), 0).z +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 3), 0).z +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).z +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).z +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).z +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).z +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 3), 0).z +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 4), 0).z;\n\n    fragColor.y += h * ((0.2 * temp_grad) - 0.001);\n    //fragColor.y += h * 0.01 * fragColor.z;\n    //fragColor.y += 0.001;\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    //fragColor.x += h * 0.5 * exp(-dot2(50.0 * (vec2(-0.5, 0.0) - uv)));\n    //fragColor.z += h * 0.5 * exp(-dot2(50.0 * (vec2(-0.5, 0.0) - uv)));\n\n    if(fragCoord.y < 20.0*fbm(vec2(0.01*fragCoord.x,0.0))+20.0) {\n        fragColor = vec4(0.0, 0.0,\n        2.0-0.01*fragCoord.y,\n        max(1.0-fragCoord.y/30.0, 0.0));\n    }\n\n    if(iMouse.z > 0.1) fragColor.z += 0.2 * max(1.0 - 0.1 * length(iMouse.xy - fragCoord), 0.0);\n\n    //fragColor.z *= 0.998+0.002*(fragCoord.y/iResolution.y);\n\n    if(fragCoord.y > iResolution.y-3.0) fragColor = vec4(0.0);\n    if(fragCoord.y > iResolution.y-6.0) fragColor.z *= 0.99;\n\n    //fragColor.y*=0.999;\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if((iFrame % STEP_INTERVAL) != 0) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n        return;\n    }\n\n    /*\n    float x0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y;\n    float y1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y;\n\n    fragColor = vec4(0.5 * ((x1 - x0) + (y1 - y0)), 0.0, 0.0, 0.0); // divergence\n    */\n\n    /*\n    fragColor = vec4(\n     0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).y +\n    -0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y +\n     0.66666666666 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y +\n    -0.08333333333 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).y,\n    0.0, 0.0, 0.0); // divergence\n    */\n\n    fragColor = vec4(\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(4, 0), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(3, 0), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(3, 0), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(4, 0), 0).x +\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 4), 0).y +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 3), 0).y +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).y +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).y +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).y +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).y +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 3), 0).y +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 4), 0).y,\n    0.0,\n    0.0,\n    0.0); // divergence\n\n    /*\n    fragColor = vec4(\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x+\n\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).y +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).y +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).y +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).y +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).y +\n     2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).y +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).y,\n     0.0,\n     0.0,\n     0.0);\n     */\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float divergence = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n\n    float x0 = texelFetch_repeat(iChannel2, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel2, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel2, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y1 = texelFetch_repeat(iChannel2, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n\n    if(iFrame < 1) {\n        x0 = 0.0;\n        x1 = 0.0;\n        y0 = 0.0;\n        y1 = 0.0;\n    }\n\n   \tfragColor = vec4((x0 + x1 + y0 + y1 - divergence) * 0.25, 0.0, 0.0, 0.0);\n}\n*/\n\n/* */\n#define Pressure iChannel2\n#define Divergence iChannel1\nfloat ComputePressure4( vec2 fragCoord )\n{\n    float pressure = 0.0;\n    float divergence = 0.0;\n    \n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-4,  0), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2,  0), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-3, -1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-3,  1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 36.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1, -1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1,  1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2, -2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-2,  2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2,  0), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1, -1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1,  1), 0).x * 24.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0, -2), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  2), 0).x * 16.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1, -3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2(-1,  3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 4,  0), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 3, -1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 3,  1), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2, -2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 2,  2), 0).x * 6.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1, -3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 1,  3), 0).x * 4.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0, -4), 0).x * 1.0;\n    pressure += texelFetch_repeat(Pressure, ivec2(fragCoord) + ivec2( 0,  4), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-3,  0), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  0), 0).x * 9.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2, -1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2,  1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-2,  0), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  0), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -1), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  1), 0).x * 25.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 16.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1, -2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1, -1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2(-1,  0), 0).x * 16.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 3,  0), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2, -1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2,  1), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 2,  0), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1, -2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1, -1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  2), 0).x * 3.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 1,  1), 0).x * 8.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -3), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0, -2), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  3), 0).x * 1.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  2), 0).x * 4.0;\n    divergence += texelFetch_repeat(Divergence, ivec2(fragCoord) + ivec2( 0,  0), 0).x * 64.0;\n\n    return (pressure - divergence) / 256.0;\n}\n/* */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(ComputePressure4(fragCoord), 0.0, 0.0, 0.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    /*\n    float x0 = texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y1 = texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    vec2 pressure_gradient = 0.5 * (vec2(x1, y1) - vec2(x0, y0));\n    */\n    /*\n    vec2 pressure_gradient = vec2(\n     0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(2, 0), 0).x,\n     0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 2), 0).x +\n    -0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x +\n     0.66666666666 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x +\n    -0.08333333333 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 2), 0).x);\n    */\n\n    vec2 pressure_gradient = vec2(\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(4, 0), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(3, 0), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(2, 0), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(1, 0), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(2, 0), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(3, 0), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(4, 0), 0).x,\n     0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 4), 0).x +\n    -0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 3), 0).x +\n     0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 2), 0).x +\n    -0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) - ivec2(0, 1), 0).x +\n     0.8000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 1), 0).x +\n    -0.2000000000000000000000000000000000000000000000000000000000000000 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 2), 0).x +\n     0.0380952380952380952380952380952380952380952380952380952380952381 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 3), 0).x +\n    -0.0035714285714285714285714285714285714285714285714285714285714286 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(0, 4), 0).x);\n\n    /*\n    pressure_gradient = vec2(\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x,\n\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  1), 0).x +\n    -2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  1), 0).x +\n    -1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  1), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0,  0), 0).x +\n     0.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1,  0), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2(-1, -1), 0).x +\n     2.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 0, -1), 0).x +\n     1.0 * texelFetch_repeat(iChannel1, ivec2(fragCoord) + ivec2( 1, -1), 0).x);\n    */\n\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xy - pressure_gradient, texelFetch(iChannel0, ivec2(fragCoord), 0).zw);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2fzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 169, 169, 1427]], "test": "untested"}
{"id": "Dl2fRR", "name": "Laser Kaleidoscope", "author": "itishappy", "description": "testing out a hexagonal grid", "tags": ["kaleidoscope", "glow"], "likes": 3, "viewed": 164, "published": 3, "date": "1693682078", "time_retrieved": "2024-07-30T17:35:42.789225", "image_code": "// how far from integer... more or less\nfloat test(float x) {\n    x = fract(x);\n    return x * (1. - x);\n}\n\n// test each axis independantly\nvec3 test(vec3 xyz) {\n    return vec3(test(xyz.x), test(xyz.y), test(xyz.z));\n}\n\n// convert uv space to hex space\nvec3 hex(vec2 uv) {\n    mat2 skew = mat2(1., -0.5, 0., 1.1547);\n    uv *= skew;\n    return vec3(uv, -uv.x - uv.y);\n}\n\n// spin 2 win\nmat2 rot(float theta) {\n    return mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n}\n\n// put my thing down, flip it and reverse it\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // center and scale uvs, convert to hex grid\n    float scale = 2.5;\n    vec2 uv = scale * (2. * fragCoord - iResolution.xy) / iResolution.x;\n    uv *= rot(.1 * iTime);\n    vec3 xyz = hex(uv);\n    \n    // math magic\n    vec3 tests = test(xyz);\n    float glow = length(uv);\n    float grip = tests.x + tests.y + tests.z;\n    float grid = tests.x * tests.y * tests.z;\n    \n    // makin' it move\n    float glowStrength = 0.7 + 0.5 * cos(0.69 * iTime);\n    float gripStrength = 0.7 - 0.5 * cos(0.55 * iTime);\n    float gridStrength = 0.7 + 0.5 * sin(0.74 * iTime);\n    float glowFalloff = 1. * (.9 + .5 * sin(0.7 * iTime));\n    float gripFalloff = 0.5 * (.9 - .5 * sin(1.3 * iTime));\n    float gridFalloff = .01 * (.9 + .5 * cos(iTime));\n    glow = clamp(glowStrength - glow / glowFalloff, 0., 1.);\n    grip = clamp(glowStrength - grip / glowFalloff, 0., 1.);\n    grid = clamp(gridStrength - grid / gridFalloff, 0., 1.);\n    \n    // (fake) color science\n    vec3 col = vec3(glow, grip, grid);\n    float t = 0.13 * iTime;\n    vec3 shift = pow(vec3(cos(t), cos(t + 1.0472), cos(t - 1.0472)), vec3(2.));\n    col = col * shift.x + col.yzx * shift.y + col.zxy * shift.z;\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2fRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 61, 61, 106], [108, 140, 161, 161, 219], [221, 254, 273, 273, 370], [372, 386, 409, 409, 474], [476, 521, 578, 628, 1776]], "test": "untested"}
{"id": "DtSBRz", "name": "9 Centered Transitions", "author": "misol101", "description": "Hold mouse button for \"soft\" transitions.\n\nEach transition runs twice, to-and-back, when BOUNCE_TIME is true.\n\nFullscreen is better\n", "tags": ["plasma", "spiral", "transition", "transitions"], "likes": 6, "viewed": 208, "published": 3, "date": "1693675501", "time_retrieved": "2024-07-30T17:35:43.548196", "image_code": "/*\n\n9 Transitions by misol101\n\nHold mouse button for \"soft\" transitions.\n\nEach transition runs twice, to-and-back, when BOUNCE_TIME is true.\n\nFullscreen is better.\n\n*/\n\n//spiral\nvoid fx1( out vec4 O, in vec2 u )\n{\n    vec2 uv = u/iResolution.xy -.5;\n\n    float l = length(uv)/3.;\n    float a = atan(uv.y, uv.x);\n\n    float b1 = sin(100.*(sqrt(l)-0.02*a-0.3*((iTime*50.+uv.y*(0.+cos(iTime*0.72)*150.9)+uv.x*(0.+cos(iTime*0.14)*100.9))/140.)))*2.54;\n    float b2 = l*2.5;\n    \n    float g=max(b1/16.,0.09)+sin((a/2.5+iTime/2.5)*25.)*13.*(b2*b2);\n    float b=sin((a/5.+iTime/3.5)*25.)*0.71*b2*b2*42.+0.62;\n    \n    vec3 col = vec3(b1*b1*b1*0.1+.62,\n                    b1/3.5+b1*b*0.2-g/2.-.32,\n                    b1/8.+b1*g*0.26+b/3.+.45);\n\n    col = col*min(l*l*940000.,1.);\n    float c1=max(col.x,max(col.y,col.z));\n    c1=c1*c1*0.27;\n\n    O = vec4(c1,c1,c1,1.0);\n}\n\n// plasma\nvoid fx2( out vec4 O, in vec2 u )\n{\n    vec2  R = vec2(0.,iResolution.y+sin(iTime/25.0)*8.24),\n          p = 5.*( u+u+vec2(800.,cos((iTime+5.)/10.0)*1000.) - R ) / R.y,\n          r = p-p;\n    \n    for(float f=1.; f < 2.5; f *= 1.05 )\t\n\t\tr += sin( p*f +iTime*0.85) / f,\n        p = p * mat2(8,6,-8,6)*.1 + r*.4;\n\n    float l = length(r);\n    vec3 c = vec3(l*0.29, l*l*0.024, l*l*l*0.0016);\n\n    vec2 uv = u/iResolution.xy;\n    vec3 c2 = -0.3 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    O = vec4(c+c2, 0.);\n}\n\nfloat transition(vec2 uv, int index, bool distinct) {\n\n    float t = getTime(iTime, interval / speed);\n\n    t = mod(t * speed, interval) - 0.25;\n    t = clamp(t, 0., interval - 0.25);\n\n    float a = length(uv) + 0.25;\n\n    float t2 = t + tmod(index, uv);\n\n    if (distinct) {\n        if (a >= t2 - EDGE_SMOOTH && a < t2)\n            t2 = smoothstep(0.,1.,(t2-a) / EDGE_SMOOTH);\n        else\n            t2 = step(a, t2); // a<n?1:0\n    }\n    else\n        t2 = clamp(t2 - 0.25, 0., 1.);\n\n    return t2;\n}\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n\n    vec4 px1, px2;\n    fx1(px1, u);\n    fx2(px2, u);\n\n    int index = (int(iTime / (interval*(BOUNCE_TIME? 2.:1.) / speed))) % NOF_TRANSITIONS;\n\n    if (!BOUNCE_TIME && (index & 1) == 1) { vec4 tmp=px1; px1=px2; px2=tmp; }\n\n    vec2 uv = u/iResolution.y -.5;\n    uv.x += (1. - iResolution.x/iResolution.y) * 0.5;\n\n    float t = transition(uv, index, iMouse.z < 1. );\n\n    O = mix(px1, px2, t);\n}\n", "image_inputs": [], "common_code": "const int NOF_TRANSITIONS = 9;\n\nconst float EDGE_SMOOTH = 0.0; // 0.03\n\nconst bool BOUNCE_TIME = true;\n\nfloat getTime(float time, float interval) {\n    if (!BOUNCE_TIME)\n        time = mod(time, interval);\n    else {\n        time = mod(time, interval*2.);\n        if (time >= interval) time = max(interval*2. - time, 0.);\n    }\n    return time;\n}\n\nconst float interval = 2.0;  // actual time of one transition: interval / speed\nconst float speed = 0.33;\n\nfloat tmod(int index, vec2 uv) {\n    switch(index) {\n\n        case 0: return sin(((uv.x+0.53)/(uv.y+0.53)*200.+uv.y*100.)*0.2)*0.25;\n        \n        case 1: return sin(uv.x*200.)*0.125 + cos(uv.y*200.)*0.125;\n\n        case 2: return sin(uv.x*200.*0.166)*0.125 + cos(uv.y*200.*0.25)*0.125;\n\n        case 3: return sin((uv.x*100.*uv.y*100.)/3.)*0.15*cos((uv.y*200.*uv.y*200.)/5.)*1.5;\n\n        case 4: return sin(uv.x*200.)*0.25;\n\n        case 5: return sin((uv.x*200.+uv.y*100.)*0.1)*0.25;\n\n        case 6: return sin((uv.x*200.-uv.y*300.)*0.35)*0.14+cos((uv.y*66.)*0.3)*0.09;\n\n        case 7: return sin((uv.x*200.+uv.y*100.)*0.2)*0.06;\n\n        case 8: return sin((uv.x*100.*uv.y*100.)*0.1)*0.25;\n\n        default: return 0.;\n    }\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 178, 213, 213, 866], [868, 878, 913, 913, 1386], [1388, 1388, 1441, 1441, 1891]], "test": "untested"}
{"id": "clBfzR", "name": "ffmpeg", "author": "silentsiege", "description": "Trying to replicate the ffmpeg test video. Generate it with:\nffmpeg -f lavfi -i testsrc2=size=1280x720:rate=60 -f lavfi -i aevalsrc=\"sin(0*2*PI*t)\" output.webm", "tags": ["test"], "likes": 1, "viewed": 40, "published": 3, "date": "1693664287", "time_retrieved": "2024-07-30T17:35:44.300185", "image_code": "const vec3 GREY = vec3(.5);\nconst vec3 PURPLE = vec3(138.,26.,253.)/255.;\nconst vec3 RED = vec3(254.,24.,0.)/255.;\nconst vec3 GREEN = vec3(1.,232.,0.)/255.;\nconst vec3 YELLOW = vec3(255.,240.,0.)/255.;\nconst vec3 BLUE = vec3(0.,15., 255.)/255.;\nconst vec3 MAGENTA = vec3(254.,39.,255.)/255.;\nconst vec3 CYAN = vec3(1.,231.,255.)/255.;\n\nconst float pi = acos(-1.);\n\nfloat thetaX(float x)\n{\n    \n    float aa = 1. / iResolution.x;\n    return smoothstep(-aa, aa, x);\n}\n\nfloat thetaY(float y)\n{\n    \n    float aa = 1. / iResolution.y;\n    return smoothstep(-aa, aa, y);\n}\n\nfloat clock(float angle, vec2 uv1)\n{\n    if (max(abs(uv1.x), abs(uv1.y)) > 10.25) return 0.;\n    \n    vec2 hand = vec2(cos(angle), sin(angle));\n    hand *= 1. / max(abs(hand.x), abs(hand.y)) * .25 / 21.;\n    float alpha = 0.;\n    for (float i = 1.5; i < 21.; i += 2.)\n    {\n        vec2 d = uv1 - hand*i;\n        alpha += thetaY(1./180. - abs(d.x)) * thetaY(1./180. - abs(d.y));\n    }\n\n    return alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 color;\n    float time = iTime;\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    {\n        vec3 bg = RED;\n        if (uv.x >= 1./6.) bg = GREEN;\n        if (uv.x >= 2./6.) bg = YELLOW;\n        if (uv.x >= 3./6.) bg = BLUE;\n        if (uv.x >= 4./6.) bg = MAGENTA;\n        if (uv.x >= 5./6.) bg = CYAN;\n\n        color = bg;\n    }\n    \n    {\n        float rpos = fract(uv.x + time/12.);\n        float alpha = fract(6.*rpos);\n\n        vec3 rainbow = mix(RED, YELLOW, alpha);\n        if (rpos >= 1./6.) rainbow = mix(YELLOW, GREEN, alpha);\n        if (rpos >= 2./6.) rainbow = mix(GREEN, CYAN, alpha);\n        if (rpos >= 3./6.) rainbow = mix(CYAN, BLUE, alpha);\n        if (rpos >= 4./6.) rainbow = mix(BLUE, MAGENTA, alpha);\n        if (rpos >= 5./6.) rainbow = mix(MAGENTA, RED, alpha);\n\n        float bar0 = abs(fract(.25*uv.x + time / 4.) - .5)*2.*44./45.;\n        float bar1 = bar0 + 1./45.;\n\n        color = mix(color, rainbow, thetaY(uv.y-bar0)*thetaY(bar1-uv.y));\n    }\n    \n    {\n        float loop = mod(trunc(time), 4.);\n        float pos = 1.-2.*abs(fract(time)-.5);\n        vec2 uv1 = (uv - vec2(.25))*vec2(aspect, 1.);\n        \n        float extent = mix(1./240., .25, pos);\n        vec2 w = vec2(extent, 1./90.);\n        if (loop == 1.) w = w.yx;\n        if (loop == 3.) w = w.xx;\n        float alpha = thetaY(w.x-abs(uv1.x)) * thetaY(w.y-abs(uv1.y));\n        if (loop == 2.) alpha = min(alpha + thetaY(w.x-abs(uv1.y)) * thetaY(w.y-abs(uv1.x)), 1.);\n        \n        color = mix(color, GREY, alpha);\n    }\n    \n    {\n        vec2 uv1 = (uv - vec2(.75))*vec2(aspect, 1.);\n        float angle = .75*pi - 2.*pi*fract(time/64.);\n        float alpha = clock(angle, uv1);\n        color = mix(color, vec3(189.,179.,63.)/255., alpha);\n        \n        \n        angle = .75*pi - 2.*pi*fract(time/16.);\n        alpha = clock(angle, uv1);\n        color = mix(color, vec3(195., 86., 195.)/255., alpha);\n        \n        angle = .75*pi - 2.*pi*fract(time/4.);\n        alpha = clock(angle, uv1);\n        color = mix(color, vec3(57.,177.,193.)/255., alpha);\n    }\n    \n    if (abs(uv.x-3./4.) < 1./8. && abs(uv.y-1./4.) < 1./8.)\n    {\n        vec2 uv1 = (uv - vec2(5./8., 3./8.))/vec2(1.,aspect)*4.*20.;\n        uv1.y *= -1.;\n        vec2 t = trunc(uv1);\n        if ((t.y+1.)*iResolution.x < 20.*iResolution.y && mod(t.x + t.y, 2.) == 0.)\n        {\n            // pcg3d, see https://www.shadertoy.com/view/XlGcRh\n            uvec3 v = floatBitsToUint(vec3(uv1, time));\n            v = v * 12829u + 47989u;\n\n            v.x += v.y*v.z;\n            v.y += v.z*v.x;\n            v.z += v.x*v.y;\n\n            v.x += v.y*v.z;\n            v.y += v.z*v.x;\n            v.z += v.x*v.y;\n\n            v >>= 16u;\n            color = mix(color, vec3(0., 220., 170.)/255., float(v.x) / float(0xffffu));\n        }\n    }\n    \n    {\n        vec2 v = 233./vec2(55., 89.);\n        \n        vec2 d = abs(mod(time/v, 2.) - 1.);\n        d.x = 1. - d.x;\n        \n        float alpha = thetaY(uv.y-mix(0., 1.-1./90., d.y)) * thetaY(mix(1./90., 1., d.y)-uv.y);\n        float tmp = 1./90. / aspect;\n        \n        alpha *= thetaX(uv.x-mix(0., 1.-tmp, d.x)) * thetaX(mix(tmp, 1., d.x)-uv.x);\n\n        color = mix(color, PURPLE, alpha);\n    }\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 388, 388, 465], [467, 467, 490, 490, 567], [569, 569, 605, 605, 974], [976, 976, 1033, 1033, 4356]], "test": "untested"}
{"id": "DlBBRz", "name": "Test Shader v2 Gardener", "author": "peaceful_gardener", "description": "Test", "tags": ["test"], "likes": 2, "viewed": 124, "published": 3, "date": "1693658837", "time_retrieved": "2024-07-30T17:35:45.049183", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 7.0; i++){\n        uv = fract(uv * 1.2) - 0.5;\n        uv *= 1.0;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = vec3(0.200,0.839,1.000);\n\n\n        d = 1.0 - sin(-d * 55.0 + iTime * 1.0);\n\n        d = 0.02 / d;\n        \n\n\n\n        vec3 paletteOut = palette(length(uv0), vec3(0.590, 0.811, 0.120), vec3(0.410, 0.392, 0.590), vec3(0.940, 0.548, 0.278), vec3(-4.242, -6.611, -4.045));\n        \n        vec3 colorOut = d * paletteOut;\n        \n        finalColor += colorOut;\n    }\n    \n    fragColor = vec4(normalize(finalColor) * finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 110, 110, 153], [155, 155, 211, 211, 964]], "test": "untested"}
{"id": "DtSfRR", "name": "Test Shader Gardener", "author": "peaceful_gardener", "description": "Test", "tags": ["test"], "likes": 2, "viewed": 124, "published": 3, "date": "1693657743", "time_retrieved": "2024-07-30T17:35:45.890932", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 3.0; i++){\n        uv = fract(uv * 2.0) - 0.5;\n        uv *= 1.0;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = vec3(0.200,0.839,1.000);\n\n\n        d = 1.0 - sin(-d * 20.0 + iTime * 1.5);\n\n        d = 0.02 / d;\n        \n\n\n\n        vec3 paletteOut = palette(length(uv0), vec3(0.590, 0.811, 0.120), vec3(0.410, 0.392, 0.590), vec3(0.940, 0.548, 0.278), vec3(-4.242, -6.611, -4.045));\n        \n        vec3 colorOut = d * paletteOut;\n        \n        finalColor += normalize(colorOut) * colorOut;\n    }\n    \n    fragColor = vec4(normalize(finalColor) * finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 110, 110, 153], [155, 155, 211, 211, 986]], "test": "untested"}
{"id": "DtSfzR", "name": "Beach (Volume Absorption)", "author": "beans_please", "description": "More or less: [code]col *= pow(absorption_col, depth)[/code]", "tags": ["volume", "gradient", "exponential", "beach", "absorption"], "likes": 5, "viewed": 240, "published": 3, "date": "1693654314", "time_retrieved": "2024-07-30T17:35:46.636938", "image_code": "float remap_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    return out_start + t * (out_end - out_start);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y += -.05 * iTime;\n    float x = uv.x + .01 * cos(10. * uv.y) + .002 * cos(40. * uv.y);\n    \n    // Base color\n    vec3 col = vec3(.98, .82, .62);\n    \n    // Absorption color\n    const vec3 sea = vec3(.45, .83, .945);\n    \n    // Absorb\n    float depth = remap_clamp(x, 0.2, 1., 0.0001, 30.);\n    col *= pow(sea, vec3(depth));\n    \n    // Desaturate\n    col = mix(col, vec3(.2, 1, 1), .01);\n    \n    // Output\n    col = pow(col, vec3(1. / 2.4));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 94, 94, 220], [222, 222, 279, 298, 828]], "test": "untested"}
{"id": "mlsBWs", "name": "color shape", "author": "jezersek", "description": "-", "tags": ["circle", "sinus", "colorshape"], "likes": 16, "viewed": 273, "published": 3, "date": "1693645141", "time_retrieved": "2024-07-30T17:35:47.395908", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/(max(iResolution.x, iResolution.y)*0.5);\n    \n    float t = iTime * 2.;\n    float pulse_t = sin(t*0.003)*100. + sin(t*.5);\n    vec2 dir = vec2(sin(pulse_t), cos(pulse_t));\n    float k = dot(dir, uv.xy);\n    \n    vec3 rainbow = vec3(0.5+sin(uv.x+t)*0.5, 0.5+cos(uv.y+t)*0.5, 1);\n    vec3 col = vec3(0);\n    int N = 20;\n    for(int i=0; i<N; i++){\n        float I = float(i)/10.;\n        float d = sqrt(pow(uv.x, 2.) + pow(uv.y, 2.)) + sin(k*15. + t*3. + I*3.)*(0.02+I*0.01) - .2 - I*0.1 + sin(t)*0.1;\n        float l = exp(-pow((d)*200., 2.));\n        col += l * I;\n    }\n    \n    col *= rainbow;\n \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 811]], "test": "untested"}
{"id": "mtlBWs", "name": "columns illusion ", "author": "FabriceNeyret2", "description": "yet another variant, inspired by https://twitter.com/gsarcone/status/1697689932066676774\n\nthe background seems important. not sure sRGB is.", "tags": ["illusion", "perception", "short", "1tweet", "reproduction"], "likes": 13, "viewed": 238, "published": 3, "date": "1693643891", "time_retrieved": "2024-07-30T17:35:48.139919", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 6.*( u+u - R ) / R.y;\n    \n    O = vec4(sqrt( .5 + .5 * mod(ceil(U.x),2.)                // backgroud + columns\n              * sin( 12.6*(  U.x*(mod(ceil(U.x/2.),2.)*2.-1.) // bricks direction\n                           + ceil(2.*U.y)/8.))                // bricks offset\n            ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 371]], "test": "untested"}
{"id": "mtlfDl", "name": "cog motion illusion golf+sweep", "author": "FabriceNeyret2", "description": "sweeping variant of SnoopethDuckDuck https://shadertoy.com/view/DtfBDl  and https://www.shadertoy.com/view/ctXBDl\n\nuncomment 8 and 13 to have the nice ring version of https://www.shadertoy.com/view/ctXBDl", "tags": ["tiling", "2tweets", "short", "cog"], "likes": 16, "viewed": 247, "published": 3, "date": "1693642008", "time_retrieved": "2024-07-30T17:35:48.892906", "image_code": "// sweeping variant of SnoopethDuckDuck https://shadertoy.com/view/DtfBDl\n//                                  and https://www.shadertoy.com/view/ctXBDl\n\nM;}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "    M*.99;  \n // M*exp(-iTimeDelta/2.); // if you want framerate independant tail\n    for ( int k; k<4; k++ ) {\n       vec2 R = iResolution.xy, F, // F can be replaced by R but for the commented variant\n            u = 2.*(U+U-R)/R.y, \n            I = ceil(u - vec2(k/2,k%2)  );\n       O = max(O,            \n  //              smoothstep(-24./R.y, 24./R.y, .16 - abs(\n                  1.-8.*length(  length( F = I-u )\n                                * cos( mod(atan(F.y,F.x) - (mod(I.x+I.y, 2.) - .5) * iTime  + I.y, 2.1)   + vec2(0,11) )\n                                - vec2(.25, .4)\n              )               )\n  //      ))\n          ;\n   }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M                                    \\\nvoid mainImage( out vec4 O, vec2 U )         \\\n{ O = texelFetch(iChannel0,ivec2(U),0)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlfDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dtlfDl", "name": "LED Spectrogram mockup", "author": "TimoKinnunen", "description": "Simulation of a wall-mounted spectrogram with a 128x10 resolution using an LED matrix size 130x10.", "tags": ["sound", "fft", "music", "led", "equalizer", "frequency", "eq", "spectrogram"], "likes": 14, "viewed": 352, "published": 3, "date": "1693641395", "time_retrieved": "2024-07-30T17:35:49.640906", "image_code": "//******************************************************\n//\n// LED Music spectrogram mockup, Timo Kinnunen 2023\n//\n// Licence: MIT\n//\n//******************************************************\n\nconst float cols = 130.;\nconst float rows = 10.;\nconst float size = 5.;\nconst float radius = size * 0.5 * 0.9;\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 p = cos(radians(c.x * 360. + vec3(0,240,120)))*1.+0.5;\n    return c.z * mix(vec3(1), clamp(p, 0.0, 1.0), c.y);\n}\n\t\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = fragCoord.xy - 0.5 * iResolution.xy;\n    vec3 intTotal = vec3(0.03,0.03,0.1);\n    vec3 extTotal = vec3(0);\n    \n    for(float col = 0.; col < cols; col++) {\n        float i = col / (cols - 1.)*6./7.;\n        vec3 intCol = hsv2rgb(vec3(i,1.0,1.0));\n        vec3 extCol = hsv2rgb(vec3(i,0.9375,0.75));\n        i = clamp((col-1.)/(cols-3.),0.,1.) * (iChannelResolution[0].x - 1.);\n\t\n\t\tfloat vol = texelFetch(iChannel0, ivec2(i, 0), 0).x;\n\t\t\n        float x = size * (col - 0.5 * cols);\n\n        for(float row = 0.; row < rows; row++) {\n        \n            float y = size * row;\n            vec2 o = vec2(x,y) + 0.125;\n            float dist = distance(p, o);\n\t    \n            float b = clamp(vol * (rows + 1.) - row, 0., 1.);\n            b = 1. - b;\n            b *= b;\n            b = 1. - b;\n            \n            float intContrib = smoothstep(0.,1.,radius-dist);\n            float extContrib = clamp(0.25/(16.*radius+0.125*0.125*dist*dist), 0., 1.);\n            \n            intTotal = mix(intTotal, b * intCol, intContrib);\n            extTotal += b * extCol * extContrib;\n        }\n    }\n\tfragColor = vec4(intTotal + extTotal, 1);\n}\n", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlfDl.jpg", "access": "api", "license": "mit", "functions": [[304, 304, 326, 326, 448], [452, 452, 507, 507, 1657]], "test": "untested"}
{"id": "mtsBDl", "name": "EULER COLOURSPACE :::.", "author": "ENDESGA", "description": "using Euler's number and the exp() function you can directly enhance a 0-1 value to be less linear, enhancing vibrancy and saturation.\nL: normal, R: this method\n\nit follows:\ny = (1-exp(-x)) * (1/(1-exp(-1)))", "tags": ["color", "exp", "colour", "colorspace", "exponential", "euler", "colourspace"], "likes": 1, "viewed": 219, "published": 3, "date": "1693639574", "time_retrieved": "2024-07-30T17:35:50.390901", "image_code": "#define T (.5 + (sin(iTime)*.5))\n#define e (exp(1.))\n\n#define E(x) ((e - exp(1. - x)) / (e - 1.))\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n    vec2 uv = F/iResolution.xy;\n    C = vec4(\n        ( (uv.yx) * float(uv.x < T)) +\n        (E(uv.yx) * float(uv.x >= T))\n    ,0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 140, 140, 279]], "test": "untested"}
{"id": "MsX3Wn", "name": "Mongolian flag", "author": "sharavsambuu", "description": "Mongolian flag", "tags": ["flag", "mongolia"], "likes": 3, "viewed": 395, "published": 3, "date": "1693630163", "time_retrieved": "2024-07-30T17:35:51.318421", "image_code": "/*\n * @Author Sharavsambuu Gunchinish\n * https://github.com/sharavsambuu/leisure-software-renderer\n * \n * References :\n *\n * - https://en.wikipedia.org/wiki/Flag_of_Mongolia\n * - Indian flag by piyushslayer \n *   https://www.shadertoy.com/view/3lyGRd\n *\n */\n \n#define PI               3.1415926535\n#define MONGOLIAN_RED    vec3(0.855, 0.125, 0.192)\n#define MONGOLIAN_BLUE   vec3(0.0  , 0.4  , 0.698)\n#define MONGOLIAN_YELLOW vec3(1.0  , 0.827, 0.0  )\n\n\n// Hash by Dave_Hoskins\nfloat hash(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) / float(0xffffffffU);\n}\n\nfloat noise(vec2 t)\n{\n\treturn texture(iChannel0,t/iChannelResolution[0].xy).x;\n}\n\nconst vec3  positions[325] = vec3 [325](vec3(0.11369219140352504, 0.7428709688492116, 0), vec3(0.095009798870189, 0.7114055291300527, 0), vec3(0.05973449191579793, 0.6851026423160318, 0), vec3(0.020403139214037632, 0.6713366688704161, 0), vec3(-0.021263512554389342, 0.6713366688704161, 0), vec3(-0.061578149073693335, 0.6851026423160318, 0), vec3(-0.09697636650527736, 0.7114055291300486, 0), vec3(-0.11565875903861329, 0.7428709688492116, 0), vec3(-0.11688786381054343, 0.7652409885613711, 0), vec3(-0.10803830945264736, 0.7888398001824302, 0), vec3(-0.09169121598597833, 0.8266962271578713, 0), vec3(-0.08185837781053823, 0.8581613093192751, 0), vec3(-0.08062927303860822, 0.8720501932420925, 0), vec3(-0.08062927303860822, 0.8801622847368288, 0), vec3(-0.07116516629474728, 0.8713127303789348, 0), vec3(-0.06034904430176331, 0.8506637702105112, 0), vec3(-0.06010322334737716, 0.8384956329684048, 0), vec3(-0.06895277770527311, 0.814896821347354, 0), vec3(-0.07780233206316924, 0.7888398001824302, 0), vec3(-0.07485248061053734, 0.7809735296420771, 0), vec3(-0.06600292625264127, 0.7751967372140081, 0), vec3(-0.057153371894745154, 0.7722468857613767, 0), vec3(-0.04682889181053326, 0.7738447219648861, 0), vec3(-0.037979337452637256, 0.7836775601403252, 0), vec3(-0.033431649796496064, 0.8016224898104967, 0), vec3(-0.029498514526320078, 0.8232547337964694, 0), vec3(-0.026179931642109078, 0.8402163796491078, 0), vec3(-0.021263512554389227, 0.8539823530947235, 0), vec3(-0.0133972420140372, 0.8709439989473498, 0), vec3(-0.008480822926317235, 0.8866765400280598, 0), vec3(-0.008480822926317235, 0.8963864677263054, 0), vec3(-0.0133972420140372, 0.9052360220841994, 0), vec3(-0.02200097541754717, 0.9187561745754319, 0), vec3(-0.02691739450526702, 0.9354719994736749, 0), vec3(-0.02531955830175806, 0.9572271539368372, 0), vec3(-0.007620449585965872, 0.9847591008280686, 0), vec3(0.0027040304982458487, 0.9904129827789522, 0), vec3(-0.003195672407017983, 0.9727138740631559, 0), vec3(-0.0028269409754389254, 0.9572271539368372, 0), vec3(0.006022613382457196, 0.9395280452210409, 0), vec3(0.022492617326319016, 0.9198623688701626, 0), vec3(0.03330873931930287, 0.9041298277894606, 0), vec3(0.03416911265965406, 0.8955260943859539, 0), vec3(0.02433627448421379, 0.8660275798596281, 0), vec3(0.014257615354388048, 0.8294002576561154, 0), vec3(0.020157318259652054, 0.8077680136701466, 0), vec3(0.03281709741053102, 0.789208531614003, 0), vec3(0.045599787038603304, 0.7803589772561088, 0), vec3(0.05764501380351689, 0.7770403943718965, 0), vec3(0.06452800052632493, 0.7770403943718965, 0), vec3(0.06846113579650097, 0.7802360667789193, 0), vec3(0.06944441961404502, 0.7881023373192682, 0), vec3(0.06833822531930801, 0.7949853240420761, 0), vec3(0.06440509004913232, 0.8008850269473429, 0), vec3(0.05850538714386808, 0.8099804022596242, 0), vec3(0.05653881950877977, 0.8178466727999771, 0), vec3(0.058259566189482276, 0.8271878690666459, 0), vec3(0.062192701459658085, 0.8409538425122616, 0), vec3(0.06833822531930824, 0.8557030997754225, 0), vec3(0.07227136058948405, 0.8655359379508616, 0), vec3(0.07165680820351913, 0.8768437018526206, 0), vec3(0.06280725384562301, 0.8925762429333225, 0), vec3(0.07141098724913308, 0.8949115419999816, 0), vec3(0.09009337978246915, 0.8801622847368248, 0), vec3(0.0919370369403645, 0.8691003417894532, 0), vec3(0.08800390167018879, 0.8543510845262963, 0), vec3(0.08554569212632841, 0.8345624976982202, 0), vec3(0.09341196266668014, 0.8148968213473378, 0), vec3(0.10717793611229612, 0.7877336058876873, 0), vec3(0.11504420665264808, 0.7670846457192677, 0), vec3(0.18338243197195608, 0.4172807125124858, 0), vec3(0.15585048508072416, 0.35336726437212485, 0), vec3(0.10287606941054118, 0.3022365058598344, 0), vec3(0.036996053635092986, 0.2756878427861481, 0), vec3(-0.03699605363509328, 0.2756878427861481, 0), vec3(-0.10287606941054131, 0.3022365058598344, 0), vec3(-0.15499011174037353, 0.35336726437212485, 0), vec3(-0.1815387748140616, 0.4172807125124858, 0), vec3(-0.1815387748140616, 0.48844587880723145, 0), vec3(-0.15499011174037353, 0.5513760431300472, 0), vec3(-0.10287606941054131, 0.602383891165144, 0), vec3(-0.03699605363509328, 0.6289325542388384, 0), vec3(0.036996053635092986, 0.6289325542388384, 0), vec3(0.10287606941054118, 0.602383891165144, 0), vec3(0.15585048508072416, 0.5513760431300472, 0), vec3(0.18338243197195608, 0.48844587880723145, 0), vec3(0.2659782726456526, 0.31243807546685454, 0), vec3(0.2227137846737164, 0.22984223479316035, 0), vec3(0.1415928697263361, 0.16359348758613224, 0), vec3(0.049164190877199886, 0.129178553972093, 0), vec3(-0.04904128040000738, 0.12905564349489929, 0), vec3(-0.14048667543159973, 0.16248729329139755, 0), vec3(-0.22160759037897979, 0.22873604049842566, 0), vec3(-0.2658553621684598, 0.31231516498966494, 0), vec3(-0.250860283950914, 0.32731024320720903, 0), vec3(-0.19284653871581778, 0.2751962008773776, 0), vec3(-0.11762532667370154, 0.23918343105982898, 0), vec3(-0.039945905087725275, 0.2214843223440368, 0), vec3(0.040068815564918064, 0.2214843223440368, 0), vec3(0.11873152096843832, 0.23918343105982898, 0), vec3(0.19395273301055413, 0.2751962008773776, 0), vec3(0.25098319442810624, 0.32731024320720903, 0), vec3(0.2007742644947657, 0.06372872486681957, 0), vec3(0.037180419350882433, -0.03226435782090942, 0), vec3(-0.03718041935088272, -0.03226435782090942, 0), vec3(-0.20077426449476615, 0.06372872486681957, 0), vec3(-0.21750545320266332, 0.08554533456857871, 0), vec3(-0.08737398547457423, 0.08554533456857871, 0), vec3(0.08737398547457383, 0.08554533456857871, 0), vec3(0.2175054532026629, 0.08554533456857871, 0), vec3(0.48217780202814, -1, 0), vec3(0.3280480636281176, -1, 0), vec3(0.29301857762811273, -0.9878088170434229, 0), vec3(0.29301857762811273, -0.8998202791828795, 0), vec3(0.29301857762811273, -0.6565266714841562, 0), vec3(0.29301857762811273, -0.25792799394726096, 0), vec3(0.29301857762811273, -0.014634386248537634, 0), vec3(0.29301857762811273, 0.07335415161199754, 0), vec3(0.3280480636281176, 0.08554533456857871, 0), vec3(0.48217780202814, 0.08554533456857871, 0), vec3(0.517207288028145, 0.07335415161199754, 0), vec3(0.517207288028145, -0.014634386248537634, 0), vec3(0.517207288028145, -0.25792799394726096, 0), vec3(0.517207288028145, -0.6565266714841562, 0), vec3(0.517207288028145, -0.8998202791828795, 0), vec3(0.517207288028145, -0.9878088170434229, 0), vec3(0.21570788747371517, -0.16814189035777072, 0), vec3(0.08665188642106494, -0.16814189035777072, 0), vec3(-0.08665188642106529, -0.16814189035777072, 0), vec3(-0.21570788747371555, -0.16814189035777072, 0), vec3(-0.23598811621056057, -0.1558508426384706, 0), vec3(-0.23598811621056057, -0.10177023267354901, 0), vec3(-0.21570788747371555, -0.08947918495424889, 0), vec3(-0.08665188642106529, -0.08947918495424889, 0), vec3(0.08665188642106494, -0.08947918495424889, 0), vec3(0.21570788747371517, -0.08947918495424889, 0), vec3(0.2359881162105603, -0.10177023267354901, 0), vec3(0.2359881162105603, -0.1558508426384706, 0), vec3(0.22787602471582227, -0.4687809175718467, 0), vec3(0.19444437491932645, -0.5454770553402863, 0), vec3(0.13077674773335224, -0.6029991586666059, 0), vec3(0.050147474694744266, -0.6324976731929277, 0), vec3(-0.050270385171937174, -0.6300394636490709, 0), vec3(-0.11221726567720922, -0.5808752727718707, 0), vec3(-0.11578166951580632, -0.5081122702736116, 0), vec3(-0.08235001971931014, -0.46484778230167434, 0), vec3(-0.02261552780351198, -0.4424780754525437, 0), vec3(0.038348068884216026, -0.42477896673675564, 0), vec3(0.09808256080001453, -0.3981073931858634, 0), vec3(0.13151421059651036, -0.3440267832209498, 0), vec3(0.13421824109475644, -0.28822542657532524, 0), vec3(0.12241883528422855, -0.2557770605963803, 0), vec3(0.13495570395791456, -0.2508606415086667, 0), vec3(0.1762536242947627, -0.28527557512270185, 0), vec3(0.21103728934038157, -0.34083111081393125, 0), vec3(0.22971968187371797, -0.39687828841394324, 0), vec3(0.10816121992984028, -0.344641335606918, 0), vec3(0.07669613776843229, -0.3898723912139457, 0), vec3(0.017699108715792014, -0.41076717233676074, 0), vec3(-0.04523105560702419, -0.4264997134174666, 0), vec3(-0.10508845800001508, -0.45120471933326045, 0), vec3(-0.13753682397896727, -0.5092184645683464, 0), vec3(-0.1411012278175642, -0.5644052688280028, 0), vec3(-0.13716809254738832, -0.5880040804490618, 0), vec3(-0.1543755593544085, -0.5843167661332604, 0), vec3(-0.18977377678599247, -0.5489185487016841, 0), vec3(-0.21570788747371544, -0.5004918206876379, 0), vec3(-0.22849057710178744, -0.44936106217535565, 0), vec3(-0.22590945708073448, -0.37979373208412337, 0), vec3(-0.1924778072842383, -0.3050641619507821, 0), vec3(-0.12819562771229925, -0.24938571578234292, 0), vec3(-0.04854963849123507, -0.22087048507357032, 0), vec3(0.04682889181053326, -0.2232057841402335, 0), vec3(0.10484263704562916, -0.27040340738234336, 0), vec3(0.2157078874737155, -0.7620453161543526, 0), vec3(0.08665188642106518, -0.7620453161543526, 0), vec3(-0.08665188642106494, -0.7620453161543526, 0), vec3(-0.21570788747371533, -0.7620453161543526, 0), vec3(-0.23598811621056034, -0.7497542684350524, 0), vec3(-0.23598811621056034, -0.6956736584701306, 0), vec3(-0.21570788747371533, -0.6833826107508307, 0), vec3(-0.08665188642106494, -0.6833826107508307, 0), vec3(0.08665188642106518, -0.6833826107508307, 0), vec3(0.2157078874737155, -0.6833826107508307, 0), vec3(0.23598811621056062, -0.6956736584701306, 0), vec3(0.23598811621056062, -0.7497542684350524, 0), vec3(-0.3280480636281175, -1, 0), vec3(-0.4821778020281399, -1, 0), vec3(-0.517207288028145, -0.9878088170434229, 0), vec3(-0.517207288028145, -0.8998202791828795, 0), vec3(-0.517207288028145, -0.6565266714841562, 0), vec3(-0.517207288028145, -0.25792799394726096, 0), vec3(-0.517207288028145, -0.014634386248537634, 0), vec3(-0.517207288028145, 0.07335415161199754, 0), vec3(-0.4821778020281399, 0.08554533456857871, 0), vec3(-0.3280480636281175, 0.08554533456857871, 0), vec3(-0.29301857762811256, 0.07335415161199754, 0), vec3(-0.29301857762811256, -0.014634386248537634, 0), vec3(-0.29301857762811256, -0.25792799394726096, 0), vec3(-0.29301857762811256, -0.6565266714841562, 0), vec3(-0.29301857762811256, -0.8998202791828795, 0), vec3(-0.29301857762811256, -0.9878088170434229, 0), vec3(0.20077426449476593, -0.8369592520034761, 0), vec3(0.037180419350882773, -0.9329523346912132, 0), vec3(-0.03718041935088249, -0.9329523346912132, 0), vec3(-0.20077426449476593, -0.8369592520034761, 0), vec3(-0.2175054532026631, -0.815142642301725, 0), vec3(-0.08737398547457395, -0.815142642301725, 0), vec3(0.08737398547457406, -0.815142642301725, 0), vec3(0.21750545320266315, -0.815142642301725, 0), vec3(0.05518680425965708, -0.2921585618455056, 0), vec3(0.024705005915793016, -0.2675764664069056, 0), vec3(-0.028638141185969003, -0.2675764664069056, 0), vec3(-0.05911993952983301, -0.2921585618455056, 0), vec3(-0.05911993952983301, -0.3360376022034033, 0), vec3(-0.028638141185969003, -0.3616029814595525, 0), vec3(0.024705005915793016, -0.3616029814595525, 0), vec3(0.05518680425965708, -0.3360376022034033, 0), vec3(0.05518680425965708, -0.5143807046104472, 0), vec3(0.024705005915793016, -0.48979860917184714, 0), vec3(-0.028638141185969003, -0.48979860917184714, 0), vec3(-0.05911993952983301, -0.5143807046104472, 0), vec3(-0.05911993952983301, -0.5582597449683446, 0), vec3(-0.028638141185969003, -0.5838251242244941, 0), vec3(0.024705005915793016, -0.5838251242244941, 0), vec3(0.05518680425965708, -0.5582597449683446, 0), vec3(-0.517207288028145, 0.08554533456857871, 0), vec3(-0.517207288028145, -1, 0), vec3(-0.29301857762811256, -1, 0), vec3(-0.29301857762811256, 0.08554533456857871, 0), vec3(-0.2713863336421449, 0.3588982358458106, 0), vec3(-0.23795468384564872, 0.08554533456857871, 0), vec3(-0.23795468384564847, -0.815142642301725, 0), vec3(-0.23598811621056057, -0.08947918495424889, 0), vec3(-0.23598811621056057, -0.16814189035777072, 0), vec3(-0.23598811621056034, -0.6833826107508307, 0), vec3(-0.23598811621056034, -0.7620453161543526, 0), vec3(-0.2300884133052965, -0.42379568291921443, 0), vec3(-0.20452303404915242, -0.5260571999437871, 0), vec3(-0.1848573576982725, 0.4532934823300343, 0), vec3(-0.18289079006318465, 0.19173998686333193, 0), vec3(-0.16322511371230433, -0.27433654265252394, 0), vec3(-0.1553588431719526, 0.25467015118614766, 0), vec3(-0.14159286972633628, -0.5496560115648461, 0), vec3(-0.1337265991859843, -0.596853634806956, 0), vec3(-0.1317600315508964, 0.579153810975666, 0), vec3(-0.1317600315508964, 0.32546658604931245, 0), vec3(-0.11996062574036823, -0.5378566057543206, 0), vec3(-0.11799405810528031, 0.7600787485192663, 0), vec3(-0.10029494938948824, 0.8072763717613801, 0), vec3(-0.08062927303860833, 0.6971478690809445, 0), vec3(-0.08062927303860822, 0.8820059418947255, 0), vec3(-0.08062927303860822, 0.870206536084196, 0), vec3(-0.07669613776843223, 0.7935103983157644, 0), vec3(-0.07669613776843205, -0.43362852109465777, 0), vec3(-0.07079643486316822, 0.7777778572350584, 0), vec3(-0.06293016432281597, -0.5358900381192222, 0), vec3(-0.06293016432281597, -0.31366789535428063, 0), vec3(-0.058997029052640156, 0.8407080215578784, 0), vec3(-0.05309732614737615, 0.7718781543297958, 0), vec3(-0.05309732614737604, -0.45132762981044583, 0), vec3(-0.035398217431584084, 0.7915438306806741, 0), vec3(-0.027531946891232117, 0.9449361062175372, 0), vec3(-0.027531946891232117, 0.8348083186526116, 0), vec3(-0.01769910871579213, 0.911504456421043, 0), vec3(-0.01769910871579213, 0.862340265543843, 0), vec3(-0.00786627054035214, 0.8938053477052509, 0), vec3(-0.003933135270175927, -0.21730608123497075, 0), vec3(-0.003933135270175927, 0.9646017825684156, 0), vec3(-0.0019665676350879057, -0.5870207966315126, 0), vec3(-0.0019665676350879057, -0.48672584724202217, 0), vec3(-0.0019665676350879057, -0.36479865386657107, 0), vec3(-0.0019665676350879057, -0.2645037044770806, 0), vec3(-1.722646319018345e-16, -0.054080967522668555, 0), vec3(-1.722646319018345e-16, 0.21927193375456333, 0), vec3(-1.722646319018345e-16, 0.12487668727033963, 0), vec3(-1.722646319018345e-16, 0.6322511371230426, 0), vec3(-1.722646319018345e-16, 0.27236925990193583, 0), vec3(-1.722646319018345e-16, 0.6696159221897131, 0), vec3(1.1484308793455633e-16, -0.9547689443929723, 0), vec3(0.007866270540352082, 1, 0), vec3(0.003933135270176041, -0.6361849875087209, 0), vec3(0.013765973445615972, 0.9292035651368312, 0), vec3(0.01573254108070405, 0.838741453922784, 0), vec3(0.027531946891231944, 0.7954769659508466, 0), vec3(0.03539821743158391, 0.8977384829754234, 0), vec3(0.049164190877200115, -0.4021634389332458, 0), vec3(0.05309732614737615, 0.7777778572350544, 0), vec3(0.05506389378246412, 0.8997050506105135, 0), vec3(0.058997029052640156, -0.5358900381192222, 0), vec3(0.058997029052640156, -0.31366789535428063, 0), vec3(0.05703046141755219, 0.8210423452069959, 0), vec3(0.06096359668772812, 0.8053098041262898, 0), vec3(0.06489673195790416, 0.8485742920982273, 0), vec3(0.06686329959299213, 0.7777778572350544, 0), vec3(0.06882986722808009, 0.7935103983157604, 0), vec3(0.06882986722808032, -0.4159294123788615, 0), vec3(0.07276300249825612, 0.8682399684491057, 0), vec3(0.07866270540352002, 0.6971478690809445, 0), vec3(0.08456240830878425, 0.8407080215578702, 0), vec3(0.09242867884913633, 0.870206536084192, 0), vec3(0.1002949493894883, 0.8013766688561093, 0), vec3(0.11209435520001619, -0.3117013277191987, 0), vec3(0.11209435520001643, -0.24287146049111197, 0), vec3(0.11602749047019201, 0.7600787485192663, 0), vec3(0.13176003155089616, 0.579153810975666, 0), vec3(0.13176003155089616, 0.32546658604931245, 0), vec3(0.13569316682107244, -0.3077681924490181, 0), vec3(0.15732541080704004, 0.25467015118614766, 0), vec3(0.16519168134739234, -0.5771879584560775, 0), vec3(0.18682392533336029, 0.4532934823300343, 0), vec3(0.18485735769827222, 0.19370655449841812, 0), vec3(0.19469019587371272, -0.31170132771919046, 0), vec3(0.23795468384564836, 0.08554533456857871, 0), vec3(0.2379546838456486, -0.815142642301725, 0), vec3(0.23205498094038438, -0.42379568291920644, 0), vec3(0.2359881162105603, -0.16814189035777072, 0), vec3(0.2359881162105603, -0.08947918495424889, 0), vec3(0.23598811621056062, -0.7620453161543526, 0), vec3(0.23598811621056062, -0.6833826107508307, 0), vec3(0.2713863336421442, 0.3588982358458106, 0), vec3(0.29301857762811273, 0.08554533456857871, 0), vec3(0.29301857762811273, -1, 0), vec3(0.517207288028145, -1, 0), vec3(0.517207288028145, 0.08554533456857871, 0));\nconst ivec3 triangles[307] = ivec3[307](ivec3(0, 1, 294), ivec3(0, 294, 304), ivec3(1, 48, 49), ivec3(1, 49, 294), ivec3(1, 298, 48), ivec3(2, 3, 47), ivec3(2, 47, 287), ivec3(2, 287, 298), ivec3(3, 278, 47), ivec3(4, 5, 22), ivec3(4, 22, 278), ivec3(5, 250, 259), ivec3(5, 259, 22), ivec3(6, 7, 20), ivec3(6, 20, 21), ivec3(6, 21, 250), ivec3(7, 248, 255), ivec3(7, 255, 20), ivec3(8, 9, 19), ivec3(8, 19, 255), ivec3(8, 255, 248), ivec3(9, 18, 19), ivec3(9, 249, 18), ivec3(10, 11, 16), ivec3(10, 16, 17), ivec3(10, 17, 249), ivec3(11, 14, 15), ivec3(11, 15, 16), ivec3(11, 252, 14), ivec3(12, 13, 14), ivec3(12, 14, 252), ivec3(13, 251, 14), ivec3(15, 258, 16), ivec3(17, 253, 249), ivec3(18, 249, 253), ivec3(21, 259, 250), ivec3(22, 23, 46), ivec3(22, 46, 278), ivec3(23, 261, 284), ivec3(23, 284, 46), ivec3(24, 25, 45), ivec3(24, 45, 261), ivec3(25, 44, 45), ivec3(25, 263, 44), ivec3(26, 27, 283), ivec3(26, 44, 263), ivec3(26, 283, 44), ivec3(27, 265, 283), ivec3(28, 29, 43), ivec3(28, 43, 283), ivec3(28, 283, 265), ivec3(29, 42, 43), ivec3(29, 266, 42), ivec3(30, 31, 40), ivec3(30, 40, 41), ivec3(30, 41, 266), ivec3(31, 264, 282), ivec3(31, 282, 40), ivec3(32, 33, 39), ivec3(32, 39, 264), ivec3(33, 262, 39), ivec3(34, 35, 37), ivec3(34, 37, 268), ivec3(34, 38, 262), ivec3(34, 268, 38), ivec3(35, 36, 37), ivec3(35, 280, 36), ivec3(38, 39, 262), ivec3(39, 282, 264), ivec3(41, 42, 266), ivec3(41, 285, 42), ivec3(45, 284, 261), ivec3(46, 47, 278), ivec3(48, 298, 287), ivec3(50, 51, 68), ivec3(50, 68, 69), ivec3(50, 69, 294), ivec3(51, 295, 301), ivec3(51, 301, 68), ivec3(52, 53, 67), ivec3(52, 67, 301), ivec3(52, 301, 295), ivec3(53, 292, 67), ivec3(54, 55, 291), ivec3(54, 67, 292), ivec3(54, 291, 67), ivec3(56, 57, 66), ivec3(56, 66, 291), ivec3(57, 293, 299), ivec3(57, 299, 66), ivec3(58, 59, 65), ivec3(58, 65, 299), ivec3(58, 299, 293), ivec3(59, 64, 65), ivec3(59, 297, 64), ivec3(60, 61, 62), ivec3(60, 62, 63), ivec3(60, 63, 297), ivec3(61, 288, 62), ivec3(63, 64, 297), ivec3(63, 300, 64), ivec3(66, 67, 291), ivec3(69, 304, 294), ivec3(70, 71, 310), ivec3(71, 305, 310), ivec3(71, 306, 305), ivec3(72, 73, 83), ivec3(72, 83, 305), ivec3(72, 305, 306), ivec3(73, 82, 83), ivec3(73, 276, 82), ivec3(73, 277, 276), ivec3(74, 75, 80), ivec3(74, 80, 81), ivec3(74, 81, 276), ivec3(74, 276, 277), ivec3(75, 246, 80), ivec3(76, 77, 239), ivec3(76, 239, 246), ivec3(78, 79, 239), ivec3(79, 245, 239), ivec3(80, 246, 245), ivec3(84, 85, 310), ivec3(84, 310, 305), ivec3(86, 87, 100), ivec3(86, 100, 101), ivec3(86, 101, 320), ivec3(87, 308, 100), ivec3(87, 311, 308), ivec3(88, 89, 98), ivec3(88, 98, 99), ivec3(88, 99, 311), ivec3(89, 274, 98), ivec3(89, 275, 274), ivec3(90, 91, 97), ivec3(90, 97, 274), ivec3(90, 274, 275), ivec3(91, 96, 97), ivec3(91, 240, 96), ivec3(92, 93, 95), ivec3(92, 95, 242), ivec3(92, 242, 240), ivec3(93, 94, 95), ivec3(93, 230, 94), ivec3(96, 240, 242), ivec3(99, 308, 311), ivec3(102, 103, 108), ivec3(102, 108, 109), ivec3(102, 109, 313), ivec3(103, 104, 108), ivec3(103, 273, 104), ivec3(104, 105, 107), ivec3(104, 107, 108), ivec3(105, 106, 107), ivec3(105, 231, 106), ivec3(110, 111, 124), ivec3(110, 124, 125), ivec3(110, 125, 323), ivec3(111, 112, 113), ivec3(111, 113, 124), ivec3(111, 322, 112), ivec3(113, 114, 124), ivec3(114, 115, 122), ivec3(114, 122, 123), ivec3(114, 123, 124), ivec3(115, 116, 121), ivec3(115, 121, 122), ivec3(116, 117, 118), ivec3(116, 118, 119), ivec3(116, 119, 121), ivec3(117, 321, 118), ivec3(119, 120, 121), ivec3(119, 324, 120), ivec3(126, 127, 135), ivec3(126, 135, 136), ivec3(126, 136, 137), ivec3(126, 137, 316), ivec3(127, 128, 134), ivec3(127, 134, 135), ivec3(128, 129, 133), ivec3(128, 133, 134), ivec3(129, 130, 132), ivec3(129, 132, 133), ivec3(129, 234, 130), ivec3(130, 131, 132), ivec3(131, 233, 132), ivec3(135, 317, 136), ivec3(138, 139, 148), ivec3(138, 148, 315), ivec3(139, 218, 148), ivec3(139, 289, 218), ivec3(139, 309, 289), ivec3(140, 141, 225), ivec3(140, 225, 289), ivec3(140, 289, 309), ivec3(141, 224, 225), ivec3(141, 281, 224), ivec3(142, 143, 222), ivec3(142, 222, 223), ivec3(142, 223, 281), ivec3(143, 247, 222), ivec3(144, 145, 221), ivec3(144, 221, 256), ivec3(144, 256, 247), ivec3(145, 220, 221), ivec3(145, 260, 220), ivec3(146, 147, 270), ivec3(146, 220, 260), ivec3(146, 270, 220), ivec3(147, 219, 270), ivec3(147, 296, 219), ivec3(148, 149, 155), ivec3(148, 155, 315), ivec3(148, 218, 296), ivec3(149, 154, 155), ivec3(149, 307, 312), ivec3(149, 312, 154), ivec3(150, 151, 152), ivec3(150, 152, 153), ivec3(150, 153, 307), ivec3(151, 303, 152), ivec3(153, 312, 307), ivec3(156, 157, 217), ivec3(156, 217, 290), ivec3(156, 290, 302), ivec3(157, 216, 217), ivec3(157, 286, 216), ivec3(158, 159, 271), ivec3(158, 216, 286), ivec3(158, 271, 216), ivec3(159, 215, 271), ivec3(159, 254, 215), ivec3(160, 161, 167), ivec3(160, 167, 237), ivec3(160, 168, 169), ivec3(160, 169, 214), ivec3(160, 214, 254), ivec3(160, 237, 168), ivec3(161, 165, 238), ivec3(161, 166, 167), ivec3(161, 238, 166), ivec3(161, 243, 165), ivec3(162, 163, 164), ivec3(162, 164, 165), ivec3(162, 165, 243), ivec3(163, 244, 164), ivec3(169, 241, 257), ivec3(169, 257, 214), ivec3(170, 171, 213), ivec3(170, 213, 257), ivec3(170, 257, 241), ivec3(171, 212, 213), ivec3(171, 267, 212), ivec3(172, 173, 210), ivec3(172, 210, 211), ivec3(172, 211, 267), ivec3(173, 302, 210), ivec3(174, 175, 183), ivec3(174, 183, 184), ivec3(174, 184, 185), ivec3(174, 185, 318), ivec3(175, 176, 182), ivec3(175, 182, 183), ivec3(176, 177, 181), ivec3(176, 181, 182), ivec3(177, 178, 180), ivec3(177, 180, 181), ivec3(177, 236, 178), ivec3(178, 179, 180), ivec3(179, 235, 180), ivec3(183, 319, 184), ivec3(186, 187, 200), ivec3(186, 200, 201), ivec3(186, 201, 228), ivec3(187, 188, 189), ivec3(187, 189, 200), ivec3(187, 227, 188), ivec3(189, 190, 200), ivec3(190, 191, 198), ivec3(190, 198, 199), ivec3(190, 199, 200), ivec3(191, 192, 197), ivec3(191, 197, 198), ivec3(192, 193, 194), ivec3(192, 194, 197), ivec3(193, 226, 194), ivec3(194, 195, 197), ivec3(195, 196, 197), ivec3(195, 229, 196), ivec3(202, 203, 208), ivec3(202, 208, 209), ivec3(202, 209, 314), ivec3(203, 204, 208), ivec3(203, 279, 204), ivec3(204, 205, 207), ivec3(204, 207, 208), ivec3(205, 206, 207), ivec3(205, 232, 206), ivec3(210, 302, 290), ivec3(211, 272, 267), ivec3(212, 267, 272), ivec3(214, 215, 254), ivec3(218, 219, 296), ivec3(222, 247, 256), ivec3(223, 269, 281), ivec3(224, 281, 269), ivec3(239, 245, 246));\nconst int   len            = 307;\n\nbool same_side(vec3 p1, vec3 p2, vec3 a, vec3 b) \n{\n    vec3 cp1 = cross(b-a, p1-a);\n    vec3 cp2 = cross(b-a, p2-a);\n    return dot(cp1, cp2) >= 0.0;\n}\n\nbool point_in_triangle(vec3 p, vec3 a, vec3 b, vec3 c) \n{\n    return same_side(p, a, b, c) && same_side(p, b, a, c) && same_side(p, c, a, b);\n}\n\nbool is_in_path(vec2 p) \n{\n    for (int i=0; i<len; i++) \n    {\n        ivec3 triangle = triangles[i];\n        vec3 a = positions[triangle[0]];\n        vec3 b = positions[triangle[1]];\n        vec3 c = positions[triangle[2]];\n        if (point_in_triangle(vec3(p, 0.0), a, b, c)) \n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 paint_background(vec2 uv)\n{\n    vec3 out_color = vec3(0.0);\n    \n    float part_width = 0.33f;\n    \n    if (uv.x<=part_width) \n    {\n\t\tout_color = MONGOLIAN_RED;\n\t}\n    if ((uv.x>part_width) && (uv.x<part_width*2.0)) \n    {\n\t\tout_color = MONGOLIAN_BLUE;\n\t}\n    if (uv.x>=part_width*2.0) \n    {\n\t\tout_color = MONGOLIAN_RED;\n\t}\n    return out_color;\n\n}\n\nvec3 paint_soyombo(vec2 uv, float res_xdivy)\n{\n    vec3 out_color = vec3(0.0);\n    uv   *= 2.0;\n    uv   -= vec2(1.0);\n    uv.x *= res_xdivy;\n    uv.x *= 1.35;\n    uv.y *= 1.4;\n    \n    float width  = (1.0*2.0-1.0)*res_xdivy*1.4;\n    float height = (1.0*2.0-1.0)*res_xdivy*1.3;\n    uv.x += width/1.55;\n    uv.y -= height/24.0;\n    \n    if (is_in_path(uv)) {\n        out_color = MONGOLIAN_YELLOW;\n    }\n    return out_color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 st = fragCoord / iResolution.xy;\n    float w = sin((uv.x + uv.y - iTime * 2.95 + sin(15.5 * uv.x + 4.5 * uv.y) * PI * 0.1) * PI * 0.6);\n\tuv *= 1.0 + (.026 - .026 * w);\n    \n    // Mongolian flag color computations\n    vec3 out_color = vec3(0.);\n    out_color += paint_background(uv);\n    out_color += paint_soyombo(uv, iResolution.x/iResolution.y);\n    \n    out_color += w * .225;\n    float v = 16. * st.x * (1. - st.x) * st.y * (1. - st.y);\n\tout_color *= 1. - .6 * exp2(-1.75 * v);\n    out_color = clamp(out_color - hash(fragCoord) * .004, 0., 1.);\n    \n    out_color -= noise(fragCoord.xy)*0.03;\n    \n    fragColor = vec4(out_color, 1.0);\n    \n    fragColor.rgb -= mod(fragCoord.y, 0.8)<1.0 ? 0.01 : 0.0;\n    fragColor.rgb -= mod(fragCoord.x, 0.8)<1.0 ? 0.01 : 0.0;\n    \n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsX3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 477, 497, 497, 637], [639, 639, 660, 660, 719], [23764, 23764, 23815, 23815, 23916], [23918, 23918, 23975, 23975, 24061], [24063, 24063, 24089, 24089, 24414], [24416, 24416, 24448, 24448, 24771], [24773, 24773, 24819, 24819, 25198], [25200, 25200, 25255, 25255, 26081]], "test": "untested"}
{"id": "mtlBzX", "name": "Radiance Cascades", "author": "fad", "description": "Interactive!\n\nA 2D implementation of [url=https://drive.google.com/file/d/1L6v1_7HY2X-LV3Ofb6oyTIxgEaP4LOI6/view]\"Radiance Cascades: A Novel Approach to Calculating Global Illumination\"[/url]\n\nSky integral formula [url=/view/NttSW7]by Mathis[/url]", "tags": ["mouse", "interactive", "global", "illumination", "light", "tracing", "keyboard", "trace", "path", "radiance", "cascade"], "likes": 108, "viewed": 5200, "published": 3, "date": "1693626074", "time_retrieved": "2024-07-30T17:35:52.252922", "image_code": "// Controls:\n// Click and drag with mouse to draw\n// Press space to toggle betweem emissive and non-emissive brush\n// Press 1 to switch to drawing a temporary light instead of permanent\n\n// A 2D implementation of \n// Radiance Cascades: A Novel Approach to Calculating Global Illumination\n// https://drive.google.com/file/d/1L6v1_7HY2X-LV3Ofb6oyTIxgEaP4LOI6/view\n\n// You can set the parameters to the algorithm in the Common tab\n\n// Sky integral formula taken from\n// Analytic Direct Illumination - Mathis\n// https://www.shadertoy.com/view/NttSW7\n\n// sdBezier() formula taken from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n\n// In this Shadertoy implementation there is a bit of temporal lag which\n// is not due to a flaw in the actual algorithm, but rather a limitation\n// of Shadertoy - one of the steps in the algorithm is to merge cascades\n// in a reverse mipmap-like fashion which would actually be done within\n// one frame, but in Shadertoy we have to split that work up over\n// multiple frames. Even with this limitation, it still looks good and\n// only has an n-frame delay to fully update the lighting, where n is\n// the total number of cascades.\n\n// For small point lights, a ringing artefact is visible. I couldn't\n// figure out a way to fix this properly :(\n\n// This buffer interpolates the radiance coming from cascade 0\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    screenRes = iResolution.xy;\n    ivec2 cubemapRes = textureSize(iChannel0, 0);\n    int nPixels = int(float(6 * cubemapRes.x * cubemapRes.y) * cubemapUsage);\n    ivec2 c0_sRes = ivec2(sqrt(\n        4.0 * float(nPixels) / (4.0 + float(c_dRes * (nCascades - 1))) *\n        iResolution.xy / iResolution.yx\n    ));\n    vec2 p = fragCoord / iResolution.xy * vec2(c0_sRes);\n    ivec2 q = ivec2(round(p)) - 1;\n    vec2 w = p - vec2(q) - 0.5;\n    ivec2 h = ivec2(1, 0);\n    vec4 S0 = cascadeFetch(iChannel0, 0, q + h.yy, 0);\n    vec4 S1 = cascadeFetch(iChannel0, 0, q + h.xy, 0);\n    vec4 S2 = cascadeFetch(iChannel0, 0, q + h.yx, 0);\n    vec4 S3 = cascadeFetch(iChannel0, 0, q + h.xx, 0);\n    vec3 fluence = mix(mix(S0, S1, w.x), mix(S2, S3, w.x), w.y).rgb * 2.0 * PI;\n    // Overlay actual SDF drawing to fix low resolution edges\n    vec4 data = sampleDrawing(iChannel1, fragCoord);\n    fluence = mix(fluence, data.gba * 2.0 * PI, clamp(3.0 - data.r, 0.0, 1.0));\n    // Tonemap\n    fragColor = vec4(1.0 - 1.0 / pow(1.0 + fluence, vec3(2.5)), 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// This buffer calculates and merges radiance cascades. Normally the\n// merging would happen within one frame (like a mipmap calculation),\n// meaning this technique actually has no termporal lag - but since\n// Shadertoy has no way of running a pass multiple times per frame, we \n// have to resort to spreading out the merging of cascades over multiple\n// frames.\n\nvec2 intersectAABB(vec2 ro, vec2 rd, vec2 a, vec2 b) {\n    // Return the two intersection t-values for the intersection between a ray\n    // and an axis-aligned bounding box\n    vec2 ta = (a - ro) / rd;\n    vec2 tb = (b - ro) / rd;\n    vec2 t1 = min(ta, tb);\n    vec2 t2 = max(ta, tb);\n    vec2 t = vec2(max(t1.x, t1.y), min(t2.x, t2.y));\n    return t.x > t.y ? vec2(-1.0) : t;\n}\n\nfloat intersect(vec2 ro, vec2 rd, float tMax) {\n    // Return the intersection t-value for the intersection between a ray and\n    // the SDF drawing from Buffer B\n    screenRes = vec2(textureSize(iChannel1, 0));\n    float tOffset = 0.0;\n    // First clip the ray to the screen rectangle\n    vec2 tAABB = intersectAABB(ro, rd, vec2(0.0001), screenRes - 0.0001);\n    \n    if (tAABB.x > tMax || tAABB.y < 0.0) {\n        return -1.0;\n    }\n    \n    if (tAABB.x > 0.0) {\n        ro += tAABB.x * rd;\n        tOffset += tAABB.x;\n        tMax -= tAABB.x;\n    }\n    \n    if (tAABB.y < tMax) {\n        tMax = tAABB.y;\n    }\n\n    float t = 0.0;\n\n    for (int i = 0; i < 100; i++) {\n        float d = sdDrawing(iChannel1, ro + rd * t);\n        t += abs(d);\n\n        if (t >= tMax) {\n            break;\n        }\n\n        if (0.2 < t && d < 1.0) {\n            return tOffset + t;\n        }\n    }\n\n    return -1.0;\n}\n\nvec4 radiance(vec2 ro, vec2 rd, float tMax) {\n    // Returns the radiance and visibility term for a ray\n    vec4 p = sampleDrawing(iChannel1, ro);\n\n    if (p.r > 0.0) {\n        float t = intersect(ro, rd, tMax);\n        \n        if (t == -1.0) {\n            return vec4(0.0, 0.0, 0.0, 1.0);\n        }\n\n        p = sampleDrawing(iChannel1, ro + rd * t);\n    }\n\n    return vec4(p.gba, 0.0);\n}\n\nvec3 integrateSkyRadiance_(vec2 angle) {\n    // Sky radiance helper function\n    float a1 = angle[1];\n    float a0 = angle[0];\n    \n    // Sky integral formula taken from\n    // Analytic Direct Illumination - Mathis\n    // https://www.shadertoy.com/view/NttSW7\n    const vec3 SkyColor = vec3(0.2,0.5,1.);\n    const vec3 SunColor = vec3(1.,0.7,0.1)*10.;\n    const float SunA = 2.0;\n    const float SunS = 64.0;\n    const float SSunS = sqrt(SunS);\n    const float ISSunS = 1./SSunS;\n    vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));\n    SI += SunColor*(atan(SSunS*(SunA-a0))-atan(SSunS*(SunA-a1)))*ISSunS;\n    return SI / 6.0;\n}\n\nvec3 integrateSkyRadiance(vec2 angle) {\n    // Integrate the radiance from the sky over an interval of directions\n    if (angle[1] < 2.0 * PI) {\n        return integrateSkyRadiance_(angle);\n    }\n    \n    return\n        integrateSkyRadiance_(vec2(angle[0], 2.0 * PI)) +\n        integrateSkyRadiance_(vec2(0.0, angle[1] - 2.0 * PI));\n}\n\nvoid mainCubemap(out vec4 fragColor, vec2 fragCoord, vec3 fragRO, vec3 fragRD) {\n    // Calculate the index for this cubemap texel\n    int face;\n    \n    if (abs(fragRD.x) > abs(fragRD.y) && abs(fragRD.x) > abs(fragRD.z)) {\n        face = fragRD.x > 0.0 ? 0 : 1;\n    } else if (abs(fragRD.y) > abs(fragRD.z)) {\n        face = fragRD.y > 0.0 ? 2 : 3;\n    } else {\n        face = fragRD.z > 0.0 ? 4 : 5;\n    }\n    \n    int i =\n        int(fragCoord.x) + int(iResolution.x) *\n        (int(fragCoord.y) + int(iResolution.y) * face);\n    // Figure out which cascade this pixel is in\n    int nPixels =\n        int(float(6 * int(iResolution.x) * int(iResolution.y)) * cubemapUsage);\n    vec2 screenRes = vec2(textureSize(iChannel1, 0));\n    ivec2 c0_sRes = ivec2(sqrt(\n        4.0 * float(nPixels) / (4.0 + float(c_dRes * (nCascades - 1))) *\n        screenRes / screenRes.yx\n    ));\n    int c_size =\n        c0_sRes.x * c0_sRes.y +\n        c0_sRes.x * c0_sRes.y * c_dRes * (nCascades - 1) / 4;    \n    \n    if (i >= c_size) {\n        return;\n    }\n    \n    int n = i < c0_sRes.x * c0_sRes.y ? 0 : int(\n        (4.0 * float(i) / float(c0_sRes.x * c0_sRes.y) - 4.0) / float(c_dRes)\n        + 1.0\n    );\n    // Figure out this pixel's index within its own cascade\n    int j = i - (n > 0\n        ? c0_sRes.x * c0_sRes.y + (c0_sRes.x * c0_sRes.y * c_dRes * (n - 1)) / 4\n        : 0);\n    // Calculate this cascades spatial and directional resolution\n    ivec2 cn_sRes = c0_sRes >> n;\n    int cn_dRes = n == 0 ? 1 : c_dRes << 2 * (n - 1);\n    // Calculate this pixel's direction and position indices\n    int d = j % cn_dRes;\n    j /= cn_dRes;\n    ivec2 p = ivec2(j % cn_sRes.x, 0);\n    j /= cn_sRes.x;\n    p.y = j;\n    int nDirs = c_dRes << 2 * n;\n    // Calculate this pixel's ray interval\n    vec2 ro = (vec2(p) + 0.5) / vec2(cn_sRes) * screenRes;\n    float c0_intervalLength = \n        length(screenRes) * 4.0 / (float(1 << 2 * nCascades) - 1.0);\n    float t1 = c0_intervalLength;\n    float tMin = n == 0 ? 0.0 : t1 * float(1 << 2 * (n - 1));\n    float tMax = t1 * float(1 << 2 * n);\n    vec4 s = vec4(0.0);\n    \n    // Calculate radiance intervals and merge with above cascade\n    for (int i = 0; i < nDirs / cn_dRes; ++i) {\n        int j = 4 * d + i;\n        float angle = (float(j) + 0.5) / float(nDirs) * 2.0 * PI;\n        vec2 rd = vec2(cos(angle), sin(angle));\n        vec4 si = radiance(ro + rd * tMin, rd, tMax - tMin);\n        \n        // If the visibility term is non-zero\n        if (si.a != 0.0) {\n            if (n == nCascades - 1) {\n                // If we are the top-level cascade, then there's no other\n                // cascade to merge with, so instead merge with the sky radiance\n                vec2 angle = vec2(j, j + 1) / float(nDirs) * 2.0 * PI;\n                si.rgb += integrateSkyRadiance(angle) / (angle.y - angle.x);\n            } else {\n                // Otherwise, find the radiance coming from the above cascade in\n                // this direction by interpolating the above cascades\n                vec2 pf = (vec2(p) + 0.5) / 2.0;\n                ivec2 q = ivec2(round(pf)) - 1;\n                vec2 w = pf - vec2(q) - 0.5;\n                ivec2 h = ivec2(1, 0);\n                vec4 S0 = cascadeFetch(iChannel0, n + 1, q + h.yy, j);\n                vec4 S1 = cascadeFetch(iChannel0, n + 1, q + h.xy, j);\n                vec4 S2 = cascadeFetch(iChannel0, n + 1, q + h.yx, j);\n                vec4 S3 = cascadeFetch(iChannel0, n + 1, q + h.xx, j);\n                vec4 S = mix(mix(S0, S1, w.x), mix(S2, S3, w.x), w.y);\n                si.rgb += si.a * S.rgb;\n                si.a *= S.a;\n            }\n        }\n        \n        s += si;\n    }\n    \n    s /= float(nDirs / cn_dRes);\n    fragColor = s;\n}", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The shader automatically calculates the maximum spatial resolution\n// possible for the cascades such that they can still fit within the\n// cubemap buffer with the c_dRes and nCascades parameters below. But if\n// you have a low end device, that might be too much, so decrease the\n// proportion of the cubemap buffer actually used here:\nconst float cubemapUsage = 1.0;\n\n// Number of directions in cascade 0\nconst int c_dRes = 16;\n// Number of cascades all together\nconst int nCascades = 5;\n\n// Brush radius used for drawing, measured as fraction of iResolution.y\nconst float brushRadius = 0.01;\n\nconst float MAX_FLOAT = uintBitsToFloat(0x7f7fffffu);\nconst float PI = 3.1415927;\nconst float MAGIC = 1e25;\n\nvec2 screenRes;\n\nvec4 cubemapFetch(samplerCube sampler, int face, ivec2 P) {\n    // Look up a single texel in a cubemap\n    ivec2 cubemapRes = textureSize(sampler, 0);\n    if (clamp(P, ivec2(0), cubemapRes - 1) != P || face < 0 || face > 5) {\n        return vec4(0.0);\n    }\n\n    vec2 p = (vec2(P) + 0.5) / vec2(cubemapRes) * 2.0 - 1.0;\n    vec3 c;\n    \n    switch (face) {\n        case 0: c = vec3( 1.0, -p.y, -p.x); break;\n        case 1: c = vec3(-1.0, -p.y,  p.x); break;\n        case 2: c = vec3( p.x,  1.0,  p.y); break;\n        case 3: c = vec3( p.x, -1.0, -p.y); break;\n        case 4: c = vec3( p.x, -p.y,  1.0); break;\n        case 5: c = vec3(-p.x, -p.y, -1.0); break;\n    }\n    \n    return texture(sampler, normalize(c));\n}\n\nvec4 cascadeFetch(samplerCube cascadeTex, int n, ivec2 p, int d) {\n    // Look up the radiance interval at position p in direction d of cascade n\n    ivec2 cubemapRes = textureSize(cascadeTex, 0);\n    int nPixels = int(float(6 * cubemapRes.x * cubemapRes.y) * cubemapUsage);\n    ivec2 c0_sRes = ivec2(sqrt(\n        4.0 * float(nPixels) / (4.0 + float(c_dRes * (nCascades - 1))) *\n        screenRes / screenRes.yx\n    ));\n    int cn_offset = n > 0\n        ? c0_sRes.x * c0_sRes.y + (c0_sRes.x * c0_sRes.y * c_dRes * (n - 1)) / 4\n        : 0;\n    int cn_dRes = n == 0 ? 1 : c_dRes << 2 * (n - 1);\n    ivec2 cn_sRes = c0_sRes >> n;\n    p = clamp(p, ivec2(0), cn_sRes - 1);\n    int i = cn_offset + d + cn_dRes * (p.x + cn_sRes.x * p.y);\n    int x = i % cubemapRes.x;\n    i /= cubemapRes.x;\n    int y = i % cubemapRes.y;\n    i /= cubemapRes.y;\n    return cubemapFetch(cascadeTex, i, ivec2(x, y));\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_1 = 49;\n\n#ifndef HW_PERFORMANCE\nuniform vec4 iMouse;\nuniform sampler2D iChannel2;\nuniform float iTime;\n#endif\n\nbool keyToggled(int keyCode) {\n    return texelFetch(iChannel2, ivec2(keyCode, 2), 0).r > 0.0;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(\n        abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0,\n        1.0\n    );\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 getEmissivity() {\n    return !keyToggled(KEY_SPACE)\n        ? pow(hsv2rgb(vec3(iTime * 0.2, 1.0, 0.8)), vec3(2.2))\n        : vec3(0.0);\n}\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return distance(p, c) - r;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    return distance(ap, ab * clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0));\n}\n\nvec4 sampleDrawing(sampler2D drawingTex, vec2 P) {\n    // Return the drawing (in the format listed at the top of Buffer B) at P\n    vec4 data = texture(drawingTex, P / vec2(textureSize(drawingTex, 0)));\n    \n    if (keyToggled(KEY_1) && iMouse.z > 0.0) {\n        float radius = brushRadius * screenRes.y;\n        //float sd = sdCircle(P, iMouse.xy + 0.5, radius);\n        float sd = sdSegment(P, abs(iMouse.zw) + 0.5, iMouse.xy + 0.5) - radius;\n        \n        if (sd <= max(data.r, 0.0)) {\n            data = vec4(min(sd, data.r), getEmissivity());\n        }\n    }\n\n    return data;\n}\n\nfloat sdDrawing(sampler2D drawingTex, vec2 P) {\n    // Return the signed distance for the drawing at P\n    return sampleDrawing(drawingTex, P).r;\n}", "buffer_a_code": "// SDF drawing logic from \n// Smooth Mouse Drawing - fad\n// https://www.shadertoy.com/view/dldXR7\n\n// This buffer tracks smoothed mouse positions over multiple frames.\n\n// See https://lazybrush.dulnan.net/ for what these mean:\n#define RADIUS (iResolution.y * 0.015)\n#define FRICTION 0.05\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    if (fragCoord.y != 0.5 || fragCoord.x > 3.0) {\n        return;\n    }\n\n    if (iFrame == 0) {\n        if (fragCoord.x == 2.5) {\n            fragColor = iMouse;\n        } else {\n            fragColor = vec4(0.0);\n        }\n        \n        return;\n    }\n    \n    vec4 iMouse = iMouse;\n    \n    if (iMouse == vec4(0.0)) {\n        float t = iTime * 3.0;\n        iMouse.xy = vec2(\n            cos(3.14159 * t) + sin(0.72834 * t + 0.3),\n            sin(2.781374 * t + 3.47912) + cos(t)\n        ) * 0.25 + 0.5;\n        iMouse.xy *= iResolution.xy;\n        iMouse.z = MAGIC;\n    }\n    \n    vec4 mouseA = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 mouseB = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 mouseC;\n    mouseC.zw = iMouse.zw;\n    float dist = distance(mouseB.xy, iMouse.xy);\n    \n    if (mouseB.z > 0.0 && (mouseB.z != MAGIC || iMouse.z == MAGIC) && dist > 0.0) {\n        vec2 dir = (iMouse.xy - mouseB.xy) / dist;\n        float len = max(dist - RADIUS, 0.0);\n        float ease = 1.0 - pow(FRICTION, iTimeDelta * 10.0);\n        mouseC.xy = mouseB.xy + dir * len * ease;\n    } else {\n        mouseC.xy = iMouse.xy;\n    }\n    \n    if (fragCoord.x == 0.5) {\n        fragColor = mouseA;\n    } else if (fragCoord.x == 1.5) {\n        fragColor = mouseB.z == MAGIC && iMouse.z != MAGIC ? vec4(0.0) : mouseB;\n    } else {\n        fragColor = mouseC;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This buffer draws the SDF:\n// .r stores signed distance\n// .gba stores emissivity\n\n// SDF drawing logic from \n// Smooth Mouse Drawing - fad\n// https://www.shadertoy.com/view/dldXR7\n\n// solveQuadratic(), solveCubic(), solve() and sdBezier() are from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n// with modification. Thank you! I tried a lot of different sdBezier()\n// implementations from across Shadertoy (including trying to make it\n// myself) and all of them had bugs and incorrect edge case handling\n// except this one.\n\nint solveQuadratic(float a, float b, float c, out vec2 roots) {\n    // Return the number of real roots to the equation\n    // a*x^2 + b*x + c = 0 where a != 0 and populate roots.\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return 0;\n    }\n\n    if (discriminant == 0.0) {\n        roots[0] = -b / (2.0 * a);\n        return 1;\n    }\n\n    float SQRT = sqrt(discriminant);\n    roots[0] = (-b + SQRT) / (2.0 * a);\n    roots[1] = (-b - SQRT) / (2.0 * a);\n    return 2;\n}\n\nint solveCubic(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 where a != 0 and populate roots.\n    const float TAU = 6.2831853071795862;\n    float A = b / a;\n    float B = c / a;\n    float C = d / a;\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n    float sQ = sqrt(abs(Q));\n    roots = vec3(-A / 3.0);\n\n    if (S > 0.0) {\n        roots += -2.0 * sQ * cos(acos(R / (sQ * abs(Q))) / 3.0 + vec3(TAU, 0.0, -TAU) / 3.0);\n        return 3;\n    }\n    \n    if (Q == 0.0) {\n        roots[0] += -pow(C - A * A * A / 27.0, 1.0 / 3.0);\n        return 1;\n    }\n    \n    if (S < 0.0) {\n        float u = abs(R / (sQ * Q));\n        float v = Q > 0.0 ? cosh(acosh(u) / 3.0) : sinh(asinh(u) / 3.0);\n        roots[0] += -2.0 * sign(R) * sQ * v;\n        return 1;\n    }\n    \n    roots.xy += vec2(-2.0, 1.0) * sign(R) * sQ;\n    return 2;\n}\n\nint solve(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 and populate roots.\n    if (a == 0.0) {\n        if (b == 0.0) {\n            if (c == 0.0) {\n                return 0;\n            }\n            \n            roots[0] = -d/c;\n            return 1;\n        }\n        \n        vec2 r;\n        int num = solveQuadratic(b, c, d, r);\n        roots.xy = r;\n        return num;\n    }\n    \n    return solveCubic(a, b, c, d, roots);\n}\n\nfloat sdBezier(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 A = a - 2.0 * b + c;\n    vec2 B = 2.0 * (b - a);\n    vec2 C = a - p;\n    vec3 T;\n    int num = solve(\n        2.0 * dot(A, A),\n        3.0 * dot(A, B),\n        2.0 * dot(A, C) + dot(B, B),\n        dot(B, C),\n        T\n    );\n    T = clamp(T, 0.0, 1.0);\n    float best = 1e30;\n    \n    for (int i = 0; i < num; ++i) {\n        float t = T[i];\n        float u = 1.0 - t;\n        vec2 d = u * u * a + 2.0 * t * u * b + t * t * c - p;\n        best = min(best, dot(d, d));\n    }\n    \n    return sqrt(best);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 data = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float sd = iFrame != 0 ? data.r : MAX_FLOAT;\n    vec3 emissivity = iFrame != 0 ? data.gba : vec3(0.0);\n    vec4 mouseA = iFrame > 0 ? texelFetch(iChannel0, ivec2(0, 0), 0) : vec4(0.0);\n    vec4 mouseB = iFrame > 0 ? texelFetch(iChannel0, ivec2(1, 0), 0) : vec4(0.0);\n    vec4 mouseC = iFrame > 0 ? texelFetch(iChannel0, ivec2(2, 0), 0) : iMouse;\n    mouseA.xy += 0.5;\n    mouseB.xy += 0.5;\n    mouseC.xy += 0.5;\n    float d = MAX_FLOAT;\n    \n    if (mouseB.z <= 0.0 && mouseC.z > 0.0) {\n        d = distance(fragCoord, mouseC.xy);\n    } else if (mouseA.z <= 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        d = sdSegment(fragCoord, mouseB.xy, mix(mouseB.xy, mouseC.xy, 0.5));\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        d = sdBezier(\n            fragCoord,\n            mix(mouseA.xy, mouseB.xy, 0.5),\n            mouseB.xy,\n            mix(mouseB.xy, mouseC.xy, 0.5)\n        );\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z <= 0.0) {\n        d = sdSegment(fragCoord, mix(mouseA.xy, mouseB.xy, 0.5), mouseB.xy);\n    }\n    \n    d -= brushRadius * iResolution.y;\n    \n    if (\n        d < max(0.0, sd) && !keyToggled(KEY_1) &&\n        (mouseC.z != MAGIC || cos(iTime * 20.0) > 0.5)\n    ) {\n        sd = min(d, sd);\n        emissivity = getEmissivity() * float(mouseC.z != MAGIC || cos(iTime * 10.0) > 0.5);\n    }\n    \n    fragColor = vec4(sd, emissivity);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1373, 1373, 1425, 1425, 2471]], "test": "untested"}
{"id": "ctjyRD", "name": "Square_Spiral", "author": "2w435", "description": "The Squares will not intersect based on the rotations, but the square distance offset only functions as intended with small positive numbers.", "tags": ["spiral", "square"], "likes": 4, "viewed": 139, "published": 3, "date": "1693612466", "time_retrieved": "2024-07-30T17:35:53.001919", "image_code": "#define TAU 6.28318530718\n#define SQRT2 1.41421356237\n\nconst float SQUARE_NUMBER_OVERHEAD = 4.0;\n\nfloat ManDist(vec2 uv) {\n    return abs(uv.x) + abs(uv.y);\n}\n\nfloat SquareSpiralMask(vec2 uv, float speed, float rotA, float rotB,\n                       int sqNo, float sqThick, float sqDistOffset)\n{\n    float mask = 1.0;\n    \n    // Calculated Angle between two adjecent Squares\n    float y = abs( 1.0 / float(sqNo) * (rotB - rotA) );\n    \n    // Factor by which the Side Length change due to the Rotation\n    float scaleFactor = 1.0 / ( SQRT2 * sin( (y + 0.125 * TAU)) );\n    \n    for (float j = -SQUARE_NUMBER_OVERHEAD; j < float(sqNo) + SQUARE_NUMBER_OVERHEAD; j++)\n    {\n        // Interploated value w/ Change over Time\n        float t = fract( iTime * speed);\n        float samp = (j + t) / float(sqNo);\n        \n        // Angle of the Square\n        float a = mix(rotB, rotA, samp);\n        \n        // Accommodates the Change in Side Length due to the Rotation\n        float sqDist = pow(scaleFactor, j);\n        sqDist = mix(              sqDist - sqDistOffset * j, \n                     scaleFactor * sqDist - sqDistOffset * (j + 1.0), t);\n       \n        // Rescales the side length to accommodate the Square Thickness\n        sqDist *= pow(1.0 - sqThick, j + t);\n        \n        // Creats rotated Distance Field\n        mat2 rot = mat2(vec2(cos(a), -sin(a)),vec2( sin(a), cos(a)));\n        float df = ManDist(rot * uv);\n        \n        df = abs(df - sqDist - (sqThick / 2.0));\n        \n        mask = min(mask, df);\n    }\n    \n    return smoothstep(sqThick, 0., mask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    \n    float mask1 = SquareSpiralMask(uv, 0.5, radians(45.0), -radians(90.), 17, 0.01, 0.03);\n    float mask2 = SquareSpiralMask(uv, -0.2, radians(36.),\n            -radians(18.) + radians(10.) * sin(iTime * 0.5), 3, 0.1, 0.2);\n    \n    mask1 = smoothstep(0.0, 1.0, length(uv * 3.0)) * mask1;\n    mask2 = smoothstep(0.0, 1.0, length(uv * 5.0)) * mask2;\n    \n    vec3 col = mask1 * vec3(0.2, 0.7, 0.5) + mask2 * vec3(0.6, 0.6, 0.6);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 122, 122, 158], [160, 160, 298, 298, 1585], [1587, 1587, 1644, 1644, 2186]], "test": "untested"}
{"id": "ctffDl", "name": "Blobby Lights III", "author": "Dem0g", "description": "Third Iteration of Blobby Lights. Each blob now consists of several subblobs, leading to more complicated shapes. Movement is mostly random, inspired by a Lava Lamp projector.", "tags": ["blobs", "simple", "metablobs", "colorful", "lavalamp", "ambient"], "likes": 1, "viewed": 86, "published": 3, "date": "1693577127", "time_retrieved": "2024-07-30T17:35:53.759893", "image_code": "#define LINES 10.0\n#define METABLOBS 10.0\n#define SUBBLOBS 5.0\n#define FF 1.0\n#define SMOOTHNESS 1.5\n#define EXPOSURE 0.9\n\nfloat rand(float x) {\n    return fract(sin(dot(vec2(x,x),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 cubic_hermite(vec2 p0, vec2 p1, vec2 v0, vec2 v1, float t) {\n    float sq = t*t;\n    float cu = t*t*t;\n    \n    float h1 = 2.*cu-3.*sq+1.;\n    float h2 = -2.*cu+3.*sq;\n    float h3 = cu - 2.*sq + t;\n    float h4 = cu - sq;\n    return h1*p0+h2*p1+h3*v0+h4*v1;\n}\n\n//sinc comb. Good start: sharpness of 10\nfloat comb(float phase, float density, float sharpness){\n    float signed_mod = mod(phase,density) - density/2.0;\n    float sinc = sin(signed_mod * sharpness)/(signed_mod*sharpness);\n    return pow(sinc,SMOOTHNESS);\n}\n\nvec2 random_path(float t, float seed){\n    vec2 pos0 = random2(vec2(seed,floor(t)));\n    vec2 pos1 = random2(vec2(seed,floor(t+1.)));\n    vec2 vel0 = random2(vec2(floor(t),seed));\n    vec2 vel1 = random2(vec2(floor(t+1.),seed));\n    return cubic_hermite(pos0,pos1,vel0,vel1,fract(t));\n}\n\nvec2 combed_path(float t, float seed, float comb) {\n    float offset = max(0.5,2.0*comb);\n    vec2 pos0 = random2(vec2(seed,floor(t)));\n    vec2 pos1 = random2(vec2(seed,floor(t+1.)));\n    float a0 = atan(pos0.x,pos0.y);\n    float a1 = atan(pos1.x,pos1.y);\n    float r0 = length(pos0)*offset;\n    float r1 = length(pos1)*offset;\n    pos0.x = r0 * cos(a0);\n    pos0.y = r0 * sin(a0);\n    pos1.x = r1 * cos(a1);\n    pos1.y = r1 * sin(a1);\n    vec2 vel0 = random2(vec2(floor(t),seed));\n    vec2 vel1 = random2(vec2(floor(t+1.),seed));\n    return cubic_hermite(pos0,pos1,vel0,vel1,fract(t));\n}\n\nfloat blob(vec2 uv, vec2 pos, float brightness, float spotlight, float cutoff){\n    float d = distance(uv,pos);\n    float mul = 2.0*(d*d*d)/(cutoff*cutoff*cutoff) - 3.0*(d*d)/(cutoff*cutoff) + 1.0;\n    return d < cutoff ? mul*brightness*exp(-spotlight*d) : 0.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv *= 2.;\n    float a = 1.3;//+noise(vec2(iTime*0.01,1.0))*10.;\n    float b = 4.0;//+noise(vec2(iTime*0.01,2.0))*10.;\n    float c = 10.0;\n    float field = 0.0;\n    vec3 color_field = vec3(0.0,0.0,0.0);\n\n    for(float i = 0.0; i<METABLOBS; i = i + 1.0){\n        float t = iTime * 0.03 * FF + (i)*1.0/(METABLOBS);\n        float blob_field = 0.0;\n        vec3 col = vec3(\n            rand(i)*EXPOSURE,\n            rand(i+0.1)*EXPOSURE,\n            rand(i-0.1)*EXPOSURE);\n        vec2 pos = combed_path(t, i,comb(iTime*0.05*FF+i,METABLOBS,0.3));\n        for( float j = 0.0; j<SUBBLOBS; j = j + 1.0){\n            float index = (i*METABLOBS+j);\n            col = mix( col, vec3(0.0), 0.12);\n            vec2 offset = 0.3*random_path(t, index);\n            float blob = blob( uv, pos+offset, a, b, c);\n            blob_field += blob;\n            color_field += col * blob;\n        }\n    }\n    \n\n\n    //vec3 col = vec3(field);\n    vec3 col = color_field;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctffDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 144, 144, 255], [257, 257, 279, 279, 418], [421, 506, 528, 528, 932], [934, 934, 999, 999, 1199], [1201, 1242, 1298, 1298, 1459], [1461, 1461, 1499, 1499, 1747], [1749, 1749, 1800, 1800, 2338], [2340, 2340, 2419, 2419, 2603], [2604, 2604, 2661, 2711, 3750]], "test": "untested"}
{"id": "DtsBDS", "name": "SDF - temple", "author": "mcavazotti", "description": "My first SDF scene!\nUsed AA, bounding sphere and shadow casting", "tags": ["prototype"], "likes": 4, "viewed": 170, "published": 3, "date": "1693574342", "time_retrieved": "2024-07-30T17:35:54.511882", "image_code": "float pillars(vec3 p) {\n    float s = 12.;\n    p = abs(p/s) - (vec3(2.,1.,2.5) * 0.5- 0.5);\n    p = (p.x<p.z) ? p.zyx : p.xyz;\n    p.z -= min(0.0, round(p.z));\n    return sdCappedCylinder(p*s, 5., 1.);\n}\nfloat ceiling(vec3 p) {\n    float plane1 = sdBox(p-vec3(0.,10.,0.), vec3(7.5,0.25,10.5));\n    float plane2 = sdBox(p-vec3(0.,10.5,0.), vec3(7.,.5,10.));\n    float plane3 = sdBox(p-vec3(0.,11.,0.), vec3(7.5,0.25,10.5));\n\n    float cover = sdTriPrism2(p - vec3(0.,11.,0.),vec2(7.,0.),vec2(-7.,0.),vec2(0.,5.), 10.);\n    vec3 tmpP = vec3(p.x,p.y,abs(p.z))/.8 - vec3(0.,11./0.8,13.);\n    float detail = .8*sdTriPrism2(tmpP,vec2(7.,0.),vec2(-7.,0.),vec2(0.,5.), 1.);\n    \n    \n    return min(min(plane1,min(plane2,plane3)),opSubtraction(detail,cover));\n}\n\nfloat buildingFloor(vec3 p) {\n    float floorP = sdBox(p- vec3(0.,-0.5,0.), vec3(7.5,1.,10.5));\n    \n    float stairs1 = sdBox(p- vec3(0.,-0.5-0.75 / 2.,11.), vec3(2.5,0.75,.5));\n    float stairs2 = sdBox(p- vec3(0.,-1. ,11.5), vec3(4.,0.5,1.5));\n    float stairs3 = sdBox(p- vec3(0.,-1.25,12.), vec3(6.,0.25,3.));\n    \n    return min(min(stairs1,min(stairs2,stairs3)),floorP);\n}\n\nfloat ground(vec3 p) {\n    return sdPlane(p- vec3(0.,-1.5,0.), vec3(0.,1.,0.), 0.);\n}\n\nfloat temple(vec3 p) {\n    return min(pillars(p - vec3(0.,5.,0.)),min(buildingFloor(p),ceiling(p)));\n}\n\nvec2 scene(vec3 p) {\n    float g = ground(p);\n    // Bounding Sphere\n    if(g > sdSphere(p,20.)) {\n        float t = temple(p);\n        float v = min(g, temple(p));\n        return vec2(v, v == t? -1.:1.);\n    }\n    return vec2(g,1.);\n}\n\nvec3 getNormal(vec3 p) {\n    float dx = scene(vec3(p.x + EPSILON, p.y, p.z)).x - scene(vec3(p.x - EPSILON, p.y, p.z)).x;\n    float dy = scene(vec3(p.x, p.y + EPSILON, p.z)).x - scene(vec3(p.x, p.y - EPSILON, p.z)).x;\n    float dz = scene(vec3(p.x, p.y, p.z + EPSILON)).x - scene(vec3(p.x, p.y, p.z - EPSILON)).x;\n    \n    return normalize(vec3(dx,dy,dz));\n}\n\n\nvec4 render(vec3 eye, vec3 dir, vec3 directionalLight, vec3 lightColor,vec3 ambient, vec3 groundColor, vec3 templeColor) {\n    float dist = MIN_DIST;\n    vec3 normDir = normalize(dir);\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = eye + normDir * dist;\n        vec2 renderP = scene(p);\n        float d = renderP.x;\n        vec3 albedo = renderP.y < 0.? templeColor:groundColor;\n        \n        if(d < EPSILON) {\n            vec3 normal = getNormal(p);\n            float intensity = clamp(dot(directionalLight,-normal),0.,1.);\n            if(intensity > 0.) {\n                vec3 shadowDir = normalize( normal-directionalLight);\n                float shadowDist = 2.*d + 2.*EPSILON;\n                \n                for(int is = 0; is < MAX_MARCHING_STEPS; is++) {\n                    vec3 ps = p + shadowDir * shadowDist;\n                    \n                    float ds = scene(ps).x;\n                    \n                    if(ds < EPSILON) return vec4(albedo*ambient, 1.);\n                    \n                    shadowDist +=ds;\n                    if(shadowDist > MAX_DIST)\n                        break;\n                }\n                return vec4(albedo*mix(ambient,lightColor, intensity ),1.);\n            }\n\n            return vec4(albedo*mix(ambient,lightColor, intensity ),1.);\n\n        }\n        \n        dist += d;\n        if(dist > MAX_DIST)\n            break;\n    }\n    return vec4(.3,.5,.8,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 eye = vec3(sin(iTime*0.5)*35., sin(3. +iTime*0.5)*15. + 25., cos(iTime*0.5)*60.);\n    vec3 target = vec3(0., 5., 0.);\n    vec3 directionalLight = normalize(vec3(1.,-1.5,-1.));\n    vec3 ambientLight = vec3(0.5,0.5,0.6);\n    vec3 dirLightColor = vec3(0.8,0.8,0.6);\n    vec3 groundColor = vec3(0.2,0.6,0.3);\n    vec3 templeColor = vec3(0.25,0.25,0.15);\n    \n    mat4 viewToWorld = generateViewMatrix(eye, target, vec3(0., 1., 0.));\n    \n    vec4 color = vec4(0.);\n    int AA =2;\n    for(int i = 0; i < AA; i++)\n        for(int j = 0; j < AA; j++) {\n            vec2 offset = vec2(float(i),float(j)) / float(AA) - 0.5;\n            vec3 rayDir = rayDirection(60., iResolution.xy+ offset, fragCoord);\n            vec3 worldRayDir = (viewToWorld * vec4(rayDir, 0.)).xyz;\n            color += vec4(pow(render(\n                    eye, \n                    worldRayDir, \n                    directionalLight, \n                    dirLightColor, \n                    ambientLight,\n                    groundColor,\n                    templeColor\n                \n                ).xyz,vec3(0.4545)),1.);\n        }\n    \n    fragColor = color/ float(AA*AA);\n}", "image_inputs": [], "common_code": "#define EPSILON 1e-4\n#define MIN_DIST 0.0\n#define MAX_DIST 1e5\n#define MAX_MARCHING_STEPS 1000\n\n\n\n/*\n** RAY FUNCTIONS \n*/\n\nvec3 rayDirection(float fieldOfView, vec2 resolution, vec2 coord) {\n    vec2 xy = coord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 generateViewMatrix(vec3 eye, vec3 target, vec3 up ) {\n    vec3 f = normalize(target - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n/*\n** OPERATIONS\n*/\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n/*\n** SDFs https://iquilezles.org/articles/distfunctions/\n*/\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\n\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTriPrism2( vec3 p, in vec2 p0, in vec2 p1, in vec2 p2, float h )\n{\n    float d = sdTriangle(p.xy,p0,p1,p2);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 203], [204, 204, 227, 227, 753], [755, 755, 784, 784, 1134], [1136, 1136, 1158, 1158, 1221], [1223, 1223, 1245, 1245, 1325], [1327, 1327, 1347, 1347, 1562], [1564, 1564, 1588, 1588, 1921], [1924, 1924, 2046, 2046, 3369], [3372, 3372, 3429, 3429, 4591]], "test": "untested"}
{"id": "ctXBDl", "name": "Cog Motion Illusion", "author": "SnoopethDuckDuck", "description": "the points move around circles like interlocking cogs\n\nugly golfed version (291 chars):\nhttps://www.shadertoy.com/view/DtfBDl", "tags": ["illusion", "tiling", "cog"], "likes": 19, "viewed": 218, "published": 3, "date": "1693570209", "time_retrieved": "2024-07-30T17:35:55.261878", "image_code": "#define pi 3.14159\n#define dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = 2.*(U+U-R)/R.y,\n         I, // Integer part\n         F; // Fractional part\n    \n    float n = 3., // Subdivision number\n          o = .2 + .3 * smoothstep(2., 4., iTime); // Offset from centre\n    \n    O *= 0.;\n\n    for (int i;  i++ < 2; ) \n    for (int j;  j++ < 2; ) {   \n        I = ceil(u + 1. - vec2(i, j)),  \n        F = I - u;\n        \n        //O += smoothstep(-4./R.y, 4./R.y, .02 - abs(.42- length(F))); \n        \n        // Rotate in checkerboard pattern,\n        // offset rotation by pi every 2nd row\n        float a = atan(F.y, F.x)\n                + (mod(I.x+I.y, 2.) - .5) * iTime\n                - pi * mod(I.y, 2.);\n        \n        // Subdivide angle\n        a = mod(a, 2.*pi/n);\n        \n        // Centre F in each subdivision\n        F = length(F) * dir(a) - o * dir(pi/n);\n        \n        // Draw n circles, one in each subdivision\n        O += smoothstep(-4./R.y, 4./R.y, .02 - abs(.07- length(F)));\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 143, 143, 1119]], "test": "untested"}
{"id": "mtsfD2", "name": "Blobby Lights II", "author": "Dem0g", "description": "Second Iterations of Blobby Lights. Supposed to resemble a Lava Lamp. Each blob takes turns jumping out of the main blob.", "tags": ["blobs", "simple", "metablobs", "colorful", "lavalamp"], "likes": 1, "viewed": 71, "published": 3, "date": "1693563741", "time_retrieved": "2024-07-30T17:35:56.018853", "image_code": "#define LINES 10.0\n#define BLOBS 50.0\n#define FF 10.0\n#define SMOOTHNESS 1.5\n#define STIFFNESS 0.5\nfloat rand(float x) {\n    return fract(sin(dot(vec2(x,x),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 cubic_hermite(vec2 p0, vec2 p1, vec2 v0, vec2 v1, float t) {\n    float sq = t*t;\n    float cu = t*t*t;\n    \n    float h1 = 2.*cu-3.*sq+1.;\n    float h2 = -2.*cu+3.*sq;\n    float h3 = cu - 2.*sq + t;\n    float h4 = cu - sq;\n    return h1*p0+h2*p1+h3*v0+h4*v1;\n}\n\n//sinc comb. Good start: sharpness of 10\nfloat comb(float phase, float density, float sharpness){\n    float signed_mod = mod(phase,density) - density/2.0;\n    float sinc = sin(signed_mod * sharpness)/(signed_mod*sharpness);\n    return pow(sinc,SMOOTHNESS);\n}\n\nvec2 random_path(float t, float seed){\n    vec2 pos0 = random2(vec2(seed,floor(t)));\n    vec2 pos1 = random2(vec2(seed,floor(t+1.)));\n    vec2 vel0 = random2(vec2(floor(t),seed));\n    vec2 vel1 = random2(vec2(floor(t+1.),seed));\n    return cubic_hermite(pos0,pos1,vel0,vel1,fract(t));\n}\n\nvec2 combed_path(float t, float seed, float comb) {\n    float offset = 2.0*comb - 1.8;\n    vec2 pos0 = random2(vec2(seed,floor(t)));\n    vec2 pos1 = random2(vec2(seed,floor(t+1.)));\n    pos0.y = pos0.y + offset;\n    pos1.y = pos1.y + offset;\n    //pos0.x = pos0.x*(1.0-comb);\n    //pos1.x = pos1.x*(1.0-comb);\n    vec2 vel0 = random2(vec2(floor(t),seed));\n    vec2 vel1 = random2(vec2(floor(t+1.),seed));\n    return cubic_hermite(pos0,pos1,vel0,vel1,fract(t));\n}\n\nfloat blob(vec2 uv, vec2 pos, float brightness, float spotlight, float cutoff){\n    float d = distance(uv,pos);\n    float mul = 2.0*(d*d*d)/(cutoff*cutoff*cutoff) - 3.0*(d*d)/(cutoff*cutoff) + 1.0;\n    return d < cutoff ? mul*brightness*exp(-spotlight*d) : 0.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv *= 2.;\n    float a = 2.2;//+noise(vec2(iTime*0.01,1.0))*10.;\n    float b = 4.0;//+noise(vec2(iTime*0.01,2.0))*10.;\n    float c = 100.0;\n    float field = 0.0;\n    vec3 color_field = vec3(0.0,0.0,0.0);\n    for(float i = 0.0; i<BLOBS; i = i + 1.0){\n        //field += blob(uv, random_path(iTime, i), a, b,c);\n        float t = iTime * 0.03 * FF + i*1.0/BLOBS;\n        vec2 pos = combed_path(t, i,comb(iTime*0.05*FF+i,BLOBS,2.0));\n        float blob = blob( uv, pos, a, b,c);\n        vec3 color = vec3(rand(i),rand(i+0.1),rand(i-0.1));\n        float noise = rand(blob);\n        //color = mix(vec3(0.0,0.0,0.0),color,noise+0.8);\n        color_field += color\n                    * blob;\n    }\n    //vec3 col = vec3(field);\n    vec3 col = color_field;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 120, 120, 231], [233, 233, 255, 255, 394], [397, 482, 504, 504, 908], [910, 910, 975, 975, 1175], [1177, 1218, 1274, 1274, 1435], [1437, 1437, 1475, 1475, 1723], [1725, 1725, 1776, 1776, 2187], [2189, 2189, 2268, 2268, 2452], [2453, 2453, 2510, 2560, 3400]], "test": "untested"}
{"id": "mtsfWf", "name": "Adaptive Threshold + Camera", "author": "soofgo", "description": "Adaptive Threshold with webcam", "tags": ["adaptivethreshold"], "likes": 1, "viewed": 289, "published": 3, "date": "1693560502", "time_retrieved": "2024-07-30T17:35:56.778821", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// 16x acceleration of https://www.shadertoy.com/view/4tSyzy\n// by applying gaussian at intermediate MIPmap level.\n\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\nvec4 threshold(in vec4 tx){\n    const float Soft = 0.001;\n    const float Threshold = 0.02;\n    float f = Soft / 5.0;\n\tfloat a = Threshold - f;\n\tfloat b = Threshold + f;\n    float l = (tx.x + tx.y + tx.z) / 3.0;\n\t\n\tfloat v = smoothstep(a, b, l);\n\t\n\treturn vec4(v);\n\n}\n\nvoid mainImage(out vec4 Result, vec2 U) {\n    vec4 blurred = blur( iChannel0, U/iResolution.xy, 1./iChannelResolution[0].xy);\n    vec4 subbed = texture(iChannel0, U/iResolution.xy) - blurred;\n    Result = threshold(subbed);\n    \n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsfWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 117]], "test": "untested"}
{"id": "ctsfDj", "name": "Shader Sorter", "author": "oneshade", "description": ".", "tags": ["sorting", "bubblesort"], "likes": 10, "viewed": 222, "published": 3, "date": "1693534660", "time_retrieved": "2024-07-30T17:35:57.530811", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 dist = abs(uv.y - texture(iChannel0, vec2(uv.x, 0)));\n    fragColor = smoothstep(2.0 / iResolution.y, 0.0, dist);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        float x1 = fragCoord.x / iResolution.x * 3.1415;\n        float x2 = x1 - 1.0;\n        fragColor = vec4(sin(x1), cos(x1), 0.5 * exp(-10.0 * x2 * x2), 0);\n    } else {\n        ivec2 thisCoord = ivec2(fragCoord);\n        fragColor = texelFetch(iChannel0, thisCoord, 0);\n        if ((thisCoord.x & 1) == (iFrame & 1)) {\n            int nextIndex = thisCoord.x + 1;\n            if (nextIndex < int(iResolution.x)) {\n                vec4 nextBin = texelFetch(iChannel0, ivec2(nextIndex, 0), 0);\n                fragColor = min(fragColor, nextBin);\n            }\n        } else {\n            int prevIndex = thisCoord.x - 1;\n            if (prevIndex >= 0) {\n                vec4 prevBin = texelFetch(iChannel0, ivec2(prevIndex, 0), 0);\n                fragColor = max(prevBin, fragColor);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 222]], "test": "untested"}
{"id": "clsBDX", "name": "Zellij pattern 18 (music)", "author": "jarble", "description": "A zellij tile pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "zellige"], "likes": 4, "viewed": 202, "published": 3, "date": "1693529082", "time_retrieved": "2024-07-30T17:35:58.290779", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract(.5+(a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvec3 fractal(vec2 uv,vec2 t2){\n    vec3 col = vec3(0.);\n    bool b = true;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5+uv+t2)/1.5\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        b =\n            uv.y>uv.x\n            //uv.y>uv.x||!b\n        ;\n        if(\n            b\n        ) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv-.5).yx\n        ;\n        uv =\n            (t2.yx-triangle_wave(uv.yx+1.)).yx\n        ;\n        //if(uv.y<uv.x||b)\n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n            //vec3(col.zx,max((uv.x+uv.y+1.),0.))\n            //abs(vec3(col.zx,max(uv.y-uv.x,col.y)))\n            //vec3(col.zx,max(col.y,max(uv.y-uv.x,0.)))\n            //vec3(col.zx,max(col.y,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.)))\n        ;\n        \n        }\n        return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1/2.0;\n    vec2 t2 = vec2(0.);\n    vec3 col = fractal(uv,t2);\n    for(int i = 0; i < 1; i++){\n        col = abs(fractal(uv,t2));\n    }\n    \n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod(float a, float b){\n    //a /= 1. + mod(1.+b/2.,2.);\n    return\n        mod(mod(floor(a),b)*mod(floor((a)/b),b),b)\n        //mod(mod(floor(a),b+mod(floor(a/8.),b)),b)\n        //floor(mod(mod(floor(a)/b,b)*mod(floor((a)/b),b),b))\n        //floor(mod(mod(floor(a),b*2.)*mod(floor((a/2.)/b),b),b))\n        //mod(mod(floor(a),b)*mod(floor((a)/b),b),b*b)\n        //mod(mod(floor(a),b)*mod(floor((a)/8.),b),b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    //divide by prime numbers to get an interesting rhythm\n    return (1.+fmod(time/2.,2.))*(1.+fmod(time/3.,2.))*(1.+fmod(time/5.,2.))*(1.+fmod(time/7.,2.));\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time)\n  ,\n  t = s1*time/tempo1,\n  t4 =\n      //t/tempo1\n      t*tempo1\n  ,\n  t1 = fmod(t4+1.,2.),\n  t5 = t,\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time/t3,\n  m3 =\n      floor(fmod(t6,s1/2.)/2.),\n      //floor(fmod(t6,s1/2.+floor(tempo1/2.))/2.),\n  m2 =\n      1. + fmod(t/t3/2.,s1/2.)\n      //1. + fmod(t/t3/2.,s1/2.)\n  ;\n  vec2 a= vec2(\n      //(1.-log(fract(t/tempo1)/2.))*(1.-log(fract(t/prime_rhythm(time+7.))/4.))\n      pow(1.-log(fract(t/tempo1)/2.),2.),pow(2.,1.-log(fract(t/prime_rhythm(time+7.))/4.))\n  ),\n  nb = vec2(\n      t*pow(2.,(m3+m2-t1*4.)/7.+7.5)*tempo1/8.\n  );\n  return\n      abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a\n      //log(a/8.-abs(a/16.-abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a))\n      //log(a/8.-abs(a/4.-abs(.5-vec2(fract(nb.x*.998),fract(nb.y/2.)))*a))\n      //abs(a/16.-abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a)\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a))\n      \n      //log(a/16.-abs(a/4.-abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a))\n      \n      \n      //abs(.5-vec2(fract(t*nb*.998/prime_rhythm(time+14.)),fract(t*nb/prime_rhythm(time+7.)/2.)))*a\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 145], [147, 147, 177, 177, 1007], [1009, 1009, 1064, 1064, 1478]], "test": "untested"}
{"id": "dlXfD2", "name": "Sine Wave 2: Electric Boogaloo", "author": "Supercooldude", "description": "idk", "tags": ["thing"], "likes": 1, "viewed": 139, "published": 3, "date": "1693527129", "time_retrieved": "2024-07-30T17:35:59.036784", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    \n    float dist = (1.0 - abs(uv.y - 0.5 - 0.5 * sin(uv.x * 3.141  * 8.0 + iTime * 10.0) * (1.0 - abs(uv.x - 0.5) * 2.0))) * (1.0 - abs(uv.x - 0.5) * 2.0);\n    \n    fragColor = vec4(1.0*cos(iTime+uv.xxx+vec3(0,2,4))*dist,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 373]], "test": "untested"}
{"id": "mtXfDf", "name": "Screen-Space Shadows", "author": "Koranir", "description": "Click and drag mouse to move light source.", "tags": ["shadow", "shadows", "screenspace"], "likes": 32, "viewed": 736, "published": 3, "date": "1693522953", "time_retrieved": "2024-07-30T17:35:59.786779", "image_code": "#define SAMPLES 16\n#define EPSILON 0.01\n#define DEPTH_REVERSED true\n#define SHADOW_INTENSITY 5.\n#define LIGHT_Z_OFFSET 0.1\n#define SOFT_SHADOWS .25\n#define DEPTH_SCALE .5\n\nfloat depth(vec2 coords)\n{\n    if(DEPTH_REVERSED) {\n        return 1. - texture(iChannel0, coords).x * DEPTH_SCALE;\n    } else {\n        return texture(iChannel0, coords).x * DEPTH_SCALE;\n    }\n}\n\n\nfloat diffuse(vec3 n, vec3 l)\n{\n\treturn max(0.0, dot(n,l));\n}\n\nvec3 normal(vec2 coords, float intensity)\n{\n    float offset = 0.0025;\n    vec3 a = vec3(coords.x - offset, 0.0, depth(vec2(coords.x - offset, coords.y)) * intensity);\n    vec3 b = vec3(coords.x + offset, 0.0, depth(vec2(coords.x + offset, coords.y)) * intensity);\n    vec3 c = vec3(0.0, coords.y + offset, depth(vec2(coords.x, coords.y + offset)) * intensity);\n    vec3 d = vec3(0.0, coords.y - offset, depth(vec2(coords.x, coords.y - offset)) * intensity);\n\n    return normalize(cross(b-a, c-d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouseuv = iMouse.xy / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    mouseuv.x *= aspect;\n    \n    vec3 norm = normal(uv, 0.2);\n    \n    vec3 colour;\n    \n    vec3 fragPos = vec3(uv, depth(uv));\n    vec3 lightPos = vec3(mouseuv, depth(mouseuv) - LIGHT_Z_OFFSET);\n    vec2 dir = normalize(fragPos.xy - lightPos.xy);\n    \n    float traverse_by = 1. / float(SAMPLES);\n    for(float i = 0.; i < 1.; i += traverse_by) {\n        vec3 traversedPos = fragPos + (lightPos - fragPos) * i;\n        float traversedDepth = depth(traversedPos.xy);\n        \n        float diff = traversedPos.z - traversedDepth;\n        if(diff > EPSILON) {\n            colour += vec3(diff) * traverse_by / SOFT_SHADOWS;\n        }\n    }\n    \n    colour *= SHADOW_INTENSITY;\n    fragColor.rgb = vec3(diffuse(normalize(fragPos - lightPos), norm));\n    float ambient = diffuse(norm, vec3(0.0,0.0,1.0))*0.05;\n    fragColor += ambient;\n    fragColor.rgb *= 1. - colour;\n    fragColor.a = 1.;\n}\n\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 198, 198, 367], [370, 370, 401, 401, 431], [433, 433, 476, 476, 933], [936, 936, 993, 993, 2049]], "test": "untested"}
