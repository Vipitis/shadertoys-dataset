{"id": "flGyRt", "name": "Tunnel through hell", "author": "Tache", "description": "some tunnel thing", "tags": ["fake3d"], "likes": 3, "viewed": 244, "published": 3, "date": "1661962166", "time_retrieved": "2024-07-30T16:33:35.264992", "image_code": "void mainImage(out vec4 o, in vec2 u){\n    o = vec4(0.,0.,0.,1.);\n    vec3 c, d = vec3(1.,0.,0.), r = iResolution;\n    vec2 q, v = (u.xy-0.5*r.xy)/r.y;\n    float e, a, p, n, i, T=iTime*8.;\n    for(i=floor(T)+16.;--i>floor(T) ;){\n        p = i-T;\n        q = (v+vec2(cos(T/20.)*p,sin(T/20.)*p)/70.)*p;\n        n = length(q);\n        for(int j=0;j++<3;){\n            q = log(abs(mat2(cos(i),sin(i),-sin(i),cos(i))*q));\n            q += tan(q.yx)/99.;}\n        a = (2.*(pow(0.5+0.5*sin(q),vec2(3.,3.))*smoothstep(0.5,0.9,n))).x*(0.4-(p/40.));\n        c = vec3(0.5+0.5*cos(i),0.4+0.4*sin(i),0.2+0.2*sin(i));\n        e = mix(e,1.,a);\n        d = mix(d,c,a);}\n    o += vec4(e*d,1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 677]], "test": "untested"}
{"id": "ftKyRc", "name": "Day 986", "author": "jeyko", "description": "uuh", "tags": ["fractal", "projection", "4d", "apollonian", "mdtmjvm"], "likes": 5, "viewed": 282, "published": 3, "date": "1661958184", "time_retrieved": "2024-07-30T16:33:36.202485", "image_code": "// Fork of \"Day 485[4d projected apollonian]\" by jeyko. https://shadertoy.com/view/fdXSD4\n// 2022-08-31 08:06:24\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    muv *= 6.28;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord.xy/iResolution.xy).xyz;\n    // reinhardt and sutff\n    //col = 1./(1. + 1./col);\n\t\n\tvec2 res = vec2(iResolution.xy);\n\tvec2 U = gl_FragCoord.xy;\n\n\tcol *= 1. - dot(uv,uv)*0.4;\n    col*=1.5;\n    \n    col = 1. - exp(-col*2.);\n    \n    col = mix(col,smoothstep(0.,1.,col),0.5);\n    \n    col = mix(col,smoothstep(0.,1.,col),0.4);\n    \n\n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n/*\nvec4 getNormala(vec4 p){\n    vec2 t = vec2(0.0004,0.00);\n    return normalize(vec4(\n        map(p+t.xyyy).x - map(p-t.xyyy).x,\n        map(p+t.yxyy).x - map(p-t.yxyy).x,\n        map(p+t.yyxy).x - map(p-t.yyxy).x,\n        map(p+t.yyyx).x - map(p-t.yyyx).x));\n}\n*/\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat sdBox(vec4 p, vec4 s){p = abs(p) - s; return max(p.x,max(p.y,max(p.z,p.w)));}\n\n\nfloat sdBoxEdges(vec4 p, vec4 s, float edgeW){\n    float d = sdBox(p, s);\n    \n    float cuttingEdgeW = edgeW*1.;\n    //d = abs(d);\n    d = max(d, -sdBox(p, s - vec4(-cuttingEdgeW,edgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,-cuttingEdgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,-cuttingEdgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,edgeW,-cuttingEdgeW)));\n    \n    \n    return d;\n}\n\n\n#define max4v(v) max(max(v.x, v.y), max(v.z, v.w))\n#define min4(x,y,z,w) min(min(x, y), min(z, w))\n\n\n#define dmin(d,b) d.x < b ? d : vec2(b,d.y + 1.)\nfloat sdTesseractFrame( vec4 p, vec4 b, float e ) { \n  p = abs(p)-b; \n  vec4 q = abs(p+e)-e; \n  mat4 t = mat4(\n        p.x, q.y, q.z, q.w,\n        q.x, p.y, q.z, q.w,\n        q.x, q.y, p.z, q.w,\n        q.x, q.y, q.z, p.w\n  );\n  return min4(\n        length(max(t[0], 0.0)+min(max4v(t[0]),0.0)),\n        length(max(t[1], 0.0)+min(max4v(t[1]),0.0)),\n        length(max(t[2], 0.0)+min(max4v(t[2]),0.0)),\n        length(max(t[3], 0.0)+min(max4v(t[3]),0.0))\n  );\n}\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n", "buffer_a_code": "\n// 2d creatures see a line\n// 3d creatures see a 2d array, projected by cam z\n// 4d creatrues see a 3d grid, projected by cam w\n\n\n// what i've done here is construct a 3d grid of 2d slices.\n// each slice is a full raymarch into 4d space, projected by the w\n// this just means that instead of doing\n// rd = normalize(vec3(uv,1));\n// we do\n// rd = normalize(vec3(uv,sliceIdx/sliceCnt,1));\n// that's really about all there is to it. in the end we project the 3d grid perspectively to our 2d shadertoy screen.\n\n\n#define iTime (iTime - g_dith/60.)\n\n// Performance vars\n\nfloat sliceCnt = 140.;\nfloat marchSteps = 50.;\nfloat dMult = 1.;\nfloat g_dith;\n\n// Coeff vars\n\nfloat rotSpd = 0.5;\nfloat fov4D = 0.7;     // scale up the sliceZDepth when widening the fov\nfloat sliceZDepth = 4.; \nfloat minT = 10e5;\n\nfloat normalEps = 0.001;\nfloat distEps = 0.001;\nfloat distOffs = -0.0;\n\nfloat ditherAmt = 1.;\n\n#define DEBUG 0\n#define TUBES 1\n\n\nfloat ld(vec3 p){\n\n    #if TUBES\n        return length(p);\n    #else\n        return max(abs(p.x),max(abs(p.y),abs(p.z)));\n    #endif\n}\nfloat ld(vec2 p){\n    #if TUBES\n        return length(p);\n    #else\n        return max(abs(p.x),abs(p.y));\n    #endif\n}\nfloat ld(float p){\n    return p;\n}\nvec2 sdApollonian(vec4 p){\n    vec2 d = vec2(10e5,0.);\n    float sc = 1.;\n    \n    for(float i = 0.; i < 4.; i++){\n        //p = abs(p);\n        p = pmod(p,vec4(1.5 + 0.5*iMouse.y/iResolution.y));\n        \n        float dpp = dot(p,p );\n        p /= dpp; sc /=dpp;\n        \n     \n    }\n    p /= sc;\n\n    d = dmin(d,ld(p.zxw) - 0.001 );\n    //d = dmin(d,length(p.y) - 0.00 );\n    \n    d = dmin(d,ld(length(p)) - 0.001 );\n    \n    return d;\n}\n\nfloat sdGrid(vec4 p){\n    //float dpp = dot(p,p);\n    //p/=dpp;\n    \n    p = pmod(p,1.5);\n    float d = min(\n        length(p.xyz),\n        min(\n            length(p.xyw),\n            min(\n                length(p.xzw),\n                length(p.ywz)\n            )\n        )\n    );\n    //d *= dpp;\n    //d = abs(d);\n    \n    d = d-.014;\n    \n    return d;\n}\n\nvec2 map(vec4 p){\n    \n    \n    p += sin(iTime*vec4(1,2,1.5,0.56)*0.5)*0.2;\n    \n    //p.wz *= rot(1.4);\n    //p.yw *= rot( -iTime*0.4);\n    \n    p.xw *= rot( iTime*0.5*rotSpd);\n    p.wz *= rot( iTime*0.7*rotSpd );\n    \n    p.yw *= rot( iTime*0.5*rotSpd);\n    p.xz *= rot( iTime*0.7 *rotSpd);\n    \n    //p += 0.2 ;\n    \n    //p -= 0.5 ;\n    \n    //p.yw *= rot( -iTime*0.15);\n\n    vec2 d = sdGrid(p)*vec2(1);\n     \n    return d;\n}\n\nvec4 getNormal(vec4 p){\n    vec2 t = vec2(normalEps,0.00);\n    return normalize(map(p).x-vec4(\n        map(p-t.xyyy).x,\n        map(p-t.yxyy).x,\n        map(p-t.yyxy).x,\n        map(p-t.yyyx).x));\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(172.412,735.124)+uv.yx*vec2(97.354,421.653)+vec2(94.321,37.365)),vec2(4.6872,7.9841))+0.71243);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    muv *= 6.28;\n\n    vec3 col = vec3(0);\n\n\n    #if DEBUG\n    \n        vec3 gro = vec3(sin(muv.x),0,cos(muv.x))*sliceZDepth*1.5;\n        vec3 grd = normalize(vec3(uv,1));\n\n        gro.yz *= rot(-muv.y);\n        grd.yz *= rot(-muv.y);\n        grd.xz *= rot(-muv.x);\n\n    #endif\n    \n    \n    bool hitAtLeastOnce = false;\n    float dither = texture(iChannel1, fragCoord / 1024.0f).r*ditherAmt*2. - 1.*ditherAmt;\n    g_dith = texelFetch(iChannel2, ivec2(fragCoord)%8,0).x;\n    for(float slice = 0.; slice < sliceCnt; slice++){\n          \n        #if DEBUG\n            vec3 sliceUv = gro + grd * plaIntersect( gro + vec3(0,0,1)*slice/sliceCnt*1.*sliceZDepth , grd, vec4(0,0,-1,0) );\n        #else\n            vec2 sliceUv = uv*(1. + (slice + dither)/sliceCnt);\n        #endif\n        \n        \n        vec4 rd = normalize(vec4(sliceUv.xy,sliceZDepth*((slice + dither)/sliceCnt - 0.5),fov4D));\n        \n        vec4 p = vec4(0); \n        p += rd*dither*0.2;\n       \n        p -= 0.4 ;\n        bool hit = false;\n        vec2 d;\n        float glow = 0.;\n        float t = 0.;\n        \n        for(float st = 0.; st < marchSteps; st++){\n            d = map(p);\n            d.x += distOffs;\n            if(d.x < distEps){\n                hit = true;\n                break;\n            } else if (t > 3.5){\n                //t = 10.;\n                break;\n            }\n            \n            d.x *= dMult;\n            t += d.x;\n            p += rd*d.x;\n        }\n        \n\n          \n        const vec3 fogCol = vec3(0.6,0.6,0.56)*1.;\n        if(hit && t < minT){\n            minT = t;\n            hitAtLeastOnce = true;\n            vec4 n = getNormal(p); \n            \n#define AO(a,m) mix(smoothstep(0.,1.,map(p+normalize(n+vec4(0.,0,0,1))*a).x/a),1.,m)\n            col = (pal(0.5,0.*vec3(1.+ sin( p.w*1.),1.,1.),vec3(0.4,1.,1.5),1.,11.*dot(n,rd)));\n            //col = pow(abs(col),vec3(1.8));\n            \n            col *= AO(1.,0.5)*AO(.4,0.7)*AO(.5,0.8)*AO(.2,0.8)*AO(.08,0.8)*AO(.1,0.8);\n            \n            \n            \n            col = mix(col,fogCol,smoothstep(0.,0.5,(t)*.2- 0.4));\n            }\n        else{\n            if(!hitAtLeastOnce)\n                col = fogCol;\n        }\n        \n    }\n    \n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 172, 172, 780]], "test": "untested"}
{"id": "7lVyz3", "name": "Abstract crystals", "author": "icylavah", "description": "Screen-space pixels checking their distance to the closest point in 3d space.", "tags": ["3d", "abstract", "distance", "perspective"], "likes": 3, "viewed": 180, "published": 3, "date": "1661949928", "time_retrieved": "2024-07-30T16:33:37.186363", "image_code": "// https://gist.github.com/icy-lava/d227da91a1256ab43d0d42093b1271d8\n// point_generator.moon - 100 points\nstruct Point { vec3 pos; vec3 color; };\nPoint points[] = Point[](\n        Point(vec3(-0.56350449741428, -0.47094099812521, 0.23110218386531), vec3(0.78951807025629, 0.52874486142465, 0.3345057682311)),\n        Point(vec3(0.56560977377901, -0.49977267732381, -0.25983021010801), vec3(0.13105054479537, 0.24369378429049, 0.56898755239844)),\n        Point(vec3(-0.062101908140461, 0.086238602291222, -0.62585386835153), vec3(0.52711876360264, 0.40886723657706, 0.1883286366086)),\n        Point(vec3(-0.60018256881268, 0.51596671331407, 0.4098355541758), vec3(0.73952808004072, 0.80096710386691, 0.38031074266251)),\n        Point(vec3(-0.15719610893209, 0.58105231251957, 0.034671846720975), vec3(0.70495394634956, 0.45968501366961, 0.62034162606704)),\n        Point(vec3(0.14854058685591, 0.74371335080931, 0.59965916101419), vec3(0.054002388746694, 0.26644158698752, 0.18016947120704)),\n        Point(vec3(0.029126752766087, -0.57673322895354, -0.53705989561797), vec3(0.39016060910681, -0.095394095410171, 0.15509951530198)),\n        Point(vec3(-0.41386187969739, 0.51052813472895, 0.59591369271636), vec3(0.25482482891291, 0.1391609592075, 0.32817485640601)),\n        Point(vec3(0.66314556412772, 0.0075299932506101, -0.69741758516432), vec3(0.3817747513845, 0.21005634059613, 0.22489143335343)),\n        Point(vec3(0.48911556505964, -0.78807410008602, 0.30810441611929), vec3(0.29681293730234, 0.16402289180575, 0.24330070581846)),\n        Point(vec3(0.57964539363688, 0.63272741359425, -0.20878995523343), vec3(0.02469082143322, 0.23146816380885, 0.1016171557583)),\n        Point(vec3(-0.013900265932766, 0.18795706755113, 0.32952874838521), vec3(-0.047934764933635, 0.22488825879577, -0.24125517537568)),\n        Point(vec3(-0.010803262402436, -0.55625844483999, 0.17992465119292), vec3(0.94914249278237, 0.71747545592635, 1.1243645061067)),\n        Point(vec3(0.27610050970984, 0.47141102412507, -0.032138185402532), vec3(0.36590324504341, 0.69013636019869, 0.81819544001739)),\n        Point(vec3(-0.2998521459182, 0.048155703149464, 0.27071858838149), vec3(0.37739350672261, -0.049570562040314, -0.22497327743498)),\n        Point(vec3(0.37906090142118, -0.58224390338919, 0.70838502999468), vec3(-1.0305732800176, 0.51193814375745, 0.37860833913036)),\n        Point(vec3(0.25022860971083, 0.46685954294579, 0.10107586886663), vec3(0.1650967224815, 0.14267638649143, -0.38793538544577)),\n        Point(vec3(0.27268702214389, -0.72172127554871, 0.17389119521674), vec3(0.32368679873677, 0.29958308415606, 0.071035901294474)),\n        Point(vec3(0.082036059974003, -0.59739946894976, 0.52875993205144), vec3(-0.2884266976858, 0.34162278650264, 0.51510328808097)),\n        Point(vec3(-0.65831793341689, 0.33912615459138, -0.50276384149328), vec3(-0.081642279068456, 0.33824633390468, 0.11481592743715)),\n        Point(vec3(0.32880426706661, 0.42749491413928, 0.14256746412069), vec3(0.075491797236695, 0.68458610480511, 0.71726469420239)),\n        Point(vec3(0.19283195836707, 0.2100429376647, 0.84555697120285), vec3(-1.5477040229303, 0.5327719509351, 0.79079958540605)),\n        Point(vec3(-0.93864597101336, -0.23706878245073, 0.22790368263132), vec3(0.74831368886185, 0.3638340248244, 0.58853076322977)),\n        Point(vec3(-0.48831664155532, 0.58683435833331, -0.20488755102208), vec3(1.0712953024484, 0.66219316404105, 0.724094441042)),\n        Point(vec3(0.35083697205189, 0.45347834432959, 0.69519957729317), vec3(-0.0074912949312643, 0.20310455471875, 0.11711292941524)),\n        Point(vec3(-0.05072764688636, -0.85814817595609, -0.45887155015586), vec3(0.32954855366744, 0.27885257739702, 0.50837552185481)),\n        Point(vec3(0.11510990367839, -0.73337162871782, -0.21737589098291), vec3(-0.55429238091256, 0.91565378682682, 0.64049008059968)),\n        Point(vec3(0.34285730044588, -0.062498740298174, -0.64582712441627), vec3(0.5769426206685, 0.84199370206258, 0.56514178199765)),\n        Point(vec3(-0.78205404505837, -0.35739553672494, 0.49585742567592), vec3(0.48208737158392, 0.59341903677527, 0.76649358446829)),\n        Point(vec3(0.55492065782103, 0.14636673487039, 0.76769786154664), vec3(-0.12037308552199, 0.17950683604641, 0.16642621944054)),\n        Point(vec3(-0.55647787599446, 0.39880129452345, 0.53175443323323), vec3(0.67129611389003, 0.68988732337507, 0.88464345429425)),\n        Point(vec3(0.33230657902006, 0.82649848205525, -0.21362180883999), vec3(0.4902700127776, 0.59498347924453, 0.477173579825)),\n        Point(vec3(0.70504789483934, -0.37495781303046, 0.048817336980411), vec3(0.87001625974906, 0.55363934888351, 0.56614823310291)),\n        Point(vec3(-0.1029093658871, -0.10781224054888, 0.50086854091191), vec3(0.38108378289916, -0.015145902725493, 0.36197647047146)),\n        Point(vec3(-0.68184495231668, 0.4405367966101, -0.44426436300126), vec3(0.63658488995014, 0.31174494427758, 0.43798999717317)),\n        Point(vec3(-0.29086874226438, -0.280615570877, -0.4384592275257), vec3(0.17097891314477, 0.31212455702216, 0.055050108595554)),\n        Point(vec3(-0.24629753888963, 0.26337177600556, 0.22769005210134), vec3(0.39840261300821, 0.40505078346746, -0.10438139496792)),\n        Point(vec3(0.79872758099016, -0.53189691366391, 0.070258449798114), vec3(0.31090863429809, 0.75132013616448, 0.91990329909757)),\n        Point(vec3(0.37373357840086, -0.59205487331253, -0.17790531161919), vec3(0.37534596433227, 0.49389419753704, 0.74067088884418)),\n        Point(vec3(-0.77777320140852, 0.20212566835454, -0.19890114448794), vec3(0.74258771402205, 0.76206304895319, 0.55519804672537)),\n        Point(vec3(-0.39955729357465, 0.05010948514257, -0.11083318295704), vec3(-1.1593981919248, 0.59039488452126, 0.40129978541933)),\n        Point(vec3(-0.90558302696935, -0.27985682798402, 0.13480574634408), vec3(0.2566267352765, 0.35653212124245, 0.63925339241042)),\n        Point(vec3(-0.65929601191446, 0.34810083109616, -0.074360561194972), vec3(0.35395949912804, 0.19935578037441, 0.18503101403084)),\n        Point(vec3(0.20100256145331, -0.010914226945715, 0.71864712809086), vec3(0.63941940393948, 0.76150945314267, 1.1646308192556)),\n        Point(vec3(0.27539418270716, -0.77669811759915, 0.090461988759145), vec3(-0.60451335806098, 0.45079887128485, 0.70498361669943)),\n        Point(vec3(0.1636987274619, 0.62311432965205, 0.0026178398043921), vec3(-3.215915013796, 0.61011457357103, 0.81825035848035)),\n        Point(vec3(-0.68478285792643, -0.27424328285401, -0.13986798128387), vec3(-0.14460497455492, 0.32852141367727, 0.31506055547241)),\n        Point(vec3(0.22879938586522, 0.25874673402278, 0.062176094829307), vec3(0.31542654418823, 0.33428857030516, 0.19996206903691)),\n        Point(vec3(0.55806876882053, -0.051137247831866, 0.17694378611614), vec3(-0.071738695288467, 0.29431530802514, 0.46392155057171)),\n        Point(vec3(0.49457915894443, 0.35951448013153, -0.083222656397495), vec3(-0.23015969546125, 0.12749178256953, 0.38403754189072)),\n        Point(vec3(0.13762881384502, 0.84858103053932, -0.1745287561024), vec3(0.34976019380646, 0.70321334994259, 0.93839986083806)),\n        Point(vec3(0.53893353604967, -0.68762078176561, 0.43489201483596), vec3(0.85276748991143, 0.51818929456308, 0.64387090292672)),\n        Point(vec3(-0.59572579455079, -0.099617876340869, 0.69537458775173), vec3(0.26905357493514, -0.10275689623515, 0.38402034341339)),\n        Point(vec3(-0.27762083149077, 0.0069917255551575, 0.13268686774067), vec3(0.74899731956851, 0.74470000416951, 0.26807692633356)),\n        Point(vec3(-0.018483129045372, -0.090465759969036, 0.9597763201709), vec3(0.19307141057031, 0.18896675588941, 0.4634618393036)),\n        Point(vec3(-0.91635447737296, 0.04545698666659, 0.26630661680286), vec3(0.36050413490863, 0.015893618169417, 0.15992899844277)),\n        Point(vec3(0.52763157571094, 0.63164702637059, -0.16217661764298), vec3(0.59350555452792, 0.11477528401774, 0.56733715054939)),\n        Point(vec3(-0.68707006255641, -0.25466949059216, 0.34947542063697), vec3(-0.21663230069288, 0.28814848222702, 0.32489590917772)),\n        Point(vec3(-0.18828797919464, -0.66269178238178, 0.59700319571279), vec3(0.94590342615591, 0.59822143229815, 0.3708649938505)),\n        Point(vec3(0.68336058898159, -0.4366542972357, 0.1766004936977), vec3(0.17829482752497, 0.049852045654475, 0.26494233799621)),\n        Point(vec3(-0.36957080512193, -0.039957680420482, 0.9277275470803), vec3(0.32517155511695, -0.055644200610892, 0.44787247943984)),\n        Point(vec3(-0.54032860991892, -0.44130731501059, -0.31949505577679), vec3(0.73860021106794, 0.090604756384555, 0.29563633062664)),\n        Point(vec3(-0.042104503754474, 0.097077282578772, -0.14417415775279), vec3(0.84444229322477, 0.6232217843739, 1.1021640115232)),\n        Point(vec3(0.66019087582928, -0.059597683244236, 0.67441496816924), vec3(0.51329075984833, 0.47200961539457, 0.10893617303932)),\n        Point(vec3(-0.79673969250608, 0.17889639929811, -0.52167689305842), vec3(0.33639268981234, 0.18046494653741, -0.21997357708025)),\n        Point(vec3(0.87693683639702, -0.23559772888102, -0.21236156773653), vec3(0.54334195316039, 0.096329005069747, 0.54740598477334)),\n        Point(vec3(0.46798454940963, 0.53044754124634, 0.45934072939309), vec3(-0.1202783431291, 0.16250698452411, 0.22968355959774)),\n        Point(vec3(0.42187858081211, 0.41229943007125, -0.12872772361977), vec3(-1.4218865577237, 0.5084049962649, 0.52789134056906)),\n        Point(vec3(0.59418672902315, -0.54620924672872, -0.01011000313802), vec3(0.060720167719088, 0.17473378522833, -0.071851975806708)),\n        Point(vec3(-0.27753370661254, -0.82221459888782, 0.11890307593737), vec3(0.89847987394748, 0.572992660791, 0.5727778964196)),\n        Point(vec3(-0.91849165109434, 0.017489398266555, 0.11028119655097), vec3(-0.74622385360933, 0.97458339615597, 0.75090254691868)),\n        Point(vec3(-0.17709403891634, 0.61141565810431, 0.17176362593748), vec3(-0.20813347253477, 0.17107268037307, -0.043900837585692)),\n        Point(vec3(0.11588016289867, 0.12912412403947, 0.65628280776171), vec3(0.27682578965001, 0.25612693190801, -0.083747589912556)),\n        Point(vec3(-0.1800012946084, -0.64240121389569, -0.52811189899337), vec3(0.18101107202813, 0.29238609721073, -0.17778872091026)),\n        Point(vec3(0.046311839229286, -0.059576127601519, -0.6042218046828), vec3(0.28748824757268, 0.083783706072424, 0.30304262565273)),\n        Point(vec3(-0.2645977515418, -0.21242667831488, -0.38410849971878), vec3(0.45558387566108, 0.54663062790831, 0.32619131886992)),\n        Point(vec3(0.39332075358377, 0.8079955859113, -0.23851239838696), vec3(-0.093881709550139, 0.16767153946513, 0.3549155315656)),\n        Point(vec3(-0.17619830778956, -0.15443051296807, 0.46530699172065), vec3(0.45516958241061, -0.1674021285857, 0.27824178537136)),\n        Point(vec3(-0.45828703029937, -0.12156325661146, -0.49218653566472), vec3(-1.3445628469842, 0.29880945868888, 0.48266315219836)),\n        Point(vec3(-0.71737575610565, -0.36898820409159, 0.39308737695097), vec3(0.14234531277761, 0.15949620529702, -0.062687774062848)),\n        Point(vec3(0.41994310552923, -0.73079411347116, 0.33071671375141), vec3(0.25033680497999, 0.086061537104298, -0.44696021401026)),\n        Point(vec3(0.09746523964758, 0.27710878549662, -0.53194645180446), vec3(0.14588416661591, 0.059459916605787, 0.47058635713556)),\n        Point(vec3(-0.2935634784412, -0.15251945294153, -0.6467427108128), vec3(0.47525163351657, 0.84242287513117, 0.91395603045132)),\n        Point(vec3(-0.67722452325758, 0.18837245774342, 0.47601692398526), vec3(0.73708884678981, 0.46377105641691, 0.18617568440082)),\n        Point(vec3(-0.59500028601159, -0.25373197125202, 0.0048260688565462), vec3(-0.12150514552962, 0.38004739402931, 0.33808039861939)),\n        Point(vec3(0.24238076570898, -0.8450317167031, 0.25471214017605), vec3(-0.081072996737368, 0.50526586338698, 0.29018343786057)),\n        Point(vec3(-0.2855565853411, -0.84135900571213, 0.27680917638163), vec3(1.0442668707984, 0.79179066723702, 0.60343443564808)),\n        Point(vec3(-0.83444271669088, 0.36002771362898, -0.39043000642562), vec3(0.2139966003838, 0.55817226824936, 0.64364872069446)),\n        Point(vec3(-0.44584842010736, 0.097591559779286, 0.068403971950147), vec3(-0.0076513297639158, 0.82702131415726, 0.71279867702016)),        \n        Point(vec3(-0.16254019052522, -0.51230724728261, 0.3511198761761), vec3(0.45173249743036, 0.23131740153786, -0.23705175630093)),\n        Point(vec3(-0.09072466741967, -0.78284510901248, 0.046863271697854), vec3(-1.5084674562619, 0.48770052611082, 0.89189780409258)),\n        Point(vec3(0.45710801444265, 0.43299949951969, 0.49442059557907), vec3(0.92188427934439, 0.65683852049455, 0.446496582264)),\n        Point(vec3(0.048042757414192, 0.10498239894514, -0.97815786819063), vec3(1.1611256003835, 0.62379374775914, 0.7481832961767)),\n        Point(vec3(-0.71835048645704, -0.2836592050796, 0.25857211606417), vec3(0.49408141012653, 0.037834922365928, 0.36975237082006)),\n        Point(vec3(0.007899239800051, -0.12347195390497, 0.86527974792464), vec3(0.42447797333823, 0.61218879141794, 1.0635626579192)),\n        Point(vec3(0.11783411591915, -0.51428224469093, -0.18777264946077), vec3(0.85357468041629, 0.63383966688733, 0.17570665178474)),\n        Point(vec3(0.057137701263305, -0.28954692812907, 0.81316979311207), vec3(1.2325367320365, 0.68363638057909, 0.70641457995251)),\n        Point(vec3(0.10131868864176, 0.13367001924023, 0.79234924560498), vec3(0.28634087728214, 0.16623586320647, 0.34391859609493)),\n        Point(vec3(0.10634865746467, -0.48469720793753, 0.020476303464279), vec3(0.54840974041513, 0.61005295154415, 0.44642469502501)),\n        Point(vec3(0.16742128348339, 0.4754238820094, 0.45103050631994), vec3(0.14709625877695, 0.543346355913, 0.60095968900077))\n);\n\n#define getPointCount() points.length()\n#define getPoint(i) points[i]\n\n#define TAU 6.28318530717958647693\n\n#define PI_DIV_360 0.00872664625997164788\nmat4 buildPerspectiveMatrix(float fov, float aspect, float n, float f) {\n    float scale = tan(fov * PI_DIV_360) * n;\n    float r = aspect * scale;\n    float l = -r;\n    float t = scale;\n    float b = -t;\n    \n    return mat4(\n        2.0 * n / (r - l), 0.0, 0.0, 0.0,\n        0.0, 2.0 * n / (t - b), 0.0, 0.0,\n        (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1.0,\n        0.0, 0.0, -2.0 * f * n / (f - n), 0.0\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y * vec2(2.0, -2.0);\n    \n    mat4 perspectiveMatrix = buildPerspectiveMatrix(100.0, 1.0, 1e-2, 1e2);\n    float minDist2 = 1e9;\n    vec3 minColor;\n    for(int i = 0; i < getPointCount(); i++) {\n        vec3 point = getPoint(i).pos;\n        float pointAngle = atan(point.z, point.x);\n        pointAngle += iTime * TAU / 12.0;\n        point = vec3(cos(pointAngle), point.y, sin(pointAngle));\n        point -= vec3(0.0, 0.0, 1.3);\n        \n        vec4 pos = perspectiveMatrix * vec4(point, 1.0);\n        point = pos.xyz / pos.w;\n        \n        if (point.z < 0.0) continue;\n        \n        #if 1\n        vec3 mag = point.xyz - vec3(uv, 0.0);\n        #else\n        vec2 mag = point.xy - uv;\n        #endif\n        \n        float len2 = dot(mag, mag);\n        \n        #if 0\n        if(len2 < 1.0) {\n            fragColor = vec4(getPoint(i).color, 1.0);\n            return;\n        }\n        #else\n        if (len2 < minDist2) {\n            minDist2 = len2;\n            minColor = getPoint(i).color;\n        }\n        #endif\n    }\n    \n    // Output to screen\n    fragColor = vec4(minColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14016, 14016, 14088, 14088, 14453], [14455, 14455, 14512, 14562, 15722]], "test": "untested"}
{"id": "7lVcR3", "name": "is your round doing roundEven ?", "author": "FabriceNeyret2", "description": "seeems like many systems implement round as roundEven.\non the left, do you see something else than plain white on top half and 1/4 white dots on bottom half ? ( ref at bottom)\nIf yes, please tell your GPU and OS ! \nSee code header for problem description.", "tags": ["test", "glsl", "compatibility"], "likes": 5, "viewed": 269, "published": 3, "date": "1661948253", "time_retrieved": "2024-07-30T16:33:38.054042", "image_code": "// variant of https://shadertoy.com/view/NlGyz3\n\n// roundEven spec: https://registry.khronos.org/OpenGL-Refpages/gl4/html/roundEven.xhtml\n// But for round, it's implementation choice: https://registry.khronos.org/OpenGL-Refpages/gl4/html/round.xhtml\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U.y > iResolution.y/2. ) U = floor(U); // top : integer coordinates. bottom: original integer+.5 coordinates.\n    O = vec4( round(U) == floor(U+.5) );  \n    \n    if ( U.x >  iResolution.x/2. ) O = texelFetch(iChannel0, ivec2(round(U))%256, 0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVcR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 289, 289, 544]], "test": "untested"}
{"id": "stVyR3", "name": "Color heat ramp collection", "author": "Raxvan", "description": "A collection of heat ramps that don't wrap around for debugging and visualization of various data. Optimizations and improvements are welcomed. Ramps work with t clamped to interval [0.0,1.0].", "tags": ["heatmapramp"], "likes": 5, "viewed": 233, "published": 3, "date": "1661942127", "time_retrieved": "2024-07-30T16:33:38.924714", "image_code": "\n//sources (with minor adjustments):\n// https://www.shadertoy.com/view/XtjBzG\n// https://www.shadertoy.com/view/llKGWG\n// https://www.shadertoy.com/view/ltlSRj\n// https://www.shadertoy.com/view/4ttfRn\n\n//----------------------------------------------------------------------------------------------\n//source: https://www.shadertoy.com/view/XtjBzG\n\nvec3 ramp0(float t)\n{\n    t = clamp(t, 0.0,1.0);\n    t *= 4.;\n    return clamp(vec3(min(t-1.5, 4.5-t),\n                      min(t-0.5, 3.5-t),\n                      min(t+0.5, 2.5-t)),\n                 0.0, 1.0);\n}\nvec3 ramp0_smooth(float t)\n{\n    return smoothstep(0.0, 1.0, ramp0(t));\n}\n\n//----------------------------------------------------------------------------------------------\n//source https://www.shadertoy.com/view/llKGWG\n\nvec3 ramp1(float greyValue) {\n    vec3 heat;\n    greyValue = clamp(greyValue, 0.0, 1.0);\n    heat.r = smoothstep(0.5, 0.8, greyValue);\n    if(greyValue >= 0.90) {\n        heat.r *= (1.1 - greyValue) * 5.0;\n    }\n    if(greyValue > 0.7) {\n        heat.g = smoothstep(1.0, 0.7, greyValue);\n    } else {\n        heat.g = smoothstep(0.0, 0.7, greyValue);\n    }\n    heat.b = smoothstep(1.0, 0.0, greyValue);\n    if(greyValue <= 0.3) {\n        heat.b *= greyValue / 0.3;\n    }\n    return heat;\n}\n\n\n//----------------------------------------------------------------------------------------------\n//source https://www.shadertoy.com/view/ltlSRj (optimized version)\n\nvec3 ramp_red_to_green( float t )\n{\n    return vec3(min(1., 2.-2.*t), min(1., 2.*t), 0.);\n}\nvec3 ramp_green_to_blue( float t )\n{\n    return vec3(0., min(1., 2.-2.*t), min(1., 2.*t));\n}\nvec3 heat2( float t )\n{\n    return mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), t);\n}\nvec3 heat5( float t )\n{\n    t = clamp(t, 0.0, 1.0);\n    float ta = 1.0 - t * 2.0;\n    float tb = ta + 1.0;\n    return mix(ramp_green_to_blue(ta), ramp_red_to_green(tb), step(0.5, t));\n    \n}\nvec3 heat7( float interpolant )\n{\n    if( interpolant < 1.0 / 6.0 )\n    {\n        float firstSegmentInterpolant = 6.0 * interpolant;\n        return ( 1.0 - firstSegmentInterpolant ) * vec3(0.0, 0.0, 0.0) + firstSegmentInterpolant * vec3(0.0, 0.0, 1.0);\n    }\n    else if( interpolant < 5.0 / 6.0 )\n    {\n        float midInterpolant = 0.25 * ( 6.0 * interpolant - 1.0 );\n        return heat5( midInterpolant );\n    }\n    else\n    {\n        float lastSegmentInterpolant = 6.0 * interpolant - 5.0;\n        return ( 1.0 - lastSegmentInterpolant ) * vec3(1.0, 0.0, 0.0) + lastSegmentInterpolant * vec3(1.0, 1.0, 1.0);\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n//source https://www.shadertoy.com/view/4ttfRn\n\nvec3 ramp8(float t)\n{\n    vec3 c = vec3(2.,1.,0.) - 2.0 * t;\n    return clamp(vec3(1.0) - c*c,vec3(0.0), vec3(1.0));\n}\n\nvec3 ramp8_gamma(float t)\n{\n    return pow(ramp8(t), vec3(1.0 / 2.2));\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 ramp_custom_v4(float value, vec4 intervals)\n{\n    float limit_min  = intervals.x;\n    float limit_low  = intervals.y;\n    float limit_high = intervals.z;\n    float limit_max  = intervals.w;\n\n    vec3 r;\n\n    if(value < limit_low)\n    {\n        //blue -> light blue\n        r = mix(vec3(0.0,0.0,1.0), vec3(0.0,1.0,1.0), smoothstep(limit_min, limit_low, value));\n    }\n    else if (value < limit_high)\n    {\n\n        float mp = (limit_low + limit_high) * 0.5;\n\n        //light-blue -> green\n        //green -> yellow\n        r = mix(vec3(0.0,1.0,1.0),vec3(0.0,1.0,0.0), smoothstep(limit_low, mp, value));\n        r = mix(r,vec3(1.0,1.0,0.0), smoothstep(mp, limit_high, value));\n    }\n    else\n    {\n        //yellow -> red\n        r = mix(vec3(1.0,1.0,0.0), vec3(1.0,0.0,0.0), smoothstep(limit_high, limit_max, value));\n    }\n\n    return r;\n}\nvec3 ramp_custom_v2(float value, vec2 interval)\n{\n    float r = interval.y - interval.x;\n    return ramp_custom_v4(value, vec4(interval.x) + vec4(0.0, 1.0, 2.0, 3.0) * r / 3.0);\n}\n\n\n//----------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------\n\nvec3 border(vec3 c, float y, float i, vec3 nc)\n{\n    float d = abs(y - i);\n    if(d < 0.0015)\n        return vec3(0.2);\n    if(y < i)\n        return nc;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float t = uv.x * 1.1 - 0.05;\n    float y = uv.y;\n\n    vec3 rgb = vec3(0.0);\n\n    rgb = border(rgb, y, 1.0, heat2(t));\n    rgb = border(rgb, y, 0.9, ramp0_smooth(t)); //dark blue -> dark red\n    rgb = border(rgb, y, 0.8, ramp0(t)); //dark blue -> dark red\n    rgb = border(rgb, y, 0.7, ramp1(t)); //black -> dark red\n    rgb = border(rgb, y, 0.6, heat7(t)); //black -> white\n    rgb = border(rgb, y, 0.5, ramp8_gamma(t)); //blue -> red\n    rgb = border(rgb, y, 0.4, ramp8(t));\n    rgb = border(rgb, y, 0.3, heat5(t));\n    rgb = border(rgb, y, 0.2, ramp_custom_v2(t, vec2(0.0,1.0)));\n    rgb = border(rgb, y, 0.1, ramp_custom_v4(t, vec4(0.0,0.25, 0.5, 1.0)));\n\n    rgb = border(rgb, t, 0.0, rgb);\n    rgb = border(rgb, t, 1.0, rgb);\n\n    fragColor = vec4(rgb,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 369, 369, 563], [564, 564, 592, 592, 637], [784, 784, 813, 813, 1273], [1441, 1441, 1476, 1476, 1532], [1533, 1533, 1569, 1569, 1625], [1626, 1626, 1649, 1649, 1712], [1713, 1713, 1736, 1736, 1903], [1904, 1904, 1937, 1937, 2525], [2672, 2672, 2693, 2693, 2790], [2792, 2792, 2819, 2819, 2864], [2964, 2964, 3014, 3014, 3809], [3810, 3810, 3859, 3859, 3989], [4284, 4284, 4332, 4332, 4452], [4454, 4454, 4511, 4511, 5326]], "test": "untested"}
{"id": "NtVczc", "name": "Colorful waves split", "author": "kkragoth", "description": "Trying colorful waves", "tags": ["colors", "pal"], "likes": 4, "viewed": 224, "published": 3, "date": "1661939127", "time_retrieved": "2024-07-30T16:33:40.197312", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time_slow = 0.2;\n    float time_fast = 10.0;\n    \n    float time = time_slow;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = pal( (p.x + p.y + sin(iTime * 10.0)) * 1.0, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n\n    // Output to screen\n     fragColor = vec4(col * sin(150.0 * (p.x + (p.y * p.y * abs(sin(iTime * 0.15)))) * cos(iTime * time_slow)) * cos((p.y + (p.x * p.x + cos(iTime))) * 10.0 * sin(iTime)),1.0);\n     \n     fragColor = vec4(col * sin(30.0 * (p.x + (p.y * p.y * sin(iTime))) * cos(iTime * 10.0)) * cos((p.y + (p.x * p.x + cos(iTime))) * 10.0 * sin(iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [113, 113, 170, 170, 890]], "test": "untested"}
{"id": "ftyyz3", "name": "[twigl]Mandelbulb (280chrs)", "author": "Catzpaw", "description": "https://twitter.com/catzpaw/status/1527290859120603138", "tags": ["mandelbulb", "twigl"], "likes": 7, "viewed": 260, "published": 3, "date": "1661920961", "time_retrieved": "2024-07-30T16:33:41.581610", "image_code": "//--- Mandelbulb\n// by Catzpaw 2022\n\n//https://bit.ly/3LoHtbf\n\nTWIGL_GEEKEST_300ES\n\nfloat d=.1,e,h,i,j,l,z;vec3 p,q;p.x-=1.7;\nfor(o++;i++<1e2&&d>4e-5;o-=.01/exp(d)){\n  for(q=p+=vec3(1.,(FC.xy*2.-r)/r.y)*d,j=d=1.;j++<9.;\n    l<2.?e=acos(q.z/l)*6.+t,h=atan(q.y,q.x)*6.+t,z=pow(l,6.),d=z/l*6.*d+1.,\n    q=p+vec3(sin(e)*cos(h),sin(e)*sin(h),cos(e))*z:p)l=length(q);\n  d=.5*log(l)*l/d;}\n\nEND_GEEKEST_300ES\n", "image_inputs": [], "common_code": "/* ============================================ **\n\n███████        █   TWIGL GEEKEST WRAPPER\n█  █  █            for Shadertoy\n   █  ███  █████\n   █   █ ▐▌ █  █    by Catzpaw 2022\n  ███  ▐█▌▐█▌ ███\n\n ██       ██  ██\n █  ▐█████ █   █\n█▌ ▐█   █  █   ▐█  \"twigl\"\n █ ▐█   █  █   █    https://twigl.app/\n ██ ▐████ ███ ██    Copyright (c) 2020 doxas\n    ████▌\n\nMIT License\nhttps://github.com/doxas/twigl/blob/master/LICENSE\n\n** ============================================ */\n\n\n/*** NOTICE **************************************\n  No backbuffer supported.\n  No MRT supported.\n  \"s\" is always zero.\n*************************************************/\n\n\n\n// --------------------------------------------\n//  noise.glsl\n// --------------------------------------------\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2  mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3  mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nfloat permute(float x){return mod289(((x*34.0)+1.0)*x);}\nvec3  permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nvec4  permute(vec4 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4  taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise2D(vec2 v){\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat snoise3D(vec3 v){\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\nfloat snoise4D(vec4 v){\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat fsnoise      (vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nconst float PI = 3.141592653589793;\nconst float PI2 = PI * 2.0;\n\n\n// --------------------------------------------\n//  twigl geekest(300 es) aliases\n// --------------------------------------------\n#define TWIGL_GEEKEST_300ES void mainImage(out vec4 o,in vec2 _fc){vec2 r=iResolution.xy,m=iMouse.xy/r;vec4 FC=vec4(_fc,.5,1);float s=0.,t=iTime;int f=iFrame;o=vec4(0);\n#define END_GEEKEST_300ES o=vec4(clamp(o.xyz,0.,1.),1);}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flVyzV", "name": "Chladni plate Audio Visualizer", "author": "SamOrantin", "description": "Chladni", "tags": ["chladni"], "likes": 4, "viewed": 311, "published": 3, "date": "1661916085", "time_retrieved": "2024-07-30T16:33:42.577946", "image_code": "\n#define PI 3.1415\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float freqs[4];\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.90, 0.25 ) ).x;\n    \n    float n = 4.*(pow(freqs[0],1.)-.5) +(2.0+sin(iTime/2.))*2.+ iMouse.x/112.;//(2.0+sin(iTime/2.))*2.;\n    float m = iMouse.y/iResolution.y;\n    m = 0.;\n    n = 4.*(pow(freqs[0],1.)-.5) +(2.0+sin(iTime/2.))*2.;\n    // n = 4.1;\n    int passes= 0;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=.5;\n    float asp = iResolution.x/iResolution.y;\n    uv.x*=asp;\n    \n    float d, col;\n  \n\t\n\t//radio\n    //edgecenter\n    uv+=vec2(0.,0.5);\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv-=vec2(0.,0.5);\n    \n    uv-=vec2(0.,0.5);\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv+=vec2(0.,0.5);\n    \n    uv+=vec2(0.5,0.);\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv-=vec2(0.5,0.);\n    \n    uv-=vec2(0.5,0.);\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv+=vec2(0.5,0.);\n    \n    //corner\n    uv+=0.5;\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv-=0.5;\n    \n    uv-=0.5;\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv+=0.5;\n    \n    uv+=vec2(0.5,-.5);\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv-=vec2(0.5,-.5);\n    \n    uv-=vec2(0.5,-.5);\n    d = length(uv);\n   \tcol += cos(2.*PI*n*d + m*float(passes));\n    passes++;\n    uv+=vec2(0.5,-.5);\n    \n    col += 5.*freqs[3];\n    col *= .3 + 3.*freqs[3];\n    col /= float(passes);\n\n    col = step(uv.x,.5)*step(-.5,uv.x)*col;\n    \n    float col1 = smoothstep(-0.5,0.5,col);\n    \n    col1 = col1*(1.-col1)*4.;\n    \n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.4,2.4,2.4);\n    vec3 d1 = vec3(0.0,0.33,0.67);\n    \n    vec3 col2 = a + b*cos(2.*PI*(c*(max(col , col1)+iTime*0.3) + d1));\n\n    //vec4 c = vec4(1.-abs(col));\n    \n    fragColor = vec4(col2,1.);\n\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 2241]], "test": "untested"}
{"id": "NlKyRV", "name": "rotating rainbow squares 2", "author": "ufffd", "description": "Generating a basic animation to use as input for stable-diffusion. I'll post the results below when they're rendered.", "tags": ["square", "rainbow", "rotating"], "likes": 8, "viewed": 217, "published": 3, "date": "1661890616", "time_retrieved": "2024-07-30T16:33:43.342901", "image_code": "// Fork of \"rotating rainbow square\" by ufffd. https://shadertoy.com/view/ftVyzG\n// 2022-08-30 06:10:17\n\nfloat drawSquare(in vec2 uv, in vec2 p, in float size) {\n    // p = rotate(p, iTime);\n    // uv = rotate(uv, iTime*2.);\n    return SS(-0.02, (abs(uv.x-p.x) + abs(uv.y-p.y)) / size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = ( 2.*fragCoord - R ) / R.y;          // [-1,1] vertically\n    \n    vec3 col = vec3(0.);\n    \n    float piTime = iTime*PI;\n    float spinTime = piTime / 6.;\n    float capTime = iTime;\n    float colorTime = iTime / 6.;\n    \n    for (int i = 0; i<4; i++) {\n        float fi = float(i);\n        vec2 nuv = rotate(uv,-piTime/12.);\n        vec2 suv = rotate(uv,spinTime); // +fi*PI/8.\n        suv = rotate(suv,sin(fi*PI/8.)); // +fi*PI/8.\n        suv *= 1.+sin(piTime+fi*PI/6.)*0.1;\n        suv *= 1.+fi*0.1;\n\n        float sq = max(abs(suv.x), abs(suv.y));\n        sq = SS(0.5,abs(sq-.15));\n        sq = cubicPulse(0.5,0.05,sq)*5.;\n        col += sq*spectral_zucconi6(fract(colorTime+fi/20.)*300.+400.);\n        \n        suv *= 0.9+noise(vec3(nuv*10.,iTime*2.))*0.2;\n        \n        sq = max(abs(suv.x), abs(suv.y));\n        sq = SS(0.5,abs(sq-.15));\n        sq = cubicPulse(0.5,0.05,sq)*5.;\n        col += 0.5*sq*spectral_zucconi6(fract(colorTime+fi/20.)*300.+400.);\n        \n        suv *= 0.9+noise(vec3(nuv*30.,iTime*3.))*0.2;\n        \n        sq = max(abs(suv.x), abs(suv.y));\n        sq = SS(0.5,abs(sq-.15));\n        sq = cubicPulse(0.5,0.05,sq)*5.;\n        col += 0.5*sq*spectral_zucconi6(fract(colorTime+fi/20.)*300.+400.);\n    }\n    \n    vec2 pt = vec2(0.,1.);\n    vec2 pb = vec2(0.,-1.);\n    vec2 pl = vec2(-1.,0.);\n    vec2 pr = vec2(1.,0.);\n    \n    // 8 step cap\n    float t3 = fract((5./6.)*capTime*0.4)*3.; // 0-3\n    float t4 = fract((5./6.)*capTime*0.3+1.)*4.; // 0-4\n    \n    vec2 p1,p2;\n    \n    if (t3 < 1.) {\n        p1 = mix(pb,pt,fract(t3));\n    } else if (t3 < 2.) {\n        p1 = mix(pt,pr,fract(t3));\n    } else {\n        p1 = mix(pr,pb,fract(t3));\n    }\n    \n    if (t4 < 1.) {\n        p2 = mix(pb,pl,fract(t4));\n    } else if (t4 < 2.) {\n        p2 = mix(pl,pt,fract(t4));\n    } else if (t4 < 3.) {\n        p2 = mix(pt,pr,fract(t4));\n    } else {\n        p2 = mix(pr,pb,fract(t4));\n    }\n    \n    p1 *= 0.5;\n    p2 *= 0.5;\n    \n    float d1 = drawSquare(uv,p1,0.25);\n    col += d1*spectral_zucconi6(fract(colorTime)*300.+400.);\n    \n    float d2 = drawSquare(uv,p2,0.25);\n    col += d2*spectral_zucconi6(fract(colorTime+PI)*300.+400.);\n\n    // tonemap & output\n    col = filmicToneMapping(col);    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define SS(a,b) smoothstep(0.5-a,0.5+a,b)\n#define PI 3.141592653589793\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat saturate (float x){\n    return min(1.0, max(0.0,x));\n}\n\nvec3 saturate (vec3 x){\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// --- MATLAB Jet Colour Scheme ----------------------------------------\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 161, 224, 288], [290, 290, 347, 397, 2696]], "test": "untested"}
{"id": "NlGyz3", "name": "roundEven", "author": "FabriceNeyret2", "description": "do you see something else than plain white ?\nIf yes, please tell your GPU and OS ! \n\nSee code header for problem description.", "tags": ["test", "glsl"], "likes": 0, "viewed": 361, "published": 3, "date": "1661874837", "time_retrieved": "2024-07-30T16:33:44.264437", "image_code": "// Indeed, the page https://registry.khronos.org/OpenGL-Refpages/gl4/html/roundEven.xhtml\n// is confusing, or even wrong.\n// A way clearer definition is there: https://blogs.sas.com/content/iml/2019/11/11/round-to-even.html\n// In short: roundEven = round  BUT for integer+0.5 . Then, parity decide. Purpose: avoid statistical bias.\n\n// still, at least on OpenGL+nVIDIA roundEven doesn't seem to work. [EDIT]: wrong: it's round that always do roundEven !\n// But it is indeed let implementation choice: https://registry.khronos.org/OpenGL-Refpages/gl4/html/round.xhtml\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (U.y > iResolution.y/2.) U = floor(U);   // then, roundEven(U) == round(U) is expected.\n                                                // but not in the other case ( bottom window ).\n    O = vec4( roundEven(U) == round(U) );\n // O = vec4( round(U) == floor(U+.5) );        // indeed, the anomaly is round, not roundEven\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 568, 606, 606, 937]], "test": "untested"}
{"id": "flGcR3", "name": "Beat boxing II", "author": "mrange", "description": "License CC0: Beat boxing II\nTook the beat boxing shader from yesterday and kicked it up a notch: https://www.shadertoy.com/view/7tGcRV\nMusic by Ultrasyd (sadly no longer with us): https://soundcloud.com/ultrasyd/shitstep-game-boy\n", "tags": ["3d", "boxes", "beats"], "likes": 13, "viewed": 383, "published": 3, "date": "1661873921", "time_retrieved": "2024-07-30T16:33:45.196944", "image_code": "// License CC0: Beat boxing II\n//  Took the beat boxing shader from yesterday and kicked it up a notch: https://www.shadertoy.com/view/7tGcRV\n//  Based on Evilryus version of mandelbox:\n//   https://www.shadertoy.com/view/XdlSD4\n//  Music by Ultrasyd (sadly no longer with us): https://soundcloud.com/ultrasyd/shitstep-game-boy\n//   The music AFAIK is made on a Gameboy!\n\n// If no sound it is usually because browsers block audio element that has no interaction\n//  So tinker with the player controls and the browser might decide to start the audio\n\n// Oh yeah and if no music then shader is black\n\n//#define THEME0\n#define THEME1\n\n#define TOLERANCE       0.001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nmat2 g_rot = ROT(0.0);\n\nfloat g_quad = 0.0;\nfloat g_beat = 0.0;\nfloat g_drum = 0.0;\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float ndbuffer = dbuffer/sph.w;\n  vec3  rc = (ro - sph.xyz)/sph.w;\n  \n  float b = dot(rd,rc);\n  float c = dot(rc,rc) - 1.0;\n  float h = b*b - c;\n  if( h<0.0 ) return 0.0;\n  h = sqrt( h );\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  if( t2<0.0 || t1>ndbuffer ) return 0.0;\n  t1 = max( t1, 0.0 );\n  t2 = min( t2, ndbuffer );\n\n  float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n  float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n  return (i2-i1)*(3.0/4.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n\n// -------------------------------------------------\n// Mandelbox - https://www.shadertoy.com/view/XdlSD4\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2 = 0.1;\nconst float folding_limit = 1.0;\nconst float scale = -2.5;\n\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp;\n    dz *= temp;\n  } else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp;\n    dz *= temp;\n  }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n  float dd = length(z)-g_drum;\n  vec3 offset = z;\n  float dr = 1.0;\n\n  for(int n = 0; n < 5; ++n) {\n    box_fold(z, dr);\n    sphere_fold(z, dr);\n\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.5;\n  }\n  \n  float d = (length(z))/abs(dr)-0.04;\n  dd = pmax(dd, -d, 0.5);\n  if (dd < d) {\n    g_quad = -1.0;\n  } else {\n    g_quad = 1.0;\n  }\n  g_quad = -g_quad;\n  d = min(d, dd);\n\n  return d;\n}\n// -------------------------------------------------\n\n\nfloat df(vec3 p) {\n  p.xz *= g_rot;\n  const float z = 1.0;\n  float d = mb(p/z)*z;\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 2.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORMTOL, 0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec4 render(vec3 ro, vec3 rd) {\n  const vec3 lightPos0  = 2.5*vec3(1.0, 1.0, 1.0);\n  const vec3 lightPos1  = vec3(0.0);\n  float beat = g_beat;\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  float quad = g_quad;\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, mix(2.3, 2.4, beat)), t);\n\n  const vec3 bcol0 = HSV2RGB(vec3(0.6, 0.6, 3.0));\n  const vec3 bcol1 = HSV2RGB(vec3(0.55, 0.8, 7.0));\n  vec3 bcol   = mix(bcol0, bcol1, beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    \n    return vec4(gcol, sqrt(lsd1));\n  }\n\n  float d     = df(pos);  \n  vec3 nor    = normal(pos);\n  float fre   = 1.0+dot(nor, rd);\n  fre *= fre;\n  fre *= fre;\n\n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n  float spe0  = pow(max(dot(reflect(rd, nor), ld0), 0.), 10.0);\n\n\n  vec3 col = vec3(0.0);\n  quad = -quad;\n  const vec3 black = vec3(0.0);\n#if defined(THEME0)\n  const vec3 dcol0 = HSV2RGB(vec3(0.6, 0.5, 1.0));\n  const vec3 dcol1 = black;\n#elif defined(THEME1)\n  const vec3 dcol0 = HSV2RGB(vec3(0. , 0.75, -0.25));\n  const vec3 dcol1 = HSV2RGB(vec3(0.08, 1.0, 1.0));\n#else\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = dcol0;\n#endif\n  col += dif0*dif0*sha0*mix(dcol0, dcol1, 0.5+0.5*quad);\n  col += spe0*bcol*bs*sha0;\n  col += gcol;\n\n  return vec4(col, 1.0);\n}\n\nvec3 synth(vec2 cp, out vec3 gg) {\n  float aaa = 2.0/RESOLUTION.y;\n  cp -= vec2(-0.75*PI, -0.3);\n  cp *= ROT(4.0*length(cp)*g_beat);\n  vec2 tp = 40.0*cp;\n  tp -= 10.0*TIME;\n  float aa = length(fwidth(tp))*sqrt(0.5);\n\n  vec2 hp = tp;\n  vec2 hn = hextile(hp);\n  float h0 = hash(hn+1234.5);\n  float h1 = fract(8677.0*h0);\n  float fft = texture(iChannel0, vec2(h1, 0.25)).x;\n  fft = tanh_approx(2.0*max(fft-0.5, 0.0));\n  fft *= fft;\n  float d = max(length(hp)-0.25*fft, 0.0);\n  vec3 bcol = hsv2rgb(vec3(h0, mix(0.95, 0.95, d*d), 0.25*fft));\n  float hd = hexagon(hp.yx, 0.49);\n  vec3 col = bcol/(d);\n  col = min(col, vec3(10.0));\n  \n  col = mix(col, bcol*10.0, smoothstep(aa, -aa, -hd));\n  const vec3 gcol = HSV2RGB(vec3(0.55, 0.9, 1.0));\n  gg = gcol*25.0*(aaa*aaa)/(aa*aa);\n  return col;\n}\n\nvec3 wave(vec2 cp) {\n  vec3 col = vec3(0.0);\n  for (int i = 0; i < 3; ++i) {\n    vec3 scol = hsv2rgb(vec3(0.2*TIME+cp.x+0.0+0.2*float(i), 0.999, 0.005));\n    float off = texture(iChannel0, vec2(0.15*(cp.x+3.0*float(i)+PI), 0.75)).x;\n\n    float dd = max(abs(cp.y+0.3+0.2*off)-0.001, 0.0);\n    col += abs(cp.x)*scol/(dd);\n  }\n  col = min(col, vec3(5.0, 2.5, 2.5));\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float fft = 0.0;\n  fft += texture(iChannel0, vec2(0.3, 0.25)).x;\n  fft += texture(iChannel0, vec2(0.2, 0.25)).x;\n  fft += texture(iChannel0, vec2(0.1, 0.25)).x;\n  fft /= 3.0;\n\n  float beat = tanh_approx(8.0*max(fft-0.5, 0.0));\n  beat *= beat;\n  beat *= beat;\n  g_beat = beat;\n  g_drum = mix(2.05, 2.2, smoothstep(0.8, 1.0, beat));\n\n  p *= ROT(-0.25*(beat)*(length(p)+0.1));\n  g_rot = ROT(-0.1*TIME+0.1*beat);\n  vec3 cam  = 5.0*vec3(1.0, 0.5, 1.0);\n  vec3 dcam = normalize(vec3(0.0) - cam);\n\n\n  vec3 ro = cam;\n  vec3 ww = dcam;\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = cross(ww,uu);\n  float rdd = tan(TAU/mix(5.5, 5.0, beat*(0.5+0.8*length(p))));\n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n\n  float a = atan(rd.x, rd.z);\n  vec2 cp = vec2(a, rd.y);\n\n\n  vec3 col = vec3(0.0);\n  vec3 gcol = vec3(0.0);\n  col += synth(cp, gcol);\n  col += wave(cp);\n  vec4 cube = render(ro, rd);\n  col = mix(col, cube.xyz, cube.w);\n  col += gcol;\n  col += smoothstep(0.9, 1.0, beat)*smoothstep(0.5, 3.0, length(p));\n  col *= smoothstep(0.0, 0.3, beat);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p);\n  col = aces_approx(col);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 29689, "src": "https://soundcloud.com/ultrasyd/shitstep-game-boy?si=70bd17745d2544259c3bddffc8d2d351&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGcR3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1056, 1056, 1078, 1078, 1224], [1453, 1513, 1541, 1561, 1637], [1639, 1761, 1819, 1819, 2270], [2272, 2372, 2411, 2411, 2496], [2498, 2586, 2625, 2625, 2654], [2656, 2756, 2775, 2775, 2862], [2864, 2971, 2997, 2997, 3181], [3183, 3301, 3333, 3333, 3519], [3521, 3622, 3650, 3749, 4076], [4078, 4138, 4159, 4159, 4229], [4464, 4464, 4512, 4512, 4750], [4752, 4752, 4797, 4797, 4856], [4858, 4858, 4876, 4876, 5274], [5330, 5330, 5348, 5348, 5429], [5432, 5432, 5486, 5486, 5681], [5683, 5683, 5706, 5706, 5914], [5916, 5916, 5993, 5993, 6293], [6295, 6295, 6326, 6326, 7871], [7873, 7873, 7907, 7907, 8658], [8660, 8660, 8680, 8680, 9038], [9040, 9040, 9061, 9061, 10140], [10142, 10142, 10197, 10197, 10399]], "test": "untested"}
{"id": "flKyzV", "name": "Pentakis Duckohedron", "author": "dr2", "description": "One duck and a lot of symmetry", "tags": ["symmetry", "polyhedron", "duck"], "likes": 13, "viewed": 262, "published": 3, "date": "1661847678", "time_retrieved": "2024-07-30T16:33:46.043679", "image_code": "// \"Pentakis Duckohedron\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (Based on mix of \"Dodecahedral Duckohedron\" and \"Pentakis Dodecahedron\")\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, szFac, dRot;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idPol = 5;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, csD * vec2 (1., -1.));\n    p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat DukDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 r, cs;\n  float d, h, s;\n  dMin /= szFac;\n  p /= szFac;\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  h = 0.1;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  DMINQ (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 0.06, 0.12);\n  cs = sin (0.3 + vec2 (0.5 * pi, 0.));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  h = 0.014;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  d = SmoothMin (d, dMin, 0.01);\n  DMINQ (idWng);\n  q = p;\n  q.yz -= vec2 (0.15, -0.08);\n  d = PrEllipsDf (q, vec3 (0.08, 0.07, 0.1));\n  d = SmoothMin (d, dMin, 0.02);\n  DMINQ (idHead);\n  q = p;\n  q.yz -= vec2 (0.14, -0.19);\n  r = vec2 (0.03, 0.008);\n  h = 0.02;\n  d = max (PrEllCylDf (q, r, h), - PrEllCylDf (q - vec3 (0., 0., h),\n     r - 0.004, 2. * h));\n  DMINQ (idBk);\n  return 0.9 * dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a1, a2, rEx;\n  rEx = 3.;\n  dMin = dstFar;\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  d = abs (dot (q.yz, - sin (a1 - a2 + vec2 (0., 0.5 * pi))) - rEx) - 0.03 * rEx;\n  d = max (d, 0.02 * rEx - min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))));\n  DMINQ (idPol);\n  q.yz = Rot2Cs (vec2 (q.y, q.z + rEx), sin (a1 - a2 + vec2 (0.5 * pi, 0.)));\n  q.xy = Rot2Cs (abs (vec2 (q.x, q.y - 0.35 * rEx)) - 0.08 * rEx, sin (dRot +\n     vec2 (0.5 * pi, 0.)));\n  q.z += 0.14 * rEx;\n  dMin = DukDf (- q.xzy, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ObjCol ()\n{\n  vec3 col, cBdy;\n  float s;\n  cBdy = vec3 (0.9, 0.7, 0.1);\n  if (idObj == idBdy) {\n    col = cBdy * (1. - smoothstep (0.02, 0.06, qHit.y) *\n       smoothstep (0., 0.14, qHit.z) * 0.1 * SmoothBump (0.3, 0.5, 0.05,\n       fract (50. * qHit.x)));\n  } else if (idObj == idWng) {\n    col = cBdy * (1. - step (0.004, qHit.y) * smoothstep (0., 0.04, qHit.z) *\n       0.2 * SmoothBump (0.3, 0.5, 0.05, fract (100. * qHit.x)));\n  } else if (idObj == idHead) {\n    s = length (qHit.yz - vec2 (0.02, -0.05));\n    col = (s > 0.03) ? cBdy : ((abs (s - 0.015) < 0.003) ? vec3 (1., 1., 1.) :\n       vec3 (0., 0.9, 0.));\n  } else if (idObj == idBk) col = vec3 (1., 0., 0.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, nDotL, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    nDotL = max (0., dot (vn, ltDir));\n    if (idObj != idPol) col = ObjCol ();\n    else col = (dot (ro, vn) < 0.) ? vec3 (0.1, 0.1, 0.4) : vec3 (0.6, 0.6, 0.7);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = col * (0.2 + 0.8 * nDotL * nDotL) +\n       0.2 * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  } else col = vec3 (0., 0., 0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (abs (uv.x) < 1.) {\n    az = 0.;\n    el = -0.1 * pi;\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += pi * mPtr.y;\n    } else {\n      az -= 0.03 * pi * tCur;\n      el -= 0.3 * pi * sin (0.02 * pi * tCur);\n    }\n    vuMat = StdVuMat (el, az);\n    szFac = 0.9 + 7.1 * SmoothBump (0.2, 0.8, 0.15, mod (0.05 * tCur, 1.));\n    dRot = -0.5 * tCur;\n    ro = vuMat * vec3 (0., 0., -11. - szFac);\n    zmFac = 3.;\n    dstFar = 50.;\n    ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = vec3 (0., 0., 0.1);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKyzV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[861, 861, 885, 885, 1431], [1433, 1433, 1467, 1467, 2547], [2549, 2549, 2571, 2571, 3240], [3242, 3242, 3275, 3275, 3459], [3461, 3461, 3482, 3482, 3737], [3739, 3739, 3776, 3776, 4005], [4007, 4007, 4023, 4023, 4698], [4700, 4700, 4735, 4735, 5278], [5280, 5280, 5336, 5336, 6592], [6594, 6594, 6629, 6629, 6691], [6693, 6693, 6737, 6737, 6812], [6814, 6814, 6859, 6859, 6951], [6953, 6953, 6998, 6998, 7036], [7038, 7038, 7095, 7095, 7178], [7180, 7180, 7216, 7216, 7422], [7424, 7424, 7454, 7454, 7567], [7569, 7569, 7600, 7600, 7664]], "test": "untested"}
{"id": "ftVyzG", "name": "rotating rainbow square", "author": "ufffd", "description": "Generating a basic animation to use as input for stable-diffusion. \nResults: https://www.instagram.com/p/Ch2iiZ9JZ0Z/", "tags": ["square", "rainbow", "rotating"], "likes": 2, "viewed": 139, "published": 3, "date": "1661839819", "time_retrieved": "2024-07-30T16:33:46.889418", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = ( 2.*fragCoord - R ) / R.y;          // [-1,1] vertically\n    \n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i<2; i++) {\n        float fi = float(i);\n        vec2 suv = rotate(uv,iTime*PI/3.); // +fi*PI/8.\n        // suv *= 1.+sin(iTime+fi)*0.1;\n        suv *= 1.+fi*0.1;\n\n        float sq = max(abs(suv.x), abs(suv.y));\n        sq = SS(0.5,abs(sq-.15));\n        sq = cubicPulse(0.5,0.05,sq)*5.;\n        col += sq*spectral_zucconi6(fract(iTime/9.+fi/20.)*300.+400.);\n        // col *= vec3(sq);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define SS(a,b) smoothstep(0.5-a,0.5+a,b)\n#define PI 3.141592653589793\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat saturate (float x){\n    return min(1.0, max(0.0,x));\n}\n\nvec3 saturate (vec3 x){\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// --- MATLAB Jet Colour Scheme ----------------------------------------\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 713]], "test": "untested"}
{"id": "slGyzy", "name": "Kaplan 5-Color Squares (634 ch)", "author": "fenix", "description": "This is an implementation of an animation from Craig S. Kaplan's \"Animated Color Mappings of Hinged Squares\" https://isohedral.ca/hinged-squares/ that appeared in the Bridges 2021 conference. Originally intended for golfing, but maybe I didn't succeed?", "tags": ["loop", "squares", "golf", "reproduction", "swirled", "hinged"], "likes": 27, "viewed": 357, "published": 3, "date": "1661838224", "time_retrieved": "2024-07-30T16:33:47.715210", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part of my Hinged Squares series:\n\n// Fathauer Hinged Squares    https://www.shadertoy.com/view/ftVyWw\n// Kaplan Hinged Squares      https://www.shadertoy.com/view/NtGcDm\n// Kaplan 5-Color Squares     https://www.shadertoy.com/view/slGyzy\n\n// This is the third and most complex of my hinged squares shaders. The question\n// this answers is, can you color the squares of the Kaplan Hinged Squares with\n// only five colors? Professor Kaplan figured out this beautiful way to do it,\n// and I hope he doesn't mind my shadertoy recreation.\n\n// https://isohedral.ca/hinged-squares/\n// https://archive.bridgesmathart.org/2021/bridges2021-23.pdf\n\n// I'm fairly pleased that I was able to get this down to 906 characters from the\n// the original's 2002. But it's still quite a hefty lad yet. I feel like there \n// are probably much more efficient ways to compute the diamonds and all the colors,\n// but I just haven't figured it out.\n\n// OTOH this is probably bordering on being a bit too complex for fun golfing,\n// so I won't be offended if the usual gang decides to skip this one.\n\n//*\n// From SnoothethDuckDuck: 634 chars (-212!)\n#define C(i) vec4[](vec4(1, .6, .2, 1),  \\\n                    o-o,                 \\\n                    vec4(.9, .2, .2, 1), \\\n                    o/o,                 \\\n                    vec4(0, .6, .5, 1))  \\\n                    [int(i) % 5]\n\nvoid mainImage( out vec4 o, vec2 u )\n{   \n    float x,\n          y, \n          a = modf(iTime * .3, x) * .78,\n          m = cos(a)*.2,\n          n = sin(a)*.2,\n          c = 4.*m*n+.2; // double angle formula\n    \n    o.xyz = 1./iResolution;\n    \n    u = (2./o.xy - 4.*u) * o.y * (mod(x, 2.) - .5) \n      + vec2(sin(4.*a) * .04 + .1, -.1) \n      - 5.*m*n;\n    \n    mat2 M = mat2(cos(vec4(0,11,33,0) - a));\n    u *= M;\n      \n    vec2 D = mod(.5*u/c, 5.),\n         b = mod(u = mod(u, c+c), c) - .5*c,         \n         r = round(D), // floor(D + .5)\n         f = floor(D),\n         A = abs(u - c);\n    \n    x = A.x, y = A.y;\n    o = mix(\n        // color 1\n        C(\n          y > c-m && x > c-n ? 4.5  + r.y + D+r+r \n          : \n          y < m   && x < n   ? 12.  + f.y - D-f\n          : \n          x < m   && y > c-n ? 3.   + r.y + D+f+f \n          : \n          x > c-m && y < n   ? 12.5 + f.y - D-r\n          : \n          u/u\n        ), \n        \n        // color 2\n        C(4 * int(D+=D) + 8 * int(D.y)),\n        \n        // mix amount\n        smoothstep(o.y, -o.y,\n        length(max(u = abs(u.x>c ^^ u.y>c ? b * M : M * b) - .1, 0.)) \n      + max(u.x, u.y)));\n}\n\n\n// From fenix: 846 chars (-60)\n/*\n#define C(i) vec4[](vec4(1, .6, .2, 1),vec4(0),vec4(.9, .2, .2, 1),vec4(1),vec4(0, .6, .5, 1))[(i) % 5]\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = 1./iResolution;\n    float i, a = modf(iTime * .3, i) * .78; // .78 = PI / 4\n          \n    u = (2./R.xy - 4.*u) * R.y * (mod(i, 2.) - .5) + vec2(sin(a * 4.) * .04 + .1, -.1) - sin(a + a) * .1;\n        \n    mat2 M = mat2(cos(vec4(0,11,33,0) - a));\n    u *= M;\n    \n    float c = abs(sin(a + a)) * .08 + .2,\n          m = cos(a)*.2,\n          n = sin(a)*.2;\n    \n    vec2 D = mod(u / (c+c), 5.),\n         q = u = mod(u, c+c),\n         b = mod(u, c) - c * .5;\n\n    O = mix(\n        ((q.y < m || q.y > c+c - m) && (q.x < n || q.x > c+c - n)) ?\n            C(int(D.y + 3.5) + int(D.x + 2.5) * 3) :\n        (q.y - c > -m && q.y - c < m && q.x - c > -n && q.x - c < n) ?\n            C((int(7. - D.y) * 2 + int(5. - D.x) + 2) * 2) :\n        (q.x - c > -m && q.x - c < m) && (q.y < n || q.y > c+c - n) ?\n            C(int(D.y + 2.5) + int(D.x + 2.) * 3) :\n        ((q.x < m || q.x > c+c - m) && (q.y - c > -n && q.y - c < n)) ?\n            C((int(8. - D.y) * 2 + int(7.5 - D.x)) * 2) : C(1),\n            \n        C(int(mod(D.x*-2., 5.)) + 3 * int(mod(D.y+D.y, 5.)) + 1),\n               smoothstep(-R.y, R.y,\n               -length(max(q = abs(u.x > c ^^ u.y > c ? b * M : M * b) - .1,0.)) - min(max(q.x,q.y),0.)));\n}\n*/\n\n// My first attempt at golfing this shader: 906 chars\n/* \nvec3 C[5] = vec3[](\n    vec3(1., .6, .2),\n    vec3(0),\n    vec3(.9, .2, .2),\n    vec3(1),\n    vec3(0., .6, .5));\n\n#define M mat2(cos(-a), sin(-a), -sin(-a), cos(-a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = 1./iResolution;\n    float a = mod(iTime * .3, 1.57); // 1.57 = PI / 2\n          \n    u = vec2(R.y / R.x, 1.) - 2.*u * R.y;\n    \n    if (a > .78) u = -u, a -= .78; // .78 = PI / 4\n         \n    u += vec2(sin(a * 4.) * .04 + .1, -.1) - sin(a + a) * .1;\n    u *= M;\n    \n    float c = abs(sin(a + a)) / 12.5 + .2,\n          m = cos(a)*.2,\n          n = sin(a)*.2;\n    \n    vec2 e, D = mod(u / (c+c), 5.),\n         q = u = mod(u, c+c);\n\n    a = u.x > c ^^ u.y > c ? -a : a;\n    u = mod(u, c);\n\n    // Lay down the colors for the diamonds\n    O = vec4(\n        ((q.y < m || q.y > c+c - m) && (q.x < n || q.x > c+c - n)) ?\n            C[(int(D.y + 3.5) + int(D.x + 2.5) * 3) % 5] :\n        (q.y - c > -m && q.y - c < m && q.x - c > -n && q.x - c < n) ?\n            C[(int(7. - D.y) * 2 + int(5. - D.x) + 2) * 2 % 5] :\n        (q.x - c > -m && q.x - c < m) && (q.y < n || q.y > c+c - n) ?\n            C[(int(D.y + 2.5) + int(D.x + 2.) * 3) % 5] :\n        ((q.x < m || q.x > c+c - m) && (q.y - c > -n && q.y - c < n)) ?\n            C[(int(8. - D.y) * 2 + int(7.5 - D.x)) * 2 % 5] : C[1], 0.0);\n    \n    e = abs(M * (u - c * .5)) - .1;\n    \n    // Add the squares on top\n    O.xyz = mix(O.xyz,\n                C[(int(mod(D.x*-2., 5.)) + 3 * int(mod(D.y+D.y, 5.)) + 1) % 5],\n                smoothstep(-R.y, R.y, -length(max(e,0.)) - min(max(e.x,e.y),0.)));\n}\n*/\n\n/* Original, pre-golf: 2002 characters\nvec3 colors[5] = vec3[](vec3(251.0, 176.0, 64.0) / 255.0, vec3(0.0, 0.0, 0.0), vec3(239.0, 65.0, 54.0) / 255.0, vec3(1.0, 1.0, 1.0), vec3(0.0, 167.0, 156.0) / 255.0);\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotAng(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    float a = mod(iTime * 0.3, PI * 0.5);\n    if (a < PI * 0.25) p = -p;\n    a = mod(a, PI * 0.25);\n    \n    float a0 = a;\n     \n    p -= sin(a + a) * 0.1;\n    p.x += sin(a* 4.) * 0.04;\n    p += vec2(0.1, -0.1);\n    p *= rotAng((-a));\n    vec2 center = abs(vec2(sin(a + a))) / 25.0 + 0.1;\n\n    vec2 pa = p;\n    p = mod(p, 4.0 * center);\n    vec2 p0 = p;\n    if (p.x > 2.0 * center.x)\n    {\n        p.x -= 2.0 * center.x;\n        a = -a;\n    }\n    if (p.y > 2.0 * center.x)\n    {\n        p.y -= 2.0 * center.x;\n        a = -a;\n    }\n    mat2 r = rotAng(-a);\n    \n    if (p0.y < cos(a0)*0.2 || p0.y > center.x* 4. - cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * 2.5/(10.*center), 5.) + 3.5)\n        + int(mod(pa.x * 2.5/(10.*center), 5.) + 2.5) * 3) % 5];\n        if (p0.x <= sin(a0)*0.2 || p0.x >= center.x * 4. - sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    if (p0.y - center.x*2. >= -cos(a0)*0.2 && p0.y - center.x*2. <= cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * -2.5/(10.*center) + 2., 5.))*2 +\n        int(mod(pa.x * -2.5/(10.*center), 5.))+ 2)*2 % 5];\n        if (p0.x - center.x*2. >= -sin(a0)*0.2 && p0.x - center.x*2. <= sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    if (p0.x - center.x*2. > -cos(a0)*0.2 && p0.x - center.x*2. < cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * 2.5/(10.*center), 5.) + 2.5)\n        + int(mod((pa.x - center.x*2.) * 2.5/(10.*center), 5.) + 2.5) * 3) % 5];\n        if (p0.y <= sin(a0)*0.2 || p0.y >= center.x * 4. - sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    \n    if (p0.x < cos(a0)*0.2 || p0.x > center.x*4. - cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * -2.5/(10.*center) + 3., 5.))*2 +\n        int(mod((pa.x - center.x*2.) * -2.5/(10.*center), 5.))+ 2)*2 % 5];\n        if (p0.y - center.x*2. >= -sin(a0)*0.2 && p0.y - center.x*2. <= sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    \n    vec3 blockColor = colors[(int(mod(pa.x * -5. / (10. * center), 5.)) + 3*int(mod(pa.y * 5./(10.*center), 5.)) + 1) % 5];//0.5 + vec3(0.5)*inv;\n    fragColor.xyz = mix(fragColor.xyz, blockColor, smoothstep(-0.001, 0.001, -sdBox(r * (p - center), vec2(0.1))));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGyzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "NtGcDm", "name": "Kaplan Hinged Squares (279 ch)", "author": "fenix", "description": "This is an implementation of an animation from Craig S. Kaplan's \"Animated Color Mappings of Hinged Squares\" https://isohedral.ca/hinged-squares/ that appeared in the Bridges 2021 conference. Is this too complicated for golfing? Or am I just a n00b?", "tags": ["loop", "squares", "golf", "reproduction", "hinged"], "likes": 17, "viewed": 282, "published": 3, "date": "1661838214", "time_retrieved": "2024-07-30T16:33:48.556960", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part of my Hinged Squares series:\n\n// Fathauer Hinged Squares    https://www.shadertoy.com/view/ftVyWw\n// Kaplan Hinged Squares      https://www.shadertoy.com/view/NtGcDm\n// Kaplan 5-Color Squares     https://www.shadertoy.com/view/slGyzy\n\n// This is the second, both in order and in complexity, of my hinged square shaders.\n// Basically, Professor Kaplan noticed that if you took the color out of Robert Fathauer's\n// hinged squares, you could repeat the loop after only half of the original animation. I\n// hope he considers this an homage to his work.\n\n// https://isohedral.ca/hinged-squares/\n// https://archive.bridgesmathart.org/2021/bridges2021-23.pdf\n\n// I tried to golf this one, but I think I should have been able to do better. I bet\n// one of the golfing experts on this site will squeeze this down into a tweet in no time. :)\n\n// From coyote: 279 chars (-3)\n//*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2  M = mat2(cos(mod(iTime/2.,.78) + vec4(0,11,33,0)));\n    O = iResolution.yyyx*.5;\n    vec2  N = M*M[0], // == vec2( cos(iTime), sin(iTime) )\n          s = .08*N.yy,\n          S = mod( u = mod(((u-O.wx)/O.x - vec2(-.1,.1 + s*N) + s/.8) * M, (s+=.2)+s) - s, s) - s*.5;        \n    N = max(S = abs( u.x*u.y<0.?M*S:S*M ),.1);\n    O *= N.x+N.y - min(max(S.x,S.y),.1)-.104;\n}\n/**/\n\n// From iapafoto: 283 chars (-1)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2  M = mat2(cos(mod(iTime/2.,.78) + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy*.5,\n          N = M*M[0], // == vec2( cos(iTime), sin(iTime) )\n          s = .08*N.yy,\n          S = mod( u = mod(((u-R)/R.y + vec2(.1,-.1 - s*N) + s/.8) * M, (s+=.2)+s) - s, s) - s*.5;        \n\n    O = (   length(   max(S = abs(  u.x * u.y < 0. ?   M*S : S*M ) - .1 ,0.)) \n                    - min(max(S.x,S.y),0.)\n                    - .004\n        ) * R.yyyy;\n}\n/**/\n\n// From coyote: 284 chars (-25)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2  M = mat2(cos(mod(iTime/2.,.78) + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy*.5,\n          N = M*M[0], // == vec2( cos(iTime), sin(iTime) )\n          s = .08*N.yy,\n          a = s + .2,\n          S = mod( u = mod( (   (u-R) / R.y\n                              + vec2(.1, -.1 - s*N ) + s/.8\n                            ) * M\n                          , a+a ) -a\n                 ,a ) - a*.5;        \n\n    O = (   length(   max(S = abs(  u.x * u.y < 0. ?   M*S : S*M ) - .1 ,0.)) \n                    - min(max(S.x,S.y),0.)\n                    - .004\n        ) * R.yyyy;\n}\n/**/\n\n// From iapafoto and coyote: 309 chars (-5)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = mod(iTime, 1.57), s = sin(t),  a = abs(s) * .08 + .2; \n    mat2  M = mat2(cos(t/2. + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy*.5, S;\n    u = mod( S = mod( (   ( u - R ) / R.y\n                         + .1* ( vec2(1, -1. - s*cos(t) *.8 ) + s )\n                      ) * M\n                    , a+a ) -a\n           ,a) - a*.5;        \n\n    O = ( abs(   length( max(u = abs(  S.x * S.y < 0. ?   M*u :u*M ) - .1 ,0.)) \n               + min(max(u.x,u.y),0.)\n             ) - .004\n        ) * R.yyyy;\n}\n/**/\n\n// From FabriceNeyret2: 314 chars (-16)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = mod(iTime, 1.57), s = sin(t),  a = abs(s) / 12.5 + .2; \n    mat2  M = mat2(cos(t/2. + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy, S;\n    u = mod( S = mod( (   ( u+u - R ) / R.y\n                         + .1* ( vec2(1, -1. - s*cos(t) *.8 ) + s )\n                      ) * M\n                    , a+a ) -a\n           ,a) - a*.5;        \n\n    O = ( abs(   length( max(u = abs(  S.x * S.y < 0. ?   M*u :u*M ) - .1 ,0.)) \n               + min(max(u.x,u.y),0.)\n             ) - .004\n        ) * R.y *.5 + O*0.;\n}\n/**/\n\n// From FabriceNeyret2: 330 chars (-49)\n/*\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float a = mod(iTime*.5, .78), s = sin(a+a); \n    mat2  M = mat2(cos(a + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy,\n          u = (   ( U+U - R ) / R.y\n                + .1* ( vec2(1, -1. - s*cos(a+a) *.8 ) + s )\n              ) * M;\n    a = abs(s) / 12.5 + .2;\n    u = mod(u, a+a) -a;\n    u.x * u.y < 0. ? M = inverse(M) :M; \n\n    O = ( abs(   length( max(u = abs( (mod(u,a) - a*.5) *M ) - .1 ,0.)) \n               + min(max(u.x,u.y),0.)\n             ) - .004\n        ) * R.y *.5 + O*0.;\n}\n/**/\n\n// My golfing attempt: 379 chars\n/*\n#define r(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution;\n    u = 2.0 * u/R.y - vec2(R.x/R.y, 1.);\n    \n    float c, a = mod(iTime * .5, .78); // PI / 4\n    \n    u += vec2(.1, -.1 - sin(a * 4.) * .04) + sin(a + a) * .1;\n    u *= r(a);\n    \n    c = abs(sin(a + a)) / 12.5 + .2;\n    \n    u = mod(u, c+c);\n    \n    a = u.x > c ^^ u.y > c ? -a : a;\n    \n    u = mod(u, c);\n    \n    vec2 d = abs(r(-a) * (u - c*.5)) - .1;\n    \n    O *= 0.;\n    O += max(0., abs(length(max(d,0.)) + min(max(d.x,d.y),0.)) - .004) * R.y * .5;\n}\n/**/\n\n// Original pre-golf: 790 chars\n/*\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotAng(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    p.x = -p.x;\n    \n    float a = mod(iTime * 0.5, PI * 0.25);\n    vec2 p0 = p;\n    \n    p += sin(a + a) * 0.1;\n    p.y -= sin(a* 4.) * 0.04;\n    p += vec2(0.1, -0.1);\n    p *= rotAng((a));\n    vec2 center = abs(vec2(sin(a + a))) / 25.0 + 0.1;\n    \n    p = mod(p, 4.0 * center);\n    if (p.x > 2.0 * center.x)\n    {\n        p.x -= 2.0 * center.x;\n        a = -a;\n    }\n    if (p.y > 2.0 * center.x)\n    {\n        p.y -= 2.0 * center.x;\n        a = -a;\n    }\n    mat2 r = rotAng(-a);\n\n    fragColor = vec4(0);\n    \n    fragColor.xyz += max(0.000, (abs(sdBox(r * (p - center), vec2(0.1)))) - 0.004) * iResolution.y * 0.5 ;\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGcDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1049, 1084, 1122, 1122, 1501]], "test": "untested"}
{"id": "ftVyWw", "name": "Fathauer Hinged Squares (225 ch)", "author": "fenix", "description": "This animation was invented by Robert Fathauer, responding to the #SwirledSeries a few years ago. AFAICT it never made it into a shadertoy, so I think it's fair to recreate it here.\n\nhttps://twitter.com/RobFathauerArt/status/1329125556252594178", "tags": ["checkerboard", "golf", "reproduction", "swirled"], "likes": 11, "viewed": 260, "published": 3, "date": "1661838205", "time_retrieved": "2024-07-30T16:33:49.315931", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part of my Hinged Squares series:\n\n// Fathauer Hinged Squares    https://www.shadertoy.com/view/ftVyWw\n// Kaplan Hinged Squares      https://www.shadertoy.com/view/NtGcDm\n// Kaplan 5-Color Squares     https://www.shadertoy.com/view/slGyzy\n\n// This is the first, simplest of the hinged squares. I was reading about the Swirled Series\n// (https://isohedral.ca/swirled-series-the-result) and came across this entry that I really\n// liked (https://twitter.com/RobFathauerArt/status/1329125556252594178). I couldn't find\n// a shadertoy implementation so hopefully he doesn't mind if I put one here.\n\n// I feel like this is reasonably competantly golfed, but I'm sure others on this site will\n// put me to shame.\n\n// From coyote: 225 chars (-7)\n//*\nvoid mainImage( out vec4 O, vec2 u)\n{\n    float a = iTime,\n          c = abs(sin(a + a))*.08 + .2;\n    \n    O = .5\n       + min(0.\n            ,max(u= abs((mod(u= mod((u - (O.xy=.5*iResolution.xy)) / O.y\n                            ,c+c)-c\n                        ,c)-.5*c) * mat2(cos(a*(c= sign(u.x*u.y))\n                                         - vec4(0,11,33,0))))\n                ,u.y).x - .1) *.5*c * O.yyyy;\n}\n/**/\n\n// From Xor: 232 chars (-75)\n/*\nvoid mainImage( out vec4 O, vec2 u)\n{\n    float a = iTime,\n          c = abs(sin(a + a))*.08 + .2,\n          s;\n\n    u = mod((u - (O.xy=.5*iResolution.xy)) / O.y / c, 2.);\n    \n    s = sign(--u * u.y).x;\n    u = abs(mat2(cos(a*s + vec4(0,11,33,0))) * (fract(u)-.5));\n    \n    O = .5 + .5 * s * O.yyyy * min(0., max(u.x, u.y) * c - .1);\n}\n/**/\n\n// Original golfed version: 307 chars\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    float a = iTime,\n          c = abs(sin(a + a)) / 25. + .1,\n          s;\n\n    O = vec4(.5);\n    u = mod(.5 * (2. * u/R.y - vec2(R.x/R.y, 1.)) / c, 2.);\n    \n    s = sign((u.x - 1.) * (u.y - 1.));\n    a *= s;\n    u = fract(u);\n    u = abs(mat2(cos(a), sin(a), -sin(a), cos(a)) * ((u + u) * c - c)) - .1;\n    \n    O += s * R.y * O * min(0., length(max(u, 0.)) + min(max(u.x, u.y), 0.));\n}\n/**/\n\n// Completely pre-golfed version, 741 chars\n/*\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotAng(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    \n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n    \n    float inv = 1.0;\n    float a = iTime;\n    vec2 center = abs(vec2(sin(a + a))) / 23.0 + 0.1;\n\n    if (p.x < 0.0)\n    {\n        p.x = -p.x;\n        inv = -inv;\n    }\n    if (p.y < 0.0)\n    {\n        p.y = -p.y;\n        inv = -inv;\n    }\n    \n    p = mod(p, 4.0 * center);\n    if (p.x > 2.0 * center.x)\n    {\n        p.x -= 2.0 * center.x;\n        inv = -inv;\n        a = -a;\n    }\n    if (p.y > 2.0 * center.x)\n    {\n        p.y -= 2.0 * center.x;\n        inv = -inv;\n        a = -a;\n    }\n    \n    fragColor.xyz += vec3(0.5)*inv * smoothstep(-0.001, 0.001, -sdBox(rotAng(-a) * (p - center), vec2(0.1)));\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVyWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[918, 953, 990, 990, 1368]], "test": "untested"}
{"id": "7lyczV", "name": "Simple Combustion Engine", "author": "oneshade", "description": "A simple 4-stroke combustion engine. Set MAX_STROKES in common to 1 to see the cycle.", "tags": ["simple", "engine", "combustion", "4stroke"], "likes": 25, "viewed": 321, "published": 3, "date": "1661829001", "time_retrieved": "2024-07-30T16:33:50.067920", "image_code": "// Utilities\nvec2 solveJoint(in vec2 a, in vec2 b, in float ra, in float rb, in float config) {\n    vec2 ba = b - a;\n    float d2 = dot(ba, ba), d = sqrt(d2);\n    float offs = (d2 + ra * ra - rb * rb) / (2.0 * ra * d);\n    return a + (ba * offs + vec2(-ba.y, ba.x) * sqrt(max(0.0, 1.0 - offs * offs)) * config) * ra / d;\n}\n\nvec3 heatPalette(in float h) {\n    return pow(vec3(0.98, 0.93, 0.1), vec3(h));\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n     vec2 pa = p - a, ba = b - a;\n     return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTrapezoid(in vec2 p, in float r1, in float r2, in float he) {\n    vec2 k1 = vec2(r2, he);\n    vec2 k2 = vec2(r2 - r1, 2.0 * he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x - min(p.x,p.y < 0.0 ? r1 : r2), abs(p.y) - he);\n    vec2 cb = p - k1 + k2 * clamp(dot(k1 - p, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = cb.x < 0.0 && ca.y < 0.0 ? -1.0 : 1.0;\n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\n#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Setup\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(0.3, 0.3, 0.5);\n\n    // Timing\n    float speed = (1.0 - exp(-20.0 * iTime / MAX_STROKES)) * MAX_STROKES;\n    float time = iTime * speed;\n    float stroke = floor(mod(time, 4.0));\n    float strokeTime = fract(time);\n\n    // Cylinder\n    vec2 cylUv = uv - vec2(0.0, 1.5);\n    float cylDist = sdBox(cylUv - vec2(0.0, 1.6), vec2(0.25, 0.01));\n    cylDist = min(cylDist, sdBox(vec2(abs(cylUv.x) - 1.0, cylUv.y - 1.6), vec2(0.25, 0.01)));\n    cylDist = min(cylDist, sdBox(vec2(abs(cylUv.x) - 1.25, cylUv.y), vec2(0.01, 1.6)));\n    cylDist = min(cylDist, sdBox(vec2(abs(abs(cylUv.x) - 0.5) - 0.25, cylUv.y - 2.1), vec2(0.01, 0.5)));\n\n    // Random pattern to show where the cutaway is\n    float inside = sdBox(cylUv + vec2(0.0, 0.02), vec2(1.23, 1.58));\n    float stripes = mod(floor(uv.x + uv.y), 2.0);\n    drawSDF(inside, vec4(vec3(0.15 * stripes), 1.0));\n\n    // Gas flow in the engine\n    if (mod(stroke, 2.0) == 0.0) strokeTime = 1.0 - strokeTime; // Reverse\n    float squeeze = strokeTime * 0.925;\n    float gas = sdBox(cylUv - vec2(0.0, 0.28 + squeeze), vec2(1.23, 1.28 - squeeze));\n    float gasDensity = stroke == 0.0 ? mix(0.0, 0.5, strokeTime) : stroke == 3.0 ? 0.5 : mix(0.5, 1.0, strokeTime);\n    drawSDF(max(gas, inside), vec4(0.6, 0.6, 1.0, gasDensity));\n    if (mod(stroke, 2.0) == 0.0) strokeTime = 1.0 - strokeTime; // Revert\n\n    // Gas intake\n    if (stroke == 0.0) {\n        float gas = length(uv - vec2(-0.5, 3.2)) - strokeTime * 3.6;\n        float dropoff = 0.5 * smoothstep(0.0, -0.5, gas);\n        drawSDF(max(gas, inside), vec4(0.6, 0.6, 1.0, dropoff));\n    }\n\n    // Explosion\n    if (stroke == 2.0) {\n        vec3 explosionColor = heatPalette(strokeTime * 50.0);\n        float explosionStrength = 1.0 - strokeTime;\n        drawSDF(max(length(uv - vec2(0.0, 2.9775)) - strokeTime * 2.75, inside), vec4(explosionColor, explosionStrength));\n    }\n\n    // Finally draw the cylinder\n    drawSDF(cylDist, vec4(1.0));\n\n    // Camshaft\n    drawSDF(length(uv + vec2(0.0, 2.0)) - 1.25, vec4(0.05, 0.05, 0.05, 1.0));\n    drawSDF(length(uv + vec2(0.0, 2.0)) - 0.15, vec4(0.2, 0.2, 0.2, 1.0));\n\n    // Piston\n    vec2 pistonPos = vec2(0.0, 2.0 - abs(mod(stroke, 2.0) - strokeTime) * 1.85);\n    vec2 joint = solveJoint(pistonPos, vec2(0.0, -2.0), 3.075, 0.925, 2.0 * mod(stroke, 2.0) - 1.0);\n    drawSDF(sdLine(uv, pistonPos, joint) - 0.1, vec4(0.25, 0.25, 0.25, 1.0));\n    drawSDF(sdBox(uv - pistonPos, vec2(1.23, 0.3)), vec4(0.4, 0.4, 0.4, 1.0));\n\n    // Intake valve\n    float inState = stroke < 1.0 ? 1.0 - abs(1.0 - 2.0 * strokeTime) : 0.0;\n    drawSDF(sdTrapezoid(uv - vec2(-0.5, 3.08 - 0.3 * inState), 0.3, 0.15, 0.075), vec4(0.0, 1.0, 0.0, 1.0));\n\n    // Exhaust valve\n    float outState = stroke > 2.0 ? 1.0 - abs(1.0 - 2.0 * strokeTime) : 0.0;\n    drawSDF(sdTrapezoid(uv - vec2(0.5, 3.08 - 0.3 * outState), 0.3, 0.15, 0.075), vec4(1.0, 0.0, 0.0, 1.0));\n\n    // Spark plug\n    float sparkState = stroke == 2.0 ? strokeTime * 100.0 : 1000.0;\n    drawSDF(sdBox(uv - vec2(0.0, 2.9775), vec2(0.03, 0.075)), vec4(0.5, 0.25, 0.0, 1.0));\n    color += heatPalette(sparkState) * smoothstep(0.1, 0.0, length(uv - vec2(0.0, 2.9025)) - 0.02);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time) {\n    float speed = (1.0 - exp(-20.0 * time / MAX_STROKES)) * MAX_STROKES;\n    float realTime = time * speed;\n\n    // Spark plug firing\n    float sound = Hash11(time * 1000.0) * exp(-5.0 * mod(realTime - 2.0, 4.0));\n\n    // Intake and exhaust\n    float strokeTime = fract(realTime);\n    float cycleTime = mod(realTime, 4.0);\n    if (cycleTime < 1.0) sound += 0.1 * Hash11(time * 1000.0) * 6.75 * (1.0 - strokeTime) * pow(strokeTime, 2.0);\n    if (cycleTime > 3.0) sound += 0.1 * Hash11(time * 1000.0) * 6.75 * strokeTime * pow(1.0 - strokeTime, 2.0);\n\n    return vec2(sound);\n}", "sound_inputs": [], "common_code": "#define MAX_STROKES 200.0 // 6000RPM\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 95, 95, 322], [324, 324, 354, 354, 404], [406, 414, 461, 461, 571], [573, 573, 608, 608, 688], [690, 742, 811, 811, 1152], [1246, 1246, 1301, 1314, 4631]], "test": "untested"}
{"id": "flKyRK", "name": "dance house", "author": "jorge2017a2", "description": "dance house", "tags": ["dancehouse"], "likes": 8, "viewed": 248, "published": 3, "date": "1661826898", "time_retrieved": "2024-07-30T16:33:51.082208", "image_code": "//----------image\n//por jorge2017a2-\n//dance house----29-ago-2022\n#define MAX_STEPS 100\n#define MAX_DIST 500.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec2 cuartobase(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);  \n    p.y= opRep1D(p.y, 16.0 );\n    vec3 p0=p;\n    float dcuartoGr= sdBox(p, vec3(21.0,8.0,8.0) );\n    float dcuartoCh= sdBox(p, vec3(20.0,7.0,7.0) );\n    p.y=abs(p.y)-5.0;\n    float dLinea1= sdBox(p-vec3(0.0,0.0,-8.0), vec3(22.0,0.15,0.5) );\n    float dLinea2= sdBox(p-vec3(0.0,0.5,-8.0), vec3(22.0,0.15,0.5) );\n    \n    float dfin= Difference(dcuartoGr, dcuartoCh);\n    dfin= Difference(dfin, dLinea1);\n    dfin= Difference(dfin, dLinea2);\n    \n    p=p0;\n    p.x= opRep1D(p.x, 8.0 );\n    float dventana= sdBox(p, vec3(2.5,3.0,9.0) );\n    dfin= Difference(dfin, dventana);\n    res =opU2(res, vec2(dfin,41.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    \n    res =opU2(res, vec2(planeDist1,57.0));    \n    vec2 c1= cuartobase(p);\n    p.z=p.z-60.0;\n    p.x= opRep1D(p.x, 80.0 );\n    vec2 c2= cuartobase(p);\n    res =opU2(res, vec2(c1.x, 23.0));\n    res =opU2(res, c2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//iq cosine based palette, 4 vec3 params\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{   return a + b*cos( 6.28318*(c*t+d) );}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    //efecto\n    t=3.0*sin(iTime-4.5);\n    if(t>0.0)\n    colOut= pal(0.5, colOut, vec3(0.5,0.5,0.5), vec3(1.0,0.5,0.2), vec3(0.2,0.2,0.5)*1.5 );\n    \n    return colOut;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n   \n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n     \n     if (id_color==41)\n     {   vec3 colp = pal( sin(21.29*0.25), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n        return colp; \n     }\n        \n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n       \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n// Rotate around a circular path\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    ///vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0,-50.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 120.0, -50.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   \n   vec3 ro;\n   float pt=15.1*abs(sin(t0*0.5));\n   if (pt>0.0 && pt<5.0)\n       ro=vec3(0.0,18.0+2.0*sin(t0*0.5),-20.0);\n   if (pt>5.0 && pt<10.0)\n       ro=vec3(0.0,18.0+2.0*sin(t0*0.5),0.0);\n   if (pt>10.0 && pt<15.0)\n       ro=vec3(0.0,-15.0,-30.0);      \n       \n   ro= rotate_z(ro,radians(-10.*sin(t)));\n   //ro= rotate_x(ro,radians(-10.*sin(t)));\n   //ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x));\n   \n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   rd= rotate_x(rd,radians(-30.));\n   rd= rotate_y(rd,radians(45.0-45.0*sin(iTime*0.5)));\n  // \n  if (pt>10.0 && pt<15.0)\n   rd= rotate_x(rd,radians(-10.*sin(t*0.5)));\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[451, 451, 483, 483, 567], [569, 569, 613, 613, 640], [641, 641, 681, 681, 708], [709, 709, 754, 754, 782], [784, 784, 820, 820, 865], [867, 867, 901, 901, 997], [998, 998, 1032, 1032, 1123], [1124, 1124, 1158, 1158, 1249], [1252, 1252, 1277, 1277, 1938], [1940, 1940, 1965, 1965, 2309], [2311, 2311, 2335, 2335, 2497], [2499, 2499, 2547, 2547, 2826], [2828, 2828, 2872, 2872, 3193], [3195, 3195, 3232, 3232, 3489], [3491, 3532, 3600, 3600, 3640], [3642, 3642, 3732, 3732, 4840], [4842, 4842, 4874, 4874, 5078], [5080, 5128, 5156, 5156, 5344], [5346, 5346, 5416, 5416, 5848], [5850, 5850, 5877, 5877, 5966], [5968, 5968, 6026, 6026, 6074], [6076, 6076, 6099, 6099, 6211], [6213, 6213, 6244, 6244, 6864], [6866, 6899, 6927, 6927, 6997], [7000, 7000, 7057, 7057, 8125]], "test": "untested"}
{"id": "7tGcRV", "name": "Beat boxing", "author": "mrange", "description": "License CC0: Beat boxing\nBit of tinkering with the oldie but goldie mandelbox (based on Evilryus version): https://www.shadertoy.com/view/XdlSD4\nMusic by Ultrasyd (sadly no longer with us): https://soundcloud.com/ultrasyd/shitstep-game-boy\n", "tags": ["mandelbox"], "likes": 22, "viewed": 582, "published": 3, "date": "1661810223", "time_retrieved": "2024-07-30T16:33:51.870101", "image_code": "// License CC0: Beat boxing\n//  Bit of tinkering with the oldie but goldie mandelbox (based on Evilryus version):\n//   https://www.shadertoy.com/view/XdlSD4\n//  Music by Ultrasyd (sadly no longer with us): https://soundcloud.com/ultrasyd/shitstep-game-boy\n//  The music AFAIK is made on a Gameboy!\n\n//#define THEME0\n#define THEME1\n\n#define TOLERANCE       0.001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\nconst float cam_amp = 1.0;\n\nmat2 g_rot = ROT(0.0);\n\nfloat g_quad = 0.0;\nfloat g_beat = 0.0;\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float ndbuffer = dbuffer/sph.w;\n  vec3  rc = (ro - sph.xyz)/sph.w;\n  \n  float b = dot(rd,rc);\n  float c = dot(rc,rc) - 1.0;\n  float h = b*b - c;\n  if( h<0.0 ) return 0.0;\n  h = sqrt( h );\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  if( t2<0.0 || t1>ndbuffer ) return 0.0;\n  t1 = max( t1, 0.0 );\n  t2 = min( t2, ndbuffer );\n\n  float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n  float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n  return (i2-i1)*(3.0/4.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// -------------------------------------------------\n// Mandelbox - https://www.shadertoy.com/view/XdlSD4\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2 = 0.1;\nconst float folding_limit = 1.0;\nconst float scale = -2.5;\n\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp;\n    dz *= temp;\n  } else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp;\n    dz *= temp;\n  }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n  float dd = length(z)-mix(2.1, 2.2, g_beat);\n  vec3 offset = z;\n  float dr = 1.0;\n\n  for(int n = 0; n < 5; ++n) {\n    box_fold(z, dr);\n    sphere_fold(z, dr);\n\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.5;\n  }\n  \n  float d = (length(z))/abs(dr)-0.04;\n  dd = pmax(dd, -d, 0.5);\n  if (dd < d) {\n    g_quad = -1.0;\n  } else {\n    g_quad = 1.0;\n  }\n  g_quad = -g_quad;\n  d = min(d, dd);\n\n  return d;\n}\n// -------------------------------------------------\n\n\nfloat df(vec3 p) {\n  p.xz *= g_rot;\n  const float z = 1.0;\n  float d = mb(p/z)*z;\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 2.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORMTOL, 0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 lightPos0  = 2.5*vec3(1.0, 1.0, 1.0);\n  const vec3 lightPos1  = vec3(0.0);\n\n  const vec3 scol = HSV2RGB(vec3(0.0, 0.95, 0.005));\n  vec3 skyCol = vec3(0.0);\n  float a = atan(rd.x, rd.z);\n  for (int i = 0; i < 2; ++i) {\n    float off = texture(iChannel0, vec2(0.15*(a+3.0*float(i)+PI), 0.75)).x;\n\n    skyCol += scol/max(abs(rd.y+0.3+0.2*off)-0.001, 0.0);\n  }\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  float quad = g_quad;\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  float beat = g_beat;\n  float lsd1  = sphered(ro, rd, vec4(lightPos1, mix(2.3, 2.4, beat)), t);\n\n  const vec3 bcol0 = HSV2RGB(vec3(0.6, 0.6, 3.0));\n  const vec3 bcol1 = HSV2RGB(vec3(0.55, 0.8, 7.0));\n  vec3 bcol   = mix(bcol0, bcol1, beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return skyCol+gcol;\n  }\n\n  float d     = df(pos);  \n  vec3 nor    = normal(pos);\n  float fre   = 1.0+dot(nor, rd);\n  fre *= fre;\n  fre *= fre;\n\n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n  float spe0  = pow(max(dot(reflect(rd, nor), ld0), 0.), 10.0);\n\n\n  vec3 col = vec3(0.0);\n  quad = -quad;\n  const vec3 black = vec3(0.0);\n#if defined(THEME0)\n  const vec3 dcol0 = HSV2RGB(vec3(0.6, 0.5, 1.0));\n  const vec3 dcol1 = black;\n#elif defined(THEME1)\n  const vec3 dcol0 = HSV2RGB(vec3(0. , 0.75, -0.25));\n  const vec3 dcol1 = HSV2RGB(vec3(0.08, 1.0, 1.0));\n#else\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = dcol0;\n#endif\n  col += dif0*dif0*sha0*mix(dcol0, dcol1, 0.5+0.5*quad);\n  col += spe0*bcol*bs*sha0;\n  col += gcol;\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float fft = 0.0;\n  fft += texture(iChannel0, vec2(0.3, 0.25)).x;\n  fft += texture(iChannel0, vec2(0.2, 0.25)).x;\n  fft += texture(iChannel0, vec2(0.1, 0.25)).x;\n  fft /= 3.0;\n\n  float beat = tanh_approx(8.0*max(fft-0.5, 0.0));\n  beat *= beat;\n  beat *= beat;\n  \n  g_beat = beat;\n\n  g_rot = ROT(-0.1*TIME-0.1*beat);\n  vec3 cam  = 5.0*vec3(1.0, 0.5, 1.0);\n  vec3 dcam = normalize(vec3(0.0) - cam);\n\n  vec3 ro = cam;\n  vec3 ww = dcam;\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = cross(ww,uu);\n  float rdd = tan(TAU/mix(5.5, 5.0, beat*(0.5+0.8*length(p))));\n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p);\n  col += 2.0*smoothstep(1.0, 0.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 29680, "src": "https://soundcloud.com/ultrasyd/shitstep-game-boy?si=7d4cbcb348ce453f8849ac639a37b790&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGcRV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[756, 756, 778, 778, 924], [1227, 1287, 1315, 1335, 1411], [1413, 1535, 1593, 1593, 2044], [2046, 2146, 2185, 2185, 2270], [2272, 2360, 2399, 2399, 2428], [2662, 2662, 2710, 2710, 2948], [2950, 2950, 2995, 2995, 3054], [3056, 3056, 3074, 3074, 3487], [3543, 3543, 3561, 3561, 3642], [3645, 3645, 3699, 3699, 3894], [3896, 3896, 3919, 3919, 4127], [4129, 4129, 4206, 4206, 4506], [4508, 4508, 4539, 4539, 6337], [6339, 6339, 6360, 6360, 7033], [7035, 7135, 7154, 7154, 7241], [7243, 7350, 7376, 7376, 7560], [7562, 7562, 7617, 7617, 7860]], "test": "untested"}
{"id": "slGyRV", "name": "Temporal Flowmap", "author": "gehtsiegarnixan", "description": "A simple Trial of how vanilla flowmap looks in a situation similar to my directional flow", "tags": ["flow", "advection", "flowmap"], "likes": 3, "viewed": 214, "published": 3, "date": "1661807350", "time_retrieved": "2024-07-30T16:33:52.938245", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nStandart Temporal Flowmap in a similar environment to my directional flow \nimplementations. Two textures are moved by a motion vector of alternating \nstrength, so that resetting the motion back to the origin is masked by the \nalternate texture.\n\nIf you want better looking Flowmap try Directional Flow:\nhttps://www.shadertoy.com/view/7dtBWl\n\nCatlikecoding has a nice tutorial explaining how Temporal Flowmaps works:\nhttps://catlikecoding.com/unity/tutorials/flow/texture-distortion/\n*/\n\n// smooth hill like tiling\nfloat hills(vec2 uv) {\n    vec2 d = sin((uv-0.5)*3.142); //remove pi sized grid\n    return (d.x+d.y)*0.25+0.5;// add and rescale to 0-1\n}\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nfloat smoothValue(float x) {\n    x = clamp(x, 0.0, 1.0); // prevents out of bounds and some float errors\n    return x * x * (3.0 - 2.0 * x); // smoothstep(0,1,x)\n}\n\n// temporal Flowmap\nvec4 flowmap(sampler2D tex, vec2 uv, vec2 direction, float time) {\n\n    // generate timers \n    float progressA = fract(time)-0.5;\n    float progressB = fract(time +0.5)-0.5;\n    \n    // Offset each new phase\n    vec2 jump = vec2(0.248, 0.201);\n    vec2 offsetA = (time - progressA) * jump;\n    vec2 offsetB = (time - progressB) * jump +0.5;\n    \n    // sample color texture using different timers to scale offset strength\n    vec4 colorA = texture(tex, uv -progressA *direction +offsetA);\n    vec4 colorB = texture(tex, uv -progressB *direction +offsetB);\n    \n    // Generate 0-1 weight for interpolation\n    float weight = abs(progressA*2.); \n    \n    // Apply a little bit of contrast for faster transitions\n    //weight = smoothValue(weight);\n    \n    // Interpolate the two offset samples\n    return mix(colorA, colorB, weight);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime* 0.5; // flow speed multiplier\n    float strength = 0.7; // flow distrotion strength\n    float scale = 8.0;  // scale of the \"wave\" texture\n    \n    //square UV coords\n    vec2 uv = fragCoord/iResolution.y; \n    \n    // Sample noise\n    vec4 noise = texture(iChannel1, uv*0.1);\n    \n    // Generate 2D Vector Field range -1 t0 1\n    vec2 direction = noise.xy *2.-1.;\n    direction *= -strength; // scale by strength\n    \n    vec3 flow = flowmap(iChannel0, uv*scale, direction, time).xyz;\n    \n    flow += vec3(0.0,0.2,0.5); //adding arbitrary watery color\n    \n    fragColor = vec4(flow,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGyRV.jpg", "access": "api", "license": "mit", "functions": [[1570, 1597, 1619, 1619, 1734], [1736, 1806, 1834, 1834, 1969], [1971, 1991, 2057, 2082, 2827], [2829, 2829, 2885, 2885, 3503]], "test": "untested"}
{"id": "7tGczK", "name": "ad", "author": "dannn", "description": "ad", "tags": ["ad"], "likes": 7, "viewed": 256, "published": 3, "date": "1661804917", "time_retrieved": "2024-07-30T16:33:53.766032", "image_code": "// Simplified lighting of clouds\n\n// Iterating on the ideas I used for \"Fishermen at sea\" and \"Distress Flare\"\n// https://www.shadertoy.com/view/tdKcWD\n// https://www.shadertoy.com/view/3dGyRc\n\n// They were in turn inspired by \"Clouds\" by iq,\n// who uses a non-physical lighting where light intensity\n// is a function of the density difference between the current\n// point and a point further toward the source.\n// https://www.shadertoy.com/view/XslGRr\n\n#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//#define T(p) smoothstep(0.,1.,textureLod(iChannel0,(p)/256.,0.).r)\n#define T(p) textureLod(iChannel0,(p)/256.,0.).r\n\nfloat fbm(vec2 p)\n{\n    p += T(p.yx*5. + iTime*0.1)*0.1;\n    return T(p)/2. + T(p*2.)/4. + T(p*4.)/8. + T(p*8.)/16. + T(p*16.)/32. + T(p*32.)/64.;\n}\n\n\nfloat density(vec2 p) \n{\n    return smoothstep(0.2,0.8,fbm(p-0.1*iTime))*3.;\n}\n\n\nfloat light(vec2 p, vec3 source)\n{\n    float dist = length(source - vec3(p,0));\n    float dist2D = length(source.xy-p);\n    //float lerpFactor = 1.0/dist;\n    float T = 1.; // Integrate transmittance along the trajectory\n    float d1 = density(p);\n    float STEPS = 3.;\n    float MAXL = 0.25;\n    for(float lerpFactor = 0.; lerpFactor<MAXL; lerpFactor+=MAXL/STEPS)\n    {\n        vec2 q = mix(p, source.xy, lerpFactor);\n        float d2 = density(q);\n        //T *= exp(-d2 * 0.1 * dist2D*exp(-lerpFactor*10.)*10.);\n        // Approximate version. Cheaper?\n        T /= 1.0 + d2/STEPS*dist2D*exp(-lerpFactor*10.)*10.;\n    }\n    return d1*T/(dist*dist);\n}\n\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    vec2 p = (u*2.-iResolution.xy)/iResolution.y;\n\n    #if 1\n    // Camera motion inspired from Shane's shaders\n    // \"Precalculated Voronoi Heightmap\" by Shane\n    // https://www.shadertoy.com/view/ldtGWj\n    p *= 2.;\n    p.xy *= R(cos(0.32*iTime)+sin(0.1*iTime));\n    p.x -= iTime*2.;\n    p.y -= cos(iTime);\n    vec3 source = vec3(-iTime*2.+sin(iTime*0.62)*1.62,cos(iTime*2.0)*0.5,2.5 + cos(iTime*0.4));\n    vec3 source2 = vec3(-iTime*2.+cos(iTime),sin(iTime*1.62)*0.62,2.5 + sin(iTime));\n    #else\n    p *= 2.;\n    vec3 source = vec3(cos(iTime),sin(iTime*0.62),2.5);\n    #endif\n    \n    //vec3 col = vec3(fbm(p * 2.));\n    \n    vec3 col = light(p, source) * vec3(5.,6.,8.);\n    col += light(p, source2) * vec3(5.,6.,8.);\n    \n    #if 1\n    col = 1.-exp(-col);\n    #else\n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    #endif\n\n    // Output to screen\n    o = vec4(pow(col,vec3(0.45)),1.0);\n    o.rgb += (texture(iChannel0, u / iChannelResolution[0].xy + iTime).r * 2. - 1.) * .01;\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 621, 640, 640, 769], [772, 772, 796, 796, 850], [853, 853, 887, 887, 1506], [1509, 1509, 1550, 1550, 2713]], "test": "untested"}
{"id": "stVyDh", "name": "[♪]Garden of Thorns", "author": "Catzpaw", "description": "Cannon-Thurston map", "tags": ["fractal", "music"], "likes": 13, "viewed": 410, "published": 3, "date": "1661787968", "time_retrieved": "2024-07-30T16:33:54.823205", "image_code": "//---Garden of Thorns\n// by Catzpaw 2022\n\n//Image:Cannon-Thurston map (figure eight knot)\n\nconst float pi=acos(-1.);\nconst float tau=pi*2.;\n\nfloat beat(){return 1.+sin(iTime*tau*20.)*pow(1.-fract(iTime*BPM/60.+.1),6.)*.1;}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nvec4 mul(vec4 a,vec4 b){return vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w,a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z,a.x*b.z-a.y*b.w+a.z*b.x+a.w*b.y,a.x*b.w+a.y*b.z-a.z*b.y+a.w*b.x);}\nvec4 div(vec4 a,vec4 b){return mul(a,vec4(b.x,-b.yzw)/dot(b,b));}\nvec4 mobius(vec2 a,vec2 b,vec2 c,vec2 d,vec4 z){return div(mul(vec4(a,0,0),z)+vec4(b,0,0),mul(vec4(c,0,0),z)+vec4(d,0,0));}\n\nconst float sr3=sqrt(3.);\nconst vec2 w=vec2(.5,sr3*.5),iw=vec2(.5,-sr3*.5);\nconst vec2 o=vec2(0,0),c=vec2(1,0);\nbool t1(vec4 p){return p.x*-w.y>-p.y*w.x;}\nbool t2(vec4 p){return p.x*-w.y>p.y*w.x;}\nbool i2(vec4 p){return (p.x-1.)*w.y>-p.y*w.x;}\nbool t3(vec4 p){return (p.x-1.)*w.y>p.y*w.x;}\nbool i3(vec4 p){p-=vec4((c+ w)/3.,0,0);return dot(p.xyz,p.xyz)<1./3.;}\nbool i1(vec4 p){p-=vec4((c+iw)/3.,0,0);p*=p;return p.x+p.y+p.z<1./3.;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    uv/=dot(uv,uv);\n    uv*=rot(iTime*.14);\n    float at=iTime*tau*BPM/(60.*128.);\n    float bt=iTime*tau*BPM/(60.*64.);\n    float a=clamp(cos(at-.1)*80.,0.,1.);\n    float b=clamp(cos(bt-.1)*40.,0.,1.);\n    float z=.2+sin(iTime*.3)*.19;\n    vec2 p=vec2(cos(at)+.5,sin(bt))+z*uv*beat();\n    vec4 q=vec4(p,z*.01,0);\n    float h=0.,v=0.;\n    for(int i=0;i<40;i++){\n        if      (t1(q)){q=mobius(   c,-w, c,  iw,q);h+=.03;}\n        else if (i1(q)){q=mobius(  iw, w,-c,   c,q);h-=.03;}\n        else if (t2(q)){q=mobius(   c, w, o,   c,q);v-=1.;}\n        else if (i2(q)){q=mobius(   c,-w,-o,   c,q);v+=1.;}\n        else if (t3(q)){q=mobius( -iw,-w, w,-w-c,q);v-=1.;}        \n        else if (i3(q)){q=mobius(-w-c, w,-w, -iw,q);v+=1.;}\n        else break;\n        v-=mix(0.,q.z,a)+mix(-q.w,q.x,b);\n    }\n    fragColor = vec4(hsv(h+a*.3+b*.4+iTime*.02,.3,.5+b*.5+v*.1),1);\n}", "image_inputs": [], "sound_code": "//---Garden of Thorns\n// by Catzpaw 2022\n\n//Sound:scale sequencer\n\n//--- Scale Sequencer 3.5 by Catzpaw 2022\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =440.;\t//master tuning (Hz)\nconst float bpm  =BPM;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=2.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst int gateSeed=241; //random seed for gate generator;\nconst int noteSeed=147; //random seed for note generator;\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nconst uint[4] scl=uint[](0xca875320u,0xcb975420u,0xcb875320u,0xcb975320u); //minor,major,harmonic,melodic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\n//div1(2),scale2(2),div2(2),scale3(2),chord1(8),chord2(8),chord3(8)\n//chord:\n//  00-07:I,I,II,III,IV,V,VI,VII\n//  +00:triad\n//  +10:-3\t  +18:+3\n//\t+20:-5\t  +28:+5\n//\t+30:-3-5  +38:+3+5\n//\t+40:add9\n//\t+80:diatonic6(m6 or 6)\n//\t+c0:diatonic7(7 or M7)\n//  Example...symbol:C7 = key:C,scale:minor,chord:Im7+3 = 0x01+0x18+0xc0 = 0xd9\n// The length of the sequence is unlimited.\nconst int chordlen=16;const uint chordseq[chordlen]=uint[](\n\t0x01u,0x21u,0x31u,0x01u,0x01u,0x21u,0x31u,0x01u,\n    0x43u,0x22u,0xc2u,0x43u,0x04u,0x42u,0x82u,0x41u);\n\n//PATTERN (version 3)\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\n// You can set up to 256 patterns.\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x48008001u,0x470af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x36605711u,0x46529114u,0x56183614u,0x34151883u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973179u,0x36390710u,  //08-0B melody\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,  //0C-13 \n    0x70080868u,0x70086865u,0x18164656u,0x18164656u,  //14-17 accompaniment,bass\n    0x3238e232u,0x3138e132u,0x61382132u,0x9d1ce136u,  //18-1B sd+hh\n    0x01010101u,0x01c10181u,0x11c14581u,0x55d10591u); //1C-1F bd+fx\n\n//PATTERN SEQUENCE (version 3)\n// speed1(2),speed2(2),division(4),top1(4),pattern1(8),top2(4),pattern2(8)\n// speed    0:1x 1:2x 2:0.25x 3:0.5x\n// top      0-e ... auto inversion amount (0:no inversion 7:octave)\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2 8:half)\n// The length of each sequence is unlimited.\nconst int len1=8;const uint[len1] seq1=uint[]( //snare+hihat\n    0x18u,0x1au,0x18u,0x19u,0x18u,0x19u,0x18u,0x1bu);\nconst int len2=8;const uint[len2] seq2=uint[]( //bassdrum\n    0x1cu,0x1du,0x1cu,0x1du,0x1cu,0x1du,0x1cu,0x1fu);\nconst int len3=1;const uint[len3] seq3=uint[]( //bass\n    0x0616u);\nconst int len4=4;const uint[len4] seq4=uint[]( //chord\n    0x03u,0x03u,0x02u,0x03u);\nconst int len5=4;const uint[len5] seq5=uint[]( //accompaniment\n    0x0814u,0x0814u,0x0815u,0x0814u);\nconst int len6=16;const uint[len6] seq6=uint[]( //melody\n    0x04u,0x05u,0x06u,0x0bu,0x04u,0x05u,0x06u,0x07u,\n    0x04u,0x09u,0x08u,0x07u,0x04u,0x09u,0x0au,0x0bu);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.1);}\n\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n//Special instruments\nfloat fx1(float x){return (osc_c30(293.*x,7)+osc_c30(440.*x,7))*env_d(x,.12);}\nfloat fx2(float x){return osc_duty(3e2*x*(1.+x*3.),.5)*env_d(x,.07);}\nfloat sd(float x){return osc_nesnoise(x,11)*env_d(x,.25)+osc_duty(6./(x*.5+.1),.5)*.3*env_d(x,.05);}\n\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);ch=st<d?ch:get8(p,0);sc=st<d?sc:get2(p,12);scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return (imod((s*s1+s2)*gateSeed+67,173)&15)<=get4(pt,6)?-99:\n        imod(((s+s1+s2)*noteSeed+71),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n//TRACK 1 snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?sd(n.x)*vec2(.48,.62):vec2(0);\n    o+=(n.y==2.)?neshh(n.x,.08)*vec2(.15,.24):vec2(0);\n    o+=(n.y==3.)?neshh(n.x,.2)*vec2(.15,.24):vec2(0);\n    return o;\n}\n//TRACK 2 bassdrum,fx1,fx2\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*vec2(.4,.55):vec2(0);\n    o+=(n.y==2.)?fx1(n.x)*vec2(.45,.65):vec2(0);\n    o+=(n.y==3.)?fx2(n.x)*vec2(.35,.15):vec2(0);\n    return o;\n}\n//TRACK 3 bass\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?dutybass(freq(n.y+24.)*n.x,n.x)*vec2(.28,.31):vec2(0);\n    o+=(n.y>-50.)?lpfsaw(n.y+36.,n.x,sin(t*bpm*3.142/480.)*.3+.34,.9)*vec2(.2)*env_d(n.x,.6)*vec2(.88,.98):vec2(0);\n    return o;\n}\n//TRACK 4 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30chord(freq(n.y+36.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(2)+48.02)*n.x,n.x)*vec2(.30,.20):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(4)+36.01)*n.x,n.x)*vec2(.31,.19):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(6)+48.01)*n.x,n.x)*vec2(.32,.18):vec2(0);\n    return o;\n}\n//TRACK 5 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?c30bell(freq(n.y+72.)*n.x,n.x)*vec2(.30,.35):vec2(0);\n    return o;\n}\n//TRACK 6 melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?lpfc30(n.y+36.03,n.x,sin(t*bpm*3.142/64.)*.3+.4,.9,5)*vec2(.40,.50):vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):track1(t,l,s)*.7; //TRACK 1 snaredrum,closehh,openhh\n    o+=e?track2(t,l,s):track2(t,l,s)*.5; //TRACK 2 bassdrum,fx1,fx2\n    o+=  track3(t,l,s);                  //TRACK 3 bass\n    o+=  track4(t,l,s);                  //TRACK 4 chord\n    o+=e?track5(t,l,s):track5(t,l,s)*.8; //TRACK 5 accompaniment\n    o+=  track6(t,l,s);                  //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.35\n#define MASTER_PRESSURE 1.05\n#define DELAY_REPEAT    8\n#define DELAY_WET       0.50\n#define DELAY_FEEDBACK  0.88\n#define DELAY_TIME      0.153\n#define DELAY_STEREO    0.11\nvec2 mainSound(in int Samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    float ff=0.,p=0.;\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        o+=a*d*vec2(1.+p*ff,1.-p*ff);\n        ff=ff<0.?1.:-1.;\n        p+=DELAY_STEREO;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "common_code": "\n#define BPM 135.\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 154, 154, 222], [223, 223, 241, 241, 288], [289, 289, 323, 323, 400], [401, 401, 425, 425, 567], [568, 568, 592, 592, 633], [634, 634, 682, 682, 757], [871, 871, 887, 887, 913], [914, 914, 930, 930, 955], [956, 956, 972, 972, 1002], [1003, 1003, 1019, 1019, 1048], [1049, 1049, 1065, 1065, 1119], [1120, 1120, 1136, 1136, 1190], [1192, 1192, 1248, 1248, 2178]], "test": "untested"}
{"id": "NlKcWR", "name": "Quadratic Bézier Interpolation", "author": "piyushslayer", "description": "Trying to relearn some curve/spline stuff after a long time, so decided to write some interpolation stuff to help me remember this stuff better in the future. Drag around points with cursor. Enable/Disable #ifdefs in common for drawing debug stuff. ", "tags": ["2d", "interactive", "sdf", "bezier", "spline", "curve", "lerp", "quadratic"], "likes": 1, "viewed": 318, "published": 3, "date": "1661778519", "time_retrieved": "2024-07-30T16:33:55.650992", "image_code": "/**\nTrying to relearn some curve/spline stuff after a long time, so decided to write this implementation\nto help me remember this stuff better in the future. \n\nUsage: Drag around anchor points with mouse to see how the curve changes. Also, enabling/disabling ifdefs \nin the common tab helps draw various debug points and line segments that are used in calculation the final\nBézier interpolant for drawing the curve. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 outColor = textureLod(iChannel0, uv, 0.0).xyz;\n    \n    if (fragCoord.y < 1.0) \n    {\n        outColor = BackgroundColor;\n    }\n    \n    fragColor = vec4(pow(outColor, GammaInv), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PIXEL_SIZE 2.0 / max(iResolution.x, iResolution.y) // because uv is in [-1, 1] domain\n#define DOUBLE_PIXEL_SIZE 2.0 * PIXEL_SIZE\n#define SS_PIXEL(x) smoothstep(DOUBLE_PIXEL_SIZE, -DOUBLE_PIXEL_SIZE * 2.0, x) // double AA looks smoother imo\n\nvoid DrawCircle(inout vec3 outColor, in vec3 inColor, in vec2 uv, in vec2 pos, const in float radius)\n{\n    outColor = mix(outColor, inColor, SS_PIXEL(length(uv - pos) - radius));\n}\n\nvoid DrawSegment(inout vec3 outColor, in vec3 inColor, in vec2 uv, in vec2 a, in vec2 b, float thickness)\n{\n    vec2 AB = b - a;\n    vec2 AP = uv - a;\n    float position = SATURATE(dot(AP, AB) / dot(AB, AB));\n    outColor = mix(outColor, inColor, SS_PIXEL(length(AP - position * AB) - thickness));\n}\n\nvoid CalculateAnchorPositions(inout vec3 outColor, inout Point anchors[AnchorCount], in vec2 uv, in vec4 mouse)\n{\n\n    if (iFrame == 0) // First frame, so just set the position and gtfo.\n    {\n        for (int i = 0; i < AnchorCount; ++i)\n        {\n            vec3 anchorPosition = InitialAnchorPositions[i];\n            \n            if (iResolution.x > iResolution.y)\n            {\n                anchorPosition.x *= iResolution.x / iResolution.y;\n            }\n            else\n            {\n                anchorPosition.y *= iResolution.y / iResolution.x;\n            }\n            \n            anchors[i].position = anchorPosition;//InitialAnchorPositions[i];\n        }\n        \n        return;\n    }\n    \n    float anchorsUnderCursor = 0.0;\n    \n    for (int i = 0; i < AnchorCount; ++i)\n    {\n        // Previous frame anchor position.\n        anchors[i].position = texelFetch(iChannel0, ivec2(i, 0), 0).xyz; \n        anchors[i].color[i] = 2.0;\n        \n        // Handle mouse input\n        if (iMouse.w > 0.0) \n        {\n            // Mask to decide which anchor to move, especially when 2 or more anchors are overlapping each \n            // other. For now it just choses the first one in the array that's detected under the mouse, but \n            // I'd eventually like to handle depth as well.\n            anchors[i].position.z = mix(step(ANCHOR_POINT_RADIUS, length(anchors[i].position.xy - mouse.xy)), 1.0, SATURATE(anchorsUnderCursor));\n            if (anchors[i].position.z < 0.5)\n            {\n                anchorsUnderCursor++;\n            }\n        }\n        \n        // Set current anchor position after handling mouse click\n        anchors[i].position.xy = mix(mouse.xy, anchors[i].position.xy, anchors[i].position.z);\n        \n        // Draw the anchor point (It's totally fine to draw here, but deferring drawing anchors \n        // until debug segments are drawn makes it look better.)\n        // DrawCircle(outColor, anchors[i].color, uv, anchors[i].position.xy, POINT_RADIUS);\n    }    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec4 mouse = (2.0 * iMouse - iResolution.xyxy) / iResolution.y;\n    vec3 outColor = BackgroundColor;\n  \n    Point anchors[AnchorCount];\n    CalculateAnchorPositions(outColor, anchors, uv, mouse);\n    \n#ifdef DRAW_DEBUG_ANCHOR_SEGMENTS\n    // Draw the line segments joining the anchor points.\n    DrawSegment(outColor, AnchorSegmentColor, uv, anchors[0].position.xy, anchors[1].position.xy, PIXEL_SIZE);\n    DrawSegment(outColor, AnchorSegmentColor, uv, anchors[1].position.xy, anchors[2].position.xy, PIXEL_SIZE);\n#endif\n    \n    // Draw the anchor points.\n    for (int i = 0; i < AnchorCount; ++i)\n    {\n        DrawCircle(outColor, anchors[i].color, uv, anchors[i].position.xy, ANCHOR_POINT_RADIUS);\n    }\n    \n    // Interpolate the Quadratic Bézier Curve.\n    vec2 previousBezierInterpolant = anchors[2].position.xy;\n    for (float i = 0.0; i < TotalBezierSegments - 1.0; ++i)\n    {\n        float fraction = (i + 1.0) * (1.0 / TotalBezierSegments);\n        \n#if defined(DRAW_DEBUG_INTERPOLANT_SEGMENTS) || defined(DRAW_DEBUG_LINEAR_INTERPOLANT_POINTS)\n        // If we're drawing debug points/segments, then calculate the interpolation manually\n        vec2 D = mix(anchors[1].position.xy, anchors[0].position.xy, fraction);\n        vec2 E = mix(anchors[2].position.xy, anchors[1].position.xy, fraction);\n        vec2 F = mix(E, D, fraction);\n#endif\n        \n#ifdef DRAW_DEBUG_LINEAR_INTERPOLANT_POINTS\n        // Draw the points that divide the line segments joining the anchor points at different fractions.\n        DrawCircle(outColor, LinearInterpolantPointColor, uv, D, INTERPOLANT_POINT_RADIUS);\n        DrawCircle(outColor, LinearInterpolantPointColor, uv, E, INTERPOLANT_POINT_RADIUS);\n#endif\n\n#ifdef DRAW_DEBUG_INTERPOLANT_SEGMENTS\n        // Draw the line segments that join the two main anchor segments at different fractions, and\n        // on which the point on the Bézier curve is interpolated.\n        DrawSegment(outColor, FloatToRGB(fraction, 4.0) * 4.0, uv, D, E, PIXEL_SIZE);\n#endif\n        \n#if !defined(DRAW_DEBUG_INTERPOLANT_SEGMENTS) && !defined(DRAW_DEBUG_LINEAR_INTERPOLANT_POINTS)\n        // If debug stuff that requires manual interpolation is turned off, just use the solved equation.\n        // Bézier quadratic equation:\n        // (A - 2B + C)*t*t + 2*t*(B - C) + C \n        vec2 currentBezierInterpolant = fraction * fraction * (anchors[0].position.xy - 2.0 * anchors[1].position.xy + anchors[2].position.xy) + \n            2.0 * fraction * (anchors[1].position.xy - anchors[2].position.xy) + anchors[2].position.xy;\n#else\n        vec2 currentBezierInterpolant = F;\n#endif\n            \n        // Draw the Bézier curve.\n        DrawSegment(outColor, BezierCurveColor, uv, previousBezierInterpolant, \n            currentBezierInterpolant, DOUBLE_PIXEL_SIZE);\n            \n#ifdef DRAW_DEBUG_BEZIER_INTERPOLANTS_POINTS\n        // Draw the point interpolated on the Bézier curve.\n        DrawCircle(outColor, BezierInterpolantPointColor, uv, currentBezierInterpolant, INTERPOLANT_POINT_RADIUS);\n#endif\n        \n        previousBezierInterpolant = currentBezierInterpolant;\n    }\n    \n    // Draw the last segment in the curve joining the ending anchor point and the last interpolant in the curve.\n    DrawSegment(outColor, BezierCurveColor, uv, previousBezierInterpolant, \n            anchors[0].position.xy, DOUBLE_PIXEL_SIZE);\n      \n#ifdef DRAW_ANIMATED_INTERPOLANTS\n    float linearRatio = sin(iTime) * 0.5 + 0.5; // 0 - 1\n    \n    vec2 D = mix(anchors[1].position.xy, anchors[0].position.xy, linearRatio);\n    vec2 E = mix(anchors[2].position.xy, anchors[1].position.xy, linearRatio);\n    vec2 F = mix(E, D, linearRatio);\n    \n    DrawCircle(outColor, LinearInterpolantPointColor, uv, D, INTERPOLANT_POINT_RADIUS);\n    DrawCircle(outColor, LinearInterpolantPointColor, uv, E, INTERPOLANT_POINT_RADIUS);\n    DrawCircle(outColor, BezierInterpolantPointColor, uv, F, INTERPOLANT_POINT_RADIUS);\n    \n    DrawSegment(outColor, vec3(2.0, 2.0, 0.01), uv, D, E, PIXEL_SIZE);\n#endif\n    \n    fragColor = vec4(outColor, 1.0);\n    \n    // Write anchor positions to the buffer.\n    if (all(lessThan(fragCoord, vec2(1.0, 1.0))))\n    {\n        fragColor = vec4(anchors[0].position, 1.0);\n    }\n    else if(all(lessThan(fragCoord, vec2(2.0, 1.0))))\n    {\n        fragColor = vec4(anchors[1].position, 1.0);\n    }\n    else if(all(lessThan(fragCoord, vec2(3.0, 1.0))))\n    {\n        fragColor = vec4(anchors[2].position, 1.0);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SATURATE(x) clamp(x, 0.0, 1.0)\n#define ANCHOR_POINT_RADIUS 0.048\n#define INTERPOLANT_POINT_RADIUS 0.024\n\n#define DRAW_DEBUG_ANCHOR_SEGMENTS\n#define DRAW_ANIMATED_INTERPOLANTS\n// #define DRAW_DEBUG_INTERPOLANT_SEGMENTS\n// #define DRAW_DEBUG_LINEAR_INTERPOLANT_POINTS\n// #define DRAW_DEBUG_BEZIER_INTERPOLANTS_POINTS\n\nconst int  AnchorCount = 3;\nconst float TotalBezierSegments = 64.0;\nconst vec3 BackgroundColor = vec3(0.03, 0.012, 0.06);\nconst vec3 BezierCurveColor = vec3(0.01, 2.0, 0.01);\nconst vec3 AnchorSegmentColor = vec3(1.0);\nconst vec3 LinearInterpolantPointColor = vec3(2.0, 1.0, 0.01);\nconst vec3 BezierInterpolantPointColor = vec3(0.01, 1.8, 2.0);\nconst vec3 GammaInv = vec3(1.0 / 2.2);\n\nconst vec3 InitialAnchorPositions[AnchorCount] = vec3[AnchorCount] (\n    vec3(-0.7, -0.6, 1.0),\n    vec3(0.9, -0.9, 1.0),\n    vec3(0.7, 0.6, 1.0)\n);\n\nstruct Point\n{\n    vec3 position;\n    vec3 color;\n};\n\n// Taken from: https://www.shadertoy.com/view/WsVGzm\nvec3 FloatToRGB(in float v, in float scale) {\n    float r = v;\n    float g = mod(v * scale, 1.0);\n    r -= g / scale;\n    float b = mod(v * scale * scale, 1.0);\n    g -= b / scale;\n    return vec3(r, g, b);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 479, 479, 717]], "test": "untested"}
{"id": "7lVyWw", "name": "water crystals 1", "author": "elenzil", "description": "refraction study", "tags": ["refraction", "ice", "queue"], "likes": 15, "viewed": 278, "published": 3, "date": "1661755001", "time_retrieved": "2024-07-30T16:33:56.567542", "image_code": "#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\n// todo\n// [x] reduce data copying in and out of ringbuffer.\n//     - this was a loss. array indexing < copies, I guess.\n// [x] try hexagon exact. might boost perf.\n//     - also a loss, of about 20% overall FPS.\n\n// globals\nfloat gT;\nconst float gMinimumRayContribution =   0.007;\nconst uint  gMaxSteps               =  30u;\nconst uint  gMaxRays                =  30u;\nconst float gSurfaceEpsilon         =   0.005;\nconst float gMaxDist                =  40.0;\nconst float gUnderstepFactor        =   0.99;\nconst float gBounceAttenuation      =   0.95;\n\nconst float PI                      = 3.141592653;\n\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n////////////////////////////\n// From Shane \"Neon Lit Hexagons\" - https://www.shadertoy.com/view/MsVfz1\n//////\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat sdHex(in vec2 p) {\n    p = abs(p);\n    \n    // Below is equivalent to:\n    return max(p.x*.866025404 + p.y*.5, p.y); \n    //return max(dot(p, s*.5), p.x); // Hexagon.\n}\n\n// Note, for raymarching performance, inexact sdHex() seems faster.\n// From IQ - https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// From IQ - https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nstruct ray2_t {\n    vec2  ro;\n    vec2  rd;\n    float contribution;\n    float side;         // 1 = external  -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray2_t\n#define Q_MAX_ENTRIEs 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nfloat map(in vec2 p) {\n    float d = 1e9;\n    // sdHexagon is exact distance, sdHex isn't,\n    // but sdHex outperforms sdHexagon by about 20% in overall FPS.\n//  d = min(d, sdHexagon((p + vec2(cos(gT), sin(gT))) * rot(gT * -0.87), 0.9));\n    d = min(d, sdHex    ((p + vec2(cos(gT), sin(gT))) * rot(gT * -0.87)) - 0.9);\n    d = min(d, length(p + vec2(cos(gT * 2.81), sin(-gT*2.21))) - 0.9);\n    d = min(d, 3.5 - abs(p.x) - p.y * p.y * 0.05);\n    d = min(d, 2.6 - abs(p.y) + p.x * p.x * 0.05);\n    return d;\n}\n\n// also cribbed from the same Shane shader\nvec2 sceneNormal(in vec2 p) {\n    const vec2 e = vec2(0.001, 0);\n    return normalize(\n        vec2(map(p + e.xy) - map(p - e.xy),\n             map(p + e.yx) - map(p - e.yx)));\n}\n\nfloat marchToIntersection(in ray2_t ray) {    \n    float rayDist = 0.0;\n    for (uint stepNum = 0u; stepNum < gMaxSteps; ++stepNum) {\n        vec2 p = ray.ro + ray.rd * rayDist;\n        float sceneDist = map(p);\n        if (sceneDist * ray.side < gSurfaceEpsilon) {\n            return rayDist;\n        }\n        rayDist += sceneDist * ray.side * gUnderstepFactor;\n    }\n    \n    return 1e9;\n}\n\n\n\n// The raymarching here is slightly different than usual.\n// Each pixel marches the same exact rays throughthe scene as every other pixel,\n// just finally coloring itself based on distance from each ray segment.\n// The inefficiency of this compared to rasterizing leaves me breathless.\n// Perhaps this would be better moved into a buffer.\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.03 + 103.0;\n\n    float zoom   = 0.3;\n    vec2  p      = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    float ss_wid = 0.5/MINRES/zoom; // screen-space line width\n    float ss_eps = 2.5/MINRES/zoom; // screen-space epsilon\n    \n    vec2  trg = iMouse.x < 1.0 ? vec2(0.0, sin(gT * 0.2)) : (iMouse.xy - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec3 col = vec3(0.0);\n    \n    // add one ray to the queue.\n    ray2_t ray;\n    ray.ro           = vec2(-3.0, 0.0);\n    ray.rd           = normalize(trg - ray.ro);\n    ray.contribution = 1.0;\n    ray.side         = sign(map(ray.ro));\n    QEnqueue(ray);\n    \n    uint rayCount = 0u;\n    // process the queue\n    while (!QIsEmpty()) {\n      ray = QDequeue();\n      \n      // determine distance along ray to end\n      float rl = marchToIntersection(ray);\n      \n      const vec3 rayColor = vec3(0.2, 1.0, 0.8);\n      float d = sdSegment(p, ray.ro, ray.ro + ray.rd * rl) - ss_wid * 5.0 * ray.contribution;\n      col += mix(vec3(0.0), rayColor * ray.contribution, smoothstep(ss_eps, 0.0, d));\n      \n      // only continue if there's room to add two more rays\n      if (QSpaceLeft() < 2u) {\n          continue;\n      }\n      \n      rayCount += 1u;\n      if (rayCount > gMaxRays) {\n          continue;\n      }\n      \n      if (ray.contribution < gMinimumRayContribution) {\n          continue;\n      }\n\n      // prepare child ray/s\n\n      vec2 ro = ray.ro + ray.rd * rl;\n      if (dot(ro, ro) > 20.0 * 20.0) {\n          // out of bounds\n          continue;\n      }\n      \n      const float ior_air     = 1.0003;\n      const float ior_ice     = 1.309;\n      const float ior_water   = 1.333;\n      const float ior_quartz  = 1.46;\n      const float ior_diamond = 2.42;\n\n      float eta = ior_air / ior_ice;\n      vec2 n = sceneNormal(ro);\n      if (ray.side < 0.0) {\n          eta = 1.0 / eta;\n          n = -n;\n      }\n\n      ray2_t childRay;\n      childRay.rd               = refract(ray.rd, n, eta);\n      // if |refract()| is zero, it's total internal.\n      if (dot(childRay.rd, childRay.rd) > gSurfaceEpsilon) {\n          // not total internal\n          childRay.ro           = ro + childRay.rd * gSurfaceEpsilon * 4.0;\n          childRay.contribution = ray.contribution * 0.5 * gBounceAttenuation;\n          childRay.side         = -ray.side;\n          QEnqueue(childRay);\n      }\n      else {\n          // total internal\n          childRay.contribution = ray.contribution * gBounceAttenuation;\n      }\n      \n      childRay.rd           = reflect(ray.rd, n);\n      childRay.ro           = ro + childRay.rd * gSurfaceEpsilon * 2.0;\n      childRay.side         = ray.side;\n      QEnqueue(childRay);\n      \n    }\n    \n    // draw scene\n    vec3 sceneColor = vec3(0.4, 0.2, 0.2);\n    float sd = map(p);\n    col += sceneColor * 0.1        * smoothstep(ss_eps, 0.0,     sd          );\n    col = mix(col, sceneColor * 1.0, smoothstep(ss_eps, 0.0, abs(sd) - ss_wid));\n    \n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n    \n    RGBA = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "\n\n////////////////////////////////////////////////////\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// this is a basic ringbuffer.\n// NO ERROR CHECKING\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIEs;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n\tif (gQHead >= gQTail) {                        \\\n\t\treturn gQHead - gQTail;                    \\\n\t}                                              \\\n\telse {                                         \\\n\t\treturn gQNumSlots - (gQTail - gQHead);     \\\n\t}                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n\treturn gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n\treturn QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n\treturn QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n\tgQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n\tgQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n\tgQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n\treturn gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[674, 683, 706, 706, 790], [793, 1079, 1103, 1103, 1253], [1255, 1384, 1426, 1426, 1616], [1618, 1679, 1729, 1729, 1848], [2638, 2681, 2710, 2710, 2859], [2861, 2861, 2903, 2903, 3253], [3257, 3596, 3639, 3639, 6664]], "test": "untested"}
{"id": "ftVczy", "name": "Fractal mosaic 7 (music)", "author": "jarble", "description": "A colorful mosaic pattern.", "tags": ["fractal", "music", "mosaic"], "likes": 5, "viewed": 314, "published": 3, "date": "1661753750", "time_retrieved": "2024-07-30T16:33:57.573851", "image_code": "vec2 triangle_wave(vec2 a){\n    //a += sign(a.x)/2.;\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(2.5,-1.)\n        \n        //vec2(1.5,0.)\n    ,\n    \n    a1 =\n        a+a2\n        //a+a2+floor(a.x)\n        //a+a2+floor(a.y)\n    ;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    //a1 += (distance(floor(a1),round(a1)));\n\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n        //abs(fract((a1+.25)*(a2.x+a2.y))-.5)\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    for(int k = 0; k < 6; k++){\n        //uv += floor(uv*1.5);\n\n        //uv.y += t1_(floor(uv),floor(uv));\n    \n        float offset =\n            0.\n            //float(k)/2.\n        ;\n        \n        //uv += pow(floor(-(uv.x+.5)*2./1.5),2.)/2.;\n        \n        //uv.x += fmod(uv.x,1.5); //lace pattern\n        //uv += floor(uv+vec2(.5,0.))/1.5;\n\n        //if(t3){ uv = uv.yx+1.;t2 = t2.yx+.5;}\n        uv =\n            abs(.5+uv+t2)/scale\n            //fract(.5+uv+t2)/scale\n            //abs(.5+uv*sign(uv.x-uv.y)+t2)/scale\n        ;\n        //uv *= sign(uv.yx-uv);\n        \n        //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n        t2 =\n            -triangle_wave(uv-.5+offset)\n            //-triangle_wave(uv-.5+offset-floor(uv.x-uv.y)*floor(t2.x-t2.y))\n            //-triangle_wave(uv-.5*sign(uv.x-uv.y))\n            //-triangle_wave(uv-.5)/(.5+fmod(t2.x,2.))\n\n            //-triangle_wave(uv-1.5-fmod(t2.x/1.5,2.))\n        ;\n        //t2 = abs(t2);\n\n        uv =\n            -triangle_wave(uv.yx+offset)\n            //-triangle_wave(uv.yx+offset+floor(t2.y-t2.x)*floor(uv.y-uv.x))\n        ;\n        uv =\n            t2+uv\n            //fract(t2+uv)\n            //t2*length(t2)+uv\n            //t2*length(uv)+uv\n        ;\n        float c1 = uv.y-uv.x;\n        //c1 = max(c1,t2.x-t2.y);\n        if(uv.y > uv.x) col = vec3(col.yz,max(c1,col.x));\n        //col *= col + .5;\n        //else if(t3) col = col;\n        //else col = vec3(0.);\n        //if(t2.x*uv.x < t2.y*uv.y) col = col.yzx;\n        //if(t2.x-t2.y > uv.x-uv.y) col = col.yzx;\n        //if(t2.x<t2.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  \n  //time += fpow(time,2.)*fpow(time*4.,2.);\n  //time += fmod(time*8.,2.)+fmod(time*8.,4.)+fmod(time*8.,8.);\n  \n  //time -= floor(time*4.);\n  //time = time*(1. + fmod(time*4.,2.))/2.;\n\n  \n  float   t=\n      time/4.\n      //time + floor(time*4.+floor(time/4.))/4.\n      //2.*time/(1.+fmod(time,2.))/(1.+fmod(time/2.,2.))\n      //time/(1.+fmod(time/s1,2.))\n  ,\n  \n  m1 = fmod(t/8.,6.),\n  m3 = fmod(t/abs(2.5-m1),4.);\n  \n  t *= 16.;\n  \n  \n  float m2 = 1. + fmod(t/4.,2.);\n\n  t /= max(m2,m1+1.);\n  \n  float a=sqrt((1.-sqrt(fract(t/4.)))/4.)*.2,\n  \n  nb = time*pow(2.,abs(m3-m2-m1)/2.+6.5)*tempo;\n\n  return vec2(fract(nb*.998)\n\n   ,fract(nb))*a;\n\n}\n\n/*\nvec2 mainSound(int samp, float time){\n  \n  float t=(time)/4.;\n  \n  float m1 = mod(floor(t),6.),\n  m3 = mod(floor(t*2./abs(2.5-m1)),4.);\n  \n  t *= 16.;\n  float m2 = 1. + min(mod(floor(t/4.),2.),t);\n\n  t /= max(m2,m1+1.);\n  \n  float a=sqrt((1.-fract(t/4.))/4.)*.2,\n  \n  nb = pow(2.,abs(m3-m2-m1)/2.+6.5);\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n\n}\n*/", "sound_inputs": [], "common_code": "\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)*floor(x),y*y)/y)\n#define fmod(x,y) mod(floor(x),y)\n#define fmod1(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 52, 564], [681, 681, 707, 707, 796], [798, 798, 855, 855, 2813]], "test": "untested"}
{"id": "flVyzy", "name": "Black and gold rug", "author": "jarble", "description": "A fractal rug pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 231, "published": 3, "date": "1661750439", "time_retrieved": "2024-07-30T16:33:58.322848", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n        vec2 t2 = vec2(0.);\n        for(int k = 0; k < 12; k++){\n            uv = (uv+t2)/scale;\n            t2 = -triangle_wave(uv-.5);\n            //t2 = abs(t2);\n\n            uv = t2-triangle_wave(uv.yx);\n            float c1 = uv.y-uv.x;\n            col = abs(max(col-col.yzx,(vec3(c1,col.yz))));\n            if(t2.x < t2.y) col = col.yzx;\n            //else col = abs(col.x-col.yzx);\n\n            //if(t2.x*uv.x < t2.y*uv.y) col = col.yzx;\n            //if(t2.x-t2.y > uv.x-uv.y) col = col.yzx;\n\n\n        }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "#define fmod(a,b) mod(floor(a),b)\n\nvec2 mainSound(int samp, float time){\n  \n  float t=(time);\n  \n  float m1 = fmod(t/8.,4.),\n  m3 = fmod(t*4./abs(2.5-m1),4.);\n  \n  t *= 16.;\n  float m2 = 1. + min(fmod(t/4.,2.),t);\n\n  t /= max(m2,m1+1.);\n  float m4 = fmod(t/2.,4.);\n  \n  float a=pow(1.-log(1./8.+.25*fract(t/2.)),2.),\n  \n  nb = pow(2.,(m3-m4)/3.+7.5);\n\n  return abs(.5-vec2(fract(time*nb*.998),fract(time*nb)))*a;\n\n}\n\n/*\nvec2 mainSound(int samp, float time){\n  \n  float t=(time)*4.;\n  \n  float m1 = mod(floor(t/4.),4.),\n  m3 = mod(floor(t*4./abs(2.5-m1)),4.),\n  m4 = (mod(floor(t*4.),8.)+m3)/8.,\n  t1 = 2.+m1;\n  //t /= floor(1.+mod(t*2.,2.));\n  \n  t *= 16.;\n  float m2 = 1. + min(mod(floor(t/4.),2.),t);\n\n  t /= max(m2,m1+1.);\n  \n  float a=sqrt(1.-fract(t/8.))*.2,\n  \n  nb = pow(2.,mod(floor(t/8.),8.)/4.+m3+6.5)*(1.-mod(floor(t/2.),t1)/t1);\n  //nb = pow(2.,mod(floor(t),8.)/2.+7.)*(1.-mod(floor(t/2.),t1)/t1);\n\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n\n}\n*/", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 873]], "test": "untested"}
{"id": "ftKczG", "name": "\"Special military operation\"", "author": "NinjaKoala", "description": "Content warning: War\n\nPC 4k Intro for Linux released at evoke 2022.\nBy juvi and me of epoqe\nPouet: https://www.pouet.net/prod.php?which=91934", "tags": ["intro", "4k", "evoke", "ukraine", "war"], "likes": 16, "viewed": 762, "published": 3, "date": "1661721036", "time_retrieved": "2024-07-30T16:34:01.742705", "image_code": "/*\nThis was just lazily transpiled from the minified version\nwith spirv-cross, so this is an unreadable mess.\n\nIf you want to know how some specific thing works, just ask in the comments.\nNothing too fancy is going on, really\n\nThe first ~25 seconds show a black screen, this is intentional.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 u;\n\nfloat c;\nfloat f;\nfloat y;\nfloat x;\nfloat z;\nfloat m;\nfloat d;\nfloat a;\nfloat s;\nfloat p;\nfloat b;\nfloat e;\nfloat w;\nfloat r;\nfloat i;\nfloat g;\nfloat o;\nfloat l;\nfloat n;\nfloat h;\nfloat F;\nfloat C;\nfloat D;\nfloat Y;\nvec3 X;\nvec3 W;\nvec3 V;\nvec3 U;\n\nfloat T(float x_1)\n{\n    return fract((x_1 * 17.0) * fract(x_1 * 0.31830990314483642578125));\n}\n\nfloat S(vec3 x_1)\n{\n    vec3 c_1 = floor(x_1);\n    vec3 f_1 = fract(x_1);\n    vec3 s_1 = (f_1 * f_1) * (vec3(3.0) - (f_1 * 2.0));\n    float y_1 = ((111.0 * c_1.x) + (317.0 * c_1.y)) + (157.0 * c_1.z);\n    float param = y_1;\n    float z_1 = T(param);\n    float param_1 = y_1 + 157.0;\n    float a_1 = T(param_1);\n    float param_2 = y_1 + 268.0;\n    float e_1 = T(param_2);\n    float param_3 = y_1 + 317.0;\n    float m_1 = T(param_3);\n    float param_4 = y_1 + 111.0;\n    float d_1 = T(param_4);\n    float param_5 = y_1 + 585.0;\n    float o_1 = T(param_5);\n    float param_6 = y_1 + 428.0;\n    float p_1 = T(param_6);\n    float param_7 = y_1 + 474.0;\n    float v_1 = T(param_7);\n    float _369 = (((((((z_1 + ((d_1 - z_1) * s_1.x)) + ((m_1 - z_1) * s_1.y)) + ((a_1 - z_1) * s_1.z)) + (((((z_1 - d_1) - m_1) + p_1) * s_1.x) * s_1.y)) + (((((z_1 - m_1) - a_1) + v_1) * s_1.y) * s_1.z)) + (((((z_1 - d_1) - a_1) + e_1) * s_1.z) * s_1.x)) + ((((((((((d_1 - z_1) + m_1) - p_1) + a_1) - e_1) - v_1) + o_1) * s_1.x) * s_1.y) * s_1.z)) * 2.0;\n    return _369 - 1.0;\n}\n\nfloat S(inout vec3 x_1, int y_1)\n{\n    mat3 s_1 = mat3(vec3(0.0, 0.800000011920928955078125, 0.60000002384185791015625), vec3(-0.800000011920928955078125, 0.36000001430511474609375, -0.4799999892711639404296875), vec3(-0.60000002384185791015625, -0.4799999892711639404296875, 0.63999998569488525390625));\n    mat3 f_1 = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\n    float z_1 = 0.0;\n    float m_1 = 0.5;\n    for (int i_1 = 0; i_1 < y_1; i_1++)\n    {\n        vec3 param = x_1;\n        z_1 += (m_1 * S(param));\n        m_1 *= 0.64999997615814208984375;\n        x_1 = (s_1 * 2.0) * x_1;\n        f_1 = (inverse(s_1) * 2.0) * f_1;\n    }\n    return z_1;\n}\n\nvec4 M(vec3 x_1, vec3 s_1)\n{\n    vec4 f_1 = vec4(0.0);\n    float z_1 = 100.0;\n    float _1166;\n    for (int i_1 = 0; i_1 < 200; i_1++)\n    {\n        vec3 c_1 = x_1 + (s_1 * z_1);\n        float y_1 = sign(c_1.y - 250.0);\n        vec3 param = (vec3(2.0, 2.0, 1.0) + (c_1 * 0.0030000000260770320892333984375)) + vec3(u.z * 0.0500000007450580596923828125);\n        int param_1 = 8;\n        float _1096 = S(param, param_1);\n        float m_1 = (40.0 - abs(c_1.y - 250.0)) - ((200.0 * _1096) * 0.699999988079071044921875);\n        if (m_1 > 0.0)\n        {\n            m_1 = min(m_1 / 50.0, 0.25);\n            f_1 += (((vec4((((((vec3(0.0500000007450580596923828125) * (0.699999988079071044921875 + (0.5 * y_1))) + (vec3(0.20000000298023223876953125, 0.300000011920928955078125, 0.4000000059604644775390625) * (0.699999988079071044921875 - (0.5 * y_1)))) + ((vec3(0.60000002384185791015625, 0.699999988079071044921875, 0.699999988079071044921875) * clamp(0.4000000059604644775390625 + ((0.60000002384185791015625 * y_1) * W.y), 0.0, 1.0)) * 3.0)) * (0.4000000059604644775390625 + (0.5 * (1.0 - m_1)))) + vec3(0.100000001490116119384765625)) / vec3(2.0), 0.300000011920928955078125) * (clamp((m_1 * 0.00260000000707805156707763671875) * z_1, 0.0, 1.0) * 0.4000000059604644775390625)) * (1.0 - f_1.w)) * exp((-0.00069999997504055500030517578125) * z_1));\n        }\n        if (m_1 > 0.001000000047497451305389404296875)\n        {\n            _1166 = z_1 * 0.0199999995529651641845703125;\n        }\n        else\n        {\n            _1166 = abs(m_1) + 0.100000001490116119384765625;\n        }\n        z_1 += _1166;\n        if (z_1 > 5000.0)\n        {\n            i_1 = 200;\n        }\n    }\n    return clamp(f_1, vec4(0.0), vec4(1.0));\n}\n\nvec3 M(vec3 x_1)\n{\n    return mix(vec3(0.100000001490116119384765625, 0.14000000059604644775390625, 0.20000000298023223876953125), vec3(0.300000011920928955078125, 0.4000000059604644775390625, 0.60000002384185791015625), vec3(clamp(x_1.y, 0.0, 1.0))) * 0.300000011920928955078125;\n}\n\nfloat R(vec3 x_1, vec3 z_1)\n{\n    vec3 f_1 = abs(x_1) - z_1;\n    return length(max(f_1, vec3(0.0))) + min(max(f_1.x, max(f_1.y, f_1.z)), 0.0);\n}\n\nfloat R(vec3 x_1, float s_1, float f_1)\n{\n    vec3 param = x_1 * 10.0;\n    int param_1 = 2;\n    float _472 = S(param, param_1);\n    return (0.004999999888241291046142578125 * pow(abs(sin(x_1.y * s_1)), f_1)) * (2.0 + (_472 * 2.5));\n}\n\nvec2 S(vec2 s_1, float x_1, float f_1)\n{\n    vec2 _431;\n    if (x_1 < s_1.x)\n    {\n        _431 = vec2(x_1, f_1);\n    }\n    else\n    {\n        _431 = s_1;\n    }\n    return _431;\n}\n\nvec2 T(vec2 s_1, float x_1, float f_1)\n{\n    vec2 _446;\n    if (x_1 > s_1.x)\n    {\n        _446 = vec2(x_1, f_1);\n    }\n    else\n    {\n        _446 = s_1;\n    }\n    return _446;\n}\n\nvec2 R(vec3 x_1)\n{\n    vec2 f_1 = vec2(1000000.0);\n    if (x_1.z > 2.2999999523162841796875)\n    {\n        vec3 param = x_1 - X;\n        vec3 param_1 = vec3(2.400000095367431640625, 1.2999999523162841796875, 1.39999997615814208984375);\n        float z_1 = R(param, param_1);\n        vec3 param_2 = x_1 - X;\n        vec3 param_3 = vec3(2.5, 1.39999997615814208984375, 1.5);\n        float a_1 = R(param_2, param_3);\n        vec3 param_4 = x_1 * 0.699999988079071044921875;\n        int param_5 = 6;\n        float _535 = S(param_4, param_5);\n        float s_1 = clamp((_535 + x_1.y) - 0.800000011920928955078125, 0.0, 0.0040000001899898052215576171875);\n        vec3 param_6 = x_1 - vec3(-1.0, 1.7999999523162841796875, 3.0);\n        vec3 param_7 = vec3(0.699999988079071044921875, 0.300000011920928955078125, 1.0);\n        float _560;\n        if (s_1 > 0.0)\n        {\n            _560 = 0.0;\n        }\n        else\n        {\n            vec3 param_8 = x_1 * vec3(5.0);\n            float param_9 = 3.400000095367431640625;\n            float param_10 = 1000.0;\n            vec3 param_11 = x_1 * 25.0;\n            int param_12 = 3;\n            float _580 = S(param_11, param_12);\n            _560 = (R(param_8, param_9, param_10) / 4.0) - (clamp(_580 - 0.449999988079071044921875, 0.0, 1.0) * 0.0199999995529651641845703125);\n        }\n        vec3 param_13 = x_1 * 1.39999997615814208984375;\n        int param_14 = 4;\n        float _595 = S(param_13, param_14);\n        vec3 param_15 = x_1 * 10.0;\n        int param_16 = 4;\n        float _602 = S(param_15, param_16);\n        vec2 param_17 = f_1;\n        float param_18 = ((max(-z_1, max(a_1, -R(param_6, param_7))) - _560) + mix(0.00039999998989515006542205810546875, (_595 * 0.008000000379979610443115234375) + clamp(_602 * 0.0030000000260770320892333984375, 0.0, 0.00025000001187436282634735107421875), 400.0 * s_1)) - s_1;\n        float param_19 = float((s_1 > 0.0030000000260770320892333984375) ? 2 : 1);\n        f_1 = S(param_17, param_18, param_19);\n        vec3 param_20 = x_1 - (floor((x_1 * 4.150000095367431640625) + vec3(0.5)) / vec3(4.150000095367431640625));\n        vec3 param_21 = vec3(0.11200000345706939697265625);\n        vec3 param_22 = x_1;\n        int param_23 = 2;\n        float _647 = S(param_22, param_23);\n        vec3 param_24 = (x_1 - vec3(-1.0, 1.7999999523162841796875, 2.5)) + vec3(0.02999999932944774627685546875 * _647);\n        vec3 param_25 = vec3(0.699999988079071044921875, 0.300000011920928955078125, 0.00200000009499490261077880859375);\n        vec3 param_26 = x_1 * 200.0;\n        int param_27 = 2;\n        float _661 = S(param_26, param_27);\n        vec2 param_28 = f_1;\n        float param_29 = max(-R(param_20, param_21), R(param_24, param_25) + (0.00039999998989515006542205810546875 * _661));\n        float param_30 = 3.0;\n        f_1 = S(param_28, param_29, param_30);\n        vec3 param_31 = x_1 - vec3(0.449999988079071044921875, 1.39999997615814208984375, 5.0);\n        vec3 param_32 = vec3(0.100000001490116119384765625, 0.25, 0.1500000059604644775390625);\n        vec2 param_33 = f_1;\n        float param_34 = R(param_31, param_32) - 0.00999999977648258209228515625;\n        float param_35 = 4.0;\n        f_1 = S(param_33, param_34, param_35);\n        vec3 param_36 = x_1 * 200.0;\n        int param_37 = 2;\n        float _703 = S(param_36, param_37);\n        vec2 param_38 = f_1;\n        float param_39 = (length(vec2(abs(x_1.x) - 0.02300000004470348358154296875, x_1.z - 2.6400001049041748046875)) - 0.00999999977648258209228515625) + (0.0003000000142492353916168212890625 * _703);\n        float param_40 = 7.0;\n        f_1 = S(param_38, param_39, param_40);\n        return f_1;\n    }\n    vec2 s_2 = vec2(0.0199999995529651641845703125);\n    vec2 z_2 = vec2(42.0);\n    vec2 y_1 = floor(vec2(0.5) + ((x_1.xz - z_2) * s_2));\n    vec2 a_2 = (x_1.xz - z_2) - (y_1 / s_2);\n    vec3 c_1 = vec3(5.0, 9.0 + (7.69999980926513671875 * sin(4.0 + (2.0 * length(y_1)))), 2.0);\n    vec3 m_1 = vec3(a_2.x, x_1.y, a_2.y);\n    vec3 v_1 = vec3(c_1.x * 0.100000001490116119384765625, 0.5, 0.0);\n    vec3 d_1 = (m_1 - v_1) - (clamp(floor(vec3(0.5) + ((m_1 - v_1) * vec3(1.0, 0.89999997615814208984375, 1.0))), vec3(-floor(c_1.x * 0.89999997615814208984375), 2.0, 0.0), vec3(floor(c_1.x * 0.699999988079071044921875), floor(c_1.y * 0.819999992847442626953125), c_1.z)) / vec3(1.0, 0.89999997615814208984375, 1.0));\n    vec3 param_41 = m_1;\n    vec3 param_42 = c_1;\n    vec3 param_43 = m_1 + vec3(7.0);\n    float param_44 = 2.83500003814697265625;\n    float param_45 = 500.0;\n    vec3 param_46 = m_1 + vec3(4.19999980926513671875);\n    float param_47 = 2.83500003814697265625;\n    float param_48 = 500.0;\n    float _824;\n    if (x_1.z < (-10.0))\n    {\n        vec3 param_49 = x_1.xyx;\n        int param_50 = 3;\n        float _831 = S(param_49, param_50);\n        _824 = clamp(_831 - 0.4000000059604644775390625, 0.0, 1.0);\n    }\n    else\n    {\n        _824 = 0.0;\n    }\n    vec3 param_51 = d_1;\n    vec3 param_52 = vec3(0.23999999463558197021484375, 0.300000011920928955078125, 0.0500000007450580596923828125);\n    vec2 param_53 = vec2(((R(param_41, param_42) + R(param_43, param_44, param_45)) + R(param_46, param_47, param_48)) + _824, 4.0);\n    float param_54 = -R(param_51, param_52);\n    float param_55 = 5.0;\n    vec2 i_1 = T(param_53, param_54, param_55);\n    bool _852 = i_1.y == 5.0;\n    bool _862;\n    if (_852)\n    {\n        _862 = m_1.z > (c_1.z - 0.0489999987185001373291015625);\n    }\n    else\n    {\n        _862 = _852;\n    }\n    if (_862)\n    {\n        i_1.y = 6.0;\n    }\n    vec2 param_56 = f_1;\n    float param_57 = i_1.x;\n    float param_58 = i_1.y;\n    f_1 = S(param_56, param_57, param_58);\n    vec2 param_59 = f_1;\n    float param_60 = length((x_1.yz * vec2(1.0, -sign(x_1.z))) - vec2(2.0 + cosh(x_1.x * 0.100000001490116119384765625), ((sin(u.z) * cos(u.z * 0.4000000059604644775390625)) * 0.100000001490116119384765625) - 0.699999988079071044921875)) - 0.0199999995529651641845703125;\n    float param_61 = 8.0;\n    f_1 = S(param_59, param_60, param_61);\n    vec3 param_62 = x_1 - vec3(-4.0, 0.0, -8.80000019073486328125);\n    vec3 param_63 = vec3(1.39999997615814208984375, 16.0, 3.0);\n    vec3 param_64 = x_1 + vec3(4.0);\n    float param_65 = 4.0;\n    float param_66 = 500.0;\n    float _932;\n    if (x_1.x < (-2.7000000476837158203125))\n    {\n        vec3 param_67 = x_1 * 0.300000011920928955078125;\n        int param_68 = 7;\n        float _947 = S(param_67, param_68);\n        _932 = clamp(clamp((x_1.y * 0.20000000298023223876953125) - 0.1599999964237213134765625, 0.0, 1.0) * _947, 0.0, 1.0);\n    }\n    else\n    {\n        _932 = 0.0;\n    }\n    vec2 param_69 = f_1;\n    float param_70 = ((R(param_62, param_63) + R(param_64, param_65, param_66)) + _932) - 0.60000002384185791015625;\n    float param_71 = 4.0;\n    f_1 = S(param_69, param_70, param_71);\n    return f_1;\n}\n\nfloat T(float x_1, float f_1)\n{\n    return sign(x_1) * pow(abs(x_1), f_1);\n}\n\nfloat Q(vec3 x_1, vec3 s_1)\n{\n    float f_1 = 1.0;\n    float z_1 = 0.0199999995529651641845703125;\n    for (int i_1 = 0; i_1 < 30; i_1++)\n    {\n        vec3 param = x_1 + (s_1 * z_1);\n        float c_1 = R(param).x;\n        float m_1 = clamp((8.0 * c_1) / z_1, 0.0, 1.0);\n        z_1 += clamp(c_1, 0.0199999995529651641845703125, 0.20000000298023223876953125);\n        f_1 = min(f_1, (m_1 * m_1) * (3.0 - (m_1 * 2.0)));\n    }\n    return clamp(f_1, 0.0, 1.0);\n}\n\nfloat O(vec3 x_1, vec3 s_1)\n{\n    float f_1 = 1.0;\n    float z_1 = 0.0;\n    for (float i_1 = 0.0; i_1 < 4.0; i_1 += 1.0)\n    {\n        float m_1 = 0.00999999977648258209228515625 + (0.02500000037252902984619140625 * i_1);\n        vec3 param = x_1 + (s_1 * m_1);\n        float _1033 = f_1;\n        float _1034 = _1033 * 0.949999988079071044921875;\n        f_1 = _1034;\n        z_1 += ((m_1 - R(param).x) * _1034);\n    }\n    return clamp(1.0 - (3.0 * z_1), 0.0, 1.0) * (0.5 + (0.5 * s_1.y));\n}\n\nvec3 K(vec3 x_1, inout vec3 f_1)\n{\n    float z_1 = 0.0;\n    vec2 s_1 = vec2(9.9999997473787516355514526367188e-05, -9.9999997473787516355514526367188e-05);\n    vec3 param = x_1;\n    vec3 param_1 = f_1;\n    vec4 c_1 = M(param, param_1);\n    vec3 param_2 = f_1;\n    vec3 i_1 = mix(M(param_2), c_1.xyz, vec3(c_1.w));\n    vec3 a_1 = sin((fract(vec3(dot(f_1, f_1.zxy) * 798.0) + f_1) * u.z) * 634.20001220703125);\n    f_1 += (a_1 * 0.00015000000712461769580841064453125);\n    vec2 v_1;\n    vec3 m_1;\n    for (int y_1 = 0; y_1 < 100; y_1++)\n    {\n        float _1259 = z_1;\n        float _1260 = _1259 + v_1.x;\n        z_1 = _1260;\n        vec3 _1263 = x_1 + (f_1 * _1260);\n        m_1 = _1263;\n        vec3 param_3 = _1263;\n        v_1 = R(param_3);\n        if ((abs(v_1.x) < 0.001000000047497451305389404296875) || (z_1 > 270.0))\n        {\n            y_1 = 200;\n        }\n    }\n    if (z_1 < 270.0)\n    {\n        vec3 y_2 = (X + vec3(-1.0, 1.2999999523162841796875, -0.800000011920928955078125)) - m_1;\n        vec3 param_4 = m_1 + s_1.xxx;\n        vec3 param_5 = m_1 + s_1.yxy;\n        vec3 param_6 = m_1 + s_1.yyx;\n        vec3 param_7 = m_1 + s_1.xyy;\n        vec3 o_1 = normalize((((s_1.xxx * R(param_4).x) + (s_1.yxy * R(param_5).x)) + (s_1.yyx * R(param_6).x)) + (s_1.xyy * R(param_7).x));\n        vec3 e_1 = vec3(-9.0, 3.0, (0.5 * sin(u.z * 3.0)) - 2.0) - m_1;\n        vec3 n_1 = normalize(y_2);\n        vec3 h_1 = normalize(e_1);\n        vec3 p_1 = vec3(0.0);\n        float r_1 = 0.0;\n        float g_1 = v_1.y;\n        float b_1 = (1.5 * clamp(dot(o_1, n_1), 0.0, 1.0)) / dot(y_2, y_2);\n        float w_1 = (5.0 * clamp(dot(o_1, h_1), 0.0, 1.0)) / dot(e_1, e_1);\n        b_1 = mix(0.0, b_1, clamp(pow(dot(n_1, V) * 3.5, 11.0), 0.0, 1.0));\n        if (g_1 == 1.0)\n        {\n            vec3 param_8 = m_1 * 100.0;\n            int param_9 = 3;\n            float _1393 = S(param_8, param_9);\n            float param_10 = _1393;\n            float param_11 = 3.0;\n            p_1 += vec3(0.5 + (T(param_10, param_11) * 0.60000002384185791015625));\n        }\n        if (g_1 == 6.0)\n        {\n            p_1 = vec3(0.100000001490116119384765625, 0.100000001490116119384765625, 0.0);\n        }\n        if (g_1 == 7.0)\n        {\n            p_1 = vec3(0.1500000059604644775390625, 0.100000001490116119384765625, 0.100000001490116119384765625);\n            r_1 = 1.5;\n        }\n        if (g_1 == 3.0)\n        {\n            p_1 += vec3(0.0500000007450580596923828125);\n            r_1 = 1.2000000476837158203125;\n        }\n        if (g_1 == 4.0)\n        {\n            vec3 param_12 = (m_1 * 200.0) / vec3(m_1.z);\n            int param_13 = 2;\n            float _1435 = S(param_12, param_13);\n            float param_14 = _1435;\n            float param_15 = 2.0;\n            vec3 param_16 = m_1 * vec3(3.0, 0.89999997615814208984375, 2.0);\n            int param_17 = 2;\n            float _1447 = S(param_16, param_17);\n            vec3 param_18 = m_1;\n            int param_19 = 4;\n            float _1459 = S(param_18, param_19);\n            p_1 = mix((vec3(0.800000011920928955078125, 0.829999983310699462890625, 0.87000000476837158203125) + vec3(T(param_14, param_15) * 0.699999988079071044921875)) + vec3(pow(abs(0.20000000298023223876953125 + _1447), 2.0) * 0.800000011920928955078125), vec3(0.0, 0.02999999932944774627685546875, 0.0), vec3(1.0299999713897705078125 * smoothstep(3.0, 0.0, _1459 + length(m_1.xy - vec2(-4.5, 7.5)))));\n            if (m_1.z > 2.0)\n            {\n                p_1 *= 0.1500000059604644775390625;\n                r_1 = 0.4000000059604644775390625;\n            }\n        }\n        if (g_1 == 2.0)\n        {\n            p_1 = vec3(0.14000000059604644775390625, 0.119999997317790985107421875, 0.12999999523162841796875);\n            r_1 = 0.60000002384185791015625;\n            if (dot(vec3(0.0, 0.0, 1.0), o_1) < 0.89999997615814208984375)\n            {\n                p_1 += vec3((((u.z < d) ? 0.300000011920928955078125 : 0.100000001490116119384765625) * smoothstep((-0.699999988079071044921875) * abs(m_1.z - 2.599999904632568359375), 0.0, 0.689999997615814208984375 - abs(m_1.x + 1.0))) * smoothstep(0.89999997615814208984375, 0.0, abs(m_1.z - 2.599999904632568359375)));\n            }\n        }\n        float t_1 = clamp(pow(dot(normalize(n_1 - f_1), o_1), 16.0), 0.0, 1.0) / dot(y_2, y_2);\n        t_1 = mix(0.0, t_1, clamp(pow(dot(n_1, V) * 3.0, 11.0), 0.0, 1.0));\n        if (u.z < d)\n        {\n            b_1 = 0.0;\n            t_1 = 0.0;\n        }\n        float _1552;\n        if (m_1.z > 0.0)\n        {\n            _1552 = 1.0;\n        }\n        else\n        {\n            vec3 param_20 = m_1 + vec3(u.z / 2.0);\n            int param_21 = 2;\n            float _1564 = S(param_20, param_21);\n            _1552 = 0.5 + _1564;\n        }\n        float _1577;\n        if (m_1.z > 0.0)\n        {\n            _1577 = 0.0;\n        }\n        else\n        {\n            vec3 param_22 = m_1;\n            vec3 param_23 = W;\n            _1577 = Q(param_22, param_23);\n        }\n        vec3 param_24 = m_1;\n        vec3 param_25 = o_1;\n        i_1 = (((((vec3(0.0599999986588954925537109375) * _1552) + ((vec3((0.3499999940395355224609375 * clamp(dot(o_1, W), 0.0, 1.0)) * _1577) + (vec3(1.0, 0.60000002384185791015625, 0.300000011920928955078125) * w_1)) + (U * b_1))) * p_1) * (0.4000000059604644775390625 + (0.60000002384185791015625 * O(param_24, param_25)))) + (U * (t_1 * r_1))) * 0.5;\n        if (g_1 == 5.0)\n        {\n            vec3 param_26 = m_1;\n            vec3 param_27 = reflect(f_1, o_1);\n            vec4 F_1 = M(param_26, param_27);\n            vec3 param_28 = reflect(f_1, o_1);\n            i_1 = pow(mix(M(param_28) + vec3(0.100000001490116119384765625), F_1.xyz, vec3(F_1.w)), vec3(2.0, 2.5, 3.0)) * 0.60000002384185791015625;\n        }\n        vec3 param_29 = f_1;\n        i_1 = mix(M(param_29), i_1, vec3(clamp(exp((0.008000000379979610443115234375 * m_1.z) + 1.0), 0.0, 1.0)));\n    }\n    i_1 += ((vec3(0.001000000047497451305389404296875) + (i_1 * 0.070000000298023223876953125)) * a_1.y);\n    return i_1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    u=vec4(iResolution.xy,iTime,iTimeDelta);\n    c = 3.1415998935699462890625;\n    f = 25.0;\n    y = f + 3.0;\n    x = f + 12.0;\n    z = x + 3.0;\n    m = z + 3.0;\n    d = m;\n    a = m + 8.0;\n    s = c * 19.0;\n    p = a + 3.0;\n    b = p + 8.0;\n    e = p + 8.5;\n    w = p + 9.0;\n    r = p + 10.0;\n    i = p + 11.0;\n    g = p + 17.0;\n    o = g + 0.5;\n    l = o + 3.7999999523162841796875;\n    n = o + 4.0;\n    h = n + 0.699999988079071044921875;\n    F = h + 0.0;\n    C = F + 10.0;\n    D = C + 6.0;\n    Y = D + 0.100000001490116119384765625;\n    X = vec3(-2.0, 0.800000011920928955078125, 4.0);\n    W = vec3(0.666666686534881591796875, 0.666666686534881591796875, 0.3333333432674407958984375);\n    V = vec3(0.0, 1.0, 0.0);\n    U = vec3(1.0, 0.64999997615814208984375, 0.4000000059604644775390625);\n    float c_1 = clamp((u.z - x) * 0.4000000059604644775390625, 0.0, 2.0);\n    float d_1 = mix(0.10999999940395355224609375, 0.0, smoothstep(0.0, o - g, clamp(u.z - g, 0.0, o - g)));\n    float W_1 = clamp(c_1, 0.00999999977648258209228515625, 1.57000005245208740234375);\n    W_1 = mix(W_1, 2.7999999523162841796875, smoothstep(0.0, h - n, clamp(u.z - n, 0.0, h - n)));\n    vec3 X_1 = vec3(-0.89999997615814208984375, 0.300000011920928955078125 + (smoothstep(0.0, 1.0, clamp((u.z - z) * 2.0, 0.0, 1.0)) * 1.2000000476837158203125), 5.0);\n    X_1 = mix(X_1, vec3(-0.89999997615814208984375, 1.5, 3.0), vec3(smoothstep(0.0, a - m, clamp(u.z - m, 0.0, a - m))));\n    X_1 = mix(X_1, vec3(-0.89999997615814208984375, 1.5, 3.2000000476837158203125), vec3(smoothstep(0.0, o - g, clamp(u.z - g, 0.0, o - g))));\n    X_1 = mix(X_1, vec3(-0.89999997615814208984375, 1.5, 4.0), vec3(smoothstep(0.0, n - o, clamp(u.z - o, 0.0, n - o))));\n    vec3 _1808;\n    if (u.z > l)\n    {\n        vec3 param = vec3((4.0 * u.z) + 4.0);\n        int param_1 = 3;\n        float _1824 = S(param, param_1);\n        vec3 param_2 = vec3((4.0 * u.z) + 8.0);\n        int param_3 = 3;\n        float _1832 = S(param_2, param_3);\n        vec3 param_4 = vec3(4.0 * u.z);\n        int param_5 = 3;\n        float _1839 = S(param_4, param_5);\n        _1808 = vec3(_1824, _1832, _1839) * exp((l - u.z) * 2.0);\n    }\n    else\n    {\n        _1808 = vec3(0.0);\n    }\n    X_1 = mix(X_1, vec3(-2.5, 0.1500000059604644775390625, 4.0), vec3(smoothstep(0.0, h - n, clamp(u.z - n, 0.0, h - n)))) + _1808;\n    vec3 U_1 = X_1 + vec3((cos(c_1 * 0.449999988079071044921875) * 0.5) - 0.5, (0.5 * sin(c_1 * 3.0)) + 0.100000001490116119384765625, -1.0);\n    U_1 = mix(U_1, X_1 + vec3(sin(min(u.z, s)) * 0.4000000059604644775390625, 0.5, -1.0), vec3(smoothstep(0.0, p - a, clamp(u.z - a, 0.0, p - a))));\n    U_1 = mix(U_1, X_1 + vec3(0.300000011920928955078125, 0.5, -1.0), vec3(smoothstep(0.0, e - b, clamp(u.z - b, 0.0, e - b))));\n    U_1 = mix(U_1, X_1 + vec3(0.4000000059604644775390625, 0.5, -1.0), vec3(smoothstep(0.0, w - e, clamp(u.z - e, 0.0, w - e))));\n    U_1 = mix(U_1, X_1 + vec3(0.100000001490116119384765625, 0.5, -1.0), vec3(smoothstep(0.0, i - r, clamp(u.z - r, 0.0, i - r))));\n    U_1 = mix(U_1, X_1 + vec3(0.100000001490116119384765625 + (sin((u.z - g) * 6.0) * d_1), 0.4000000059604644775390625 + (cos((u.z - g) * 6.0) * d_1), -1.0), vec3(smoothstep(0.0, o - g, clamp(u.z - g, 0.0, o - g))));\n    U_1 = mix(U_1, X_1 + vec3(0.0, 0.4000000059604644775390625, -1.0), vec3(smoothstep(0.0, n - o, clamp(u.z - o, 0.0, n - o))));\n    U_1 = mix(U_1, X_1 + vec3(-0.800000011920928955078125, -1.0, -1.7999999523162841796875), vec3(smoothstep(0.0, h - n, clamp(u.z - n, 0.0, h - n))));\n    U_1 = mix(U_1, X_1 + vec3(0.60000002384185791015625, 0.699999988079071044921875, -0.20000000298023223876953125), vec3(smoothstep(0.0, C - F, clamp(u.z - F, 0.0, C - F))));\n    U_1.x += (0.008000000379979610443115234375 * dot(vec3(sin(u.z * 4.0)), vec3(0.20000000298023223876953125, 0.800000011920928955078125, 0.300000011920928955078125)));\n    U_1.y += (0.007000000216066837310791015625 * dot(vec3(cos(u.z * 3.0)), vec3(0.300000011920928955078125, 0.4000000059604644775390625, 0.699999988079071044921875)));\n    vec3 _2073 = V;\n    vec2 _2075 = _2073.xz + vec2(mix(0.0, 0.119999997317790985107421875 * sin(6.0 * u.z), smoothstep(0.0, o - g, clamp(u.z - g, 0.0, o - g))));\n    V.x = _2075.x;\n    V.z = _2075.y;\n    vec3 T_1 = normalize(X_1 - U_1);\n    vec3 R_1 = normalize(cross(vec3(cos(W_1), sin(W_1), 0.0), T_1));\n    vec3 param_6 = X_1;\n    vec3 param_7 = mat3(vec3(R_1), vec3(cross(T_1, R_1)), vec3(T_1)) * normalize(vec3(((fragCoord.xy * 2.0) - u.xy) / vec2(u.y), -1.7000000476837158203125));\n    vec3 _2133 = K(param_6, param_7);\n    fragColor = vec4(mix(vec3(mix(vec3(0.0), pow(abs(mix(_2133, pow(abs(texture(iChannel0, fragCoord.xy / u.xy).xyz), vec3(2.2002201080322265625)), vec3(mix(0., 0.8, smoothstep(0.0, h - n, clamp(u.z - n, 0.0, h - n)))))), vec3(0.4544999897480010986328125)), vec3(smoothstep(0.0, y - f, clamp(u.z - f, 0.0, y - f))))), vec3(0.0), vec3(smoothstep(0.0, Y - D, clamp(u.z - D, 0.0, Y - D)))), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float p(inout uint s_1)\n{\n    s_1 ^= (s_1 >> uint(16));\n    s_1 *= 2146121005u;\n    s_1 ^= (s_1 >> uint(15));\n    s_1 *= 2221713035u;\n    s_1 ^= (s_1 >> uint(16));\n    return (-1.0) + (4.656612873077392578125e-10 * float(s_1));\n}\n\nfloat p(inout float s_1, int f, float v)\n{\n    float e = 0.699999988079071044921875;\n    float r = 0.0;\n    s_1 *= 44100.0;\n    for (int i = 0; i < f; i++)\n    {\n        float m = (s_1 / v) * exp(float(i));\n        uint param = uint(int(m));\n        float _131 = p(param);\n        uint param_1 = uint(int(m) + 1);\n        float _138 = p(param_1);\n        r += ((mix(_131, _138, smoothstep(0.0, 1.0, mod(m, 1.0))) * e) * exp(float(-i)));\n    }\n    return r;\n}\n\nfloat t(float s_1, float f)\n{\n    float _160;\n    if (s_1 < f)\n    {\n        _160 = ((2.0 * s_1) / f) - 1.0;\n    }\n    else\n    {\n        _160 = 1.0 - ((2.0 * (s_1 - f)) / (1.0 - f));\n    }\n    return _160;\n}\n\nfloat f(inout float s_1, float f_1)\n{\n    float v = 3.1415998935699462890625;\n    float e = 3.0;\n    float m = 7.0;\n    float i = 16.0;\n    float r = 0.20000000298023223876953125;\n    float p_1 = s_1;\n    s_1 = mod(s_1, i);\n    float o = sin(((s_1 / e) * v) / 2.0);\n    float x = ((((-2.0) * cos(((s_1 / e) / 2.0) * v)) * f_1) * e) / v;\n    o = (s_1 < e) ? o : 1.0;\n    float _228;\n    if (s_1 < m)\n    {\n        _228 = o;\n    }\n    else\n    {\n        _228 = exp((m - s_1) * r);\n    }\n    o = _228;\n    float _243;\n    if (s_1 < e)\n    {\n        _243 = x;\n    }\n    else\n    {\n        _243 = f_1 * (s_1 - e);\n    }\n    x = _243;\n    float _257;\n    if (s_1 < m)\n    {\n        _257 = x;\n    }\n    else\n    {\n        _257 = f_1 * (((m - e) + (1.0 / r)) - (exp((m - s_1) * r) / r));\n    }\n    x = _257;\n    bool _281 = p_1 > 0.0;\n    bool _288;\n    if (_281)\n    {\n        _288 = p_1 < (i * 3.0);\n    }\n    else\n    {\n        _288 = _281;\n    }\n    float _289;\n    if (_288)\n    {\n        float param = mod(x, 1.0);\n        float param_1 = 0.5;\n        float param_2 = mod(x * 2.0, 1.0);\n        float param_3 = 0.20000000298023223876953125;\n        _289 = (o * (clamp(5.0 * t(param, param_1), -1.0, 1.0) + t(param_2, param_3))) * 0.100000001490116119384765625;\n    }\n    else\n    {\n        _289 = 0.0;\n    }\n    return _289;\n}\n\nvec2 p(vec2 s_1, float f_1)\n{\n    float v = exp2(f_1);\n    return sqrt(vec2(v) / (vec2(1.0) + ((s_1 * (v - 1.0)) * s_1))) * s_1;\n}\n\nvec2 f(float s_1)\n{\n    float param = s_1 - 0.0;\n    float param_1 = 392.0;\n    float _321 = f(param, param_1);\n    float param_2 = s_1 - 0.180000007152557373046875;\n    float param_3 = 390.0;\n    float _329 = f(param_2, param_3);\n    float param_4 = s_1 - 0.2899999916553497314453125;\n    float param_5 = 391.0;\n    float _339 = f(param_4, param_5);\n    vec2 param_6 = vec2(((_321 * 0.100000001490116119384765625) + (_329 * 0.0500000007450580596923828125)) + (_339 * 0.02500000037252902984619140625));\n    float param_7 = 7.5;\n    return p(param_6, param_7) * 0.070000000298023223876953125;\n}\n\nvec2 t(inout float s_1, float f_1, float v)\n{\n    float m = 1.0;\n    vec2 r = vec2(0.0);\n    vec2 _415;\n    for (int i = 0; i < 20; i++)\n    {\n        bool _406 = s_1 > f_1;\n        bool _414;\n        if (_406)\n        {\n            _414 = (s_1 - f_1) < v;\n        }\n        else\n        {\n            _414 = _406;\n        }\n        if (_414)\n        {\n            float param = s_1;\n            int param_1 = 10;\n            float param_2 = 30.0;\n            float _424 = p(param, param_1, param_2);\n            vec2 param_3 = vec2((_424 * pow(0.5 + (0.5 * sin(60.0 * (s_1 - f_1))), 40.0)) * 0.300000011920928955078125);\n            float param_4 = 6.30000019073486328125;\n            _415 = p(param_3, param_4);\n        }\n        else\n        {\n            _415 = vec2(0.0);\n        }\n        r += (_415 * m);\n        uint param_5 = uint(i);\n        float _451 = p(param_5);\n        s_1 -= (0.100000001490116119384765625 + (_451 * 0.07999999821186065673828125));\n        uint param_6 = uint(i * i);\n        float _462 = p(param_6);\n        m *= (0.699999988079071044921875 + (_462 * 0.20000000298023223876953125));\n    }\n    return r;\n}\n\nvec2 f(float s_1, float f_1, float v)\n{\n    vec2 _355;\n    if (s_1 > f_1)\n    {\n        float param = s_1;\n        int param_1 = 1;\n        float param_2 = 150.0;\n        float _363 = p(param, param_1, param_2);\n        float param_3 = s_1;\n        int param_4 = 7;\n        float param_5 = 150.0;\n        float _369 = p(param_3, param_4, param_5);\n        vec2 param_6 = vec2(mix(_363, _369, exp((-3.0) * (s_1 - f_1))) * exp(f_1 - s_1));\n        float param_7 = v;\n        _355 = p(param_6, param_7);\n    }\n    else\n    {\n        _355 = vec2(0.0);\n    }\n    return _355;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float m = time;\n    float param = m;\n    int param_1 = 3;\n    float param_2 = 150.0;\n    float _491 = p(param, param_1, param_2);\n    float param_3 = m - 4.0;\n    float param_4 = m - 7.0;\n    float param_5 = m;\n    float param_6 = m;\n    float param_7 = 47.0;\n    float param_8 = 0.60000002384185791015625;\n    vec2 _517 = t(param_6, param_7, param_8);\n    float param_9 = m;\n    float param_10 = 49.0;\n    float param_11 = 0.4000000059604644775390625;\n    vec2 _526 = t(param_9, param_10, param_11);\n    float param_12 = m;\n    float param_13 = 57.0;\n    float param_14 = 0.5;\n    vec2 _535 = t(param_12, param_13, param_14);\n    float param_15 = m;\n    float param_16 = 58.0;\n    float param_17 = 0.699999988079071044921875;\n    vec2 _543 = t(param_15, param_16, param_17);\n    float param_18 = m;\n    float param_19 = 71.0;\n    float param_20 = 3.7999999523162841796875;\n    float param_21 = m;\n    float param_22 = 62.0;\n    float param_23 = 1.2999999523162841796875;\n    float param_24 = m;\n    float param_25 = 62.5;\n    float param_26 = 1.2999999523162841796875;\n    float param_27 = m;\n    float param_28 = 64.0;\n    float param_29 = 0.60000002384185791015625;\n    float param_30 = m;\n    float param_31 = 75.0;\n    float param_32 = 5.0;\n    return mix(((((((((((((vec2(_491) * 0.07999999821186065673828125) + (f(param_3) * 0.5)) + (f(param_4) * 0.20000000298023223876953125)) + f(param_5)) + (_517 * 0.0500000007450580596923828125)) + (_526 * 0.1500000059604644775390625)) + (_535 * 0.1500000059604644775390625)) + (_543 * 0.100000001490116119384765625)) + (f(param_18, param_19, param_20) * 0.300000011920928955078125)) + (f(param_21, param_22, param_23) * 0.100000001490116119384765625)) + (f(param_24, param_25, param_26) * 0.1500000059604644775390625)) + (f(param_27, param_28, param_29) * 0.0500000007450580596923828125)) + f(param_30, param_31, param_32), vec2(sin(m * 8000.0)) * 0.00999999977648258209228515625, vec2(smoothstep(75.8000030517578125, 77.0, m)));\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 352, 352, 434]], "test": "untested"}
{"id": "NtKcRG", "name": "Red and blue rug", "author": "jarble", "description": "A fractal rug pattern.", "tags": ["fractal", "music", "carpet", "rug"], "likes": 4, "viewed": 233, "published": 3, "date": "1661715284", "time_retrieved": "2024-07-30T16:34:02.611383", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n    \n        //uv.y -= t1_(floor(uv),floor(uv));\n        \n        uv = (uv+t2)/scale;\n        //if(uv.x<uv.y) uv = uv.yx;\n        t2 = -triangle_wave(uv-.5);\n        uv = t2-triangle_wave(uv.yx);\n        col = abs(vec3(uv.y-uv.x,col.yz));\n        if(uv.x < uv.y) {col = col.yzx;}\n        //else if(t2.x < t2.y) col = abs(col.x-col.yzx);\n\n        //if(t2.x < t2.y) {col = col.xzy; uv=abs(uv.yx*2.);}\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n/*\n\nvec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        uv = (uv+t2);\n        t2 = triangle_wave(uv-.5)/2.;\n        uv = t2-triangle_wave(uv.yx);\n        col = abs(vec3(uv.y-uv.x,col.yz));\n        if(uv.x < uv.y) {col = col.yzx; uv=-abs(uv/2.);}\n        //if(t2.x < t2.y) {col = col.xzy; uv=abs(uv.yx*2.);}\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n*/", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  \n  float t=(time)/2.;\n  \n  float m1 = mod(floor(t/8.),4.);\n  //t *= 1. + m1;\n  float m3 = mod(floor(t/abs(2.5-m1)),4.),\n  t1 = 2.+m1;\n  //t /= floor(1.+mod(t*2.,2.));\n  \n  t *= 16.;\n\n  t *= m1/2.+1.;\n  \n  float a=sqrt(1.-fract(sqrt(t1)))*.1,\n  \n  nb = pow(2.,mod(floor(t/8.),8.)/4.+m3/4.+7.)*(1.-mod(floor(t/2.),t1)/t1);\n  //nb = pow(2.,mod(floor(t),8.)/2.+7.)*(1.-mod(floor(t/2.),t1)/t1);\n\n\n  return vec2(fract(time*nb*.998)*a,fract(time*nb)*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [194, 194, 220, 220, 309], [311, 311, 368, 368, 1052]], "test": "untested"}
{"id": "7lGczy", "name": "RaceBall", "author": "Behzod", "description": "no comment", "tags": ["game"], "likes": 3, "viewed": 181, "published": 3, "date": "1661712313", "time_retrieved": "2024-07-30T16:34:03.351404", "image_code": "\n/**\n    * Thanks in advance for Shader Tutorial site\n    * https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7\n    \n    |; happy code\n    \n    */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\n\nconst float roadW = 9.0;\nconst float rumbleW = roadW/3.0;\n\nfloat sdSphere(vec3 p, float r)\n{\n  float d = length(p) - r;\n  return d;\n}\n\nfloat road(vec3 p) {\n  float d = p.y + 1./* + 0.3*sin(p.z) + 0.3*/;\n  \n  float left = p.x + roadW/2.;\n  d = max(d, -left);\n  float right = -p.x + roadW/2.;\n  d = max(d, -right);\n  return d;\n}\n\nfloat rumble(vec3 p) {\n  float d = p.y + 0.7;\n  float rw = rumbleW;\n  float left = p.x + roadW/2. + rw;\n  float right = -p.x + roadW/2. + rw;\n  d = min( max(max(d, -left), left-rw), max( max(d, -right), right-rw) );\n  \n  return d;\n}\n\nfloat grass(vec3 p) {\n  float d = p.y + 1.0;\n  float rw = rumbleW;\n  float left = p.x + roadW/2. + rw;\n  float right = -p.x + roadW/2. + rw;\n  return min(max(d, left), max(d, right));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n  vec2 flooring = vec2(road(p), 0.5); // ID = 0.5\n  vec2 sphereLeft = vec2(sdSphere(p - vec3(-2.5, 0, -2), 1.), 1.5); // ID = 1.5\n  vec2 sphereRight = vec2(sdSphere(p - vec3(2.5, 0, -2), 1.), 2.5); // ID = 2.5\n  vec2 rumbling = vec2(rumble(p), 3.5); // ID = 3.5\n  vec2 grassing = vec2(grass(p), 4.5);\n  \n  res = opU(res, flooring);\n  res = opU(res, sphereLeft);\n  res = opU(res, sphereRight);\n  res = opU(res, rumbling);\n  res = opU(res, grassing);\n  return res; // the y-component is the ID of the object hit by the ray\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = COLOR_BACKGROUND;\n    \n    vec2 res = rayMarch(ro, rd);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n\n\tfloat id = res.y; // id of object\n    \n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    if (id > 0.) col = dif * vec3(0.7*mod(floor(p.x) + floor(p.z), 2.0), .5, .5);\n    if (id > 1.) col = dif * vec3(0, .8, .8);\n    if (id > 2.) col = dif * vec3(1, 0.58, 0.29);\n    if (id > 3.) col = dif * vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    if (id > 4.) col = dif * vec3(0, .7, .2);\n    \n    col += COLOR_BACKGROUND * 0.2; // add a bit of the background color to blend objects more with the scene\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(10.*sin(iTime), 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  \n  vec3 col = render(ro, rd);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 423, 423, 464], [466, 466, 486, 486, 657], [659, 659, 681, 681, 891], [893, 893, 914, 914, 1078], [1080, 1080, 1110, 1110, 1194], [1196, 1196, 1214, 1214, 1776], [1778, 1778, 1811, 1811, 2199], [2201, 2201, 2229, 2229, 2435], [2437, 2437, 2468, 2468, 3427], [3429, 3429, 3486, 3486, 3771]], "test": "untested"}
{"id": "7lGyzy", "name": "OdetoJoy-Beethoven", "author": "jorge2017a2", "description": "OdetoJoy-Beethoven.....play again...if you don't hear", "tags": ["odetojoybeethoven"], "likes": 11, "viewed": 249, "published": 3, "date": "1661707821", "time_retrieved": "2024-07-30T16:34:04.405585", "image_code": "//por jorge2017a2\n///por jorge flores P.--- :)  28-ago-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 noisemontanaCol(vec2 p, vec3 colIn, vec3 colOut, float ptime )\n{   float t=ptime;\n    float fx4a=sin(p.x);\n    float fx4b= 2.0*noise(vec2(3.*p.x+t*20.0,1.0))+fx4a;\n    float y41=p.y+fx4b;\n    float y42=p.y+4.0;\n    float y4e= differenceSDF(y41,y42);\n     colOut=DrawFigBorde(colIn, colOut,y4e);    \n    return colOut;\n    \n}\n\nvec3 monte(vec2 p, vec3 colOut, vec3 colIn)\n{   float t=0.0;\n    float x=p.x;\n    \n    float fx1=4. + 4.*smoothstep(0.0,0.7,sin(x+t));\n    float fx5=(t + floor(x-t))/2.0 - 5.0;\n    float fx6=sin(fx5 -0.5 )+2.0*(fx5/8.0);\n    \n    float y1=p.y+fx6;\n    float y2=p.y+2.0;\n    \n    float yg0= differenceSDF(y1,y2);\n    float fxy1=yg0;\n    \n    vec3 col;\n    col= DrawFigBorde(colIn, colOut, fxy1); \n    \n    return col;\n}\n\nvec3 edificios(vec2 uv, vec3 colOut, vec3 colIn)\n{   const float bands = 20.0;\n\tvec2 p;\n\tp.x = floor(uv.x*bands)/bands;\n\tp.y = uv.y;\n    // led shape\n\tfloat dx = fract( (uv.x - p.x) * bands) - 0.5;\n\tfloat led = smoothstep(0.5, 0.3, abs(dx));\t\n    float fft=random1d(p.x+sin(p.x*0.5));\n    fft-=random1d(p.x);\n    \n    float mask = (p.y*2.0 < fft) ? 1.0 : 0.0;\t\n    \n    vec3 col=mix( colIn*led*mask,colOut,1.0-abs(led*mask));\n    return col;\n}\n\nvec3 nubes(vec2 uv, vec3 colOut)\n{   vec3 col;\n    float d1,d2,d3;\n    float esc=0.75;\n     d1= sdCircle(uv, 1.0);\n     d2= sdCircle(uv-vec2(1.5,0.0), 1.5);\n     d3= sdCircle(uv-vec2(3.0,-0.25), 1.2);\n     float duni= unionSDF(d1, d2);\n     duni= unionSDF(duni,d3);\n     col= DrawFigBorde(vec3(1.0)+uv.y*0.5, colOut, duni);\n     return col;\n}\n\nvec3 sol(vec2 p, vec3 colOut)\n{    float d1= length(p)- 1.0;\n     colOut= DrawFigBorde(vec3(1.0), colOut, d1);\n     return colOut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    vec2 uva= fragCoord.xy/iResolution.xy;;\n    vec2 uv0=uv;\n    uv*=esc;\n    \n     vec3 col=vec3(0.0,0.0,0.5);\n    float t=iTime*0.25;\n    uv.x+=t*8.0;\n\n    float posxn1=mod(t*5.0 ,30.0);\n    float posxn2=mod(t*5.0 ,35.0);\n    \n    col= sol(uv0*8.0-vec2(6.0,7.0), col);\n    col= nubes(uv0*6.0-vec2(-15.0+posxn1,4.5),col);\n    col= nubes(uv0*6.0-vec2(-20.0+posxn2,6.0),col);\n    col= monte(uv0*5.0-vec2(0.0+t,-0.1), col, vec3(1.0) );\n    col= monte(uv0*5.0-vec2(0.0+t,-0.2), col, vec3(0.15) );\n    col=edificios(uva+vec2(2.0-t*0.25,-0.25),col,vec3(0.25)); \n    col= noisemontanaCol(uv-vec2(0.0,2.0),vec3(0.0,0.0,0.3), col,1. );\n    col= noisemontanaCol(uv-vec2(1.0,1.0),vec3(0.0,0.2,0.9), col,2.0 );\n    col= noisemontanaCol(uv-vec2(0.0,0.0),vec3(0.0,0.0,1.0), col,3.0 );\n    col=edificios(uva+vec2(0.0+t,0.0),col, vec3(0.4,0.2,0.5)); \n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///tool sound  and random\n\n//version D \n////Octava #1\n//--fin--\n////Octava #2\n const float A0 =27.5;  //1\n const float A_0 =29.14;  //2\n const float B0 =30.87;  //3\n//--fin--\n////Octava #3\n const float C1 =32.7;  //4\n const float C_1 =34.65;  //5\n const float D1 =36.71;  //6\n const float D_1 =38.89;  //7\n const float E1 =41.2;  //8\n const float F1 =43.65;  //9\n const float F_1 =46.25;  //10\n const float G1 =49.0;  //11\n const float G_1 =51.91;  //12\n const float A1 =55.;  //13\n const float A_1 =58.27;  //14\n const float B1 =61.74;  //15\n//--fin--\n////Octava #4\n const float C2 =65.41;  //16\n const float C_2 =69.3;  //17\n const float D2 =73.42;  //18\n const float D_2 =77.78;  //19\n const float E2 =82.41;  //20\n const float F2 =87.31;  //21\n const float F_2 =92.5;  //22\n const float G2 =98.;  //23\n const float G_2 =103.83;  //24\n const float A2 =110.;  //25\n const float A_2 =116.54;  //26\n const float B2 =123.47;  //27\n//--fin--\n////Octava #5\n const float C3 =130.81;  //28\n const float C_3 =138.59;  //29\n const float D3 =146.83;  //30\n const float D_3 =155.56;  //31\n const float E3 =164.81;  //32\n const float F3 =174.61;  //33\n const float F_3 =185.;  //34\n const float G3 =196.;  //35\n const float G_3 =207.65;  //36\n const float A3 =220.;  //37\n const float A_3 =233.08;  //38\n const float B3 =246.94;  //39\n//--fin--\n////Octava #6\n const float C4 =261.63;  //40\n const float C_4 =277.18;  //41\n const float D4 =293.66;  //42\n const float D_4 =311.13;  //43\n const float E4 =329.63;  //44\n const float F4 =349.23;  //45\n const float F_4 =369.99;  //46\n const float G4 =392.;  //47\n const float G_4 =415.3;  //48\n const float A4 =440.;  //49\n const float A_4 =466.16;  //50\n const float B4 =493.88;  //51\n//--fin--\n////Octava #7\n const float C5 =523.25;  //52\n const float C_5 =554.37;  //53\n const float D5 =587.33;  //54\n const float D_5 =622.25;  //55\n const float E5 =659.26;  //56\n const float F5 =698.46;  //57\n const float F_5 =739.99;  //58\n const float G5 =783.99;  //59\n const float G_5 =830.61;  //60\n const float A5 =880.;  //61\n const float A_5 =932.33;  //62\n const float B5 =987.77;  //63\n//--fin--\n////Octava #8\n const float C6 =1046.5;  //64\n const float C_6 =1108.73;  //65\n const float D6 =1174.66;  //66\n const float D_6 =1244.51;  //67\n const float E6 =1318.51;  //68\n const float F6 =1396.91;  //69\n const float F_6 =1479.98;  //70\n const float G6 =1567.98;  //71\n const float G_6 =1661.22;  //72\n const float A6 =1760.;  //73\n const float A_6 =1864.66;  //74\n const float B6 =1975.53;  //75\n//--fin--\n////Octava #9\n const float C7 =2093.;  //76\n const float C_7 =2217.46;  //77\n const float D7 =2349.32;  //78\n const float D_7 =2489.02;  //79\n const float E7 =2637.02;  //80\n const float F7 =2793.83;  //81\n const float F_7 =2959.96;  //82\n const float G7 =3135.96;  //83\n const float G_7 =3322.44;  //84\n const float A7 =3520.;  //85\n const float A_7 =3729.31;  //86\n const float B7 =3951.07;  //87\n//--fin--\n////Octava #10\n const float C8 =4186.01;  //88\n const float C_8 =4434.92;  //89\n const float D8 =4698.64;  //90\n const float D_8 =4978.03;  //91\n const float E8 =5274.04;  //92\n const float F8 =5587.65;  //93\n const float F_8 =5919.91;  //94\n const float G8 =6271.93;  //95\n const float G_8 =6644.88;  //96\n const float A8 =7040.;  //97\n const float A_8 =7458.62;  //98\n const float B8 =7902.13;  //99\n//--fin--\n\n\n// Durations\nconst float WHOLE_NOTE = 1.0;\nconst float HALF_NOTE = 1.0/2.0;\nconst float _4_NOTE = 1.0/4.0;\nconst float _8_NOTE = 1.0/8.0;\nconst float _16_NOTE = 1.0/16.0;\nconst float _32_NOTE = 1.0/32.0;\nconst float DOUBLE_NOTE = 2.0;\n\n//octava\nconst float _0oct8=0.0/8.0;\nconst float _1oct8=1.0/8.0;\nconst float _2oct8=2.0/8.0;\nconst float _3oct8=3.0/8.0;\nconst float _4oct8=4.0/8.0;\nconst float _5oct8=5.0/8.0;\nconst float _6oct8=6.0/8.0;\nconst float _7oct8=7.0/8.0;\nconst float _8oct8=8.0/8.0;\n\nconst float _1cua4=1.0/4.0;\nconst float _2cua4=2.0/4.0;\nconst float _3cua4=3.0/4.0;\nconst float _4cua4=4.0/4.0;\n\nconst float _1med2=1.0/2.0;\n\nconst float _t1=1.0;\nconst float _t2=2.0;\nconst float _t3=3.0;\nconst float _t4=4.0;\nconst float _t5=5.0;\n\nconst float _1hex16=1.0/16.0;\nconst float _2hex16=2.0/16.0;\nconst float _3hex16=3.0/16.0;\nconst float _4hex16=4.0/16.0;\n\n\n\n\n\n///-----------random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n\nfloat random1d( float  v ) \n{\treturn fract(sin(dot( vec2(v,v), vec2(114.0, 514.0))) * 1919810.0) * 2.0 - 1.0; }\n\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\n\n\n", "sound_code": "///por jorge flores P.--- :)  28-ago-2022\nstruct Note {\n    // in Hz, see \"common\" tab\n    float frequency;\n    // offset - time in seconds when to start playing note\n    float offset;\n    // duration of a note (1/4, 1/8, ...), see \"common\" tab\n    float duration;\n};\n\nconst Note[] notes = Note[] (\nNote(C4,0.0,1.),\nNote(E5,0.0,0.25),\nNote(E5,0.25,0.25),\nNote(F5,0.5,0.25),\nNote(G5,0.75,0.25),\nNote(B3,1.0,1.),\nNote(G5,1.0,0.25),\nNote(F5,1.25,0.25),\nNote(E5,1.5,0.25),\nNote(D5,1.75,0.25),\nNote(C4,2.0,1.),\nNote(C5,2.0,0.25),\nNote(C5,2.25,0.25),\nNote(D5,2.5,0.25),\nNote(E5,2.75,0.25),\nNote(B3,3.0,0.5),\nNote(E5,3.0,0.375),\nNote(D5,3.375,0.125),\nNote(G3,3.5,0.5),\nNote(D5,3.5,0.5),\nNote(C3,4.0,1.),\nNote(E5,4.0,0.25),\nNote(E5,4.25,0.25),\nNote(F5,4.5,0.25),\nNote(G5,4.75,0.25),\nNote(G2,5.0,1.),\nNote(G5,5.0,0.25),\nNote(F5,5.25,0.25),\nNote(E5,5.5,0.25),\nNote(D5,5.75,0.25),\nNote(C3,6.0,1.),\nNote(C5,6.0,0.25),\nNote(C5,6.25,0.25),\nNote(D5,6.5,0.25),\nNote(E5,6.75,0.25),\nNote(D3,7.0,0.5),\nNote(D5,7.0,0.375),\nNote(C5,7.375,0.125),\nNote(C3,7.5,0.5),\nNote(C5,7.5,0.5),\nNote(G3,8.0,1.),\nNote(D5,8.0,0.25),\nNote(D5,8.25,0.25),\nNote(E5,8.5,0.25),\nNote(C5,8.75,0.25),\nNote(G3,9.0,1.),\nNote(D5,9.0,0.25),\nNote(E5,9.25,0.125),\nNote(F5,9.375,0.125),\nNote(E5,9.5,0.25),\nNote(C5,9.75,0.25),\nNote(G3,10.0,0.5),\nNote(D5,10.0,0.25),\nNote(E5,10.25,0.125),\nNote(F5,10.375,0.125),\nNote(A_3,10.5,0.5),\nNote(E5,10.5,0.25),\nNote(D5,10.75,0.25),\nNote(A3,11.0,0.25),\nNote(C5,11.0,0.25),\nNote(F_3,11.25,0.25),\nNote(D5,11.25,0.25),\nNote(B2,11.5,0.5),\nNote(G4,11.5,0.5),\nNote(C3,12.0,1.),\nNote(E5,12.0,0.25),\nNote(E5,12.25,0.25),\nNote(F5,12.5,0.25),\nNote(G5,12.75,0.25),\nNote(B2,13.0,1.),\nNote(G5,13.0,0.25),\nNote(F5,13.25,0.25),\nNote(E5,13.5,0.25),\nNote(D5,13.75,0.25),\nNote(C3,14.0,1.),\nNote(C5,14.0,0.25),\nNote(C5,14.25,0.25),\nNote(D5,14.5,0.25),\nNote(E5,14.75,0.25),\nNote(B2,15.0,1.),\nNote(E5,15.0,0.375),\nNote(D5,15.375,0.125),\nNote(D5,15.5,0.5)\n\n\n);\n\nfloat Weight( float x )\n{  if( x < 0.0 )x = - x;\n\tif( x < 1.0 )return (1.0 - 2.0*x*x + x*x*x) ;\n\tif( x < 2.0 )return (4.0 - 8.*x + 5.*x*x - x*x*x) ;\n\treturn 0.0 ;\n}\n\nfloat saw(float t, float note, float octave)\n{   return fract(t*note*exp2(octave-1.))-0.5;}\n\n\nvec2 noteFreq(Note note, float time)\n{   float octava=3.0;\n    float n1=saw(time,note.frequency, octava)* exp(-1.0/note.duration * (time - note.offset));  ///ORIGINAL\n    \n    float n1a=n1+pow(n1, 2.0);\n    float t=time;\n    \n    n1=Weight(n1)*n1+n1a;\n    return vec2(n1*0.25);\n}\n\n\nvec2 mainSound( in int samp,float time) \n{   vec2 result;\n    float tt=sin(time*0.25)+2.0*sin(time*0.25+5.0*cos(time*0.125));\n    float ftime=time;\n    ftime= mod(ftime*0.5, 20.0);\n    \n    for (int i = 0; i < notes.length(); i++) \n    {\n        //Note(D5,15.5,0.5)    \n        Note note = notes[i];\n        float x = float(i) * 1.0;\n        \n        if (ftime >= note.offset) \n        {\n            result += noteFreq(note, ftime);            \n        }\n    }\n    return result*0.35;\n    \n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 380, 380, 425], [431, 431, 478, 478, 505], [506, 506, 549, 549, 576], [577, 577, 625, 625, 653], [656, 656, 728, 728, 854], [856, 856, 918, 918, 1048], [1050, 1050, 1131, 1131, 1259], [1261, 1261, 1318, 1318, 1388], [1390, 1390, 1452, 1452, 1517], [1519, 1519, 1587, 1587, 1655], [1657, 1657, 1721, 1721, 1792], [1796, 1796, 1830, 1830, 1926], [1927, 1927, 1961, 1961, 2052], [2053, 2053, 2087, 2087, 2178], [2179, 2179, 2213, 2213, 2308], [2310, 2310, 2347, 2347, 2421], [2423, 2423, 2458, 2458, 2481], [2483, 2483, 2552, 2552, 2812], [2814, 2814, 2859, 2859, 3232], [3234, 3234, 3284, 3284, 3677], [3679, 3679, 3713, 3713, 4021], [4023, 4023, 4054, 4054, 4155], [4157, 4157, 4214, 4214, 5258]], "test": "untested"}
{"id": "flyczG", "name": "Common subexpression elimination", "author": "ttg", "description": "A demonstration of what not to optimize: repeated small expressions.\n\nAt default res this shader runs for me at 30fps.  Uncommenting MONSTER does not change this.  But that is >12000 transcendental functions!  The compiler merges common expressions.", "tags": ["optimization", "compiler"], "likes": 2, "viewed": 287, "published": 3, "date": "1661666430", "time_retrieved": "2024-07-30T16:34:05.317148", "image_code": "/*\nA demonstration of what not to optimize: repeated small expressions.\n\nAt default res this shader runs for me at 30fps.\nUncommenting MONSTER does not change this.\nBut that is >12000 transcendental functions, per loop iteration!\nThe compiler merges common expressions.\n\nIf crash: sorry, your system shader compiler lacks this optimization!\nIf \"out of memory\" error or strange error: try changing RESULT to lower level.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  float total=0.;\n  for (int i=0;i<400;i++) {\n    uv.x+=.0001;\n\n#define STEP(a,b) (2.1*cos((a)-exp(-sin(b))))\n\n//#define MONSTER\n\n#ifndef MONSTER\n    float x0 = STEP(uv.x,uv.y);\n    float x1 = STEP(x0,x0);\n    float x2 = STEP(x1,x1);\n    float x3 = STEP(x2,x2);\n    float x4 = STEP(x3,x3);\n    float x5 = STEP(x4,x4);\n    float x6 = STEP(x5,x5);\n    float x7 = STEP(x6,x6);\n    float x8 = STEP(x7,x7);\n    float x9 = STEP(x8,x8);\n    float x10 = STEP(x9,x9);\n    float x11 = STEP(x10,x10);\n    float x12 = STEP(x11,x11);\n#else // defined MONSTER\n    #define x0 STEP(uv.x,uv.y) //     33-char expression with    1 sin,cos,exp\n    #define x1 STEP(x0,x0)     //     91-char expression with    3 sin,cos,exp\n    #define x2 STEP(x1,x1)     //    207-char expression with    7 sin,cos,exp\n    #define x3 STEP(x2,x2)     //    439-char expression with   15 sin,cos,exp\n    #define x4 STEP(x3,x3)     //    903-char expression with   31 sin,cos,exp\n    #define x5 STEP(x4,x4)     //   1831-char expression with   63 sin,cos,exp\n    #define x6 STEP(x5,x5)     //   3687-char expression with  127 sin,cos,exp\n    #define x7 STEP(x6,x6)     //   7399-char expression with  255 sin,cos,exp\n    #define x8 STEP(x7,x7)     //  14823-char expression with  511 sin,cos,exp\n    #define x9 STEP(x8,x8)     //  29671-char expression with 1023 sin,cos,exp\n    #define x10 STEP(x9,x9)    //  59367-char expression with 2047 sin,cos,exp\n    #define x11 STEP(x10,x10)  // 118759-char expression with 4095 sin,cos,exp\n    #define x12 STEP(x11,x11)  // 237543-char expression with 8191 sin,cos,exp\n#endif\n    #define RESULT x7\n    //#define RESULT x8    // MONSTER: Nvidia: \"')' : out of memory\" \n    total+=RESULT/400.;\n  }\n  fragColor = vec4(total)/3.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 425, 482, 482, 2252]], "test": "untested"}
{"id": "ftGyRy", "name": "Yet Another Bloom Shader", "author": "QuarksAndLeptons", "description": "Bloom shaders have already been done hundreds of times, but I like how this one is subtle yet capable of enhancing the color and value of an image. \n", "tags": ["imageprocessing", "bloom"], "likes": 0, "viewed": 340, "published": 3, "date": "1661665373", "time_retrieved": "2024-07-30T16:34:06.120999", "image_code": "// The MIT License\n// Copyright © 2022 Micah Mundy\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Slide the mouse cursor over the image to compare the \n// results of the bloom effect with the original image.\n\n\n// The size of the most significant blur kernel\n// Note: blurring is done for free with mipmaps!\n#define LEVELS 12\n// The size of the least significant blur kernel\n#define BLURSIZE 3\n\n// Uncomment the line below to see how the bloom effect contributes to the image.\n//#define ONLY_SHOW_BLOOM 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float minDim = min(iResolution.x, iResolution.y);\n    //vec2 fc2 = fragCoord - iResolution.xy/2.0;\n\t//vec2 uv = fc2 / vec2(minDim, minDim);\n\t//vec2 uv = fragCoord.xy / vec2(minDim, minDim);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //float power = iMouse.x/iResolution.x*3.0;\n    //float threshold = iMouse.y/iResolution.y;\n    //float mixAmount = 0.3;\n    \n    float power = 1.0;\n    float threshold = 2.5;\n    float mixAmount = 0.6;\n    float subAmount = 0.1;\n\t\n\t\n\tvec4 col = vec4(0.0);\n    float highP = 0.0;\n    for(int i = LEVELS; i > BLURSIZE; i-=2){\n        col = col + texture( iChannel0, uv, float(i) );\n        highP = highP + 1.0;\n        col = col * power;\n        highP = highP * power; // TODO calculate highP at compile-time.\n    }\n    col = max(col-vec4(threshold), vec4(0.0)); \n    highP = highP - threshold;\n    \n    col = col / vec4(highP);\n    \n    #ifndef ONLY_SHOW_BLOOM\n    col = col*vec4(mixAmount) + texture( iChannel0, uv) - vec4(subAmount);\n    #endif\n    \n    //col = col * vec4(step(uv.x, iMouse.z/iResolution.x));\n    \n    if(uv.x<iMouse.x/iResolution.x){\n        col = texture( iChannel0, uv);\n    }\n    //col = mix(texture( iChannel0, uv), col, mixAmount);\n    \n\t\n\tfragColor = col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGyRy.jpg", "access": "api", "license": "mit", "functions": [[1489, 1489, 1546, 1792, 2830]], "test": "untested"}
{"id": "flycRG", "name": "Leaf carpet pattern", "author": "jarble", "description": "A simple carpet pattern.", "tags": ["fractal", "leaf", "carpet", "rug"], "likes": 1, "viewed": 184, "published": 3, "date": "1661653357", "time_retrieved": "2024-07-30T16:34:06.969729", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 15; k++){\n        uv = (uv-(.5-t2/2.))/2.;\n        t2 = -triangle_wave(uv-.5);\n        uv = t2-triangle_wave(uv.yx);\n        col = abs(vec3(uv.y-uv.x,col.yz));\n        if(t2.x*uv.x < t2.y*uv.y) col = abs(.5-col.yzx);\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flycRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 628]], "test": "untested"}
{"id": "ftGcRG", "name": "Red and gold rug", "author": "jarble", "description": "A simple rug pattern.", "tags": ["fractal", "music", "carpet", "rug"], "likes": 4, "viewed": 257, "published": 3, "date": "1661649614", "time_retrieved": "2024-07-30T16:34:07.720721", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 18; k++){\n        uv = (uv+t2)/scale;\n        t2 = -triangle_wave(uv-.5);\n        uv = t2-triangle_wave(uv.yx);\n        col = abs(vec3(uv.y-uv.x,col.yz));\n        if(t2.x < t2.y) {col = col.yzx; uv=abs(uv/2.);}\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  \n  float t=(time)/4.;\n  \n  float m1 = mod(floor(t),4.);\n  //t *= 1. + m1;\n  float m3 = mod(floor(t/abs(2.5-m1)),4.),\n  t1 = 2.+m1;\n  //t /= floor(1.+mod(t*2.,2.));\n  \n  t *= 16.;\n  float m2 = 1. + min(mod(floor(t),2.),t);\n\n  //t *= m1/2.+1.;\n  \n  float a=sqrt(1.-fract(t1/4./m2))*.2,\n  \n  nb = pow(2.,mod(floor(t/(8.)/m2),8.)/4.+m3/4.+7.)*(1.-mod(floor(t/2.),t1)/t1);\n  //nb = pow(2.,mod(floor(t),8.)/2.+7.)*(1.-mod(floor(t/2.),t1)/t1);\n\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 625]], "test": "untested"}
{"id": "flKcDw", "name": "Catmull-Roms!", "author": "HeavyPaws", "description": "A fully featured, parameterized Catmull-Rom Spline demonstration, revealing that this can in fact work as a shader, even though it is computationally expensive.  Multiple optimizations where implemented to continue to fit running at 60 fps on an older GPU", "tags": ["splinehp"], "likes": 1, "viewed": 180, "published": 3, "date": "1661631828", "time_retrieved": "2024-07-30T16:34:08.492657", "image_code": "///////////////////////////////////////////////////////////////\n//\n// Cathmul-Rom Spline Demo                   by:  HeavyPaws\n//\n///////////////////////////////////////////////////////////////\n//\n// Changelog:\n//\n// Release 1.0 - Initial experiment completion\n// Release 1.1 - Further optimization to save callstack and\n//               some mul/div instructions, and an entire for\n//               loop!  Now entirely stable at 60 FPS. \n//\n///////////////////////////////////////////////////////////////\n//\n// Original shadertoy from which this was expanded:\n//     https://www.shadertoy.com/view/tdGcRh\n//\n///////////////////////////////////////////////////////////////\n//\n// Released under the DBAD License as open source code:\n//     https://dbad-license.org/\n//\n// You may use, modify, or redistrobute code as long as credit\n// to the original author is provided, and you are not being\n// a dick in terms with the license!\n//\n// If you would like to help improve this project as it is now\n// fully open source, you can do so and let me know!\n//\n///////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////\n//\n// Params\n//\n///////////////////////////////////////////////////////////////\n\n#define time (iTime/1.0)\n#define VEC2D_UP vec2(0.0,1.0)\n#define LINES 8\n#define STEP 1.0/float(LINES)\n#define POINTS 10\n#define MAX_POINTS POINTS\n#define ALPHA 1.0f\n#define TENSION 0.0f\n#define SUBDIVISIONS 20\n#define LENGTH_PRECISION 0.1f\n#define PI acos(-1.0)\n#define TAU acos(-1.0)*2.0f\n\n// Updated each iteration.  Don't mess with these.\nvec2 pixel_uv;\nfloat spline_length, segment_length;\nvec2 pin_block[MAX_POINTS];\nfloat position;\n\n///////////////////////////////////////////////////////////////\n//\n// Math\n//\n///////////////////////////////////////////////////////////////\n\nfloat point(vec2 o) { return smoothstep(10.0/iResolution.y,7.5/iResolution.y,length(pixel_uv-o)); }\n\nvec2 rotate2d(vec2 point, float degree, vec2 pivot)\n{\n    float radAngle = -radians(degree);\n    float x = point.x;\n    float y = point.y;\n    float rX = pivot.x + (x - pivot.x) * cos(radAngle) - (y - pivot.y) * sin(radAngle);\n    float rY = pivot.y + (x - pivot.x) * sin(radAngle) + (y - pivot.y) * cos(radAngle);\n    return vec2(rX, rY);\n}\n\nfloat cross2D(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\n\nfloat line(vec2 a, vec2 b) {\n\tvec2 v  = b-a;\n    vec2 p0 = pixel_uv-a;\n    float k = min(length(p0)/length(v),1.0);\n    return smoothstep(4.0/iResolution.y,0.0,length(p0-k*v));\n}\n\nvec2[MAX_POINTS] deformedCircle(int count) {\n    vec2 p[MAX_POINTS];\n    for (int i = 0; i < count; i++) {\n        float a = float(i) / float(count) * TAU;\n        p[i] = vec2(3.0, 1.5) * vec2(cos(a), sin(a)) * (0.30 + 0.03 * sin(iTime) + 0.03 * sin(a * PI + iTime));\n    }\n    return p;\n}\n\nfloat sinewarp(float speed) {\n    float p = sin(iTime) * speed;\n    return p;\n}\n\n///////////////////////////////////////////////////////////////\n//\n// Cathmul-Rom Spline\n//\n///////////////////////////////////////////////////////////////\n\n// Commented functions are previously working code that\n// has been commented but not removed for documentation-sake.\n\n/*\nvec2 splineStartTangent(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    \n    float t01 = pow(distance(p0, p1), ALPHA);\n\tfloat t12 = pow(distance(p1, p2), ALPHA);\n    \n\tvec2 m1 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));\n    return m1;\n}\n*/\n\n/*\nvec2 splineEndTangent(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    \n\tfloat t12 = pow(distance(p1, p2), ALPHA);\n\tfloat t23 = pow(distance(p2, p3), ALPHA);\n\n\tvec2 m2 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));\n    return m2;\n}\n*/\n\n// UPDATE:  Packing in splineStartTangent and splineEndTangent\n//          to reduce callstack and number of muls.\nvec2 splinePosition(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    float t01 = pow(distance(p0, p1), ALPHA);\n\tfloat t12 = pow(distance(p1, p2), ALPHA);\n  \tfloat t23 = pow(distance(p2, p3), ALPHA);\n    float tt = t * t;\n\tfloat ttt = tt * t;\n    \n\tvec2 m1 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));\n\tvec2 m2 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));\n\n\tvec2 a = 2.0f * (p1 - p2) + m1 + m2;\n\tvec2 b = -3.0f * (p1 - p2) - m1 - m1 - m2;\n\tvec2 c = m1;\n\tvec2 d = p1;\n\n\treturn a * ttt +\n           b * tt +\n           c * t +\n           d;\n}\n\nvec2 splineTangent(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n\tfloat tt = t * t;\n    \n    float q1 = (-3.0f * tt + 4.0f * t - 1.0f);\n    float q2 = (9.0f * tt - 10.0f * t);\n    float q3 = (-9.0f * tt + 8.0f * t + 1.0f);\n    float q4 = (3.0f * tt - 2.0f * t);\n\n\tfloat tx = 0.5f * (p0.x * q1 + p1.x * q2 + p2.x * q3 + p3.x * q4);\n\tfloat ty = 0.5f * (p0.y * q1 + p1.y * q2 + p2.y * q3 + p3.y * q4);\n\n    return vec2 (tx, ty);\n}\n\nvec2 splineRotator(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    vec2 a = splineTangent(p0, p1, p2, p3, t);\n    float angle = atan(-a.y, a.x);\n    return vec2(sin(angle), cos(angle));\n}\n\n\n/*\n// WARNING: Do not calculate more than once per spline per frame, is expensive.\nfloat splineLength(vec2 points[MAX_POINTS]) {\n    float l = 0.0f;\n    for (int i = 1; i < points.length() - 3; i++) {\n        vec2 p0 = points[i-1];\n        vec2 p1 = points[i];\n        vec2 p2 = points[i+1];\n        vec2 p3 = points[i+2];   \n        vec2 a = p1, b;\n        for (float j = 0.0f; j <= 1.0f; j += LENGTH_PRECISION) { \n            vec2 b = splinePosition(p0, p1, p2, p3, j);\n            l += pow(distance(a, b), ALPHA);\n            a = b;\n        }\n    }\n    return l;\n}\n*/\n\n/* vec2 splineRealPosition(vec2 points[MAX_POINTS], float l) {\n    float adjusted_maxIndex = float(points.length()) - 3.0f;\n    int pointIndex = int(floor(adjusted_maxIndex * ( l / spline_length)));\n    float pointOffset = \n        clamp((adjusted_maxIndex * ( l / spline_length)) - float(pointIndex), 0.0f, 1.0f);\n    \n    vec2 result = splinePosition(\n        points[pointIndex], \n        points[pointIndex+1], \n        points[pointIndex+2], \n        points[pointIndex+3], \n        pointOffset);\n    return result;\n} */\n\n/*\nvec2 splineRealRotator(vec2 points[MAX_POINTS], float l) {\n    float adjusted_maxIndex = float(points.length()) - 3.0f;\n    int pointIndex = 1 + int(floor(adjusted_maxIndex * ( l / spline_length)));\n    float pointOffset =\n        clamp((1.0f + (adjusted_maxIndex * ( l / spline_length))) - float(pointIndex), 0.0f, 1.0f);\n    vec2 result = splineRotator(\n        points[pointIndex-1],    \n        points[pointIndex], \n        points[pointIndex+1], \n        points[pointIndex+2],\n        pointOffset);\n    return result;\n} */\n\n// UPDATE:  Pack in splineRealPosition and splineRealRotator\n//          to reduce callstack and number of muls/divs.\nfloat draw_spline_marker(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float marker;\n    float pointTime = (segment_length * t) / segment_length;\n    vec2 r = splineRotator(p0, p1, p2, p3, pointTime);\n    vec2 qp = splinePosition(p0, p1, p2, p3, pointTime);\n    vec2 f = -0.1f * r + qp;\n    vec2 h = 0.1f * r + qp;\n    marker = mix(marker, 1.0f, point(f));\n    marker = mix(marker, 1.0f, point(h));\n    marker = mix(marker, 1.0f, line(f,h));\n    return marker;\n}\n\n///////////////////////////////////////////////////////////////\n//\n// Datablocks\n//\n///////////////////////////////////////////////////////////////\n\n// UPDATE:  Spline length is now calculated in splineRenderBlock\n//          to save an additional for loop and callstack.\nvoid splineGetPinBlock(void) {\n    pin_block = deformedCircle(POINTS);\n    // spline_length = splineLength(pin_block);\n}\n\n// UPDATE:  Spline length now happening in core loop.\nvec3 splineRenderBlock(void) {\n    vec3 color, drawColor;\n    spline_length = 0.0f;\n    vec2 p0, p1, p2, p3, a, b, c;\n    for (int i = 0; i < (MAX_POINTS - 3); i++) {\n        p0 = pin_block[i];\n        p1 = pin_block[i+1];\n        p2 = pin_block[i+2];\n        p3 = pin_block[i+3];          \n\n        a = p1; c = a; segment_length = 0.0f;\n        for (int j = 1; j <= LINES; j++) {\n            b = splinePosition(p0, p1, p2, p3, STEP*float(j));\n            segment_length += abs(distance(a, b));\n\n            // Draw control lines\n            if (j == LINES - 1) {\n                drawColor = vec3(0.2,0.2,0.2);\n                color = mix(color, drawColor, line(c, b));\n                drawColor = vec3(1.0,1.0,0.0);\n                color = mix(color, drawColor, point(c));    \n            }\n            \n            if (j == LINES) {\n                drawColor = vec3(1.0,1.0,0.0);\n                color = mix(color, drawColor, point(p2)); \n                float t = 0.0f;\n                while (t <= 1.0f) {\n                   drawColor = vec3(0.0,0.0,1.0);\n                   color = mix(color, drawColor, draw_spline_marker(p0, p1, p2, p3, t));\n                   t += 1.0f / float(SUBDIVISIONS);\n                }\n            }\n\n            // Draw curve\n            drawColor = vec3(1.0,1.0,1.0);\n            color = mix(color, drawColor, line(a, b));\n            a = b;\n        }     \n    }\n    \n    return color;\n}\n\n///////////////////////////////////////////////////////////////\n//\n// Main\n//\n///////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    pixel_uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0.94);\n    \n    splineGetPinBlock();\n    color = splineRenderBlock();\n\n\tfragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1843, 1843, 1864, 1864, 1942], [1944, 1944, 1997, 1997, 2285], [2287, 2287, 2318, 2318, 2350], [2352, 2352, 2380, 2380, 2530], [2823, 2823, 2852, 2852, 2902], [3737, 3852, 3918, 3918, 4481], [4483, 4483, 4548, 4548, 4911], [4913, 4913, 4978, 4978, 5103], [6731, 6849, 6920, 6920, 7316], [7467, 7590, 7620, 7620, 7710], [7712, 7766, 7796, 7796, 9187], [9332, 9332, 9389, 9389, 9580]], "test": "untested"}
{"id": "ssjczc", "name": "2D Sphere Shield", "author": "W_Master", "description": "I tried making a pattern such that it looks like a spherical force field seen from above, for a 2D game. I'm not very satisfied, because I made part of some shapes inside another shape's coordinates. I've yet to learn how to do this better.", "tags": ["sphere"], "likes": 7, "viewed": 339, "published": 3, "date": "1661629721", "time_retrieved": "2024-07-30T16:34:09.234673", "image_code": "#define PI 3.1416\n\nfloat center(float a, float b, float c)\n{\n    return min(max(a,b),min(max(a,c),max(b,c)));\n}\n\nfloat segDist(vec2 a, vec2 b, vec2 point)\n{\n    vec2 ab = b - a;\n    vec2 ap = point - a;\n    vec2 segp = a + dot(ap, ab) / dot(ab, ab) * ab;\n    \n    segp.x = center(segp.x, a.x, b.x);\n    segp.y = center(segp.y, a.y, b.y);\n    \n    vec2 toSeg = point - segp;\n    \n    return length(toSeg);\n}\n\nfloat shapeDist(vec2 uv, float top)\n{\n    uv.x = .5-abs(0.5-uv.x);\n    float slope = 1./1.5;\n    float pos = 5./8.;\n    float line = max(0., (uv.y-pos)*slope);\n    float area = uv.x - line;\n    area = 1.-step(0., area);\n    \n    //dis = smoothstep(0.05,0.,dis);\n    \n    float dis = segDist(vec2(0,0), vec2(0,5./8.), uv);\n    dis = min(dis, segDist(vec2(0,5./8.), vec2(0.25, 1.), uv));\n    dis = min(dis, segDist(vec2(0.25,1.), vec2(0.5, 1.), uv));\n    dis = min(dis, segDist(vec2(0,0), vec2(0.5, (1.-top)*-0.65), uv));\n    dis *= (1.0 + area * 0.9);\n    return dis;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y/iResolution.x;\n    uv *= 3.0;\n    \n    float t = iTime * 0.4;\n    \n    vec3 col = vec3(0);\n    \n    float r = 1.3;\n    float l = length(uv);\n    float v = asin(l/r) / PI * 2.0; // 0 - 1\n    \n    float bandSize = 0.2;\n    float divisions = 4.0;\n    float p = fract(t);\n    float band = 1.-smoothstep(0., bandSize, abs(fract(v*divisions)-p));\n    band += 1.-smoothstep(0., bandSize, abs(fract(v*divisions)-p-1.));\n    band += 1.-smoothstep(0., bandSize, abs(fract(v*divisions)-p+1.));\n    \n    \n    float divs = 5.0;\n    float u = fract(v*divs);\n    float x1 = atan(uv.x, uv.y)/2./PI+0.5;\n    \n    float level = floor(v*divs);\n    float sections = 4.0 * pow(2.,level);\n    float sector = floor(fract(x1 + .5/sections) *sections);\n    sector += fract(level*0.5)*2.;\n    sector += max(2., level);\n    float x = fract(x1*sections);\n    \n    if (level > 0.0)\n        x = fract(x + 0.5);\n    \n    vec2 cellUV = vec2(x,u);\n    float top = 1.-fract(sector * 0.5)*2.;\n    float dist = shapeDist(cellUV, top);\n    \n    float thickness = 0.01 * (2.0+level*0.3);\n    float outline = smoothstep(thickness,0.,abs(dist-0.07));\n    float inner = smoothstep(thickness,0., 0.07-dist);\n    float a = min(1., outline + inner);\n    \n    float shieldOutline = smoothstep(0.01,0.,abs(l/r-1.));\n    float shieldCenter = smoothstep(0.05,0.04,l/r);\n    outline = mix(outline, 1., shieldCenter);\n    \n    float innerPhase = smoothstep(0.25, 0.75, abs(0.5-fract(0.5 * iTime)));\n    //inner *= (0.5 + 0.4 * innerPhase);\n    inner *= 0.5;\n    col = vec3(0);\n    col.z = outline + inner * 0.3;\n    col.y = outline * band + inner * 0.2;\n    col.y = col.y * 0.5 + 0.5 * outline;\n    \n    col = mix(col, vec3(0.1,0.4,0.9), shieldOutline);\n    \n    fragColor = vec4(col,a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 60, 60, 111], [113, 113, 156, 156, 406], [408, 408, 445, 445, 976], [978, 978, 1035, 1035, 2856]], "test": "untested"}
{"id": "7lVcDw", "name": "drawQuad", "author": "Behzod", "description": "square which up and dw sidee are parallel to each other", "tags": ["square"], "likes": 1, "viewed": 204, "published": 3, "date": "1661622491", "time_retrieved": "2024-07-30T16:34:09.978687", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a triangle. Negative in the inside, positive in the outside.\n// Note there's only one square root involved. The clamp(x,a,b) is really just\n// max(a,min(b,x)). The sign(x) function is |x|/x. \n\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// Other triangle functions:\n//\n// Distance:   https://www.shadertoy.com/view/XsXSz4\n// Gradient:   https://www.shadertoy.com/view/tlVyWh\n// Boundaries: https://www.shadertoy.com/view/tlKcDz\n\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 + e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat drawQuad(in vec2 p, vec2 v1, float w1, vec2 v2, float w2){\n    float t1 = sdTriangle(p, v1+vec2(-w1/2.,0.0),v1+vec2(w1/2.,0.0),v2+vec2(w2/2.,0));\n    return min(t1, sdTriangle( p,v1+vec2(-w1/2.,0.0),v2-vec2(w2/2.,0),v2+vec2(w2/2.,0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    m *= 1.5;\n    \n    // animate\n\tvec2 v1 = vec2(1.4,1.0)*cos( iTime*vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = vec2(1.4,1.0)*cos( iTime*vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = vec2(1.4,1.0)*cos( iTime*vec2(0.0,3.00) + 4.0 );\nv3 = abs(v3);\n    // distance\n\tfloat d = sdTriangle( p, v1, v2, v3 );\n    d = drawQuad(p, v1, v3.x, v2, v3.y);\n    // color\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVcDw.jpg", "access": "api", "license": "mit", "functions": [[1612, 1648, 1715, 1715, 2316], [2318, 2318, 2382, 2382, 2561], [2563, 2563, 2620, 2620, 3299]], "test": "untested"}
{"id": "flKyWm", "name": "Only straight lines", "author": "LorenzoFiestas", "description": "I watched a video about transformations and got a bit carried away. \nI used noise to mingle with line widths and colors but other than that, everything is made only using straight lines.\n\nHere's the video: https://www.youtube.com/watch?v=Pp47xzf4wGg", "tags": ["lines", "transform"], "likes": 6, "viewed": 331, "published": 3, "date": "1661612400", "time_retrieved": "2024-07-30T16:34:10.965047", "image_code": "// Author: Lorenzo Fiestas\n\n//-----------------------------------------------\n//      UTILITIES\n\n#define PI (3.141592)\n\nfloat rand(vec2 st);\n\nfloat rand(vec3 p);\n\nfloat valueNoise(vec2 st);\n\nfloat valueNoise(vec3 p);\n\nfloat valueNoise(vec3 p, int octaves);\n\nvec3 hsv2rgb(vec3 hsv);\n\nvec3 rgb2hsv( in vec3 rgb );\n\nmat2 rotate(float t);\n\n\n\n\n\n//-----------------------------------------------\n\n\n\n\n\n// Draw line trough p0 and p1\nfloat line(vec2 st, vec2 p0, vec2 p1)\n{\n    float width = .15 + .125*(.5*valueNoise(2.*st + iTime) - .5);\n    float dx = p1.x - p0.x;\n    \n    bool divBy0 = dx == 0.;\n    if(divBy0)\n        return smoothstep(width, -width, abs(st.x - p0.x));\n    \n    float m = (p1.y - p0.y)/dx;\n    float b = p0.y - m*p0.x;\n    float wFix = abs(cos(atan(m)));\n    width /= wFix;\n    \n    return smoothstep(width, -width, abs(m*st.x + b - st.y));\n}\n\n// Functions to be used for transformations\nfloat func(float x)\n{    \n    float t = .3*iTime;\n    float ret = 0.;\n    \n    float func0 = 1./x;\n    float func1 = exp(x) + x;\n    float func2 = 1./x + x;\n    float func3 = cos(x);\n    \n//#define SIN_CYCLING\n#ifdef SIN_CYCLING\n    #define SQR(x) ((x)*(x))\n    ret += (SQR(max(0.,  sin(t))) + .01) * func0;\n    ret += (SQR(max(0.,  cos(t))) + .01) * func1;\n    ret += (SQR(max(0., -sin(t))) + .01) * func2;\n    ret += (SQR(max(0., -cos(t))) + .01) * func3;\n#else\n    #define cycle(x) (smoothstep(0., 1., 1.-abs((x)-1.)))\n    ret += (cycle(mod(t + 0., 4.)) +.01) * func0;\n    ret += (cycle(mod(t + 1., 4.)) +.01) * func1;\n    ret += (cycle(mod(t + 2., 4.)) +.01) * func2;\n    ret += (cycle(mod(t + 3., 4.)) +.01) * func3;\n#endif\n\n    float twist = 2.*sin(.1*iTime) + 2.;\n    return ret + twist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1. to 1.)\n    vec2 uv0 = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    const float ZOOM = 4.;\n    vec2 uv  = uv0 * ZOOM * rotate(-.25*iTime);\n    vec2 uvr = rotate(0.*PI/3.) * uv;\n    vec2 uvg = rotate(2.*PI/3.) * uv;\n    vec2 uvb = rotate(4.*PI/3.) * uv;\n\n    // Time varying pixel color\n    float mask = 0.;\n    vec3 col = vec3(0.);\n    const float RANGE = 5.;\n    const float LINES = 100.;\n    \n    // Paint 2.*LINES lines for each color \n    for(float x = -RANGE; x <= RANGE; x += RANGE/LINES)\n    {   \n        #define PAINT_COLOR(C,UV) mask   = line(UV, vec2(x, 1.), vec2(func(x), -1.));  \\\n                                  col.C += /*max(0., cos(PI*x/RANGE)) * */ mask;\n        \n        PAINT_COLOR(r, uvr)\n        PAINT_COLOR(g, uvg)\n        PAINT_COLOR(b, uvb)\n    }\n    // Extra juice to colors\n    col *= atan(length(col))/(length(col) + .001);\n            \n    // Smokify colours\n    vec3 hsv = rgb2hsv(col);\n#define PRONOUNCED_COLOR_BOUNDARIES\n#ifdef PRONOUNCED_COLOR_BOUNDARIES\n    // Change noise based on color to get more defined color sections\n    hsv += .4*valueNoise(vec3(3.*uv0, 5.*(hsv[0] + hsv[1]) + iTime), 5);\n#else\n    hsv += .4*valueNoise(vec3(3.*uv0, iTime), 5);\n#endif\n    hsv[2] *= 1. - smoothstep(1., .5, hsv[1] + .5); // darken bg noise\n    \n    vec3 rgb = hsv2rgb(hsv); \n    fragColor = vec4(rgb, 1.);\n}\n\n\n\n\n\n\n\n\n\n//-----------------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\nfloat rand(vec2 st)\n{\n    return fract(6373.35391*st.x*sin(734.255*(st.y-st.x + 35.3)) +\n                 344.872343*st.y*sin(5443.65*(st.y-st.x + 11.2)) + 395.47);\n}\n\nfloat rand(vec3 p)\n{\n    return fract(6373.35391*p.x*sin(734.255*(p.y-p.x-p.z + 35.3)) +\n                 344.872343*p.y*sin(5443.65*(p.y-p.x-p.z + 11.2)) +\n                 -42.349436*p.z*sin(-246.42*(p.y-p.x-p.z + 7.26)) +\n                 395.47);\n}\n\nfloat valueNoise(vec2 st)\n{\n    float x0y0 = rand(floor(st + vec2(0., 0.)));\n    float x0y1 = rand(floor(st + vec2(0., 1.)));\n    float x1y0 = rand(floor(st + vec2(1., 0.)));\n    float x1y1 = rand(floor(st + vec2(1., 1.)));\n    \n    float l = mix(x0y0, x0y1, fract(st.y));\n    float r = mix(x1y0, x1y1, fract(st.y));\n    return mix(l, r, fract(st.x));\n}\n\nfloat valueNoise(vec3 p)\n{\n    float x0y0z0 = rand(floor(p + vec3(0., 0., 0.)));\n    float x0y1z0 = rand(floor(p + vec3(0., 1., 0.)));\n    float x1y0z0 = rand(floor(p + vec3(1., 0., 0.)));\n    float x1y1z0 = rand(floor(p + vec3(1., 1., 0.)));\n    \n    float x0y0z1 = rand(floor(p + vec3(0., 0., 1.)));\n    float x0y1z1 = rand(floor(p + vec3(0., 1., 1.)));\n    float x1y0z1 = rand(floor(p + vec3(1., 0., 1.)));\n    float x1y1z1 = rand(floor(p + vec3(1., 1., 1.)));\n    \n    float l0 = mix(x0y0z0, x0y1z0, fract(p.y));\n    float r0 = mix(x1y0z0, x1y1z0, fract(p.y));\n    \n    float l1 = mix(x0y0z1, x0y1z1, fract(p.y));\n    float r1 = mix(x1y0z1, x1y1z1, fract(p.y));\n    \n    return mix(mix(l0, r0, fract(p.x)),\n               mix(l1, r1, fract(p.x)), fract(p.z));\n}\n\nfloat valueNoise(vec3 p, int octaves)\n{\n    float k = 1.;\n    float f = 1.;\n    float ret = 0.;\n    for(int i = 0; i < octaves; i++)\n    {\n        ret += k*valueNoise(f*p);\n        k *= 1./sqrt(2.);\n        f *= 2.;\n    }\n    return ret/(sqrt(float(octaves)));\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nvec3 rgb2hsv( in vec3 rgb )\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz),\n                 vec4(rgb.gb, K.xy),\n                 step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r),\n                 vec4(rgb.r, p.yzx),\n                 step(p.x, rgb.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\nmat2 rotate(float t)\n{\n    return mat2(cos(t), -sin(t),\n                sin(t), cos(t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 425, 464, 464, 856], [858, 902, 923, 923, 1698], [3254, 3254, 3275, 3275, 3420], [3422, 3422, 3442, 3442, 3674], [3676, 3676, 3703, 3703, 4029], [4031, 4031, 4057, 4057, 4796], [4798, 4798, 4837, 4837, 5060], [5062, 5062, 5086, 5086, 5218], [5220, 5220, 5249, 5249, 5693], [5695, 5695, 5717, 5717, 5785]], "test": "untested"}
{"id": "Ntcyzr", "name": "UI - 2D SDF Radial Hue Picker", "author": "shmoich", "description": "A radial color Hue Picker", "tags": ["ui"], "likes": 2, "viewed": 223, "published": 3, "date": "1661587760", "time_retrieved": "2024-07-30T16:34:11.893565", "image_code": "// Official HSV to RGB conversion \nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 toPolar(vec2 cartesian)\n{\n    return vec2(length(cartesian), atan(cartesian.x, cartesian.y));\n}\n\nvec3 radialHueFromPoint(vec2 point)\n{\n    float theta = toPolar(point).y;\n    float hue = theta / (2.0 * 3.14);\n    vec3 col = vec3(hue, 1.0, 1.0);\n    col = hsv2rgb(col);\n    return col;\n}\n\n\nvec2 dir(vec2 to, vec2 from)\n{\n    return normalize(from - to);\n}\n\n\n\nvec3 hueColorFromOrginToMouse(vec2 origin, vec2 mouse)\n{\n    float radius = 0.4;\n    vec2 dirvec = dir(mouse, origin);\n    float theta = toPolar(dirvec).y;\n    float hue = map(theta, 0.0, 2.0 * 3.14, 0.0, 1.0);\n    vec3 col = vec3(hue, 1.0, 1.0);\n    col = hsv2rgb(col);\n    return col;\n}\n\n\n\nvec3 colorSDFWithRadialHue(float sdf, vec2 radialOrigin, vec3 inputCol)\n{\n    vec3 col = inputCol;\n    // sdf outline\n    if (sdf < 0.0)\n    {\n        col = radialHueFromPoint(radialOrigin);\n    }\n    if (sdf > 0.0 && sdf < 0.01)\n    {\n        col = mix(inputCol, radialHueFromPoint(radialOrigin), 1.0-smoothstep(0.0, 0.01,abs(sdf)));\n    }\n    \n    return col;\n}\n\nvec3 colorSDFHueFromMouse(float sdf, vec2 origin, vec2 mouse, vec3 inputCol)\n{\n    vec3 col = inputCol;\n    \n    if (sdf < 0.0)\n    {\n        col = hueColorFromOrginToMouse(origin, mouse);\n    }\n    if (sdf > 0.0 && sdf < 0.01)\n    {\n        col = mix(inputCol, hueColorFromOrginToMouse(origin, mouse), 1.0-smoothstep(0.0, 0.01,abs(sdf)));\n    }\n    \n    return col;\n}\n\nfloat hueRingSDF(vec2 p, vec2 m, float roundness)\n{\n    \n    float sdf = sdCircle(p, 0.4);\n    sdf = opSubtraction(sdCircle(p, 0.35), sdf);\n    return sdf;\n}\n\nfloat pickerLineSDF(vec2 origin, vec2 mouse, float roundness)\n{\n    float sdf = sdCircle(origin, 0.05);\n    if (iMouse.z > 0.01) sdf = opUnion(sdSegment(origin, vec2(0), mouse), sdf);\n    return sdf  - roundness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = (2.0 * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0 * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 pickerPosition = center - vec2(0.0, 0.0);\n    \n    float hueRing = hueRingSDF(pickerPosition, m, 0.1);\n    float picker = pickerLineSDF(pickerPosition, m, 0.1);\n    \n    vec3 background = vec3(0.3, 0.3, 0.3);\n    vec3 col = colorSDFWithRadialHue(hueRing, pickerPosition, background);\n    col = colorSDFHueFromMouse(picker, vec2(0.0, 0.0), m, col);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntcyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 113, 113, 188], [189, 189, 216, 216, 342], [344, 344, 381, 381, 402], [403, 403, 446, 446, 468], [469, 469, 513, 513, 534], [536, 536, 577, 577, 605], [607, 607, 659, 659, 778], [780, 780, 810, 810, 880], [882, 882, 919, 919, 1071], [1074, 1074, 1104, 1104, 1139], [1143, 1143, 1199, 1199, 1431], [1435, 1435, 1508, 1508, 1798], [1800, 1800, 1878, 1878, 2168], [2170, 2170, 2221, 2221, 2327], [2329, 2329, 2392, 2392, 2543], [2545, 2545, 2602, 2602, 3174]], "test": "untested"}
{"id": "stGyWm", "name": "namble bamble 2", "author": "elenzil", "description": "just fooling around.\nfullscreen! webcam by default, click for shirley.", "tags": ["video"], "likes": 24, "viewed": 793, "published": 3, "date": "1661558903", "time_retrieved": "2024-07-30T16:34:12.672482", "image_code": "// Fork of \"namble bamble\" by elenzil. https://shadertoy.com/view/NtyyWm\n// 2022-08-27 00:06:34\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float cellSize = 20.0;\n    float margin   = 0.75;\n    \n    vec2 p = mod(XY + cellSize / 2.0, cellSize) - cellSize / 2.0;\n    vec2 cellP = floor(XY / cellSize + 0.5) * cellSize;\n    \n    float t = iTime * 0.92;\n    \n    vec2 xy = cellP - iResolution.xy / 2.0;\n    if (length(xy) < 0.001) {\n        t = 0.0;\n    }\n    else {\n        t = atan(xy.y, xy.x) + 3.14159 / 2.0;\n    }\n    \n    t += iTime * 2.2;\n    \n    if (iMouse.z < 10.0) {\n    //    t *= 0.0;\n    }\n    \n    float q = texelFetch(iChannel0, ivec2(cellP), 0).r;\n    float rate = q;\n    rate *= 2.0;\n    \n    float theta = t + rate * 3.14159;\n    vec2 rayDir = vec2(cos(theta), sin(theta));\n    \n    float d = abs(rayDir.x * p.y - rayDir.y * p.x) - margin;\n    if (length(p) > cellSize / 2.0 - margin * 2.0) {\n        d = 1e9;\n    }\n    \n    float c = smoothstep(margin, 0.0, d);\n    \n    RGBA = vec4(c, c, c, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame % 1 == 0) {\n        if (iMouse.z < 1.0) {\n            fragColor = texture(iChannel0, vec2(iResolution.x - 1.0 - fragCoord.x, fragCoord.y)/iResolution.xy, 3.0);\n        }\n        else {\n            fragColor = texture(iChannel2, vec2(fragCoord.x, fragCoord.y)/iResolution.xy, 3.0);\n        }\n    }\n    else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 142, 142, 1022]], "test": "untested"}
{"id": "slGyDw", "name": "sandpiles experiment", "author": "drschizzo", "description": "from https://www.youtube.com/watch?v=1MtEUErz7Gg\n\nyou can change the scale in Common tab", "tags": ["buffer", "sandpiles"], "likes": 8, "viewed": 259, "published": 3, "date": "1661547691", "time_retrieved": "2024-07-30T16:34:13.573074", "image_code": "//from https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n\n   \n    float val = texture(iChannel0,uv).x;\n    \n    vec3 col=palette((1./(maxval))*val,vec3(0.5, 0.5, 0.5),vec3(0.5, 0.5, 0.5),vec3(2.0, 1.0, 0.),vec3(0.50, 0.20, 0.25));\n    if(val>maxval)\n        col=vec3(1.);\n    if(val==0.)\n        col=vec3(0.);\n   \n    fragColor=vec4(col,1.0);\n    \n   \n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n    \n    if(abs(uv.x)<(1./iResolution.y)*(scale/2.) && abs(uv.y)<(1./iResolution.y)*(scale/2.)){\n        fragColor = vec4(5.0);\n    }\n    else{\n        \n        fragColor=vec4(computePile(iChannel0,fragCoord,iResolution.xy,float(iFrame)));\n    \n        \n        \n    }\n    \n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float maxval=4.;\nfloat scale=5.;\nfloat speed=1.;\n\n\n\nfloat computePile(sampler2D channel,vec2 pos,vec2 res, float f){\n    float prevUp=texture(channel,(pos+vec2(0.,-scale))/res).x;\n    float prevDown=texture(channel,(pos+vec2(0.,scale))/res).x;\n    float prevLeft=texture(channel,(pos+vec2(-scale,0.))/res).x;\n    float prevRight=texture(channel,(pos+vec2(scale,0.))/res).x;\n    float prev=texture(channel,(pos)/res).x;\n    float ret=prev;\n    if(mod(f,speed)==0.){\n                        \n        if(prevUp>=maxval)\n            ret++;\n        if(prevDown>=maxval)\n            ret++;\n        if(prevLeft>=maxval)\n            ret++;\n        if(prevRight>=maxval)\n            ret++;\n        if(prev >= maxval){\n            return (prev-maxval);        \n        }\n        else{\n            return (ret);\n        }\n    }\n    else\n        return (prev);\n\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor=vec4(computePile(iChannel0,fragCoord,iResolution.xy,float(iFrame)));\n\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor=vec4(computePile(iChannel0,fragCoord,iResolution.xy,float(iFrame)));\n\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor=vec4(computePile(iChannel0,fragCoord,iResolution.xy,float(iFrame)));\n\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 121, 121, 164], [167, 167, 224, 224, 563]], "test": "untested"}
{"id": "flSyz1", "name": "Strings Example", "author": "ArmandB", "description": "Allows strings to be rendered easily\nsee common tab for mapping functions and variables\npress any key to view it", "tags": ["font", "reference", "keyboard", "input"], "likes": 3, "viewed": 348, "published": 3, "date": "1661547314", "time_retrieved": "2024-07-30T16:34:14.506578", "image_code": "/*\n    see common tab for mapping functions and character variables\n    press any key to see it on screen\n    string useage in common\n*/\n\n\n/*\ninput: \n    code - an int representing the location on the font texture to sample\noutput:\n    a texture with the character on it\n*/\nvec3 getChar(int code, vec2 uv){\n    vec2 code_wrapped = vec2(code - code/16*16, 16 - code/16 - 1);\n    return texture(iChannel1, (code_wrapped + clamp(uv,0.0,1.0))/16.0).rgb;\n}\n\n/*\ninput: \n    string - a 64 int array representing all the characters you want to use\n    fontSize - a float representing the scale to use when rendering\n    wrap - int, the number of characters to print before wrapping\n    uv - vec2, uv coordinates (0-1)\noutput:\n    a texture (in the same format as the font texture) with your string on it\n*/\nvec3 renderString(int[64] string, float fontSize, int wrap, vec2 uv){\n    vec3 col = vec3(0);\n    vec2 offset = vec2(0,1.0/fontSize-1.0);\n    for (int i = 0; i < 64; i++){\n        vec2 charuv = uv/fontSize - offset*vec2(0.5,1);\n        if (string[i] == _newline){\n            offset.y -= 1.0;\n            offset.x = 0.0;\n        } else {\n            if (charuv.x >= 0.25 && charuv.x < 0.75 && charuv.y >= 0.0 && charuv.y < 1.0){\n                col = getChar(asciiToImage(string[i]), charuv);\n            }\n            offset.x += 1.0;\n            if (offset.x == float(wrap)){\n                offset.y -= 1.0;\n                offset.x = 0.0;\n            }\n        }\n    }\n    return col;\n}\n\n/*\ninput: \n    num - the number you want a digit of\n    digit - digit of the int you want to use\noutput:\n    the selected digit (int 0-9) in the input number\n*/\nint hexOfInt(int num, int digit){\n    return num >> 4 * digit - 4 & 15;\n}\n\nint digitOfInt(int num, int digit){\n    digit = max(digit,0);\n    int mul = 1;\n    for (int i = 0; i < digit; i++){\n        mul*=10;\n    }\n    return num/(mul/10) - num/mul*10;\n}\n\n\n\n/*////////\n  MAIN\n////////*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //gets the keycode from Buffer A in order to only run the loop for one pixel\n    int keycode = int(texelFetch(iChannel0, ivec2(0), 0).x);\n    bool shiftPressed = bool(texelFetch(iChannel0, ivec2(0), 0).y);\n\n    //init uv coords and screen color\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(1);\n\n    //draw pressed key\n    if (keycode != -1) {\n        col = mix(vec3(1), vec3(0), getChar(keyboardToImage(keycode, shiftPressed), uv*1.5 - vec2(0.25)).x);\n    }\n    \n    //the pressed key in ascii\n    int ascii = keyboardToAscii(keycode, shiftPressed);\n    \n    //String example. Must be 64 chars\n    //use underscore in front of char you want to use\n    int[64] myString = int[64](\n        _A,_s,_c,_i,_i,_colon,_space,\n        hexToAscii(hexOfInt(ascii,3)),\n        hexToAscii(hexOfInt(ascii,2)),\n        hexToAscii(hexOfInt(ascii,1)),\n        _newline,_K,_e,_y,_b,_o,_a,_r,_d,_colon,_space,\n        hexToAscii(hexOfInt(keycode,3)),\n        hexToAscii(hexOfInt(keycode,2)),\n        hexToAscii(hexOfInt(keycode,1)),\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n    );\n    \n    //another string\n    int[64] myOtherString = int[64](\n        _T,_h,_e,_space,\n        _q,_u,_i,_c,_k,_space,\n        _b,_r,_o,_w,_n,_space,\n        _f,_o,_x,_space,\n        _j,_u,_m,_p,_s,_space,\n        _o,_v,_e,_r,_newline,\n        _t,_h,_e,_space,\n        _l,_a,_z,_y,_space,\n        _d,_o,_g,_period,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n    );\n    \n    //render both strings\n    col = mix(col, vec3(0),renderString(myString, 0.1, 64, uv).r);\n    col = mix(col, vec3(0),renderString(myOtherString, 0.1, 64, uv+vec2(0,0.8)).r);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//int keyboardToAscii(int key, bool shiftPressed)\n//remaps a keyboard value to an ascii value\n\n//int asciiToImage(int ascii)\n//remaps an ascii value to a texture position\n\n//int asciiToKeyboard(int ascii)\n//remaps an ascii value to a keyboard value\n\n//int keyboardToImage(int key, bool shiftPressed)\n//remaps a keyboard value to a texture position\n\n//int keyboardToDigit(int key)\n//converts a keyboard value to a digit\n\n//int digitToAscii(int digit)\n//converts a digit to ascii\n\n//int digitToImage(int digit)\n//converts a digit to a texture position\n\n//all (printable) characters in ascii\nconst int _a = 97;\nconst int _b = 98;\nconst int _c = 99;\nconst int _d = 100;\nconst int _e = 101;\nconst int _f = 102;\nconst int _g = 103;\nconst int _h = 104;\nconst int _i = 105;\nconst int _j = 106;\nconst int _k = 107;\nconst int _l = 108;\nconst int _m = 109;\nconst int _n = 110;\nconst int _o = 111;\nconst int _p = 112;\nconst int _q = 113;\nconst int _r = 114;\nconst int _s = 115;\nconst int _t = 116;\nconst int _u = 117;\nconst int _v = 118;\nconst int _w = 119;\nconst int _x = 120;\nconst int _y = 121;\nconst int _z = 122;\n\nconst int _A = 65;\nconst int _B = 66;\nconst int _C = 67;\nconst int _D = 68;\nconst int _E = 69;\nconst int _F = 70;\nconst int _G = 71;\nconst int _H = 72;\nconst int _I = 73;\nconst int _J = 74;\nconst int _K = 75;\nconst int _L = 76;\nconst int _M = 77;\nconst int _N = 78;\nconst int _O = 79;\nconst int _P = 80;\nconst int _Q = 81;\nconst int _R = 82;\nconst int _S = 83;\nconst int _T = 84;\nconst int _U = 85;\nconst int _V = 86;\nconst int _W = 87;\nconst int _X = 88;\nconst int _Y = 89;\nconst int _Z = 90;\n\nconst int _space = 32;\nconst int _newline = 10;\n\nconst int _slash = 47;\nconst int _backslash = 92;\nconst int _pipe = 124;\n\nconst int _colon = 58;\nconst int _semicolon = 59;\nconst int _apostrophe = 39;\nconst int _backtick = 96;\nconst int _quotation = 34;\n\nconst int _question = 63;\nconst int _period = 46;\nconst int _comma = 44;\nconst int _exclaimation = 33;\n\nconst int _equals = 61;\nconst int _plus = 43;\nconst int _minus = 45;\n\nconst int _underscore = 95;\nconst int _asterisk = 42;\nconst int _and = 38;\nconst int _caret = 94;\nconst int _percent = 37;\nconst int _dollar = 36;\nconst int _hash = 35;\nconst int _at = 64;\n\nconst int _arrowleft = 60;\nconst int _arrowright = 62;\nconst int parright = 40;\nconst int parleft = 41;\nconst int sbrackright = 91;\nconst int sbrackleft = 93;\nconst int cbrackright = 123;\nconst int cbrackleft = 125;\n\n/*\nnote: due to missing ascii values\n    enter = return\n    shift = shift in\n    ctrl = device control 1\n    alt = substitute\n    left = missing\n    up = missing\n    right = missing\n    down = missing\n*/\n\n//maps each keyboard key value to ascii\nconst int[256] keyboardToAsciiMap = int[256](\n  0,  0,  0,  0,  0,  0,  0,  0,  8, 27,  0,  0,  0, 10,  0,  0,\n 15, 17, 26,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,\n 32,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,  0,  0,  0,  0,  0,  0,\n  0, 97, 98, 99,100,101,102,103,104,105,107,108,109,110,110,111,\n112,113,114,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 59, 61, 44, 45, 46, 47,\n 96,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 91, 92, 93, 39,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n);\n\n//maps each keyboard key value to ascii when shift is pressed\nconst int[256] shiftKeyboardToAsciiMap = int[256](\n  0,  0,  0,  0,  0,  0,  0,  0,  8, 27,  0,  0,  0, 10,  0,  0,\n 15, 17, 26,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,\n 32,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n 41, 33, 64, 35, 36, 37, 94, 38, 42, 40,  0,  0,  0,  0,  0,  0,\n  0, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 58, 43, 60, 95, 62, 63,\n126,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,123,124,125, 34,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n);\n\n//remaps a keyboard value to an ascii value\nint keyboardToAscii(int key, bool shiftPressed){\n    return shiftPressed ? shiftKeyboardToAsciiMap[key] : keyboardToAsciiMap[key];\n}\n\n//remaps an ascii value to a texture position\nint asciiToImage(int ascii){\n    if (ascii >= 32){\n        return ascii;\n    }\n    return 32;\n}\n\n//maps each ascii value to a keyboard value\nconst int[128] asciiToKeyboardMap = int[128](\n    0,0,0,0,0,0,0,0,8,27,13,0,0,0,0,16,\n    0,17,0,0,0,0,0,0,0,0,18,9,0,0,0,0,\n    32,49,221,51,52,53,55,221,57,48,56,186,187,188,189,190,\n    48,49,50,51,52,53,54,55,56,57,186,186,187,186,189,190,\n    50,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,\n    80,81,82,83,84,85,86,87,88,89,90,218,219,220,54,188,\n    191,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,\n    80,81,82,83,84,85,86,87,88,89,90,218,219,220,191,0\n);\n\n//remaps an ascii value to a keyboard value\nint asciiToKeyboard(int ascii) {\n    return asciiToKeyboardMap[ascii];\n}\n\n//maps each keyboard key value to the correct symbol on the font texture\nconst int[256] keyboardToImageMap = int[256](\n  0,  0,  0,  0,  0,  0,  0,  0, 32, 32,  0,  0,  0, 32,  0,  0,\n 32, 32, 32,  0,  0,  0,  0,  0,  0,  0,  0, 32,  0,  0,  0,  0,\n 32,  0,  0,  0,  0, 16, 17, 18, 19,  0,  0,  0,  0,  0,  0,  0,\n 48, 49, 50, 51, 52, 53, 54, 55, 56,  57, 0,  0,  0,  0,  0,  0,\n  0, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 59, 61, 44, 45, 46, 47,\n 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 91, 92, 93,180,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n);\n\n//maps each keyboard key value when shift is pressed to the correct symbol on the font texture\nconst int[256] shiftKeyboardToImageMap = int[256](\n  0,  0,  0,  0,  0,  0,  0,  0, 32, 32,  0,  0,  0, 32,  0,  0,\n 32, 32, 32,  0,  0,  0,  0,  0,  0,  0,  0, 32,  0,  0,  0,  0,\n 32,  0,  0,  0,  0, 16, 17, 18, 19,  0,  0,  0,  0,  0,  0,  0,\n 41, 33, 64, 35, 36, 37, 94, 38, 42, 40,  0,  0,  0,  0,  0,  0,\n  0, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 58, 43, 60, 95, 62, 63,\n 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,123,124,125, 34,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n);\n\n//remaps a keyboard value to a texture position\nint keyboardToImage(int key, bool shiftPressed){\n    return shiftPressed ? shiftKeyboardToImageMap[key] : keyboardToImageMap[key];\n}\n\n//converts a keyboard value to a digit\nint keyboardToDigit(int key){\n    if (key >= 48 && key <= 56) {\n        return key - 48;\n    }\n    return -1;\n}\n\n//converts a digit to ascii\nint digitToAscii(int digit){\n    return digit + 48;\n}\n\n//converts a hex digit to ascii\nint hexToAscii(int hex){\n    if (hex < 10){\n        return hex + 48;\n    } else if (hex == 10){\n        return 65;\n    } else if (hex == 11){\n        return 66;\n    } else if (hex == 12){\n        return 67;\n    } else if (hex == 13){\n        return 68;\n    } else if (hex == 14){\n        return 69;\n    } else if (hex == 15){\n        return 70;\n    }\n}\n\n//converts a digit to a texture position\nint digitToImage(int digit){\n    return digit + 48;\n}\n\n/*\nref\n\nnormal:\n  0,  0,  0,  0,  0,  0,  0,  0,bsp,esc,  0,  0,  0,ent,  0,  0,\nsft,ctr,alt,  0,  0,  0,  0,  0,  0,  0,  0,tab,  0,  0,  0,  0,\nspc,  0,  0,  0,  0,  <,  ^,  >,  v,  0,  0,  0,  0,  0,  0,  0,\n  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  0,  0,  0,  0,  0,\n  0,  a,  b,  c,  d,  e,  f,  g,  h,  i,  j,  k,  l,  m,  n,  o,\n  p,  q,  r,  s,  t,  u,  v,  w,  x,  y,  z,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  ;,  =,  ,,  -,  .,  /,\n  `,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  [,  \\,  ],  ',  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n  \nshift:\n  0,  0,  0,  0,  0,  0,  0,  0,bsp,esc,  0,  0,  0,ent,  0,  0,\nsft,ctr,alt,  0,  0,  0,  0,  0,  0,  0,  0,tab,  0,  0,  0,  0,\nspc,  0,  0,  0,  0,  <,  ^,  >,  v,  0,  0,  0,  0,  0,  0,  0,\n  ),  !,  @,  #,  $,  %,  ^,  &,  *,  (,  0,  0,  0,  0,  0,  0,\n  0,  A,  B,  C,  D,  E,  F,  G,  H,  I,  J,  K,  L,  M,  N,  O,\n  P,  Q,  R,  S,  T,  U,  V,  W,  X,  Y,  Z,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  :,  +,  <,  _,  >,  ?,\n  ~,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  {,  |,  },  \",  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n  \n  ascii\n0,0,0,0,0,0,0,0,bs,tab,lf,0,0,0,0,si,\n0,dc1,0,0,0,0,0,0,0,0,sub,esc,0,0,0,0,\n ,!,\",#,$,%,&,',(,),*,+,,,-,.,/,\n0,1,2,3,4,5,6,7,8,9,:,;,<,=,>,?,\n@,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,\nP,Q,R,S,T,U,V,W,X,Y,Z,[,\\,],^,_,\n`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,\np,q,r,s,t,u,v,w,x,y,z,{,|,},~,0\n*/", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (floor(fragCoord) == vec2(0)) {\n        //loops through all keys in the keyboard texture and finds the first one that's pressed\n        int keycode = -1;\n        for (int i = 0; i < 256; i++){\n            if (i == 16) {continue;}\n\n            bool pressed = bool(texelFetch(iChannel0, ivec2(i, 0), 0).x);\n            if (pressed){\n                keycode = i;\n                break;\n            }\n        }\n        bool shiftPressed = bool(texelFetch(iChannel0, ivec2(16,0), 0).x);\n        fragColor = vec4(keycode,shiftPressed,0,0);\n    } else {\n        fragColor = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 274, 306, 306, 451], [1491, 1652, 1685, 1685, 1725], [1727, 1727, 1762, 1762, 1905]], "test": "untested"}
{"id": "ftGyDm", "name": "Golfing Mosaic Filter  - 133 ch", "author": "GregRostami", "description": "Here's some quick golfing of deni_de's shader here:\n[url]https://www.shadertoy.com/view/stKcWW[/url]", "tags": ["video", "filter", "mosaic"], "likes": 8, "viewed": 384, "published": 3, "date": "1661536994", "time_retrieved": "2024-07-30T16:34:15.335362", "image_code": "// 133 chars - Golfed by Golfing Guru Xor and Jedi Master Fabrice!\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o.xyz = iResolution/25.;\n    o = tanh((.5 - length( modf(u/o.y, u) -.5) ) * o.y)\n        * texture(iChannel0, u * o.y/o.xy / 25.);\n}\n\n\n// 145 chars - Original shader by Greg Rostami\n/*\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o.xyz = iResolution;\n    o = texture( iChannel0, ceil( u *= 25./o.y ) / 25. * o.yz/o.xz )\n        * smoothstep( .48, .44, length(fract(u)-.5) ) ;\n}\n*/", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 102, 102, 239]], "test": "untested"}
{"id": "NtyyWm", "name": "namble bamble", "author": "elenzil", "description": "just fooling around.\nthe phase of a circle's pulse depends on the texture beneath it.", "tags": ["video"], "likes": 11, "viewed": 303, "published": 3, "date": "1661532755", "time_retrieved": "2024-07-30T16:34:16.363613", "image_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float cellSize = 20.0;\n    \n    vec2 p = mod(XY + cellSize / 2.0, cellSize) - cellSize / 2.0;\n    vec2 cellP = floor(XY / cellSize + 0.5) * cellSize;\n    \n    float margin = 1.0;\n    float t = iTime * 4.92;\n    \n    float q = texelFetch(iChannel0, ivec2(cellP), 0).r;\n    float rate = q * 0.2 + 0.8;\n    rate *= 20.0;\n    \n    float pulse = sin(t + rate) * 0.3 + 0.6;\n    float d = abs(length(p)) - ((cellSize - margin) / 2.0 * pulse);\n    \n    float c = smoothstep(margin, 0.0, d);\n    \n    RGBA = vec4(c, c, c, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame % 1 == 0) {\n        fragColor = texture(iChannel0, vec2(fragCoord)/iResolution.xy, 0.0);\n    }\n    else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 570]], "test": "untested"}
{"id": "ftycWw", "name": "Day 981", "author": "jeyko", "description": "asdgasdg", "tags": ["mdtmjvm"], "likes": 12, "viewed": 307, "published": 3, "date": "1661528406", "time_retrieved": "2024-07-30T16:34:17.340999", "image_code": "\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/1255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/155.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    \n    vec4 t = Tb(uv);\n    \n    vec2 x = unpackS16(t.x);\n    vec2 y = unpackS16(t.y);\n    vec2 w = unpackU16(t.w)*vec2(100,1500.);\n    \n    vec3 n = normalize(vec3(x.xy,y.x));\n    \n    \n    vec2 st = (1.)/R.xy;\n\n    vec2 l = \n        unpackU16(  Tb(uv+vec2(st.x,0)).w  )-unpackU16(Tb(uv - vec2(st.x,0)).w) +\n        unpackU16(Tb(uv + vec2(0,st.y)).w)-unpackU16(Tb(uv - vec2(0,st.y)).w) +\n        unpackU16(Tb(uv + vec2(st.xy)).w) -unpackU16(Tb(uv - vec2(st.xy)).w) +\n        unpackU16(Tb(uv + vec2(st.x,-st.y)).w)-unpackU16(Tb(uv - vec2(st.x,-st.y)).w)\n    ;\n    \n    l = clamp(abs((l*vec2(100,1500.)).xx)*6.,0.,1.);\n    \n    //t.xyz = unpackS8(t.x).xyz;\n    //C = 1.*t.xyzz + 0.4;\n    C = max(dot(normalize(vec3(1,-1.5,-7)),-n),0.04)*vec4(1);\n    \n    C.xyz *= pow(palAppleII[int(w.y*1111.)%16],vec3(2.));\n    \n    \n    C = mix(C,C*0.,l.x);\n    \n    \n    C = mix(C,vec4(0.9),smoothstep(1.4,2.,w.x*0.3));\n    //max((sin(n.xyzz*0. + w.y*2101110. +vec4(3.,2,0.,1))*0.5 + 0.6),0.1);\n    \n    C = abs(C);\n    C = 1.-exp(-C*1.3);\n    //C = 1.-C*1.;\n    C *=1.5;\n    \n    \n    if(w.x<0.2)\n        C *=0.;\n    \n    C = pow(max(C,0.),vec4(0.454545));\n    //C = vec4(1)*sin(Tb(uv).x*15. + iTime)*0.5 + 0.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iTime (iTime + 70. + 0.)\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(right,dir));\n    float fov = 2.;\n    return normalize(dir + right*uv.x*fov + up * uv.y*fov);\n}\n\n// 8bit\nhighp uint packU8(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackU8(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packU8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackU8(float a) { return vec4(unpackU8(floatBitsToUint(a))) / 255.; }\nfloat packS8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackS8(float a) { return clamp((vec4(unpackU8(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n\n// 16bit\nhighp uint packU16(highp uvec2 a) {\n    return uint( (a.x << 16)\n               | (a.y << 0)); }\nmediump uvec2 unpackU16(highp uint a) {\n    return uvec2( (a & 0xFFFF0000u) >> 16\n                , (a & 0x0000FFFFu) >> 0   ); }\nfloat packU16(  vec2  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, 0., 1.)* (pow(2.,16.) - 1.))))); }\nvec2  unpackU16(float a) { return vec2(unpackU16(floatBitsToUint(a))) / (pow(2.,16.) - 1.); }\n\n#define S16SZ (pow(2.,16.) - 1.)\n#define halfS16SZ S16SZ/2.\nfloat packS16(  vec2  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, -1., 1.)*halfS16SZ + halfS16SZ)))); }\nvec2  unpackS16(float a) { return clamp((vec2(unpackU16(floatBitsToUint(a))) - halfS16SZ) / halfS16SZ, -1., 1.); }\n\n\n\n//float pack16(  vec3  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, 0., 1.)* (pow(2.,16.) - 1.))))); }\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\n\n#define R iResolution.xy\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( const vec3 ro, const vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n            \n            vec4 hash42(vec2 p)\n            {\n                vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n                p4 += dot(p4, p4.wzxy+33.33);\n                return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n            }", "buffer_a_code": "\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    \n    vec2 w;\n    \n    if(iFrame == 0){\n        C = vec4(0);\n    } else{\n        C = texture(iChannel0,uv);\n        w = unpackU16(C.w);\n    \n    }\n    \n    \n    \n    float t = w.y;\n    \n    \n    t += 1.;\n    \n    if(C.w > 10.){\n        C.w = 0.;\n        C.x = 1.;\n    }\n    \n    \n    //C.xy = packU16(C.w);\n    \n    // xy - pos\n    // zw - rot, scale, it\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    //vec2 uv = U/R.xy;\n    vec2 uv = (U-0.5*R.xy)/R.y;\n    vec2 uvn = U/R.xy;\n    \n    vec3 ro = vec3(2.,2.4,0)*0.4;\n    \n    \n    if(fract(iTime/4.) < 0.5){\n        ro.y = -1.2;\n        ro.xz *= rot(iTime*4.);\n    }\n    \n    \n    vec3 rd = getRd(ro, vec3(0.4,-0.2,0) + sin(vec3(3,2,1)*iTime*0.1)*0.1, uv );\n    \n    \n    float depth;\n    float hitIt;\n    //vec3 normal = unpackU16(C.w).xyz;\n    \n    if(iFrame == 0){\n        C = vec4(110);\n        depth=100.;\n        hitIt=0.;\n    } else{\n        C = Tb(uvn);\n        \n        depth = unpackU16(C.w).x*100.;\n        hitIt = unpackU16(C.w).y*1500.;\n        \n        depth = abs(depth);\n        \n        \n        depth = min(depth+0.004*2.*(1.+sin(iTime)) + 0.*exp(-abs(depth)*2.1),100.);\n        \n        depth += smoothstep(0.1,0.,depth);\n        //C = vec4(110);\n    }\n    for(float part=0.; part < 1.; part++){\n        vec3 p = vec3(0);\n        float r = 0.;\n        vec3 rvec = vec3(0,0,-1);\n        float s = float(0.1);\n        vec3 n;\n        const float iiters = 115.;\n        const float iitersrecip = 1./iiters;\n        \n        \n        float cnt = 0.;\n        float mode = 0.;\n        float rtdir = 1.;\n        for(float i=0.; i < iiters; i++){\n                \n                \n            //mat4 rot = rotationAxisAngle( normalize(vec3(0.,1.,0.0)), r );\n            //mat4 tra = translate( p.x, p.y, p.z );\n            //mat4 txi = tra * rot; \n            //mat4 txx = inverse( txi );\n            \n            //ip.xz *= rot(r);\n            //float t = boxIntersection( ip, rd, vec3(s), n ).x;\n            \n            //vec4 t = iBox( ro, rd, txx, txi, vec3(s) );\n            vec4 t;\n            vec3 offs = vec3(0,0.,0.);\n            t.x = sphIntersect( ro, rd, p + offs, s ).x;\n            \n            //t = cylIntersect( ro, rd, p, p - vec3(0,200.,0), s);\n            \n            if(t.x != -1. && t.x < depth){\n                \n                depth = t.x;\n                hitIt = i;\n                t.yzw = normalize(ro+rd*t.x - p);\n                \n                if(abs(t.y) < 0.004)\n                    t.y += 0.1;\n                //t. += 0.;\n                \n                \n                //C.x = packS8(vec4(t.yzww));\n                C.x = packS16(t.yz);\n                C.y = packS16(t.wz);\n                \n                //C.xyz = t.yzw;\n                \n                //float packU16(  vec2  a);\n\n            }\n               \n            vec4 r = hash42(vec2(i*0.51256 + float(iFrame)*0.25 + part*15.125 + 100.));\n            \n            float _rt;\n            float _sc;\n            float _st;\n            \n            if(mode == 0.){\n                _st = 1.5 + sin(iTime*0. + sin(iTime))*0.5;\n                _rt = 0.2 + sin( i/iiters*12. + 11. + iTime*0.5 + sin(i/iiters*5. + iTime*0.2)*1.)*0.1;\n                _sc = mix(0.97,0.9,1.-exp(-i/iiters));\n                p.y += sin(iTime + i/iiters)*0.3*(i/iiters)*_st;\n                if(mod(cnt+2.,5.) == 0. && r.x < 0.1){\n                    mode = 1.;\n                    _rt = 4.;\n                    _sc = 0.5;\n                    if(r.z < 0.5)\n                        _rt *= -1.;\n                    cnt = 0.;\n                } else  if(mod(cnt+0.,5.) == 0. && r.w < 0.1){\n                    mode = 1.;\n                    _rt = -1.;\n                    _sc = 1.;\n                    rtdir = -1.;\n                    if(r.z < 0.5)\n                        _rt *= -1.;\n                    cnt = 0.;\n                }\n                if(cnt>1230.)\n                    break;\n                \n            } else if(mode == 1.){\n                _rt = .2*rtdir;\n                _sc = 0.9;\n                _st = 1.;\n                p.y -= 0.01*(1.-i/iiters);\n                if(mod(cnt+4.,3.) == 0. && r.x < 0.1){\n                    mode = 1.;\n                    _rt = 2.;\n                    _sc = 0.5;\n                    if(r.z < 0.5)\n                        _rt *= -1.;\n                    cnt = 0.;\n                //    cnt = 0.;\n                //}\n                }\n                if(cnt>30.)\n                    break;\n            }\n            \n            if(s<0.001)\n                break;\n            \n            cnt += 1.;\n            /*\n            if(r.x < 0.2){\n                _rt = 0.2;\n            } else if(r.x < 0.5){\n            \n                _rt = -0.2;\n            } else {\n                _rt = 11.2;\n                _sc = 0.95;\n            }\n            */\n            r += _rt;\n            rvec.xz *= rot(_rt);\n            p += rvec*s*_st;\n            //p.xz *= rot(r + part);\n            s *= _sc;\n        }\n    }\n    \n    depth = clamp(depth,0.,100.);\n    C.w = packU16(vec2(depth,hitIt)/vec2(100.,1500.));\n                \n    \n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftycWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 538, 538, 1763]], "test": "untested"}
{"id": "styyWD", "name": "Anaglyph Neural Core", "author": "derSchamane", "description": "- put your Red/Cyan-glasses on\n- play some techno or your favorit music (bpm - see line 18)\n- drag mouse to rotate view\n\nlove to BigWings - \" RayMarching starting point\"\nmusic: der Schamane - Aerosoul", "tags": ["3d", "raymarching", "music", "anaglyph", "neuron"], "likes": 10, "viewed": 549, "published": 3, "date": "1661525448", "time_retrieved": "2024-07-30T16:34:19.970968", "image_code": "//                   = Anaglyph Neural Core =         \n//                by Maximilian Knape ·∑>|  2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 120\n#define MAX_DIST 80.\n#define SURF_DIST .00001\n#define SURF_MUL 13000.\n\n#define EYE_DIS 0.75\n#define FIL_COR 1.2\n\n#define BPM 127. //Set your own speed\n#define iTime iTime * BPM / 124.141\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n\n    p *= 1. + smoothstep(-1., 0.5,sin(iTime*6.5))*0.01;\n    vec3 r = p ;\n    float l = length(p);\n    r.xz *= Rot(sin(iTime/19.)*6.28*smoothstep(10., MAX_DIST, l));\n    r.zy *= Rot(sin(iTime/14.)*6.28*smoothstep(5., MAX_DIST, l));\n    r.yx *= Rot(sin(iTime/11.)*6.28*smoothstep(3., MAX_DIST, l));\n    \n    float web = length(cross(sin(r/ (1.0 + smoothstep(5., 10., l))), normalize(r)))-(sin(iTime*1.75+r.y-r.z)*0.02+0.03);\n    \n    float dp = 1. - smoothstep(0., 1., dot(sin(p/10.), cos(p/10.))+sin(iTime/3.25));\n    web -= smoothstep(0.98, 1., sin(pow(length(p), 1.7)/50. - (iTime*3.25)))*0.08*dp;\n    \n    p *= 1. + smoothstep(-0.5,1.0,sin(iTime*3.25))*0.1;\n\n    float wire = abs(dot(sin(p+vec3(0.,0.,0.)), cos(p+(3.14/2.))))-(smoothstep(-0.5, 1., sin(iTime/17.))*3.);\n                         \n    p *= 1. + smoothstep(-0.3,1.0,sin(iTime*6.5))*(0.1+sin(iTime*3.25)*0.05);\n    \n    float sphere = abs(length(p)-5.+(sin(iTime/7.)*2.))-(sin(iTime/21.)*.5+1.);\n\n    float d = mix(sphere, wire, 0.5+(sin(iTime/11.)*0.2));\n    \n    \n    d = mix(d, web, sin(iTime/12.)*0.25+0.3);\n    \n    \n    d = min(d, pow(web, 1.2));\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=17.0;\n    int steps = 0;\n    for(int i=0; i<MAX_STEPS; i++) {\n        steps = i;\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<(SURF_DIST * (pow(dO/ MAX_DIST,1.5)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, 0.);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(cos(iTime / 12.)*30., 20., sin(iTime / 12.)*30.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 p1 = vec3(0), p2 = vec3(0);\n    vec3 ro = vec3(0, 4.+(sin(iTime/13.)*5.), -30.+(sin(iTime/7.)*5.));\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.+sin(iTime/3.)*.1);\n    \n    float bg = smoothstep(0.6+sin(iTime/2.7)*.2, 1.0, dot(abs(rd), (normalize(vec3(sin(iTime/1.6), sin(iTime/1.2), sin(iTime/0.5))))));\n    float fac = smoothstep(0.0, 1., sin(iTime/1.3))*clamp(sin(iTime*3.25),0.,1.)*0.3*abs(sin(iTime/2.8));\n    float colL = bg * fac;\n\n    vec3 rmd = RayMarch(ro, rd);\n    float depth = pow(1. - rmd.x / MAX_DIST, 1.0);\n\n    if(rmd.x<MAX_DIST && rmd.x < (1.-colL)*MAX_DIST) \n    {\n        p1 = ro + rd * rmd.x;\n        colL = GetLight(p1) * depth * depth;\n        colL += rmd.y / float(MAX_STEPS) * depth * (1.5-smoothstep(10., 20., length(p1)));\n    }\n    \n    float eyedis = EYE_DIS; //smoothstep(-0.1, 0., sin(iTime/2.))*0.2;\n    ro += cross(rd, vec3(0.,-1.,0.)) * eyedis;\n    rd = R(uv, ro, vec3(0,1,0), 1.+sin(iTime/3.)*.1);\n    \n    bg = smoothstep(0.6+sin(iTime/2.7)*.2, 1.0, dot(abs(rd), (normalize(vec3(sin(iTime/1.6), sin(iTime/1.2), sin(iTime/0.5))))));\n    float colR = bg * fac;\n\n    rmd = RayMarch(ro, rd);\n    depth = pow(1. - rmd.x / MAX_DIST, 1.0);\n\n    if(rmd.x<MAX_DIST && rmd.x < (1.-colR)*MAX_DIST) \n    {\n        p2 = ro + rd * rmd.x;\n        colR = GetLight(p2) * depth * depth;\n        colR += rmd.y / float(MAX_STEPS) * depth * (1.5-smoothstep(10., 20., length(p2)));\n    }\n    \n    //filter correction\n    colL *= FIL_COR; \n    colR /= FIL_COR;\n    \n    //neural flash\n    float dp = 1. - smoothstep(0., 1., dot(sin(p1/10.), cos(p1/10.))+sin(iTime/3.25));\n    float nfL = 1. - smoothstep(0.98, 1., sin(pow(length(p1), 1.7)/50. - (iTime*3.25))) * dp; \n    float nfR = 1. - smoothstep(0.98, 1., sin(pow(length(p2), 1.7)/50. - (iTime*3.25))) * dp;\n    \n    colL *= (1.5 - smoothstep(10., 15., length(p1)) * nfL);\n    colR *= (1.5 - smoothstep(10., 15., length(p2)) * nfR);\n\n    vec3 colS = smoothstep(vec3(0.), vec3(1.), vec3(colL, colR, colR)); //contrast\n    \n    colS = pow(colS, GAMMA);\t//gamma correction\n    \n    fragColor = vec4(colS,1.0);\n}", "image_inputs": [{"id": 31962, "src": "https://soundcloud.com/derschamane/aerosoul", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styyWD.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[540, 540, 559, 559, 635], [637, 637, 660, 660, 1799], [1801, 1801, 1825, 1825, 1979], [1981, 1981, 2014, 2014, 2312], [2316, 2316, 2340, 2340, 2554], [2556, 2556, 2598, 2598, 2793], [2795, 2795, 2852, 2852, 5090]], "test": "untested"}
{"id": "7lGcWD", "name": "Candy cage", "author": "ruojake", "description": "Sugar rush", "tags": ["3d", "raymarching", "abstract", "halftone", "truchet", "weave"], "likes": 10, "viewed": 286, "published": 3, "date": "1661515701", "time_retrieved": "2024-07-30T16:34:21.114909", "image_code": "// Candy cage by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat hash12(vec2 p)\n{\n    p = fract(p * 3.213 + .679) * 31.9;\n    p.x *= fract(p.y * 12.321) * 2047.6;\n    return fract(p.x + p.y);\n}\n\nfloat cheb(vec2 p, float k)\n{\n    return pow(pow(abs(p.x), k) + pow(abs(p.y), k), 1./k);\n}\n\nfloat cheb(vec3 p, float k)\n{\n    return pow(pow(abs(p.x), k) + pow(abs(p.y), k) + pow(abs(p.z), k), 1./k);\n}\n\nvec2 cubeCoord(vec3 n)\n{\n    vec2 res;\n    if (abs(n.x) > abs(n.y) && abs(n.x) > abs(n.z))\n        res = n.yz / abs(n.x);\n    else if (abs(n.y) > abs(n.x) && abs(n.y) > abs(n.z))\n        res = n.xz / abs(n.y);\n    else\n        res = n.xy / abs(n.z);\n    \n    return res + 1.5;\n}\n\nvec2 truch(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = p - i;\n    \n    float h = hash12(i*17.);\n    if (h < .5) f.y = 1. - f.y;\n    \n    if (f.x + f.y > 1.) f = 1. - f;\n    \n    float y = sin(atan(f.y, f.x));\n    y = smoothstep(.4, -.4, y);\n    \n    return vec2(cheb(f, 1.5 + h * 5.) - .5, y);\n}\n\nfloat cage(vec3 p, float rad, float t)\n{\n    mat2 r = rot(t);\n    p.xz *= r;\n    p.yx *= r;\n    vec2 uv = cubeCoord(normalize(p));\n    uv *= floor(rad);\n    vec2 t0 = truch(uv);\n    vec2 t1 = truch(uv + 3.5);\n    t0.y = t0.y * .2 + length(p) - rad;\n    t1.y = t1.y * .2 + length(p) - rad;\n    return (min(length(t0), length(t1)) - .05)\n         * max(1. - max(abs(p.y)-rad*.5, 0.) * .4, .1);\n}\n\nfloat scene(vec3 p)\n{\n    float pt = iTime * 3.141593 * .125;\n    return min(min(cage(p, 1., pt * -.75), cage(p, 1.5, pt)), cage(p, 2., pt * -1.5)) * .5;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    const vec2 e = vec2(.001, 0);\n    return normalize(\n        d - vec3(\n            scene(p - e.xyy),\n            scene(p - e.yxy),\n            scene(p - e.yyx)\n        )\n    );\n}\n\n// sphere intersection to accelerate raymarch\nfloat acc(vec3 ro, vec3 rd)\n{\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - 2.1*2.2;\n    float h = b*b-c;\n    if (h<0.) return 11.;\n    return -b-sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0,0,-3.),\n         rd = normalize(vec3(uv, .8)),\n          p = vec3(0),\n        col = vec3(0);\n    float i = 0., t = acc(ro, rd), d = 0.;\n\n    for(;i<1. && t < 10.;i += 1./256.)\n    {\n        p = ro + rd * t;\n        d = scene(p) - .02;\n        if (abs(d) < .001) break;\n        t += d;\n    }\n    \n    float olT = t;\n    t += d;\n    \n    for(;i<1. && t < 10.;i += 1./256.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        if (abs(d) < .001 + max(t * .001 - .001, 0.)) break;\n        t += d;\n    }\n    \n    if (t < 10.)\n    {\n        vec3 n = normal(p, d);\n        float frn = pow(1.-dot(rd,-n), 2.);\n        vec3 refd = reflect(rd,n);\n        mat2 r = rot(1.);\n        n.xz *= r;\n        n.yz *= r;\n        float l = dot(max(n, 0.), vec3(.5));\n        l *= l;\n        col = mix(vec3(1.,.2,0), vec3(.85,1.,0), smoothstep(.5 - fwidth(l), .5 + fwidth(l), l));\n        float e = exp(-t + 1.2);\n        col = mix(col, vec3(0,.95,1), 1.-e);\n        l = max(l, pow(dot(vec3(1), cos(refd * 8.)), 4.) * frn);       \n        col = mix(col,vec3(l),l*l);\n    }\n    else if (olT < 10.)\n        col = vec3(1);\n    else\n    {\n       float grad = clamp(uv.y - uv.x * .25 + .5, 0.,1.) * 2. -1.;\n       uv *= rot(.6);\n       uv.y += iTime * .2;\n       \n       float hft = cheb(fract(uv * 20.) * 2. - 1., 2. + 2. * smoothstep(-.8,.8,sin(uv.x * 3. + iTime)));\n       col = mix(vec3(.9,0,1), vec3(1), step(.5, hft+grad));\n    }\n\n    col *= 1.-pow(length(fragCoord / iResolution.xy - .5), 4.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGcWD.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[111, 111, 130, 130, 203], [205, 205, 227, 227, 339], [341, 341, 370, 370, 431], [433, 433, 462, 462, 542], [544, 544, 568, 568, 822], [824, 824, 844, 844, 1121], [1123, 1123, 1163, 1163, 1516], [1518, 1518, 1539, 1539, 1673], [1675, 1675, 1705, 1705, 1887], [1889, 1935, 1964, 1964, 2100], [2102, 2102, 2159, 2159, 3762]], "test": "untested"}
{"id": "7tVcWW", "name": "Soft Shadow (SDF)", "author": "wcvanvan", "description": "use SDF to create soft shadows", "tags": ["sdf"], "likes": 0, "viewed": 462, "published": 3, "date": "1661510451", "time_retrieved": "2024-07-30T16:34:22.014504", "image_code": "precision highp float;\n\n\n#define RAYMARCHING_MAX_STEPS 100\n\n/*\nReturn the min distance between p and the world\n*/\nfloat GetDist(vec3 p){\n    float dist_floor=p.y;\n    vec3 sphere=vec3(0,1,3);\n    float sphere_radius=0.5;\n    float dist_sphere=length(sphere-p)-sphere_radius;\n    return(dist_sphere<dist_floor)?dist_sphere:dist_floor;\n}\n\n/*\nReturn the normal vector at point p\n*/\nvec3 GetNormal(vec3 p){\n    float small_step_value=.01;\n    vec2 small_step=vec2(small_step_value,0.);\n    float dist=GetDist(p);\n    float gradient_x=(GetDist(p+small_step.xyy)-dist);\n    float gradient_y=(GetDist(p+small_step.yxy)-dist);\n    float gradient_z=(GetDist(p+small_step.yyx)-dist);\n    return normalize(vec3(gradient_x,gradient_y,gradient_z));\n}\n\nfloat Shadow(vec3 origin,vec3 direction,float max_dist){\n    float min_dist=.01;\n    float shadow=1.;\n    float k=8.;\n    float marching_distance=0.;\n    for(int i=0;i<RAYMARCHING_MAX_STEPS;i++){\n        float dist=GetDist(origin+marching_distance*direction);\n        shadow=min(shadow,k*dist/marching_distance);\n        marching_distance+=dist;\n        if(marching_distance>max_dist){\n            break;\n        }\n    }\n    return 0.25*(1.0+shadow)*(1.0+shadow)*(2.0-shadow);\n}\n\nvec3 Shading(vec3 p){\n    vec3 light_pos=vec3(5.*sin(iTime),5.,5.*cos(iTime));\n    vec3 light_direction=normalize(light_pos-p);\n    \n    // diffuse\n    vec3 normal=GetNormal(p);\n    float shading_intensity=dot(normal,light_direction);\n    shading_intensity=clamp(shading_intensity,0.,1.);\n    \n    // shadow\n    float max_dist=length(light_pos-p);\n    float shadow=Shadow(p,light_direction,max_dist);\n    \n    return shadow*shading_intensity*vec3(1,1,1);\n}\n\nvec3 RayMarching(vec3 origin,vec3 direction){\n    float max_dist=100.;\n    float min_dist=.01;\n    float marching_distance=0.;\n    \n    vec3 current_pos=origin;\n    \n    for(int i=0;i<RAYMARCHING_MAX_STEPS;i++){\n        float dist=GetDist(current_pos);\n        if(dist<min_dist){\n            break;\n        }\n        current_pos+=direction*dist;\n        marching_distance+=dist;\n        if(marching_distance>max_dist){\n            break;\n        }\n    }\n    return Shading(current_pos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 camera_pos=vec3(0,1,0);\n    vec3 ray_direction=normalize(vec3(uv.x,uv.y,1));\n    vec3 color=RayMarching(camera_pos,ray_direction);\n    fragColor=vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 114, 136, 136, 335], [337, 379, 402, 402, 737], [739, 739, 795, 795, 1217], [1219, 1219, 1240, 1240, 1675], [1677, 1677, 1722, 1722, 2165], [2168, 2168, 2225, 2225, 2457]], "test": "untested"}
{"id": "stKcWW", "name": "Mosaic Filter", "author": "deni_de", "description": "It reminded me of a child's toy where a picture was made up of dots", "tags": ["video", "filter", "mosaic"], "likes": 4, "viewed": 314, "published": 3, "date": "1661508019", "time_retrieved": "2024-07-30T16:34:22.822344", "image_code": "#define grid vec2( 50., 25. )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * grid;\n    vec3 final = texture(iChannel0, fract(uv)).rgb * texture(iChannel1, ceil(uv) / grid).rgb;\n    fragColor = vec4(final.rgb,1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float circle = smoothstep(0.50, 0.56, 1. - length(uv - vec2(0.5, 0.5)));\n    fragColor = vec4(vec3(circle), 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 88, 88, 270]], "test": "untested"}
{"id": "7tycDD", "name": "Hexagonal Limited Repetition SDF", "author": "josaid", "description": "Implementation of an algorithm for limited repetition of Hexagonal SDFs in a Hexagonal Grid.\nBased on the works of Inigo Quilez (https://iquilezles.org) and Red Blob Games (https://redblobgames.com/grids/hexagons).", "tags": ["sdf", "repetition", "hexagon", "distance", "field", "hex", "tile", "hexagonal", "tilling", "signed", "limited"], "likes": 10, "viewed": 311, "published": 3, "date": "1661470617", "time_retrieved": "2024-07-30T16:34:23.612232", "image_code": "// The MIT License\n// Copyright © 2022 João Pedro Braz (brazjoaopedro@ymail.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define CAMERA_ZOOM 16.0\n#define GRID_RADIUS 8.0\n#define HEX_RADIUS 0.5\n#define HEX_MARGIN 0.0\n#define ANIMATED 1\n// Modes:\n// 0 - Naive Approach (Clamp and query the closest neighbor, from all sides)\n// 1 - Directed Approach (Similiar to #0, but excludes the opposite neighbor)\n// 2 - SDF Approach (Treat the whole grid as a hexagon and compute the signed distance to it)\n// 3 - Another version of #2, but using Inigo Quilez's SDF function\n#define CLAMPING_MODE 0\n\nconst float PI = 3.141592653589793;\nconst float SQRT_3 = 1.732050807568877;\nconst float HALF_SQRT_3 = 0.8660254037844386;\nconst float THIRD_SQRT_3 = 0.5773502691896258;\nconst float THIRD = 0.33333333333333334;\nconst float TWO_THIRDS = 0.6666666666666667;\nconst float THREE_HALFS = 1.5;\nconst float EPSILON = 0.00000001;\n\nconst vec3 KERNEL = vec3(-HALF_SQRT_3, 0.5, THIRD_SQRT_3);\n\nconst vec3 DIRECTIONS[6] = vec3[6](\n    vec3(1.0, 0.0, -1.0),\n    vec3(0.0, 1.0, -1.0),\n    vec3(-1.0, 1.0, 0.0),\n    vec3(-1.0, 0.0, 1.0),\n    vec3(0.0, -1.0, 1.0),\n    vec3(1.0, -1.0, 0.0)\n);\n\n// Transformation Utilities\nvec2 translate(vec2 point, vec2 by);\nvec2 scale(vec2 point, vec2 scale);\n\n\n// Hex Utilities\nvec3 neighbor(int direction);\nfloat distance_from_center(vec3 hex);\nbool is_inside_grid(vec3 hex, float half_width);\nvec3 cube_round(vec3 cube);\nvec3 uv_to_hex(vec2 uv, float size);\nvec2 hex_to_uv(vec3 hex, float size);\nvec3 uv_to_hex_clamped(vec2 uv, float size, float half_width);\n\n\n// SDF Utilities\nfloat sd_hexagon(vec2 point, float half_size);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Resolution dependent antialiasing, used with smoothstep\n\tfloat aa = 1.0 / min(iResolution.y, iResolution.x) * 10.0 * CAMERA_ZOOM;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Compute zoom taking into account the current aspect ratio\n\tvec2 zoom = iResolution.xy * CAMERA_ZOOM / min(iResolution.y, iResolution.x);\n    \n    // Our camera offset\n    vec2 camera_offset = vec2(0.0, 0.0);\n    if (iMouse.z > EPSILON) {\n        camera_offset = iMouse.xy / iResolution.xy;\n        camera_offset = scale(translate(camera_offset, vec2(0.5, 0.5)), zoom);\n    }\n    \n    // Center and scale the UV\n\tvec2 point = translate(scale(translate(uv, vec2(0.5, 0.5)), zoom), camera_offset);\n    \n    // Compute the current Hexagon in Cube Coordinates\n\tvec3 hex = uv_to_hex_clamped(point, HEX_RADIUS, GRID_RADIUS);\n    \n    // Get the center of the Hexagon\n\tvec2 center = hex_to_uv(hex, HEX_RADIUS);\n    \n    // Transform our UV into the Local Coordinate System of the Hexagon\n\tvec2 relative_point = (point - center) / HEX_RADIUS;\n\t\n    // Compute the SDF\n    float roundness = 0.0;\n#if ANIMATED == 1\n    roundness = cos(iTime * 0.75) * 1.1 + 1.5;\n#endif\n\tfloat signed_distance =\n        sd_hexagon(relative_point * (HEX_MARGIN + HEX_RADIUS + roundness), HEX_RADIUS) - roundness;\n\t\n    // Inigo Quilez's Color Scheme\n    vec3 color = vec3(1.0) - sign(signed_distance) * vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-2.0 * abs(signed_distance));\n\tcolor *= 0.8 + 0.2 * cos(signed_distance);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01 + aa, abs(signed_distance)));\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n// -- Star of the show --\nvec3 uv_to_hex_clamped(vec2 uv, float radius, float grid_radius) {\n    // Compute which Hexagon does the UV maps to\n\tvec3 hex = uv_to_hex(uv, radius);\n\t\n    // Check whether the Hexagon is outside the grid\n    // If so, apply our clamping algorithm\n\tif (!is_inside_grid(hex, grid_radius)) {\n\n#if CLAMPING_MODE == 0\n\n        // Clamp the hex to be just inside the grid\n        vec3 remapped_hex = cube_round(\n\t\t\thex / distance_from_center(hex) * grid_radius\n\t\t);\n\n        // Search for the closest neighbor\n        bool local_minimum_empty = true;\n        vec4 local_minimum = vec4(0.0);\n\n        // Search every neighbord (including itself), except the one in the opposite direction\n        float direction = floor(3.0 * (atan(uv.y, -uv.x) + PI) / PI);\n\t\tvec4 neighbor_hex = vec4(remapped_hex, 0.0);\n        // -2 to 2 + 1 for itself\n\t\tfor (int i = -2; i <= 3; i++) {\n\t\t\t// Pick only those inside the grid\n\t\t\tif (is_inside_grid(neighbor_hex.xyz, grid_radius)) {\n\t\t\t\tneighbor_hex.w = length(hex_to_uv(neighbor_hex.xyz, radius) - uv);\n\t\t\t\t\n\t\t\t\tif (local_minimum_empty || neighbor_hex.w < local_minimum.w) {\n\t\t\t\t\tlocal_minimum = neighbor_hex;\n\t\t\t\t\tlocal_minimum_empty = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tneighbor_hex = vec4(neighbor(int(mod(direction + float(i), 6.0))) + remapped_hex, 0.0);\n\t\t}\n        \n        // Return what we found\n        return local_minimum.xyz;\n        \n#elif CLAMPING_MODE == 1\n\n        // Clamp the hex to be just inside the grid\n        vec3 remapped_hex = cube_round(\n\t\t\thex / distance_from_center(hex) * grid_radius\n\t\t);\n\n        // Search for the closest neighbor\n        bool local_minimum_empty = true;\n        vec4 local_minimum = vec4(0.0);\n        \n        // Search every neighbord and itself\n        for (int i = -1; i < 6; i++) {\n            vec4 neighbor = vec4(neighbor(i) + remapped_hex, 0.0);\n        \n            // Pick only those inside the grid\n            if (is_inside_grid(neighbor.xyz, grid_radius)) {\n                neighbor.w = length(hex_to_uv(neighbor.xyz, radius) - uv);\n\n                if (local_minimum_empty || neighbor.w < local_minimum.w) {\n                    local_minimum = neighbor;\n                    local_minimum_empty = false;\n                }\n            }\n        }\n        \n        // Return what we found\n        return local_minimum.xyz;\n        \n#elif CLAMPING_MODE == 2\n    \n        // Compute the angle from the uv to the center\n        float angle = mod(atan(uv.y, uv.x) - PI / 2.0, PI / 3.0);\n        // Get the distance \n        float dist = SQRT_3 * SQRT_3 * radius * grid_radius + radius;\n        dist /= SQRT_3 * cos(angle) + sin(angle);\n\n        // Instead of returning the result hexagon, we could pass it to the CLAMPING_MODE == 1\n        // Left as an exercise to the reader.\n        return uv_to_hex(\n            uv / length(uv) * dist,\n            radius\n        );\n\n#elif CLAMPING_MODE == 3\n    \n        // vec2(uv.y, uv.x) so that the resulting SDF if of a pointy hexagon\n        float grid_size = SQRT_3 * radius * (grid_radius - 1.0);\n        float signed_distance = sd_hexagon(vec2(uv.y, uv.x), grid_size);\n\n        return uv_to_hex(\n            uv - uv * signed_distance / length(uv),\n            radius\n        );\n\n#endif\n\n\t}\n\n\treturn hex;\n}\n\n\n// -- Transformation Utilities Implementations --\nvec2 translate(vec2 point, vec2 by) {\n    return point - by;\n}\n\nvec2 scale(vec2 point, vec2 scale) {\n    return point * scale;\n}\n\n// -- Hex Utilities Implementations --\n// Please check out https://www.redblobgames.com/grids/hexagons/\n// The source of most these functions.\nfloat distance_from_center(vec3 hex) {\n    return max(max(abs(hex.x), abs(hex.y)), abs(hex.z));\n}\n\nbool is_inside_grid(vec3 hex, float grid_radius) {\n\treturn (\n\t\tabs(hex.x) <= grid_radius && \n\t\tabs(hex.y) <= grid_radius && \n\t\tabs(hex.z) <= grid_radius\n\t);\n}\n\nvec3 neighbor(int direction) {\n    return direction == -1\n        ? vec3(0.0)\n        : DIRECTIONS[direction];\n}\n\n// Justin Pombrio's\n// https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 cube_round(vec3 cube) {\n\tfloat a = ceil(cube.x - cube.y);\n    float b = ceil(cube.y - cube.z);\n    float c = ceil(cube.z - cube.x);\n\t\n\treturn vec3(\n\t\tround((a - c) / 3.0),\n\t\tround((b - a) / 3.0),\n\t\tround((c - b) / 3.0)\n\t);\n}\n\nvec3 uv_to_hex(vec2 uv, float size) {\n\tfloat q = uv.x * TWO_THIRDS / size;\n\tfloat r = (-THIRD * uv.x + THIRD_SQRT_3 * uv.y) / size;\n\tfloat s = -q - r;\n\n\treturn cube_round(vec3(q, r, s));\n}\n\nvec2 hex_to_uv(vec3 hex, float size) {\n\tfloat x = THREE_HALFS * hex.x * size;\n\tfloat y = ((HALF_SQRT_3 * hex.x) + (SQRT_3 * hex.y)) * size;\n\t\n\treturn vec2(x, y);\n}\n\n// -- SDF Utilities Implementations --\n// Please check out https://iquilezles.org/articles/distfunctions2d/\n// For other SDF functions\nfloat sd_hexagon(vec2 point, float radius) {\n    point = abs(point);\n    point -= 2.0 * min(dot(KERNEL.xy, point), 0.0) * KERNEL.xy;\n    point -= vec2(clamp(point.x, -KERNEL.z * radius, KERNEL.z * radius), radius);\n    return length(point) * sign(point.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tycDD.jpg", "access": "api", "license": "mit", "functions": [[2621, 2621, 2678, 2741, 4355], [4358, 4384, 4450, 4499, 7614], [7617, 7667, 7704, 7704, 7729], [7731, 7731, 7767, 7767, 7795], [7797, 7940, 7978, 7978, 8037], [8039, 8039, 8089, 8089, 8197], [8199, 8199, 8229, 8229, 8311], [8313, 8403, 8431, 8431, 8632], [8634, 8634, 8671, 8671, 8822], [8824, 8824, 8862, 8862, 8987], [8989, 9124, 9168, 9168, 9382]], "test": "untested"}
{"id": "7tyyW1", "name": "Sparks on Swiss Cheese Mountain", "author": "fenix", "description": "I wanted to see what it looked like to drop some particles on some more interesting terrain, and I am happy with the results!\nTerrain FBM based on iq's Sphere FBM: https://www.shadertoy.com/view/Ws3XWl\n*space disables terrain* *mouse controls sparks*", "tags": ["3d", "collision", "simulation", "fbm", "particles", "physics", "multipass"], "likes": 35, "viewed": 519, "published": 3, "date": "1661462495", "time_retrieved": "2024-07-30T16:34:24.596600", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I wanted to drop some cheap non-interacting particles on some complex geometry,\n//  so I borrowed the FBM function from iq's Sphere FBM: https://www.shadertoy.com/view/Ws3XWl\n//\n//  The mouse basically controls the red particle fountain, in terms of making sense of\n//  the X/Y mappings. The other two streams are also under your control since they are\n//  just rotated by 120 degrees.\n//\n//  Space disables terrain rendering, which also speeds up FPS quite a lot. I tried to\n//  optimize the raymarch performance but it still seems very slow, any ideas to make\n//  it faster are welcome. (Or ideas about anything else for that matter...)\n//\n//  Each particle is a light source, so I guess this renders 100k dynamic lights? :)\n//  I think technically this is deferred rendering because I do lighting calculations\n//  only in the image tab.\n// \n//  Buffer A computes the particle positions\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders the background with depth in the w component\n//\n// ---------------------------------------------------------------------------------------\n\n#define DIFFUSE_PER_PARTICLE 1\n#define SHADOWS 1 // Disable for faster speed\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // fetch precomputed background geometry\n    vec4 normalAndZ = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n      \n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    float zDist = normalAndZ.w;\n    vec3 groundPos = cameraPos + rayDir * zDist;\n\n\tvec3 reverseLightDir = normalize(vec3(sin(iTime * -0.4),0.5,cos(iTime * -0.4)));\n\tvec3 lightColor = vec3(0.2,0.2,0.2);\t\n\tconst vec3 ambientColor = vec3(0);//.05,0.05,0.05);\n    float shadowHit = 1e6;\n#if SHADOWS\n    if (!keyDown(KEY_SPACE))\n    {\n        shadowHit = raycast(groundPos + normalAndZ.xyz * 0.01, -reverseLightDir);\n    }\n    if (shadowHit < 0.)\n    {\n        lightColor = vec3(0);\n    }\n#endif\n\n    // diffuse\n\tvec3 groundColor = ambientColor;\n\tfloat dp = dot(normalAndZ.xyz, reverseLightDir);\n\tif(dp > 0.0) groundColor += (dp * lightColor);\n    \n    // specular\n    vec3 reflection = reflect(reverseLightDir, normalAndZ.xyz);\n    dp = dot(cameraFwd, reflection);\n    if (dp > 0.0 && shadowHit > 0.) groundColor += pow(abs(dp), 15.0) * vec3(0.5);\t\t\n   \n    fragColor = vec4(groundColor, 0.0) * smoothstep(-50.0, -17.0, -zDist);\n    \n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n\n    for(int j=0; j<4; j++)\n    {\n        int particle = old[j];\n        if (particle < 0 || particle >= MAX_PARTICLES) continue;\n        fxParticle data = fxGetParticle(particle);\n        \n        vec3 oldPos = data.pos;\n        vec3 newPos = data.pos + data.vel;\n         \n#if DIFFUSE_PER_PARTICLE\n        const float GLOW_INTENSITY = 0.001;\n        vec3 groundDelta = oldPos - groundPos.xyz;\n        float groundDotParticle = dot(groundDelta, normalAndZ.xyz);\n        \n        if (groundDotParticle > 0.001)\n        {\n            float distToGround = length(groundDelta);\n            float glow = GLOW_INTENSITY * normalize(groundDotParticle) / (distToGround * distToGround);\n            vec3 glowTemp  = fxBlackBody(MAX_TEMP * 1.0 * (1.0 - data.age / 1.5));\n            if (data.color == 1.0) glowTemp = glowTemp.brg;\n            if (data.color == -1.0) glowTemp = glowTemp.bgr;\n            fragColor = min(vec4(1), fragColor + vec4(glow * glowTemp, 0.0));\n        }\n#endif // DIFFUSE_PER_PARTICLE\n \n        // convert to camera space\n        vec3 oldPosCamera = (w2c * vec4(oldPos,1.0)).xyz;\n        oldPosCamera.xy = oldPosCamera.xy / oldPosCamera.z;\n        vec3 newPosCamera = (w2c * vec4(newPos,1.0)).xyz;\n        newPosCamera.xy = newPosCamera.xy / newPosCamera.z;\n        \n        // if in front of clipping plane, not occluded by scene\n        if(oldPosCamera.z > 0.01 && newPosCamera.z > 0.01 && zDist > oldPosCamera.z && zDist > newPosCamera.z)\n        {\n            float dist2 = fxLinePointDist2(oldPosCamera.xy, newPosCamera.xy, p, iResolution.x / iResolution.y);\n            float dist = sqrt(dist2);\n            \n            const float PARTICLE_SIZE = 0.015;\n            float particleTemp = max(0.0, PARTICLE_SIZE - dist) * 800.0 / PARTICLE_SIZE;\n        \n            if (dist < PARTICLE_SIZE)\n            {\n                vec4 pColor = 1.0 * vec4(fxBlackBody(particleTemp / (data.age + 0.1)), 1.0);\n                if (data.color == 1.0) pColor = pColor.brga;\n                if (data.color == -1.0) pColor = pColor.bgra;\n                fragColor = min(vec4(1), fragColor + pColor);\n            }\n        }\n    }\n    \n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.w = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float MAX_AGE = 10.0;\nconst int MAX_PARTICLES = 100000;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvoid fxCalcCamera(in float iTime, in vec4 iMouse, in vec3 iResolution, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0.0, 0.0f, 0.0);\n    float angleX = 1.1*3.14 + iTime * 0.1;\n    float angleY = 0.75*3.14;\n    cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5* cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nconst float MAX_TEMP = 1000.0;\n\nvec3 fxBlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p, float ar)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2((p - b * h) * vec2(ar, 1)); // squared dist to segment\n}\n\nconst float PI = 3.141592653589793;\n\nmat2 rotMat(float a)\n{\n    vec2 sc = vec2(cos(a), sin(a));\n    return mat2(sc.x, sc.y, -sc.y, sc.x);\n}\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader uses a a grid of spheres to carve out fractal detail from\n// a solid block. Unlike naive SDF disaplcemente by a traditional fBM,\n// this shader produces a field that is a valid SDF, so there's no need\n// to reduce the raymarcher's step size to get artifact free visuals.\n//\n// The article that explains this technique can be found here:\n//\n//     https://iquilezles.org/articles/fbmsdf\n//\n// A additive synthesis example of this technique, here: \n//\n//     https://www.shadertoy.com/view/3dGSWR\n\n// 0 = lattice\n// 1 = simplex\n#define NOISE 0\n\n\n// please, do not use in real projects - replace this by something better\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n//---------------------------------------------------------------\n// A random SDF - it places spheres of random sizes in a grid\n//---------------------------------------------------------------\n\nfloat sdBase( in vec3 p )\n{\n#if NOISE==0\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.7)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return min(min(min(SPH(i,f,vec3(0,0,0)),\n                       SPH(i,f,vec3(0,0,1))),\n                   min(SPH(i,f,vec3(0,1,0)),\n                       SPH(i,f,vec3(0,1,1)))),\n               min(min(SPH(i,f,vec3(1,0,0)),\n                       SPH(i,f,vec3(1,0,1))),\n                   min(SPH(i,f,vec3(1,1,0)),\n                       SPH(i,f,vec3(1,1,1)))));\n#else\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(d0.yzx, d0);\n\tvec3 i1 = e*(1.0-e.zxy);\n\tvec3 i2 = 1.0-e.zxy*(1.0-e);\n    \n    vec3 d1 = d0 - (i1  - 1.0*K2);\n    vec3 d2 = d0 - (i2  - 2.0*K2);\n    vec3 d3 = d0 - (1.0 - 3.0*K2);\n    \n    float r0 = hash( i+0.0 );\n    float r1 = hash( i+i1 );\n    float r2 = hash( i+i2 );\n    float r3 = hash( i+1.0 );\n\n    #define SPH(d,r) length(d)-r*r*0.55\n\n    return min( min(SPH(d0,r0),\n                    SPH(d1,r1)),\n                min(SPH(d2,r2),\n                    SPH(d3,r3)));\n#endif\n}\n\n//---------------------------------------------------------------\n// subtractive fbm\n//---------------------------------------------------------------\nfloat sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return d;\n}\n\nfloat sdMountains( in vec3 p )\n{\n    const vec2 sc = vec2(sin(0.9), cos(0.9));\n    \n    float d = sdCone( p - vec3(1.0, 1.0, 0.0), sc );\n    d = smin(d, sdCone( p - vec3(-1.0, 0.8, 0.0), sc ), 0.1);\n    return d;\n}\n\nfloat map( in vec3 p )\n{\n    // box\n    float d = sdMountains( p );\n\n    // fbm\n    d = sdFbm( p, d );\n    \n    return d;\n}\n\nconst float precis = 0.001;\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat raycast( in vec3 ro, in vec3 rd )\n{\n\tfloat res = 1e6;\n\n    // bounding volume    \n    vec2 dis = iBox( ro + vec3(0.0, 2.0, 0.0), rd, vec3(3.0) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float t = dis.x;\n    \n    // First just against the mountains, to get as close as possible\n#if 1 // Disable to test optimization\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = sdMountains( pos );\n        res = t;\n        \n\t\tif( h<precis || t>dis.y ) break;\n\t\tt += h;\n\t}\n#endif\n    \n    // Then against the FBM to pick up details\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = map( pos );\n        res = t;\n        \n\t\tif( h<precis || t>dis.y ) break;\n\t\tt += h;\n\t}\n\n\tif( t>dis.y ) res = 1e6;\n\treturn res;\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS 0\n#define VEL 1\n#define NUM_PARTICLE_DATA_TYPES 2\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    float age;\n    float color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xyz;\n    particle.vel = particleData1.xyz;\n    particle.age = particleData0.w;\n    particle.color = particleData1.w;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:  \n        return vec4(p.pos, p.age);\n    case VEL:  \n        return vec4(p.vel, p.color);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position and velocity of each particle, one per texture fragment.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0.0,-0.001,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=MAX_PARTICLES) return;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    fxParticle p = fxGetParticle(id);\n    \n    // Integrate velocities\n    vec3 newVel = p.vel + GRAVITY;\n    ivec3 newMapPos = ivec3(floor(p.pos + newVel));\n\n    // Detect if we're about to pass through the boundary and bounce off\n    float rc = map(p.pos + p.vel);\n    if (rc > 0.0 && rc < length(p.vel))\n    {\n        vec3 g = calcNormal(p.pos);\n        p.pos += rc * g;\n\n        newVel -= 1.2 * min(0.0, dot(g, newVel)) * g;\n    }\n    \n    float len = length(newVel);\n    if (len > 0.02)\n    {\n        newVel = 0.02 * normalize(newVel);\n    }\n    \n    p.vel = newVel;\n\n    vec3 newPos = p.pos + newVel;\n    float newAge = p.age + min(iTimeDelta, 0.033) / MAX_AGE;\n    \n    p.pos = newPos;\n        \n    // Release particles slowly when shader starts\n    if (int(state.z) < (60*int(MAX_AGE)*id)/MAX_PARTICLES)\n    {\n        newAge = 2.0;\n        p.pos = vec3(1e6);\n    }\n\n    // Reset particles that have gotten too old\n    if (newAge > 1.0)\n    {\n        const float XZ_SPREAD = 0.001;\n        const float Y_SPREAD = 0.0003;\n        const float Y_SPRAY = 0.0;\n\n        vec4 nse = noise(ivec2(id, id)) - 0.5;\n        p.vel = nse.xyz * 2.0 * vec3(XZ_SPREAD, Y_SPREAD, XZ_SPREAD);\n        p.vel.y += Y_SPRAY;\n\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n        cameraFwd.y = 0.0;\n        \n        vec2 mouse = iMouse.xy;\n        if (iMouse.z <= 0.0)\n        {\n            mouse = (vec2(sin(iTime * 0.2), cos(iTime * 0.4)) * 2.5 + 4.0) * iResolution.xy * 0.1;\n        }\n        vec3 mouseFwd = 2.0 * normalize(cameraFwd) * (2.0*mouse.y/iResolution.y - 1.0);\n        vec3 mouseLeft = -2.0 * cameraLeft * (2.0*mouse.x/iResolution.x - 1.0);\n        \n        p.pos = vec3(0.0, 1.5, 0.0) + p.vel + mouseFwd + mouseLeft;\n        \n        switch (int(hash(id) * 3.0))\n        {\n            case 0:\n                p.color = 0.0;\n                break;\n            case 1:\n                p.color = 1.0;\n                vec2 rotPos = rotMat(0.66 * PI) * p.pos.xz;\n                p.pos = vec3(rotPos.x, p.pos.y, rotPos.y);\n                break;\n            case 2:\n                p.color = -1.0;\n                rotPos = rotMat(-0.66 * PI) * p.pos.xz;\n                p.pos = vec3(rotPos.x, p.pos.y, rotPos.y);\n                break;\n        }\n\n        newAge = noise(ivec2(fragCoord) + 3).x * 0.5;\n    }\n    \n    p.age = newAge;\n    \n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew){\n    if(id==-1) return 1e20;\n    vec3 worldPos = fxGetParticleData(id, POS).xyz + fxGetParticleData(id, VEL).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    vec2 delta = (screenPos.xy)-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    if(iFragCoord == ivec2(0))\n    {\n        // Reset if resolution changes\n        vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n        if (iFrame == 0 || iResolution.xy != state.xy)\n        {\n            state = vec4(iResolution.xy, -1.0, 0.0);\n        }\n        else\n        {\n            state.z += 1.0;\n        }\n        \n        fragColor = state;\n        return;\n    }\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    ivec4 old   = fxGetClosest( iFragCoord );      \n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, p, w2c);\n        insertion_sort( new, dis, id, dis2 );\n    }\n\n    uint searchRange = 15u;\n    uint searchCount = 32u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    int searchIterations = 10;\n\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n\n        //pick random id of particle\n        int id = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Background rendering based on \"Sphere FBM\" by iq\n//    https://www.shadertoy.com/view/Ws3XWl\n//\n// All of iq's code is in common, since it's used both here and for the particle boundary.\n// This buffer just calls raycast to generate a texture full of normals and z distances\n// (the G-buffer).\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if (keyDown(KEY_SPACE))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1e6);\n        return;\n    }\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    // render\n    float t = raycast(cameraPos, rayDir);\n    vec3 normal = vec3(0);\n    if( t>0.0 )\n    {\n        vec3 pos = cameraPos + t * rayDir;\n        normal = calcNormal(pos);\n    }\n\n    fragColor = vec4(normal,t);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyyW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1402, 1402, 1459, 1472, 5271]], "test": "untested"}
{"id": "7lyyWD", "name": "smooth cut capsule", "author": "zelect", "description": "need help to optimize this :3", "tags": ["sdf", "line", "cut", "capsule"], "likes": 2, "viewed": 176, "published": 3, "date": "1661457051", "time_retrieved": "2024-07-30T16:34:25.436355", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nconst float PI = 3.14159265359;\nconst float hPI = 1.5707963268;\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    const vec2 c = vec2(1.0,0.0);\n    const vec2 smoothing = vec2(-0.1,0.1);\n\n\n\n    vec3 pa = p - a, ba = b - a;\n    float tt = dot(pa,ba)/dot(ba,ba);\n    float t = clamp(tt,0.0,1.0);\n    vec3 cap = pa - ba*t;\n\n    vec2 q = vec2( length(cap.xz), -cap.y );\n\n    float h = (sin(abs(-clamp((abs(tt-0.5)*16.0)-8.0,-hPI,hPI))) - 1.0) * sign(-tt+0.5) * -((a.y-b.y)*0.03);\n    //h = 0.0;\n\n\n    float w = sqrt(r*r-h*h);\n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n    float final = (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n\n    return final;\n    //return final - noise(p*5.0)*0.061;\n  \n}\n\nfloat map( in vec3 pos )\n{\n    return sdCylinder(pos, vec3(cos(iTime+2.22)*-0.3,cos(iTime)*-0.3,-0.1), vec3(0.3,sin(iTime)*0.5,0.3), 0.15 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n        \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyyWD.jpg", "access": "api", "license": "mit", "functions": [[1080, 1080, 1103, 1103, 1142], [1144, 1144, 1167, 1236, 1605], [1673, 1673, 1724, 1724, 2387], [2389, 2389, 2415, 2415, 2531], [2533, 2579, 2611, 2611, 2850]], "test": "untested"}
{"id": "7tyyDW", "name": "Test 4 channels", "author": "starea", "description": "test", "tags": ["test"], "likes": 0, "viewed": 170, "published": 3, "date": "1661453290", "time_retrieved": "2024-07-30T16:34:26.301044", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb; \n    if (uv.x > 0.25) {\n       col = texture(iChannel1, uv).rgb; \n    }\n\n    if (uv.x > 0.5) {\n       col = texture(iChannel2, uv).rgb; \n    }\n    \n    if (uv.x > 0.75) {\n       col = texture(iChannel3, uv).rgb; \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 499]], "test": "untested"}
{"id": "ftGcWD", "name": "BLF Bezier Rope", "author": "iY0Yi", "description": "\"BezierExtrude\" by Del:\n[url]https://www.shadertoy.com/view/7dyBz3[/url]\n", "tags": ["bezier", "repetition", "extrude", "maptoy"], "likes": 23, "viewed": 343, "published": 3, "date": "1661439354", "time_retrieved": "2024-07-30T16:34:27.250505", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 1\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 3.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n// \"BezierExtrude\" by Del:\n// https://www.shadertoy.com/view/7dyBz3\n// --------------------------------------------------------------------\n// returns xyz = position, w = spline position (t)\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    // check for colinear\n    //if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < 0.0001)\n    //    return sdLinearSegment(pos, A, C);\n\n\t// first, calc curve T value\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\tfloat t;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = uv.x+uv.y-kx;\n        // 1 root\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 tt = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n\t\t// 3 roots, but only need two\n\t\tvec3 r1 = d + (c + b * tt.x) * tt.x;\n\t\tvec3 r2 = d + (c + b * tt.y) * tt.y;\n\t\t//t = length(r2.xyz) < length(r1.xyz) ? tt.y : tt.x;\n        t = dot(r2,r2) < dot(r1,r1) ? tt.y : tt.x; // quicker\n        \n    }\n    // now we have t, calculate splineposition and orient to spline tangent\n    t = clamp(t,0.,1.); // clamp spline start/end\n    vec3 ttan = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));  // spline tangent\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 binormal = normalize(cross(up, ttan));\n    vec3 _normal = cross(ttan, binormal);\n//\tvec3 t1 = normalize(cross(_normal, ttan));\n\tvec3 t1 = cross(_normal, ttan); // no need to normalize this?\n\tmat3 mm = mat3(t1, cross(ttan, t1), ttan);\n    vec3 tp = mix(mix(A, B, t), mix(B, C, t), t);\n    pos.xyz = tp - pos; // spline position\n    pos *= mm;\n    \n    return vec4(pos, t);\n}\n\n// 1D version of iq's limited repetition\n// https://www.shadertoy.com/view/3syGzz\nfloat opRepLim( in float p, in float s, in float lima, in float limb ){\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nfloat map( in vec3 pos )\n{\n    // bezier\n    vec3 a = vec3(sin(iTime*.5)*-3.,cos(iTime*.5)*3.,0);\n    vec3 b = vec3(0.0,sin(iTime*.5)*3.,sin(iTime*4.)*2.0);\n    vec3 c = vec3(sin(iTime*.5)*3.,cos(iTime*.5)*3.,0);\n    vec4 bz = sdBezierExtrude(pos,a,b,c);\n    \n    // repeated domain \n    float l = 10.;\n    vec3 bzr = bz.xyz;\n    float bzrz = bzr.z;\n    bzr.z -= (bz.w-.5)*l;\n    bzr.z = opRepLim(bzr.z, 1., -l, l);\n    \n    // twisted rings\n    bzr.xy = R(bzr.xy, bzr.z*PI*2.);\n    bzr.x = abs(bzr.x)-.05;\n    float tw = length(vec2(bzr.x, bzr.y))-.3;\n    \n    // cut \n    float d = max(tw, abs(bzrz)-.5);\n    \n    return d;\n}\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.5\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.5 @ 2022/09/14    \n//        - Fixed long compilation in Quad view.\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n#define INIT_CAM_POS vec3(0,0,2)\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        vec2 offset;\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n        fragColor = vec4(renderRect(fragCoord*2.-offset),1);\\\n        if((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) || (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.))fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 427, 483, 660, 2317], [2319, 2401, 2472, 2472, 2518], [2520, 2520, 2546, 2560, 3147]], "test": "untested"}
{"id": "NlKcD1", "name": "Fractured fractal", "author": "jarble", "description": "A fractal with a fractured pattern.", "tags": ["fractal", "fracture", "fissure"], "likes": 4, "viewed": 265, "published": 3, "date": "1661395382", "time_retrieved": "2024-07-30T16:34:28.250831", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 2.;\n        vec2 t2 = vec2(0.);\n        for(int k = 0; k < 12; k++){\n            uv = (uv+t2)/scale;\n            t2 = -triangle_wave(uv-.5);\n            uv = t2-triangle_wave(uv.yx);\n            col = abs(vec3(uv.y-uv.x,col.yz));\n            if(t2.x-t2.y < 0.) {col = col.yzx; uv /= scale;} else {t2 /= scale;}\n        }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 674]], "test": "untested"}
{"id": "flVyWh", "name": "O *= 0.", "author": "Xor", "description": "This is a quick test to see if \"O *= 0.\" works on most hardware. Does work on your machine?", "tags": ["golf"], "likes": 34, "viewed": 1061, "published": 3, "date": "1661379657", "time_retrieved": "2024-07-30T16:34:29.064654", "image_code": "/*\n    \"O *= 0.\" by @XorDev\n    \n    This is a quick test to see if \"O *= 0.\" works on most hardware.\n    Does work on your machine?\n\n    Idea from FabriceNeyret2 here: https://www.shadertoy.com/view/styyDR\n*/\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O *= 0.; //Does this work on your machine?\n    \n    //Resolution for scaling\n    vec2 R = iResolution.xy;\n    //Loop through 30 orbs\n    for(float i=0.; i++<30.; )\n    \n        //Color (simple sine palette)\n        O += (sin(i+vec4(0,1,2,0)) + 1.)/.3\n        //Brightness attenuation\n            / length(I+I-R+cos(i*R+iTime)*R);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 210, 246, 246, 582]], "test": "untested"}
{"id": "7lGyD1", "name": "The Redmond wrinkle", "author": "ruojake", "description": "A wallpaper", "tags": ["3d", "raymarching", "abstract"], "likes": 4, "viewed": 279, "published": 3, "date": "1661372197", "time_retrieved": "2024-07-30T16:34:29.825619", "image_code": "// The Redmond wrinkle by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat scene(vec3 p)\n{\n    p.xz *= rot(.2);\n    float a = atan(p.z, p.x) * 2.5;\n    a += length(p.xz) * 1.3;\n    p.xz *= 1. + (sin(a) + sin(a * 2.) * .5 + sin(a * 3.) * .25) * .25;\n    float t = abs(abs(abs(abs(abs(length(p.xz) - .5) - .4) - .2) - .1) - .05) - .001;\n    return max(t, p.y + 1. - (length(p.xz) * .4 - .1) - .2 * dot(sin(p.xz * 2.5), vec2(p.z * 3. + .5)));\n}\n\nvec3 normal(vec3 p, float d)\n{\n    const vec2 e = vec2(.00075,0);\n    return normalize(\n        d - vec3(\n            scene(p - e.xyy),\n            scene(p - e.yxy),\n            scene(p - e.yyx)\n        )\n    );\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.;\n    float t = 0.;\n    \n    for(int i = 0; i < 160; ++i)\n    {\n        float d = scene(ro+rd*t);\n        res = min(res, 8.*d/t);\n        t += d;\n    }\n    \n    return max(res,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    float dth = fract(dot(fragCoord, vec2(.155013, .61233)));\n\n    vec3 col = vec3(.75 + uv.y * .5),\n          ro = vec3(0,.5,-2),\n          rd = normalize(vec3(uv, 1)),\n          p;\n          \n    rd.yz *= rot(.45);\n    float i, d = 0., t = dth * .2;\n    \n    for(i = 0.; i < 1. && t < 12.; i += 1./512.)\n    {\n        p = ro + rd * t;\n        d = scene(p)*.33;\n        if (abs(d) < .0001) break;\n        t += d;\n    }\n    \n    if (t < 12.)\n    {\n        vec3 n = normal(p,d);\n        vec3 ld = normalize(vec3(1,1,-1));\n        float frn = pow(1. - max(dot(rd,-n), 0.), 16.);\n        float l = dot(ld,n) * .5 + .5;\n        l *= l;\n        \n        l *= shadow(p + n * .001, ld);\n        l = max(l, frn * .5);\n        col = mix(vec3(.05, .1, .2), vec3(.1,.3,1.), sqrt(l));\n        col = mix(col, vec3(l), l*l*.75);\n    }\n\n    col *= 1. - pow(length(fragCoord / iResolution.xy - .5), 3.);\n\n    fragColor = vec4(col + dth / 255.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGyD1.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[120, 120, 139, 139, 212], [214, 214, 235, 235, 586], [588, 588, 618, 618, 801], [803, 803, 835, 835, 1036], [1038, 1038, 1095, 1095, 2096]], "test": "untested"}
{"id": "7lycDh", "name": "Mouse Complex", "author": "Behzod", "description": "it is base of mendalbrot", "tags": ["line", "complex", "fractalbase"], "likes": 2, "viewed": 211, "published": 3, "date": "1661363013", "time_retrieved": "2024-07-30T16:34:30.578606", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define fit(func) 1. - smoothstep(0., 0.007, func)\n#define Red     vec3(1, 0, 0)\n#define Blu     vec3(.3, .5, .7)\n#define Orn     vec3(1, 0.5, 0)\n#define t       iTime\n\nstruct complex{\n vec2 v;\n};\n\nvec2 mul(vec2 v1, vec2 v2){\n return vec2(v1.y*v2.y - v1.x*v2.x,\n         v1.x*v2.y + v2.x*v1.y);\n}\n\nfloat Line(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 ba = b - a;\n  vec2 pa = p - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - h * ba);\n}\n\nfloat cycl(in vec2 uv){\n uv.y *= (iResolution.y/iResolution.x);\n return length(uv) - 0.01;\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n vec2 uv = FragCoord/iResolution.xy;\n vec2 ms = iMouse.xy /iResolution.xy;\n vec3 col = vec3(.5, .25, .2)/1.2;\n \n float R = 0.37;\n if(ms == vec2(0, 0)){\n     ms.x = R * cos(t);\n     ms.y = R * sin(t);\n }\n\n float line;\n complex point;\n vec2 tempP;\n\n point.v = vec2(0);\n\n float cycP0 = cycl(uv - point.v);\n cycP0 = fit(cycP0);\n col = mix(col, Red, cycP0);\n tempP = point.v;\n\n point.v = mul(point.v, point.v);\n point.v += ms;\n float cycP1 = cycl(uv - point.v);\n cycP1 = fit(cycP1); // below point\n col = mix(col, Red, cycP1);\n // fst line\n line = Line(uv, tempP, point.v);\n line = fit(line);\n col = mix(col, Blu, line);\n tempP = point.v;\n\n\n\n point.v = mul(point.v, point.v);\n point.v += ms;\n float cycP2 = cycl(uv - point.v);\n cycP2 = fit(cycP2);\n col = mix(col, Red, cycP2);\n // scnd line\n line = Line(uv, tempP, point.v);\n line = fit(line);\n col = mix(col, Blu, line);\n tempP = point.v;\n\n point.v = mul(point.v, point.v);\n point.v += ms;\n float cycP3 = cycl(uv - point.v);\n cycP3 = fit(cycP3);\n col = mix(col,Red, cycP3);\n // thrd line\n line = Line(uv, tempP, point.v);\n line = fit(line);\n col = mix(col, Blu, line);\n tempP = point.v;\n\n point.v = mul(point.v, point.v);\n point.v += ms;\n float cycP4 = cycl(uv - point.v);\n cycP4 = fit(cycP4);\n col = mix(col, Red, cycP4);\n // fourth line\n line = Line(uv, tempP, point.v);\n line = fit(line);\n col = mix(col, Blu, line);\n tempP = point.v;\n\n point.v = mul(point.v, point.v);\n point.v += ms;\n float cycP5 = cycl(uv - point.v);\n cycP5 = fit(cycP5);\n col = mix(col, Red, cycP5);\n // fifth line\n line = Line(uv, tempP, point.v);\n line = fit(line);\n col = mix(col, Blu, line);\n tempP = point.v;\n\n point.v = mul(point.v, point.v);\n point.v += ms;\n float cycP6 = cycl(uv - point.v);\n cycP6 = fit(cycP6);\n col = mix(col, Red, cycP6);\n // sixth line\n line = Line(uv, tempP, point.v);\n line = fit(line);\n col = mix(col, Blu, line);\n tempP = point.v;\n\n point.v = mul(point.v, point.v);\n point.v += ms;\n float cycP7 = cycl(uv - point.v);\n cycP7 = fit(cycP7);\n col = mix(col, Red, cycP7);\n // fifth line\n line = Line(uv, tempP, point.v);\n line = fit(line);\n col = mix(col, Blu, line);\n tempP = point.v;\n // uv = step(vec2(0.5), uv);\n FragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lycDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 321, 321, 392], [394, 394, 439, 439, 563], [565, 565, 588, 588, 657], [659, 659, 714, 714, 2909]], "test": "untested"}
{"id": "NtGyDh", "name": "Donut soul", "author": "ruojake", "description": "Threw a bit of everything at the wall and now the wall is like that.", "tags": ["3d", "raymarching", "abstract"], "likes": 9, "viewed": 295, "published": 3, "date": "1661341069", "time_retrieved": "2024-07-30T16:34:31.345556", "image_code": "// Donut soul by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// 2022-08-25: Added some cheese\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat cheb(vec3 p, float k)\n{\n    return pow(pow(abs(p.x),k) + pow(abs(p.y),k) + pow(abs(p.z),k), 1./k);\n}\n\nfloat cheb(vec2 p, float k)\n{\n    return pow(pow(abs(p.x),k) + pow(abs(p.y),k), 1./k);\n}\n\nfloat time;\n\nfloat scene(vec3 p)\n{\n    float pt = time * 3.141593;\n    mat2 r = rot(pt / 3.);\n    \n    p.xz *= r;\n    float tr0 = abs(cheb(p.xy, 2.5 + sin(pt)) - 1.) - .5;\n    p.zy *= r;\n    float tr1 = abs(cheb(p.yz, 3. - sin(pt * 2.) * 1.5) - 1.) - .5;\n    p.yx *= r;\n    float tr2 = abs(cheb(p.zx, 2.1 + sin(pt * -3.) * .5) - 1.) - .5;\n    \n    return cheb(vec3(tr0, tr1, tr2), 2.25 + .75 * sin(pt * .5)) - .5;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    const vec2 e = vec2(.004, 0);\n    return normalize(\n        d - vec3(\n            scene(p - e.xyy),\n            scene(p - e.yxy),\n            scene(p - e.yyx)\n        )\n    );\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.;\n    float t = 0.;\n    for(int i = 0; i < 80 && res > 0.; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = scene(p);\n        if (d < .001) return 0.;\n        res = min(res, d/t);\n        t += d;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6),\n         rd = normalize(vec3(uv, 1.75)),\n         p;\n    \n    time = iTime;\n    \n    float zoomPos = uv.y * .5;\n    float zoomWidth = .5;\n    zoomPos += fract(time * .17) * 1.5 - fract(time * .3);\n    zoomWidth *= 2. + sin(time * .5) * fract(time * .2 + .3);\n    bool isZoomed = abs(uv.x - zoomPos) < zoomWidth * .5;\n    if (isZoomed)\n    {\n        rd = normalize(vec3(uv, 3.));\n        ro.y += floor(cos(time * .7) * 1.5) * .5;\n    };\n    \n    float hft = length(fract(uv * (isZoomed ? 15. : 40.)) - .5);\n    time += step(.5, hft) * .1 * (sin(iTime + length(uv) * 8.) * .5 + .5);\n    \n    float t = 2., d = 0., i = 0.;\n    \n    for(;i < 1. && t < 12.; i += 1./256.)\n    {\n        p = ro + rd * t;\n        d = scene(p) * .7;\n        if (abs(d) < .0001) break;\n        t += d;\n    }\n\n    vec3 col = vec3(.75 + uv.y * .25);\n    \n    bool line = abs(abs(uv.x - zoomPos) - zoomWidth * .5) < .05;\n    bool render = t < 12. && !line;\n    \n    if (render)\n    {\n        vec3 n = normal(p,d);\n        float frn = pow(1. - dot(rd,-n), 8.);\n        vec3 rfd = reflect(rd, n);\n        vec3 ld = normalize(vec3(1,1,-1));\n        float l = dot(ld, n) * .5 + .5;\n        l *= l;\n        float s = shadow(p + n * .1, ld);\n        float rf = frn * pow(dot(vec3(1), cos(rfd * 16. + 3.)), 4.) * (n.y * .5 + .5) * (1.-i);\n        float spec = pow(dot(rfd, ld), 16.);\n        float lighting = min(max(rf, s *max(spec, l)), 1.);\n        col = mix(vec3(.05,.1,.5) * max(sqrt(lighting), .1), mix(vec3(1.,.5,.3), vec3(1.,.1,.6), lighting), lighting);\n        col = mix(col,vec3(lighting), lighting * lighting * lighting);\n        if (isZoomed) col = max(vec3(.85,1.,0), vec3(floor(lighting * 6.)/6.)) * step(.125,lighting);\n    }\n\n    col *= 1. - pow(length((fragCoord / iResolution.xy) - .5), 5.);\n\n    float dth = fract(dot(fragCoord + float(iFrame & 7) * iResolution.xy, vec2(.11592,.60233)));\n    if (line) col = vec3(1);\n    fragColor = vec4(col + dth / 255.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGyDh.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[145, 145, 164, 164, 237], [239, 239, 268, 268, 345], [347, 347, 376, 376, 435], [450, 450, 471, 471, 852], [854, 854, 884, 884, 1066], [1068, 1068, 1100, 1100, 1348], [1350, 1350, 1407, 1407, 3453]], "test": "untested"}
{"id": "ftGcWh", "name": "parallelism illusion 3", "author": "FabriceNeyret2", "description": "minimalistic version of reference: https://twitter.com/gsarcone/status/1562219678281240576", "tags": ["illusion", "2tweets", "perception", "short", "golf", "reproduction"], "likes": 8, "viewed": 257, "published": 3, "date": "1661327864", "time_retrieved": "2024-07-30T16:34:32.154393", "image_code": "// variant of https://shadertoy.com/view/ftyyWh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.* ( 2.*u - R ) / R.y;\n\n    U.y = fract(U.y) \n        + .04* sign(mod(U.y,2.)-1.) * (fract(2.*U.x)-.5);\n    \n    O = step(.5,fract(U.xxxx)) * smoothstep( 9./R.y, 0., abs(U.y-.5)-.01 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 317]], "test": "untested"}
{"id": "NlyyWh", "name": "Fractal mosaic 6", "author": "jarble", "description": "A variant of my \"Banded mosaic\" pattern with a more interesting color palette.", "tags": ["fractal", "mosaic"], "likes": 6, "viewed": 509, "published": 3, "date": "1661327751", "time_retrieved": "2024-07-30T16:34:33.053988", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //min(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //fract(a-fract(a*4.)/2.)\n        //fract(a+floor(a.y*2.+.5)/2.)\n    ;\n}\n\n\nvec2 triangle_wave(vec2 a){\n    //a += sign(a.x-a.y)/2.;\n    //a += sign(a.y)/2.;\n    //a += sign(a.x)/2.;\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(2.,-0.5)\n        //vec2(2.5,-1.)\n        \n        //vec2(1.5,0.)\n        \n        //vec2(-2.,.5+mod(floor(a.x),2.))\n    ,\n    \n    a1 =\n        a+a2\n        //a*sign(a-a2.yx)+a2\n        //a+a2+mod(floor(a.x),3.)\n        //a+a2+floor(a.x)\n        //a+a2+floor(a.y)\n    ;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return abs(f1((a1)*(a2.x+a2.y))-.5);\n}\n\n/*\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n*/\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\n\nvec3 fractal(vec2 uv,float s1,float s2){\n    vec3 col = vec3(0.);\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    //float p1 = 1.;\n    bool b1 = false;\n    for(int k = 0; k < 9; k++){\n        \n        //uv.x += t1_(floor(uv),floor(uv));\n        \n        b1 = uv.y>uv.x || !b1;\n        //uv += floor((uv.x+.5)*2./1.5)/2.;\n\n        \n        //uv.x += fmod(uv.x,1.5); //lace pattern\n        //uv += floor(uv+vec2(1.,0.5))/1.5;\n        //uv.x += floor(uv.x*4.)/4.;\n\n        //uv += binary_digit(k,1)/2.;\n        //uv += binary_digit(k,2)/2.;\n        //uv += binary_digit(k,3)/2.;\n\n        float offset =\n            0.\n            //.25\n            //float(k)/2.\n        ;\n        \n        //another awesome pattern (looks better zoomed out)\n        //if(uv.y>uv.x){ uv = uv.yx+.5;t2 = -t2.yx;}\n        \n        //if(t3||t2.x>t2.y)\n        //if(t2.x<t2.y||!t3)\n        uv =\n            //max(abs(.5+uv+t2),abs(-.5+uv+t2))/scale\n            //(uv+max(t2,uv)/1.5)/scale\n            //(t2+max(uv.yx,t2))\n            //(uv/1.5+t2)\n            (uv+t2)/scale\n        ;\n        \n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n\n        //uv.x += .5;\n\n        //uv *= sign(uv.yx-uv);\n        //if(uv.y<uv.x) uv = uv.yx; else uv *= sign(uv-uv.yx);\n        t2 =\n            triangle_wave(uv+.5*s1+offset)\n            //triangle_wave(uv+.5*sign(uv.x-.5)+offset)\n            //triangle_wave(uv+.5+offset)*sign(.5-uv.x)\n            //-triangle_wave(uv-.5)/(.5+fmod(t2.x,2.))\n            //triangle_wave(uv+.5*sign(uv.x-uv.y))\n            //triangle_wave(uv+.5)*(.5+fmod(t2.x,2.))\n        ;\n        \n        //uv += floor(t2.y-t2.x);\n        uv =\n            t2-triangle_wave(uv.yx+s2+offset)\n            //fract(t2-triangle_wave(uv.yx+offset)+.5)\n            //t2-triangle_wave(uv.yx+offset+floor(uv.x+uv.y))\n        ;\n        \n        //uv += length(uv/8.);\n        //uv += length(uv/4.);\n        //uv.y += floor((uv.x-uv.y))/2.;\n        \n        //uv.x -= sign(uv.x)*.5;\n        \n        float c1 =\n            uv.y-uv.x\n            //uv.y-uv.x*float(col.x<col.y)\n            //uv.y-uv.x*sign(t2.y-t2.x)\n        ;\n        //c1 = max(c1,t2.x-t2.y);\n        \n        //if(t3)\n        //if(uv.y>uv.x)\n        col =\n            vec3(c1,col.yz)\n            //vec3(max(c1,col.x),col.yz)\n        ;\n\n        //col = col.xzy;\n        if(t3 =\n            //t2.x < t2.y || !t3\n            t2.x<t2.y\n            //b1\n            //t2.x*float(!b1) < t2.y\n            //t2.x < t2.y && uv.x < uv.y || !t3\n        ) col =\n            col.yzx\n            //fract(col.yzx-iTime)/2.\n        ;\n        //if(uv.x < uv.y) uv /= 1.5;\n        //if(t2.x*uv.x < t2.y*uv.y) col = col.yzx;\n        //if(t2.x-t2.y > uv.x-uv.y) col = col.yzx;\n        //if(t2.x<t2.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n        //if(uv.x<uv.y && k%2 == 0) {uv = -uv;break;}\n        //if(uv.x>uv.y) uv.x -= .5;\n        //if(uv.x < .5) uv.x += .5;\n        //if(uv.y < .5) uv.y += .5;\n        //if(uv.y>uv.x) {uv=-uv.yx;t2=t2.yx;}\n        \n        //WOW!\n        //{uv=-uv.yx;t2=-t2.yx;}\n        //uv -=\n            //float(uv.x>uv.y)/1.5\n            //float(uv.x>uv.y&&t2.x>t2.y)/1.5\n        //;\n\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    col = fractal(uv,1.,0.);\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "\n//#define fmod(a, b) mod(mod(floor(a),floor(1.+(a)/5.)),b)\n\n//multiply by prime numbers to get an interesting rhythm\n//#define fmod(a,b) mod(floor(a)+floor((a)/2.)*2.+floor((a)/4.)*3.+floor((a)/8.)*5.+floor((a)/16.)*7.,b)\n\n\n//#define fmod(x,y) mod(floor(x)+floor(floor((x))/8.),y)\n#define fmod1(x,y) mod(floor(x+floor(t0*y)),y)\n#define fmod2(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)*floor(x),y*y)/y)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))\n#define floor1(x) floor(x)*floor(mod((x)/2.,2.))\n\n\nvec2 mainSound1(int samp, float t,float scale){\n  float tempo =\n      1.\n      //pow(2.,fmod(t/4.,2.))\n  ;\n  t /= tempo;\n  /*\n  for(int i = 0; i < 3; i++){\n        t += mod(floor(t*4.),4.);\n  }\n  */\n  //t = (t + pow(2.,fmod(t*2.,3.)));\n  t += fpow(t,2.)*fpow(t*2.,2.)*fpow(t/2.,2.);\n  //t = t*(1. + fmod(t*4.,2.))/2.;\n  //t += floor(t*4.)/4.;\n  float t0=t, s1 =\n      8.\n      //pow(2.,2.+fmod(t/16.,2.))\n  ;\n      \n  //t += floor(t*8.)/8.;\n  \n  float\n  z1 =\n      (1.+fmod(t+floor(t/s1)/s1,2.))\n      //(1.+fmax(t+floor(t/s1)/s1,t,2.))\n  ,\n  m3 =\n      fmod(t*s1+z1,s1)\n      //fmax(t*s1+z1,t*s1,s1)\n  ;\n  //t += m3;\n  t /=\n      1.+fmod(floor(t)/s1,2.)\n      //1.+fmod(floor(t*z1)/s1,2.)\n  ;\n  /*\n  for(int i = 0; i < 3; i++){\n      t += mod(floor(t*4.),2.)/2.;\n  }\n  */\n  float a =\n      //64.*sqrt(1.-sqrt(fract(t)))*.2\n      (2.-log(fract(t)))*(2.-log(fract(t/2.)))\n      //64.*sqrt(1.-sqrt(fract(t*pow(2.,fmod(t/4.,4.)))))*.2\n  ,\n\n  nb =\n      //pow(2.,(m3+z1+sign(m3-z1))/5.+7.)\n      t*pow(2.,(m3+z1)/5.+scale)*tempo\n  ;\n  //nb *= sign(z1-m3);\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      //(abs(a/8.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //abs(log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}\n\nvec2 mainSound(int a,float b){\n    return mainSound1(a,b,7.);\n    //return (mainSound1(a,b,7.5)+mainSound1(a,b/2.,7.5)+mainSound1(a,b/4.,7.5))/3.;\n    //return mainSound1(a,b,6.5)+mainSound1(a,b/2.,6.5)/2.+mainSound1(a,b/4.,6.5)/4.+mainSound1(a,b/8.,6.5)/8.;\n}", "sound_inputs": [], "common_code": "float fmod2(float a, float b){\n    return mod(floor(a/b),b)*b;\n}\n\nfloat fmod1(float a, float b){\n    //a += floor(a/2./pow(2.,fmod2(a,2.)));\n    \n    //a += fmod2(a*2.,4.);\n    //a += pow(2.,mod(floor(a/4./4.),4.));\n    //a += floor(a/2.);\n    //a += floor(a/4.);\n    //a += floor(a/8.);\n    //a += floor(a/16.);\n    \n    \n    float a1 = floor(a);\n    \n    //another amazing remix!\n    //a -= mod((floor(a/2.)+b),2.);\n    \n    //divide by powers of 2 to get interesting rhythms\n    //a /= 1. + mod(floor(a1/32.),2.);\n    //a /= 1. + mod(floor(a1/16.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //floor(mod(floor(a)+mod(a/8.,8.),b))\n        //mod(floor(mod(floor(a)/2.,b))+floor(mod(floor(a),b*2.)),b)\n        //mod(floor(floor(a)*b/3.),b)\n        //mod(floor(a+8./b),b)\n        //abs(b-mod(floor(a+b),b*2.))\n        //mod(mod(floor(a+b),floor(a/8.+4.)),b)\n        //floor(sqrt(mod(floor(a/2.),(b))*mod(floor(a/b)*floor(a*b/8.),b)))\n        //mod(floor(a*2./b+b/2.),b)\n        //mod(floor(a*sign(.5-mod(floor(a*4./b),2.))),b)\n        //max(mod(floor(a+floor(a/4.))*floor(a),b),mod(floor(a),b))\n\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //fmod1(a+fmod1(a/4.,b),b)\n    ;\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 180], [183, 183, 210, 289, 831], [1023, 1023, 1049, 1049, 1138], [1141, 1141, 1181, 1181, 4330], [4332, 4332, 4389, 4389, 4690]], "test": "untested"}
{"id": "NtyyWh", "name": "parallelism illusion 2", "author": "FabriceNeyret2", "description": "try Mouse.y", "tags": ["illusion", "2tweets", "perception", "short", "golf", "reproduction"], "likes": 10, "viewed": 180, "published": 3, "date": "1661327506", "time_retrieved": "2024-07-30T16:34:33.881774", "image_code": "// variant of https://shadertoy.com/view/ftyyWh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.* ( 2.*u - R ) / R.y;\n    U.y = fract(U.y) \n        - .02* sign( (mod(U.y,2.)-1.) ) * sin(12.56*U.x + 6.*iMouse.y/R.y);\n    \n    O = vec4( mix(.5, step(fract(U.x),.5), smoothstep( 9./R.y, 0., abs(U.y-.5)-.01 ) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 347]], "test": "untested"}
{"id": "slVyDz", "name": "Zeta derivative", "author": "guil", "description": "Represents the first derivative of Riemann Zeta function with he Riemann–Siegel Z function, shifted by 1/2 so it intesects the critical line at zeros.\nKey 1 : Zeta, Key 2 : numerical derivative.\n", "tags": ["derivative", "zeta"], "likes": 5, "viewed": 220, "published": 3, "date": "1661327251", "time_retrieved": "2024-07-30T16:34:34.702580", "image_code": "const float pi = 3.1415926535897932;\nconst float LOG2 = 0.6931471805599453;\nconst float LOGPI = 1.1447298858494002;\n\n\n\n//------------------ ------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cinv(vec2 z) {return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cexp( vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog( vec2 z) {  return vec2( 0.5*log(z.x*z.x+z.y*z.y), atan(z.y,z.x)); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cpow( vec2 a, vec2 b ) {  return cexp(cmul(b,clog(a))) ;}vec2 cpow( float n, vec2 z ) {  return (n>0.)? pow( n, z.x )*vec2( cos(z.y*log(n)), sin(z.y*log(n)) )\n            :cpow(vec2(n,0),z); }\n\nvec2 csin( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\n\nvec2 ccos( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\nvec2 clogsin(vec2 z) {\n  if (abs(z.y)<8.0)return clog(csin(z));  \n  if (z.y > 0.) return vec2(z.y - LOG2, mod(1.5*pi-z.x, 2.0*pi) - pi);\n  else return vec2(-z.y - LOG2, mod(0.5*pi+z.x, 2.0*pi) - pi);\n  \n}\n//------------------------------------------------------------\n\n\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 col(vec2 u){\n    float r = u.x;\n    float v =min( exp(-r*.15),1.);\n    return hsv2rgb(vec3(u.y/(2.*pi),.5+.5*fract(r),.8))*v;\n}\n\n\n\n// Spouge's method for gamma\nvec2 gamma(vec2 z){\n    const int N = 16;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t   \n    s = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    return cdiv(s,z);\n    //s = clog(s); \n    //s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    //return s-clog(z);      \n}\n\n// Spouge's method for gamma\nvec2 loggamma(vec2 z){\n    const int N = 16;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t   \n    //s = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    //return cdiv(s,z);\n    s = clog(s); \n    s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    return s-clog(z);      \n}\n\n\n\n//Zeta with first Euler Maclaurin term \nvec2 zeta1(vec2 z, float a){\n  const float N = 400.;\n  vec2 sum = vec2(0);\n  for(float i = 0.; i < N; i++)\n    sum += cpow(i+a,-z);\n  return sum+cdiv(cpow(N+a,vec2(1,0)-z),z-vec2(1,0))+ cpow(N+a,-z)/2.;\n}\n\n\n//Borwein algorithm 3\n//http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nvec2 eta3(vec2 s) {\n  const int N = 120;  \n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n  return sum1 + sum2;\n}\n\n//Borwein algorithm 3\n//http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nvec2 deta3(vec2 s) {\n  const int N = 120;  \n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*cpow(float(i), -s)*log(float(i));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*cpow(float(2*N-i),-s)*log(float(2*N-i));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n  return -sum1 - sum2;\n}\n\nvec2 dzeta3(vec2 s) {\n  vec2 n = cmul(deta3(s),vec2(1,0)-cpow(2.,vec2(1,0)-s))\n         - cmul(eta3(s),cpow(2.,vec2(1,0)-s)*log(2.));\n  vec2 d = csqr(vec2(1,0)-cpow(2.,vec2(1,0)-s));\n  return cdiv(n,d);\n}\n\nvec2 logkhi(vec2 z){\n    return z*log(2.*pi)-vec2(log(pi),0)+clogsin(pi*z/2.)+loggamma(vec2(1.,0.)-z);\n}  \n\nvec2 logzeta(vec2 z){\n    if(z.x<.5)return logkhi(z)+clog(eta3(vec2(1.,0.)-z))-clog(vec2(1,0)-cpow(2.,z));\n    return clog(eta3(z))-clog(vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\nvec2 zeta(vec2 z){    \n    return cexp(logzeta(z));\n}\n\nvec2 dzeta(vec2 z){\n    vec2 eps = vec2(1e-2);\n    return cdiv(zeta(z+eps)-zeta(z-eps),2.*eps);\n\n}\n\n//θ(t)\nfloat theta(float t){\n    return -t/2.*log(pi)+loggamma(vec2(.25,t*.5)).y;    \n}\n//or θ(t) = t/2 log(t/2π)−t/2−π/8+1/48t+7/5760t^3+...\nfloat theta1(float t){\n    return t/2.*log(t/2./pi)-t/2.-pi/8.+1./(48.*t)+7./(5760.*t*t*t);    \n}\n\n\n//Riemann Siegel Z function using Riemann Siegel formula\n//Not accurate, needs more terms\nfloat Z1(float t){\n    float m = sqrt(t/2./pi);\n    float r= 0.;\n    float s=-1.;\n    for(float i=1.;i< m; i++)\n        r += cos((theta(t))-t*log(i))/sqrt(i);\n        s=-s;\n    r*=2.;\n    float z=2.*(m-floor(m))-1.;\n    r += s/sqrt(m)*cos(.5*pi*z*z+3./8.*pi)/cos(pi*z);\n    //r += ...\n    return r;\n}\n\n//Riemann Siegel Z function \nfloat Z(float t){\n    return cmul(zeta1(vec2(.5,t),1.),cexp(vec2(0,theta(t)))).x;    \n}\n\n\nbool keypress(int key) {\n    return texelFetch(iChannel3, ivec2(key,2),0).x != 0.0;\n}\n\n\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (2.*fragCoord - iResolution.xy-iMouse.xy) / iResolution.y+(iMouse.xy==vec2(0.,0.)?0.:.5);;  // Map y-coordinates to [-1;1]\n  float zoom = 12.;\n  if (keypress(90)) zoom = 4.0;\n  if (keypress(85)) zoom = 16.0;\n  uv *= zoom;  // Zoom out\n  float shift = 0.;\n  if (keypress(87)) shift = 376.0;//w\n  if (keypress(88)) shift = 1440.0;//x\n  uv.x += shift+iTime;  // Move up in uv-space!\n  vec2 z = uv.yx;  \n    \n  if (keypress(49)) {//1\n      z=logzeta(z);\n  } else if (keypress(50)){//2\n      z = clog(dzeta(z));\n  } else{\n      z=clog(dzeta3(z));\n  }\n  fragColor.rgb = col(z);\n  float size = 4.*zoom/iResolution.x;\n  if (mod(abs(uv.x),5.)<size)fragColor.rgb = vec3(0.5);\n  if (mod(abs(uv.y),5.)<size)fragColor.rgb = vec3(0.5);\n  if (abs(uv.y-.5)<size)fragColor.rgb = vec3(1);\n  float x = abs(uv.x);\n  float k = exp(-10.*abs(Z(x)-uv.y+.5));\n  \n  fragColor.rgb += vec3(k);\n  \n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 212, 242, 242, 271], [272, 272, 302, 302, 357], [358, 358, 377, 377, 409], [410, 410, 440, 440, 510], [511, 511, 532, 532, 578], [579, 579, 601, 601, 688], [689, 689, 710, 710, 735], [736, 736, 756, 756, 805], [806, 806, 826, 826, 884], [885, 885, 915, 915, 1015], [1016, 1016, 1045, 1045, 1078], [1078, 1078, 1108, 1108, 1213], [1215, 1215, 1235, 1235, 1312], [1314, 1314, 1334, 1334, 1412], [1413, 1413, 1435, 1435, 1617], [1685, 1685, 1707, 1707, 1876], [1879, 1879, 1896, 1896, 2011], [2015, 2044, 2063, 2063, 2555], [2557, 2586, 2608, 2608, 3098], [3102, 3142, 3170, 3170, 3346], [3349, 3452, 3471, 3471, 3871], [3873, 3976, 3996, 3996, 4424], [4426, 4426, 4447, 4447, 4630], [4632, 4632, 4652, 4652, 4736], [4740, 4740, 4761, 4761, 4911], [4913, 4913, 4931, 4931, 4966], [4968, 4968, 4987, 4987, 5066], [5068, 5076, 5097, 5097, 5156], [5157, 5218, 5240, 5240, 5315], [5318, 5408, 5426, 5426, 5708], [5710, 5739, 5756, 5756, 5826], [5829, 5829, 5853, 5853, 5914], [5917, 5917, 5972, 5972, 6855]], "test": "untested"}
{"id": "ftyyWh", "name": "parallelism illusion", "author": "FabriceNeyret2", "description": "minimalistic version of reference: https://twitter.com/gsarcone/status/1562219678281240576", "tags": ["illusion", "perception", "reproduction"], "likes": 13, "viewed": 204, "published": 3, "date": "1661327047", "time_retrieved": "2024-07-30T16:34:35.538346", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.* ( 2.*u - R ) / R.y;\n // U.x *= 1. + .5*sin(iTime);\n    U.y = fract(U.y) \n        + .01* sign( (fract(2.*U.x)-.5)*(mod(U.y,2.)-1.) );\n    \n    O = vec4( mix(.5, step(fract(U.x),.5), smoothstep( 9./R.y, 0., abs(U.y-.5)-.01 ) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 313]], "test": "untested"}
{"id": "7lKcDR", "name": "Truchet Sparks", "author": "fenix", "description": "*drag with mouse* *space to reset* \nSame basic particle system with new colors and a truchet function from Exercise: basic truchet tiling by endymion https://www.shadertoy.com/view/WlcfWf\n", "tags": ["2d", "voronoi", "simulation", "particles", "flow", "liquid", "sph"], "likes": 10, "viewed": 280, "published": 3, "date": "1661320035", "time_retrieved": "2024-07-30T16:34:36.495785", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, attempting to approximate smoothed particle\n//  hydrodynamics. \n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles\n//  Buffer D applies temporal blur\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 p = fragCoord/iResolution.xy;\n    //fragColor = vec4(truchet(iResolution, 0, fragCoord));//*1000.0;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 100000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.002;\nconst float PARTICLE_REPEL_SIZE = 0.03;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\n\nconst int NUM_WING_POINTS = 25;\nvec2 WING_POINTS[NUM_WING_POINTS] = vec2[](\n    vec2(-0.9,  0.8),\n    vec2(-0.65,  0.5),\n    vec2(-0.85,  0.45),\n    vec2(-0.55,  0.3),\n    vec2(-0.75,  0.125),\n    vec2(-0.45,  0.1),\n    vec2(-0.63,  -0.2),\n    vec2(-0.35, -0.1),\n    vec2(-0.51,  -0.45),\n    vec2(-0.25, -0.3),\n    vec2(-0.2, -0.3),\n    vec2(-0.1, -0.4),\n    vec2(-0.075, -0.6),\n    vec2(-0.175, -0.75),\n    vec2(-0.05, -0.7),\n    vec2(-0.15, -0.85),\n    vec2(-0.045, -0.8),\n    vec2(-0.05, -0.9),\n    vec2(-0.0, -0.85),\n    vec2(-0.0, 0.125),\n    vec2(-0.045, 0.0),\n    vec2(-0.125, -0.1),\n    vec2(-0.2, -0.0),\n    vec2(-0.3,  0.2),\n    vec2(-0.6,  0.6)\n);\n\nfloat sdPolygon( in vec2[NUM_WING_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_WING_POINTS-1; i<NUM_WING_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst int NUM_HEAD_POINTS = 9;\nvec2 HEAD_POINTS[NUM_HEAD_POINTS] = vec2[](\n    vec2(-0.0, -0.2),\n    vec2(0.0, 0.3),\n    vec2(-0.1, 0.4),\n    vec2(-0.2, 0.425),\n    vec2(-0.145, 0.5),\n    vec2(-0.05, 0.7),\n    vec2(0.15, 0.75),\n    vec2(0.25, 0.55),\n    vec2(0.2, 0.35)\n);\n\nfloat sdPolygon( in vec2[NUM_HEAD_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_HEAD_POINTS-1; i<NUM_HEAD_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n/*\nfloat sdPhoenix(in vec2 p)\n{\n#if 1\n    float minDist = sdPolygon(WING_POINTS, p);\n    minDist = min(minDist, sdPolygon(WING_POINTS, vec2(-p.x, p.y)));\n    minDist = min(minDist, sdPolygon(HEAD_POINTS, p));\n    return minDist;\n#else\n    float minDist = sdBox(p, vec2(0.05, 0.1));\n    minDist = min(minDist, sdTriangle(p, vec2(-0.9, 0.9), vec2(-0.0, -0.0), vec2(-0.5, 0.9)));\n    minDist = min(minDist, sdTriangle(p, vec2( 0.9, 0.9), vec2(-0.0, -0.0), vec2( 0.5, 0.9)));\n    return minDist;\n#endif\n}\n\nvec2 normPhoenix(in vec2 p)\n{\n    const float DELTA = 0.001;\n    return vec2(sdPhoenix(p + vec2(DELTA, 0.0)) - sdPhoenix(p - vec2(DELTA, 0.0)),\n                sdPhoenix(p + vec2(0.0, DELTA)) - sdPhoenix(p - vec2(0.0, DELTA)));\n}\n*/\n\nfloat truchet(in vec3 res, in int frame, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * res.xy) / res.y;\n    \n    // Zoom;\n    float scale = 10.0;\n    uv *= scale; \n    \n    // Tiles from -.5 to .5\n    vec2 gv = fract(uv) - .5;\n    \n    // Rotate\n    vec2 id = floor(uv);\n    float r = hash(int(id.x + 37.5 * id.y + 9.0 * float(frame)));\n    if (r < .5) gv.x *= -1.;\n    \n    // Curves\n    float sgn = sign(gv.x + gv.y);\n    sgn = sgn == 0. ? 1. : sgn;\n    float dist = abs(abs(gv.x + gv.y) - .5);\n    dist = length(gv - sgn * .5) - .5;\n    float width = 0.004 * scale;\n    return smoothstep(scale/res.y, -scale/res.y, abs(dist) - width);\n}\n\nvec2 normTruchet(in vec3 res, in int frame, in vec2 p)\n{\n    const float DELTA = 0.001;\n    return vec2(truchet(res, frame, p + vec2(DELTA, 0.0)) - truchet(res, frame, p - vec2(DELTA, 0.0)),\n                truchet(res, frame, p + vec2(0.0, DELTA)) - truchet(res, frame, p - vec2(0.0, DELTA)));\n}\n\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x + resolution.x / resolution.y);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    vec2 uv;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.0000);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.00005;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    fxParticle data = fxGetParticle(id);\n    vec4 state = texelFetch(iChannel2, ivec2(0), 0);\n    \n    if (dataType == POS_VEL)\n    {\n        if (iFrame == 0 || keyDown(32) || state.z > 0.0)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2(i / particlesPerRow, j / particlesPerRow) * 1.8 - 0.9) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.uv = vec2(data.pos.x * 0.5 + 0.5, data.pos.y * 0.5 + 0.5);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = (vec2(4.0, 2.0) * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.1 / sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n            \n            // downward force near tail to keep it from becoming empty, also creates firey heart\n            float ddist = length2(data.pos - vec2(0.0, -0.3));\n            if (ddist < 0.5)\n            {\n                force += 0.00000025 * vec2(0.0, -1.0) / sqrt(ddist);\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n            };\n            \n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            \n            vec2 pSpace = data.pos * 0.3;\n            float sdp = truchet(vec3(1.0, 1.0, 1.0), iFrame/100, pSpace);\n            if (sdp > 0.0)\n            {\n                force += normTruchet(vec3(1.0, 1.0, 1.0), iFrame/100, pSpace) * 0.1;\n            }\n                   \n\n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos / dist;\n                    \n                    \n                    // Apply crazy auto-stirring force\n                    data.vel += 0.0001 * vec2(deltaPos.y, -deltaPos.x) / dist;\n                    force += PARTICLE_REPEL * deltaPos * SPHgradKernel(dist / PARTICLE_REPEL_SIZE) / dist;\n                }\n            }       \n\n            \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            // Damping\n            data.vel -= data.vel * length2(data.vel) * 200.0;\n\n\n            // Clamping\n            float maxSpeed = 0.001 + smoothstep(0.0, 1.0, 1.-sdp) * 0.005; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Particle render\n\nconst float MAX_TEMP = 0.003;\n\nvec3 BlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / (1.5 * MAX_TEMP)), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (1.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = linePointDist2(p.pos, p.pos - 1.5 * p.vel, fragCoord, iResolution, closest);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    vec3 color = BlackBody(length(p.vel));\n    fragColor.xyz += color * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Temporal blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(iResolution.xy, 0.0, 0.0);\n            return;\n        }\n        \n        vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n        if (iResolution.xy != state.xy)\n        {\n            state = vec4(iResolution.xy, 1.0, 0.0);\n        }\n        else\n        {\n            state.z = 0.0;\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    if (iFrame == 0) fragColor = vec4(0);\n    \n    vec4 newColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 oldColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    fragColor = oldColor * 0.95 + newColor;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKcDR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[627, 627, 680, 680, 856]], "test": "untested"}
{"id": "wdsSD7", "name": "Colors uv test", "author": "starea", "description": "colors", "tags": ["colors"], "likes": 0, "viewed": 204, "published": 3, "date": "1661298185", "time_retrieved": "2024-07-30T16:34:39.310261", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(uv.xyy,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 133]], "test": "untested"}
{"id": "styyDR", "name": "Checker Shuffle Zoom (262 chs)", "author": "fenix", "description": "An infinite zoom animation of a rearranging checkerboard, with anti-aliasing. I did my best to golf the code, but I am hoping someone will join in to make it even smaller.", "tags": ["antialiasing", "checkerboard", "golf", "swirled"], "likes": 19, "viewed": 371, "published": 3, "date": "1661295362", "time_retrieved": "2024-07-30T16:34:40.345493", "image_code": "// From FabriceNeyret2 (262 chars)\n//*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy,a;\n    O*=0.;\n    for (float x,e, i = 0.; i < 9.; m.x*m.y < 0. ? O += .11 : O )\n        x = .004 * i++ - iTime,\n        e = fract(x+x), \n        a = abs( m = mod( 9.*(u-R/2.)/R.y * ++e, 2.) - 1. ) -.5,\n        fract(x) > .5 ? m = m.yx : m,\n        m *= sign(m.y),\n        a.y * a.x < 0. ? m.x -= sign(a.y)/e : e,\n        m = fract(m) - .5;\n}\n/**/\n\n// From Xor (266 chars)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy,a;\n    O=vec4(0);\n    for (float x,e, i = 0.; i < 9.; m.x*m.y < 0. ? O += .11 : O )\n        x = .004 * i++ - iTime,\n        e = fract(x+x), \n        a = abs( m = mod( 9.*(u-R/2.)/R.y * ++e, 2.) - 1. ) -.5,\n        fract(x) > .5 ? m = m.yx : m,\n        m *= sign(m.y),\n        a.y * a.x < 0. ? m.x -= sign(a.y)/e : e,\n        m = fract(m) - .5;\n}\n/**/\n\n// From FabriceNeyret2 (267 chars)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy,a;\n    O=vec4(0);\n    for (float x,e, i = 0.; i < 9.;  m.x*m.y < 0. ? O += .11 : O )\n        x = .004 * i++ - iTime,\n        e = fract(x+x), \n        a = abs( m = mod( 9.*(u-R/2.)/R.y * ++e, 2.) - 1. ) -.5,\n        fract(x) > .5 ? m = m.yx : m,\n        m.y > 0. ? m = -m : m,\n        a.y * a.x < 0. ? m.x += sign(a.y)/e : e,\n        m = fract(m) - .5;\n}\n/**/\n\n// From Xor (291 chars)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy;\n    u -= R * .5;\n    O = vec4(0);\n\n    for (float x, y, e, a, A = 9., s = A / R.y, i = 0.; i < A; O += vec4(m.x > .5 ^^ m.y > .5) / A)\n    \n        x = fract(.004 * i++ - iTime) * s * 2.,\n        y = mod(x, s),\n        e = s + y,\n        a = y / e,\n        m = mod(u * e, 2.),\n        x > s ? m = m.yx : m,\n        m.y > 1. ? m = 2. - m : m,\n        m.y > .5 ^^ abs(m.x - 1.) < .5 ? m.x -= m.y > .5 ? -a : a : a,\n        m = fract(m);\n}\n/**/\n\n// My initial golfing attempt (315 chars)\n\n/*\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec3 R = iResolution;\n    u -= R.xy * .5;\n    O = vec4(0);\n\n    for (float A = 9., s = A / R.y, i = 0.; i < A; ++i)\n    {\n        float x = fract(.004 * i - iTime) * (s + s),\n            y = mod(x, s),\n            e = s * (1. + y / s),\n            a = y / e;\n            \n        vec2 m = mod(u * e, 2.);\n        if (x > s) m = m.yx;\n        if (m.y > 1.) m = 2. - m;\n        if (m.y > .5) a = -a;\n        if (m.y > .5 ^^ abs(m.x - 1.) < .5) m.x -= a;\n        m = fract(m);\n        \n        O += vec4(m.x > .5 ^^ m.y > .5) / A;\n    }\n}\n/**/\n\n\n// Original: 492 chars\n\n/*\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    u -= iResolution.xy * 0.5;\n    float size = 10.0 / iResolution.y;\n    \n    float AA = 16.;\n    O = vec4(0);\n    for (float i = 0.; i < AA; ++i)\n    {\n        float factor = -(iTime - iTimeDelta * (i / AA)) * 2.0;\n        float mm = mod(factor * size, size * 2.);\n        float mm0 = mod(mm, size);\n        float scale = size * (1.0 + mm0 / size);\n        float animate = mm0 / scale;\n        vec2 m = mod(u * scale, 2.0);\n        if (mm > size) m = m.yx;\n        if (m.y > 1.0) m = 2.0 - m;\n        if (m.y < 0.5 && m.x > 0.5 && m.x < 1.5) m.x += animate;\n        if (m.y > 0.5 && (m.x > 1.5 || m.x < 0.5)) m.x -= animate;\n        m = mod(m, 1.0);\n        O += vec4(m.x > 0.5 ^^ m.y > 0.5) / float(AA);\n    }\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 77, 77, 450]], "test": "untested"}
{"id": "stKyzD", "name": "3d metaball third order motion", "author": "ufffd", "description": "metaballs, translucency, and stacked harmonic patterns", "tags": ["raymarch", "materials"], "likes": 11, "viewed": 392, "published": 3, "date": "1661286299", "time_retrieved": "2024-07-30T16:34:41.365764", "image_code": "// Fork of \"sphere material test\" by ufffd. https://shadertoy.com/view/sl2yWR\n// 2022-08-21 15:55:05\n\n// with wisdom from:\n// Nrx glass polyhedron - https://www.shadertoy.com/view/4slSzj\n// artofcode raymarch - https://www.shadertoy.com/view/WtGXDD\n// artofcode bending light - https://www.shadertoy.com/view/sllGDN\n\n#define PI 3.141592653589793\n#define MAX_STEP 100\n#define MAX_DIST 10000.\n#define SURF_DIST 0.001\n#define JIGGLE .1\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t60\n#define REFRACT_FACTOR\t\t.6\n#define REFRACT_INDEX\t\t1.15\n#define AMBIENT\t\t\t\t.95\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.7\n#define FADE_POWER\t\t\t1.\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat columnDist( vec3 p, vec3 c, vec3 r ) { \n    p.xy *= Rot(r.x);\n    // p.yz *= Rot(r.y);\n    // p.zx *= Rot(r.z);\n    return length(p.xz-c.xy)-c.z; \n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 texNormalMap(in vec2 uv, in sampler2D tx, in vec2 txr)\n{\n    vec2 s = 1.0/txr.xy;\n    \n    float p = texture(tx, uv).x;\n    float h1 = texture(tx, uv + s * vec2(1,0)).x;\n    float v1 = texture(tx, uv + s * vec2(0,1)).x;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nfloat sphereDist(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat boxDist(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat boxDist(vec3 p, float s) {\n    return boxDist(p,vec3(s));\n}\nfloat bevelboxDist(vec3 p, float s, vec3 rot) {\n  // p.yz *= Rot(rot.x);\n  // p.zx *= Rot(rot.y);\n  // p.xy *= Rot(rot.z);\n  vec3 q = abs(p) - s;\n  float d = min(max(q.x,max(q.y,q.z)),0.0);\n  d += length(max(q,0.0));\n  // d = max(d, q.x*2.+q.y+0.2);\n  d = max(d, q.x+q.y*2.+0.2);\n  d = max(d, q.y*2.+q.z+0.2);\n  // d = max(d, q.y+q.z*2.+0.2);\n  // d = max(d, q.z+q.x+0.1);\n  return d;\n}\n\nfloat chamferboxDist(vec3 p, vec3 s, float ch) {   \n    vec3 p1 = p - clamp(p, ch - s, s - ch);\n    p1 = abs(p1);\n    float d1 = (p1.x + p1.y + p1.z - ch) / 3.0;\n    vec3 point = p1 - d1;\n    vec3 d2 = min(point, 0.0);\n    point += (d2.x + d2.y + d2.z) * 0.5 - d2 * 1.5;\n    point = clamp(point, 0.0, ch); \n    float d3 = length(p - point) * sign(d1);\n    // return max(d3, 0.0);\n    \n    vec3 p2 = abs(p) - s;\n    float d4 = max(max(p2.x, p2.y), p2.z);\n    float d5 = (p2.x + p2.y + p2.z + 2.0 * ch) / sqrt(3.0);\n    float d6 = (max(max(p2.x + p2.y, p2.x + p2.z), p2.y + p2.z) + ch) / sqrt(2.0);\n    return max(d3, 0.0) + min(max(max(d4, d5), d6), 0.0);\n}\n\nvec2 map(vec3 p) {\n    float mater = -1.;\n    float d = 1000.;   \n    \n    vec3 jiggle_p = JIGGLE*vec3(\n        noise(vec2(iTime*.7,1.)),\n        noise(vec2(iTime*.8,2.)),\n        noise(vec2(iTime*.9,3.))\n    );\n    \n    vec3 s_p = vec3(0.);\n    float sphere = 0.;\n    \n    for (int i=1;i<20;i++) {\n        float fi = float(i) * 0.3;\n        float ft = iTime*10. - fi;\n        // sphere 1\n        s_p = vec3(\n            cos(ft) + cos(ft*0.1),\n            sin(ft) + sin(ft * 0.5),\n            cos(ft * 0.5) + sin(ft*0.1)\n        ) * sin(iTime*0.1);\n        sphere = sphereDist(p - s_p + jiggle_p, 1.-fi*0.2);\n        // if (sphere < 0.125) mater = 2.;\n        d = smin(d, sphere, 0.5);\n    }\n    \n    if (d < 0.001) mater = 2.; // apply material to all smoothed objects thus far\n    \n    return vec2(d, mater);\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 mapr = map(p);\n    vec2 e = vec2(.001, 0);\n    \n\tfloat d = mapr.x;\n    vec3 n = vec3(0.);\n    \n    int method = 1;\n    // method 1\n    if (method==1) { \n        n = d - vec3(\n            map(p-e.xyy).x,\n            map(p-e.yxy).x,\n            map(p-e.yyx).x);\n    }\n    // method 2\n    if (method==2) {\n        n = vec3(\n            map(p+e.xyy).x - map(p-e.xyy).x,\n            map(p+e.yxy).x - map(p-e.yxy).x,\n            map(p+e.yyx).x - map(p-e.yyx).x);\n    }\n    \n    return normalize(n);\n}\n\nvec3 getLightPos(in int i) {\n    if (i==1){\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n        return lightPos;\n    }\n}\n\nfloat getLight(vec3 p, vec3 n, in vec3 rd) {\n    vec3 lp = getLightPos(1);\n    vec3 l = normalize(lp-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = map(p+n*SURF_DIST*2.).x;\n    if(d<length(lp-p)) dif *= .1;\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 50.);\n    \n    return dif + spec;\n}\n\nvec3 getCol(vec3 p, float mater, in vec3 rd, in vec3 norm) {\n    vec3 col = vec3(0.);\n    if (mater < 0.) {\n        return vec3(0.0);\n    } else if (mater < 0.5) {\n        col = norm;\n        col *= norm;\n    } else if (mater < 1.5) {\n        col = vec3(sin(norm.r*100.));\n        col *= norm;\n    } else if (mater < 2.5) {\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        vec3 text = texture(iChannel0, txuv).rrr;\n        col = mix(col,text*0.5,1.-col.r);\n    } else if (mater < 3.5) {\n        col = norm;\n        col = vec3(sin(norm.b*100.));\n    } else if (mater < 4.5) {\n        col = p * mat3(vec2(0.5), 0.1, vec2(0.2), 0.9, vec2(0.4), 1.);\n        // col = vec3(sin(norm.g*100.));\n    } else {\n        col = vec3(0.9,0.85,0.8) * 0.1;\n    }\n    return col;\n}\nvec3 k = vec3(0.);\n\nbool doesBounce(in float mater) {\n    if (mater > 1.5 && mater < 2.5) return true; // 2\n    if (mater > 4.5 && mater < 5.5) return true; // 5\n    return false;\n}\n\nvec3 materNorm(in float mater, in vec3 norm) {\n    vec3 mN;\n    if (mater > 1.5 && mater < 2.5) {\n        // todo - improve texturing https://www.youtube.com/watch?v=VaYyPTw0V84\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        mN = texNormalMap(txuv, iChannel0, iChannelResolution[0].xy).xyx;\n    }\n    return mN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec3 p, ro, rd, col;\n    ro = vec3(0.5,0.3,-3.); \n    ro.xz *= Rot(iTime*0.3);\n    ro -= JIGGLE*sin(vec3(iTime*1.,iTime*0.22,iTime*0.91));    \n    rd = normalize(vec3(uv.x-.15, uv.y-.2, 1.0));\n    rd.xz *= Rot(iTime*0.3);\n    rd.yz *= Rot(sin(iTime)*0.05);\n    rd.xy *= Rot(sin(iTime*1.1)*0.05);\n    rd.zx *= Rot(sin(iTime*0.9)*0.05);\n    vec3 ord = rd;\n       \n    \n    float d = 0.;\n    bool hit = false;\n    bool hit_matte = false;\n    float glow = 0.;\n    float mater = -1.;\n\tvec2 delta = vec2 (DELTA, 0.0);\n    \n    float intensity = 0.;\n\n    // vec3 backColor = vec3(0.,0.01,0.02) * (1.-length(uv + vec2(0.,0.3)));\n    // vec3 backColor = vec3(54./255., 57./255., 63./255.);\n    vec3 backColor = vec3(0.1);\n    col = vec3(0.);\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n        d = 0.; // reset ray dist\n        float ds = 0.; // distance step\n        for(int i=0;i<MAX_STEP;i++){\n            p = ro + rd * d; // update current point\n            vec2 mapr = map(p);\n            ds = mapr.x; // map distance\n            ds *= distanceFactor; // flip sdf when inside\n            mater = mapr.y; // material index\n            d += max(ds, DELTA); // update march distance\n            if(ds<0.) { hit=true; break; } // check hit\n            if(d>MAX_DIST) break; // check limit\n            glow += 1./ds; // add glow\n        }\n        if (!hit) {col = backColor; break;}\n        vec3 norm = distanceFactor*getNorm(p);\n        // material color\n        col += getCol(p,mater,rd,norm) * AMBIENT;\n        // matte lighting\n        float light = getLight(p, norm, rd);\n        if (rayIndex==0) {\n            col += mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        // check for bounces\n        bool do_bounce = doesBounce(mater);\n        if (!do_bounce) {\n            // hit matte, done bouncing\n            break;\n        } else {\n            // col *= 0.1;\n            // apply normal to material 2 - note: make this a conditional if more reflective/refractive materials are added\n            norm += materNorm(mater, norm);\n            \n            vec3 reflection = reflect(rd, norm);            \n            // reflection light (i think it should be in getLight fxn so I can call it with multiple lights)\n            if (distanceFactor > 0.) { // only calculate light on outside\n                vec3 lp = getLightPos(1);\n                vec3 lightDirection = normalize(lp-p);\n                float reflectDiff = max (0.0, dot (norm, lightDirection));\n                float reflectSpec = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + reflectDiff) * localColor + reflectSpec;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n            }\n\n            // Next ray...\n            ro = p;\n            vec3 refraction = refract(rd, norm, refractionRatio);\n            if (dot (refraction, refraction) < DELTA) { // reflect at grazing angles, idk how the dot math works here\n                // fragColor = vec4(1.,1.,0.,1.); return;\n                rd = reflection; // update ray dir to reflected angle\n                ro += rd * DELTA * 2.0; // step away from surface\n            } else {\n                rd = refraction; // update ray dir to refracted angle\n                // ro += rd * DELTA * 2.0; // step away from surface - not needed?\n                refractionRatio = 1.0 / refractionRatio; // reverse refraction ratio \n                distanceFactor = -distanceFactor; // flip sdf sign while inside\n            }\n        }\n        \n        // todo: chromatic aberation, optical density, bevel, fresnel reflection\n        // https://www.youtube.com/watch?v=0RWaR7zApEo\n    }\n    \n    \n    \n    // col += glow*glow*glow*0.00000000000000001 * nsin(iTime*.5);\n\n    // Output to screen\n    // col = pow(col, vec3(.45));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 736, 736, 829], [831, 831, 851, 851, 874], [876, 876, 896, 896, 963], [965, 965, 1002, 1002, 1035], [1037, 1037, 1059, 1059, 1125], [1127, 1127, 1171, 1171, 1281], [1283, 1283, 1303, 1303, 1512], [1514, 1514, 1575, 1575, 1779], [1781, 1781, 1816, 1816, 1844], [1846, 1846, 1877, 1877, 1964], [1965, 1965, 1997, 1997, 2030], [2031, 2031, 2078, 2153, 2417], [2419, 2419, 2467, 2467, 3075], [3077, 3077, 3095, 3095, 3889], [3891, 3891, 3913, 3913, 4417], [4419, 4419, 4447, 4447, 4590], [4592, 4592, 4636, 4636, 4947], [4949, 4949, 5009, 5009, 5732], [5753, 5753, 5786, 5786, 5914], [5916, 5916, 5962, 5962, 6251], [6253, 6253, 6310, 6310, 10745]], "test": "untested"}
{"id": "flVcDz", "name": "Center Focus/Blur", "author": "turboplay", "description": "I 've seen it in some shows.", "tags": ["blur", "focus"], "likes": 5, "viewed": 252, "published": 3, "date": "1661285324", "time_retrieved": "2024-07-30T16:34:42.178591", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float Pi = 6.28318530718; // Pi*2\n\n    // GAUSSIAN BLUR SETTINGS\n    float Directions = 16.; // BLUR DIRECTIONS (Default 16.0 - More is better but slower), 8,64,32\n    float Quality = 32.; // BLUR QUALITY (Default 4.0 - More is better but slower) 4,64,32\n    float Size = 16.; // BLUR SIZE (Radius) 0-128\n\n    vec2 Radius = Size / iResolution.xy;\n    vec4 Color = texture(iChannel0,uv);\n    if (uv.x > 0.7f || uv.x < 0.3f)\n    {\n        // Zoom\n        float zoom = 2.;\n        float offset_x = 0.25;\n        float offset_y = 0.25;\n        vec2 xy = uv;\n        xy = vec2(offset_x + xy.x / zoom, offset_y + xy.y / zoom);\n        // Blur calculations\n        for (float d = 0.0; d < Pi; d += Pi / Directions)\n        {\n            for (float i = 1.0 / Quality; i <= 1.0; i += 1.0 / Quality)\n            {\n                Color += texture(iChannel0,xy + vec2(cos(d), sin(d)) * Radius * i);\n            }\n        }\n        Color /= Quality * Directions - 15.0;\n    }\n    fragColor = Color;\n}\n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1141]], "test": "untested"}
{"id": "NtVcWz", "name": "Machinery Build", "author": "dr2", "description": "Minimalist assembly instructions for \"Controllable Machinery\"", "tags": ["book", "album", "machine", "instructions"], "likes": 19, "viewed": 288, "published": 3, "date": "1661276382", "time_retrieved": "2024-07-30T16:34:43.117082", "image_code": "// \"Machinery Build\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Minimalist assembly instructions for \"Controllable Machinery\" (mouseable,\n  but no control capability)\n\n  No. 8 in \"Album\" series\n    \"Distance Field Guide\"       (WdcGWf)\n    \"Engine Album\"               (WsyGRK)\n    \"Chateaux..\"                 (Wtd3Df)\n    \"Live Assembly Instructions\" (WlcSD2)\n    \"Nautilus: The Book\"         (3lVSWw)\n    \"Book of Chopped Surfaces\"   (tdlcD7)\n    \"Sand Album\"                 (3slBRf)\n*/\n\n#define AA    0 // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\n\nvec4 wgObj;\nvec3 ltDirEx, ltDir, vnBlk, qHit, pgSize;\nvec2 qBlk;\nfloat dstFar, tCur, msAz, msEl, dstFarEx, tpBook, phsTurn, idPage, tMov, angRot, bEdge,\n   tCyc, cnPos, hitBlk;\nint idObj, cState;\nconst int nPage = 10;\nbool isBw;\nconst int idGr = 1, idPln = 2, idConv = 3, idSup = 4, idAx = 5, idBas = 6,\n   idWhl = 7, idSpl = 8, idCon = 9, idBlk = 10;\nconst float pi = 3.1415927;\nconst float nBlk = 13.;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GearWlDf (vec3 p, float rad, float wlThk, float tWid, float nt, float aRot, \n   bool bev, float dMin)\n{\n  vec3 q;\n  float d, s;\n  q = p;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    q.xy = Rot2D (q.xy, aRot);\n    q.xy = Rot2D (q.xy, floor (nt * atan (q.y, - q.x) / (2. * pi) + 0.5) * 2. * pi / nt);\n    if (bev) q.xy *= 1.2 - 0.2 * q.z / wlThk;\n    s = q.x - 2. * clamp (1.5 * tWid + 0.5 * q.x * step (0., q.x) - abs (q.y), 0., tWid);\n    d = max (d, - rad - 0.95 * s);\n  }\n  return min (dMin, d);\n}\n\nvec4 BPos (float t)\n{\n  vec3 p;\n  float a;\n  t = mod (t, tCyc);\n  if (t < 5.) {\n    a = 0.;\n    p = vec3 (-1.018 + 2.118 * t / 5., bEdge, 0.);\n  } else if (t < 10.) {\n    a = 0.5 * pi * (t - 5.) / 5.;\n    p = vec3 (1.1, bEdge + 1. * sin (a), 1. - 1. * cos (a));\n  } else if ( t < 15.) {\n    a = 0.5 * pi;\n    p = vec3 (1.1 - 2.118 * (t - 10.) / 5., 1. + bEdge, 1.);\n  } else if (t < 17.5) {\n    a = 0.5 * pi;\n    p = vec3 (-1.018, 1. + bEdge, 1. - 1. * (t - 15.) / 2.5);\n  } else {\n    t -= 17.5;\n    a = -0.5 * pi * t;\n    p = vec3 (-1.018, 1. + bEdge - t * t, 0.);\n  }\n  return vec4 (p, a);\n}\n\nfloat GearDf (vec3 p)\n{\n  vec3 q;\n  float dMin, wlThk, tWid, nt, rad, gRat;\n  dMin = dstFar / 0.3;\n  gRat = 2.;\n  rad = 0.43;\n  wlThk = rad / 15.;\n  tWid = rad / 16.;\n  nt = 32.;\n  q = p - vec3 (0.1, 0., 1.);\n  dMin = GearWlDf ((q - vec3 (0., bEdge, 0.)).yzx, rad, wlThk, tWid, nt,\n     - angRot - 0.3 * pi / nt, false, dMin);\n  dMin = GearWlDf (- (q - vec3 (0., -0.21, 0.555)).zyx, rad / gRat, wlThk, tWid,\n     nt / gRat, - angRot * gRat, false, dMin);\n  rad = 0.3;\n  wlThk = rad / 7.;\n  tWid = rad / 10.;\n  nt = 20.;\n  q = p - vec3 (-1.05, -0.21, 1.3);\n  dMin = GearWlDf (- q, rad, wlThk, tWid, nt, angRot * gRat, true, dMin);\n  dMin = GearWlDf ((q - vec3 (0.85 * rad, 0., 0.85 * rad)).yzx,\n     rad, wlThk, tWid, nt, angRot * gRat + pi / nt, true, dMin);\n  rad = 0.32;\n  wlThk = rad / 15.;\n  tWid = rad / 12.;\n  nt = 24.;\n  q = p - vec3 (-1.05, -0.21, 0.6);\n  dMin = GearWlDf ((q - vec3 (0., 0., 0.1)), rad, wlThk, tWid, nt,\n     angRot * gRat + pi / nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, 0.1)), rad / gRat, wlThk, tWid, nt / gRat,\n     - angRot * gRat * gRat, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, -0.1)), rad, wlThk, tWid, nt,\n     - angRot * gRat * gRat - pi / nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., 0., -0.1)), rad / gRat, wlThk, tWid, nt / gRat,\n     angRot * gRat * gRat * gRat, false, dMin);\n  return dMin * 0.3;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 a4;\n  vec3 q, bPos;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  if (cState >= 1) {\n    q = p - vec3 (0., -1.2, 0.9);\n    d = PrRoundBoxDf (q, vec3 (1.7, 0.03, 1.5), 0.02);\n    DMIN (idBas);\n    q = p - wgObj.xyz;\n    d = PrRoundCylDf (q.xzy, wgObj.w, 0.02, 0.02);\n    DMIN (idCon);\n  }\n  if (cState >= 2) {\n    q = p - vec3 (0.65, -0.14, 1.);\n    q.x = abs (q.x) - 0.3;\n    d = PrRoundBoxDf (q, vec3 (0.01, 1.08, 0.06), 0.02);\n    q = p - vec3 (-0.05, -0.68, 0.);\n    q.xz = abs (q.xz) - vec2 (1., 0.2);\n    d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n    q = p - vec3 (-1.05, -0.14, 1.);\n    d = min (d, PrRoundBoxDf (q, vec3 (0.04, 1.08, 0.01), 0.02));\n    q = p - vec3 (-1.05, -0.68, 0.6);\n    q.z = abs (q.z) - 0.2;\n    d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n    q = p - vec3 (-0.33, -0.68, 1.555);\n    q.x = abs (q.x) - 0.3;\n    d = min (d, PrRoundBoxDf (q, vec3 (0.01, 0.55, 0.04), 0.02));\n    DMIN (idSup);\n    d = min (PrBoxDf (p - vec3 (0., 0.98, 1.), vec3 (1.12, 0.02, 0.1)),\n       PrBoxDf (p - vec3 (-1.018, 0.98, 0.5), vec3 (0.1, 0.02, 0.5 - bEdge)));\n    DMIN (idPln);\n  }\n  if (cState >= 3) {\n    q = p - vec3 (0.65, bEdge, 1.);\n    d = PrCylDf (q.yzx, 0.04, 0.62);\n    q = p - vec3 (-0.36, -0.21, 1.555);\n    d = min (d, PrCylDf (q.yzx, 0.03, 0.51));\n    q = p - vec3 (-0.05, -0.21, 0.);\n    q.x -= 1.;\n    d = min (d, PrCylDf (q, 0.03, 0.27));\n    q.xz -= vec2 (-2., 0.14);\n    d = min (d, PrCylDf (q, 0.03, 0.4));\n    q.z -= 0.87;\n    d = min (d, PrCylDf (q, 0.03, 0.36));\n    q = p - vec3 (-1.05, -0.68, 0.6);\n    d = min (d, PrCylDf (q, 0.03, 0.25));\n    DMIN (idAx);\n  }\n  if (cState >= 4) {\n    q = p - vec3 (1.13 + bEdge, bEdge, 1.);\n    r = length (q.yz);\n    q.yz = Rot2D (q.yz, - angRot);\n    a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n    q.yz = Rot2D (q.yz, 2. * pi * (floor (8. * a + 0.5)) / 8.);\n    q.z = abs (q.z);\n    d = SmoothMax (min (min (abs (r - 1.01) - 0.1, r - 0.3),\n       max (r - 1., dot (q.yz, vec2 (sin (0.8 * 2. * pi / 32.),\n       cos (0.8 * 2. * pi / 32.))))), abs (q.x) - 0.02, 0.01);\n    DMIN (idWhl);\n  }\n  if (cState >= 6) {\n    q = p - vec3 (-0.05, -0.21, 0.);\n    q.x = abs (q.x) - 1.;\n    d = PrRoundCylDf (q, 0.18, 0.01, 0.11);\n    DMIN (idSpl);\n    d = SmoothMax (abs (PrCaps2Df ((p - vec3 (-0.05, -0.21, 0.)).yx, 0.2, 1.)) - 0.01,\n      abs (p.z) - 0.1, 0.02);\n    DMIN (idConv);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GearRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 250; j ++) {\n    d = GearDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 GearNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GearDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 GearNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GearDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * GearDf (p)) / (e.x * e.x));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec4 a4;\n  vec3 rm, rdm, u, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k / nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      hitBlk = k;\n      vnBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      u = (v + dn) * rdm;\n      qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n      vnBlk.zy = Rot2D (vnBlk.zy, - a4.w);\n    }\n  }\n  return dMin;\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 a4;\n  vec3 rm, rdm, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k / nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) dMin = dn;\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GearSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = GearDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 vn, col, q;\n  float dstObj, dstGear, dstBlk, sh, s, r, a;\n  int idObjT;\n  bool isNu;\n  isBw = (cState <= 8);\n  tCyc = 18.5;\n  bEdge = 0.08;\n  angRot = 0.1 * pi * tMov;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstGear = (cState >= 5) ? GearRay (ro, rd) : dstFar;\n  if (dstGear < min (dstObj, dstFar)) {\n    dstObj = dstGear;\n    idObj = idGr;\n  } else idObj = idObjT;\n  dstBlk = (cState >= 7) ? BlkHit (ro, rd) : dstFar;\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      dstObj = dstBlk;\n      ro += dstObj * rd;\n      idObj = idBlk;\n      vn = vnBlk;\n      col4 = vec4 (HsvToRgb (vec3 (hitBlk / nBlk, 1., 1.)), 0.2) *\n         (1. - 0.4 * step (0.8 * bEdge, Maxv2 (abs (qBlk))));\n    } else {\n      ro += dstObj * rd;\n      if (isBw) {\n        vn4 = (idObj == idGr) ? GearNfL (ro) : ObjNfL (ro);\n        vn = vn4.xyz;\n      } else {\n        vn = (idObj == idGr) ? GearNf (ro) : ObjNf (ro);\n      }\n      if (idObj == idWhl) {\n        col4 = vec4 (0.9, 0.7, 0.3, 0.2);\n        q = ro - vec3 (1.1 + bEdge + 0.03, bEdge, 1.);\n        r = length (q.yz);\n        q.yz = Rot2D (q.yz, - angRot);\n        a = fract (64. * atan (q.z, - q.y) / (2. * pi) + 0.5);\n        if (r > 0.99) vn.yz = Rot2D (vn.yz, - sin (a - 0.5));\n        if (r > 0.92) col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, a);\n      } else if (idObj == idGr) {\n        col4 = vec4 (0.9, 0.8, 0.4, 0.2);\n      } else if (idObj == idSpl) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2) * (1. - 0.4 * step (abs (ro.z), 0.1));\n      } else if (idObj == idAx) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n      } else if (idObj == idPln) {\n        col4 = (abs (vn.y) > 0.99) ? vec4 (0.5, 0.6, 0.2, 0.05) : vec4 (0.7, 0.5, 0.4, 0.1);\n      } else if (idObj == idConv) {\n        q = ro - vec3 (-0.05, -0.21, 0.);\n        col4 = vec4 (0.8, 0.8, 0.4, 0.);\n        if (sign (vn.y) != sign (q.y)) {\n          if (abs (q.x) < 1. && abs (vn.y) > 0.5) col4 *= 1. - 0.1 * SmoothBump (0.45, 0.55, 0.03,\n           fract (10. * (q.x - sign (q.y) * mod (tMov, 20.) * 2.1 / 5.)));\n        } else col4 *= 0.8 + 0.2 * smoothstep (0., 0.01, abs (abs (q.z) - 0.07));\n      } else if (idObj == idSup) {\n        col4 = vec4 (0.7, 0.5, 0.4, 0.1);\n      } else if (idObj == idBas) {\n        q = ro;\n        q.z -= 0.9;\n        if (Maxv2 (abs (q.xz) - vec2 (1.65, 1.45)) > 0.) {\n          col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n        } else {\n          col4 = vec4 (0.3, 0.5, 0.4, 0.);\n        }\n        col4 *= (0.5 + 0.5 * step (0., Maxv2 (abs (vec2 (q.x, q.z + 1.3)) - vec2 (0.4, 0.02)))) *\n           (0.7 + 0.3 * step (0., abs (PrCaps2Df (vec2 (q.z + 1.3, q.x), 0.08, 0.5)) - 0.01));\n      } else if (idObj == idCon) {\n        col4 = vec4 (0., 1., 1., 0.2);\n        if (length (ro.xz - wgObj.xz) < 0.6 * wgObj.w) col4 *= 0.8;\n      }\n    }\n    if (isBw) {\n      isNu = false;\n      if (cState == 1) isNu = (idObj == idBas || idObj == idCon);\n      else if (cState == 2) isNu = (idObj == idSup || idObj == idPln);\n      else if (cState == 3) isNu = (idObj == idAx);\n      else if (cState == 4) isNu = (idObj == idWhl);\n      else if (cState == 5) isNu = (idObj == idGr);\n      else if (cState == 6) isNu = (idObj == idConv || idObj == idSpl);\n      else if (cState == 7) isNu = (idObj == idBlk);\n      col = vec3 (1., 0.98, 0.96) * pow (Maxv3 (col4.rgb), 0.8);\n      if (isNu) col.gb *= 0.3;\n      col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n         (0.4 + 0.6 * max (dot (vn, ltDir), 0.));\n    } else {\n      q = ro + 0.01 * ltDir;\n      sh = min (ObjSShadow (q, ltDir), GearSShadow (q, ltDir));\n      sh = 0.6 + 0.4 * min (sh, BlkHitSh (q, ltDir, 6.));\n      col = col4.rgb * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) +\n         0.9 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    }\n  } else col = isBw ? vec3 (0.8) : vec3 (0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac, spd;\n  cState = int (idPage);\n  az = 0.17 * pi;\n  el = -0.1 * pi;\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  spd = 1.;\n  tMov = (cState >= 8) ? spd * tCur : 0.;\n  cnPos = 0.5;\n  wgObj = vec4 (cnPos - 0.5, -1.12, -0.4, 0.08);\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -0.3, -12.);\n  ro.z += 0.9;\n  zmFac = 5.;\n  dstFar = 30.;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  ltDir = vuMat * normalize (vec3 (-0.4, 0.6, -1.));\n  fCol = ShowScene (ro, rd);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 3.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExZeroPg (vec2 w)\n{\n  vec3 col;\n  float d;\n  col = vec3 (1.);\n  if (fract (tCur) < 0.9) {\n    w -= vec2 (1.05, -0.7);\n    d = min (length (max (abs (w) - vec2 (0.1, 0.002), 0.)),\n       length (max (abs (Rot2D (vec2 (w.x - 0.1, abs (w.y)), 0.2 * pi)) - vec2 (0.1, 0.002), 0.)));\n    col = mix (vec3 (0.3, 0.9, 0.3), col, smoothstep (0., 0.01, length (d)));\n  }\n  return col;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (2.7, 0.011, 1.9);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (fract (t / (tpCyc + tpWait)) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage));\n      c = vec3 (0.85, 0.85, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz));\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          if (idPage > 0.) {\n            isImg = true;\n            ExMain (col, w);\n          } else {\n            col4 = vec4 (ExZeroPg (w), 0.2);\n          }\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.95, 0.95, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = max (1.3 * tCur - 0.3, 0.);\n  az = 0.;\n  el = -0.5 * pi;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.y) > 0.42) {\n      tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n    } else if (abs (mPtr.x - 0.04) > 0.42) {\n      el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n    } else if (abs (mPtr.x - 0.04) < 0.33 && abs (mPtr.y) < 0.42) {\n      msAz = pi * clamp (3. * (mPtr.x - 0.04), -1., 1.);\n      msEl = pi * mPtr.y;\n    }\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (2.7, 0., -20.);\n  zmFac = 9.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n  ro = vuMat * ro;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVcWz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1742, 1742, 1851, 1851, 2276], [2278, 2278, 2299, 2299, 2872], [2874, 2874, 2897, 2897, 4250], [4252, 4252, 4274, 4274, 6688], [6690, 6690, 6723, 6723, 6907], [6909, 6909, 6943, 6943, 7128], [7130, 7130, 7152, 7152, 7410], [7412, 7412, 7433, 7433, 7690], [7692, 7692, 7715, 7715, 8048], [8050, 8050, 8072, 8072, 8403], [8405, 8405, 8438, 8438, 9132], [9134, 9134, 9180, 9180, 9664], [9666, 9666, 9703, 9703, 9920], [9922, 9922, 9960, 9960, 10178], [10180, 10180, 10215, 10215, 14168], [14170, 14170, 14216, 14216, 14811], [14813, 14813, 14837, 14837, 15719], [15721, 15721, 15756, 15756, 15937], [15939, 15939, 15962, 15962, 16219], [16221, 16221, 16260, 16260, 16491], [16493, 16493, 16517, 16517, 16874], [18545, 18545, 18601, 18601, 19932], [19934, 19934, 19966, 19966, 20066], [20068, 20068, 20114, 20114, 20161], [20163, 20163, 20205, 20205, 20256], [20258, 20258, 20315, 20315, 20391], [20393, 20393, 20437, 20437, 20497], [20499, 20499, 20545, 20545, 20602], [20604, 20604, 20626, 20626, 20664], [20666, 20666, 20688, 20688, 20726], [20728, 20728, 20750, 20750, 20777], [20779, 20779, 20824, 20824, 20916], [20918, 20918, 20963, 20963, 21001], [21003, 21003, 21060, 21060, 21143], [21145, 21145, 21181, 21181, 21387], [21389, 21389, 21419, 21419, 21532], [21534, 21534, 21558, 21558, 21680], [21714, 21714, 21738, 21738, 21850], [21852, 21852, 21877, 21877, 22063], [22065, 22065, 22086, 22086, 22241]], "test": "untested"}
{"id": "7dyfRc", "name": "Icosahedral Spiral Weave ", "author": "Shane", "description": "Attaching a double layered three pronged star weave to the triangle cells of a subdivided icosahedron.", "tags": ["raymarching", "math", "star", "icosahedron", "spherical", "polyhedron", "weave"], "likes": 78, "viewed": 983, "published": 3, "date": "1661264940", "time_retrieved": "2024-07-30T16:34:44.059562", "image_code": "/*\n\n    Icosahedral Spiral Weave\n    ------------------------    \n    \n    See Buffer A for an explanation.\n    \n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    \n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Animated Icosahedral Weave\n    --------------------------\n    \n    This is a common polyhedral weave that you may have seen around. I'm not \n    sure what it's officially called, but it's some kind of double layered\n    three pronged star weave. They're normally precalculated using multiple \n    steps involving Beziers, etc, inside 3D applications like Blender, then \n    loaded into realtime applications after construction, but I thought it'd\n    be fun attempting to produce one in realtime on Shadertoy.\n    \n    I'm stating the obvious here, but pixel shader restrictions coupled with\n    realtime constraints meant that it was a bit difficult to produce the\n    equivalent of an elegantly lit static path traced image, or prerecorded\n    video. However, I employed a few cheap realtime tricks to at least convey \n    that feel.\n    \n    It would have been nice to make it better, faster, stronger, and all that, \n    but I ran out of time. There are definitely faster ways to render this \n    scene, but I figured I'd post it in its current form then try for something \n    nicer later. If I produced this with Bezier curves, it'd be a more \n    geometrically interesting looking object, but would also be way more \n    expensive.\n    \n    I put more effort into the background and color scheme than the icosahedral \n    sphere construction itself, which involved obtaining the nearest \n    icosahedral triangle face information, then using that to render two set of \n    three pronged arcs emminating from the center to offset midpoints.    \n    \n    For those of you experiencing ridiculous compile times, you have my apologies,\n    but it really is beyond my control. All I can say is, I miss the days when\n    everyone looked forward to compiler updates. :)\n\n\t\n    Other examples:\n    \n  \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n    \n    // The flat plane version.\n    Triangle Grid Spiral Weave - Shane\n    https://www.shadertoy.com/view/7syfWz\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3./2.);\n    p.yz *= rot2(iTime/6./3.); \n    \n    return p;\n    \n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smin(vec2 a, vec2 b, float k){\n\n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smax(vec2 a, vec2 b, float k){\n    \n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n \n// IQ's box routine.\nfloat sBox(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n/*\n// hash based 3d value noise\nvec4 hash41T(vec4 p){\n    \n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Two layers of noise.\nfloat fBm(vec3 p){ return n3DT(p)*.57 + n3DT(p*2.)*.28 + n3DT(p*4.)*.15; }\n*/ \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n \n     \n    return q;\n}\n\n\n\n\n/////////\n// Nimitz's simple basis function. I'll take people's word for it that it\n// fails at the negative one Z point, so I've attempted to put in a hacky fix.\nmat3 basis(in vec3 n){\n    \n    float a = min(1./(1. + n.z), 1e6);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n}\n\n// Readjusting the points to the surface of the sphere in question. The function here\n// is the same as the one below, but that's not always the case.\nvec3 size(in vec3 p, in float rad){\n\n    //return p;\n    return normalize(p)*rad;\n}\n\nvec3 sSize(in vec3 p, in float rad){\n    \n    return normalize(p)*rad;\n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    \n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n            \n    // Icosahedron vertices and vertex IDs for the current cell.\n    vec3[3] v, vertID;\n\n    // Obtaining the local cell coordinates and spherical coordinates\n    // for the icosahedron cell.\n    const float rad = .5;\n    vec3 lq = getIcosTri(q, vertID, rad);\n\n    vec3 vAng = vertID[0];//(vertID[0] + vertID[1] + vertID[2])/3.;\n\n    v[0] = sphericalToWorld(vertID[0]);//vec3(0, rad, 0);\n    v[1] = sphericalToWorld(vertID[1]);\n    v[2] = sphericalToWorld(vertID[2]);\n\n\n     // The cell center, which doubles as a cell ID,\n    // due to its uniqueness, which can be used for \n    // randomness, etc.\n    //vec3 id = (v[0] + v[1] + v[2])/3.;\n    vec3 tCntr = sSize(v[0] + v[1] + v[2], rad);\n\n\n     // Icosahedral cell boundary.\n    mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n    vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n    // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n    // \"abs\" above away.\n    float line = min(min(ep.x, ep.y), ep.z);   \n\n\n    float mOffs = .5/((sin(iTime/2.)*.5 + .5)*16.75 + 1.25); // Edge mid point offset. Smaller means wider.\n    //float mOffs = .5/1.5;\n\n    // Edge mid points, edge tangents and exit and entry points.\n    vec3[3] mid, midA, midB;\n\n    // Resizing the mid points.\n    mid[0] = sSize(mix(v[0], v[1], .5), rad);\n    mid[1] = sSize(mix(v[1], v[2], .5), rad);\n    mid[2] = sSize(mix(v[2], v[0], .5), rad);\n\n\n\n    // Dividing the cell triangles into three regions.\n    vec3 quadSect;\n\n    for(int i = 0; i<3; i++){\n\n        int ip2 = (i + 2)%3;\n        // Sectioning off the triangle into three seperate quads.\n        float edg = dot((lq/rad), cross(tCntr, mid[i])/length(tCntr - mid[i]));\n        float edg2 = dot((lq/rad), cross(mid[ip2], tCntr)/length(mid[ip2] - tCntr));\n        quadSect[i] = min(edg, edg2); // Boundary for this region.\n\n    }\n\n    ////////////\n    ////////////\n    // Orthonormal basis calcultion.\n\n    mat3 mB = basis(normalize(tCntr));\n    vec3 qq = lq -  tCntr;\n    vec3 blq = mB*qq;\n\n    // Sizing the vertex points.\n    v[0] = size(mB*v[0], rad);\n    v[1] = size(mB*v[1], rad);\n    v[2] = size(mB*v[2], rad);\n\n\n    // The triangle cell center with sizing.\n    tCntr = sSize(v[0] + v[1] + v[2], rad);\n\n    \n    // Midpoints, and midpoint offsets.\n    for(int i = 0; i<3; i++){\n\n        int ip1 = (i + 1)%3;\n        int ip2 = (i + 2)%3;\n\n        // Edge midpoints.\n        mid[i] = size(mix(v[i], v[ip1], .5), rad);\n\n        // Edge entry points -- One on each side of the mid point.                \n        midA[i] = size(mix(v[i], v[ip1], .5 - mOffs), rad);\n        midB[i] = size(mix(v[i], v[ip1], .5 + mOffs), rad);\n\n    } \n\n\n    // Rendering the curves between entry and exit points. There are six\n    // alltogether.\n    float object = 1e5, bord = 1e5;\n\n    // Normalizing Z values. It's a bit hacky and needs improvement, but it'll do. \n    float minDist = length(tCntr.xy - mid[0].xy); // Center to shortest side.\n    float lnN = line/minDist;\n    float lnN2 = max(1. - length(blq.xy - tCntr.xy)/minDist*.8660254, 0.);\n    float lnNew = mix(lnN, lnN2, smoothstep(.1, .9, lnN));\n \n    float rA = length(midA[0].xy - tCntr.xy);\n    float rB = rA; //length(midB[0].xy - tCntr.xy); // Same distance.\n\n    float zOffs = .2; \n    \n    // Three pronged spirals. Unfortunately, animating the curves meant that I've had to \n    // render all three on the top and bottom, which is obviously slower. There are certain \n    // configurations that allow for repeat space tricks which are much faster, and I'll\n    // demonstrate that at some stage.\n    for(int i = 0; i<3; i++){\n\n            // The next index.\n            int ip1 = (i + 1)%3;\n           \n\n            // Top spiral prongs and borders.\n            float obj = length(blq.xy - midB[i].xy) - rA; // rA\n            vec2 oVec = vec2(obj, length(lq) - rad + lnNew*zOffs*rad);\n\n            // There are some subtleties that I sometimes forget about. When partitioning\n            // off an ofject, it should effectively be zero along the dimensions in which\n            // you're doing it. Otherwise, there will be inconsistancies across boundaries.\n            obj = sBox(oVec, vec2(.03*(1. + lnN*lnN), .025), .01) + .025;\n\n            float tObj = sBox(oVec, vec2(.03*(1. + lnN*lnN) + .02, .025 - .015), .005) + .025;\n            tObj = max(tObj, -quadSect[i]);\n            obj = max(obj, -quadSect[i]);\n\n            //if(obj<ln[0]) minI = i;\n            object = min(object, obj);\n            bord = min(bord, tObj);\n\n\n            // Top spiral and border.\n            obj = length(blq.xy - midA[i].xy) - rB; //rB\n            oVec = vec2(obj, length(lq) - rad - lnNew*zOffs*rad);\n            obj = sBox(oVec, vec2(.03*(1. + lnN*lnN), .025), .01) + .025;\n\n            tObj = sBox(oVec, vec2(.03*(1. + lnN*lnN) + .02, .025 - .015), .005) + .025;\n            tObj = max(tObj, -quadSect[ip1]);\n\n\n            //obj = max(obj, -(svObj - .02));\n            obj = max(obj, -quadSect[ip1]);\n            object = min(object, obj);\n            bord = min(bord, tObj);\n\n\n\n\n    }\n        \n    // Giving the spiral prongs and borders some thickness.\n    object -= .025;\n    bord -= .025;\n\n\n    // The top and bottom vertices.\n    /*\n    vec2 ve2;\n    vec2 oVec = vec2(length(blq.xy), blq.z - (zOffs*rad - .0075));\n    ve2.x = sBox(oVec, vec2(.025, .045), .015);\n    oVec.y = blq.z + (zOffs*rad - .0075);\n    ve2.y = sBox(oVec, vec2(.025, .045), .015);\n    // Vertices and border. They're using the same material, so it\n    // makes sense to group them together.\n    float vert = min(min(ve2.x, ve2.y), bord);\n    */\n    \n    // The top and bottom vertices -- Equivalent to above.\n    vec2 oVec = vec2(length(blq.xy), abs(blq.z) - (zOffs*rad - .0075));\n    float vert = sBox(oVec, vec2(.025, .045), .015);\n    //\n    // Vertices and border. They're using the same material, so it\n    // makes sense to group them together.\n    vert = min(vert, bord);\n    \n\n    //////////////////\n    // The background wall and wavy background.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(48. - 3.))) - 48.);\n    // Flat plane back wall.\n    float wall = -p.z + 3.;\n    \n    // Perturbation.\n    p.xy += sin(p.xy*4.)*.1;\n    float px = p.x;\n    p.xy = rot2(-3.14159/4.)*p.xy;\n\n    // Subtle wall ridges to reflect the light in a more interesting way.\n    const float s = 1./2.;\n    float f = abs(fract(p.x/s) - .5)*2.;\n    wall -= f*.05 - .05;\n\n\n    // The repeate extruded wavy lines.\n    vec2 q2 = p.xy;\n    float ix = floor(q2.x/s) + .5;\n    q2.x -= ix*s;\n    q2 = vec2(q2.x, p.z - 3.);\n    //float tube = length(q2) - .05 - cos(px*4.)*.02; // Round tubes.\n    float tube = sBox(q2, vec2(.05 + cos(px*4.)*.0125, .1), .025); // Rounded square tubes.\n\n\n    ////////////////////////////////    \n\n    // Overall object ID -- There in one rundundant slot there.\n    vID = vec4(tube, wall, vert, object);\n\n    // Shortest distance.\n    return  min(min(tube, wall), min(vert, object));\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Frame blend value for the sphere.\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1 + .0, .25, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t     \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        vec3 rCol = spRef*refTx*1.; //smoothstep(.03, 1., spRef)  \n        \n        // Texturing position and normal.\n        vec3 txP = sp, txN = sn;\n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The wavy background lines.\n            txP/= 2.;\n            txP.xy *= rot2(-3.14159/4.);\n             \n            texCol = vec3(.7, .3, .1);\n            texCol += rCol;\n            \n            // Metallic trick.\n            diff = pow(diff, 4.)*2.;\n           \n        }\n        else if(objID==1){ \n        \n           \n            //  The background itself.\n            txP /= 1.;\n            txP.xy = mix(txP.xy*1.5, txP.xy + sin(txP.xy*4. - vec2(0, iTime*0.))*.1, .35);\n            txP.xy *= rot2(-3.14159/4.);\n         \n             // Color and reflection.\n            texCol = vec3(.65);    \n            texCol += rCol*.25; \n\n        }\n        else if(objID==2){ \n        \n            // The icosahedral border trim and vertices.\n        \n            // Texture position and normal.\n            txP -= sphPos;\n\n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n\n\n\n            // Color and reflection.\n            texCol = vec3(.7, .3, .1); \n            texCol += rCol;\n\n            // Cheap metallic trick.\n            diff = pow(diff, 4.)*2.;\n\n        }\n        else { \n        \n            // Icosahedral color.\n        \n            // Texture position and normal.\n            txP = sp - sphPos;\n             \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n             // Color and reflection.\n            \n            texCol = vec3(.85, .75, .57); // Pearl.\n            //texCol = vec3(.4, .15, .8); diff = pow(diff, 4.)*2.; // Purple.\n            //texCol = vec3(.5); diff = pow(diff, 4.)*2.; // Silver.\n            //texCol = vec3(.07); diff = pow(diff, 4.)*2.; // Graphite.\n            texCol += rCol;\n            \n            \n        }\n        \n\n        vec3 tx; \n        if(objID==1){ \n            // Background wood grain.\n            tx = tex3D(iChannel3, txP + .5, txN);\n            texCol *= tx*2. + .06;\n           \n        }\n        else { \n            // Metal and powder coat enamel.\n            tx = tex3D(iChannel2, txP + .5, txN);\n            texCol *= tx*2. + .3;\n        }\n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        //texCol = mix(texCol, vec3(dot(texCol, vec3(.299, .587, .114))), .1);\n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh*2.);\n \n\n\n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 172, 248, 480]], "test": "untested"}
{"id": "flVcWR", "name": "bisection method w/ Box Interpol", "author": "alaula", "description": "I tried speeding up raymarching by mixing it with raytracing.\nIt doesn't seem to work too well", "tags": ["sdf", "bisection", "falseposition"], "likes": 1, "viewed": 176, "published": 3, "date": "1661263660", "time_retrieved": "2024-07-30T16:34:44.840474", "image_code": "#define FOVTAN 2.0\n#define CAMDIST 5.0\n#define DELTA 0.0001\n\nstruct ray {\n    vec3 rd;\n    vec3 ro;\n};\n\nstruct hit {\n    float tn;\n    float tf;\n};\n\nconst vec3 pos = vec3(1.0, 1.0, 1.0);\nconst float size = 1.0;\nconst float inflate = 1.0;\nconst vec3 boxDim = vec3(4.0,4.0,4.0);\nconst vec3 color = vec3(0.1, 0.4, 0.2);\n\nconst vec3 signs = vec3(1.0, -1.0, 0.0);\n\nray getRay(in vec2 fragCoord) {\n    vec2 circle = vec2(cos(iTime),sin(iTime));\n    float pxSize = FOVTAN/iResolution.x;\n    vec2 offset = pxSize*(fragCoord - iResolution.xy/2.0);\n    return ray(normalize(vec3(circle,offset.y) + offset.x*vec3(circle.y,-circle.x,0.0)),CAMDIST*vec3(-circle, 0.0));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    vec3 o = p - m/3.;\n    vec3 k = min(o, 0.0);\n    o = o + (k.x + k.y + k.z) * 0.5 - k * 1.5;\n    o = clamp(o, 0.0, s);\n    return length(p - o) * sign(m) - inflate;\n}\n\nhit BoxIntersect(in ray line){\n    vec3 uh = -1.0/line.rd;\n    vec3 m = uh*(line.ro);\n    vec3 n = abs(uh*boxDim);\n    uh = m - n;\n    m = m + n;\n    return hit(max(max(uh.x,uh.y),uh.z),min(min(m.x,m.y),m.z));\n}\n\nhit SphereIntersect(in ray line){\n    float rDist = dot(line.rd,-line.ro);\n    float rad = size + inflate;\n    vec3 off = rDist*line.rd + line.ro;\n    float offSqr = dot(off,off);\n    if (offSqr > rad*rad) return hit(1.0, -1.0);\n    float n = abs(sqrt(rad*rad - offSqr));\n    return hit(rDist - n, rDist + n);\n}\n\nvec3 getNorm(in vec3 p){\n    float val = sdOctahedron(p ,size);\n    return normalize(vec3(val - sdOctahedron(p + DELTA*signs.xzz, size),\n                          val - sdOctahedron(p + DELTA*signs.zxz, size),\n                          val - sdOctahedron(p + DELTA*signs.zzx, size)));\n}\n\nfloat falsePos(in vec2 vals, in vec2 dist){\n    return (vals.y*dist.x - vals.x*dist.y)/(vals.y - vals.x);\n}\n\n#define AVG(X) mix(X.x,X.y,0.5)\nfloat trace(in ray line){\n    line.ro = line.ro - pos;\n    hit box = BoxIntersect(line);\n    if (box.tn > box.tf) return -1.0;\n    //return 5.0;\n    float avg = (box.tn + box.tf)/2.0;\n    float val = sdOctahedron(avg*line.rd + line.ro, size);\n    avg = val > 0.0 ? dot(line.rd, -line.ro) : avg;\n    val = sdOctahedron(avg*line.rd + line.ro, size);\n    if(val > 0.0) return -1.0;\n    vec2 vals = vec2(sdOctahedron(line.ro + line.rd*box.tn,size),val);\n    vec2 dist = vec2(box.tn,avg);\n    //bisection\n    avg = AVG(dist);\n    val = sdOctahedron(avg*line.rd + line.ro, size);\n    float less = float(val < 0.0);\n    dist = vec2(dist.x*less +avg*abs(less -1.0),avg*less+ dist.y*abs(less -1.0));\n    vals = vec2(vals.x*less +val*abs(less -1.0),val*less+ vals.y*abs(less -1.0));\n    //bisection\n    avg = AVG(dist);\n    val = sdOctahedron(avg*line.rd + line.ro, size);\n    less = float(val < 0.0);\n    dist = vec2(dist.x*less +avg*abs(less -1.0),avg*less+ dist.y*abs(less -1.0));\n    vals = vec2(vals.x*less +val*abs(less -1.0),val*less+ vals.y*abs(less -1.0));\n    //falsePos\n    avg = falsePos(vals,dist);\n    val = sdOctahedron(avg*line.rd + line.ro, size);\n    less = float(val < 0.0);\n    dist = vec2(dist.x*less +avg*abs(less -1.0),avg*less+ dist.y*abs(less -1.0));\n    vals = vec2(vals.x*less +val*abs(less -1.0),val*less+ vals.y*abs(less -1.0));\n    //bisection\n    avg = AVG(dist);\n    val = sdOctahedron(avg*line.rd + line.ro, size);\n    less = float(val < 0.0);\n    dist = vec2(dist.x*less +avg*abs(less -1.0),avg*less+ dist.y*abs(less -1.0));\n    vals = vec2(vals.x*less +val*abs(less -1.0),val*less+ vals.y*abs(less -1.0));\n    //falsePos\n    avg = falsePos(vals,dist);\n    val = sdOctahedron(avg*line.rd + line.ro, size);\n    less = float(val < 0.0);\n    dist = vec2(dist.x*less +avg*abs(less -1.0),avg*less+ dist.y*abs(less -1.0));\n    vals = vec2(vals.x*less +val*abs(less -1.0),val*less+ vals.y*abs(less -1.0));\n    \n    return AVG(dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ray line = getRay(fragCoord);\n    vec3 col = vec3(0.3,0.3,0.3);\n    \n    float rayDist = trace(line);\n    \n    if(rayDist > 0.0){\n        col = color*(1.0 + dot(line.rd,getNorm(line.ro + line.rd*rayDist - pos))/4.0);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 391, 391, 657], [659, 659, 696, 696, 941], [943, 943, 973, 973, 1154], [1156, 1156, 1189, 1189, 1467], [1469, 1469, 1493, 1493, 1755], [1757, 1757, 1800, 1800, 1864], [1898, 1898, 1923, 1923, 3849], [3851, 3851, 3908, 3908, 4192]], "test": "untested"}
{"id": "7tycWR", "name": "Variable 16-segment display", "author": "cmzw", "description": "16-segments display with variable segment length, gap, and diagonals angle. Based on [url]https://www.shadertoy.com/view/NlSSRy[/url]\n\nOriginally made for Material Maker", "tags": ["2d", "segments", "16seg", "sixteensegment"], "likes": 3, "viewed": 248, "published": 3, "date": "1661238977", "time_retrieved": "2024-07-30T16:34:45.702171", "image_code": "float m(vec4 d) { return max(max(d.x,d.y),max(d.z,d.w)); }\n\nfloat fs(vec2 p, float st, float sl, vec4 s14, float s5, bool sf, float da)\n{\n\tconst vec2 h = vec2(1,-1);\n\tda *= 0.017453;\n\t\n\tsl *= .1;\n\tst *= .5;\n\tsl = clamp(sl, .0,1.);\n\n\tp = 2. * (p - .5);\n\tvec2 p1 = p;\n\tvec2 p2 = p;\n\tvec2 _p = p;\n\t\n\tp = abs(p) - vec2(0.25,0.4);\n\t\n\tfloat f = -max(p.x, p.y);\n\tfloat ism = f - st - (sl*1.625);\n\tfloat isg = min(ism, st-abs(dot(normalize(vec2(sin(da),cos(da))),_p*vec2(sf ? 1.0:-1.0 ,1.0))));\n\t\n\tfloat d = min(st - abs(f), min(-dot(p, normalize(h.xx)), abs(dot(p, normalize(h)))) - sl);\n\n\tp1.x = abs(p1.x); p2.y = abs(p2.y);\n\tp1 += vec2(0.15, 0.0); p2 -= vec2(0.0, 0.15);\n\n\tfloat q1 = -dot(p1,h.xx);\n\tfloat q2 = min(p2.x, -dot(p2,h.yx));\n\tfloat q3 = dot(p1, h.yx);\n\tfloat q4 = min(-p2.x, -dot(p2,h.xx));\n\t\n\tvec4 qv4 = vec4(q1,q2,q3,q4);\n\tqv4 = min(qv4,s14);\n\t\n\treturn max(m(min(vec4(d),qv4)), min(isg,s5));\n}\n\nfloat xvisd(vec2 uv, float st, float sl, float bevel, float da)\n{\n\tfloat d;\n\tconst vec2 b = vec2(1,0);\n\t\n\tst *= .5;\n\n\tfloat d1 = fs(uv+vec2(.125, -.2), st, sl, vec4(1), 1. ,true, da );\n\tfloat d2 = fs(uv-vec2(.125,  .2), st, sl, vec4(1), 1. ,false, da);\n\tfloat d3 = fs(uv+vec2(.125,  .2), st, sl, vec4(1), 1. ,false, da);\n\tfloat d4 = fs(uv-vec2(.125, -.2), st, sl, vec4(1), 1., true, da);\n\t\n\td = m(vec4(d1,d2,d3,d4));\n\n\treturn clamp(d/max(bevel, 1e-4), .0, 1.);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 p = .5*(2.*I - iResolution.xy) / iResolution.y;\n\n    float t = (cos(iTime)+1.)*.5;\n    float seg_gap = t*.8;     // segments gap\n    float seg_len = t*.4+.08; // segments length\n    float diag_an = 60.;      // diagonals angle\n    \n    O = vec4(xvisd(p+.5,seg_len,seg_gap,.01,diag_an));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tycWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 58], [60, 60, 137, 137, 902], [904, 904, 969, 969, 1366], [1369, 1369, 1410, 1410, 1708]], "test": "untested"}
{"id": "flGcWz", "name": "Better Function SDF", "author": "Spi3lot", "description": "Better Function SDF than https://www.shadertoy.com/view/7lSyDV\nUsing derivatives instead of iteration, I don't know how I didn't think of this first.", "tags": ["sdf", "derivative", "function"], "likes": 6, "viewed": 262, "published": 3, "date": "1661212171", "time_retrieved": "2024-07-30T16:34:46.460144", "image_code": "const float thickness = 0.1;  // 0.1\n\n\nfloat f(float x)\n{\n    return sin(x * 2.0) + sin(1.1 * (x + 3.14159 * 0.5));\n}\n\nfloat dfdx(float x)\n{\n    return 1000.0 * (f(x + 0.001) - f(x));\n}\n\nfloat sdf(vec2 co)\n{\n    float y = f(co.x);\n    float yPrime = dfdx(co.x);\n    return abs(y - co.y) - max(abs(yPrime), 1.0) * thickness;\n    //return abs(y - co.y) - (abs(yPrime) + 1.0) * thickness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= vec2(iTime, 3.0);\n    \n    float v = sdf(uv);\n    float c = smoothstep(1.5, 0.0, v / fwidth(v));\n    fragColor = vec4(c);\n\n    // Squishing and tearing only happens because only uv.x is multiplied by iTime\n    //fragColor = vec4(sdf(uv));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 57, 57, 117], [119, 119, 140, 140, 185], [187, 187, 207, 207, 387], [390, 390, 447, 447, 784]], "test": "untested"}
{"id": "7lKczw", "name": "+Something gaz 248", "author": "nabr", "description": "3d", "tags": ["3d", "sound"], "likes": 11, "viewed": 337, "published": 3, "date": "1661193108", "time_retrieved": "2024-07-30T16:34:47.241056", "image_code": "// Fork of \"Something gaz 248\" by gaz. https://shadertoy.com/view/7lcyWj\n// 2022-08-22 17:25:02\n\n#define N(x) fract(sin((x)*333.333))\n#define H(t) (cos((vec3(0,2,-2)/3.+t)*6.24)*.5+.5)\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define minkowski(v,m) pow(dot(pow(v, v*0.+m), v*0.+1.), 1./m)//glslsandbox by sphinx\n#define char(p,C)(((p.x<0.||p.x>1.||p.y<0.||p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,p/16.+fract(vec2(C,15-C/16)/16.),dFdx(p/16.),dFdy(p/16.)))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution;vec2 u =(C-.5*r.xy)/r.y;\n    vec3 d=normalize(vec3(u,1)); \n    float i=0.,n,g=0.,t=mod(iTime, 16.);\n    for(int i=0;i<2;i++) t+=2.*N(floor(t/.8));\n    for(;i++<48.;O+=.5/exp(i*i*n)/(12.+log2(N(i/length(p.zxy))))+\n    (1.-t/8.) * char(28.*vec2(u.x+.89, u.y*.9+.02), int[](32,108,101,116,32,112,101,111,112,108,101,32,107,110,111,119,32,105,116,39,115,32,97,32,83,79,85,78,68,32,68,69,77,79,110,115,116,114,97,116,105,111,110,32,97,108,115,111,46)[int(i)]).x,u.x-=.02)\n    p=d*g-i/1e5,\n    p -=mod(t,2.)<1.?R(vec3(2,3,6),normalize(H(t*.1)).xyx,t):vec3(0, .3*N(t), exp(3.*fract(t))),\n    g+=n=minkowski(abs(mod(p, vec3(3))-1.5),(1.+mod(t, 5.)))-max(.2, .5*sin(t));\n   \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define f fract\n#define s sin\n#define it(x) int(x*t)\n#define p(x) s(x*f(x))\n#define pw(x,y) pow(1.-f(x*t), y)\n#define z 8.*t\nvec2 mainSound(int samp, float t )\n{\n    return .251*vec2(\n    //synth\n    p( (2.5+f(19.*t)) * p(vec4(4,8,12,it(1.)%4>3?1:4)[it(8.)%4]\n        * t*100.*vec4(4,3,2.5,5)[it(2.)%4]+f(-650.*t)))\n        * exp(-float(it(1.)%6<5?3:1)*f(mod(t,8.)>6.?-.5*t:z)\n      )\n    //kick\n    + p(10.*pw(8.,2.))*pw(2.,4.)\n    //hihat\n    + p((40.+f(z))*t*400.)*exp(-15.*f(z)));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tKyRw", "name": "test_uvmap", "author": "starea", "description": "testuv", "tags": ["test"], "likes": 0, "viewed": 163, "published": 3, "date": "1661184660", "time_retrieved": "2024-07-30T16:34:48.044906", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(uv.xyy,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 208]], "test": "untested"}
{"id": "ssGBRK", "name": "Extruded Triangle Grid Truchet", "author": "Shane", "description": "An extruded triangle grid Truchet variation.", "tags": ["raymarching", "grid", "triangle", "truchet", "extrude"], "likes": 58, "viewed": 606, "published": 3, "date": "1661176822", "time_retrieved": "2024-07-30T16:34:49.152945", "image_code": "/*\n\n    Extruded Triangle Grid Truchet\n    ------------------------------\n    \n    I've been making a few technical shaders lately, so wanted to take a \n    break and code something simple.\n    \n    This is an extruded 2D simplex Truchet variation comprising three basic \n    tile configurations. It's not a common pattern, but some may have seen \n    it before. The 2D field is not difficult to construct: Simply render a \n    mixture of arcs or circles between triangle cell midpoints, then extrude \n    the result. Raymarching objects like this in a front-on fashion doesn't \n    present any challenges either.\n \n    I used an old extruded pattern template, then updated the colors and \n    lighting a bit. This was not a difficult shader to make. I was originally \n    going to give it a metallic look, but I might save that for one of the \n    more interesting variations I'm working on.\n\n\n    References:\n\n    // A two tiled variation using the same extrusion template.\n\tExtruded Octagon Diamond Truchet - Shane\n    https://www.shadertoy.com/view/3tGBWV\n\n    // BigWIngs's popular Youtube channel. It's always informative seeing how \n    // others approach various graphics topics.\n    Shader Coding: Truchet Tiling Explained! -  The Art of Code\n\thttps://www.youtube.com/watch?v=2R7h76GoIJM\n    \n    // A bump-mapped 2D compliment version of this pattern, or something to \n    // that effect.\n    slimy triangular truchet - mattz\n    https://www.shadertoy.com/view/lsffzX\n\n\n*/\n\n\n// Maximum ray distance.\n#define FAR 10.\n\n// Subtle textured lines.\n#define LINES\n\n// Double arcs.\n//#define DOUBLE_ARC\n\n// Curve shape - Round: 0, Straight: 1.\n#define SHAPE 0\n\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n\n// Distance metrics.\nfloat dist(vec2 p){\n\n    // Circular or hexagonal bounds.\n    #if SHAPE == 0\n    return length(p);\n    #else \n    // Not a proper distance field, but it'll get the job done.\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x);\n    #endif\n\n}\n\n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n*/\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nfloat scale = 1./1.5;\n\nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(1./.8660254, 1))*scale;\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    // Vertex IDs for the quad.\n    vec2[3] vID; \n  \n    // Vertex IDs for each partitioned triangle.\n    if(gTri<0.){\n        vID = vec2[3](vec2(-.5, .5), vec2(.5, -.5), vec2(.5));\n    }\n    else {\n        vID = vec2[3](vec2(.5, -.5), vec2(-.5, .5), vec2(-.5));\n    }\n    \n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect, sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n    // Specific centered triangle ID.\n    ctr = vID[2]/3.; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.;\n    id += ctr;\n    // Not used here, but for jigsaw pattern creation, etc, the vertex IDs\n    // need to be correctly centered too.\n    //vID[0] -= ctr; vID[1] -= ctr; vID[2] -= ctr; \n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// A standard square grid 2D blobby Truchet routine: Render circles\n// in opposite corners of a tile, reverse the pattern on alternate\n// checker tiles, and randomly rotate.\nvec3 tr(vec2 p){\n\n    \n        // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices.\n    vec2[3] v;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec4 p4 = getTriVerts(p, v);\n    p = p4.xy;\n    vec2 triID = p4.zw;// + (vID[0] + vID[1] + vID[2])/3.;\n    \n    \n    \n    // Grid triangles. Some are upside down.\n    vec2 q = p*vec2(1, gTri); // Equivalent to the line above.\n    float tr = max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n\n     \n    // Nearest vertex ID.\n    float vert = 1e5;\n    vec3 midD;\n    float sL = length(v[0] - v[1]);\n    \n    // Random value based on the overall triangle ID.\n    float rnd = hash21(triID + .11);\n    float rnd2 = hash21(triID + .22);    \n   \n    // Random rotation, in incrents of 120 degrees to maintain symmetry.\n    p = rot2(floor(rnd*36.)*6.2831/3.)*p;\n\n    // Nearest vertex, vertex-arc and angle (subtended from each vertex) calculations.\n    vec2 vertID;\n    for(int i = 0; i<3; i++){\n        \n        //vertD[i] = length(p - v[i]);\n        vert = min(vert, dist(p - v[i]));\n        \n        vec2 vM = mix(v[i], v[(i + 1)%3], .5);\n        midD[i] = dist(p - vM);\n \n    }\n    \n    float pTh = sL/6.; // Arc thickness.\n    // Turning the circle distance into an arc.\n    float arc = abs(dist(p - v[0]) - sL/2.) - pTh;\n\n    // Edge midpoint vertices.\n    float mid = min(min(midD.x, midD.y), midD.z);\n    \n    float tile;\n    \n    // Triangle Truchet tiles.\n    if(rnd2<.4){\n    \n        // Tri-pronged tile.\n        //tile = min(min(arc.x, arc.y), arc.z);\n        tile = -(vert - (sL/2. - pTh));\n    }\n    else if(rnd2<.7){\n    \n        // Arc and circle tile.\n        tile = min(arc, midD.y - pTh);\n    }\n    else {\n         \n         // Midpoint circle tiles.\n         tile = mid - pTh;\n    }\n    \n    #ifdef DOUBLE_ARC\n    tile = abs(tile + pTh/2.25) - pTh/1.2; // Doubling the arcs.\n    #endif\n    \n     \n    return vec3(tile, mid, tr);\n\n\n}\n \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    \n    \n    // 2D Truchet distance -- for the extrusion cross section.\n    vec3 tr3 = tr(p.xy);\n    float obj = tr3.x;\n    \n    // Back plane with a slight triangle cell bevel.\n    float fl = -p.z - min(-tr3.z*4., .2)*.05;\n    //fl -= min(-tr3.z*2., .25)*.15;\n    //fl -= smoothstep(0., .07, -tr3.z)*.03;//smoothstep(.08, .15, obj)*.1;\n    //fl += tr3.z*.3;\n    \n    // Extrude the 2D Truchet object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    obj = max(obj, abs(p.z) - .125) - smoothstep(.05, .11, -obj)*.04;\n    // Proper extrusion formula for comparisson.\n    //obj = opExtrusion(obj, p.z, .125, .01) - smoothstep(.03, .25, -obj)*.1; \n    \n   \n    // Object ID.\n    objID = fl<obj? 0 : 1 ;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash21(r.xy*57. + fract(iTime + r.z))*.5;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(d, .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.25, .25, 2);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n \n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    \n    \n    \n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec2[3] v;\n    //scale /= 3.;\n    vec4 p4 = getTriVerts(p.xy, v);\n    vec2 triID = p4.zw;// + (vID[0] + vID[1] + vID[2])/3.;\n    float svGTri = gTri;\n    // Grid triangles. Some are upside down.\n    vec2 q = p4.xy*vec2(1, gTri); \n    float tri = max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n    q = (p4.xy - normalize(p.xy/(p.z - 3.) - l.xy/(l.z - 3.))*.005)*vec2(1, gTri); \n    float tri2 = max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n    float b = max(tri2 - tri, 0.)/.005;\n\n    \n    // 2D Truchet face distace -- Used to render borders, etc.\n    //scale *= 3.;\n    vec3 tr3 = tr(p.xy);\n    float d = tr3.x;\n    p4 = getTriVerts(p.xy, v);\n    q = p4.xy*vec2(1, gTri); \n    float triB = tr3.z; //max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n    \n    // Smooth borders.\n    float bord = abs(triB) - .003; \n    \n    \n    \n    // Subtle pattern lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5) - .125)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5) - .125)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif     \n     \n\n    vec4 col1 = vec4(1, .15, .4, 0);\n    vec4 col2 = vec4(.4, .7, 1, 0);\n \n    /*\n    // Extra color. Interesting, but it makes things look creepily anatomical. :)\n    vec2 fID = floor(triID + .5);\n    if(mod(fID.x, 2.)<.5) col1 *= vec4(1, 2.35, 1.5, 0);\n    if(mod(fID.y, 2.)<.5) col1 *= vec4(2, 1.5, 1, 0);\n    if(mod(fID.x, 2.)<.5) col2 *= vec4(1, 1.15, .9, 0).zxyw;\n    if(mod(fID.y, 2.)<.5) col2 *= vec4(1.15, 1, .9, 0).zxyw; \n    */\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The blue floor:\n       col2 = mix(col2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);  \n       // Blue with some subtle lines.\n       oCol = col2;//mix(col2, vec4(1), .25);//mix(col2/1.2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);\n       // Triangle borders: Omit the middle of edges where the Truchet passes through.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n       //oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, abs(bord - .06) - .005))*.8);\n       //oCol = mix(oCol, col2/1.15, (1. - smoothstep(0., .01, tri + .07)));\n\n       // Darken alternate triangles. \n       if(gTri<.0) oCol *= .8;\n        \n       // Using the Truchet pattern for some bottom edging.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, d - .015))*.8);\n       \n      \n    }\n    else {\n    \n        // Extruded Truchet:\n \n        // White sides with a dark edge. \n        oCol = mix(vec4(.9), vec4(0), 1. - smoothstep(0., .01, d + .05));\n        //df = mix(pow(df, 4.), df, 1. - smoothstep(0., .01, d + .05));\n     \n        \n        // Golden faces with some subtle lines.\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        \n        // Darken alternate checkers on the face only.\n        if(svGTri>0.) fCol *= .8;\n        \n        // Triangle borders: Omit the middle of edges where the Truchet passes through.\n        bord = abs(tri) - .003;\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        \n        \n        // Apply the colored face to the Truchet, but leave enough room\n        // for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .08));\n\n        \n    }\n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n   \n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel0, ref); refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    float rf = (gObjID == 0)? .1 : 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .08));\n    oCol += spRef*refTx*rf; //smoothstep(.03, 1., spRef) \n\n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n    \n     \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1742, 1775, 1797, 1797, 1855], [1857, 1885, 1906, 1906, 1969], [1973, 1994, 2013, 2051, 2241], [2728, 2791, 2819, 2819, 2849], [2851, 2916, 2946, 2946, 2985], [7333, 7506, 7522, 7600, 8384], [8386, 8407, 8443, 8492, 8964], [8966, 9157, 9209, 9300, 10436], [10439, 10591, 10626, 10626, 11021], [11025, 11116, 11136, 11467, 11737]], "test": "untested"}
{"id": "7stGR2", "name": "Aurora Borealis Test", "author": "Khael", "description": "Aurora", "tags": ["test"], "likes": 5, "viewed": 265, "published": 3, "date": "1661175542", "time_retrieved": "2024-07-30T16:34:50.116368", "image_code": "// Fonction de cercle qui nécessite 3 inputs, l'uv, le radius et la valeur du blur.\nfloat Circle(vec2 uv, vec2 p, float r, float blur) {\n\n    // Distance de l'UV ( au dessus de 1 la distance est clampé\n    float d = length(uv-p);\n    \n    //smoothstep r est le min, r-0.01 est le max, et d est la valeur de la source donc le cercle\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n\n}\n\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1 * band2;\n}\n    \n\nfloat Smiley(vec2 uv, vec2 p, float size){\n    \n    uv -= p; // translating coordinate system\n    uv /= size; //scaling coordinate system\n    float mask = Circle(uv, vec2(0.), .4, .01);\n\n    mask -= Circle(uv, vec2(-.12, .15), .07, .01);\n    mask -= Circle(uv, vec2(.12, .15), .07, .01);\n    \n    float mouth = Circle(uv, vec2(0.), .3, .01);\n    mouth -= Circle(uv, vec2(0., 0.1), .3, .01);\n    \n    mask -= mouth;\n    \n    return mask;\n}\n    //Lerp function\nfloat remap01(float a, float b, float t){\n    return (t-a) / (b-a); // Si t =a alors 0/0 = 0\n    //Si t = b alors 1/1=1\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a,b,t) * (d-c) + c;\n}\n\nvec3 yToRgb(float y)\n{    \n    float r, g, b;\n    \n    // functions where created based on the default linear equation\n    // f(x) = mx + b, where m is the slope and b the intersection point\n    // with the x axis f(0) = b ;)\n    // you can view the graph of the functions here: \n    // https://iquilezles.org/apps/graphtoy/?f3(x)=1-abs(x*2-1)&f4(x)=clamp(1-x*2,%200,%201)&f6(x)=clamp((x-0.5)*2,%200,%201)\n    \n    b = clamp(1.0-y*2.0, 0.0, 1.0);\n    g = 1.0-abs(y*2.0-1.0);\n    r = clamp((y-0.5)*2.0, 0.0, 1.0);\n    \n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    \n    // Uv from -0.5 to 0.5\n    uv -= 0.5; \n    \n    // Calculate the x aspect ratio of the screen\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //float mask = Smiley(uv, vec2(0.), 1.);\n    float mask =.0;\n\n    //vec3 col = vec3(mouth);\n    float x = uv.x;\n    \n    float m = sin(t+x*8.)*.1;\n    float y = uv.y-m;\n    \n    \n    float blur = remap(-1., .5, .05, .25, x);\n    blur = pow(blur*4., 2.);\n    mask = Rect(vec2(x,y), -1., 1., -.1, .1, blur);\n    \n    vec3 rgb = vec3(yToRgb(-uv.x)); \n    vec3 col = pow( rgb, vec3(1./2.2)) * mask;\n    vec3 colormask = vec3(remap01(-0.3, 0.9, -uv.x));\n           \n    // Output to screen\n    fragColor = vec4(col ,1.0);\n    //fragColor = vec4( pow( rgb, vec3(1./2.2)) * colormask , 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 137, 203, 395], [397, 397, 453, 453, 594], [596, 596, 678, 678, 809], [816, 816, 858, 858, 1254], [1259, 1275, 1316, 1316, 1396], [1398, 1398, 1455, 1455, 1496], [1498, 1498, 1520, 1520, 2043], [2045, 2045, 2102, 2152, 2956]], "test": "untested"}
{"id": "ftVcRw", "name": "Bezier Runes", "author": "cmzw", "description": "Based on runes from [url]https://www.shadertoy.com/view/MsXSRn[/url] but replacing line segments with beziers", "tags": ["bezier", "runes"], "likes": 12, "viewed": 459, "published": 3, "date": "1661162881", "time_retrieved": "2024-07-30T16:34:50.867360", "image_code": "/* \n   References\n   https://www.shadertoy.com/view/MsXSRn runes\n   https://www.shadertoy.com/view/4djSRW hash22\n   https://www.shadertoy.com/view/MlKcDD Quadratic Bezier\n*/\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    return sqrt( res );\n}\n\n\nfloat ThickLine(vec2 uv, vec2 posA, vec2 posB, vec2 posC)\n{\n\treturn smoothstep(.04,.01,sdBezier(uv, posA, posB, posC));\n}\n\nfloat Rune(vec2 uv, int strokes, float scale, vec2 snaps) {\n\tfloat finalLine = 0.0;\n\tvec2 seed = floor(uv)-hash22(vec2(1));\n\tuv = fract(uv);\n\tfor (int i = 0; i < strokes; i++)\t\n\t{\n\t\tvec2 posA = hash22(floor(seed+1.5));\n\t\tvec2 posB = hash22(floor(seed+2.0));\n\t\tvec2 posC = hash22(floor(seed+3.5));\n\t\tseed += 3.0;\n\t\tposA = fract(posA * 128.0);\n\t\tposB = fract(posB * 128.0);\n        posC = fract(posC * 128.0);\n\t\tif (i == 0) posA.y = 0.0;\n\t\tif (i == 1) posA.x = 0.999;\n\t\tif (i == 2) posA.x = 0.0;\n\t\tif (i == 3) posA.y = 0.999;\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps;\n\t\t//posB = (floor(posB * snaps) + 0.5) / snaps;\n        posC = (floor(posC * snaps) + 0.5) / snaps;\n\t\tfinalLine = max(finalLine, ThickLine(uv, posA, posB, posC));\n\t}\n\treturn finalLine;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 p = (7.*I - iResolution.xy) / iResolution.y;\n    \n    p.x += iTime * 0.2;\n\n    O = vec4(Rune(p,4,0.8,vec2(2.0,3.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 196, 196, 329], [331, 331, 356, 356, 375], [377, 377, 412, 412, 440], [442, 442, 506, 506, 1447], [1450, 1450, 1509, 1509, 1571], [1573, 1573, 1632, 1632, 2329], [2331, 2331, 2372, 2372, 2501]], "test": "untested"}
{"id": "NlGyRh", "name": "Triquelize it", "author": "deni_de", "description": "triquetrum equalizer", "tags": ["audioshading"], "likes": 4, "viewed": 262, "published": 3, "date": "1661159786", "time_retrieved": "2024-07-30T16:34:51.693152", "image_code": "float smoothCircle(vec2 uv, vec2 pos, float wave, vec3 size)\n{\n    float c = length( uv - pos ) *  (1. - ( 0.69 + 1.1 * wave)); \n\n    vec3 max_mid_min_size = vec3( size.x, size.y, size.z );\n    \n    float e = smoothstep( max_mid_min_size.y, max_mid_min_size.x, c );\n    float e2 = smoothstep( max_mid_min_size.z, max_mid_min_size.y, c );\n    \n    return 1. - abs( e - e2 );\n}\n\nfloat circleDraw(vec2 uv, vec2 pos, float wave, vec3 size)\n{\n    vec2 _pos = pos + 1. * sin(iTime + wave * 1.1);\n    return 1. - smoothCircle( uv, _pos, wave, size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 r = iResolution.xy ;\n    vec2 uv = U/r.xy;\n    vec2 cells = ceil( 100. * U/vec2(r.x/2.0,r.y) ) ;\n    \n    float waveM = texture( iChannel1, vec2(U.x,0.5)  ).x * .23  ;\n    float waveH = texture( iChannel1, vec2(U.x,0.0)  ).x * .23  ;\n    \n    vec3 color = 0.5 + 0.5 * cos( 77.1251252 * waveM * uv.xyx + pow( waveM, 0.05 ) + ( vec3( 0.1,2,4 ) * iTime ) ) ;\n    vec3 size = vec3( 2.1, 1.75 , 1.45 );\n    \n    \n    float image = circleDraw(cells, vec2(105., 50.), waveM * 1.5, size )\n                    + circleDraw( cells, vec2(95. , 50.), waveM * 1.5, size )\n                        + circleDraw( cells, vec2(100. , 41.5), waveM * 1.5, size )\n                    //BIG\n                +circleDraw( cells, vec2(100. , 47.), (waveH * 3.5)  * (0.3 + 2.7 * waveH), vec3(7.0, 4., 1.) );  \n    fragColor = vec4( image * color, 1.);\n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 375], [377, 377, 437, 437, 544], [546, 546, 595, 595, 1432]], "test": "untested"}
{"id": "7lKczD", "name": "Spark Volcano 2", "author": "fenix", "description": "A reprisal of my very first public shader, but with 500x as many particles (50k particles vs ~100)! Made possible via vononoi tracking plus many cool tricks I've learned from the amazing people on this site since then.\n*space to reset* *mouse camera*", "tags": ["3d", "collision", "simulation", "particles", "physics", "integration", "multipass"], "likes": 26, "viewed": 497, "published": 3, "date": "1661128703", "time_retrieved": "2024-07-30T16:34:52.736364", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Powered-up verison of my first public shader, with roughly five hundred times as many\n//  particles. There are no interactions between particles so neighbor tracking is purely\n//  for rendering.\n// \n//  Buffer A computes the particle positions\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders the background with depth in the w component\n//\n// ---------------------------------------------------------------------------------------\n\n#define DIFFUSE_PER_PARTICLE 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec4 normalAndZ = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n      \n    float zDist = normalAndZ.w;\n\tconst vec3 reverseLightDir = normalize(vec3(1.0,2.0,3.0));\n\tconst vec3 lightColor = vec3(0.5,0.5,0.5);\t\n\tconst vec3 ambientColor = vec3(0);\n\n    // diffuse\n\tvec3 groundColor = ambientColor;\n\tfloat dp = dot(normalAndZ.xyz, reverseLightDir);\n\tif(dp > 0.0) groundColor += (dp * lightColor) * .5;\n    \n    // specular\n    vec3 reflection = reflect(reverseLightDir, normalAndZ.xyz);\n    dp = dot(cameraFwd, reflection);\n    if (dp > 0.0) groundColor += pow(abs(dp), 15.0) * vec3(0.5);\t\t\n   \n    fragColor = vec4(groundColor, 0.0) * smoothstep(-50.0, -17.0, -zDist);\n    \n#if DIFFUSE_PER_PARTICLE\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    vec3 groundPos = cameraPos + rayDir * zDist;\n#endif // DIFFUSE_PER_PARTICLE\n\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n\n    for(int j=0; j<4; j++)\n    {\n        int particle = old[j];\n        if (particle < 0 || particle >= MAX_PARTICLES) continue;\n        fxParticle data = fxGetParticle(particle);\n        \n        vec3 oldPos = data.pos;\n        vec3 newPos = data.pos + data.vel;\n         \n#if DIFFUSE_PER_PARTICLE\n        const float GLOW_INTENSITY = 0.001;\n        vec3 groundDelta = oldPos - groundPos.xyz;\n        float groundDotParticle = dot(groundDelta, normalAndZ.xyz);\n        \n        if (groundDotParticle > 0.001)\n        {\n            float distToGround = length(groundDelta);\n            float glow = GLOW_INTENSITY * normalize(groundDotParticle) / (distToGround * distToGround * distToGround);\n            vec3 glowTemp  = fxBlackBody(MAX_TEMP * 1.0 * (1.0 - data.age / 1.5));\n            fragColor += vec4(glow * glowTemp, 0.0);\n        }\n#endif // DIFFUSE_PER_PARTICLE\n \n        // convert to camera space\n        vec3 oldPosCamera = (w2c * vec4(oldPos,1.0)).xyz;\n        oldPosCamera.xy = oldPosCamera.xy / oldPosCamera.z;\n        vec3 newPosCamera = (w2c * vec4(newPos,1.0)).xyz;\n        newPosCamera.xy = newPosCamera.xy / newPosCamera.z;\n        \n        // if in front of clipping plane, not occluded by scene\n        if(oldPosCamera.z > 0.01 && newPosCamera.z > 0.01 && zDist > oldPosCamera.z && zDist > newPosCamera.z)\n        {\n            float dist2 = fxLinePointDist2(oldPosCamera.xy, newPosCamera.xy, p, iResolution);\n            float dist = sqrt(dist2);\n            \n            const float PARTICLE_SIZE = 0.01;\n            float particleTemp = max(0.0, PARTICLE_SIZE - dist) * MAX_TEMP / PARTICLE_SIZE;\n        \n            if (dist < PARTICLE_SIZE)\n            {\n                fragColor += vec4(fxBlackBody(particleTemp / (data.age + 0.1)), 0);\n            }\n        }\n    }\n    \n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.w = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float MAX_AGE = 10.0;\nconst int MAX_PARTICLES = 50000;\n\nbool getVoxel(ivec3 c) {\n    return abs(c[0] + 3) + c[1] + abs(c[2]) < 1 ||\n    abs(c[0] - 3) + c[1] + abs(c[2]) < 0 ||\n    abs(c[0]) + c[1] + abs(c[2] + 3) < 2 ||\n    abs(c[0] - 6) + c[1] + abs(c[2] + 20) < -5 ||\n    abs(c[0] + 9) + c[1] + abs(c[2] - 11) < -3;    \n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvoid fxCalcCamera(in float iTime, in vec4 iMouse, in vec3 iResolution, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float animate = (iMouse.x / iResolution.x) * 2.0 - 0.5;\n    \n    cameraLookAt = vec3(0.0, 0.0f, 0.0);\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 1.1*3.14 + iTime * 0.1;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.75*3.14;\n    cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 15.0;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5*resolution.y / resolution.x * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nconst float MAX_TEMP = 1000.0;\n\nvec3 fxBlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nfloat fxLinePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    //closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS 0\n#define VEL 1\n#define NUM_PARTICLE_DATA_TYPES 2\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    float age;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xyz;\n    particle.vel = particleData1.xyz;\n    particle.age = particleData0.w;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:  \n        return vec4(p.pos, p.age);\n    case VEL:  \n        return vec4(p.vel, 0.0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position and velocity of each particle, one per texture fragment.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0.0,-0.004,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=MAX_PARTICLES) return;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    fxParticle p = fxGetParticle(id);\n    \n    // Integrate velocities\n    vec3 newVel = p.vel + GRAVITY;\n    ivec3 newMapPos = ivec3(floor(p.pos + newVel));\n\n    // Detect if we're about to enter a voxel and bounce off\n    if (getVoxel(newMapPos))\n    {\n        ivec3 oldMapPos = ivec3(floor(p.pos));\n        ivec3 mapDelta = abs(newMapPos - oldMapPos);\n\n        newVel += -1.6 * newVel * vec3(mapDelta);\n    }\n    \n    p.vel = newVel;\n\n    vec3 newPos = p.pos + newVel;\n    float newAge = p.age + min(iTimeDelta, 0.033) / MAX_AGE;\n    \n    p.pos = newPos;\n        \n    // Release particles slowly when shader starts\n    if (int(state.z) < (60*int(MAX_AGE)*id)/MAX_PARTICLES)\n    {\n        newAge = 1.0;\n        p.pos = vec3(1e6);\n    }\n\n    // Reset particles that have gotten too old\n    if (newAge > 1.0)\n    {\n        const float XZ_SPREAD = 0.01;\n        const float Y_SPREAD = 0.02;\n        const float Y_SPRAY = 0.1;\n\n        p.vel = (noise(ivec2(fragCoord)) - 0.5).xyz * 2.0 * vec3(XZ_SPREAD, Y_SPREAD, XZ_SPREAD);\n        p.vel.y += Y_SPRAY;\n\n        p.pos = vec3(-0.1, 0.1, -0.1) + p.vel;\n        newAge = noise(ivec2(fragCoord) + 3).x * 0.25;\n    }\n    \n    p.age = newAge;\n    \n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew){\n    if(id==-1) return 1e20;\n    vec3 worldPos = fxGetParticleData(id, POS).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    vec2 delta = (screenPos.xy)-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    if(iFragCoord == ivec2(0))\n    {\n        // Reset if resolution changes\n        vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n        if (iFrame == 0 || iResolution.xy != state.xy || keyDown(KEY_SPACE))\n        {\n            state = vec4(iResolution.xy, -1.0, 0.0);\n        }\n        else\n        {\n            state.z += 1.0;\n        }\n        \n        fragColor = state;\n        return;\n    }\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    ivec4 old   = fxGetClosest( iFragCoord );      \n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, p, w2c);\n        insertion_sort( new, dis, id, dis2 );\n    }\n\n    uint searchRange = 15u;\n    uint searchCount = 32u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    int searchIterations = 10;\n    if (iFrame < 5)\n    {\n        searchIterations = 100;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n\n        //pick random id of particle\n        int id = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Background rendering inspired by \"Branchless Voxel Raycasting\" by fb39ca4\n//    https://www.shadertoy.com/view/4dX3zl/\n//\n// Added zDist computation based on math from the source cited: https://lodev.org/cgtutor/raycasting.html\n// Resulting buffer contains (normal.x, normal.y, normal.z, zDist) for each pixel.\n// ---------------------------------------------------------------------------------------\n\nconst int MAX_RAY_STEPS = 90;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\t\t\t\n\tivec3 mapPos = ivec3(floor(cameraPos + 0.));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    ivec3 rayStep = ivec3(sign(rayDir));\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - cameraPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n    bool hit = false;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n\t\tif (getVoxel(mapPos))\n        {\n            hit = true;\n            break;\n        }\n\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\t}\n\t\n    if (!hit)\n    {\n        fragColor=vec4(0.0, 0.0, 0.0, 1000000000.0);\n        return;\n    }\n    \n\tvec3 normal;\n    float perpWallDist;\n\tif (mask.x)\n    {\n\t\tnormal = vec3(1.0, 0.0, 0.0);\n        perpWallDist = sideDist.x - deltaDist.x;\n\t}\n\tif (mask.y)\n    {\n\t\tnormal = vec3(0.0, 1.0, 0.0);\n        perpWallDist = sideDist.y - deltaDist.y;\n\t}\n\tif (mask.z)\n    {\n\t\tnormal = vec3(0.0, 0.0, 1.0);\n        perpWallDist = sideDist.z - deltaDist.z;\n\t}\n    \n    float zDist = dot(vec3(mapPos) - cameraPos, rayDir);\n\tfragColor = vec4(normal, perpWallDist);\n}\n\n\n", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKczD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[711, 711, 768, 781, 3964]], "test": "untested"}
{"id": "flGyzm", "name": "AVizMandelbulb PF", "author": "senseedious", "description": "Rave fractal\nStill suffers from spaghetti code curse", "tags": ["fractal", "raytracer", "raymarch", "sound", "mandelbulb", "audio"], "likes": 3, "viewed": 363, "published": 3, "date": "1661116767", "time_retrieved": "2024-07-30T16:34:53.569137", "image_code": "// Fork of \"Audio visualizer Mandelbulb\" by Pyromma. https://shadertoy.com/view/7djcDc\n// 2022-08-21 21:18:43\n\n#define PI 3.1415\n#define EPS 0.005\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light \n{\n\tvec3 position;\n\tvec3 color;\n};\n\n// Shoot Ray\nRay getFragCoordRay(const vec2 frag_coord) {\n  \t   \n    // FOV\n    float fov = 230.;\n    float cameraDistance = 1.0 / tan(fov * 0.5f * PI / 180.0);\n    vec3 position = vec3(0.0, 0.0, -6.5);\n    \n    vec3 rayTarget = vec3((frag_coord / iResolution.xy) * 2.0 - 1.0, cameraDistance);\n    rayTarget.y /= (iResolution.x / iResolution.y);\n    \n  \tvec3 origin = vec3(-0., 0.0, -10.0);\n    vec3 direction = normalize(rayTarget - origin + position);\n  \n  \treturn Ray(origin, direction);\n}\n\n//Rotate Mandelbulb\nvec3 rot(vec3 pos, float x, float y, float z)\n{\n\tmat3 rx = mat3(1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n\tmat3 ry = mat3(cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n\tmat3 rz = mat3(cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n\n\treturn rx * ry * rz * pos;\n}\n\n//Distance Estimator - MandelBulb\nfloat distEst(vec3 pos)\n{\n    float fft[4];\n    fft[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfft[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfft[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfft[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \n    float fftA = (fft[0]+fft[1]+fft[2]+fft[3])/4.;\n    \n    float wave = 0.8*pow(texelFetch( iChannel0, ivec2(1,1), 0 ).x, 0.5);\n    \n    \n\tfloat dis = 0.0;\n\tfloat res = 0.0;\n    int iter = 5;\n\n    pos = rot(pos, sin(iTime * 0.2) * 0.01 - 0.3, cos(iTime * 0.2) * 0.02 - 0.3, 1.2);\n\tvec3 posN = vec3( pos.xyz );\n\n\tfloat p = sin(iTime * 0.1) + 8.0;\n\tfloat d = sin(iTime * 0.1) * 0.2 + 1.0;\n    \n\tfor(int l = 0; l < iter; ++l)\n\t{\n\t\t\n        dis = length(posN);\n\n        if( dis > 1.5 )\n        {\t\n            res = 0.3 * log(dis) * dis / d;\n        }\n        else\n        {\n            d = pow(dis, 7.0) * 7.0 * d + 1.0;\n            \n            float theta = atan( length( posN.xy ), posN.z );\n            float phi = atan( posN.y, posN.x );\n            \n            float tran = sin(theta * p);\n            float rPow = pow(dis, 8.0);\n            \n            posN.x = rPow * cos(phi * p + (1.0-fftA)) * tran;\n            posN.y = rPow * sin(phi * (1.0-fftA) - pow(fft[3],3.0) - pow(sin(fft[0]),3.0)) * tran;\n            posN.z = rPow * cos(theta * p) * wave;\n            \n            posN += pos;\n        }\n\t\t\t\n\t}\n\t\n\treturn res;\n}\n\n//Global var\nconst int maxSteps = 100;\nconst float maxDistance = 500.;\n\nconst int lightAmount = 2;\n\n//Ray Marching\nvec2 rayMarch(Ray ray)\n{\n    float totalDistance = 0.0;\n    int steps;\n    \n\tfor (steps = 0; steps < maxSteps; ++steps)\n    {\n\t\tvec3 p = ray.origin + totalDistance * ray.direction;\n\t\tfloat distance = distEst(p);\n        \n\t\ttotalDistance += distance;\n\t\tif (totalDistance > maxDistance)\n            break;\n            \n\t}\n\treturn vec2(totalDistance, float(steps) / float(maxSteps));\n}\n\n//Normal\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(EPS, 0);\n    float d = distEst(pos);\n    \n    vec3 n = d - vec3(\n        distEst(pos - e.xyy),\n        distEst(pos - e.yxy),\n        distEst(pos - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n//Get light\nvec3 getLight(Ray ray, vec2 dist, Light[lightAmount] light)\n{\n    vec3 pos = ray.origin + ray.direction * dist.x;\n    float diff = 0.0;\n    vec2 shadow = vec2(0.0);\n    vec3 shade = vec3(0.0);\n    vec3 n = getNormal(pos);\n    \n    for(int i = 0; i < lightAmount; i++)\n    {\n        vec3 lightVec = normalize(light[i].position - pos);\n        diff = clamp(dot(n, lightVec), 0.0, 1.0);\n        shadow = rayMarch(Ray(pos + n * EPS, lightVec));\n        diff *= 1.0 - shadow.y;\n        shade += diff * light[i].color * pow(length(pos),3.);\n    }\n\n    return shade;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fft[4];\n    fft[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfft[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfft[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfft[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \n    float fftA = (fft[0]+fft[1]+fft[2]+fft[3])/4.;\n    \n    Light[2] light;\n\n    light[0].position = vec3(13.0, 7.0, -18.0);\n    light[0].color = vec3(0.0, 0.8, 0.9) * fft[0];\n    light[1].position = vec3(-1.0, 9.0, -6.0);\n    light[1].color = vec3(1.0, 0.0, 0.7) * fft[3];\n\n    Ray ray = getFragCoordRay(fragCoord);\n    \n    vec2 res = rayMarch(ray);\n    \n    vec3 color = vec3(0.0);\n\n    color = getLight(ray, res, light) + 0.4 * vec3(res.y * pow(fft[2],3.), 0.0, res.y * pow(fft[0], 10.) - fft[2]*0.3) + 0.5*vec3(pow(fftA,10.));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 264, 308, 326, 743], [745, 765, 812, 812, 1068], [1070, 1104, 1129, 1129, 2502], [2604, 2619, 2643, 2643, 3001], [3003, 3012, 3038, 3038, 3249]], "test": "untested"}
{"id": "NtGyzm", "name": "RCV PubFo", "author": "senseedious", "description": "Nothing really interesting.\n\nIt makes nice visuaals if you put a video in iChannel0 instead of a music.", "tags": ["visualizer"], "likes": 2, "viewed": 219, "published": 3, "date": "1661116607", "time_retrieved": "2024-07-30T16:34:57.655211", "image_code": "// Fork of \"Really cheap visualizer\" by stduhpf. https://shadertoy.com/view/MlV3DW\n// 2022-08-21 21:16:05\n\n#define usemic false //for some reason the mic input does not work the same as soundcloud or the basic sound input\n#define n 5.  //number of *rays?*\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n     vec2 R = iResolution.xy;\n    u = (u+u-R) /R.y;\n     float t = cos(iTime+length(u)*10.)/10.;\n    u*=mat2(cos(t),sin(t),-sin(t),cos(t));\n    vec2 p = vec2(exp2(length(u))-iTime,.5*n*atan(u.y,u.x)/acos(-1.));\n    float s =texture(iChannel0,abs((usemic?1.:.5)-fract(p))).r;   \n    o+=pow(s,2.)-o;    \n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 298, 298, 602]], "test": "untested"}
{"id": "ftGyzm", "name": "Polar audio visualizer22-PF", "author": "senseedious", "description": "Polar audio visualizer", "tags": ["audio", "visualizer", "polar"], "likes": 2, "viewed": 239, "published": 3, "date": "1661116411", "time_retrieved": "2024-07-30T16:34:58.835057", "image_code": "// Fork of \"Polar audio visualizer22\" by made. https://shadertoy.com/view/Ndy3WV\n// 2022-08-21 21:13:04\n\n// Fork of \"Polar audio visualizer\" by edo_m18. https://shadertoy.com/view/tlB3Ry\n// 2021-09-20 20:30:34\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.141592653589793\n#define PI_TWO 6.283185307179586\n\nvoid mainImage(out vec4 O, in vec2 U)\n{    \n    vec2 uv = (U.xy - 0.5 * iResolution.xy) / iResolution.y;\n        \n    vec2 nuv = normalize(uv);\n    float r = length(uv);\n    float th = fract(atan(nuv.y, nuv.x) / PI_TWO);\n    \n    float c = texture(iChannel0, vec2(th, 0.5)).x;\n    float y = S(0.1, 0.2, (c - r) - 0.1);\n    float m = step(0.2, r);\n\n    O.rgb = (mod(th * 360., 3.) < 1.)\n        ? hue2rgb(th) * y * m\n        : vec3(0.0);\n}", "image_inputs": [{"id": 18773, "src": "https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0 );\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 hue2rgb(float h)\n{\n    return clamp(abs(mod(h * 6. + vec3(0, 4, 2), 6.) - 3.) - 1., 0., 1.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 352, 352, 751]], "test": "untested"}
{"id": "NlGcRm", "name": "Circle Music Visualizer V5856-PF", "author": "senseedious", "description": "circle", "tags": ["circle"], "likes": 3, "viewed": 173, "published": 3, "date": "1661116211", "time_retrieved": "2024-07-30T16:34:59.642897", "image_code": "// Fork of \"Circle Music Visualizer V5856\" by KitVanDeBunt. https://shadertoy.com/view/4tj3Dt\n// 2022-08-21 21:09:23\n\n#define bars 100.0                 // How many buckets to divide spectrum into\n#define barSize 1.0 / bars        // Constant to avoid division in main loop\n#define barGap 0.1 * barSize      // 0.1 represents gap on both sides, so a bar is\n#define sampleSize 5.0           // How accurately to sample spectrum, must be a factor of 1.0\n#define PI 3.14159265359\n\n\n// used\n// https://www.shadertoy.com/view/XdX3z2\n\n// atan2 en lerp:\n// http://http.developer.nvidia.com/Cg/index_stdlib.html\n\n// colors\n// https://color.adobe.com/nl/Mijn-Kuler-thema-color-theme-4149936/?showPublished=true\n\n\nfloat lerp(float a, float b, float t)\n{\n  return a + t*(b-a);\n}\n\nvec4 lerp(vec4 a, vec4 b, float t)\n{\n  return a + t*(b-a);\n}\n\nfloat atan2(float y, float x)\n{\n  float t0, t1, t2, t3, t4;\n\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) / t0;\n  t3 = t1 * t3;\n\n  t4 = t3 * t3;\n  t0 =         - float(0.013480470);\n  t0 = t0 * t4 + float(0.057477314);\n  t0 = t0 * t4 - float(0.121239071);\n  t0 = t0 * t4 + float(0.195635925);\n  t0 = t0 * t4 - float(0.332994597);\n  t0 = t0 * t4 + float(0.999995630);\n  t3 = t0 * t3;\n\n  t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\n  t3 = (x < 0.0) ?  float(3.141592654) - t3 : t3;\n  t3 = (y < 0.0) ? -t3 : t3;\n\n  return t3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / vec2(iResolution.y,iResolution.y);\n\tvec2 mouse = iMouse.xy / vec2(iResolution.y,iResolution.y);\n    \n    // calculate stuff\n    vec2 center = vec2((0.5*(iResolution.x/iResolution.y)),0.5);\n    //float deltaYFromCenter = center.y - uv.y;\n    //float deltaXFromCenter = center.x - uv.x;\n    float deltaYFromCenter = (mouse.y) - uv.y;\n    float deltaXFromCenter = (mouse.x) - uv.x;\n    \n    // create music map red (dist center)\n\tvec4 musicMap;\n    float angleFromCenter = atan2(deltaYFromCenter,deltaXFromCenter);  \n    musicMap.r = (angleFromCenter+PI)/(PI*2.0);\n    \n    // create music map blue\n    float distFromCenter = sqrt((deltaYFromCenter*deltaYFromCenter)+(deltaXFromCenter*deltaXFromCenter));\n    //musicMap.b = pow((distFromCenter),0.25);  \n    musicMap.b = clamp(pow((distFromCenter-0.2),2.5)/0.02,0.0,1.0);\n    musicMap.g = (distFromCenter*6.0);\n   \n    \n    // use music map red\n    float musicChannelnput = texture( iChannel0, vec2( musicMap.r,0.0)).r;\n    \n    \n\t// Get the starting x for this bar by rounding down\n\tfloat barStart = floor(musicMap.r * bars) / bars;\n    \n    // Sample spectrum in bar area, keep cumulative total\n    float intensity = 0.0;\n    for(float s = 0.0; s < barSize; s += barSize * sampleSize) {\n        // Shader toy shows loudness at a given frequency at (f, 0) with the same value in all channels\n        intensity += texture(iChannel0, vec2(barStart + s, 0.0)).r;\n    }\n    intensity *= sampleSize;\n    \n    if(musicMap.r - barStart < barGap || musicMap.r > barStart + barSize - barGap) {\n\t\tintensity = 0.0;\n\t}\n    \n    \n    // use music map blue\n    vec4 colorOnCenter = vec4(0.24);\n    vec4 colorOnBars = vec4(0.27,0.48,0.44,1.0);\n    \n    vec4 colorOn = lerp(colorOnCenter,colorOnBars,floor( clamp(musicMap.b,0.0,1.0) ));\n    vec4 colorOff = vec4(0.21,0.40,0.51,1.0);\n    \n    //float onOff = musicMap.b-musicChannelnput;\n\tfloat onOff = musicMap.g-intensity;\n    onOff = clamp(onOff,-0.5,0.5); \n    onOff = floor(onOff+1.0)+0.5;\n    fragColor = lerp(colorOn, colorOff,onOff);\n                       \n\t/*\n    \tif(musicChannelnput>musicMap.b){\n\t\t\tfragColor = colorOn;\n    \t}else{\n\t\t\tfragColor = colorOff;   \n\t\t}\n    */\n    \n    // used to debug music map\n    // fragColor = musicMap;\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[704, 704, 743, 743, 767], [769, 769, 805, 805, 829], [831, 831, 862, 862, 1407], [1409, 1409, 1466, 1503, 3760]], "test": "untested"}
{"id": "ftGcRm", "name": "RL Style Visualizer publicfork", "author": "senseedious", "description": "Rough remake of Rocket League Visualizer", "tags": ["visualizer"], "likes": 5, "viewed": 287, "published": 3, "date": "1661115659", "time_retrieved": "2024-07-30T16:35:00.478663", "image_code": "// Fork of \"RL Style Visualizer\" by clintolibre. https://shadertoy.com/view/llXyzN\n// 2022-08-21 20:59:56\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //basic background\n    vec4 base = vec4(7.0/255.0, 38.0/255.0, 70.0/255.0, 1.0);\n    fragColor = base;\n    \n    //proper ratios\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = uv.y*1.1;\n    uv.x = uv.x*2.0 - .45;\n    \n    \n    //lookup conversion (512 frequences returned by input)\n    int tx = int(uv.x*512.0);\n    \n    //bucketed values of current and max frequencies\n    int starter = int(floor(float(tx)/57.0))*57;\n    int diff = tx-starter;\n    float sum = 0.0;\n    float maxSum = 0.0;\n    for (int i = 0; i<9;i++) {\n\t\tsum = sum + texelFetch( iChannel0, ivec2(starter+i,2), 0 ).x;\n        maxSum = maxSum + texelFetch( iChannel0, ivec2(starter+i,1), 0 ).x;\n    }\n    \n    //normalize values\n    sum = (sum/9.0);\n    maxSum = (maxSum/9.0);\n    \n    //Draw bars\n    float height = sum;\n    float col = ((sum)-.2)*1.25;\n    if (sum > uv.y && diff>20) {\n        fragColor = vec4(uv.y + base.x, uv.y+base.y, uv.y+base.z, 1.0);\n    }\n    \n    //draw \"max\" lines\n    float mDiff = abs((uv.y+.01)-maxSum);\n    float mVal = 1.0-(mDiff*50.0);\n    if (mDiff<.02 && diff>20 && maxSum > 0.001) {\n        fragColor = vec4(mix(fragColor.x,1.0, mVal),mix(fragColor.y, 1.0, mVal),mix(fragColor.z,1.0,  mVal), 1.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //same as usual uv but we offset by one so we grab the previous frame/texture from Buf A one frame higher;\n    vec2 ouv = vec2(fragCoord.x, fragCoord.y-1.0) / iResolution.xy;\n    //not offset texture for grabbing \"max\" values\n    vec2 uv = vec2(fragCoord.x, fragCoord.y) / iResolution.xy;\n    \n    //conversion factor for our texture to sound texture\n    int tx = int(fragCoord.x);\n    \n    //grab previous frame but offset by one pixel\n    fragColor = texture(iChannel0, ouv);\n    //old values for grabbing \"max\" values\n    vec4 fragColorOld = texture(iChannel0, uv);\n    \n    //get frequency data\n    float freq = texelFetch( iChannel1, ivec2(tx,0), 0 ).x;\n    \n    //only overwrite pixel if its the bottom one!\n    //fragColor = mix(fragColor, vec4(vec3(freq), 1.0), clamp(1.0-fragCoord.y,0.0,1.0));\n    \n    //simpler code for overwriting third to bottom pixel\n    if (int(fragCoord.y) == 2) {\n        fragColor = vec4(vec3(freq),1.0);\n    }\n    //write max in second to bottom pixel\n    if (int(fragCoord.y) == 1) {\n        if (freq > fragColorOld.x) {\n        \tfragColor = vec4(freq, 0.0, 0.0,1.0);\n        } else {\n            //reduce max over time\n        \tfragColor = vec4(fragColorOld.x-.005, 0.0, 0.0,1.0);\n        }\n    }\n}\n\n//Also see https://www.shadertoy.com/view/XtKGzm by ttoinou for a similar effect", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 11938, "src": "https://soundcloud.com/michael_ault/angelwings", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 164, 190, 1390]], "test": "untested"}
{"id": "ftyyzw", "name": "Auroras with bokeh blur", "author": "fishy", "description": "Bokeh blur! I made the blur myself here: https://www.shadertoy.com/view/NtGczw. Also has vignette and color correction.", "tags": ["procedural", "blur", "bokeh", "aurora", "atmosphere", "weather", "boke"], "likes": 39, "viewed": 980, "published": 3, "date": "1661109877", "time_retrieved": "2024-07-30T16:35:01.330385", "image_code": "float intensity(vec2 p)\n{\n    return float(distance(p, vec2(0.0)) < 1.0);\n}\n\nvec3 blur(sampler2D tex, float size, int res, vec2 uv, float ratio)\n{\n    float div = 0.0;\n    vec3 accumulate = vec3(0.0);\n    \n    for(int iy = 0; iy < res; iy++)\n    {\n        float y = (float(iy) / float(res))*2.0 - 1.0;\n        for(int ix = 0; ix < res; ix++)\n        {\n            float x = (float(ix) / float(res))*2.0 - 1.0;\n            vec2 p = vec2(x, y);\n            float i = intensity(p);\n            \n            div += i;\n            accumulate += vec3(texture(tex, uv+p*size*vec2(1.0, ratio)) * vec4(i));\n        }\n    }\n    \n    return accumulate / vec3(div);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    fragColor = vec4(blur(iChannel0, clamp(-uv.y+0.6, -0.1, 1.0)*0.02, 4, uv, iResolution.x/iResolution.y), 1.0);\n    fragColor = pow(fragColor, vec4(vec3(0.8), 1.0));\n    \n    fragColor *= vec4(vec3(pow(1.0-length(uv - vec2(0.5)),0.7)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Auroras by nimitz 2017 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\t\n\tThere are two main hurdles I encountered rendering this effect. \n\tFirst, the nature of the texture that needs to be generated to get a believable effect\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\n\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\n\tthe rest of the effect. Which is always the case for auroras.\n\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\n\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\n\tdirection. But this was not required for this demo and would be trivial to fix.\n*/\n\n#define time iTime*2.0\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo *= float(iMouse.z > 0.5);\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x + time*0.01);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 75], [657, 657, 714, 764, 1094]], "test": "untested"}
{"id": "NtGczw", "name": "Easy Bokeh Blur", "author": "fishy", "description": "the easiest bokeh blur I could do, not sure how to make a separable filter to do it. Use the mouse to change the focus plane.", "tags": ["blur", "bokeh"], "likes": 18, "viewed": 1178, "published": 3, "date": "1661109335", "time_retrieved": "2024-07-30T16:35:02.158173", "image_code": "#define gamma 10.2\n#define hardness 0.5\n\nfloat intensity(vec2 p)\n{\n    return smoothstep(1.0, hardness, distance(p, vec2(0.0)));\n}\n\nvec3 blur(sampler2D tex, float size, int res, vec2 uv, float ratio)\n{\n    float div = 0.0;\n    vec3 accumulate = vec3(0.0);\n    \n    for(int iy = 0; iy < res; iy++)\n    {\n        float y = (float(iy) / float(res))*2.0 - 1.0;\n        for(int ix = 0; ix < res; ix++)\n        {\n            float x = (float(ix) / float(res))*2.0 - 1.0;\n            vec2 p = vec2(x, y);\n            float i = intensity(p);\n            \n            div += i;\n            accumulate += pow(texture(tex, uv+p*size*vec2(1.0, ratio)).xyz, vec3(gamma)) * i;\n        }\n    }\n    \n    return pow(accumulate / vec3(div), vec3(1.0 / gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    fragColor = vec4(blur(iChannel0, abs(uv.y - mouse.y)*0.02, 10, uv, iResolution.x/iResolution.y), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 66, 66, 130], [746, 746, 803, 853, 1046]], "test": "untested"}
{"id": "stKyRW", "name": "weaving 2", "author": "FabriceNeyret2", "description": "ok, with collisions ;-)    .  better seen in fullscreen.\nvariant line 11: can't decide which I prefer.\nreference: https://twitter.com/larswander/status/1560731507634888705\n", "tags": ["2d", "short", "reproduction"], "likes": 21, "viewed": 279, "published": 3, "date": "1661078233", "time_retrieved": "2024-07-30T16:35:02.966012", "image_code": "#define S(v) smoothstep(90./R.y,0.,  v )\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.5*( u+u - R ) / R.y;\n // O-=O; \n    float c = 0., z = -9., i,x,y;\n    for( int k=0; k<3; k++ ) {          // angled layers\n        if ( abs(U.y) < 1. )\n            for( i = 0.; i<6.; i++ ) {  // loop required because of neighbors superimposition   \n             // y = sin(10.*U.y)*.8*sin(i-1.) , x = 20.*U.x - i+3. + y; // variant\n                y = sin(10.*U.y) , x = 20.*U.x - i+3. + y*.8*sin(i-1.);\n                if (abs(x) < 20. ) \n                    x = abs( mod(x,6.) -.5) - .2,\n                 // O.ra +=  (1.-O.a)                 // simple blending\n                 //          * vec2( (.2+.8*S(abs(x))), 1 )\n                 //          * S( x ), \n                    y > z && S(x) > 0. ?              // Z-buffer\n                        c = (.2+.8*S(abs(x))) * S(x), // ribbon pattern * mask\n                        z = y : y;\n            } \n        U *= mat2(cos(vec4(1,12,34,1)));              // ~ rot pi/3\n    }\n        \n    O = sqrt(  c *vec4(.7,.7,1,1) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 79, 79, 1103]], "test": "untested"}
{"id": "7lKyz1", "name": "amoeba world", "author": "lomateron", "description": "click to paint\n7 layers across time of 3x3+4 pixel grids\nit looks like eating makes them survive more time\n", "tags": ["automata"], "likes": 2, "viewed": 207, "published": 3, "date": "1661046418", "time_retrieved": "2024-07-30T16:35:03.883559", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0);\n    uint b = floatBitsToUint(a.x)&255U;\n    int i = iFrame&7;\n    b = (b>>i)|(b<<(8-i));\n    fragColor = cos(float(b&255U)*77.1111+vec4(3,1,2,4))*.5+.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    uint a = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 1, 0)),0).x);\n    uint b = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 0, 1)),0).x);\n    uint c = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2(-1, 0)),0).x);\n    uint d = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 0,-1)),0).x);\n    uint e = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 1, 1)),0).x);\n    uint f = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2(-1, 1)),0).x);\n    uint g = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 1,-1)),0).x);\n    uint h = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2(-1,-1)),0).x);\n    uint i = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 0, 0)),0).x);\n    uint j = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 2, 0)),0).x);\n    uint k = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 0, 2)),0).x);\n    uint l = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2(-2, 0)),0).x);\n    uint m = floatBitsToUint(texelFetch(iChannel0,ivec2(u+vec2( 0,-2)),0).x);\n    uint o = \n    +((a>>0U)&1U) +((b>>0U)&1U) +((c>>0U)&1U) +((d>>0U)&1U) +((e>>0U)&1U) +((f>>0U)&1U) +((g>>0U)&1U) +((h>>0U)&1U) +((i>>0U)&1U)   +((j>>0U)&1U) +((k>>0U)&1U) +((l>>0U)&1U) +((m>>0U)&1U)\n    +((a>>1U)&1U) +((b>>1U)&1U) +((c>>1U)&1U) +((d>>1U)&1U) +((e>>1U)&1U) +((f>>1U)&1U) +((g>>1U)&1U) +((h>>1U)&1U) +((i>>1U)&1U)   +((j>>1U)&1U) +((k>>1U)&1U) +((l>>1U)&1U) +((m>>1U)&1U)\n    +((a>>2U)&1U) +((b>>2U)&1U) +((c>>2U)&1U) +((d>>2U)&1U) +((e>>2U)&1U) +((f>>2U)&1U) +((g>>2U)&1U) +((h>>2U)&1U) +((i>>2U)&1U)   +((j>>2U)&1U) +((k>>2U)&1U) +((l>>2U)&1U) +((m>>2U)&1U)\n    +((a>>3U)&1U) +((b>>3U)&1U) +((c>>3U)&1U) +((d>>3U)&1U) +((e>>3U)&1U) +((f>>3U)&1U) +((g>>3U)&1U) +((h>>3U)&1U) +((i>>3U)&1U)   +((j>>3U)&1U) +((k>>3U)&1U) +((l>>3U)&1U) +((m>>3U)&1U)\n    +((a>>4U)&1U) +((b>>4U)&1U) +((c>>4U)&1U) +((d>>4U)&1U) +((e>>4U)&1U) +((f>>4U)&1U) +((g>>4U)&1U) +((h>>4U)&1U) +((i>>4U)&1U)   +((j>>4U)&1U) +((k>>4U)&1U) +((l>>4U)&1U) +((m>>4U)&1U)\n    +((a>>5U)&1U) +((b>>5U)&1U) +((c>>5U)&1U) +((d>>5U)&1U) +((e>>5U)&1U) +((f>>5U)&1U) +((g>>5U)&1U) +((h>>5U)&1U) +((i>>5U)&1U)   +((j>>5U)&1U) +((k>>5U)&1U) +((l>>5U)&1U) +((m>>5U)&1U)\n    +((a>>6U)&1U) +((b>>6U)&1U) +((c>>6U)&1U) +((d>>6U)&1U) +((e>>6U)&1U) +((f>>6U)&1U) +((g>>6U)&1U) +((h>>6U)&1U) +((i>>6U)&1U)   +((j>>6U)&1U) +((k>>6U)&1U) +((l>>6U)&1U) +((m>>6U)&1U);\n    a = (16U*2U+4U)*(16U*8U*16U*8U)+(16U*6U+7U);\n    o = (i<<1U) | ((a>>(o&31U))&1U);\n    \n    vec2  v = (u        *2.-iResolution.xy)/iResolution.y;\n    vec2  w = (iMouse.xy*2.-iResolution.xy)/iResolution.y-v;\n    float r = fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*5467.5678)*256.;\n    if(iFrame==0)\n    {\n        //r*= step(dot(v,v),.5);\n        r*= step(.999,fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*3467.5678));\n        o = uint(r);\n    }\n    if(iMouse.z>.5 && dot(w,w)<.001)\n    {\n        o = uint(r);\n    }\n    fragColor = vec4(uintBitsToFloat(o));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 267]], "test": "untested"}
{"id": "NlVyRW", "name": "basic toon shader test", "author": "intrakits", "description": "Messing around with making a more stylized look.", "tags": ["kuwahara", "outline", "toon"], "likes": 2, "viewed": 338, "published": 3, "date": "1661034694", "time_retrieved": "2024-07-30T16:35:04.891863", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float off = .002;\n    // Time varying pixel color\n    vec3 d = texture(iChannel1,uv).rgb;\n    vec3 du = d-texture(iChannel1,uv-vec2(0.,off)).rgb;\n    vec3 dd = d-texture(iChannel1,uv-vec2(0.,-off)).rgb;\n    vec3 dr = d-texture(iChannel1,uv-vec2(off,0.)).rgb;\n    vec3 dl = d-texture(iChannel1,uv-vec2(-off,.0)).rgb;\n    d = (du+dd+dr+dl) * vec3(1.,0,0) * smoothstep(40.,30.,d);\n    \n    vec3 n = texture(iChannel2,uv).rgb;\n    float nu = dot(n,texture(iChannel2,uv-vec2(0.,off)).rgb);\n    float nd = dot(n,texture(iChannel2,uv-vec2(0.,-off)).rgb);\n    float nr = dot(n,texture(iChannel2,uv-vec2(off,0.)).rgb);\n    float nl = dot(n,texture(iChannel2,uv-vec2(-off,.0)).rgb);\n    n=1.-vec3(min(min(min(nu,nd),nr),nl));\n    n=clamp(n,0.,1.);\n    n*=vec3(1,0,0);\n    vec3 col = texture(iChannel3,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(d+n+col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\nvec2 GetDist(vec3 p){\n    // some test object\n    vec4 sphere = vec4(0,1,6,1);\n    \n    // distance to sphere\n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n    vec2 ds = vec2(length(p-sphere.xyz-vec3(sin(iTime),0.,0))-sphere.w,0.);\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    vec2 dp = vec2(p.y,1.);\n    \n    //capsule distance\n    vec2 cd = vec2(sdCapsule(p, vec3(2,0.5,6), vec3(2,1.5,6), 0.5),2.);\n    \n    //torus distance\n    vec2 td = vec2(sdTorus(p-vec3(-3,0.5,6), vec2(.5,.3)),3.);\n    \n    //box distance\n    vec2 bd = vec2(dBox(p-vec3(-2,0.5,8),vec3(0.5)),4.);\n    p.y-=sin(iTime)*.5+.5;\n    p-=vec3(1, .3, 5);\n    p.xz*=Rot(iTime);\n    \n    // cylinder distance\n    vec2 cyld = vec2(sdCylinder(p, vec3(0.), vec3(3, 0, 1), .3),5.);\n    \n    //choose the closest of the two\n    vec2 d = colMin(ds,dp);\n    d = colMin(cd,d);\n    d = colMin(d,td);\n    d = colMin(bd,d);\n    d = colMin(cyld,d);\n    return d;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5.,3);\n    \n    lightPos.xz += vec2(sin(iTime)*5.,cos(iTime)*5.);\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 refl = texture(iChannel0, r).rgb;\n    refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    \n    if(d.y == 0.){\n        float noise = iqnoise(p.xz*10.,1.,1.);\n        float noise2 = iqnoise(p.xy*10.,1.,1.);\n        col = vec3(noise*noise2);\n        \n        reflVal = smoothstep(.2,.6,noise*noise2);\n    }\n    else if(d.y==1.){\n    \n       col *= vec3(1,1,0);\n\n       reflVal = 0.9;\n    }\n    else if(d.y==2.){\n       float noise = iqnoise(p.xy*10.,1.,1.);\n       col *= noise*vec3(1,0,1);\n       reflVal = smoothstep(.3,.7,noise);\n    }\n    else if(d.y==3.){\n      float noise = iqnoise(p.xz*10.,1.,1.);\n      col *= noise*vec3(.3,.3,1);\n      reflVal = smoothstep(.3,.7,noise);\n    }\n    else if(d.y==4.){\n      float noise = iqnoise(p.xz*10.,1.,1.);\n      float noise2 = iqnoise(p.xy*10.,1.,1.);\n      col *= noise2*noise*vec3(1,.3,.4);\n      reflVal=smoothstep(.2,.6,noise*noise2);;\n    }\n    else if(d.y==5.){\n    float noise = iqnoise(p.xz*10.,1.,1.);\n      float noise2 = iqnoise(p.xy*10.,1.,1.);\n      col *= noise2*noise*vec3(0,1,1);\n      reflVal=smoothstep(.2,.6,noise*noise2);;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb*.3;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(0,4,0);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = normalize(vec3(uv.x,uv.y-0.5,1));\n    //------------------\n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat GetDist(vec3 p){\n    // some test object\n    vec4 sphere = vec4(0,1,6,1);\n    \n    // distance to sphere\n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n    float ds = length(p-sphere.xyz-vec3(sin(iTime),0.,0))-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    float dp = p.y;\n    \n    //capsule distance\n    float cd = sdCapsule(p, vec3(2,0.5,6), vec3(2,1.5,6), 0.5);\n    \n    //torus distance\n    float td = sdTorus(p-vec3(-3,0.5,6), vec2(.5,.3));\n    \n    //box distance\n    float bd = dBox(p-vec3(-2,0.5,8),vec3(0.5));\n    p.y-=sin(iTime)*.5+.5;\n    p-=vec3(1, .3, 5);\n    p.xz*=Rot(iTime);\n    // cylinder distance\n    float cyld = sdCylinder(p, vec3(0.), vec3(3, 0, 1), .3);\n    \n    //choose the closest of the two\n    float d = min(ds,dp);\n    d = min(cd,d);\n    d = min(d,td);\n    d = min(bd,d);\n    d = min(cyld,d);\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(0,4,0);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = normalize(vec3(uv.x,uv.y-0.5,1));\n    //------------------\n    float d = RayMarch(ro,rd);\n\n    col = vec3(d);\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [], "buffer_c_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat GetDist(vec3 p){\n    // some test object\n    vec4 sphere = vec4(0,1,6,1);\n    \n    // distance to sphere\n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n    float ds = length(p-sphere.xyz-vec3(sin(iTime),0.,0))-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    float dp = p.y;\n    \n    //capsule distance\n    float cd = sdCapsule(p, vec3(2,0.5,6), vec3(2,1.5,6), 0.5);\n    \n    //torus distance\n    float td = sdTorus(p-vec3(-3,0.5,6), vec2(.5,.3));\n    \n    //box distance\n    float bd = dBox(p-vec3(-2,0.5,8),vec3(0.5));\n    p.y-=sin(iTime)*.5+.5;\n    p-=vec3(1, .3, 5);\n    p.xz*=Rot(iTime);\n    // cylinder distance\n    float cyld = sdCylinder(p, vec3(0.), vec3(3, 0, 1), .3);\n    \n    //choose the closest of the two\n    float d = min(ds,dp);\n    d = min(cd,d);\n    d = min(d,td);\n    d = min(bd,d);\n    d = min(cyld,d);\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(0,4,0);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = normalize(vec3(uv.x,uv.y-0.5,1));\n    //------------------\n    float d = RayMarch(ro,rd);\n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    col = GetNormal(p);\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [], "buffer_d_code": " // From https://www.shadertoy.com/view/sd2SzR\n const int radius = 7;\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n {\n\t vec2 src_size = vec2 (1.0 / iResolution.x, 1.0 / iResolution.y);\n     vec2 uv = fragCoord.xy/iResolution.xy;\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n\n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         fragColor = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         fragColor = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         fragColor = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         fragColor = vec4(m3, 1.0);\n     }\n }", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1013]], "test": "untested"}
{"id": "slyyzW", "name": "Curvature metrics", "author": "Nolan", "description": "From paper:\nFundamental quantitative methods of land surface analysis (Shary et al. 2002)", "tags": ["curvature", "meancurvature", "shary", "evans", "plancurvature", "surfaceanalysis"], "likes": 3, "viewed": 203, "published": 3, "date": "1661016833", "time_retrieved": "2024-07-30T16:35:05.801431", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define HORIZONTAL_CURVATURE 0\n#define PLAN_CURVATURE \t\t 1\n#define VERTICAL_CURVATURE\t 2\n#define DIFFERENCE_CURVATURE 3\n#define MEAN_CURVATURE\t\t 4\n#define UNSPHERICITY\t\t 5\n#define MIN_CURVATURE \t\t 6\n#define MAX_CURVATURE\t\t 7\n#define MIN_MAX_CURVATURE\t 8\t\n\n#define TYPE      MIN_MAX_CURVATURE\n\n#define SCALE     10.\n#define THRESHOLD 0.\n\n#define R iResolution\n#define T iTime\n\nfloat e[9];          // elevation in a 3x3 grid\nfloat p, q, r, s, t; // coefficients of the polynomial fitting the surface\nfloat pp, qq, pq;    // see Shary 2002 Geoderma (appendix A)\n\nvec2 uv;\n\nfloat h(in float x, in float y) {\n\tvec2 o = vec2(x,y)/R.xy;\n\treturn texture(iChannel0, uv+o).x;\n}\n\nfloat z(in int i) {\n\tif (i < 1 || i > 9) return 0.;\n\n\treturn e[i-1];\n}\n\n// formula sheet, p. 13 of (Shary et al. 2002)\n// http://wiki.dpi.inpe.br/lib/exe/fetch.php?media=ser301-2012:shary2002geoderma.pdf\n\nfloat plan_curvature() {\n\treturn -(qq*r-2.*pq*s+pp*t) / pow(pp+qq, 1.5);\n}\n\nfloat horizontal_curvature() { // sometimes called profile curvature\n\treturn -(qq*r-2.*pq*s+pp*t) / ((pp+qq)*sqrt(1.+pp+qq));\n}\n\nfloat vertical_curvature() { // sometimes called profile curvature\n\treturn -(pp*r-2.*pq*s+qq*t) / ((pp+qq)*pow(1.+pp+qq, 1.5));\n}\n\nfloat difference_curvature() {\n\treturn (qq*r-2.*pq*s+pp*t)/((pp+qq)*sqrt(1.+pp+qq))-((1.+qq)*r-2.*pq*s+(1.+pp)*t)/(2.*pow(1.+pp+qq, 1.5));\n}\n\nfloat mean_curvature() {\n\treturn -((1.+qq)*r - 2.*pq*s + (1.+pp)*t)/(2.*pow((1.+pp+qq), 1.5));\n}\n\nfloat unsphericity() { // Shary 1995\n\tfloat a = sqrt((1.+qq)/(1.+pp));\n\tfloat term1 = r*a - t/a;\n\tterm1 *= term1;\n\tfloat term2 = pq*r*a - 2.*a*s + pq*t/a;\n\t \n\treturn sqrt(term1/(1.+pp+qq) + term2*term2) / (2.*pow(1.+pp+qq, 1.5));\n}\n\nfloat min_curvature() {\n\treturn mean_curvature() - unsphericity();\n}\n\nfloat max_curvature() {\n\treturn mean_curvature() + unsphericity();\n}\n\nvoid init(in vec2 fc) {\n    uv = fc/R.xy;\n    \n\te[0] = h(-1., 1.);\n\te[1] = h(0., 1.);\n\te[2] = h(1., 1.);\n\te[3] = h(-1., 0.);\n\te[4] = h(0., 0.); // center of the grid\n\te[5] = h(1., 0.);\n\te[6] = h(-1., -1.);\n\te[7] = h(0., -1.);\n\te[8] = h(1., -1.);\n\n\tp\t= (z(3)+z(6)+z(9)-z(1)-z(4)-z(7)) / 6.; // dz/dx;\n\tq\t= (z(1)+z(2)+z(3)-z(7)-z(8)-z(9)) / 6.; // dz/dy; equivalent to GLSL dFdy & dFdx?\n \tr \t= (z(1)+z(3)+z(4)+z(6)+z(7)+z(9)-2.*(z(2)+z(5)+z(8)))/3.; // d²z/dx²\n\ts \t= (-z(1)+z(3)-z(7)+z(9))/4.; // d²z/dxdy\n\tt\t= (z(1)+z(2)+z(3)+z(7)+z(8)+z(9)-2.*(z(4)+z(5)+z(6)))/3.; // d²z/dy²\n\n\tpp = p*p, qq = q*q, pq=p*q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tinit(fragCoord);\n\tfloat k = SCALE * (\n\t\t\t\tTYPE == HORIZONTAL_CURVATURE ? horizontal_curvature() :\n\t\t\t\tTYPE == PLAN_CURVATURE ? plan_curvature() :\n\t\t\t\tTYPE == VERTICAL_CURVATURE ? vertical_curvature() :\n\t\t\t\tTYPE == DIFFERENCE_CURVATURE ? difference_curvature() :\n\t\t\t\tTYPE == MEAN_CURVATURE ? mean_curvature() :\n\t\t\t\tTYPE == UNSPHERICITY ? unsphericity() :\n\t\t\t\tTYPE == MIN_CURVATURE ? min_curvature() :\n\t\t\t\tTYPE == MAX_CURVATURE ? max_curvature() : 0.);\n\n\tvec4 o = TYPE == MIN_MAX_CURVATURE ?\n\t\tSCALE*vec4(max_curvature(), 0., -min_curvature(), 1.) : vec4(k, 0., -k, 1.);\n\n\tfragColor = step(THRESHOLD, o)*o; return;\n}\n", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "flGyRD", "name": "Scan This QR Code", "author": "MysteryPancake", "description": "We do a little trolling", "tags": ["scan", "qr", "code", "barcode", "meme"], "likes": 2, "viewed": 299, "published": 3, "date": "1660997219", "time_retrieved": "2024-07-30T16:35:06.579351", "image_code": "const int pixels[] = int[] (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\nconst float size = 27.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = vec2(0.5) + (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\tif (abs(uv.x - 0.5) < 0.5) {\n\t\tfloat coord = (uv.x + floor(uv.y * size)) * size;\n\t\tfragColor = vec4(vec3(pixels[int(coord)]), 1.0);\n    } else {\n        fragColor = vec4(0.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2242, 2242, 2297, 2297, 2574]], "test": "untested"}
{"id": "ftGyRD", "name": "alcubierre drive", "author": "grevel", "description": "Visualisation of alcubierre drive (read the comments in the code)", "tags": ["warp", "visualisation", "physics", "drive", "alcubierre"], "likes": 2, "viewed": 265, "published": 3, "date": "1660995879", "time_retrieved": "2024-07-30T16:35:07.348295", "image_code": "#define SHRINK 0.009\n\n// While watching this video: https://www.youtube.com/watch?v=Vk5bxHetL4s (3:19) I was \n// dissatisfied with the visual effect provided. The \"space bubble\" warped only on the \n// edges, leaving the enclosed space still stationary, completely missing the point in \n// my opinion.\n\n// This visualisation makes the space near your mouse moving relative to the \n// surroundings, so any matter living inside the bubble would \"move\" together with the \n// bubble, while staying stationary relative to the space it sits in.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float col = 1.0;\n    \n    int shrink = int(SHRINK * iResolution.x);\n    \n    for(int x = -shrink; x <= shrink; x++) {\n        for(int y = -shrink; y <= shrink; y++) {\n            col *= texture(iChannel0, (fragCoord + vec2(float(x), float(y))) / iResolution.xy).x;\n        }\n    }\n    \n    \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GRID_SIZE 20.0\n#define BUBBLE_R 0.2\n#define SPACE_SPEED 0.1\n#define BLEND 0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xx;\n    \n    if(mouse == vec2(0.0, 0.0)) {\n        mouse = vec2(0.5, 0.3);\n    }\n    \n    vec2 uv = fragCoord / iResolution.xx;\n    vec2 bubbleSpace = fract(GRID_SIZE * (fragCoord/iResolution.xx - mouse));\n    vec2 gridSpace = GRID_SIZE * fragCoord/iResolution.xx;\n    gridSpace.x += SPACE_SPEED * iTime * GRID_SIZE;\n    gridSpace.y += SPACE_SPEED * iTime * GRID_SIZE * 0.2;\n    gridSpace = fract(gridSpace);\n\n    float distSq = (mouse.x - uv.x) * (mouse.x - uv.x) + (mouse.y - uv.y) * (mouse.y - uv.y);\n    float dist = sqrt(distSq);\n\n    float mask = smoothstep(dist - BLEND, dist + BLEND, BUBBLE_R);\n    \n    \n    gridSpace -= vec2(0.5);\n    gridSpace = 2.0*abs(gridSpace);\n    \n    bubbleSpace -= vec2(0.5);\n    bubbleSpace = 2.0*abs(bubbleSpace);\n    \n    vec2 finalSpace = mix(gridSpace, bubbleSpace, mask);\n    \n    \n    float thickness = 0.5;\n    float col = step(thickness, finalSpace.x) + step(thickness, finalSpace.y);\n    \n\n    fragColor = vec4(col);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 541, 598, 598, 969]], "test": "untested"}
{"id": "NlGczW", "name": "Noise Lens Blur", "author": "MysteryPancake", "description": "Cool lens blur/defocus effect", "tags": ["noise", "blur", "lens", "defocus", "tiltshift", "tilt"], "likes": 4, "viewed": 357, "published": 3, "date": "1660993123", "time_retrieved": "2024-07-30T16:35:08.103276", "image_code": "vec2 noise(vec2 p) { // From https://www.shadertoy.com/view/Msf3WH\n\tp = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 center = vec2(0.5);\n    if (iMouse.z > 0.0) {\n        center = iMouse.xy / iResolution.xy;\n    }\n\n    vec2 offset = noise(iTime + uv) * pow(distance(uv, center), (1.0 + sin(iTime)) * 2.0);\n    fragColor = texture(iChannel0, uv + offset);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 66, 187], [189, 189, 244, 244, 536]], "test": "untested"}
{"id": "flycRW", "name": "Imp in glass", "author": "Maurogik", "description": "A simple ray-tracing doodle I did as a coding test.", "tags": ["raytracing", "sphere", "glass"], "likes": 28, "viewed": 517, "published": 3, "date": "1660986138", "time_retrieved": "2024-07-30T16:35:09.080663", "image_code": "const float kPI = 3.14159265359;\n\n// WebGL sometimes likes to force unroll things, even if the iteration count is very large\n// This stops it from unrolling. (Can massively reduce shader compilation times)\n#define NON_CONST_ZERO min(0, iFrame)\n\nconst int kMatSky = -1;\nconst int kMatSphereAirToGlass = 0;\nconst int kMatSphereGlassToAir = 1;\nconst int kMatTable = 2;\nconst int kMatImpBody = 3;\nconst int kMatImpEye = 4;\nconst int kMatImpGlow = 5;\n\nconst vec3 kSpherePosWs = vec3(0.0, 1.0, 0.0);\nconst float kFocalLengthWs = 1.0;\n\n// Path tracer rays\nconst int kMaxRayCount = 10;\nstruct Ray\n{\n    vec3 originWs;\n    vec3 directionWs;\n    float weight;\n};\n\nconst float kGlassIoR = 1.5;\nconst float kAirIoR = 1.0;\n\n// Returns outside and inside intersections\nvec2 rayVsSphere(vec3 ray_origin, vec3 ray_dir, vec3 sphere_pos, float sphere_radius)\n{\n    vec3 e = ray_origin - sphere_pos;\n    vec3 d = ray_dir;\n    \n    float a = 1.0;\n    float b = 2.0 * dot(d,e);\n    float c = dot(e,e) - sphere_radius*sphere_radius;\n    \n    float det = b*b - 4.0*a*c;\n    \n    if (det <= 0.0) {\n        return vec2(0.0);\n    }\n    \n    return vec2(-b - sqrt(det), -b + sqrt(det)) / (2.0 * a) ;\n}\n\nfloat rayVsTable(vec3 rayOriginWs, vec3 rayDirWs)\n{\n    if (rayDirWs.y >= 0.0 || rayOriginWs.y <= 0.0) {\n        return 0.0;\n    }\n    float distWs = (0.0 - rayOriginWs.y) / rayDirWs.y;\n    \n    vec3 hitWs = rayOriginWs + rayDirWs * distWs;\n    if(max(abs(hitWs.x), abs(hitWs.z)) < 4.0)\n    {   \n        return distWs;\n    }\n            \n    return 0.0;\n}\n\nfloat fSphere(vec3 vecToCentreWs, float radiusWs)\n{\n    return length(vecToCentreWs) - radiusWs;\n}\n\nfloat fVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 rotate2D(vec2 vec, float rotRadians)\n{\n    float cosR = cos(rotRadians);\n    float sinR = sin(rotRadians);\n    return vec2(cosR * vec.x + sinR * vec.y,\n                -sinR * vec.x + cosR * vec.y);\n}\n\nfloat fSDF(vec3 positionWs, out int material)\n{\n    // SDF for a little Dreams imp thingy.\n    \n    float minDistWs = 999999.0;\n    \n    vec3 impCentreWs = vec3(0.0, 0.9 - sin(iTime * 1.0) * 0.035, 0.0);\n    \n    // Eyes\n    vec3 mirrorPositionWs = positionWs;\n    mirrorPositionWs.x = abs(mirrorPositionWs.x);\n    vec3 eyeOffsetWs = vec3(0.12, 0.05, -0.18);\n    float squint = 0.5 + 0.5*sin(iTime * 4.0);\n    float eyeDistWs = fSphere(mirrorPositionWs - (impCentreWs + eyeOffsetWs)\n        + squint * vec3(0.0, 0.005, 0.0), 0.05);\n        \n    // Cutout bottom to make smilling eyes\n    eyeOffsetWs += vec3(0.0, -0.08, -0.05);\n    float antiEyeDistWs = fSphere(mirrorPositionWs - (impCentreWs + eyeOffsetWs), 0.08);\n    eyeDistWs = max(eyeDistWs, -antiEyeDistWs);\n    \n    if(eyeDistWs < minDistWs)\n    {\n        material = kMatImpEye;\n        minDistWs = eyeDistWs;\n    }\n    \n    // Mouth\n    float mouthDistWs = fSphere(positionWs - (impCentreWs + vec3(0.0, -0.01, -0.18)), 0.1);\n    float breath = 0.5 + 0.5 * sin(iTime * 0.6 * kPI);\n    float antiMouthDistWs = fSphere(positionWs - (impCentreWs + vec3(0.0, 0.04 + breath * 0.015, -0.25)), 0.11);\n    mouthDistWs = max(mouthDistWs, -antiMouthDistWs);\n    if(mouthDistWs < minDistWs)\n    {\n        minDistWs = mouthDistWs;\n        material = kMatImpEye;\n    }\n    \n    // Body\n    vec3 vecToImp = impCentreWs - positionWs;\n    float bodyDistWs = fSphere(vecToImp, 0.25);\n    vec3 disp = sin(vecToImp * 30.0 + vec3(0.0, 1.0, 1.0) * iTime);\n    bodyDistWs -= min(min(mouthDistWs, eyeDistWs) * 6.0, 1.0) * 0.025 * \n        disp.x * disp.y * disp.z;\n    \n    // Tail ? (The thing at the top)\n    vec3 tailStartWs = impCentreWs + vec3(0.0, 0.25, 0.0);\n    float tailStartToEnd = (positionWs.y - tailStartWs.y)/0.25;\n    float tailRadiusWs = 0.04 - tailStartToEnd * 0.03;\n    \n    //tailStartWs.x += (1.0 + breath) * tailStartToEnd * tailStartToEnd * 0.05;\n    vec3 vecToTailWs = positionWs - tailStartWs;\n    float wag = 0.8 * sin(iTime * 2.0);\n    vecToTailWs.xy = rotate2D(vecToTailWs.xy, vecToTailWs.y * wag);\n    bodyDistWs = min(bodyDistWs, fVerticalCapsule(vecToTailWs, 0.25, tailRadiusWs));\n    \n    if(bodyDistWs < minDistWs)\n    {\n        material = kMatImpBody;\n        minDistWs = bodyDistWs;\n    }\n    \n    // Glowing bit at the top\n    vec3 tailToGlowWs = vec3(0.0, 0.25, 0.0);\n    tailToGlowWs.xy = rotate2D(tailToGlowWs.xy, -0.25 * wag);\n    vec3 glowPosWs = tailStartWs + tailToGlowWs;\n    float glowDistWs = fSphere(positionWs - glowPosWs, 0.03);\n    if(glowDistWs < minDistWs)\n    {\n        minDistWs = glowDistWs;\n        material = kMatImpGlow;\n    }    \n    \n    return minDistWs;\n}\n\n// From https://iquilezles.org/articles/normalsSDF\nvec3 getNormalWS(vec3 p, float dt)\n{\n    int material;\n    vec3 normalWS = vec3(0.0);\n    for( int i = NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        float dist = fSDF(p + e * dt, material);\n        normalWS += e*dist;\n    }\n    return normalize(normalWS);\n}\n\nvec3 getBackgroundLight(vec3 directionWs, float blur)\n{\n    vec3 colourSrgb = textureLod(iChannel0, directionWs, blur * 10.0).rgb;\n    return pow(colourSrgb, vec3(2.2));\n}\n\n// Ambient diffuse approximation, use the cubemap at the highest mip\n// Also sneak in some table lighting\nvec3 getDiffuseLight(vec3 directionWs)\n{\n    vec3 light = pow(textureLod(iChannel0, directionWs, 10.0).rgb, vec3(2.2));\n    \n    // Do approximated table diffuse lighting\n    vec3 upLight = pow(textureLod(iChannel0, directionWs, 10.0).rgb, vec3(2.2));\n    vec3 tableAlbedo = pow(textureLod(iChannel1, vec2(0.5), 10.0).rgb, vec3(2.2));\n    light = mix(light, tableAlbedo * upLight, clamp(-directionWs.y + 0.4, 0.0, 1.0));\n    \n    return light;\n}\n\n// Add a ray to the ray list, unless we're out of rays, in which case return the background light\nvec3 addRayOrGetBackground(vec3 originWs, vec3 directionWs, float weight,\n    inout Ray[kMaxRayCount] rays, inout int rayCount)\n{\n    if(rayCount < kMaxRayCount)\n    {\n        rays[rayCount].directionWs = directionWs;\n        rays[rayCount].originWs = originWs;         \n        rays[rayCount].weight = weight;\n        ++rayCount;\n        return vec3(0.0);\n    }\n    else\n    {\n        return abs(weight) * getBackgroundLight(directionWs, 0.0);\n    }\n}\n\nconst float kSurfaceSkipDtWs = 0.0025;\n\n// Do lighting or add new rays to trace (for bounce reflection/refraction)\nvec3 processRay(vec3 rayOriginWs, vec3 rayDirectionWs, float rayLengthWs, float totalRayLengthWs,\n    int material, float incomingWeight,\n    inout Ray[kMaxRayCount] rays, inout int rayCount)\n{\n    vec3 hitPosWs = rayOriginWs + rayDirectionWs * rayLengthWs;\n    float fresnelF0 = 0.04;\n    if(material == kMatSky)\n    {\n        return incomingWeight * getBackgroundLight(rayDirectionWs, 0.0);\n    }\n    else\n    {\n        vec3 normalWs, albedo;\n        if(material == kMatSphereAirToGlass) \n        {\n            normalWs = normalize(hitPosWs - kSpherePosWs);   \n        }\n        else if(material == kMatSphereGlassToAir) \n        {\n            normalWs = -normalize(hitPosWs - kSpherePosWs);   \n        }\n        else if(material == kMatTable)\n        {\n            // Compute (approximated) pixel derivative\n            float uvDt = 1.0/iResolution.x;\n            float rayConeWidthAtUnitLength = uvDt / kFocalLengthWs;\n            \n            float rayConeProjectedSizeWs = rayConeWidthAtUnitLength * totalRayLengthWs\n                / max(0.0001, -rayDirectionWs.y);\n            \n            vec2 der = vec2(rayConeProjectedSizeWs) / 4.0;\n            vec3 texColourSrgb = textureGrad(iChannel1, hitPosWs.xz / 4.0, der, der).rgb;\n            albedo = pow(texColourSrgb, vec3(2.2));\n            normalWs = normalize(vec3(0.0, 1.0, 0.0) + 0.2 * vec3(1.0, 0.0, 1.0) * (albedo.g - 0.075));\n        }\n        else if(material >= kMatImpBody) // All imp materials\n        {\n            normalWs = getNormalWS(hitPosWs, 0.01);\n            albedo = (material == kMatImpBody) ? vec3(1.0, 0.025, 0.15) : vec3(0.0);\n            albedo = (material == kMatImpEye) ? vec3(0.0) : albedo;\n            albedo = (material == kMatImpGlow) ? vec3(1.0) : albedo;\n        }\n        \n        float NoR = max(-dot(normalWs, rayDirectionWs), 0.0);\n        float fresnelReflectance = fresnelF0 + (1.0 - fresnelF0) * pow(1.0 - NoR, 5.0);\n        \n        vec3 reflectedDirWs = reflect(rayDirectionWs, normalWs);        \n        vec3 lighting = vec3(0.0);\n        vec3 diffuseLight = (material == kMatImpGlow) ? vec3(2.) : getDiffuseLight(normalWs);\n        \n        if(material == kMatSphereAirToGlass || material == kMatSphereGlassToAir) \n        { \n            float eta = (material == kMatSphereAirToGlass) ? kAirIoR / kGlassIoR : kGlassIoR / kAirIoR;\n            vec3 refractedRayDirWs = refract(rayDirectionWs, normalWs, eta);\n            // refract returns vec3(0.0) if internal reflection\n            // in this case, there is no refraction, only reflection\n            if(dot(refractedRayDirWs, refractedRayDirWs) > 0.01)\n            {\n                vec3 refractedOriginWs = hitPosWs + refractedRayDirWs * kSurfaceSkipDtWs; \n                // Try to add a refraction ray\n                float newWeight = incomingWeight * (1.0 - fresnelReflectance);\n                newWeight = (material == kMatSphereAirToGlass) ? -newWeight : newWeight;\n                lighting += addRayOrGetBackground(refractedOriginWs, refractedRayDirWs,\n                    newWeight, rays, rayCount);\n            }\n            else\n            {\n                // total internal reflection, no refracted ray\n                // the reflected ray (added below) is all we need\n                fresnelReflectance = 1.0;\n            }\n        }\n        else if(material >= kMatTable) // All opaque materials\n        {\n            if(material == kMatTable)\n            {\n                // Do FAKE diffuse caustics from the sphere\n                // Tracing diffuse rays sampled from a cosine distribution would be better\n                // but without temporal accumulation, that's just too noisy.\n                vec3 vecToSphereWs  = kSpherePosWs - hitPosWs;\n                float sqSphereDistWs = dot(vecToSphereWs, vecToSphereWs);\n                vec3 dirToSphereWs = normalize(vecToSphereWs);\n                \n                vec3 causticsLight = getBackgroundLight(dirToSphereWs, 0.15 + sqSphereDistWs * 0.15);\n                causticsLight *= causticsLight * 2.0;\n                \n                // Fake caustic occlusion from the imp\n                float impShadow = smoothstep(0.02, 0.2, 1.0 - dirToSphereWs.y);\n                causticsLight *= impShadow;\n                \n                diffuseLight += causticsLight * pow(max(0.0, dirToSphereWs.y), 4.0);\n            }\n            \n            lighting += incomingWeight * (1.0 - fresnelReflectance) * albedo.rgb * diffuseLight;\n        }\n        \n        vec3 reflectedRayOriginWs = hitPosWs + reflectedDirWs * kSurfaceSkipDtWs;\n        \n        // Try to add a reflection ray\n        float newWeight = incomingWeight * fresnelReflectance;\n        newWeight = (material == kMatSphereGlassToAir) ? -newWeight : newWeight;\n        lighting += addRayOrGetBackground(reflectedRayOriginWs, reflectedDirWs,\n               newWeight, rays, rayCount);\n        \n        \n        return lighting;\n    }\n}\n\n// March to find the intersection with the imp\nfloat marchSdfDepth(vec3 rayOriginWs, vec3 rayDirectionWs, out int outMaterial)\n{    \n    float rayLengthWs = 0.0;\n    \n    for(int i = NON_CONST_ZERO; i < 32; ++i)\n    {\n        vec3 positionWs = rayOriginWs + rayDirectionWs * rayLengthWs;\n        float distWs = fSDF(positionWs, outMaterial);\n        rayLengthWs += distWs;\n        \n        if(abs(distWs) < 0.001)\n        {\n            return rayLengthWs;\n        }\n    }\n    \n    outMaterial = kMatSky;\n    return 999999.0;\n}\n\n// Trace the sphere and table\nfloat traceSceneDepth(vec3 rayOriginWs, vec3 rayDirectionWs, out int outMaterial)\n{\n    vec2 sphereDistsWs = rayVsSphere(rayOriginWs, rayDirectionWs, kSpherePosWs, 1.0);\n    \n    outMaterial = kMatSky;\n    \n    if(sphereDistsWs.x > 0.0)\n    {\n        outMaterial = kMatSphereAirToGlass;\n        return sphereDistsWs.x;\n    }\n    else if(sphereDistsWs.y > 0.0)\n    {\n        outMaterial = kMatSphereGlassToAir;\n        return sphereDistsWs.y;\n    } \n    else\n    {\n        float tableDistWs = rayVsTable(rayOriginWs, rayDirectionWs);\n        if(tableDistWs > 0.0)\n        {\n            outMaterial = kMatTable;\n            return tableDistWs;   \n        }\n    }\n}\n\n// The main ray tracing\nvec3 traceLighting(vec3 rayOriginWs, vec3 rayDirectionWs)\n{\n    Ray rays[kMaxRayCount];\n    int rayCount = 1;\n    rays[0].originWs = rayOriginWs;\n    rays[0].directionWs = rayDirectionWs;\n    rays[0].weight = 1.0;\n    \n    vec3 lighting = vec3(0.0);\n    \n    float totalRayLengthWs = 0.0;\n    \n    for(int rayIndex = NON_CONST_ZERO; rayIndex < rayCount; ++rayIndex)\n    {\n        // Trace sphere & table\n        int material;\n        float rayLengthWs = traceSceneDepth(rays[rayIndex].originWs, rays[rayIndex].directionWs, \n            /*out*/material);    \n        \n        // March sdf inside sphere\n        int sdfMaterial;\n        float sdfRayLengthWs = marchSdfDepth(rays[rayIndex].originWs,rays[rayIndex].directionWs, \n            /*out*/sdfMaterial);            \n        if(rayLengthWs == 0.0 || rayLengthWs > sdfRayLengthWs)\n        {\n            material = sdfMaterial;\n            rayLengthWs = sdfRayLengthWs;\n        }\n        \n        totalRayLengthWs += rayLengthWs;\n        lighting += processRay(rays[rayIndex].originWs,rays[rayIndex].directionWs, rayLengthWs,\n            totalRayLengthWs, material, abs(rays[rayIndex].weight), rays, rayCount);\n    }    \n    \n    return lighting;\n}\n\n// Basic x/(1+x) tomemapping\nvec3 reinhard(vec3 value)\n{\n    return value / (vec3(1.0) + value);\n}\n\n// A twist on the plain reinhard tonemapping that doesn't suck out the light as much\nvec3 poweredReinhard(vec3 value)\n{\n    float maxRange = 1.0;\n    vec3 power = vec3(2.0);\n    return pow(reinhard(pow(value / maxRange, power)), 1.0 / power) * maxRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseSnorm = ((iMouse.xy / iResolution.xy) * 2.0 - vec2(1.0, 1.0));\n    if(iMouse.xy == vec2(0)) // Centre the camera by default\n    {\n        mouseSnorm *= 0.0;\n    }\n    \n    vec3 cameraPosWs = vec3(0.0, 0.25, -4.0);\n    vec3 cameraTargetWs = vec3(0.0, 1.0, 0.0);\n    \n    // Mouse rotation\n    cameraPosWs.yz = rotate2D(cameraPosWs.yz, -(1.0 + mouseSnorm.y) * kPI * 0.15);\n    cameraPosWs.xz = rotate2D(cameraPosWs.xz, mouseSnorm.x * kPI * 0.5);\n\n    // Screen\n    vec3 cameraForwardWs = normalize(cameraTargetWs - cameraPosWs);\n    vec3 cameraRightWs = normalize(cross(vec3(0.0, 1.0, 0.0), cameraForwardWs));\n    vec3 cameraUpWs = cross(cameraForwardWs, cameraRightWs);\n\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 posNdc = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n    vec3 posOnCameraPlaneWs = cameraPosWs + kFocalLengthWs * cameraForwardWs\n        + cameraRightWs * posNdc.x + cameraUpWs * posNdc.y * aspectRatio;\n    \n    vec3 rayDirectionWs = normalize(posOnCameraPlaneWs - cameraPosWs);\n    vec3 rayOriginWs = cameraPosWs;\n    \n    vec3 lighting = traceLighting(rayOriginWs, rayDirectionWs);\n    \n    //Tonemap\n    vec3 colour = poweredReinhard(2.5 * lighting);\n    \n    // Shadertoy needs to output an srgb colour\n    fragColor.rgb = pow(colour, vec3(1.0/2.2));\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flycRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[711, 755, 842, 842, 1174], [1176, 1176, 1227, 1227, 1531], [1533, 1533, 1584, 1584, 1631], [1633, 1633, 1685, 1685, 1744], [1746, 1746, 1789, 1789, 1951], [1953, 1953, 2000, 2043, 4605], [4607, 4658, 4694, 4694, 4983], [4985, 4985, 5040, 5040, 5156], [5158, 5264, 5304, 5304, 5709], [11298, 11345, 11426, 11426, 11824], [11826, 11856, 11939, 11939, 12518], [12520, 12544, 12603, 12603, 13743], [13745, 13774, 13801, 13801, 13843], [13845, 13930, 13964, 13964, 14100], [14102, 14102, 14159, 14159, 15521]], "test": "untested"}
{"id": "stVcR1", "name": "7 layers across time", "author": "lomateron", "description": "click to paint\n7 layers across time of 3x3+4 pixel grids\nnext will be 15 layers\n", "tags": ["automata"], "likes": 4, "viewed": 209, "published": 3, "date": "1660967700", "time_retrieved": "2024-07-30T16:35:09.859580", "image_code": "#define A(u) texelFetch(iChannel0,ivec2(u),0)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    uint b = floatBitsToUint(a.x)&255U;\n    int i = iFrame&7;\n    b = (b>>i)|(b<<(8-i));\n    fragColor = cos(float(b&255U)*77.77777+vec4(1,2,3,4))*.5+.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texelFetch(iChannel0,ivec2(u),0)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    uint a = floatBitsToUint(A(u+vec2( 1, 0)).x);\n    uint b = floatBitsToUint(A(u+vec2( 0, 1)).x);\n    uint c = floatBitsToUint(A(u+vec2(-1, 0)).x);\n    uint d = floatBitsToUint(A(u+vec2( 0,-1)).x);\n    uint e = floatBitsToUint(A(u+vec2( 1, 1)).x);\n    uint f = floatBitsToUint(A(u+vec2(-1, 1)).x);\n    uint g = floatBitsToUint(A(u+vec2( 1,-1)).x);\n    uint h = floatBitsToUint(A(u+vec2(-1,-1)).x);\n    uint i = floatBitsToUint(A(u+vec2( 0, 0)).x);\n    uint j = floatBitsToUint(A(u+vec2( 2, 0)).x);\n    uint k = floatBitsToUint(A(u+vec2( 0, 2)).x);\n    uint l = floatBitsToUint(A(u+vec2(-2, 0)).x);\n    uint m = floatBitsToUint(A(u+vec2( 0,-2)).x);\n    uint o = \n    +((a>>0U)&1U) +((b>>0U)&1U) +((c>>0U)&1U) +((d>>0U)&1U) +((e>>0U)&1U) +((f>>0U)&1U) +((g>>0U)&1U) +((h>>0U)&1U) +((i>>0U)&1U)   +((j>>0U)&1U) +((k>>0U)&1U) +((l>>0U)&1U) +((m>>0U)&1U)\n    +((a>>1U)&1U) +((b>>1U)&1U) +((c>>1U)&1U) +((d>>1U)&1U) +((e>>1U)&1U) +((f>>1U)&1U) +((g>>1U)&1U) +((h>>1U)&1U) +((i>>1U)&1U)   +((j>>1U)&1U) +((k>>1U)&1U) +((l>>1U)&1U) +((m>>1U)&1U)\n    +((a>>2U)&1U) +((b>>2U)&1U) +((c>>2U)&1U) +((d>>2U)&1U) +((e>>2U)&1U) +((f>>2U)&1U) +((g>>2U)&1U) +((h>>2U)&1U) +((i>>2U)&1U)   +((j>>2U)&1U) +((k>>2U)&1U) +((l>>2U)&1U) +((m>>2U)&1U)\n    +((a>>3U)&1U) +((b>>3U)&1U) +((c>>3U)&1U) +((d>>3U)&1U) +((e>>3U)&1U) +((f>>3U)&1U) +((g>>3U)&1U) +((h>>3U)&1U) +((i>>3U)&1U)   +((j>>3U)&1U) +((k>>3U)&1U) +((l>>3U)&1U) +((m>>3U)&1U)\n    +((a>>4U)&1U) +((b>>4U)&1U) +((c>>4U)&1U) +((d>>4U)&1U) +((e>>4U)&1U) +((f>>4U)&1U) +((g>>4U)&1U) +((h>>4U)&1U) +((i>>4U)&1U)   +((j>>4U)&1U) +((k>>4U)&1U) +((l>>4U)&1U) +((m>>4U)&1U)\n    +((a>>5U)&1U) +((b>>5U)&1U) +((c>>5U)&1U) +((d>>5U)&1U) +((e>>5U)&1U) +((f>>5U)&1U) +((g>>5U)&1U) +((h>>5U)&1U) +((i>>5U)&1U)   +((j>>5U)&1U) +((k>>5U)&1U) +((l>>5U)&1U) +((m>>5U)&1U)\n    +((a>>6U)&1U) +((b>>6U)&1U) +((c>>6U)&1U) +((d>>6U)&1U) +((e>>6U)&1U) +((f>>6U)&1U) +((g>>6U)&1U) +((h>>6U)&1U) +((i>>6U)&1U)   +((j>>6U)&1U) +((k>>6U)&1U) +((l>>6U)&1U) +((m>>6U)&1U);\n    a = (16U*0U+1U)*(16U*8U*16U*8U)+(16U*0U+5U);\n    //a = a&(~(1U<<0U));\n    o = (i<<1U) | ((a>>(o&31U))&1U);\n    \n    vec2  v = (u        *2.-iResolution.xy)/iResolution.y;\n    vec2  w = (iMouse.xy*2.-iResolution.xy)/iResolution.y-v;\n    float r = fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*5467.5678)*256.;\n    if(iFrame==0)\n    {\n        r*= step(dot(v,v),.2);\n        o = uint(r);\n    }\n    if(iMouse.z>.5 && dot(w,w)<.001)\n    {\n        o = uint(r);\n    }\n    fragColor = vec4(uintBitsToFloat(o));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 286]], "test": "untested"}
{"id": "NtVyzh", "name": "Smoke Man", "author": "MysteryPancake", "description": "Simple directional blur effect", "tags": ["water", "smoke", "liquid", "man", "smoking"], "likes": 12, "viewed": 416, "published": 3, "date": "1660930824", "time_retrieved": "2024-07-30T16:35:10.615559", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(0.0);\n    \n    const vec3 target = vec3(0.0, 1.0, 0.0); // Find green\n    const float threshold = 0.5; // Controls target color range\n    const float softness = 0.3; // Controls linear falloff\n  \n    const float steps = 64.0;\n    for (float i = 0.0; i < steps; i++) {\n    \n        float percent = i / steps;\n        vec2 offset = vec2(sin(iTime * 8.0 - uv.y * 24.0) * percent * 0.15, percent);\n        \n        // Color key\n        vec4 col = texture(iChannel0, uv - offset * 0.5);\n        float diff = distance(col.xyz, target) - threshold;\n        float factor = clamp(diff / softness, 0.0, 1.0);\n        \n        // Tint\n        vec4 tint = mix(col, vec4(0.0, 0.0, 1.0, 0.0), percent);\n        \n        fragColor = max(fragColor, tint * factor * (1.0 - percent));\n    }\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 894]], "test": "untested"}
{"id": "7tVyzR", "name": "Earth from neural network", "author": "FabriceNeyret2", "description": "grabbed from https://shadertoy.com/view/sldyWl\ndata from https://github.com/harry7557558/Graphics/blob/master/fitting/neural-earth.ipynb\nmouse.y = depth in/out Earth", "tags": ["earth", "neural"], "likes": 22, "viewed": 557, "published": 3, "date": "1660899924", "time_retrieved": "2024-07-30T16:35:11.372535", "image_code": "// Earth Color neural network https://github.com/harry7557558/Graphics/blob/master/fitting/neural-earth.ipynb\n// grabbed from https://shadertoy.com/view/sldyWl\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0))) \n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2 R = iResolution.xy;\n    U = ( U+U - R ) / R.y;\n    vec3 P = vec3(U,sqrt(1.-dot(U,U)));      // 3D location\n    P.yz *= rot(.5);                         // rotations\n    P.xz *= rot(-iTime);\n    if (iMouse.z > 0.) P *= 2.*iMouse.y/R.y; // mouse.y = depth in/out Earth\n    O.rgb = mapEarth(P.zxy);                 // Earth 3D texture\n // O /= length(O.rgb);                      // chrominance + sat. only\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Earth Color neural network https://github.com/harry7557558/Graphics/blob/master/fitting/neural-earth.ipynb\n// grabbed from https://shadertoy.com/view/sldyWl\n\n/* Siren neural network. cf  https://www.vincentsitzmann.com/siren/    https://medium.com/@sallyrobotics.blog/sirens-implicit-neural-representations-with-periodic-activation-functions-f425c7f710fa\n   Hidden layers:     sine activation\n   Last hidden layer: sigmoid activation\n   Output layer:      sigmoid activation\n*/\n\n#define sigmoid(x)     1./(1.+exp(-(x)))\n//#define sigmoid(x)   clamp(x+.5,0.,1.)\n//#define sigmoid(x)   .5+.5*sin(x)\n\nvec3 mapEarth(vec3 q) { // 491 coefficients\n  vec4   p = vec4(q,1),\n  // (12, 3) (12,)\n       v00 = sin( mat4(2.18,2.07,-.05,.04 , -1.16,2.08,1.81,-.2  , -.05,.05,-.81,-.96 , .59,-.09,-.03,-.77) *p ),\n       v01 = sin( mat4(-.53,.36,.87,-1.57 , -1.84,-2.31,-.71,1.15, .53,.02,-1.08,-.41 , .16,.15,-.68,-.43 ) *p ),\n       v02 = sin( mat4(.75,-2.02,-.46,2.03, -.64,1.16,-.56,-.29  , .75,.47,-.6,-.91   , -.69,-.53,.98,-.8 ) *p ),\n  // (12, 12) (12,)\n       v10 = sin( mat4(-1.98,2.1,-.12,-.7,-.17,.55,.35,-1.75,-.92,-.03,-.79,1.02,.21,-1.14,.01,1.08)*v00 + mat4(-.27,2.59,-.41,.37,-1.55,-.59,-1.15,.88,.8,.8,0,.19,.22,1.48,.66,.49            )*v01 + mat4(-1.7,-1.18,1.5,.63,-1.35,1.04,-.39,-.32,.68,2.29,-.28,-.68,-2.15,-1.66,-.37,-1.34)*v02 + vec4(-.22,-.5,-.02,1.34) ),\n       v11 = sin( mat4(1.09,1.62,-.72,2.4,.74,-.86,2.04,-.07,.65,-.85,1.16,.34,-1.85,1.28,1.14,.3  )*v00 + mat4(2.43,-2.37,1.71,-2.44,-.74,.51,-1.83,1.02,-.28,-.2,-2.83,1.08,-1.04,.83,.33,1.27)*v01 + mat4(.05,-.43,-.77,1.04,1.77,1.44,-2.19,1.4,-3.9,1.1,1.22,1.57,.48,.55,2.61,1.01      )*v02 + vec4(-.4,.69,-2.1,-.43)  ),\n       v12 = sin( mat4(-.15,.75,1.32,-.29,-.18,.21,.01,-2.14,.95,-1.85,1.95,-2.53,.94,.54,1.2,1.19 )*v00 + mat4(.31,-.66,1.91,-1.75,.87,-1.56,1.28,1.72,-.07,-1.4,-1.21,-.07,.96,-.56,-.28,1.24) *v01 + mat4(.93,-1.07,2.83,-1.15,-1.29,1.83,1.59,-.15,2.55,-1.7,-2.03,-2.1,.26,-.5,1.05,-.01 )*v02 + vec4(-1.11,.33,3.23,2.4) ),\n  // (12, 12) (12,)\n       v20 = sin( mat4(-1.22,1.04,-.4,.05,.61,-1.16,-1.25,-.9,-.41,-.48,-1.4,.6,-1.37,.45,-.1,-1.82)*v10 + mat4(-.53,-1.64,1.07,-.02,1.93,.9,.55,-2.21,1.2,1.01,-.92,-.92,.46,.11,-1.88,-2.65    )*v11 + mat4(-1.03,.62,-1.22,-.89,-2.27,-.92,-.59,.02,-.43,-1.38,2.93,1.32,2.02,.84,-.57,.91)*v12 + vec4(-.6,.73,-1.59,.64)    ),\n       v21 = sin( mat4(-3.2,.97,-.82,-.94,.42,-.26,-1.6,1.28,-.26,-2.17,.28,1.62,1.6,-.63,-1.1,.57 )*v10 + mat4(.81,1.76,-1.23,-1.59,-1.88,-.75,-.9,.13,-2.21,1.07,-.39,-1.54,-3.04,.5,-.56,-2.26)*v11 + mat4(-.98,-.73,.83,-2.97,-1.61,-.3,1.55,-2.04,1.46,.09,-.13,.88,-.18,.5,-.43,-.2    )*v12 + vec4(-.08,-2.18,-1.3,1.15) ),\n       v22 = sin( mat4(2,.27,.01,-.38,-.11,-.9,.38,-1.35,.3,3.89,-.1,.9,-1.36,-.66,-.52,-.22       )*v10 + mat4(-.09,-.52,.42,.15,2.85,.16,-.53,-1.15,.27,.32,.81,1.42,-.6,-.22,1.11,2.13        )*v11 + mat4(-1.96,-1.06,.06,.68,-.58,-1.41,.43,.43,-1.77,-.66,-1.72,-1.22,.19,1.11,1.15,.24)*v12 + vec4(.05,.85,-.72,-1.05)   ),\n  // (8, 12) (8,)\n       v30 = sigmoid( mat4(3.74,2.98,-2.85,1.67,2.69,2.42,-2,2.01,-6.28,-1.99,4.83,-1.36,-5.06,-3.07,1.08,-6.41)*v20 + mat4(-2.42,-.87,1.32,-.82,1.25,-6.41,-.49,-5.09,-.04,-.47,3.35,6.26,-3.75,-5.87,3.62,-3.36 )*v21 + mat4(-4.54,.41,-1.18,-3.14,-8.28,-.79,7.43,-2.98,8.06,-2.25,3.2,.48,-7.99,-3.18,1.12,-7.99  )*v22 + vec4(5.54,1.15,-2.06,2.02)),\n       v31 = sigmoid( mat4(4.2,-6.97,1.37,2.04,3.42,.97,4.22,1.71,-6.85,2.56,-4,-2.37,-2.77,-2.33,.46,-1.98    )*v20 + mat4(-2.43,1.87,-2.57,-1.06,-6.1,3.38,-2.83,-2.97,.16,9.4,-4.07,-.43,-4.72,4.07,-3.46,-3.17)*v21 + mat4(-1.52,5.93,-1.74,-.6,-3.53,-1.03,-2.08,-1.59,-2.03,6.98,-.7,-.64,-5.34,2.52,-2.22,-2.92)*v22 + vec4(.07,-4.84,.67,.98)   );\n  // (3, 8) (3,)\n  return vec3( sigmoid( dot(vec4(-.93,-3.13,1.01,-1.07),v30) + dot(vec4(-1.65,2.54,-1.78,5.45),v31) +.43 ),\n               sigmoid( dot(vec4(-.26,-2.16,.86,-.87)  ,v30) + dot(vec4(-1.08,2.09,-1.23,3.8) ,v31) +.01 ),\n               sigmoid( dot(vec4(1.31,-1.13,.97,-.65)  ,v30) + dot(vec4(-.61,1.37,-1.19,2.14) ,v31) -.71 )\n             );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 248, 248, 663]], "test": "untested"}
{"id": "7tGcRz", "name": "Spark Phoenix 2", "author": "fenix", "description": "*drag with mouse* *space to reset* Based on Spark Phoenix, https://www.shadertoy.com/view/ftdyDX\nDue to some users complaining about FPS and my inability to reproduce the problems, I removed the neighborhood solve and retuned the effect.", "tags": ["2d", "voronoi", "simulation", "particles", "flow", "liquid", "sph"], "likes": 33, "viewed": 555, "published": 3, "date": "1660859399", "time_retrieved": "2024-07-30T16:35:12.407767", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, attempting to approximate smoothed particle\n//  hydrodynamics. \n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles\n//  Buffer D applies temporal blur\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = sqrt(texelFetch(iChannel0, ivec2(fragCoord), 0));\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 50000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.003;\nconst float PARTICLE_REPEL_SIZE = 0.03;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nfloat linePointDist2(vec2 a,vec2 b, vec2 p, vec3 resolution)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2((p - b * h) * vec2(resolution.x / resolution.y, 1));                     // squared dist to segment\n}\n\nconst int NUM_WING_POINTS = 25;\nvec2 WING_POINTS[NUM_WING_POINTS] = vec2[](\n    vec2(-0.9,  0.8),\n    vec2(-0.65,  0.5),\n    vec2(-0.85,  0.45),\n    vec2(-0.55,  0.3),\n    vec2(-0.75,  0.125),\n    vec2(-0.45,  0.1),\n    vec2(-0.63,  -0.2),\n    vec2(-0.35, -0.1),\n    vec2(-0.51,  -0.45),\n    vec2(-0.25, -0.3),\n    vec2(-0.2, -0.3),\n    vec2(-0.1, -0.4),\n    vec2(-0.075, -0.6),\n    vec2(-0.175, -0.75),\n    vec2(-0.05, -0.7),\n    vec2(-0.15, -0.85),\n    vec2(-0.045, -0.8),\n    vec2(-0.05, -0.9),\n    vec2(-0.0, -0.85),\n    vec2(-0.0, 0.125),\n    vec2(-0.045, 0.0),\n    vec2(-0.125, -0.1),\n    vec2(-0.2, -0.0),\n    vec2(-0.3,  0.2),\n    vec2(-0.6,  0.6)\n);\n\nfloat sdPolygon( in vec2[NUM_WING_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_WING_POINTS-1; i<NUM_WING_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst int NUM_HEAD_POINTS = 9;\nvec2 HEAD_POINTS[NUM_HEAD_POINTS] = vec2[](\n    vec2(-0.0, -0.2),\n    vec2(0.0, 0.3),\n    vec2(-0.1, 0.4),\n    vec2(-0.2, 0.425),\n    vec2(-0.145, 0.5),\n    vec2(-0.05, 0.7),\n    vec2(0.15, 0.75),\n    vec2(0.25, 0.55),\n    vec2(0.2, 0.35)\n);\n\nfloat sdPolygon( in vec2[NUM_HEAD_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_HEAD_POINTS-1; i<NUM_HEAD_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\nfloat sdPhoenix(in vec2 p)\n{\n#if 1\n    float minDist = sdPolygon(WING_POINTS, p);\n    minDist = min(minDist, sdPolygon(WING_POINTS, vec2(-p.x, p.y)));\n    minDist = min(minDist, sdPolygon(HEAD_POINTS, p));\n    return minDist;\n#else\n    float minDist = sdBox(p, vec2(0.05, 0.1));\n    minDist = min(minDist, sdTriangle(p, vec2(-0.9, 0.9), vec2(-0.0, -0.0), vec2(-0.5, 0.9)));\n    minDist = min(minDist, sdTriangle(p, vec2( 0.9, 0.9), vec2(-0.0, -0.0), vec2( 0.5, 0.9)));\n    return minDist;\n#endif\n}\n\nvec2 normPhoenix(in vec2 p)\n{\n    const float DELTA = 0.001;\n    return vec2(sdPhoenix(p + vec2(DELTA, 0.0)) - sdPhoenix(p - vec2(DELTA, 0.0)),\n                sdPhoenix(p + vec2(0.0, DELTA)) - sdPhoenix(p - vec2(0.0, DELTA)));\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x + resolution.x / resolution.y);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    vec2 uv;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.0000);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.00005;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    fxParticle data = fxGetParticle(id);\n    vec4 state = texelFetch(iChannel2, ivec2(0), 0);\n    \n    if (dataType == POS_VEL)\n    {\n        if (iFrame == 0 || keyDown(32) || state.z > 0.0)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2(i / particlesPerRow, j / particlesPerRow) * 1.8 - 0.9) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.uv = vec2(data.pos.x * 0.5 + 0.5, data.pos.y * 0.5 + 0.5);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = (vec2(4.0, 2.0) * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.1 / sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n            \n            // downward force near tail to keep it from becoming empty, also creates firey heart\n            float ddist = length2(data.pos - vec2(0.0, -0.3));\n            if (ddist < 0.5)\n            {\n                force += 0.00000025 * vec2(0.0, -1.0) / sqrt(ddist);\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n            };\n            \n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            \n            vec2 pSpace = data.pos * vec2(iResolution.y / iResolution.x, 1.0);\n            float sdp = sdPhoenix(pSpace);\n            if (sdp >= 0.0)\n            {\n                force -= normPhoenix(pSpace) * 0.05;\n            }\n                   \n\n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos / dist;\n                    \n                    \n                    // Apply crazy auto-stirring force\n                    vec2 dir = vec2(1.0, 1.0);\n                    if (data.pos.x < 0.0) dir *= -1.0;\n                    data.vel += (1.0 - sdp) * 0.00004 * dir * vec2(deltaPos.y, -deltaPos.x) / dist;\n                    force += PARTICLE_REPEL * deltaPos * SPHgradKernel(dist / PARTICLE_REPEL_SIZE) / dist;\n                }\n            }       \n\n            \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            // Damping\n            data.vel -= data.vel * length2(data.vel) * 200.0;\n\n\n            // Clamping\n            float maxSpeed = 0.001 + smoothstep(0.0, 1.0, 1.-sdp) * 0.005; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Particle render\n\nconst float MAX_TEMP = 0.002;\n\nvec3 BlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = linePointDist2(p.pos, p.pos - 1.5 * p.vel, fragCoord, iResolution);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    vec3 color = BlackBody(length(p.vel));\n    fragColor.xyz += color * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n    \n        // Render neighbor lines\n    #if 0\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n            otherPos.x *= iResolution.y / iResolution.x;\n\n            if (length(otherPos - p.pos) < 0.1)\n            {\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += 10.*color * max(0.0, PARTICLE_SIZE * 0.3 - sqrt(distToLin)) / (PARTICLE_SIZE);\n            }\n        }\n    }\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Temporal blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(iResolution.xy, 0.0, 0.0);\n            return;\n        }\n        \n        vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n        if (iResolution.xy != state.xy)\n        {\n            state = vec4(iResolution.xy, 1.0, 0.0);\n        }\n        else\n        {\n            state.z = 0.0;\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    if (iFrame == 0) fragColor = vec4(0);\n    \n    vec4 newColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 oldColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    fragColor = oldColor * 0.95 + newColor;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGcRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[627, 627, 680, 680, 753]], "test": "untested"}
{"id": "NtyyRR", "name": "大龙猫 -Infinite Log Space Junkyard", "author": "totetmatt", "description": "Infinite Log Space Junkyard\nhttps://www.youtube.com/watch?v=yo-GVtMVlVM", "tags": ["logpolar"], "likes": 4, "viewed": 240, "published": 3, "date": "1660858460", "time_retrieved": "2024-07-30T16:35:13.172722", "image_code": "const vec2 sz = vec2(1.,1.73);\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat hexa(vec2 p){\n     \n    return max(dot(p=abs(p),sz*.5),p.x)-1.5;\n}\nvec3 ppp;\nvec2 sdf(vec3 p){\n    vec3 op = p;\n    p.xy *=rot(iTime*.05);\n   \n    float d,c=5./3.14;\n    p.xz = vec2(log(d=length(p.xz)),atan(p.x,p.z))/c;\n     p.x +=(-iTime*.05);\n    p.y/=d/=c;\n    ppp = p;\n    p = abs(p)-.5;\n    vec2 h;\n    h.x = 0.;\n    float sc=1.;\n    for(float i=0.;i++<5.;){\n          h.x =max(h.x, d*sc*min(hexa(p.yz),min(hexa(p.xz),hexa(p.xy))));\n          sc/=3.;\n          p=fract((p-1.)*.5)*6.-3.;\n          p +=sin(i*.785)*.1;\n          p =p.yzx;\n    }\n    h.x = max(abs(op.y)-1.5,h.x);\n    h.y = 1.;\n    return h;\n}\n\n#define q(s) s*sdf(p+s).x\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define gao(rp,n) (ao(rp,n,.2)+ao(rp,n,.5)+ao(rp,n,.7))/3.\nvec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv =( fragCoord.xy -.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(.01);\n    \n    vec3 ro=vec3(3.,2.,-5.),rt=vec3(0.);\n    vec3 z= normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n    vec3 light = vec3(1.,2.,-3.);\n    \n    vec3 rp=ro;\n    \n    for(float i=0.;i<128.;i++){\n    \n        vec2 d = sdf(rp);\n        rp+=rd*d.x;\n        if(d.x<.0001){\n            vec3 n = norm(rp,.001);\n            float dif = max(0.,dot(normalize(light-rp),n));\n            float sc = pow(max(0.,dot(rd,reflect(normalize(rp-light),n))),32.);\n            col = vec3(.7,.4,.4)*dif*(asin(sin(length((ppp)*500.5)))*.25+.6);\n            col = mix(vec3(.1,.1,.1)*2.*sc,col*gao(rp,n),dif);\n            break;\n        }\n    }\n    \n    \n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 49, 49, 96], [97, 97, 116, 116, 169], [180, 180, 197, 197, 714], [838, 838, 865, 865, 940], [941, 941, 996, 996, 1873]], "test": "untested"}
{"id": "stcyWl", "name": "Unintuitive Crystal", "author": "pb", "description": "triangular prism doing weird things with normals and refraction, it only looks cool when it is moving so don't pause it", "tags": ["refraction", "prism", "crystal"], "likes": 13, "viewed": 542, "published": 3, "date": "1660776027", "time_retrieved": "2024-07-30T16:35:13.928701", "image_code": "//philip.bertani@gmail.com\n//see Buffer A please\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n   \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 ro,rd,pp;\nmat3 rot;\nvec3 light;\nbool hitPrism;\nfloat totdist;\n#define pi 3.14159265\n\n\n//thanks iq\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nmat3 rot_xz_xy(float a1, float a2) {\n    //rotation matrices - can't live with'em, can't live without'em\n    //even the rodrigues formula is a matrix in the end...\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n                     \n    return mat3( c2*c1, s2, c2*s1,\n                -s2*c1, c2, -s2*s1,\n                  -s1,   0.,  c1 );\n}\n\nfloat dist_func01(vec3 p) {\n\n    hitPrism = false;\n    \n    vec3 q = rot*p;\n    float prism = sdTriPrism(q,vec2(1.,1.));\n\n    p = mod(p-2.,4.)-2.;\n\n    float dist = length(p) - .3;\n    \n    if ( prism  < dist ) {\n        dist = prism;\n        hitPrism = true;\n    }\n   \n    return dist;\n}\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .0001 * dpn; \n\n    vec3 df = dpn.xxx * dist_func01(p+dp.xxx) +\n              dpn.yyx * dist_func01(p+dp.yyx) +\n              dpn.xyy * dist_func01(p+dp.xyy) +\n              dpn.yxy * dist_func01(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n  \n    float  rf = .9;  // rf > 1.  causes rays to diverge behind lens\n    \n    float tt = mod(iTime,20.);\n\n    \n    light = normalize( vec3( -.5, 0., -1.) ) ;\n    xy = (2.*xy - iResolution.xy) / iResolution.y;\n    \n    ro = vec3(0.,0.,-2.5);\n    rd = normalize( vec3(xy,2.) );\n    \n    vec3 p = ro;\n    \n    rot = rot_xz_xy(iTime/3.,iTime/5.);\n    \n    float init_eps=1e-8;\n    float n=0.,dist,threshold=init_eps;\n    totdist=0.;\n    vec3 color=vec3(0.);\n    float pc = 0.;\n\n    for(;n<300.;n++) {\n        \n        dist = dist_func01(p);\n        \n        if ( dist < init_eps && hitPrism )  {\n\n            vec3 pp = p - 200.*dist*rd;  //first mistake (used to be -2)\n            vec3 nn = gradient(pp);\n            vec3 rd2 =  refract( rd, nn, rf);  //change ray direction\n            \n            p = pp + .25*rd2;  //second mistake  (used to be +.8)\n            \n            rd = rd2;\n            \n            color += vec3( 10.,3.,0.);\n            \n            pc += 1.;           \n        \n        }\n          \n        else if ( dist < threshold && !hitPrism ) {\n          \n            color += 3.*vec3(.3,.5,.8);\n            \n            vec3 nn = gradient(p+dist*rd) ;\n           \n            color *= max(0.,dot(nn,light));\n            \n            break;   \n           \n        }\n        \n        else {\n            p += dist * rd;\n        }\n        \n \n        totdist += dist;\n        threshold = init_eps * (1. + totdist*50. );\n \n  \n\n    }\n    \n    color *= exp(-totdist*totdist/500.);\n    \n    float sqpc = sqrt(pc);\n    color.r += .03*sqpc;\n    color.g += .02*sqpc;\n    \n    rgba = vec4(color,1.);\n    \n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 384, 441, 441, 915]], "test": "untested"}
{"id": "NttyWs", "name": "squar bomb blundergn", "author": "lomateron", "description": "3 layers across time of 5x5+4 pixel grid", "tags": ["automata"], "likes": 5, "viewed": 430, "published": 3, "date": "1660775837", "time_retrieved": "2024-07-30T16:35:14.696648", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    fragColor = cos(dot(a,vec4(1,2,4,8)*56.)+vec4(0,1,2,3));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n          uint r = M;\n    if(s>=32U){r = N;}\n    \n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((r>>(s&31U))&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.2);\n        o*= step(dot(v,v),dot(m,m)*.2);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n          uint r = M;\n    if(s>=32U){r = N;}\n    \n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((r>>(s&31U))&1U);\n\n\n    fragColor = o;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n          uint r = M;\n    if(s>=32U){r = N;}\n    \n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((r>>(s&31U))&1U);\n\n\n    fragColor = o;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n          uint r = M;\n    if(s>=32U){r = N;}\n    \n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((r>>(s&31U))&1U);\n\n\n    fragColor = o;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M (+8U*4U*8U*4U* 0U\\\n           +8U*4U*8U*    1U\\\n           +8U*4U*       7U\\\n           +8U*          3U\\\n           +             7U)\n#define N (3U<<0U)", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 198]], "test": "untested"}
{"id": "NldyDl", "name": "Hard Yet Flowing Techno", "author": "Geopin", "description": "VJ TECHNO BASIC REACTIVE", "tags": ["raymarch", "postprocessing", "techno", "vj"], "likes": 3, "viewed": 421, "published": 3, "date": "1660771914", "time_retrieved": "2024-07-30T16:35:15.439661", "image_code": "//Freshlov3 Online Browser Techno VJ \n\n// Cabbibo's HSV\nvec3 hsv(float h, float s, float v)\n\n\n//CHANGE THE H+VEC3 Values below to change the colours\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 1.0, 9.0, 2.0 ) / 0.9 ) * 1.8 ) - 1.0 ), 0.0, 0.9 ), s ) * v;\n}\n\nvoid mainImage(out vec4 f, in vec2 w)\n{\n    vec2 u = w/iResolution.xy;\n    vec4 col = vec4(0.);\n    float PSD = pow(abs(texture(iChannel1, vec2(.5)).r), 2.);\n    \n    for (int i = 0; i < 25; i++)\n    {\n        // adapted from by iq https://www.shadertoy.com/view/MsKGWR\n        vec2 offset = .05*cos( 0.1*float(i) + PSD + iTime + vec2(0,.1));\n        vec4 t = texture(iChannel0, u*.8 + offset + vec2(.01))*.3;\n        col += t*5.;\n    }\n    \n    col.rgb = hsv(col.x * .1 + iTime*.9 + PSD, 1., 1.);\n    f = col;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float eps = 0.01;\nconst float far = 100.;\n\nfloat map(vec3 p)\n{\n    p.z -= iTime;\n    return length(mod(p, 3.)-1.)-.8;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(eps,0.5);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(uv, 1.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    float t = 0.;\n    for (int i = 0; i < 10; i++)\n    {\n        float m = map(ro + rd * t);\n        t += m;\n        if (m < eps || t > far) break;\n    }\n \n    vec3 p = ro + rd * t;\n    vec3 n = calcNormal(p);\n    vec3 lp = vec3(5., 4., 5.);\n    vec3 ld = lp - p;\n    float len = length(ld);\n    ld /= len;\n    float diff = max(dot(ld, n), 0.);\n    vec3 col = vec3(1.) * diff;\n\tfragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 56, 150, 150, 276], [278, 278, 317, 317, 790]], "test": "untested"}
{"id": "ftccDj", "name": "Simple Strandbeest", "author": "oneshade", "description": "A simple 3D strandbeest.", "tags": ["simple", "robot", "strandbeest", "linkage", "quadruped", "theojansen"], "likes": 24, "viewed": 223, "published": 3, "date": "1660770509", "time_retrieved": "2024-07-30T16:35:16.176690", "image_code": "// Utilities\n#define PI 3.1415926536\n#define TAU 6.2831853072\n\nmat2 Rotate2D(in float angle) {\n    float co = cos(angle), si = sin(angle);\n    return mat2(co, si, -si, co);\n}\n\nvec2 solveJoint(in vec2 a, in vec2 b, in float ra, in float rb, in float config) {\n    vec2 ba = b - a;\n    float d2 = dot(ba, ba), d = sqrt(d2);\n    float offs = (d2 + ra * ra - rb * rb) / (2.0 * ra * d);\n    return a + (ba * offs + vec2(-ba.y, ba.x) * sqrt(1.0 - offs * offs) * config) * ra / d;\n}\n\n// SDFs\nfloat sdLine(in vec3 a, in vec3 b, in vec3 p) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdCylinder(in float h, in float r, in vec3 p) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Not exact\nfloat sdFlatCapsule(in float h, in float r, in float t, in vec3 p) {\n    return max(length(vec2(p.x - clamp(p.x, -h, h), p.y)) - r, abs(p.z) - t);\n}\n\nfloat sdBox(in vec3 b, in vec3 p) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdGear(in float r1, in float r2, in float t, in float h, in float n, in vec3 p) {\n    float teeth = (0.5 + 0.5 * cos(atan(p.y, p.x) * n)) * h;\n    float pr = length(p.xy);\n    return max(max(pr - r2 - teeth, abs(p.z) - t), r1 - pr); // Bad extrusion\n}\n\n// Scene\n#define add(dist, id) if (dist < scene.x) { scene = vec2(dist, id); }\nvec2 map(in vec3 p) {\n    // Treadmill\n    vec2 scene = vec2(sdFlatCapsule(16.0, 2.0, 8.0, p + vec3(0.0, 10.4, 0.0)), 0);\n    add(sdFlatCapsule(16.0, 4.0, 1.5, vec3(p.x, p.y + 10.4, abs(p.z) - 9.5)), 1);\n\n    // Main body and axles\n    add(sdBox(vec3(8.0, 1.25, 3.8), p - vec3(0.0, 0.78, 0.0)) - 1.0, 2);\n    add(sdCylinder(5.2, 0.2, p - vec3(0.0, 0.78, 0.0)), 3);\n    add(sdCylinder(5.2, 0.2, vec3(abs(p.x) - 3.8, p.y - 0.78, p.z)), 3);\n\n    // Set crank angle and adjust it for each leg\n    float motorAngle = iTime * 5.0;\n    float crankAngle = motorAngle / 2.0;\n    if (p.x < 0.0) crankAngle = PI - crankAngle; // Offset back leg\n    if (p.z < 0.0) crankAngle += PI;\n\n    // Widthwise symmetry\n    p.z = abs(p.z) - 5.0;\n\n    // Driver gear\n    vec3 driverGearUv = p - vec3(0.0, 0.78, 0.0);\n    driverGearUv.xy *= Rotate2D(motorAngle + TAU / 20.0);\n    add(sdGear(0.2, 0.9, 0.2, 0.4, 10.0, driverGearUv), 4);\n\n    // Lengthwise symmetry\n    p.x = 7.5 - abs(p.x);\n\n    // Crank gears (the ones moving the legs)\n    vec3 crankGearUv = p - vec3(3.8, 0.78, 0.0);\n    crankGearUv.xy *= Rotate2D(crankAngle);\n    add(sdGear(0.2, 2.3, 0.2, 0.4, 20.0, crankGearUv), 4);\n\n    vec2 crankShaft = vec2(3.8, 0.78);\n    vec2 crank = crankShaft + vec2(cos(crankAngle), sin(crankAngle)) * 1.5;\n\n    vec2 fixedPivot = vec2(0.0);\n    vec2 top = solveJoint(crank, fixedPivot, 5.0, 4.15, -1.0);\n    add(sdLine(vec3(crank, 0.4), vec3(top, 0.4), p) - 0.2, 5);\n    add(sdLine(vec3(top, 0.0), vec3(fixedPivot, 0.0), p) - 0.2, 5);\n\n    vec2 hangPivot = solveJoint(crank, fixedPivot, 6.19, 3.93, 1.0);\n    add(sdLine(vec3(crank, 0.8), vec3(hangPivot, 0.8), p) - 0.2, 5);\n    add(sdLine(vec3(fixedPivot, 0.4), vec3(hangPivot, 0.4), p) - 0.2, 5);\n\n    vec2 swingPivot = solveJoint(top, fixedPivot, 5.58, 4.01, -1.0);\n    add(sdLine(vec3(top, 0.0), vec3(swingPivot, 0.0), p) - 0.2, 5);\n    add(sdLine(vec3(fixedPivot, 0.0), vec3(swingPivot, 0.0), p) - 0.2, 5);\n\n    vec2 knee = solveJoint(swingPivot, hangPivot, 3.94, 3.67, -1.0);\n    add(sdLine(vec3(swingPivot, 0.4), vec3(knee, 0.4), p) - 0.2, 5);\n    add(sdLine(vec3(knee, 0.0), vec3(hangPivot, 0.0), p) - 0.2, 5);\n\n    vec2 tip = solveJoint(hangPivot, knee, 4.90, 6.57, 1.0);\n    add(sdLine(vec3(hangPivot, 0.0), vec3(tip, 0.0), p) - 0.2, 5);\n    add(sdLine(vec3(knee, 0.0), vec3(tip, 0.0), p) - 0.2, 5);\n\n    return vec2(scene.x * 0.8, scene.y);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 k = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + k.xyy).x, map(p + k.yxy).x, map(p + k.yyx).x) - map(p).x);\n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialize output\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    // Default mouse position\n    if (iMouse.xy == vec2(0)) mouse = vec2(-0.15, -0.1);\n\n    // Initialize ray\n    vec3 ro = vec3(0.0, -5.0, 50.0);\n    vec3 rd = normalize(vec3(uv, -1.5));\n\n    // Rotate with mouse\n    mat2 hori = Rotate2D(-mouse.x * 3.14);\n    ro.xz *= hori;\n    rd.xz *= hori;\n\n    mat2 vert = Rotate2D(-mouse.y * 3.14);\n    ro.yz *= vert;\n    rd.yz *= vert;\n\n    vec3 color = texture(iChannel0, rd).rgb;\n\n    // Raymarch\n    float t = 0.0;\n    for (int i=0; i < 250; i++) {\n        vec3 p = ro + rd * t;\n        vec2 scene = map(p);\n        if (abs(scene.x) < 0.001) {\n            vec3 nor = getNormal(p);\n\n            //color = vec3(max(0.0, dot(-rd, nor)) * 0.8);\n            //color += max(0.0, dot(nor, normalize(vec3(0.0, 1.0, -2.0)))) * 0.2;\n            color = vec3(max(0.0, dot(nor, normalize(vec3(0.0, 5.0, 20.0) - p)))) * 0.75;\n            color += max(0.0, dot(nor, normalize(vec3(15.0, 10.0, 15.0) - p))) * 0.25;\n            color += max(0.0, dot(nor, normalize(vec3(-15.0, 10.0, -15.0) - p))) * 0.5;\n\n            // Treadmill texture\n            if (scene.y == 0.0) {\n                 p.y += 10.4; // Convert to object space\n\n                 vec2 treadUv = vec2(p.z + 8.0, 0.0);\n                 if (abs(p.x) < 16.0) treadUv.y = p.y > 0.0 ? p.x + 16.0 : 48.0 - p.x + TAU;\n                 else if (p.x > 16.0) treadUv.y = 32.0 + atan(p.x - 16.0, p.y) * 2.0;\n                 else if (p.x < -16.0) treadUv.y = 64.0 + TAU + atan(-p.x - 16.0, -p.y) * 2.0;\n                 treadUv /= vec2(16.0, 64.0 + 2.0 * TAU);\n\n                 treadUv *= vec2(5.0, 20.0);\n                 treadUv.y += mod(iTime * 1.5, 20.0);\n\n                 color += 0.1; // Ambient\n                 color *= vec2(mod(floor(treadUv.x + treadUv.y), 2.0), 0.0).rrg;\n            }\n\n            else if (scene.y == 1.0) color *= 0.1; // Sides of the treadmill\n            else if (scene.y == 3.0) color *= 0.0; // Axles\n            else if (scene.y == 4.0) color *= 0.15; // Gears\n            else if (scene.y == 5.0) color *= vec3(0.7, 0.3, 0.1); // Legs\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.x;\n    }\n\n    // Tonemap and output\n    fragColor = vec4(pow(color, vec3(0.65)), 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftccDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 94, 94, 174], [176, 176, 258, 258, 475], [477, 485, 532, 532, 640], [642, 642, 695, 695, 811], [813, 826, 894, 894, 974], [976, 976, 1011, 1011, 1101], [1103, 1103, 1190, 1190, 1360], [1441, 1441, 1462, 1479, 3817], [3819, 3819, 3846, 3846, 3972], [3974, 3982, 4037, 4062, 6460]], "test": "untested"}
{"id": "7tcyDl", "name": "Octahedron Raytrace", "author": "alaula", "description": "I figured out how to handle octahedron intersections", "tags": ["raytrace"], "likes": 1, "viewed": 181, "published": 3, "date": "1660754080", "time_retrieved": "2024-07-30T16:35:16.930674", "image_code": "#define CAMTAN 2.0\n#define DELTA 0.0001\n\nvec4 OctaHedron = vec4(0.5, 0.5, -1.0, 2.0);\nvec3 OcthColor = vec3(.1 , .7 , .2);\n\n#define OCTH(X) dot(abs(X),ones)\n#define CHECK(X) OCTH(ro+rd*prj.X)\nbool OctIntersect (in vec3 rd, in vec3 ro, in float OctSize){\n    vec3 prj = -ro/rd;  //ray distance from axis planes\n    vec3 ones = vec3(1.0);\n    return min(min(CHECK(x),CHECK(y)),CHECK(z)) <= OctSize; //if axis intersection is inside oct then so is the line\n}\n\n// I need to figure out a better way to implement this function\nfloat OctFindDist(in vec3 rd, in vec3 ro, in float OctSize){\n    vec3 prj = -ro/rd;  //ray distance from axis planes\n    vec3 ones = vec3(1.0);\n    prj = prj+ 1000.0*(vec3(CHECK(x) > OctSize,CHECK(y) > OctSize,CHECK(z) > OctSize)); //cull invalid points\n    float minimum = min(min(prj.x,prj.y),prj.z); // find nearest valid axis intersection\n    prj = ro + rd*(minimum - DELTA); //re-use variable\n    ones = sign(prj); //re-use variable\n    return minimum + (OctSize - dot(prj,ones))/dot(rd,ones); //step back from the axis plane to find the surface\n}\n\n#define DIFF(X) OCTH(p+DELTA*v.X)-d\nvec3 CalcNorm(vec3 p){\n    vec3 ones = vec3(1.0);\n    vec2 v = vec2(1.0,0.0);\n    float d = OCTH(p);\n    return normalize(vec3(DIFF(xyy), DIFF(yxy), DIFF(yyx)));\n}\n\nvec3 CalcRayDir(in vec2 fragCoord){\n    vec2 camOff = (fragCoord - 0.5*iResolution.xy)*(CAMTAN/iResolution.x);\n    vec2 camDir = vec2(cos(iTime/2.0),sin(iTime/2.0));\n    return vec3(camDir.xy,camOff.y)+camOff.x*vec3(camDir.y,-camDir.x,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = normalize(CalcRayDir(fragCoord));\n    vec3 ro = 10.0*vec3(-cos(iTime/2.0),-sin(iTime/2.0),0.2);\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec3 offset = vec3(0.0, 0.0, 4.0 -pow(mod(iTime,4.0)-2.0, 2.0));\n\n    // Time varying pixel color\n    vec3 col = vec3(.1,.2,.2);\n    \n    if (uv.y < -0.05){\n        vec2 fuv = (ro + rd*((+OctaHedron.z -ro.z - OctaHedron.w)/(rd.z))).xy;\n        float shade = smoothstep(0.0,1.0,length(OctaHedron.xyz +offset - vec3(fuv,-OctaHedron.w+OctaHedron.z))/4.0);\n        fuv = 0.5+sign(mod(fuv,2.0)-0.5)/2.0;\n        col = fuv.x*vec3(.2,.1,.1) + fuv.y*vec3(.3,.2,.1);\n        col *= shade;\n    }\n    \n    if(OctIntersect(rd, ro - OctaHedron.xyz - offset, OctaHedron.w)){\n        float dist = OctFindDist(rd,ro - OctaHedron.xyz - offset,OctaHedron.w);\n        float shade = 0.5 - dot(CalcNorm(ro + dist*rd - OctaHedron.xyz - offset),rd)/2.0;\n        col = shade*OcthColor;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 253, 253, 455], [457, 521, 581, 581, 1073], [1111, 1111, 1133, 1133, 1274], [1276, 1276, 1311, 1311, 1518], [1520, 1520, 1577, 1577, 2563]], "test": "untested"}
{"id": "Nt3yDs", "name": "Per-Pixel Dynamic Arrays", "author": "Lorenzo_Vannuccini", "description": "How about a small dynamic array that can be loaded / stored in a single pixel ?\n\nDS Array is an utility snippet that implements just that: per-pixel dynamic-size arrays in glsl.\nCheck out Common tab for more info.\n\nEnjoy! :)", "tags": ["vector", "container", "spatialhashing", "dynamicarray", "dynamicvector", "dynamicmemory", "spacepartitioning", "datatype"], "likes": 21, "viewed": 668, "published": 3, "date": "1660752838", "time_retrieved": "2024-07-30T16:35:18.037715", "image_code": "//\n//  How about a small dynamic array that can be loaded / stored in a single pixel ?\n// \n//  DS Array is an utility snippet that implements just that: per-pixel dynamic-size arrays in glsl.\n//  Now hold your horses, there are obviously some major limitations compared to classic containers from other languages:\n// \n//  - The maximum capacity a ds_array can grow is 9, so no more than 9 elements stored per vector / pixel.\n//  - A ds_array can only contain unsigned integers, and their values can only range from [0u, 9998u].\n//  - Code atm only works on desktop and it's far from being optimized (be wary)... but it's a start.\n// \n//  With these compromises in mind, a ds_array can be encoded / decoded in a single pixel on RGBA32F render textures,\n//  and passed to other render passes. This can come in real handy for use-cases such as spatial hashing / partitioning, \n//  tiled based deferred shading, OIT, etc.\n// \n//  This array is intended to be used as a small dynamic index buffer, its indices can look up about ~10k objects and the vector\n//  can grow / shrink at runtime. API is flexible and can be used to implement queues, sorting, and more.\n// \n// \n//  Find:\n// \n//  - Snippet & Doxygen in \"Common\" tab                <-- Copy/paste on your project to use, 10 lines snippet\n// \n//  - Test Cases Run / Usage examples in \"Buffer A\"    <-- The meat is here, should be fairly straightforward\n// \n//  - Test Cases Validation / Printing in \"Buffer B\"   <-- Note: only few test-cases are printed to ease compilation time,\n//                                                         select the ones you want\n// \n//  Enjoy! :)\n//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); // pass-through\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ******************************************************************************************** //\n//                                           DS Array  v.1.0.1                                  //\n// ******************************************************************************************** //\n/*\n    Copyright © 2022 Lorenzo Vannuccini, blackravenprod@gmail.com\n\n    This framework is provided 'as-is', without any express or implied\n    warranty. In no event will the authors be held liable for any damages\n    arising from the use of this framework.\n\n    Permission is granted to anyone to use this framework for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this framework must not be misrepresented; you must not\n        claim that you wrote the original framework. If you use this framework\n        in a product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not be\n        misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source distribution.\n*/\n\n#define USE_UIBTF_WORKAROUND // Hardware Bug Workaround: on some GPUs uintBitsToFloat() behaves inconsistently\n                             // due to internal optimizations. This workaround tricks the glsl compiler into thinking\n                             // input parameters to this function are uniform-dependent, which bypasses the issue.\n#define ds_array uvec4\n#ifdef  USE_UIBTF_WORKAROUND\n#define uintBitsToFloat(v)uintBitsToFloat(v+uint(mod(iDate.x,1e-6)))\n#endif\nuvec4 _ds_array_pack(const uint u[9]){return(u[0]+1u)/uvec4(1000u,100u,10u,1u)%10u+(u[1]+1u)/uvec4(1000u,100u,10u,1u)%10u*10u+(u[2]+1u)/uvec4(1000u,100u,10u,1u)%10u*100u+(u[3]+1u)/uvec4(1000u,100u,10u,1u)%10u*1000u+(u[4]+1u)/uvec4(1000u,100u,10u,1u)%10u*10000u+(u[5]+1u)/uvec4(1000u,100u,10u,1u)%10u*100000u+(u[6]+1u)/uvec4(1000u,100u,10u,1u)%10u*1000000u+(u[7]+1u)/uvec4(1000u,100u,10u,1u)%10u*10000000u+(u[8]+1u)/uvec4(1000u,100u,10u,1u)%10u*100000000u;}uint[9] _ds_array_unpack(const uvec4 u){return uint[9](1000u*(u.r%10u)+100u*(u.g%10u)+10u*(u.b%10u)+u.a%10u-1u,1000u*(u.r/10u%10u)+100u*(u.g/10u%10u)+10u*(u.b/10u%10u)+u.a/10u%10u-1u,1000u*(u.r/100u%10u)+100u*(u.g/100u%10u)+10u*(u.b/100u%10u)+u.a/100u%10u-1u,1000u*(u.r/1000u%10u)+100u*(u.g/1000u%10u)+10u*(u.b/1000u%10u)+u.a/1000u%10u-1u,1000u*(u.r/10000u%10u)+100u*(u.g/10000u%10u)+10u*(u.b/10000u%10u)+u.a/10000u%10u-1u,1000u*(u.r/100000u%10u)+100u*(u.g/100000u%10u)+10u*(u.b/100000u%10u)+u.a/100000u%10u-1u,1000u*(u.r/1000000u%10u)+100u*(u.g/1000000u%10u)+10u*(u.b/1000000u%10u)+u.a/1000000u%10u-1u,1000u*(u.r/10000000u%10u)+100u*(u.g/10000000u%10u)+10u*(u.b/10000000u%10u)+u.a/10000000u%10u-1u,1000u*(u.r/100000000u%10u)+100u*(u.g/100000000u%10u)+10u*(u.b/100000000u%10u)+u.a/100000000u%10u-1u);}int ds_array_size(const uvec4 u){int i=0;uint f=max(max(max(u.r,u.g),u.b),u.a);if(f==0u)i=0;else if(f==1u)i=1;else if(f==10u)i=2;else if(f==100u)i=3;else if(f==1000u)i=4;else if(f==10000u)i=5;else if(f==100000u)i=6;else if(f==1000000u)i=7;else if(f==10000000u)i=8;else if(f==100000000u)i=9;else i=max(int(floor(log(float(f))/2.30259))+1,0);return i;}void ds_array_clear(inout uvec4 u){u=uvec4(0u);}bool ds_array_empty(const uvec4 v){return ds_array_size(v)==0;}bool ds_array_full(const uvec4 v){return ds_array_size(v)>=9;}uint ds_array_remove(inout uvec4 i,in int u){int v=ds_array_size(i);u=clamp(u,0,v-1);uint f=uint(0);if(v>0){uint c[9]=_ds_array_unpack(i);--v;f=c[u];for(int t=u;t<=v;++t)c[t]=t<v?c[t+1]:-1u;i=_ds_array_pack(c);}return f;}int ds_array_insert(inout uvec4 i,in int u,const uint v){int c=ds_array_size(i);u=clamp(u,0,c);if(c<9){uint f[9]=_ds_array_unpack(i);for(int t=c;t>u;--t)f[t]=f[t-1];f[u]=v;++c;i=_ds_array_pack(f);}return c;}int ds_array_push(inout uvec4 u,const uint v){return ds_array_insert(u,9,v);}int ds_array_unshift(inout uvec4 v,const uint u){return ds_array_insert(v,0,u);}uint ds_array_pop(inout uvec4 v){return ds_array_remove(v,9);}uint ds_array_shift(inout uvec4 v){return ds_array_remove(v,0);}void ds_array_fill(inout uvec4 u,const uint v){int t=ds_array_size(u);uint i[9]=uint[9](-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u);for(int f=0;f<t;++f)i[f]=v;u=_ds_array_pack(i);}void ds_array_set(inout uvec4 i,const int v,const uint u){uint r[9]=_ds_array_unpack(i);r[v]=u;i=_ds_array_pack(r);}uint ds_array_get(const uvec4 i,in int v){uint u[9]=_ds_array_unpack(i);return u[v];}uint ds_array_front(const uvec4 i){return ds_array_get(i,0);}uint ds_array_back(const uvec4 i){int u=ds_array_size(i);return ds_array_get(i,u-1);}bool ds_array_resize(inout uvec4 i,in int v,in uint u){int t=ds_array_size(i);v=clamp(v,0,9);if(t!=v){uint f[9]=_ds_array_unpack(i);for(int r=min(v,t);r<9;++r)f[r]=r<v?u:-1u;i=_ds_array_pack(f);return true;}return false;}bool ds_array_resize(inout uvec4 i,in int u){return ds_array_resize(i,u,0u);}void ds_array_sort(inout uvec4 i){int v=ds_array_size(i);uint u[9]=_ds_array_unpack(i);for(int f=0;f<v-1;++f)for(int t=0;t<v-f-1;++t){if(u[t]>u[t+1]){uint o=u[t];u[t]=u[t+1];u[t+1]=o;}}i=_ds_array_pack(u);}void ds_array_reverse(inout uvec4 u){int v=ds_array_size(u);uint t[9]=_ds_array_unpack(u),i[9]=uint[9](-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u);for(int f=0;f<v;++f)i[f]=t[v-f-1];u=_ds_array_pack(i);}uvec4 ds_array_load(const vec4 c){return floatBitsToUint(c);}vec4 ds_array_store(const uvec4 u){return uintBitsToFloat(u);}uvec4 ds_array_make(){return uvec4(0);}uvec4 ds_array_make(const int v){uvec4 c=uvec4(0);ds_array_resize(c,v);return c;}uvec4 ds_array_make(const int c,const uint v){uvec4 i=uvec4(0);ds_array_resize(i,c,v);return i;}\n#define ds_array_overload(size) uvec4 ds_array_make(const uint v[size]){uvec4 u=uvec4(0);uint t[9]=uint[9](-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u);for(int e=0;e<size;++e)t[e]=min(v[e],9998u);return _ds_array_pack(t);}\nds_array_overload(1) ds_array_overload(2) ds_array_overload(3) ds_array_overload(4) ds_array_overload(5) ds_array_overload(6) ds_array_overload(7) ds_array_overload(8) ds_array_overload(9)\n\n// ---------------------------------------- API Doxygen ---------------------------------------- //\n\n/** Constructs a dynamic array\n *\n *  @param[in]  size  [OPTIONAL] The size of the array, must be in range [0, 9], default is 0 when unspecified\n *  @param[in]  fill  [OPTIONAL] Fills the array with this value, must be in range [0u, 9998u], default is 0u when unspecified\n *  @return           The dynamic array object\n */\nds_array ds_array_make(const int size, const uint fill);\n\n\n/** Constructs a dynamic array from a static array of arbitrary size\n *\n *  @param[in]  c_array  The input static array to copy, size must be in range [1, 9]\n *  @return              The dynamic array object\n */\nds_array ds_array_make(const uint c_array[9]);\n\n\n/** Returns the number of elements in the dynamic array\n *\n *  @param[in]  array  The input dynamic array\n *  @return            The size of the array, can range between [0, 9]\n */\nint ds_array_size(const ds_array array);\n\n\n/** Empties the dynamic array\n *\n *  @param[in, out]  array  The dynamic array to clear\n */\nvoid ds_array_clear(inout ds_array array);\n\n\n/** Checks if the dynamic array is empty\n *\n *  @param[in]  array  The input dynamic array\n *  @return            True is size is 0, false otherwise\n */\nbool ds_array_empty(const ds_array array);\n\n\n/** Checks if the dynamic array has reached maximum capacity\n *\n *  @param[in]  array  The input dynamic array\n *  @return            True is size is 9, false otherwise\n */\nbool ds_array_full(const ds_array array);\n\n\n/** Adds a new element at the back of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must not be full or the element won't be added\n *  @param[in]       value  The value of the new element\n *  @return                 The new size of the array\n */\nint ds_array_push(inout ds_array array, const uint value);\n\n\n/** Erases the last element of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @return                 The removed element's value\n */\nuint ds_array_pop(inout ds_array array);\n\n\n/** Adds a new element at the front of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must not be full or the element won't be added\n *  @param[in]       value  The value of the new element\n *  @return                 The new size of the array\n */\nint ds_array_unshift(inout ds_array array, const uint value);\n\n\n/** Erases the first element of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @return                 The removed element's value\n */\nuint ds_array_shift(inout ds_array array);\n\n\n/** Inserts a new element in the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must not be full or the element won't be added\n *  @param[in]       index  The index at which the element will be inserted\n *  @param[in]       value  The value of the new element\n *  @return                 The new size of the array\n */\nint ds_array_insert(inout ds_array array, in int index, const uint value);\n\n\n/** Erases an element from the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @param[in]       index  The index of the element to remove\n *  @return                 The removed element's value\n */\nuint ds_array_remove(inout ds_array array, in int index);\n\n\n/** Fills the dynamic array with a value\n *\n *  @param[in, out]  array  The input dynamic array, must not be empty or it won't be filled\n *  @param[in]       value  The value to fill the array with\n */\nvoid ds_array_fill(inout ds_array array, const uint value);\n\n\n/** Sets an element of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must already contain the element or it won't set\n *  @param[in]       index  The index of the element to set\n *  @param[in]       value  The new value of the element\n */\nvoid ds_array_set(inout ds_array array, const int index, const uint value);\n\n\n/** Reads an element from the dynamic array\n *\n *  @param[in]  array  The input dynamic array, must already contain the element\n *  @param[in]  index  The index of the element to read\n *  @return            The element's value\n */\nuint ds_array_get(const ds_array array, in int index);\n\n\n/** Reads the first element of the dynamic array\n *\n *  @param[in]  array  The input dynamic array, must not be empty\n *  @return            The array first element's value\n */\nuint ds_array_front(const ds_array array);\n\n\n/** Reads the last element of the dynamic array\n *\n *  @param[in]  array  The input dynamic array, must not be empty\n *  @return            The array last element's value\n */\nuint ds_array_back(const ds_array array);\n\n\n/** Resizes the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @param[in]       size   The new size of the array, must be in range [0, 9]\n *  @param[in]       fill   [OPTIONAL] Fills the new elements with this value, must be in range [0u, 9998u], default is 0u when unspecified\n *  @return                 True if the array was resized, false if the size was unchanged\n */\nbool ds_array_resize(inout ds_array array, in int size, in uint fill);\n\n\n/** Sorts the dynamic array in ascending order\n *\n *  @param[in, out]  array  The input dynamic array to sort\n */\nvoid ds_array_sort(inout ds_array array);\n\n\n/** Inverts the elements's order of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array to reverse\n */\nvoid ds_array_reverse(inout ds_array array);\n\n\n/** Packs the dynamic array into a single 32 bit vec4\n *\n *  @param[in]  array  The dynamic array to store\n *  @return            A 32 bit vec4 containing the encoded array, can be subsequently decoded via ds_array_load()\n */\nvec4 ds_array_store(const ds_array array);\n\n\n/** Unpacks the dynamic array from a single 32 bit vec4\n *\n *  @param[in]  encoded  The 32 bit vec4, which was encoded via ds_array_store()\n *  @return              The decoded dynamic array\n */\nds_array ds_array_load(const vec4 encoded);\n\n// --------------------------------------------------------------------------------------------- //\n", "buffer_a_code": "// ***************************************************************************************** //\n//                         Writes / Generates Tests-Cases Outputs                            //\n// ***************************************************************************************** //\n\n// This pass runs all kind of tests, some are stateless others are stateful.\n// Each test-case runs on a separate dynamic array, each is stored on a single pixel.\n// Generated results are then evaluated in next pass (\"Buffer B\"), and compared against expected results.\n\n#define TEST_CASE_CONSTRUCTOR_FILL  0 // tests dynamic array constructor and filling\n#define TEST_CASE_CONSTRUCTOR_IMPL  1 // tests dynamic array implicit constructor\n#define TEST_CASE_DYNAMIC_SIZE      2 // tests dynamic array insertions / resizing\n#define TEST_CASE_SORTING           3 // tests dynamic array elements sorting (bubble-sort)\n#define TEST_CASE_LOAD_REVERSE      4 // tests dynamic array elements reversing\n#define TEST_CASE_RUNTIME_QUEUE     5 // test dynamic arrays insertions / resizing at runtime\n#define TEST_CASES                  6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ds_array array = ds_array_make(); // make an empty dynamic array\n    \n    int pixelID = int(floor(fragCoord.x) + floor(fragCoord.y) * iResolution.x); // pixel index\n    switch(pixelID) // 1 array per pixel, so 1 test case per pixel\n    {\n        case TEST_CASE_CONSTRUCTOR_FILL:\n        {\n            // make a dynamic array of 4 elements, and fill it with value \"123\"\n            array = ds_array_make(4, 123u); // { 123, 123, 123, 123 }\n    \n        } break;\n        \n        case TEST_CASE_CONSTRUCTOR_IMPL:\n        { \n            // make a dynamic array from a static array\n            array = ds_array_make(uint[](0u, 123u, 456u, 789u, 1011u, 1213u, 1415u, 1617u, 9998u));\n    \n        } break;\n        \n        case TEST_CASE_DYNAMIC_SIZE:\n        { \n            uint i = 0u;\n            // fill the array incrementally until it reaches max capacity (9), stop at 99 in case something went wrong\n            while(!ds_array_full(array) && (++i < 99u)) ds_array_push(array, i); // { 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n            \n            // remove 8th element and store it in a temp variable\n            uint temp = ds_array_remove(array, 7); // { 1, 2, 3, 4, 5, 6, 7, 9 } | temp = 8\n            \n            // halve the array size \n            int size = ds_array_size(array);\n            ds_array_resize(array, size / 2); // { 1, 2, 3, 4 }\n\n            // insert the removed element between the 1st and 2nd elements\n            ds_array_insert(array, 1, temp); // { 1, 8, 2, 3, 4 }\n\n            // read 3rd element\n            temp = ds_array_get(array, 2); // { 1, 8, 2, 3, 4 } | temp = 2\n            \n            // multiply 3rd element by 3\n            ds_array_set(array, 2, temp * 3u); // { 1, 8, 6, 3, 4 }\n\n        } break;\n        \n        case TEST_CASE_SORTING:\n        { \n            // make a dynamic array from a static array\n            array = ds_array_make(uint[](345u, 0u, 3u, 9u, 1234u, 9876u, 1u, 10u, 9876u));\n            \n            // sort the array in ascending order\n            ds_array_sort(array); // { 0, 1, 3, 9, 10, 345, 1234, 9876, 9876 }\n            \n        } break;\n        \n        case TEST_CASE_LOAD_REVERSE:\n        { \n            // fetch TEST_CASE_SORTING's array\n            vec4 test_case_sorting_frag_color = texelFetch(iChannel0, ivec2(TEST_CASE_SORTING, 0), 0);\n            array = ds_array_load(test_case_sorting_frag_color); // { 0, 1, 3, 9, 10, 345, 1234, 9876, 9876 }\n            \n            // reverse the elements on the array\n            ds_array_reverse(array); // { 9876, 9876, 1234, 345, 10, 9, 3, 1, 0 }\n            \n        } break;\n        \n        case TEST_CASE_RUNTIME_QUEUE:\n        { \n            // fetch last state\n            array = ds_array_load(texelFetch(iChannel0, ivec2(TEST_CASE_RUNTIME_QUEUE, 0), 0));\n            \n            // the queue max length\n            const int queue_max_size = 8;\n            const uint queue_regrow_period = 16u; // regrow the queue every 16 insertions\n            \n            // value to insert in the queue\n            uint frameID = (uint(iFrame) / 20u) % 9999u; // make sure we don't go over 9998u (ds_array limit)\n            \n            // regrow queue every n insertions\n            if(frameID % queue_regrow_period == 0u) ds_array_clear(array);\n            \n            // check if new value is different form the queue's head (prevents spamming the same value every frame)\n            if(ds_array_empty(array) || ds_array_front(array) != frameID)\n            {\n                // if the value is new, push it to the front and grab the new queue size\n                int size = ds_array_unshift(array, frameID);\n                 \n                // if size exceeded the queue's limit, remove last element (first-in first-out)\n                if(size > queue_max_size) ds_array_pop(array);\n            }\n\n        } break;\n    }\n    \n    fragColor = ds_array_store(array); // store the whole array on this pixel\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ********************************************************************************** //\n//                      Reads Tests-Cases Outputs & Validate                          //\n// ********************************************************************************** //\n\n// This pass reads the generated test cases arrays, and compares them against expected results.\n// \n// This shader can be quite slow to compile due to the amazing procedural text, so I'd recommend printing\n// only a few test-cases at once, but feel free to uncomment them all if you're brave ;)\n \n// #define TEST_CASE_CONSTRUCTOR_FILL  0 // tests dynamic array constructor and filling\n// #define TEST_CASE_CONSTRUCTOR_IMPL  1 // tests dynamic array implicit constructor\n// #define TEST_CASE_DYNAMIC_SIZE      2 // tests dynamic array insertions / resizing\n// #define TEST_CASE_SORTING           3 // tests dynamic array elements sorting (bubble-sort)\n #define TEST_CASE_LOAD_REVERSE      4 // tests dynamic array elements reversing\n #define TEST_CASE_RUNTIME_QUEUE     5 // test dynamic arrays insertions / resizing at runtime\n \n #define TEST_CASES 6\n\n// -------------------------------------------------------------------------------------- //\n//              SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#                //\n//                      Creative Commons CC0 1.0 Universal (CC-0)                         //\n// -------------------------------------------------------------------------------------- //\n\n#define AUTO_FONT_SPACING\n#define FONT_SAMPLER iChannel1\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n    {\n        return 0.1f;\n    }\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )\n    {     \n        return 0.8f;\n    }\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n    \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n#ifdef FONT_EFFECTS    \n    float fShadowDistance;\n    vec2 vNormal;    \n#endif\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n#ifdef FONT_EFFECTS        \n    state.fShadowDistance = 1000000.0;\n    state.vNormal = vec2(0.0);    \n#endif    \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold;\n#ifdef FONT_EFFECTS        \n    bool bShadow;\n    vec2 vShadowOffset;\n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(16.0f, 16.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n#ifdef FONT_EFFECTS        \n    style.vShadowOffset = vec2(0);\n    style.bShadow = false;\n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n#ifdef FONT_EFFECTS            \n    vec3 vOutlineColor;\n    vec3 vHighlightColor;\n    float fOutlineWeight;\n    float fBevelWeight;\n    float fShadowSpread;\n    float fShadowStrength;\n    vec2 vLightDir;\n#endif    \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;\n#ifdef FONT_EFFECTS            \n    style.vOutlineColor = vec3(1);\n    style.vHighlightColor = vec3(0);\n    style.fOutlineWeight = 0.0f;\n    style.fBevelWeight = 0.0f;\n    style.fShadowSpread = 0.0f;\n    style.fShadowStrength = 0.0f;\n    style.vLightDir = vec2(-1.0f, -0.5f );\n#endif    \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;\n#ifdef FONT_EFFECTS            \n        state.vNormal = v.yz;\n#endif        \n    }\n\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fShadowDistance = SampleCharacter( iChar, vUV - style.vShadowOffset ).a;\n        if ( style.bBold )\n        {\n            fShadowDistance -= 0.025f;\n        }\n        \n        if ( fShadowDistance < state.fShadowDistance )\n        {\n            state.fShadowDistance = fShadowDistance;\n        }        \n    }\n#endif\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fSize = renderStyle.fFontWeight + renderStyle.fOutlineWeight;\n        float fBlendShadow = clamp( (state.fShadowDistance - fSize - renderStyle.fShadowSpread * 0.5) / -renderStyle.fShadowSpread, 0.0, 1.0);\n        color.rgb = mix( color.rgb, vec3(0.0), fBlendShadow * renderStyle.fShadowStrength);    \n    }\n\n    if ( renderStyle.fOutlineWeight > 0.0f )\n    {        \n        float fBlendOutline = GetFontBlend( state, style, renderStyle.fFontWeight + renderStyle.fOutlineWeight );\n        color.rgb = mix( color.rgb, renderStyle.vOutlineColor, fBlendOutline);\n    }\n#endif\n    \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n\t\n#ifdef FONT_EFFECTS            \n    if ( renderStyle.fBevelWeight > 0.0f )\n    {    \n        float fBlendBevel = GetFontBlend( state, style, renderStyle.fFontWeight - renderStyle.fBevelWeight );    \n        float NdotL = dot( state.vNormal, normalize(renderStyle.vLightDir ) );\n        float shadow = 1.0 - clamp(-NdotL, 0.0, 1.0f);\n        float highlight = clamp(NdotL, 0.0, 1.0f);\n        highlight = pow( highlight, 10.0f);\n        vCol = mix( vCol, vCol * shadow + renderStyle.vHighlightColor * highlight, 1.0 - fBlendBevel);\n    }\n#endif\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i< CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\nvoid PrintMessage( inout PrintState state, LayoutStyle style )\n{\n    uint strA[] = uint[] ( _H, _e, _l, _l, _o, _COMMA, _SP, _w, _o, _r, _l, _d, _PERIOD, _EOL );\n    ARRAY_PRINT( state, style, strA );\n\n    uint strB[] = uint[] ( _ITALON, _A, _B, _C, _1, _2, _3, _ITALOFF, _EOL );\n    ARRAY_PRINT( state, style, strB );\n    \n    uint strC[] = uint[] ( _BOLDON, _A, _B, _C, _1, _2, _3, _BOLDOFF, _SP );\n    ARRAY_PRINT( state, style, strC );\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\n#define PRINT_TEST_CASE(state, style, title, array, compare, size) { ARRAY_PRINT(state, style, title); bool passed = true; int l = ds_array_size(array); if(l != size) passed = false; PrintCh(state, style, _COLON); PrintEOL(state, style); PrintCh(state, style, _LSQB); Print(state, style, l); PrintCh(state, style, _RSQB); PrintCh(state, style, _LCUB); for(int i = 0; i < l; ++i){ uint val = ds_array_get(array, i); if(passed && val != compare[i]) passed = false; Print(state, style, int(val)); if(i < l - 1){ PrintCh(state, style, _COMMA); PrintCh(state, style, _SP); }} PrintCh(state, style, _RCUB); PrintCh(state, style, _SP); RenderFont(state, style, RenderStyle_Default(vec3(0.2)), fragColor.rgb); ClearPrintResult(state); if(passed){ ARRAY_PRINT(state, style, uint[](_BOLDON, _ITALON, _P, _a, _s, _s, _ITALOFF, _BOLDOFF)); } else { ARRAY_PRINT(state, style, uint[](_BOLDON, _ITALON, _F, _a, _i, _l, _ITALOFF, _BOLDOFF)); } PrintEOL(state, style); PrintEOL(state, style); RenderFont(state, style, RenderStyle_Default(vec3(0.2 + 0.55 * float(!passed), 0.2 + 0.45 * float(passed), 0.2)), fragColor.rgb); ClearPrintResult(state); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // load generated test cases (1 array per pixel)\n    ds_array array_tests[TEST_CASES];\n    for(int i = 0; i < TEST_CASES; ++i) array_tests[i] = ds_array_load(texelFetch(iChannel0, ivec2(i, 0), 0)); \n    \n    // expected results (to compare against)\n    uint TEST_CASE_CONSTRUCTOR_FILL_title[] = uint[](_C, _o, _n, _s, _t, _r, _u, _c, _t, _o, _r, _SP, _F, _i, _l, _l);\n    uint TEST_CASE_CONSTRUCTOR_FILL_expected[] = uint[](123u, 123u, 123u, 123u);\n    \n    uint TEST_CASE_CONSTRUCTOR_LAMBDA_title[] = uint[](_C, _o, _n, _s, _t, _r, _u, _c, _t, _o, _r, _SP, _L, _a, _m, _b, _d, _a);\n    uint TEST_CASE_CONSTRUCTOR_LAMBDA_expected[] = uint[](0u, 123u, 456u, 789u, 1011u, 1213u, 1415u, 1617u, 9998u);\n    \n    uint TEST_CASE_DYNAMIC_SIZE_title[] = uint[](_D, _y, _n, _a, _m, _i, _c, _SP, _S, _i, _z, _e);\n    uint TEST_CASE_DYNAMIC_SIZE_expected[] = uint[](1u, 8u, 6u, 3u, 4u);\n    \n    uint TEST_CASE_SORTING_title[] = uint[](_A, _s, _c, _e, _n, _d, _i, _n, _g, _SP, _S, _o, _r, _t);\n    uint TEST_CASE_SORTING_expected[] = uint[](0u, 1u, 3u, 9u, 10u, 345u, 1234u, 9876u, 9876u);\n    \n    uint TEST_CASE_LOAD_REVERSE_title[] = uint[](_L, _o, _a, _d, _SP, _AMP, _SP, _R, _e, _v, _e, _r, _s, _e);\n    uint TEST_CASE_LOAD_REVERSE_expected[] = uint[](9876u, 9876u, 1234u, 345u, 10u, 9u, 3u, 1u, 0u);\n    \n    const int queue_max_size = 8;\n    const uint queue_regrow_period = 16u;\n    uint frameID = (uint(iFrame) / 20u) % 9998u;\n    uint TEST_CASE_RUNTIME_QUEUE_title[] = uint[](_R, _u, _n, _t, _i, _m, _e, _SP, _Q, _u, _e, _u, _e);\n    uint TEST_CASE_RUNTIME_QUEUE_expected[queue_max_size];\n    for(int i = 0; i < queue_max_size; ++i) TEST_CASE_RUNTIME_QUEUE_expected[i] = frameID - uint(i);\n    int TEST_CASE_RUNTIME_QUEUE_expected_length = min(int(frameID % queue_regrow_period) + 1, queue_max_size);\n    \n    // print results\n    fragColor = vec4(0.9);\n   \n    vec2 vCanvasCoord = vec2( fragCoord.x - 8.0, iResolution.y - 9.0f - fragCoord.y ) * vec2(640.0, 360) * 1.35 / iResolution.xy;\n    vec2 vCanvasPixelSize = vec2(640.0, 360) / iResolution.xy;\n\n    PrintState state = PrintState_InitCanvas( vCanvasCoord, vCanvasPixelSize );\n\n    LayoutStyle style = LayoutStyle_Default();\n    PrintBeginNextLine(state, style);\n    \n    ARRAY_PRINT(state, style, uint[](_ITALON, _P, _e, _r, _MINUS, _P, _i, _x, _e, _l, _SP, _D, _y, _n, _a, _m, _i, _c, _SP, _A, _r, _r, _a, _y, _s, _ITALOFF, _EOL, _EOL));\n    ARRAY_PRINT(state, style, uint[](_BOLDON, _T, _e, _s, _t, _SP, _C, _a, _s, _e, _s, _COLON, _BOLDOFF, _EOL, _EOL));\n    RenderFont(state, style, RenderStyle_Default(vec3(0.2)), fragColor.rgb); \n    ClearPrintResult(state);\n    \n#ifdef TEST_CASE_CONSTRUCTOR_FILL\n    PRINT_TEST_CASE(state, style, TEST_CASE_CONSTRUCTOR_FILL_title, array_tests[TEST_CASE_CONSTRUCTOR_FILL], TEST_CASE_CONSTRUCTOR_FILL_expected, TEST_CASE_CONSTRUCTOR_FILL_expected.length());\n#endif\n\n#ifdef TEST_CASE_CONSTRUCTOR_LAMBDA\n    PRINT_TEST_CASE(state, style, TEST_CASE_CONSTRUCTOR_LAMBDA_title, array_tests[TEST_CASE_CONSTRUCTOR_LAMBDA], TEST_CASE_CONSTRUCTOR_LAMBDA_expected, TEST_CASE_CONSTRUCTOR_LAMBDA_expected.length()); \n#endif\n\n#ifdef TEST_CASE_DYNAMIC_SIZE\n    PRINT_TEST_CASE(state, style, TEST_CASE_DYNAMIC_SIZE_title, array_tests[TEST_CASE_DYNAMIC_SIZE], TEST_CASE_DYNAMIC_SIZE_expected, TEST_CASE_DYNAMIC_SIZE_expected.length()); \n#endif\n\n#ifdef TEST_CASE_SORTING\n    PRINT_TEST_CASE(state, style, TEST_CASE_SORTING_title, array_tests[TEST_CASE_SORTING], TEST_CASE_SORTING_expected, TEST_CASE_SORTING_expected.length()); \n#endif\n\n#ifdef TEST_CASE_LOAD_REVERSE\n    PRINT_TEST_CASE(state, style, TEST_CASE_LOAD_REVERSE_title, array_tests[TEST_CASE_LOAD_REVERSE], TEST_CASE_LOAD_REVERSE_expected, TEST_CASE_LOAD_REVERSE_expected.length()); \n#endif\n\n#ifdef TEST_CASE_RUNTIME_QUEUE\n    PRINT_TEST_CASE(state, style, TEST_CASE_RUNTIME_QUEUE_title, array_tests[TEST_CASE_RUNTIME_QUEUE], TEST_CASE_RUNTIME_QUEUE_expected, TEST_CASE_RUNTIME_QUEUE_expected_length); \n#endif\n}\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3yDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1637, 1637, 1692, 1692, 1770]], "test": "untested"}
{"id": "fl3yWl", "name": "gludlenblungler", "author": "lomateron", "description": "3 layers across time of 5x5+4 pixel grid", "tags": ["automata"], "likes": 7, "viewed": 223, "published": 3, "date": "1660750604", "time_retrieved": "2024-07-30T16:35:18.824611", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    fragColor = cos(dot(a,vec4(1,2,4,8)*56.)+vec4(0,1,2,3));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((M>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m));\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((M>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m));\n    }\n    fragColor = o;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((M>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m));\n    }\n    fragColor = o;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,1,1,0))+.1);\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((M>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m));\n    }\n    fragColor = o;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M (+8U*4U*8U*4U* (1U<<0U)\\\n           +8U*4U*8U*    3U\\\n           +8U*4U*       5U\\\n           +8U*          3U\\\n           +             7U)", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3yWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 198]], "test": "untested"}
{"id": "stccWl", "name": "Psychedelic Clouds", "author": "Geopin", "description": "Psy", "tags": ["psychedelic"], "likes": 3, "viewed": 197, "published": 3, "date": "1660748089", "time_retrieved": "2024-07-30T16:35:19.566627", "image_code": "// George Pinnegar 2022 Update Version\n// Made into third eye tye-dye by Cale Bradbury - @netgrind 2015\n// Edited version of https://www.shadertoy.com/view/MsfGzM Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MIC\n//comment out the line above to disable mic\n\n//#define GREY\n//uncomment out above to make grey\n\nfloat f(vec3 p) \n{ \n    p.z-=iTime*.5;\n    return length(cos(p)-.1*cos(9.*(p.z+.1*p.x-p.y)+iTime*2.0))-(0.9+sin(iTime)*.1); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iTime;\n    vec3 d = .5-vec3(fragCoord,1.)/iResolution.x;\n    d.y-=0.1;\n    d.x = abs(d.x);\n    vec3 o=d;\n    float l = length(d.xyz)*1.0;\n    float a = atan(d.y,d.x);\n    o.xy*= mat2(cos(i+sin(a+i)), sin(i*.5+a*l)*2.0, -sin(i+a),cos(i*d.z+l)+10.0);\n    for(int i=0;i<150;i++){\n    \tfloat m = 0.0;\n        #ifdef MIC\n        m = texture(iChannel0,vec2(1,float(i/20))).r;\n        #endif\n        o+=f(o+m)*(d);\n    }\n    o.z = length(o*d);\n    vec4 c = vec4(sin(i+abs((o-d)+length(o.xy*step(o.z,700.0))))*.3+.7,1.0);\n    #ifdef GREY\n    c.r = c.b+c.g+c.r;\n    c.r/=3.0;\n    c.r = pow(c.r,1.0);\n    c.rgb = c.rrr;\n    #endif\n    fragColor=c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stccWl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[393, 393, 411, 411, 519], [520, 520, 577, 577, 1231]], "test": "untested"}
{"id": "fl3cDl", "name": "test image input", "author": "lome", "description": "load image", "tags": ["cineshader"], "likes": 0, "viewed": 2872, "published": 3, "date": "1660724485", "time_retrieved": "2024-07-30T16:35:20.312632", "image_code": "//Click on iChannel0 > Textures > Page 2 > London \n// Alt + Enter to Apply changes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // get pixel information from uv location\n    vec4 texColor = texture(iChannel1, uv);\n    \n    // add code here\n\n    // Output to screen\n    fragColor = vec4(texColor);\n}\n\n\n\n// If you want a custom texture, checkout https://www.shadertoy.com/view/lsGG\n\n// or theses plugins\n// chrome\n// https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda?hl=en\n// mozilla\n// https://addons.mozilla.org/en-US/firefox/addon/shadertoy-custom-texures/\n\n/*\n\nMac Chrome:  cmd + opt + J \n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/88u2uo8dxdmgzxo/world2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/5rdhhnvnr5mochq/cloud2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/ojl5zoxgbdn5w5s/light2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n*/\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3cDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 140, 190, 406]], "test": "untested"}
{"id": "7ldyDf", "name": "Pseudeo 3D mandelbrot", "author": "mireq", "description": "Mandelbrot with blended gradients ported from C (https://github.com/adammaj1/Mandelbrot-set-with-blended-gradients) to GLSL with color palette", "tags": ["3d", "fractal", "mandelbrot"], "likes": 32, "viewed": 913, "published": 3, "date": "1660711116", "time_retrieved": "2024-07-30T16:35:21.122467", "image_code": "// Mandelbrot set with blended gradients ported to GLSL\n// https://github.com/adammaj1/Mandelbrot-set-with-blended-gradients\n\n// Rendered result: https://youtu.be/iXg-1cvxhr8 \n// Renderer: https://github.com/mireq/Shadertoy-renderer\n\n// Colorscheme 2 is rainbow\n#define COLORSCHEME 1\n\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 1\n#endif\n\n// Color schemes\n#if COLORSCHEME==1\n\n#define INVERTED_GRADIENT\n#define MAXITER_POT 300\n#define MAXITER_NORMAL 500\n\n#else\n\n#define MAXITER_POT 180\n#define MAXITER_NORMAL 300\n\n#endif\n\n// Interation end conditions\n#define ER_POT 100000.0\n#define ER_NORMAL 100.0\n\n// Constants\n#define M_PI 3.1415926535897932384626433832795\n\n// Number of points\n#define NUMBER_OF_POINTS 8\n\n// Coordinates with awesome places and zoom values\nconst vec3 coordinates[NUMBER_OF_POINTS] = vec3[NUMBER_OF_POINTS](\n\tvec3(-0.774693, 0.1242263647, 14.0),\n\tvec3(-0.58013, 0.48874, 14.0),\n\tvec3(-1.77, 0.0, 5.0),\n\tvec3(-0.744166858, 0.13150536, 13.0),\n\tvec3(0.41646, -0.210156433, 16.0),\n\tvec3(-0.7455, 0.1126, 10.0),\n\tvec3(-1.1604872, 0.2706806, 12.0),\n\tvec3(-0.735805, 0.196726496, 15.0)\n);\nconst float centerDuration = 31.0;\nconst float rotationDuration = 53.0;\nconst vec2 defaultCenter = vec2(-0.6, 0.0);\n\n#if COLORSCHEME==1\nconst vec4 insideColor = vec4(0.0, 0.0, 0.0, 1.0);\n#else\nconst vec4 insideColor = vec4(0.1, 0.12, 0.15, 1.0);\n#endif\n\nfloat time = 0.0;\nint centerIndex = 0;\nvec2 currentCenter;\nfloat currentZoom;\n\n\n// Color palettes https://iquilezles.org/articles/palettes/\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n\treturn a + b*cos(2.0*M_PI*(c*t+d));\n}\n\nvec3 awesomePalette(in float t)\n{\n\treturn palette(t, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.1,0.2));\n}\n\nvec3 rainbow(in float t)\n{\n\treturn palette(t, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67));\n}\n\n\n// Complex multiplication\nvec2 cmul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);\n}\n\n// Complex c^2\nvec2 cpow2(in vec2 c)\n{\n\treturn vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\n// Complex division\nvec2 cdiv(in vec2 a, in vec2 b)\n{\n\treturn vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)));\n}\n\n// Get rotation matrix\nmat2 rotate(float theta)\n{\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat2(c, -s, s, c);\n}\n\n// Potential formula\nfloat potential(in vec2 c)\n{\n\tvec2 z = vec2(0.0, 0.0); // z0\n\tint iter = 0;\n\n\tfor (iter = 0; iter < MAXITER_POT; ++iter) {\n\t\tz = cpow2(z) + c; // z_n+1 = z_n^2 + c\n\t\tfloat absZ = length(z); // |z|\n\t\tif (absZ > ER_POT) {\n\t\t\treturn abs(log(log2(absZ)) - (float(iter) + 1.0) * log(2.0));\n\t\t}\n\t}\n\n\treturn -1.0;\n}\n\n// Reflection formula\nfloat reflection(in vec2 c) {\n\tvec2 z = vec2(0.0, 0.0); // z0\n\tvec2 dc = vec2(0.0, 0.0); // Derivate of c\n\n\tconst float h2 = 1.5; // Height of light\n\tvec2 angle = normalize(vec2(-1.0, 1.0)) * rotate(time / rotationDuration); // Light always from top left\n\n\tfor (int i = 0; i < MAXITER_NORMAL; i++) {\n\t\tdc = 2.0 * cmul(dc, z) + vec2(1.0, 0.0);\n\t\tz = cpow2(z) + c;\n\n\t\tif (length(z) > ER_NORMAL) { // Outside lighting calculation formula\n\t\t\tvec2 slope = normalize(cdiv(z, dc));\n\t\t\tfloat reflection = dot(slope, angle) + h2;\n\t\t\treflection = reflection / (1.0 + h2); // Lower value to max 1.0\n\t\t\tif (reflection < 0.0) {\n\t\t\t\treflection = 0.0;\n\t\t\t}\n\t\t\treturn reflection;\n\t\t}\n\t}\n\n\treturn -1.0;\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Coordinates [-1, 1]\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y) * 2.0;\n\n\t// Mix between base poistion and target position\n\tfloat mixFactor = 1.0 - (0.5 + 0.5 * cos(time / centerDuration * 2.0 * M_PI));\n\n\t// Zoom and position calculation\n\tfloat zoom = exp2(-currentZoom * mixFactor);\n\tfloat maxZoom = exp2(-currentZoom);\n\tvec2 c = mix(currentCenter, defaultCenter, zoom / (1.0 - maxZoom) - maxZoom) + uv * zoom * rotate(time / rotationDuration);\n\n\tfloat pot = potential(c);\n\tfloat ref = reflection(c);\n\n#ifdef INVERTED_GRADIENT\n\tfloat intensity = 1.0 - sqrt(fract(pot));\n\tintensity = mix(intensity, ref, 0.5);\n\t// intensity = 0.8 * (intensity * ref) + 0.2; // Alternative shadows\n#else\n\tfloat intensity = 0.7 * (fract(pot) * ref) + 0.3;\n#endif\n\n#if COLORSCHEME==1\n\tvec3 color = awesomePalette(time / 50.0 + pot / 40.0);\n\tif (ref < 0.0) { // Inner color\n\t\tfragColor = insideColor;\n\t}\n\telse { // Outer color\n\t\t//fragColor = vec4(color * intensity, 1.0);\n\t\t//fragColor = mix(fragColor, vec4(1.0), intensity * 0.3 + clamp(ref - 0.5, 0.0, 1.0) * pow((1.0 - fract(pot)), 30.0));\n\t\tfragColor = vec4(\n\t\t\tcolor * intensity + // Base color\n\t\t\tvec3(intensity) * 0.3 + // Matte white\n\t\t\tclamp(ref - 0.5, 0.0, 1.0) * pow((1.0 - fract(pot)), 30.0), // Specular\n\t\t1.0);\n\t\tfragColor = clamp(fragColor, 0.0, 1.0);\n\t}\n#else\n\tvec3 color = rainbow(pot / 20.0);\n\tif (pot < 0.0) { // Inner color\n\t\tcolor = insideColor.rgb * min((ref + 0.5), 1.0);\n\t}\n\telse { // Outer color\n\t\tcolor = color * intensity;\n\t}\n\tfragColor = vec4(color, 1.0);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\ttime = iTime + centerDuration / 2.0 - 7.0; // Start with zoom\n\tcenterIndex = int(time / centerDuration) % NUMBER_OF_POINTS; // Seleect current target\n\tcurrentCenter = coordinates[centerIndex].xy;\n\tcurrentZoom = coordinates[centerIndex].z;\n\n\tfragColor = vec4(0.0);\n\n\t// Antialiasing\n\tconst float fraction = 1.0 / float(AA);\n\tconst float fraction2 = fraction / float(AA);\n\tfor (int i = 0; i < AA; i++) {\n\t\tfor (int j = 0; j < AA; j++) {\n\t\t\tvec4 color = vec4(0.0);\n\t\t\tvec2 shift = vec2(\n\t\t\t\tfloat(i) * fraction + float(AA - j - 1) * fraction2,\n\t\t\t\tfloat(j) * fraction + float(i) * fraction2\n\t\t\t);\n\t\t\trender(color, fragCoord + shift);\n\t\t\tfragColor += clamp(color, 0.0, 1.0);\n\t\t}\n\t}\n\n\tfragColor = fragColor / float(AA * AA);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1442, 1502, 1572, 1572, 1611], [1613, 1613, 1646, 1646, 1744], [1746, 1746, 1772, 1772, 1872], [1875, 1901, 1928, 1928, 1990], [1992, 2007, 2030, 2030, 2086], [2088, 2108, 2141, 2141, 2234], [2236, 2259, 2285, 2285, 2360], [2693, 2715, 2744, 2744, 3402], [3404, 3404, 3456, 3480, 5023], [5025, 5025, 5080, 5080, 5803]], "test": "untested"}
{"id": "7tdcDX", "name": "team sparkle", "author": "lomateron", "description": "2 layers across time of 3x3+4 pixel grid", "tags": ["automata"], "likes": 4, "viewed": 209, "published": 3, "date": "1660699935", "time_retrieved": "2024-07-30T16:35:21.866478", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2( 0,-2));\n    uint s = uint(dot(a,vec4(1,1,0,0))+.1);\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((+8U*4U*8U*4U* 16U //mod 7U to get similar world\n                    +8U*4U*8U*    0U\n                    +8U*4U*       0U\n                    +8U*          3U\n                    +             5U>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.1);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2( 0,-2));\n    uint s = uint(dot(a,vec4(1,1,0,0))+.1);\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((+8U*4U*8U*4U* 16U //mod 7U to get similar world\n                    +8U*4U*8U*    0U\n                    +8U*4U*       0U\n                    +8U*          3U\n                    +             5U>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.1);\n    }\n    fragColor = o;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2( 0,-2));\n    uint s = uint(dot(a,vec4(1,1,0,0))+.1);\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float((+8U*4U*8U*4U* 16U //mod 7U to get similar world\n                    +8U*4U*8U*    0U\n                    +8U*4U*       0U\n                    +8U*          3U\n                    +             5U>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+1.5363)))*vec4(2467.5678,\n                                                                    3467.5678,\n                                                                    4467.5678,\n                                                                    5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.1);\n    }\n    fragColor = o;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 140]], "test": "untested"}
{"id": "stdyDX", "name": "Quadratic bezier circle approx", "author": "NinjaKoala", "description": "Approximating a circle with n quadratic bezier curves", "tags": ["2d", "bezier", "circle", "approximation", "quadratic", "numeric"], "likes": 4, "viewed": 263, "published": 3, "date": "1660693445", "time_retrieved": "2024-07-30T16:35:22.642403", "image_code": "/*\nQuick experiment on approximating a circle with n=3,...,10 quadratic bezier curves.\nThe control point is taken as lying on the angle bisector between the endpoints\nand the length of that vector is optimized with respect to two different constraints:\n\n1. Smoothness: We want two neighbouring curves to have the same tangents\n2. Global Error: Minimize how far away the curve is from the perfect circle on average\n\nBoth variants look like the circle for bigger n, but for smaller n they are quite\ndifferent and it probably depends on your application which is better\n(or maybe something in between?)\n\nValues are computed using sage:\nhttps://gist.github.com/Ninja-Koala/05d32186364901f69c65f2f30804f282\n*/\n\n//#define N_CURVES 3\n//#define MOUSE\n//#define SHOW_CIRCLE\n\nconst vec3 line_col=vec3(0);\nconst vec3 bg_col=vec3(1);\nconst vec3 circ_col=vec3(1,0,0);\n\nconst float zoom=5.;\nconst float speed=1.;\n\nconst float pi=3.1415925;\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tvec3 t0=vec3(0.,.5,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat quadratic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\treturn sqrt(quadratic_bezier_dis_approx_sq(uv,p0,p1,p2));\n}\n\nvec2 circle(float angle){\n\treturn vec2(cos(angle), sin(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\n\tfloat time=iTime*speed;\n\n\t//x value optimizes for smoothness\n\t//y value optimizes global error\n\tvec2 params[]=vec2[](vec2(2.0000000,1.5266269717117547),\n\t                     vec2(1.4142137,1.302540332610836),\n\t                     vec2(1.2360680,1.1952007055159193),\n\t                     vec2(1.1547005,1.1360708085570863),\n\t                     vec2(1.1099162,1.1001848642387122),\n\t                     vec2(1.0823922,1.0768091648486144),\n\t                     vec2(1.0641778,1.0607443753104062),\n\t                     vec2(1.0514622,1.0492315540059483));\n\n    #ifndef N_CURVES\n\tfloat n_curves=mod(floor(time),7.)+3.;\n    #else\n    float n_curves=float(N_CURVES);\n    #endif\n\n\tint index=int(n_curves-3.);\n    \n    #ifdef MOUSE\n    float t1=iMouse.x/iResolution.x;\n    #else\n    float t1=fract(time);\n    #endif\n    \n\n\tvec2 p0=circle(0.);\n\tvec2 p1=mix(params[index].x,params[index].y,t1)*circle(pi/n_curves);\n\tvec2 p2=circle(2.*pi/n_curves);\n\n\tfloat angle=atan(uv.y,uv.x);\n\tangle=mod(angle,2.*pi/n_curves);\n\tuv=length(uv)*circle(angle);\n\n\tfloat dis=quadratic_bezier_dis_approx(uv,p0,p1,p2);\n\t//dis=min(dis,abs(length(uv)-1.));\n\t\n\tvec3 color=bg_col;\n\tcolor=mix(line_col,color,smoothstep(0.,border,dis));\n    \n    #ifdef SHOW_CIRCLE\n    dis=abs(length(uv)-1.);\n    color=mix(circ_col,color,smoothstep(0.,border,dis));\n    #endif\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[927, 927, 1003, 1003, 1137], [1139, 1139, 1212, 1212, 1567], [1569, 1569, 1639, 1639, 1700], [1702, 1702, 1727, 1727, 1767]], "test": "untested"}
{"id": "7ldcWX", "name": "Raytracing Shader Test", "author": "Sturdyfool10", "description": "Using math from the cherno raytracing series I decided to translate the code to gpu code, use your mouse along the X axis to control the camera", "tags": ["raytracing", "interactive", "shading"], "likes": 0, "viewed": 303, "published": 3, "date": "1660690883", "time_retrieved": "2024-07-30T16:35:23.393395", "image_code": "struct ray {\n    vec3 origin;\n    vec3 rotation;\n};\nstruct camera {\n    vec3 position;\n    vec3 rotation;\n    float FOV;\n};\n\n//begin random def\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n//end random def\n\nvec3 randomUnit(vec2 uv) {\n    float r1 = random(iTime * uv);\n    float r2 = random(r1 * 0.32874 * uv);\n    float r3 = random(r2 * r1 * .39482387 * uv);\n    return normalize(vec3(r1, r2, r3));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float rayRandomness = 0.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 coord = (uv * 2.0) - 1.0;\n    coord.x *= aspect;\n    float noiseAmp = 0.005; //camera noise used to eliminate color banding\n    vec3 noise = randomUnit(uv * 2.0) * noiseAmp - (noiseAmp * 0.5);\n    // Time varying pixel color\n    vec3 col = vec3(1, 1, 0);\n    \n    float sR = 0.5;\n    vec3 origin = vec3(0, 0, (iMouse.x / iResolution.x) * 5.0);\n    vec3 direction = vec3(coord.x, coord.y, -1) + (randomUnit(uv) * rayRandomness - (rayRandomness * 0.5));\n    vec3 lightDirection = normalize((vec3(cos(iTime), sin(iTime), 0)));\n    \n    \n    \n    float a = dot(direction, direction);\n    float b = 2.0 * dot(origin, direction);\n    float c = dot(origin, origin) - sR * sR;\n    \n    float desc = (b * b) - (4.0 * a * c);\n    if (desc < 0.0) col = vec3(0, 0, 0);\n    float sDesc = sqrt(desc); //half the sqrt count\n    \n    float rSol0 = (-b + sDesc) / (2.0 * a);\n    float rSol1 = (-b - sDesc) / (2.0 * a);\n    \n    vec3 hitPos = origin + direction * rSol1;\n    vec3 normal = normalize(hitPos * 0.5 + 0.5);\n    \n    float d = max(dot(normal, -lightDirection), 0.0);\n    \n    col = vec3(1, 1, 0) * d + noise;\n\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 144, 165, 165, 296], [300, 366, 388, 388, 446], [447, 447, 469, 469, 527], [528, 528, 550, 550, 608], [610, 610, 642, 642, 1062], [1064, 1064, 1089, 1089, 1140], [1141, 1141, 1166, 1166, 1217], [1218, 1218, 1243, 1243, 1294], [1295, 1295, 1320, 1320, 1371], [1390, 1390, 1416, 1416, 1584], [1587, 1587, 1644, 1694, 2990]], "test": "untested"}
{"id": "sttcWX", "name": "torpedo amoeba", "author": "lomateron", "description": "why it has color? read user comments in https://www.shadertoy.com/view/Nltyzs\nthis one is 3 layers across time of 3x3 pixel grids\ncomplexity increases faster by increasing pixel reads across time than increasing pixel reads across space", "tags": ["automata"], "likes": 8, "viewed": 266, "published": 3, "date": "1660690485", "time_retrieved": "2024-07-30T16:35:24.143390", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    if((iFrame&3)==0){a = a.xyzw;}\n    if((iFrame&3)==1){a = a.yzwx;}\n    if((iFrame&3)==2){a = a.zwxy;}\n    if((iFrame&3)==3){a = a.wxyz;}\n    fragColor = cos(dot(a,vec4(1,2,4,8)*3.)+vec4(0,1,2,3));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    uint s = uint(dot(a,vec4(1,1,1,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((+16U*8U*16U*8U* (1U<<11U) \n                     +16U*8U*16U*    5U\n                     +16U*8U*        0U\n                     +16U*           1U\n                     +               7U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                     3467.5678,\n                                                                     4467.5678,\n                                                                     5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.1);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 337]], "test": "untested"}
{"id": "fdtyDj", "name": "Test World Phase 4", "author": "byt3_m3chanic", "description": "standard balls moving in a tiled domain of all 3 axis | Cropping wave fun for effect.", "tags": ["raymarching", "refraction", "repetition", "looping"], "likes": 24, "viewed": 407, "published": 3, "date": "1660682803", "time_retrieved": "2024-07-30T16:35:24.892387", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Test World Phase 4    \n    8/16/22 | byt3 m3chanic\n    \n    Same ole trick, trying refraction and fumbling with a single pass multi\n    bounce marcher - thanks @blackle / @tdhooper / and sdf's @iq\n*/\n\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    40.\n\n// AA Setting - comment/uncomment to disable/endable AA from render\n#define AA 2\n\nfloat mtime=0.,time=0.;\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*41458.5453); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//@iq SDF functions\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cap( vec3 p, float h, float r ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global vars\nvec3 hit=vec3(0), hitPoint=vec3(0);\nfloat travelSpeed,modTime,fractTime;\n\nconst float size = 20.;\nconst float rep_half = size/2.;\nconst float rr = rep_half/2.;\n\nvec2 map(vec3 pos) {\n\tvec2 res = vec2(1e5,-1.);\n    vec3 center = vec3(0,-2, -rr);\n\n    vec3 pp = pos-center;\n    vec3 tt = pp;\n    vec3 sp = pp;\n\n    vec3 pi = vec3(\n        floor((pp + rep_half)/size)\n    );\n    vec3 ti = pi;\n\n    float bfs,fhs,dhs;\n    if(modTime<2.){\n        fhs = hash21(pi.xz);\n        if(fhs>.57){\n            tt.y += fractTime;\n        } else {\n            tt.y -= fractTime;\n        } \n    } else if (modTime<4.){\n      \tdhs = hash21(pi.zy+vec2(4,.4));\n        if(dhs>.67){\n            tt.x += fractTime;\n        } else {\n            tt.x -= fractTime;\n        }\n    } else {\n      \tbfs = hash21(pi.xy+vec2(21,.4));\n        if(bfs>.27){\n            tt.z -= fractTime;\n        } else {\n            tt.z += fractTime;\n        }   \n    }\n\n    pp =  mod(pp+rep_half,size) - rep_half;\n\ttt =  mod(tt+rep_half,size) - rep_half;\n\n    float thk = 1.;\n    float d1 = length(abs(pp.xy)-vec2(10))-thk;\n    d1 = min(length(abs(pp.xz)-vec2(10))-thk,d1);\n    d1 = min(length(abs(pp.yz)-vec2(10))-thk,d1);\n    if(d1<res.x) {\n        res = vec2(d1,3);\n        hit = abs(pp)-vec3(10);\n    }\n\n    d1 = min(cap(abs(pp)-vec3(10,0,10),1.5,1.5),d1);\n    d1 = min(cap(abs(pp.yzx)-vec3(10,0,10),1.5,1.5),d1);\n    d1 = min(cap(abs(pp.zxy)-vec3(10,0,10),1.5,1.5),d1);\n    if(d1<res.x) {\n        res = vec2(d1,6);\n        hit = abs(pp)-vec3(10);\n    }\n\n\tfloat d2 = box(abs(pp)-vec3(10), vec3(3.5))-.05;\n    d2=max(d2,-(abs(d1)-.5));\n    if(d2<res.x) {\n        res = vec2(d2,2);\n        hit = abs(pp)-vec3(10);\n    }\n\n    float d5 = length(tt)-2.35;\n    if(d5<res.x) {\n        res = vec2(d5,4);\n        hit = tt;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist){\n    t*=mindist;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d-vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n){\n    n = normal(p,d,1.);\n  \n    vec3 lpos = vec3(5,9,-7);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 h=vec3(.05);\n\n    if(m==2.) {\n        vec3 dv = p-vec3(0,0, -rr/2.);\n        vec3 f=fract(dv)-.5;\n        if(f.x*f.y*f.z>.0) h = vec3(1);\n        \n        float px = 4./R.x;\n        float d1 = length(hitPoint)-4.5;\n        float d2 = smoothstep(px,-px,abs(d1)-.05);\n        d1=smoothstep(px,-px,d1);\n        float cut = clamp((p.y*.03)+.2,0.,1.);\n        h=mix(h,vec3(.8,.47,0.),d1);\n        h=mix(h,vec3(.05),d2);\n    }\n\n    if(m==3.) {\n        float bg = clamp(sin(length(hitPoint)*22.)*1.5-.5,.01,.99);\n        h=mix(vec3(.37,.55,.57),vec3(.063,.11,.12),bg);\n    }\n    if(m==4.) h=vec3(.05);\n    if(m==6.) h=vec3(.3);\n    return diff*h;\n}\n\nvec3 renderFull(vec2 uv)\n{\n\n    vec3 C=vec3(.0);\n    float fA = 0.;\n    vec3 ro = vec3(0,-1,10.15),\n         rd = normalize(vec3(uv,-1));\n\n    mat2 mx =rot(-(.65*sin(T*.08))); mat2 my =rot(-.55+(.2*cos(T*.1)));\n    \n    ro.zy*=mx;rd.zy*=mx;\n    ro.xz*=my;rd.xz*=my;\n    \n    vec3  p = ro + rd * .0001;\n    float atten = 1.;\n    float k = 1.;\n    float bounce = 4.;\n\n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    // a lot of these settings are tweaked for this scene \n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n        float d = i<32? ray.x*.5:ray.x*.9;\n        float m = ray.y;\n        p += rd*d*k;\n\n        hitPoint=hit;\n        if(bounce>2.)fA+=d;\n\n        if (d*d < 1e-5) {\n            bounce--;\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m!=4.&&m!=6.) break;\n            \n            atten *= .45;\n            p += rd*.1;\n            k = sign(map(p).x);\n            vec3 rf=refract(rd,n,.65);\n            \n            if(m==6.){\n                rf=reflect(-rd,n);  \n            }\n            \n            p+=n*.5;\n            rd=rf;\n\n        }\n\n        if(bounce<1.||distance(p,rd)>75.) break;\n    }\n\n    if(fA>0.) C=mix(C,vec3(.03), 1.-exp(-.00001*fA*fA*fA));\n    return clamp(C,vec3(0),vec3(1)); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n\n    vec3 col = vec3(.00); \n    time = iTime;    \n \n    mat2 r15 = rot(-25.*PI/180.);\n    fractTime = fract(time*.3)* (size);\n    modTime = mod(time*.6,6.);\n    \n    vec2 o = vec2(0);\n    vec2 xv = (2.*fragCoord.xy-R.xy)/max(R.x,R.y);\n    \n    vec2 ff = fract(xv*5.+T*.5)-.5;\n    float wv = .2 * sin(xv.x*.75+T*1.5);\n    xv.y+=wv;\n\n    if(ff.x*ff.y>0.&&(xv.y>.35||xv.y<-.35)) col=vec3(.9);\n\n    if(xv.y<.35&&xv.y>-.35){\n    // @tdhooper \n    // @iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - .5;\n    #endif\n\t\t\n        //time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.x;\n    \tcol += renderFull(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    }\n    \n    float px = 2./R.x;\n    float f1 = length(abs(xv.y)-.35)-.005;\n    float f2 = smoothstep(.02+px,-px,f1);\n    f1 = smoothstep(px,-px,f1);\n    if(xv.y>.35||xv.y<-.35)col = mix(col,col*.4,f2);\n    col = mix(col,vec3(.8,.47,0.),f1);\n    col = pow( col, vec3(.4545) );\n    fragColor = vec4(col, 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtyDj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[571, 571, 593, 593, 652], [653, 653, 671, 671, 715], [717, 737, 765, 765, 856], [858, 858, 892, 892, 972], [974, 974, 1012, 1012, 1123], [1300, 1300, 1320, 1320, 2934], [2936, 2936, 2980, 2980, 3170], [3172, 3172, 3232, 3232, 4012], [4014, 4014, 4040, 4040, 5334]], "test": "untested"}
{"id": "ftdcWX", "name": "motion=depth illusion", "author": "FabriceNeyret2", "description": "we perceive the moving color as deeper background\n\nreference: [url] https://twitter.com/jagarikin/status/1518401294607982592 [/url]\n       B&W: [url] https://twitter.com/jagarikin/status/1517706648575680512 [/url]\n", "tags": ["illusion", "2tweets", "perception", "short", "golf", "reproduction"], "likes": 18, "viewed": 299, "published": 3, "date": "1660666253", "time_retrieved": "2024-07-30T16:35:25.699230", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    int i = ( int( texture(iChannel0,U/vec2(6,1)).a > .5  ) + int(iTime/4.) ) % 2;\n    O-=O;\n    O[i] = texture(iChannel1, U + .1*iTime*vec2(i,0) ).r;\n // O +=       // B&W variant\n // O[1-i] =   // swapped colors variant\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NltyWX", "name": "cube 11", "author": "FabriceNeyret2", "description": "mouse controls camera\n", "tags": ["raymarching", "short"], "likes": 8, "viewed": 299, "published": 3, "date": "1660660657", "time_retrieved": "2024-07-30T16:35:26.441246", "image_code": "// variant of https://shadertoy.com/view/7lcyDf\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))           // rotation \n\nfloat L(vec3 p) { \n    p.x += clamp(-p.x, 0., 1.);                            // proj coord on line  \n    return length(p);                                      // dist to segment\n}\nfloat map(vec3 q) {\n    q = abs(q)-1.;\n    return min( L(q) , min( L(q.yzx), L(q.zxy) )) - .1;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  R = iResolution, N, e = vec3(.01,0,0),\n          D = vec3(U*.4 - R.xy*.2, -R.y) / R.y,            // ray direction\n          p = vec3(0,0,10), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3(.1,0,0) * cos(iTime + vec3(0,11,0)); \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(.78-6.*M.y),                           // rotations\n        q.xz *= rot(.78-6.*M.x), \n        t = map(q),\n     // t = min(t, map(q)),\n        p += t*D;                                          // step forward = dist to obj          \n\n   if (t<.01) \n       N = normalize( t - vec3( map(q+e), map(q+e.yxy), map(q+e.yyx) ) ),\n       O -= dot(N,vec3(.7)) +O;\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 139, 139, 303], [304, 304, 323, 323, 400], [402, 402, 438, 438, 1240]], "test": "untested"}
{"id": "7lcyDf", "name": "cube 10", "author": "FabriceNeyret2", "description": "mouse controls camera\n", "tags": ["raymarching", "short"], "likes": 9, "viewed": 282, "published": 3, "date": "1660658458", "time_retrieved": "2024-07-30T16:35:27.182266", "image_code": "\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))           // rotation \n#define C(q, r, l)  max(abs(q.y)-l,length(q.xz)-r)         // cylinder\n\nfloat map(vec3 q) {\n    q = abs(q);\n    vec3 c = q -1.;\n    return max( min( length(c.xy) , min( length(c.yz), length(c.zx) )) - .1,\n                max( q.x, max(q.y,q.z)) - 1.2 );\n             // length(q)-1.73 );\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  R = iResolution, N, e = vec3(.01,0,0),\n          D = vec3(U*.4 - R.xy*.2, -R.y) / R.y,            // ray direction\n          p = vec3(0,0,10), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3(.1,0,0) * cos(iTime + vec3(0,11,0)); \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(.78-6.*M.y),                           // rotations\n        q.xz *= rot(.78-6.*M.x), \n        t = map(q),\n        p += t*D;                                          // step forward = dist to obj          \n\n   if (t<.01) \n       N = normalize( t - vec3( map(q+e), map(q+e.yxy), map(q+e.yyx) ) ),\n       O -= dot(N,vec3(.7)) +O;\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 164, 164, 362], [364, 364, 400, 400, 1174]], "test": "untested"}
{"id": "st3yDX", "name": "Another voronoi tracking viz", "author": "josemorval", "description": "Voronoi trackign based on wyatt (and others) works.", "tags": ["voronoi", "particles", "mosaic", "voronoitracking"], "likes": 20, "viewed": 405, "published": 3, "date": "1660645266", "time_retrieved": "2024-07-30T16:35:27.927273", "image_code": "//Here visualization (voronoi cells)\n//Based on wyatt works\n\nvec2 R;\n\nvec4 read0(vec2 U) {return texelFetch(iChannel0,ivec2(U),0);}\nvec4 read1(vec2 U) {return texelFetch(iChannel1,ivec2(U),0);}\nvec4 read2(vec2 U) {return texelFetch(iChannel2,ivec2(U),0);}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    R = iResolution.xy;\n     \n    vec2 P = read0(U).xy; \n    vec2 V = read1(U).xy; \n    \n    vec2 \n        n = read0(U+vec2(0,1)).xy,\n        e = read0(U+vec2(1,0)).xy,\n        s = read0(U-vec2(0,1)).xy,\n        w = read0(U-vec2(1,0)).xy;\n \tfloat d = (length(n-P.xy)-1.+\n        length(e-P.xy)-1.+\n        length(s-P.xy)-1.+\n        length(w-P.xy)-1.);\n \n    Q = read0(U);\n    Q = vec4(1.)*fract(9221.*sin(213.11+dot(Q.zw,vec2(853.1221,821.11))));\n    Q += vec4(5.*length(V),0.,0.,0.)*(smoothstep(0.,0.1,d));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Here voronoi tracking\n\nvec2 R;\n\nvec4 read0(vec2 U) {return texelFetch(iChannel0,ivec2(U),0);}\nvec4 read1(vec2 U) {return texelFetch(iChannel1,ivec2(U),0);}\nvec4 read2(vec2 U) {return texelFetch(iChannel2,ivec2(U),0);}\n\nvoid swap (vec2 U, inout vec4 Q, vec2 u) {\n    vec4 p = read0(U+u);\n    float d = length(U-Q.xy) - length(U-p.xy);\n    float e = .1;\n    Q = mix(Q,p,d>0.?1.:0.);\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n\n    R = iResolution.xy;\n    vec2 s = U/R-0.5; s.x*=R.x/R.y;\n    \n    Q = read0(U);\n    \n \tswap(U,Q,vec2(1,0));\n \tswap(U,Q,vec2(0,1));\n \tswap(U,Q,vec2(0,-1));\n \tswap(U,Q,vec2(-1,0));\n    \n    \n    Q.xy += read1(Q.xy).xy;\n    if (iFrame < 1) {\n        Q = vec4(0.,0.,0.,0.);\n        float s = 20.;\n        vec4 QQ = vec4(floor(U/s+0.5)*s,0.,0.); \n        QQ.zw = QQ.xy;\n        Q = QQ;\n        \n        //Differents tile sizes\n        /*for(;s<30.;s*=3.){\n            vec4 QQ = vec4(floor(U/s+0.5)*s,0.,0.); \n            QQ.zw = QQ.xy;\n            float mask = fract(591.12*sin(1021.*s+dot(QQ.xy,vec2(2301.23,3201.1))));\n            mask = step(0.3,mask);\n            Q = mix(Q,QQ,mask);\n        }\n        */\n        \n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Here simple velocity field\n\nvec2 R;\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    R = iResolution.xy;\n    vec2 uv = U/R-0.5; uv.x*=R.x/R.y;\n    uv.x += 0.5*sin(0.5*iTime);\n    vec2 dir = mix(vec2(-uv.y,uv.x),vec2(uv.y,-uv.x),0.);\n    Q = vec4(5.*smoothstep(0.4,0.,length(uv))*dir,0.,0.);\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3yDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 90, 90, 131], [132, 132, 152, 152, 193], [194, 194, 214, 214, 255], [257, 257, 298, 298, 809]], "test": "untested"}
{"id": "ftccDX", "name": "Spinning Spark Clouds", "author": "fenix", "description": "*drag with mouse* *space to reset* Just goofing around with an old shader and thought this was interesting enough to share.", "tags": ["2d", "voronoi", "simulation", "particles", "flow", "liquid", "sph"], "likes": 5, "viewed": 273, "published": 3, "date": "1660629718", "time_retrieved": "2024-07-30T16:35:28.855790", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, attempting to approximate smoothed particle\n//  hydrodynamics. \n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles\n//  Buffer D applies temporal blur\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 5000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.003;\nconst float PARTICLE_REPEL_SIZE = 0.01;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, (point.x + 1.0 - MOVING_WALL_MAG - MOVING_WALL_MAG*sin(time / MOVING_WALL_TIME)) * resolution.x / resolution.y);\n    minDist = min(minDist, (1.0 - point.x) * resolution.x / resolution.y);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    vec2 uv;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.0000);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.0001;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS_VEL)\n    {\n        if (iFrame == 0 || keyDown(32))\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i / particlesPerRow, j / particlesPerRow) * 1.8 - 0.9;\n            data.vel = vec2(0);\n            data.uv = vec2(data.pos.x * 0.5 + 0.5, data.pos.y * 0.5 + 0.5);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            else\n            {\n                // auto disturb\n                //disturbPos = vec2(sin(iTime * 0.5), sin(iTime * 1.0))* vec2(1.2, 0.2) + vec2(0.0, 0.2);\n                //disturbDelta = 80.0 * vec2(cos(iTime * 0.5), cos(iTime * 1.0));\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.5 / sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n            };\n            \n            solverParticle particles[17];\n            int numSolverParticles = 0;\n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            \n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos / dist;\n\n                    particles[numSolverParticles].pos = otherPosVel.xy;\n                    particles[numSolverParticles].vel = otherPosVel.zw;\n                    \n                    ++numSolverParticles;\n                    \n                    // Apply crazy auto-stirring force\n                    data.vel += 0.02 * vec2(deltaPos.y, -deltaPos.x);\n                }\n            }       \n\n            particles[numSolverParticles].pos = data.pos;\n            particles[numSolverParticles].vel = data.vel;\n            ++numSolverParticles;\n\n            // Solve local neighborhood\n            float pressure = 0.0;\n            const int NUM_ITERATIONS = 25;\n            for(int iterations = 0; iterations < NUM_ITERATIONS; ++iterations)\n            {\n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    float impulse;\n                    for (int j = 0; j < numSolverParticles; ++j)\n                    {\n                        if (i != j)\n                        {\n                            vec2 deltaPos = particles[i].pos - particles[j].pos;\n                            float dist = length(deltaPos) + 0.001;\n                            vec2 dir = deltaPos / dist; \n\n                            impulse = (PARTICLE_REPEL * SPHgradKernel(dist / PARTICLE_REPEL_SIZE));\n                                                        \n                            particles[i].vel += impulse * dir;\n                            particles[j].vel -= impulse * dir;\n                        }\n                    }\n                    \n                    // Last particle is the one we're working on\n                    pressure += impulse;\n                }\n                \n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    // Integrate vel\n                    particles[i].vel -= particles[i].vel * 0.0004 - GRAVITY / float(NUM_ITERATIONS);\n                    \n                    // Integrate pos\n                    particles[i].pos += particles[i].vel / float(NUM_ITERATIONS);\n                }\n            }\n            \n            // Combine solver results into force\n            force += particles[numSolverParticles - 1].vel - data.vel;\n            \n\n                   \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            // Damping\n            data.vel -= data.vel * length2(data.vel) * 200.0;\n\n\n            // Clamping\n            float maxSpeed = 0.006; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(nb0);\n        vec4 bestDists = vec4(length2(fxGetParticleData(bestIds[0], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[1], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[2], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[3], POS_VEL).xy - data.pos));\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = fxGetClosest(ivec2(fragCoord));\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(distance(fxGetParticleData(new[0], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[1], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[2], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[3], POS_VEL).xy, screen2world(fragCoord)));\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(maxParticles));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Particle render\n\nconst float MAX_TEMP = 0.002;\n\nvec3 BlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    float dist = linePointDist2(p.pos, p.pos - 1.5 * p.vel, fragCoord, iResolution, closest);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    vec3 color = BlackBody(length(p.vel));\n    fragColor.xyz += color * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Temporal blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) fragColor = vec4(0);\n    \n    vec4 newColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 oldColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    fragColor = oldColor * 0.95 + newColor;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftccDX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[627, 627, 680, 680, 747]], "test": "untested"}
{"id": "NlccWf", "name": "Iijtunnel music remix 4", "author": "jarble", "description": "More simple patterns", "tags": ["music", "iij"], "likes": 5, "viewed": 292, "published": 3, "date": "1660628899", "time_retrieved": "2024-07-30T16:35:29.599801", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 U =( 2.*fragCoord-iResolution.xy)/iResolution.y/4.;\n\n  float b=sqrt(length(U));\n  \n  U=fract(vec2(b,abs(atan(U.x,U.y))));\n\n  vec2 c=vec2(U.x-iTime,U.y)*100.;\n  \n  U=floor(mod((c),vec2(256)));\n\n  float d=b*mod(abs(U.x*U.x-U.y*U.y),abs(U.x-U.y))/256.;\n\n  fragColor=vec4(fract(d*U.x),fract(d*U.y),d,1.);\n\n}", "image_inputs": [], "sound_code": "float fmod(float a,float b){    \n    /*\n    for(int i = 0; i < 4; i++){\n        a /= (1. + floor(mod(((a+1.)),2.)))*2.;\n    }\n    */\n    return\n        mod(floor(a),b)\n        //mod(mod(floor(a),b)*mod(floor(a/4.),b),b)\n        //mod(mod(4.+floor(a/b*2.),4.+floor(a+b)),b)\n        //ceil(mod(floor(a),b)-mod(floor(-a),b/2.))\n        //floor(sqrt(mod(floor(a*4./b/b)*floor(a),b*b)))\n        //mod(floor(a/b)*floor(a),b)\n    ;\n}\n\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n\n\nvec2 mainSound(int samp, float time){\n  //time *= (1.+fmod(time/4.,2.));\n  //time /= (1.+fmod(time*4.,2.));\n  \n  float t=\n      //time*(1.+fmod(time,2.))/2.\n      time\n  ;\n  \n  float m1 = fmod(t/4.,4.),\n  t1 = 2.+m1;\n  //t /= floor(1.+mod(t*2.,2.));\n  \n  t *= 8.;\n  //float m2 = ;\n  t /=\n      1. + fmod(t,2.)\n      //1. + fmod(t+floor(t/8.),2.)\n  ;\n  \n  //instruments\n  float a =\n      //64.*sqrt(1.-fract(t))*.2\n      32.*log(1.+fract(-t))\n      //pow(2.,2.-(fract(t)))\n      //pow(2.,2.-log(fract(t)))\n  ,\n  \n  nb = time*pow(2.,fmod(t/8.,8.)/4.+7.)*(1.-fmod(t/2.,t1)/t1);\n  //nb = pow(2.,fmod(t,8.)/2.+7.)*(1.-fmod(t/2.,t1)/t1);\n\n\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      abs(log(.5+abs(.5-vec2(fract(nb*.998),fract(nb)))*a))/2.\n  ;\n\n\n}\n\n/*\nvec2 mainSound(int samp, float time){\n  \n  float t = time*8.,\n  \n  t1 = 1.+fmod(t/8.,4.),\n  \n  a=sqrt(1.-fract(t))*.2,\n  \n  nb = pow(2.,fmod(t/8.,8.)/4.+8.)*(1.-fmod(t,t1)/t1);\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n}\n*/\n\n/*\n\n\nvec2 mainSound(int samp, float time){\n  \n  float t = time*8.,\n  \n  t1 = 1.+fmod(t/8.,4.),\n  \n  a=sqrt(1.-fract(t))*.2,\n  \n  nb = pow(2.,fmod(t/4.+t1,8.)/4.+8.)*(1.-mod(floor(t/2.)+floor(t/3.),t1)/t1);\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n}\n\n*/\n\n/*\nvec2 mainSound(int samp, float time){\n  \n  float t=(time);\n  \n  float m1 = fmod(t/4.,4.),\n  t1 = 2.+m1;\n  //t /= floor(1.+mod(t*2.,2.));\n  \n  t *= 8.;\n  float m2 = 1. + fmod(t,2.);\n  float m3 = 1. + fmod(t*16.,2.);\n  t /= m2;\n  \n  float a=sqrt(1.-fract(t))*.2,\n  \n  nb = pow(2.,fmod(t/8.,8.)/4.+m3+7.)*(1.-fmod(t/2.,t1)/t1);\n  //nb = pow(2.,fmod(t,8.)/2.+7.)*(1.-fmod(t/2.,t1)/t1);\n\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n\n}\n*/\n\n/*\nvec2 mainSound(int samp, float time){\n  \n  float t=(time)*4.;\n  \n  float m1 = fmod(t/2.,4.),\n  t1 = 2.+m1;\n  //t /= floor(1.+mod(t*2.,2.));\n  \n  t *= 8.;\n  float m2 = 1. + min(fmod(t/2.,2.),m1);\n\n  t /= max(m2,m1+1.);\n  \n  float a=sqrt(1.-fract(t/4.))*.2,\n  \n  nb = pow(2.,fmod(t/8.,8.)/4.+m2/2.+7.)*(1.-fmod(t/2.,t1)/t1);\n  //nb = pow(2.,fmod(t,8.)/2.+7.)*(1.-fmod(t/2.,t1)/t1);\n\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n\n}\n*/", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlccWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 373]], "test": "untested"}
{"id": "sttcWB", "name": "Temple Gateway", "author": "byt3_m3chanic", "description": "Temple Gateway - experiment with using 3 2D sdf's to make one 3D sdf", "tags": ["raymarching", "sdf", "temple"], "likes": 28, "viewed": 355, "published": 3, "date": "1660609166", "time_retrieved": "2024-07-30T16:35:30.382708", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    Temple Gateway\n    08/15/22 | byt3_m3chanic\n\n    @IY0YI posted a cool thing on the tweets\n    https://twitter.com/IY0YI/status/1558851205920858113\n\n    with a link to a shader from @fizzer\n    shadertoy.com/view/MsdBDj\n    \n    in which he used 3 2D SDF shapes to composite a 3D \n    SDF, so this is a version/inspired by that.\n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    55.\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 d = vec3(0.110,0.584,0.949);\n    return .45+.4*cos( PI2*t*vec3(.95,.97,.88)*d ); \n}\n//@iq \nfloat box( vec3 p, vec3 b ) {\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat box( vec2 p, vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat uncap( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n// sides\nfloat sideX(vec3 p) {\n    p.x=abs(p.x);\n    float d = length(p.xy-vec2(0,.35))-.095;\n    d = min(d,length(p.xy-vec2(0,.17))-.045);\n    vec2 tp=p.xy-vec2(.7,-.3);\n    tp*=rot(.83);\n    float t = uncap(tp,.05,.05-.025,.85);\n    d=min(d,t);\n    \n    float c = box(p.xy+vec2(0,.0),vec2(.2,.05))-.04;\n    c=abs(c)-.02;\n    c = min(c,box(vec2(p.x,abs(p.y+.225)-.05),vec2(.15,.025)));\n    c = min(c,box(p.xy+vec2(0,.41 ),vec2(.3,.055)));\n    c = min(c,box(p.xy+vec2(0,.575),vec2(.3,.06)));\n    c = min(c,box(p.xy+vec2(0,1.2 ),vec2(.3,.52)));\n    c = min(c,box(p.xy+vec2(0,2.1 ),vec2(.3,.34)));\n    d=min(d,c);\n    \n    return d;\n}\n\nfloat sideZ(vec3 p) {\n    vec2 sc = vec2(1.5,1.5);\n    float d = box(p.xz,sc);\n    float ff = (p.y<-1.75 || p.y>-.66)?.2:.1;\n    if(p.y<-.5) d=length(vec2(abs(p.x)-(1.25-.4*cos(p.y*.5)),p.z))-ff;\n    return d;\n}\n\nfloat sideY(vec3 p) {\n    return box(p.xy,vec2(2.));\n}\n\n//global\nvec3 hp,hitPoint;\n\nvec2 map(vec3 p) {\n    p.y-=1.25;\n    vec2 r = vec2(1e5,0.);\n    p.z-=T*.65;\n    p.y-=.5*sin(p.z*.4);\n    \n    vec3 q = p;\n    p.z=mod(p.z+2.,4.)-2.;\n    vec3 w = p;\n    p.y-=-.1*cos(p.x*.5*PI);\n\n    float x = \n        max(sideZ(p.xyz),\n            max(sideY(p.xzy),sideX(p.zyx))\n        );\n\n    if(x<r.x) {\n        r = vec2(x,1.);\n        hitPoint=p;\n    }\n\n    float f = q.y+2.25;\n    if(f<r.x) {\n        r = vec2(f,2.);\n        hitPoint=q;\n    }\n    \n    w.x=abs(w.x)-2.25;\n    float v = box(w+vec3(0,2.3,0),vec3(.5,.1,2.));\n    if(v<r.x) {\n        r = vec2(v,3.);\n        hitPoint=w;\n    }\n    \n    return r;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p);\n        if(abs(t.x)<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.3:t.x*.7;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 FC = vec3(0);\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    vec3 sp= p;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 200);\n    d = ray.x;\n    m = ray.y;\n    \n    hp = hitPoint;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(8.5,8,5.5);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = marcher(p + n * .01 * 2., l, sp, hit, 128).x;\n        if(shdw < length(p -  lpos)) diff *= .65;\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 12.);\n        fresnel = mix(.0, .9, fresnel);\n\n        vec3 h = vec3(.5);\n           \n        if(m==1.) {\n            h=mix(vec3(1.,0,0),vec3(1,.4,.0),clamp(hp.y+1.*.5,0.,1.));\n            if(hp.y>-.65&&hp.y<-.5)h=vec3(.9);\n            h=mix(h,h*.1,clamp(n.x,0.,1.));\n            ref=vec3(h);\n        }\n        \n        if(m==2.) {\n            h=vec3(0.18);\n            ref=h*.15;hp.xz+=sin(hp.xz*4.);\n            vec2 ff = fract(hp.xz)-.5;\n            if(ff.x*ff.y>0.) {\n                h=vec3(0.1);\n            }\n            \n            ref=h;\n        }\n        \n        if(m==3.) {\n            h=vec3(.8);\n            ref=vec3(.4);\n        }\n        \n        RC = h*diff;\n        if(bnc<2) RC = mix(RC,FC, 1.-exp(-.001*d*d*d));\n        \n        ro = p+n*.0001;\n        vec3 rf = reflect(rd,n);\n        rd = mix(rd,rf,1.-fresnel);\n\n    } else {\n        RC = FC;\n    } \n\n    return RC;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    \n    vec3 C=vec3(0);\n    vec3 ro = vec3(0, 0, 10);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float ux = clamp((uv.y+.25)*1.5,0.,1.);\n    FC = mix(vec3(0.396,0.671,0.945),vec3(0.443,0.016,0.016),ux);\n    \n    if(uv.x>-.5&&uv.x<.5&&uv.y>-.5&&uv.y<.5){\n    // mouse //\n    float x = M.xy==vec2(0)? 0.: -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0)? 0.: -(M.x/R.x*.5-.25)*PI;\n\n    mat2 rx = rot(.18+x), ry = rot(.78+y);\n\n    ro.yz*=rx; ro.xz*=ry; \n    rd.yz*=rx; rd.xz*=ry;\n\n    vec3 RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    \n    C = mix(C,FC, 1.-exp(-.00035*fA*fA*fA));\n    C = mix(C,FC,smoothstep(0.,1.,f*0.015));\n \n    }\n    \n    // top decorations\n    float scl = R.x/15.;\n    float bg = (clamp(sin((uv.x - uv.y)*PI2*scl) + .8, 0., 1.)*.5 + .5);\n    float px = 2./R.x;\n    float f = length(uv)-.45;\n    float sd = length(uv+vec2(-.005,.01))-.45;\n    sd=smoothstep(.04+px,-px,sd);\n    float df=smoothstep(px,-px,abs(f)-.005);\n    f=smoothstep(-px,px,f);\n    C = mix(C,vec3(.50,0.,0.)*bg,f);\n    \n    // dots and lines setup\n    vec2 p = uv;\n    p *= rot(-T*.1);\n    vec2 q = p;\n    \n    float a = atan(p.y, p.x);\n    float dots = 100.;\n    float tabs = 12.;\n\n    float ia = floor(a/PI2*dots);\n    ia = (ia + .5)/dots*PI2;\n\n    float ix = floor(a/PI2*tabs);\n    ix = (ix + .5)/tabs*PI2;\n    \n    p *= rot(ia);\n    q *= rot(ix);\n\n    // lines\n    float ln = (q.y)-.001;\n    ln=smoothstep(px,-px,ln);\n    C=mix(C,vec3(.161,0.,0.),min(ln,f));\n    \n    C = mix(C,C*.1,min(sd,f));\n    C = mix(C,vec3(.890,.361,.008),df);\n    \n    // dots\n    p.x -= .45 + .05*sin(ia*6.);\n    float b = length(p)-(.0075+.005*sin(ia*3.-T*3.));\n    b=smoothstep(px,-px,b);\n    C=mix(C,vec3(.984,.596,.055),b);\n\n    \n    \n    \n    C = clamp(C,vec3(.01),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttcWB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[645, 645, 666, 666, 728], [729, 729, 748, 748, 793], [795, 842, 860, 860, 954], [955, 962, 991, 991, 1076], [1077, 1077, 1106, 1106, 1184], [1185, 1185, 1237, 1237, 1476], [1478, 1487, 1508, 1508, 2110], [2112, 2112, 2133, 2133, 2323], [2325, 2325, 2346, 2346, 2379], [2409, 2409, 2427, 2427, 3023], [3025, 3100, 3130, 3130, 3369], [3371, 3371, 3444, 3444, 3719], [3740, 3740, 3823, 3823, 5289], [5291, 5291, 5332, 5350, 7463]], "test": "untested"}
{"id": "NttyD2", "name": "Complex Functions Reserve", "author": "tungster24", "description": "a bunch of complex functions.\nnaming convention: z and w are imaginary, n is real, k is an integer\nif there's an error, please let me know and I'll fix it.\n\nyou are completely free to use this by the way, a thanks would be nice though :^)", "tags": ["complex", "functions", "resource"], "likes": 0, "viewed": 210, "published": 3, "date": "1660594640", "time_retrieved": "2024-07-30T16:35:31.124724", "image_code": "//complex operations resource\n//basic four operators\nvec2 addc(in vec2 z, in vec2 w) {return vec2(z.x+w.x,z.y+w.y);}\nvec2 subc(in vec2 z, in vec2 w) {return vec2(z.x-w.x,z.y-w.y);}\nvec2 mulc(in vec2 z, in vec2 w) {return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);}\nvec2 divc(in vec2 z, in vec2 w) {return vec2((z.x*w.x+z.y*w.y)/(w.x*w.x+w.y*w.y),(z.y*w.x-z.x*w.y)/(w.x*w.x+w.y*w.y));}\n\n//conjugate\nvec2 con(in vec2 z) {return vec2(z.x,-z.y);}\n//absolute value\nfloat absc(in vec2 z) {return sqrt(z.x*z.x+z.y*z.y);}\n//argument\nfloat arg(in vec2 z) {return atan(z.y,z.x);}\n//cis\nvec2 cis(in float x) {return vec2(cos(x),sin(x));}\n\n//real exponentiation\nvec2 powc(in vec2 z,in float n) {return pow(absc(z),n)*vec2(cos(arg(z)*n),sin(arg(z)*n));}\n//natural logarithm\nvec2 lnc(in vec2 z,in int k) {return vec2(log(absc(z)),arg(z)+6.2831*float(k));}\n//complex exp\nvec2 expc(in vec2 z) {return exp(z.x)*vec2(cos(z.y),sin(z.y));}\n\n//complex sine\nvec2 sinc(in vec2 z) {return vec2(sin(z.x)*cosh(z.y),cos(z.x)*sinh(z.y));}\n//complex cosine\nvec2 cosc(in vec2 z) {return vec2(cos(z.x)*cosh(z.y),sin(z.x)*sinh(z.y));}\n//complex tangent\nvec2 tanc(in vec2 z) {return vec2(sin(2.*z.x),sinh(2.*z.y))/(cos(2.*z.x)+cosh(2.*z.y));}\n\n//complex inverse sine\nvec2 invsinc(in vec2 z,in int k) {vec2 COMM = vec2(mulc(z,z).x-1.,mulc(z,z).y);return mulc(vec2(0.,-1.),lnc(addc(mulc(z,vec2(0.,1.)),mulc(vec2(sqrt(absc(COMM)),0.),expc(mulc(vec2(0.,0.5),vec2(arg(COMM),0.))))),0))+float(k)*6.2831;}\n//complex inverse cosine\nvec2 invcosc(in vec2 z,in int k) {vec2 COMM = vec2(mulc(z,z).x-1.,mulc(z,z).y);return mulc(vec2(0.,-1.),lnc(addc(z,mulc(vec2(sqrt(absc(COMM)),0.),expc(mulc(vec2(0.,0.5),vec2(arg(COMM),0.))))),0)) + float(k)*6.2831;}\n//complex inverse tangent\nvec2 invtanc(in vec2 z,in int k) {return mulc(vec2(0.,-0.5),lnc(divc(vec2(-z.x,1.-z.y),vec2(z.x,1.+z.y)),0))+float(k)*3.1415926;}\n//complex inverse cotangent\nvec2 invcotc(in vec2 z,in int k) {return mulc(vec2(0.,-0.5),lnc(divc(vec2(z.x,1.+z.y),vec2(-z.x,1.-z.y)),0))+float(k)*3.1415926;}\n\n//full exponentiation\nvec2 powf(in vec2 z,in vec2 w) {float r = absc(z); float t = arg(z);return expc(addc(mulc(vec2(log(r),0.),w),mulc(vec2(0.,t),w)));}\n//integer tetration\nvec2 tetc(in vec2 z,in int k) {vec2 w=z; for(int i=1;i<k;i++)w = powf(w,z); return w;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec2(1.-sin(iTime)/2.-fragCoord.xy/300.),0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 86, 86, 116], [117, 117, 150, 150, 180], [181, 181, 214, 214, 260], [261, 261, 294, 294, 380], [382, 394, 415, 415, 438], [439, 456, 479, 479, 509], [510, 521, 543, 543, 565], [566, 572, 594, 594, 622], [624, 646, 679, 679, 736], [737, 757, 787, 787, 837], [838, 852, 874, 874, 915], [917, 932, 954, 954, 1006], [1007, 1024, 1046, 1046, 1098], [1099, 1117, 1139, 1139, 1205], [1207, 1230, 1264, 1264, 1461], [1462, 1487, 1521, 1521, 1702], [1703, 1729, 1763, 1763, 1858], [1859, 1887, 1921, 1921, 2016], [2018, 2040, 2072, 2072, 2171], [2172, 2192, 2223, 2223, 2278], [2280, 2280, 2337, 2337, 2409]], "test": "untested"}
{"id": "7ttcDj", "name": "Cable nest v2", "author": "mrange", "description": "License CC0: Cable nest v2\nRevisited the old Cable nest shader and recoloured + tweaked distance field\nThought it turned out nice enough to share again", "tags": ["3d"], "likes": 22, "viewed": 515, "published": 3, "date": "1660592348", "time_retrieved": "2024-07-30T16:35:31.865743", "image_code": "// License CC0: Cable nest v2\n//  Revisited the old Cable nest shader and recoloured + tweaked distance field\n//  Thought it turned out nice enough to share again\n\n\n// ---\n\n// Some parameters to play with.\n\n#define BPM 120.0\n\n// Controls camera \"fisheye\" \n//#define RDD0\n//#define RDD1\n\n// cable shapes\n#define ROUNDEDX\n//#define BOX\n\n// Colour themes\n//#define THEME0\n#define THEME1\n//#define THEME2\n\n// If using aces approx \n#define HDR\n\n// Another distance field, slightly different\n//#define DF0\n\n// Number of iterations used for distance field\n#define MAX_ITER  3\n\n// ---\n\n\n#define TOLERANCE       0.0001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\nconst float cam_amp = 1.0;\n\nmat2 g_rot = ROT(0.0);\nfloat g_quad = 0.0;\nint g_hit = 0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 cam_path(float z) {\n  return vec3(cam_amp*sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b, float r) {\n  b -= r;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  p = abs(p);\n  return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat cables(vec3 p3) {\n  const float cylr = 0.2;\n  vec2 p = p3.xy;\n  float t = p3.z;\n  \n  const float ss = 1.5;\n  mat2 pp = ss*ROT(1.0+0.5*p3.z);\n\n  p *= g_rot;\n  float s = 1.0;\n  \n  float d = 1E6;\n  float quad = 1.0;\n  int hit = 0; \n  for (int i = 0; i < MAX_ITER; ++i) {\n    p *= pp;\n    p = abs(p);\n#if defined(DF0)\n    const float scaling = 3.0;\n    p -= 0.5*s*scaling;\n    s *= 1.0/ss;\n    float sz = scaling*s;\n#else\n    p -= 1.35*s;\n    s *= 1.0/ss;\n    const float sz = 1.0;\n#endif    \n    \n#if defined(ROUNDEDX)\n    float dd = roundedX(p, sz*1.5*cylr, sz*0.25*cylr)*s;\n#elif defined(BOX)\n    float dd = box(p, vec2(sz*cylr), sz*cylr*0.1)*s;\n#else\n    float dd = (length(p)-sz*cylr)*s;\n#endif\n    vec2 s = sign(p);\n    float q = s.x*s.y;\n    \n    if (dd < d) {\n      d = dd;\n      quad = q;\n      hit = i;\n    }\n    \n  }\n  \n  g_quad = quad;\n  g_hit = hit;\n  \n  return d;\n}\n\nfloat df(vec3 p) {\n  // Found this world warping technique somewhere but forgot which shader :(\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n  float d = cables(p);\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.1;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(NORMTOL,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos0  = cam_path(TIME-0.5);\n  vec3 lightPos1  = cam_path(TIME+6.5);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  float quad = g_quad;\n  float hit  = float(g_hit);\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*BPM/60.0));\n  vec3 bcol   = mix(HSV2RGB(vec3(0.6, 0.6, 3.0)), HSV2RGB(vec3(0.55, 0.8, 7.0)), beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return skyCol+gcol;\n  }\n  \n  vec3 nor    = normal(pos);\n\n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n\n  vec3 lv1    = lightPos1 - pos;\n  float ll21  = dot(lv1, lv1);\n  float ll1   = sqrt(ll21);\n  vec3 ld1    = lv1 / ll1;\n  float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);\n\n  vec3 col = vec3(0.0);\n\n  const vec3 black = vec3(0.0);\n#if defined(THEME0)\n  const vec3 dcol0 = HSV2RGB(vec3(0.6, 0.5, 1.0));\n  const vec3 dcol1 = dcol0;\n#elif defined(THEME1)\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = HSV2RGB(vec3(0.08, 1.0, 1.0));\n#elif defined(THEME2)\n  vec3 dcol0 = hsv2rgb(vec3(0.6-0.05*hit, 0.75, 1.0));\n  const vec3 dcol1 = HSV2RGB(vec3(0.8, 1.0, 0.));\n#else\n  const vec3 dcol0 = black;\n  const vec3 dcol1 = dcol0;\n#endif\n  col += dif0*sha0*mix(dcol0, dcol1, 0.5+0.5*quad);\n  col += spe1*bcol*bs;\n  col += gcol;\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float tm = TIME;\n  g_rot = ROT(-0.2*tm);\n  vec3 cam  = cam_path(tm);\n  vec3 dcam = dcam_path(tm);\n  vec3 ddcam= ddcam_path(tm);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n#if defined(RDD0)\n  float rdd = (2.0-0.5*tanh_approx(dot(p, p)));\n#elif defined(RDD1)\n  float rdd = (2.0+0.75*tanh_approx(dot(p, p)));\n#else\n  const float rdd = 2.5;\n#endif  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p);\n#if defined(HDR)\n  col = aces_approx(col);\n  col = sRGB(col);\n#else  \n  col = sqrt(col);\n#endif  \n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttcDj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1115, 1115, 1137, 1137, 1283], [1666, 1766, 1785, 1785, 1872], [1874, 1981, 2007, 2007, 2191], [2193, 2253, 2281, 2301, 2377], [2379, 2501, 2559, 2559, 3040], [3042, 3102, 3124, 3124, 3172], [3174, 3174, 3198, 3198, 3246], [3248, 3248, 3273, 3273, 3329], [3331, 3331, 3357, 3357, 3428], [3430, 3548, 3584, 3584, 3672], [3674, 3792, 3834, 3834, 3893], [3895, 3895, 3918, 3918, 4776], [4778, 4778, 4796, 4873, 5056], [5059, 5059, 5113, 5113, 5308], [5310, 5310, 5336, 5336, 5547], [5549, 5549, 5626, 5626, 5926], [5928, 5928, 5959, 5959, 7624], [7626, 7626, 7647, 7647, 8195], [8197, 8197, 8252, 8252, 8507]], "test": "untested"}
{"id": "fldyW2", "name": "Diamond Square algorithm.", "author": "jeyko", "description": "asdfgadg", "tags": ["mdtmjvm"], "likes": 9, "viewed": 432, "published": 3, "date": "1660575808", "time_retrieved": "2024-07-30T16:35:32.610750", "image_code": "// explanation: https://www.youtube.com/watch?v=4GuAV1PnurU\n// some creative liberty is taken to make it display here nicely.\nvoid mainImage( out vec4 C, in vec2 U){\n    \n    /*\n    C += texelFetch(\n        iChannel0,\n        ivec2(\n            vec2(res)*U/min(R.x,R.y)\n            ),\n        0\n        )*0.2;\n      */  \n        \n    C -= C;\n    \n    C += texelFetch(iChannel0,ivec2(U),0)*0.2;\n    \n    if(fract(iTime*0.125)<0.5)\n        C = vec4(1)*sin(C.x*3.+iTime)*0.5 + 0.5;\n    \n    C = 1.-exp(0.6*C); // bro y r u tonemapping ur noise 🤦‍\n    \n    C = pow(abs(C),vec4(0.4545));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n// dave hoskins hash\nvec4 hash44(vec4 p4)\n{\n    p4 += 1200.;\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nconst ivec2 res = ivec2(pow(2.,9.) + 1.);\n//#define res ivec2(R.y+1.)", "buffer_a_code": "\n\nvec4 getSquare(ivec2 lidx, int sz){\n    return (\n        texelFetch(iChannel0, (lidx + ivec2(sz,-sz))  % ivec2(R)   ,0) + \n        texelFetch(iChannel0, (lidx + ivec2(-sz,sz))  % ivec2(R)   ,0) +\n        texelFetch(iChannel0, (lidx + ivec2(-sz,-sz)) % ivec2(R)   ,0) + \n        texelFetch(iChannel0, (lidx + ivec2(sz,sz))   % ivec2(R)    ,0) \n    )/4.\n    ;\n}\n\nvec4 getDiamond(ivec2 lidx, int sz){\n    return (\n        texelFetch(iChannel0,(lidx + ivec2(0,sz) ) % ivec2(R),0) + \n        texelFetch(iChannel0,(lidx + ivec2(sz,0) ) % ivec2(R),0) +\n        texelFetch(iChannel0,(lidx + ivec2(-sz,0)) % ivec2(R),0) + \n        texelFetch(iChannel0,(lidx + ivec2(0,-sz)) % ivec2(R),0) \n    )/4.\n    ;\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n    \n    C = texelFetch(iChannel0,ivec2(U),0) ;\n    \n    \n    ivec2 idx = ivec2(U);\n    \n    bool currPixelIsTime = ( idx.x == int(R.x - 1.) && idx.y == int(R.y - 1.) ) ;\n    \n    \n    \n    \n    int t = floatBitsToInt(texelFetch(iChannel0,ivec2(R.x-1.,R.y-1.),0).x);\n\n    // Init bs    \n    {\n        if(iFrame == 0){\n            C -= C;\n            return;\n        }\n        // increment time counter pixel\n        if(idx.x == int(R.x - 1.) &&idx.y == int(R.y - 1.) ){\n\n            C = vec4(intBitsToFloat(t + 1));\n            if(iMouse.z > 0.)\n                C -= C;\n            return;\n        }\n\n        if(t == 0 || iMouse.z > 0.){\n            C -= C;\n            return;\n        }   \n        //if(idx.x >= res.x || idx.y >= res.y) return;\n\n\n        // First step\n        if(t == 1){\n            if( idx.y == 0 || idx.y == res.y - 1){\n                if(idx.x == 0 || idx.x == res.x - 1){\n                    C =  hash44(vec4(idx,0.,0));\n                }\n            }\n            return;\n        }\n    }\n\n    int st = t%2;\n    int stId = t/2;\n    \n    \n    int chunkSz = (res.x-1)/int(pow(2.,float(stId-1)));\n    \n    float roughness = exp(-float(stId)*0.1);\n    //roughness = 1.;\n    \n    int halfChunkSz = chunkSz/2;\n    \n    \n    \n    \n    if(chunkSz <= 1)\n        return;\n    \n    \n    \n    \n    float bias = 1.;\n    float biasMin = -1.;\n    float biasMax = 2.;\n    \n    \n    #define getBias(r) ((r)*(biasMax - biasMin) + biasMin)*bias\n    if(st == 0){\n        // Square\n        ivec2 lidx = idx - halfChunkSz;\n        if(\n            lidx.x%chunkSz == 0 \n            && lidx.y%chunkSz == 0\n        ){\n            C = getSquare(lidx, chunkSz) + getBias(hash44(vec4(lidx,0.,iTime)))*roughness;\n        }\n       \n    }else{\n        // Diamond\n        ivec2 lidx = idx;\n        \n        if(\n            (lidx.x + (lidx.y + halfChunkSz) % chunkSz ) % chunkSz == 0 \n            && (lidx.y) % halfChunkSz == 0\n        ){\n            C = getDiamond(lidx, halfChunkSz) + getBias(hash44(vec4(lidx,0.,iTime)))*roughness;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 126, 165, 318, 589]], "test": "untested"}
{"id": "Nlccz2", "name": "Yin-Yang Zoom (311 chars)", "author": "fenix", "description": "Infinite zoom effect with yin-yang symbol. Let the code golfing begin!\n\n", "tags": ["zoom", "recursion", "infinite", "yinyang", "golf"], "likes": 6, "viewed": 264, "published": 3, "date": "1660557467", "time_retrieved": "2024-07-30T16:35:33.354761", "image_code": "// from Xor: 311 chars (with initializing O to zero)\n//*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy*.5,\n    p = vec2(0, .5), s;\n    \n    float i = 1.,\n        z = exp(-mod(iTime * .7, 4.6)),\n        w = z / R.y, l = w;\n    \n    u = ((u - R) / R.y + sin(iTime + p*66.) * .3) * z +\n         --z * p / .9;\n         \n    for (O = p.xxxx; l<.2; w /= .1)\n        \n        s = sign(u),\n        l = length(u*s - p),\n        z = length(u),\n        O += smoothstep(w+w, 0., min(max(--z,.5*s.y-l*s.x+w), abs(z))) * i,\n        i *= s.y,\n        u -= p*s,\n        u /= .1;\n}\n/**/\n\n// from Xor: 307 chars, but using O -= O which does not work on all platforms (such as iPad app)\n\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy*.5,\n    p = vec2(0, .5), s;\n    \n    float i = 1.,\n        z = exp(-mod(iTime * .7, 4.6)),\n        w = z / R.y, l = w;\n    \n    u = ((u - R) / R.y + sin(iTime + p*66.) * .3) * z +\n         --z * p / .9;\n         \n    for (O -= O; l<.2; w /= .1)\n        \n        s = sign(u),\n        l = length(u*s - p),\n        z = length(u),\n        O += smoothstep(w+w, 0., min(max(--z,.5*s.y-l*s.x+w), abs(z))) * i,\n        i *= s.y,\n        u -= p*s,\n        u /= .1;\n}\n/**/\n\n\n/*\n// Original golf attempt by fenix (444 chars)\n\n#define n length\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    vec3 R = iResolution;\n    vec2 p = vec2(0., .5);\n    float i = 1.,\n        z = pow(.1, mod(iTime * .3, 2.)),\n        w = z * 2. / R.y;\n        \n    O -= O;\n    for (u = ((2.* u - R.xy) / R.y + vec2(sin(iTime), cos(iTime)) * .3) * z +\n         (z - 1.) * p * 1.111;; w *= 10.)\n    {\n        float l = n(u - p),\n            m = n(u + p),\n            d = n(u),\n            e = -d * w,\n            r = clamp(float(u.x > 0. && d < 1. && l > 0.5)\n                + smoothstep(-1. + e, -1. - e, -d) * float(m < .5), 0., 1.)\n                + smoothstep(e, 0., -abs(d - 1.));\n             \n        O += i * r;\n        \n        if (l < .2)\n            u = (u - p) * 10.;\n        else if (m < .2)\n            u = (u + p) * 10.,\n            i = -i;\n        else break;\n    }\n}\n/**/\n\n/*\n// Original:\nconst vec2 p1 = vec2(0.0, 0.5);\n\n// Based on Antialized Circle by Dmitry https://www.shadertoy.com/view/tsySWy\nfloat aaCircle(vec2 uv, float wd)\n{\n    // 2. draw anti-aliased circle\n    float d = length(uv);\n    float circle = smoothstep(0.0, d * wd, abs(d - 1.0));\n\n    // 3. result\n    return 1.0 - circle;\n}\n\nfloat aaFilledCircle(vec2 uv, float wd)\n{\n    // 2. draw anti-aliased circle\n    float d = length(uv);\n    float circle = smoothstep(1.0 - d * wd, 1.0 + d * wd, d);\n\n    // 3. result\n    return 1.0 - circle;\n}\n\nfloat drawYY(in vec2 u, inout float l1, inout float l2, float wd)\n{\n    l1 = length(u - p1);\n    l2 = length(u + p1);\n    float r = aaCircle(u, wd);\n    if (u.x > 0.0 && length(u) < 1.0)\n    {\n        r = max(0.0, 1.0 - r);\n    }\n    if (l1 < 0.50 && length(u) < 1.0 - wd)\n    {\n        r -= aaFilledCircle((u - p1) * 2.0, wd);\n    }\n    if (l2 < 0.50)\n    {\n        r += aaFilledCircle((u + p1) * 2.0, wd);\n    }\n    return clamp(r, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    float invert = 1.0;\n    float flip = 1.0;\n    float time = mod(iTime * 0.3, 2.0);\n    float zoom = pow(.1, time);\n    float wd = zoom * 2./(min(iResolution.x, iResolution.y));\n\tu = (2.* u - iResolution.xy) / iResolution.y;\n    u += vec2(sin(iTime), cos(iTime)) * 0.3;\n    vec2 ou = u;\n    vec2 p3 = p1 * (2.0 - 0.88888);\n    u = (u + p3) * zoom - p3;\n    float l1, l2;\n    O = vec4(0);\n    int step;\n    for ( step = 0; step < 5; ++step)\n    {\n        O += invert * vec4(drawYY(u * flip, l1, l2, wd));\n        wd *= 10.0;\n        if (l1 <= 0.11)\n        {\n            u = (u - p1) * 10.0;\n        }\n        else if (l2 <= 0.11)\n        {\n            u = (u + p1) * 10.0;\n            invert = -invert;\n        }\n        else break;\n    }\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlccz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 93, 93, 583]], "test": "untested"}
{"id": "slccDj", "name": "advanced CRT filter", "author": "whkrmrgks0", "description": "feel free to use. integration to any kind of open source software is appreciated.\nPlease read the Common tab for info.\nretroarch slang shader: https://github.com/whkrmrgks0/Advanced-CRT-shader\n\ntodo: maike a multi-pass version with better performance", "tags": ["postprocessing", "filter", "crt"], "likes": 12, "viewed": 1374, "published": 3, "date": "1660547470", "time_retrieved": "2024-07-30T16:35:34.096777", "image_code": "#define tau 6.28318530718\n#define cr vec2(4.,0.)\n#define cb vec2(2.,0.)\n#define cg vec2(0.,0.)\n#define cw vec2(3.,1.)\n\nfloat sawtooth(float inp){\n    return inp-floor(inp);\n}\n\nfloat square(float zed,float marchpoint,float floaz){\n    return step(sawtooth(zed/floaz),marchpoint/floaz);\n}\n\nfloat triangle(float zed){\n    return abs(sawtooth(zed+0.5)-.5)*2.;\n}\n\nvec2 hash22(vec2 seed){\n    return fract(75.345*sin(623.3754*seed));\n}\n\nfloat grd(vec2 uv, vec2 disp){\n    uv +=disp*dts;\n    uv /= dts;\n    return square(uv.x,2.,6.)*square(uv.y,1.,2.);\n}\n\nvec3 tpscany (vec3 bef,vec3 ucj,vec3 dcj,float temp){\n    vec3 scan = vec3(.0);\n    scan += max((triangle(temp)-1.+(bef*sling)),.0);\n    scan += max((clamp(.0,1.,temp*2.-1.)-2.)+(ucj*sling),.0);\n    scan += max((clamp(.0,1.,-(temp*2.-1.))-2.)+(dcj*sling),.0);\n    return scan/(sling*0.5);\n}\n \nvoid pinc(vec2 uv, inout vec2 uv2, inout float mxbf, inout float vign, float ar){\n    uv2 = (uv*vec2(2.)-vec2(1.))*vec2((1.+marginv),(1.+marginv*ar));\n    uv2 = vec2(uv2.x/(cos(abs(uv2.y*cus)*tau/4.)),uv2.y/(cos(abs(uv2.x*cus*ar)*tau/4.)));\n    vec2 uvbef = abs(uv2)-vec2(1.);//boarder\n    mxbf = max(uvbef.x,uvbef.y);\n    vign = max(uvbef.x*uvbef.y,.0);\n    uv2 = (uv2+vec2(1.))*vec2(.5);//recoordination\n}\n\nfloat scimpresp(float range){//scanline IR\n    return sin(pow(range,capashape)*tau)+1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv2;\n    float mxbf, vign;\n    vec2 ratd = fragCoord;\n    vec2 uv = fragCoord/iResolution.xy;\n    pinc(uv,uv2,mxbf,vign,iResolution.x/iResolution.y);\n    vec2 nuv = uv2;\n    vec2 nuvyud = vec2(floor(nuv.y*scanline-1.)/scanline,floor(nuv.y*scanline+1.)/scanline);\n    nuv.y = floor(nuv.y*scanline)/scanline;\n\n    vec3 bef = vec3(.0);\n    vec3 ucj = vec3(.0);\n    vec3 dcj = vec3(.0);\n    \n    float capatemp, capainteg = .0;\n    for(float i=-capaiter/2.;i<capaiter/2.;i++){\n        capatemp = scimpresp((i+capaiter/2.)/capaiter);\n        capainteg += capatemp;\n        bef += texture(iChannel0,vec2(sawtooth(nuv.x-capa/scanline*i/(capaiter/2.)),nuv.y)).xyz*capatemp;\n        ucj += texture(iChannel0,vec2(sawtooth(nuv.x-capa/scanline*i/(capaiter/2.)),nuvyud.y)).xyz*capatemp;\n        dcj += texture(iChannel0,vec2(sawtooth(nuv.x-capa/scanline*i/(capaiter/2.)),nuvyud.x)).xyz*capatemp;\n    }\n    dcj /= capainteg;\n    bef /= capainteg;\n    ucj /= capainteg;\n    \n    vec3 scan =vec3(.0);\n    float temp;\n    float snippet;\n    float integral = .0;\n    for(float i = -AAz/2.; i<=AAz/2. ;i++){\n        snippet = (AAz/2.-abs(i))/AAz/2.;\n        integral += snippet;\n        temp = sawtooth(uv2.y*scanline);\n        scan += tpscany(bef,ucj,dcj,temp+(i/AAz*2.)*vex/iResolution.y*scanline)*snippet;//antimoire convololution\n    }\n    scan /= integral;\n\n    float brd = step(mxbf,.0);\n    vign = pow(vign,vstr);\n    \n    vec3 grid = vec3(grd(ratd,cr),grd(ratd,cg),grd(ratd,cb));\n    grid += vec3(grd(ratd,cr+cw),grd(ratd,cg+cw),grd(ratd,cb+cw));\n    \n    float mask = brd*vign;\n    \n    scan /= sling;\n    scan = pow(scan,vec3(0.5));\n    scan = pow(scan,vec3(1.+1./3.));\n    scan = pow(scan,vec3(gma));\n    \n    vec3 grided = scan*grid*3.;\n    vec3 final = min(vec3(mix(grided,scan,scan)),vec3(1.))*mask;\n    \n    fragColor = vec4(final,1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------notes for integration--------\n\n//CRT curvature\nconst float cus = 0.15;\n\n//Vignette strength\nconst float vstr = .05;\n\n//Display margin\nconst float marginv = .02;\n\n//Phosper size (should be an integer)\nconst float dts = 1.;\n\n//De-moire convolution iteration (if you see moire, up this value)\nconst float AAz = 64.;\n\n//De-moire convolution width (don't touch if you have no idea)\nconst float vex = 2.;\n\n//Capacitance (scanline horizontal blur)\nconst float capa = 1.;\n\n//Capacitnace iteration\nconst float capaiter  = 5.0;\n\n//Capacitance IR shape parameter\nconst float capashape = 3.0;\n\n//Scanline count\nconst float scanline =240.;\n\n//Gamma correction\nconst float gma = 1.0;\n\n//Line bleed\nconst float sling = 2.0;\n\n//------------------------------------\n\n\n/*\n\nGPLv3\n\nThis file is part of advanced CRT filter by whkrmrgks0.\n\nadvanced CRT filter by whkrmrgks0 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\nadvanced CRT filter by whkrmrgks0 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with advanced CRT filter by whkrmrgks0. If not, see <https://www.gnu.org/licenses/>.\n\n\nunlike the one i made before, this one is made with authenticity and performance in mind.\n\n\nthis shader features:\n\n1x1 to whatever size you want\nScanline width modulation\nCustomisable scanlines\nCustomisable curvature\nCustomisable vignette\nCustomisable capacitance artifact\nCustomisable horizontal pre-sharpen filter\nPhosper pattern without any dimming\nAnti moire convolution filter\n\nall of those in a single pass\n\naug 15 2022\n\ncopyright 2022\nwhkrmrgks0\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slccDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 145, 145, 174], [176, 176, 229, 229, 286], [288, 288, 314, 314, 357], [359, 359, 382, 382, 429], [431, 431, 461, 461, 547], [549, 549, 602, 602, 839], [842, 842, 923, 923, 1249], [1251, 1251, 1280, 1293, 1340], [1342, 1342, 1396, 1396, 3240]], "test": "untested"}
{"id": "slcyWj", "name": "deep 29input", "author": "lomateron", "description": "9input is 3x3 pixel grid\n18input is 2 layers of 3x3 pixel grid, grids reads from 1st,2nd previous frames\n29input is 5x5 pixel grid plus 4 pixels at north-south-east-west border of grid\n", "tags": ["automata"], "likes": 5, "viewed": 222, "published": 3, "date": "1660541337", "time_retrieved": "2024-07-30T16:35:34.849764", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a = A(fragCoord).xy;\n    if((iFrame&1)==0){a = a.xy;}\n    if((iFrame&1)==1){a = a.yx;}\n    fragColor = vec4(dot(a,vec2(1,2)/3.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0))\n             \n             +A(u+vec2( 2,-2))\n             +A(u+vec2( 2,-1))\n             +A(u+vec2( 2, 0))\n             +A(u+vec2( 2, 1))\n             +A(u+vec2( 2, 2))\n             +A(u+vec2( 1, 2))\n             +A(u+vec2( 0, 2))\n             +A(u+vec2(-1, 2))\n             +A(u+vec2(-2, 2))\n             +A(u+vec2(-2, 1))\n             +A(u+vec2(-2, 0))\n             +A(u+vec2(-2,-1))\n             +A(u+vec2(-2,-2))\n             +A(u+vec2(-1,-2))\n             +A(u+vec2( 0,-2))\n             +A(u+vec2( 1,-2))\n             \n             +A(u+vec2( 3, 0))\n             +A(u+vec2( 0, 3))\n             +A(u+vec2(-3, 0))\n             +A(u+vec2( 0,-3));\n    uint s = uint(dot(a,vec4(1,0,0,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((+16U*8U*16U*8U* (1U<<12U)\n                     +16U*8U*16U*    0U\n                     +16U*8U*        0U\n                     +16U*           0U\n                     +               15U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                     3467.5678,\n                                                                     4467.5678,\n                                                                     5467.5678))+.1);\n        o*= step(dot(v,v),dot(m,m)*.5);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 249]], "test": "untested"}
{"id": "NlccDj", "name": "deep 18input 6", "author": "lomateron", "description": "why it has color?\nread user comment in https://www.shadertoy.com/view/Nltyzs\n", "tags": ["automata"], "likes": 4, "viewed": 221, "published": 3, "date": "1660520770", "time_retrieved": "2024-07-30T16:35:35.590783", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    if((iFrame%3)==0){a = a.xyzw;}\n    if((iFrame%3)==1){a = a.yzxw;}\n    if((iFrame%3)==2){a = a.zxyw;}\n    fragColor = a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    uint s = uint(dot(a,vec4(1,1,0,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((+16U*8U*16U*8U* 8U\n                     +16U*8U*16U*    7U\n                     +16U*8U*        2U\n                     +16U*           1U\n                     +               0U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                     3467.5678,\n                                                                     4467.5678,\n                                                                     5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.2);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlccDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 261]], "test": "untested"}
{"id": "flccDj", "name": "deep 18input 5", "author": "lomateron", "description": "why it has color?\nread user comment in https://www.shadertoy.com/view/Nltyzs\n", "tags": ["automata"], "likes": 3, "viewed": 190, "published": 3, "date": "1660520493", "time_retrieved": "2024-07-30T16:35:36.351748", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    if((iFrame%3)==0){a = a.xyzw;}\n    if((iFrame%3)==1){a = a.yzxw;}\n    if((iFrame%3)==2){a = a.zxyw;}\n    fragColor = a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    uint s = uint(dot(a,vec4(1,1,0,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((+16U*8U*16U*8U* 3U\n                     +16U*8U*16U*    7U\n                     +16U*8U*        0U\n                     +16U*           3U\n                     +               15U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                     3467.5678,\n                                                                     4467.5678,\n                                                                     5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.05);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flccDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 261]], "test": "untested"}
{"id": "fl3cDj", "name": "deep 18input 4", "author": "lomateron", "description": "why it has color?\nread user comment in https://www.shadertoy.com/view/Nltyzs\n", "tags": ["automata"], "likes": 3, "viewed": 194, "published": 3, "date": "1660520096", "time_retrieved": "2024-07-30T16:35:37.093764", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    if((iFrame%3)==0){a = a.xyzw;}\n    if((iFrame%3)==1){a = a.yzxw;}\n    if((iFrame%3)==2){a = a.zxyw;}\n    fragColor = a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    uint s = uint(dot(a,vec4(1,1,0,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((+16U*8U*16U*8U* 5U\n                     +16U*8U*16U*    7U\n                     +16U*8U*        12U\n                     +16U*           1U\n                     +               0U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                     3467.5678,\n                                                                     4467.5678,\n                                                                     5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.04);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3cDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 261]], "test": "untested"}
{"id": "NtcyDj", "name": "deep 18input 3", "author": "lomateron", "description": "why it has color?\nread user comment in https://www.shadertoy.com/view/Nltyzs\nin Buffer A mod whats commented", "tags": ["automata"], "likes": 6, "viewed": 172, "published": 3, "date": "1660518697", "time_retrieved": "2024-07-30T16:35:37.921551", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    if((iFrame%3)==0){a = a.xyzw;}\n    if((iFrame%3)==1){a = a.yzxw;}\n    if((iFrame%3)==2){a = a.zxyw;}\n    fragColor = a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    uint s = uint(dot(a,vec4(1,1,0,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((+16U*8U*16U*8U* 7U //mod 7U to get similar world\n                     +16U*8U*16U*    3U\n                     +16U*8U*        8U\n                     +16U*           0U\n                     +               15U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(u,vec2(1.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                     3467.5678,\n                                                                     4467.5678,\n                                                                     5467.5678))+.005);\n        o*= step(dot(v,v),dot(m,m)*.5);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 261]], "test": "untested"}
{"id": "Nt3yDj", "name": "deep 18input 2", "author": "lomateron", "description": "why it has color?\nread user comment in https://www.shadertoy.com/view/Nltyzs\ngame of life deeper cousin?", "tags": ["automata"], "likes": 2, "viewed": 165, "published": 3, "date": "1660516997", "time_retrieved": "2024-07-30T16:35:38.736372", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    if((iFrame%3)==0){a = a.xyzw;}\n    if((iFrame%3)==1){a = a.yzxw;}\n    if((iFrame%3)==2){a = a.zxyw;}\n    fragColor = a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    uint s = uint(dot(a,vec4(1,1,0,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((+16U*8U*16U*8U* 1U \n                     +16U*8U*16U*    2U\n                     +16U*8U*        8U\n                     +16U*           0U\n                     +               11U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(v,vec2(234.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                       3467.5678,\n                                                                       4467.5678,\n                                                                       5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.01);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3yDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 261]], "test": "untested"}
{"id": "flccWj", "name": "deep 18input", "author": "lomateron", "description": "why is it colored? read user comments of https://www.shadertoy.com/view/Nltyzs\nafter traveling through 2^13 diferent univers of 2^19 total\nwill post my top interesten starting with this\nmost of them are noise worlds waiting for decodetion", "tags": ["binaryfunction"], "likes": 5, "viewed": 188, "published": 3, "date": "1660515643", "time_retrieved": "2024-07-30T16:35:39.546207", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = A(fragCoord);\n    if((iFrame%3)==0){a = a.xyzw;}\n    if((iFrame%3)==1){a = a.yzxw;}\n    if((iFrame%3)==2){a = a.zxyw;}\n    fragColor = a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    uint s = uint(dot(a,vec4(1,1,0,0)));\n    vec4 o = A(u+vec2(0,0)).xxyz;\n         o.x=float(((16U*8U*16U*8U* 8U + 7U*16U+14U)>>s)&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(v,vec2(234.76543,iTime+22.5363)))*vec4(2467.5678,\n                                                                       3467.5678,\n                                                                       4467.5678,\n                                                                       5467.5678))+.5);\n        o*= step(dot(v,v),dot(m,m)*.5);\n    }\n    fragColor = o;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flccWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 261]], "test": "untested"}
{"id": "stdcWB", "name": "Lightmotif V1", "author": "grahamcracker8155", "description": "great stuff", "tags": ["synthwave"], "likes": 6, "viewed": 936, "published": 3, "date": "1660500174", "time_retrieved": "2024-07-30T16:35:40.294207", "image_code": "//#define VAPORWAVE\n//#define AA 2\n//#define stereo\n#define speed 1. \n#define wave_thing\n\n//you can add any sound texture in iChannel0 to turn it into a cool audio visualizer (it looks better with lower speeds though)\n//you should commment out or remove the following line to enable it:\n#define disable_sound_texture_sampling\n\n\nvec4 textureMirror(sampler2D tex, vec2 c){\n    #ifdef disable_sound_texture_sampling\n    return vec4(0);\n    #else\n    vec2 cf = fract(c);\n    return texture(tex,mix(cf,1.-cf,mod(floor(c),2.)));\n    #endif\n}\n\nfloat jTime;\n\nfloat amp(vec2 p){\n    return smoothstep(1.,8.,abs(p.x));\n    \n}\nfloat pow512(float a){\n    a*=a;//^2\n    a*=a;//^4\n    a*=a;//^8\n    a*=a;//^16\n    a*=a;//^32\n    a*=a;//^64\n    a*=a;//^128\n    a*=a;//^256\n    return a*a;\n}\nfloat pow1d5(float a){\n    return a*sqrt(a);\n}\nfloat hash21(vec2 co){\n    return fract(sin(dot(co.xy,vec2(1.9898,7.233)))*45758.5433);\n}\nfloat hash(vec2 uv){\n    float a = amp(uv);\n    #ifdef wave_thing\n    float w = a>0.?(1.-.4*pow512(.51+.49*sin((.02*(uv.y+.5*uv.x)-jTime)*2.))):0.;\n    #else\n    float w=1.;\n    #endif\n    return (a>0.?\n        a*pow1d5(\n        //texture(iChannel0,uv/iChannelResolution[0].xy).r\n        hash21(uv)\n        )*w\n        :0.)-(textureMirror(iChannel0,vec2((uv.x*29.+uv.y)*.03125,1.)).x)*.25;\n}\n\nfloat edgeMin(float dx,vec2 da, vec2 db,vec2 uv){\n    uv.x+=5.;\n    vec3 c = fract((round(vec3(uv,uv.x+uv.y)))*(vec3(0,1,2)+0.61803398875));\n    float a1 = textureMirror(iChannel0,vec2(c.y,0.)).x>.6?.15:1.;\n    float a2 = textureMirror(iChannel0,vec2(c.x,0.)).x>.6?.15:1.;\n    float a3 = textureMirror(iChannel0,vec2(c.z,0.)).x>.6?.15:1.;\n\n    return min(min((1.-dx)*db.y*a3,da.x*a2),da.y*a1);\n}\n\nvec2 trinoise(vec2 uv){\n    const float sq = sqrt(3./2.);\n    uv.x *= sq;\n    uv.y -= .5*uv.x;\n    vec2 d = fract(uv);\n    uv -= d;\n\n    bool c = dot(d,vec2(1))>1.;\n\n    vec2 dd = 1.-d;\n    vec2 da = c?dd:d,db = c?d:dd;\n    \n    float nn = hash(uv+float(c));\n    float n2 = hash(uv+vec2(1,0));\n    float n3 = hash(uv+vec2(0,1));\n\n    \n    float nmid = mix(n2,n3,d.y);\n    float ns = mix(nn,c?n2:n3,da.y);\n    float dx = da.x/db.y;\n    return vec2(mix(ns,nmid,dx),edgeMin(dx,da, db,uv+d));\n}\n\n\nvec2 map(vec3 p){\n    vec2 n = trinoise(p.xz);\n    return vec2(p.y-2.*n.x,n.y);\n}\n\nvec3 grad(vec3 p){\n    const vec2 e = vec2(.005,0);\n    float a =map(p).x;\n    return vec3(map(p+e.xyy).x-a\n                ,map(p+e.yxy).x-a\n                ,map(p+e.yyx).x-a)/e.x;\n\n}\n\nvec2 intersect(vec3 ro,vec3 rd){\n    float d =0.,h=0.;\n    for(int i = 0;i<500;i++){ //look nice with 50 iterations\n        vec3 p = ro+d*rd;\n        vec2 s = map(p);\n        h = s.x;\n        d+= h*.5;\n        if(abs(h)<.003*d)\n            return vec2(d,s.y);\n        if(d>150.|| p.y>2.) break;\n    }\n    \n    return vec2(-1);\n}\n\n\nvoid addsun(vec3 rd,vec3 ld,inout vec3 col){\n    \n\tfloat sun = smoothstep(.21,.2,distance(rd,ld));\n    \n    if(sun>0.){\n        float yd = (rd.y-ld.y);\n\n        float a =sin(3.1*exp(-(yd)*14.)); \n\n        sun*=smoothstep(-.8,0.,a);\n\n        col = mix(col,vec3(1.,.8,.4)*.75,sun);\n    }\n}\n\n\nfloat starnoise(vec3 rd){\n    float c = 0.;\n    vec3 p = normalize(rd)*300.;\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p)-.5;\n        vec3 id = floor(p);\n        float c2 = smoothstep(.5,0.,length(q));\n        c2 *= step(hash21(id.xz/id.y),.06-i*i*0.005);\n        c += c2;\n        p = p*.6+.5*p*mat3(3./5.,0,4./5.,0,1,0,-4./5.,0,3./5.);\n    }\n    c*=c;\n    float g = dot(sin(rd*10.512),cos(rd.yzx*10.512));\n    c*=smoothstep(-3.14,-.9,g)*.5+.5*smoothstep(-.3,1.,g);\n    return c*c;\n}\n\nvec3 gsky(vec3 rd,vec3 ld,bool mask){\n    float haze = exp2(-5.*(abs(rd.y)-.2*dot(rd,ld)));\n    //float st = mask?pow512(texture(iChannel0,(rd.xy+vec2(300.1,100)*rd.z)*10.).r)*(1.-min(haze,1.)):0.;\n    //float st = mask?pow512(hash21((rd.xy+vec2(300.1,100)*rd.z)*10.))*(1.-min(haze,1.)):0.;\n    float st = mask?(starnoise(rd))*(1.-min(haze,1.)):0.;\n    vec3 col=clamp(mix(vec3(.4,.1,.7)*(1.-.5*textureMirror(iChannel0,vec2(.5+.05*rd.x/rd.y,0.)).x*exp2(-.1*abs(length(rd.xz)/rd.y))*max(sign(rd.y),0.)),\n                    vec3(.7,.1,.4),haze)+st,0.,1.);\n    if(mask)addsun(rd,ld,col);\n    return col;\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    #ifdef AA\n    for(float x = 0.;x<1.;x+=1./float(AA)){\n    for(float y = 0.;y<1.;y+=1./float(AA)){\n    #else\n        const float AA=1.,x=0.,y=0.;\n    #endif\n    vec2 uv = (2.*(fragCoord+vec2(x,y))-iResolution.xy)/iResolution.y;\n    \n\t//float dt = fract(texture(iChannel0,float(AA)*(fragCoord+vec2(x,y))/iChannelResolution[0].xy).r+iTime);\n    float dt = fract(hash21(float(AA)*(fragCoord+vec2(x,y)))+iTime);\n    jTime = mod(iTime-dt*iTimeDelta*.25,4000.);\n    vec3 ro = vec3(0.,1,(-20000.+jTime*speed));\n    \n        #ifdef stereo\n            ro+=vec3(.2*(float(uv.x>0.)-.5),0.,0.); //-= for x-view\n            const float de = .9;\n            uv.x=uv.x+.5*(uv.x>0.?-de:de);\n            uv*=2.;\n\t\t#endif\n        \n    vec3 rd = normalize(vec3(uv,4./3.));//vec3(uv,sqrt(1.-dot(uv,uv)));\n    \n    vec2 i = intersect(ro,rd);\n    float d = i.x;\n    \n    vec3 ld = normalize(vec3(0,.125+.05*sin(.1*jTime),1));\n\n    vec3 fog = d>0.?exp2(-d*vec3(.14,.1,.28)):vec3(0.);\n    vec3 sky = gsky(rd,ld,d<0.);\n    \n    vec3 p = ro+d*rd;\n    vec3 n = normalize(grad(p));\n    \n    float diff = dot(n,ld)+.1*n.y;\n    vec3 col = vec3(.1,.11,.18)*diff;\n    \n    vec3 rfd = reflect(rd,n); \n    vec3 rfcol = gsky(rfd,ld,true);\n    \n    col = mix(col,rfcol,.05+.95*pow(max(1.+dot(rd,n),0.),5.));\n    #ifdef VAPORWAVE\n    col = mix(col,vec3(.4,.5,1.),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    col = sqrt(col);\n    #else\n    col = mix(col,vec3(.8,.1,.92),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    //no gamma for that old cg look\n    #endif\n    if(d<0.)\n        d=1e6;\n    d=min(d,10.);\n    fragColor += vec4(clamp(col,0.,1.),d<0.?0.:.1+exp2(-d));\n     #ifdef AA\n    }\n    }\n    fragColor/=float(AA*AA);\n    #endif\n    \n}\n\n/** SHADERDATA\n{\n\t\"title\": \"another synthwave sunset thing\",\n\t\"description\": \"I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 328, 370, 370, 535], [551, 551, 569, 569, 615], [616, 616, 638, 638, 775], [776, 776, 798, 798, 822], [823, 823, 845, 845, 912], [913, 913, 933, 933, 1304], [1306, 1306, 1355, 1355, 1701], [1703, 1703, 1726, 1726, 2193], [2196, 2196, 2213, 2213, 2277], [2279, 2279, 2297, 2297, 2463], [2465, 2465, 2497, 2497, 2793], [2796, 2796, 2840, 2840, 3083], [3086, 3086, 3111, 3111, 3583], [3585, 3585, 3622, 3622, 4191]], "test": "untested"}
{"id": "NltyDB", "name": "Sine Spectrogram", "author": "MysteryPancake", "description": "Sine waves making up a spectrogram", "tags": ["wave", "spectrum", "sdf", "sine", "waveform", "spectrogram"], "likes": 5, "viewed": 287, "published": 3, "date": "1660476225", "time_retrieved": "2024-07-30T16:35:41.033232", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 result = vec3(0.0);\n    const int iterations = 48;\n    \n    for (int i = 0; i <= iterations; i++) {\n        float percent = float(i) / float(iterations);\n        float spectrum = texture(iChannel0, vec2(percent, 0.0)).x;\n        float amplitude = 0.02 * spectrum;\n        float sine = percent + sin(iTime * 8.0 + uv.y * float(i * 4)) * amplitude;\n        result += vec3(0.0016 / distance(vec2(sine, uv.y), uv)) * uv.xyx;\n    }\n    \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 576]], "test": "untested"}
{"id": "ftdyDS", "name": "Iijtunnel music remix 3", "author": "jarble", "description": "More simple patterns", "tags": ["music", "fireworks", "iij"], "likes": 10, "viewed": 452, "published": 3, "date": "1660458033", "time_retrieved": "2024-07-30T16:35:41.806165", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 U =( 2.*fragCoord-iResolution.xy)/iResolution.y;\n\n  float b=sqrt(length(U)),num=128.;\n  \n  U=fract(vec2(b,abs(atan(U.x,U.y))));\n  num /=\n      1. + mod(U.x,2.)\n      \n      //WOW!\n      //1. + mod(U.x*4.,1.)\n  \n  ; //\"fireworks\" effect\n\n  U=floor(mod(vec2(U.x-iTime/4.,U.y)*num,vec2(num)));\n\n  float d=b*mod((U.x*U.y),U.x)/num;\n\n  fragColor=vec4(fract(d*U.x),fract(d*U.y),d,1.);\n    \n\n}", "image_inputs": [], "sound_code": "//double spaced so it looks like more work\n\nfloat song(float t, float d){\n\n  return pow(2.,mod(t*t*(floor(t/(d))),d)/3.+6.);\n\n}\n\nvec2 mainSound(int samp, float time){\n\n  time += floor(time*2.)/2.;\n  \n  float t=(time+10.)*4.,a=sqrt(1.-sqrt(fract(t)))*.2,\n\n  m=64.,\n  \n  nb = 0.,\n  \n  z1=.125;\n  \n  for(int i = 0; i < 4;i++){\n  \n      z1 *= 2.;\n  \n      nb = max(nb/z1,song(floor(t*z1/floor(1.+mod(t*2.,2.))),m/4.));\n      \n      //this song is even weirder\n      //nb = (nb+max(nb/z1,song(floor(t*z1/floor(1.+mod(t*2.,2.))),m/4.)))/2.;\n\n  }\n  nb *= time;\n  return 64.*abs(.5-vec2(fract(nb*.998)\n\n   ,fract(nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 456]], "test": "untested"}
{"id": "NltyDS", "name": "Flowing Noise", "author": "MysteryPancake", "description": "Flows a bit like a liquid", "tags": ["noise", "distortion", "distort", "string", "flow", "liquid", "flowing", "stringy"], "likes": 7, "viewed": 353, "published": 3, "date": "1660457848", "time_retrieved": "2024-07-30T16:35:42.557157", "image_code": "float noise(float n) {\n\treturn fract(cos(n * 89.42) * 343.42);\n}\n\nfloat shake(float x) {\n\treturn sin(x) * sin(x * 4.0) * cos(x * 8.0) * sin(x * 12.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = texture(iChannel0, uv + vec2(0.0, shake(uv.y + iTime) * noise(uv.x)) * 0.5);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 64], [66, 66, 88, 88, 152], [154, 154, 209, 209, 340]], "test": "untested"}
{"id": "7lccDS", "name": "buffering aug_13_22", "author": "ufffd", "description": "playing with buffers and noise", "tags": ["feedback", "buffer"], "likes": 2, "viewed": 179, "published": 3, "date": "1660443002", "time_retrieved": "2024-07-30T16:35:43.309146", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nfloat PHI = (1.0+sqrt(5.0))/2.0;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec4 dist(vec4 x, vec4 y,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) :  (x * x + y * y);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 worley(vec2 P, float jitter, bool manhattanDistance) {\nfloat K =  0.142857142857;// 1/7\nfloat K2= 0.0714285714285; // K/2\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, 7.0)*K+K2;\n\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d =  dist(dx, dy, manhattanDistance); // d11, d12, d21 and d22, squared\n\t// Sort out the two smallest distances\n\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n}\n\nfloat cubicPulse( float c, float w, float x ) {\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n         uv = fragCoord / R,\n         uvc = ( 2.*fragCoord - R ) / R.y,\n         px = 1./R,\n         pxc = 2./R.yy;          // [-1,1] vertically\n         \n    vec2 bguv = uvc;\n\n    // Time varying pixel color\n    vec3 col = cos(iTime+bguv.xyx+vec3(0,2,4))*2.;\n    \n    uv.y += sin(iTime*1.1+uv.x)*0.0005;\n    \n    float worls = 0.;\n    for (int i=0;i<8;i++) {\n        float worl = worley(uv*4.,1.5-float(i)/8.,true).x;\n        float worlstep = float(i)*0.1;\n        worls += smoothstep(-0.01,0.01,worl-worlstep);\n    }\n    worls = mod(worls,2.);\n    col *= worls;\n    \n    \n    vec2 fuv = vec2(\n        sin(iTime*3.),\n        cos(2.*iTime+1.55)\n        )*vec2(0.9,0.5);\n    float floaterlen = length(fuv-uvc);\n    float floater = 1.-smoothstep(-.01,.01,floaterlen-0.1);\n    \n    fuv += vec2(\n        sin(iTime*3.),\n        cos(iTime*3.)\n        )*vec2(0.2);\n    float floater2len = length(fuv-uvc);\n    float floater2 = 1.-smoothstep(-.01,.01,floater2len-0.05);\n    \n    fuv += vec2(\n        cos(iTime*5.),\n        sin(iTime*5.)\n        )*vec2(0.2);\n    float floater3len = length(fuv-uvc);\n    float floater3 = 1.-smoothstep(-.01,.01,floater3len-0.02);\n    \n    col += vec3(floater, floater2, floater3+floater);\n    \n    vec3 lp = texture(iChannel0,uv).rgb;\n    col = mix(col,lp, 0.99-floater-floater2-floater3);\n    \n    vec3 lpn = texture(iChannel0,uv+vec2(0.,pxc.y)).rgb;\n    vec3 lps = texture(iChannel0,uv-vec2(0.,pxc.y)).rgb;\n    vec3 lpe = texture(iChannel0,uv+vec2(pxc.x,0.)).rgb;\n    vec3 lpw = texture(iChannel0,uv-vec2(pxc.x,0.)).rgb;\n    \n    // color adjustments\n    col.g = col.b + col.r;\n    vec3 hsv = rgb2hsv(col);\n    \n    col.b -= floater + floater2 + floater3;\n    // hsv.r = 1.;\n    // hsv.g += sin(iTime)*0.1;\n    // hsv.b = 0.;\n    col = hsv2rgb(hsv);\n    \n    col += floater2;\n    \n    col.r += cubicPulse((floaterlen + floater2len + floater3len), 0.01, .6) * 0.1 * sin(iTime + uv.y*12.);\n    col.g += cubicPulse((floaterlen + floater2len + floater3len), 0.02, .8) * 0.3 * cos(iTime + uv.y*15.);\n    col.b += cubicPulse((floaterlen + floater2len + floater3len), 0.03, 1.1) * 0.2 * cos(PI+iTime * 3.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lccDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 205]], "test": "untested"}
{"id": "slccDS", "name": "Hurwitz Zeta function", "author": "guil", "description": "Hurwitz Zeta function is a generalization of Riemann Zeta function depending on a parameter a\nFor a = 1 (time = 0) we get Riemann Zeta function.\nHurwitz(z,a) = sum (n+a)**z for n in N\nThe approximation method is Euler-Maclaurin", "tags": ["zeta", "hurwitz"], "likes": 3, "viewed": 223, "published": 3, "date": "1660430614", "time_retrieved": "2024-07-30T16:35:44.056149", "image_code": "const float pi = 3.1415926535897932;\nconst float LOG2 = 0.6931471805599453;\nconst float LOGPI = 1.1447298858494002;\n\n\n\n//------------------ ------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cinv(vec2 z) {return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cpow( float n, vec2 z ) {  return pow( n, z.x )*vec2( cos(z.y*log(n)), sin(z.y*log(n)) ); }\nvec2 cexp( vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog( vec2 z) {  return vec2( 0.5*log(z.x*z.x+z.y*z.y), atan(z.y,z.x)); }\nvec2 csin( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\nvec2 cpow( vec2 a, vec2 b ) {  return cexp(cmul(b,clog(a))) ;}\nvec2 ccos( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\nvec2 clogsin(vec2 z) {\n  if (abs(z.y)<8.0)return clog(csin(z));  \n  if (z.y > 0.) return vec2(z.y - LOG2, mod(1.5*pi-z.x, 2.0*pi) - pi);\n  else return vec2(-z.y - LOG2, mod(0.5*pi+z.x, 2.0*pi) - pi);\n  \n}\n//------------------------------------------------------------\n\n\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 col(vec2 u){\n    float r = u.x;\n    float v =min( exp(-r*.15),1.);\n    return hsv2rgb(vec3(u.y/(2.*pi),.5+.5*fract(r),.8))*v;\n}\n\n\n\n// Spouge's method for gamma\nvec2 gamma(vec2 z){\n    const int N = 16;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t   \n    s = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    return cdiv(s,z);\n    //s = clog(s); \n    //s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    //return s-clog(z);      \n}\n\n//Bernoulli\nfloat bn(int n){\n    float[40] a = float[40](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,\n                            0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,\n                            0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,\n                            0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    for(int i = 0; i <= n; i++){\n        a[i]=1./float(i+1);\n        for(int j = i; j > 0; j--){\n            a[j-1] = float(j)*(a[j-1] - a[j]);\n        }\n    }\n    return a[0];\n}\n\n\n//Hurwitz zeta : Euler Maclaurin approximation\nvec2 zeta7(vec2 z, float a){\n  const float N = 20.;\n  const float P = 12.;\n   \n  vec2 sum = vec2(0);\n  \n  for(float i = 0.; i < N; i++)\n    sum += cpow(i+a,-z); \n  sum += cpow(N+a,-z)/2.;  \n  sum += cdiv(cpow(N+a,vec2(1,0)-z),z-vec2(1,0));\n  vec2 c = z/2.;\n  for(float i = 1.; i < P; i++){\n    sum += cmul(c,cpow(N+a,-z-vec2(2.*i-1.,0)))*bn(2*int(i)); \n    c=cmul(c,cmul(z+vec2(2.*i-1.,0),z+vec2(2.*i,0)))/(2.*i+1.)/(2.*i+2.);\n  }     \n  return sum;\n}\n\n\nvec2 reflection(vec2 z, float a){\n  const float N = 20.;\n  vec2 sum1 = vec2(0);\n  for(float i = 1.; i < N; i++)\n    sum1 += cos(2.*pi*i*a)*cpow(i,z-vec2(1,0)); \n  vec2 sum2 = vec2(0);\n  for(float i = 1.; i < N; i++)\n    sum2 += sin(2.*pi*i*a)*cpow(i,z-vec2(1,0)); \n  vec2 f = cmul(csin(pi*z/2.),sum1)+cmul(ccos(pi*z/2.),sum2);\n  return 2.*cmul(cpow(2.*pi,z-vec2(1,0)),cmul(gamma(vec2(1,0)-z),f));\n}\n\nvec2 Hurwitz(vec2 z, float a){\n  if(z.x<-1.)return reflection(z,a);\n  return zeta7(z,a);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel3, ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (2.*fragCoord - iResolution.xy-iMouse.xy) / iResolution.y+(iMouse.xy==vec2(0.,0.)?0.:.5);;  // Map y-coordinates to [-1;1]\n  float zoom = 12.;\n  if (keypress(90)) zoom = 4.0;\n  uv *= zoom;  // Zoom out\n  vec2 z = uv.yx;  \n  z = clog(Hurwitz(z,.5+.5*cos(.1*iTime)));\n  fragColor.rgb = col(z);\n  float size = 4.*zoom/iResolution.x;\n  if (mod(abs(uv.x),5.)<size)fragColor.rgb = vec3(0.5);\n  if (mod(abs(uv.y),5.)<size)fragColor.rgb = vec3(0.5);\n  if (abs(uv.y-.5)<size)fragColor.rgb = vec3(1);\n  \n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slccDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 212, 242, 242, 271], [272, 272, 302, 302, 357], [358, 358, 377, 377, 409], [410, 410, 440, 440, 510], [511, 511, 532, 532, 578], [579, 579, 601, 601, 688], [689, 689, 710, 710, 735], [736, 736, 766, 766, 866], [867, 867, 897, 897, 963], [964, 964, 984, 984, 1033], [1034, 1034, 1054, 1054, 1112], [1113, 1113, 1133, 1133, 1210], [1211, 1211, 1240, 1240, 1273], [1274, 1274, 1294, 1294, 1372], [1373, 1373, 1395, 1395, 1577], [1645, 1645, 1667, 1667, 1836], [1839, 1839, 1856, 1856, 1971], [1975, 2004, 2023, 2023, 2515], [2964, 3011, 3039, 3039, 3462], [3465, 3465, 3498, 3498, 3863], [3865, 3865, 3895, 3895, 3955], [3957, 3957, 3981, 3981, 4042], [4044, 4044, 4099, 4099, 4607]], "test": "untested"}
{"id": "fltcWM", "name": "My Pendulum Wave", "author": "kilianovski", "description": "My Pendulum Wave", "tags": ["pendulum"], "likes": 3, "viewed": 294, "published": 3, "date": "1660420336", "time_retrieved": "2024-07-30T16:35:44.807141", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define g 9.81\n#define S smoothstep\n#define T iTime\n#define NUM_REF 2\n\nconst int MAT_BALL = 0;\nconst int MAT_THREAD = 1;\nconst int MAT_UP_BASE = 2;\nconst int MAT_DOWN_BASE = 3;\n\n\nconst int N_PENDULUMS = 15;\nconst float FIRST_L = 15.;\nconst float Tmax = 60.;\n\nconst float ball_r = .5;\nconst float base_y = 3.;\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat pendulumPeriod(float L){\n    return 2.*PI*sqrt(L/g);\n}\n\nfloat pendulumTheta(float t, float A, float T) {\n    return A*cos( (2.*PI/T) * t );\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) { \n    vec3 ab = b - a, ap = p - a;\n    \n    float t = dot(ap, ab)/dot(ab,ab);\n    t = clamp(t, 0.,1.);\n    vec3 c = a + t*ab;\n    float d = length(p-c) - r;\n    return d;\n}\n\n\nvec2 sdPend(vec3 p, float l, float t) { \n    //p.y -= base_y;\n    p.y -= (base_y - (l+ball_r));\n\n    vec3 base = vec3(0,(l+ball_r),0);\n    \n    float A = PI/4.;\n    float T = pendulumPeriod(l);\n    float a = pendulumTheta(t, A, T);\n    \n    p -= base;\n    p.xy *= Rot(a);\n    p += base;\n    \n    float line = sdCapsule(p, base, vec3(0.), .03);\n    float ball = length(p) - ball_r;\n    \n    float d = min(line, ball);\n    \n    int mat = d == line ? MAT_THREAD: MAT_BALL;\n    \n    return vec2(d, mat);\n}\n\n\n\nfloat get_k(){\n    float d = sqrt(FIRST_L/g)*2.*PI;\n    float k = Tmax/d - 2.;\n    return k;\n}\n\n\nfloat getL(float Tmax, float k, float n){\n    float x = pow(Tmax / (2.*PI*(k+n+1.)), 2.);\n    return g*x;\n}\n\nvec2 Min(vec2 a, vec2 b){\n    return a.x > b.x ? b : a;\n}\n\nvec2 GetDist(vec3 p) {\n    float ball_horizontal_offset = 3.*ball_r;\n    float base_length = ball_horizontal_offset * float(N_PENDULUMS-1);\n    \n    float base = sdCapsule(p-vec3(0., base_y+.5, 0.), vec3(0.), vec3(0,0,base_length), .5);\n    vec2 d = vec2(base, MAT_UP_BASE);\n    \n    float t = iTime*1.5;\n    t -= 3.;\n    t = max(t, 0.);\n    //t = 0.;\n    \n    float k = get_k();\n    \n    for (int i = 0; i < N_PENDULUMS; i++){\n        float L = getL(Tmax, k, float(i+1));\n       \n        vec3 pendulum_offset = vec3(0.,0., ball_horizontal_offset*float(i));\n        vec2 p_dist = sdPend(p-pendulum_offset, L, t);\n        d = Min(d, p_dist);\n    }\n    \n    float downbase = sdBox(p+vec3(0.,FIRST_L*1.,-base_length), vec3(10., .1, base_length*1.5));\n    \n    d = Min(d, vec2(downbase, MAT_DOWN_BASE));\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 Render(inout vec3 ro, inout vec3 rd) {\n    vec3 col = vec3(0);\n    float d = RayMarch(ro, rd);\n    \n    vec3 background = texture(iChannel0, rd).rgb;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        int mat = int( GetDist(p).y );\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        vec3 r = reflect(rd, n);\n        vec3 ref = texture(iChannel0, r).rgb;\n        \n        \n        if (mat == MAT_UP_BASE) col = ref*.05;\n        else if (mat == MAT_BALL) col = ref*.95;\n        else if (mat == MAT_THREAD) col = vec3(.4);\n        else if (mat == MAT_DOWN_BASE) { \n            col = vec3(.8, .6, .3);\n            col = vec3(0.);\n            rd = r;\n            ro = p+SURF_DIST*2.;\n        }\n        else col = vec3(p);\n       \n        \n    }\n    \n    else col = background*.3;\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0, -15);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i < NUM_REF; i++) {\n\n        col += Render(ro, rd);\n    \n    }\n    \n    col /= float(NUM_REF);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltcWM.jpg", "access": "api", "license": "mit", "functions": [[1788, 1788, 1807, 1807, 1869], [1871, 1871, 1901, 1901, 1931], [1933, 1933, 1981, 1981, 2018], [2020, 2020, 2049, 2049, 2130], [2132, 2132, 2182, 2182, 2354], [2357, 2357, 2396, 2418, 2858], [2862, 2862, 2876, 2876, 2956], [2959, 2959, 3000, 3000, 3066], [3068, 3068, 3093, 3093, 3125], [3127, 3127, 3149, 3149, 3952], [3954, 3954, 3988, 3988, 4201], [4203, 4203, 4227, 4227, 4389], [4391, 4391, 4441, 4441, 4626], [4628, 4628, 4671, 4671, 5553], [5555, 5555, 5612, 5612, 6041]], "test": "untested"}
{"id": "fl3yWB", "name": "avenue", "author": "nabr", "description": "don't code and drive", "tags": ["sound", "synth", "reverb", "riff", "fdn", "slowwave"], "likes": 23, "viewed": 444, "published": 3, "date": "1660419832", "time_retrieved": "2024-07-30T16:35:45.613984", "image_code": "// soundin shader by FabriceNeyret2\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg return length(T.yz)==0. ? -1. : T.x\n\nfloat message(vec2 U) {// to alter in the icon with the alter message\n    initMsg;C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110);// message \"Sound in\"\n    endMsg;\n} // EOL soundin shader\n\n#define T iTime\n\nfloat tex(vec3 uv) \n{\n    uv.xyz *=(mod(T, 8.)<4.5?20.:10.*max(1.,.2*(floor(mod(6.*T, 8.)))));\n    uv.y += mod(6. * T, 20.);\n    float s = 1.;\n    float mobile = max(iResolution.x, iResolution.y)*20.;\n    //by FabriceNeyret2\n    s = fract((s = sin(mod(mobile, 2.*mobile)*length(ceil(uv.xy *= mat2(14, 0, -7, 14) / 1e2)))) > .5 ? uv.xy : s < -.25 ? uv.yx : uv.xy + uv.y).x;\n    return s;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    \n    if (min(1., 1.-T/8.)>0.&&iResolution.y<2000.) {float c=message(mod(fragCoord/iResolution.y*18.-vec2(3,T), vec2(18, 7)));if(c>=0.){fragColor=vec4(fract(T)*c);return;}}\n\n    vec3 c = vec3(0);\n    //by iq\n    vec3 dthr = 10. * fract(sin((fragCoord.x / iResolution.x)*2.-1. * vec3(13, 1, 11) + fragCoord.y * vec3(1, 7, 5)) * 158.391832) / 255.0;\n    \n    const vec3 o = vec3(-0.05, -.05, 1);\n    vec3 d = normalize(vec3((fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y), 2.));\n    \n    float dd = 2.8;\n    vec3 p = (o + d * .001);\n    float dn = dot(p, d);\n    if(abs(dn) > .001)\n    {\n        p = (o + d * (-dd - dot(p, o)) / dn);\n        vec3 n = vec3(0, .01, 1);\n        //p.y-=.25*T;n.y-=.25*T;\n        //by nimitz\n        vec3 tgt = (n * dot(d, n) - d);\n        tgt /= (abs(dot(tgt, d))) + 1.002;\n        p += (tgt * tex(p) * .02);\n        float ds = distance(o, p);\n        vec2 e = vec2(0.07 * pow(0.105 * ds, .5) , 0);\n        #define btex(_p)(tex(_p) + tex(_p))\n        vec3 dd = (btex(p) - vec3(btex(p - e.xyy), btex(p - e.yxy), btex(p - e.yyx))) / e.x;\n        vec3 tgd = dd - n * dot(n, dd);\n        n = normalize(n - tgd  * .62 * 8. / (ds));\n        \n        vec3 l = normalize(normalize(2. * vec3( sin(T), cos(T), 1)) + p),\n             dn = vec3(sin(T), mod(.25*T, 2.), 3),\n             D = dot(dn, o) / dot(dn, d) * p;\n        \n        c = dthr;\n        c += max(.2, abs(sin(T))) * (cos(vec3(1, 2, 2.8) + 2.32 * mix(tex(n), tex(p), abs(sin(pow(1.-fract(.5*T), 4.)))) ) * .5 + .5);\n        float dif = max(0., dot(n, l));\n        float k = pow(max(0., .556 + length(dot(-l, reflect(n, -d)))), 15.) * exp2(15. - dot(D, D));\n        c = c * min(.01+ c * k, 1.5 -dif * vec3(1.2, 1.5, 1.4));\n    }\n\n    fragColor.rgb = sqrt(c);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "/*\n\n    Just an other reverb experiment\n    If you have a simple delay going there \n    Are some ops you can shuffle to your liking\n    The very improvment and the basic first step \n    Is to store the delay in a multi-channel\n    And than mix it down to a stereo output\n    Note: Probably less dense in a raw float 32bit output\n\n*/\n\n#define _f(_x)(fract(_x))\n#define tau (acos(0.)*4.) //6.283185307179586\n\nfloat drm(float t)\n{\n    float kk ;\n    float tt = t * 4., ft = mod(tt, 1.);\n    int ut = int(tt) % 12;\n    kk = (1. - ft);\n    kk = pow( kk, 4. ); //  * kk;\n    kk *= sin(12. * tau * kk);\n    kk *= float[](1.,0.,0.,1.,0.,0.,1.,0.,1.,1.,0.,0.)[ut];\n    return  .6 * kk * min(1., 10. * ft) * max( 0., 1.-ft);\n}\nfloat ns(inout float snn, float rt, float t)\n{\n    float sn;\n    float x = t * 5623.123456;\n    snn = mod(x * mod(t + x, 1.), 1.);\n    sn = snn * min(1., mod(rt/2., 2.) ) * max(0., 1.-mod(rt/2., 2.) ) ;\n    return rt>2.?(.02*sn*exp(-1.*_f(rt))):0.;\n}\nfloat shk(float t)\n{\n    float kk,sn;\n    float tt = t * 4., ft = mod(tt, 1.);\n    int ut = int(tt) % 12;\n    ns(sn, t, t);\n    sn *= float[](0., 0., 1., 0., 0., 1., 0., 1., 0., 0., 1., 1.)[ut];\n    sn *=  .051 * atan(1. - ft, 5. * ft);\n    return  sn * min(1., 5. * ft) * max( 0., 1.-ft);\n}\n\nvec2 chd(in float rt, in float t, int ch)\n{\n    float mx = 8.;\n    int it = int(mx * t) % 4;\n    float ft = mod(mx * t, 1.);\n\n    mat4x2 p1 = mat4x2(57, 64, 67, 71, 72, 74, 76, 79);\n    mat4x2 p2 = mat4x2(56, 63, 67, 70, 72, 75, 79, 75);\n    mat4x2 p3 = mat4x2(53, 60, 63, 68, 70, 75, 67, 75);\n    mat4x2 p4 = mat4x2(48, 62, 65, 70, 74, 79, 67, 79);\n\n    vec2 pp =vec2(0., 0.);\n \n    switch(int( .5 * t)%4)\n    {\n        case 0:pp = p1[it];\n        break;\n        case 1:pp = p2[it];\n        break;\n        case 2:pp = p3[it];\n        break;\n        case 3:pp = p4[it];\n        break;   \n        default: vec2(0., 0.);\n    }\n\n    vec2 s = sin(rt * tau * 8.175799 * exp( 0.057762265 * pp) ) * ft  * ( 1. - ft );\n    if(ch==0)\n    {\n        return.55 * tanh(7. * s ) * min(1., 10. * ft) * max( 0., 1.-ft);\n    }\n    else\n    {\n    s.y *= cos(rt + 220.00 * exp(-.101 * pow(1. - ft, 14.)));\n    s.x = (sin(.5*s.x) + .43021 ) /(1.23242 + cos(7. * s.y));\n    return .2985 * vec2( tanh( 5. * s.x),  0); \n    }\n}\n\n\nvoid sndmix(inout vec2 y,in float k[8], in int c)\n{\n     y.x = k[0];\n     if(c<2) y.y = k[1+c];\n}\n\n#define MODE 3\nvec2 mainSound(in int samp, float t)\n{\n\n    vec2 y = vec2(1e-6, 1e-6);\n    #define initarr float[8](1e-6,1e-6,1e-6,1e-6,1e-6,1e-6,1e-6,1e-6)\n    float o[8] = initarr;\n    float k[8] = initarr;\n    float dlt = t;\n    float fsn = 0.;\n    int maxiter = 15;//29\n    for (int i = 1; i < maxiter; ++i)\n    {\n        for (int c = 0; c < 3; ++c)//max channels 7\n        {\n                dlt += .0991609 //brute forced correlation val\n                        * exp2( float(i / 6 % 8) );\n                o[c] += (ns(fsn, t, dlt) + drm(dlt) + chd(t, dlt, 1).x );\n                k[c]*= float[8](-1., -1., 1., 1., -1., -1., 1., 1.)[c];\n                o[c] = (c%2==0)? (k[c] = o[c]): (k[c] = o[(1+c)%4]);\n                k[c]*= -2./8.; //+/-\n                \n    #if MODE == 1 \n    \n          sndmix(y, k, i);\n          \n    #endif\n    \n        }\n    \n    #if (MODE == 1) || (MODE == 2)\n        #if MODE == 2\n        y.x = k[0]; \n        #endif\n        if(i>12)\n        {\n            y.y = k[1];\n            break;\n        }\n        \n    #endif\n    \n    }\n\n    \n    #if MODE == 3\n    // in array stored sample right to left like a rotation \n        y.x = k[0];\n        \n        for (int c = 0; c < 2; ++c)\n            y.y = k[1+c];\n            \n    #endif\n\n     t = (float(samp%int(8.*iSampleRate))/iSampleRate);//less hairy\n     \n     #if 1\n     return .211 * chd(.5*t,t, 0) + .51 * y  + (.7  * drm(t) + .223 * shk(t));\n     #else\n     return  .707 * y;\n     #endif\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3yWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 300, 346, 448], [489, 489, 510, 510, 877], [879, 879, 931, 931, 2700]], "test": "untested"}
{"id": "fldyRl", "name": "porthole", "author": "sh1boot", "description": "working on a procedural occlusion window to use instead of `length(x) > 1.0` and trying to learn how to do all this procedural stuff as I go.", "tags": ["procedural", "wip"], "likes": 0, "viewed": 184, "published": 3, "date": "1660415421", "time_retrieved": "2024-07-30T16:35:46.353008", "image_code": "vec4 overlay(vec4 top, vec4 bottom) {\n    return bottom * (1.0 - top.a) + top;\n}\n\nfloat hash(vec2 uv) {\n    // Seeing some weird discontinuity coming from overflow cases -- this'll fix it!\n    uv = vec2(ivec2(floatBitsToUint(uv.x), floatBitsToUint(uv.y))) / 65537.0;\n\n    const vec2 swiz = vec2(12.9898, 78.233);\n    return fract(sin(dot(uv, swiz)) * 43758.5453);\n}\n\nfloat hash(float f) {\n    return hash(vec2(f));\n}\n\nfloat noise(vec2 uv, float p) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = smoothstep(0.0, 1.0, f);\n    vec4 o = vec4(vec2(-0.5), vec2(0.5)) + fract(p * 1.73737373);\n    return mix(mix(hash(i + o.xy), hash(i + o.zy), f.x),\n               mix(hash(i + o.xw), hash(i + o.zw), f.x),\n               f.y);\n}\n\nfloat noise(vec2 uv) {\n    return noise(uv, 0.0);\n}\n\n   \nfloat bumpmap(float dx, float dy, float shine) {\n    vec3 n = cross(normalize(vec3(1.0, 0.0, dx * 4.0)),\n                   normalize(vec3(0.0, 1.0, dy * 4.0)));\n    vec3 light = normalize(vec3(sin(iTime * 1.445), 4.0, 6.0 - cos(iTime)));\n    float diff = max(0.0, dot(light, n));\n    float spec = pow(max(0.0, dot(light, normalize(n + vec3(0.0, 0.0, 1.0)))), 20.0);\n    return 0.15 + 0.85 * diff + spec * shine;\n}\n\n\n\nfloat bevel(float lo, float hi, float x) {\n    if (x <= lo) return 0.0;\n    if (x >= hi) return 1.0;\n    x = (x - lo) / (hi - lo);\n    return sqrt(x * (2.0 - x));\n}\n\nfloat nbevel(float lo, float hi, float x) {\n    return 1.0 - bevel(-hi, -lo, -x);\n}\n\nvec4 wood(vec2 uv) {\n    const mat2 grain = mat2(1.0, 0.0, 0.0, 12.0);\n    const float offcentre = 0.2345;\n    const float planks_per_unit = 3.0;\n    float edge = uv.y * planks_per_unit + offcentre;\n    float plank = round(edge);\n    float d = noise(uv * grain, plank) * 24.0;\n\n    // Pedantry: each plank is cut at a different depth into the trunk.\n    d += (hash(plank) - 0.5) * 12.0;\n\n    // summer and winter growth rings\n    const vec3 woods = vec3(0.50, 0.31, 0.06);\n    const vec3 woodw = vec3(0.40, 0.22, 0.00);\n    // summer/winter rings for heart.\n    const vec3 hearts = vec3(0.32, 0.14, 0.00);\n    const vec3 heartw = vec3(0.28, 0.12, 0.00);\n    float w1 = smoothstep(3.0, 10.0, d);\n    float w0 = abs(sin(d));  // mostly near 1, so these are the summer rings\n    float lip = 0.2 + 0.8 * smoothstep(0.005, 0.04, 0.5 - abs(plank - edge));\n    return vec4(mix(mix(heartw, hearts, w0), mix(woodw, woods, w0), w1) * lip, 1.0);\n}\n\nfloat smoothmax(float x, float y, float k) {\n    float f_k = pow(max(0.0, k - abs(y - x)), 3.0) / (6.0 * k * k);\n\n    return max(x, y) + f_k;\n}\n\nvec4 bolt(vec2 uv, float t) {\n    const float size = 0.075;\n    const float sides = 5.0;\n    float r = length(uv);\n    const float roundoff = 2.0 * 3.14159265358979 / sides;\n    t = fract(atan(uv.y, uv.x) / roundoff + t) * roundoff;\n    t = size / smoothmax(cos(t), cos(roundoff - t), 0.35);\n \n    const vec3 metal = vec3(0.4, 0.3, 0.0);\n    vec3 colour = metal;\n    float bevel = 1.0 - nbevel(-0.015, 0.0, r -t);\n    float light = bumpmap(dFdx(bevel), dFdy(bevel), 1.0);\n    colour = clamp(colour * light, 0.0, 1.0);\n    \n    float w = 0.75 * fwidth(r);\n    float alpha = 1.0 - smoothstep(-w, w, r - t);\n    return vec4(colour, 1.0) * alpha;\n}\n\nfloat pock(vec2 uv) {\n    mat2 r0 = mat2(0.866, 0.50, -0.50, 0.866) * 31.0;\n    mat2 r1 = mat2(1.0, 0.0, 0.0, 1.0) * 18.0;\n    float f = 0.66 * noise(uv * r0, 0.0) + 0.34 * noise(uv * r1, 1.0); \n    return smoothstep(0.75, 0.95, f);\n}\n\nvec4 flange(vec2 uv, float t, float r) {\n    const vec3 brass0 = vec3(0.70, 0.60, 0.1);\n    const vec3 brass1 = vec3(0.42, 0.34, 0.0);\n    float w0 = pock(uv);\n    float bevel = bevel(1.00, 1.05, r) - nbevel(1.20, 1.25, r);\n    float alpha = 1.0 - smoothstep(1.24, 1.25, r);\n\n    vec3 colour = mix(brass0, brass1, w0);\n\n    float light = bumpmap(dFdx(bevel), dFdy(bevel), 1.0)\n                * bumpmap(dFdx(-w0), dFdy(-w0), 0.7);\n    colour = clamp(colour * light, 0.0, 1.0);\n\n    return vec4(colour, 1.0) * alpha;\n}\n\nvec4 cracks(vec2 uv) {\n    const vec2 v[] = vec2[](\n        // random.gauss(0.62, 0.18), random.gauss(0.59, 0.18)\n        vec2(0.631, 0.598),\n        vec2(0.609, 0.749),\n        vec2(0.452, 0.935),\n        vec2(0.483, 0.568),\n        vec2(0.357, 0.525),\n        vec2(0.627, 0.596),\n        vec2(0.662, 0.712),\n        vec2(0.863, 0.683),\n        vec2(0.718, 0.260),\n        vec2(0.739, 0.991),\n        vec2(1.000, 0.625),\n        vec2(0.554, 0.661),\n        vec2(0.617, 0.563)\n    );\n    int m0 = 0, m1 = 0;\n    float d0 = 100.0, d1 = 100.0;\n    \n    vec2 wiggle = vec2(sin(1.0 + uv.y * 1.53) * 0.231,\n                       cos(uv.x * 1.7) * 0.221);\n    uv += wiggle;\n\n    for (int i = 0; i < v.length(); ++i) {\n        float d = distance(uv, v[i]);\n        if (d < d0) {\n            d1 = d0;\n            m1 = m0;\n            d0 = d;\n            m0 = i;\n        } else if (d < d1) {\n            d1 = d;\n            m1 = i;\n        }\n//        if (distance(uv, v[i]) < 0.02) return vec4(1.0, 1.0, 0.0, 1.0);\n    }\n\n    vec2 v0 = v[m0];\n    vec2 r = normalize(v[m1] - v0);\n    float d = dot(uv - v0, r);\n    float w = dot(uv - v0, vec2(r.x, -r.y));\n    float mid = distance(v0, v[m1]) / 2.0;\n    const vec4 glass = vec4(0.3, 1.0, 0.6, 1.0);\n    const vec4 white = vec4(1.0);\n    const vec4 black = vec4(vec3(0.0), 1.0);\n\n    float threshold = 0.01 + noise(uv * 3.0, 1.0) * 0.02;\n    vec4 colour = mix(mix(glass, white, abs(r.y)), black, abs(r.x));\n\n    return colour * smoothstep(0.0, 0.01, threshold - abs(mid - d));\n\n#if 0\n    // Nope, this bit is all wrong!\n    vec2 b = vec2(min(d, dw), max(d, dw));\n    float alpha = smoothstep(b.x - 0.02, b.x, mid) - smoothstep(b.y, b.y + 0.02, mid);\n    alpha *= 1.0 - (mid - b.x) / (b.y - b.x);\n    if (alpha > 0.01) return glass * vec4(vec3(0.9975), 1.0) * alpha;\n#endif    \n    return vec4(0.0);\n}\n\nvec4 f(vec2 uv) {\n    float t = atan(uv.y, uv.x);\n    float r = length(uv);\n\n    vec4 colour = vec4(0.0);\n    float w = 0.75 * fwidth(r);\n    float alpha = smoothstep(-w, w, r - 1.0);\n    if (alpha > 0.01) {\n        colour = wood(uv);\n        colour *= clamp(step(1.00, r), 0.0, 1.0);\n\n        colour = overlay(flange(uv, t, r), colour);\n\n        const float roundoff = 8.0 / (2.0 * 3.14159265358979);\n        float bt = round(t * roundoff) / roundoff;\n        vec2 bolt_uv = vec2(cos(bt), sin(bt)) * 1.125;\n\n        colour = overlay(bolt(uv - bolt_uv, hash(bolt_uv)), colour);\n    }\n    if (alpha < 0.99) {\n        colour = overlay(colour * alpha, cracks(uv));\n    }\n\n    return colour;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 d = 0.06125 * vec2(noise(fragCoord, iTime), noise(fragCoord.yx, 2.0 + iTime));\n    vec2 uv = (fragCoord + d - iResolution.xy * 0.5) * 4.0 / iResolution.x;\n\n    vec4 colour = f(uv);\n    vec3 back = 0.3 + 0.3*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 s = uv.xyxy * 3.0 + vec4(iTime, iTime * 0.382, -iTime, -iTime * 0.618);\n    back = vec3(noise(s.xy, 0.0), noise(s.zw, 1.0), noise(s.yz, 2.0)) * 3.0 - 1.0;\n\n    fragColor = overlay(colour, vec4(back, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 80], [82, 82, 103, 188, 365], [367, 367, 388, 388, 416], [418, 418, 449, 449, 733], [735, 735, 757, 757, 786], [792, 792, 840, 840, 1206], [1210, 1210, 1252, 1252, 1374], [1376, 1376, 1419, 1419, 1459], [1461, 1461, 1481, 1481, 2397], [2399, 2399, 2443, 2443, 2542], [2544, 2544, 2573, 2573, 3188], [3190, 3190, 3211, 3211, 3424], [3426, 3426, 3466, 3466, 3943], [5787, 5787, 5804, 5804, 6476], [6479, 6479, 6536, 6536, 7000]], "test": "untested"}
{"id": "sldczs", "name": "Seeing blue color in focus", "author": "NoxWings", "description": "I read this article https://calebkruse.com/10-projects/seeing-blue/ and wanted to replicate it's effect\nPress and hold 1, 2 or 3 keys to blur R, G, B channels respectively and composite that into the main image\nAlso pressing Q, W, E shows the blu", "tags": ["perception"], "likes": 1, "viewed": 274, "published": 3, "date": "1660387586", "time_retrieved": "2024-07-30T16:35:47.098016", "image_code": "// I read this article https://calebkruse.com/10-projects/seeing-blue/ and wanted to replicate it's effect\n// Press and hold 1, 2 or 3 keys to blur R, G, B channels respectively and composite that into the main image\n// Also pressing Q, W, E shows the blurred image for that channel\n\n// Run this line on the js console to load the original article image:\n// gShaderToy.mEffect.NewTexture(gShaderToy.mActiveDoc, 0, { mSrc: \"https://calebkruse.com/10-projects/seeing-blue/original.jpg\", mType:\"texture\", mID:\"4dXGRn\", mSampler: { filter:\"linear\", wrap:\"clamp\", vflip:\"true\", srgb:'true', internal:'byte' }});\n\n#define BLUR_DIRECTIONS 16.0\n#define BLUR_QUALITY 8.0\n#define BLUR_SIZE 0.03\n\n#define BLUR_CHANNEL 0\n#define OUTPUT 0\n\nconst int KEY_1 = 0x31;\nconst int KEY_2 = 0x32;\nconst int KEY_3 = 0x33;\nconst int KEY_Q = 0x51;\nconst int KEY_W = 0x57;\nconst int KEY_E = 0x45;\n\nbool isKeyPressed(int keyCode) {\n    return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x > 0.5;\n}\n\nconst float PI = 3.14159;\nconst float TAU = PI*2.0;\n\nvec4 sampleBlur(\n    sampler2D tex, \n    vec2 res, \n    vec2 pos, \n    float directions, \n    float quality, \n    float size\n) {\n    vec2 radius = size / res.xy;\n    vec2 uv = pos / res.xy;\n    \n    vec4 color = texture(tex, uv);\n    \n    float directionStep = TAU/directions;\n    float qualityStep = 1.0/quality;\n    \n    float importance = 1.0;\n    \n    for(float arc = 0.0; arc < TAU; arc += directionStep)\n    for(float q = 1.0; q > 0.0; q -= qualityStep) {\n        vec2 offset = vec2(cos(arc),sin(arc)) * q * radius * res.y;\n        vec2 cuv = uv + offset;\n        \n        // Avoid sampling outside the edges\n        if (\n            cuv.x < 0.0 ||\n            cuv.y < 0.0 ||\n            cuv.x > res.x ||\n            cuv.y > res.y\n        ) {\n            continue;\n        }\n        \n        float sampleImportance = 1.0 + (1.0 - q); // linear fallof\n        importance += sampleImportance;\n        color += texture(tex, cuv) * sampleImportance;\n    }\n    \n    return color / importance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 regular = texture(iChannel0, uv);\n    vec4 blurred = sampleBlur(\n        iChannel0, \n        iResolution.xy,\n        fragCoord.xy, \n        BLUR_DIRECTIONS,\n        BLUR_QUALITY, \n        BLUR_SIZE\n    );\n    \n    vec4 color = regular;\n    \n    if (isKeyPressed(KEY_1)) {\n        color.r = blurred.r;\n    }\n    if (isKeyPressed(KEY_2)) {\n        color.g = blurred.g;\n    }\n    if (isKeyPressed(KEY_3)) {\n        color.b = blurred.b;\n    }\n    if (isKeyPressed(KEY_Q)) {\n        color = vec4(blurred.r);\n    }\n    if (isKeyPressed(KEY_W)) {\n        color = vec4(blurred.g);\n    }\n    if (isKeyPressed(KEY_E)) {\n        color = vec4(blurred.b);\n    }\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[872, 872, 904, 904, 970], [1025, 1025, 1153, 1153, 2020], [2022, 2022, 2079, 2079, 2814]], "test": "untested"}
{"id": "7ldyRs", "name": "[Evoke 2022] Cube^3", "author": "totetmatt", "description": "Semi 1 from Evoke 2022 Shader showdown\nHeavily inspired from @mrange work https://www.shadertoy.com/view/ssdBWS for the cubehex trick\nand @kamoshika's #つぶやきGLSL works on hexagonal figures", "tags": ["cube"], "likes": 9, "viewed": 348, "published": 3, "date": "1660376669", "time_retrieved": "2024-07-30T16:35:47.902864", "image_code": "// Come to https://livecode.demozoo.org \n// I encourage you to check the real effect with bonzomatic and music\n// The effect live \"abuse\" the fft  representation in bonzomatic which is less evenly distributed\n// and create a 'running flash effect' that I have hard time to reproduce here.\n\n// Greetings to the Evoke shader showdown lineup NuSan, Flopine, z0rg, psenough, havoc.\n// Thanks also to the amazing Evoke orga ! \n// And Thanks the public ! I hope you enjoyed !\n\n// Heavily inspired from mrange work https://www.shadertoy.com/view/ssdBWS for the cubehex trick\n// and @kamoshika's #つぶやきGLSL works on hexagonal figures\n//\n\n\n// Constants for hexa stuff\nconst vec2 sz = vec2(1.,1.73),hs = sz*.5; \n\n\n// Created an hexa grid (check art of code, explaination are far better :D ) \nvec2 hexgrid(inout vec2 p){\n  vec2 pa= mod(p,sz)-hs,pb=mod(p-hs,sz)-hs,pc=dot(pa,pa) < dot(pb,pb) ? pa : pb;\n  vec2 n = (p-pc+hs)/sz;\n  //   ^--- This is used to have the \"id\" of the hexcell\n  p = pc;\n  return round(n*2.)*.5;\n  // Returning the cell id, but p is 'inout' and beeing modified /!\\ to \n  // makes p having local cell coordinate\n  \n  }\n  \n// Getting a box for sdf (yeah 2D & 3D wow) \nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n    // Could have simplified this, but didn't had time\n  }\n// Palette trick from iq, simple and efficient to get shiny color palette\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.3,.6)));}\n\n// 2d rotation\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n     vec2 uuv = uv; // I keep original uv for later \n/************ 2D background /************/\n \n \n    vec3 col = vec3(.1+texture(iChannel0,fract(abs(uv.xy))).r*1.);\n\tfloat tt =iTime*.25; // this is originaly a texFFTIntegrated so it's should be\n    // increasing in sync with the sound\n    \n    uv += vec2(asin(sin(sz.y*tt)),asin(cos(sz.x*tt))); \n    //    ^--- moving up down left right, asin make it more sharp\n    uv*=2.;\n  \n  vec2 n = hexgrid(uv);\n  //        ^-- First hexagrid, it will be used only for the \"scale\" effect  \n  if(dot(cos(n),sin(n.yx)) < .0) uv*=2.;\n  //     ^--- Scale effect where sometime it's big cube, sometime small\n  //     dot here make it more \"biome\" like (whatever it means you got the idea)\n  \n  vec2 p1=uv*3.,p2=p1+vec2(1.,inversesqrt(3.));\n  // The background cube are in fact 2 hexgrid with one of it shifted from \n  // +vec2(1.,inversesqrt(3.))\n  \n  vec2 n1 = hexgrid(p1); \n  vec2 n2 = hexgrid(p2);\n  \n  float l = 1.; \n  if(n1.x < n2.x+.5) l *= .75;\n  if(n1.y < n2.y) l *= .75;\n  // ^--- all the 3 lines : Trick to shade the \"face\" of the cube\n  \n  // Now basically it's about messing enough with all the data we have to make \n  // Sparkling flashy things. (Works better on bonzo)\n  \n  float gy = dot(sin(n1*4.),cos(n2*8.));\n  // Some gyroid, quite cool effect usually.\n  \n  float zzccmxtp=  (gy + iTime+n2.y*2.4+n2.y*3.3+n2.x*.2+n1.x*1.1);\n  // The magic, defining a value that will be almost uniq across all 'face' of cube\n  // but value will be close enough so you can have some shading effect or color\n  // grading thanks to the pal stuff\n  \n  float txt = texture(iChannel0,fract(vec2(zzccmxtp))).r;\n  // If you are not used to my style, I L.O.V.E F.F.T\n  \n  float d1 = max(dot(p1=abs(p1),sz*.5),p1.x)-.48;\n  float d2 = max(dot(p2=abs(p2),sz*.5),p2.x)-.48;\n  //         ^--- one lines to get and hexagone\n  //  v--- which will be combined to this\n  float d = max(d1,d2); \n  d = smoothstep(0.,fwidth(d),d);\n  // to have the edge of each cube face.\n  \n  // HERE WE GO\n  col = (gy < .0 ? d: 1.)* // Should it be plain face or wired ? \n  (txt*10.> .1 ? pal(zzccmxtp*2.): vec3(.5))* // Intend to be an effect where \n  // it use the color when the fft is \"high\" enough and gray otherwise\n  // I had it working in a practice shader, but here didn't manage to make it.\n   \n  l*        // to have some sort of shading \n  vec3(1.5)* // Useless * 1. but HEY it's 25min :D \n  pow(txt,4.)*3.  ;  // intensity from music;\n \n/************ 3D foreground /************/\n  uv = uuv; // Get back the original uv\n\n  vec3 p,dd= normalize(vec3(uv,1.)); // initialisation of the smol ray marcher\n  for(float i=0.,g=0.,e=0.;i++<50.;){ // The ray marching\n        \n       p = dd*g; // Current pos\n       \n       p.z -=5.-texture(iChannel0,vec2(.3)).r*2.;\n       p.x += asin(sin(iTime));\n       p.y += asin(cos(iTime));\n       p.xy *=rot(iTime);\n       // ^--- Some plays with the coordinate to move the cube\n       \n        float h = box(p,vec3(1.)); // A cube\n        g+=e=h; // ray move forward\n        // CUBIGGGAAAAAAAA (purely a public bait :D )\n        vec3 cc = mod(floor(p.x*5.+floor(mod(p.y*5.,2.)))*5. ,2.) < 1. ? vec3(1.,0.,0.) : vec3(1.);\n        //    ^--- The color\n        //    I still don't know how to have a proper texture applied on all face\n        col += cc*.055/exp(e*e*i);\n        // Color accumulation\n    }\n   fragColor = vec4(sqrt(col),1.);\n   // aaaand we are done ! :D \n}", "image_inputs": [{"id": 29527, "src": "https://soundcloud.com/fms_cat/eveone200bpm-2017120720171231", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[711, 789, 816, 816, 1136], [1140, 1185, 1210, 1210, 1358], [1359, 1433, 1451, 1451, 1497], [1499, 1514, 1532, 1532, 1579], [1581, 1581, 1638, 1688, 5171]], "test": "untested"}
{"id": "Nltyzs", "name": "deep 9input", "author": "lomateron", "description": "click to reset simulation\nwe going deep\nnext is 18input deep", "tags": ["binaryfunction"], "likes": 6, "viewed": 254, "published": 3, "date": "1660345528", "time_retrieved": "2024-07-30T16:35:48.704720", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord);\n    if((iFrame&1)==0){fragColor = fragColor.xxxx;}\n    if((iFrame&1)==1){fragColor = fragColor.yyyy;}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = +A(u+vec2( 1, 0))\n             +A(u+vec2( 0, 1))\n             +A(u+vec2(-1, 0))\n             +A(u+vec2( 0,-1))\n             +A(u+vec2( 1, 1))\n             +A(u+vec2(-1, 1))\n             +A(u+vec2( 1,-1))\n             +A(u+vec2(-1,-1))\n             +A(u+vec2( 0, 0));\n    //a = 9.-a;\n    float s = round(dot(a,vec4(1,0,0,0)));\n    float o = 0.;\n    if(s==0.){o = 1.;}\n    if(s==1.){o = 1.;}\n    if(s==2.){o = 0.;}\n    if(s==3.){o = 1.;}\n    if(s==4.){o = 1.;}\n    if(s==5.){o = 1.;}\n    if(s==6.){o = 1.;}\n    if(s==7.){o = 0.;}\n    if(s==8.){o = 0.;}\n    if(s==9.){o = 0.;}\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = floor(fract(cos(dot(u,vec2(234.76543,iTime+22.5363)))*2467.5678)+.97);\n        o *= step(dot(v,v),dot(m,m)*.5);\n    }\n    fragColor = vec4(o,A(u+vec2(0,0)).xyz);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nltyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 242]], "test": "untested"}
{"id": "NltcRl", "name": "Iijtunnel music remix 2", "author": "jarble", "description": "More simple patterns", "tags": ["music", "iij"], "likes": 7, "viewed": 341, "published": 3, "date": "1660332488", "time_retrieved": "2024-07-30T16:35:49.444741", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 U =( 2.*fragCoord-iResolution.xy)/iResolution.y;\n\n     float b=sqrt(length(U));\n  \n  float t=iTime*.5;U=fract(vec2(b,abs(atan(U.x,U.y))));\n\n  vec2 c=U*25.;\n  \n  c.x += iTime*100.;\n\n  U=floor(mod((c),vec2(256*2)));\n\n  float d=b*mod((U.x*U.x+U.y*U.y),U.x-U.y)/256.;\n\n  fragColor=vec4(fract(d*U.x),fract(d*U.y),d,1.);\n    \n\n}", "image_inputs": [], "sound_code": "//double spaced so it looks like more work\n\n#define fmod(x,y) mod(floor(x),y)\n#define fpow(x,y) pow(y,fmod(x,y))\n\nfloat song(float t, float d){\n\n  return\n      pow(2.,mod(t*t*(floor(t/(d))),d)/6.+7.)\n      //pow(2.,mod(t*t*(floor(t/2./(d))),d+mod(t,d))/6.+7.)\n\n      //pow(2.,floor(sqrt(mod(t*t*(floor(t/(d))),d*d)))/6.+7.)\n\n      //pow(2.,mod(t*t*(floor(t/(d))),d*2.)/12.+d/2.-1.)\n      //pow(2.,mod((floor(t*t*t/(d))),d)/6.+7.)\n      //pow(2.,mod((t*floor(t*t/(d))),d)/6.+7.)\n      //pow(2.,mod((t*floor(t*t/(d))),d)/6.+d/2.-1.)\n\n\n      //pow(2.,mod(t/d*(floor(t*t)),d)/5.+7.)\n      //pow(2.,mod(t*t/d*(floor(t)),d)/5.+7.)\n      ;\n}\n\nvec2 mainSound(int samp, float time){\n  \n  //time += fpow(time*4.,2.)*fpow(time,2.);\n  \n  float t=(time+10.)*4.,\n  m1=\n      1.+mod(floor(t*2.),2.)\n      //1.+mod(floor(t+floor(t/2.)),2.)\n      //1.+mod(floor(t/4.),2.)\n  ,\n  t1=t/m1,\n\n  m=64.,\n  a=\n      64.*sqrt(1.-sqrt(fract(t)))*.2,\n      //sqrt(1.-sqrt(fract(t1)))*.2,\n  nb=\n      time*min(song(floor(t1),m/4.),song(floor(t*(2.)),m/2.))\n      //max(song(floor(t1),m/4.),song(floor(t1*(2.)),m/4.))\n      //max(song(floor(t1),m/4.),song(floor(t1*(2.)),m/4.))/4.+64.+m1*2.\n\n  ;\n\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      //log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a)/2.\n  ;\n\n}\n\n/*\nvec2 mainSound(int samp, float time){\n\n  float t=(time+10.)*8.,a=sqrt(1.-fract(t/2.))*.2,\n  \n  nb = pow(2.,mod(floor(t/2.)*floor(t)*floor(t/16.),16.)/6.+7.);\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n\n}\n*/", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltcRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 394]], "test": "untested"}
{"id": "stdyRX", "name": "Pixel Art Palette Conversion", "author": "kemandel", "description": "Pixilates an image and then swaps the palette. This is done with ordered dithering in order to simulate the shading techniques present in pixel art, while creating the illusion of a larger color palette. (fullscreen for best results)", "tags": ["retro", "pixel", "color", "art", "ordereddithering", "paletteswap"], "likes": 27, "viewed": 874, "published": 3, "date": "1660331206", "time_retrieved": "2024-07-30T16:35:50.198725", "image_code": "// Inspired by https://www.youtube.com/watch?v=8wOUe32Pt-E\n\n// What power of 2 the pixel cell sizes are increased to\nconst int pixel_scale = 2;\n\n// https://lospec.com/palette-list/oil-6\n// Should be sorted in increasing order by perceived luminance for best results\n// Can work with up to 256 distinct colors\nconst vec4[] palette = vec4[] (\nvec4(39./255., 39./255., 68./255., 1.), \nvec4(73./255., 77./255., 126./255., 1.), \nvec4(139./255., 109./255., 156./255.,1.), \nvec4(198./255., 159./255., 165./255., 1.),\nvec4(242./255., 211./255., 171./255., 1.),\nvec4(251./255., 245./255., 239./255., 1.));\n\n// Amount of colors in the palette\n// Changing this is not recommended\nconst int colors = int(palette.length());\n\n// How much the dither effect spreads. By default it is set to decrease as the amount of colors increases.\n// Set to 0 to disable the dithering effect for flat color areas.\nconst float dither_spread = 1./float(colors);\n\n// Precomputed threshold map for dithering\nconst mat4x4 threshold = mat4x4(0., 8., 2., 10., \n                                12., 4., 14., 6.,\n                                3.,11.,1.,9.,\n                                15.,7.,13., 5.);\n\n// Chooses a color from the palette based on the current luminance\nvec4 applyPalette(float lum)\n{\n    lum = floor(lum * float(colors));\n    return palette[int(lum)];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // https://luka712.github.io/2018/07/01/Pixelate-it-Shadertoy-Unity/\n    float pixelSizeX = 1.0 / iResolution.x;\n    float pixelSizeY = 1.0 / iResolution.y;\n    float cellSizeX = pow(2., float(pixel_scale)) * pixelSizeX;\n    float cellSizeY = pow(2., float(pixel_scale)) * pixelSizeY;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert pixel coordinates to cell coordinates\n    float u = cellSizeX * floor(uv.x / cellSizeX);\n    float v = cellSizeY * floor(uv.y / cellSizeY);\n    \n    // get pixel information from the cell coordinates\n    vec4 col = texture(iChannel0, vec2(u,v));\n    \n    // https://en.wikipedia.org/wiki/Ordered_dithering\n    int x = int(u / cellSizeX) % 4;\n    int y = int(v / cellSizeY) % 4;\n    col.r = col.r + (dither_spread * ((threshold[x][y]/16.) -.5));\n    col.g = col.g + (dither_spread * ((threshold[x][y]/16.) -.5));\n    col.b = col.b + (dither_spread * ((threshold[x][y]/16.) -.5));\n    col.r = floor(col.r * float(colors-1) + .5)/float(colors-1);\n    col.g = floor(col.g * float(colors-1) + .5)/float(colors-1);\n    col.b = floor(col.b * float(colors-1) + .5)/float(colors-1);\n    \n    // Calculate luminance\n    float lum = (0.299*col.r + 0.587*col.g + 0.114*col.b);\n    \n    // Apply the new color palette\n    col = applyPalette(lum);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1171, 1238, 1268, 1268, 1338], [1340, 1340, 1397, 1470, 2785]], "test": "untested"}
{"id": "fl3yRl", "name": "Day 967", "author": "jeyko", "description": "cccccccc", "tags": ["voxel", "mdtmjvm"], "likes": 13, "viewed": 497, "published": 3, "date": "1660326492", "time_retrieved": "2024-07-30T16:35:51.132230", "image_code": "\nvoid mainImage( out vec4 C, vec2 U){\n    vec2 uv = (U)/R.xy;\n\n    vec3 col = vec3(0);\n    \n    vec2 st = (0.5)/R.xy;\n\n    \n    float l = \n        Ta(uv + vec2(st.x,0)).x-(Ta(uv - vec2(st.x,0))).x +\n        Ta(uv + vec2(0,st.y)).x-(Ta(uv - vec2(0,st.y))).x +\n        Ta(uv + vec2(st.xy)).x -(Ta(uv - vec2(st.xy))).x +\n        Ta(uv + vec2(st.x,-st.y)).x-(Ta(uv - vec2(st.x,-st.y))).x\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    \n    C = Ta(uv);\n    \n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + 0*int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n    float quant = 6. - float(fract(iTime/3./2.) > 0.8)*2.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    vec3 currColHsv = rgb2hsv(s.xyz);\n    //s = hsv2rgbSmooth(currColHsv*vec3(1,0.2,1.) + vec3(0.3,0.,0.)).xyzz;\n    //s = vec4(luma(s));\n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    \n    float bmod = float(lightMode==0.)*float(fract(iTime*0.125)<0.5);\n    float db = sdBox(nuv + vec2(0,-bmod*0.6),vec2(0.45,0.25 - bmod*0.24)*1.1);\n    \n\n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n    \n    \n    //C = mix(C,1.-C,smoothstep(dFdx(nuv.x),0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    \n    \n    C = mix(C,1.-C,smoothstep(0.001,0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    \n    \n    // outlines\n    if( db < 0.)\n        C = mix(C,-(0. + 14.*float(fract(iTime*0.25) < 0.5))*C,l);\n    else  \n        C = pow(abs(C),vec4(0.4545));\n        \n    \n    \n  \n    //C = abs(C);\n    \n    if(fract(iTime*0.33/2.) < 0.25 && hash11(floor(iTime)) < 0.2){\n        C = 1.-C;\n        C = pow(abs(C),vec4(0.454545));\n    }\n    if(fract(iTime*0.1) < 0.5){\n        float dbb = sdBox(nuv + vec2(0.4,0.2),vec2(0.45,0.25 - bmod*0.24)*0.1);\n        \n        if(dbb<0.&& hash11(floor(iTime)) < 0.2)\n            C *= 0.;\n        dbb = sdBox(nuv - vec2(0.4,0.),vec2(0.02,0.2 - bmod*0.));\n        \n        if(dbb<0.&& hash11(floor(iTime*0.99 + 0.06) + 150.) < 0.1)\n            C *= 0.;\n        // ui col blocks\n        vec2 p = nuv;\n        \n        float md = 0.0156;\n        \n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.004;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        \n        \n        if(abs(id.y-14.) <2.  && abs(id.x) < 18.){\n            if(sin(iTime + sin(r.y*3.)*4.)> 0.){\n                if(r.y < 0.5){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n                \n                } else{\n                    C = vec4(0);\n                }\n            \n            \n            } else{\n                C = 1.- C;\n            }\n            \n            \n               \n        }\n\n         \n    }     \n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi acos(-1.)\n#define R iResolution.xy\n#define iTime (iTime + 20.)\n\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\n#define lightMode float(fract(iTime*0.1) <0.5 )\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat noise(vec3 p_, float t){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.+ (t + sin(t))*0.4);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 2.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 2.4;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "// Fork of \"Day 966\" by jeyko. https://shadertoy.com/view/fltcRf\n// 2022-08-12 07:41:35\n\n\nfloat pixelScale = 4.;\n\nvec3 camPos;\n\nfloat map(vec3 p){\n    p *= 1./pixelScale;\n    float n = noise(p*(2. + 15.*floor(fract(iTime*0.05)*3.)),iTime);\n    float cbox = -length(p-camPos) +0.3;\n    \n   \n    //p.y += sin(p.x + cos(p.z*2.)*4.  + cos(p.z*2.)*4.)*0.2;\n    \n    float d = p.y;\n    \n    d = min(d, abs(p.y -1.8) - 0.1*sin(iTime));\n    \n    \n    d = n;\n    //d = max(d, (p.y+0.4));\n    \n    //d -= dot(p.xz,p.xz)*0.01;\n    d = max(d,cbox);\n    \n    //d = max(d,-length(p - vec3(0,sin(iTime*0.5 + sin(iTime*0.5)),0)) +0.4);\n    return d;\n}\n\nfloat mapQuantized(vec3 p){\n    return map(floor(p));\n}\n\nvec3 getRd(vec3 ro, vec3 target, vec2 uv){\n    vec3 dir = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\n\n\nvec3 getNormal(vec3 p){\n    vec2 t= vec2(0.001,0.);\n    return normalize(vec3(\n        map(p + t.xyy) - map(p - t.xyy),\n        map(p + t.yxy) - map(p - t.yxy),\n        map(p + t.yyx) - map(p - t.yyx)\n    ));\n}\n\n\nvec3 getNormalQuantized(vec3 p, int hitAxis){\n    vec2 t= vec2(0.04,0.);\n    vec3 hitVec = vec3(0);\n    hitVec[hitAxis] = 1.;\n    hitVec = mix(hitVec,vec3(1),0.05);\n    return normalize(vec3(\n        mapQuantized(p + t.xyy*hitVec) - mapQuantized(p - t.xyy*hitVec),\n        mapQuantized(p + t.yxy*hitVec) - mapQuantized(p - t.yxy*hitVec),\n        mapQuantized(p + t.yyx*hitVec) - mapQuantized(p - t.yyx*hitVec)\n    ));\n}\n\nvoid mainImage( out vec4 C, vec2 U){\n\n    if(fract(iTime*0.1) > 0.5)\n        pixelScale = 1.;\n    vec2 uv = (U-0.5*R.xy)/R.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    vec2 muv = iMouse.xy/R.xy;\n    float rotEnv = (iTime + sin(iTime + sin(iTime*0.7)*0.4)*0.4)*0.2;\n    ro.xz = vec2(cos(rotEnv +muv.x*pi),sin(rotEnv +muv.x*pi));\n    ro.y = 0.9;\n    \n    ro.y += sin(iTime*0.5)*0.2 - muv.y*2. + 0.;\n    \n    \n    \n    if(fract(iTime*0.15) > 0.5)\n        ro.y = -0.2;\n    camPos = ro;\n    ro *= pixelScale;\n    \n    //ro = floor(ro); // truley amazine\n    vec3 p = ro;\n    \n    \n    vec3 rd = getRd(ro, sin(vec3(3,2,1)*iTime*0.1)*pixelScale*.3,uv);\n    \n    float t = 0.;\n    bool hit = false;\n    \n    \n    int hitAxis = 0;\n    \n\n    float fZ;\n    float fX;\n    float fY;\n\n    float mn = 100.;\n    float i = 0.;\n    // voxel march\n    {\n\n        // basic trigonometry used to calculate the step size in each dir.\n        // sin(angle) = opposite/hypotenuse\n        // hypotenuse = 1./sin(angle)\n        \n        float zHypot;\n        float xHypot;\n        float yHypot;\n        \n        {\n            float zAngle = atan(rd.x/rd.z);\n            if(rd.z < 0.)\n                zAngle *= -1.;\n            if(rd.x < 0.)\n                zAngle *= -1.;\n\n            zHypot = 1./sin(zAngle);\n        }\n        {\n            float xAngle = atan(rd.z/rd.x);\n            if(rd.z < 0.)\n                xAngle *= -1.;\n            if(rd.x < 0.)\n                xAngle *= -1.;\n\n            xHypot = 1./sin(xAngle);\n        }\n        \n        {\n            float yAngle = acos(rd.y);\n            yHypot = 1./sin(yAngle); \n        }\n        \n        \n        \n        const float maxFractalD = 5.;\n        float currFractalD = 1.;\n        float[int(maxFractalD + 2.)] walkTillExit;\n        float[int(maxFractalD + 2.)] currDWalk;\n        for(int i = 0; i < walkTillExit.length(); i++){walkTillExit[i] = 0.;}\n        for(int i = 0; i < currDWalk.length(); i++){walkTillExit[i] = 0.;}\n        walkTillExit[1] = 10000.;\n        \n        for( i = 0.; i < 4414.; i++){\n            vec3 fracP = fract(p*currFractalD);\n            \n            float d = map(floor(p*currFractalD ));\n            \n           \n            if(d < 0.){\n                // EXIT HIT FINAL\n                if(currFractalD > maxFractalD){\n                    //p *= currFractalD;\n                    hit = true;\n                    break;\n                }\n            }             \n            if(rd.z < 0.){\n                fracP.z = 1. - fracP.z;\n            }\n            if(rd.x < 0.){\n                fracP.x = 1. - fracP.x;\n            }\n            if(rd.y < 0.){\n                fracP.y = 1. - fracP.y;\n            }\n            \n            const float overStepFac = 1.0001;\n            fZ = xHypot*(overStepFac-fracP.z);\n            fX = zHypot*(overStepFac-fracP.x);\n            fY = yHypot*(overStepFac-fracP.y);\n            \n            float minWalk = min(min(fZ,fX),fY);\n            \n            if(d < 0. && currFractalD <= maxFractalD){\n                // HIT CURR\n                currFractalD += 1.;\n                walkTillExit[int(currFractalD)] = minWalk;\n                currDWalk[int(currFractalD)] = 0.;\n            } else {\n                // WALK\n                float stepSz = minWalk / currFractalD;\n                currDWalk[int(currFractalD)] += stepSz;\n                t += stepSz;\n                p += rd * stepSz;\n                \n                // REDUCE D\n                if(currDWalk[int(currFractalD)] + 0.4 > walkTillExit[int(currFractalD)]){\n                    currFractalD -= 1.;\n                    p += rd * (0.001 + 0.5*float(fract(iTime*0.1)<0.1));\n                                        \n                    if(currFractalD == 0.){\n                        break;\n                    }\n                }\n            }\n            \n            \n            \n            \n        }    \n\n    }\n    \n    if(fZ < mn){\n        mn = fZ;\n        hitAxis = 2;\n    }if(fX < mn){\n        mn = fX;\n        hitAxis = 0;\n    }if(fY < mn){\n        mn = fY;\n        hitAxis = 1;\n    }    \n    \n    col = vec3(1);\n    \n    \n    #define ao(p,n,d,amt) mix(1.,clamp(map(p+n*d)/d/pixelScale,0.,1.),amt)\n    \n    // sghading\n    if(hit){\n        \n        float normalSign = sign(fract(p[hitAxis]) - 0.5);\n        \n        vec3 n = getNormal(p);\n        vec3 nq = vec3(0);\n        nq[hitAxis] = 1.;\n        nq *= normalSign;\n        \n        \n        vec3 q = abs(fract(p) - 0.5)*1.5;\n        q[hitAxis] = 0.;\n        \n        \n        //col = mix(col,col*-(0. + float(fract(iTime*0.1) < 0.5)),max(q.x,max(q.y,q.z)));\n        //col = mix(col,col*0.,max(q.x,max(q.y,q.z)));\n        \n        col = 0.5*nq + 0.5;\n        \n        \n        col = abs(col);\n        \n        \n        col = palAppleII[int(floor(p.x)*14. + nq.x + nq.y*10.)%16];\n        col = pow(abs(col),vec3(.4545));\n        \n        float AO = 1. \n            //ao(p + nq*0.,nq,0.6*pixelScale,0.9)\n            * ao(p + nq*0.,nq,40.*pixelScale,0.5)\n            * ao(p + nq*0.,nq,1.*pixelScale,0.7)\n            * ao(p,nq,1.4*pixelScale,0.5)\n            //* ao(p + nq*0.,n,0.2*pixelScale,0.5)\n            //* ao(p + nq*0. + vec3(0.5,0.4,0)*pixelScale,n,1.*pixelScale,.4)\n            //* ao(p,normalize(mix(n,vec3(1,1,0),1.)),1.4*pixelScale,0.8)\n            \n            ;\n        {\n        if(fract(iTime*0.125) < 0.2)\n            col *= 1. * AO;\n        }\n        col *= smoothstep(-80.5,40.,p.y);\n        col *= 1.3;\n    }\n    \n    \n    col = mix(\n        col,\n        sin(col*1. + i*(.04 + 0.4*float(fract(iTime*0.4) < 0.5)))*0.5 + 0.5,\n        exp(-i*(0.01+ 0.*float(fract(iTime*0.1)> 0.89)))\n    );\n    col = mix(col, vec3(1),\n        smoothstep(1.,5.,t*0.4)    \n        );\n    \n    col *= 1. - dot(uv,uv)*0.7;\n    \n    C = 1.-exp(-abs(C));\n    C = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3yRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 3097]], "test": "untested"}
{"id": "sl3czs", "name": "another deep 6input", "author": "lomateron", "description": "ananother one", "tags": ["binaryfunction"], "likes": 2, "viewed": 188, "published": 3, "date": "1660323375", "time_retrieved": "2024-07-30T16:35:51.877238", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord).xxxx;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nuint nor(uint a, uint b)\n{\n    return ~(a|b);\n}\nuint deep6(uint a, uint b, uint c, uint d, uint e, uint f)\n{\n    uint r = (a<<0U)|\n             (b<<1U)|\n             (c<<2U)|\n             (d<<3U)|\n             (e<<4U)|\n             (f<<5U);\n         //r = 63U-r;\n    uint v1 = 3900801303U;\n    uint v2 = 2129193089U;\n          uint v = v1;\n    if(r>=32U){v = v2;}\n             \n    return (v>>(r&31U))&1U;\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    int mv = -(iFrame&1);\n    uint a = uint(A(u+vec2(-1,-1)).x) & 1U;//uint(A(u+vec2(-2+mv,-1)).x) & 1U;\n    uint b = uint(A(u+vec2( 0,-1)).x) & 1U;//uint(A(u+vec2(-1+mv,-1)).x) & 1U;\n    uint c = uint(A(u+vec2( 1,-1)).x) & 1U;//uint(A(u+vec2( 0+mv,-1)).x) & 1U;\n    uint d = uint(A(u+vec2(-1,-2)).x) & 1U;//uint(A(u+vec2( 1+mv,-1)).x) & 1U;\n    uint e = uint(A(u+vec2( 0,-2)).x) & 1U;//uint(A(u+vec2( 2+mv,-1)).x) & 1U;\n    uint f = uint(A(u+vec2( 1,-2)).x) & 1U;//uint(A(u+vec2( 3+mv,-1)).x) & 1U;\n    \n    uint o = deep6(a,b,c,d,e,f);  o = nor(o,o);\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = uint(fract(cos(dot(u,vec2(234.76543,iTime+13.23513)))*2467.5678)+.5);\n        //o = uint(step(dot(v,v),dot(m,m)*.1));\n        //o = 1U-uint(u.x==0.5 && u.y==0.5);\n    }\n    if(iFrame!=0&&int(u.y)!=(iFrame%int(iResolution.y))){o=uint(A(u).x)&1U;}\n    fragColor = vec4(o&1U);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3czs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 145]], "test": "untested"}
{"id": "7tcyzs", "name": "deep 6input NOR network", "author": "lomateron", "description": "probably the deepest 6input\nthis new method \"DEEP FILTER\" will let me go into the deep 9input and\nlet me classify how deep is \"the game of life\"\n", "tags": ["binaryfunction"], "likes": 5, "viewed": 201, "published": 3, "date": "1660322084", "time_retrieved": "2024-07-30T16:35:52.616262", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord).xxxx;\n}\n\n//    DEEP FILTER\n//    NOR network has Xinputs 1bit each and 1bit output\n//    all inputs must participate\n//    swaping inputs result in same output\n//    simulations that dont get stuck early have white-black ratio balanced\n//\n//    transform whats under \"Xinput\" into decimal position\n//    then mark that position in \"filter\" as ONbit\n//    then color the fitler ONbit then color that ONbit of the filer into the \"result\"\n//    \n//    1input  filter  color\n//    □       ■□      □ or ■\n//    ■       □■      □ or ■\n//    result  □□\n//            ■■\n//    \n//    2input       filter  color\n//    □□           ■□□□    □ or ■\n//    ■□ □■        □■■□    ■ or □\n//    ■■           □□□■    □ or ■\n//         result  □■■□    \n//                 ■□□■    \n//    \n//    3input       filter    color\n//    □□□          ■□□□□□□□  ■ or □\n//    ■□□ □■□ □□■  □■■□■□□□  □ or ■\n//    ■■□ ■□■ □■■  □□□■□■■□  ■ or □\n//    ■■■          □□□□□□□■  □ or ■\n//         result  ■□□■□■■□\n//                 □■■□■□□■\n//    \n//    4input                         filter            color\n//    □□□□                           ■□□□□□□□□□□□□□□□  ■ or ■\n//    ■□□□ □■□□ □□■□ □□□■            □■■□■□□□■□□□□□□□  ■ or □\n//    ■■□□ ■□■□ □■■□ ■□□■ □■□■ □□■■  □□□■□■■□□■■□■□□□  □ or ■\n//    ■■■□ ■■□■ ■□■■ □■■■            □□□□□□□■□□□■□■■□  ■ or □\n//    ■■■■                           □□□□□□□□□□□□□□□■  □ or □\n//                           result  ■■■□■□□■■□□■□■■□   \n//                                   ■□□■□■■□□■■□■□□□\n//    5input                                                       filter                            color\n//    □□□□□                                                        ■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□  ■ or □\n//    ■□□□□ □■□□□ □□■□□ □□□■□ □□□□■                                □■■□■□□□■□□□□□□□■□□□□□□□□□□□□□□□  ■ or □\n//    ■■□□□ ■□■□□ □■■□□ ■□□■□ □■□■□ □□■■□ ■□□□■ □■□□■ □□■□■ □□□■■  □□□■□■■□□■■□■□□□□■■□■□□□■□□□□□□□  □ or ■\n//    ■■■□□ ■■□■□ ■□■■□ □■■■□ ■■□□■ ■□■□■ □■■□■ ■□□■■ □■□■■ □□■■■  □□□□□□□■□□□■□■■□□□□■□■■□□■■□■□□□  ■ or □\n//    ■■■■□ ■■■□■ ■■□■■ ■□■■■ □■■■■                                □□□□□□□□□□□□□□□■□□□□□□□■□□□■□■■□  □ or ■\n//    ■■■■■                                                        □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■  □ or ■\n//                                                         result  ■■■□■□□■■□□■□■■□■□□■□■■□□■■□■□□□\n//                                                                 □□□■□■■□□■■□■□□■□■■□■□□■■□□■□■■■", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nuint nor(uint a, uint b)\n{\n    return ~(a|b);\n}\nuint deep6(uint a, uint b, uint c, uint d, uint e, uint f)\n{\n    uint r = (a<<0U)|\n             (b<<1U)|\n             (c<<2U)|\n             (d<<3U)|\n             (e<<4U)|\n             (f<<5U);\n         //r = 63U-r;\n    uint v1 = 3918960233U;\n    uint v2 = 2129258902U;\n          uint v = v1;\n    if(r>=32U){v = v2;}\n             \n    return (v>>(r&31U))&1U;\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    int mv = -(iFrame&1);\n    uint a = uint(A(u+vec2(-1,-1)).x) & 1U;//uint(A(u+vec2(-2+mv,-1)).x) & 1U;\n    uint b = uint(A(u+vec2( 0,-1)).x) & 1U;//uint(A(u+vec2(-1+mv,-1)).x) & 1U;\n    uint c = uint(A(u+vec2( 1,-1)).x) & 1U;//uint(A(u+vec2( 0+mv,-1)).x) & 1U;\n    uint d = uint(A(u+vec2(-1,-2)).x) & 1U;//uint(A(u+vec2( 1+mv,-1)).x) & 1U;\n    uint e = uint(A(u+vec2( 0,-2)).x) & 1U;//uint(A(u+vec2( 2+mv,-1)).x) & 1U;\n    uint f = uint(A(u+vec2( 1,-2)).x) & 1U;//uint(A(u+vec2( 3+mv,-1)).x) & 1U;\n    \n    uint o = deep6(a,b,c,d,e,f);  //o = nor(o,o);\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = uint(fract(cos(dot(u,vec2(234.76543,iTime+13.23513)))*2467.5678)+.5);\n        //o = uint(step(dot(v,v),dot(m,m)*.1));\n        o = 1U-uint(u.x==0.5 && u.y==0.5);\n    }\n    if(iFrame!=0&&int(u.y)!=(iFrame%int(iResolution.y))){o=uint(A(u).x)&1U;}\n    fragColor = vec4(o&1U);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 145]], "test": "untested"}
{"id": "stdcRf", "name": "Lens Distort", "author": "MysteryPancake", "description": "Not physically accurate, just looks cool", "tags": ["distortion", "lens", "distort", "circle", "optics"], "likes": 4, "viewed": 341, "published": 3, "date": "1660275658", "time_retrieved": "2024-07-30T16:35:53.447041", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\n\tvec2 center = vec2(0.5);\n\tif (iMouse.z > 0.0) {\n\t\tcenter = iMouse.xy / iResolution.xy;\n\t}\n\n\tfloat dist = distance(uv, center);\n\tvec2 dir = uv - center;\n\tfloat lens = mod(iTime, 4.0);\n\n\tfragColor = texture(iChannel0, uv - dist * dir * lens);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 340]], "test": "untested"}
{"id": "sltcRf", "name": "Simple Outline (Stroke)", "author": "MysteryPancake", "description": "Based on my \"Circle Man\" shader", "tags": ["stroke", "edge", "outline", "border"], "likes": 16, "viewed": 2667, "published": 3, "date": "1660275497", "time_retrieved": "2024-07-30T16:35:54.189057", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tconst vec3 target = vec3(0.0, 1.0, 0.0); // Find green\n    const float TAU = 6.28318530;\n\tconst float steps = 32.0;\n    \n\tfloat radius = iMouse.z > 0.0 ? length(0.5 - iMouse.xy / iResolution.xy) * 100.0 : sin(iTime * 4.0) * 20.0 + 20.0;\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n\tfragColor = vec4(uv.y, 0.0, uv.x, 1.0);\n\tfor (float i = 0.0; i < TAU; i += TAU / steps) {\n\t\t// Sample image in a circular pattern\n        vec2 offset = vec2(sin(i), cos(i)) * aspect * radius;\n\t\tvec4 col = texture(iChannel0, uv + offset);\n\t\t\n\t\t// Mix outline with background\n\t\tfloat alpha = smoothstep(0.5, 0.7, distance(col.rgb, target));\n\t\tfragColor = mix(fragColor, vec4(1.0), alpha);\n\t}\n\t\n    // Overlay original video\n\tvec4 mat = texture(iChannel0, uv);\n\tfloat factor = smoothstep(0.5, 0.7, distance(mat.rgb, target));\n\tfragColor = mix(fragColor, mat, factor);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 996]], "test": "untested"}
{"id": "7ltyRX", "name": "Shortest RGB Noise - 102 chars", "author": "GregRostami", "description": "Here's a fork of my previous noise shader here:\n[url]https://www.shadertoy.com/view/7ldyRB[/url]", "tags": ["2d", "noise", "short"], "likes": 14, "viewed": 367, "published": 3, "date": "1660262271", "time_retrieved": "2024-07-30T16:35:54.929078", "image_code": "#define n fract( tan(dot(u,u+ ++o.a) / u.y+iTime) * u)\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o*=0.;\n    o = vec4(n,n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 91, 91, 123]], "test": "untested"}
{"id": "wsBczG", "name": "Mondrianesque", "author": "bikemule", "description": "Asked as a challenge in: https://thebookofshaders.com/07/", "tags": ["2d", "beginner", "painting", "mondrian", "bookofshaders"], "likes": 2, "viewed": 186, "published": 3, "date": "1660251181", "time_retrieved": "2024-07-30T16:35:55.739910", "image_code": "// Width of box borders\n#define W .005\n// Background/border color\nconst vec3 bgColor = vec3(0.,0.,0.);\n\n/* \nLines all the way across at these points, horizontal and vertical\n\nIt would be nice to randomly generate these, but I'm not sure how to generate\nsomething that will be random, but consistent every frame.\n\nNoise channel could provide repeatability?\n*/\n\n// horizontal\nconst float xlines[4] = float[4](0.2,0.45,0.7,0.83);\n// vertical\nconst float ylines[6] = float[6](0.1, 0.33, 0.55, 0.6, 0.7, 0.92);\n\nvec3 inLines(in vec2 p) {\n    \n    // Draw horizontal lines\n    for(int i=0; i<xlines.length(); i++){\n        if(p.x < (xlines[i] + W) && p.x > (xlines[i] - W)){\n            return bgColor;\n        }\n    }\n    \n    // Draw vertical lines\n    for(int i=0; i< ylines.length(); i++) {\n        if(p.y < (ylines[i] + W) && p.y > (ylines[i] - W)) {\n            return bgColor;\n        }\n    }\n    \n    // Determine color inside boxes.\n    // TODO: Store the boxes w/ colors in some better data format\n    \n    // Easier to think of the ordering of the boxes as starting at the bottom \n    // First 4 boxes (0-3) of first col and first 2 of last col\n    if(p.x < xlines[0] && p.y < ylines[3] || p.y < ylines[1] && p.x > xlines[3]) {\n\t    return vec3(0.9, 0.2, 0.2);  // Red\n    } else if (p.x > xlines[2] && p.x < xlines[3] && p.y < ylines[4] && p.y > ylines[0]) {\n      \t// Second through fifth boxes of 4th col\n        return vec3(.2, 0.2, .9);  // Blue\n    } else if (p.x > xlines[2] && p.y > ylines[5]) {\n        // last box of last two cols\n        return vec3(.95,.99,0.);  // Yellow\n    } else\n        return vec3(1.);  // Default to white\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // Output to screen, inLines() returns color\n    fragColor = vec4(inLines(uv),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 507, 532, 566, 1648], [1650, 1650, 1707, 1757, 1892]], "test": "untested"}
{"id": "tlXBzl", "name": "concentric circles accident", "author": "bikemule", "description": "Trying to do something else, ended up with this and thought it looked cool", "tags": ["happyaccidents"], "likes": 3, "viewed": 204, "published": 3, "date": "1660251128", "time_retrieved": "2024-07-30T16:35:56.548748", "image_code": "#define PI 3.1415926535897932384626433832795028841971693993751058209\n\n// https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make coords from -2 to 2\n    uv *= vec2(2.5);\n    uv -= vec2(1.25);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    fragColor = vec4(vec3(.5,.5, .5), 1.);\n    \n    // circle\n    if(length(uv - vec2(0)) <= 1.0 && length(uv - vec2(0)) >= .99){\n        fragColor = vec4(vec3(0), 1.);\n    }\n    \n    // Draw moving circles\n    for(float i=0.;i<16.;i++){\n        uv = rotate(uv, ((PI*2.)/16.)*i);\n        if(mod(length(uv - vec2(sin(iTime + (iTime/PI)))), 1.) <= .05){\n    \t    fragColor = vec4(vec3(sin(iTime),cos(iTime),tan(iTime)), 1.0);\n    \t}\n    }\n    \n    // Circle moving around circumference of circle\n    if(length(uv - vec2(sin(iTime), cos(iTime))) <= .05){\n\t\tfragColor = vec4(vec3(0), 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 137, 167, 167, 251], [253, 253, 310, 360, 1119]], "test": "untested"}
{"id": "NltcRf", "name": "Night valley", "author": "pohy", "description": "Just something soothing.\nThe mehs are because I made this in my own live coding utility and then copy pasted. Just a quick and dirty fix.", "tags": ["2d", "noise", "night", "mountains", "valley"], "likes": 7, "viewed": 302, "published": 3, "date": "1660245401", "time_retrieved": "2024-07-30T16:35:57.295750", "image_code": "// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float x) {\n    return fract(sin(x) * 43758.5453123); \n}\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat posSin(float x) {\n    return sin(x) * -1.0 + 1.0;\n}\n\nfloat sdfCircle(vec2 uv, float radius, float softness) {\n    float circleDistance = length(uv);\n    return smoothstep(radius + softness, radius - softness, circleDistance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    // Seems that my live coding tool has the y coordinate inerted :)\n    uv.y *= -1.0;\n    float time = iTime;\n    // time = 0;\n    \n    // Sky gradient\n    vec3 skyColor = vec3(0.2, 0.2, 0.4);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    col = mix(col, skyColor, exp(0.8 + uv.y * 2.5));\n\n    // Stars\n    float steps = 200.0;\n    // For loop is not the best [performant] solution :/\n    for (float i = 0.0; i < steps; i++) {\n        float iNormalized = i / steps;\n        vec2 offset = vec2(-0.5 + noise(i) * 2.0 - sin(time * 0.001), 0.1 + noise(uv.x + i) * 0.5);\n        float circle = sdfCircle(uv.xy + offset, 0.0008, 0.0003);\n        // float circle = sdfCircle(uv.xy + offset, 0.05, 0.001);\n        float intensity = noise(i + uv.y) * 0.8 * (posSin(time * 0.5 + i));\n        circle *= intensity;\n        col = mix(col, vec3(1), circle);\n    }\n\n    // Mountain pass masks\n    float firstPass = step(noise(uv.x * 60.0 + time) * 0.02, uv.y + 0.26);\n    float secondPass = step(noise((uv.x + 0.0) * 45.0 + time) * 0.08, uv.y + 0.27);\n    float thirdPass = step(noise((uv.x + 0.2) * 20.0 + time) * 0.15, uv.y + 0.28);\n    float fourthPass = step(noise((uv.x + 2.0) * 10.0 + time) * 0.22, uv.y + 0.29);\n\n    float tintFactor = 0.12;\n    vec3 tint = mix(skyColor * tintFactor, vec3(0), uv.y + 0.5);\n    tint = mix(vec3(0), skyColor, uv.y * 0.2 + tintFactor);\n    //tint *= posSin(time * 0.1) * 0.5;\n    //tint *= 0.0;\n    col = mix(col, vec3(0.12) + tint, firstPass);\n    col = mix(col, vec3(0.08) + tint, secondPass);\n    col = mix(col, vec3(0.04) + tint, thirdPass);\n    col = mix(col, vec3(0.0) + tint, fourthPass);\n\n    // Debugging\n    // float pass = step(uv.y - 0.1, noise(uv.x * -2 - 10) * -0.2 + noise(uv.x * 10 + time) * 0.2);\n    // col = vec3(pass);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 69, 90, 90, 135], [136, 136, 157, 157, 249], [251, 251, 274, 274, 308], [310, 310, 366, 366, 484], [486, 486, 543, 543, 2399]], "test": "untested"}
{"id": "fltcRf", "name": "Day 966", "author": "jeyko", "description": "cccccccc", "tags": ["voxel", "mdtmjvm"], "likes": 21, "viewed": 574, "published": 3, "date": "1660245290", "time_retrieved": "2024-07-30T16:35:58.105585", "image_code": "\nconst float pixelScale = 70.;\n\nvec3 camPos;\n\nfloat map(vec3 p){\n    p *= 1./pixelScale;\n    float n = noise(p*(2. + 5.*floor(fract(iTime*0.05)*3.)),iTime);\n    float cbox = -length(p-camPos) +0.5;\n    p.y += 0.1 + n * 0.3;\n    \n   \n    p.y += sin(p.x + cos(p.z*2.)*4.  + cos(p.z*2.)*4.)*0.2;\n    \n    float d = p.y;\n    \n    d = min(d, abs(p.y -1.8) - 0.1*sin(iTime));\n    \n    //d = max(d, (p.y+0.4));\n    \n    //d -= dot(p.xz,p.xz)*0.01;\n    d = max(d,cbox);\n    \n    d = max(d,-length(p - vec3(0,sin(iTime*0.5 + sin(iTime*0.5)),0)) +0.4);\n    return d;\n}\n\nfloat mapQuantized(vec3 p){\n    return map(floor(p));\n}\n\nvec3 getRd(vec3 ro, vec3 target, vec2 uv){\n    vec3 dir = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\n\n\nvec3 getNormal(vec3 p){\n    vec2 t= vec2(0.001,0.);\n    return normalize(vec3(\n        map(p + t.xyy) - map(p - t.xyy),\n        map(p + t.yxy) - map(p - t.yxy),\n        map(p + t.yyx) - map(p - t.yyx)\n    ));\n}\n\n\nvec3 getNormalQuantized(vec3 p, int hitAxis){\n    vec2 t= vec2(0.4,0.);\n    vec3 hitVec = vec3(0);\n    hitVec[hitAxis] = 1.;\n    hitVec = mix(hitVec,vec3(1),0.3);\n    return normalize(vec3(\n        mapQuantized(p + t.xyy*hitVec) - mapQuantized(p - t.xyy*hitVec),\n        mapQuantized(p + t.yxy*hitVec) - mapQuantized(p - t.yxy*hitVec),\n        mapQuantized(p + t.yyx*hitVec) - mapQuantized(p - t.yyx*hitVec)\n    ));\n}\n\nvoid mainImage( out vec4 C, vec2 U){\n    vec2 uv = (U-0.5*R.xy)/R.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    vec2 muv = iMouse.xy/R.xy;\n    float rotEnv = (iTime + sin(iTime + sin(iTime*0.7)*0.4)*0.4)*0.2;\n    ro.xz = vec2(cos(rotEnv +muv.x*pi),sin(rotEnv +muv.x*pi));\n    ro.y = 0.9;\n    \n    ro.y += sin(iTime)*0. - muv.y*2. + 0.;\n    \n    camPos = ro;\n    ro *= pixelScale;\n    \n    //ro = floor(ro); // truley amazine\n    vec3 p = ro;\n    \n    \n    vec3 rd = getRd(ro, sin(vec3(3,2,1)*iTime*0.1)*pixelScale*0.2,uv);\n    \n    float t = 0.;\n    bool hit = false;\n    \n    \n    int hitAxis = 0;\n    \n\n    float fZ;\n    float fX;\n    float fY;\n\n    float mn = 100.;\n    \n    // voxel march\n    {\n\n        // basic trigonometry used to calculate the step size in each dir.\n        // sin(angle) = opposite/hypotenuse\n        // hypotenuse = 1./sin(angle)\n        \n        float zHypot;\n        float xHypot;\n        float yHypot;\n        \n        {\n            float zAngle = atan(rd.x/rd.z);\n            if(rd.z < 0.)\n                zAngle *= -1.;\n            if(rd.x < 0.)\n                zAngle *= -1.;\n\n            zHypot = 1./sin(zAngle);\n        }\n        {\n            float xAngle = atan(rd.z/rd.x);\n            if(rd.z < 0.)\n                xAngle *= -1.;\n            if(rd.x < 0.)\n                xAngle *= -1.;\n\n            xHypot = 1./sin(xAngle);\n        }\n        \n        {\n            float yAngle = acos(rd.y);\n            yHypot = 1./sin(yAngle); \n        }\n        \n            \n\n        \n        for(float i = 0.; i < 1414.; i++){\n            vec3 fracP = fract(p);\n            \n            float d = map(floor(p));\n            \n            if(d < 0.){\n                hit = true;\n                break;\n            }            \n            \n            if(rd.z < 0. && fracP.z != 0.){\n                fracP.z = 1. - fracP.z;\n            }\n            if(rd.x < 0. && fracP.x != 0.){\n                fracP.x = 1. - fracP.x;\n            }\n            if(rd.y < 0. && fracP.y != 0.){\n                fracP.y = 1. - fracP.y;\n            }\n            \n            const float overStepFac = 1.004;\n            fZ = xHypot*(overStepFac-fracP.z);\n            fX = zHypot*(overStepFac-fracP.x);\n            fY = yHypot*(overStepFac-fracP.y);\n            \n            vec3 op = p;\n            \n            \n            p += (min(min(fZ,fX),fY)) * rd;\n            \n        }    \n\n    }\n    \n    if(fZ < mn){\n        mn = fZ;\n        hitAxis = 2;\n    }if(fX < mn){\n        mn = fX;\n        hitAxis = 0;\n    }if(fY < mn){\n        mn = fY;\n        hitAxis = 1;\n    }    \n    \n    col = vec3(1);\n    \n    \n    #define ao(p,n,d,amt) mix(1.,clamp(map(p+n*d)/d/pixelScale,0.,1.),amt)\n    \n    // sghading\n    if(hit){\n        vec3 gn;\n        \n        vec3 nq = getNormalQuantized(p, hitAxis);\n        vec3 n = getNormal(p);\n        \n        col = sin(vec3(1,2,3) + n.x*1111.\n            //+ float(fract(iTime*0.1) < 0.25)*(dot(p.xz,p.xz)*0.01 + iTime*10.)\n            )*1. + 1.;\n        col *= 1.4;\n        \n        vec3 q = abs(fract(p) - 0.5)*2.;\n        q[hitAxis] = 0.;\n        col = mix(col,col*-(0. + float(fract(iTime*0.1) < 0.5)),max(q.x,max(q.y,q.z)));\n        col = abs(col);\n        float AO = ao(p + nq*0.,nq,0.6*pixelScale,0.9)\n            * ao(p + nq*0.,n,0.1*pixelScale,0.4)\n            * ao(p + nq*0. + vec3(0.5,0.4,0)*pixelScale,n,1.*pixelScale,.4)\n            * ao(p,normalize(mix(n,vec3(1,1,0),1.)),1.4*pixelScale,0.8)\n            //* ao(p + nq*0. + vec3(0,1,0),n,3.4*pixelScale,0.4)\n            ;\n        col *= \n            max(dot(n,normalize(vec3(1,1.,0))),0.)*0.4*AO \n            + 0.4*AO\n            //*ao(p,n,0.1*pixelScale,0.5)\n            //*ao(p,n,1.9*pixelScale,0.5)\n            ;\n        col *= smoothstep(-30.5,40.,p.y);\n        col *= 1.3;\n    }\n    \n    \n    col = mix(col, vec3(1),\n        smoothstep(1.,5.,length((ro-p)/pixelScale))\n        \n        );\n    \n    col *= 1. - dot(uv,uv)*0.7;\n    C = vec4(col,1.0);\n    \n    C = abs(C);\n    C = 1.-exp(-C);\n    C = pow(C,vec4(0.454545));\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi acos(-1.)\n#define R iResolution.xy\n#define iTime (iTime + 7.)\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat noise(vec3 p_, float t){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.+ (t + sin(t))*0.4);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 2.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 2.4;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 64, 64, 558], [560, 560, 587, 587, 615], [617, 617, 659, 659, 847], [850, 850, 873, 873, 1060], [1063, 1063, 1108, 1108, 1480], [1482, 1482, 1518, 1518, 5532]], "test": "untested"}
{"id": "NltyzX", "name": "Generative", "author": "wyatt", "description": "An attempt to keep  up with the times.", "tags": ["cnn"], "likes": 5, "viewed": 403, "published": 3, "date": "1660238509", "time_retrieved": "2024-07-30T16:35:58.855580", "image_code": "Main {\n\n    vec4 a = C(U);\n    Q = D(U);\n    //Q = A(U).zzzz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nvec2 hash(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n#define W 6.\n#define LOD (2.+mod(float(iFrame),2.))\n\n#define v (vec2(0,.3)*R+vec2(1,.6)*R*floor(hash(iDate.w)*100.)/100.)\n\n#define AL(U) texture(iChannel0,(U)/R,LOD)\n#define BL(U) texture(iChannel1,(U)/R,LOD)\n#define CL(U) texture(iChannel2,(U)/R,LOD)\n#define DL(U) texture(iChannel3,(U)/R,LOD)\n\n", "buffer_a_code": "// Convolution\nMain {\n    float w = 0.;\n    for (float x = 0.; x < W; x++)\n    for (float y = 0.; y < W; y++)\n    {\n        vec2 u = 2.*(vec2(x,y)-.5*W)*LOD;\n        vec4 a = DL(U+u);\n        vec4 b = CL(v+u);\n        w += dot(a.xyz-b.xyz,a.xyz-b.xyz);\n    }\n    Q = vec4(U,exp(-w*w),1);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Pooling\nMain {\n    Q = vec4(0);\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++)\n    {\n        vec2 u = U+LOD*vec2(x,y);\n        vec4 a = A(u);\n        if (a.z>Q.z) Q = a;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Pooling\nMain {\n    Q = vec4(0);\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++)\n    {\n        vec2 u = U+LOD*4.*vec2(x,y);\n        vec4 a = A(u);\n        if (a.z>Q.z) Q = a;\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = D(U);\n    vec4 a = vec4(0);\n    \n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++)\n    {\n        vec2 u = U+40.*vec2(x,y);\n        vec4 b = B(u);\n        if (b.z>a.z) a = b;\n    }\n    vec4 c = C(v+U-a.xy);\n    float q = texture(iChannel0,.5*R,10.).z;\n    if (q>0.) a.z /= q;\n    float d = length(U-a.xy)/5.;\n    c.w = 100.*exp(-6.*sqrt(d))*clamp(a.z,0.,1.);\n    Q.xyz = mix(Q.xyz,c.xyz,clamp(.3*(c.w)/(Q.w+c.w),0.,1.));\n    Q.w = .995*Q.w+c.w;\n    if (iFrame < 1) {\n        U += 100.;\n        Q.xyz = hash32(floor(.01*U));\n        Q.xyz *= hash32(floor(.1*U));\n        Q.xyz *= hash32(floor(U));\n        Q = sqrt(sqrt(Q));\n        Q.w=1e-9;\n   }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Nlcczf", "name": "Traveling by the mountains", "author": "detectiveLosos", "description": "Another shader written on the mobile phone during travel. Slightly modified to fit shadertoy horizontal framing and resolution better.\nThere are some aliasing artifacts on the horizontal lines. But I probably won't ever fix them :P", "tags": ["2d", "mountains", "ink", "paper"], "likes": 92, "viewed": 3856, "published": 3, "date": "1660225774", "time_retrieved": "2024-07-30T16:35:59.601585", "image_code": "float getH(\n    float pos,\n    out vec2 from, out vec2 to, out float blend\n)\n{\n    float n;\n\n    float i = floor(pos);\n    float f = pos - i;\n    vec2 rand = vec2(0.4, 0.95);\n\n    // x is i-offset, y is peak height.\n    vec2 sub = vec2(0.5, 0.0);\n    vec2 add = vec2(0.5, 1.1 - rand.y);\n    vec2 l = (hash21((i-1.0)) - sub) * rand + add;\n    vec2 c = (hash21(i) - sub) * rand + add;\n    vec2 r = (hash21((i+1.0)) - sub) * rand + add;\n\n    l.x = (i - 1.0) + l.x;\n    c.x = i + c.x;\n    r.x = (i + 1.0) + r.x;\n\n    if(pos < c.x)\n    {\n        from = l;\n        to = c;\n    }\n    else\n    {\n        from = c;\n        to = r;\n    }\n\n    // Make 90-degree angle mountains\n    // between from-to points by creating mid point.\n    //if(false)\n    {\n        float tl = 0.5*(to.x - from.x - to.y + from.y);\n        vec2 mid = to + vec2(-1.0, 1.0)*tl;\n\n        if(pos < mid.x)\n        {\n            to = mid;\n        }\n        else\n        {\n            from = mid;\n        }\n    }\n\n    // Linearly interpolate between from-to points.\n    blend = ((pos - from.x) / (to.x - from.x));\n    n = lerp(from.y, to.y, blend);\n\n    return n;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord.y -= -0.1*iResolution.y + 0.1*iResolution.y*cos((fragCoord.x / iResolution.x - 0.5)*M_PI*0.5);\n\n\n    float mx = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord.xy / mx;\n    vec2 nuv = fragCoord.xy / iResolution.xy;\n    vec2 pos = uv - (iResolution.xy)*0.5/mx;\n    \n    float col = 1.0;\n\n    float sNoise = optimizedSnoise(vec2(pos.x*15.0, 0.0));\n\n    // Sun.\n    vec3 circle = sdgCircle(pos + vec2(0.2, -0.05), 0.1);\n    col *= saturate(400.0*abs(circle.x) - 1.0*(0.5 + sin(sNoise*5.0 + 0.5*iTime)));\n    col *= saturate(1.3 - saturate(-circle.x*800.0 - 7.0)*cos(circle.x*800.0 - 1.0*(1.0 + cos(sNoise*5.0+0.5*iTime))));\n\n    // Deform.\n    pos -= 0.5*vec2(pos.y, - pos.x);\n\n    // Horizontal scroll.\n    pos.x += iTime*0.01;\n\n    // Wiggle animation.\n    /*\n    float t = 0.25*sin(iTime*0.25);\n    vec2 newX = vec2(cos(t), sin(t));\n    vec2 newY = vec2(-newX.y, newX.x);\n    pos = newX*pos.x + newY*pos.y;\n    //*/\n\n    float scaleX = 5.0;\n    vec2 from, to; float blend;\n    float noise = getH(\n        scaleX*pos.x, // In\n        from, to, blend // Out\n    );\n    \n    \n    \n    // Additional wiggle to the lines.\n    noise -= 0.05*sNoise;\n\n    float posY = 0.3;\n    float scaleY = 1.0 / scaleX; //0.05;\n\n    float scaledNoise = scaleY*noise;\n    float mountHeight = posY + scaledNoise;\n\n    float hatchLength = length(to - from);\n    float hatchWidth = lerp(0.5, 3.0, 1.0 - saturate(pcurve(blend, 2.0*hatchLength, 2.0))); //lerp(1.5, 5.0, 1.0 - saturate(pcurve(blend, 2.0*hatchLength, 2.0))) / iResolution.y;\n    //hatchWidth = lerp(0.0, 1.0, blend);\n    col = min(col, iResolution.y*(abs(nuv.y - mountHeight) - hatchWidth/iResolution.y));\n    \n    \n\n    // Hatching inside mountains.\n    float mountGrad = saturate(scaledNoise - nuv.y + posY) / scaledNoise;\n    if(\n        //false &&\n        (nuv.y < mountHeight - 0.0025) && (nuv.y > posY)\n    )\n    {\n        col = ((\n            + lerp(0.5, 3.0, mountGrad)*abs(cos((1.0-pow(0.025*sNoise + mountGrad, 0.5))*(lerp(1.0, noise, 0.8))*M_PI*25.0))\n            + saturate(3.0 + 10.0*cos(pos.x * 32.0 - cos(pow(mountGrad, 1.25)*13.0)))\n            - saturate(3.0 + 10.0*cos(2.0 + pos.x * 32.0 - cos(pow(mountGrad, 1.25)*13.0)))\n        ));\n    }\n\n    \n    // Horizon.\n    float belowHorizon = saturate(1.0 - (posY - nuv.y) / posY + 0.01*sNoise);\n    float aboveHorizonMask = saturate(iResolution.y*(belowHorizon - 1.0 + 1.0/iResolution.y));\n    col = min(col, max(aboveHorizonMask, saturate(max(\n        saturate(1.1 - belowHorizon*belowHorizon),\n        saturate(abs(cos(0.2*belowHorizon*belowHorizon*M_PI*450.0*posY)))\n        + saturate(0.5 + cos(pos.x * 27.0 + cos(belowHorizon*belowHorizon*belowHorizon*13.0)))\n        - saturate(-0.5 + cos(pos.x * 32.0 + cos(belowHorizon*belowHorizon*belowHorizon*13.0)))\n    ))));\n    \n    \n    // Clouds.\n    //if(false)\n    {\n        float clouds = saturate(\n            2.0*abs(optimizedSnoise(nuv * vec2(2.0, 4.0) + vec2(0.05*iTime, 0.0)) - 0.5)\n            + 1.0*optimizedSnoise(nuv * vec2(5.0, 16.0) + vec2(0.2*iTime, 0.0))\n        );\n        col = max(col, saturate((nuv.y + 0.25)*clouds*clouds - 1.0 + clouds));\n    }\n    \n    // Colorize.\n    fragColor.a = 1.0;\n    //fragColor.rgb = vec3(col);\n    /*\n    fragColor.rgb = lerp(\n        vec3(0.3, 0.0, 0.5),\n        vec3(0.7, 0.75, 0.79),\n        col\n    );\n    //*/\n    //*\n    fragColor.rgb = lerp(\n        vec3(0.0, 0.2, 0.45),\n        //vec3(0.7, 0.75, 0.79),\n        //vec3(0.9),\n        vec3(0.8, 0.85, 0.89),\n        1.0-col\n    );\n    //*/\n\n    // Grains.\n    fragColor.rgb += 1.5*0.75*((rand2(uv)-.5)*.07);\n    \n    // Vigente.\n    vec2 vigenteSize = 0.3*iResolution.xy;\n    float sdf = -sdRoundedBox(fragCoord.xy - iResolution.xy*0.5, vigenteSize, vec4(0.25*min(iResolution.x, iResolution.y))) / vigenteSize.x;\n    float percent = 0.8;\n    sdf = (saturate(percent + sdf) - percent) / (1.0 - percent);\n    sdf = lerp(1.0, sdf, 0.05);\n    fragColor.rgb *= sdf;\n}", "image_inputs": [], "common_code": "#define M_PI 3.14159265359\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define pack(x) (x*0.5+0.5)\n#define unpack(x) (x*2.0 - 1.0)\n#define lerp(a,b,x) mix(a,b,x)\n#define rgb(r, g, b) (vec3(r, g, b)*0.0039215686)\n\n// Directions\nconst ivec2 center = ivec2(0, 0);\nconst ivec2 up = ivec2(0, 1);\nconst ivec2 down = ivec2(0, -1);\nconst ivec2 right = ivec2(1, 0);\nconst ivec2 left = ivec2(-1, 0);\nconst ivec2 upRight = up + right;\nconst ivec2 upLeft = up + left;\nconst ivec2 downRight = down + right;\nconst ivec2 downLeft = down + left;\n\nconst vec2 centerf = vec2(0, 0);\nconst vec2 upf = vec2(0, 1);\nconst vec2 downf = vec2(0, -1);\nconst vec2 rightf = vec2(1, 0);\nconst vec2 leftf = vec2(-1, 0);\nconst vec2 upRightf = normalize(upf + rightf);\nconst vec2 upLeftf = normalize(upf + leftf);\nconst vec2 downRightf = normalize(downf + rightf);\nconst vec2 downLeftf = normalize(downf + leftf);\n\nfloat smootherstep(float a, float b, float x)\n{\n    x = saturate((x - a) / (b - a));\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat segment(float value, float segments)\n{\n    return float(int(value*segments))/segments;\n}\n\nvec3 sdgCircle( in vec2 p, in float r )\n{ float d = length(p); return vec3( d-r, p/d ); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a+b,a+b)/(pow(a,a)*pow(b,b));\n    return k*pow(x,a)*pow(1.0-x,b);\n}\n\nfloat rand2(vec2 p) {\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p)\n{\n    return fract(sin(vec2(\n        dot(p, vec2(127.1, 311.7)),\n        dot(p, vec2(269.5, 183.3))\n    ))*43758.5453);\n}\n\n\n//==== Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8 ====//\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\nvec4 glslmod(vec4 x, vec4 y) { return x - y * floor(x / y); }\nvec3 glslmod(vec3 x, vec3 y) { return x - y * floor(x / y); }\nvec2 glslmod(vec2 x, vec2 y) { return x - y * floor(x / y); }\nvec3 permute_optimizedSnoise2D(in vec3 x) { return glslmod(x*x*34.0 + x, vec3(289.0)); }\nfloat optimizedSnoise(in vec2 v) {\n    vec2 i = floor((v.x + v.y)*.36602540378443 + v);\n    vec2 x0 = (i.x + i.y)*.211324865405187 + v - i;\n    float s = step(x0.x, x0.y);\n    vec2 j = vec2(1.0 - s, s);\n    vec2 x1 = x0 - j + .211324865405187;\n    vec2 x3 = x0 - .577350269189626;\n    i = glslmod(i, vec2(289.));\n    vec3 p = permute_optimizedSnoise2D(permute_optimizedSnoise2D(i.y + vec3(0, j.y, 1)) + i.x + vec3(0, j.x, 1));\n    vec3 m = max(.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x3, x3)), 0.);\n    vec3 x = fract(p * .024390243902439) * 2. - 1.;\n    vec3 h = abs(x) - .5;\n    vec3 a0 = x - floor(x + .5);\n    return .5 + 65. * dot(pow(m, vec3(4.0))*(-0.85373472095314*(a0*a0 + h * h) + 1.79284291400159), a0 * vec3(x0.x, x1.x, x3.x) + h * vec3(x0.y, x1.y, x3.y));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlcczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 78, 78, 1124], [1128, 1128, 1185, 1296, 5133]], "test": "untested"}
{"id": "7l3yzX", "name": "Spitfire Pursuit II", "author": "dr2", "description": "An update of the original; mouseable (mouse in top/bottom for static views)", "tags": ["landscape", "aircraft", "flight"], "likes": 18, "viewed": 359, "published": 3, "date": "1660213730", "time_retrieved": "2024-07-30T16:36:00.525116", "image_code": "// \"Spitfire Pursuit II\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 21 in \"Aeroplane\" series\n    \"Spruce Goose\"                (fdy3DW) - others listed here\n    \"Snoopy and the Red Baron 2\"  (NdVSDV)\n    \"Mighty Mriya\"                (7llfz2)\n    \"Mriya Plans\"                 (ftjBzG)\n*/\n    \n#define AA   0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_FLYER  2\n\nmat3 flyerMat[N_FLYER];\nvec3 flyerPos[N_FLYER], qHit, qHitTr, sunDir, trkAx, trkFx, trkAy, trkFy;\nfloat dstFar, tCur, flyerSz;\nint idObj, idObjTr, idObjGrp, vuMode;\nconst int idFus = 1, idCkpt = 2, idWngM = 3, idWngT = 4, idTail = 5, idNos = 6,\n   idGun = 7, idEx = 8, idIn = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n#define DMINTRQ(id) if (d < dMin) { dMin = d;  idObjTr = id;  qHitTr = q; }\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, tapr;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  float dx, dz;\n  dx = abs (p.x - wg.trans);\n  dz = dx / wg.span;\n  p.yz = abs (p.yz);\n  p.y -= - (wg.sRad + wg.tapr * dz * dz * dz);\n  return max (length (p.yz) - wg.thck, dx - wg.span);\n}\n\nfloat FusRad (float z)\n{\n  return 1.68 - 0.0083 * z * z;\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, df, wSpan;\n  dMin /= flyerSz;\n  p /= flyerSz;\n  if (vuMode == 0) d = PrRoundBoxDf (p, vec3 (15., 4., 15.), 0.1);\n  if (vuMode > 0 || d < 0.1 / flyerSz) {\n    wSpan = 15.;\n    q = p;\n    df = PrCapsDf (q - vec3 (0., 0., -1.44), FusRad (q.z), 12.);\n    df = max (df, q.z - 10.92);\n    d = df;\n    DMINQ (idObjGrp + idFus);\n    d = PrCapsDf (q - vec3 (0., 0.78 + 0.13 * q.z, -1.2), 1.2, 3.6);\n    d = SmoothMin (d, df, 0.05);\n    DMINQ (idObjGrp + idCkpt);\n    q = p;\n    q.yz -= vec2 (-0.75, 1.8);\n    q.x = abs (q.x);\n    q.xy = Rot2Cs (q.xy, sin (-0.01 * pi + vec2 (0.5 * pi, 0.)));\n    d = WingDf (q, WingParm (wSpan, 13.7, 0., 14.05, 0.37));\n    d = SmoothMax (d, - abs (PrBox2Df (vec2 (abs (abs (q.x) - 7.5) - 2.5, q.z + 2.5),\n       vec2 (2., 0.7))), 0.07);\n    d = SmoothMin (d, df, 0.3);\n    DMINQ (idObjGrp + idWngM);\n    q = p;\n    q.yz -= vec2 (0.1, -11.4);\n    d = WingDf (q, WingParm (0.4 * wSpan, 6.8, 0., 7.05, 0.37));\n    d = SmoothMax (d, - abs (PrBox2Df (vec2 (abs (q.x) - 2.5, q.z + 1.6),\n       vec2 (1.4, 0.7))), 0.07);\n    d = SmoothMin (d, df, 0.2);\n    DMINQ (idObjGrp + idWngT);\n    q = p;\n    q.yz -= vec2 (-0.2, - 11.8);\n    d = max (WingDf (vec3 (q.x, Rot2Cs (q.yz, sin (0.05 * pi + vec2 (0.5 * pi, 0.)))).yxz,\n       WingParm (0.18 * wSpan, 7., 1.5, 7.2, 0.2)), - q.y);\n    d = SmoothMax (d, - abs (PrBox2Df (vec2 (q.y - 1.9, q.z + 1.7), vec2 (1.2, 0.6))), 0.07);\n    d = SmoothMin (d, df, 0.2);\n    DMINQ (idObjGrp + idTail);\n    q = p;\n    q.z -= 11.76;\n    d = PrConeDf (q, vec3 (0.8, 0.6, 0.9));\n    DMINQ (idObjGrp + idNos);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (5., -0.6, 4.7);\n    d = PrCylDf (q, 0.1, 0.6);\n    DMINQ (idObjGrp + idGun);\n    q = p;\n    q.x = abs (q.x);\n    q.z -= 8.;\n    q.xz = Rot2Cs (q.xz, sin (-0.045 * pi + vec2 (0.5 * pi, 0.)));\n    q.z = abs (abs (q.z - 0.3) - 0.6);\n    q.xz -= vec2 (1.07, 0.3);\n    d = PrCapsDf (q, 0.12, 0.1);\n    DMINQ (idObjGrp + idEx);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (2.3, -0.8, 3.);\n    d = max (PrRoundBoxDf (q, vec3 (0.5, 0.05, 0.8), 0.2), q.y - 0.05);\n    DMINQ (idObjGrp + idIn);\n  } else dMin = min (dMin, d);\n  return flyerSz * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    if (vuMode == 0 || vuMode == k + 1) {\n      idObjGrp = (k + 1) * 256;\n      dMin = FlyerDf (flyerMat[k] * (p - flyerPos[k]), dMin);\n    }\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / flyerSz;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    if (vuMode == 0 || vuMode == k + 1) {\n      idObjGrp = (k + 1) * 256;\n      q = (flyerMat[k] * (p - flyerPos[k])) / flyerSz;\n      q.z -= 11.05;\n      d = PrCylDf (q, 2.3, 0.05);\n      DMINTRQ (idObjGrp);\n    }\n  }\n  return flyerSz * dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, bCol4;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  bCol4 = (ig == 1) ? vec4 (0.9, 0.2, 0.9, 0.2) : vec4 (0.9, 0.9, 0.2, 0.2);\n  col4 = vec4 (0.9, 0.9, 1., 0.2);\n  if (id == idFus) {\n    col4 = mix (col4, bCol4, smoothstep (-0.75, -0.65, qHit.y));\n    col4 = mix (bCol4.gbra, col4, smoothstep (0., 0.02,\n       abs (length (qHit.yz - vec2 (0.2, -5.)) - 0.5) - 0.07));\n  } else if (id == idCkpt) {\n    col4 = (abs (qHit.x) > 0.07 && qHit.z > 0.5 && abs (abs (abs (qHit.z - 1.) - 1.) -\n       0.5) > 0.07) ? vec4 (0., 0., 0., -1.) : bCol4;\n  } else if (id == idWngM) {\n    col4 = mix (bCol4.gbra, col4, smoothstep (0., 0.05,\n       abs (length (qHit.xz - vec2 (8., 0.5)) - 1.) - 0.1));\n    if (qHit.y > 0.) col4 = mix (bCol4, col4, smoothstep (0., 0.05,\n       length (qHit.xy - vec2 (0., 0.84)) - FusRad (qHit.z + 1.8) - 0.2));\n  } else if (id == idWngT) {\n    col4 = mix (bCol4, col4, smoothstep (0., 0.05, length (qHit.xy - vec2 (0, -0.1)) -\n        FusRad (qHit.z - 11.4) - 0.1));\n  } else if (id == idTail) {\n    col4 = mix (bCol4.gbra, col4, smoothstep (0., 0.05,\n       abs (length (qHit.yz - vec2 (2.5, 0.)) - 0.5) - 0.07));\n    col4 = mix (bCol4, col4, smoothstep (0., 0.05, length (qHit.xy - vec2 (0., 0.2)) -\n       FusRad (qHit.z - 11.8) - 0.1));\n  } else if (id == idNos) {\n    col4.rgb *= 0.8;\n  } else if (id == idGun) {\n    col4.rgb *= 0.6;\n  } else if (id == idEx) {\n    col4.rgb *= 0.7;\n  } else if (id == idIn) {\n    col4.rgb *= 0.8 * (1. - 0.4 * step (0., qHit.z) *\n       (1. - smoothstep (0., 0.02, PrBox2Df (qHit.xy, vec2 (0.5, 0.2)))));\n  }\n  return col4;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), 0.5 + abs (dot (trkAy, sin (trkFy * t))), t);\n}\n\nvec3 TrackDir (float t)\n{\n  return vec3 (dot (trkFx * trkAx, cos (trkFx * t)), dot (trkFy * trkAy, cos (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkFx * trkFx * trkAx, - sin (trkFx * t)), 0., 0.);\n}\n\nfloat GrndDf (vec3 p, float d)\n{\n  vec3 pt;\n  vec2 q, r;\n  float wAmp, h, s, w, t;\n  wAmp = 1.;\n  q = 0.02 * p.xz;\n  t = 0.;\n  h = 0.; // (from \"Terrain Explorer 2\", simplified)\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    r = Noisev2v2 (3. * q);\n    t += r.y;\n    h += wAmp * r.x / (1. + t * t);\n    wAmp *= 0.5;      \n    q *= 2.;\n  }\n  h *= 16. * (1. + 0.4 * Noisefv2 (0.01 * p.xz));\n  h *= 1. - 0.5 * smoothstep (0.9, 1., d / dstFar);\n  pt = TrackPath (p.z);\n  w = abs (p.x - pt.x);\n  s = smoothstep (10., 35., w);\n  h = mix (pt.y + 0.2 * h * (0.5 + 2.5 * s + 0.004 * w * w) + 0.1 * Noisefv2 (p.xz) - 2.5, h, s);\n  return p.y - h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    h = GrndDf (ro + s * rd, s);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.1, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (GrndDf (ro + s * rd, s) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (1., -1.) * max (0.01, 0.00001 * d * d);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)), d);\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = GrndDf (ro + d * rd, d);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += max (0.01 * d, 2. * h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 GrndCol (vec3 p, vec3 vn)\n{\n  vec4 col, gCol, rCol, snCol, saCol;\n  float f;\n  f = length (p.xz);\n  gCol = mix (vec4 (0.2, 0.45, 0.3, 0.1), vec4 (0.15, 0.35, 0.25, 0.1),\n     smoothstep (0.35, 0.65, Fbm2 (0.5 * p.xz)));\n  rCol = mix (vec4 (0.4, 0.4, 0.45, 0.), vec4 (0.37, 0.37, 0.4, 0.),\n     smoothstep (0.4, 0.6, Fbm2 (vec2 (f, 3. * p.y)))) * (0.9 +\n     0.1 * Noisefv2 (vec2 (4. * f, 8. * p.y)));\n  col = mix (rCol, gCol, smoothstep (0.45, 0.8, vn.y) * (1. - smoothstep (10., 20., p.y)));\n  snCol = vec4 (0.97, 0.97, 1., 0.3) * (0.9 + 0.1 * Noisefv2 (4. * p.xz));\n  if (vn.y > 0.25) col = mix (col, snCol, smoothstep (20., 25., p.y - 0.5 * Noisefv2 (2. * p.xz)));\n  saCol = vec4 (0.6, 0.53, 0.43, 0.1) * (0.8 + 0.2 * Noisefv2 (4. * p.xz));\n  col = mix (col, saCol, (1. - smoothstep (0.02, 0.1, p.y)) * smoothstep (0.85, 0.95, vn.y));\n  return col;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.1, 0.2, 0.55) + 0.25 * pow (1. - abs (rd.y), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  f = Fbm2 (0.01 * (ro + rd * (200. - ro.y) / rd.y).xz);\n  return mix (SkyBg (rd) + 0.35 * pow (max (dot (rd, sunDir), 0.), 16.),\n     vec3 (0.9), clamp (1.6 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 objCol, col, vn, roo, rdo, rp;\n  float dstObj, dstWat, dstGrnd, sh, refFac, dstFade;\n  bool isLit;\n  roo = ro;\n  rdo = rd;\n  refFac = 1.;\n  sh = 1.;\n  isLit = false;\n  dstWat = dstFar;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (vuMode == 0) {\n    dstGrnd = GrndRay (ro, rd);\n    dstFade = dstGrnd;\n    if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n      dstWat = - ro.y / rd.y;\n      dstFade = dstWat;\n      ro += dstWat * rd;\n      rd = reflect (rd, VaryNf (2. * ro, vec3 (0., 1., 0.),\n         0.1 * (1. - smoothstep (0.1, 0.4, dstWat / dstFar))));\n      ro += 0.01 * rd;\n      dstGrnd = GrndRay (ro, rd);\n      dstFade += dstGrnd;\n      dstObj = ObjRay (ro, rd);\n      refFac *= 0.8;\n    }\n    if (dstObj < min (dstGrnd, dstFar)) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = FlyerCol ();\n      if (col4.a >= 0.) {\n        sh = ObjSShadow (ro, sunDir);\n        isLit = true;\n      } else col = 0.2 + 0.7 * SkyCol (ro, reflect (rd, vn));\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro, dstGrnd);\n      vn = VaryNf (0.15 * ro, vn, 1.5 - 1.2 * smoothstep (10., 15., ro.y));\n      col4 = GrndCol (ro, vn);\n      sh = GrndSShadow (ro + 0.01 * vn, sunDir);\n      isLit = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n    }\n  } else {\n    col = vec3 (0.2, 0.2, 0.3);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = FlyerCol ();\n      if (col4.a >= 0.) {\n        sh = ObjSShadow (ro, sunDir);\n        isLit = true;\n      } else col = 0.2 + 0.7 * SkyCol (ro, reflect (rd, vn));\n    }\n  }\n  if (isLit) col = refFac * (col4.rgb * (0.1 + 0.1 * max (vn.y, 0.) + \n     0.2 * max (- dot (vn, normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n     sh * max (dot (vn, sunDir), 0.)) +\n     col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.));\n  if (vuMode == 0 && refFac == 1. && dstGrnd < min (dstObj, dstFar))\n     col = mix (refFac * 1.05 * SkyBg (rd), col, exp2 (min (0., 4. - 9. * dstFade / dstFar)));\n  if (TrObjRay (roo, rdo) <  min (min (min (dstObj, dstGrnd), dstWat), dstFar))\n     col = mix (0.85 * col, ((idObjTr / 256 == 1) ?\n     vec3 (0.9, 0.3, 0.9) : vec3 (0.9, 0.9, 0.3)),\n     0.3 * SmoothBump (0., 0.2, 0.02, length (qHitTr.xy) - 1.9));\n  return clamp (col, 0., 1.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 e;\n  e = vec2 (1., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 4.) *\n     (4. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\nvoid FlyerPM (float t, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, va, ori, ca, sa;\n  float tgr, td, el, az, rl;\n  if (vuMode == 0) {\n    flPos = TrackPath (t);\n    vel = TrackDir (t);\n    el = - ((vu == 0.) ? 1. : 0.3) * asin (vel.y / length (vel));\n    az = atan (vel.z, vel.x) - 0.5 * pi;\n    va = cross (TrackAcc (t), vel) / length (vel);\n    rl = ((vu == 0.) ? 20. : 6.) * length (va) * sign (va.y);\n    if (vu > 0.) {\n      el *= -1.;\n      rl *= -1.;\n      az += pi;\n    }\n    ori = vec3 (el, az, rl);\n    ca = cos (ori);\n    sa = sin (ori);\n    flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n            mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n    tgr = 100.;\n    td = floor (t / tgr) * tgr;\n    flPos.y = 5.5 - mix (GrndDf (vec3 (TrackPath (td).xz, 0.).xzy, 0.),\n       GrndDf (vec3 (TrackPath (td + tgr).xz, 0.).xzy, 0.), (t - td) / tgr);\n  } else {\n    flPos = vec3 (0.);\n    flMat = mat3 (1., 0., 0., 0., 1., 0., 0., 0., 1.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, flMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr, asp, spd, tGap, ts;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  vuMode = 0;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    if (abs (mPtr.y) < 0.45) {\n      el = clamp (0.6 * pi * mPtr.y, - 0.25 * pi, 0.25 * pi);\n    } else {\n      vuMode = (mPtr.y < 0.) ? 1 : 2;\n      az += 0.6 * pi;\n      el = -0.1 * pi * sign (mPtr.y);\n    }\n  }\n  tCur = mod (tCur, 1200.) + 30. * floor (dateCur.w / 3600.);\n  if (vuMode == 0) {\n    trkAx = 8. * vec3 (1.9, 2.9, 4.3);\n    trkFx = 0.15 * vec3 (0.23, 0.17, 0.13);\n    trkAy = 0.7 * vec3 (1.7, 3.7, 0.);\n    trkFy = 0.3 * vec3 (0.21, 0.15, 0.);\n    spd = 15.;\n    tGap = 15. * (1. + 0.3 * sin (0.01 * pi * tCur));\n    ts = 1. - 2. * SmoothBump (0.25, 0.75, 0.1, mod (tCur / 60., 1.));\n    for (int k = 0; k < N_FLYER; k ++) FlyerPM (spd * tCur + (float (k) -\n       0.5 * float (N_FLYER - 1)) * tGap, 0., flyerPos[k], flyerMat[k]);\n    FlyerPM (spd * tCur + ts * tGap * float (N_FLYER - 1), sign (ts), ro, flMat);\n    vuMat = StdVuMat (- el * sign (ts), az);\n    zmFac = 2.5;\n    ro.y += 1.3;\n    ro.x += 1.5 * sin (0.05 * pi * tCur);\n    sunDir = normalize (vec3 (-0.9, 1.5, -1.));\n    flyerSz = 0.08;\n  } else {\n    for (int k = 0; k < N_FLYER; k ++) FlyerPM (0., 0., flyerPos[k], flyerMat[k]);\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * vec3 (0., 0., -20.);\n    zmFac = 3.5;\n    sunDir = vuMat * normalize (vec3 (0.5, 0.1, -1.));\n    flyerSz = 0.5;\n  }\n  dstFar = 300.;\n  if (vuMode > 0 || abs (uv.y) < 0.9) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      uvv /= zmFac;\n      if (vuMode == 0) rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp,\n         uvv.y, 1.)) * flMat;\n      else rd = normalize (vec3 (uvv, 1.));\n      rd = vuMat * rd;\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n    if (vuMode == 0) col += GlareCol (rd, flMat * (sunDir * vuMat), uv);\n    else if (abs (abs (uv.y) - 0.895) < 0.005) col = vec3 (0.4, 0.4, 0.6);\n  } else {\n    col = vec3 (0.2, 0.2, 0.3);\n    if (mPtr.z > 0.) col += vec3 (0.2, 0.2, 0.) * step (PrBox2Df (vec2 (uv.x, abs (uv.y) - 0.95),\n       vec2 (0.07, 0.01)), 0.);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v2 (vec2 p)\n{\n  return vec2 (Noisefv2 (p), Noisefv2 (p + vec2 (17., 23.)));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3yzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1555, 1555, 1591, 1591, 1781], [1783, 1783, 1807, 1807, 1841], [1843, 1843, 1879, 1879, 4048], [4050, 4050, 4072, 4072, 4318], [4320, 4320, 4353, 4353, 4536], [4538, 4538, 4559, 4559, 4809], [4811, 4811, 4848, 4848, 5077], [5079, 5079, 5103, 5103, 5449], [5451, 5451, 5486, 5486, 5670], [5672, 5672, 5690, 5690, 7299], [7301, 7301, 7327, 7327, 7420], [7422, 7422, 7447, 7447, 7545], [7547, 7547, 7572, 7572, 7646], [7648, 7648, 7680, 7680, 8283], [8285, 8285, 8319, 8319, 8798], [8800, 8800, 8831, 8831, 9114], [9116, 9116, 9154, 9154, 9407], [9409, 9409, 9441, 9441, 10267], [10269, 10269, 10291, 10291, 10360], [10362, 10362, 10394, 10394, 10593], [10595, 10595, 10630, 10630, 12951], [12953, 12953, 12996, 12996, 13430], [13432, 13432, 13498, 13498, 14481], [17261, 17261, 17307, 17307, 17354], [17356, 17356, 17389, 17389, 17478], [17480, 17480, 17522, 17522, 17573], [17575, 17575, 17618, 17618, 17682], [17684, 17684, 17717, 17717, 17790], [17792, 17792, 17837, 17837, 17929], [17931, 17931, 17976, 17976, 18014], [18016, 18016, 18073, 18073, 18156], [18158, 18158, 18188, 18188, 18301], [18303, 18303, 18334, 18334, 18398], [18400, 18400, 18436, 18436, 18642], [18676, 18676, 18700, 18700, 18812], [18814, 18814, 18839, 18839, 19025], [19027, 19027, 19052, 19052, 19116], [19118, 19118, 19139, 19139, 19294], [19296, 19296, 19325, 19325, 19537], [19539, 19539, 19578, 19578, 19830]], "test": "untested"}
{"id": "st3cRX", "name": "Circle Man", "author": "MysteryPancake", "description": "Crazy technology turns man into a circle", "tags": ["chroma", "texture", "circle", "key", "sample"], "likes": 8, "viewed": 291, "published": 3, "date": "1660209761", "time_retrieved": "2024-07-30T16:36:01.283089", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const vec3 target = vec3(0.0, 1.0, 0.0); // Find green\n    const float TAU = 6.28318530;\n    const float steps = 64.0;\n    \n    float radius = iMouse.z > 0.0 ? length(0.5 - iMouse.xy / iResolution.xy) * 200.0 : sin(iTime * 4.0) * 20.0 + 20.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n    fragColor = texture(iChannel0, uv);\n    for (float i = 0.0; i < TAU; i += TAU / steps) {\n        // Sample image in a circular pattern\n        vec2 offset = vec2(sin(i), cos(i)) * aspect * radius;\n        vec4 col = texture(iChannel0, uv + offset);\n        \n        // Mix circles with background\n        float alpha = smoothstep(0.5, 0.7, distance(col.rgb, target));\n        fragColor = max(fragColor, col * alpha);\n    }\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3cRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 869]], "test": "untested"}
{"id": "ft3czf", "name": "Glass Mosaic (Pixelate)", "author": "MysteryPancake", "description": "Cool glass effect based on an earlier mosaic shader I made", "tags": ["pixel", "glass", "pixelate", "mosaic", "pixelize"], "likes": 5, "viewed": 318, "published": 3, "date": "1660204130", "time_retrieved": "2024-07-30T16:36:02.083948", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float pixels = mod(iTime * 10.0, 50.0);\n    fragColor = textureLod(iChannel0, (uv + floor(uv * pixels) / pixels) * 0.5, 0.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3czf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 229]], "test": "untested"}
{"id": "Nlcyzf", "name": "Soft Balls", "author": "IWBTShyGuy", "description": "I haven't been able to make much lately...", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 218, "published": 3, "date": "1660203773", "time_retrieved": "2024-07-30T16:36:02.926695", "image_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 randomUnit(in float gen) {\n    vec2 u = hash21(gen);\n    float t = 2.0 * PI * u.x;\n    float z = 2.0 * u.y - 1.0;\n    float r = sqrt(1.0 - z * z);\n    return vec3(r * cos(t), r * sin(t), z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sDist(in vec3 p) {\n    float dist = length(p) - 1.5;\n    for (int i = 0; i < 20; i++) {\n        vec3 c = 5.0 * (sin((float(i) * 0.5 + iTime * 1.2) / 5.0 * PI) + 1.0) * randomUnit(float(i));\n        dist = opSmoothUnion(dist, length(p - c) - 0.5, 0.5);\n    }\n    return dist;\n}\n\nvec3 calcNormal(in vec3 p) {\n    const vec2 h = vec2(0, 1.0e-5);\n    return normalize(vec3(\n        sDist(p + h.yxx) - sDist(p - h.yxx),\n        sDist(p + h.xyx) - sDist(p - h.xyx),\n        sDist(p + h.xxy) - sDist(p - h.xxy)\n    ));\n}\n\nvoid mainImage0(out vec4 O, in vec2 U) {\n    vec2 r = iResolution.xy,\n    pos = vec2(cos(iTime * 0.12), sin(iTime * 0.12));\n    U /= r;\n    Camera cam = Camera(\n        vec3(pos.y, 0, pos.x) * 20.0,\n        vec3(-pos.y, 0, -pos.x),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        r.x / r.y\n    );\n    Ray ray = cameraRay(cam, U);\n    \n    float dist = 0.0; int i;\n    for (i = 0; i < 256; i++) {\n        vec3 p = ray.origin + dist * ray.direction;\n        float dist0 = sDist(p);\n        if (dist0 < 1.0e-3 || dist > 40.0) break;\n        dist += dist0;\n    }\n\n    float k = clamp((0.5 + U.y - U.x) / 4.0, 0.0, 1.0);\n    O = vec4(0, k, 0.25 - k, 1);\n    if (i < 256 && dist < 40.0) {\n        vec3 p = ray.origin + dist * ray.direction;\n        vec3 normal = calcNormal(p);\n        float c = -dot(normal, normalize(vec3(-1)));\n        O = vec4(c * 0.1, 0, (1.0 - c) * 0.1, 1);\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n    if (fwidth(length(O.xyz)) > 0.1) {\n        vec4 o;\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n    }\n    \n    O = pow(O, vec4(.4545));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlcyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 379, 424, 424, 831], [833, 874, 896, 896, 1024], [1026, 1026, 1057, 1057, 1223], [1225, 1225, 1277, 1277, 1376], [1662, 1662, 1690, 1690, 1897], [1899, 1899, 1939, 1939, 2782], [2784, 2784, 2820, 2820, 3204]], "test": "untested"}
{"id": "7tdyW7", "name": "these cubes move a lot", "author": "abje", "description": "made something similar in unity and someone told me to check out shadertoy, so i did ;)", "tags": ["voxels", "cubes", "planes"], "likes": 11, "viewed": 311, "published": 3, "date": "1660192343", "time_retrieved": "2024-07-30T16:36:03.678685", "image_code": "#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define cubes 100\n\nvec3 get_ro(void)\n{\n    return vec3(0.5+sin(iTime*0.02)*30.0,sin(iTime*0.24)*10.0-4.0,iTime);\n}\n\nfloat get_height(vec2 p)\n{\n    float s = sin(p.x)*2.0;\n    float c = cos(p.y+iTime)*sin(iTime)*3.5;\n    \n    float h = s+c;\n    \n    vec3 ro = get_ro();\n    \n    vec2 p2 = p-ro.xz;\n    \n    float l = clamp(length(p2)*0.2-0.2, 0.0, 1.0);\n    \n    return mix(min(h,ro.y-2.0), h, l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec4 muv = (iMouse.xyzw*2.0-iResolution.xyxy)/iResolution.y;\n    \n    vec3 ro = get_ro();\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    rd.zy *= rot(-muv.y);\n    rd.xz *= rot(muv.x);\n    \n    vec3 ird = 1.0/rd;\n    vec3 srd = sign(ird);\n    vec2 fro = floor(ro.xz);\n    vec2 lro = ro.xz-fro;\n    \n    vec2 dists = (step(0.0,ird.xz)-lro)*ird.xz;\n    \n    float oldl = 0.0;\n    \n    float height = 0.0;\n    \n    vec3 normal = vec3(0);\n    \n    int i = 0;\n    for (int j = 0; j < cubes; j++)\n    {\n        j++;\n        vec2 mask = vec2(1, 0);\n        if (dists.y < dists.x)\n            mask = vec2(0, 1);\n        \n        float l = dot(dists, mask);\n        \n        vec3 p = ro+rd*oldl;\n        \n        height = get_height(fro);\n    \n        float hit1 = ird.y*(height-ro.y-0.5*srd.y);\n        \n        if ((hit1 > oldl && hit1 < l) || abs(p.y-height) < 0.5) break;\n        \n        fro += mask*srd.xz;\n        dists += mask*ird.xz*srd.xz;\n        \n        oldl = l;\n        normal.xz = mask;\n    }\n    \n    float hit1 = ird.y*(height-ro.y-0.5*srd.y);\n    \n    if (hit1 < oldl)\n    {\n        normal *= -srd;\n    }\n    else\n    {\n        normal = vec3(0,-srd.y,0);\n    }\n    \n    float d = max(hit1,oldl);\n    \n    vec3 p = ro+rd*d;\n    \n    // Time varying pixel color\n    \n    float sun1 = dot(normal, normalize(vec3(1.0, 0.5, 0.8)));\n    float sun2 = dot(normal, normalize(vec3(-1.4, -0.7, -0.8)));\n    \n    vec3 suncol1 = sun1*vec3(0.8,1.0,0.7);\n    vec3 suncol2 = sun2*vec3(0.5,0.3,0.2);\n    \n    vec3 col = max(suncol1, suncol2);\n    \n    vec3 heightcol = vec3(max(0.0, -height), max(0.0, height), 1.0);\n    \n    col *= heightcol;\n\n    // Output to screen\n    if (i < cubes)\n        fragColor = vec4(col,1.0);\n    else\n    {\n        fragColor = vec4(normalize(rd)*0.5+0.5,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 92, 92, 168], [170, 170, 196, 196, 452], [454, 454, 511, 561, 2421]], "test": "untested"}
{"id": "flccRX", "name": "Moving Wave", "author": "DaShe", "description": "跟随鼠标的圆环，第一次玩ShaderToy好有意思哈哈哈", "tags": ["2d"], "likes": 1, "viewed": 193, "published": 3, "date": "1660188615", "time_retrieved": "2024-07-30T16:36:04.469569", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 mouse = fragCoord/(iMouse.xy);\n    vec2 uv = fragCoord/iResolution.xx;\n    float x = iMouse.x / iResolution.x;\n    float y = iMouse.y / iResolution.x;\n    float ruv = length(uv - vec2(x,y));\n    vec3 wave = vec3(step(fract(ruv*10.0 + iTime),0.9),1.0,1.0);\n    fragColor = vec4(wave,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flccRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 406]], "test": "untested"}
{"id": "Nt3yRX", "name": "Bilinear Mosaic Blur (Pixelate)", "author": "MysteryPancake", "description": "Cheap blur using bilinear interpolation, similar to using a lower LOD level", "tags": ["blur", "pixel", "linear", "pixelate", "mosaic", "bilinear", "pixelize", "pixelization", "pixelise", "pixelisation"], "likes": 2, "viewed": 351, "published": 3, "date": "1660184359", "time_retrieved": "2024-07-30T16:36:05.217569", "image_code": "#define USE_SMOOTHSTEP\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    float pixels = mod(iTime * 10.0, 50.0);\n    \n    vec2 rounded = floor(uv * pixels);\n    vec4 topLeft = textureLod(iChannel0, rounded / pixels, 0.0);\n    vec4 topRight = textureLod(iChannel0, (rounded + vec2(1.0, 0.0)) / pixels, 0.0);\n    vec4 bottomLeft = textureLod(iChannel0, (rounded + vec2(0.0, 1.0)) / pixels, 0.0);\n    vec4 bottomRight = textureLod(iChannel0, (rounded + vec2(1.0, 1.0)) / pixels, 0.0);\n    \n    vec2 fraction = fract(uv * pixels);\n    #ifdef USE_SMOOTHSTEP\n    fraction = smoothstep(0.0, 1.0, fraction);\n    #endif\n    \n    vec4 top = mix(topLeft, topRight, fraction.x);\n    vec4 bottom = mix(bottomLeft, bottomRight, fraction.x);\n    fragColor = mix(top, bottom, fraction.y);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3yRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 79, 79, 828]], "test": "untested"}
{"id": "stdcz2", "name": "Simple Mosaic (Pixelate)", "author": "MysteryPancake", "description": "Simplest way to pixelate an image", "tags": ["pixel", "pixelate", "mosaic", "pixelize", "pixelization", "pixelise", "pixelisation"], "likes": 4, "viewed": 316, "published": 3, "date": "1660183059", "time_retrieved": "2024-07-30T16:36:05.958589", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float pixels = mod(iTime * 10., 50.);\n    vec2 uv = floor(fragCoord / iResolution.xy * pixels) / pixels;\n    fragColor = textureLod(iChannel0, uv, 0.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 213]], "test": "untested"}
{"id": "NsXfzS", "name": "Oscillator Module", "author": "ttg", "description": "A study of waveforms from an imaginary synthesizer's oscillator circuit.\n\nVersion with sound: [url]https://www.shadertoy.com/view/stdcR2[/url]", "tags": ["plot", "util", "macro"], "likes": 12, "viewed": 372, "published": 3, "date": "1660176743", "time_retrieved": "2024-07-30T16:36:06.707586", "image_code": "// copied from shadertoy.com/view/3t3XWf by ttg\n// see it for examples of PLOT_ macro modes and styles.\n\nconst float pi = 3.1415927;\nvec2 csin (float a) { return vec2(cos(a),sin(a)); }\nvec2 cexp (vec2 a) { return exp(a.x)*csin(a.y); }\nvec2 conj (vec2 a) { return vec2(a.x,-a.y); }\nvec2 cmul (vec2 a, vec2 b) { return a.x*b+a.y*conj(b).yx; }\nvec2 cinv (vec2 a) { return conj(a)/dot(a,a); }\n\nfloat wave (float x, float p, float w, int N, int Hsel, out vec2 ret_m) {\n  vec2 os=csin(2.*pi*(fract(x)));\n  vec2 o=os;\n  w=clamp(w,1e-4,1.-1e-4);\n  float v=0.;\n  float le1=log(w*(1.-w)*.5*pi*pi), lem=log(.5-.5*cos(2.*pi*w));\n  vec2 m0=csin(pi/2.*-p)/(pi*pi)*4./exp(.5*(lem+exp(1.5*(1.-p))*(le1-lem)));\n  float nb=0.;\n  vec2 m1s=csin(-pi*2.*w);\n  vec2 m1=m1s;\n  ret_m=vec2(0.);\n  for (int n=1;n<N;n++) {\n    float nf=float(n);\n    vec2 m=vec2(1,0)-m1;\n    m=cmul(m,m0);\n    m*=1./pow(nf,p);\n    if (n==Hsel) ret_m=m;\n    v+=cmul(o,m).x;\n    o=cmul(o,os);\n    m1=cmul(m1,m1s);\n  }\n  return v;\n}\n\nfloat wave (float x, float p, float w, int N) {\n  vec2 m;\n  return wave(x,p,w,N,0,m);\n}\n\nvec2 waveft (int Hsel, float p, float w, int N) {\n  vec2 m;\n  wave(0.,p,w,N,Hsel,m);\n  return m;\n}\n\nfloat square (vec2 x) {return dot(x,x);}\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    float xmin,xmax,ymin,ymax;\n    mat2 domain;\n    mat2 window = mat2(0,0,1,1);\n\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    mouse.x*=2.;\n    if (square(iMouse.xy)<100.) {\n      //demo\n      mouse=.5+.49*sin(.2*iTime*vec2(2.,1.618));\n    }\n    float p=mouse.y*4.;\n    float w=mouse.x;\n    int N=140;\n    \n    xmin = -1.;\n    xmax =  1.;\n    ymin = -4.;\n    ymax =  4.;\n    domain = mat2(xmin,ymin,xmax,ymax);\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(0,1,.3), 0, 1, 0.014, wave(x,p,w,N) );\n    \n    xmin =  0.;\n    xmax = 32.;\n    ymin =  0.;\n    ymax =  1.;\n    domain = mat2(xmin,ymin,xmax,ymax);\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(1,.6,0), 0, 1, 0.01, square(waveft(int(floor(x)),p,w,N)) );\n\n\n    col+= .4*(\n       lines(uv.y*4.,.0005)\n      +lines(uv.y*16.,.0001)\n      +lines(uv.x*4.,.0005)\n      +lines(uv.x*16.,.0001)\n      );\n\n    fragData = vec4(pow(col,vec3(1./2.2)),0);\n}\n", "image_inputs": [], "common_code": "\n/* \n\nExpression Plotter\n\nUsage: PLOT_CONTINUOUS( fragColor, uv, window, domain,\n                        linecolor, side, blend, linewidth, expression );\n\n  fragColor - output (linear RGB)\n  uv - coordinate system for window\n  window - mat2, first col: window corner, second col: window size\n  domain - mat2, first col: min x,y, second col: max x,y\n  linecolor - RGB\n  side - 0 = line, 1 = below, -1 = above (see demo)\n  blend - 0=paint, 1=light-trace, 2=ink (see demo)\n  linewidth - measured in units of uv.x; only for side=0\n  expression - uses x as the independent variable\n\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/3t3XWf\", is displayed within the source.\n\n*/\n\n\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\n\n\n/*\nCopyright 2020 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n\n// End of Expression Plotter https://www.shadertoy.com/view/3t3XWf by ttg\n\n\n\n// Filtered line functions\n// Copyright 2021 Theron Tarigo, all rights reserved.\n\nfloat lines (float x, float dx, float w) {\n  if (dx>.2)dx+=(dx-.2)*1.;\n  dx*=1.2;\n  //dx=clamp(dx,0.,.5);\n  x = .5-abs(fract(x)-.5);\n  if (dx>1.) return w;\n  float edx = min(dx,.5);\n  float v;\n  if (w<edx) {\n    float ew=edx;\n    v = (clamp(.5-(x-ew/2.)/edx,0.,1.))*w/ew;\n  }\n  else if (1.-w<edx) {\n    float ew=edx;\n    v = 1.-(clamp(.5-(.5-x-ew/2.)/edx,0.,1.))*(1.-w)/ew;\n  }\n  else v = (clamp(.5-(x-w/2.)/edx,0.,1.));\n  if (dx>.5) {\n    return mix(v,w,clamp((dx-.5)*2.,0.,1.));\n  }\n  return v;\n}\n\nfloat lines (float x, float w) {\n  return lines(x, fwidth(x), w);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 154, 154, 184], [185, 185, 205, 205, 234], [235, 235, 255, 255, 280], [281, 281, 309, 309, 340], [341, 341, 361, 361, 388], [390, 390, 463, 463, 984], [986, 986, 1033, 1033, 1073], [1075, 1075, 1124, 1124, 1173], [1175, 1175, 1198, 1198, 1215], [1217, 1217, 1273, 1273, 2244]], "test": "untested"}
{"id": "Ntcczj", "name": "totally unique mandelbrot set B)", "author": "fishy", "description": "it's a mandlebrot set, you've definitely never seen it before. my first shader! mouse to move the set.", "tags": ["mandlebrot"], "likes": 0, "viewed": 120, "published": 3, "date": "1660172105", "time_retrieved": "2024-07-30T16:36:07.473538", "image_code": "bool iterate(vec2 c, int maxIterations)\n{\n    int i = 0;\n    vec2 z = vec2(0.0);\n    \n    while(length(z) < 2.0 && i < maxIterations)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        i++;\n    }\n    \n    return i < maxIterations;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= vec2(2.0, 1.12) * vec2(2.0);\n    uv -= (vec2(iMouse)/iResolution.xy - vec2(0.5)) * 2.0;\n\n\n    //bool set = iterate(uv, 10);\n    \n    vec3 col = vec3(0.0);\n    if(iterate(uv, 100))\n    {\n        col = vec3(1.0);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntcczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 249], [251, 251, 308, 308, 651]], "test": "untested"}
{"id": "fttyz2", "name": "Edge Rim Light (Inner Shadow)", "author": "MysteryPancake", "description": "Recreation of the \"Inner Shadow\" layer style in After Effects", "tags": ["chroma", "shadow", "light", "glow", "edge", "key", "rim", "inner", "rimlight"], "likes": 18, "viewed": 991, "published": 3, "date": "1660153543", "time_retrieved": "2024-07-30T16:36:08.217549", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\t\n    vec2 orbit = vec2(sin(iTime), cos(iTime));\n\tfloat circle = 1.0 - distance(uv - 0.5, orbit * 0.5);\n\tfloat lightStrength = 0.75 + sin(iTime * 5.0) * 0.25;\n\tvec2 offset = orbit * lightStrength * 0.01;\n\n\tvec3 target = vec3(0.0, 1.0, 0.0); // Find green\n\tvec3 light = vec3(1.0, 0.5, 0.0); // Orange light color\n\tvec3 background = vec3(0.0, 0.0, 0.1) + circle * lightStrength * light;\n\n\tfloat threshold = 0.7; // Controls target color range\n\tfloat softness = 0.1; // Controls linear falloff\n\t\n\t// Background color key\n\tvec4 col = texture(iChannel0, uv);\n\tfloat diff = distance(col.xyz, target.xyz) - threshold;\n\tfloat factor = clamp(diff / softness, 0.0, 1.0);\n\n\t// Same color key with an offset for the edge\n\tvec4 colOffset = texture(iChannel0, uv + offset);\n\tfloat diffOffset = distance(colOffset.xyz, target) - threshold;\n\tfloat lightFactor = 1.0 - clamp(diffOffset / softness, 0.0, 1.0);\n\t\n\t// Color correction for fun\n\tcol.xyz *= vec3(1.0, 0.7, 0.9);\n\n\tfragColor = vec4(mix(background, col.xyz + light * lightFactor, factor), col.a);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1136]], "test": "untested"}
{"id": "NttyR2", "name": "Barycentric Smoothstep", "author": "Bloodwyn", "description": "Smoothstep your barycentric coordinates!", "tags": ["barycentriccoordinatestriangle"], "likes": 0, "viewed": 317, "published": 3, "date": "1660145597", "time_retrieved": "2024-07-30T16:36:08.966546", "image_code": "#define PI 3.14159265359\n\n// Rotate point.\nvec2 rotate (vec2 p, float r)\n{\n    r *= PI / 180.0;\n    float x = p.x * cos(r) - p.y * sin(r);\n    float y = p.y * cos(r) + p.x * sin(r);\n    return vec2(x, y);\n}\n\n// Draw point\nbool point (vec2 a, vec2 p)\n{\n    return length(a - p) < 0.01;\n}\n\n// Draw line from a to b.\nbool line (vec2 a, vec2 b, vec2 p)\n{\n    vec2 c = b - a;\n    c = normalize(vec2(c.y, -c.x));\n    return abs(dot(c, a - p)) < 0.002;\n}\n\n// Find intersection between vectors a and b by projecting a onto b.\nvec2 projection (vec2 a, vec2 b)\n{\n    b = normalize(b);\n    return b * (b.x * a.x + b.y * a.y);\n}\n\nbool tri (vec2 a, vec2 b, vec2 c, vec2 p, out vec3 color)\n{\n    vec2 ab = b - a;\n    vec2 cb = b - c;\n    vec2 ca = a - c;\n    vec2 ac = c - a;\n    vec2 ba = a - b;\n    vec2 bc = c - b;\n    \n    // Projection of a onto c -> b\n    vec2 ai = c + projection(ca, cb);\n    \n    // Projection of test point onto ai -> a\n    vec2 pai = a + projection(p - ai, a - ai);\n    \n    float percentA = length(pai - a) / length(ai - a) * sign(dot(p - ai, a - ai));\n    \n    // Projection of b onto c -> b\n    vec2 bi = a + projection(ab, ac);\n    \n    // Projection of test point onto bi -> b\n    vec2 pbi = b + projection(p - bi, b - bi);\n    \n    float percentB = length(pbi - b) / length(bi - b) * sign(dot(p - bi, b - bi));\n    \n    // Projection of b onto c -> b\n    vec2 ci = b + projection(bc, ba);\n    \n    // Projection of test point onto ci -> c\n    vec2 pci = c + projection(p - ci, c - ci);\n    \n    float percentC = length(pci - c) / length(ci - c) * sign(dot(p - ci, c - ci));\n    \n    color = vec3(percentA, percentB, percentC);\n    \n    if (percentA > 0.0 && percentA < 1.0 && percentB > 0.0 && percentB < 1.0 && percentC > 0.0 && percentC < 1.0)\n        return true;\n    \n    return false;\n}\n\nint pascalTriangle(int a, int b) {\n    int num = 1;\n    int den = 1;\n    for (int i = 0; i < b; ++i){\n        num *= (a - i);\n        den *= (i + 1);\n     }\n    return num/den;\n}\n\nfloat gsmoothstep(float x, int N) {\n    x = clamp(x, 0., 1.);\n    float result = 0.;\n    for (int n = 0; n <= N; ++n){\n        result += float(pascalTriangle(-N - 1, n) *\n        pascalTriangle(2 * N + 1, N - n)) *\n        pow(x, float(N + n + 1));\n    }\n    return result;\n}\n\nvec3 barySmoothstep(vec3 bary, int order){\n    float sum = 0.;\n    for (int i = 0; i < 3; i++) {\n        bary[i] = gsmoothstep(bary[i], order);\n        sum += bary[i];\n    }    \n    return bary / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ws = uv.xy * 2.0 - 1.0;\n    ws.y /= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    vec2 a = vec2(0.0, 0.25);\n    vec2 b = vec2(0.25, -0.25);\n    vec2 c = vec2(-0.25, -0.25);\n    \n    vec3 triUV;\n    if (tri(a, b, c, rotate(ws, iTime * 10.0), triUV))\n        color = triUV;\n    \n\tfragColor = vec4(barySmoothstep(color, int(iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 43, 74, 74, 206], [208, 222, 251, 251, 286], [288, 314, 350, 350, 447], [449, 518, 552, 552, 616], [618, 618, 677, 677, 1810], [1812, 1812, 1846, 1846, 1990], [1992, 1992, 2027, 2027, 2267], [2269, 2269, 2311, 2311, 2471], [2473, 2473, 2530, 2530, 2945]], "test": "untested"}
{"id": "Nttczj", "name": "deep 5input expanded", "author": "lomateron", "description": "taking that 5input network and expanding to 9inputs\nthe simulation behaves similarly\nthis is not deeper just an expansion of the structure by repeating the structure\nsomething deeper will have no structure repetition", "tags": ["binaryfunction"], "likes": 4, "viewed": 233, "published": 3, "date": "1660141592", "time_retrieved": "2024-07-30T16:36:09.816274", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nuint nor(uint a, uint b)\n{\n    return ~(a|b);\n}\nuint deep5(uint a, uint b, uint c, uint d, uint e)\n{\n    uint r1 = 0U;\n    uint r2 = 0U;\n    {\n        uint e = nor( a , a );\n        uint f = nor( b , b );\n        uint g = nor( d , d );\n        uint h = nor( a , b );\n        uint i = nor( e , f );\n        uint j = nor( h , i );\n        uint k = nor( j , c );\n        uint l = nor( j , k );\n        uint m = nor( c , k );\n        uint n = nor( l , m );\n        uint o = nor( n , i );\n        uint p = nor( n , d );\n        uint q = nor( o , g );\n             r1= nor( p , q );\n    }\n    {\n        uint o1 = nor(a,b);  uint o0 = o1;\n        uint o2 = nor(o1,a); \n        uint o3 = nor(o1,b);\n             a  = nor(o2,o3);\n             b  = c;\n             o1 = nor(a,b);\n             o2 = nor(o1,a);\n             o3 = nor(o1,b);\n        uint o4 = nor(o2,o3);\n        uint o5 = nor(o4,o4);\n        uint d2 = nor(d,d);\n             o5 = nor(o5,d2);\n             o4 = nor(o4,o0);\n             o4 = nor(o4,o4);\n             o4 = nor(o4,d);\n             r2 = nor(o4,o5);\n    }\n    uint ee = nor(e,e);\n         r1 = nor( r1 , ee);\n         r2 = nor( r2 , e);\n    uint o  = nor( r1 , r2);\n         o  = nor( o , o);\n    return o;\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    uint a = uint(A(u+vec2( 1, 0)).x) & 1U;\n    uint b = uint(A(u+vec2( 0, 1)).x) & 1U;\n    uint c = uint(A(u+vec2(-1, 0)).x) & 1U;\n    uint d = uint(A(u+vec2( 0,-1)).x) & 1U;\n    uint e = uint(A(u+vec2( 1, 1)).x) & 1U;\n    uint f = uint(A(u+vec2(-1, 1)).x) & 1U;\n    uint g = uint(A(u+vec2( 1,-1)).x) & 1U;\n    uint h = uint(A(u+vec2(-1,-1)).x) & 1U;\n    uint i = uint(A(u+vec2( 0, 0)).x) & 1U;    //i = nor(i,i);\n    \n    uint j = deep5(a,b,c,d,i);  //j = nor(j,j);\n    uint k = deep5(e,f,g,h,j);  //k = nor(k,k);\n\n    uint o = k;\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 1.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 1.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = uint(fract(cos(dot(u,vec2(234.76543,iTime)))*2467.5678)+.5);\n        o = uint(step(dot(v,v),dot(m,m)*.06));\n    }\n    fragColor = vec4(o);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nttczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 140]], "test": "untested"}
{"id": "fldcRj", "name": "deep evening", "author": "lomateron", "description": "I found a way to go above >= 5input deep NOR network\nbut meanwhile deep evening", "tags": ["clouds", "sky"], "likes": 16, "viewed": 310, "published": 3, "date": "1660133796", "time_retrieved": "2024-07-30T16:36:10.600178", "image_code": "float j(vec2 u)\n{\n   vec4 a = u.xyxy*(vec4(1.,1.,2.,2.)*.05);\n   vec4 b = u.xyxy*(vec4(4.,4.,8.,8.)*.05);\n   return dot(vec4(texture(iChannel0,a.xy).x,\n                   texture(iChannel0,a.zw).x,\n                   texture(iChannel0,b.xy).x,\n                   texture(iChannel0,b.zw).x),vec4(.5,.25,.125,.0625));\n}\nvec4 my(vec2 u, vec2 pp)\n{\n   float d1 = length(u)*.5+.1;\n   float d2 = d1*d1;\n   float d3 = d2*d1;\n   vec4 c = vec4(d3,d2,d1,1.);\n        c = vec4(dot(vec4(1.),c*vec4(1.,-1.6,-.1,1.)),\n                 dot(vec4(1.),c*vec4(.94,-1.4,-.05,.94)),\n                 dot(vec4(1.),c*vec4(1.15,-2.08,.66,.79)),\n                 0.);\n   float b = 1./dot(u,u);\n   u = 2.*u*b;\n   u += (j(u+sign(u)*pp.y*vec2(.01,.0))-.5)*.3;\n   u *= 1.5;\n   vec2 f = normalize(floor(u)+.5);\n   u = (fract(u)-.5)*3.;\n   vec4 e = mix(vec4(.48,.39,.41,1.),vec4(.99,.89,.54,1.),dot(f,u)*.5+.5);\n   float a = max(1.-.1/max(1.-dot(u,u),0.)-.1*b,0.);\n   return mix(c,e,a);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 1.*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 m = 8.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    fragColor = my(u, vec2(iTime));\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 317], [318, 318, 344, 344, 957], [958, 958, 1015, 1015, 1175]], "test": "untested"}
{"id": "NldyRj", "name": "BMtesting04", "author": "thebtype", "description": "testing integration", "tags": ["cineshader"], "likes": 6, "viewed": 3041, "published": 3, "date": "1660130751", "time_retrieved": "2024-07-30T16:36:11.353165", "image_code": "/**\n * Fractal Brownian Motion\n *\n * Reference: https://thebookofshaders.com/13/\n * \n * See also: https://iquilezles.org/articles/morenoise\n */\n\n#define NUM_OCTAVES 5\n\nconst vec3 color = vec3(.90, 0.745, 0.9);\n\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Get noise\nfloat noise(in vec2 st)\n{\n    // Splited integer and float values.\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i + vec2(0.0, 0.0));\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    // -2.0f^3 + 3.0f^2\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// fractional brown motion\n//\n// Reduce amplitude multiplied by 0.5, and frequency multiplied by 2.\nfloat fbm(in vec2 st)\n{\n\tfloat v = 0.0;\n    float a = 0.5;\n    \n    for (int i = 0; i < NUM_OCTAVES; i++)\n    {\n    \tv += a * noise(st);\n        st = st * 2.0;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate normalized UV values.\n    vec2 st = fragCoord / iResolution.xy;\n        \n    vec2 q = vec2(0.0);\n    q.x = fbm(st + vec2(0.0));\n    q.y = fbm(st + vec2(1.0));\n    \n    // These numbers(such as 1.7, 9.2, etc.) are not special meaning.\n    vec2 r = vec2(0.0);\n    r.x = fbm(st + (1.0 * q) + vec2(1.7, 9.2) + (0.15 * iTime));\n    r.y = fbm(st + (1.0 * q) + vec2(8.3, 2.8) + (0.12 * iTime));\n    \n    // Calculate 'r' is that getting domain warping.\n    float f = fbm(st + r);\n    \n    // f^3 + 0.6f^2 + 0.5f\n    float coef = (f * f * f + (0.6 * f * f) + (0.5 * f));\n    \n    fragColor = vec4(coef * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 232, 258, 258, 334], [336, 349, 374, 415, 789], [791, 891, 914, 914, 1095], [1098, 1098, 1155, 1194, 1783]], "test": "untested"}
{"id": "fldyRj", "name": "BMtesting03", "author": "thebtype", "description": "testing integration", "tags": ["cineshader"], "likes": 24, "viewed": 3346, "published": 3, "date": "1660130458", "time_retrieved": "2024-07-30T16:36:12.209874", "image_code": "/*\n\n    Exotic Particles\n    ----------------\n    \n    Accumulating color values via transcental function warping to create some \n    pretty moving imagery that resembles colliding exotic particles in a \n    chamber... of paint... I actually have no idea what this looks like. :D\n    \n    Function warping is nothing new, and this particular example is just a \n    slightly dressed up version of Jolle and Jarble's previous work, which in \n    turn was very loosely based on one of Lomateron's recent examples -- The \n    respective links are below.\n    \n    Anyway, I've commented the code. However, there's definitely nothing \n    difficult to grasp here. The simple color imagery was produced in \n    \"Buffer A\", which was blended with previous frames for a bit of temporal \n    blurring. The result (Image tab) was then used to take two 3x3 blurred \n    samples in order to add some highlights.\n    \n    \n    \n    \n    Uses elements from the following shaders:\n    \n    Glass bubble lamp - Jarble: https://www.shadertoy.com/view/ttcfD7\n    \n    Glass bubble lamp fork - Jolle: https://www.shadertoy.com/view/WtdBDM\n    \n    Mount Mask - lomateron: https://www.shadertoy.com/view/WdsfRf\n    \n    \n*/\n\n// Things look cleaner without highlights, and in some ways I prefer it.\n// However, it's less interesting... I think? :)\n#define HIGHLIGHTS\n\n// Serves no other purpose than to save having to write this out all the time. I'm using this \n// on a buffer texture, so no sRGB to linear operation needs to be performed. I'm also\n// using (and prefer to use) aspect correct pixel coordinates, so it's necessary to stretch \n// out the X values before retrieving them. It's also possible to stretch out the UV coordinates\n// first, then use a stretched sample spread, which is faster... Yeah, it's confusing, but it \n// doesn't matter, just so long as you have a method you're happy with. :)\n//\nvec4 tx(in vec2 p){ \n     p *= vec2(iResolution.y/iResolution.x, 1);\n     return texture(iChannel0, p + .5/iResolution.y); \n}\n\n// Blur function. Pretty standard.\nvec4 bTx(in vec2 p){\n    \n    // Sample spread -- Measured in pixels.\n    float px = 2.;\n    \n    // Result.\n\tvec4 c = vec4(0);\n    \n    // Standard equally weighted 3x3 blur.\n    for(int i = 0; i<9; i++) c += tx(p + (vec2(i/3, i%3) - 1.)*px/iResolution.y);\n \n    // Normalizing the return value.\n    return c/9.;  \n    \n    /*\n    // NxN blur.\n    const int N = 5;\n    for(int i = 0; i<N*N; i++) c += tx(p + (vec2(i/N, i%N) - float(N - 1)/2.)*px/iResolution.y);\n    return c/float(N*N); \n    */\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Aspect correct pixel coordinates.\n    vec2 uv = fragCoord/iResolution.y;\n   \n    // A 3x3 blurred texture sample. The generated warped imagery contains a few\n    // high frequency speckles, so blurred samples mitigate that somewhat. Denoising\n    // would be better, but this will do.\n    vec4 col = bTx(uv);\n    //vec4 col = tx(uv); // Standard single sample.\n     \n    #ifdef HIGHLIGHTS\n    // Bump mapping via cheap, directional derivative-based highlighting.\n    vec2 px = 4./iResolution.yy; // Sample spread.\n    vec4 col2 = bTx(uv - px); // Seperate sample.\n    float b = max(dot(col2 - col, vec4(.299, .587, .114, 0)), 0.)/length(px); // Bump.\n    col += col2.yzxw*col2.yzxw*b/12.; // Add the colored highlights.\n    #endif\n    \n    // Toning down the lower half slightly.\n    col = mix(col, col.zyxw, max(.3 - uv.y, 0.));\n    \n\n    // Rough gamma correction.\n    fragColor = sqrt(max(col, 0.));\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// Start off with a function, warp it, and accumulate color along the way.\n// This one is just a more mutated version of a simple sine warp function,\n// of which there are plenty of examples on Shadertoy.\nvec3 warp(vec2 u, float ph1, float ph2){\n\n    // Initializing the warped UV coordinates. This gives it a bit \n    // of a worm hole quality. There are infinitly other mutations.\n    vec2 v = u - log(1./max(length(u), .001))*vec2(-1, 1);\n    \n    // Scene color.\n    vec3 col = vec3(0.);\n    \n    // Number of iterations.\n    const int n = 5;\n    \n    for (int i = 0; i<n; i++){\n    \n        // Warp function.\n        v = cos(v.y - vec2(0, 1.57))*exp(sin(v.x + ph1) + cos(v.y + ph2));\n        v -= u;\n        \n        // Color via IQ's cosine palatte and shading.\n        vec3 d = (.5 + .45*cos(vec3(i)/float(n)*3. + vec3(0, 1, 2)*1.5))/max(length(v), .001);\n        // Accumulation.\n        col += d*d/32.;\n        \n        // Adding noise for that fake path traced look. \n        // Also, to hide speckling in amongst noise. :)\n        //col += fract(sin(u.xyy*.7 + u.yxx + dot(u + fract(iTime), \n        //             vec2(113.97, 27.13)))*45758.5453)*.01 - .005;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct UV coordinates.\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y*2.;\n\n   \n    // Angular offsets.\n    float ph1 = iTime*.6;\n    float ph2 = sin(iTime)*.25;\n    \n    // Adding two warp functions phase shifted by a certain amount was\n    // Jolle's interesting addition. Just the one would work, but isn't\n    // as interesting.\n    vec3 col = warp(u, ph1, ph2) + warp(u, ph1, ph2 + 1.57);\n    \n    // Toning things down slightly.\n    col = mix(col, col.zyx, .1);\n    \n    // Noise, for that fake path traced feel. :)\n    //col.xyz += fract(sin(u.xyy*.7 + u.yxx + dot(u + fract(iTime), \n    //                 vec2(113.97, 27.13)))*45758.5453)*.1 - .05;    \n    \n    // Mix the previous frames in.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : .25; \n    col = mix(preCol.xyz, col, blend);\n    \n    \n    // Clamp and add to Buffer A.\n    fragColor = vec4(clamp(col, 0., 1.), 1);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1346, 1891, 1910, 1910, 2016], [2018, 2053, 2073, 2122, 2550], [2553, 2553, 2610, 2652, 3523]], "test": "untested"}
{"id": "NtdyRj", "name": "BMtest2", "author": "thebtype", "description": "testing inputs", "tags": ["cineshader"], "likes": 10, "viewed": 3095, "published": 3, "date": "1660130145", "time_retrieved": "2024-07-30T16:36:13.064589", "image_code": "// domain warping based on the master's notes at https://iquilezles.org/articles/warp\n\n// NOISE ////\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n\n    return f/0.96875;\n}\n\n// -----------------------------------------------------------------------\n\nfloat pattern(in vec2 p, in float t, in vec2 uv, out vec2 q, out vec2 r, out vec2 g)\n{\n\tq = vec2(fbm(p), fbm(p + vec2(10, 1.3)));\n    \n    float s = dot(uv.x + 0.5, uv.y + 0.5);\n    r = vec2(fbm(p + 4.0 * q + vec2(t) + vec2(1.7, 9.2)), fbm(p + 4.0 * q + vec2(t) + vec2(8.3, 2.8)));\n    g = vec2(fbm(p + 2.0 * r + vec2(t * 20.0) + vec2(2, 6)), fbm(p + 2.0 * r + vec2(t * 10.0) + vec2(5, 3)));\n    return fbm(p + 5.5 * g + vec2(-t * 7.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // noise\n    vec2 q, r, g;\n    float noise = pattern(fragCoord * vec2(.004), iTime * 0.007, uv, q, r, g);\n    \n    // base color based on main noise\n    vec3 col = mix(vec3(0.1, 0.4, 0.4), vec3(0.5, 0.7, 0.0), smoothstep(0.0, 1.0, noise));\n    \n    // other lower-octave colors and mixes\n    col = mix(col, vec3(0.35, 0.0, 0.1), dot(q, q) * 1.0);\n    col = mix(col, vec3(0, 0.2, 1), 0.2*g.y*g.y);\n    col = mix(col, vec3(.3, 0, 0), smoothstep(0.0, .6, 0.6*r.g*r.g));\n    col = mix(col, vec3(0, .5, 0), 0.1*g.x);\n    \n    // some dark outlines/contrast and different steps\n    col = mix(col, vec3(0), smoothstep(0.3, 0.5, noise) * smoothstep(0.5, 0.3, noise));\n    col = mix(col, vec3(0), smoothstep(0.7, 0.8, noise) * smoothstep(0.8, 0.7, noise));\n    \n    // contrast\n    col *= noise*2.0;\n    \n    // vignette\n    col *= 0.70 + 0.65 * sqrt(70.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 101, 124, 124, 192], [194, 194, 220, 220, 604], [659, 659, 680, 680, 985], [1063, 1063, 1149, 1149, 1502], [1504, 1504, 1561, 1611, 2603]], "test": "untested"}
{"id": "Ntccz2", "name": "Iijtunnel music remix", "author": "jarble", "description": "More simple patterns", "tags": ["music", "iij"], "likes": 6, "viewed": 314, "published": 3, "date": "1660099404", "time_retrieved": "2024-07-30T16:36:13.971165", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 U =( 2.*fragCoord-iResolution.xy)/iResolution.y;\n\n     float b=sqrt(length(U));\n  \n  U=fract(vec2(b-iTime,abs(atan(U.x,U.y))));\n  //U = mod(U+iTime,256.);\n\n  vec2 c=U*vec2(50.,25.);\n  //c.x += iTime*100.; //makes a cool \"warp speed\" animation\n\n  U=floor(mod((c),vec2(256*2)));\n\n  float d=b*mod((U.x*U.x+U.y*U.y),U.x-U.y)/256.;\n\n  fragColor=vec4(fract(d*U.x),fract(d*U.y),d,1.);\n    \n\n}", "image_inputs": [], "sound_code": "float song(float t, float d){  \n  return pow(2.,\n      mod(t*t*(floor(t/(d))),d)/6.+6.\n      //mod(floor((t*t+t)/d)*floor(t/d),d)/6.+6.\n      //mod(t*(floor(t*t/(d))),d)/6.+6.\n      //mod((floor(t*t*t/(d))),d)/6.+6.\n  );\n}\n\nvec2 mainSound(int samp, float time){\n\n  float t=(time+10.)*6.5,a=(1.-sqrt(fract(t)))*.2;\n  //t /= floor(1.+mod(t/2.,2.));\n  //m = floor(64.-mod(t,3.)),\n  float m=64.,\n  //nb=song(floor(t),64.);\n  nb = 2.*time*min(song(floor(t/4.),m/4.),song(floor(t/2.),m/2.));\n\n  return\n      16.*abs(log(1.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      //64.*abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n  ;\n\n}\n\n/*\n\nfloat song(float t, float d){  \n  return pow(2.,mod(t*2.*(floor(t/(d))),d)/6.+7.);\n}\n\nvec2 mainSound(int samp, float time){\n\n  float t=(time+10.)*6.5*2.,a=sqrt(1.-fract(t/2.))*.2,\n  //m = floor(64.-mod(t,3.)),\n  m=64.,\n  //nb=song(floor(t),64.);\n  nb=min(song(floor(t/4.),m/4.),song(floor(t/2.),m/2.));\n\n  return vec2(fract(time*nb*.998)*a\n\n   ,fract(time*nb)*a);\n\n}\n\n*/", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntccz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 457]], "test": "untested"}
{"id": "ft3yR2", "name": "Iijtunnel", "author": "eiffie", "description": "More simple patterns", "tags": ["iij"], "likes": 16, "viewed": 393, "published": 3, "date": "1660086037", "time_retrieved": "2024-07-30T16:36:14.831864", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 U =( 2.*fragCoord-iResolution.xy)/iResolution.y;\n\n     float b=sqrt(length(U));\n\n  float t=iTime*.5;U=vec2(b-t,abs(atan(U.x,U.y)));\n\n  vec2 c=U*vec2(50.,25.);\n\n  U=floor(mod(abs(c),vec2(256)));\n\n  float d=b*mod((U.x*U.x+U.y*U.y)*floor(iTime*6.5/4.),256.)/256.;\n\n  fragColor=vec4(fract(10.*d),fract(d*d*2.),d,1.);\n    \n\n}", "image_inputs": [], "sound_code": "//double spaced so it looks like more work\n\nfloat song(float n, float t, float d, float off){\n\n  n=mod(n*n*(off+floor(t/(2.*d))*4.),d);\n\n  n+=mod(floor(t/d),2.)*5.;\n\n  return pow(2.,n/12.+6.);\n\n}\n\nvec2 mainSound(int samp, float time){\n\n  float d=64.,t=time*6.5,a=sqrt(1.-fract(t));\n\n  t=floor(t);\n\n  float n=mod(t,d),nb=song(n,t,d,4.),nl=mod(t-1.,d);\n\n  n=song(n,t,d,3.);nl=song(nl,t,d,3.);\n\n  return vec2((fract(time*n*.998)-.5)*(.2-.1*a)+\n\n   (fract(time*nl*.998)-.5)*.1*a\n\n   ,(fract(time*nb)-.5)*.2*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3yR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 392]], "test": "untested"}
{"id": "7ldyRB", "name": "Shortest Noise - 75 chars", "author": "GregRostami", "description": "As I've been experimenting with small noise functions, I found this.\nI doubt this is original, but I would love to know how this stacks up against other noise functions.", "tags": ["2d", "noise", "short"], "likes": 15, "viewed": 337, "published": 3, "date": "1660069757", "time_retrieved": "2024-07-30T16:36:15.932921", "image_code": "void mainImage(out vec4 o,vec2 u) {\n    o = fract( tan(dot(u,u) / u.x+iTime) * u.xxxx); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 89]], "test": "untested"}
{"id": "7ldyW7", "name": "metaballs-wip", "author": "victorqribeiro", "description": "exercise on metaballs", "tags": ["metaballs"], "likes": 6, "viewed": 379, "published": 3, "date": "1660065661", "time_retrieved": "2024-07-30T16:36:16.795613", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\tvec2 uv = ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n\t\t\n        vec2 balls[5];\n        \n        float d = 0.;\n        \n        for (int i = 0; i < balls.length(); i++) {\n            float index = float(i);\n            float x = sin(index + 1. * 0.2 + iTime * 0.8599 + index) * 0.9;\n            float y = cos(index + 1. * 0.189 + iTime * 1.9878) * 0.5;\n            balls[i] = vec2(x, y);\n            d += 1. / length(uv - balls[i]);\n        }\n\t\t\n        d = smoothstep(0.78, 0.8, d * 0.07);\n\t\t\n\t\tfragColor = vec4( d );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 587]], "test": "untested"}
{"id": "7ldcDN", "name": "Ripple Kernel", "author": "JB_0x0003", "description": "Just ripples using a circular-ish kernel. The two extra buffers are to store the previous output, but it would have been more more efficient to store in unused color channels in Buffer A.  Needs an additional smoothing step to get rid of artifacts.", "tags": ["water", "fluid", "derivative", "ripple", "kernel", "sim", "fluidsim"], "likes": 5, "viewed": 286, "published": 3, "date": "1660031918", "time_retrieved": "2024-07-30T16:36:17.552590", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coords\n    vec2 pix = fragCoord.xy / iResolution.xy;\n    \n    // use buffer content to determine color mixing\n    float fac = texture(iChannel0,pix).x / 10.0 + .1; \n    if (fac <= 0.0) {fac = fac * 0.2;}\n    \n    // define colors\n    vec4 col1 = vec4(0.752941, 0.733333, 0.780392,1.0);\n    vec4 col2 = vec4(0.0745098, 0.192157, 0.258824,1.0);\n    \n    // interpolate between colors. Goes darker than the color associated with negative numbers\n    // because ripple values can be negative\n    vec4 outCol = col1 * fac + col2 * (1.0 - fac);\n\n    fragColor = vec4(outCol);\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // sets ripple height at mouse position on click\n    if (iFrame %1 == 0 && vec2(fragCoord.xy + .5) == abs(iMouse.xy) && iMouse.z > 0.0)  {\n    \n        fragColor = vec4(100);\n    \n    }else{\n    \n        ivec2 pos = ivec2(fragCoord.xy - 0.5);\n        \n        //There's probably a better way to implement kernels on shadertoy, but I don't know what it is\n        fragColor = (texelFetch(iChannel0, ivec2(pos.x + 1,pos.y),0) //positives\n                     +texelFetch(iChannel0, pos.xy+1,0) * 0.25\n                     +texelFetch(iChannel0, ivec2(pos.x,pos.y + 1),0)\n                     +texelFetch(iChannel0, pos.xy-1, 0) *0.25//negatives\n                     +texelFetch(iChannel0, ivec2(pos.x - 1, pos.y), 0)\n                     +texelFetch(iChannel0, ivec2(pos.x, pos.y -1),0)\n                     +texelFetch(iChannel0, ivec2(pos.x + 1, pos.y -1),0) *.25//mixed\n                     +texelFetch(iChannel0, ivec2(pos.x -1, pos.y + 1),0) *.25\n                     \n                     // divides total inputs to ensure conservation of energy, \n                     // then subtracts based on the stored volocity value\n                     ) /2.49  -texelFetch(iChannel1,pos,0); \n        \n        // dampens energy every tick to make ripples die\n        fragColor = fragColor * 0.98;\n    \n    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Janky way of recording previous buffer values\n    //B will always execute before C, so it will be one loop behind\n    vec2 pix = fragCoord.xy / iResolution.xy;\n    \n        fragColor = texture(iChannel0,pix);\n        \n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Janky way of recording preious buffer values\n    //B will always execute before C, so it will be one loop behind\n    vec2 pix = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texture(iChannel0,pix);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldcDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 656]], "test": "untested"}
{"id": "7lcyzB", "name": "Carnival ride - hexa", "author": "FabriceNeyret2", "description": "inspired by reference:  https://twitter.com/pickover/status/1556458766194835456\nvariant of https://shadertoy.com/view/fttcW7\nmouse controls camera\n", "tags": ["raymarching", "short", "reproduction", "funfair", "merrygoround"], "likes": 25, "viewed": 339, "published": 3, "date": "1660029920", "time_retrieved": "2024-07-30T16:36:18.307571", "image_code": "// hexa variant of https://shadertoy.com/view/fttcW7\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))           // rotation \n#define C(q, r, l)  max(abs(q.y)-l,length(q.xz)-r)         // cylinder\n#define B(q,T)      r= q, r.xz *= rot(.52), t = min( t, C(r.zxy,.1,1.9) ), \\\n                    r= q, r.z = abs(r.z)-1.5, r.xy *= rot(T), t = min(t, C(r,.2,2.5))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., T=iTime;\n    vec3  R = iResolution,\n          D = vec3(U*.4 - R.xy*.2, -R.y) / R.y,            // ray direction\n          p = vec3(0,0,20), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3(.1,0,0) * cos(T + vec3(0,11,0)); \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(.78-6.*M.y),                           // rotations\n        q.xz *= rot(.78-6.*M.x), \n        r = q, r.y+=2., t = min(t,C(r,.3,4.)),             // trunck\n                         B(q,   T), \n        q.xz*=rot(1.05), B(q,1.-T),                        // bars + handles\n        q.xz*=rot(1.05), B(q,1.+T),         \n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O * 1.3;                                           // color scheme\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 361, 397, 397, 1316]], "test": "untested"}
{"id": "slcyzB", "name": "Cartoon Bricks", "author": "intrakits", "description": "Trying to make some cartoony bricks. might try to add some cracks in them later.", "tags": ["procedural", "noise", "cartoon", "bricks"], "likes": 7, "viewed": 233, "published": 3, "date": "1660029878", "time_retrieved": "2024-07-30T16:36:19.123390", "image_code": "vec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nmat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv.y+=iTime*.2;\n    float id = rand(floor((uv-iqnoise(10.*uv,.9,.9)*.03)*4.));\n    uv = fract((uv-iqnoise(10.*uv,.9,.9)*.03)*4.)-.5;\n    uv.x*=max(1.7,id*2.3);\n    \n    vec3 col = vec3(max(iqnoise((uv-rand(uv*20.)*.1-vec2(3,0))*4., .9, .3),.2));\n    float off =iqnoise(20.*uv,.9,.9);\n    col += DrawSquare(uv-off*.03, .8, .4, 0., 0., .001)*off;\n    col-=DrawSquare(uv-off*.03, .73+id*.03, .33+id*.03, 0., 0., .001)*2.;\n    col = clamp(col,0.,1.);\n    col+=5.*DrawSquare(uv-off*.03, .73+id*.03, .33+id*.03, 0., 0., .001)*max(iqnoise(10.*uv-rand(uv*30.)*.3-id*20.,.9,.1),.4)*.2;\n    \n    vec2 gv = uv;\n    gv*=rotate(3.1415/6.2);\n    float bounds = max(smoothstep(-.37,-.4,uv.y),smoothstep(.4,.41,uv.y));\n    //\n    col+=DrawSquare(gv-off*.03, 1.4, .02, 0., 0., .001)*bounds*off;\n    \n    \n    gv=uv;\n    gv*=rotate(-3.1415/6.2);\n    col+=DrawSquare(gv-off*.03, 1.4, .02, 0., 0., .001)*bounds*off;\n    col*=smoothstep(0.9,.8,abs(uv.x));\n    col*=smoothstep(0.55,.3,abs(uv.y));\n    float r = smoothstep(0.,.5,id);\n    float g = smoothstep(0.4,.7,id);\n    float b = smoothstep(0.7,1.,id);\n    col*=max(vec3(r,g,b)*.7,vec3(.4));\n\n   \n   // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 127], [129, 129, 149, 149, 212], [214, 214, 277, 277, 842], [843, 843, 933, 933, 1118], [1119, 1119, 1141, 1141, 1217], [1218, 1218, 1275, 1325, 2605]], "test": "untested"}
{"id": "7l3yRB", "name": "Flower Creation", "author": "wyatt", "description": "flower", "tags": ["flower"], "likes": 26, "viewed": 308, "published": 3, "date": "1660021454", "time_retrieved": "2024-07-30T16:36:20.101774", "image_code": "void mainImage (out vec4 Q, in vec2 U) {\n    U = 2.*(U-.5*R)/R.y;\n    Q = vec4(0);\n    if (iFrame<3000)\n    for (float x = 0.; x<50.;x++) {\n        vec2 a = A(vec2(x,0)+.5).xy;\n        vec2 b = A(vec2(x+1.,0)+.5).xy;\n        vec4 C = 1.-sin(2.*(x-25.)/50.+vec4(1,2,3,4));\n        Q = max(Q,\n            C*step(\n                segment(U,a,b),\n                .01\n            )\n        );\n    }\n    for (float x = 0.; x<50.;x++) {\n        vec2 a = A(vec2(x,1)+.5).xy;\n        float t = float(iFrame)/100.;\n        vec4 C = sin(x/50.+6.+.2*sin(t)+vec4(1,2,3,4));\n        Q = max(Q,\n            C*step(\n                length(U-a.xy),\n                .01*exp(-sin(t)*sin(t))\n            )\n        );\n    }\n    \n    if (iFrame < 1) Q = vec4(0);\n    else if (length(Q)==0.) discard;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat segment (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec3 rodrigues( vec3 v, vec3 k, float t) {\n    return v*cos(t)+cross(k,v)*sin(t)+k*dot(k,v)*(1.-cos(t));\n}\nvec3 hash (vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    vec3 \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nvec3 fbm (vec2 p)\n{\n    vec3 w = vec3(0);\n    float N = 5.;\n    for (float i = 1.; i < N; i++)\n    {\n        p *= 1.7*ei(.5);\n        w += noise(p)/N/i;\n    }\n    return w;\n}", "buffer_a_code": "void mainImage (out vec4 Q, in vec2 U) {\n    float x = U.x/50.;\n    if (U.y<1.) {\n        Q.x = .8*x;\n        Q.y = 0.;\n        float a = float(iFrame)/200.;\n        Q.xy *= ei(a);\n        Q.xy *= .8+.5*sin(3.1+5.*a);\n        float d = dot(Q.xy,Q.xy);\n        vec2 f = sqrt(d)*(fbm(vec2(sin(x),sin(10.*a))).xy);\n        f -= .5*Q.xy*dot(f,Q.xy);\n        Q.xy += f;\n    } else {\n        float a = 1.618*6.28318530718*U.x;\n        float t = float(iFrame)/100.;\n        Q.xy = .2*x*vec2(cos(a),sin(a));\n        Q.xy += Q.xy*sin(t);\n        Q.y += 4.*length(Q.xy)*.1*(1.5-sin(t)*sin(t));\n    }\n    Q.y -= .2;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3yRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 779]], "test": "untested"}
{"id": "stcyRB", "name": "Stringy Distortion", "author": "MysteryPancake", "description": "Messed up a histogram idea, this is the result", "tags": ["distortion", "texture", "distort", "sample", "smear", "stringy"], "likes": 3, "viewed": 220, "published": 3, "date": "1660021301", "time_retrieved": "2024-07-30T16:36:21.030291", "image_code": "const int samples = 4;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tfragColor = vec4(1.0);\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\tfloat m = clamp(mod(iTime * 0.1, 1.1), 0.0, 1.0);\n\t\n\tfor (int x = 0; x < samples; x++) {\n\t\tfor (int y = 0; y < samples; y++) {\n\t\t\tvec2 normalised = vec2(float(x) / float(samples), float(y) / float(samples));\n\t\t\tvec4 samp = texture(iChannel0, mix(uv, normalised, m));\n\t\t\tfloat dist = distance(samp.rgb, vec3(uv.x));\n\t\t\tif (dist < 0.1) {\n\t\t\t\tfragColor = samp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 79, 79, 530]], "test": "untested"}
{"id": "stcyRS", "name": "Merging Stripes", "author": "MysteryPancake", "description": "Based on an earlier voronoi experiment", "tags": ["distance", "stripes", "stripe", "nearest", "neighbor"], "likes": 1, "viewed": 180, "published": 3, "date": "1660011908", "time_retrieved": "2024-07-30T16:36:21.890990", "image_code": "// Based on https://www.shadertoy.com/view/7ttyD7\nfloat rand(float co) {\n\treturn fract(sin(co) * sin(iTime * 0.5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfloat smallest = 1.0;\n\tvec3 result;\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat j = float(i);\n\t\tfloat xDiff = rand(j) - uv.x;\n\t\tfloat yDiff = rand(j) - uv.y;\n\t\tfloat dist = xDiff * xDiff + yDiff * yDiff;\n\t\tif (dist < smallest) {\n\t\t\tsmallest = dist;\n\t\t\tresult = vec3(rand(j), rand(j + 1.0), rand(j + 1.0));\n\t\t}\n\t}\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 72, 72, 117], [119, 119, 174, 174, 558]], "test": "untested"}
{"id": "ftcyRS", "name": "2D Stars by hugolnx", "author": "hugolnx", "description": "Testing random generated 2d stars shader.", "tags": ["2d", "sky", "stars"], "likes": 0, "viewed": 199, "published": 3, "date": "1659982356", "time_retrieved": "2024-07-30T16:36:22.954147", "image_code": "// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/stars\n// SHADERTOY: https://www.shadertoy.com/view/ftcyRS\n\n#define SHADERTOY 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\n\n// -------------------\n// BEGIN https://github.com/stegu/webgl-noise\n// -------------------\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod7(vec3 x) {return x - floor(x * (1.0 / 7.0)) * 7.0;}\nvec3 permute(vec3 x) {return mod289((34.0 * x + 10.0) * x);}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Cellular\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nvec2 ncellular(vec2 p, float seed) {\n  p *= 15.;\n  seed *= 0.3;\n  return cellular(vec3(p, seed));\n}\n\n// Classic Perlin noise\nfloat perlin(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat nperlin(vec2 p, float seed) {\n  p *= 20.;\n  seed *= 0.5;\n  return norm(perlin(vec3(p, seed)));\n}\n\n// Simplex Noise\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat nsimplex(vec2 x, float seed) {\n  x *= 10.;\n  seed *= 0.3;\n  return norm(simplex(vec3(x, seed)));\n}\n\n\n// -------------------\n// END noise3D\n// -------------------\n\n// -------------------\n// BEGIN https://www.shadertoy.com/view/4dS3Wd\n// -------------------\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat morgan(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat morgan(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat morgan(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat nmorgan(float x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x, float seed) {\n  x *= 20.;\n  seed *= 0.5;\n  return morgan(vec3(x, seed));\n}\n// -------------------\n// END Morgan Noises\n// -------------------\n\n\n// -------------------\n// BEGIN http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// -------------------\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 P = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, P.wz) : vec4(c.gb, P.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    // vec4 p = mix(vec4(c.bg, P.wz), vec4(c.gb, P.xy), step(c.b, c.g));\n    // vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 P = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + P.xyz) * 6.0 - P.www);\n    return c.z * mix(P.xxx, clamp(p - P.xxx, 0.0, 1.0), c.y);\n}\n// -------------------\n// END HSV Conversion \n// -------------------\n\nvec3 hsv(float h, float s, float v) {return hsv2rgb(vec3(h, s, v));}\n\n\n// Noise Aux Functions\nfloat random(vec2 uv, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(uv, vec2(a, b)) + seed) * c);\n}\n\n#define OCTAVES 6\n#define OCTAVES_F 6.0\n\n// Simplex Variations\n#define SIMPLEX_VARS_SCALE 1.0\nfloat turbSimplex( vec3 p ) {\n  p *= SIMPLEX_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(100.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( simplex( power * p + shift ) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbSimplex(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.08;\n  return 1.-sat(-1.2*turbSimplex(vec3(p, seed)));\n}\n\nfloat nturb2Simplex(vec2 st2, float seed) {\n  seed *= 0.04;\n  vec3 st = vec3(st2, seed);\n  st *= SIMPLEX_VARS_SCALE * 3.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(200.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(simplex(st));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmSimplex(vec3 x) {\n  x *= SIMPLEX_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(300.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * simplex(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmSimplex(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmSimplex(vec3(x, seed)));\n}\n\n\n// Morgan Variations\n#define MORGAN_VARS_SCALE 2.5\nfloat turbMorgan( vec3 p ) {\n  p *= MORGAN_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(0.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(morgan( power * p + shift )) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbMorgan(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.05;\n  return 1.-sat(-2.0*turbMorgan(vec3(p, seed)));\n}\n\nfloat nturb2Morgan(vec2 st2, float seed) {\n  seed *= 0.03;\n  vec3 st = vec3(st2, seed);\n  st *= MORGAN_VARS_SCALE * 6.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(0.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(morgan(st)));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmMorgan(vec3 x) {\n  x *= MORGAN_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = .9;\n\tvec3 shift = vec3(0.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * (denorm(morgan(x))+0.05);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmMorgan(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmMorgan(vec3(x, seed)));\n}\n\n\n\n// Cellular Variations\n#define CELLULAR_VARS_SCALE 1.5\nfloat turbCellular( vec3 p ) {\n  p *= CELLULAR_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(700.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(cellular( power * p + shift ).x) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbCellular(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.07;\n  return sat(0.85+2.*turbCellular(vec3(p, seed)));\n}\n\nfloat nturb2Cellular(vec2 st2, float seed) {\n  seed *= 0.02;\n  vec3 st = vec3(st2, seed);\n  st *= CELLULAR_VARS_SCALE * 5.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(800.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(cellular(st).x));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmCellular(vec3 x) {\n  x *= CELLULAR_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(900.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * denorm(cellular(x).x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmCellular(vec2 x, float seed) {\n  seed *= 0.1;\n  x *= 5.;\n  return norm(fbmCellular(vec3(x, seed)));\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\n#define SKY_COLOR1 vec3(.0, .15, .35)\n#define SKY_COLOR2 vec3(.0, .0, .1)\n#define WHITE vec3(1.0, 1.0, 1.0)\n#define TWO_PI 6.283185\n#define PI 3.14159\n\nvec3 drawCleanSky(vec2 uv) {\n    float t = length(uv+vec2(0.5,-0.5));\n    return mix(SKY_COLOR2, SKY_COLOR1, t);\n}\n\nfloat sincurve(float t) {\n    return sin(t*PI/2.0);\n}\n\nfloat coscurve(float t) {\n    return 1.0-cos(t*PI/2.0);\n}\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nfloat drawStar(vec2 uv, float bright) {\n    //bright = 0.5\n    uv *= 2.;\n    float len = length(uv);\n    float v = 0.;\n    float ctV = (1. - sincurve(clamp(len/0.5, 0., 1.)));\n    float axiV = (1. - sincurve(clamp(abs(uv.x/0.5*0.7), 0., 1.)))\n        * (1. - sincurve(clamp(abs(uv.y/0.5*0.7), 0., 1.)));\n    float c = cos(PI/4.0);\n    float s = sin(PI/4.0);\n    vec2 rotuv = mat2(c, -s, s, c) * uv;\n    float digV = (1. - sincurve(clamp(abs(rotuv.x/0.6), 0., 1.)))\n        * (1. - sincurve(clamp(abs(rotuv.y/0.6), 0., 1.)));\n    //bright = 0.0;\n    float b = mix(0.35, 1.0, bright);\n    v += max(digV, axiV*0.9) * b + ctV * (1.0-b);\n    return v;\n}\n\nfloat drawSkyStars(vec2 uv, float cellsize, float seed, float amount) {\n    float padding = 0.15;\n    float r3 = nmorgan(vec2(seed/cellsize, seed*amount*107.53), seed*97.37);\n    uv -= r3*49.379;\n    vec2 cell = floor(uv/cellsize);\n    float cellinsize = cellsize-padding*2.;\n    float r4 = nmorgan(cell * seed * 67.837, seed*97.37)-0.5;\n    vec2 cellct = cell + vec2(cellsize/2.);\n    vec2 celluv = mod(uv, cellsize)/cellsize-0.5;\n    celluv *= cellinsize/cellsize;\n    celluv += r4*padding*0.85;\n    float v = nmorgan(cellct*3., seed);\n    float amountstep = mix(0.98, 0.7, amount);\n    v = step(amountstep, v);\n    float r1 = nmorgan(cellct, seed*13.17)*TWO_PI;\n    float r2 = mix(1.0, 3.0, nmorgan(cellct, seed*92.17));\n    return v * drawStar(celluv, (cos(iTime*r2*PI+r1)+1.0)/2.0);// + v * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    float mx = max(iResolution.x, iResolution.y);\n    vec2 ct = iResolution.xy / mx / 2.0;\n    vec2 uv = fragCoord/mx;\n    uv -= ct;\n\n\n    float t = iTime/60.0*3.0;\n    vec3 c = drawCleanSky(uv);\n    uv -= vec2(t*0.5, -t*0.85);\n    float cellsize = 0.05;\n    float s = 0.;\n    s += drawSkyStars(uv, 0.11, 73.96, .5);\n    s += drawSkyStars(uv, 0.12, 3.96, .85);\n    s += drawSkyStars(uv, 0.13, 53.96, .85);\n    s += drawSkyStars(uv, 0.14, 17.29, .25);\n    s += drawSkyStars(uv, 0.15, 17.29*7., .25);\n    c = mix(c, s * WHITE, s);\n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 245, 245, 265], [266, 266, 289, 289, 309], [310, 310, 350, 350, 388], [389, 389, 435, 435, 482], [483, 483, 521, 521, 563], [564, 564, 585, 585, 615], [616, 616, 637, 637, 667], [668, 668, 689, 689, 719], [720, 720, 740, 740, 765], [766, 766, 787, 787, 814], [815, 815, 862, 862, 918], [919, 919, 970, 970, 1027], [1122, 1122, 1143, 1143, 1188], [1189, 1189, 1210, 1210, 1255], [1256, 1256, 1275, 1275, 1316], [1317, 1317, 1339, 1339, 1377], [1378, 1378, 1400, 1400, 1434], [1435, 1435, 1462, 1462, 1510], [1511, 1511, 1530, 1530, 1566], [1568, 1580, 1603, 1603, 6410], [6412, 6412, 6448, 6448, 6511], [6513, 6537, 6559, 6559, 8854], [8856, 8856, 8891, 8891, 8958], [8960, 8977, 9002, 9002, 11141], [11143, 11143, 11179, 11179, 11247], [11312, 11479, 11500, 11500, 11567], [11568, 11568, 11588, 11588, 11693], [11695, 11695, 11718, 11718, 11850], [11852, 11852, 11874, 11874, 12508], [12511, 12511, 12533, 12533, 13294], [13296, 13296, 13320, 13320, 13354], [13355, 13355, 13378, 13378, 13412], [13413, 13413, 13448, 13448, 13509], [13579, 13690, 13712, 13712, 14173], [14175, 14175, 14197, 14197, 14366], [14437, 14437, 14474, 14474, 14505], [14508, 14531, 14566, 14566, 14714], [14810, 14810, 14839, 14839, 15073], [15075, 15075, 15115, 15115, 15194], [15196, 15196, 15239, 15239, 15562], [15564, 15564, 15590, 15590, 15801], [15803, 15803, 15842, 15842, 15912], [15966, 15966, 15994, 15994, 16232], [16234, 16234, 16273, 16273, 16351], [16353, 16353, 16395, 16395, 16722], [16724, 16724, 16749, 16749, 16971], [16973, 16973, 17011, 17011, 17080], [17139, 17139, 17169, 17169, 17415], [17417, 17417, 17458, 17458, 17538], [17540, 17540, 17584, 17584, 17919], [17921, 17921, 17948, 17948, 18171], [18173, 18173, 18213, 18213, 18284], [18287, 18287, 18321, 18321, 18403], [18557, 18557, 18585, 18585, 18671], [18673, 18673, 18698, 18698, 18726], [18728, 18728, 18753, 18753, 18785], [18958, 18958, 18997, 19016, 19606], [19608, 19608, 19679, 19679, 20410], [20412, 20412, 20469, 20524, 21110]], "test": "untested"}
{"id": "7ttyD7", "name": "Nearest Neighbor Voronoi", "author": "MysteryPancake", "description": "Inspired by the K-Nearest Neighbors algorithm", "tags": ["2d", "fractal", "voronoi", "nearest", "neighbor"], "likes": 3, "viewed": 334, "published": 3, "date": "1659976397", "time_retrieved": "2024-07-30T16:36:23.781934", "image_code": "float rand(float co) {\n\treturn fract(sin(co) * mod(iTime * 0.5, 10.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfloat smallest = 1.0;\n\tvec3 result;\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat j = float(i);\n\t\tfloat xDiff = rand(j) - uv.x;\n\t\tfloat yDiff = rand(j + 1.0) - uv.y;\n\t\tfloat dist = xDiff * xDiff + yDiff * yDiff;\n\t\tif (dist < smallest) {\n\t\t\tsmallest = dist;\n\t\t\tresult = vec3(rand(j), rand(j + 1.0), rand(j + 2.0));\n\t\t}\n\t}\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 73], [75, 75, 130, 130, 520]], "test": "untested"}
{"id": "sttyW7", "name": "2D Clouds by hugolnx", "author": "hugolnx", "description": "Generate random 2D clouds (testing with noise)", "tags": ["2d", "clouds", "sensen"], "likes": 2, "viewed": 323, "published": 3, "date": "1659968996", "time_retrieved": "2024-07-30T16:36:24.873017", "image_code": "// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/clouds\n// SHADERTOY: https://www.shadertoy.com/view/sttyW7\n\n#define SHADERTOY 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\nfloat normrange(float v, float minV, float maxV) { return sat((v-minV)/(maxV-minV)); }\n\n// -------------------\n// BEGIN https://github.com/stegu/webgl-noise\n// -------------------\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod7(vec3 x) {return x - floor(x * (1.0 / 7.0)) * 7.0;}\nvec3 permute(vec3 x) {return mod289((34.0 * x + 10.0) * x);}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Cellular\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nvec2 ncellular(vec2 p, float seed) {\n  p *= 15.;\n  seed *= 0.3;\n  return cellular(vec3(p, seed));\n}\n\n// Classic Perlin noise\nfloat perlin(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat nperlin(vec2 p, float seed) {\n  p *= 20.;\n  seed *= 0.5;\n  return norm(perlin(vec3(p, seed)));\n}\n\n// Simplex Noise\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat nsimplex(vec2 x, float seed) {\n  x *= 10.;\n  seed *= 0.3;\n  return norm(simplex(vec3(x, seed)));\n}\n\n\n// -------------------\n// END noise3D\n// -------------------\n\n// -------------------\n// BEGIN https://www.shadertoy.com/view/4dS3Wd\n// -------------------\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat morgan(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat morgan(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat morgan(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat nmorgan(float x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x, float seed) {\n  x *= 20.;\n  seed *= 0.5;\n  return morgan(vec3(x, seed));\n}\n// -------------------\n// END Morgan Noises\n// -------------------\n\n\n// -------------------\n// BEGIN http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// -------------------\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 P = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, P.wz) : vec4(c.gb, P.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    // vec4 p = mix(vec4(c.bg, P.wz), vec4(c.gb, P.xy), step(c.b, c.g));\n    // vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 P = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + P.xyz) * 6.0 - P.www);\n    return c.z * mix(P.xxx, clamp(p - P.xxx, 0.0, 1.0), c.y);\n}\n// -------------------\n// END HSV Conversion \n// -------------------\n\nvec3 hsv(float h, float s, float v) {return hsv2rgb(vec3(h, s, v));}\n\n\n// Noise Aux Functions\nfloat random(vec2 uv, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(uv, vec2(a, b)) + seed) * c);\n}\n\n#define OCTAVES 6\n#define OCTAVES_F 6.0\n\n// Simplex Variations\n#define SIMPLEX_VARS_SCALE 1.0\nfloat turbSimplex( vec3 p ) {\n  p *= SIMPLEX_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(100.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( simplex( power * p + shift ) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbSimplex(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.08;\n  return 1.-sat(-1.2*turbSimplex(vec3(p, seed)));\n}\n\nfloat nturb2Simplex(vec2 st2, float seed) {\n  seed *= 0.04;\n  vec3 st = vec3(st2, seed);\n  st *= SIMPLEX_VARS_SCALE * 3.;\n  float value = 0.0;\n  float amplitude = .9;\n  vec3 shift = vec3(200.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(simplex(st));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmSimplex(vec3 x) {\n  x *= SIMPLEX_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(300.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * simplex(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmSimplex(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmSimplex(vec3(x, seed)));\n}\n\n\n// Morgan Variations\n#define MORGAN_VARS_SCALE 2.5\nfloat turbMorgan( vec3 p ) {\n  p *= MORGAN_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(0.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(morgan( power * p + shift )) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbMorgan(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.05;\n  return 1.-sat(-2.0*turbMorgan(vec3(p, seed)));\n}\n\nfloat nturb2Morgan(vec2 st2, float seed) {\n  seed *= 0.03;\n  vec3 st = vec3(st2, seed);\n  st *= MORGAN_VARS_SCALE * 6.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(0.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(morgan(st)));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmMorgan(vec3 x) {\n  x *= MORGAN_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = .9;\n\tvec3 shift = vec3(0.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * (denorm(morgan(x))+0.05);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmMorgan(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmMorgan(vec3(x, seed)));\n}\n\n\n\n// Cellular Variations\n#define CELLULAR_VARS_SCALE 1.5\nfloat turbCellular( vec3 p ) {\n  p *= CELLULAR_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(700.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(cellular( power * p + shift ).x) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbCellular(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.07;\n  return sat(0.85+2.*turbCellular(vec3(p, seed)));\n}\n\nfloat nturb2Cellular(vec2 st2, float seed) {\n  seed *= 0.02;\n  vec3 st = vec3(st2, seed);\n  st *= CELLULAR_VARS_SCALE * 5.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(800.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(cellular(st).x));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmCellular(vec3 x) {\n  x *= CELLULAR_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(900.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * denorm(cellular(x).x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmCellular(vec2 x, float seed) {\n  seed *= 0.1;\n  x *= 5.;\n  return norm(fbmCellular(vec3(x, seed)));\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\n\n// Main Code\n#define SKY_COLOR1 vec3(0.0, 0.65, 1.0)\n#define SKY_COLOR2 vec3(0.0, 0.25, 0.85)\n#define WHITE vec3(1.0, 1.0, 1.0)\n\n// How big the clouds will be\n#define CROWDED_LEVEL 0.5\n\n// Simplify cloud colors\n// #define COLOR_LAYERS 3.0\n\n// How much stronger each layer will be\n#define COLOR_MIN 0.1\n#define COLOR_MAX 1.0\n\n\nvec3 drawDrySky(vec2 uv) {\n    vec3 c = vec3(0.);\n    c = mix(SKY_COLOR2, SKY_COLOR1, length(uv-vec2(0.0,1.0))/1.414);\n\n    float t = iTime/60.0*3.0;\n    float v = nturb2Simplex(vec2(uv.x-t, uv.y-t/4.0), t);\n    float cutMin = 1.-CROWDED_LEVEL;\n    float cutMax = 1.001;\n    v = v * xstep(cutMin, cutMax, v);\n\n    #ifdef COLOR_LAYERS\n    // simplify clouds\n    v = normrange(v, cutMin, cutMax);\n    v = step(0.001, v) * mix(COLOR_MIN, COLOR_MAX, flatten(v, COLOR_LAYERS+1.));\n    v = mix(cutMin, cutMax, v);\n    v *= step(cutMin+0.01, v);\n    #endif\n\n    c = mix(c, WHITE, v);\n    return c;\n}\n\nvec3 blurredSky(vec2 uv, float dist) {\n    vec3 c1 = drawDrySky(uv + vec2(0.0 , 1.0 )*dist);\n    vec3 c2 = drawDrySky(uv + vec2(1.0 , 0.0 )*dist);\n    vec3 c3 = drawDrySky(uv + vec2(0.0 , -1.0)*dist);\n    vec3 c4 = drawDrySky(uv + vec2(-1.0, 0.0 )*dist);\n    return (c1+c2+c3+c4) / 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    float mx = max(iResolution.x, iResolution.y);\n    vec2 ct = iResolution.xy / mx / 2.0;\n    vec2 uv = fragCoord/mx;\n    uv -= ct;\n\n    vec3 c = blurredSky(uv, 0.001);\n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 246, 246, 266], [267, 267, 290, 290, 310], [311, 311, 351, 351, 389], [390, 390, 436, 436, 483], [484, 484, 522, 522, 564], [565, 565, 586, 586, 616], [617, 617, 638, 638, 668], [669, 669, 690, 690, 720], [721, 721, 741, 741, 766], [767, 767, 788, 788, 815], [816, 816, 863, 863, 919], [920, 920, 971, 971, 1028], [1029, 1029, 1079, 1079, 1115], [1210, 1210, 1231, 1231, 1276], [1277, 1277, 1298, 1298, 1343], [1344, 1344, 1363, 1363, 1404], [1405, 1405, 1427, 1427, 1465], [1466, 1466, 1488, 1488, 1522], [1523, 1523, 1550, 1550, 1598], [1599, 1599, 1618, 1618, 1654], [1656, 1668, 1691, 1691, 6498], [6500, 6500, 6536, 6536, 6599], [6601, 6625, 6647, 6647, 8942], [8944, 8944, 8979, 8979, 9046], [9048, 9065, 9090, 9090, 11229], [11231, 11231, 11267, 11267, 11335], [11400, 11567, 11588, 11588, 11655], [11656, 11656, 11676, 11676, 11781], [11783, 11783, 11806, 11806, 11938], [11940, 11940, 11962, 11962, 12596], [12599, 12599, 12621, 12621, 13382], [13384, 13384, 13408, 13408, 13442], [13443, 13443, 13466, 13466, 13500], [13501, 13501, 13536, 13536, 13597], [13667, 13778, 13800, 13800, 14261], [14263, 14263, 14285, 14285, 14454], [14525, 14525, 14562, 14562, 14593], [14596, 14619, 14654, 14654, 14802], [14898, 14898, 14927, 14927, 15161], [15163, 15163, 15203, 15203, 15282], [15284, 15284, 15327, 15327, 15649], [15651, 15651, 15677, 15677, 15888], [15890, 15890, 15929, 15929, 15999], [16053, 16053, 16081, 16081, 16319], [16321, 16321, 16360, 16360, 16438], [16440, 16440, 16482, 16482, 16809], [16811, 16811, 16836, 16836, 17058], [17060, 17060, 17098, 17098, 17167], [17226, 17226, 17256, 17256, 17502], [17504, 17504, 17545, 17545, 17625], [17627, 17627, 17671, 17671, 18006], [18008, 18008, 18035, 18035, 18258], [18260, 18260, 18300, 18300, 18371], [18374, 18374, 18408, 18408, 18490], [18990, 18990, 19016, 19016, 19582], [19584, 19584, 19622, 19622, 19872], [19874, 19874, 19931, 19986, 20213]], "test": "untested"}
{"id": "fttcW7", "name": "Carnival ride", "author": "FabriceNeyret2", "description": "inspired by reference:  https://twitter.com/pickover/status/1556458766194835456\nmouse controls camera\n\ncould this generalize to more (long) branches ? :-) ", "tags": ["raymarching", "short", "reproduction", "funfair", "merrygoround"], "likes": 19, "viewed": 311, "published": 3, "date": "1659945710", "time_retrieved": "2024-07-30T16:36:25.698809", "image_code": "// more readable version below  564\n\n// -3 by Xor\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))           // rotation \n#define C(q, r, l)  max(abs(q.y)-l,length(q.xz)-r)         // cylinder\n#define B(q,T)      r= q, r.z = abs(r.z)-1., r.xy *= rot( sign(q.z)*(T)), t = min(t, C(r,.3,2.5))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  R = iResolution,\n          D = vec3(U*.4 - R.xy*.2, -R.y) / R.y,            // ray direction\n          p = vec3(0,0,20), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3(.1,0,0) * cos(iTime + vec3(0,11,0)); \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(.78-6.*M.y),                           // rotations\n        q.xz *= rot(.78-6.*M.x), \n        t = min( C(q.zxy,.1,1.5), C(q.xzy,.1,1.5) ),       // axis\n        r = q, r.y+=2., t = min(t,C(r,.3,4.)),             // trunck\n        B(q,iTime), B(q.zyx,iTime-1.6),                    // bars\n     // B(q.zxy,iTime-.8),                                 // ( try adding horizontals :-) )\n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O * 1.5;                                           // color scheme\n}\n\n\n\n\n\n\n/**  // --- 649 chars\n\n#define rot(a)        mat2(cos(a+vec4(0,-1.57,1.57,0)))    // rotation \n#define C(q, r, l)    max(abs(q.y)-l,length(q.xz)-r)\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -5.*R.y) - R),           // ray direction\n          p = vec3(0,0,20), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3( .1,0,0) * cos(iTime + vec3(0,11,0)); \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(.78-6.*M.y),                           // rotations\n        q.xz *= rot(.78-6.*M.x), \n        t = min( C(q.zxy,.1,1.5), C(q.xzy,.1,1.5) ),       // axis\n        r = q, r.y+=2., t = min(t,C(r,.3,4.)),             // trunck\n        r = q, r.z++, r.xy*=rot( iTime),     t = min(t, C(r,.3,2.)), // bars\n        r = q, r.z--, r.xy*=rot(-iTime),     t = min(t, C(r,.3,2.)),\n        r = q, r.x++, r.yz*=rot(-iTime-1.6), t = min(t, C(r,.3,2.)),\n        r = q, r.x--, r.yz*=rot( iTime+1.6), t = min(t, C(r,.3,2.)),\n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O * 1.5;                                           // color scheme\n}\n\n/**/", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 329, 329, 1311]], "test": "untested"}
{"id": "fldyWM", "name": "Trees at Sunset", "author": "wyatt", "description": "trees at sunset", "tags": ["sunset", "trees"], "likes": 27, "viewed": 395, "published": 3, "date": "1659931144", "time_retrieved": "2024-07-30T16:36:26.533577", "image_code": "#define R iResolution.xy\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat segment (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec3 rodrigues( vec3 v, vec3 k, float t) {\n    return v*cos(t)+cross(k,v)*sin(t)+k*dot(k,v)*(1.-cos(t));\n}\nvec3 hash (vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    vec3 \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nvec3 fbm (vec2 p)\n{\n    vec3 w = vec3(0);\n    float N = 5.;\n    for (float i = 1.; i < N; i++)\n    {\n        p *= 1.7*ei(.5);\n        w += noise(p)/N/i;\n    }\n    return w;\n}\nvoid mainImage (out vec4 Q, in vec2 U) {\n    U = 2.*(U-.5*R)/R.y;\n    U.y += 1.;\n    Q = vec4(1);\n    for (float k = -5.; k <= 5.; k++) {\n    vec3 a = vec3(k/3.+.1*sin(3.*k),0,0),\n        b = vec3(k/3.+.1*sin(3.*k),.2+.1*sin(3.*k),0),\n        p = vec3(0,0,1);\n    float j = 0.;\n    for (float i = 1.; i < 10.; i++) {\n        Q *= step(.1*length(a-b),segment(U,a.xy,b.xy));\n        vec3 t = b;\n        vec3 h = floor(hash(k+U+iTime+100.*i)*5.)-2.;\n        if (abs(h.x)>1.) h.x = 0.;\n        vec3 f = hash(vec2(i,j+k))*2.-1.;\n        j += h.x*i;\n        vec3 u = b-a;\n        u *=.95-.5*abs(h.x);\n        vec3 k = normalize(u);\n        p.xz *= ei(.15*6.2*f.x);\n        u = rodrigues(u,p,-.1*j+.1*f.y+.5*3.*h.x);\n        b = b+u;\n        a = t;\n    }\n    Q *= step(.01,segment(U,a.xy,b.xy));\n        \n    }\n    \n    if (iFrame < 1) {\n        Q = sin(5.+2.-U.y+vec4(1,2,3,4));\n        Q -= .3*fbm(5.*U).x;\n        Q += .7*fbm(20.*U).x*(\n        smoothstep(.18,.15,length(U-vec2(1.35,1.65)))*\n        smoothstep(.18,.1,length(U-vec2(1.3,1.6)))\n        )\n        ;\n    }else \n    if (Q.x==1.) discard;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 114, 114, 185], [186, 186, 228, 228, 292], [293, 293, 313, 313, 449], [450, 450, 470, 470, 746], [747, 747, 766, 766, 921], [922, 922, 962, 962, 2019]], "test": "untested"}
{"id": "sl3yW7", "name": "slowly but surely", "author": "nabr", "description": "didnt post in a while", "tags": ["sound", "synth", "reverb", "riff", "glide", "fdn", "portamento"], "likes": 8, "viewed": 326, "published": 3, "date": "1659909848", "time_retrieved": "2024-07-30T16:36:27.366350", "image_code": "// soundin shader by FabriceNeyret2\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n} // EOL soundin shader\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float t = iTime;\n    if (iResolution.y<2000.) {float c=message(mod(U/iResolution.y*18.-vec2(3,iTime), vec2(18, 6)));if(c>=0.){O=vec4(fract(t)*c);return;}}\n\n    U = (U.xy*.5-iResolution.xy)/iResolution.y;\n    vec2 u = (mod(25.*U+float(iFrame%60), 2.)-1.) * mat2(cos(t), sin(t), -sin(t), cos(t));\n    float b = max(abs(u.x), abs(u.y));\n    if(b<1.&&mod(distance(t, b),.6)>.5)\n    O.xyz = vec3(.5);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define _f(_x) (fract(_x))\n\n// main glide synth\nfloat gldsnth(float t) \n{\n  float tt = t * 4., ft = mod(tt, 1.);\n  float p = mod(t, 16.) < 8.? 420. : vec2(420,123.5)[int(tt) & 1];\n  float y = sin(_f(t * (mod(t, 1.) > .25 ? 1. : 2.))\n                * (6.283185 * p + exp(5.001 * sin(4. * t)))) * exp(-2. * ft);\n  return tanh(clamp(7. * y, -1., .1) * min(1., 40.1 * ft) * max(0., 1. - ft));\n}\n\n//distorted\nvec2 snth( float t ) \n{\n    \n  float p, dt = t, dt1 = t;\n  t*=8.;\n  float ft = _f(t);\n  p = vec3(210, 330, 112)[int(t) & 3];\n  dt *= p;\n  dt1 *= .5 * p;\n  return vec2(_f(dt), _f(dt1)) * min(1., ft) * max(0., 1. - ft);\n}\n\nvec2 mainSound(int samp, float t) \n{\n  vec2 snth_rv = vec2(0), gldsnth_rv = vec2(0);\n  float dlt = t,\n   ft = mod(1. * t, 1.), //long tail rev, \n   toff=.2, //dist synth time offset\n   sldlt = .063,//scale delay var\n   y[4], y1[4], \n   hm[8], //its doing something\n   pm[8] = float[8](-1., -1., 1., -1., 1., -1., 1., 1.);//flip polarity - out of my head\n\n  for (int i = 0; i < (2*16); ++i) \n  {\n    int iaps = i % 8 ;\n   \n    for (int c = 0; c < 4; ++c) \n    {\n       float dp = (1./float(c)) * float(i / 6 % 8); // damping equally distributed\n       dlt += exp2(min(sldlt, dp)) * sldlt; \n       hm[iaps] = dlt;\n\n       y[c] = gldsnth(dlt);\n       y[c] *= pm[iaps];\n      \n       c % 4 == 0 ? y1[c] += snth(toff + dlt).x : y1[c] += snth(toff + dlt).y;\n       y1[c] *= pm[iaps];\n\n    }\n    dlt = hm[iaps];\n    hm[iaps] *= -2./8.;\n    \n    // mixdown stereo\n    float env =  exp(-.5 * ft) * min(1., 40.1 * ft) * max(0., 1. - ft);\n    int stps = i / 8 % 8; \n    snth_rv += vec2(y[stps], y[1 + stps]) * env;\n    gldsnth_rv += vec2(y1[stps], y1[1 + stps]) * env;\n\n  }\n\n  return.7*( .05 * snth_rv + .5 * (gldsnth(.5 * t) \n        + .7 * (mod(t, 12.) > 10. ? gldsnth(.1 - t) : gldsnth(t)))\n        + (mod(t, 18.) > 10. ? \n          snth( toff + t) \n        + vec2(.7, 1) * (abs(sin(2.*t)+.5)* snth( toff + .5 * t))\n        + .2 * gldsnth_rv : vec2(0)));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3yW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 300, 347, 526], [550, 550, 591, 591, 993]], "test": "untested"}
{"id": "7l3yDM", "name": "Vase w/ Soft Shadow 2", "author": "fenix", "description": "Inspired by a vase I saw today at the Corning Museum of Glass, Corning, NY. I like how the ground lenses refract all the lenses on the other side. The color is on the outer glass surface and the lenses cut through it. Soft shadow rendered in buffer A.", "tags": ["sdf", "refraction", "shadows", "glass", "vase"], "likes": 14, "viewed": 292, "published": 3, "date": "1659909346", "time_retrieved": "2024-07-30T16:36:28.486356", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Buffer A renders all the rays that bounce off the table.\n//\n//  Marching code in common buffer derived from Liquid in glass by tmst:\n//      https://www.shadertoy.com/view/3tfcRS\n//\n//  Inspired by a vase I saw today at the Corning Museum of Glass. I like how the\n//  ground lenses refract all the lenses on the other side. The color here is on the\n//  outer glass surface and the lenses cut through it.\n//\n//  This is not-as-slow as my previous vase because the cuts do not overlap, so there\n//  is at most one cut needed per SDF step.\n//\n// ---------------------------------------------------------------------------------------\n\n// ===============================\n// Camera setup\n// ===============================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip)\n{\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid getCamera(in vec2 uv, out vec3 camPos, out vec3 nvCamDir) {\n    float animate = iTime;\n    vec2 mouseAng = vec2(animate * 0.17, PI*0.3 + 0.1*cos(animate * 0.27));\n    if (iMouse.z > 0.0)\n        mouseAng += vec2(8.0*iMouse.x / iResolution.x,0.8*iMouse.y / iResolution.y);\n        \n    float radius = 3.8 + 2.0 * cos(animate * 0.1);\n    camPos = vec3(0.0, 1.0, 0.0) + radius * SPHERICAL(mouseAng.x, mouseAng.y);\n\n    vec3 lookTarget = vec3(0.0, 0.8, 0.0);\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n}\n\n// ===============================\n// Main render\n// ===============================\n\nvec4 mainColor(vec2 fragCoord)\n{\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord / RES.xy;\n    getCamera(uv, camPos, nvCamDir);\n\n    vec4 color;\n    vec3 nvRayOut;\n    march(iChannel0, camPos, nvCamDir, color, nvRayOut);\n\n    return blendOnto(color, SKYBOX(nvRayOut));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = mainColor(fragCoord);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ===============================\n// Table render\n// ===============================\n\n// The table is completely matte, so rays bounce in every possible direction equally,\n// allowing us to completely precompute it.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 oldRes = texelFetch(iChannel0, ivec2(0, 0), 0);\n    bool init = oldRes.xyz != iResolution || iFrame == 0; // Init at the beginning or if the resolution changes\n    \n    if (init)\n    {\n        fragColor = vec4(GROUND_COLOR);\n        \n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            // Store the resolution in the first pixel\n            fragColor = vec4(iResolution, iFrame);\n        }\n    }\n    else\n    {\n        int framesSinceReset = iFrame - int(oldRes.w);\n        \n        vec4 oldColor;\n        oldColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n        // Shoot a ray in a random direction\n        vec2 camUV = (fragCoord.xy / iResolution.xy) * TABLE_SIZE + TABLE_MIN;\n        vec3 camPos = vec3(camUV.x, TABLE_HEIGHT, camUV.y);\n        vec3 nvRayCur = noise(ivec3(iFrame * int(fragCoord.x), int(fragCoord.y) * iFrame, int(fragCoord.x * fragCoord.y))).xyz;\n        nvRayCur = normalize(nvRayCur);\n        if (nvRayCur.y < 0.0) nvRayCur.y = -nvRayCur.y;\n\n        vec4 newColor;\n        vec3 nvRayOut;\n        march(iChannel0, camPos, nvRayCur, newColor, nvRayOut);\n        \n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = oldRes;\n        }\n        else\n        {\n            // Compute the average over time\n            fragColor = oldColor * float(framesSinceReset) / float(framesSinceReset + 1) + newColor / float(framesSinceReset + 1);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LAST_FRAME iChannel0\n#define SKYBOX(v) vec3(dot(v, vec3(-0.4, 1.0, 0.4)))\nconst vec2 TABLE_MIN = vec2(-15.0, -15.0);\nconst vec2 TABLE_MAX = vec2(2.0, 2.0);\nconst vec2 TABLE_SIZE = TABLE_MAX - TABLE_MIN;\n\n// ===============================\n// Generic Helpers/Constants\n// ===============================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define SQRT2INV 0.7071067811865475\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\n// Same as built-in 'refract' (cf. link) but replaces the case which would\n// normally result in 0 with a reflection (for total internal reflection)\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\nvec3 refractFix(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    return k < 0.0\n        ? reflect(I, N) // <- 'refract' returns 0 here\n    \t: eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\nfloat length2(vec3 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x*x;\n}\n\n// ===============================\n// Geometry definitions\n// ===============================\n\n#define BOUNDING_SPHERE_RADIUS 15.0\n\nfloat sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    return dot(p - planePoint, nvPlaneN);\n}\n\nfloat sdfInterval(float a, float b, float x) {\n    return abs(x - 0.5*(a+b)) - 0.5*(b-a);\n}\n\n// From https://iquilezles.org/articles/distfunctions\nfloat sdfSphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p - pos) - radius;    \n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdfInterior(vec3 p)\n{\n    return sdEllipsoid(p - vec3(0.0, 1.0, 0.0), vec3(0.9, 1.6, 0.9));\n}\n\nconst ivec2 DIVS = ivec2(15, 25);\nconst vec2 DIVS_REL = vec2(DIVS) / (2.0 * PI);\nconst vec2 DIVS_NOISE = vec2(0.2, 0.3);\nconst float CUT_DIST = 1.1;\n\nvec3 getCutPos(vec2 spherical)\n{\n    float sinX = sin(spherical.x);\n    float sinY = sin(spherical.y);\n    float cosX = cos(spherical.x);\n    float cosY = cos(spherical.y);\n\n    vec3 dir = vec3(sinY * cosX * 1.0, cosY * 1.9 + 0.8, sinY * sinX * 1.0);\n    return CUT_DIST * dir;\n}\n\nfloat sdExterior(vec3 p)\n{\n    p.y -= 0.8;\n    return sdEllipsoid(p, vec3(1.0, 1.9, 1.0));\n}\n\nfloat sdfGlass(vec3 p)\n{\n    float sd = sdExterior(p);\n\n    vec3 delta = p;\n    delta.y = (delta.y - 0.8) / 1.9;\n    vec2 spherical = vec2(atan(delta.z, delta.x), atan(length(delta.xz), delta.y));\n    spherical = (floor(spherical * DIVS_REL) + 0.6) / DIVS_REL;//vec2((floor(theta * THETA_DIVS) + 0.5) / THETA_DIVS, (floor(phi * PHI_DIVS) + 0.5) / PHI_DIVS)\n\n    if (spherical.y < 10.0 / DIVS_REL.y)\n    {\n        sd = max(sd, - sdfSphere(p, getCutPos(spherical), 0.17));\n    }\n    float vase = max(-sdfInterior(p), sd);\n    \n    return max(-p.y - 0.99, max(vase, p.y - 2.3));\n}\n\n#define SDF_N_EPS 0.005\n#define SDF_NORMAL(sdfFn, p) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0) ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0) ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0) ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0) ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS) ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS) )  \\\n    ))\n\n// ===============================\n// Marching, lighting/materials\n// ===============================\n\n// rendering engine forked from Liquid in glass by tmst https://www.shadertoy.com/view/3tfcRS\n#define SDF_EPS 0.01\n#define DSTEP_ADJUST_EPS 0.02\n#define STEPS 50\n\n#define LIGHT_COLOR vec3(1.0)\n\n#define GLASS_SURFACE_COLOR vec4(0.1, 0.0, 0.05, 0.2)\n\n#define IR_AIR 1.0\n#define IR_GLASS 1.5\n\n// Enums\n#define SUBSTANCE_AIR 0\n#define SUBSTANCE_GLASS 1\n\n#define TABLE_HEIGHT -1.0\nconst float GROUND_COLOR = 0.515;\n\nvec4 computeSpecular(\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    const float specularCoefficient = 0.8;\n    const float specularExponent = 80.0;\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular*vec4(LIGHT_COLOR, 1.0);\n}\n\nvoid march(in sampler2D tableSampler, in vec3 pRay, in vec3 nvRayIn, out vec4 color, out vec3 nvRayOut)\n{\n    // Light (in world coordinates)\n    vec3 pLightO = pRay + vec3(0.0, 10.0, 0.0);\n\n    // Light and camera (in object coordinates)\n\n    vec3 pCam = pRay;\n    vec3 pLight = pLightO;\n\n    // Ray while marching (in object coordinates)\n    vec3 pCur = pCam;\n    vec3 nvRayCur = nvRayIn;\n\n    color = vec4(0.0);\n    int curSubstance = SUBSTANCE_AIR;\n\n    int i=0;\n    for (; i<STEPS; i++) {\n\n        // Quick exits\n        // ----------------\n        vec3 centerToCur = pCur;\n        if (\n            (length2(centerToCur) > square(BOUNDING_SPHERE_RADIUS)) &&\n            (dot(nvRayCur, centerToCur) > 0.0)\n        ) {\n            if (nvRayCur.y < 0.0)\n                color = blendOnto(color, vec4(GROUND_COLOR, GROUND_COLOR, GROUND_COLOR, 1.0));\n            else\n                color = blendOnto(color, vec4(SKYBOX(nvRayCur), 1.0));\n            break;\n        }\n\n        if (color.a > 0.95) { break; }\n\t\t// ----------------\n\n        float sdGlass = sdfGlass(pCur);\n        vec3 dpStep = abs(sdGlass) * nvRayCur;\n\n        if (curSubstance == SUBSTANCE_AIR)\n        {\n            if (sdGlass < SDF_EPS)\n            {\n                vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur);\n\n                if (dot(nvGlass,nvRayCur) < 0.0) \n                {\n                    curSubstance = SUBSTANCE_GLASS;\n\n                    vec4 sColor = computeSpecular(\n                        nvGlass, normalize(pLight-pCur), normalize(pCam-pCur)\n                    );\n                    color = blendOnto(color, sColor);\n\n                    if (-sdExterior(pCur) < SDF_EPS * 0.1)\n                    {\n                        color = blendOnto(color, GLASS_SURFACE_COLOR);\n                    }\n\n                    // Schlick approximation\n                    float cosHitAngle = clamp(dot(nvGlass, -nvRayCur), 0.0, 1.0);\n                    float r0 = pow((IR_GLASS-IR_AIR)/(IR_GLASS+IR_AIR), 2.0);\n                    float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 3.0)); // Modified exponent 5 -> 3\n\n                    vec3 nvRefl = reflect(nvRayCur, nvGlass);\n                    color = blendOnto(color, valRefl*vec4(SKYBOX(nvRefl), 1.0));\n\n                    dpStep = sdGlass*nvRayCur;\n                    dpStep += -DSTEP_ADJUST_EPS*nvGlass;\n                    nvRayCur = refractFix(nvRayCur, nvGlass, IR_AIR/IR_GLASS);\n                }\n            }\n        }\n        else if (curSubstance == SUBSTANCE_GLASS)\n        {\n            vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur);\n            float sdGlassInv = -sdGlass;\n            vec3 nvGlassInv = -nvGlass;\n\n            dpStep = abs(sdGlassInv)*nvRayCur;\n\n            if (sdGlassInv < SDF_EPS && dot(nvGlassInv,nvRayCur) < 0.0)\n            {\n                curSubstance = SUBSTANCE_AIR;\n\n                if (-sdExterior(pCur) < SDF_EPS)\n                {\n                    color = blendOnto(color, GLASS_SURFACE_COLOR);\n                }\n                \n                dpStep = sdGlassInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlassInv;\n                nvRayCur = refractFix(nvRayCur, nvGlassInv, IR_GLASS/IR_AIR);\n            }\n        } \n\n        pCur += dpStep;\n        \n        if (pCur.y <= TABLE_HEIGHT)\n        {\n            float t = (TABLE_HEIGHT - pCur.y) / dpStep.y;\n            pCur += t * dpStep;\n            \n            vec3 tableColor;\n            if (any(lessThan(pCur.xz, TABLE_MIN)) || any(greaterThan(pCur.xz, TABLE_MAX)))\n            {\n                tableColor = vec3(GROUND_COLOR);\n            }\n            else\n            {\n                vec2 tableUV = (pCur.xz - TABLE_MIN) / TABLE_SIZE;\n                tableColor = texture(tableSampler, tableUV).xyz;\n                vec2 deltaFromSide = max(vec2(0), abs(tableUV - 0.5) - 0.4);\n                float distFromSide = max(deltaFromSide.x, deltaFromSide.y) * 10.0;\n                tableColor = mix(vec3(GROUND_COLOR), tableColor, 1.0 - distFromSide);\n            }\n            color = blendOnto(color, tableColor);\n            break;\n        }\n    }\n\n    // Convert ray direction from object to world coordinates\n    nvRayOut = nvRayCur;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3yDM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[998, 998, 1061, 1061, 1240], [1242, 1242, 1306, 1306, 1822], [1910, 1910, 1942, 1942, 2192], [2194, 2194, 2249, 2249, 2289]], "test": "untested"}
{"id": "ft3yWn", "name": "Day 958", "author": "jeyko", "description": "potato  t", "tags": ["mdtmjvm"], "likes": 14, "viewed": 308, "published": 3, "date": "1659883462", "time_retrieved": "2024-07-30T16:36:29.714073", "image_code": "// Fork of \"Day 957\" by jeyko. https://shadertoy.com/view/Nl3czM\n// 2022-08-03 08:27:34\n\n// Fork of \"Day 956\" by jeyko. https://shadertoy.com/view/7l3yz4\n// 2022-08-02 07:37:58\n\n// Fork of \"Day 955\" by jeyko. https://shadertoy.com/view/fttyR8\n// 2022-08-01 07:12:45\n\n// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\n\nfloat T;\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    T = initTime(iTime, U, R);\n    vec2 oU = U;\n    C *= 0.;\n    \n    \n    // pixelzie\n    float sc = 1./(1.+ 0.*max(5.*float(lightMode == 1.)*max(sin(T*2.),0.)*sin(T*0.5),0.));\n    \n    \n    // offset uv\n    float md = 1.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(T*md)),hash11(ceil(T*md)),fract(T*md)),0.1);\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    vec2 id;\n    quantid(nuv,vec2(0.0+ 0.04*hash11(floor(T*5. + 2000.)),0.001 + 0.04*hash11(floor(T*10.))),id);\n    \n    float db = sdBox(nuv,vec2(0.1,0.1)*-0.2 + 0.6*hash11(floor(T*10. + 2000.)) -  float(lightMode));\n    //float db = length(nuv) - 0. ;\n    float dbb;\n    \n    if(lightMode == 1.)\n        dbb= sdBox(nuv,vec2(0.25,0.25) + 0.5*hash11(floor(T*1.))*float(lightMode) );\n    else\n        dbb= -10e5;\n    \n    \n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    vec4 d = Td(uv);\n    \n    \n    /*\n    if(db > 0.){\n        d.xyz *= 0.;\n    }*/\n    //vec2 st = 0.4/R.xy + 0.1*sin(T)*float(hash11(floor(T)) < 1. && lightMode == 0.);\n    vec2 st = (140.4 + 0.*float(hash11(floor(T*2.)) < 0.5 && lightMode == 0.))/R.xy;\n    \n    int cmp = 0;\n    float l = \n        Tb(uv + vec2(st.x,0))[cmp]-(Tb(uv - vec2(st.x,0)))[cmp] +\n        Tb(uv + vec2(0,st.y))[cmp]-(Tb(uv - vec2(0,st.y)))[cmp] +\n        Tb(uv + vec2(st.xy))[cmp]-(Tb(uv - vec2(st.xy)))[cmp] +\n        Tb(uv + vec2(st.x,-st.y))[cmp]-(Tb(uv - vec2(st.x,-st.y)))[cmp]\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    //a.xz = vec4(l);\n    \n    \n    \n\n\n    C += b;\n    \n    \n    // C = mix(C,1.-C,abs(l));\n    \n    // britney\n    \n    C += d;\n    C = clamp(C,0.,1.);\n    \n    C = mix(C,d,d.z);\n    \n    //C *= Td(uv);\n        \n        \n    uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    if(lightMode == 0.){\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        p.y *= 0.01;\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.003;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(T*1.5 + ra*1.));\n        \n        if(mod(id.y+T,2.) == 0.){\n            if(r.y < 0.){\n                if(r.x < 0.9)\n                    d = abs(d) - 0.0004;\n                \n                C = mix(C,vec4(1),smoothstep(0.001,0.,d));\n                \n            } else if(r.x < 0.1){\n                C = mix(C,vec4(1),1.);\n                \n            }\n               \n        }\n         \n    }\n\n    if(dbb > 0.)\n        C = vec4(1);\n    {\n        // ui crosses\n        vec2 p = uv;\n        \n        vec2 sid = vec2(float(p.x > 0.),float(p.y > 0.))*2. - 1.;\n        p = abs(p) - vec2(0.45,0.2);\n        float md = 0.0156;\n        \n        float trig = fcondmore(T, 0.1,0.3);\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        vec2 sz = vec2(0.001,0.004 + trig);\n        float d = sdBox(p.xy,sz);\n        if(lightMode == 1.)\n            d = min(d,sdBox(p.xy,sz.yx)) ;\n        if(trig == 1.)\n            d = max(d,-sdBox(p.xy,vec2(0.003))) ;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(T*1.5 + ra*1.));\n        \n        if(abs(id.x) < 1. + trig*0. && abs(id.y) < 1. + hash12(sid + floor(T*4.))*6.*(lightMode*2.-1.)*(1. + trig*1. )){\n        \n            if(d < 0.){\n                C = vec4(1);\n                if(r.y < 0.4){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n\n                }    \n            }\n            \n               \n        } else if(abs(id.x) < 4. && abs(id.y) < 1. + hash12(sid + floor(T*4.) + 20.)*3.){\n            C = vec4(1);\n        } else{\n        \n            if(lightMode == 0.){\n                // ui coloured --blocks-- lines\n                vec2 p = uv;\n\n                vec2 md = vec2(0.01 + 0.0*hash11(floor(T)),0.07);\n\n                vec2 id = floor(p/md);\n                p = pmod(p,md); \n\n                float d = length(p.xy) - 0.004;\n\n                float ra = hash12(id + 10.);\n                vec2 r = hash22(id + 200. + floor(T*1.5 + ra*1.));\n\n\n                if(abs(uv.y) > 0.24 && abs(id.x) < 13. && sin(T + sin(r.y*3.)*4.)> 0.){\n                    C = vec4(1);\n                    if(r.y < 0.4){\n                        int cidx = int(r.x*4.*4.);\n                        vec3 c = palAppleII[cidx];\n\n                        c = rgb2hsv(c);\n                        c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                        C.xyz = c;\n\n                    }\n\n                }\n\n\n            }  \n        \n        }\n        \n        \n    }    \n    \n  \n    \n    vec3 n = hash33(vec3(U,mod(T,200.)));\n    vec3 nb = hash33(vec3(U,mod(T,5200.)));\n    \n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    float e = float(enva(T)>0.5);\n    e = float(fract(T*0.18) < 0.5);\n\n    uv = (oU - 0.5*R.xy)/max(R.x,R.y);\n    if(\n        e == 0.\n    ){\n        //if(uv.x < 0.)\n            //C = mix(C,1.-C,1.);\n    \n    }else {\n        if( fract(T*0.3) > 0.9)\n            C = 1.-C;\n    \n    }\n    //C = mod(Tb(U/R).x,1.)*vec4(1);\n    C = max(C,vec4(0.01));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat hash11(float p);\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n//float eeeeeeeeeeee;\n\n//#define iTime (iTime + floor(gl_FragCoord.y/200.)*0.4*)\n#define NO_INTERSECTION -1456.123456\n#define iTime (iTime + 100. + 60. + 20.)\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    //ro = -ro;\n    n = normalize(n);\n    //dot(n, ro + rd*t) = 0;\n    //(ro.x + rd.x*t)*n.x + (ro.y + rd.y*t)*n.y + (ro.z + rd.z*t)*n.z = 0\n    //ro.x*n.x + rd.x*t*n.x + ro.y*n.y + rd.y*t*n.y + ro.z*n.z + rd.z*t*n.z = 0\n    // t  = - (ro.x*n.x +  ro.y*n.y  + ro.z*n.z)/( rd.x*n.x + rd.y*n.y + rd.z*n.z ) \n    //return vec4(-(dot(ro,n))/dot(rd,n), n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(NO_INTERSECTION);\n    }\n}\n\n#define fcondless(t,c,l) float(fract(t*c) < l)\n#define fcondmore(t,c,l) float(fract(t*c) > l)\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n#define quant(v,a) floor(v/a)*a\n#define quantid(v,a,id)  id = floor(v/a);v = floor(v/a)*a; \n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n\n\n#define lightMode float(fract(iTime*0.1) <0.5 )\n#define hardMode(T) float(fract(T*0.15) >0.7 ) \n\n\nvec3 getRo(float t, vec2 m, vec2 r){\n    vec3 ro = vec3(0,-2,2);\n    //ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    ro.yz *= rot(sin(t)*0.4);\n    \n    //ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    \n    ro.xz *= rot((t + sin(t*1.4))*0.6);\n    \n    ro.xz *= rot(m.x/r.x);\n    ro.yz *= rot(m.y/r.x);\n    \n    ro *= 0.5;\n    \n    if(fract(t*0.167) < 0.33)\n        ro = vec3(0,4,0);\n    //if(fract(t*0.15)< 0.25)\n    ro.y *= 0.5;\n    return ro;\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt,float t){\n\n    //ro = vec3(,4,0) + 0.004;\n    float lm = float(fract(t*0.1) <0.5 );\n    lookAt =  vec3(0,0. + lm*0.1 - 2.4*0.,0) + 0.2*sin(t*vec3(1,0.8,0.9));\n    lookAt *= 0.8;\n    \n    \n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\n\n\n// iq\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n\n\nfloat initTime(float T, vec2 fc, vec2 res){\n    \n    float per = 0.05;\n    \n    float subdivs = (8. + 16.*hash11(floor(T/per)));\n    \n    \n    float subdivIdx = floor(fc.y/res.y*subdivs);\n    \n    float probEnv = fract((T - subdivIdx/subdivs*0.4)*per);\n    \n    \n    probEnv = clamp(probEnv*10.,0.,1.);\n    probEnv *= smoothstep(0.,0.1,probEnv);\n    probEnv *= 1. - smoothstep(0.9,1.,probEnv);\n    \n    \n    \n    if(hardMode(T) == 1.)\n        T -= subdivs*0.6*probEnv;\n    else\n        T += (subdivIdx)/subdivs*0.4*probEnv;\n    \n    \n    return T;\n}\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 8.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5*vec4(1,1.5,1,1);\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "float T;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    T = initTime(iTime, fragCoord, R);\n    \n    fragColor = vec4(0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// raymarch\n\nfloat T;\n\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat map(vec3 p){\n    vec3 op = p;\n    p.y += (T + sin(T))*0.4;\n    \n    if(lightMode == 0.)\n        p.xz *= rot(p.z + sin(T + p.z)*4.);\n    else\n        p.xz *= rot(p.y + sin(T + p.y)*3.);\n    \n    \n    float d = 10e5;\n    \n    float its = 2.;\n    for(float i = 0.; i < its; i++){\n        vec3 lp = p - vec3(cos(i/its*pi*2.),0,sin(i/its*pi*2.))*sin(T+i + sin(T + i))*1.;\n        \n        \n        if(lightMode == 1.)\n            d = min(d,dot(lp.xz,lp.xz));\n        else\n            d = min(d,length(lp.xz));\n    }\n    \n    return d + sin(p.y + T)*0.3*noise(p*2.*vec3(1.,0.1,4) + vec3(T + sin(T),0,0))*0.4 + smoothstep(2.,3.,abs(op.y));\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    T = initTime(iTime, U, R);\n    \n    float sc = 1.;\n    U = floor(U/sc)*sc;\n    \n    vec2 uv = (U-0.5*R.xy)/max(R.x,R.y)*(1. ) ;\n\n    vec3 ro = getRo(T, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(T);\n    //ro.xy *= rot(sin(T));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,T);\n    vec3 rd = lookAtMat * normalize(vec3(uv,0.5));\n    \n    \n    float t = 0.;\n    vec3 p = ro;\n    bool hit = false;\n    \n    float c = 0.;\n    float planeCnt = 1. + 4.*float(fract(iTime*0.12) > 0.2 || fract(iTime*0.2) < 0.2 );\n    \n    //\n    for(float i = 0.; i < planeCnt; i++){\n        vec3 pp = vec3(0,-i/planeCnt*0.5 - 0.,0);\n        \n        vec4 plane = intersectPlane(ro + pp, rd, vec3(0,1,0));\n        \n        vec3 hitP = ro + rd * plane.x;\n        \n        vec2 pUv = hitP.xz;\n        \n        #define xor(a,b) (int(a) ^ int(b))\n        #define fxor(a,b) float(xor(a,b))\n        \n        float epicSwirly = enva(T);\n        //epicSwirly = 0.;\n        if(hardMode(T) == 1.){\n        \n        } else {\n            //epicSwirly = enva(iTime);\n        }\n        \n        //epicSwirly = 0.;\n        if(epicSwirly < 0.6){\n            //pUv *= 10. + 40.*float(1.-lightMode)*hash11(floor(T*1.) + 20.);\n            pUv *= 20. + 140.*float(1.-lightMode);\n            \n            pUv.x = abs(pUv.x) -120.*(lightMode) ;\n            \n            pUv.y = -abs(pUv.y)- 1.;\n\n            float x = fxor(pUv.x,pUv.y);\n            //x = clamp(x,-100.,11114.);\n            \n            if(lightMode == 0. && fract(T*0.18) < 0.5){\n                pUv *= .15*8.;\n                pUv.xy += T;\n                x -= fxor(pUv.x,pUv.y);\n                c = x*0.8;\n                //c = mix(c,1.-c,x*(1.-0.*pow(hash11(floor(T)),0.06)));\n            }else{\n            \n                if(hash11(floor(T*0.25)) < 0.5)\n                    c = mod(x*0.04 + iTime,4.);\n                if(mod(c,1.) < 0.5)\n                    c = mix(c,1.-c,1. + x*(1. - 1.*pow(hash11(floor(T)),0.06)));            \n                    \n            }\n            //c = x*0.01;\n            \n            //x = mod(x,120.);\n            //c += mod(x*0.05 + iTime*5.,40.);\n            \n\n        } else{\n            vec2 qid = vec2(1);\n            \n            \n            pUv = quantid(pUv,(0.001 + 0.2*hash11(floor(T/0.5))*fcondless(T, 0.34,0.5)*0.06),qid);\n            \n            vec2 ppUv = vec2(0,length(pUv));\n            \n            ppUv.y = log(ppUv.y);\n            \n            float ll = ppUv.y;\n            \n            \n            float h = floor(hash11(floor(iTime))*5.);\n            float hb = pow(hash11(floor(iTime/2. + 200.)),0.4)*5.;\n            \n            \n            vec2 lpp = pUv*rot(sin(ppUv.y*(1. + hb) + T) + ppUv.y*5. + T+ i*4.);\n            \n            ppUv.x = atan(lpp.x,lpp.y);\n            \n            \n            \n            //vec2 md = vec2(1./(5. - 4.*floor(hash11(floor(iTime*12. + 1200.)))));\n            \n            //float hashp = floor(iTime);\n            //hashp = fract(hashp * .1031);\n            //hashp *= hashp + 33.33;\n            //hashp *= hashp + hashp;\n            //float h = fract(hashp);\n            \n            vec2 md = vec2(1./(1. + h));\n            vec2 id = floor(ppUv/md);\n            ppUv = pmod(ppUv,md);\n            \n            \n            \n            float d = length(ppUv.x);\n            \n            if(d < 0.04){\n                c += sin(i +1. + ppUv.y*200.*float(fract(T*0.5)>0.75) + (T*20. + ll*10. + id.x)*float(fract(T*0.25)<0.25));\n            } else {\n                c -= 1.*lightMode;\n            \n            }\n            break;\n            \n        }\n    }\n        \n    \n    \n    uv = U/R.xy*(1. );\n    \n    \n    vec2 st = 1.4/R.xy;\n   \n    float tPrev = Tb(uv).x;\n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x\n    ;\n    \n    \n    C.x = c;\n    C.y = l;\n    C.z = t;\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// dither\n\n\nfloat T;\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n\n    //T = initTime(iTime, U, R);\n    T = iTime;\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + int(fract(T*0.1) < 0.5)))).x;\n    \n    \n    float quant = 1.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    s = vec4(s.x);\n    \n    \n    \n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n   \n    vec3 Chsv = rgb2hsv(C.xyz);\n\n    vec3 hit = vec3(0);\n    float similarity = -0.;\n    for(int i = 0; i < 4*4; i++){\n        vec3 palC = palAppleII[i];\n        \n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float palMod = sin(T*(1. + float(fract(T*0.2)>0.8)*1. ) + C.x*(0.01 + lightMode)+ float(i))*3.;\n        palCHsv.b += palMod;\n        float localSimilarity = dot(palCHsv.b, Chsv.b);\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    \n    C = vec4(hit.xyzx);\n    \n}", "buffer_c_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ui\n\nfloat T;\n \nvec4 n14(float f){ return hash41(f); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (T * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(T + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (T + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((T - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    \n    float lim = n14(idx + 200.).x*15.;\n   \n   if(id.x > lim && id.x < 18.)\n       return -0.1;\n   if(abs(id.y) < 1. && id.x >= 0. && id.x < 16.   && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    char += floor(hash11(idx)*200.);\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (T + sin(id.x))*24.).y*pow(abs(sin(T + id.x*0.2 + idx)),5.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (T + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((T - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 3. - hash11(idx + 20.)*2.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    T = initTime(iTime, U, R);\n    \n    vec2 oU = U;\n    float sc = 1. + 4.*float(fract(T)<0.3)*float(fract(T*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    \n    float z = Ta(U/R.xy).z;\n    z = 1000000.;\n    //z = z;\n    \n    uv = (U - 0.5*R.xy)/min(R.y,R.x);\n    \n    vec3 ro = getRo(T, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(T);\n    //ro.xy *= rot(sin(T));\n    float rep = fract(T*0.15) < 0.25 ? 0.04 : 1./min(R.y,R.x);\n    \n    float idd = floor(uv.y/rep);\n    uv.y = floor(uv.y / rep)*rep; \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,T);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    C -= C;\n      \n   U = oU;\n   uv = (U - 0.5*R.xy)/max(R.y,R.x);\n    \n   // epic text\n   \n           for(float i = 0.; i < 1. - lightMode*10.; i++){\n            vec2 projPos = hash21(floor(i + iTime))*2. - 1.;\n            \n            projPos *= 0.5;\n            \n            vec2 lp = uv - projPos.xy;\n            \n            lp *= 79.4;\n\n            float md = 0.3;\n            float id = floor(lp.y/md);\n            if(id < 1. || id > 5. + sin(i)*1.)\n                continue;\n                \n                \n            lp.y = mod(lp.y,md);\n            float td = textb(lp, float[4*4](\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,96.,96.,96.\n                ), -0.5 , 0.2 , false, 0., 0.4 , true, id + i*40. + floor(iTime*10.));\n            C = mix(C,vec4(1),smoothstep(0.04,0.,td - 0.0));\n        }\n            \n   U = oU;\n    sc = 1. + 15.*float(fract(T)<0.3)*float(fract(T*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   \n   u += 1. - hash11(floor(T) + 200.)*1.8;\n   u *= 0.9 - hash11(floor(T))*0.1;\n   u*=0.51 + floor((hash11(floor(T/3.))*4.));\n   u.x /= 7.;\n   \n\n   \n   \n   \n    \n    //u += 1./3.;\n   if(u.x < 1. && u.y < 0.3 && u.x > 0. && u.y > 0. && fract(T) < 0.2 && sin(T) < 0.){\n       vec4 britney =  texture(iChannel1,u);\n       float dith = texture(iChannel2,oU.xy/vec2(textureSize(iChannel1,0).xy*(4 + 0*int(fract(T*0.1) < 0.2)))).x;\n    \n    \n        float quant = 2.;\n        float recipQuant = 1./quant;\n\n        vec4 s = Tb(uv);\n        vec4 currC = floor(s*quant)/quant;\n        vec4 nextC = clamp(currC + recipQuant,0.,1.);\n        float perc = fract(luma(s)*quant);\n\n\n\n\n        if(perc>dith){\n            britney = nextC;\n        } else{\n            britney = currC;\n        }\n        \n        britney.xyz = rgb2hsv(britney.xyz);\n        britney.xyz = hsv2rgbSmooth(britney.xyz*vec3(110.9,0.5,0.5) + vec3(1. + T,0.2,0.)).xyz;\n        C = britney;\n       C -= 1.- britney;\n       C.w = 1.;\n   } else {\n       C.w = 0.;\n   }\n   \n   \n    \n\n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}", "buffer_d_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3yWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[863, 863, 903, 903, 6176]], "test": "untested"}
{"id": "ft3yDM", "name": "7-Segment display counter", "author": "Zyphery", "description": "A 7-Segment display counter\nDIGITS are how many digits are displayed on screen\nBCD is the binary representation of the 7 segments to binary digits\n", "tags": ["7segment", "counter"], "likes": 4, "viewed": 263, "published": 3, "date": "1659879346", "time_retrieved": "2024-07-30T16:36:30.469055", "image_code": "#define DIGITS 5\n#define CURVEDEDGES true\n#define EDGETHICKNESS 0.03\n#define TILTED true\n#define TILTFACTOR 0.2\n#define COLOR vec3(0.8,0.05,0.1)\n#define FADECOLOR COLOR * 0.15\n\nbool rect(vec2 uv, vec2 pos, vec2 size)\n{\n    if(uv.x > pos.x && uv.x < pos.x + size.x)\n        if(uv.y > pos.y && uv.y < pos.y + size.y)\n            return true;\n    return false;\n}\n\nint line(vec2 uv, vec2 p0, vec2 p1, float len)\n{\n    vec2 pos = min(p0,p1);\n    vec2 size = max(p0,p1) - pos;\n    if(!rect(uv, pos, size))\n        return 0;\n    \n    float m = (p1.y-p0.y)/(p1.x-p0.x);\n    float b = p1.y-m*p1.x;\n    \n    vec2 d = vec2(\n    ((2.0*(m*(uv.y-b)+uv.x))/(m*m+1.0))-uv.x,\n    ((2.0*(m*(m*(uv.y-b)+uv.x)))/(m*m+1.0))+2.0*b-uv.y);\n    float dis=distance(d,uv)/2.0;\n    \n    if(dis <= len)\n        return 1;\n    \n    return 0;\n}\n\nint clm(int v)\n{\n    if(v >= 1)\n        return 1;\n    return 0;\n}\n\nint BCD[] = int[](95, 12, 118, 124, 45, 121, 123, 28, 127, 61);\n\nint outline(vec2 uv, int num)\n{\n    int BITS = BCD[num % 10];\n    int mask = 0;\n    \n    if(rect(uv, vec2(0.1,0.55), vec2(0.1,0.3))) {\n        mask++;\n        if((BITS & 1) != 0)\n            mask++;\n    }\n    \n    if(rect(uv, vec2(0.1,0.15), vec2(0.1,0.3))) {\n        mask++;\n        if((BITS & 2) != 0)\n            mask++;\n    }\n    \n    if(rect(uv, vec2(0.5,0.55), vec2(0.1,0.3))) {\n        mask++;\n        if((BITS & 4) != 0)\n            mask++;\n    }\n    \n    if(rect(uv, vec2(0.5,0.15), vec2(0.1,0.3))) {\n        mask++;\n        if((BITS & 8) != 0)\n            mask++;\n    }\n    \n    if(rect(uv, vec2(0.2,0.85), vec2(0.3,0.1))) {\n        mask++;\n        if((BITS & 16) != 0)\n            mask++;\n    }\n    \n    if(rect(uv, vec2(0.2,0.45), vec2(0.3,0.1))) {\n        mask++;\n        if((BITS & 32) != 0)\n            mask++;\n    }\n    \n    if(rect(uv, vec2(0.2,0.05), vec2(0.3,0.1))) {\n        mask++;\n        if((BITS & 64) != 0)\n            mask++;\n    }\n    \n    //mask += rect(uv, vec2(0.1,0.55), vec2(0.1,0.3)) * (BITS & 1);\n    //mask += rect(uv, vec2(0.1,0.15), vec2(0.1,0.3)) * (BITS & 2);\n    \n    //mask += rect(uv, vec2(0.5,0.55), vec2(0.1,0.3)) * (BITS & 4);\n    //mask += rect(uv, vec2(0.5,0.15), vec2(0.1,0.3)) * (BITS & 8);\n    \n    //mask += rect(uv, vec2(0.2,0.85), vec2(0.3,0.1)) * (BITS & 16);\n    //mask += rect(uv, vec2(0.2,0.45), vec2(0.3,0.1)) * (BITS & 32);\n    //mask += rect(uv, vec2(0.2,0.05), vec2(0.3,0.1)) * (BITS & 64);\n    \n    if(CURVEDEDGES) {    \n        mask -= line(uv, vec2(0.05, 0.6), vec2(0.65, 0.0), EDGETHICKNESS) * 64;\n        mask -= line(uv, vec2(0.05, 0.0), vec2(0.65, 0.6), EDGETHICKNESS) * 64;\n        mask -= line(uv, vec2(0.05, 1.0), vec2(0.65, 0.4), EDGETHICKNESS) * 64;\n        mask -= line(uv, vec2(0.05, 0.4), vec2(0.65, 1.0), EDGETHICKNESS) * 64;\n    }\n    \n    return mask;\n}\n\nint tenpow(int x)\n{\n    int z = 1;\n    for(int i = 0; i < x; i++)\n        z = z * 10;\n    return z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float value = iTime * 1.0;\n    \n    vec2 uv = (fragCoord/iResolution.x) * 0.7;\n    \n    uv *= float(DIGITS);\n    if(TILTED)\n        uv.x -= uv.y * TILTFACTOR - TILTFACTOR * 0.5;\n    float xVal = uv.x;\n    uv.x = mod(uv.x, 0.7);\n    \n    int xDif = (DIGITS - 1) - int(floor(xVal / 0.7));\n\n    vec3 col = vec3(0.0);\n    //col = floor(col * 10.0) / 10.0;\n    int oVal = outline(uv, int(value) / tenpow(xDif));\n    if(oVal > 0)\n        col = (oVal == 2) ? COLOR : FADECOLOR;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3yDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 218, 218, 359], [361, 361, 409, 409, 812], [814, 814, 830, 830, 879], [946, 946, 977, 977, 2778], [2780, 2780, 2799, 2799, 2881], [2883, 2883, 2938, 2938, 3448]], "test": "untested"}
{"id": "Nt3yWM", "name": "Simple not accurate ray tracing", "author": "mireq", "description": "Simple fast ray tracing with many simplifications", "tags": ["raytracing", "reflection", "shadow", "antialiasing", "fresnel"], "likes": 12, "viewed": 429, "published": 3, "date": "1659873563", "time_retrieved": "2024-07-30T16:36:31.231017", "image_code": "// Constants\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 1\n#endif\n\n#define M_PI 3.141592654\n#define MAX_REFLECTIONS 3\n#define MAX_DIST 10000.0\n\n// Render single item color\n#define renderItem(iName, sName, data) \\\n\tresult = iName(rayOrigin, rayDirection, data); \\\n\tif (result.dist > 0.00001 && result.dist <= dist) { \\\n\t\tfragColor = vec4(sName(rayOrigin, rayDirection, result), 1.0); \\\n\t\tdist = result.dist; \\\n\t}\n\n\n// Calculate reflected ray\n#define calcReflect(iName, rName, data) \\\n\tresult = iName(reflectOrigin, reflectDirection, data); \\\n\tif (result.dist > 0.00001 && result.dist <= dist) { \\\n\t\treflectStrength = rName(reflectOrigin, reflectDirection, result); \\\n\t\trayOrigin = reflectOrigin + reflectDirection * result.dist; \\\n\t\trayDirection = reflect(reflectDirection, result.norm); \\\n\t\tdist = result.dist; \\\n\t}\n\n\n// Scene definition\nconst vec4 spherePos = vec4(-0.9, 0.5, 1.0, 0.5);\nconst vec4 glassSpherePos = vec4(0.0, 0.5, 0.5, 0.5);\n\nconst vec3 lightAmbientIntensity = vec3(0.2, 0.2, 0.2);\nconst vec3 lightDiffuseIntensity = vec3(0.4, 0.4, 0.4);\nconst vec3 lightDiffuseDirection = normalize(vec3(1.0, 1.0, -1.0));\n\n// Index of refraction\nconst float ior = 1.4;\n\n\nstruct IntersectResult\n{\n\tfloat dist; // Distance from ray origin, negative - not intersecting\n\tvec3 norm; //Normal vector\n};\n\n\n// Sphere intersection (from outside and from inside)\nIntersectResult iSphereUniversal(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere, in bool outside) {\n\tvec3 oMinusC = rayOrigin - sphere.xyz;\n\tfloat b = dot(rayDirection, oMinusC);\n\tfloat c = dot(oMinusC, oMinusC) - sphere.w * sphere.w;\n\tfloat delta = b * b - c;\n\n\tif (delta < 0.0) {\n\t\treturn IntersectResult(-1.0, vec3(0.0));\n\t}\n\n\tfloat dist = -b;\n\tif (outside) {\n\t\tdist -= sqrt(delta);\n\t}\n\telse {\n\t\tdist += sqrt(delta);\n\t}\n\tvec3 nor = normalize((rayOrigin + rayDirection * dist) - sphere.xyz);\n\treturn IntersectResult(dist, nor);\n}\n\n\nIntersectResult iSphere(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere) {\n\treturn iSphereUniversal(rayOrigin, rayDirection, sphere, true);\n}\n\nIntersectResult iSphereInside(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere) {\n\treturn iSphereUniversal(rayOrigin, rayDirection, sphere, false);\n}\n\n\n// Sphere shading\nvec3 sSphere(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\t// Difuse attentuation\n\tfloat attentuation = dot(res.norm, lightDiffuseDirection);\n\t// Diffuse intensity\n\tvec3 diffuse = lightDiffuseIntensity * clamp(attentuation, 0.0, 1.0);\n\t// Combined with ambient light\n\treturn lightAmbientIntensity + diffuse;\n}\n\n\n// Reflection intensity calculation\nfloat rSphere(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\t// Fresnel factor\n\tfloat fresnel = pow(max(1.0 - dot(res.norm, -rayDirection), 0.0), 3.5);\n\t// Constant factor\n\tconst float metalic = 0.05;\n\t// Combined reflection intensity\n\treturn clamp(fresnel + metalic, 0.0, 1.0);\n}\n\n\n// Plane intersection (position is y coordinate)\nIntersectResult iPlane(in vec3 rayOrigin, in vec3 rayDirection, in float position)\n{\n\treturn IntersectResult(\n\t\t(position - rayOrigin.y) / rayDirection.y, // Plane in height y\n\t\tvec3(0.0, 1.0, 0.0) // Normal always facing up\n\t);\n}\n\n\n// Shade plane\nvec3 sPlane(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\t// Intersection position\n\tvec3 pos = rayOrigin + rayDirection * res.dist;\n\t// Distance to sphere\n\tfloat dist = length(pos - spherePos.xyz);\n\t// Apparent angle size - https://www.neoprogrammics.com/sphere_angular_diameter/\n\tfloat angle = 2.0 * acos(sqrt(dist*dist - spherePos.w*spherePos.w) / dist);\n\t// (2*pi*(1-cos(angle/2)))/(4*pi)\n\tfloat shadow = cos(angle / 2.0); // Shadow factor\n\t\n\t// Same calculation for second sphere\n\tdist = length(pos - glassSpherePos.xyz);\n\tangle = 2.0 * acos(sqrt(dist*dist - glassSpherePos.w * glassSpherePos.w) / dist);\n\n\t// (Not correctly) combined shadow factor\n\tshadow = shadow * cos(angle / 2.0);\n\n\t// Checker color\n\tfloat color = mod(floor(pos.x) + floor(pos.z), 2.0);\n\t// Combined grayed checker collor disappearing in distance 20-100\n\treturn vec3(color * 0.8 + 0.1) * shadow + smoothstep(20.0, 100.0, res.dist);\n}\n\n\n// Constant reflection factor\nfloat rPlane(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\treturn 0.2;\n}\n\n\nIntersectResult iBackground(in vec3 ro, in vec3 rd, in float dummy)\n{\n\t// Maximal distance, any normal direction\n\treturn IntersectResult(MAX_DIST, rd);\n}\n\n\nvec3 sBackground(in vec3 ro, in vec3 rd, in IntersectResult res)\n{\n\t// Formula from here https://www.shadertoy.com/view/NtjcW3\n\treturn cos(rd) * vec3(.8, .7, 1.1) * smoothstep(0.0, 0.1, rd.y) + vec3(smoothstep(-0.1, 0.0, -rd.y));\n}\n\n\n// Construct camera matrix\nmat3 lookAt(in vec3 cameraPos, in vec3 lookAtPoint)\n{\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // Forward vector\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // Right vector\n\tvec3 cu = normalize(cross(cd, cr)); //Top vector\n\treturn mat3(cr, cu, cd);\n}\n\n\nvec4 rayReflect(inout vec3 reflectOrigin, inout vec3 reflectDirection)\n{\n\t// Output color and intensity (default zero)\n\tvec4 fragColor = vec4(0.0);\n\n\t// Macro renderItem needs reflectOrigin and reflectDirection names\n\tvec3 rayOrigin = reflectOrigin;\n\tvec3 rayDirection = reflectDirection;\n\tIntersectResult result;\n\tfloat dist = MAX_DIST;\n\n\t// Default value - no reflection (if don't hit any sufrace)\n\tfloat reflectStrength = 0.0;\n\n\t// Calculate reflection strength and ray direction\n\tcalcReflect(iPlane, rPlane, 0.0);\n\tcalcReflect(iSphere, rSphere, spherePos);\n\tcalcReflect(iSphere, rSphere, glassSpherePos);\n\n\tif (reflectStrength < 0.0001) { // Too low strength\n\t\treturn fragColor;\n\t}\n\n\t// Reset distance\n\tdist = MAX_DIST;\n\n\t// Render from new ray position\n\trenderItem(iSphere, sSphere, spherePos);\n\trenderItem(iSphere, sSphere, glassSpherePos);\n\trenderItem(iPlane, sPlane, 0.0);\n\trenderItem(iBackground, sBackground, 0.0);\n\n\t// Update ray (propagate to outer function)\n\treflectOrigin = rayOrigin;\n\treflectDirection = rayDirection;\n\n\t// Output color and intensity\n\treturn vec4(fragColor.rgb, reflectStrength);\n}\n\n\nvec4 rayRefract(inout vec3 refractOrigin, inout vec3 refractDirection)\n{\n\t// Similar to rayReflect\n\tvec3 rayOrigin = refractOrigin;\n\tvec3 rayDirection = refractDirection;\n\n\tvec4 fragColor = vec4(0.0);\n\n\tIntersectResult result;\n\tfloat dist = MAX_DIST;\n\n\t// Výpočet vzdialenosti k objektom\n\tresult = iSphere(rayOrigin, rayDirection, spherePos);\n\tif (result.dist > 0.00001) { dist = min(dist, result.dist); }\n\tresult = iPlane(rayOrigin, rayDirection, 0.0);\n\tif (result.dist > 0.00001) { dist = min(dist, result.dist); }\n\n\tfloat refractStrength = 0.0;\n\n\tresult = iSphere(rayOrigin, rayDirection, glassSpherePos);\n\tif (result.dist > 0.0001 && result.dist < dist) {\n\t\t// Hardcode strength for sphere\n\t\trefractStrength = 0.8;\n\n\t\t// Compute new ray (inside sphere)\n\t\trefractOrigin = rayOrigin + rayDirection * result.dist;\n\t\t// Refraction from air to glass\n\t\trefractDirection = refract(rayDirection, result.norm, 1.0 / ior);\n\n\t\t// Compute intersection inside sphere\n\t\tresult = iSphereInside(refractOrigin, refractDirection, glassSpherePos);\n\t\t\n\t\t// Compute new ray outside sphere\n\t\trefractOrigin = refractOrigin + refractDirection * result.dist;\n\t\t// Refraction from glass to air\n\t\trefractDirection = refract(refractDirection, -result.norm, ior / 1.0);\n\n\t\t// Update ray\n\t\trayOrigin = refractOrigin;\n\t\trayDirection = refractDirection;\n\n\t\t// Reset distance\n\t\tdist = MAX_DIST;\n\n\t\t// Render other objects\n\t\trenderItem(iSphere, sSphere, spherePos);\n\t\trenderItem(iPlane, sPlane, 0.0);\n\t\trenderItem(iBackground, sBackground, 0.0);\n\t}\n\n\treturn vec4(fragColor.rgb, refractStrength);\n}\n\n\nvec4 rayTrace(in vec3 rayOrigin, in vec3 rayDirection)\n{\n\tvec4 fragColor = vec4(0.0);\n\n\t// Max distance on beginning\n\tfloat dist = MAX_DIST;\n\tIntersectResult result;\n\n\t// Render objects\n\trenderItem(iBackground, sBackground, 0.0);\n\trenderItem(iPlane, sPlane, 0.0);\n\trenderItem(iSphere, sSphere, spherePos);\n\trenderItem(iSphere, sSphere, glassSpherePos);\n\n\t// Secondary rays used to compute reflection and refraction\n\tvec3 reflectOrigin = rayOrigin;\n\tvec3 reflectDirection = rayDirection;\n\tfloat reflectStrength = 1.0;\n\tvec3 refractOrigin = rayOrigin;\n\tvec3 refractDirection = rayDirection;\n\tfloat refractStrength = 1.0;\n\n\t// Compute reflection / refraction\n\tfor (int i = 0; i < MAX_REFLECTIONS; i++) {\n\t\t// Color and strength calculated\n\t\tvec4 reflectColor = rayReflect(reflectOrigin, reflectDirection);\n\t\tvec4 refractColor = rayRefract(refractOrigin, refractDirection);\n\t\treflectStrength *= reflectColor.a;\n\t\trefractStrength *= refractColor.a;\n\t\t// Break cycle if strength is too low\n\t\tif (reflectStrength < 0.001 && refractStrength < 0.001) {\n\t\t\tbreak;\n\t\t}\n\t\t// Mix colors\n\t\tfragColor.rgb = mix(fragColor.rgb, refractColor.rgb, refractStrength);\n\t\tfragColor.rgb += reflectColor.rgb * reflectStrength;\n\t}\n\n\treturn fragColor;\n}\n\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Calculate coordinates in interval [-0.5, 0.5]\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n\n\t// Camera properties\n\tvec3 lookAtPoint = vec3(sin(iTime / 3.5) * 0.5 - 0.2, 0.5, 0.75 + sin(iTime / 11.0) * 0.5);\n\tvec3 rayOrigin = vec3(sin(iTime) * 2.0, sin(iTime / 2.0) * 0.5 + 0.75, cos(iTime) * 2.0);\n\n\t// Calculate camera matrix\n\tmat3 cameraMatrix = lookAt(rayOrigin, lookAtPoint);\n\n\t// Ray direction and zoom factor\n\tvec3 rayDirection = cameraMatrix * normalize(vec3(uv, 0.8));\n\n\tfragColor = rayTrace(rayOrigin, rayDirection);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(0.0);\n\n\t// Antialiasing\n\tconst float fraction = 1.0 / float(AA);\n\tconst float fraction2 = fraction / float(AA);\n\tfor (int i = 0; i < AA; i++) {\n\t\tfor (int j = 0; j < AA; j++) {\n\t\t\tvec4 color = vec4(0.0);\n\t\t\tvec2 shift = vec2(\n\t\t\t\tfloat(i) * fraction + float(AA - j - 1) * fraction2,\n\t\t\t\tfloat(j) * fraction + float(i) * fraction2\n\t\t\t);\n\t\t\trender(color, fragCoord + shift);\n\t\t\tfragColor += clamp(color, 0.0, 1.0);\n\t\t}\n\t}\n\n\tfragColor = fragColor / float(AA * AA);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3yWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1308, 1362, 1470, 1470, 1902], [1905, 1905, 1987, 1987, 2054], [2056, 2056, 2144, 2144, 2212], [2215, 2233, 2312, 2336, 2564], [2567, 2603, 2683, 2702, 2904], [2907, 2956, 3040, 3040, 3186], [3189, 3204, 3282, 3308, 4135], [4138, 4168, 4247, 4247, 4262], [4265, 4265, 4334, 4377, 4418], [4421, 4421, 4487, 4547, 4652], [4655, 4682, 4735, 4735, 4942], [4945, 4945, 5017, 5063, 6057], [6060, 6060, 6132, 6158, 7629], [7632, 7632, 7688, 7688, 8858], [8861, 8861, 8913, 8963, 9486], [9489, 9489, 9544, 9544, 10026]], "test": "untested"}
{"id": "sltyDN", "name": "color fusion 7", "author": "FabriceNeyret2", "description": "supposed to appear plain grey.\nIf not, your monitor is probably incorrectly tuned.\n( only 0 or 1 values are used, no gamma/sRGB conversion involved ).", "tags": ["color", "gamma", "monitor", "perception", "fusion", "persistance", "pov"], "likes": 7, "viewed": 259, "published": 3, "date": "1659866343", "time_retrieved": "2024-07-30T16:36:33.509925", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y;\n    int  t = iFrame%2;\n    if (U.y<0.) t = ( int(u.y) + int(u.x) + t ) % 2;\n    O = length(U) > .7 \n            ? t > 0 ? vec4(1,0,0,1) : vec4(0,1,1,1) \n            : t > 0 ? vec4(0,1,0,1) : vec4(1,0,1,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sltyWN", "name": "linear interpolation animation", "author": "yasuo", "description": "linear interpolation animation test", "tags": ["linearinterpolation"], "likes": 10, "viewed": 275, "published": 3, "date": "1659859897", "time_retrieved": "2024-07-30T16:36:34.452404", "image_code": "#define MAX_STEPS 128\n#define MAX_DIST 128.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define DATA_SIZE 8\n#define MOUSE 0\n\nconst vec3 targets0[DATA_SIZE] = vec3[](\n    vec3(0.,0.,0.),vec3(0.1,0.,0.),vec3(0.2,0.,0.),vec3(0.2,0.1,0.),\n    vec3(0.2,0.2,0.),vec3(0.2,0.2,0.1),vec3(0.2,0.2,0.2),vec3(0.1,0.2,0.2)\n); \n\nconst vec3 targets1[DATA_SIZE] = vec3[](\n    vec3(0.,0.,0.),vec3(0.0,0.0,0.1),vec3(0.0,0.0,0.2),vec3(0.0,0.1,0.2),\n    vec3(0.0,0.2,0.2),vec3(0.0,0.2,0.1),vec3(0.0,0.2,0.0),vec3(0.0,0.1,0.0)\n); \n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nvec2 boxAnimation(float t, int index, vec3[DATA_SIZE] targets, vec3 p){\n    vec3 pos = vec3(0.0);\n    vec3 size = vec3(0.05);\n    float d = B3D(p,size);\n    \n    vec2 res = vec2(d, 0);\n    \n    int len = targets.length();\n    for(int i = 1; i<len; i++){\n        if(index<len-i){\n            pos = mix(targets[index],targets[index+1],t);\n        } else {\n            pos = targets[len-i];\n        }\n\n        d = B3D(p-pos,size);\n        \n        int cindex = int(mod(float(i),2.));\n        \n        vec2 res2 = vec2(d, cindex);\n        res = combine(res,res2);\n    }\n    return res;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.y+=cos(p.x*3.0+iTime*2.0)*0.3*cos(p.z*3.0+iTime*1.5)*0.5;\n    p-=vec3(0.0,0.0,1.0);\n    float d = p.y;\n    d = max(abs(p.z)-0.2,d);\n    d = max(abs(p.y)-0.01,d);\n    vec2 res = vec2(d,2.0);\n    \n    p = prevP;\n    p.yz *= Rot(-radians(iTime*20.0-45.));\n    p.xz *= Rot(radians(iTime*20.0-45.));\n    \n    p = abs(p);\n    \n    float it = iTime+5.;\n    float speed = 5.0;\n    float t = mod(it*speed,30.);\n    float t2 = mod(it*speed,1.);\n    \n    int index = int(t);\n    \n    vec2 res2 = boxAnimation(t2,index,targets0,p);\n    vec2 res3 = boxAnimation(t2,index,targets1,p);\n    res = combine(res,combine(res2,res3));\n    \n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(0,0,0));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.3)*diff;\n    diffCol += col*vec3(0.9)*skyDiff;\n    diffCol += col*vec3(0.7)*bounceDiff;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == 0){\n        vec3 c = vec3(0.3);\n        col = diffuseMaterial(n,rd,p,c);\n    } else if(mat == 1){\n        vec3 c = vec3(0.6);\n        col = diffuseMaterial(n,rd,p,c);\n    } else if(mat == 2){\n        vec3 c = 0.5 + 0.5*cos(iTime+p+vec3(0,1,2));\n        col = diffuseMaterial(n,rd,p,c);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0.0, -1.2);\n    if(iMouse.z>0. && MOUSE == 1){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = mix(vec3(1.0),vec3(0.6), length(uv)-0.01);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );\n    \n    uv+=mod(iTime,5.)*2.0;\n    col+=noise2d(uv*100.0)*0.05;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 689, 710, 710, 844], [846, 846, 874, 874, 1377], [1380, 1380, 1416, 1416, 1458], [1460, 1460, 1487, 1487, 1541], [2128, 2128, 2150, 2150, 2818], [2820, 2820, 2878, 2878, 3145], [3147, 3147, 3171, 3171, 3372], [3374, 3374, 3416, 3416, 3611], [3613, 3613, 3670, 3670, 4146], [4148, 4148, 4207, 4207, 4536], [4538, 4538, 4595, 4595, 5444]], "test": "untested"}
{"id": "NldyDN", "name": "SphericalD", "author": "0xBAMA", "description": "was messing around with something to do backgrounds for rays that escape in a simple raytracer\n\nnoticed that there's an iDate uninform in shadertoy, used that for seeding a base color", "tags": ["hash", "date", "sphericalcamera"], "likes": 1, "viewed": 66, "published": 3, "date": "1659840904", "time_retrieved": "2024-07-30T16:36:35.324074", "image_code": "#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n// from wrighter https://www.shadertoy.com/view/WlfyRs\nvec3 GetRdSpherical ( vec2 uv ) {\n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    uv += 0.5;\n    uv.y *= 3.141592;\n    // parametrized sphere\n    return vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n}\n\nuint WangHash ( inout uint seed ) {\n\tseed = uint( seed ^ uint( 61 ) ) ^ uint( seed >> uint( 16 ) );\n\tseed *= uint( 9 );\n\tseed = seed ^ ( seed >> 4 );\n\tseed *= uint( 0x27d4eb2d );\n\tseed = seed ^ ( seed >> 15 );\n\treturn seed;\n}\nfloat RandomFloat ( inout uint wangState ) { return float( WangHash( wangState ) ) / 4294967296.0; }\nvec3 DateBasedColor () {\n    uint seed = uint( iDate.x ) + 451u * uint( iDate.y ) + 1984u * uint( iDate.z );\n    return vec3( RandomFloat( seed ), RandomFloat( seed ), RandomFloat( seed ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord / iResolution.xy ) - 0.5;\n    vec3 dir = GetRdSpherical( uv );\n    dir.xy = rot( iDate.a ) * dir.xy;\n    dir.yz = rot( iDate.a * 1.618 ) * dir.yz;\n    // compute a color\n    vec3 base = DateBasedColor();\n    vec3 color = vec3( base.r, 0.0, 0.0 ) * abs( dot( dir, vec3( 0.0, 1.0, 0.0 ) ) ) +\n                 vec3( 0.0, base.g, base.b ) * sin( 5.0 * dot( dir, vec3( 1.0, 0.0, 0.0 ) ) ) +\n                 vec3( 0.0, 0.0, base.b ) * abs( cos( dot( dir, vec3( 0.0, 0.0, 1.0 ) ) * 4.0 ) );\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 106, 139, 159, 336], [338, 338, 373, 373, 563], [564, 564, 608, 608, 664], [665, 665, 689, 689, 857], [859, 859, 916, 916, 1466]], "test": "untested"}
{"id": "fttyWN", "name": "city 2d-b", "author": "jorge2017a2", "description": "city 2d-b", "tags": ["city2db"], "likes": 5, "viewed": 191, "published": 3, "date": "1659830956", "time_retrieved": "2024-07-30T16:36:36.587695", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 Luna(vec2 p, vec3 colOut)\n{   float d1= sdCircle( p,2.0);\n    colOut= DrawFigBorde(vec3(0.7), colOut, d1);\n    return colOut;    \n}\n\nvec3 nubeA(vec2 p, vec3 colOut)\n{  p=vec2(p.y-2.0,p.x);\n   float d1=3.0*sin(p.x*0.25)+1.0*sin(p.x*0.5);\n   float d2=6.0*cos(p.x*4.0);\n   float d3= sdCircle( p-vec2(d1,d2),1.0 );\n    d1+=p.y+d3;\n    d2+=p.y+2.0+1.5*sin(p.y+p.x+iTime);\n    float duni= differenceSDF(d1, d2);\n    //16/9 or 1.77778\n    float aspect = iResolution.x / iResolution.y;\n     //Amount of smoothness for anti-aliasing\n    float px = 2.0*aspect/iResolution.x;\n    float sh3=smoothstep(px,-px,duni);\n    colOut= mix(colOut,vec3(0.0),sh3);\n    return colOut;\n}\n\n\nvec3 drawGradient(in vec2 v_p)\n{ return mix( vec3(0.0,0.3,0.7), vec3(1.0,0.8,0.7), 1.0-v_p.y + 0.7); }\n\nvec3 GraficarEdificioCol(vec2 p, vec3 colIn, vec3 colOut)\n{  float t=0.0;\n    float x=p.x;\n    float fx1=2.+2.*sin(floor(x+t)*4321.);\n    float y=p.y+fx1;\n    vec3 col= DrawFigBorde(colIn, colOut, y);\n    return col;\n}\n\nvec3 getColor(float c){\n   float r = cos((c-0.75)*PI);\n   float g = cos((c-0.55)*PI);\n   float b = cos((c-0.25)*PI);\n   return vec3(r,g,b);\n}\n\nvec3 estrella(vec2 p, vec3 colOut)\n{\n   float r = 5.5; \n   vec2 uv=p;\n   float d1= sdCircle( p,0.015);\n   float v = r/(d1);\n   \n   vec3 luna= getColor(0.916)*v; \n   colOut= DrawFigBorde(luna, colOut, d1);\n   return luna;\n   \n}  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    \n    vec2 st = fragCoord.xy / min(iResolution.x, iResolution.y) ;\n    float t=iTime;\n    vec2 st0=st;\n    st+=vec2( t*0.5,0.0+0.15*sin(t));\n    \n    vec2 p=st;\n\t\n    \n    vec3 col=vec3(1.0);\n    col= nubeB(st, col);\n    col*= drawGradient(p+ vec2(0.0,0.75));\n    col= Luna(uv-vec2(0.0,8.0), col);\n    \n    col= nubeA(uv-vec2(0.0,8.0), col);\n    uv.y+=2.0*sin(t+cos(t));\n    uv.x= opRep1D(uv.x+t*2.0, 20.0 );\n    col= nubeA(uv-vec2(0.0,8.0), col);\n    \n    uv=uv0;\n    float ts=3.0*sin(t);\n    if( ts>0.0)\n    col=(col+estrella(uv-vec2(0.0,8.0), col))/2.0;\n    col= GraficarEdificioCol(uv-vec2(0.0-iTime,2.5), vec3(0.25,0.2,1.0)*0.5, col);\n    col= GraficarEdificioCol(uv-vec2(0.0,2.0), vec3(0.5,0.2,0.5), col);\n    col= GraficarEdificioCol(uv-vec2(0.0,1.0), vec3(0.25,0.2,1.0), col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "\n////------------\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n////------------\n//nube\n//https://www.glslsandbox.com/e#82722.0\nfloat random( vec2 v ) \n{\treturn fract(sin(dot(v, vec2(114.0, 514.0))) * 1919810.0) * 2.0 - 1.0; }\n\nfloat random1d( float  v ) \n{\treturn fract(sin(dot( vec2(v,v), vec2(114.0, 514.0))) * 1919810.0) * 2.0 - 1.0; }\n\nfloat noise( vec2 v, float octave ) {\n\tvec2 maj = floor(v * pow(2.0, octave));\n\tvec2 sub = fract(v * pow(2.0, octave));\n\tfloat v00 = random(maj);\n\tfloat v10 = random(maj + vec2(1.0, 0.0));\n\tfloat v01 = random(maj + vec2(0.0, 1.0));\n\tfloat v11 = random(maj + vec2(1.0, 1.0));\n\tvec2 u = smoothstep(0.,1.,sub);\n\t\n\treturn mix(v00, v10, u.x) +\n\t\t(v01 - v00)* u.y * (1.0 - u.x) +\n\t\t(v11 - v10) * u.x * u.y;\n}\n\nvec3 nubeB(in vec2 fragCoord, vec3 colOut )\n{\n    vec2 st = fragCoord;\n \tfloat v = 0.0;\n\tfor (int i = 0; i < 10; i ++) {\n\t\tv += noise(st, float(i)) / pow(2.0, float(i));\n\t}\n   return   vec3(v) * 0.5 + 0.5;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 332, 332, 377], [383, 383, 430, 430, 457], [458, 458, 501, 501, 528], [529, 529, 577, 577, 605], [607, 607, 669, 669, 798], [801, 801, 835, 835, 930], [932, 932, 964, 964, 1068], [1070, 1070, 1103, 1103, 1600], [1603, 1603, 1635, 1635, 1705], [1707, 1707, 1766, 1766, 1925], [1927, 1927, 1950, 1950, 2068], [2070, 2070, 2106, 2106, 2296], [2300, 2300, 2357, 2357, 3392]], "test": "untested"}
{"id": "NtccWN", "name": "procedural cat eye mk2", "author": "Artemis152", "description": "procedural cat eye refined", "tags": ["raymarching"], "likes": 13, "viewed": 365, "published": 3, "date": "1659814360", "time_retrieved": "2024-07-30T16:36:37.809428", "image_code": "//dark mode\n//#define COOOOOL\n\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST 0.0023\n\n#define PI 3.141592\n\n//size 0 to 1\n#define SIZE .9\n//#define DIL 2\n#define BUMP 0.065\n\n//don't change\n#define CORNEA 0.5\n\n\nfloat rand(vec2 n) {     return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\nfloat box(vec3 p, float e)\n{\n    vec3 d = abs(p) - e;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat cust(vec3 p)\n{\n    return length(p) - .5;\n}\n\nvec3 pol2Cart(float rX, float rY, float d)\n{\n    return normalize(vec3(\n        sin(rX),\n        sin(rY),\n        cos(rX)\n    )) * d;\n}\n\nfloat eye(vec3 ro, vec3 rd)\n{\n    float dS, dO;\n    vec3 p;int it = 0;\n    for(; it < MAX_STEPS; it++)\n    {\n        p = ro + rd * dO;\n        p.x -= smoothstep(0.4, 0.8, p.x) * BUMP;\n        //dS = cust(p);\n        dS = sphere(p, 1.);\n                \n        dO += dS;\n                \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nfloat corneaDist(vec3 p)\n{\n    return max(sphere(p, 1.), (CORNEA - p.x \n//        - (smoothstep(0., 0.3, abs(1.-p.y)) + 1.) * 0.12\n    ));\n}\n\nfloat cornea(vec3 ro, vec3 rd, float bump, float d)\n{\n    float dS, dO;\n    vec3 p;int it = 0;\n    for(; it < MAX_STEPS; it++)\n    {\n        p = ro + rd * dO;\n        p.x -= smoothstep(0.4, 0.8, p.x) * BUMP;\n        //p.x = min(p.x, 0.);\n        p.x -= bump;\n        //dS = cust(p);\n        dS = corneaDist(p) * d;\n                \n        dO += dS;\n                \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    //dO += texture(iChannel1, p.zy).r * 0.02;\n    return dO;\n}\n\n\nvec3 corneaNormal(vec3 p)\n{\n\tfloat d = corneaDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        corneaDist(p-e.xyy),\n        corneaDist(p-e.yxy),\n        corneaDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 eyeNormal(vec3 p)\n{\n\tfloat d = sphere(p, 1.);\n    vec2 e = vec2(.04, 0);\n    \n    vec3 n = d - vec3(\n        sphere(p-e.xyy, 1.),\n        sphere(p-e.yxy, 1.),\n        sphere(p-e.yyx, 1.));\n    \n    return normalize(n);\n}\n\nfloat shade(vec3 n)\n{\n    return dot(n, -normalize(vec3(-1.1,-1.,.5)));\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\n//veins https://www.shadertoy.com/view/7l3cD4\n#define THIC 0.3\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat getLine(vec2 uv, vec2 offset, float rot)\n{\n    uv = rotate(uv, rot);\n    uv *= 20.;\n    uv += offset;\n    float n = noise(uv*vec2(.9, .4));\n    uv.y += n - .4;\n\n    float col = 1.0;\n    \n    if(abs(uv.y) > THIC)\n        col = 0.;\n        \n    col = smoothstep(THIC, -.1, abs(uv.y));\n        \n    return col;\n}\n\nfloat getVein(vec2 uv)\n{\n    uv *= PI/2.;\n    float f;\n    \n    for(int i = 0; i < 80; ++i)\n    {\n        float fi = float(i);\n        f += getLine(uv, vec2(.5 + fi, noise(fi) * 50. - 25.), (float(i*60))/PI / 2.);\n    }\n    \n    f = min(f, 1.);\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5* iResolution.xy) / iResolution.y;\n    \n    float zoom = 2.2;\n    \n    vec2 m = iMouse.xy / iResolution.xy * 10.;\n    if(iMouse.z < 0.)\n        m = vec2(1.2, -.8);\n        \n    \n    m.x += iTime / 8.;\n\n    vec3 ro = pol2Cart(m.x, -m.y - 1., 5.),\n         lookat = vec3(0.),\n         f = normalize(lookat - ro),\n         r = normalize(cross(vec3(0., 1., 0.), f)),\n         u = cross(f, r),\n         cc = ro + f * zoom,\n         i = cc + uv.x * r + uv.y * u,\n         rd = normalize(i - ro),\n         col;\n         \n    vec3 cubemap = texture(iChannel0, rd).xyz;\n\n    float d = eye(ro, rd);\n    //d = cornea(ro, rd, 0., 1.);\n    \n    if(d >= MAX_DIST)\n        col = cubemap;\n    else\n    {\n        vec3 p = ro + rd * d;\n        vec2 u = vec2(atan(p.y/p.z) * 3./PI, p.x) * 0.82;\n                \n        float corneaMask = smoothstep(0.5, 0.76, u.y);\n        \n        vec3 n = eyeNormal(p);\n        \n        float s = shade(n);\n        vec3 r = reflect(rd, n);\n        float fren = smoothstep(1.1, 0., -dot(n, rd)) * 0.07;\n        vec3 refl = texture(iChannel0, r).rgb;\n        \n        //iris\n        if(corneaMask > 0.)\n        {\n            float IOR = 1.44,\n                  DIL = sin(iTime / 1.) + PI;\n            \n            vec3 rdIn = refract(rd, n, 1./IOR);\n        \n            vec3 pEnter = p - n * SURF_DIST * 5.;\n            float dIn = cornea(pEnter, rdIn, 0., -1.);\n        \n            vec3 pE = pEnter + rdIn * dIn;\n            vec3 nExit = eyeNormal(pE);\n            \n            float px = pE.x;\n            \n            pE *= mix(1., 0.7, SIZE * SIZE);\n            \n            vec2 u2 = vec2(\n                length(pE.zy),\n                atan(pE.y, pE.z));\n                         \n            float d2 = DIL + DIL,\n                  od = 1. - d2,\n                  im = mix(map(u2.x * 0.78, d2, od, 0., 1.68), abs(u2.x * 0.78), 0.02);\n                  \n            u2.x = im + .4;\n            u2.y = abs(u2.y * 1.1) + PI;\n            //u2.y += .4;\n            \n            pE.z *= DIL;\n            pE.z += texture(iChannel3, pE.zy).g * 0.05 - + 0.05;\n                \n            col = texture(iChannel1, u2).rgb;\n            \n            float pupilMask = smoothstep(0.35, .4, length(pE.yz));\n            \n            col *= pupilMask;\n            //*IOR*1.2\n            vec3 rdOut = refract(rdIn*IOR*2., nExit, IOR);\n            \n            if(length(rdOut)==0.)\n            {\n                rdOut = reflect(rdIn, nExit);\n                col = mix(col, texture(iChannel0, rdOut).rgb * 0.6, 0.9);\n            }\n            \n            //s = shade(nExit);\n            \n            col *= corneaMask;\n            fren += corneaMask * fren * 6.;\n            fren = min(1., fren + (1.0 - pupilMask) * 0.1);\n        }\n        \n        //back\n        /*col += vec3(smoothstep(0.45, 0.55, 1.-u.y) * 0.8);\n        \n        float ven = getVein(u);\n        \n        vec3 blood = mix(vec3(.6, 0.1, .13) * ven, vec3(.4, 0.,0.), smoothstep(0.4, -.55, u.y));*/\n        \n        \n        #ifdef COOOOOL\n        vec3 ven = vec3(.6, 0.1, .13) * getVein(u);\n        #else\n        col += vec3(smoothstep(0.45, 0.55, 1.-u.y) * 0.8);\n        vec3 ven = mix(vec3(1.), vec3(.6, 0.1, .13), getVein(u));\n        #endif\n        \n        vec3 blood = mix(ven, vec3(.5, 0.,0.), smoothstep(0.4, -.35, u.y));\n        \n        col = mix(col, blood, smoothstep(0.39, 0.03, u.y));\n        col = mix(col, vec3(refl), fren);\n        col *= clamp(s*1.5, .7, 1.);\n        col = pow(col, vec3(0.8));\n        \n        col += vec3(pow(max(0., shade(r)), 64.));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtccWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 243, 243, 312], [314, 314, 353, 353, 453], [454, 454, 485, 485, 513], [514, 514, 542, 542, 637], [639, 639, 659, 659, 688], [690, 690, 734, 734, 825], [827, 827, 856, 856, 1189], [1191, 1191, 1217, 1217, 1331], [1333, 1333, 1386, 1386, 1826], [1829, 1829, 1856, 1856, 2057], [2059, 2059, 2083, 2083, 2284], [2286, 2286, 2307, 2307, 2359], [2361, 2361, 2433, 2433, 2499], [2566, 2566, 2596, 2596, 2692], [2694, 2694, 2714, 2714, 2752], [2754, 2754, 2775, 2775, 2865], [2867, 2867, 2888, 2888, 3086], [3088, 3088, 3136, 3136, 3403], [3672, 3672, 3729, 3779, 7422]], "test": "untested"}
{"id": "7l3cD4", "name": "vein generator", "author": "Artemis152", "description": "procedural vein generator made for my procedural eye (https://www.shadertoy.com/view/NtccWN)", "tags": ["noise"], "likes": 4, "viewed": 350, "published": 3, "date": "1659814349", "time_retrieved": "2024-07-30T16:36:38.567402", "image_code": "#define THIC 0.3\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat getLine(vec2 uv, vec2 offset, float rot)\n{\n    //rot = radians(rot);\n    uv = rotate(uv, radians(rot));\n    uv *= 20.;\n    uv += offset;\n    float n = noise(uv*vec2(.9, .4));\n    uv.y += n - .4;\n\n    float col = smoothstep(THIC, -.15, abs(uv.y));\n        \n    return col;\n}\n\nfloat getVein(vec2 uv)\n{\n    float rot = iTime * 20.;\n    \n    float f = 0.;\n    \n    for(float i = 0.; i < 65.; i += 0.9)\n    {\n        f += getLine(uv, vec2(.5 + i, noise(i) * 35. - 25.), rot + (i*15.9)/1.43);\n    }\n    \n    f = min(f, 1.);\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5* iResolution.xy) / iResolution.y;\n    \n    vec3 col = mix(vec3(.4, 0.,0.), vec3(.6, 0.1, .13), getVein(uv)) * 1.4;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3cD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 48, 48, 144], [146, 146, 166, 166, 236], [238, 238, 258, 258, 296], [298, 298, 319, 319, 417], [419, 419, 440, 440, 646], [648, 648, 696, 722, 927], [929, 929, 953, 953, 1192], [1194, 1194, 1251, 1301, 1504]], "test": "untested"}
{"id": "Nt3yDN", "name": "twisted-rotation on grid (211ch)", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/Yugemaku/status/1555776471058112513", "tags": ["2d", "2tweets", "short", "golf", "reproduction"], "likes": 35, "viewed": 558, "published": 3, "date": "1659791762", "time_retrieved": "2024-07-30T16:36:39.451039", "image_code": "// more readable version below\n\n\n/**/ // --- -3 chars by coyote\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u -= O.xy = iResolution.xy/2.;\n    u *= 1.6/O.y;\n    u *= mat2(cos( tanh(6.*modf(3.-length(u)+iTime*.8, O.x) -3. )/3.98\n                   + .5*O.x\n                   + vec4(0,33,11,0) ) );\n    O = 1.2 - .8 * min( u = abs( mod(u, .2) - .1 ) / fwidth(u), u.y).xxxx; \n}\n\n\n\n\n\n/** // --- 214 chars:  -9 chars by coyote, -1 by Fab, -1 by Xor\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u -= O.xy = iResolution.xy/2.;\n    u *= 1.6/O.y;\n    u *= mat2(cos( .5*ceil(O += length(u) - iTime*.8 -O) + tanh(6.* fract(O) -3. ) /3.98\n                   + vec4(0,11,33,0) ) ); \n    O = 1.2 - .8 * min( u = abs( mod(u, .2) - .1 ) / fwidth(u), u.y).xxxx; \n}\n\n\n\n\n\n/** // --- -17 chars by Xor\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 8.*( u+u - R ) / R.y;\n    float l = .2* length(U) - .8* iTime;\n      U *= mat2(cos( .5*ceil(l) + tanh(6.* fract(l) -3. ) /3.98\n//    U *= mat2(cos( .5*ceil(l) - tanh(2. *cos(3.14*fract(l)))/3.86 \n                   +vec4(0,11,33,0) ));                // rotation( ease(l) )\n    U = abs( fract(U) - .5 ) / fwidth(U);              // antialiased lines\n    O += 1.2 - .8* min(U.x,U.y) -O; \n}\n\n\n\n\n\n\n/** // --- 242 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 8.*( u+u - R ) / R.y;\n    float l = .2* length(U) - .8* iTime;\n    U *= mat2(cos( ( tanh( 2. *sin(3.14*(fract(l)-.5)))/.964 + 2.*ceil(l) ) /4.\n                   +vec4(0,11,33,0) ));                // rotation( ease(l) )\n    U = abs( fract(U) - .5 ) / fwidth(U);              // antialiased lines\n    O += 1.2 - .8* min(U.x,U.y) -O; \n}\n\n\n\n\n \n/** // --- 280 chars \n\n#define E(x) ( tanh( 2. *sin(mod(x/2.+1.57,3.14)-1.57))/tanh(2.) + 2.*round(x/6.28) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 8.*( u+u - R ) / R.y, A;\n    float l = length(U) - 4.*iTime;\n // O = vec4( U.y < E(U.x) ); return;                  // display ease function\n    U *= mat2(cos( vec4(0,11,33,0) + .26*E(1.18*l) )); // rotation( E(l) )\n    \n    A = abs( fract(U)-.5 ) / fwidth(U);                // antialiased lines\n    O += 1.2 - .8* min(A.x,A.y) -O; \n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3yDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 103, 103, 375]], "test": "untested"}
{"id": "7ltcW8", "name": "Zeta in a box", "author": "guil", "description": "3d graphic of zeia function in a box with shadows", "tags": ["box", "zeta"], "likes": 7, "viewed": 239, "published": 3, "date": "1659786500", "time_retrieved": "2024-07-30T16:36:40.283813", "image_code": "const float pi = 3.1415926535897932;\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n\n//------------------ ------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cinv(vec2 z) {return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cpow( float n, vec2 z ) {  return pow( n, z.x )*vec2( cos(z.y*log(n)), sin(z.y*log(n)) ); }\nvec2 cexp( vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog( vec2 z) {  return vec2( 0.5*log(z.x*z.x+z.y*z.y), atan(z.y,z.x)); }\nvec2 csin( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\nvec2 cpow( vec2 a, vec2 b ) {  return cexp(cmul(b,clog(a))) ;}\nvec2 ccos( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\n//\n\n\n\n// Spouge's method\nvec2 gamma(vec2 z){\n    const int N = 8;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += cinv(z+vec2(float(k),0.))*c;\n\t}\n\ts = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    return cdiv(s,z);   \n}\n\n\nvec2 zeta3(vec2 s) {\n  const int N = 8;  \n  \n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n\n  return cdiv(sum1+sum2, vec2(1,0) - cpow(2., vec2(1,0) - s));\n}\n\nvec2 khi(vec2 z){\n    return cmul(cmul(cpow(2.*pi,z)/pi,csin(pi*z/2.)),gamma(vec2(1.,0.)-z));\n}  \n\n\nvec2 zeta(vec2 z){\n    if(z.x<.5&&abs(z.y)<55.)return cmul(khi(z),zeta3(vec2(1.,0.)-z));\n    return zeta3(z);\n}\n\n//https://iquilezles.org/articles/boxfunctions\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    return vec2( tN, tF );\n}\n\nvec2 f(vec2 s){\n\nreturn cdiv(cmul(s,s-1.),s+1.);\n}\n\n\nvec3 field(in vec3 p) {\n\t\n    vec2 z=p.xz;\n    z=zeta(5.*z);\n    //z=f(z);\n    //z=gamma(z);\n    float d=p.y-log(length(z)+1.);\n    return vec3(z,d);\n}\n\nvec3 col(vec2 u){\n    return hsv2rgb(vec3(atan(u.y,u.x)/6.28,.6,1.));\n}\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 0., dt = .05, d, dd,tmax;\n    vec2 vt = boxIntersection( ro, rd, vec3(3)); \n\tt=vt.x;    \n    if (t<0.)return vec3(1);\n    tmax=vt.y;\n    vec3 v, c, v1;\n    for( int i=0; i<100; i++ )\n\t{        \n        v = field(ro+t*rd);\n        d=v.z;        \n        t+=dt*abs(d);\n        if(t>tmax)return vec3(.5);\n        if(t<vt.x)return vec3(.5);\n        if(abs(d)<.0001)break;\n                       \n    } \n    vec3 l =normalize(vec3(.0,.2,.2));//light\n    l.xz *= rot(t);\n    ro = ro+t*rd;       \n    t=.02;d=1.;\n    for( int i=0; i<15; i++ )\n\t{                \n        d = min((field(ro+t*l).z)/t,d);               \n        t+=.2; \n        if(abs(d)<.0001)break;\n    } \n    c=col(v.xy)*clamp(d,.5,1.);\n    //c=vec3(1)*clamp(d,.4,.9);\n    return c;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*.2;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n   \n    \n    // camera\n\n    vec3 ro = vec3(8.,6.,0.);   \n    vec3 rd = -normalize(vec3( p.y , 2., p.x ));   \n    rd.xy *= rot(1.);\n    \n    rd.xz *= rot(t);\n    ro.xz *= rot(t);\n    \n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \t\n\t// shade\n        \n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 57, 57, 104], [106, 106, 128, 128, 297], [302, 395, 425, 425, 454], [455, 455, 485, 485, 540], [541, 541, 560, 560, 592], [593, 593, 623, 623, 693], [694, 694, 715, 715, 761], [762, 762, 784, 784, 871], [872, 872, 893, 893, 918], [919, 919, 949, 949, 1049], [1050, 1050, 1080, 1080, 1146], [1147, 1147, 1167, 1167, 1216], [1217, 1217, 1237, 1237, 1295], [1296, 1296, 1316, 1316, 1393], [1394, 1394, 1423, 1423, 1456], [1457, 1457, 1477, 1477, 1555], [1562, 1581, 1600, 1600, 1953], [1956, 1956, 1976, 1976, 2418], [2420, 2420, 2437, 2437, 2515], [2520, 2520, 2538, 2538, 2631], [2633, 2680, 2741, 2741, 3044], [3046, 3046, 3061, 3061, 3096], [3099, 3099, 3122, 3122, 3250], [3252, 3252, 3269, 3269, 3323], [3325, 3325, 3362, 3362, 4124], [4127, 4127, 4184, 4184, 4640]], "test": "untested"}
{"id": "ftcyWN", "name": "Celtic knot 4e editable", "author": "FabriceNeyret2", "description": "variant of https://shadertoy.com/view/fl3yD4\ninteractively pick and displace any torii ( not too far away ) despite procedural draw.\nIf you don't want shaking, just stop shader and keep picking ;-)", "tags": ["2d", "pattern", "2tweets", "short", "celtic", "reproduction"], "likes": 8, "viewed": 304, "published": 3, "date": "1659786295", "time_retrieved": "2024-07-30T16:36:41.351957", "image_code": "// variant of https://shadertoy.com/view/fl3yD4\n\nvoid mainImage( out vec4 O, vec2 u ) { \n    O  = T(u);         \n    O *=  .8 + .2 * cos( O.w*2.   + vec4(0,23,21,0)  ) ; // coloring\n    if (O == O-O ) O += .4;                              // grey background\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === draw nested torii. read individual offsets in buffB\n\n#define S(r) smoothstep( 12./R.y, 0., abs(length(V)-.85) -r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  \n         U = 2.*( u+u - R ) / R.y, V,D,I;\n    O-=O;\n    float a, z = 9., i;\n    for( int k=0; k<9; k++ )                // check neighborhood for overlaps\n        D = vec2(k%3,k/3),                  // offset to neighbor\n        I = floor(U-D)+5., i = I.y+5.*I.x,  //  cell Id\n        V = fract(U) + D -1.5               // local coordinate \n          - T(vec2(i,0)).xy                 // edited offset for this torus\n          + .01*cos( iTime*30. +vec2(0,11)+ 6.3* fract(1e4*sin(dot(I,17.-R))) ), // shake\n        a = sin ( 4.* atan(V.y,V.x) ),      // depth oscillation at each torus angle\n        a < z && S(.07) > .5 ?              // top z + opaque mask:\n            O *= 1.-S(.07), O += vec4(vec3(S(.05)), i) , z=a  : z; // draw, .w = id, update z\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === maintain offset for each object\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n    vec2  R = iResolution.xy,  \n          M = iMouse.xy, P = iMouse.zw *vec2(1,-1);  // current mouse pos + drag init\n    float i = texture(iChannel1,M/R).w;              // on which id does the mouse click.\n\n    O = T(u);\n    if ( u == vec2(1.5) && P.y < 0. ) O.z = i;       // pick: memorize id\n    if ( P.x > 0. && P.y > 0. && u-.5 == vec2(T(1).z,0) ) // save the edited pos\n        O.xy = 4.* ( M - P ) / R.y;\n    \n // if ( P.x > 0. && P.y > 0. && u-.5 == vec2(i,0) ) // save the edited pos ( less robust )\n //    O.xy = 4.* ( M - P ) / R.y;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 259]], "test": "untested"}
{"id": "ftcyW4", "name": "4D Cube II", "author": "iq", "description": "Another 4D cube. It's the same as [url]https://www.shadertoy.com/view/4tVyWw[/url] but rendering faces (with gaps) instead of edges.", "tags": ["3d", "4d", "tesseract", "hypercube"], "likes": 80, "viewed": 2970, "published": 3, "date": "1659786011", "time_retrieved": "2024-07-30T16:36:42.348293", "image_code": "// Copyright Inigo Quilez, 2022 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Another 4D cube. It's like https://www.shadertoy.com/view/4tVyWw\n// but rendering faces instead of edges.\n\n    \n// make this 2 is your machine is fast\n#define AA 1\n\n\n//------------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    // based on a 1D hash by Hugo Elias\n    int n = 1376312589;\n    n += frame; n = (n<<13)^n; n=n*(n*n*15731+789221); \n    n += p.y;   n = (n<<13)^n; n=n*(n*n*15731+789221);\n    n += p.x;   n = (n<<13)^n; n=n*(n*n*15731+789221);\n    seed = n;\n}\n\n//------------------------------------------------------------------\n// intersecting a quadrilateral with a window in it\n//------------------------------------------------------------------\nvec4 quadIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, in float tmin, float tmax, out float oDisSq )\n{\n    // make v0 the origin\n    vec3 r1 = v1 - v0;\n    vec3 r2 = v2 - v0;\n    vec3 r3 = v3 - v0;\n    vec3 rz = ro - v0;\n\n    // intersect with the quad's plane\n    vec3 nor = cross(r1,r2);\n    float t = -dot(rz,nor)/dot(rd,nor);\n    \n    // early exit\n    if( t<tmin || t>tmax ) return vec4(-1.0);\n    \n    // intersection point\n    vec3 rp = rz + t*rd;\n    \n    \n    // build reference frame for the quad (uu,vv,ww)\n    vec3 ww = normalize(nor);\n    float l1 = length(r1);\n    vec3 uu = r1/l1;\n    vec3 vv = cross(uu,ww);\n    \n    // project all vertices to 2D into to the (uu,vv) plane\n    vec2 k0 = vec2( 0.0, 0.0 );\n    vec2 k1 = vec2( l1,  0.0 );\n    vec2 k2 = vec2( dot(r2,uu), dot(r2,vv) );\n    vec2 k3 = vec2( dot(r3,uu), dot(r3,vv) );\n    vec2 kp = vec2( dot(rp,uu), dot(rp,vv) );\n\n    // compute 2D distance from intersection point to quad edges\n    vec2  e0 = k1 - k0, p0 = kp - k0; \n    vec2  e1 = k2 - k1, p1 = kp - k1;\n    vec2  e2 = k3 - k2, p2 = kp - k2;\n    vec2  e3 = k0 - k3, p3 = kp - k3;\n    \n    float c0 = e0.x*p0.y - e0.y*p0.x;\n    float c1 = e1.x*p1.y - e1.y*p1.x;\n    float c2 = e2.x*p2.y - e2.y*p2.x;\n    float c3 = e3.x*p3.y - e3.y*p3.x;\n    \n    // if outside, early out\n    if( max(max(c0,c1),max(c2,c3))>0.0 ) return vec4(-1.0);\n    \n    // euclidean internal distance squared\n    float d = min(min(c0*c0/dot(e0,e0),\n                      c1*c1/dot(e1,e1)),\n                  min(c2*c2/dot(e2,e2),\n                      c3*c3/dot(e3,e3)));\n    \n    // open window of size 0.3\n    if( d>0.3*0.3 )  return vec4(-1.0);\n    \n    // return ray distance, normal, and distance from intersection to quad edges\n    oDisSq = d; \n    return vec4(t,ww);\n}\n\n//-------------------------------------------------------------------\n// 4D cube stuff\n//-------------------------------------------------------------------\n// 2d ->  4 verts, 1 face  per vertex -> ( 4*1)/4 =  1 quad\n// 3d ->  8 verts, 3 faces per vertex -> ( 8*3)/4 =  6 quads\n// 4d -> 16 verts, 6 faces per vertex -> (16*6)/4 = 24 quads\n//\n// So, the vertex indices of a quad differ by one bit each, in\n// a 00, 01, 11, 10 pattern. I feel I should be able to generate\n// this LUT on the fly instead of hardcoding it here below, but\n// I can't afford rabbit-holing myself into this right now :(\n#define DF(f) (ivec4((f)>>12,(f)>>8,(f)>>4,(f))&15);\n#define EF(a,b,c,d) (((a)<<12)|((b)<<8)|((c)<<4)|(d))\n#define QF(x,y,a) EF(a,a^(1<<x),a^(1<<x)^(1<<y),a^(1<<y))\nconst int kFaces[24] = int[24](\n    // xy\n    QF(0,1,  0),  //  0, 1, 3, 2\n    QF(0,1,  7),  //  7, 6, 4, 5\n    QF(0,1, 11),  // 11,10, 8, 9\n    QF(0,1, 12),  // 12,13,15,14\n    // xz\n    QF(0,2,  0),  //  0, 1, 5, 4\n    QF(0,2,  7),  //  7, 6, 2, 3\n    QF(0,2, 11),  // 11,15,14,10\n    QF(0,2, 12),  // 12, 8, 9,13\n    // xw\n    QF(0,3,  0),  //  0, 1, 9, 8\n    QF(0,3,  7),  //  7,15,14, 6\n    QF(0,3, 11),  // 11,10, 2, 3\n    QF(0,3, 12),  // 12, 4, 5,13\n    // yz\n    QF(1,2,  0),  //  0, 2, 6, 4\n    QF(1,2,  7),  //  7, 5, 1, 3\n    QF(1,2, 11),  //  11,15,13,9\n    QF(1,2, 12),  //  12,8,10,14\n    // yw\n    QF(1,3,  0),  //  0, 2,10, 8\n    QF(1,3,  7),  //  7,15,13, 5\n    QF(1,3, 11),  // 11, 9, 1, 3\n    QF(1,3, 12),  // 12, 4, 6,14\n    // zw\n    QF(2,3,  0),  //  0, 4,12, 8\n    QF(2,3,  7),  //  7,15,11, 3\n    QF(2,3,  9),  //  9, 1, 5,13\n    QF(2,3, 14)); //  14,10,2, 6\n\nvec4 intersectClosest( in vec3 ro, in vec3 rd, in vec3 verts[16], out int oFace, out float oDisSq )\n{\n    vec4 res = vec4(1e10,0.0,0.0,0.0);\n    oFace = -1;\n    \n    for( int i=0; i<kFaces.length(); i++ )\n    {\n        float tmpd;\n        ivec4 idx = DF(kFaces[i]); // decode face indices\n        vec4 tmp = quadIntersect( ro, rd, verts[idx.x], verts[idx.y], verts[idx.z], verts[idx.w], 0.0, res.x, tmpd );\n        if( tmp.x>0.0 )\n        {\n            res = tmp;\n            oFace = i;\n            oDisSq = tmpd;\n        }\n    }\n\n    res.yzw = (dot(res.yzw,rd)<0.0) ? res.yzw : -res.yzw;  // face camera\n\n    return (res.x<1e9)?res:vec4(-1.0);\n}\n\nfloat intersectAny( in vec3 ro, in vec3 rd, in vec3 v[16], int obj )\n{\n    for( int i=0; i<kFaces.length(); i++ )\n    {\n        if( i!=obj ) // prevent self shadowing, without epsilons\n        {\n            float kk;\n            ivec4 idx = DF(kFaces[i]); // decode face indices\n            if( quadIntersect( ro, rd, v[idx.x], v[idx.y], v[idx.z], v[idx.w], 0.001, 10.0, kk ).x>0.0 )\n                return 0.0;\n        }\n    }\n    return 1.0;\n}\n\n// regular ambient occlusion\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in vec3 verts[16], int obj )\n{\n    float occ = 0.0;\n    const int num = 16;   // 16 samples, can change it of course\n    for( int j=0; j<num; j++ )\n    {\n        // uniform distribution on sphere\n        float u = frand();\n        float v = frand();\n        float a = 6.2831853*v; float b = 2.0*u-1.0;\n        vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n        \n        // convert to cosine distribution around normal\n        dir = normalize( nor + dir );\n        \n        // cast shadow ray\n        if( dir.y>0.0 ) // but only towards the sky\n        occ += intersectAny( pos, dir, verts, obj );\n    }\n    return occ/float(num);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 verts[16], in vec2 px )\n{ \n    // background\n    vec3 col = mix(vec3(0.05,0.4,0.4),vec3(0.05,0.2,0.4),0.5+0.5*px.y)*0.45;\n    col *= 1.0-0.4*length(px);\n\n    // 4D cube\n    if( abs(px.x)<1.0)\n    {\n        int   face;\n        float disSq;\n        vec4  tnor = intersectClosest(ro,rd,verts,face,disSq);\n        float t = tnor.x;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n\n            // material\n            ivec4 idx = DF(kFaces[face]); // decode face indices\n            float l = length( verts[idx.x]-verts[idx.y] );\n            l = max(l,length( verts[idx.y]-verts[idx.z] ));\n            l = max(l,length( verts[idx.z]-verts[idx.w] ));\n            l = max(l,length( verts[idx.w]-verts[idx.x] ));\n            l += nor.x*1.5; \n            vec3 mate = vec3(0.6,0.4,0.52) + 0.5*sin(0.26*l+vec3(0,1.5,2)+1.35);\n            mate = max(mate,0.0);\n            mate.z += 0.2*(1.0-exp2(-0.02*t*t));\n            mate *= 1.2-1.2*vec3(0.5,0.5,0.1)*smoothstep(0.6,0.7,-cos(sqrt(disSq)*80.0));\n\n            // lighting\n            col = mate * calcOcclusion( pos, nor, verts, face );\n        }\n    }\n    return col;\n}\n\n// look-at from r(ray)o(origin) to ta(rget) with c(amera)r(oll)\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// a rotation matrix\nmat2 rot( float a )\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// animation will repeat every 18 second\nvec3 transform( in vec4 p, float time )\n{\n    // some rotations in 4D\n    p.xy = rot(6.283185*time/18.0)*p.xy;\n    p.zw = rot(6.283185*time/ 6.0)*p.zw;\n    // perspective projection (4D to 3D)\n    return 2.8*p.xyz/(3.0+p.w); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms\n    srand( ivec2(fragCoord), iFrame );\n    \n    // camera (static)\n    vec3 ro = vec3( 3.8, 2.0, 3.3 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float time = iTime + frand()/30.0;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n        // rotate 4D cube\n        vec3 v[] = vec3[]( transform(vec4(-1,-1,-1,-1),time),\n                           transform(vec4(-1,-1,-1, 1),time),\n                           transform(vec4(-1,-1, 1,-1),time),\n                           transform(vec4(-1,-1, 1, 1),time),\n                           transform(vec4(-1, 1,-1,-1),time),\n                           transform(vec4(-1, 1,-1, 1),time),\n                           transform(vec4(-1, 1, 1,-1),time),\n                           transform(vec4(-1, 1, 1, 1),time),\n                           transform(vec4( 1,-1,-1,-1),time),\n                           transform(vec4( 1,-1,-1, 1),time),\n                           transform(vec4( 1,-1, 1,-1),time),\n                           transform(vec4( 1,-1, 1, 1),time),\n                           transform(vec4( 1, 1,-1,-1),time),\n                           transform(vec4( 1, 1,-1, 1),time),\n                           transform(vec4( 1, 1, 1,-1),time),\n                           transform(vec4( 1, 1, 1, 1),time));\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, v, p );\n\n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n        #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dither to remove banding from background (should be triangular, ie, two frand()s)\n    tot += frand()/255.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcyW4.jpg", "access": "api", "license": "proprietary-license", "functions": [[1127, 1127, 1145, 1145, 1202], [1203, 1203, 1222, 1222, 1254], [1255, 1255, 1290, 1330, 1536], [1538, 1728, 1867, 1893, 3540], [5188, 5188, 5289, 5289, 5834], [5836, 5836, 5906, 5906, 6281], [6283, 6312, 6389, 6389, 7001], [7003, 7003, 7073, 7092, 8208], [8210, 8274, 8326, 8326, 8515], [8517, 8538, 8559, 8559, 8632], [8634, 8675, 8716, 8744, 8902]], "test": "untested"}
{"id": "Nt3cD4", "name": "Celtic knot 4d shaking", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/kamoshika_vrc/status/1554813085848051715\nvariant of https://www.shadertoy.com/view/fl3yD4\nTo be able to shake individual rings, we can no longer use any symmetry.", "tags": ["2d", "pattern", "short", "golf", "celtic", "reproduction", "3tweets"], "likes": 5, "viewed": 268, "published": 3, "date": "1659775311", "time_retrieved": "2024-07-30T16:36:43.374549", "image_code": "// variant of https://shadertoy.com/view/fl3yD4\n// variant of https://shadertoy.com/view/7ldcWn\n\n// --- version with correct order + shake\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  \n         U = 2.*( u+u - R ) / R.y, V,D;\n    O += .5-O;                                //  3-grey variant\n    float a, z = 9., s,d;\n    for( int k=0; k<9; k++ )\n        D = vec2(k%3,k/3),\n        V = fract(U) + D -1.,  \n        V += .02*cos( iTime*30. +vec2(0,11)+ 6.3* fract(1e4*sin(dot(floor(U-D),17.-R))) ),\n        a = sin ( 4.* atan(V.y,V.x) ),\n        s = smoothstep( 12./R.y, 0., abs(d = length(V)-.85) -.07 ),\n        a < z && s > .5 ?\n            O *= 1.-s, O += s * ( .5 + .5* cos(30.*d) - O )\n          , z=a  : z; \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3cD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 179, 179, 738]], "test": "untested"}
{"id": "fl3yD4", "name": "Celtic knot 4c shaking", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/kamoshika_vrc/status/1554813085848051715\nvariant of https://shadertoy.com/view/7ldcWn\nTo be able to shake individual rings, we can no longer use any symmetry.", "tags": ["2d", "pattern", "2tweets", "short", "golf", "celtic", "reproduction"], "likes": 7, "viewed": 253, "published": 3, "date": "1659774957", "time_retrieved": "2024-07-30T16:36:44.209317", "image_code": "// variant of https://shadertoy.com/view/7ldcWn\n\n// --- version with correct order + shake\n\n#define S(r) smoothstep( 12./R.y, 0., abs(length(V)-.85) -r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  \n         U = 2.*( u+u - R ) / R.y, V,D;\n    O-=O; // -.5;                                //  3-grey variant\n    float a, z = 9.;\n    for( int k=0; k<9; k++ )\n        D = vec2(k%3,k/3),\n        V = fract(U) + D -1.,  \n        V += .02*cos( iTime*30. +vec2(0,11)+ 6.3* fract(1e4*sin(dot(floor(U-D),17.-R))) ),\n \n        a = sin ( 4.* atan(V.y,V.x) ),\n        a < z && S(.07) > .5 ?\n            O *= 1.-S(.07), O += S(.05) \n            // * ( .6 + .6 * cos( atan(V.y,V.x)    + vec4(0,23,21,0)  ) )\n            // * ( .6 + .6 * cos( (H.x+11.*H.y)    + vec4(0,23,21,0)  ) )\n          , z=a  : z; \n}\n\n\n\n\n\n/* // --- 266 chars order.   no shake\n\n#define S(r) smoothstep( 12./R.y, 0., abs(length(V)-.9) -r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  \n         U = 2.*( u+u - R ) / R.y, V;\n    O-=O; // -.5;                                //  3-grey variant\n    float a, z = 9.;\n    for( int k=1; k<5; k++ )\n        V = mod( U + vec2(k%3,k/3), 2. ) - 1.,\n        a = sin ( 4.* atan(V.y,V.x) ),\n        a < z && S(.07) > .5 ?\n            O *= 1.-S(.07), O += S(.05) // * ( .6 + .6 * cos( atan(V.y,V.x)    + vec4(0,23,21,0)  ) )\n          , z=a  : z; \n}\n\n\n\n\n\n/** // --- 208 chars  no order no shake\n\n#define S(r) smoothstep( 12./R.y, 0., abs(length(V)-.9) -r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  \n         U = 2.*( u+u - R ) / R.y, V;\n    O-=O; // -.5;                                //  3-grey variant\n    for( int k=1; k<5; k++ )\n        V = mod( U + vec2(k%3,k/3), 2. ) - 1.,\n        O *= 1.-S(.07), O += S(.05); // * ( .6 + .6 * cos( float(k)*1.6  + vec4(0,23,21,0)  ) );\n}\n\n\n\n\n\n/** // --- 229 chars  no order no shake\n\n#define S(U,r) smoothstep( 12./R.y, 0., abs(length(U)-.9) -r )\n#define B(U)   O *= 1.-S(U,.07), O += S(U,.05)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  \n         U = 2.*( u+u - R ) / R.y;\n    O-=O; // -.5;                                //  3-grey variant\n    for( int k=0; k<9; k++ )\n        B( mod(U+vec2(k%3-1,k/3-1),2.)-1. );\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3yD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 193, 193, 818]], "test": "untested"}
{"id": "7t3yW8", "name": "\"Descending\" (227 chs)", "author": "fenix", "description": "My first attempt at a golf-type shader. Inspired by Descending (1965) by Bridget Riley, Gemeentemuseum Den Haag.\n\nhttps://upload.wikimedia.org/wikipedia/commons/b/bd/Binary_%2826093852377%29.jpg\n\nI got it down under 280 characters at least, woohoo!", "tags": ["stripes", "steps", "stairs", "golf", "reproduction"], "likes": 3, "viewed": 252, "published": 3, "date": "1659765152", "time_retrieved": "2024-07-30T16:36:45.102928", "image_code": "// also from Xor: 210 characters! :O\n\n//*\nvoid mainImage( out vec4 O, vec2 u)\n{\n    u /= iResolution.xy;\n\n    float x = u.x - .1 * (u.x - .5) * u.y,\n          z = .3 + .6 * (x - smoothstep(0., .75 / (.5 - abs(x - .5)), \n                                      1. - abs(u.y - .25))),  \n          f = fract(x*7. + iTime * .14);\n\n    O = vec4(mod( u.y / .1 - min(f / z, --f / --z), .4) > .2);\n}\n/**/\n\n// from coyote: 221 characters\n\n/*\nvoid mainImage( out vec4 O, vec2 u)\n{\n    u /= iResolution.xy;\n\n    float x = u.x - .1 * (u.x - .5) * u.y,\n          z = .3 + .6 * (x - smoothstep(0., .75, \n                                      (1. - abs(u.y - .25)) * (.5 - abs(x - .5)))), \n          f = fract(x*7. + iTime * .14);\n\n    O = vec4(abs(.2 - mod( u.y / .1 - (f < z ? f / z : --f / --z), .4) ) > .1);\n}\n/**/\n\n// from Xor: 227 characters\n\n/*\nvoid mainImage( out vec4 O, vec2 u)\n{\n    u /= iResolution.xy;\n\n    float x = u.x - .1 * (u.x - .5) * u.y,\n          z = .3 + .6 * (x - smoothstep(0., .75, \n                                      (1. - abs(u.y - .25)) * (.5 - abs(x - .5)))), \n          f = fract(x*7. + iTime * .14);\n\n    O = vec4(abs(.2 - mod( u.y / .1 - (f < z ? f / z : (1. - f) / (1. - z)), .4) ) > .1);\n}\n/**/\n\n// from FabriceNeyret2: 237 chars (+ 12 for aa)\n\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= iResolution.xy;\n\n    float x = u.x - .1 * (u.x - .5) * u.y,\n          z = .7 - .6 * (x - smoothstep(0., .75, \n                                      (1. - abs(u.y - .25)) * (.5 - abs(x - .5)))), \n          f = fract(-x*7. - iTime * .14);\n\n    O = vec4( round( abs(1. - mod( u.y - .1 * (f < z ? f / z : (1. - f) / (1. - z)), .04) / .02 ) ) );\n  //O = R.yyyy*.01*(s-.3);  // antialiasing\n}\n/**/\n\n// Amateur hour (251 chars):\n\n/*\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    u /= iResolution.xy;\n\n        float x = u.x - .1 * (u.x - .5) * u.y,                // warp apart at the top\n        z = .7 - .6 * (x - smoothstep(0., .75,                // warp away from (0.5, 0.25)\n                (1. - abs(u.y - .25)) * (.5 - abs(x - .5)))), \n        f = fract((-x - iTime * .02) * 7.),                   // horizontal stripes\n        y = u.y - .1 * (f < z ? f / z : (1. - f) / (1. - z)), // doubleRamp\n        s = abs(.5 - fract(y / .04)) * 2.;                    // vertical stripes\n    \n    O = vec4(round(s));\n}\n/**/\n\n// Original:\n\n/*\nfloat doubleRamp(float x, float z)\n{\n    if (x < z) return x / z;\n    return (1.0 - x) / (1.0 - z);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    u /= iResolution.xy;\n    \n    u.x += -0.1 * (u.x - 0.5) * u.y;\n    float a = -u.x - iTime * 0.02;//  + 0.01 * sin(uv.y * 3.1 + 1.4) / (0.2 + 1.0 * length((uv - vec2(0.5, 0.25)) * vec2(1.0, 0.1)));\n    \n    u.x -= 1.0 * smoothstep(0.0, 0.75, (1.0 - abs(u.y - 0.25)) * (0.5 - abs(u.x - 0.5)));\n    u.y -= 0.1 * doubleRamp(mod(a * 7.0, 1.0), u.x * -0.6 + 0.65);\n    \n    const float w = 1.0 / 24.0;\n    float s = abs(0.5 - mod(u.y, w) / w) * 2.0;\n    float bw = smoothstep(.4, .6, s);\n    \n    vec3 col = vec3(bw);\n\n    O = vec4(col,1.0);\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3yW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 42, 79, 79, 389]], "test": "untested"}
{"id": "NldyDH", "name": "Bouncing ball and colorful logo", "author": "mrange", "description": "CC0: Bouncing ball and colorful logo\nUsually I go for colorful background and muted colors in foreground\nThis time I tried to reverse it. I thought the results were good enough to share.\n", "tags": ["2d", "3d"], "likes": 35, "viewed": 387, "published": 3, "date": "1659725467", "time_retrieved": "2024-07-30T16:36:45.931712", "image_code": "// CC0: Bouncing ball and colorful logo\n// Usually I go for colorful background and muted colors in foreground\n// This time I tried to reverse it. I thought the results were good enough to share.\n\n// Try COLOR0 to COLOR5 for different color schemes of varying success\n#define COLOR4\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float bstart = 0.0;\nconst float bpm    = 120.0;\nconst float bhz    = bpm/60.0;\nfloat btime(float n) {\n  return bhz*n*8.0;\n}\n\nfloat beat(float tm) {\n  return 1.0*smoothstep(0.0, 1.0, cos(TAU*(tm-bstart)*bhz));\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nconst float glimglam_corner0 = 0.02;\nconst float glimglam_corner1 = 0.075;\nconst float glimglam_topy    = 0.0475+glimglam_corner0*0.5;\nconst float glimglam_smoother= 0.0125;\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat corner(vec2 p) {\n  vec2 v = min(p, vec2(0));\n  return length(max(p, vec2(0))) + max(v.x, v.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, vec4 r) {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat glimglam_bar(vec2 p) {\n  vec2 pbar = p;\n  pbar.y -= glimglam_topy;\n  return abs(pbar.y)-glimglam_corner0;\n}\n\nfloat glimglam_a(vec2 p) {\n  p.x = abs(p.x);\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));\n  float dc = corner(p-vec2(0.045, -0.07))-glimglam_corner0;\n\n  float d = db;\n  d = max(d, -dc);\n\n  return d;\n}\n\nfloat glimglam_c(vec2 p) {\n  p = -p.yx;\n  float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));\n  p.x = abs(p.x);\n  float dc = corner(p-vec2(0.05, glimglam_topy))-glimglam_corner0;\n\n  float d = db;\n  d = max(d, -dc);\n\n  return d;\n}\n\nfloat glimglam_e(vec2 p) {\n  p = -p.yx;\n  float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner0));\n\n  float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;\n  float dt = p.y-glimglam_topy;\n\n  float d = db;\n  d = max(d, -pmax(dl,dt, glimglam_smoother));\n\n  return d;\n}\n\nfloat glimglam_l(vec2 p) {\n  float db = roundedBox(p, vec2 (0.175, 0.166), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner1));\n  float dc = corner(-(p-vec2(-0.027, -0.055)))-glimglam_corner0;\n  float d = db;\n  d = max(d, -dc);\n  return d;\n}\n\nfloat glimglam_n(vec2 p) {\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner0));\n\n  float dl = abs(p.x)-0.07;\n  float dt = p.y-glimglam_topy;\n\n  float d = db;\n  d = max(d, -max(dl,dt));\n\n  return d;\n}\n\nfloat lance(vec2 p) {\n  p.x -= -0.810;\n  float dbar = glimglam_bar(p);\n\n  vec2 pl = p;\n  float dl = glimglam_l(pl);\n\n  vec2 pa = p;\n  pa.x -= 0.39;\n  float da = glimglam_a(pa);\n\n  vec2 pn = p;\n  pn.x -= 0.795;\n  float dn = glimglam_n(pn);\n\n  vec2 pc = p;\n  pc.x -= 1.2;\n  float dc = glimglam_c(pc);\n\n  vec2 pe = p;\n  pe.x -= 1.605;\n  float de = glimglam_e(pe);\n\n  float d = 1E6;\n  d = min(d, dl);\n  d = min(d, da);\n  d = min(d, dn);\n  d = min(d, dc);\n  d = min(d, de);\n  d = pmax(d, -dbar, glimglam_smoother);\n\n  return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nfloat bouncef(float tt) {\n  float tm = tt*bhz/2.0;\n  float t = fract(tm)-0.5;\n  return 4.0*(0.25 - t*t);\n}\n\nfloat dots(vec2 p, float f, float mf) {\n  const vec2 gz = vec2(PI/100.0);\n  vec2  n = mod2(p, gz);\n  p.x     /= f;\n  float d = length(p)-0.005;\n  \n  return d;\n}\n\nfloat grid(vec2 p, float f, float mf) {\n  const float steps = 20.0;\n  vec2 gz = vec2(PI/(steps*mf), PI/steps);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float d = min(abs(p.x), abs(p.y))-0.0025;\n  return d;\n}\n\nconst vec3 lightPos = vec3(1.0, 2.0, 2.0);\nconst float planeY  = -0.75;\n\nvec4 ballDim(float bf) {\n  float b = 0.25*bf;\n  const float r = 0.5;\n  return vec4(vec3(0.0, b+planeY+r, 0.0), r);\n}\n\nvec3 skyColor(float bf, vec3 ro, vec3 rd, vec3 nrd) {\n  float pi = -(ro.y-(planeY))/rd.y;\n  \n  if (pi < 0.0) return vec3(1.0);\n  \n  vec3 pp = ro+rd*pi;\n  vec3 npp= ro+nrd*pi;\n  vec3 pld = normalize(lightPos-pp); \n\n  float aa = length(npp-pp);\n  \n  vec4 ball = ballDim(bf);\n\n  vec2 bi = raySphere(pp, pld, ball);\n  \n  vec2 pp2 = pp.xz+0.5*TIME;\n  vec2 np2 = mod2(pp2, vec2(0.5));\n  float pd = min(abs(pp2.x), abs(pp2.y))-0.01;\n  \n  vec3 col = vec3(1.0);\n  \n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, pd));\n  \n  if (bi.x > 0.0) {\n    col *= mix(1.0, 1.0-exp(-bi.x), tanh_approx(2.0*(bi.y-bi.x)));\n  }\n  \n  col = mix(vec3(1.0), col, exp(-0.2*max(pi-2.0, 0.0)));\n\n  return col;\n}\n\nvec3 color(float bf, vec3 ro, vec3 rd, vec3 nrd) {\n  vec4 ball = ballDim(bf);\n\n  vec3 sky = skyColor(bf, ro, rd, nrd);\n  \n  vec2 bi = raySphere(ro, rd, ball);\n  float pi = -(ro.y-(planeY))/rd.y;\n  \n  vec3 sp   = ro + bi.x*rd;\n  vec3 nsp  = ro + bi.x*nrd;\n  float aa  = length(sp-nsp);\n  vec3 pp  = ro + pi*rd;\n\n  vec3 sld = normalize(lightPos-sp); \n  sp -= ball.xyz;\n  vec3 sn   = normalize(sp);\n  vec3 sr   = reflect(rd, sn);\n  float sfre= 1.0+dot(sn, rd);\n  sfre *= sfre;\n  \n  sp.yz    *= ROT(TIME*sqrt(0.5));\n  sp.xy    *= ROT(TIME*1.234);\n  vec3 ssp = toSpherical(sp.zxy);\n\n  vec2 sp2 = ssp.yz;\n  float sf  = sin(sp2.x); \n  float slf2 = -ceil(log(sf)/log(2.0));\n  float smf = pow(2.0, slf2);\n  \n  float sdiff = max(dot(sld, sn), 0.0);\n  float sspe  = pow(max(dot(sld, sr), 0.0), 0.5);\n  float sdd = dots(sp2, sf, smf);\n  float sdg = grid(sp2, sf, smf);\n    \n  vec3 col = vec3(1.0);\n  vec2 pp2 = pp.xz;\n\n  float st = tanh_approx(10.0*(bi.y-bi.x));\n  if (st > 0.0) {\n    vec3 scol = vec3(0.0);\n    float sdcol = mix(0.05, 0.1, sdiff); \n    scol += sdcol;\n    scol = mix(scol, vec3(sdcol*2.0), smoothstep(aa, -aa, sdd));\n    scol = mix(scol, vec3(sdcol*3.0), smoothstep(aa, -aa, sdg));\n    scol += sspe*sfre;\n    col = mix(col, scol, st);\n  }\n  \n  return mix(sky, col, st);\n}\n\nvec3 background(vec2 p) {\n  vec3 ro = vec3(0.0, 0, 2.0);\n  vec3 la = vec3(0.0 ,0.0, 0.0); \n\n  vec2 np = p + vec2(2.0/RESOLUTION.y); \n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = cross(ww,uu);\n  float rdd = 2.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd= normalize(-np.x*uu + np.y*vv + rdd*ww);\n\n  float bf = bouncef(TIME);\n  return color(bf, ro, rd, nrd);\n}\n\nconst float logoZoom  = 1.5;\n\nfloat f_df(vec2 p) {\n  vec2 p0 = p;\n  p0 /= logoZoom;\n  float d0  = lance(p0);\n  d0 *= logoZoom;\n  return d0;\n}\n\nfloat f_hf(vec2 p) {\n  float aa = 0.025;\n  float d = f_df(p);\n  return 0.04*smoothstep(aa, -aa, -d);\n}\n\nvec3 f_normal(vec2 p) {\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = f_hf(p + e.xy) - f_hf(p - e.xy);\n  n.y = -2.0*e.x;\n  n.z = f_hf(p + e.yx) - f_hf(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 foreground(vec3 col, vec2 p) {\n  const float split = glimglam_topy*logoZoom; \n  float aa = 2.0/RESOLUTION.y;\n  float d = f_df(p);\n  vec3 n = f_normal(p);\n  vec3 lp1 = vec3(-.5, -2.0, 8.0);\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 po = vec3(p.x, 0.0, p.y);\n  vec3 rd = normalize(po-ro);\n  float fre = 1.0+dot(rd,n);\n  fre *= fre;\n  vec3 ld1 = normalize(lp1 - po);\n  float diff1 = max(dot(n, ld1), 0.0);\n  vec3  ref   = reflect(rd, n);\n  float ref1  = pow(max(dot(ref, ld1), 0.0), 20.0);\n\n\n#if defined(COLOR0)\n  vec3 lcol = hsv2rgb(vec3((p.y > split ? 0.65 : 0.)-(p.y)*0.45, 0.9, 1.0));\n#elif defined(COLOR1)\n  vec3 lcol = hsv2rgb(vec3((p.y > split ? 0.65 : 0.1)-abs(p.y)*0.45, 0.9, 1.0));\n#elif defined(COLOR2)\n  vec3 lcol = hsv2rgb(vec3((p.y > split ? 0.8 : 0.55)-(p.y)*0.45, 0.9, 1.0));\n#elif defined(COLOR3)\n  vec3 lcol = hsv2rgb(vec3((p.y > split ? 0.65 : 0.2)-abs(p.y)*0.45, 0.9, 1.0));\n#elif defined(COLOR4)\n  vec3 lcol = hsv2rgb(vec3((p.y > split ? 0.6 : 0.1)-abs(p.y-split)*0.33, 0.9, 1.0));\n#elif defined(COLOR5)\n  vec3 lcol = hsv2rgb(vec3((p.y > split ? 0.85 : 0.575), 0.66, 1.5))*vec3(abs(p.y-split));\n#else\n  vec3 lcol = hsv2rgb(vec3((p.y > split ? 0. : 0.)-(p.y)*0.45, 0.9, 1.0));\n#endif\n  vec3 ocol = 0.25*lcol*lcol;\n  lcol += 0.25*(n.x+n.z)+0.5*ref1;\n  float t = smoothstep(6.0, 8.0, TIME);\n  col = mix(col, ocol, t*smoothstep(aa, -aa, d-0.0075));\n  col = mix(col, lcol, t*smoothstep(aa, -aa, d));\n  \n  return col;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = background(p);\n  col = foreground(col, p);\n  col = mix(col, vec3(1.0), smoothstep(3.0, 0.0, TIME-dot(p, p)));\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 569, 569, 591], [593, 593, 615, 615, 678], [832, 832, 854, 854, 1000], [1295, 1355, 1376, 1376, 1446], [1448, 1508, 1536, 1556, 1632], [1634, 1720, 1756, 1756, 1850], [1853, 1953, 1992, 1992, 2077], [2079, 2079, 2118, 2118, 2147], [2324, 2410, 2432, 2432, 2512], [2514, 2632, 2674, 2674, 2831], [2833, 2833, 2861, 2861, 2946], [2948, 2948, 2974, 2974, 3229], [3231, 3231, 3257, 3257, 3532], [3534, 3534, 3560, 3560, 3876], [3878, 3878, 3904, 3904, 4145], [4147, 4147, 4173, 4173, 4419], [4421, 4421, 4442, 4442, 4945], [4947, 5069, 5113, 5113, 5310], [5312, 5312, 5338, 5338, 5447], [5449, 5449, 5474, 5474, 5555], [5557, 5557, 5596, 5596, 5717], [5719, 5719, 5758, 5758, 5928], [6003, 6003, 6027, 6027, 6119], [6121, 6121, 6174, 6174, 6801], [6803, 6803, 6853, 6853, 8079], [8081, 8081, 8106, 8106, 8510], [8542, 8542, 8562, 8562, 8653], [8655, 8655, 8675, 8675, 8757], [8759, 8759, 8782, 8782, 8961], [8963, 8963, 8998, 8998, 10399], [10401, 10501, 10520, 10520, 10607], [10609, 10716, 10742, 10742, 10926], [10928, 10928, 10983, 10983, 11280]], "test": "untested"}
{"id": "sl3cWH", "name": "Celtic knot 4b ( 243 chars )", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/kamoshika_vrc/status/1554813085848051715\nvariant of https://shadertoy.com/view/7ldcWn", "tags": ["2d", "pattern", "2tweets", "short", "golf", "celtic", "reproduction"], "likes": 7, "viewed": 221, "published": 3, "date": "1659686779", "time_retrieved": "2024-07-30T16:36:46.778448", "image_code": "// variant of https://shadertoy.com/view/7ldcWn\n\n\n#define B   O +=   smoothstep( 12./R.y, 0., abs(length(U)-.9) -.07 )   \\\n                 * ( .5 + .5* cos(30.*(length(U)-.9)) - O );           \\\n/*               * vec4(.7,.7,1,1);  /* nice transp col variant :-) */ \\\n            U += D\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, D = vec2(.5,-.5),\n         U = fract( ( 4.*u - R-R ) / R.y ) - .5; // tile = 1/4 circle\n    O-=O  -.4;                                   //  3-grey variant\n    U = abs( U.x*U.y<0. ? U.yx : U )             // tile = 1/16 circle\n    - D; B\n    +.5; B\n    -.5; B;  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3cWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 327, 327, 621]], "test": "untested"}
{"id": "7ldcWr", "name": "Noun O’ Clock  ⌐ⓝ°ⓒ ", "author": "duvengar", "description": "I didn't know what to expect and ended up with this. Homage to the nouns.", "tags": ["2d", "nouns"], "likes": 13, "viewed": 274, "published": 3, "date": "1659683556", "time_retrieved": "2024-07-30T16:36:47.724918", "image_code": "// ⌐ⓝ°ⓒ\n// by @duvengar-2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////////\n#define T iTime\n#define R iResolution.xy\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    \n \n   \t// glitch offset \n    vec2 V  = 1. - 2. * U / R;  \n    vec2 off = vec2(.4);\n\t\n    // colorize\n    float r = texture(iChannel0, U/ R - .01 * off).r;\n    float g = texture(iChannel0, U/ R + .00 * off).r;\n    float b = texture(iChannel0, U/ R + .01 * off).r;\n    C = vec4(r,g,b,1.);\n    \n  \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define T iTime\n#define PI2 (2.*acos(-1.))\n#define ROT(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat sdBox( in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n   \n    return max(q.x,q.y);\n}\n\nfloat hash2(vec2 p){ \n\n\tvec3 p3  = fract(vec3(p.xyx) * .2831);\n    p3 += dot(p3, p3.yzx + 12.1233);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat starf(vec2 uv, float i){\n\nuv.x -=iTime*0.2;\n\nfloat star = hash2(floor(uv.yx*80.));\n   vec2 starsuv = .5-fract(uv*80.);\n   float sstar = star > .997 ? 1.:.0;\nreturn i*sstar;\n}\n\n\nfloat fill(float s){\n\nreturn smoothstep(0.003,0.,s);\n\n}\n\nfloat flow( vec2 u, float s, float d ){\n\nreturn sin(3.*iTime+u.y*s)*length(-u.y-d);\n\n}\n\n\nvec3 makeGlasses( vec2 u ){\n   float glasses = sdBox( vec2(abs(u.x),u.y-.23) + vec2(-0.08,0.05), vec2(.062, .062));\n   float glasses2 = sdBox( vec2(abs(u.x),u.y-.23) + vec2(-0.08,0.05), vec2(.042, .042));\n   float glasses2b = sdBox( vec2(abs(u.x+.019),u.y-.23) + vec2(-0.08,0.05), vec2(.023, .042));\n   float glasses3 = sdBox( u - vec2(0.,0.2), vec2(.03, .01));\n   float glasses4 = sdBox( u - vec2(0.,0.2), vec2(.03, .01));\n   float glasses5 = sdBox( u - vec2(-0.17,0.2), vec2(.03, .01));\n   float glasses6 = sdBox( u - vec2(-0.2,0.18), vec2(.01, .03));\n   \n   float Glasses = glasses/glasses2;\n   Glasses = min(Glasses,glasses3);\n   Glasses = min(Glasses,glasses5);\n   Glasses = min(Glasses,glasses6);\n    \n   return vec3(Glasses, glasses2, glasses2b);\n\n}\n\n\nvoid mainImage( out vec4 S, in vec2 UV )\n{\n  \n   vec2 uv = (UV-R*.5)/R.y;\n   uv*= 1.;\n   vec2 nuv = (UV-R*.5)/R.y;\n   nuv.y += 0.1;\n   vec2 suv = (UV-R*.5)/R.y;\n \n   vec2 uv2 = uv;\n   vec2 uv3 = uv;\n    \n   uv.x += 0.02*sin(flow(uv, 10., 1.))*smoothstep(uv.y-.5, .1, 0.);\n   uv.y += 0.1;\n    \n   uv2.x += 0.045*sin(flow(uv, 7., .5))*smoothstep(uv2.y-.5, .1, 0.);\n   uv2.y += 0.1;\n    \n   uv3.x += 0.07*sin(flow(uv, 5., .5))*smoothstep(uv2.y-.5, .1, 0.);\n   uv3.y += 0.1;\n    \n   vec2 ruv = (uv2-vec2(0.0,.1)) * ROT(-iTime);\n   vec2 ruv2 = (uv2-vec2(0.0,.1)) * ROT(-iTime*20.);\n \n   float steps = 25.;\n   vec2 id = floor(suv * steps);\n   float idfactor = ((hash2(suv)))/steps*10.;\n\n   \n   \n   vec2 muv = mod(vec2(iTime,.0)-uv*steps,1.)-.5 ;\n   vec2 muv2 = mod(uv*steps*.5,1.)-.5 ;\n   muv = vec2(muv.x, uv.y);\n   muv2 = vec2(uv.x, muv2.y);\n    \n   vec2 muv3 = muv + vec2(.3,.0);\n   vec2 muv4 = muv2 + vec2(.0,.15);\n   vec2 sluv = suv;\n   suv /= +.5+dot(suv,suv);\n    \n   float kong = sdBox( uv + vec2(-0.05,-0.39), vec2(.03, .1));\n   vec2 uvt = uv;\n   uvt.y += sin(.9+-uv.x*20.)*0.03;\n   float kong2 = sdBox( uvt + vec2(-0.015,-0.42), vec2(.052, .01));\n   float kong3 = sdBox( uv + vec2(-0.035,-0.295), vec2(.02, .005));\n   float kong4 = sdBox( uv + vec2(-0.08,-0.44), vec2(.015, .02));\n   \n   float kongt = sdBox( (uv) + vec2(-0.09,-0.435), vec2(.005, .005));\n   float kongt2 = sdBox( (uv) + vec2(-0.07,-0.435), vec2(.005, .005));\n   float kongt3 = sdBox( (uv) + vec2(-0.05,-0.435), vec2(.005, .005));\n   float kongt4 = sdBox( (uv) + vec2(-0.03,-0.435), vec2(.005, .005));\n   \n   \n   float skyline = sdBox( uv - vec2(-.75,-0.3), vec2(.1, .2));\n   float skyline2 = sdBox( uv - vec2(-.25,-0.45), vec2(.07, .2));\n   float skyline3 = sdBox( uv - vec2(-.45,-0.35), vec2(.1, .2));\n   float skyline4 = sdBox( uv - vec2(.25,-0.45), vec2(.1, .2));\n   float skyline5 = sdBox( uv - vec2(.5,-0.3), vec2(.1, .25));\n   float skyline6 = sdBox( uv - vec2(.7,-0.3), vec2(.06, .2));\n   float skyline7 = sdBox( uv - vec2(.9,-0.3), vec2(.06, .3));\n   float skyline8 = sdBox( uv - vec2(-.8,-0.2), vec2(.06, .2));\n   float skyline9 = sdBox( uv - vec2(-.6,-0.4), vec2(.4, .1));\n   float skyline10 = sdBox( uv - vec2(.5,-0.3), vec2(.2, .1));\n   float skyline11 = sdBox( uv - vec2(.7,-0.4), vec2(.2, .1));\n    \n \n   float towerp = sdBox( uv + vec2(0.0,0.5), vec2(.08, .55)); \n   float towerp2 = sdBox( uv - vec2(0.0,0.315), vec2(.06, .01));\n   float towerp3 = sdBox( uv - vec2(0.0,0.258), vec2(.07, .004));\n   float towerp4 = sdBox( uv - vec2(0.0,0.212), vec2(.03, .03));\n   float towerp5 = sdBox( vec2(abs(uv.x),uv.y) - vec2(0.046,0.212), vec2(.004, .03));\n   float towerp6 = sdBox( vec2(abs(uv.x),uv.y) - vec2(0.066,0.212), vec2(.004, .03));\n   float towerp7 = sdBox( abs(uv2-vec2(0.0,.1)) - vec2(0.075, .055),vec2(.004, .004));\n   \n   float tower = sdBox( uv- vec2(0.0,-0.3), vec2(.08, .55));\n   float tower2 = sdBox( uv - vec2(0.0,0.265), vec2(.07, .02));\n   float tower3 = sdBox( uv - vec2(0.0,0.3), vec2(.06, .04));\n   float tower4 = sdBox( uv - vec2(0.0,0.34), vec2(.05, .01));\n   float tower5 = sdBox( uv - vec2(0.0,0.35), vec2(.04, .01));\n   float tower6 = sdBox( uv - vec2(0.0,0.36), vec2(.03, .03));\n   float tower7 = sdBox( uv - vec2(0.0,0.39), vec2(.02, .01));\n   float tower8 = sdBox( uv - vec2(0.0,0.427), vec2(.006, .025));\n    \n   float pattern = sdBox( muv - vec2(0.0,0.0), vec2(.15, .9));\n   float pattern2 = sdBox( muv3 - vec2(0.0,0.0), vec2(.15, .9));\n   float patternh = sdBox( muv2 - vec2(0.0,0.0), vec2(.25, .075));\n   float patternh2 = sdBox( muv4 - vec2(0.0,0.0), vec2(.25, .075));\n    \n   float clockbox = sdBox( uv2 - vec2(0.0,0.1), vec2(.1, .08));\n   float clockboxin = sdBox( uv2 - vec2(0.0,0.1), vec2(.09, .07));\n    \n   float clock = sdBox( uv2 - vec2(0.0,0.1), vec2(.025, .04));\n   float clock1 = sdBox( uv2 - vec2(0.0,0.1), vec2(.045, .02));\n   float clock2 = sdBox( uv2 - vec2(0.0,0.1), vec2(.035, .03));\n    \n   float needle = sdBox( ruv - vec2(0.0,0.01), vec2(.005, .013));\n   float needle2 = sdBox( ruv2 - vec2(0.01,0.0), vec2(.016 , .005));\n    \n   float Tower = min( tower, clockbox);\n   Tower = min( Tower, tower2);\n   Tower = min( Tower, tower3);\n   Tower = min( Tower, tower4);\n   Tower = min( Tower, tower5);\n   Tower = min( Tower, tower6);\n   Tower = min( Tower, tower7);\n   Tower = min( Tower, tower8);\n   \n   float Clock = min(clock, clock1);\n   Clock = min(Clock, clock2);\n    \n   float Needle = min(needle, needle2);\n\n    \n   float Skyline = skyline;\n   Skyline = min(Skyline,skyline2);\n   Skyline = min(Skyline,skyline3);\n   Skyline = min(Skyline,skyline4);\n   Skyline = min(Skyline,skyline5);\n   Skyline = min(Skyline,skyline6);\n   Skyline = min(Skyline,skyline7);\n   Skyline = min(Skyline,skyline8);\n   Skyline = min(Skyline,skyline9);\n   Skyline = min(Skyline,skyline10);\n   Skyline = min(Skyline,skyline11);\n      \n   vec3 Glasses = makeGlasses(uv3);\n     \n   float Pattern = max((pattern/patternh),towerp);\n   Pattern = max(Pattern,clock-clockbox/clockboxin);\n   Pattern = min(Pattern,clockboxin);\n     \n   float Pattern2 = max(min(pattern2,patternh2),towerp);\n   Pattern2 = max(Pattern2,clock-clockbox/clockboxin);\n   Pattern2 = min(Pattern2,clockboxin);\n     \n   float Pattern3 = max (pattern, towerp2);\n   Pattern3 = min(Pattern3,towerp3);\n   Pattern3 = min(Pattern3,towerp4);\n   Pattern3 = min(Pattern3,towerp5);\n   Pattern3 = min(Pattern3,towerp6);\n    \n   float Kong = kong;\n   Kong = min(Kong, kong2);\n   Kong = min(Kong, kong3);\n   Kong = min(Kong, kong4);\n    \n   float Kongt = kongt;\n   Kongt = min(Kongt, kongt2);\n   Kongt = min(Kongt, kongt3);\n   Kongt = min(Kongt, kongt4);\n\n   float Mask = min(Tower,Glasses.y);\n   Mask = min(Mask,smoothstep( .0,.003,Glasses.y));\n \n   float stars = starf(suv, idfactor);\n   float maskfill = smoothstep(0.003,0.,Mask);\n    \n   //float towerstroke = smoothstep(0.003,0.,abs(Tower)-.0003);\n   float towerfill = fill(Tower);\n   float glassesfill = fill(Glasses.x);\n   float paternfill = fill(Pattern);\n   float paternfill2 = fill(Pattern2);\n   float paternfill3 = fill(Pattern3);\n   float paternfill4 = fill(towerp7);\n   float clockfill = fill(Clock);\n   float needlefill = fill(Needle);\n   float antennafill =fill(tower8);\n   float skylinefill =fill(Skyline);\n   float kongfill =fill(Kong);\n    \n    \n   float lines = 0.1*smoothstep(.1,.0,length(fract(.25+(suv.y*steps))-.5));\n   lines = max(length(suv.y-.5)*lines,maskfill);\n    \n    \n   vec3 col = .01*vec3(1.-length(uv));\n   col += 0.3*lines;\n   vec3 g = makeGlasses(mod(vec2(-iTime*0.2,.0)+nuv*vec2(5.),1.)-.5);\n   float c= 0.;\n   c += .1*fill(g.x);\n   c -= 5.*clamp(maskfill,.0,1.);\n   c += min(stars, 1.-maskfill);\n   float d = smoothstep(1., 0., length(suv))-maskfill;\n   col += .3*d;\n   c = clamp(c, .0,1.);\n    \n   c+= 0.1*pow(hash2(iTime+suv*3423.456),2.);\n    \n   c -= 0.15*towerfill;\n   c += clockfill;\n   c += 0.1*paternfill;\n   c += 0.05*paternfill2;\n   c += 0.2*paternfill3;\n   c += 0.1*antennafill;\n   c -= needlefill*1.2;\n   c -= paternfill4*.15;\n   c -= glassesfill*2.;\n    \n   col+=c;\n\n   vec3 gl  = vec3(.5,.5,.5)* vec3(glassesfill);\n   gl += smoothstep(.0003,.0,Glasses.y);\n   gl -= 2.*smoothstep(.0003,.0,Glasses.z);\n   col = clamp(col, vec3(.0),vec3(1.));\n   col += gl;\n   col -= skylinefill;\n   \n   vec3 kglasses = makeGlasses((uv-vec2(.051,.42))*3.5);\n   float kongmask = max(kongfill, fill(kglasses.x));\n   kongmask = max(kongmask,fill(kglasses.y));\n   col = clamp(col, vec3(.0),vec3(1.));\n   col -= min(kongmask,kglasses.y);\n   col -= min(kongmask,kglasses.y);\n   col.b -= 1.*kongfill;\n    \n   col += fill(Kongt);\n   col.r+= .5*fill(kglasses.r);\n   col += 2.*fill(kglasses.g);\n   col-= 2.*fill(kglasses.b);\n\n\n   S = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldcWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[252, 252, 291, 320, 592]], "test": "untested"}
{"id": "7l3cD8", "name": "Gloom", "author": "turboplay", "description": "Glloom effect. ", "tags": ["filter", "gloom"], "likes": 1, "viewed": 257, "published": 3, "date": "1659681117", "time_retrieved": "2024-07-30T16:36:48.747184", "image_code": "// MIT\n\nfloat GloomThreshold = 0.25f;\nfloat GloomIntensity = 2.0f; // 0-10\nfloat BaseIntensity = 1.0f; // 0-10\nfloat GloomSaturation = 1.0f; // 0-100\nfloat BaseSaturation = 2.0f; // 0-100\n\n\nvec4 AdjustSaturation(vec4 color, float saturation)\n{\n    float grey = dot(color.rgb, vec3(0.3f, 0.59f, 0.11f));\n    return mix(vec4(grey), color, saturation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0,uv);\n    \n    vec4 base = 1.0 - col;\n    vec4 gloom = clamp((base - GloomThreshold) / (1.0 - GloomThreshold),0.,1.);    \n    \n    // Adjust color saturation and intensity.\n    gloom = AdjustSaturation(gloom, GloomSaturation) * GloomIntensity;\n    base = AdjustSaturation(base, BaseSaturation) * BaseIntensity;\n    \n    // Darken down the base image in areas where there is a lot of bloom,\n    // to prevent things looking excessively burned-out.\n    base *= (1. - clamp(gloom,0.,1.));\n    \n    // Combine the two images.\n    fragColor = 1.0 - (base + gloom);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3cD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 243, 243, 351], [353, 353, 410, 410, 1044]], "test": "untested"}
{"id": "stcyW8", "name": "swirly background", "author": "hazysu", "description": "A colorful background which swirls around.", "tags": ["2d", "noise", "animated", "background"], "likes": 7, "viewed": 329, "published": 3, "date": "1659661191", "time_retrieved": "2024-07-30T16:36:49.667723", "image_code": "// Noise code from https://www.shadertoy.com/view/MtcGRl\nvec2 GetGradient(vec2 intPos, float t) {\n    float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n// Color conversion from https://www.shadertoy.com/view/XljGzV\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 c1 = vec3(0.7750, 0.4800, 0.2300);\nvec3 c2 = vec3(0.9361, 0.4100, 0.5600);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / ((max(iResolution.x, iResolution.y)/10.0) + 800.0);\n    float noiseValA = 0.5 + 0.5 * Pseudo3dNoise(vec3(uv.x * 2.6, uv.y * 2.6, iTime / 20.0));\n    float noiseValB = 0.5 + 0.5 * Pseudo3dNoise(vec3(uv.x * 4.0, uv.y * 4.0, max(sin(noiseValA) * 2.0, 0.8) * 8.0 + iTime / 10.0));\n    fragColor.rgb = hsl2rgb(mix(c1, c2, noiseValB));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 97, 97, 271], [274, 274, 305, 305, 895], [961, 961, 988, 988, 1131], [1214, 1214, 1269, 1269, 1630]], "test": "untested"}
{"id": "Nt3yDH", "name": "Hyperbolic Cross - distance", "author": "iq", "description": "Exact distance to a cross made of four y(x)=1/x curves. It leverages\n// the SDF computed here: [url]https://www.shadertoy.com/view/ftcyW8[/url]", "tags": ["2d", "distancefield", "sdf", "cross", "1x"], "likes": 26, "viewed": 904, "published": 3, "date": "1659652228", "time_retrieved": "2024-07-30T16:36:50.649099", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to the a cross made of four y(x) = 1/x curves. Minimizing the\n// distance squared d²(x,y) = (x-t)²+(y-1/t)² produces a 4th degree\n// polyonomial in t, which I'm solving with Ferrari's Method as described\n// here: https://en.wikipedia.org/wiki/Quartic_equation\n//\n// I added a paramter k in the open range (0,1) to control its shape.\n// Compare to negative squircle here: https://www.shadertoy.com/view/7stcR4\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, float k )\n{\n    // scale\n    float s = 1.0/k - k;\n    p = p*s;\n    // symmetry\n    p = abs(p);\n    p = (p.x>p.y) ? p.yx : p.xy;\n    // offset\n    p += k;\n    \n    // solve quartic (for details see https://www.shadertoy.com/view/ftcyW8)\n    float x2 = p.x*p.x/16.0;\n    float y2 = p.y*p.y/16.0;\n    float r = (p.x*p.y-4.0)/12.0;\n    float q = y2-x2;\n    float h = q*q-r*r*r;\n    float u;\n    if( h<0.0 )\n    {\n        float m = sqrt(r);\n        u = m*cos( acos(q/(r*m) )/3.0 );\n    }\n    else\n    {\n        float m = pow(sqrt(h)+q,1.0/3.0);\n        u = (m+r/m)/2.0;\n    }\n    float w = sqrt(u+x2);\n    float x = p.x/4.0-w+sqrt(2.0*x2-u+(p.y-x2*p.x*2.0)/w/4.0);\n    \n    // clamp arm\n    x = max(x,k);\n    \n    // compute distance to closest point\n    float d = length( p-vec2(x,1.0/x) ) / s;\n\n    // sign\n    return p.x*p.y < 1.0 ? -d : d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float scale = 1.5;\n    \n\tvec2  p = scale*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = scale*2.0/iResolution.y;\n    \n    float k = 0.5 + 0.45*sin(3.14159*iTime);\n    \n    float d = sdHyperbolicCross(p, k);\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-10.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(70.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,4.0*px,abs(d)) );\n    \n    // mouse\n    if( iMouse.z>0.001 )\n    {\n        float d = sdHyperbolicCross(m, k);\n        float l = length(p-m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, abs(l-abs(d))));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, l-px*3.0));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3yDH.jpg", "access": "api", "license": "mit", "functions": [[1633, 1653, 1700, 1713, 2529], [2531, 2531, 2588, 2588, 3435]], "test": "untested"}
{"id": "ftcyW8", "name": "1/x - distance", "author": "iq", "description": "Distance to the 1/x curve.", "tags": ["2d", "distancefield", "sdf", "hyperbola", "1x"], "likes": 22, "viewed": 1050, "published": 3, "date": "1659641757", "time_retrieved": "2024-07-30T16:36:51.542710", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to the y(x)=1/x curve. \n\n\n// Minimizing the distance squared D² = (x-t)²+(y-1/t)² produces\n//\n// t⁴ - xt³ + yt - 1 = 0\n//\n// which can be solved with the quartic formula, as described in Wikipedia:\n// https://en.wikipedia.org/wiki/Quartic_equation. I followed the \n// section \"Summary of Ferrari's method\" and simplified a lot of things\n// (complex branches to reals, trigonometrics, constant unfolding, etc)\n// until I got this expression.\n//\n// I wrote the shader for comparison with the numerically computed version\n// of the SDF implemented here: https://www.shadertoy.com/view/sttyWr\n\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p )\n{\n    p = (p.x>p.y) ? p.yx : p.xy;\n    \n    float x2 = p.x*p.x/16.0;\n    float y2 = p.y*p.y/16.0;\n    float r = (4.0-p.x*p.y)/12.0;\n    float q = x2 - y2;\n    float h = q*q + r*r*r;\n    float u;\n    if( h<0.0 )\n    {\n        float m = sqrt(-r);\n        u = m*cos( acos(q/(r*m))/3.0 );\n    }\n    else\n    {\n        float m = pow(sqrt(h)-q,1.0/3.0);\n        u = (m - r/m)/2.0;\n    }\n    float w = sqrt( u + x2 );\n    float b = p.y - x2*p.x*2.0;\n    float t = p.x/4.0 - w + sqrt( 2.0*x2 - u + b/w/4.0 );\n    \n    float d = length( p-vec2(t,1.0/t) );\n    \n    return p.x*p.y < 1.0 ? d : -d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float scale = 3.0;\n    \n\tvec2  p = scale*fragCoord/iResolution.y;\n    vec2  m = scale*iMouse.xy/iResolution.y;\n    float px = scale/iResolution.y;\n    \n    float d = sdOOX(p);\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(73.33*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,3.0*px,abs(d)) );\n    \n    // mouse\n    if( iMouse.z>0.001 )\n    {\n        float d = sdOOX(m);\n        float l = length(p-m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, abs(l-abs(d))));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, l-px*3.0));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcyW8.jpg", "access": "api", "license": "mit", "functions": [[1817, 1838, 1864, 1864, 2451], [2453, 2453, 2508, 2508, 3228]], "test": "untested"}
{"id": "NtdcDr", "name": "Day 959", "author": "jeyko", "description": "potato  t", "tags": ["mdtmjvm"], "likes": 19, "viewed": 427, "published": 3, "date": "1659635124", "time_retrieved": "2024-07-30T16:36:52.620827", "image_code": "// Fork of \"Day 956\" by jeyko. https://shadertoy.com/view/7l3yz4\n// 2022-08-04 09:07:01\n\n// Fork of \"Day 955\" by jeyko. https://shadertoy.com/view/fttyR8\n// 2022-08-01 07:12:45\n\n// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    C *= 0.;\n    \n    float sc = 1./(1.+0.*max(15.*float(lightMode == 1.)*max(sin(iTime*2.),0.)*sin(iTime*0.5),0.));\n    \n    float md = 14.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(iTime*md)),hash11(ceil(iTime*md)),fract(iTime*md)),0.5)*0.;\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    float db = sdBox(nuv,vec2(0.4 + float(lightMode==0.)*float(fract(iTime*0.125)<0.5)*0.24,0.4));\n    \n    vec4 aa = Ta(uv);\n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    \n    \n    \n    //vec2 st = 0.4/R.xy + 0.1*sin(iTime)*float(hash11(floor(iTime)) < 1. && lightMode == 0.);\n    vec2 st = (0.1 + 0.*float((fract(iTime*0.2)) < 0.5 && lightMode == 0.))/R.xy;\n    \n    int cmp = 3 - int(lightMode);\n    float l = \n        Tb(uv + vec2(st.x,0))[cmp]-(Tb(uv - vec2(st.x,0)))[cmp] +\n        Tb(uv + vec2(0,st.y))[cmp]-(Tb(uv - vec2(0,st.y)))[cmp] +\n        Tb(uv + vec2(st.xy))[cmp]-(Tb(uv - vec2(st.xy)))[cmp] +\n        Tb(uv + vec2(st.x,-st.y))[cmp]-(Tb(uv - vec2(st.x,-st.y)))[cmp]\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    //a.xz = vec4(l);\n    \n    \n    \n    if(db > 0.){\n        //b = 1.-step(b,vec4(0.4,0.1,0.4,1));\n        b *= 0.1;\n        //b = 1.-b;\n    }\n\n\n    \n    C += vec4 (1)- b*1. - abs(a.y)*0. ;\n    \n    C = mix(C,vec4(0),l );\n    C = mix(C,vec4(0),aa.x );\n    // britney\n    C *= Td(uv);\n        \n        \n    uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    if(lightMode == 0.){\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        p.y *= 0.1;\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.003;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        if((id.x) > 28.){\n            if(r.y < 0.1){\n                if(r.x < 0.5)\n                    d = abs(d) - 0.0004;\n                \n                //C = mix(C,vec4(0),smoothstep(0.001,0.,d));\n                \n            } else if(r.x < 0.5){\n                C = mix(C,vec4(0),1.);\n                \n            }\n               \n        }\n         \n    }\n    \n    {\n        // ui crosses\n        vec2 p = uv;\n        \n        vec2 sid = vec2(float(p.x > 0.),float(p.y > 0.))*2. - 1.;\n        p = abs(p) - vec2(0.45,0.2);\n        float md = 0.0156;\n        \n        float trig = fcondmore(iTime, 0.1,0.3);\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        vec2 sz = vec2(0.004,0.004 + trig);\n        float d = sdBox(p.xy,sz);\n        d = length(p.xy);\n        if(lightMode == 1.)\n            d = min(d,sdBox(p.xy,sz.yx)) ;\n        if(trig == 1.)\n            d = max(d,-sdBox(p.xy,vec2(0.003))) ;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        if(abs(id.x) < 1. + trig*1. && abs(id.y) < 1. + hash12(sid + floor(iTime*4.))*1.*(lightMode*2.-1.)*(1. + trig*1. )){\n        \n            if(d < 0.){\n                C = vec4(1);\n                if(r.y < 0.4){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n\n                }    \n            } else{\n                C = 1. - C;\n            }\n            \n               \n        }    \n    \n        // ui;\n        p = uv;\n        \n        md = 0.0156;\n        \n        id = floor(p/md);\n        p = pmod(p,md); \n        \n        d = length(p.xy) - 0.004;\n        \n        ra = hash12(id + 10.);\n        r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        \n        if(abs(id.y) < 4. && (id.x) < -28.){\n        \n            if(  sin(iTime + sin(r.y*3.)*4.)> 0.){\n                if(r.y < 0.1){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n\n                }\n\n            } else{\n                C = vec4(0);\n            }\n        } \n         \n    }    \n    \n    vec3 n = hash33(vec3(U,mod(iTime,200.)));\n    vec3 nb = hash33(vec3(U,mod(iTime,5200.)));\n    //C = mix(C,n.xyzx,n.xyzz);\n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    C = mix(C,1.-C,float(fract(iTime*0.2) < 0.05)*lightMode);\n    \n    //C = mix(C,1.-C,smoothstep(dFdx(nuv.x),0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    C = max(C,vec4(0.01));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define lightMode float(fract(iTime*0.2) <0.5 )\n\n#define hardMode(t) float(fract(t*0.1) >0.8 )\n\n#define fcondless(t,c,l) float(fract(t*c) < l)\n#define fcondmore(t,c,l) float(fract(t*c) > l)\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt,float t){\n    \n    lookAt.z = 4.;\n    lookAt.y = 0. + 2. * hardMode(t);\n    lookAt.x = 0.0;\n    lookAt += 0.2*sin(t*vec3(1,0.8,0.9));\n    \n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\nvec3 getRo(float t, vec2 m, vec2 r){\n    vec3 ro = vec3(0,1.,-0.8);\n    ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    //ro.yz *= rot(sin(t)*0.4);\n    \n    //ro.xz *= rot((t + sin(t*1.4))*0.2);\n    ro.xz *= rot(m.x/r.x - 0.5);\n    ro.yz *= rot(m.y/r.x - 0.5);\n    return ro;\n}\n\n\n\n// iq\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 5.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "vec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    \n    \n    \n    if(abs(id.y) < 1. && id.x < 16.  && id.x >= 0. && char < 200.){\n        if( id.x < 16. - n14(idx + 200.).x*15. ){\n            vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n            t = letter.w - opacity;\n            if(abs(p.x-1./16./2.)>1./16./2.)\n                t = 10e4;\n\n            t /= s*10.1;\n        } else {\n            return -10.;\n        }\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = 1. + 0.*floor(hash11(floor(iTime + 200.))*8.)*float(hash11(floor(iTime)) < 0.2);\n    fragCoord = floor(fragCoord/sc)*sc;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    \n    \n   fragColor *= 0.;\n   if((lightMode==0.)){\n        vec2 p = (uv + vec2(-0.58,0.))*15.;\n        p.y += iTime;\n        float md = 0.4;\n        float id = floor(p.y/md);\n        p.y = mod(p.y,md);\n        if(mod(id*0.1 + sin(iTime*0.1+id),1.) < 0.5){\n            float td = text(p, float[4*4](\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,96.,96.,96.\n                ), -0.5 , 0.2 , false, 0., 0.5 , true, id);\n            fragColor = mix(fragColor,vec4(1),smoothstep(0.004,0.,td));\n        }\n        \n        \n    }  \n    \n    //col = 1.- col;\n    //fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// raymarch\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\nfloat gid;\n\nfloat map(vec3 p){\n    \n    \n    //float n = noise(p*10.)*0.01;\n    \n    float d = 10e5;\n    \n    \n    if(fract(iTime*0.125) < 0.5)\n        d = min(d,abs(abs(p.x )- 4.));\n    //p.y;\n    \n    p.x = abs(p.x);\n    \n    p.z += (iTime + sin(iTime)*0.7)*0.5;\n    \n    float md = 0.2 + 0.6 * (1.-lightMode)*mod(floor(iTime*0.2),2. );\n    \n    float id = gid = p.z/md;\n    p.z = pmod(p.z,md);\n   \n   \n    float sz = 0.003 + float(fract(iTime*0.15) > 0.9)*0.01;\n    p.x -= 0.4;\n    p.xy *= rot(4.5 + sin(id));\n    \n    \n    float noodlePer = 0.1;\n    float noodles = float(fract(iTime*0.1) < 0.4);\n    float noodlesId = floor(iTime*0.1);\n    \n    if(noodles == 1.)\n        p.x += sin(dot(p,p)*(1.) - iTime)*0.4;\n        \n    d = min(d,length(p.xz) - sz);\n    \n    \n    for(float i = 0.; i < 1.; i++){\n        p.xy = (abs(p.xy -1.*sin(id + iTime*0.4)*.3) ) * rot(1.5 + sin(id + iTime*0.1));\n\n        d = min(d,length(p.xz) - sz);\n\n    }\n    \n    \n    //d -= abs(noise(p*01.401))*0.01;\n    //p.xy *= rot(p.z + sin(iTime + p.z)*4.);\n    \n    //d -= noise(p*1.)*max(noise(p*4. + 14.),0.)*0.04;\n    //d = min(d, \n    //    length(p.xy) + sin(p.z + iTime)*0.3*noise(p*5.)*0.8 - 0.1  + smoothstep(1.,1.,abs(p.z))\n    //);\n    return d;\n}\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001 + lightMode*0.01,0.);\n    \n    return normalize(vec3(\n        map(p + vec3(t.xyy)) - map(p - vec3(t.xyy)),\n        map(p + vec3(t.yxy)) - map(p - vec3(t.yxy)),\n        map(p + vec3(t.yyx)) - map(p - vec3(t.yyx))\n    ));\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    float sc = 1. + 3.*float(fract((iTime + 2.)*0.15) < 0.1) ;\n    U = floor(U/sc)*sc;\n    \n    vec2 uv = (U-0.5*R.xy)/max(R.x,R.y)*(1. ) ;\n    //uv += vec2(.6,0)*float(fract(iTime*14.2) < 0.4)*float(fract(iTime*2.2) < 0.1);\n    //vec2 t = 1./R.xy;\n    //vec4 l = vec4(\n    //    luma(Ta(uv + vec2(t.x,0)))-luma(Ta(uv - vec2(t.x,0))) +\n    //    luma(Ta(uv + vec2(0,t.y)))-luma(Ta(uv - vec2(0,t.y)))\n    //);\n    //l = abs(l);\n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    C -= C;\n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,0.5));\n    //rd = getRd(ro, lookAt,  uv );\n    \n    float t = 0.;\n    vec3 p = ro;\n    bool hit = false;\n    for(float i = 0.; i < 1840. - 500.*float(fract(iTime*0.25)>0.8); i++){\n        float d = map(p);\n        \n        if(d < 0.001){\n            hit = true;\n            break;\n        } else if(t > 24.5){\n            break;\n        }\n        d *= 0.06;\n        \n        p = ro + rd * (t += d);\n    }\n    if(hit == false){\n        t = 1000.;\n    } else{\n        \n        vec3 n = getNormal(p);\n        \n        \n        C.x += max(dot(n,normalize(vec3(4,1.,-2. + lightMode*14.* float(mod(gid + iTime*1.,2.))<1.))),0.);\n        \n        \n        //C.y = gid;\n    }\n    \n    uv = U/R.xy*(1. );\n    \n    \n    vec2 st = 1.4/R.xy;\n   \n    float tPrev = Tb(uv).x;\n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x\n    ;\n    \n    \n    C.w = t;\n    \n    //C.y = l;\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// dither\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2 + idx)),14.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 4. - hash11(idx)*4.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    int dithsc = (2 + 1*int(fract(iTime*0.1) < 0.2));\n    \n    vec2 dithu = U.xy/vec2(textureSize(iChannel1,0).xy*dithsc);\n       \n    \n    \n    if(enva(iTime) < 0.25)\n        dithu = vec2(\n            mod(U.y/float(dithsc),float(textureSize(iChannel1,0).x)),\n            mod(floor(U.y/float(dithsc))/float(textureSize(iChannel1,0).x),float(textureSize(iChannel1,0).y))\n        );\n   \n    float dith = texture(iChannel1,dithu).x;\n    \n    \n    float quant = 2. - hardMode(iTime)*1.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    vec3 currColHsv = rgb2hsv(s.x*vec3(1));\n    s = hsv2rgbSmooth(currColHsv*vec3(1,0.2,1.) + vec3(0.3,0.1,0.*hardMode(iTime) )).xyzz;\n    //s = vec4(luma(s));\n    //s = vec4(s.x);\n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n    //C = sin(Ta(uv));\n    \n   \n    vec3 Chsv = rgb2hsv(C.xyz);\n\n    vec3 hit = vec3(0);\n    float similarity = -0.;\n    for(int i = 0; i < 4*4; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        palCHsv.b += sin(iTime*(1. + float(fract(iTime*0.5) < 0.5)) + float(i))*1.;\n        float localSimilarity = dot(palCHsv.b, Chsv.b);\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz *= hit;\n    \n    uv = (U - 0.5*R.xy)/R.y;\n    \n   \n          /*\n    \n    vec3 OC = C.xyz;\n    \n    C = vec4(1);\n    \n    float sc = 1.;\n    U = floor(U/sc)*sc;\n    \n    uv = (U - 0.5*R.xy)/R.y;\n    \n    float rep = 0.004;\n    \n    float idd = floor(uv.y/rep);\n    uv.y = floor(uv.y / rep)*rep; \n      \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n\n    {\n        \n        vec2 lastDotPos = vec2(0);\n        float lastDD = 10e5;\n        for(float i = 0.; i < 140.; i++){\n            vec3 dotPos = max(hash31(i + 20.),0.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*4.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            //lp *= rot(exp(-fract(iTime*sin(i) + sin(i)*20.)*4.)*pi);\n            \n            float d;\n            \n            vec2 r = hash21(i);\n            \n            if(i < 20.){\n                d = max(\n                    min(abs(lp.x),abs(lp.y)),\n                    sdBox(lp,vec2(0.1,0.01))\n                    ) - 0.001 - 0.00*pow(abs(sin(i + iTime)),5.);\n            }else{\n                lp *= rot(iTime + i + sin(iTime*2. + i));\n            \n                 if(i<130.){\n                    float dd = length(lp) - 0.04*sin(i + iTime + sin(iTime + i));\n\n                    if(r.y > 0.5)\n                        d = abs(dd) - 0.001 ;\n                    else\n                        d = (dd) - 0.001 ;\n\n                    if(lightMode == 0.){\n\n                       float l = sdSegment(uv,projPos.xy,lastDotPos.xy)-0.004*(sin(i + iTime*2.));\n                       if(mod(idd,2.) == 0.)\n                           l = 10e5;\n                       d = min(d,max(max(l,-dd),-lastDD));\n                    }\n\n                    lastDD = dd;\n\n                } else {\n                    if(lightMode == 0.)\n                        continue;\n                    d = length(lp.y) - 0.004 ;\n                }\n            }\n            \n            lastDotPos = projPos.xy;\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n            C -= smoothstep( 1./R.x, 0. , d);\n        }\n        \n        for(float i = 0.; i < 40. - 30.*lightMode; i++){\n            vec3 dotPos = max(hash31(i + 100.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n\n            float sc = 8. + sin(i)*5.;\n            lp *= sc;\n            //uv *= 2.;\n\n            float td = text(lp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.47 , true, i);\n            \n            //col = mix(col,vec3(1),smoothstep(0.4*fwidth(td)*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n            C = mix(C,vec4(0),smoothstep(0.4*0.01*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n\n        }\n\n        \n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n\n        \n    \n    }\n    */\n    C = clamp(C,0.,1.);\n    //C = mix(vec4(OC.xyz,1),vec4(1,1,1,0),dot(1.-C.x,1.-C.x));\n    //C = currC;\n    \n}", "buffer_c_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    char -= 544. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 oU = U;\n    float sc = 4. + 4.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    uv.x = abs(uv.x);\n    \n    uv.x -= 0.4;\n    vec2 t = 1./R.xy;\n    \n    \n    \n    vec2 prevP = vec2(0);\n    \n    float d = 10e4;\n    for(float i = 0.; i < 0.; i++){\n        vec2 k = vec2(sin(i*0.7 + sin(iTime + i)), cos(i*1.5 + iTime)*2.)*0.1;\n            \n            \n            \n        d = min(d,sdSegment(uv,k,prevP) - 0.004 - noise(vec3(i+iTime + sin(iTime + i),uv*5.))*0.01);\n        \n        \n        prevP = k;\n    }\n   \n   float od = d;\n   d = abs(d);\n   C *= 0.;\n   //C += 1.; // epic lol\n   \n   \n\n   C= mix(C,1.-C,smoothstep(0.,fwidth(d),d - 0.004));\n   \n   if(od < 0.)\n       return;\n   U = oU;\n    sc = 1. + 0.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   \n   u += 1. - hash11(floor(iTime) + 200.)*1.8;\n   u *= 0.4 - hash11(floor(iTime))*0.1;\n   u*=2. + floor((hash11(floor(iTime/3.))*4.));\n   u.x /= 1.;\n   \n\n    //u += 1./3.;\n   if(u.x < 1. && u.y < 1. && u.x > 0. && u.y > 0. && fract(iTime) < 0.2 && sin(iTime) < 0.){\n       vec4 britney =  texture(iChannel1,u);\n       \n       vec2 dithu = oU.xy/vec2(textureSize(iChannel1,0).xy*(1 + 0*int(fract(iTime*0.1) < 0.2)));\n       \n       float dith = texture(iChannel2,dithu).x;\n        \n    \n        float quant = 1.;\n        float recipQuant = 1./quant;\n\n        vec4 s = Tb(uv);\n        vec4 currC = floor(s*quant)/quant;\n        vec4 nextC = clamp(currC + recipQuant,0.,1.);\n        float perc = fract(luma(s)*quant);\n\n\n\n\n        if(perc>dith){\n            britney = nextC;\n        } else{\n            britney = currC;\n        }\n\n       //britney = hsv2rgbSmooth(currColHsv*vec3(0.2,0.,1.) + vec3(1. + iTime,0.5,0.)).xyzz;\n\n       C -= 1.- britney;\n   }\n    \n    \n    sc = 2.;\n    U = floor(U/sc)*sc;   \n    uv = (U-R.xy*0.5)/R.y;\n    \n    float pxsz = 0.001;\n    float tt =10e5;\n\n \n             \n            \n    C = mix(C,(0.6-C) ,smoothstep(pxsz + 0.01,0., tt - 0.01));\n    \n    uv = (oU-R.xy*0.5)/R.y;\n    \n    if(fract(iTime*0.5)>0.75)\n    for(float i = 0.; i < 2. - 4.*hash11(floor(iTime) ); i++){\n        vec3 dotPos = max(hash31(i + 1200. + floor(iTime)),0.4)*2. - 1.;\n        vec2 lp = uv - dotPos.xy;\n        lp *= 17.4;\n\n        float md = 0.3;\n        float id = floor(lp.y/md);\n        if(id < 2. || id > 9. + sin(i)*20.)\n            continue;\n        lp.y = mod(lp.y,md);\n        float td = textb(lp, float[4*4](\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,96.,96.,96.\n            ), -0.5 , 0.2 , false, 0., 0.47 , true, id + i*20. + floor(iTime*10.));\n        C = mix(C,vec4(0),smoothstep(0.001,0.,td - 0.4));\n    }\n    \n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}", "buffer_d_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[763, 763, 803, 803, 5379]], "test": "untested"}
{"id": "7ldyWn", "name": "Diagonal Weave", "author": "cmzw", "description": "hi-tech looking weaving stripes", "tags": ["2d", "scifi", "weave"], "likes": 8, "viewed": 341, "published": 3, "date": "1659624430", "time_retrieved": "2024-07-30T16:36:53.374812", "image_code": "// hash12 from https://www.shadertoy.com/view/4djSRW\nfloat h(vec2 p)\n{\n\tvec3 a  = fract(vec3(p.xyx) * .1031);\n    a += dot(a, a.yzx + 33.33);\n    return fract((a.x + a.y) * a.z);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 p = I / 40.;\n    \n    O = vec4(step(abs(abs(fract(dot(vec2((floor(h(ceil(p))*2.-.5)),1),p))-.5)-.38),.06));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 70, 70, 180], [182, 182, 223, 223, 342]], "test": "untested"}
{"id": "sldyDn", "name": "Textured Nested Block 3", "author": "pyBlob", "description": "inspired by reference:  https://twitter.com/kineticgraphics/status/1537861671296741376\n\nimproving https://www.shadertoy.com/view/7ldyRH\nimproving https://www.shadertoy.com/view/slccz7", "tags": ["raytracing", "short", "golf", "reproduction"], "likes": 11, "viewed": 347, "published": 3, "date": "1659615906", "time_retrieved": "2024-07-30T16:36:54.395084", "image_code": "// Thanks to FabriceNeyret2 for the inspiration + golfing\n\n// vec3: 783 (-3 R(a), -4 bias)\n#define E(x)     .1 * sin( k = min(0., x) *2e2 ) / (k - .1)\n\n#define S(n)                             \\\n    s = exp2(T+i)/4.,                    \\\n    c = (f - W/s).n + L,                 \\\n    k = c.x/D.n.x,                       \\\n    M = abs(v = k * D.n - c),            \\\n    Z = texture(iChannel0, .5*v.yz + .5, -1.) \\\n         * vec4(u+ .3*L.n, 1)            \\\n         * exp(.6-.1*s*k),               \\\n        M.y < u && M.z < u               \\\n        && k > 0.                        \\\n        && C.w < Z.w                     \\\n      ? C = Z : C,\n\n#define B(v, j)                      \\\n    P.v += E(m=j-i-T),               \\\n    f = -u-2.*vec3(--l/4,l/2&1,l&1), \\\n    f.v += 50. * m - k / 4.,         \\\n    S(xyz) S(yxz) S(zyx)\n\n#define A           \\\n    for ( i=-u      \\\n        ; l=8       \\\n        , B(x, .2 ) \\\n          B(z, .55) \\\n          B(y, .5 ) \\\n          B(y, .7 ) \\\n          B(x, .45) \\\n          B(z, .65) \\\n          B(x, .75) \\\n          ++i<6.    \\\n        ; )         \\\n        ;\n\n#define R(a) mat2(cos(a+vec4(0,11,33,0)))\n#define r(v) v.xy *= R(M.x); v.xz *= R(M.y);\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    int   l;\n    float k, i, m,\n          s = iTime / 5.,\n          T = fract(s),\n          u = 1.;\n    vec4  Z;\n    vec3  c, v, f,\n          W = iResolution,\n          P = W/W    , //   vec3(1, 1, 1)\n          L = P/W.zxy, // ~ vec3(1, 0, 0)\n          D = vec3(U+U,0) - W.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/W.xyy-.5 : W-W;\n    D.xy *= R((floor(s) + min(u,1e2*T*T) + E(.1-T))/.955); // 1./.955 ~ 2. * pi / 6.\n    D = D / vec3(1.77,3,1.1) / W.x   * mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    r(D) r(P)\n    A C -= C; W = P; A\n\n    //s = iResolution.x; T = U.x/s;\n    //if (abs(U.x-fract(iTime/5.)*s)<1.) C = vec4(1,0,0,1); // T = T from above\n    //if (abs(U.y-iResolution.y/6.)<1.) C = vec4(1); // y = 0\n    //if (abs(U.y-iResolution.y/6.*4.)<1.) C = vec4(1); // y = 1\n    //C.r += float(abs(E(-T)*iResolution.y*10.+iResolution.y/6.-U.y) < 1.); // Sinc bounce\n    //C.r += float(abs(smoothstep(.0,.1,T)*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Smoothstep ease\n    //C.g += float(abs((min(1.,1e2*T*T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic ease\n    //C.b += float(abs((min(1.,1e2*T*T) + E(.1-T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic start + Sinc bounce ~ C1 continuous loop\n}\n\n/*\n// simplify fog, move square scale into square: 794\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define E(x)     .1 * sin( k = min(0., x) *2e2 ) / (k - .1)\n\n#define S(n)                             \\\n    s = exp2(T+i)/4.,                    \\\n    c = (f - R/s).n + L,                 \\\n    k = c.x/D.n.x,                       \\\n    M = abs(v = k * D.n - c),            \\\n    Z = texture(iChannel0, .5*v.yz + .5) \\\n         * vec4(u+ .3*L.n, 1)            \\\n         * exp(.6-.1*s*k),               \\\n        M.y < u && M.z < u               \\\n        && k > 0.                        \\\n        && C.w < Z.w                     \\\n      ? C = Z : C,\n\n#define B(v, j)                     \\\n    P.v += E(m=j-i-T),              \\\n    f = -u-2.*V(--l/4&1,l/2&1,l&1), \\\n    f.v += 50. * m - k / 4.,        \\\n    S(xyz) S(yxz) S(zyx)\n\n#define A           \\\n    for ( i=-u      \\\n        ; l=8       \\\n        , B(x, .2 ) \\\n          B(z, .55) \\\n          B(y, .5 ) \\\n          B(y, .7 ) \\\n          B(x, .45) \\\n          B(z, .65) \\\n          B(x, .75) \\\n          ++i<6.    \\\n        ; )         \\\n        ;\n\n#define r(v) v.xy *= R(M.x); v.xz *= R(M.y);\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    int   l;\n    float k, i, m,\n          s = iTime / 5.,\n          T = fract(s),\n          u = 1.;\n    vec4  Z;\n    V     c, v, f,\n          R = iResolution,\n          P = R/R,\n          L = V(1,0,0),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : R-R;\n    D.xy *= R((floor(s) + min(u,1e2*T*T) + E(.1-T))/.955); // 1./.955 ~ 2. * pi / 6.\n    D = normalize(D / sqrt(V(2, 6, .8)) * mat3(-1,-1,1, 1,-1,1, 0,2,1));\n    r(D) r(P)\n    A C -= C; R = P; A\n\n    //s = iResolution.x; T = U.x/s;\n    //if (abs(U.x-fract(iTime/5.)*s)<1.) C = vec4(1,0,0,1); // T = T from above\n    //if (abs(U.y-iResolution.y/6.)<1.) C = vec4(1); // y = 0\n    //if (abs(U.y-iResolution.y/6.*4.)<1.) C = vec4(1); // y = 1\n    //C.r += float(abs(E(-T)*iResolution.y*10.+iResolution.y/6.-U.y) < 1.); // Sinc bounce\n    //C.r += float(abs(smoothstep(.0,.1,T)*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Smoothstep ease\n    //C.g += float(abs((min(1.,1e2*T*T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic ease\n    //C.b += float(abs((min(1.,1e2*T*T) + E(.1-T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic start + Sinc bounce ~ C1 continuous loop\n}\n*/\n\n/*\n// reduce uses of block scale, replace \"1.\" with constant: 797\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define E(x)     .1 * sin( k = min(0., x) *2e2 ) / (k - .1)\n\n#define S(n)                             \\\n    c = (f - R/s).n + L,                 \\\n    k = c.x/D.n.x,                       \\\n    M = abs(v = k * D.n - c),            \\\n    Z = texture(iChannel0, .5*v.yz + .5) \\\n         * vec4(u+ .3*L.n, 1)            \\\n         * exp(.6-.1*s*length(c+v)),     \\\n        M.y < u && M.z < u               \\\n        && k > 0.                        \\\n        && C.w < Z.w                     \\\n      ? C = Z : C,\n\n#define B(v, j)                     \\\n    P.v += E(m=j-i-T),              \\\n    f = -u-2.*V(--l/4&1,l/2&1,l&1), \\\n    f.v += 50. * m - k / 4.,        \\\n    S(xyz) S(yxz) S(zyx)\n\n#define A \\\n    for ( s = exp2(T)/4., i=-u ; ++i<6. ; ) \\\n        l=8,      \\\n        B(x, .2 ) \\\n        B(z, .55) \\\n        B(y, .5 ) \\\n        B(y, .7 ) \\\n        B(x, .45) \\\n        B(z, .65) \\\n        B(x, .75) \\\n        s+=s;\n\n#define r(v) v.xy *= R(M.x); v.xz *= R(M.y);\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    int   l;\n    float k, i, m,\n          s = iTime / 5.,\n          T = fract(s),\n          u = 1.;\n    vec4  Z;\n    V     c, v, f,\n          R = iResolution,\n          P = R/R,\n          L = V(1,0,0),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : R-R;\n    D.xy *= R((floor(s) + min(u,1e2*T*T) + E(.1-T))/.955); // 1./.955 ~ 2. * pi / 6.\n    D /= sqrt(V(2, 6, .8));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    r(D) r(P)\n    A C -= C; R = P; A\n\n    //s = iResolution.x; T = U.x/s;\n    //if (abs(U.x-fract(iTime/5.)*s)<1.) C = vec4(1,0,0,1); // T = T from above\n    //if (abs(U.y-iResolution.y/6.)<1.) C = vec4(1); // y = 0\n    //if (abs(U.y-iResolution.y/6.*4.)<1.) C = vec4(1); // y = 1\n    //C.r += float(abs(E(-T)*iResolution.y*10.+iResolution.y/6.-U.y) < 1.); // Sinc bounce\n    //C.r += float(abs(smoothstep(.0,.1,T)*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Smoothstep ease\n    //C.g += float(abs((min(1.,1e2*T*T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic ease\n    //C.b += float(abs((min(1.,1e2*T*T) + E(.1-T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic start + Sinc bounce ~ C1 continuous loop\n}\n*/\n\n/*\n// packed block center, block as expression: 798\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define E(x)     .1 * sin( k = min(0., x) *2e2 ) / (k - .1)\n\n#define S(n)                               \\\n    c = (s*f - R).n + s*L,                 \\\n    k = c.x/D.n.x,                         \\\n    M = abs(v = k * D.n - c),              \\\n    Z = texture(iChannel0, .5/s*v.yz + .5) \\\n         * vec4(1.+ .3*L.n, 1)             \\\n         * exp(.6-.1*length(c+v)),         \\\n        M.y < s && M.z < s                 \\\n        && k > 0.                          \\\n        && C.w < Z.w                       \\\n      ? C = Z : C,\n\n#define B(v, j)                      \\\n    P.v += E(m=j-i-T),               \\\n    f = -1.-2.*V(--l/4&1,l/2&1,l&1), \\\n    f.v += 50. * m - k / 4.,         \\\n    S(xyz) S(yxz) S(zyx)\n\n#define A \\\n    for ( s = exp2(T)/4., i=-1. ; ++i<6. ; ) \\\n        l=8,      \\\n        B(x, .2 ) \\\n        B(z, .55) \\\n        B(y, .5 ) \\\n        B(y, .7 ) \\\n        B(x, .45) \\\n        B(z, .65) \\\n        B(x, .75) \\\n        s+=s;\n\n#define r(v) v.xy *= R(M.x); v.xz *= R(M.y);\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    int   l;\n    float k, i, m,\n          s = iTime / 5.,\n          T = fract(s);\n    vec4  Z;\n    V     c, v, f,\n          R = iResolution,\n          P = R/R,\n          L = V(1,0,0),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : R-R;\n    D.xy *= R((floor(s) + min(1.,1e2*T*T) + E(.1-T))/.955); // 1./.955 ~ 2. * pi / 6.\n    D /= sqrt(V(2, 6, .8));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    r(D) r(P)\n    A C -= C; R = P; A\n\n    //s = iResolution.x; T = U.x/s;\n    //if (abs(U.x-fract(iTime/5.)*s)<1.) C = vec4(1,0,0,1); // T = T from above\n    //if (abs(U.y-iResolution.y/6.)<1.) C = vec4(1); // y = 0\n    //if (abs(U.y-iResolution.y/6.*4.)<1.) C = vec4(1); // y = 1\n    //C.r += float(abs(E(-T)*iResolution.y*10.+iResolution.y/6.-U.y) < 1.); // Sinc bounce\n    //C.r += float(abs(smoothstep(.0,.1,T)*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Smoothstep ease\n    //C.g += float(abs((min(1.,1e2*T*T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic ease\n    //C.b += float(abs((min(1.,1e2*T*T) + E(.1-T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic start + Sinc bounce ~ C1 continuous loop\n}\n*/\n\n/*\n// more golfing by Fabrice + even more golfing + uniform ease: 819\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define E(x)     .1 * sin( k = min(0., x) *2e2 ) / (k - .1)\n\n#define S(n)                               \\\n    c = (s*f - R).n + s*L,                 \\\n    k = c.x/D.n.x,                         \\\n    M = abs(v = k * D.n - c),              \\\n    Z = texture(iChannel0, .5/s*v.yz + .5) \\\n         * vec4(1.+ .3*L.n, 1) * exp(.6-.1*length(c+v)), \\\n        M.y < s && M.z < s                 \\\n        && k > 0.                          \\\n        && C.w < Z.w                       \\\n      ? C = Z : C;\n\n#define B(a,b,c, v, j)                      \\\n    P.v += E(m=j-i-T),                      \\\n    f = -V(a,b,c); f.v += 50. * m - k / 4., \\\n    S(xyz) S(yxz) S(zyx)\n\n#define A \\\n    for ( s = exp2(T)/4., i=-1. ; ++i<6. ; s+=s ) \\\n    { \\\n        B(3,3,3, x, .2 ) \\\n        B(1,3,3, x, .45) \\\n        B(3,1,3, y, .5 ) \\\n        B(3,3,1, z, .55) \\\n        B(3,1,1, y, .7 ) \\\n        B(1,3,1, z, .65) \\\n        B(1,1,3, x, .75) \\\n    }\n\n#define r(v) v.xy *= R(M.x); v.xz *= R(M.y);\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float k, i, m,\n          s = iTime / 5.,\n          T = fract(s);\n    vec4  Z;\n    V     c, v, f,\n          R = iResolution,\n          P = R/R,\n          L = V(1,0,0),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : R-R;\n    D.xy *= R((floor(s) + min(1.,1e2*T*T) + E(.1-T))/.955); // 1./.955 ~ 2. * pi / 6.\n    D /= sqrt(V(2, 6, .8));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    r(D) r(P)\n    A C -= C; R = P; A\n\n    //s = iResolution.x; T = U.x/s;\n    //if (abs(U.x-fract(iTime/5.)*s)<1.) C = vec4(1,0,0,1); // T = T from above\n    //if (abs(U.y-iResolution.y/6.)<1.) C = vec4(1); // y = 0\n    //if (abs(U.y-iResolution.y/6.*4.)<1.) C = vec4(1); // y = 1\n    //C.r += float(abs(E(-T)*iResolution.y*10.+iResolution.y/6.-U.y) < 1.); // Sinc bounce\n    //C.r += float(abs(smoothstep(.0,.1,T)*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Smoothstep ease\n    //C.g += float(abs((min(1.,1e2*T*T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic ease\n    //C.b += float(abs((min(1.,1e2*T*T) + E(.1-T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic start + Sinc bounce ~ C1 continuous loop\n}\n*/\n\n/*\n// non-bouncy camera turn: 798\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n\n#define S(n)                               \\\n    c = (s*f - R).n + s*L,                 \\\n    k = c.x/D.n.x,                         \\\n    M = abs(v = k * D.n - c),              \\\n    Z = texture(iChannel0, .5/s*v.yz + .5) \\\n         * vec4(1.+ .3*L.n, 1) * exp(.6-.1*length(c+v)), \\\n        M.y < s && M.z < s                 \\\n        && k > 0.                          \\\n        && C.w < Z.w                       \\\n      ? C = Z : C;\n\n#define B(a,b,c, v, j)                                      \\\n    P.v += .1 * sin(k = min(0., m = j-i-T)*2e2) / (k - .1), \\\n    f = -V(a,b,c); f.v += 50. * m - k / 4.,                 \\\n    S(xyz) S(yxz) S(zyx)\n\n#define A \\\n    for ( s = exp2(T)/4., i=-1. ; ++i<6. ; s+=s ) \\\n    { \\\n        B(3,3,3, x, .2 ) \\\n        B(1,3,3, x, .45) \\\n        B(3,1,3, y, .5 ) \\\n        B(3,3,1, z, .55) \\\n        B(3,1,1, y, .7 ) \\\n        B(1,3,1, z, .65) \\\n        B(1,1,3, x, .75) \\\n    }\n\n#define r(v) v.xy *= R(M.x); v.xz *= R(M.y);\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float k, i, m,\n          s = iTime / 5.,\n          T = fract(s);\n    vec4  Z;\n    V     c, v, f,\n          R = iResolution,\n          P = R/R,\n          L = V(1,0,0),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : R-R;\n    D.xy *= R((\n        floor(s)\n        + smoothstep(0., .1, T)\n    )/.955); // 1./.955 ~ 2. * pi / 6.\n    D /= sqrt(V(1, 3, .4));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    r(D) r(P)\n    A C -= C; R = P; A\n}\n*/\n\n/*\n// streamline ease and ensure C1 continuity: 866\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define E(x) (k = min(0., x)*19., k==0. ? 0. : .1 * sin(k) / (k - .1))\n\n#define S(n)                               \\\n    c = (s*f - R).n + V(s,0,0),            \\\n    v = c.x/D.n.x * D.n - c,               \\\n    Z = texture(iChannel0, .5/s*v.yz + .5) \\\n         * vec4(1.+ .3*V(1,0,0).n, 1) * exp(.6-.1*length(c+v)), \\\n        abs(v.y) < s &&  abs(v.z) < s      \\\n        && dot(c+v, D.n) > 0.              \\\n        && C.w < Z.w                       \\\n      ? C = Z : C;\n\n#define B(a,b,c, v, j)                          \\\n    P.v += E((j-i-T) / .1),                     \\\n    f = -V(a,b,c); f.v += 50. * max(0., j-i-T), \\\n    S(xyz) S(yxz) S(zyx)\n\n#define A \\\n    for ( s = exp2(T)/4., i=-1. ; ++i<6. ; s+=s ) \\\n    { \\\n        B(3,3,3, x, .2 ) \\\n        B(1,3,3, x, .45) \\\n        B(3,1,3, y, .5 ) \\\n        B(3,3,1, z, .55) \\\n        B(3,1,1, y, .7 ) \\\n        B(1,3,1, z, .65) \\\n        B(1,1,3, x, .75) \\\n    }\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float s, i, k,\n          T = fract(iTime / 5.);\n    vec4  Z;\n    V     c, v, f,\n          R = iResolution,\n          P = V(1),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : V(0);\n    D.xy *= R((floor(iTime/5.) + min(1.,1e2*T*T) + E(1.-T/.1))/.955); // 1./.955 ~ 2. * pi / 6.\n    D /= sqrt(V(2, 6, .8));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    D.xy *= R(M.x); P.xy *= R(M.x);\n    D.xz *= R(M.y); P.xz *= R(M.y);\n    A C -= C; R = P; A\n\n    //s = iResolution.x; T = U.x/s;\n    //if (abs(U.x-fract(iTime/5.)*s)<1.) C = vec4(1,0,0,1); // T = T from above\n    //if (abs(U.y-iResolution.y/6.)<1.) C = vec4(1); // y = 0\n    //if (abs(U.y-iResolution.y/6.*4.)<1.) C = vec4(1); // y = 1\n    //C.r = float(abs(E(-T)*iResolution.y*10.+iResolution.y/6.-U.y) < 1.); // Sinc bounce\n    //C.r += float(abs(smoothstep(.0,.1,T)*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Smoothstep ease\n    //C.g += float(abs((min(1.,1e2*T*T))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic ease\n    //C.b += float(abs((min(1.,1e2*T*T) + E(1.-T/.1))*iResolution.y/2.+iResolution.y/6.-U.y) < 1.); // Quadratic start + Sinc bounce ~ C1 continuous loop\n}\n*/\n\n/*\n// remove phase loop: 887\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define sinc(x) ( x==0. ? 0. : sin(x) / (x - .1) )\n\n#define S(n)                               \\\n    c = ( s*f - R ) n + V(s,0,0),          \\\n    d = D n,                               \\\n    v = c.x/d.x * d - c,                   \\\n    Z = texture(iChannel0, .5/s*v.yz + .5) \\\n         * vec4(1.+ .3*V(1,0,0)n, 1) * exp(.6-.1*length(c+v)), \\\n        abs(v.y) < s &&  abs(v.z) < s      \\\n        && dot(c+v, d ) > 0.               \\\n        && C.w < Z.w                       \\\n      ? C = Z : C;\n\n#define B(a,b,c, v, j)                          \\\n    P.v += .1* sinc( min(0., j-i-T) *2e2 ),     \\\n    f = -V(a,b,c); f.v += 50. * max(0., j-i-T), \\\n    S(.xyz) S(.yxz) S(.zyx)                     \\\n\n#define A \\\n    for ( s = exp2(T)/4., i=-1. ; ++i<6. ; s+=s ) \\\n    { \\\n        B(3,3,3, x, .2 ) \\\n        B(1,3,3, x, .45) \\\n        B(3,1,3, y, .5 ) \\\n        B(3,3,1, z, .55) \\\n        B(3,1,1, y, .7 ) \\\n        B(1,3,1, z, .65) \\\n        B(1,1,3, x, .75) \\\n    } \\\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float s, i,\n          T = fract(iTime / 5.);\n    vec4  Z;\n    V     c, v, f, d,\n          R = iResolution,\n          P = V(1),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : V(0);\n    D.xy *= R(( floor(iTime/5.) + smoothstep(.0,.1,T) + .1*sinc(min(0., .1-T) *20.) )/6.*6.283 );\n    D /= sqrt(V(2, 6, .8));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    D.xy *= R(M.x); P.xy *= R(M.x);\n    D.xz *= R(M.y); P.xz *= R(M.y);\n    A C -= C; R = P; A\n}\n*/\n\n/*\n// B(a,b,c, ...): 898\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define sinc(x) ( x==0. ? 0. : sin(x) / (x - .1) )\n\n#define S(n)                               \\\n    c = ( s*f - P ) n + V(s,0,0),          \\\n    d = D n,                               \\\n    v = c.x/d.x * d - c,                   \\\n    Z = texture(iChannel0, .5/s*v.yz + .5) \\\n         * vec4(1.+ .3*V(1,0,0)n, 1) * exp(.6-.1*length(c+v)), \\\n        abs(v.y) < s &&  abs(v.z) < s      \\\n        && dot(c+v, d ) > 0.               \\\n        && C.w < Z.w                       \\\n      ? C = Z : C;\n\n#define B(a,b,c, v, j)                            \\\n    if (p == 0)                                   \\\n        P.v += .1* sinc( min(0., j-i-t) *2e2 ) ;    \\\n    else                                          \\\n    {                                             \\\n        f = -V(a,b,c); f.v += 50. * max(0., j-i-t), \\\n        S(.xyz) S(.yxz) S(.zyx)                   \\\n    }\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float s, i,\n          T = fract(iTime / 5.);\n    vec4  Z;\n    V     c, v, f, d,\n          R = iResolution,\n          P = V(1),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : V(0);\n    D.xy *= R(( floor(iTime/5.) + smoothstep(.0,.1,T) + .1*sinc(min(0., .1-T) *20.) )/6.*6.283 );\n    D /= sqrt(V(2, 6, .8));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    D.xy *= R(M.x); P.xy *= R(M.x);\n    D.xz *= R(M.y); P.xz *= R(M.y);\n    for ( int p=0 ; p<2 ; ++p )\n    for ( s = exp2(T)/4., i=-1. ; ++i<6. ; s+=s )\n    {\n        B(3,3,3, x, .2 )\n        B(1,3,3, x, .45)\n        B(3,1,3, y, .5 )\n        B(3,3,1, z, .55)\n        B(3,1,1, y, .65)\n        B(1,3,1, z, .7 )\n        B(1,1,3, x, .75)\n    }\n}\n*/\n\n/*\n// using phase macros: 907\n#define R(a)     mat2(cos(a+vec4(0,11,33,0)))\n#define V        vec3\n#define sinc(x) ( x==0. ? 0. : sin(x) / (x - .1) )\n\n#define S(n)                               \\\n    c = ( s*f - P ) n + V(s,0,0),          \\\n    d = D n,                               \\\n    v = c.x/d.x * d - c,                   \\\n    Z = texture(iChannel0, .5/s*v.yz + .5) \\\n         * vec4(1.+ .3*V(1,0,0)n, 1) * exp(.6-.1*length(c+v)), \\\n        abs(v.y) < s &&  abs(v.z) < s      \\\n        && dot(c+v, d ) > 0.               \\\n        && C.w < Z.w                       \\\n      ? C = Z : C,\n\n#define A(B) \\\n    for ( s = exp2(T)/4., i=-1. ; ++i<6. ; s+=s ) \\\n        B((3,3,3), x, .2 ) \\\n        B((1,3,3), x, .45) \\\n        B((3,1,3), y, .5 ) \\\n        B((3,3,1), z, .55) \\\n        B((3,1,1), y, .65) \\\n        B((1,3,1), z, .7 ) \\\n        B((1,1,3), x, .75) \\\n        0; \\\n\n#define P(c, v, j) \\\n    P.v += .1* sinc( min(0., j-i-T) *2e2 ), \\\n\n#define Q(c, v, j) \\\n    f = -V c, f.v += 50. * max(0., j-i-T), \\\n    S(.xyz) S(.yxz) S(.zyx)                \\\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float s, i,\n          T = fract(iTime / 5.);\n    vec4  Z;\n    V     c, v, f, d,\n          R = iResolution,\n          P = V(1),\n          D = V(U+U,0) - R.xyy,\n          M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : V(0);\n    D.xy *= R(( floor(iTime/5.) + smoothstep(.0,.1,T) + .1*sinc(min(0., .1-T) *20.) )/6.*6.283 );\n    D /= sqrt(V(2, 6, .8));\n    D *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    D.xy *= R(M.x); P.xy *= R(M.x);\n    D.xz *= R(M.y); P.xz *= R(M.y);\n    A(P)\n    A(Q)\n}\n*/\n\n/*\n// initial: 1028\n#define R(a) mat2(cos(a+vec4(0,11,33,0)))\n\n#define sinc(x) (x==0. ? 0. : sin(x) / (x - .1))\n\n#define S(f, n) \\\n{ \\\n    c = (s*(f) - ro - sk) n + vec3(s,0,0); \\\n    v = c.x / (rd n).x * rd n - c; \\\n    vec4 t = texture(iChannel0, .5/s*v.yz + .5) * vec4(1. + .3*vec3(1,0,0) n, 1) * exp(-.1*(length(c+v)-6.)); \\\n    if ( \\\n        abs(v.y) < s && \\\n        abs(v.z) < s && \\\n        dot(c+v, rd n) > 0. && \\\n        C.w < t.w \\\n    ) \\\n        C = t; \\\n} \\\n\n#define A(f) \\\n    S(f, .xyz) \\\n    S(f, .yxz) \\\n    S(f, .zyx) \\\n\n#define B(c, v, i) \\\n    if (p == 0) sk += sinc(min(0., i - t) * 2e2) * .1 * vec3 v; \\\n    else { A(-vec3 c + o * vec3 v * max(0., i - t)) } \\\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    float\n        t, s, i,\n        o = 50.,\n        T = fract(iTime / 5.);\n    vec3\n        c, v,\n        R = iResolution,\n        ro = vec3(1),\n        sk = vec3(0),\n        rd = vec3(O+O,0) - R.xyy,\n        M = iMouse.z>0. ? iMouse.xyz/R.xyy-.5 : vec3(0);\n    rd.xy *= R((floor(iTime / 5.) + smoothstep(.0, .1, T) + .1 * sinc(min(0., .1 - T) * 20.))/6.*6.283);\n    rd /= sqrt(vec3(2, 6, .8));\n    rd *= mat3(-1,-1,1, 1,-1,1, 0,2,1);\n    rd.xy *= R(M.x);\n    ro.xy *= R(M.x);\n    rd.xz *= R(M.y);\n    ro.xz *= R(M.y);\n    for (int p=0 ; p<2 ; ++p)\n    for (s = exp2(T) / 4., i=0. ; t=i-1.+T, i<=5. ; s*=2., ++i)\n    {\n        B((3,3,3), (1,0,0), .2 )\n        B((1,3,3), (1,0,0), .45)\n        B((3,1,3), (0,1,0), .5 )\n        B((3,3,1), (0,0,1), .55)\n        B((3,1,1), (0,1,0), .65)\n        B((1,3,1), (0,0,1), .7 )\n        B((1,1,3), (1,0,0), .75)\n    }\n}\n*/\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7ldcWn", "name": "Celtic knot 4 ( 227 chars )", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/kamoshika_vrc/status/1554813085848051715", "tags": ["2d", "pattern", "2tweets", "short", "golf", "celtic", "reproduction"], "likes": 21, "viewed": 315, "published": 3, "date": "1659612951", "time_retrieved": "2024-07-30T16:36:55.146076", "image_code": "// more readable version at bottom\n\n// --- -10 by coyote\n\n#define S    smoothstep( 12./R.y, 0., abs(length(U)-.9)\n#define B    O += S-.05) - O* S-.07); U += D\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, D = vec2(.5,-.5),\n         U = fract( ( 4.*u - R-R ) / R.y ) - .5; // tile = 1/4 circle\n    O-=O; // -.5;                                //  3-grey variant\n    U = abs( U.x*U.y<0. ? U.yx : U )             // tile = 1/16 circle\n    - D; B\n    +.5; B\n    -.5; B;  \n}\n\n\n\n\n\n\n/** // --- 247 chars\n\n#define S    smoothstep( 12./R.y, 0., abs(length(U)-.9)\n#define B    O += S-.05) - O* S-.07)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, D = vec2(.5,-.5),\n         U = fract( ( 4.*u - R-R ) / R.y ) - .5; // tile = 1/4 circle\n    O-=O; // -.5;                                //  3-grey variant\n    U *= sign(U.x); \n    U = U.y<0. ? vec2(-U.y,U) : U;               // tile = 1/16 circle\n    U -= D;    B;\n    U += D+.5; B;\n    U += D-.5; B;  \n}\n\n\n\n\n\n\n/** // --- 260 chars\n\n#define S(U,r) smoothstep( 12./R.y, 0., abs(length(U)-.9) -r )\n#define B(U)   O *= 1.-S(U,.07), O += S(U,.05)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, D = vec2(.5,-.5),\n         U = fract( ( 4.*u - R-R ) / R.y ) - .5; // tile = 1/4 circle\n    O-=O; // -.5;                                //  3-grey variant\n    U = U.x<0. ? -U : U;\n    U = U.y<0. ? vec2(-U.y,U) : U;               // tile = 1/16 circle\n    B(U-D);\n    B(U+.5);\n    B(U+D);  \n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 198, 198, 492]], "test": "untested"}
{"id": "st3cDr", "name": "Parallax buildings", "author": "X_Future", "description": "something I made for fun", "tags": ["parallax", "rainbow", "city"], "likes": 8, "viewed": 334, "published": 3, "date": "1659575292", "time_retrieved": "2024-07-30T16:36:55.902055", "image_code": "float noise (vec2 st, float maxx, float comp, float modx) \n{\n    float xtr = mod(floor(st.x/comp)*modx, 271.);\n    float rand = sin(mod(xtr*xtr, 311.))*comp*2.0;\n    return float(st.y < float(int(floor(rand)) % int(maxx)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // change value from 0.0 to 1.0\n    // most optimal - 0.8-1.0\n    float quality = 1.;\n    // optimal - 0.0-5.0\n    float light = 3.;\n    \n    vec2 uv = fragCoord;\n    vec3 res = iResolution;\n    \n    //uncomment for a mirror effect\n    //uv.y = res.y-abs(uv.y-(res.y/2.))*2.;\n\n    vec3 color = vec3(0,0,0);\n    float pix = 0.;\n    \n    float f = res.x/50.;\n    float lay = 1.;\n    float q = 2.-quality+0.01;\n    vec2 l1 = uv;\n    \n    for (float i=0.01; i<=1.; i*=q){\n        lay += float(q*1e2-1e2);\n        l1.x = uv.x + (iTime+floor(lay/10.)*50.)*(f*i*10.) - res.x/2.;\n        l1.y = uv.y - (res.y+f)*(1.-i)/1.2-res.y/8.;\n        pix = max(pix, noise(l1, res.y*i, 5.*i*f, 5.*f)*i*(uv.y/res.y*light)); \n    }\n    \n    vec2 uvk = fragCoord/res.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uvk.xyx+vec3(0,2,4));\n    \n    color = vec3(pix);\n    \n    \n    \n    fragColor = vec4(vec3(color*col),1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3cDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 225], [226, 226, 283, 357, 1189]], "test": "untested"}
{"id": "7l3yWr", "name": "Fork 4 Music+ Green Plasma Globe", "author": "soundmasteraj", "description": "*best when bass guitar starts\nForking to make a green + sound reactive ver. (original author)My first attempt at recreating a real world object.  I tried making the sphere glow based on ray position but it didn't look better and was much more expensive.\n", "tags": ["3d", "raymarching", "rays", "plasma", "volumetric", "fork", "soundreactive"], "likes": 4, "viewed": 407, "published": 3, "date": "1659562683", "time_retrieved": "2024-07-30T16:36:56.765745", "image_code": "// Fork of \"Fork for Green Plasma Globe\" by soundmasteraj. https://shadertoy.com/view/fdGfWR\n// 2022-08-03 21:37:26\n\n// Fork of \"Plasma Globe\" by nimitz. https://shadertoy.com/view/XsjXRm\n// 2022-07-15 20:56:39\n\n// Plasma Globe by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsjXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//looks best with around 25 rays\n#define NUM_RAYS 13.\n\n#define VOLUMETRIC_STEPS 19\n\n#define MAX_ITER 35\n#define FAR 6.\n\n#define time iTime*1.1\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\t\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, fp.z);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n//See: https://www.shadertoy.com/view/XdfXRj\nfloat flow(in vec3 p, in float t)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\tp += time*.1;\n\t\trz+= (sin(noise(p+t*0.8)*6.)*0.5+0.5) /z;\n\t\tp = mix(bp,p,0.6);\n\t\tz *= 2.;\n\t\tp *= 2.01;\n        p*= m3;\n\t}\n\treturn rz;\t\n}\n\n//could be improved\nfloat sins(in float x)\n{\n \tfloat rz = 0.;\n    float z = 2.;\n    for (float i= 0.;i < 3.;i++ )\n\t{\n        rz += abs(fract(x*1.4)-0.5)/z;\n        x *= 1.3;\n        z *= 1.15;\n        x -= (sin(iTime/3.1415))+time*.65*z; //added sin\n    }\n    return rz;\n}\n\nfloat segm( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.5;\n}\n\nvec3 path(in float i, in float d)\n{\n    vec3 en = vec3(0.,0.,1.);\n    float sns2 = sins(d+i*0.5)*0.22;\n    float sns = sins(d+i*.6)*0.21;\n    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);\n    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);\n    return en;\n}\n\nvec2 map(vec3 p, float i)\n{\n\tfloat lp = length(p);\n    vec3 bg = vec3(0.);   \n    vec3 en = path(i,lp);\n    \n    float ins = smoothstep(0.11,.46,lp);\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\n    p *= ins*outs;\n    float id = ins*outs;\n    \n    float rz = segm(p, bg, en)-0.011;\n    return vec2(rz,id);\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\n{\n\tfloat precis = 0.001;\n    float h=0.5;\n    float d = startf;\n    for( int i=0; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h*1.2;\n\t    float res = map(ro+rd*d, j).x;\n        h = res;\n    }\n\treturn d;\n}\n\n//volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\n{   \n    vec3 p = ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float w = 0.;\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\n    {\n        r = map(p,j);\n        p += rd*.03;\n        float lp = length(p);\n        \n        vec3 col = sin(vec3(.05,0.5,1.052)*3.94+r.x)*.85+0.4; // +r.y to +r.x   and changed vec3\n        \n        col.rgb *= smoothstep(.0,.015,-r.x);\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\n        col *= smoothstep(0.1,.34,lp);\n        \n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\n    }\n    return sum;\n}\n\n//returns both collision dists of unit sphere\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n    \n\t//camera\n\tvec3 ro = vec3(0.,0.,5.);\n    vec3 rd = normalize(vec3(p*.7,-1.5));\n    mat2 mx = mm2(time*.4+um.x*6.);\n    mat2 my = mm2(time*0.3+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec3 bro = ro;\n    vec3 brd = rd;\n\t\n    vec3 col = vec3(0.0125,0.,0.025);\n    #if 1\n    for (float j = 1.;j<NUM_RAYS+1.;j++)\n    {\n        ro = bro;\n        rd = brd;\n        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);\n        ro.xy *= mm;rd.xy *= mm;\n        ro.xz *= mm;rd.xz *= mm;\n        float rz = march(ro,rd,2.5,FAR,j);\n\t\tif ( rz >= FAR)continue;\n    \tvec3 pos = ro+rz*rd;\n    \tcol = max(col,vmarch(pos,rd,j, bro));\n    }\n    #endif\n    \n    ro = bro;\n    rd = brd;\n    vec2 sph = iSphere2(ro,rd);\n    \n    if (sph.x > 0.)\n    {\n        vec3 pos = ro+rd*sph.x;\n        vec3 pos2 = ro+rd*sph.y;\n        vec3 rf = reflect( rd, pos );\n        vec3 rf2 = reflect( rd, pos2 );\n        float nz = (-log(abs(flow(rf*1.2,time)-.01)));\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\n        col += (0.1*nz*nz* vec3(0.012,0.512,.5) + 0.05*nz2*nz2*vec3(0.0055,0.2,.55))*0.8;\n    }\n    \n\tfragColor = vec4(col*1.3, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3yWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[582, 582, 603, 603, 655], [656, 656, 682, 682, 734], [736, 736, 758, 758, 791], [793, 793, 817, 817, 1036], [1148, 1193, 1228, 1228, 1444], [1446, 1466, 1490, 1490, 1718], [1720, 1720, 1757, 1757, 1883], [1885, 1885, 1920, 1920, 2133], [2135, 2135, 2162, 2162, 2449], [2451, 2451, 2532, 2532, 2771], [2773, 2795, 2858, 2858, 3446], [3448, 3494, 3533, 3533, 3721], [3723, 3723, 3780, 3780, 5058]], "test": "untested"}
{"id": "ftcyRM", "name": "008 - Plot study", "author": "PiGIon", "description": "Tip: you can zoom in/out with your mouse\n\nThe implementation isn't perfect, lines get \"dashed\" on large scales.", "tags": ["mouse", "interactive", "study", "plot", "begginer"], "likes": 2, "viewed": 259, "published": 3, "date": "1659555408", "time_retrieved": "2024-07-30T16:36:59.743783", "image_code": "// 2022.08.02 rev 1\n// 2022.08.02 rev 2 - fix plot errors for pow when x and y < 0.\n// 2022.08.02 rev 3 - fix plot errors when result isinf\n\n#define PI 3.14159265\n\n// tells if the result is undefined, e.g. pow(-1, -1)\nbool undefinedResult = false;\n\n// avoids undefined behavior when x < 0 && y < 0\nfloat safePow(float x, float y) {\n    if (x < 0. || (x == 0. && y <= 0.))\n        undefinedResult=true;\n    \n    float res = pow(x, y);\n    if (isinf(res))\n        undefinedResult=true;\n\n    return res;\n}\nfloat safeDiv(float x, float y) { return x/(y + 0.00000000001); }\n#define pow safePow\n#define div safeDiv\n\n// equation to plot that defines y based on x\n//#define eqy sin(x)\n//#define eqy x*x*x\n//#define eqy pow(x, x)\n\n// from https://www.mzrg.com/math/graphs.shtml\n#define eqy abs(div(sin(pow(x, x)), pow(2., div((pow(x, x)-PI/2.), PI))))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // controls the scale, or, in another word, the zoom of the plot\n    float mouseScale = (0.1 + (iMouse.x / iResolution.x));\n    float scale = 15. * mouseScale;\n    vec2 uv = scale * ((2. * fragCoord - iResolution.xy) / iResolution.y);\n    \n    float lineThickness = 3.;\n    // determine the minimum size for a x pixels in the screen\n    float line = scale*lineThickness/iResolution.y;\n    \n    float antiAlias = (scale * 1.5)/iResolution.y; // higher scale requires more antiAlias\n    \n    vec3 col;\n    \n    float x = uv.x;\n    float yOfx = eqy;\n\n    \n    vec2 p = vec2(uv.x, yOfx);\n\n    \n    float bias = distance(uv, p);\n    \n    vec3 plot = vec3(.96, 0.1, 0.06);\n    vec3 bg = vec3(.993, .992, 0.995);\n    vec3 grid = vec3(0.05, 0.085, 0.97);\n    \n    \n    float g = step(line/1.5, mod(uv.x, 2.)) * step(line/1.5, mod(uv.y, 2.));\n    bg = mix(grid, bg, smoothstep(line - antiAlias, line + antiAlias, g));\n\n    if (!undefinedResult) {\n        col = mix(plot, bg, smoothstep(line - antiAlias, line + antiAlias, bias));\n    } else {\n        col = bg;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 298, 331, 331, 502], [503, 503, 536, 536, 568], [844, 844, 901, 970, 2021]], "test": "untested"}
{"id": "NtBcRD", "name": "Random Loading screen 03", "author": "Karp", "description": "random test\n", "tags": ["2d"], "likes": 0, "viewed": 73, "published": 3, "date": "1659536918", "time_retrieved": "2024-07-30T16:37:00.953548", "image_code": "#define PI  3.14159265359\n#define TAU 6.28318530717\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n///UV\nvec2 CenterUV(vec2 fragCoord)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 NormalizeUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n    uv = 2.0 * uv.xy / iResolution.xy;\n\t// [-iResolution.x/2, iResolution.x/2] -> [-1.0, 1.0]\n    // [-iResolution.y/2, iResolution.y/2] -> [-1.0, 1.0]\n    \n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n\tuv = 2.0 * uv.xy / iResolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    //angle in degree (TAU = 2PI = 360 degrees)\n\tangle = angle * PI / 180.0;\n    uv * mat2( cos(angle), sin(angle),\n              -sin(angle), cos(angle));\n    return uv;\n}\n\n///COLOR\nvec3 Color255(int R, int G, int B)\n{\n    float rat = 1.0/255.0;\n    return vec3(float(R)*rat, float(G)*rat, float(B)*rat);\n}\nvec3 HSVcolor(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Grayscale \n#define black   vec3(0.0)\n#define grey   vec3(0.5)\n#define white   vec3(1.0)\n//RGB\n#define red     vec3(1.0,0.0,0.0)\n#define green   vec3(0.0,1.0,0.0)\n#define blue    vec3(0.0,0.0,1.0)\n//CMY\n#define cyan    vec3(0.0,1.0,1.0)\n#define yellow  vec3(1.0,1.0,0.0)\n#define magenta vec3(1.0,0.0,1.0)\n\n//HELPER\nfloat Clamp01(float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n//2DShape\nfloat LineHori(vec2 uv, float height, float thickness, float blur) \n{\n    float sdfLine = abs(uv.y - height)- thickness;\n\treturn Clamp01(sdfLine * (10.0/blur));\n}\nfloat LineVert(vec2 uv, float height, float thickness, float blur) \n{\n    float sdfLine = abs(uv.y - height)- thickness;\n\treturn Clamp01(sdfLine * (10.0/blur));\n}\nfloat Disk(vec2 uv, vec2 center, float radius, float blur) \n{\n    float sdfCircle = length(uv-center)-radius;\n\treturn Clamp01(sdfCircle * (10.0/blur));\n}\n\n//TODO => https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat Rectangle(vec2 uv, vec2 center, vec2 size) \n{\n\tfloat ret;\n\tfloat d = 0.005;\n\tret  = smoothstep((center.x + (-size.x*.5))-d,(center.x +( size.x*.5))+d, uv.x);\n\tret *= smoothstep((center.y + ( size.y*.5))-d,(center.y +(-size.y*.5))+d, uv.y);\n\tret *= 1.0 - smoothstep((center.y +(-size.y*.5))-d,(center.y +( size.y*.5))+d, uv.y);\n\tret *= 1.0 - smoothstep((center.x +( size.x*.5))-d,(center.x +(-size.x*.5))+d, uv.x);\n\treturn ret;\n}\n\n//Reminder\n//mix(a, b, t);\n//mod(val, 1.0);\n//step(edge, var);\n//clamp(var, min, max);\n//smoothstep(edge1, edge2, var);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy);\n    uv *= 1.2;\n    \n    //Parameter\n    float t = iTime * 2.0;\n    \n    //Visu\n    vec3 pix = vec3(uv,0);\n    pix = vec3(0.1);\n    for(int i = 0; i < 1200; i++)\n    {\n        float t = (iTime * 1.0) + abs(sin(float(i)/10000.0* TAU + iTime));\n        vec2 pos = vec2(cos( float(i)/1.0 * TAU + t),sin(float(i)/1.0* TAU+t)) * sin(float(i)/128.0* TAU+t)\n        + vec2(0.0,0.0);\n        float circleMask = Disk(uv,pos, 0.08, 0.2);\n        pix = mix(HSVcolor(vec3(float(i)/3600.0, 0.95,0.95)), pix, circleMask); \n    }\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 229, 264, 264, 292], [293, 293, 330, 330, 410], [412, 418, 449, 476, 679], [680, 680, 714, 714, 927], [928, 928, 964, 964, 1205], [1206, 1206, 1243, 1292, 1417], [1419, 1428, 1464, 1464, 1552], [1553, 1553, 1576, 1576, 1741], [2050, 2059, 2087, 2087, 2122], [2124, 2134, 2203, 2203, 2296], [2297, 2297, 2366, 2366, 2459], [2460, 2460, 2521, 2521, 2613], [2615, 2669, 2720, 2720, 3103], [3226, 3226, 3283, 3306, 3899]], "test": "untested"}
{"id": "NtcyDn", "name": "Wednesday messing around", "author": "mrange", "description": "CC0: Wednesday messing around\nTinkered a bit with an earlier shader\nThought while similar it turned out distinct enough to share\n", "tags": ["3d"], "likes": 113, "viewed": 4485, "published": 3, "date": "1659531971", "time_retrieved": "2024-07-30T16:37:01.807266", "image_code": "// CC0: Wednesday messing around\n// Tinkered a bit with an earlier shader\n// Thought while similar it turned out distinct enough to share\n\n#define COLORBURN\n#define SKYDOME\n#define PERIOD        10.0\n\n#define PI            3.141592654\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst int   bars     = 7;\nconst mat2  trans    = ROT(PI/9.0);\nconst float twist    = 1.0;\nconst float dist     = 0.5;\nconst float rounding = 0.125;\n\nconst float raymarchFactor = 0.8;\n\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define MAX_RAY_LENGTH  15.0\n#define MAX_RAY_MARCHES 70\n#define TOLERANCE       0.001\n#define NORM_OFF        0.005\n\nint g_hit     = 0;\nint g_period  = 0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nvec3 band_color(float ny) {\n  vec3 hsv = vec3(0.0);\n  float ramp = 1.0/abs(ny);\n  if (abs(ny) < 4.0) {\n    hsv = vec3(0.0, 0.0, 0.);\n  } else if (ny > 0.0) {\n    hsv = vec3(0.88, 2.5*ramp,0.8);\n  } else {\n    hsv = vec3(0.53, 4.0*ramp, 0.8);\n  }\n\n  return hsv2rgb(hsv);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat fadeIn(float x) {\n  return mix(-0.1, 1.0, smoothstep(-0.9, -0.5, -cos(-0.1*x+TAU*TIME/PERIOD)));\n}\n\nfloat df_bars1(vec3 p) {\n  p.y += dist*sin(0.5*p.x+0.5*p.z+TIME);\n  vec2 bp = p.zy;\n  \n  float d = 1E6;\n\n  float bs = 0.25*fadeIn(p.x);\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n\n  for (int i = 0; i < bars; ++i) {\n    float ii = float(i);\n    vec2 pp = bp;\n    float a = -TIME+0.5*ii;\n    float b = ii+p.x-2.0*TIME;\n    pp.y += sin(a);\n    mat2 rot = ROT(-PI/4.0*cos(a+twist*b));\n    pp.x -= bsz.x*sqrt(2.0)*ii; \n    pp *= rot;\n    float dd = box(pp, bsz, brd);\n    if (dd < d) {\n      g_hit = i;\n      d = dd;\n    }\n  }\n  \n  return d; \n}\n\nfloat df_bars2(vec3 p) {\n  p.y += 0.5*dist*sin(-0.9*p.x+TIME);\n  vec2 p2 = p.yz;\n  p2 *= ROT(TIME+p.x);  \n  vec2 s2 = sign(p2);\n  p2 = abs(p2);\n  p2 -= 0.3;\n  g_hit = 3+int(s2.y+2.0*s2.x)-1;\n  float bs = 0.25*fadeIn(p.x);\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n  return length(p2)-bs;\n}\n\nfloat df_bars3(vec3 p) {\n  const float r = 0.25;\n  p.y += 0.5*dist*sin(-0.9*p.x+TIME);\n  mat2 rot = ROT(TIME+p.x);\n  vec2 p2 = p.yz;\n  vec2 s2 = vec2(0.0);\n\n  p2 *= rot;\n  s2 += 2.0*sign(p2);\n  p2 = abs(p2);\n  p2 -= 2.0*r;\n\n  p2 *= rot;\n  s2 += 1.0*sign(p2);\n  p2 = abs(p2);\n  p2 -= 1.0*r;\n\n  g_hit = 3+int(s2.y+2.0*s2.x)-1;\n\n  float bs = (0.9*r)*fadeIn(p.x);\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n  float d0 = length(p2)-bs;\n  float d1 = box(p2, bsz, brd);\n  float d = d0;\n  return d;\n}\n\nfloat df_bars4(vec3 p) {\n  p.y += 0.5*dist*sin(-0.9*p.x+TIME);\n  vec2 p2 = p.yz;\n  p2 *= ROT(TIME+p.x);  \n  vec2 s2 = sign(p2);\n  p2 = abs(p2);\n  p2 -= 0.3;\n  g_hit = 3+int(s2.y+2.0*s2.x)-1;\n\n  float bs = 0.25*fadeIn(p.x);\n\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n  return box(p2, bsz, brd);\n}\n\nfloat df(vec3 p) {\n  p.xy *= trans;\n  switch(g_period) {\n  case 0:\n    return df_bars1(p);\n  case 1:\n    return df_bars2(p);\n  case 2:\n    return df_bars3(p);\n  case 3:\n    return df_bars4(p);\n  default:\n    return length(p) - 0.5;\n  }\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float ti) {\n  float t = ti;\n  int i = 0;\n  vec2 dti = vec2(1e10,0.0);\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    if (d<dti.x) { dti=vec2(d,t); }\n    t += raymarchFactor*d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; }\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nconst vec3 lightPos = vec3(2.0, 3.0, -5.0); \nconst vec3 lightCol = vec3(HSV2RGB(vec3(0.53, 0.5, 1.0)));\nconst vec3 overCol  = vec3(HSV2RGB(vec3(0.88, 0.25, 0.8)));\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3  ld    = normalize(lightPos - ro);\n  float dif   = max(dot(ld, rd), 0.0);\n\n  vec3  col   = vec3(0.0);\n\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) { \n    col = 2.0*overCol*rd.y;\n  }\n  float rb = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n\n  col += overCol*pow(clamp(1.0 - rb*0.5, 0.0, 1.0), 6.0);\n  col += lightCol*pow(dif, 8.0);\n  col += 4.0*lightCol*pow(dif, 40.0);\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  g_hit = -1;\n  float t = rayMarch(ro, rd, 3.0);\n  int hit = g_hit;\n  \n  vec3 col = vec3(1.0);\n  vec3 bcol = band_color(-4.0*float(hit-(bars-1)/2));\n  bcol *= bcol;\n  if (t < MAX_RAY_LENGTH) {\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    vec3 r = reflect(rd, n);\n    vec3 ld= normalize(lightPos-p);\n  \n    float dif = max(dot(ld, n), 0.0);\n    col = bcol*mix(0.5, 1.0, dif);\n#ifdef SKYDOME    \n    vec3 rs= skyColor(p, r);\n    float fre = 1.0+dot(rd, n);\n    fre *= fre;\n    float rf  = mix(0.05, 1.0, fre);\n    col += rf*rs;\n    // Just some fine-tuning, don't judge me\n    col += smoothstep(0.5, 1.0, fre)*max(n.y, 0.0);\n#else   \n    float spe = pow(max(dot(ld, r), 0.0), 30.0);\n    col += spe;\n#endif    \n  }\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x     *= RESOLUTION.x/RESOLUTION.y;\n  g_period = int(mod(1.0+floor(TIME/PERIOD), 4.0));\n\n  vec3 col  = effect(p);\n#if defined(COLORBURN)  \n  col -= vec3(0.2, 0.3, 0.2);\n#endif  \n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[876, 876, 898, 898, 1044], [1339, 1339, 1366, 1366, 1610], [1612, 1730, 1765, 1765, 1914], [1916, 1916, 1939, 1939, 2020], [2022, 2022, 2046, 2046, 2573], [2575, 2575, 2599, 2599, 2877], [2879, 2879, 2903, 2903, 3383], [3385, 3385, 3409, 3409, 3693], [3695, 3695, 3713, 3713, 3932], [3934, 3934, 3978, 3978, 4278], [4280, 4280, 4303, 4303, 4511], [4678, 4678, 4711, 4711, 5134], [5136, 5136, 5157, 5157, 6160], [6163, 6163, 6220, 6220, 6545]], "test": "untested"}
{"id": "Nl3yDn", "name": "Giza Cell Automaton", "author": "Ni2Be", "description": "Simple sand-like cellular automaton", "tags": ["simulation", "cellular", "ca", "sand", "automaton"], "likes": 6, "viewed": 272, "published": 3, "date": "1659529481", "time_retrieved": "2024-07-30T16:37:02.588177", "image_code": "/*\n\n    Buffer A: Cell Automaton\n    Buffer B: Init + Draw\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*     Cell Automaton    */\n\nbool isSolid(vec4 cell)\n{\n    return cell != NONE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 tile = (1. / iResolution.xy);\n    vec4 cells[9]; \n    cells[0] = texture(iChannel0, uv + tile * offsets[0]);\n    cells[1] = texture(iChannel0, uv + tile * offsets[1]);\n    cells[2] = texture(iChannel0, uv + tile * offsets[2]);\n    cells[3] = texture(iChannel0, uv + tile * offsets[3]);\n    cells[4] = texture(iChannel0, uv + tile * offsets[4]);\n    cells[5] = texture(iChannel0, uv + tile * offsets[5]);\n    cells[6] = texture(iChannel0, uv + tile * offsets[6]);\n    cells[7] = texture(iChannel0, uv + tile * offsets[7]);\n    cells[8] = texture(iChannel0, uv + tile * offsets[8]);\n    \n    /*  \n    Cell indices:\n    6 7 8\n    3 4 5    \n    0 1 2\n    \n    N := None\n    S := Solid\n    o := undefined\n    \n    special cases:\n    \n     1.  2.  3.  4.  5.\n     ooo Soo ooo ooS ooo\n     oSo SNo SSo oNS oSS\n     SSS Soo SNo ooS oNS\n    \n     1. solid stays solid if it stands on 3 solid\n     2. NONE with solid on top-left that can't get another place will turn solid\n     3. case above, from viewpoint of cell 7 if it is solid (it will \"wait\")\n     4. NONE with solid on top-right that can't get another place will turn solid\n     5. case above from viewpoint of cell 7 if it is solid (it will \"wait\")\n     \n    */\n    \n    bool currentCellIsSolid = cells[4] != NONE;\n    \n    // ground stays ground and does not fall\n    if(cells[4] == GROUND || cells[7] == GROUND)\n        fragColor = cells[4];\n    // 1. solid stays solid if it stands on 3 solid\n    else if(currentCellIsSolid && isSolid(cells[0]) && isSolid(cells[1]) && isSolid(cells[2]))\n        fragColor = cells[4];\n    // 2. NONE with solid on top-left that can't get another place will turn solid\n    else if(!currentCellIsSolid && !isSolid(cells[7]) && isSolid(cells[0]) && isSolid(cells[3]) && isSolid(cells[6]))\n        fragColor = cells[6];\n    // 3. case above, from viewpoint of cell 7 if it is solid (it will \"wait\")\n    else if(currentCellIsSolid && !isSolid(cells[1]) && isSolid(cells[3]) && isSolid(cells[0]))\n        fragColor = cells[4];\n    // 4. NONE with solid on top-right that can't get another place will turn solid\n    else if(!currentCellIsSolid && !isSolid(cells[7]) && isSolid(cells[2]) && isSolid(cells[5]) && isSolid(cells[8]))\n        fragColor = cells[8];\n    // 5. case above from viewpoint of cell 7 if it is solid (it will \"wait\")\n    else if(currentCellIsSolid && !isSolid(cells[1]) && isSolid(cells[5]) && isSolid(cells[2]))\n        fragColor = cells[4];\n    // all other solid turn NONE\n    else if(currentCellIsSolid)\n        fragColor = NONE;\n    // all NONE may become solid or stay NONE\n    else\n        fragColor = cells[7];\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*      Initialize  +  Draw       */\n#define ANIMATE\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Init (restart on fullscreen)\n    if(texture(iChannel0, vec2(1. - 1. / iResolution.x, 1. / iResolution.y)) != GROUND)\n    {\n        if(fragCoord.y < 5. || fragCoord.y > iResolution.y - 5.)\n            fragColor = GROUND;\n        else\n            fragColor = NONE;\n        return;\n    }\n    \n#ifdef ANIMATE\n    float width = (iResolution.y / 40.) * rand(vec2(cos(iTime),sin(iTime)));\n    if (distance(vec2(iResolution.x / 2. + sin(iTime) * iResolution.x * 0.02,iResolution.y * .95), fragCoord.xy) < width)\n    {\n        if(texture(iChannel0, uv) == NONE)\n            fragColor = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.);\n        else\n            fragColor = texture(iChannel0, uv);\n        return;\n    }\n    if (distance(vec2(iResolution.x / 4. + cos(iTime) * iResolution.x * 0.02,iResolution.y * .35), fragCoord.xy) < width)\n    {\n        if(texture(iChannel0, uv) == NONE)\n            fragColor = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.);\n        else\n            fragColor = texture(iChannel0, uv);\n        return;\n    }\n    if (distance(vec2(3.5 * iResolution.x / 4. + cos(iTime) * iResolution.x * 0.02,iResolution.y * .8), fragCoord.xy) < width)\n    {\n        if(texture(iChannel0, uv) == NONE)\n            fragColor = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.);\n        else\n            fragColor = texture(iChannel0, uv);\n        return;\n    }\n#endif\n    \n    \n    // Draw\n    if (iMouse.z > 0.5)\n    {\n        float width = 15.0;\n        if (distance(iMouse.xy, fragCoord.xy) < width)\n        {\n            fragColor = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.);\n        \treturn;\n        }\n    }   \n\n    // Just output\n    fragColor = texture(iChannel0, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nCell indices:\n678\n345\n012\n*/\nvec2 offsets[] = vec2[](\n    vec2(-1., -1.),\n    vec2( 0., -1.),\n    vec2( 1., -1.),\n    vec2(-1.,  0.),\n    vec2( 0.,  0.),\n    vec2( 1.,  0.),\n    vec2(-1.,  1.),\n    vec2( 0.,  1.),\n    vec2( 1.,  1.)\n    );\n    \n// Not used at the moment but could be fun\nvec2 offsetsReverse[] = vec2[](\n    vec2( 1., 1.),\n    vec2( 0., 1.),\n    vec2(-1., 1.),\n    vec2( 1.,  0.),\n    vec2( 0.,  0.),\n    vec2(-1.,  0.),\n    vec2( 1., -1.),\n    vec2( 0., -1.),\n    vec2(-1., -1.)\n);\n  \nconst vec4 NONE = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 GROUND = vec4(1.0, 1.0, 1.0, 1.0);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3yDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 121, 121, 203]], "test": "untested"}
{"id": "NldyRn", "name": "TP supply (115 chars)", "author": "hnh", "description": "Finally coping with some deep German trauma...\nThere should be a way to make it even smaller. However, I am out of -- ideas. ", "tags": ["simple", "parallax", "joke", "golf"], "likes": 1, "viewed": 206, "published": 3, "date": "1659517612", "time_retrieved": "2024-07-30T16:37:03.494754", "image_code": "\n/*\nvoid mainImage(out vec4 O, vec2 U) {  // base\n    U /= iResolution.xy;\n    float f = floor(1./(1.-U.y));  // If you feel brave, try switching floor to ceil ;-)\n    O = sqrt(abs(sin(f*U.xxxx*9. + iTime*5.)))/f/f;\n}\n/*/\nvoid mainImage(out vec4 O, vec2 U) {  // 123 -> 117 chars\n    U /= iResolution.xy;\n    //O = floor(1./(1.-U.yyyy));\n    O = ceil(U/(1.-U)).yyyy;  // Fabrice -> 113\n    O = sqrt(abs(sin(O*U.x*9.+iTime*5.)))/O/O;\n}\n//*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 222, 258, 279, 434]], "test": "untested"}
{"id": "NsGfWt", "name": "Penrose Unillumulinable Room", "author": "fenix", "description": "Simulation of light rays bouncing inside Roger Penrose's solution to the \"unilluminable room\" problem.\n* Mouse to choose your own starting point\n* Arrow keys to limit the light ray only to that direction\n* Shift to debug draw the SDF", "tags": ["reflection", "illumination", "penrose"], "likes": 11, "viewed": 330, "published": 3, "date": "1659490387", "time_retrieved": "2024-07-30T16:37:04.514029", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Demonstration of Roger Penrose's solution to the \"unilluminable room\" problem, presented\n//  in the 1958 Christmas edition of New Scientist magazine. The question is, can you\n//  build a room with mirrored walls, such that a light source anywhere in the room cannot\n//  shed light on the entire room?\n//\n//  The yellow lines are simulated rays of light originating from the blue dot. They should\n//  not* be able to reach any part of the room that is highlighted in red. \n//\n//  The way the optics works is that the top and bottom arcs are ellipses, and the corners of\n//  the \"arms\" are located at the ellipses' foci. You may know that light passing through one\n//  focus of an ellipse is guaranteed to pass through the other. But they key observation\n//  that makes this room work is that light coming from \"outside\" one focus will bounce\n//  to \"outside\" the other (and \"inside\" bounces to \"inside\").\n// \n//  * So, actually although this \"demonstrates\" the principle of the idea, it seems like\n//  precision issues are preventing it from working perfectly. I'm \"cheating\" in two ways:\n//      a) I'm letting the ray pass through the corners very close to the ellise foci\n//      b) In the attract mode, I only cycle among 20 light locations that don't happen to exhibit the problem\n//\n//  You'll find that if you use the mouse very much, especially if you increase NUM_LINES, it\n//  won't take too long to find some lines occasionally crossing the red area. I am considering\n//  it fair to say that I'm demonstrating the concept since it works at least 90% of the time.\n//  If anyone knows how to fix it, advice is appreciated!\n// \n//  Sources:\n//      https://en.wikipedia.org/wiki/Illumination_problem\n//      https://www.youtube.com/watch?v=x3VluzZTReE\n//\n// ---------------------------------------------------------------------------------------\n\n\nvec3 renderRay(int rayIndex, vec2 p)\n{\n    vec3 col;\n    vec2 begin = texelFetch(iChannel0, ivec2(0, rayIndex), 0).xy;\n    vec2 pointA = begin;\n    \n    // Just a dumb loop over all the rays. I thought I'd have to do some kind of voronoi type\n    // tracking, but it seems like it runs pretty fast? LMK if you disagree\n    if (pointA != vec2(0))\n    {\n        int NUM_LINES = 25;\n    \n        float minDist = 1e6;\n        for (int i = 0; i < NUM_LINES; ++i)\n        {\n            vec2 pointB = texelFetch(iChannel0, ivec2(i + 1, rayIndex), 0).xy;\n            if (pointB == vec2(0)) break;\n            float dist = linePointDist2(pointA, pointB, p, vec3(1.0, 1.0, 1.0));\n\n            minDist = min(minDist, dist);\n\n            pointA = pointB;\n        }\n        col += vec3(1.0, 1.0, 0.0) * (1.0 - smoothstep(0.0, 0.01, iResolution.x * minDist));\n        col = mix(col, vec3(0.0, 0.0, 1.0), 1.0 - smoothstep(15.0, 17.0, iResolution.x * length(begin - p)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n \tfloat roomD = sdRoom( p );\n\n    vec3 col;\n    if (keyDown(KEY_SHIFT))\n    {\n        // iq's SDF debug draw e.g. https://www.shadertoy.com/view/4sS3zz\n        col = (roomD>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n        col *= 1.0 - exp(-6.0*abs(roomD));\n        col *= 0.8 + 0.2*cos(150.0*roomD);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(roomD)) );\n    }\n    else\n    {\n        col = vec3(1.0 - smoothstep(0.0, 0.01, abs(roomD)));\n    }\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0, NUM_RAY_DIRS), 0);\n    vec2 mouseP = state.xy;\n    \n    // Color the \"unreachable\" parts of the room\n    if (sdRoom(mouseP) > 0.0)\n    {\n        float topSideRoomD = sdSideRoom(mouseP, true);\n        float bottomSideRoomD = sdSideRoom(mouseP, false);\n\n        float unreachableD = 1e6;\n        if (topSideRoomD < 0.0)\n        {\n            unreachableD = sdMostOfRoom(p, false);\n        }\n        else if (bottomSideRoomD < 0.0)\n        {\n            unreachableD = sdMostOfRoom(p, true);\n        }\n        else if (mouseP.y > 0.0)\n        {\n            unreachableD = sdSideRoom(p, false);\n        }\n        else\n        {\n            unreachableD = sdSideRoom(p, true);\n        }\n  \n        if (roomD > 0.0)\n        {\n            col += (1.0 - smoothstep(0.0, 0.01, max(0.0, unreachableD))) * vec3(0.5, 0.0, 0.0);\n        }\n    }    \n    \n    int singleRay = -1;\n    if (keyDown(KEY_LEFT)) singleRay = 6;\n    if (keyDown(KEY_UP)) singleRay = 0;\n    if (keyDown(KEY_RIGHT)) singleRay = 2;\n    if (keyDown(KEY_DOWN)) singleRay = 4;\n    \n    if (singleRay != -1)\n    {\n        col += renderRay(singleRay, p);\n    }\n    else\n    {\n        for (int j = 0; j < NUM_RAY_DIRS; ++j)\n        {\n            col += renderRay(j, p);\n        }\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int NUM_RAY_DIRS = 8;\nconst float ATTRACT_FRAMES = 120.0;\nconst float PI = 3.141592653589793;\n\n//hashing noise by IQ\nfloat hash( int k )\n{\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// https://iquilezles.org/articles/ellipsedist/\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for any given shape\n    p.x = abs(p.x);\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n    return (s<0.0) ? length(p)-r :\n           (p.x<w) ? h - p.y     :\n                     length(p-vec2(w,h));\n}\n\nconst float SDF_EPSILON = 1e-3;\nconst vec2 ELLIPSE_AXES = vec2(1.4,0.7);\nconst float FOCUS_DIST = sqrt(ELLIPSE_AXES.x*ELLIPSE_AXES.x - ELLIPSE_AXES.y*ELLIPSE_AXES.y);\nconst float SIDE_ROOM_WALL_HEIGHT = 0.05;\nconst float ELLIPSE_GAP = 0.2;\n\nfloat sdRoom(in vec2 p)\n{\n    const vec2 h = vec2(0.0, ELLIPSE_GAP);\n    vec2 q = abs(p)-h;\n\n    float minDist = sdEllipse( max(q,0.0), ELLIPSE_AXES ) + min(max(q.x,q.y),0.0);\n    minDist = max(minDist, -sdBox(p - vec2(1.7, 0.0), vec2(0.6, SIDE_ROOM_WALL_HEIGHT)));\n    minDist = max(minDist, -sdBox(p - vec2(-1.7, 0.0), vec2(0.6, SIDE_ROOM_WALL_HEIGHT)));\n    minDist = max(minDist, -sdCutDisk(vec2(p.y, p.x) + vec2(0.0, FOCUS_DIST), h.y, 0.0));\n    minDist = max(minDist, -sdCutDisk(vec2(p.y, -p.x) + vec2(0.0, FOCUS_DIST), h.y, 0.0));\n    return -minDist;\n}\n\nvec2 normRoom(in vec2 p)\n{\n    const float DELTA = 0.02;\n    return normalize(vec2(sdRoom(p + vec2(DELTA, 0.0)) - sdRoom(p - vec2(DELTA, 0.0)),\n                          sdRoom(p + vec2(0.0, DELTA)) - sdRoom(p - vec2(0.0, DELTA))));\n}\n\nfloat sdSideRoom(in vec2 p, bool top)\n{\n    p.x = abs(p.x);\n    p.y = top ? p.y : -p.y;\n    vec2 center = vec2((ELLIPSE_AXES.x + FOCUS_DIST) * 0.5, (ELLIPSE_GAP + SIDE_ROOM_WALL_HEIGHT) * 0.5);\n    return sdBox(p - center, vec2((ELLIPSE_AXES.x - FOCUS_DIST) * 0.5, (ELLIPSE_GAP - SIDE_ROOM_WALL_HEIGHT) * 0.5));\n}\n\nfloat sdMostOfRoom(in vec2 p, bool top)\n{\n    p.x = abs(p.x);\n    p.y = top ? p.y : -p.y;\n    float minDist = sdBox(p - vec2(0.0, 0.7), vec2(FOCUS_DIST, 0.7 + ELLIPSE_GAP));\n    minDist = min(minDist, sdBox(p - vec2(0.0, 0.7), vec2(ELLIPSE_AXES.x, 0.7)));\n    return minDist;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//    Buffer A computes the light rays, one bounce per pixel. Also manages state.\n// ---------------------------------------------------------------------------------------\n\nvec2 startingPoint()\n{\n    // Figure out a good starting point for our light rays\n    int frame = (iFrame / int(ATTRACT_FRAMES)) % 20;\n    \n    // It's the \"amazing\" case and we'd never hit it by accident, so force a choice in the small side rooms sometimes\n    bool forceSmallRoom = hash(frame * 7262) > 0.4;\n    \n    float h0 = hash(frame * 25519);\n    float h1 = hash(int(h0 * 1e9) + frame * 233448);\n    vec2 newMouse;\n    if (forceSmallRoom)\n    {        \n        // These rooms are square so it's simple to pick a safe spot here\n        newMouse = vec2(ELLIPSE_AXES.x - FOCUS_DIST, ELLIPSE_GAP - SIDE_ROOM_WALL_HEIGHT) * vec2(h0 * 2.0 - 1.0, h1 * 2.0 - 1.0);\n        newMouse += sign(newMouse) * vec2(FOCUS_DIST, SIDE_ROOM_WALL_HEIGHT);\n    }\n    else\n    {\n        newMouse = vec2(h0, h1) * ELLIPSE_AXES;\n\n        // To pick a random valid point, check if it's in the room and just try again if it isn't\n        while (sdRoom(newMouse) < 0.0)\n        {\n            h0 = hash(int(h1 * 1e9) + frame * 22541);\n            h1 = hash(int(h0 * 1e9) + frame * 29293);\n            newMouse = vec2(h0, h1) * ELLIPSE_AXES;\n        }\n    }\n    \n    return newMouse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    fragColor = vec4(0);\n\n    ivec2 ifc = ivec2(fragCoord);\n    \n    if (ifc == ivec2(0, NUM_RAY_DIRS))\n    {\n        // manage persistent state (for demo mode)\n        vec4 old = texelFetch(iChannel0, ifc, 0);\n        \n        if (iMouse.z > 0.0)\n        {\n            if (iMouse.w > 0.0)\n            {\n                // Set the mouse to zero for a frame when clicking. This allows a zero to propagate to the right\n                // one frame ahead of the actual calculation wavefront, telling our renderer where to stop.\n                fragColor = vec4(0);\n            }\n            else\n            {\n                // Stuff the mouse location into the state\n                vec2 p = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n                fragColor = vec4(p.xy, 1.0, 0.0);\n            }\n        }\n        else\n        {\n            if (old.z > 0.0)\n            {\n                // User cancelled attract mode, don't update the state automatically any more\n                fragColor = old;\n            }\n            else\n            {\n                if (old.w > 0.0)\n                {\n                    // Count down the frames...\n                    old.w -= 1.0;\n                    fragColor = old;\n                }\n                else\n                {\n                    // Timer ran out, pick a new starting point\n                    fragColor = vec4(startingPoint(), 0.0, ATTRACT_FRAMES);\n                }\n            }\n        }\n        \n        return;\n    }\n    \n    if (ifc.y >= NUM_RAY_DIRS) return;\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0, NUM_RAY_DIRS), 0);\n    vec2 mouse = state.xy;\n    \n    if (ifc.x == 0)\n    {\n        // Column zero gets the computation started by recording the starting position and light direction\n        if (mouse != vec2(0) && sdRoom(mouse) > 0.0)\n        {\n            vec4 old = texelFetch(iChannel0, ivec2(ifc.x, ifc.y), 0);\n\n            if (old.xy == vec2(0) || old.xy == mouse.xy)\n            {\n                // Eight rays in each of the cardinal and ordinal directions\n                float theta = float(ifc.y) * 0.25 * PI;\n                fragColor = vec4(mouse, sin(theta), cos(theta));\n            }\n        }\n    }\n    else\n    {\n        vec4 left = texelFetch(iChannel0, ivec2(ifc.x - 1, ifc.y), 0);\n        if (left != vec4(0))\n        {\n            // march ray\n            vec2 cur = left.xy;\n            vec2 dir = left.zw;\n            float dist = 1e6;\n            const int STEPS = 100;\n            \n            for (int i = 0; i<STEPS; i++)\n            {\n                dist = sdRoom(cur);\n                if (abs(dist) < SDF_EPSILON)\n                {\n                    // Hack/cheat to avoid precision errors near foci, let the ray pass through if close enough\n                    const float CHEAT_DIST = 0.01;\n                    if (length2(abs(cur) - vec2(FOCUS_DIST, ELLIPSE_GAP)) < CHEAT_DIST * CHEAT_DIST)\n                    {\n                        dist = SDF_EPSILON;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                cur += dist * dir;\n            }\n            \n            vec2 newDir = reflect(dir, normRoom(cur));\n            fragColor = vec4(cur + newDir * SDF_EPSILON * 2.0, newDir);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGfWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2068, 2068, 2106, 2106, 3047], [3049, 3049, 3106, 3106, 4953]], "test": "untested"}
{"id": "sltyRM", "name": "Binary Marching Cubes", "author": "TinyTexel", "description": "The original 15 marching cubes configurations realized using 8 slopels per cell.\nhttps://en.wikipedia.org/wiki/Marching_cubes#/media/File:MarchingCubes.svg\n\ncamera controls via mouse + shift key", "tags": ["cubes", "marching"], "likes": 31, "viewed": 986, "published": 3, "date": "1659480184", "time_retrieved": "2024-07-30T16:37:05.646002", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    The original 15 marching cubes configurations realized using 8 slopels per case.\n    A slopel is a cube with a part of it cut away by a plane, creating a slope (hence the name).\n    Besides a simple cube only 3 additional slopel types are needed here.\n    \n    For comparison, you can find an image of the original, triangulation based topology here: \n    https://en.wikipedia.org/wiki/Marching_cubes#/media/File:MarchingCubes.svg\n    \n    The configuration all the way at the bottom right is redundant (the one right above it is just a mirrored version).\n    It is also the one configuration where the surface of the slopel based approach is different from the original.\n    \n    The GetSlopelPlane(...) method (Common tab) returns the slopel plane for a given \n    marching cubes configuration and octant id. It can be used either directly or to prepare a lookup table.\n    \n    A raymarching demo using binary marching cubes can found here: https://www.shadertoy.com/view/fttyzM\n    \n    W - toggle wireframe\n    S - toggle shading style\n    \n    camera controls via mouse + shift key\n*/\n\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nbool IntersectMCCell(vec3 rp, vec3 rd, uint data, bvec3 oct, inout vec2 tt, inout vec3 N0)\n{\n    if(data == 0u) return false;\n\n    vec3 N; float D;\n    if(!GetSlopelPlane(data, oct, /*out:*/ N, D)) return false;\n\n    float PdN = dot(rp, N) - D;\n    float DdN = dot(rd, N);\n\n    float t = -1.0/DdN * PdN;\n\n    bool hit = true;\n\n    if(t < 0.0)\n    {\n        hit = PdN < 0.0;\n    }\n    else if(PdN < 0.0)\n    {\n        hit = t >= tt.x;\n    }\n    else\n    if(t > tt.x)\n    {\n        hit = t <= tt.y;\n\n        tt.x = t;\n\n        N0 = N;\n    }\n    \n    return hit;\n}\n\nuint Byte(int bits[8])\n{\n    uint byte = 0u;\n    for(uint i = 0u; i < 8u; ++i)\n        byte |= (uint(bits[i]) & 1u) << i;\n        \n    return byte;\n}\n\nbool VoxelRaycast(vec3 ro, vec3 rd, uint id, out vec3 vp, out vec3 N0, out float t)\n{\n    // the original 15 marching cubes configurations\n    uint data0[5*3] = uint[]\n    (\n        Byte(int[](1, 0, 0, 0, 0, 0, 0, 1)),\n        Byte(int[](1, 0, 0, 0, 1, 0, 0, 1)),\n        Byte(int[](0, 0, 1, 0, 1, 0, 0, 1)),\n        Byte(int[](1, 0, 1, 0, 0, 1, 0, 1)),\n        Byte(int[](1, 1, 0, 0, 0, 1, 0, 1)),\n        \n        Byte(int[](1, 1, 0, 0, 1, 1, 0, 0)),\n        Byte(int[](0, 1, 1, 0, 1, 1, 0, 0)),\n        Byte(int[](1, 0, 0, 1, 0, 1, 1, 0)),\n        Byte(int[](1, 1, 0, 1, 0, 1, 0, 0)),\n        Byte(int[](0, 1, 0, 1, 1, 1, 0, 0)),\n        \n        Byte(int[](0, 0, 0, 0, 0, 0, 0, 0)),\n        Byte(int[](1, 0, 0, 0, 0, 0, 0, 0)),\n        Byte(int[](1, 0, 0, 0, 1, 0, 0, 0)),\n        Byte(int[](1, 0, 0, 0, 0, 0, 1, 0)),\n        Byte(int[](0, 1, 0, 0, 1, 1, 0, 0))\n    );\n    \n    uint data = data0[id];\n        \n    N0 = vec3(0.0);\n    t = 0.0;\n\tvp = floor(ro);\n\t\n    vec3 ri = 1.0/rd;\n    \n\tvec3 rs = vec3(rd.x < 0.0 ? -1.0 : 1.0,\n                   rd.y < 0.0 ? -1.0 : 1.0,\n                   rd.z < 0.0 ? -1.0 : 1.0);\n                     \n\tvec3 off = vec3(rd.x < 0.0 ? 0.0 : ri.x,\n                    rd.y < 0.0 ? 0.0 : ri.y,\n                    rd.z < 0.0 ? 0.0 : ri.z) - ro * ri;\n\n\tvec3 mm = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 4; i++) \n\t{\n        vec3 t30 = vp * ri + off;\n\t\t\n        vec3 mm0 = vec3(minmask(t30));\n        \n        uvec3 tc0 = uvec3(ivec3(vp));\n       \n        if(tc0.x >= 2u || tc0.y >= 2u || tc0.z >= 2u) return false;\n\n        uvec3 tc = ((tc0 + 1u) >> 1u) - 1u;\n\n        if(data != 0u)\n        {\n            vec2 tt = vec2(dot(t3 , mm ), \n                           dot(t30, mm0));\n\n            N0 = -rs * mm;\n\n            vec3 rp = ro - (vp + 0.5);\n        \n            bvec3 oct = equal(tc0 & 1u, uvec3(1u));\n        \n            if(IntersectMCCell(rp, rd, data, oct, /*inout*/ tt, N0))\n            {\n                t = tt.x;\n                \n                return true;\n            }\n        }\n       \n        t3 = t30;\n        mm = mm0;\n        \n        vp += mm * rs;\n\t}\n\t\n\tN0 = -rs * mm;\n    t = dot(t3, mm);\n\n\treturn hit;\n}\n\nvec3 EvalCol(vec3 rd, vec3 p, vec3 n)\n{\n    vec3  fm  = abs(n);\n    float fmc = dot(mix(vec3(1.0), vec3(0.0), equal(fm, vec3(0.0))), vec3(1.0));\n    \n    float wf;\n    {\n        bvec3 b = greaterThan(abs(fract(p) - 0.5), vec3(0.45));\n\n        if(fmc != 1.0)\n        {\n            wf = b.x || b.y || b.z ? 0.0 : 1.0;\n        }\n        else\n        {\n            bvec3 l = bvec3(b.y && b.z, b.z && b.x, b.y && b.x);\n            wf = l.x || l.y || l.z ? 0.0 : 1.0;\n        }\n    }\n    \n    float err = 0.0;\n    {\n        bvec3 b = greaterThan(abs(fract(p*0.5) - 0.5), vec3(0.47));\n    \n        if(fmc == 1.0)\n        if((b.x && n.x != 0.0) ||\n           (b.y && n.y != 0.0) ||\n           (b.z && n.z != 0.0)) err = 1.0; \n    }     \n     \n    vec3 c;\n    if(ReadKeyToggle(KEY_S) != 0.0)\n    {\n        c = n * 0.5 + 0.5;\n    }\n    else\n    {\n        c = vec3(0.125);\n        c = vec3(1.0, 0.5, 0.25);\n        \n        if(err == 1.0) c = vec3(1.0, 0.25, 0.5);\n        if(fmc == 2.0) c = vec3(0.5, 0.9, 0.25);\n        if(fmc == 3.0) c = vec3(0.25, 0.5, 1.0);\n    }\n    \n    c *= sqrt(clamp01(-dot(n, rd)));\n   \n    if(ReadKeyToggle(KEY_W) == 0.0)\n    c *= wf;\n    \n    return c;\n}\n\nbool SceneRayCast(vec3 rp, vec3 rd, uint id, out vec3 c, out vec3 n, out vec3 p)\n{\n    p = rp;\n\n    // intersect bounding box\n    vec2 tt; vec3 n0 = vec3(0.0);\n    float res = Intersect_Ray_Cube(rp - vec3(1.0), rd, vec3(1.0 - 1.0/1024.0), /*out:*/ tt);\n\n    if(res == -1.0) { return false; }\n    \n    if(res == 1.0)\n    {\n    \tp += rd * tt.x;\n        \n        n0 = vec3(maxmask(abs(p - 1.0))) * -sign(rd);\n    }\n    \n    float lthr = 0.95;\n    vec3 lcol = vec3(0.6);\n    {\n        bool mA = false;\n        if(res == 1.0)\n        {\n            bvec3 m = greaterThan(abs(p - 1.0), vec3(lthr));\n            mA = m.x && m.y || m.y && m.z || m.z && m.x;\n        }\n\n        if(mA)\n        {\n            n = n0;\n            \n            c = lcol;\n            \n            return true;\n        }\n    }\n    \n    // intersect 2x2x2 slopels setup\n    vec3 vp; float t;\n\tbool hit = VoxelRaycast(p, rd, id, /*out:*/ vp, n, t);\n    \n    if(!hit)\n    {\n        p = rp + rd * tt.y;\n        \n        bool mB = false;\n        {\n            bvec3 m = greaterThan(abs(p - 1.0), vec3(lthr));\n            mB = m.x && m.y || m.y && m.z || m.z && m.x;\n        }\n\n        if(mB)\n        {\n            n = n0;\n            \n            c = lcol;\n            \n            return true;\n        }\n        \n        return false;\n    }\n\n    if(n.x == 0.0 && n.y == 0.0 && n.z == 0.0)\n    {\n        n = n0;\n    }\n    \n    n = normalize(n);\n    \n    p += rd * t;\n    \n    c = EvalCol(rd, p, n);\n    \n    return true;\n}\n\n\nvoid GetCameraRay(vec2 uv, sampler2D stateChannel, vec2 pixelCount, out vec3 rp, out vec3 rd, out vec2 tc)\n{\n    vec4 mouseAccu = texelFetch(stateChannel, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(-0.1 * Pi, -Pi * 0.13);\n    ang += mouseAccu.xy * 0.008;\n\n    float focalLen = 4.0;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    rp = -cmat[2] * exp2(3. + mouseAccu.w * 0.02);\n    \n    rp += 1.0;\n    \n    tc = uv * (1.0 / (pixelCount.xx*0.5)) - vec2(1.0, pixelCount.y/pixelCount.x);\n    \n    rd = normalize(cmat * vec3(tc, focalLen));     \n}\n\n\nvec3 EvalSceneCol(vec2 uv)\n{    \n    vec3 col0 = vec3(0.005);  \n    vec3 col = col0;  \n    \n   #if 0\n   \n    vec3 rp, rd; vec2 tc;\n    GetCameraRay(uv, iChannel0, iResolution.xy, /*out*/ rp, /*out*/ rd, /*out*/ tc);\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, 9u, /*out:*/ c, n, p))\n    {\n        col = c;\n    }\n    \n   #else\n   \n    // multi-view setup\n    vec2 count = vec2(5.0, 3.0);\n    vec2 res = iResolution.xy / count;\n    vec2 tc = uv / res;\n    vec2 tcI = floor(tc);\n    vec2 tcF = tc - tcI;\n    \n    uv = tcF * res;\n    uint id = uint(tcI.x + tcI.y * count.x);\n    \n    vec3 rp, rd; vec2 tc0;\n    GetCameraRay(uv, iChannel0, res, /*out*/ rp, /*out*/ rd, /*out*/ tc0);\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, id, /*out:*/ c, n, p))\n    {\n        col = c;\n    }\n    \n   #endif\n   \n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;    \n  \n#if 0\n    // 1 sample\n    col = vec3(EvalSceneCol(uv0));\n#elif 1\n    // 3 samples\n    float count = 3.0;\n    for(float i = 0.0; i < count; ++i) \n    {\n        vec2 off = GetUVOffset(uv, count, i);\n      \n        col += vec3(EvalSceneCol(uv0 + off));\n    }\n    col /= count; \n#endif\n    \n    \n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n\n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    data: the lower 8 bits hold the values of the binary implicit evaluated at the 8 vertices of the current grid cell\n    oct:  the octant of the current grid cell for which the slopel type is queried\n    \n  out N:  normal of the slopel plane\n  out D:  offset of the slopel plane along its normal from the slopel center\n  \n  return: is octant not empty\n*/\nbool GetSlopelPlane(uint data, bvec3 oct, out vec3 N, out float D)\n{   \n    // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n    uint d = data;\n    d -= (d >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    d = (d & 0x33333333u) + ((d >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    d = (d + (d >> 4u)) & 0xfu;// put count of each 8 bits into those 8 bits  \n    \n    bool flip = d < 5u;\n    \n    if(flip) data = data ^ 0xFFu;\n    \n    if(oct.x) data = ((data & 0x55u) << 1u) ^ ((data & 0xAAu) >> 1u);\n    if(oct.y) data = ((data & 0x33u) << 2u) ^ ((data & 0xCCu) >> 2u);\n    if(oct.z) data = ((data & 0x0Fu) << 4u) ^ ((data & 0xF0u) >> 4u);\n\n    \n    uint m = data;\n    \n    uint my = data & 0x55u;\n    my = (my ^ (my >>  1u)) & 0x33u;\n    my =  my ^ (my >>  2u);\n    m  =  m  ^ (my << 8u);\n    \n    uint mz = data & 0x33u;\n    mz = (mz ^ (mz <<  1u)) & 0x55u;\n    mz =  mz ^ (mz >>  3u);\n    m  =  m  ^ (mz << 16u);\n    \n    \n    // k will contain the quantized interpolation results + some garbage bits\n    uint k = (m | (m >> 1u)) & 0x010101u;// edges\n    \n     // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n     m -= (m >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n     m = (m & 0x33333333u) + ((m >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    \n    k = k ^ ((m | (m >> 1u)) & 0x020202u);// faces\n    \n    // compact scattered bits\n    k = k ^ (k >> 6u);\n    k = k ^ (k >> 4u);\n    \n    // clean up\n    k = k & 0xCFu;\n    \n    // add the 2 missing bits \n    k = k ^ ((data & 1u) << 4u);// origin\n    // (0 | 0 | k | 0)\n    \n    // expand to 4 blocks\n    k = k ^ (k <<  8u);\n    k = k ^ (k << 16u);\n    // (k | k | k | k)\n    \n    // apply bit flips \n    k = k ^ 0xDF37F17Cu;\n    // (D | N.z | N.y | N.x)\n    \n    // counts bits in each byte block (https://en.wikipedia.org/wiki/Hamming_weight)\n    k -= (k >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    k = (k & 0x33333333u) + ((k >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    k = (k + (k >> 4u)) & 0x0f0f0f0fu;// put count of each 8 bits into those 8 bits  \n    \n    \n    uvec3 N0 = (uvec3(k) >> uvec3(0u, 8u, 16u)) & uvec3(0xFu);\n\n#if 1\n    N0 -= 4u;\n    \n    N = vec3(N0.x == 0u ? 0.0 : 1.0,\n             N0.y == 0u ? 0.0 : 1.0,\n             N0.z == 0u ? 0.0 : 1.0);\n\n    if(oct.x != flip != ((N0.x & 0x80000000u) == 0u)) N.x = -N.x;\n    if(oct.y != flip != ((N0.y & 0x80000000u) == 0u)) N.y = -N.y;\n    if(oct.z != flip != ((N0.z & 0x80000000u) == 0u)) N.z = -N.z;\n#else\n    N = vec3(N0.x < 4u ? 1.0 : N0.x > 4u ? -1.0 : 0.0,\n             N0.y < 4u ? 1.0 : N0.y > 4u ? -1.0 : 0.0,\n             N0.z < 4u ? 1.0 : N0.z > 4u ? -1.0 : 0.0);\n\n    if(oct.x != flip) N.x = -N.x;\n    if(oct.y != flip) N.y = -N.y;\n    if(oct.z != flip) N.z = -N.z;\n#endif\n\n    float count = abs(N.x) + abs(N.y) + abs(N.z);\n\n    if(count < 2.0) N.x = 1.0;\n\n    uint D0 = k >> 24u;\n    {\n        uint th = count == 3.0 ? 4u : 2u;\n\n        float v2 = D0 > 2u ? -0.5 : 0.5;\n\n        if(count  < 2.0) v2 = 128.0;\n        if(count == 2.0) v2 = 0.0;\n\n        D = D0 > th ? -128.0 : v2;\n    }\n    \n    if(flip) \n    { \n        D = -D; \n    }\n    \n    return D > -128.0;\n}\n\n\nvec4 GetMCLookupEntry(uvec2 uv)\n{\n    uint data = uv.x;\n    bvec3 oct = equal((uv.yyy >> uvec3(0u, 1u, 2u)) & 1u, uvec3(1u));\n    \n    vec3 N; float D;\n    GetSlopelPlane(data, oct, /*out*/ N, D);\n    \n    return vec4(N, D);\n}\n\nbool ReadMCLookupEntry(sampler2D sampler, uint data, bvec3 oct, out vec3 N, out float D)\n{\n    uvec2 uv;\n    uv.x = data;\n    uv.y = (oct.x ? 1u : 0u) | (oct.y ? 2u : 0u) | (oct.z ? 4u : 0u);\n    \n    vec4 res = texelFetch(sampler, ivec2(uv), 0);\n    \n    N = res.xyz;\n    D = res.w;\n    \n    return D > -128.0;\n}\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nvec3 GammaDecode(vec3 x) {return pow(x, vec3(      2.2));}   \nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\nbvec3 maxmask(vec3 v)\n{\n    bool x = v.x >  v.y && v.x >  v.z;\n    bool y = v.y >= v.z && v.y >= v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n\nbvec3 minmask(vec3 v)\n{\n    bool x = v.x <= v.y && v.x <= v.z;\n    bool y = v.y <  v.z && v.y <  v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n\n\n// https://www.shadertoy.com/view/3tdBWM\nvec2 GetUVOffset(vec2 uv, float count, float smplNum)\n{\n    uvec2 uvi = uvec2(uv);\n\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n    if(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n\n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    float i = smplNum;\n    \n    float ang = (Pi*(2.0/count)) * (i+u);\n\n    vec2 off = vec2(cos(ang), sin(ang));\n\n    float l = float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n    \n    return off * l;\n}\n", "buffer_a_code": "// persistent state stuff\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n\n    if(uv.y >= 1.0) discard;\n    \n    vec4 iMouseLast      = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast  = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast    = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool ctrl  = texelFetch(iChannel1, ivec2(17, 0), 0).x != 0.0;\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    \n    if(ctrl) cond0 = false;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltyRM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1204, 1204, 1232, 1232, 1286], [1287, 1287, 1321, 1321, 1375], [1377, 1377, 1469, 1469, 1938], [1940, 1940, 1964, 1964, 2089], [4299, 4299, 4338, 4338, 5472], [5474, 5474, 5556, 5556, 6958], [6961, 6961, 7069, 7069, 8057], [8060, 8060, 8088, 8088, 8878], [8881, 8881, 8927, 8927, 9517]], "test": "untested"}
{"id": "Nldcz7", "name": "Pink Blob 2", "author": "nsbalbi", "description": "Adapted from Inigo Quilez (https://iquilezles.org/)\nSimplex 3D Noise by Ian McEwan, Ashima Arts", "tags": ["raymarching", "noise"], "likes": 4, "viewed": 275, "published": 3, "date": "1659478833", "time_retrieved": "2024-07-30T16:37:06.738082", "image_code": "// Heavily adapted from Inigo Quilez (https://iquilezles.org/)\n\nconst float D_MAX = 5.0;  // max marching distance\n\n#define AA 1  // number of anti-aliasing passes\n\n#define PI 3.1416\n\n\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\n////////////////////////////////////\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 0.5*((42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) )) + 1.0);\n}\n\n///////////////////////////////\n\n\n// SDFs\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n// Scene SDF\nfloat sceneSDF(vec3 p) {    \n  // return sdSphere(samplePoint, 0.5);\n  float d1 = sdSphere(p, 0.4);\n\n  float d2 = 0.2*snoise(2.0*(p + 0.2*iTime));\n\n  return d1 - d2;\n}\n\n// Calculates surface normal\nvec3 calcNormal( in vec3 pos ) {\n  vec2 e = vec2(1.0,-1.0)*0.5773;\n  const float eps = 0.0005;  // small increment epsilon\n  return normalize( e.xyy*sceneSDF( pos + e.xyy*eps ) + \n          e.yyx*sceneSDF( pos + e.yyx*eps ) + \n          e.yxy*sceneSDF( pos + e.yxy*eps ) + \n          e.xxx*sceneSDF( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  // camera movement\t\n\tfloat angle = 0.25 * PI * iTime + 0.75 * PI;\n\tvec3 eye = vec3( 1.2*cos(angle), 0.4, 1.2*sin(angle) );\n  vec3 center = vec3( 0.0, 0.0, 0.0 );\n\t// vec3 eye = vec3( 1., 0.4, -1.);\n  // vec3 center = vec3( 0., 0., 0.);\n  // camera matrix\n  vec3 ww = normalize( center - eye );  // vect from center to eye\n  vec3 uu = normalize( cross(ww, vec3(0.0,1.0,0.0)) );  // cross with up\n  vec3 vv = normalize( cross(uu, ww) );\n\n  vec3 tot = vec3(0.0);\n  \n  #if AA>1  // anti-aliasing passes\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ ) {\n    // pixel coordinates\n    vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;  // offset for anti-aliasing passes\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+offset))/iResolution.y;\n    #else    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    #endif\n\n    // create view ray\n    vec3 ray = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    float dTot = 0.0;\n    for( int i=0; i<256; i++ ) {\n      vec3 pos = eye + dTot*ray;\n      float d = sceneSDF(pos);\n      if( d < 0.0001 || dTot > D_MAX ) break;\n      dTot += d;\n    }\n    \n    // shading/lighting\t\n    vec3 color = vec3(0.0);\n    if( dTot < D_MAX ) {\n      vec3 pos = eye + dTot * ray;  // position of point on surface\n      vec3 normal = calcNormal(pos);  // surface normal\n      float diffuse = clamp( dot(normal, vec3(0.6)), 0.0, 1.0 );\n      float ambient = 0.5 + 0.5 * dot(normal, vec3(0.0,1.0,0.0));\n      color = vec3(0.5882, 0.302, 0.302) * ambient + vec3(0.098, 0.1843, 0.5882) * diffuse;\n    }\n\n    // gamma        \n    color = sqrt( color );\n    tot += color;\n    #if AA>1\n  }\n  tot /= float(AA*AA);  // take mean if multiple anti-aliasing passes\n  #endif\n\n  fragColor = vec4( tot, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nldcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 269, 290, 290, 327], [328, 328, 355, 355, 403], [405, 405, 426, 426, 2276], [2321, 2321, 2356, 2356, 2380], [2382, 2395, 2419, 2463, 2562], [2564, 2593, 2625, 2625, 2915]], "test": "untested"}
{"id": "Nldyz7", "name": "circle with line", "author": "tommasozanetti", "description": "cirlcle", "tags": ["virtualdj", "cirlcle"], "likes": 6, "viewed": 366, "published": 3, "date": "1659478136", "time_retrieved": "2024-07-30T16:37:07.486082", "image_code": "#define BEATMOVE 1\n\nconst float FREQ_RANGE = 100.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.9;\nconst float BRIGHTNESS = 0.3;\nconst float SPEED = 0.0;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nldyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 180, 201, 201, 370], [372, 372, 396, 396, 446], [448, 448, 477, 477, 570], [572, 572, 608, 608, 819], [821, 821, 856, 856, 920], [922, 922, 964, 964, 1431], [1433, 1433, 1484, 1484, 1736], [1739, 1739, 1796, 1796, 2229]], "test": "untested"}
{"id": "fldyz7", "name": "Pink Blob", "author": "nsbalbi", "description": "Adapted from Inigo Quilez (https://iquilezles.org/).", "tags": ["raymarching"], "likes": 3, "viewed": 215, "published": 3, "date": "1659477861", "time_retrieved": "2024-07-30T16:37:08.499374", "image_code": "// Heavily adapted from Inigo Quilez (https://iquilezles.org/)\n\nconst float D_MAX = 5.0;  // max marching distance\n\n#define PI 3.1416\n\n// SDFs\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n// Scene SDF\nfloat sceneSDF(vec3 p) {    \n  // return sdSphere(samplePoint, 0.5);\n  float d1 = sdSphere(p, 0.5);\n\n  float df = 8.0;  // frequency\n  float da = 0.1;  // amplitude\n  float d2 = da * sin(df * (p.x + 0.25*PI*iTime))*sin(df * p.y)*sin(df * p.z);\n\n  return d1 + d2;\n}\n\n// Calculates surface normal\nvec3 calcNormal( in vec3 pos ) {\n  vec2 e = vec2(1.0,-1.0)*0.5773;\n  const float eps = 0.0005;  // small increment epsilon\n  return normalize( e.xyy*sceneSDF( pos + e.xyy*eps ) + \n          e.yyx*sceneSDF( pos + e.yyx*eps ) + \n          e.yxy*sceneSDF( pos + e.yxy*eps ) + \n          e.xxx*sceneSDF( pos + e.xxx*eps ) );\n}\n\n#define AA 2  // number of anti-aliasing passes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // camera movement\t\n\t// float angle = 0.25 * PI * u_time + 0.75 * PI;\n\t// vec3 eye = vec3( 1.2*cos(angle), 0.4, 1.2*sin(angle) );\n  // vec3 center = vec3( 0.0, 0.0, 0.0 );\n\tvec3 eye = vec3( 1., 0.4, -1.);\n  vec3 center = vec3( 0., 0., 0.);\n  // camera matrix\n  vec3 ww = normalize( center - eye );  // vect from center to eye\n  vec3 uu = normalize( cross(ww, vec3(0.0,1.0,0.0)) );  // cross with up\n  vec3 vv = normalize( cross(uu, ww) );\n\n  vec3 tot = vec3(0.0);\n  \n  #if AA>1  // anti-aliasing passes\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ ) {\n    // pixel coordinates\n    vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;  // offset for anti-aliasing passes\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+offset))/iResolution.y;\n    #else    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    #endif\n\n    // create view ray\n    vec3 ray = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    float dTot = 0.0;\n    for( int i=0; i<256; i++ ) {\n      vec3 pos = eye + dTot*ray;\n      float d = sceneSDF(pos);\n      if( d < 0.0001 || dTot > D_MAX ) break;\n      dTot += d;\n    }\n    \n    // shading/lighting\t\n    vec3 color = vec3(0.0);\n    if( dTot < D_MAX ) {\n      vec3 pos = eye + dTot * ray;  // position of point on surface\n      vec3 normal = calcNormal(pos);  // surface normal\n      float diffuse = clamp( dot(normal, vec3(0.6)), 0.0, 1.0 );\n      float ambient = 0.5 + 0.5 * dot(normal, vec3(0.0,1.0,0.0));\n      color = vec3(0.5882, 0.302, 0.302) * ambient + vec3(0.098, 0.1843, 0.5882) * diffuse;\n    }\n\n    // gamma        \n    color = sqrt( color );\n    tot += color;\n    #if AA>1\n  }\n  tot /= float(AA*AA);  // take mean if multiple anti-aliasing passes\n  #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 179, 179, 203], [205, 218, 242, 286, 482], [484, 513, 545, 545, 835]], "test": "untested"}
{"id": "7dGfDD", "name": "Fract City v1", "author": "byt3_m3chanic", "description": "Experiment while away with family - cleaned up and presented to you.", "tags": ["raymarching", "fractal"], "likes": 33, "viewed": 781, "published": 3, "date": "1659476281", "time_retrieved": "2024-07-30T16:37:09.336135", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    Frac City\n    08/02/22 | byt3_m3chanic\n\n    An experiment while away with family. Trying to stay lean and simple,\n    mostly doing some folding around a vector and making a simple box.\n    Everything else based off a grid and each spaces hash value. \n    Using @Shane's multi-tap system to allow for the packed fractal forms. \n    --> https://www.shadertoy.com/view/WtffDS\n\n    mouseable\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI 3.141592653\n#define PI2 6.28318530\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define H21(a) fract(sin(dot(a,vec2(21.23,41.32)))*43758.5453)\n#define N(p,e) vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx))\n\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat box( vec2 p, vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\nfloat thrs=.15,xln,tm,tmod,ga1,ga2,ga3,ga4;\nfloat mat,hash,smat,shash;\nvec2 gid,sid;\nvec3 hp,hitPoint;\n\nconst float scale = 2./.95;\nconst float scale_h = scale*.5;\nconst vec2 s = vec2(scale)*2.;\nconst vec2 pos = vec2(.5,-.5);\nconst vec2[4] ps4 = vec2[4](pos.yx,pos.xx,pos.xy,pos.yy);\n\nfloat map(vec3 p3) {\n    float r = 1e5;\n\n    p3.x-= T*3.5;\n    p3.y+= .6*sin(p3.x*.25+T*1.65);\n\n    vec2 p,ip,id=vec2(0),ct=vec2(0);\n  \n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2. - ps4[0]/2.;\n        p  = p3.xz - ct*s;\n        ip = floor(p/s)+.5;\n        p -= (ip)*s;\n        vec2 idi = (ip+ct)*s;\n\n        float hs = H21(idi),\n             shs = hs;\n        \n        hs=floor(hs*9.)*.25;\n\n        vec3 q = vec3(p.x,p3.y+2.-hs,p.y);\n\n        if(shs>.75) q.x=-q.x;\n        if(shs>.5) q.y=-q.y;\n        \n        if (q.x + q.y<0.) q.xy = -q.yx;\n        if (q.x + q.z<0.) q.xz = -q.zx;\n        if (q.y + q.z<0.) q.zy = -q.yz;\n    \n        q = abs(q);\n        float k = (1.5 - .5)*2.;\n        if (q.x < q.y) q.xy = q.yx; q.x = -q.x;\n        if (q.x > q.y) q.xy = q.yx; q.x = -q.x;\n        if (q.x < q.z) q.xz = q.zx; q.x = -q.x;\n        if (q.x > q.z) q.xz = q.zx; q.x = -q.x;\n        q.xyz = q.xyz*1.15 - k + 1.25;\n        \n        q.yz=abs(q.yz)-.95;\n   \n        vec2 bz = vec2(.52,.1+hs),\n             bx = vec2(2.*bz.x+.01,.5+hs);\n        \n        float d = box(q,bz.xyx);\n        if(d<r && fract(shs*33.72)>thrs) {\n            r = d;\n            sid=idi;\n            shash=hs;\n            hitPoint=q;\n            smat = 2.;\n        }\n\n        \n    }\n\n    float f = p3.y+3.;\n    if(f<r) {\n        r = f;\n        sid=vec2(15);\n        shash=.0;\n        hitPoint=p3;\n        smat = 1.;\n    }\n\n    return r;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n             \n    vec3 C = vec3(0);\n    vec3 p  = vec3(0),\n         ro = vec3(0,0,7.25+3.25*sin(T*.09)),\n         rd = normalize(vec3(uv,-1));\n\n    float ttt = T*.5;\n    \n    tmod = mod(ttt, 10.);\n    tm   = mod(ttt, 20.);\n    \n    float t1 = lsp(3.,  5., tmod);\n    float t2 = lsp(8., 10., tmod);\n    \n    ga1 = ((t1-t2)*2.2)-1.1;\n\n    float px = tm<10.? .78 : 1.57;\n    float py = tm<10.? .78 : .0;\n\n    vec3 c1 = tm<10.? vec3(.59,.92,.82) : vec3(.92,.78,.59);\n    vec3 c2 = tm<10.? vec3(.23,.44,.38) : vec3(.52,.38,.17);\n    \n    xln = ga1-(.025*sin(uv.y*25.+T*5.));\n    \n    if(uv.x>xln) { \n    \n        px = tm>5.&&tm<15.?.42:1.15;\n        py = tm>5.&&tm<15.?-.68:2.45;\n        \n        c1 = tm>5.&&tm<15.? vec3(.58,.68,.92) : vec3(.88,.59,.87);\n        c2 = tm>5.&&tm<15.? vec3(.33,.52,.97) : vec3(.44,.23,.40) ;\n    }\n\n    float x = M.xy==vec2(0)||M.z<0. ? px : px-(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0)||M.z<0. ? py : py-(M.x/R.x* 2.-1.)*PI;\n\n    mat2 rx = rot(x), ry = rot(y);\n\n    ro.yz*=rx; ro.xz*=ry; \n    rd.yz*=rx; rd.xz*=ry;\n\n    float d=0.;\n    for(int i=0;i<110;i++){\n        p = ro+rd*d;\n        float t = map(p);\n        d += i<42?t*.25:t;\n        if(d<t*1e-3||d>25.) break;\n    }\n    \n    mat=smat;\n    hash=shash;\n    gid=sid;\n    hp=hitPoint;\n    \n    if(d<25.){\n        float t = map(p),\n             sd = 1.,\n              z = .01;\n\n        vec2 e = vec2(d*1e-3,0);\n        vec3 l = normalize(vec3(-5,9,-5)-p),\n             n = t - N(p,e);\n             n = normalize(n);\n\n        for(float z=.01;z<18.;) {\n            float h = map(p+l*z);\n            if(h<1e-3) {sd=0.;break;}\n            sd = min(sd, 18.*h/z);\n            z+=h;\n            if(sd<1e-3) break;\n        }\n\n        float diff = clamp(dot(n,l),.1,.8);\n        diff=mix(diff,diff*sd,.75);\n\n        vec3 h = vec3(.5);\n        float px = 4./R.x;\n\n        if(mat == 1.) {\n            h = vec3(.1);\n\n            vec2 uv = fract(hp.xz/scale);\n\n            float d = min(\n                length(abs(uv.x-.5))-.1,\n                length(abs(uv.y-.5))-.1\n                );\n\n            float b=smoothstep(px,-px,abs(d)-.015);\n            d=smoothstep(px,-px,d);\n\n            h=mix(h,c2*.25,d);  \n            h=mix(h,c1,b);  \n        }\n\n        if(mat == 2.) {\n            float ss = floor(6./1.745);\n\n            vec3 ff = floor(hp*ss)+gid.xyx,\n                 vv = fract(hp*ss)-.5;\n\n            float b = box(vv,vec3(.4))-.001;\n            b=smoothstep(px,-px,b);\n\n            h = vec3(.5);\n\n            float hx = H21(ff.xy),\n                  hy = H21(ff.yz),\n                  hz = H21(ff.xz),\n                  hs = (hx+hy+hz)/3.;\n                  \n            h = (hs>.8||hs<.2)? mix(h,c1,b):mix(h,vec3(hs),b);\n            h = h*h*h;\n\n        }\n\n        C = h*diff;\n    }\n    \n    float ux = (uv.y+.5)*.7;\n    \n    vec3 fog = mix(vec3(.01),c2,ux);\n    C = mix(C,fog,1.-exp(-.0005*d*d*d));\n    if(uv.x+.01>xln && uv.x-.01<xln)C=c1;\n    C = pow(C,vec3(.4545));  \n    O = vec4(C,1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfDD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[770, 770, 814, 814, 869], [871, 871, 900, 900, 985], [987, 987, 1016, 1016, 1094], [1381, 1381, 1401, 1401, 2795], [2797, 2797, 2838, 2838, 5865]], "test": "untested"}
{"id": "7t3cR7", "name": "Ink Splatter", "author": "Peace", "description": "Tweakable expanding ink splatter blot", "tags": ["ink", "splatter", "splash", "blot"], "likes": 11, "viewed": 605, "published": 3, "date": "1659465869", "time_retrieved": "2024-07-30T16:37:10.195837", "image_code": "#define TAU 6.28318530718\n\n#define SPEED 0.33\n#define INK_COLOR vec3(0, 0, 0)\n#define BACKGROUND_COLOR vec3(1)\n#define POSITION vec2(0)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 p, int octaves)\n{\n    float n = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    for(int i = 0; i < octaves; ++i)\n    {\n        n += noise(p) * a;\n        norm += a;\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return n / norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime, 2.5 / SPEED);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy - POSITION * iResolution.xy) / iResolution.y;\n \n    float angle = atan(uv.y, uv.x);\n    angle += fbm(uv * 4.0, 2) * 0.5;\n    vec2 p = vec2(cos(angle), sin(angle));\n    \n    float t = time * SPEED;\n    t *= t;\n    \n    float l = dot(uv / t, uv / t);\n    l -= (fbm(normalize(uv) * 3.0, 2) - 0.5);\n    float ink = fbm(p * 8.0, 2) + 1.5 - l;\n\n    vec3 col = mix(BACKGROUND_COLOR, INK_COLOR, clamp(ink, 0.0, 1.0));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3cR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 157, 157, 224], [226, 226, 246, 246, 455], [457, 457, 489, 489, 703], [705, 705, 762, 762, 1301]], "test": "untested"}
{"id": "fttyzM", "name": "Binary Marching Cubes Demo", "author": "TinyTexel", "description": "Using binary marching cubes to discretize the surface of an implicit function during raymarching.\nThis is a demo of the idea presented here: https://www.shadertoy.com/view/sltyRM\n\ncamera controls via mouse + shift key", "tags": ["raymarching", "cubes", "marching"], "likes": 32, "viewed": 926, "published": 3, "date": "1659465191", "time_retrieved": "2024-07-30T16:37:11.256002", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    Using binary marching cubes to discretize the surface of an implicit function during raymarching.\n    This is a demo of the idea presented here: https://www.shadertoy.com/view/sltyRM\n    \n    As this is based on the original 15 marching cubes configurations, there are spots where\n    the original, triangulation based approach would result in a non-closed surface.\n    If you toggle the shading style (S) these parts of the surface show up as (desaturated) magenta.\n    \n    W - toggle wireframe\n    S - toggle shading style\n    \n    camera controls via mouse + shift key\n*/\n\n// if USE_LOOKUP_TABLE is used, GetSlopelPlane(...) isn't evaluated directly during raymarching,\n// but instead it is used to prepare a lookup table in BufferB as a replacement (this seems to be a bit faster).\n\n// #define USE_LOOKUP_TABLE\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nfloat map(uvec3 tc)\n{\n    if(tc.x >= VOLUME_RES || tc.y >= VOLUME_RES || tc.z >= VOLUME_RES) return 1.0;\n    \n    float res05 = float(VOLUME_RES/2u);\n    \n    vec3 p = vec3(tc) - res05;\n    \n    vec4 n = textureLod(iChannel3, p / (32.0*6.0), 0.0);\n    \n    float f = Rotate(n.rg * 2.0 - 1.0, iTime * 0.25).x;\n    \n    return f;\n}\n\nbool ReadMCLookupEntry(sampler2D sampler, uint data, bvec3 oct, out vec3 N, out float D)\n{\n    uvec2 uv;\n    uv.x = data;\n    uv.y = (oct.x ? 1u : 0u) | (oct.y ? 2u : 0u) | (oct.z ? 4u : 0u);\n    \n    vec4 res = texelFetch(sampler, ivec2(uv), 0);\n    \n    N = res.xyz;\n    D = res.w;\n    \n    return D > -128.0;\n}\n\nbool IntersectMCCell(vec3 rp, vec3 rd, uint data, bvec3 oct, inout vec2 tt, inout vec3 N0)\n{\n    if(data == 0u) return false;\n\n    vec3 N; float D;\n    \n   #ifdef USE_LOOKUP_TABLE\n   \n    if(!ReadMCLookupEntry(iChannel1, data, oct, /*out:*/ N, D)) return false;\n    \n   #else\n   \n    if(!GetSlopelPlane(data, oct, /*out:*/ N, D)) return false;\n    \n   #endif\n\n    float PdN = dot(rp, N) - D;\n    float DdN = dot(rd, N);\n\n    float t = -1.0/DdN * PdN;\n\n    bool hit = true;\n\n    if(t < 0.0)\n    {\n        hit = PdN < 0.0;\n    }\n    else if(PdN < 0.0)\n    {\n        hit = t >= tt.x;\n    }\n    else\n    if(t > tt.x)\n    {\n        hit = t <= tt.y;\n\n        tt.x = t;\n\n        N0 = N;\n    }\n    \n    return hit;\n}\n\nbool VoxelRaycast(vec3 ro, vec3 rd, out vec3 vp, out vec3 N0, out float t)\n{\n    N0 = vec3(0.0);\n    t = 0.0;\n\tvp = floor(ro);\n\t\n    vec3 ri = 1.0/rd;\n    \n\tvec3 rs = vec3(rd.x < 0.0 ? -1.0 : 1.0,\n                   rd.y < 0.0 ? -1.0 : 1.0,\n                   rd.z < 0.0 ? -1.0 : 1.0);\n                     \n\tvec3 off = vec3(rd.x < 0.0 ? 0.0 : ri.x,\n                    rd.y < 0.0 ? 0.0 : ri.y,\n                    rd.z < 0.0 ? 0.0 : ri.z) - ro * ri;\n\n    uvec3 vpu = uvec3(ivec3(vp));\n    uvec3 rsu = uvec3(ivec3(rs));\n\n    uint data = 0u;\n    uvec3 tcL = uvec3(0x10000000u);\n\n    // when stepping into a new grid cell evaluate map() only at the 4 new vertices\n    // this is slower if evaluating map() 4 times is cheaper than shuffeling the data around\n    #define ONLY_EVAL_MAP_AT_NEW_VERTICES\n    \n#ifdef ONLY_EVAL_MAP_AT_NEW_VERTICES\n    {\n        uvec3 tc0 = uvec3(ivec3(vp));\n\n        uvec3 tc = ((tc0 + 1u) >> 1u) - 1u;\n\n        data =        (map(tc + uvec3(0u, 0u, 0u)) < 0.0 ? 1u << 0u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 0u, 0u)) < 0.0 ? 1u << 1u : 0u);\n        data = data ^ (map(tc + uvec3(0u, 1u, 0u)) < 0.0 ? 1u << 2u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 1u, 0u)) < 0.0 ? 1u << 3u : 0u);\n        data = data ^ (map(tc + uvec3(0u, 0u, 1u)) < 0.0 ? 1u << 4u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 0u, 1u)) < 0.0 ? 1u << 5u : 0u);\n        data = data ^ (map(tc + uvec3(0u, 1u, 1u)) < 0.0 ? 1u << 6u : 0u);\n        data = data ^ (map(tc + uvec3(1u, 1u, 1u)) < 0.0 ? 1u << 7u : 0u);\n\n        tcL = tc;\n    }\n#endif\n\n\tvec3 mm = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 512; i++) \n\t{\n        vec3 t30 = vp * ri + off;\n\t\t\n        vec3 mm0 = vec3(minmask(t30));\n        \n        \n       #if 1\n        uvec3 tc0 = uvec3(ivec3(vp));\n       #else\n        uvec3 tc0 = vpu;\n       #endif\n       \n        if(tc0.x >= VOLUME_RES*2u || tc0.y >= VOLUME_RES*2u || tc0.z >= VOLUME_RES*2u) return false;\n\n        uvec3 tc = ((tc0 + 1u) >> 1u) - 1u;\n\n#ifdef ONLY_EVAL_MAP_AT_NEW_VERTICES\n        if(tcL.x != tc.x || tcL.y != tc.y || tcL.z != tc.z)\n        {\n            if(mm.x != 0.0) data = ((data & 0x55u) << 1u) ^ ((data & 0xAAu) >> 1u);\n            if(mm.y != 0.0) data = ((data & 0x33u) << 2u) ^ ((data & 0xCCu) >> 2u);\n            if(mm.z != 0.0) data = ((data & 0x0Fu) << 4u) ^ ((data & 0xF0u) >> 4u);\n            \n            uint dir = dot(mm, rs) > 0.0 ? 1u : 0u;\n            \n            uvec3 off;\n            uint bm;\n            \n            off = mm.x != 0.0 ? uvec3(dir, 0u, 0u) : mm.y != 0.0 ? uvec3(0u, dir, 0u) : uvec3(0u, 0u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n\n            off = mm.x != 0.0 ? uvec3(dir, 1u, 0u) : mm.y != 0.0 ? uvec3(1u, dir, 0u) : uvec3(1u, 0u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n\n            off = mm.x != 0.0 ? uvec3(dir, 0u, 1u) : mm.y != 0.0 ? uvec3(0u, dir, 1u) : uvec3(0u, 1u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n\n            off = mm.x != 0.0 ? uvec3(dir, 1u, 1u) : mm.y != 0.0 ? uvec3(1u, dir, 1u) : uvec3(1u, 1u, dir);\n            bm = 1u << (off.x + off.y * 2u + off.z * 4u);\n            data = (data & ~bm) | (map(tc + off) < 0.0 ? bm : 0u);\n            \n            data = data & 255u;\n        }\n#else        \n        if(tcL.x != tc.x || tcL.y != tc.y || tcL.z != tc.z)\n        {\n            data =        (map(tc + uvec3(0u, 0u, 0u)) < 0.0 ? 1u << 0u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 0u, 0u)) < 0.0 ? 1u << 1u : 0u);\n            data = data ^ (map(tc + uvec3(0u, 1u, 0u)) < 0.0 ? 1u << 2u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 1u, 0u)) < 0.0 ? 1u << 3u : 0u);\n            data = data ^ (map(tc + uvec3(0u, 0u, 1u)) < 0.0 ? 1u << 4u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 0u, 1u)) < 0.0 ? 1u << 5u : 0u);\n            data = data ^ (map(tc + uvec3(0u, 1u, 1u)) < 0.0 ? 1u << 6u : 0u);\n            data = data ^ (map(tc + uvec3(1u, 1u, 1u)) < 0.0 ? 1u << 7u : 0u);\n        }\n#endif        \n#undef DO_OPTIMIZE\n\n        tcL = tc;\n        \n        if(data != 0u)\n        {\n            vec2 tt = vec2(dot(t3 , mm ), \n                           dot(t30, mm0));\n\n            N0 = -rs * mm;\n\n            vec3 rp = ro - (vp + 0.5);\n        \n            bvec3 oct = equal(tc0 & 1u, uvec3(0u));\n        \n            if(IntersectMCCell(rp, rd, data, oct, /*inout*/ tt, N0))\n            {\n                t = tt.x;\n                \n                return true;\n            }\n            \n        }\n       \n        t3 = t30;\n        mm = mm0;\n        \n        vp += mm * rs;\n        vpu += uvec3(mm) * rsu;\n\t}\n\t\n\tN0 = -rs * mm;\n    t = dot(t3, mm);\n\n\treturn hit;\n}\n\nbool SceneRayCast(vec3 rp, vec3 rd, out vec3 n, out vec3 p)\n{\n    p = rp;\n    \n    vec2 tt; vec3 n0 = vec3(0.0);\n    float res = Intersect_Ray_Cube(rp - vec3(VOLUME_RES), rd, vec3(float(VOLUME_RES) - 1.0/1024.0), /*out:*/ tt);\n\n    if(res == -1.0) { return false; }\n    \n    if(res == 1.0)\n    {\n    \tp += rd * tt.x;\n        \n        n0 = vec3(maxmask(abs(p - vec3(VOLUME_RES)))) * -sign(rd);\n    }\n\n    vec3 vp; float t;\n\tbool hit = VoxelRaycast(p, rd, /*out:*/ vp, n, t);\n    \n    if(!hit)\n    {\n        return false;\n    }\n\n    if(n.x == 0.0 && n.y == 0.0 && n.z == 0.0)\n    {\n        n = n0;\n    }\n    \n    n = normalize(n);\n    \n    p += rd * t;\n        \n    return true;\n}\n\nvec3 EvalCol(vec3 rd, vec3 p, vec3 n)\n{\n    vec3  fm  = abs(n);\n    float fmc = dot(mix(vec3(1.0), vec3(0.0), equal(fm, vec3(0.0))), vec3(1.0));\n    \n    float wfA;\n    {\n        bvec3 b = greaterThan(abs(fract(p) - 0.5), vec3(0.45));\n\n        if(fmc != 1.0)\n        {\n            wfA = b.x || b.y || b.z ? 0.0 : 1.0;\n        }\n        else\n        {\n            bvec3 l = bvec3(b.y && b.z, b.z && b.x, b.y && b.x);\n            wfA = l.x || l.y || l.z ? 0.0 : 1.0;\n        }\n        \n    }\n    \n    float wfB;\n    {\n        bvec3 b = greaterThan(abs(fract(p*0.5+0.5) - 0.5), vec3(0.47));\n\n        wfB = b.x || b.y || b.z ? 0.0 : 1.0;\n    }\n    \n    float err = 0.0;\n    {\n        bvec3 b = greaterThan(abs(fract(p*0.5+0.5) - 0.5), vec3(0.47));\n    \n        if(fmc == 1.0)\n        if((b.x && n.x != 0.0) ||\n           (b.y && n.y != 0.0) ||\n           (b.z && n.z != 0.0)) err = 1.0; \n     }     \n     \n    float wf = mix(wfA, 1.0, 0.75) * mix(wfB, 1.0, err);\n    \n    vec3 c;\n    if(ReadKeyToggle(KEY_S) == 0.0)\n    {\n        c = n * 0.5 + 0.5;\n    }\n    else\n    {\n        c = vec3(0.125);\n        c = vec3(1.0, 0.5, 0.25);\n        \n        if(err == 1.0) c = vec3(1.0, 0.25, 0.5);\n        if(fmc == 2.0) c = vec3(0.5, 0.9, 0.25);\n        if(fmc == 3.0) c = vec3(0.25, 0.5, 1.0);\n    }\n    \n    c *= sqrt(clamp01(-dot(n, rd)));\n   \n    if(ReadKeyToggle(KEY_W) == 0.0)\n    c *= wf;\n    \n    return c;\n}\n\nvec3 EvalCol(vec3 rp, vec3 rd, vec3 p0, vec3 n)\n{\n    vec3 p = rp - p0;\n    \n    float PdN = dot(p, n);\n    float DdN = dot(rd, n);\n    \n    float t = PdN / -DdN;\n    \n    return EvalCol(rd, rp + rd * t, n);\n}\n\nvoid GetCameraRay(vec2 uv, sampler2D stateChannel, vec2 pixelCount, out vec3 rp, out vec3 rd, out vec2 tc)\n{\n    vec4 mouseAccu = texelFetch(stateChannel, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(-1.4 * Pi, Pi * 0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    float focalLen = 0.6;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    rp = -cmat[2] * exp2(6.7 + mouseAccu.w * 0.02);\n    \n    rp += vec3(VOLUME_RES);\n    \n    tc = uv * (1.0 / (pixelCount.xx*0.5)) - vec2(1.0, pixelCount.y/pixelCount.x);\n    \n    rd = normalize(cmat * vec3(tc, focalLen));     \n}\n\nvec3 EvalSceneCol(vec2 uv0, vec2 uv)\n{    \n    vec3 col = vec3(0.002);    \n    \n    vec3 rp, rd; vec2 tc;\n    GetCameraRay(uv, iChannel0, iResolution.xy, /*out*/ rp, /*out*/ rd, /*out*/ tc);\n    \n    rp += rd * 1.0;\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, /*out:*/ n, p))\n    {\n        col = vec3(0.0);\n \n        // oversample wireframe shading\n        float count = 3.0;\n        for(float i = 0.0; i < count; ++i) \n        {\n            vec2 uv2 = uv0 + GetUVOffset(uv0, count, i);\n\n            vec3 rp, rd; vec2 tc;\n            GetCameraRay(uv2, iChannel0, iResolution.xy, /*out*/ rp, /*out*/ rd, /*out*/ tc);\n\n            col += EvalCol(rp, rd, p, n);\n        }\n        \n        col /= count;\n    }\n\n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;    \n  \n#if 0\n    col = vec3(EvalSceneCol(uv0, uv0));\n#else\n    vec2 off = GetUVOffset(uv, 1.0, 1.0);\n      \n    col = vec3(EvalSceneCol(uv0, uv0 + off));\n#endif\n    \n    {\n        // vignetting\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n        col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    }\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    data: the lower 8 bits hold the values of the binary implicit evaluated at the 8 vertices of the current grid cell\n    oct:  the octant of the current grid cell for which the slopel type is queried\n    \n  out N:  normal of the slopel plane\n  out D:  offset of the slopel plane along its normal from the slopel center\n  \n  return: is octant not empty\n*/\nbool GetSlopelPlane(uint data, bvec3 oct, out vec3 N, out float D)\n{   \n    // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n    uint d = data;\n    d -= (d >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    d = (d & 0x33333333u) + ((d >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    d = (d + (d >> 4u)) & 0xfu;// put count of each 8 bits into those 8 bits  \n    \n    bool flip = d < 5u;\n    \n    if(flip) data = data ^ 0xFFu;\n    \n    if(oct.x) data = ((data & 0x55u) << 1u) ^ ((data & 0xAAu) >> 1u);\n    if(oct.y) data = ((data & 0x33u) << 2u) ^ ((data & 0xCCu) >> 2u);\n    if(oct.z) data = ((data & 0x0Fu) << 4u) ^ ((data & 0xF0u) >> 4u);\n\n    \n    uint m = data;\n    \n    uint my = data & 0x55u;\n    my = (my ^ (my >>  1u)) & 0x33u;\n    my =  my ^ (my >>  2u);\n    m  =  m  ^ (my << 8u);\n    \n    uint mz = data & 0x33u;\n    mz = (mz ^ (mz <<  1u)) & 0x55u;\n    mz =  mz ^ (mz >>  3u);\n    m  =  m  ^ (mz << 16u);\n    \n    \n    // k will contain the quantized interpolation results + some garbage bits\n    uint k = (m | (m >> 1u)) & 0x010101u;// edges\n    \n     // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n     m -= (m >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n     m = (m & 0x33333333u) + ((m >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    \n    k = k ^ ((m | (m >> 1u)) & 0x020202u);// faces\n    \n    // compact scattered bits\n    k = k ^ (k >> 6u);\n    k = k ^ (k >> 4u);\n    \n    // clean up\n    k = k & 0xCFu;\n    \n    // add the 2 missing bits \n    k = k ^ ((data & 1u) << 4u);// origin\n    // (0 | 0 | k | 0)\n    \n    // expand to 4 blocks\n    k = k ^ (k <<  8u);\n    k = k ^ (k << 16u);\n    // (k | k | k | k)\n    \n    // apply bit flips \n    k = k ^ 0xDF37F17Cu;\n    // (D | N.z | N.y | N.x)\n    \n    // counts bits in each byte block (https://en.wikipedia.org/wiki/Hamming_weight)\n    k -= (k >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    k = (k & 0x33333333u) + ((k >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    k = (k + (k >> 4u)) & 0x0f0f0f0fu;// put count of each 8 bits into those 8 bits  \n    \n    \n    uvec3 N0 = (uvec3(k) >> uvec3(0u, 8u, 16u)) & uvec3(0xFu);\n\n#if 1\n    N0 -= 4u;\n    \n    N = vec3(N0.x == 0u ? 0.0 : 1.0,\n             N0.y == 0u ? 0.0 : 1.0,\n             N0.z == 0u ? 0.0 : 1.0);\n\n    if(oct.x != flip != ((N0.x & 0x80000000u) == 0u)) N.x = -N.x;\n    if(oct.y != flip != ((N0.y & 0x80000000u) == 0u)) N.y = -N.y;\n    if(oct.z != flip != ((N0.z & 0x80000000u) == 0u)) N.z = -N.z;\n#else\n    N = vec3(N0.x < 4u ? 1.0 : N0.x > 4u ? -1.0 : 0.0,\n             N0.y < 4u ? 1.0 : N0.y > 4u ? -1.0 : 0.0,\n             N0.z < 4u ? 1.0 : N0.z > 4u ? -1.0 : 0.0);\n\n    if(oct.x != flip) N.x = -N.x;\n    if(oct.y != flip) N.y = -N.y;\n    if(oct.z != flip) N.z = -N.z;\n#endif\n\n    float count = abs(N.x) + abs(N.y) + abs(N.z);\n\n    if(count < 2.0) N.x = 1.0;\n\n    uint D0 = k >> 24u;\n    {\n        uint th = count == 3.0 ? 4u : 2u;\n\n        float v2 = D0 > 2u ? -0.5 : 0.5;\n\n        if(count  < 2.0) v2 = 128.0;\n        if(count == 2.0) v2 = 0.0;\n\n        D = D0 > th ? -128.0 : v2;\n    }\n    \n    if(flip) \n    { \n        D = -D; \n    }\n    \n    return D > -128.0;\n}\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n#define VOLUME_RES 64u\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nvec3 GammaDecode(vec3 x) {return pow(x, vec3(      2.2));}   \nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n// https://www.shadertoy.com/view/3tdBWM\nvec2 GetUVOffset(vec2 uv, float count, float smplNum)\n{\n    uvec2 uvi = uvec2(uv);\n\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n    if(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n\n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    float i = smplNum;\n    \n    float ang = (Pi*(2.0/count)) * (i+u);\n\n    vec2 off = vec2(cos(ang), sin(ang));\n\n    float l = float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n    \n    return off * l;\n}\n\nbvec3 maxmask(vec3 v)\n{\n    bool x = v.x >  v.y && v.x >  v.z;\n    bool y = v.y >= v.z && v.y >= v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n\nbvec3 minmask(vec3 v)\n{\n    bool x = v.x <= v.y && v.x <= v.z;\n    bool y = v.y <  v.z && v.y <  v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n", "buffer_a_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n// persistent state stuff\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n   \n    if(uv.y >= 1.0) discard;\n    \n    vec4 iMouseLast      = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast  = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast    = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool ctrl  = texelFetch(iChannel1, ivec2(17, 0), 0).x != 0.0;\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    \n    if(ctrl) cond0 = false;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    Write a marching cubes lookup table into Buffer B in case GetSlopelPlane(...) isn't used directly in Image.\n    \n    uv.x [0, 255]: marching cube configuration id\n    uv.y [0,   7]: octant id\n    \n    BufferB[uv] = vec4(slopel plane normal.xyz, slopel plane D);\n*/\n\nvec4 GetMCLookupEntry(uvec2 uv)\n{\n    uint data = uv.x;\n    bvec3 oct = equal((uv.yyy >> uvec3(0u, 1u, 2u)) & 1u, uvec3(1u));\n    \n    vec3 N; float D;\n    GetSlopelPlane(data, oct, /*out*/ N, D);\n    \n    return vec4(N, D);\n}\n\nbool ReadMCLookupEntry(sampler2D sampler, uint data, bvec3 oct, out vec3 N, out float D)\n{\n    uvec2 uv;\n    uv.x = data;\n    uv.y = (oct.x ? 1u : 0u) | (oct.y ? 2u : 0u) | (oct.z ? 4u : 0u);\n    \n    vec4 res = texelFetch(sampler, ivec2(uv), 0);\n    \n    N = res.xyz;\n    D = res.w;\n    \n    return D > -128.0;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    if(iFrame > 1) discard;\n    \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    if(uv.x >= 256.0) discard;\n    if(uv.y >=   8.0) discard;\n\n    uvec2 uv2 = uvec2(uv);\n\n    col = GetMCLookupEntry(uv2);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttyzM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[928, 928, 956, 956, 1010], [1011, 1011, 1045, 1045, 1099], [1101, 1101, 1122, 1122, 1430], [1432, 1432, 1522, 1522, 1745], [1747, 1747, 1839, 1839, 2455], [7364, 7364, 7425, 7425, 8042], [8044, 8044, 8083, 8083, 9446], [9448, 9448, 9497, 9497, 9657], [9659, 9659, 9767, 9767, 10767], [10769, 10769, 10807, 10807, 11497], [11500, 11500, 11546, 11546, 12018]], "test": "untested"}
{"id": "Nl3czM", "name": "Day 957", "author": "jeyko", "description": "potato  t", "tags": ["mdtmjvm"], "likes": 32, "viewed": 616, "published": 3, "date": "1659464505", "time_retrieved": "2024-07-30T16:37:12.358056", "image_code": "// Fork of \"Day 956\" by jeyko. https://shadertoy.com/view/7l3yz4\n// 2022-08-02 07:37:58\n\n// Fork of \"Day 955\" by jeyko. https://shadertoy.com/view/fttyR8\n// 2022-08-01 07:12:45\n\n// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    vec2 oU = U;\n    C *= 0.;\n    \n    float sc = 1./(1.+ max(5.*float(lightMode == 1.)*max(sin(iTime*2.),0.)*sin(iTime*0.5),0.));\n    \n    float md = 14.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(iTime*md)),hash11(ceil(iTime*md)),fract(iTime*md)),0.1);\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    vec2 id;\n    quantid(nuv,vec2(0.0+ 0.04*hash11(floor(iTime*5. + 2000.)),0.001 + 0.04*hash11(floor(iTime*10.))),id);\n    \n    //float db = sdBox(nuv,vec2(0.5,0.4 -  float(lightMode==0.)*float(fract(iTime*0.125)<0.5)*0.1));\n    float db = sdBox(nuv,-vec2( - 0.3 - 0.1*hash11(floor(iTime*10. + 2000.)) -  float(lightMode)));\n    \n    \n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    vec4 d = Td(uv);\n    \n    \n    \n    if(db > 0.){\n        d.xyz *= 0.;\n    }\n    //vec2 st = 0.4/R.xy + 0.1*sin(iTime)*float(hash11(floor(iTime)) < 1. && lightMode == 0.);\n    vec2 st = (140.4 + 0.*float(hash11(floor(iTime*2.)) < 0.5 && lightMode == 0.))/R.xy;\n    \n    int cmp = 0;\n    float l = \n        Tb(uv + vec2(st.x,0))[cmp]-(Tb(uv - vec2(st.x,0)))[cmp] +\n        Tb(uv + vec2(0,st.y))[cmp]-(Tb(uv - vec2(0,st.y)))[cmp] +\n        Tb(uv + vec2(st.xy))[cmp]-(Tb(uv - vec2(st.xy)))[cmp] +\n        Tb(uv + vec2(st.x,-st.y))[cmp]-(Tb(uv - vec2(st.x,-st.y)))[cmp]\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    //a.xz = vec4(l);\n    \n    \n    \n\n\n    C += b;\n    \n    \n    //C = mix(C,1.-C,abs(l));\n    \n    // britney\n    \n    C += d;\n    C = clamp(C,0.,1.);\n    \n    C = mix(C,d,d.z);\n    \n    //C *= Td(uv);\n        \n        \n    uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    if(lightMode == 0.){\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        p.y *= 0.01;\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.003;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        if(mod(id.y+iTime,2.) == 0.){\n            if(r.y < 0.){\n                if(r.x < 0.9)\n                    d = abs(d) - 0.0004;\n                \n                C = mix(C,vec4(1),smoothstep(0.001,0.,d));\n                \n            } else if(r.x < 0.1){\n                C = mix(C,vec4(1),1.);\n                \n            }\n               \n        }\n         \n    }\n    \n    {\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.004;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        \n        if((id.y) > 14. && abs(id.x) < 13. && sin(iTime + sin(r.y*3.)*4.)> 0.){\n            C = vec4(1);\n            if(r.y < 0.4){\n                int cidx = int(r.x*4.*4.);\n                vec3 c = palAppleII[cidx];\n                \n                c = rgb2hsv(c);\n                c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n        \n                C.xyz = c;\n                \n            }\n               \n        }\n\n         \n    }    \n    \n    vec3 n = hash33(vec3(U,mod(iTime,200.)));\n    vec3 nb = hash33(vec3(U,mod(iTime,5200.)));\n    \n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    float e = float(enva(iTime)>0.4);\n\n    if(e == 0. && fract(iTime*0.3) < 0.5){\n        if(uv.x < 0.)\n            C = mix(C,1.-C,smoothstep(1./min(R.x,R.y),0.,abs(db) - 0.001 - 0.4*e));\n    \n    }else {\n        C = mix(C,1.-C,smoothstep(1./min(R.x,R.y),0.,abs(db) - 0.04 - 0.4*e));\n    \n    }\n    \n    C = max(C,vec4(0.01));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n//float eeeeeeeeeeee;\n\n//#define iTime (iTime + floor(gl_FragCoord.y/200.)*0.4*)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt,float t){\n\n    //ro = vec3(,4,0) + 0.004;\n    lookAt += 0.1*sin(t*vec3(1,0.8,0.9));\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define lightMode float(fract(iTime*0.1) <0.5 )\n\n\n// iq\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nvec3 getRo(float t, vec2 m, vec2 r){\n    vec3 ro = vec3(0,0,-2);\n    //ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    ro.yz *= rot(sin(t)*0.4);\n    \n    ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    \n    ro.xz *= rot((t + sin(t*1.4))*0.6);\n    ro.xz *= rot(m.x/r.x);\n    ro.yz *= rot(m.y/r.x);\n    return ro;\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 8.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5*vec4(1,1.5,1,1);\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n#define quant(v,a) floor(v/a)*a\n#define quantid(v,a,id)  id = floor(v/a);v = floor(v/a)*a; \n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = vec4(0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// raymarch\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat map(vec3 p){\n    vec3 op = p;\n    p.y += (iTime + sin(iTime))*0.4;\n    \n    if(lightMode == 0.)\n        p.xz *= rot(p.z + sin(iTime + p.z)*4.);\n    else\n        p.xz *= rot(p.y + sin(iTime + p.y)*3.);\n    \n    \n    float d = 10e5;\n    \n    float its = 2.;\n    for(float i = 0.; i < its; i++){\n        vec3 lp = p - vec3(cos(i/its*pi*2.),0,sin(i/its*pi*2.))*sin(iTime+i + sin(iTime + i))*1.;\n        \n        \n        if(lightMode == 1.)\n            d = min(d,dot(lp.xz,lp.xz));\n        else\n            d = min(d,length(lp.xz));\n    }\n    \n    return d + sin(p.y + iTime)*0.3*noise(p*2.*vec3(1.,0.1,4) + vec3(iTime + sin(iTime),0,0))*0.4 + smoothstep(2.,3.,abs(op.y));\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    float sc = 1.;\n    U = floor(U/sc)*sc;\n    \n    vec2 uv = (U-0.5*R.xy)/max(R.x,R.y)*(1. ) ;\n    //uv += vec2(.6,0)*float(fract(iTime*14.2) < 0.4)*float(fract(iTime*2.2) < 0.1);\n    //vec2 t = 1./R.xy;\n    //vec4 l = vec4(\n    //    luma(Ta(uv + vec2(t.x,0)))-luma(Ta(uv - vec2(t.x,0))) +\n    //    luma(Ta(uv + vec2(0,t.y)))-luma(Ta(uv - vec2(0,t.y)))\n    //);\n    //l = abs(l);\n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,0.5));\n    \n    \n    float t = 0.;\n    vec3 p = ro;\n    bool hit = false;\n    for(float i = 0.; i < 140.; i++){\n        float d = map(p);\n        \n        if(d < 0.01){\n            hit = true;\n            break;\n        } else if(t > 4.5){\n            break;\n        }\n        d *= 0.2;\n        \n        p = ro + rd * (t += d);\n    }\n    if(hit == false){\n        t = 1000.;\n    } \n    \n    uv = U/R.xy*(1. );\n    \n    \n    vec2 st = 1.4/R.xy;\n   \n    float tPrev = Tb(uv).x;\n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x\n    ;\n    \n    \n    \n    if(hit){\n        if(fract(iTime*0.2) < 0.5){\n            C.x = sin(p.x*20.);\n        }else{\n            float md = 0.7;\n            if(lightMode == 1.)\n                C.x = floor(fract(p.y*20.)/md)*md;\n            else\n                C.x = sin(length(abs(p)/dot(p,p))*200.);\n        }\n    }\n    else \n        C.x = 0.;\n    //C.z = 0.;\n    \n    C.y = l;\n    C.z = t;\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// dither\n\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + int(fract(iTime*0.1) < 0.5)))).x;\n    \n    \n    float quant = 1.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    s = vec4(s.x);\n    \n    \n    \n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n   \n    vec3 Chsv = rgb2hsv(C.xyz);\n\n    vec3 hit = vec3(0);\n    float similarity = -0.;\n    for(int i = 0; i < 4*4; i++){\n        vec3 palC = palAppleII[i];\n        \n        vec3 palCHsv = rgb2hsv(palC);\n        palCHsv.b += sin(iTime*(2. + float(fract(iTime*0.2)>0.8)*20.) + float(i))*3.;\n        float localSimilarity = dot(palCHsv.b, Chsv.b);\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    \n    C = vec4(hit.xyzx);\n    \n}", "buffer_c_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ui\n\n \nvec4 n14(float f){ return hash41(f); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    char += floor(hash11(idx)*200.);\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2 + idx)),5.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 3. - hash11(idx + 20.)*2.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 oU = U;\n    float sc = 1. + 4.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    \n    float z = Ta(U/R.xy).z;\n    z = z*=0.25;\n    \n    uv = (U - 0.5*R.xy)/min(R.y,R.x);\n    \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n    float rep = fract(iTime*0.15) < 0.25 ? 0.04 : 1./min(R.y,R.x);\n    \n    float idd = floor(uv.y/rep);\n    uv.y = floor(uv.y / rep)*rep; \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    C -= C;\n    {\n        \n        vec2 lastDotPos = vec2(0);\n        float lastDD = 10e5;\n        for(float i = 0.; i < 210. - lightMode*200. ; i++){\n            vec3 dotPos = max(hash31(i + 20.),0.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*4.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            \n            float r = hash11(i);\n            \n            float d;\n            \n            if(r < 0.8){\n            lp *= rot(exp(-fract(iTime*sin(i) + sin(i)*20.)*4.)*pi);\n                d = max(\n                    min(abs(lp.x),abs(lp.y)),\n                    sdBox(lp,vec2(0.02,0.01))\n                ) - 0.001 - 0.00*pow(abs(sin(i + iTime)),5.);\n                d = max(d,-sdBox(lp,vec2(0.01)));\n            } else {\n                d = sdBox(lp,vec2(0.001,0.04));\n            }\n            if(projPos.z < z)\n                C += smoothstep( 1./R.x, 0. , d);\n        }        \n        for(float i = 0.; i < 30.; i++){\n            vec3 dotPos = max(hash31(i + 120.),0.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*4.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            float d;\n            \n            vec2 r = hash21(i);\n            \n            \n            {\n                lp *= rot(iTime + i + sin(iTime*2. + i));\n            \n                 if(i<30.){\n                    float dd = length(lp) - 0.001 - 0.01*sin(i + iTime + sin(iTime + i));\n\n                    if(r.y > 0.5)\n                        d = abs(dd) - 0.001 ;\n                    else\n                        d = (dd) - 0.001 ;\n\n                    //if(lightMode == 0.){\n\n                       float l = sdSegment(uv,projPos.xy,lastDotPos.xy)-0.004*(sin(i + iTime*2.));\n                       if(mod(idd,2.) == 0.)\n                           l = 10e5;\n                       d = min(d,max(max(l,-dd),-lastDD));\n                    //}\n\n                    lastDD = dd;\n\n                } else {\n                    // epic lines\n                    //if(lightMode == 0.)\n                        continue;\n                    d = length(lp.y) - 0.004 ;\n                }\n            }\n            \n            lastDotPos = projPos.xy;\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n            \n            if(projPos.z < z)\n                C += smoothstep( 1./R.x, 0. , d);\n        }\n        \n        // lines-text\n        for(float i = 0.; i < 340.\n            - 100.*float(fract(iTime*2.5) < 0.5) \n            - 100.*float(fract(iTime*.25) > 0.5) \n            + float(fract(iTime*0.1) < 0.5)*300.;\n            i++){\n            \n            vec3 dotPos = max(hash31(i + 420.),0.);\n            dotPos = dotPos*2. - 1.;\n            dotPos *= 0.6*float(fract(iTime*0.1) > 0.1);\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            float d;\n            \n            vec2 r = hash21(i);\n            \n            float td;\n            {\n                //lp *= rot(iTime + i + sin(iTime*2. + i));\n            \n                float sz = 0.01 + 0.01*sin(i + iTime + sin(iTime + i));\n                float dd = length(lp) - sz;\n                \n                if(r.y > 0.5)\n                    d = abs(dd) - 0.001 ;\n                else\n                    d = (dd) - 0.001 ;\n\n\n                vec2 uiPos = (0.5+hash21(i + 20.)*0.5)*2. - 1.;\n                \n                //uiPos *= 0.5;\n                \n                uiPos = mix(projPos.xy + uiPos*0.5 ,projPos.xy,0.5);\n                \n                float imp = smoothstep(0.4,0.5,abs(projPos.y) + abs(projPos.x)*0.5);\n                //imp += max(sin(i + iTime + sin(i + iTime)),0.);\n                \n                imp = mix(imp,100.,max(-sz*200.,0.));\n                //if(sz < 0.)\n                //    imp *= 1000.;\n                \n                \n                //imp += 1.;\n                float l = sdSegment(uv,projPos.xy,uiPos.xy)-0.001 + imp;\n                \n                \n                {\n                    float sc = 4. + sin(i)*1.;\n                    \n                    sc += 20.*imp;\n                    \n                    if(imp > 0.9)\n                        sc *= 1000.;\n                    vec2 tp = uv - uiPos;\n                    \n                    \n                    tp *= sc;\n                    //uv *= 2.;\n                    \n                    td = text(tp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.5, true, i);\n                    \n                    //td = abs(td);\n                    \n                    \n                \n                }\n                \n                \n                //if(mod(idd,2.) == 0.)\n                //    l = 10e5;\n                d = min(d,max(l,-dd));\n\n\n                lastDD = dd;\n\n               \n            }\n            \n            lastDotPos = projPos.xy;\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n                       \n            if(projPos.z < z && mod(idd,4.) != 0.){\n                C += smoothstep( 1./R.x, 0. , d);\n            \n                C = mix(C,vec4(1),smoothstep(0.5*0.04*(1.-step(0.01,td)),0.,td - 0. * float(i<9. && sc > 5.)));\n            }\n        }\n        // epic text\n        /*\n        for(float i = 0.; i < 40. - 30.*lightMode; i++){\n            vec3 dotPos = max(hash31(i + 100.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n \n            float sc = 8. + sin(i)*5.;\n            lp *= sc;\n            //uv *= 2.;\n\n            float td = text(lp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.47 , true, i);\n            \n            if(projPos.z < z)\n                C = mix(C,vec4(1),smoothstep(0.4*0.01*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n\n            //col = mix(col,vec3(1),smoothstep(0.4*fwidth(td)*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n            \n        }*/\n\n        \n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n\n        \n    \n    }\n\n   U = oU;\n    sc = 1. + 15.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   \n   u += 1. - hash11(floor(iTime) + 200.)*1.8;\n   u *= 0.9 - hash11(floor(iTime))*0.1;\n   u*=0.51 + floor((hash11(floor(iTime/3.))*4.));\n   u.x /= 7.;\n   \n\n    //u += 1./3.;\n   if(u.x < 1. && u.y < 1. && u.x > 0. && u.y > 0. && fract(iTime) < 0.2 && sin(iTime) < 0.){\n       vec4 britney =  texture(iChannel1,u);\n       float dith = texture(iChannel2,oU.xy/vec2(textureSize(iChannel1,0).xy*(4 + 0*int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n        float quant = 3.;\n        float recipQuant = 1./quant;\n\n        vec4 s = Tb(uv);\n        vec4 currC = floor(s*quant)/quant;\n        vec4 nextC = clamp(currC + recipQuant,0.,1.);\n        float perc = fract(luma(s)*quant);\n\n\n\n\n        if(perc>dith){\n            britney = nextC;\n        } else{\n            britney = currC;\n        }\n        \n        britney.xyz = rgb2hsv(britney.xyz);\n        britney.xyz = hsv2rgbSmooth(britney.xyz*vec3(110.9,0.5,0.5) + vec3(1. + iTime,0.2,0.)).xyz;\n        C = britney;\n       C -= 1.- britney;\n       C.w = 1.;\n   } else {\n       C.w = 0.;\n   }\n   \n   \n    \n\n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}", "buffer_d_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3czM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[763, 763, 803, 803, 4438]], "test": "untested"}
{"id": "fttcRM", "name": "Proper vs Fabrice Corner", "author": "pyBlob", "description": "left=proper, center=subtract 180°, right=fabrice\n\ntop=only corner\nbottom=zoomed corner + 3 cubes", "tags": ["3d", "sdf", "corner", "l2", "linf"], "likes": 0, "viewed": 179, "published": 3, "date": "1659462296", "time_retrieved": "2024-07-30T16:37:13.327464", "image_code": "bool proper, sub180, big;\n\nconst int Linf = 00;\nconst int L2   =  2;\nint norm = Linf;\n\nfloat zsweep = 0.;\nbool diagonal = true;\n\nvoid demo()\n{\n    //return;\n    diagonal = cos(iTime/8.) > 0.;\n    norm = sin(iTime/8. + .01) > 0. ? Linf : L2;\n    zsweep = 9. * sin(iTime);\n}\n\nfloat C(vec3 q)\n{\n    if (norm == Linf)\n        return max(q.x, max(q.y,q.z));\n    if (norm == L2)\n    {\n        //return length(max(q, 0.));\n        return length(max(q, 0.)) + min(max(max(q.x, q.y), q.z), 0.);\n    }\n    return 0.;\n}\n\nfloat sdCorner(vec3 q, vec3 r)\n{\n    vec3 a; float t;\n    if (big) q /= 2.;\n    if (norm == Linf)\n    {\n        if (proper)\n            t = C(q + 8. * step(q.xyz, min(q.yzx, q.zxy)));\n        else if (sub180)\n            t = max(C(q), -C(-q-8.));\n        else\n        {\n            t = C(q), a = 8.-abs(q), t = max(t, -C(-a));\n            //t = C(q), a = 8.-abs(q), t = -C(-a); // only show subtracted box\n        }\n    }\n    if (norm == L2)\n    {\n        if (proper)\n            // the L2 corner does not like having multiple 1-values in that added vector\n            // -> use \"?:\" instead of \"step\"\n            t = C(q + 8. * (q.x<min(q.y, q.z) ? vec3(1,0,0) : q.y<min(q.x, q.z) ? vec3(0,1,0) : vec3(0,0,1)));\n        else if (sub180)\n            t = max(C(q), -C(-q-8.));\n        else\n        {\n            t = C(q), a = 8.-abs(q), t = max(t, min(min(a.x, a.y), a.z));\n            //t = C(q), a = 8.-abs(q), t = min(min(a.x, a.y), a.z); // only show subtracted box\n        }\n    }\n    if (big) t = min(t, C((abs(q+vec3(6,2,2))-2.)));\n    if (big) t = min(t, C((abs(q+vec3(2,6,2))-2.)));\n    if (big) t = min(t, C((abs(q+vec3(2,2,6))-2.)));\n    if (big) t *= 2.;\n    return t;\n}\n\nfloat sdScene(vec2 p)\n{\n    float scale = 12.;\n    p *= scale;\n    vec3 q;\n    q = vec3(p, zsweep);\n    if (diagonal)\n    {\n        q /= sqrt(vec3(2,6,3));\n        q = mat3(-1,1,0, -1,-1,2, 1,1,1) * q;\n    }\n    return sdCorner(q, vec3(8. + cos(iTime*3.), 8. + cos(iTime * 2.), 8.)) / scale;\n}\n\nfloat VC(vec3 q)\n{\n    if (diagonal)\n    {\n        q /= sqrt(vec3(2,6,3));\n        q = mat3(-1,1,0, -1,-1,2, 1,1,1) * q;\n    }\n    return C(abs(q));\n}\n\nconst vec2 views = vec2(3, 2);\nvoid linf(out vec4 fragColor, vec2 fragCoord, vec3 iResolution, vec4 iMouse, float iTime)\n{\n    // iq: Box - distance L-inf https://www.shadertoy.com/view/Nlj3WR\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y * views.yx/views.x;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y * views.yx/views.x;\n\n    if( iMouse.z<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    float d = sdScene(p);\n\n    vec3 col;\n    if (norm == Linf)\n    {\n        col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n        col *= 1.0 - exp(-3.0*abs(d));\n        col *= 0.8 + 0.2*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n    }\n    if (norm == L2)\n    {\n        col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n        col *= 1.0 - exp(-3.0*abs(d));\n        col *= 0.8 + 0.2*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n    }\n\n    d = sdScene(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(VC(vec3(p-m, 0)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    demo();\n    vec3 R = iResolution;\n    vec2 U = O * views;\n    proper = U.x < R.x;\n    sub180 = U.x >= R.x && U.x < 2. * R.x;\n    big = U.y < R.y;\n    linf(C, mod(U, R.xy), R, iMouse.z < 0.01 ? iMouse : mod(iMouse*views.xyxy, R.xyxy), iTime);\n    C = mix(C, vec4(0), clamp(2. - abs(O.y - floor(R.y/2.*1.) + .5), 0., 1.));\n    C = mix(C, vec4(0), clamp(2. - abs(O.x - floor(R.x/3.*1.) + .5), 0., 1.));\n    C = mix(C, vec4(0), clamp(2. - abs(O.x - floor(R.x/3.*2.) + .5), 0., 1.));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 142, 156, 272], [274, 274, 291, 291, 508], [510, 510, 542, 542, 1691], [1693, 1693, 1716, 1716, 1986], [1988, 1988, 2006, 2006, 2138], [2171, 2171, 2262, 2332, 3327], [3329, 3329, 3365, 3365, 3850]], "test": "untested"}
{"id": "slccz7", "name": "infinite nested block 2", "author": "FabriceNeyret2", "description": "inspired by reference:  https://twitter.com/kineticgraphics/status/1537861671296741376\n\nimproving https://www.shadertoy.com/view/7ldyRH\nwith the help of pyBlob https://shadertoy.com/view/NtdyRN", "tags": ["raymarching", "short", "reproduction"], "likes": 18, "viewed": 364, "published": 3, "date": "1659457507", "time_retrieved": "2024-07-30T16:37:14.148269", "image_code": "// improving https://www.shadertoy.com/view/7ldyRH\n// with the help of pyBlob https://shadertoy.com/view/NtdyRN\n\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))          // rotation \n#define C(q)         max( q.x, max(q.y,q.z) )\n#define B(d,y,k,p)   r = abs( q+ vec3(6, y, 2.+4.*min(d,T-k)).p ), t = min(t, C(r) -2. )  \nfloat T;\n\nfloat S(vec3 q) {                                          // --- scene\n    //float t= C(q); vec3 r, a = 8.-abs(q); t = max(t, -C(-a) ); // cube - corner\n    float t = max(C(q), -C(-8.-q)); vec3 r;                    // pyBlob simplif\n    B(1.,6.,2.,xyz),                                           // flying bricks\n    B(0.,6.,3.,yzx), \n    B(0.,6.,4.,zxy), \n    B(0.,6.,5.,xyz), \n    B(0.,2.,6.,yzx), \n    B(0.,2.,7.,zxy), \n    B(0.,2.,8.,xyz);\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    T = mod(iTime,8.);\n    float t=9., l=0., s = exp2(-T/8.); \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -4.*R.y) - R),           // ray direction\n          p = vec3(11.5),                                  // marching point along ray\n          e = vec3(1e-3,0,0), N,\n          M = iMouse.z > 0. ? 2.*(iMouse.xyz/R -.5)\n              :  0.*vec3( 10,4,0)/1e2 * cos(iTime + vec3(0,11,0)); \n    p *= s;                                                // zoom\n    D.xy *= rot(.5*iTime),\n    D.yz *= rot(-.6*M.y+.60),                              // rotations\n    D.xz *= rot(-.6*M.x+.78); \n    for( O = vec4(1); O.x > 0. &&  t > .01; O-=.01 )       // march scene\n        l += t = S(p),\n        p += t*D;                                          // step forward = dist to obj          \n\n    N = normalize( vec3(S(p+e),S(p+e.zxy), S(p+e.yzx) ) - S(p) ); // normal\n    O.rgb  = (1.+.3*N) * exp(-.1*(l/s-20.));               // color scheme\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slccz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 333, 350, 486, 794], [796, 796, 832, 832, 1785]], "test": "untested"}
{"id": "7tccR7", "name": "Infinite Cubes", "author": "nsbalbi", "description": "Heavily adapted from Inigo Quilez (https://iquilezles.org/). Renamed some variables and added comments to improve readability and understanding", "tags": ["raymarching"], "likes": 3, "viewed": 377, "published": 3, "date": "1659453347", "time_retrieved": "2024-07-30T16:37:14.963091", "image_code": "// Heavily adapted from Inigo Quilez (https://iquilezles.org/)\n\nconst float D_MAX = 30.0;   // max marching distance\n\n#define AA 2  // number of anti-aliasing passes\n\n// SDFs\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sceneSDFnoRep(vec3 samplePoint) {    \n  return sdBox(samplePoint, vec3(0.1));\n}\n\n// SDF Transforms\n\n// Repeat SDF infinitely\n// c is ~size of repeated unit\nfloat opRep( in vec3 p, in vec3 c){\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sceneSDFnoRep( q );\n}\n\n// Scene SDF\nfloat sceneSDF(vec3 samplePoint) {    \n  return opRep(samplePoint, vec3(1.0));\n}\n\n// Calculates surface normal\nvec3 calcNormal( in vec3 pos ) {\n  vec2 e = vec2(1.0,-1.0)*0.5773;\n  const float eps = 0.0005;  // small increment epsilon\n  return normalize( e.xyy*sceneSDF( pos + e.xyy*eps ) + \n          e.yyx*sceneSDF( pos + e.yyx*eps ) + \n          e.yxy*sceneSDF( pos + e.yxy*eps ) + \n          e.xxx*sceneSDF( pos + e.xxx*eps ) );\n}\n\n// Apply fog\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float dist,     // camera to point distance\n               in float distFactor) {\n  float fogAmount = 1.0 - exp( -dist * distFactor );\n  vec3  fogColor  = vec3(0.0, 0.0, 0.0);\n  return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n// camera movement\t\n  vec3 eye = vec3( 1.0 - iTime, 0.4, -1.0 + iTime );\n  vec3 center = vec3( 0.0  - iTime, 0.0, 0.0  + iTime );\n  // camera matrix\n  vec3 ww = normalize( center - eye );  // vect from center to eye\n  vec3 uu = normalize( cross(ww, vec3(0.0,1.0,0.0)) );  // cross with up\n  vec3 vv = normalize( cross(uu, ww) );\n\n  vec3 tot = vec3(0.0);\n  \n  #if AA>1  // anti-aliasing passes\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ ) {\n    // pixel coordinates\n    vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;  // offset for anti-aliasing passes\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+offset))/iResolution.y;\n    #else    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    #endif\n\n    // create view ray\n    vec3 ray = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    float dTot = 0.0;\n    for( int i=0; i<256; i++ ) {\n      vec3 pos = eye + dTot*ray;\n      float d = sceneSDF(pos);\n      if( d < 0.0001 || dTot > D_MAX ) break;\n      dTot += d;\n    }\n    \n    // shading/lighting\t\n    vec3 color = vec3(0.0);\n    if( dTot < D_MAX ) {\n      vec3 pos = eye + dTot * ray;  // position of point on surface\n      vec3 normal = calcNormal(pos);  // surface normal\n      float diffuse = clamp( dot(normal, vec3(0.5)), 0.0, 1.0 );\n      float ambient = 0.5 + 0.5 * dot(normal, vec3(0.0,1.0,0.0));\n      color = vec3(0.5882, 0.302, 0.302) * ambient + vec3(0.098, 0.1843, 0.5882) * diffuse;\n\n      color = applyFog(color, dTot, 0.3);\n    }\n\n    // gamma        \n    color = sqrt( color );\n    tot += color;\n    #if AA>1\n  }\n  tot /= float(AA*AA);  // take mean if multiple anti-aliasing passes\n  #endif\n\n  fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tccR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 207, 207, 294], [296, 296, 335, 335, 381], [402, 458, 493, 493, 557], [559, 572, 606, 606, 652], [654, 683, 715, 715, 1005], [1007, 1020, 1185, 1185, 1323]], "test": "untested"}
{"id": "st3yR7", "name": "Wiggly Lines illusion (273 ch)", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/scdollins/status/1553110788809756674", "tags": ["illusion", "2tweets", "perception", "short", "golf", "reproduction"], "likes": 13, "viewed": 229, "published": 3, "date": "1659452404", "time_retrieved": "2024-07-30T16:37:15.720067", "image_code": "// more readable version below\n\n// ---  -13 chars by coyote\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u+u - R,\n         I = ceil(U*=8./R.y),             // cell Id\n         N = round(U);                    // node Id\n         \n    u -= u - atan( 20.* sin( .5*iTime + sin(dot(N,7.+R)) *1e3 ));\n    \n    O = smoothstep(24./R.y, 0., vec4( abs(U-N)-.01, length(U-N)-.2*abs(u) ));\n    \n    O += mix( mix( mod(I+I.y,2.),         // checkered background\n                   step(0.,u), O.zw).x,   // dots at nodes\n                   .6, max(O.x,O.y) ) -O; // grey lines\n}\n\n\n\n\n\n\n/** //--- 286 chars\n\n#define S(v)    smoothstep(24./R.y, 0., v)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 8.* ( u+u - R ) / R.y,\n         I = ceil(U),                                         // cell Id\n         N = round(U),                                        // node Id\n      // F = U - N,                                           // node local coords\n         L = S( abs(U-N) -.01 );                              // lines\n                               // ease-flip every Pi seconds with random phase\n    float r = atan( 20.* sin( .5*iTime + sin(dot(N,7.+R)) *1e3 ));\n    O += mix( mix( mod(I.x+I.y,2.),                           // checkered background\n                   step(0.,r), S( length(U-N) - .2*abs(r) )), // dots at nodes\n                   .6, max(L.x,L.y) ) -O;                     // grey lines\n}\n\n\n\n\n\n/**  // --- 338 chars\n\n//#define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define H(p)    fract(sin(dot(p, 7.+R)) * 4e4 )\n#define S(v)    smoothstep(24./R.y, 0., v)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 8.* ( 2.*u - R ) / R.y,\n         I = ceil(U);                                     // cell Id\n\n    float r = atan(20.*sin(.5*iTime + 6.28*H(round(U)))); // ease-flip every Pi seconds with random phase\n    U = fract(U+.5) -.5;                                  // node local coords\n    O = mix( vec4( mod(I.x+I.y,2.) ),                     // checkered background\n             vec4(r>0.), S( length(U) - .2*abs(r) ));     // dots at nodes\n    U = S( abs(U) -.01 );\n    O = mix(O, vec4(.6), max(U.x,U.y) );                  // grey lines\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3yR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 99, 99, 603]], "test": "untested"}
{"id": "sl3yRM", "name": "Time for some inner reflections", "author": "mrange", "description": "CC0: Time for some inner reflections\nAn evolution of: https://www.shadertoy.com/view/7dKBDt\nAfter a tip from shane found knighty's shader: https://www.shadertoy.com/view/MsKGzw\nKnighty's shaders allows one to experiment with many cool polyhedras\n", "tags": ["3d", "reflections"], "likes": 46, "viewed": 639, "published": 3, "date": "1659443883", "time_retrieved": "2024-07-30T16:37:16.458093", "image_code": "// CC0: Time for some inner reflections\n// An evolution of: https://www.shadertoy.com/view/7dKBDt\n// After a tip from shane found knighty's shader: https://www.shadertoy.com/view/MsKGzw\n// Knighty's shaders allows one to experiment with many cool polyhedras\n\n// Original inspiration from:https://www.youtube.com/watch?v=qNoQXF2dKBs\n\n// ------------------------------------------------------------------------------------\n// Here are some parameters to experiment with\n\n#define INNER_SPHERE\n//#define GOT_BEER\n\nconst float poly_U        = 1.0;  // [0, inf]\nconst float poly_V        = 1.0;  // [0, inf]\nconst float poly_W        = 2.0;  // [0, inf]\nconst int   poly_type     = 3;    // [2, 5]\n\nconst float zoom = 3.0;\n// ------------------------------------------------------------------------------------\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define MAX_BOUNCES     6\n\n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nconst float poly_cospin   = cos(PI/float(poly_type));\nconst float poly_scospin  = sqrt(0.75-poly_cospin*poly_cospin);\nconst vec3  poly_nc       = vec3(-0.5, -poly_cospin, poly_scospin);\nconst vec3  poly_pab      = vec3(0., 0., 1.);\nconst vec3  poly_pbc_     = vec3(poly_scospin, 0., 0.5);\nconst vec3  poly_pca_     = vec3(0., poly_scospin, poly_cospin);\nconst vec3  poly_p        = normalize((poly_U*poly_pab+poly_V*poly_pbc_+poly_W*poly_pca_));\nconst vec3  poly_pbc      = normalize(poly_pbc_);\nconst vec3  poly_pca      = normalize(poly_pca_);\n\nconst float initt = 0.125; \n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nvoid poly_fold(inout vec3 pos) {\n  vec3 p = pos;\n\n  for(int i = 0; i < poly_type; ++i){\n    p.xy  = abs(p.xy);\n    p    -= 2.*min(0., dot(p,poly_nc)) * poly_nc;\n  }\n  \n  pos = p;\n}\n\nfloat poly_plane(vec3 pos) {\n  float d0 = dot(pos, poly_pab);\n  float d1 = dot(pos, poly_pbc);\n  float d2 = dot(pos, poly_pca);\n  float d = d0;\n  d = max(d, d1);\n  d = max(d, d2);\n  return d;\n}\n\nfloat poly_corner(vec3 pos) {\n  float d = length(pos) - .1;\n  return d;\n}\n\nfloat dot2(vec3 p) {\n  return dot(p, p);\n}\n\nfloat poly_edge(vec3 pos) {\n  float dla = dot2(pos-min(0., pos.x)*vec3(1., 0., 0.));\n  float dlb = dot2(pos-min(0., pos.y)*vec3(0., 1., 0.));\n  float dlc = dot2(pos-min(0., dot(pos, poly_nc))*poly_nc);\n  return sqrt(min(min(dla, dlb), dlc))-0.025;\n}\n\nfloat poly_planes(vec3 pos, out vec3 pp) {\n  poly_fold(pos);\n  pos -= poly_p;\n\n  pp = pos;\n  return poly_plane(pos);\n}\n\nfloat poly_edges(vec3 pos, out vec3 pp) {\n  poly_fold(pos);\n  pos -= poly_p;\n\n  pp = pos;\n  return poly_edge(pos);\n}\n\n\nfloat blobs(vec2 p) {\n  // Generates a grid of dots\n  vec2 bp = p;\n  vec2 bn = mod2(bp, vec2(3.0));\n\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*gcol, 0.0, 1.0);\n  \n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    const float fz = 0.25;\n    const float bz = 1.0/fz;\n    vec2 bpos = pos.xz/bz;\n    float db = blobs(bpos)*bz;\n    db = abs(db);\n    vec2 pp = pos.xz*fz;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.125);\n    dp = min(dp, db);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 pcol = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    \n    float f = 1.0-tanh_approx(0.1*length(pos.xz));\n    col = mix(col, pcol , f);\n  }\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));\n  }\n\n\n  return col;\n}\n\nfloat dfExclusion(vec3 p, out vec3 pp) {\n  return -poly_edges(p/zoom, pp)*zoom;\n}\n\nfloat shape(vec3 p) {\n  vec3 pp;\n  return poly_planes(p/zoom, pp)*zoom;\n}\n\nfloat df0(vec3 p) {\n  float d0 = shape(p);\n  float d = d0;\n  return d;\n}\n\nfloat df1(vec3 p) {\n  float d0 = -shape(p);\n  float d = d0;\n#if defined(INNER_SPHERE)\n  float d1 = length(p) - 2.;\n  d = min(d, d1);\n#endif\n  return d;\n}\n\nvec3 normal1(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df1(pos+eps.xyy) - df1(pos-eps.xyy);\n  nor.y = df1(pos+eps.yxy) - df1(pos-eps.yxy);\n  nor.z = df1(pos+eps.yyx) - df1(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch1(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df1(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 normal0(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df0(pos+eps.xyy) - df0(pos-eps.xyy);\n  nor.y = df0(pos+eps.yxy) - df0(pos-eps.yxy);\n  nor.z = df0(pos+eps.yyx) - df0(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch0(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df0(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  float tagg = initt;\n  vec3 ragg = vec3(1.0);\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float mragg = max(max(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.1) break;\n    float st = rayMarch1(ro, rd);\n    tagg += st;\n    vec3 sp = ro+rd*st;\n    vec3 spp;\n    float de = dfExclusion(sp, spp);\n    vec3 sn = normal1(sp);\n    \n    float si = cos(5.0*TAU*zoom*spp.z-0.5*sp.y+TIME);\n    const vec3 lcol = vec3(1.0, 1.5, 2.0)*0.8;\n    float lf = mix(0.0, 1.0, smoothstep(0., 0.9, si));\n    \n    vec3 gcol = ragg*lcol*exp(8.0*(min(de-0.2, 0.0)));\n    // Will never miss\n    if (de < 0.0) {\n      agg += gcol;\n      ragg *= vec3(0.5, 0.6,0.8);\n    } else {\n      agg += gcol*lf;\n      agg += ragg*lcol*1.5*lf;\n      ragg = vec3(0.0);\n    }\n    \n    rd = reflect(rd, sn);\n    ro = sp+initt*rd;\n    tagg += initt;\n  }\n#if defined(GOT_BEER)\n  return agg*exp(-.5*vec3(0.3, 0.15, 0.1)*tagg);\n#else  \n  return agg;\n#endif\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec3 col = skyCol;\n\n  float st = rayMarch0(ro, rd);\n  vec3 sp = ro+rd*st;\n  vec3 sn = normal0(sp);\n    vec3 spp;\n  float de = dfExclusion(sp, spp);\n  float ptime = mod(TIME, 30.0);\n  if (st < MAX_RAY_LENGTH) {\n    float sfre = 1.0+dot(rd, sn);\n    sfre *= sfre;\n    sfre = mix(0.1, 1.0, sfre); \n    vec3 sref   = reflect(rd, sn);\n    vec3 srefr  = refract(rd, sn, 0.9);\n    vec3 ssky = sfre*skyColor(sp, sref);\n\n    if (de > 0.0) {\n      col = ssky;\n    } else {\n      col = 0.5*sfre*ssky;\n      vec3 col1 = (1.0-sfre)*render1(sp+srefr*initt, srefr);\n      col += col1;\n    }\n    \n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 ro = 0.8*vec3(0.0, 4.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  float a = 0.5*(-0.5+0.5*sin(0.123*TIME));\n  float b = 0.1*TIME;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    // Get angle from mouse position\n    a =-2.0*m.y;\n    b =-2.0*m.x;\n  }\n  ro.yz *= ROT(a);\n  ro.xz *= ROT(b);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float fov = tan(TAU/6.0);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render0(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3yRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1944, 1944, 1966, 1966, 2112], [2408, 2508, 2527, 2527, 2614], [2616, 2723, 2749, 2749, 2933], [2935, 2995, 3023, 3089, 3165], [3167, 3198, 3234, 3234, 3328], [3330, 3330, 3361, 3361, 3387], [3389, 3507, 3534, 3534, 3610], [3612, 3712, 3751, 3751, 3844], [3846, 3958, 4000, 4000, 4047], [4049, 4132, 4164, 4164, 4312], [4314, 4314, 4342, 4342, 4507], [4509, 4509, 4538, 4538, 4582], [4584, 4584, 4604, 4604, 4626], [4628, 4628, 4655, 4655, 4877], [4879, 4879, 4921, 4921, 4997], [4999, 4999, 5040, 5040, 5115], [5118, 5118, 5139, 5169, 5653], [5655, 5655, 5688, 5688, 6857], [6859, 6859, 6899, 6899, 6940], [6942, 6942, 6963, 6963, 7015], [7017, 7017, 7036, 7036, 7089], [7091, 7091, 7110, 7110, 7244], [7246, 7246, 7270, 7270, 7484], [7486, 7486, 7521, 7521, 7768], [7770, 7770, 7794, 7794, 8008], [8010, 8010, 8045, 8045, 8292], [8294, 8294, 8326, 8326, 9288], [9290, 9290, 9322, 9322, 9961], [9963, 9963, 9984, 9984, 10598], [10600, 10600, 10655, 10655, 10911]], "test": "untested"}
{"id": "NlcyzM", "name": "slant ramp", "author": "assfafa", "description": "slant ramp", "tags": ["slantramp"], "likes": 0, "viewed": 170, "published": 3, "date": "1659422686", "time_retrieved": "2024-07-30T16:37:17.197118", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 col = abs(vec3(uv.y-uv.x));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 291]], "test": "untested"}
{"id": "ftccRM", "name": "Sunset Clouds", "author": "wyatt", "description": "Cumulative image of clouds with 2D lighting", "tags": ["noise", "sunset", "fbm"], "likes": 20, "viewed": 401, "published": 3, "date": "1659411640", "time_retrieved": "2024-07-30T16:37:17.946115", "image_code": "Main {\n    Q = .9*A(U);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)", "buffer_a_code": "float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat noise ( vec3 h ) {\n    vec3 f = floor(h);\n    vec3 c = ceil(h);\n    vec3 r = fract(h);\n    float _000 = hash(f),\n          _001 = hash(vec3(f.xy,c.z)),\n          _010 = hash(vec3(f.x,c.y,f.z)),\n          _011 = hash(vec3(f.x,c.yz)),\n          _100 = hash(vec3(c.x,f.yz)),\n          _101 = hash(vec3(c.x,f.y,c.z)),\n          _110 = hash(vec3(c.xy,f.z)),\n          _111 = hash(c),\n          _00 = mix(_000,_001,r.z),\n          _01 = mix(_010,_011,r.z),\n          _10 = mix(_100,_101,r.z),\n          _11 = mix(_110,_111,r.z),\n          _0 = mix(_00,_01,r.y),\n          _1 = mix(_10,_11,r.y);\n          return mix(_0,_1,r.x);\n}\nfloat fbm (vec3 p)\n{\n    float w = 0.;\n    float N = 10.;\n    for (float i = 1.; i < N; i++)\n    {\n        p.xy *= 2.*ei(2.);\n        p.yz *= ei(1.);\n        w += 4.*noise(p)/N*pow(2.,-i);\n    }\n    return w;\n}\nMain {\n    U = 3.*(U-.5*R)/R.y;\n    U.y += 1.5;\n    U.x += .5;\n    vec3 v = 2.*vec3(U,3.-.2*float(iFrame)/60.);\n    float w = fbm(v)-.02;\n    w *= 1.5*exp(.05*v.z);\n    w *= .8*smoothstep(-5.,1.,5.*exp(-.1*v.x*v.x)-v.y+.1*v.z-2.);\n    w = smoothstep(.12,0.21,w);\n    Q = vec4(w*w);\n    \n}", "buffer_a_inputs": [], "buffer_b_code": "Main {\n    Q = vec4(1);\n    for (float x = 0.; x < 40.; x++){\n        float a = A(U+10.*vec2(x,.3*x)).x;\n        Q -= .1*Q*a;\n    }\n    Q = vec4(1,2,3,4)*.3+.8*Q*sin(.5+Q-(1.1-sqrt(float(iFrame)/60.)*.1)+vec4(1,2,3,4));\n    Q.w = A(U).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = A(U);\n    Q = mix(C(U),Q*Q,Q.w);\n    \n    if (iFrame < 1) {\n        Q = \n        .5+.5*sin(5.+U.y/R.y+vec4(1,2,3,4));\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftccRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7l3cR4", "name": "Rainbow Sand Playground 2", "author": "fenix", "description": "* Click to stop the demo and take control!\n* Double click on the toolbar to select wall presets, change palettes, delete walls and delete everything.\n* Space to restart demo.\n* Shift to disable anti-aliasing.", "tags": ["2d", "simulation", "antialiasing", "particles", "sand"], "likes": 12, "viewed": 410, "published": 3, "date": "1659394644", "time_retrieved": "2024-07-30T16:37:19.273566", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Particles are capable of falling or sliding down a slope greater than 45 degrees. \n//  Particle motion is performed within 2x2 cells. Buffer A's cells are in a natural\n//  alignment: cell 0, 0 includes the four cells (0 ... 1, 0 ... 1). Buffer B is offset\n//  by 1, 1 so it can advect particles across buffer A's cell boundaries. Buffers C and D\n//  are just copies of A and B respectively to get twice the integration speed.\n//\n//  v2: added auto-scroll based on deleting bottom row, removed horizontal black lines,\n//      mouse function determined by clicked region\n//  v3: better auto-scroll, new auto-spawner animation\n//\n//  \"playground\" v1: all the things\n//   * doubled pixels to increase activity at higher resolutions\n//   * added content-aware antialiasing to combat resultant blockiness\n//   * added walls\n//   * tool bar allowing selection of particlar colors, wall, and erase functions\n//   * selectable color palettes\n//   * noise added to particle color\n//   * double click detection\n//   * wall presets\n//   * \"sky\" instead of black void\n//\n//   \"playground\" v2: added attract mode, more palettes\n//\n// ---------------------------------------------------------------------------------------\n\n#define DISABLE_ANTIALIASING 0\n\nvec4 getPixel(ivec2 ifc)\n{\n    // to eliminate gaps as particles fall, combine neighboring pixels vertically for rendering\n    vec4 top = texelFetch(iChannel0, ivec2(ifc.x / 4, (ifc.y / 2) & ~1), 0);\n    vec4 bottom = texelFetch(iChannel0, ivec2(ifc.x / 4, (ifc.y / 2) | 1), 0);\n    return top == EMPTY ? bottom : top;\n}\n\n// are these colors different enough to apply anti-aliasing? (so that we blur only edges, not sand particles)\nfloat distantColor(vec4 a, vec4 b)\n{\n    // w component is sand type id\n    return floor(a.w) != floor(b.w) ? 1.0 : 0.0;\n}\n\nvec4 addSky(vec4 x, vec2 uv)\n{\n    if (x != EMPTY) return x;\n    \n    return mix(vec4(0.8, 0.8, 0.8, 1.0), vec4(0.0, 0.0, uv.y * 0.8, 1.0), sqrt(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x = fragCoord.x * (iResolution.x / (iResolution.x + 8.0)) + 4.0;\n    ivec2 ifc = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 origPixel = getPixel(ifc);\n    vec4 pixel = origPixel;\n    \n#if !DISABLE_ANTIALIASING\n    vec4 above = getPixel(ifc + ivec2(0, 2));\n    vec4 below = getPixel(ifc + ivec2(0, -2));\n    vec4 left = getPixel(ifc + ivec2(-4, 0));\n    vec4 right = getPixel(ifc + ivec2(4, 0));\n\n    float ulDist = distantColor(above, left);\n    float urDist = distantColor(above, right);\n    float llDist = distantColor(below, left);\n    float lrDist = distantColor(below, right);\n    float distAbove = distantColor(above, pixel);\n    float distBelow = distantColor(below, pixel);\n    float distLeft = distantColor(left, pixel);\n    float distRight = distantColor(right, pixel);\n#endif\n    \n    const float DIST_THRESHOLD = 0.1;\n    \n#if !DISABLE_ANTIALIASING\n    fragColor = addSky(pixel, uv);\n    vec2 subCell = mod(fragCoord, vec2(4.0, 4.0));\n    if (ulDist + lrDist < urDist + llDist && ulDist + lrDist < 0.5)\n    {\n        // we can create a smooth diagonal line from ll to ur\n        if (distAbove > distBelow && distAbove > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (4.0 + subCell.x - subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(above, left, 0.5), uv), addSky(pixel, uv), aa);\n        }\n        else if (distBelow > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (4.0 - subCell.x + subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(below, right, 0.5), uv), addSky(pixel, uv), aa);\n        }\n    }\n    else if (urDist + llDist < 0.5)\n    {\n        // we can create a smooth diagonal line from ul to lr\n        if (distAbove > distBelow && distAbove > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (8.0 - subCell.x - subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(above, right, 0.5), uv), addSky(pixel, uv), aa);\n        }\n        else if (distBelow > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (subCell.x + subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(below, left, 0.5), uv), addSky(pixel, uv), aa);\n        }\n    }\n    else\n#endif\n    {\n        fragColor = addSky(pixel, uv);\n    }\n    \n    // (debug) disable antialiasing\n    bool disableAa = texelFetch(iChannel3,ivec2(KEY_SHIFT,0),0).x > 0.0;\n    if (disableAa) fragColor = addSky(pixel, uv);\n    \n    // draw UI\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    bool idle = state.w == FLT_MAX;\n\n    float selection = state.z;\n    int pallette = int(state.y);\n    if (!idle && fragCoord.y > iResolution.y * 0.9)\n    {\n        float u = fragCoord.x / iResolution.x;\n        u *= SELECT_CHOICES;\n        \n        // anti-aliasing for UI (also creates curve for selection)\n        float alpha = clamp(fragCoord.y - (iResolution.y * (0.95 - smoothstep(0.0, 0.2, abs(u - round(u))) * 0.025)), 0.0, 1.0);\n        if (disableAa) alpha = floor(alpha);\n        \n        if (fragCoord.y > iResolution.y * 0.95 ||\n            (floor(u) == selection && alpha > 0.0))\n        {\n            vec4 uiColor;\n            if (u < S_RAINBOW)\n            {\n                // specific colors\n                uiColor = rainbow(int(u), pallette);\n            }\n            else if (u < S_WALL)\n            {\n                // color cycle (rainbow)\n                uiColor = colorByFrame(int(fragCoord.x / (iResolution.x * 0.02) * float(COLOR_CHANGE_FRAMES)), pallette);\n            }\n            else if (u < S_ERASE)\n            {\n                // walls\n                uiColor = vec4(1);\n            }\n            else\n            {\n                // eraser\n                uiColor = vec4(0);\n            }\n            fragColor = mix(fragColor, uiColor, alpha);\n        }\n    }    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(0));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// options\nconst float WALL_SIZE = 0.0025;\nconst float SPAWN_SIZE = 0.005;\nconst int COLOR_CHANGE_FRAMES = 100;\n\n// tool bar selections\n// 0 ... 6 are the specific color selections\n#define S_RAINBOW 7.0\n#define S_WALL 8.0\n#define S_ERASE 9.0\n#define SELECT_CHOICES 10.0\n\n// special pixel values\nconst vec4 EMPTY = vec4(0);\nconst vec4 WALL = vec4(1);\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nconst int NUM_PALETTES = 6;\n\nvec4 rainbow(int i, int palette)\n{\n    switch(palette)\n    {\n        case 0: // actual rainbow\n            switch(i)\n            {\n                case 0: return vec4(1.0, 0.0, 0.0, 2.0);\n                case 1: return vec4(1.0, 0.5, 0.0, 3.0);\n                case 2: return vec4(1.0, 1.0, 0.0, 4.0);\n                case 3: return vec4(0.0, 1.0, 0.0, 5.0);\n                case 4: return vec4(0.0, 0.0, 1.0, 6.0);\n                case 5: return vec4(0.25, 0.0, 0.5, 7.0);\n                case 6: return vec4(0.5, 0.0, 0.7, 8.0);\n            }\n        case 1: // grey scale w/ red\n            switch(i)\n            {\n                case 0: return vec4(0.1, 0.1, 0.1, 9.0);\n                case 1: return vec4(0.25, 0.25, 0.25, 10.0);\n                case 2: return vec4(0.4, 0.4, 0.4, 11.0);\n                case 3: return vec4(0.55, 0.55, 0.55, 12.0);\n                case 4: return vec4(0.75, 0.75, 0.75, 13.0);\n                case 5: return vec4(0.99, 0.99, 0.99, 14.0);\n                case 6: return vec4(1.0, 0.0, 0.0, 15.0);\n            }\n        case 2: // pastel rainbow\n            switch(i)\n            {\n                case 0: return vec4(255.0 / 256.0, 102.0 / 256.0, 99.0 / 256.0, 16.0);\n                case 1: return vec4(254.0 / 256.0, 177.0 / 256.0, 68.0 / 256.0, 17.0);\n                case 2: return vec4(253.0 / 256.0, 253.0 / 256.0, 151.0 / 256.0, 18.0);\n                case 3: return vec4(158.0 / 256.0, 224.0 / 256.0, 158.0 / 256.0, 19.0);\n                case 4: return vec4(158.0 / 256.0, 193.0 / 256.0, 207.0 / 256.0, 20.0);\n                case 5: return vec4(174.0 / 256.0, 153.0 / 256.0, 231.0 / 256.0, 21.0);\n                case 6: return vec4(204.0 / 256.0, 153.0 / 256.0, 201.0 / 256.0, 22.0);\n            }\n        case 3: // natural colors (draw a mountain scene!)\n            switch(i)\n            {\n                case 0: return vec4(222.0 / 256.0, 204.0 / 256.0, 166.0 / 256.0, 23.0);\n                case 1: return vec4(164.0 / 256.0, 167.0 / 256.0, 38.0 / 256.0, 24.0);\n                case 2: return vec4(25.0 / 256.0, 121.0 / 256.0, 39.0 / 256.0, 25.0);\n                case 3: return vec4(100.0 / 256.0, 100.0 / 256.0, 110.0 / 256.0, 26.0);\n                case 4: return vec4(112.0 / 256.0, 100.0 / 256.0, 84.0 / 256.0, 27.0);\n                case 5: return vec4(148.0 / 256.0, 91.0 / 256.0, 20.0 / 256.0, 28.0);\n                case 6: return vec4(56.0 / 256.0, 29.0 / 256.0, 10.0 / 256.0, 29.0);\n            }\n        case 4: // tiger stripes\n            switch(i)\n            {\n                case 0: return vec4(1.0, 0.5, 0.1, 30.0);\n                case 1: return vec4(0.1, 0.1, 0.1, 31.0);\n                case 2: return vec4(1.0, 0.5, 0.1, 30.0);\n                case 3: return vec4(0.1, 0.1, 0.1, 31.0);\n                case 4: return vec4(1.0, 0.5, 0.1, 30.0);\n                case 5: return vec4(0.1, 0.1, 0.1, 31.0);\n                case 6: return vec4(1.0, 0.5, 0.1, 30.0);\n            }\n        case 5: // boys n girls\n            switch(i)\n            {\n                case 0: return vec4(0.4, 0.4, 0.4, 32.0);\n                case 1: return vec4(0.70, 0.202, 0.706, 33.0);\n                case 2: return vec4(1.0, 0.412, 0.706, 34.0);\n                case 3: return vec4(0.55, 0.55, 0.55, 35.0);\n                case 4: return vec4(0.75, 0.75, 0.75, 36.0);\n                case 5: return vec4(0.3, 0.4, 1.0, 37.0);\n                case 6: return vec4(0.2, 0.5, 1.0, 38.0);\n            }\n    }    \n}\n\nvec4 colorByFrame(int frame, int palette)\n{   \n    // compute the current color for the color-cycling rainbow spawn selection\n    int colorIndex = (frame / COLOR_CHANGE_FRAMES) % 7;\n    int nextColorIndex = (colorIndex + 1) % 7;\n    int blendIndex = frame % COLOR_CHANGE_FRAMES;\n    float blend = float(blendIndex) / float(COLOR_CHANGE_FRAMES);\n    return mix(rainbow(colorIndex, palette), rainbow(nextColorIndex, palette), blend);\n}\n\nfloat hash( int k )\n{\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 res)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        // line was very short anyway\n        closest = oldPos;\n    }\n\n    // distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= res.xy / res.y;\n    return length2(closestDelta);\n}\n\nfloat dist2hopper(vec2 fragCoord, vec3 res, vec2 pos, vec2 dim, float opening)\n{\n    float dist2 =      linePointDist2(vec2(pos.x - dim.x, pos.y) * res.xy, vec2(pos.x - dim.x, pos.y + dim.y) * res.xy, fragCoord, res);\n    dist2 = min(dist2, linePointDist2(vec2(pos.x + dim.x, pos.y) * res.xy, vec2(pos.x + dim.x, pos.y + dim.y) * res.xy, fragCoord, res));\n    dist2 = min(dist2, linePointDist2(vec2(pos.x + dim.x, pos.y) * res.xy, vec2(pos.x + opening, pos.y) * res.xy, fragCoord, res));\n    dist2 = min(dist2, linePointDist2(vec2(pos.x - dim.x, pos.y) * res.xy, vec2(pos.x - opening, pos.y) * res.xy, fragCoord, res));\n    return dist2;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id( x,y)   floor(x)+100.*floor(y)\n\n// from maze 2 by FabriceNeyret2\n// https://www.shadertoy.com/view/4sSXWR\nfloat maze(vec2 u) {\n    float n = id(u.x,u.y);  u = fract(u);\n    return 1.-smoothstep(.1,.15,((rnd(n)>.5)?u.x:u.y));\n}\n\n// from Exercise: basic truchet tiling by endymion\n// https://www.shadertoy.com/view/WlcfWf\nfloat truchet(in vec3 res, in int frame, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * res.xy) / res.y;\n    \n    // Zoom;\n    float scale = 10.0;\n    uv *= scale; \n    \n    // Tiles from -.5 to .5\n    vec2 gv = fract(uv) - .5;\n    \n    // Rotate\n    vec2 id = floor(uv);\n    float r = hash(int(id.x + 37.5 * id.y + 9.0 * float(frame)));\n    if (r < .5) gv.x *= -1.;\n    \n    // Curves\n    float sgn = sign(gv.x + gv.y);\n    sgn = sgn == 0. ? 1. : sgn;\n    float dist = abs(abs(gv.x + gv.y) - .5);\n    dist = length(gv - sgn * .5) - .5;\n    float width = 0.002 * scale;\n    return smoothstep(scale/res.y, -scale/res.y, abs(dist) - width);\n}\n\nvoid handleDoubleClick(float selection, vec2 fc, vec3 res, int iFrame, inout vec4 fragColor)\n{\n    bool shouldBeWall = false;\n    float dist2 = 1e6;\n    float dist = 1e6;\n    \n    // wall scenes you can select by double clicking on the specific color tabs\n    switch(int(selection))\n    {\n        case 0:\n            // big V\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            dist2 = linePointDist2(vec2(0.13, 0.1) * res.xy, vec2(0.215, 0.4) * res.xy, fc, res);\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 1:\n            // cascading hoppers\n            fc.x = res.x * 0.125 - abs(fc.x - res.x * 0.125);\n            dist2 =            dist2hopper(fc, res, vec2(0.035, 0.35), vec2(0.025, 0.05), 0.003);\n            dist2 = min(dist2, dist2hopper(fc, res, vec2(0.055, 0.25), vec2(0.025, 0.05), 0.003));\n            dist2 = min(dist2, dist2hopper(fc, res, vec2(0.075, 0.15), vec2(0.025, 0.05), 0.003));\n            dist2 = min(dist2, dist2hopper(fc, res, vec2(0.125, 0.05), vec2(0.06, 0.05), 0.003));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 2:\n            // horizontal lines\n            const float HEIGHT = 0.1;\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            fc.y = mod(fc.y + res.x * 0.01, res.x * HEIGHT * 1.25);\n            dist2 = linePointDist2(vec2(0.1, HEIGHT) * res.xy, vec2(0.15, HEIGHT) * res.xy, fc, res);\n            dist2 = min(dist2, linePointDist2(vec2(0.175, HEIGHT) * res.xy, vec2(0.225, HEIGHT) * res.xy, fc, res));\n            dist2 = min(dist2, linePointDist2(vec2(0.2, HEIGHT + HEIGHT) * res.xy, vec2(0.1375, HEIGHT + HEIGHT) * res.xy, fc, res));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n\n        case 3:\n            // maze       \n            fc.x += mod(float(iFrame % 1000) * 10.0, res.x * 10.0);\n            const float MAZE_SCALE = 1.6;\n            dist = maze(MAZE_SCALE * vec2(square(res.x / res.y), 1.0)*fc/(res.xy * 0.125));\n            shouldBeWall = dist > 0.060 * res.x * WALL_SIZE;\n\n            break;\n                        \n        case 4:\n            // bowls\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            fc.y = res.y * 0.125 - fc.y;\n            const float theta = 2.0;\n            const vec2 sc = vec2(sin(theta), cos(theta));\n            dist = sdArc((fc / res.x) - vec2(0.2, 0.0), sc, 0.02, 0.0);\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.15, -0.14), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.175, -0.07), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.2, -0.14), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fc / res.x) - vec2(0.15, 0.0), sc, 0.02, 0.0));\n            shouldBeWall = dist < WALL_SIZE;\n\n            break;\n\n        case 5:\n            // slopes\n            fc.x = abs(fc.x - res.x * 0.125) + res.x * 0.125;\n            fc.y = mod(fc.y + res.x * 0.01, res.x * HEIGHT * 1.25);\n            dist2 = linePointDist2(vec2(0.125, HEIGHT * 1.2) * res.xy, vec2(0.15, HEIGHT) * res.xy, fc, res);\n            dist2 = min(dist2, linePointDist2(vec2(0.175, HEIGHT) * res.xy, vec2(0.225, HEIGHT * 1.2) * res.xy, fc, res));\n            dist2 = min(dist2, linePointDist2(vec2(0.2, HEIGHT * 2.2) * res.xy, vec2(0.1375, HEIGHT * 2.0) * res.xy, fc, res));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 6:\n            // truchet\n            fc.x *= res.x / res.y;\n            dist = truchet(res, iFrame, fc);\n            shouldBeWall = dist > 0.060 * res.x * WALL_SIZE;\n\n            break;\n    }\n\n    if (shouldBeWall)\n        fragColor = WALL;\n    else if (fragColor == WALL)\n        fragColor = EMPTY;\n}\n\nvoid spawnSand(int frame, vec2 fragCoord, vec3 res, vec2 oldMouse, vec4 newMouse, float selection, int palette, inout vec4 fragColor)\n{\n    if (newMouse.z > 0.0 && newMouse.y < res.y * 0.9)\n    {\n        vec4 sandColor;\n        if (selection < S_RAINBOW)\n        {\n            // specific color selection\n            sandColor = rainbow(int(selection), palette);\n        }\n        else if (selection < S_WALL)\n        {\n            // rainbow selection\n            sandColor = colorByFrame(frame, palette);\n        }\n        else\n        {\n            sandColor = WALL;\n        }\n\n\n        // compute the distance to the line segment from oldMouse to newMouse\n        // using a capsule instead of a sphere prevents gaps when the mouse is moved quickly\n        vec2 spawnBegin = oldMouse / vec2(4.0, 2.0);\n        vec2 spawnEnd = newMouse.xy / vec2(4.0, 2.0);\n        if (newMouse.w > 0.0) spawnBegin = spawnEnd;\n        float dist2 = linePointDist2(spawnBegin, spawnEnd, fragCoord, res);\n        \n        if (sandColor == WALL)\n        {\n            if (dist2 < square(res.x * WALL_SIZE))\n            {\n                // wall selection (white)\n                fragColor = WALL;\n            }\n        }\n        else if (fragColor == EMPTY && dist2 < square(res.x * SPAWN_SIZE))\n        {\n            float noise = (0.55 + 0.45 * hash(frame * int(fragCoord.x) * int(fragCoord.y)));\n            fragColor = vec4(noise, noise, noise, 1.0) * sandColor;\n        }\n    }\n}\n\nvoid removeSand(int frame, vec2 fragCoord, vec3 res, vec2 oldMouse, vec4 newMouse, inout vec4 fragColor)\n{\n    if (newMouse.z > 0.0)\n    {\n        vec2 removeBegin = oldMouse / vec2(4.0, 2.0);\n        vec2 removeEnd = newMouse.xy / vec2(4.0, 2.0);\n        if (newMouse.w > 0.0) removeBegin = removeEnd;\n        float dist2 = linePointDist2(removeBegin, removeEnd, fragCoord, res);\n \n        if (dist2 < square(res.x * 0.01))\n        {\n            // erase selection (black)\n            fragColor = EMPTY;\n        }\n    }\n}\n\nvoid evolveByCells(sampler2D sampler, int frame, ivec2 coord, ivec2 offset, ivec2 ires, out vec4 fragColor)\n{\n    // compute coordinates for the four pixels in our cell\n    ivec2 cellCoord = (coord - offset) / 2;\n    ivec2 llCell = cellCoord * 2 + offset;\n    ivec2 lrCell = llCell + ivec2(1, 0);\n    ivec2 ulCell = llCell + ivec2(0, 1);\n    ivec2 urCell = llCell + ivec2(1, 1);\n   \n    if (!all(lessThan(urCell, ivec2(ires.x / 4, ires.y / 2))) ||\n        (offset != ivec2(0) && any(equal(coord, ivec2(0)))))\n    {\n        // don't move particles at the bottom of the screen or off the edge\n        fragColor = texelFetch(sampler, coord, 0);\n        return;\n    }\n    \n    // fetch the members of our cell\n    vec4 ulValue = texelFetch(sampler, ulCell, 0);\n    vec4 urValue = texelFetch(sampler, urCell, 0);\n    vec4 llValue = texelFetch(sampler, llCell, 0);\n    vec4 lrValue = texelFetch(sampler, lrCell, 0);\n    \n    // figure out which are empty\n    bvec4 cell = bvec4(ulValue != EMPTY, urValue != EMPTY, llValue != EMPTY, lrValue != EMPTY);\n    \n    // try to match a pattern that should fall\n    if ((cell == bvec4(true,  false,\n                      false, false) ||\n        cell == bvec4(true,  false,\n                      false, true)||\n        cell == bvec4(true,  true,\n                      false, true)) && ulValue != WALL)\n    {\n        // left side falls\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if ((cell == bvec4(false, true,\n                           false, false) ||\n             cell == bvec4(false, true,\n                           true, false) ||\n             cell == bvec4(true, true,\n                           true, false)) && urValue != WALL)\n    {\n        // right side falls\n        lrValue = urValue;\n        urValue = EMPTY;\n    }\n    else if (cell == bvec4(true, true,\n                           false, false))\n    {\n        // both sides fall\n        if (urValue != WALL)\n        {\n            lrValue = urValue;\n            urValue = EMPTY;\n        }\n        if (ulValue != WALL)\n        {\n            llValue = ulValue;\n            ulValue = EMPTY;\n        }\n    }\n    else if ((cell == bvec4(true, false,\n                           true, false)) && ulValue != WALL)\n    {\n        // left side collapses\n        lrValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if ((cell == bvec4(false, true,\n                           false, true)) && urValue != WALL)\n    {\n        // right side collapses\n        llValue = urValue;\n        urValue = EMPTY;\n    }\n\n    // record result\n    if (coord == llCell)\n    {\n        fragColor = llValue;\n    }\n    else if (coord == lrCell)\n    {\n        fragColor = lrValue;\n    }\n    else if (coord == ulCell)\n    {\n        fragColor = ulValue;\n    }\n    else if (coord == urCell)\n    {\n        fragColor = urValue;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(keySampler,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(keySampler,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define FLT_MAX 3.402823466e+38\n\nvec4 updateState(sampler2D sandSampler, sampler2D keySampler, int iFrame, vec4 iMouse, vec3 iResolution)\n{\n    const float DOUBLE_CLICK_FRAMES = 40.0;\n    vec4 oldState = texelFetch(sandSampler, ivec2(0), 0);\n    if (iFrame < 10 || keyDown(KEY_SPACE)) return vec4(0.0, 0.0, S_RAINBOW, FLT_MAX); // init state\n    int palette = int(oldState.y);\n    float selection = oldState.z;\n    float clickState = oldState.w;\n    if (iMouse.z > 0.0 && iMouse.y > iResolution.y * 0.9)\n    {\n        float u = iMouse.x / iResolution.x;\n        float newSelection = floor(u * SELECT_CHOICES);\n\n        if (iMouse.w > 0.0)\n        {\n            if (clickState < 0.0 && clickState > -DOUBLE_CLICK_FRAMES && newSelection == selection)\n            {\n                // double click detected\n                clickState = 0.0;\n                \n                if (newSelection == S_RAINBOW)\n                {\n                    // change palette\n                    palette = (palette + 1) % NUM_PALETTES;\n                }\n            }\n            else\n            {\n                clickState = 1.0;\n            }\n        }\n        else\n        {\n            // count frames held down\n            ++clickState;\n        }\n\n        selection = newSelection;\n    }\n    else\n    {\n        if (clickState < 0.0)\n        {\n            // count frames released...\n            --clickState;\n        }\n        else if (clickState > 1.0 && clickState < 1.0 + DOUBLE_CLICK_FRAMES)\n        {\n            // ...but only if it was held down only a short time.\n            clickState = -1.0;\n        }\n        else if (iMouse.z > 0.0)\n        {\n            clickState = 1.0;\n        }\n    }\n    \n    return vec4(iMouse.x * iResolution.y + iMouse.y, float(palette), selection, clickState);\n}\n\nconst int FRAMES_PER_MODE = 1300;\nconst int IDLE_FRAMES = 300;\nconst int NUM_ATTRACT_MODES = 5;\n\nvec2 sinuous(int frame, vec2 radius, vec2 speed, vec2 center)\n{\n    return vec2(cos(float(frame) * speed.x) * radius.x + center.x, sin(float(frame) * speed.y) * radius.y + center.y);\n}\n\nvoid updateAttract(inout vec2 oldMouse, inout vec4 newMouse, inout float selection, inout int palette, inout bool doubleClick, int frame, vec3 res)\n{\n    int fmod = frame % FRAMES_PER_MODE;\n    if ((frame % FRAMES_PER_MODE) > FRAMES_PER_MODE - IDLE_FRAMES) return;\n    int attractIndex = frame / FRAMES_PER_MODE;\n    int attractMode = attractIndex % NUM_ATTRACT_MODES;\n\n    switch (attractMode)\n    {\n        case 0:\n        \n            float radius = float(fmod) * (0.4 / float(FRAMES_PER_MODE - IDLE_FRAMES));\n            newMouse = vec4(sinuous(frame, radius * res.xy, vec2(0.1), res.xy * 0.5), 1.0, 0.0);\n            oldMouse = sinuous(frame - 1, radius * res.xy, vec2(0.1), res.xy * 0.5);\n            \n            break;\n            \n        case 1:\n\n            radius = 0.4 * sqrt(float(fmod) * (1.0 / float(FRAMES_PER_MODE - IDLE_FRAMES)));\n            newMouse = vec4(sinuous(-frame, radius * res.xy, vec2(0.1, 0.2), res.xy * 0.5), 1.0, 0.0);\n            oldMouse = sinuous(1 - frame, radius * res.xy, vec2(0.1, 0.2), res.xy * 0.5);\n            \n            break;\n\n        case 2:\n            \n            float mouseY = res.y * 0.9 - res.y * 0.9 * float(fmod) / float (FRAMES_PER_MODE - IDLE_FRAMES);\n            float oldMouseY = res.y * 0.9 - res.y * 0.9 * float((frame - 1) % (FRAMES_PER_MODE)) / float (FRAMES_PER_MODE - IDLE_FRAMES);\n            newMouse = vec4(sinuous(-frame, vec2(0.8 * res.y, 0.0), vec2(0.1, 0.2), vec2(res.x * 0.5, res.y * 0.8)).x, mouseY, 1.0, 0.0);\n            oldMouse = vec2(sinuous(1-frame, vec2(0.8 * res.y, 0.0), vec2(0.1, 0.2), vec2(res.x * 0.5, res.y * 0.8)).x, oldMouseY);\n            \n            break;\n\n        case 3:\n\n            newMouse = vec4(sinuous(frame, 0.3 * res.xy, vec2(0.02), res.xy * 0.5) +\n                            sinuous(-frame, 0.07 * res.xy, vec2(0.1), vec2(0)), 1.0, 0.0);\n            oldMouse = sinuous(frame - 1, 0.3 * res.xy, vec2(0.02), res.xy * 0.5) +\n                            sinuous(-(frame - 1), 0.07 * res.xy, vec2(0.1), vec2(0));\n            \n            break;\n\n        case 4:\n\n            newMouse = vec4(sinuous(frame, 0.1 * res.xy, vec2(0.03), res.xy * 0.5) +\n                            sinuous(frame, 0.3 * res.xy, vec2(0.05), vec2(0)), 1.0, 0.0);\n            oldMouse = sinuous(frame - 1, 0.1 * res.xy, vec2(0.03), res.xy * 0.5) +\n                            sinuous(frame - 1, 0.3 * res.xy, vec2(0.05), vec2(0));\n            \n            break;\n\n    }            \n\n    if (fmod == 0)\n    {\n        // new attract, clear the board on frame zero..\n        selection = S_ERASE;\n        doubleClick = true;\n        newMouse.z = -1.0;\n    }\n    else if (fmod == 1)\n    {\n        // choose the wall type on frame one...\n        selection = float(attractIndex % int(S_RAINBOW));\n        doubleClick = true;\n        newMouse.z = -1.0;\n    }\n    else\n    {\n        // then select the palette and let it run\n        palette = attractIndex % NUM_PALETTES;\n    }\n}\n\nvoid bufferMainInternal( out vec4 fragColor, in vec2 fragCoord, in ivec2 offset, in sampler2D sandSampler, in sampler2D keySampler, int iFrame, vec3 iResolution, vec4 iMouse)\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    // handle persistent state\n    if (ifc == ivec2(0, 0))\n    {\n        fragColor = updateState(sandSampler, keySampler, iFrame, iMouse, iResolution);\n        return;\n    }\n    \n    vec4 state = texelFetch(sandSampler, ivec2(0), 0);\n    int palette = int(state.y);\n    float selection = state.z;\n    float clickState = state.w;\n    bool doubleClick = clickState == 0.0;\n    bool idle = clickState == FLT_MAX;\n\n    // only use an eighth of the screen for simulation\n    if (fragCoord.x > iResolution.x * 0.25 || fragCoord.y > iResolution.y * 0.5)\n    {\n        return;\n    }\n    \n    // integration step\n    evolveByCells(sandSampler, iFrame, ifc, offset, ivec2(iResolution.xy), fragColor);\n    \n    // user interaction\n    float oldEncodedMouse = state.x;\n    vec2 oldMouse = vec2(oldEncodedMouse / iResolution.y, mod(oldEncodedMouse, iResolution.y));\n    \n    if (idle) updateAttract(oldMouse, iMouse, selection, palette, doubleClick, iFrame, iResolution);\n\n    if (selection == S_ERASE)\n        removeSand(iFrame, fragCoord, iResolution, oldMouse, iMouse, fragColor);\n    else\n        spawnSand(iFrame, fragCoord, iResolution, oldMouse, iMouse, selection, palette, fragColor);\n    \n    // perform double click action if requested\n    if (doubleClick && selection != S_RAINBOW) handleDoubleClick(selection, fragCoord, iResolution, iFrame, fragColor);\n    \n    // init scene\n    if (iFrame == 0 || (doubleClick && selection == S_ERASE)) fragColor = EMPTY;\n}\n\n#define bufferMain(X, Y, Z) bufferMainInternal(X, Y, Z, iChannel0, iChannel3, iFrame, iResolution, iMouse)", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(1));\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(0));\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(1));\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3cR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1454, 1454, 1480, 1576, 1774], [1776, 1886, 1922, 1957, 2008], [2010, 2010, 2040, 2040, 2164]], "test": "untested"}
{"id": "sltyz4", "name": "Fork Color pall jpupper 198", "author": "jpupper", "description": "Color pallete example ", "tags": ["pallete"], "likes": 0, "viewed": 165, "published": 3, "date": "1659387223", "time_retrieved": "2024-07-30T16:37:21.182462", "image_code": "vec3 palette[7];\nvec3 getsmcolor(float c, float s) \n{\n    s*=.5;\n    c=mod(c-.5,7.);\n    vec3 color1=vec3(0.0),color2=vec3(0.0);\n    for(int i=0;i<7;i++) {\n        if (float(i)-c<=.0) {\n            color1 = palette[i];\n            color2 = palette[(i+1>6)?0:i+1];\n        }\n    }\n    // smooth mix the two colors\n    return mix(color1,color2,smoothstep(.5-s,.5+s,fract(c)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float fx = iResolution.x/iResolution.y;\n    \n    uv.x*=fx;\n    vec2 p = vec2(0.5*fx,.5) - uv;\n    float r = length(p);\n    float a = atan(p.x,p.y);\n\tpalette[6]=vec3(200,000,000)/255.;\n\tpalette[5]=vec3(255,127,000)/255.;\n\tpalette[4]=vec3(255,200,100)/255.;\n\tpalette[3]=vec3(50,200,100)/255.;\n\tpalette[2]=vec3(000,000,255)/255.;\n\tpalette[1]=vec3(075,000,130)/255.;\n\tpalette[0]=vec3(143,000,255)/255.;\n    \n    vec3 color = vec3(0.);\n    \n    \n    \n    float forma = sin(r*5.+sin(a*10.+sin(r*10.))*.2)*sin(r*2.-iTime);\n    \n    forma*=sin(forma*10.+iTime)+sin(a*4.);\n    forma = r;\n    color = getsmcolor(forma-iTime*.5, .99); \n    \n    \n   \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 53, 53, 376], [377, 377, 434, 434, 1152]], "test": "untested"}
{"id": "NldcR4", "name": "alacran -v1", "author": "jorge2017a2", "description": "alacran -v1", "tags": ["alacranv1"], "likes": 9, "viewed": 218, "published": 3, "date": "1659385595", "time_retrieved": "2024-07-30T16:37:22.273545", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n\n///alacran -v1--1-agosto-2022\n///referencia iQ funciones\n//https://iquilezles.org/articles/\n//https://thebookofshaders.com/?lan=es\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smin( float a, float b )\n{   float k = 0.1;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    \n    p.xyz=vec3(p.z, p.x, -p.y);\n    p= rotate_y(p,radians(-45.0) );\n     p.y=p.y+10.0;\n     \n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    float planeDistpiso = -p.z+10.0;  //piso inf\n    \n    res =opU2(res, vec2(planeDistpiso,57.0));\n    p.y=p.y-30.0;\n    vec3 pos=p;\n    \n    \n    //cola alacran\n    float r1,r2,he;\n    r1=3.0;r2=1.5;\n    he=10.0;\n    \n    float t=iTime;\n    p.x+=0.5*sin(p.y*0.125+t); //xy onda\n    \n    float d1a=sdTrapezoid(p.xy,r1,r2,he );\n    float d1b=sdRoundBox(p, vec3(5.0,11.,0.8), 0.5 );\n    float dif1= Intersect(d1a, d1b);\n    \n    ///---picos de cola\n    vec2 c;float h;\n    p.x= opRep1D(p.x+1.5, 3.2 );\n    c=vec2(1.0,10.0);h=7.0;\n    vec3 pnew=vec3(p.x, -p.z-3.0, p.y)-vec3(0.0,5.5,5.0);\n    pnew.z= opRep1D(pnew.z, 3.0 );\n    float d2a= sdCone(pnew,c,h );\n    d2a= Intersect(d1a, d2a);\n    \n    ///cola fin\n    p=p0;\n    float d3a= sdTriPrism(p-vec3(0.0,42.0,-1.0), vec2(3.8,1.0));\n    \n    \n    //panza\n    p.y-=10.0;\n    float d4a= sdEllipsoid(p,vec3(5.5,15.0,2.0) );\n    \n    res =opU2(res, vec2(dif1,2.0));\n    res =opU2(res, vec2(d2a,0.0));\n    res =opU2(res, vec2(d3a,10.0));\n    res =opU2(res, vec2(d4a,8.0));\n    \n    ///anillos panza\n    p.y= opRep1D(p.y, 3.0 );\n    float d5a= sdTorus(p-vec3(0.0,0.0,0.5), vec2(3.5,0.5) );\n    p=p0;\n    p.y-=11.0;\n    float d5b= sdBox(p,vec3(5.0,8.0,8.0) );\n    d5a=Intersect(d5a, d5b);\n    res =opU2(res, vec2(d5a,10.));\n    \n    //patas horizontales\n    vec3 a,b;float r;\n    a=vec3(5.0,0.0,5.0);\n    b=vec3(0.0,4.0,5.0);\n    p.z+=6.0;\n    p.x=abs(p.x)-4.0;\n    r=0.5;\n    float d6a=sdCapsule(p,a,b,r);\n    p.y+=6.0;\n    float d6b=sdCapsule(p,a,b,r);\n    \n    \n    res =opU2(res, vec2(d6a,9.));\n    res =opU2(res, vec2(d6b,9.));\n    \n    \n    //patas verticales\n    p=p0;\n    //z largo pata\n    a=vec3(7.0,8.0,10.0);\n    b=vec3(7.0,8.0,15.0);\n    p.x=abs(p.x);\n    float d7a=sdCapsule(p-vec3(2.0,3.0,-11.0),a,b,r);\n    p.y+=6.0;\n    float d7b=sdCapsule(p-vec3(2.0,3.0,-11.0),a,b,r);\n    res =opU2(res, vec2(d7a,9.));\n    res =opU2(res, vec2(d7b,9.));\n    \n    ///cabeza\n    p.y-=2.0;\n    float d8a= sdEllipsoid(p,vec3(5.5,3.0,3.0) );\n    res =opU2(res, vec2(d8a,1.0));\n    \n    //ojos\n    p.y+=0.85;\n    p.z+=3.0;\n    p.x=abs(p.x)-1.5;\n    float d9a= sdEllipsoid(p,vec3(1.0,0.5,1.0) );\n    res =opU2(res, vec2(d9a,11.0));\n    \n    //cuernos\n    p.xyz=vec3(p0.x, -p0.y, p0.z)-vec3(0.0,15.0,-2.0);\n    p.z+=1.0*sin(p.y+6.0); //xy onda\n    \n    p.x=abs(p.x)-3.0;\n    c=vec2(1.0,12.0);h=10.0;\n    float d10a= sdCone(p,c,h );\n    res =opU2(res, vec2(d10a,10.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n      return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    //return col*vec3(0.5,0.1,0.8);\n    return col+0.25*vec3(0.5,0.1,0.8);\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n         \n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   \n   vec3 ro=vec3(5.0+16.0*sin(t0*0.75),10.0+abs(3.0*sin(t*0.25)),-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(30.0));\n\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 631, 631, 652], [653, 653, 685, 685, 769], [770, 770, 816, 816, 903], [904, 904, 938, 938, 1000], [1003, 1003, 1047, 1047, 1074], [1075, 1075, 1115, 1115, 1142], [1143, 1143, 1188, 1188, 1216], [1218, 1218, 1254, 1254, 1299], [1302, 1302, 1336, 1336, 1432], [1433, 1433, 1467, 1467, 1558], [1559, 1559, 1593, 1593, 1684], [1687, 1687, 1712, 1712, 1731], [1732, 1732, 1757, 1757, 1776], [1777, 1777, 1813, 1813, 1841], [1844, 1844, 1909, 1909, 2219], [2221, 2221, 2268, 2402, 2737], [2739, 2739, 2776, 2776, 2859], [2861, 2861, 2897, 2897, 2980], [2983, 2983, 3035, 3035, 3156], [3158, 3158, 3190, 3190, 3296], [3298, 3298, 3323, 3323, 5937], [5939, 5939, 5963, 5963, 6125], [6127, 6127, 6175, 6175, 6454], [6457, 6457, 6501, 6501, 6822], [6824, 6824, 6861, 6861, 7118], [7120, 7120, 7210, 7210, 8169], [8172, 8172, 8204, 8204, 8401], [8403, 8451, 8479, 8479, 8726], [8729, 8729, 8799, 8799, 9046], [9048, 9048, 9075, 9075, 9164], [9166, 9166, 9224, 9224, 9272], [9274, 9274, 9297, 9297, 9409], [9412, 9412, 9443, 9443, 10063], [10066, 10066, 10123, 10123, 10711]], "test": "untested"}
{"id": "sltcR4", "name": "Back-and-Forth", "author": "nsbalbi", "description": "Created while following along with Book of Shaders", "tags": ["loop", "tiling"], "likes": 4, "viewed": 194, "published": 3, "date": "1659383892", "time_retrieved": "2024-07-30T16:37:23.049471", "image_code": "\n// Adapted from Book of Shaders (@patriciogv ( patriciogonzalezvivo.com ) - 2015)\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592653589793\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nvec2 brickTile(vec2 _st, float _zoom, float _time){\n    _st *= _zoom;\n\n    float t = sineInOut(fract(_time));\n    \n    _st.x += step(1., mod(_time,2.0)) * step(1., mod(_st.y,2.0)) * fract(t);\n    _st.x -= step(1., mod(_time,2.0)) * step(1., mod(_st.y + 1.0,2.0)) * fract(t);\n\n    _st.y += step(1., mod(_time + 1.0,2.0)) * step(1., mod(_st.x,2.0)) * fract(t);\n    _st.y -= step(1., mod(_time + 1.0,2.0)) * step(1., mod(_st.x + 1.0,2.0)) * fract(t);\n\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec4 scene(vec2 fragCoord, float time) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv = brickTile(uv, 6.0, time);\n\n    color = vec3(box(uv,vec2(0.8)));\n\n    return vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 s1 = scene(gl_FragCoord.xy, iTime);\n    \n    #define BLUR 6\n    #define T_RANGE 0.06\n    for (int i = 1; i < BLUR; i += 1) {\n        s1 += scene(fragCoord.xy, iTime - float(i)*T_RANGE/float(BLUR));\n    }\n    s1 /= float(BLUR);\n\n    fragColor = s1;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 186, 186, 225], [227, 227, 278, 278, 700], [702, 702, 734, 734, 905], [907, 907, 947, 947, 1165], [1167, 1167, 1223, 1223, 1482]], "test": "untested"}
{"id": "Ntdcz4", "name": "3D Corner - distance L-inf", "author": "pyBlob", "description": "Infinite planes with cutout!", "tags": ["3d", "sdf", "corner", "linf"], "likes": 3, "viewed": 250, "published": 3, "date": "1659383487", "time_retrieved": "2024-07-30T16:37:23.800462", "image_code": "float sdCorner(vec3 p, vec3 r)\n{\n    // pyBlob: 3D Corner - distance L-inf https://www.shadertoy.com/view/Ntdcz4\n    vec3 q = p + r;\n    p += r * step(q.xyz, min(q.yzx, q.zxy)); // for 3D\n    // p += step(q.xy, q.yx); // for 2D\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sdScene(vec2 p)\n{\n    float scale = 12.;\n    p *= scale;\n    vec3 q = vec3(p, -4. + 5. * sin(iTime));\n    return sdCorner(q, vec3(8. + cos(iTime*3.), 8. + cos(iTime * 2.), 8.)) / scale;\n}\n\nfloat sdBox(vec2 p, vec2 rad)\n{\n    // iq: Box - distance L-inf https://www.shadertoy.com/view/Nlj3WR\n    p = abs(p)-rad;\n\n    return max(p.x,p.y);\n}\n\nvoid linf(out vec4 fragColor, vec2 fragCoord, vec3 iResolution, vec4 iMouse, float iTime)\n{\n    // iq: Box - distance L-inf https://www.shadertoy.com/view/Nlj3WR\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if( iMouse.z<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    float d = sdScene(p);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    \n    d = sdScene(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    linf(C, O, iResolution, iMouse, iTime);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntdcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 112, 265], [267, 267, 290, 290, 460], [462, 462, 493, 563, 611], [613, 613, 704, 774, 1449], [1451, 1451, 1487, 1487, 1533]], "test": "untested"}
{"id": "7l3yz4", "name": "Day 956", "author": "jeyko", "description": "potato  t", "tags": ["mdtmjvm"], "likes": 30, "viewed": 650, "published": 3, "date": "1659376574", "time_retrieved": "2024-07-30T16:37:25.006238", "image_code": "// Fork of \"Day 955\" by jeyko. https://shadertoy.com/view/fttyR8\n// 2022-08-01 07:12:45\n\n// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    C *= 0.;\n    \n    float sc = 1./(1.+0.*max(15.*float(lightMode == 1.)*max(sin(iTime*2.),0.)*sin(iTime*0.5),0.));\n    \n    float md = 14.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(iTime*md)),hash11(ceil(iTime*md)),fract(iTime*md)),0.5)*0.5;\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    float db = sdBox(nuv,vec2(0.2 + float(lightMode==0.)*float(fract(iTime*0.125)<0.5)*0.24,0.4));\n    \n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    \n    \n    \n    //vec2 st = 0.4/R.xy + 0.1*sin(iTime)*float(hash11(floor(iTime)) < 1. && lightMode == 0.);\n    vec2 st = (0.4 + 2.*float(hash11(floor(iTime*2.)) < 0.5 && lightMode == 0.))/R.xy;\n    \n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x +\n        Tb(uv + vec2(st.xy)).x-(Tb(uv - vec2(st.xy))).x +\n        Tb(uv + vec2(st.x,-st.y)).x-(Tb(uv - vec2(st.x,-st.y))).x\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    //a.xz = vec4(l);\n    \n    \n    \n    if(db > 0.){\n        //b = 1.-step(b,vec4(0.4,0.1,0.4,1));\n        b *= 0.1;\n        //b = 1.-b;\n    }\n\n\n    \n    C += vec4 (1)- b*1.*float(a.x > 100. || b.w <-0.01) - abs(a.y)*0. ;\n    \n    C = mix(C,vec4(0),l );\n    // britney\n    C *= Td(uv);\n        \n        \n    uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    if(lightMode == 0.){\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        p.y *= 0.1;\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.003;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        if((id.x) > 28.){\n            if(r.y < 0.1){\n                if(r.x < 0.5)\n                    d = abs(d) - 0.0004;\n                \n                //C = mix(C,vec4(0),smoothstep(0.001,0.,d));\n                \n            } else if(r.x < 0.5){\n                C = mix(C,vec4(0),1.);\n                \n            }\n               \n        }\n         \n    }\n    \n    {\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.004;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        \n        if(abs(id.y) < 15. && (id.x) < -28. && sin(iTime + sin(r.y*3.)*4.)> 0.){\n            if(r.y < 0.1){\n                int cidx = int(r.x*4.*4.);\n                vec3 c = palAppleII[cidx];\n                \n                c = rgb2hsv(c);\n                c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n        \n                C.xyz = c;\n                \n            }\n               \n        }\n\n         \n    }    \n    \n    vec3 n = hash33(vec3(U,mod(iTime,200.)));\n    vec3 nb = hash33(vec3(U,mod(iTime,5200.)));\n    //C = mix(C,n.xyzx,n.xyzz);\n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    C = mix(C,1.-C,smoothstep(dFdx(nuv.x),0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    C = max(C,vec4(0.01));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt,float t){\n    lookAt += 0.1*sin(t*vec3(1,0.8,0.9));\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define lightMode float(fract(iTime*0.1) <0.5 )\n\n\n// iq\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nvec3 getRo(float t, vec2 m, vec2 r){\n    vec3 ro = vec3(0,0,-2);\n    //ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    ro.yz *= rot(sin(t)*0.4);\n    \n    ro.xz *= rot((t + sin(t*1.4))*0.2);\n    ro.xz *= rot(m.x/r.x);\n    ro.yz *= rot(m.y/r.x);\n    return ro;\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 8.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = 1. + floor(hash11(floor(iTime + 200.))*8.)*float(hash11(floor(iTime)) < 0.2);\n    fragCoord = floor(fragCoord/sc)*sc;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    \n    \n    \n    float mode = floor(fract(iTime*0.2)*2.4);\n    if(lightMode == 1.)\n        mode = 3.;\n    if(mode == 0.){\n        col = vec3(1)*sin(dot(uv,uv)*1000. + sin(length(uv + 0.05*sin(+iTime))*4. + iTime)*20. + iTime*10.);\n    } else if(mode == 1.) {\n        col = vec3(1)*sin(dot(uv.y,uv.x)*1000. + sin(length(uv + 0.05*sin(+iTime))*4. + iTime)*20. + iTime*10.);\n    } else {\n        col = vec3(1);\n    }\n    //col = abs(sin(col));\n    \n    col = mod(col*0.000001,1.);\n\n    \n    uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float td = sdBox(uv - (max(hash31(floor(iTime*1.)).xy,0.2)*1. - 0.75)*2., vec2(0.1,0.001));\n    \n    \n    if(td < 0.){\n        col = 1.-col;\n    }\n\n    //col = mix(col,1.-col,smoothstep(0.,fwidth(td),td));\n    //vec3 rd = normalize(vec3(uv,1));\n    \n    \n    \n    \n    if((envb(iTime) < 0.1))\n        col = luma(col)*vec3(1);\n\n    \n    //col = 1.- col;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat map(vec3 p){\n    \n    p.xy *= rot(p.z + sin(iTime + p.z)*4.);\n    return length(p.xy) - 0.0+ sin(p.z + iTime)*0.3*noise(p*5.)*0.8 - 0.1  + smoothstep(1.,2.,abs(p.z));\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    float sc = 3.;\n    U = floor(U/sc)*sc;\n    \n    vec2 uv = (U-0.5*R.xy)/max(R.x,R.y)*(1. ) ;\n    //uv += vec2(.6,0)*float(fract(iTime*14.2) < 0.4)*float(fract(iTime*2.2) < 0.1);\n    //vec2 t = 1./R.xy;\n    //vec4 l = vec4(\n    //    luma(Ta(uv + vec2(t.x,0)))-luma(Ta(uv - vec2(t.x,0))) +\n    //    luma(Ta(uv + vec2(0,t.y)))-luma(Ta(uv - vec2(0,t.y)))\n    //);\n    //l = abs(l);\n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,0.5));\n    \n    \n    float t = 0.;\n    vec3 p = ro;\n    bool hit = false;\n    for(float i = 0.; i < 40.; i++){\n        float d = map(p);\n        \n        if(d < 0.03){\n            hit = true;\n            break;\n        } else if(t > 4.5){\n            break;\n        }\n        d *= 0.2;\n        \n        p = ro + rd * (t += d);\n    }\n    if(hit == false){\n        t = 1000.;\n    } \n    \n    uv = U/R.xy*(1. );\n    \n    \n    vec2 st = 1.4/R.xy;\n   \n    float tPrev = Tb(uv).x;\n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x\n    ;\n    \n    C = vec4(t);\n    \n    C.y = l;\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// dither\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2 + idx)),14.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 4. - hash11(idx)*4.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n    float quant = 3.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    vec3 currColHsv = rgb2hsv(s.xyz);\n    s = hsv2rgbSmooth(currColHsv*vec3(1,0.2,1.) + vec3(0.3,0.,0.)).xyzz;\n    s = vec4(luma(s));\n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n    C = sin(Ta(uv));\n    \n   \n    vec3 Chsv = rgb2hsv(C.xyz);\n\n    vec3 hit = vec3(0);\n    float similarity = -0.;\n    for(int i = 0; i < 4*4; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        palCHsv.b += sin(iTime*2. + float(i))*3.;\n        float localSimilarity = dot(palCHsv.rb, Chsv.rb);\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz *= hit;\n    \n    \n    vec3 OC = C.xyz;\n    \n    C = vec4(1);\n    \n    float sc = 1.;\n    U = floor(U/sc)*sc;\n    \n    uv = (U - 0.5*R.xy)/R.y;\n    \n    float rep = 0.004;\n    \n    float idd = floor(uv.y/rep);\n    uv.y = floor(uv.y / rep)*rep; \n    \n        \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    \n    {\n        \n        vec2 lastDotPos = vec2(0);\n        float lastDD = 10e5;\n        for(float i = 0.; i < 140.; i++){\n            vec3 dotPos = max(hash31(i + 20.),0.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*4.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            //lp *= rot(exp(-fract(iTime*sin(i) + sin(i)*20.)*4.)*pi);\n            \n            float d;\n            \n            vec2 r = hash21(i);\n            \n            if(i < 20.){\n                d = max(\n                    min(abs(lp.x),abs(lp.y)),\n                    sdBox(lp,vec2(0.1,0.01))\n                    ) - 0.001 - 0.00*pow(abs(sin(i + iTime)),5.);\n            }else{\n                lp *= rot(iTime + i + sin(iTime*2. + i));\n            \n                 if(i<130.){\n                    float dd = length(lp) - 0.04*sin(i + iTime + sin(iTime + i));\n\n                    if(r.y > 0.5)\n                        d = abs(dd) - 0.001 ;\n                    else\n                        d = (dd) - 0.001 ;\n\n                    if(lightMode == 0.){\n\n                       float l = sdSegment(uv,projPos.xy,lastDotPos.xy)-0.004*(sin(i + iTime*2.));\n                       if(mod(idd,2.) == 0.)\n                           l = 10e5;\n                       d = min(d,max(max(l,-dd),-lastDD));\n                    }\n\n                    lastDD = dd;\n\n                } else {\n                    if(lightMode == 0.)\n                        continue;\n                    d = length(lp.y) - 0.004 ;\n                }\n            }\n            \n            lastDotPos = projPos.xy;\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n            C -= smoothstep( 1./R.x, 0. , d);\n        }\n        \n        for(float i = 0.; i < 40. - 30.*lightMode; i++){\n            vec3 dotPos = max(hash31(i + 100.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n\n            float sc = 8. + sin(i)*5.;\n            lp *= sc;\n            //uv *= 2.;\n\n            float td = text(lp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.47 , true, i);\n            \n            //col = mix(col,vec3(1),smoothstep(0.4*fwidth(td)*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n            C = mix(C,vec4(0),smoothstep(0.4*0.01*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n\n        }\n\n        \n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n\n        \n    \n    }\n    C = clamp(C,0.,1.);\n    C = mix(vec4(OC.xyz,1),vec4(1,1,1,0),dot(1.-C.x,1.-C.x));\n    //C = currC;\n    \n}", "buffer_c_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    char -= 544. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 oU = U;\n    float sc = 4. + 4.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    uv.x = abs(uv.x);\n    \n    uv.x -= 0.4;\n    vec2 t = 1./R.xy;\n    \n    \n    \n    vec2 prevP = vec2(0);\n    \n    float d = 10e4;\n    for(float i = 0.; i < 0.; i++){\n        vec2 k = vec2(sin(i*0.7 + sin(iTime + i)), cos(i*1.5 + iTime)*2.)*0.1;\n            \n            \n            \n        d = min(d,sdSegment(uv,k,prevP) - 0.004 - noise(vec3(i+iTime + sin(iTime + i),uv*5.))*0.01);\n        \n        \n        prevP = k;\n    }\n   \n   float od = d;\n   d = abs(d);\n   C *= 0.;\n   //C += 1.; // epic lol\n   \n   \n\n   C= mix(C,1.-C,smoothstep(0.,fwidth(d),d - 0.004));\n   \n   if(od < 0.)\n       return;\n   U = oU;\n    sc = 1. + 0.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   \n   u += 1. - hash11(floor(iTime) + 200.)*1.8;\n   u *= 0.4 - hash11(floor(iTime))*0.1;\n   u*=2. + floor((hash11(floor(iTime/3.))*4.));\n   u.x /= 1.;\n   \n\n    //u += 1./3.;\n   if(u.x < 1. && u.y < 1. && u.x > 0. && u.y > 0. && fract(iTime) < 0.2 && sin(iTime) < 0.){\n       vec4 britney =  texture(iChannel1,u);\n       float dith = texture(iChannel2,oU.xy/vec2(textureSize(iChannel1,0).xy*(1 + 0*int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n        float quant = 3.;\n        float recipQuant = 1./quant;\n\n        vec4 s = Tb(uv);\n        vec4 currC = floor(s*quant)/quant;\n        vec4 nextC = clamp(currC + recipQuant,0.,1.);\n        float perc = fract(luma(s)*quant);\n\n\n\n\n        if(perc>dith){\n            britney = nextC;\n        } else{\n            britney = currC;\n        }\n\n       //britney = hsv2rgbSmooth(currColHsv*vec3(0.2,0.,1.) + vec3(1. + iTime,0.5,0.)).xyzz;\n\n       C -= 1.- britney;\n   }\n    \n    \n    sc = 2.;\n    U = floor(U/sc)*sc;   \n    uv = (U-R.xy*0.5)/R.y;\n    \n    float pxsz = 0.001;\n    float tt =10e5;\n\n    {\n        float m = sin(iTime*4.4 + sin(iTime)*0.);\n        vec2 p = uv + vec2(0.7,-0.2);\n        p.y += 0.4;\n        \n        p *= rot(0.5*pi);\n        \n        p *= 4.;\n        p.x += (iTime + sin(iTime))*2.3;\n        \n        float id = floor(p.x/6.);\n        p.x = pmod(p.x,6.);\n        \n        if(hash11(id + 200.) < 0.5)\n            p.x = 1.-p.x;\n            \n            \n        if(hash11(id + 200.) < 0.5)\n            p.y = -p.y + 5.8;\n        \n        if(hash11(id) < 0.5)\n            tt = min(tt,text(p, float[8](128.,127.,132.,113.,132.,117.,1117.,1130.), 0.01 +m*0. , 0.4 , true, 0.0001, 0.5 + 0.*sin(iTime*0.3 + 0.4), true));\n    }   \n             \n            \n    C = mix(C,(0.6-C) ,smoothstep(pxsz + 0.01,0., tt - 0.01));\n    \n    uv = (oU-R.xy*0.5)/R.y;\n    \n    if(fract(iTime*0.5)>0.75)\n    for(float i = 0.; i < 4.; i++){\n        vec3 dotPos = max(hash31(i + 1200. + floor(iTime)),0.4)*2. - 1.;\n        vec2 lp = uv - dotPos.xy;\n        lp *= 17.4;\n\n        float md = 0.3;\n        float id = floor(lp.y/md);\n        if(id < 2. || id > 9. + sin(i)*20.)\n            continue;\n        lp.y = mod(lp.y,md);\n        float td = textb(lp, float[4*4](\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,96.,96.,96.\n            ), -0.5 , 0.2 , false, 0., 0.47 , true, id + i*20. + floor(iTime*10.));\n        C = mix(C,vec4(0),smoothstep(0.001,0.,td - 0.03));\n    }\n\n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}", "buffer_d_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3yz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[674, 674, 714, 714, 3868]], "test": "untested"}
{"id": "ssGfDd", "name": "webcam-display calibration", "author": "FabriceNeyret2", "description": "Long term goal is to use the webcam to calibrate the monitor.\nProblem: is capture = display ? worse: there is autobalance in the webcam, so that nothing is stable.\nBeside, sticking the webcam on the grey requires a big correction while pure color don't.", "tags": ["gamma", "calibration", "webcam"], "likes": 1, "viewed": 379, "published": 3, "date": "1659368653", "time_retrieved": "2024-07-30T16:37:25.753241", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch( iChannel0, ivec2(U), 0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define G(O) pow(O, vec4(1./2.2) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R,\n         V = 2.*U-1.; V *= V;\n\n\n    O = texture(iChannel1, U)  // vignetting correction on my Logi720p.\n      * ( 1. + vec4(.07,.03,0,0) + vec4(.6,.2,.2,0)*V.x + vec4(.18,.18,.18,0)*V.y );\n    if (U.x>.5) O *= 1.7;\n    \n // O *= .5 / textureLod(iChannel1, u/R, 99.); // auto-qualibration\n // O *= 1.85 ; \n // O.r *= 1.05;\n   \n    float y = abs(U.y-.5); \n    int j = int(6.*U.y);\n    if ( U.x < ( y < .34 ? .3 : .5 ) ) O = G( vec4(j==1,j==3,j==5,0) \n                                            + vec4(j==0,j==2,j==4,0) *.5 );\n    if ( U.x > ( y < .34 ? .7 : .5 ) ) O = G(U.y<.5 ? vec4(mod(u.x+u.y, 2.) < 1.)\n                                                   : vec4(.5) \n                                           );\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 86]], "test": "untested"}
{"id": "fttcz4", "name": "PT workshop 8S: Progressive", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nThis shader adds progressive rendering to the final solution. Click Reset time after viewport changes.\nSolved\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 3, "viewed": 499, "published": 3, "date": "1659368094", "time_retrieved": "2024-07-30T16:37:26.685748", "image_code": "// Interesting things happen in Buffer A, this just displays the image\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    out_color = texture(iChannel0, pixel_coord / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TRIANGLE_COUNT 30\n#define MAX_PATH_LENGTH 5\n#define SAMPLE_COUNT 1\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n    vec3 v0 = tri.positions[0];\n    mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);\n    vec3 solution = inverse(matrix) * (origin - v0);\n    out_t = solution.x;\n    vec2 barys = solution.yz;\n    return out_t >= 0.001 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n    for (int i = 0; i != TRIANGLE_COUNT; ++i) {\n        float t;\n        if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {\n            out_t = t;\n            out_tri = tris[i];\n        }\n    }\n    return out_t < 1.0e38;\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    float z = 2.0 * random_numbers[1] - 1.0;\n    float phi = 2.0 * M_PI * random_numbers[0];\n    float x = cos(phi) * sqrt(1.0 - z * z);\n    float y = sin(phi) * sqrt(1.0 - z * z);\n    return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n    vec3 direction = sample_sphere(random_numbers);\n    if (dot(normal, direction) < 0.0)\n        direction -= 2.0 * dot(normal, direction) * normal;\n    return direction;\n}\n\n\n// Performs path tracing: It starts with the given ray. If this ray intersects\n// a triangle, a new random ray is traced iteratively, up to a fixed limit.\n// \\param origin The position at which the ray starts (x_j)\n// \\param direction The direction vector of the ray (omega_j)\n// \\param seed Needed for get_random_numbers()\n// \\return A noisy estimate of the reflected and emitted radiance at the point\n//         intersected by the ray (i.e. the color) (L_o(x))\nvec3 get_ray_radiance(vec3 origin, vec3 direction, inout uvec2 seed) {\n    vec3 radiance = vec3(0.0);\n    vec3 throughput_weight = vec3(1.0);\n    for (int i = 0; i != MAX_PATH_LENGTH; ++i) {\n        float t;\n        triangle_t tri;\n        if (ray_mesh_intersection(t, tri, origin, direction)) {\n            radiance += throughput_weight * tri.emission;\n            origin += t * direction;\n            direction = sample_hemisphere(get_random_numbers(seed), tri.normal);\n            throughput_weight *= tri.color * 2.0 * dot(tri.normal, direction);\n        }\n        else\n            break;\n    }\n    return radiance;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Use a different seed for each pixel and each frame\n    uvec2 seed = uvec2(pixel_coord) ^ uvec2(iFrame << 16, iFrame << 16 + 237);\n    // Perform path tracing with SAMPLE_COUNT paths\n    out_color.rgb = vec3(0.0);\n    for (int i = 0; i != SAMPLE_COUNT; ++i)\n        out_color.rgb += get_ray_radiance(camera_position, ray_direction, seed);\n    out_color.rgb /= float(SAMPLE_COUNT);\n    vec3 prev_color = texture(iChannel0, tex_coord).rgb;\n    float weight = 1.0 / float(iFrame + 1);\n    out_color.rgb = (1.0 - weight) * prev_color + weight * out_color.rgb;\n    out_color.a = 1.0;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 128, 128, 196]], "test": "untested"}
{"id": "Nttyz4", "name": "oscilloscope analysis luminance", "author": "FabriceNeyret2", "description": "trace the luminance profile of a source image ( video or webcam ) along a series of horizontal and vertical lines.\nSPACE: show image\nTAB: fix webcam vignetting.\nMouse.y: change grid density.", "tags": ["oscilloscope", "calibration", "webcam", "vignetting"], "likes": 45, "viewed": 1539, "published": 3, "date": "1659367084", "time_retrieved": "2024-07-30T16:37:27.422777", "image_code": "// variant of https://shadertoy.com/view/7t3yzN\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define S(v)            smoothstep(1., 0., abs(v)/fwidth(v) )\n\n#define T(U)  texture(iChannel1,U) * ( keyToggle(9) ? 1. + vec4(.07,.03,0,0) + vec4(.6,.2,.2,0)*V.x + vec4(.18,.18,.18,0)*V.y : vec4(1) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R,\n         G = R/ ( iMouse.xy==vec2(0) ? 8. : exp2(round(2.+4.*iMouse.y/R.y)) ),\n         I = round (U*G)/G,\n         V = 2.*U-1.; V *= V;\n  \n    G = G*(U-I)+.5;\n\n    O-=O;\n    if keyToggle(32) O = T(U);\n    \n  \n    vec4 P = T( vec2(U.x,I.y) );  // horizontal RGB profiles\n    O = mix( O, vec4(1), S( G.y - length(P.rgb)/sqrt(3.) ) );\n  \n    P = T( vec2(I.x,U.y) );       // vertical RGB profiles\n    O = mix( O, vec4(1), S( G.x - length(P.rgb)/sqrt(3.) ) );\n    \n    O = sqrt(O);                  // to sRGB\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nttyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fldcR4", "name": "PT workshop 3S: Ray-mesh test", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 3: Implementing a ray-mesh intersection test.\nSolved.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 1, "viewed": 590, "published": 3, "date": "1659365041", "time_retrieved": "2024-07-30T16:37:28.369247", "image_code": "#define TRIANGLE_COUNT 30\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n    vec3 v0 = tri.positions[0];\n    mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);\n    vec3 solution = inverse(matrix) * (origin - v0);\n    out_t = solution.x;\n    vec2 barys = solution.yz;\n    return out_t >= 0.0 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n    for (int i = 0; i != TRIANGLE_COUNT; ++i) {\n        float t;\n        if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {\n            out_t = t;\n            out_tri = tris[i];\n        }\n    }\n    return out_t < 1.0e38;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Trace a ray and display the triangle color+emission\n    triangle_t tri;\n    float t;\n    out_color.rgb = vec3(0.0);\n    if (ray_mesh_intersection(t, tri, camera_position, ray_direction))\n        out_color.rgb = tri.color + tri.emission;\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 529, 640, 640, 760], [1210, 1560, 1654, 1654, 1966], [1969, 2348, 2446, 2509, 13656], [13659, 13659, 13716, 13769, 14562]], "test": "untested"}
{"id": "NtdcR4", "name": "PT workshop 4S: Sphere sampling", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 4: Implementing uniform sampling of the unit sphere.test.\nSolved.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 160, "published": 3, "date": "1659364905", "time_retrieved": "2024-07-30T16:37:29.298761", "image_code": "#define SAMPLE_COUNT 512\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    float z = 2.0 * random_numbers[1] - 1.0;\n    float phi = 2.0 * M_PI * random_numbers[0];\n    float x = cos(phi) * sqrt(1.0 - z * z);\n    float y = sin(phi) * sqrt(1.0 - z * z);\n    return vec3(x, y, z);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Splat spherical samples as Gaussians\n    out_color.rgb = vec3(0.0);\n    vec3 sphere_camera_position = vec3(0.0, 3.2, 0.0);\n    uvec2 seed = uvec2(0xdeadbeef, 0xc0ffee);\n    for (int i = 0; i != SAMPLE_COUNT; ++i) {\n        vec3 dir = sample_sphere(get_random_numbers(seed));\n        float gaussian = exp(-100000.0 * (1.0 - dot(ray_direction, normalize(dir - sphere_camera_position))));\n        out_color.rgb += 0.5 * vec3(gaussian);\n    }\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 568, 679, 679, 799], [802, 1034, 1077, 1138, 1464], [1467, 1631, 1672, 1672, 1881], [1884, 1884, 1941, 1994, 2989]], "test": "untested"}
{"id": "7lcczN", "name": "Windows angle bug #65", "author": "FabriceNeyret2", "description": "On Windows/Angle, cond ? ( a = expr(1), a ) : ( a = expr(2), a ) doesn't always work (top) while if/else is ok (bottom):\n a = expr(1) , a = expr(2) is evaluated prior everything.\n\nOn OpenGL, left= grey and right= white.\nOn Windows/Angle, top/left = white.", "tags": ["glsl", "bug", "angle"], "likes": 7, "viewed": 269, "published": 3, "date": "1659361887", "time_retrieved": "2024-07-30T16:37:30.071695", "image_code": "// acid test for Windows/Angle bug in https://www.shadertoy.com/view/fdyfDd\n\nint n = 5;\nfloat a;\n  #define F(v)  ( (a = n==5 ? v : v/4.) , a )   // not ok on Windows/Angle, ok on OpenGL\n//#define F(v)    (a = n==5 ? v : v/4.)         // ok\n//#define F(v)  ( (a = v< 0. ? -v : v ) , a )   // ok \n//#define F(v)  (  a = max(v, -iTime  ) , a )   // ok \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = u/R;\n    \n    if (U.y > .5 )                              // top:     () ? :\n        O = vec4( U.x < .5 ? F(.5) : F(1.)  );\n    else                                        // bottom:  if ; else\n        if ( U.x < .5 ) O = vec4( F(.5) );\n        else            O = vec4( F(1.) );\n        \n    U = floor(u)-floor(R/2.); if (U.x*U.y==0.) O = vec4(1,0,0,1); // red separators     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 389, 389, 802]], "test": "untested"}
{"id": "7t3yzN", "name": "calibrate your webcam", "author": "FabriceNeyret2", "description": "how are your camera colors ?\nPut camera against screen on a white area. E.g. fullscreen +  bottom-left corner.\nFor mine ( Logi 720p / auto-balance / linux ) R,G,B values differs, as their vignetting profile.\nAlso, it changes if I turn my camera by 90° !", "tags": ["calibration", "webcam", "vignetting"], "likes": 4, "viewed": 580, "published": 3, "date": "1659357879", "time_retrieved": "2024-07-30T16:37:30.882527", "image_code": "#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define S(v)            smoothstep(1., 0., abs(v)/fwidth(v) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R;\n\n    O = texture(iChannel0, U);\n    \n        // --- color profile along horizontal axis\n    vec4 V = texture(iChannel0, vec2(U.x,.5) ); V.a = .5; // video central line + ref .5\n\n    float x = abs(2.*U.x-1.);  \n    if keyToggle(32) V *= 1. + vec4(.07,.03,0,0) + vec4(.6,.2,.2,0)*x*x; // correction for my Logi720p\n \n    V = S( U.y - V ); // draw RGB profile for mid-line.\n    O = mix( O, vec4(1,0,0,1), V.r );\n    O = mix( O, vec4(0,1,0,1), V.g );\n    O = mix( O, vec4(0,0,1,1), V.b );\n    O = mix( O, vec4(1), V.a );\n    \n        // --- color profile along vertical axis\n    V = texture(iChannel0, vec2(.5,U.y) ); V.a = .5; // video central column + ref .5\n    float y = abs(2.*U.y-1.);  \n    if keyToggle(32) V *= 1. + vec4(.07,.03,0,0) + vec4(.18,.18,.18,0)*y*y; // correction for my Logi720p\n\n    V = S( U.x - V ); // draw RGB profile for mid-line.\n    O = mix( O, vec4(1,0,0,1), V.r );\n    O = mix( O, vec4(0,1,0,1), V.g );\n    O = mix( O, vec4(0,0,1,1), V.b );\n    O = mix( O, vec4(1), V.a );\n    \n // O *= 1. + vec4(.07,.03,0,0) + vec4(.6,.2,.2,0)*x*x + vec4(.18,.18,.18,0)*y*y;\n    \n        // --- white corner for qualibration.\n    if (max(U.x,U.y)<.15) O = vec4(1);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3yzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sl3yzN", "name": "Test SSGI (infinite bounces)", "author": "romax9lahin", "description": "testing screen space GI  (infinite bounces) for deferred rendering.", "tags": ["gi", "ssgi"], "likes": 6, "viewed": 697, "published": 3, "date": "1659356881", "time_retrieved": "2024-07-30T16:37:31.832985", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;    \n    \n    fragColor.rgb = texture(iChannel3, uv).rgb;\n}\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// All code here is by Zavie (https://www.shadertoy.com/view/4sfGDB#)\n\n/*\n\nThis shader is an attempt at porting smallpt to GLSL.\n\nSee what it's all about here:\nhttp://www.kevinbeason.com/smallpt/\n\nThe code is based in particular on the slides by David Cline.\n\nSome differences:\n\n- For optimization purposes, the code considers there is\n  only one light source (see the commented loop)\n- Russian roulette and tent filter are not implemented\n\nI spent quite some time pulling my hair over inconsistent\nbehavior between Chrome and Firefox, Angle and native. I\nexpect many GLSL related bugs to be lurking, on top of\nimplementation errors. Please Let me know if you find any.\n\n--\nZavie\n\n*/\n\n// Play with the following value to change quality.\n// You want as many samples as your GPU can bear. :)\n#define MAXDEPTH 4\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n// Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct PixelInfo { vec3 pos, norm; };\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres()\n{\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);\n}\n\nfloat intersect(Sphere s, Ray r) \n{\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) \n{\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvoid world_pos_at(Ray r, out PixelInfo info)\n{\n    vec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\n    float t;\n\tSphere obj;\n\tid = intersect(r, t, obj, id);               \n\tvec3 x = t * r.d + r.o;\n    vec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n    info.pos = x;\n    info.norm = n;\n}\n\nvec3 camPos()\n{\n    float speed = 1.;\n    vec3 offset = 30. * vec3(sin(speed * iTime), cos(speed * iTime), 0);\n    vec3 camPos = offset + vec3(\n        (2. * .5 * iResolution.xy / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), \n        169.\n    );\n    return camPos;   \n}\n\nvoid build_screen_ray(vec2 fragCoord, out Ray r)\n{    \n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    vec3 target = vec3(50., 40., 81.6);\n    vec3 camera = camPos();\n\n    vec3 cz = normalize(target - camera);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n    vec3 raydir = normalize(0.53135 * (iResolution.x/iResolution.y * uv.x * cx + uv.y * cy) + cz);\t    \n    \n    r.o = camera;\n    r.d = raydir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tinitSpheres();\n        \n    PixelInfo info;\n    Ray screen_ray;\n    build_screen_ray(fragCoord, screen_ray);\n    world_pos_at(screen_ray, info); \n     \n    fragColor.rgb = info.norm;\n    fragColor.a = length(info.pos - screen_ray.o);\n}\n\n\n\n\n\n", "buffer_a_inputs": [], "buffer_b_code": "\nstruct Ray { vec3 o, d; };\n\nvec3 camPos()\n{\n    float speed = 1.;\n    vec3 offset = 30. * vec3(sin(speed * iTime), cos(speed * iTime), 0);\n    vec3 camPos = offset + vec3(\n        (2. * .5 * iResolution.xy / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), \n        169.\n    );\n    return camPos;   \n}\n\nvoid build_screen_ray(vec2 uv, out Ray r)\n{    \n    //vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    vec3 target = vec3(50., 40., 81.6);\n    vec3 camera = camPos();\n\n    vec3 cz = normalize(target - camera);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n    vec3 raydir = normalize(0.53135 * (iResolution.x/iResolution.y * uv.x * cx + uv.y * cy) + cz);\t    \n    \n    r.o = camera;\n    r.d = raydir;\n}\n\nvec3 position(vec2 uv, float depth)\n{\n    Ray screen_ray;\n    build_screen_ray(2. * uv - vec2(1,1), screen_ray);\n\n    return (screen_ray.o + screen_ray.d * depth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec4 c02 = texture(iChannel0, uv);\n\n    vec3 N = c02.xyz;\n    vec3 P = position(uv, c02.w);  \n    \n    vec3 res = vec3(0.0);\n    \n    if (P.y < 0.02)\n    {\n        res += 1.0 * \n            vec3(0.5+0.5*sin(iTime*0.7),0.5+0.5*cos(iTime*1.4),0.2);\n           //vec3(0.2,0.9,0.2);\n    }\n    if (P.y > 81.32)\n    {\n       res += 1.0 * \n           vec3(0.5+0.5*cos(iTime*1.1),0.2,0.5+0.5*cos(iTime*0.9));\n           //vec3(0.9,0.2,0.2);\n    }\n    \n    fragColor.rgb = res;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nstruct Ray { vec3 o, d; };\n\nfloat rand(vec3 co, float seed)\n{\n    return fract(iDate.a + seed * 109.3 + sin(dot(co.xy, vec2(12.9898, seed * 78.233))) * 43758.5453);\n}\n\nvec3 camPos()\n{\n    float speed = 1.;\n    vec3 offset = 30. * vec3(sin(speed * iTime), cos(speed * iTime), 0);\n    vec3 camPos = offset + vec3(\n        (2. * .5 * iResolution.xy / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), \n        169.\n    );\n    return camPos;   \n}\n\nvoid build_screen_ray(vec2 uv, out Ray r)\n{    \n    vec3 target = vec3(50., 40., 81.6);\n    vec3 camera = camPos();\n\n    vec3 cz = normalize(target - camera);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n    vec3 raydir = normalize(0.53135 * (iResolution.x/iResolution.y * uv.x * cx + uv.y * cy) + cz);\t    \n    \n    r.o = camera;\n    r.d = raydir;\n}\n\nvec3 position(vec2 uv, float depth)\n{\n    Ray screen_ray;\n    build_screen_ray(2. * uv - vec2(1,1), screen_ray);\n\n    return (screen_ray.o + screen_ray.d * depth);\n}\n\nvec3 combine(vec3 P1, vec3 N1, vec2 uv2, inout float w)\n{\n    vec4 c02 = texture(iChannel0, uv2);\n\n    vec3 N2 = c02.xyz;\n    vec3 P2 = position(uv2, c02.w);  \n    vec3 L2 = texture(iChannel3, uv2).rgb;\n    \n    //1 bounce\n    //if (fract(iTime * 0.12) < 0.5) L2 = texture(iChannel1, uv2).rgb; \n    \n    vec3 delta = P2 - P1;\n    float dist = length(delta);\n    vec3 L = delta / dist;\n    if (dist < 0.001) return vec3(0);\n\n    float alignA = clamp(dot(L, N1), 0.0f, 1.0f); // how much the center is curved towards the sample   \n    float alignB = clamp(dot(-L, N2), 0.0f, 1.0f); // how much the sample is curved towards the center\n        \n    float weight = alignA * alignB / (dist * dist);\n   \n    w += weight;\n    \n    return L2 * weight;\n}\n\nvec4 SSGI(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ps = vec2(1) / iResolution.xy;\n     \n    float w = 0.;\n    vec3 acc = vec3(0);\n    \n    vec4 c0 = texture(iChannel0, uv);\n    \n    vec3 N = c0.xyz;\n    vec3 P = position(uv, c0.w);\n    vec3 L = texture(iChannel2, uv).rgb;\n        \n    float nr_samples = 6.;\n    \n    // super big cheat as a test for directional sampling > seems to make it more glossy!\n    // float v = dot(N, vec3(0, 1, 0));\n    // float h = dot(N, vec3(1, 0, 0));\n    // vec2 q = vec2(h, v);\n    \n    float prog_begin = 2. * 3.1415 * rand(P, 357.); \n    float prog_end = prog_begin + 2. * 3.1415;\n    \n    float prog = prog_begin;\n    \n    float step_avg = (prog_end - prog_begin) / nr_samples;\n    float step_min = 0.8 * step_avg;\n    float step_range = 0.4 * step_avg; \n    float offset = 1.5;\n    float limit = iResolution.x * 0.7;\n\n    // take random samples on screen: \n    // todo -> in direction of normal\n    // todo -> more in direction of normal if glossy\n    // todo -> avoid off-screen samples?\n    for (float i = 0.; i < nr_samples; ++i)\n    {\n        prog += step_min + step_range * rand(P, 1. + i);\n        float r2 = rand(P, 2. * i);\n        //r2 = sqrt(r2);\n        r2 = offset + (limit - offset) * r2;\n        vec2 s = uv + ps /** q*/ * r2 * vec2(sin(prog), cos(prog));\n        // why does this have the wrong effect\n        // because clamping is actually a good method to approximate off-screen areas?\n        /*if (s.x < 0.) s.x = -s.x;\n        if (s.y < 0.) s.y = -s.y;\n        if (s.x > 1.) s.x = 2. - s.x;\n        if (s.y > 1.) s.y = 2. - s.y;*/\n        acc += combine(P, N, s, w);\n    }\n    \n    return vec4(acc / (0.00001 + w), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //vec3 camera = vec3((2. * .5*iResolution.xy / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n    vec2 uv = fragCoord / iResolution.xy;\n    // todo: double buffer the light-accumulation\n    // and then make a mapping of the new fram onto the old one?\n    // mapping by 1 matrix to map from old to new view-space?\n    // then pretend pixels are {u, v, depth, 0/1(?)} coordinates\n    fragColor = SSGI(fragCoord) * 0.3 + 0.7 * texture(iChannel2, uv);\n\n}\n\n\n\n\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "struct Ray { vec3 o, d; };\n\nfloat rand(vec3 co, float seed)\n{\n    return fract(iDate.a + seed * 109.3 + sin(dot(co.xy, vec2(12.9898, seed * 78.233))) * 43758.5453);\n}\n\nvec3 camPos()\n{\n    float speed = 1.;\n    vec3 offset = 30. * vec3(sin(speed * iTime), cos(speed * iTime), 0);\n    vec3 camPos = offset + vec3(\n        (2. * .5 * iResolution.xy / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), \n        169.\n    );\n    return camPos;   \n}\n\nvoid build_screen_ray(vec2 uv, out Ray r)\n{    \n    //vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    vec3 target = vec3(50., 40., 81.6);\n    vec3 camera = camPos();\n\n    vec3 cz = normalize(target - camera);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n    vec3 raydir = normalize(0.53135 * (iResolution.x/iResolution.y * uv.x * cx + uv.y * cy) + cz);\t    \n    \n    r.o = camera;\n    r.d = raydir;\n}\n\nvec3 position(vec2 uv, float depth)\n{\n    Ray screen_ray;\n    build_screen_ray(2. * uv - vec2(1,1), screen_ray);\n\n    return (screen_ray.o + screen_ray.d * depth);\n}\n\nvec3 combine(vec3 P1, vec3 N1, vec2 uv2, inout float w)\n{\n    vec4 c02 = texture(iChannel0, uv2);\n\n    vec3 N2 = c02.xyz;\n    vec3 P2 = position(uv2, c02.w);\n    vec3 AA2 = texture(iChannel2, uv2).rgb;\n    \n    float dist = length(P1 - P2) / 5.;\n    float align = clamp(dot(N1, N2), 0., 1.);\n        \n    float weight = align / (0.01 + dist);\n    w += weight;\n    \n    return AA2 * weight;\n}\n\nvec3 SSGI_resolve(vec2 fragCoord)\n{\n    // todo: 2 pass resolve (2 pass weighted gaussian blurr)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ps = vec2(1) / iResolution.xy;\n    \n    vec4 c0 = texture(iChannel0, uv);\n\n    vec3 N = c0.xyz;\n    vec3 P = position(uv, c0.w);\n\n    float w = 1.;\n    vec3 acc = w * texture(iChannel2, uv).rgb;\n            \n    float nr_samples = 32.;\n    float prog = 2. * 3.1415 * rand(P, 1.);\n    float step_avg = 2. * 3.1415 / nr_samples;\n    float step_min = 0.95 * step_avg;\n    float step_range = 0.1 * step_avg; \n     \n    // take random samples on screen\n    for (float i = 0.; i < nr_samples; ++i)\n    {\n        prog += step_min + step_range * rand(P, i);\n        float r2 = rand(P, 2. * i + 99.);\n        r2 = 7.5 + 11.5 * r2;     \n        vec2 s = uv + ps * vec2(r2 * sin(prog), r2 * cos(prog));\n        acc += combine(P, N, s, w);\n    }\n\n    //return vec3(acc.w);\n    return acc.rgb / (0. + w); //(acc.xyz / w + light * 0.8);\n    //return vec3(light.r, acc.r * 2.0, 0);\n    //return light + acc;// / nr_samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;    \n    vec4 c02 = texture(iChannel0, uv);\n\n    vec3 N = c02.xyz;\n    vec3 P = position(uv, c02.w);\n    \n    vec3 light = texture(iChannel1, uv).rgb;\n    fragColor.rgb = light;\n    \n    //fragColor.rgb = position(uv);\n    \n    /*if (fract(iTime * 0.12) < 0.15)\n    {\n        fragColor.rgb = vec3(0.5) + 0.5 * texture(iChannel0, uv).rgb;     \n    }\n    else if (fract(iTime * 0.12) < 0.3)\n    {\n        fragColor.rgb = light;\n    }\n    else if (fract(iTime * 0.12) < 0.45)\n    {\n        fragColor.rgb = texture(iChannel2, uv).rgb;\n    }\n    else\n    {*/\n        fragColor.rgb = light + SSGI_resolve(fragCoord) * 0.7;\n    //}\n    \n\n    // todo: reconstuct pos from depth!\n   \n    //if (uv.x < 0.5)\n    //   fragColor.rgb = light; // SSGI_resolve(fragCoord);\n    //else\n    //   fragColor.rgb = light + SSGI_resolve(fragCoord);\n    //if (uv.x > 0.5)\n    //    fragColor.rgb = SSGI_resolve(fragCoord);\n    //else\n    //   fragColor.rgb = texture(iChannel2, uv).rgb;\n    //fragColor.rgb = light;\n    //fragColor.rgb = light + SSGI_resolve(fragCoord);\n}\n\n\n\n\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3yzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 159]], "test": "untested"}
{"id": "7lccRN", "name": "Logo Blender", "author": "Karp", "description": "I remake the Blender Logo. ", "tags": ["logo", "blender"], "likes": 2, "viewed": 131, "published": 3, "date": "1659356348", "time_retrieved": "2024-07-30T16:37:32.614895", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // UV manipulation\n    vec2 uv = fragCoord.xy - 0.5 * iResolution.xy;\n\tuv = 2.0 * uv.xy / iResolution.y; \n    uv *= 2.0;\n    \n    //Anim\n    //uv = RotateUV(uv, iTime * -150.0);\n    uv.y += cos(iTime* 0.5) * 0.25;\n    \n    //Parameter \n    float blurLvl = 100.0;\n    float lineThick = 0.2;\n    float lineLenght = 0.65;\n    float circleRatio = 0.6;\n    \n    // color\n    vec3 bgCol = vec3(.0902);\n    vec3 orange = Color255(219,125,40);\n    vec3 white = vec3(1);    \n    vec3 blue = Color255(19,175,240);\n    \n    //Draw\n    vec3 pixel = bgCol; \n    for(int i; i < 3; i++)\n    {\n        vec2 uvRot = RotateUV(uv,-45.0 + (45.0 *float(i)));\n        float line = sdBox(uvRot + vec2(lineLenght,lineThick-1.0), vec2(lineLenght,0.00));\n        pixel = mix(orange,pixel, Clamp01((line-lineThick)*blurLvl));\n    }\n    float centerCircle = sdCircle(uv + vec2(0.0,0.0), 0.0);\n    pixel = mix(orange,pixel, Clamp01((centerCircle - pow(circleRatio,0.0))*blurLvl));\n    pixel = mix(white,pixel, Clamp01((centerCircle - pow(circleRatio,1.0))*blurLvl));\n    pixel = mix(blue,pixel, Clamp01((centerCircle - pow(circleRatio,2.0))*blurLvl));\n    \n\tvec4 result = vec4(pixel, 1.0);\n\tfragColor = result;\n}", "image_inputs": [], "common_code": "#define PI 3.14159265359\nvec2 RotateUV(inout vec2 uv, float angle)\n{\t\n\tangle = angle * PI / 180.0;\n    return uv * mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\nvec3 Color255(int R, int G, int B)\n{\n    return vec3(float(R)/255.0, float(G)/255.0, float(B)/255.0);\n}\nfloat Clamp01( in float value)\n{\n    return clamp(value,0.0,1.0);\n}\nfloat sdCircle( vec2 point, float radius )\n{\n    return length(point) - radius;\n}\nfloat sdBox( in vec2 point, in vec2 box )\n{\n    vec2 dist = abs(point)-box;\n    return length(max(dist,0.0)) + min(max(dist.x,dist.y),0.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lccRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 1246]], "test": "untested"}
{"id": "stcyz4", "name": "Cluddy", "author": "isaul", "description": "blog glow cloud-like", "tags": ["blob", "glow"], "likes": 1, "viewed": 214, "published": 3, "date": "1659338315", "time_retrieved": "2024-07-30T16:37:33.435701", "image_code": "#define COUNT 6.\n#define COL1 vec3(188, 188, 188)/255.\n#define COL2 vec3(0, 5, 110)/255.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.y*.87)/iResolution.y;        \n    \n    float sum = 0.;  \n    float sumG = 0.;\n    \n    for(float i=0.; i<COUNT; i++){\n        float dir = mod(i, 2.)*2.-1.;        \n        float a = iTime * 0.4+ i + fract(sin(i* 78.233)* 43758.5453) * 3.1415;\n        float l = length(uv + dir* vec2( sin(a)/2., cos(a*.5)/4.) );\n    \t\n        sum+=.001/l;\n        sumG+=.0175/l;\n    }        \n    \n    sumG-=0.35;\n              \n    float fd = smoothstep(1., .5,  sum);\n    \n    vec3 col = mix(COL1, COL2, clamp(fd + sumG*3.95, 0., 0.5));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 200, 200, 803]], "test": "untested"}
{"id": "7lcyR4", "name": "Alien Toothpaste", "author": "isaacchurchill", "description": "I had the idea for this in my head and I managed to get it out.\nI could have done more with this but right now I'm tired and want to go to bed.", "tags": ["2d", "alien", "toothpaste"], "likes": 8, "viewed": 244, "published": 3, "date": "1659328360", "time_retrieved": "2024-07-30T16:37:34.201653", "image_code": "const float PI = 3.14159265;\n\nvec3 palette(float f)\n{\n    return vec3(\n        sin(f), sin(f + 2.0), sin(f + 4.0)\n    ) * 0.5 + 0.5;\n}\n\nvec3 palette2(float f)\n{\n    return vec3(\n        sin(f), sin(f + 1.0), sin(f + 2.0)\n    ) * 0.5 + 0.5;\n}\n\nfloat checker(vec2 uv)\n{\n    return abs(\n        (mod(uv.x, 1.0) > 0.5 ? 1.0 : 0.0)\n        - (mod(uv.y, 1.0) > 0.5 ? 1.0 : 0.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = fragCoord / iResolution.xy;\n    pos -= 0.5;\n    pos *= 2.0;\n    pos.x *= iResolution.x / iResolution.y;\n    \n    float ceil_y = cos((pos.x + iTime) * 4.0 * PI + PI) * -0.05 + 0.72;\n    float top_y = abs(mod((pos.x + iTime) * 4.0, 2.0) - 1.0) * 0.3 + 0.5;\n    float mid_y = sin((pos.x - iTime * 1.0) * PI * 2.0) * 0.3;\n    float bot_y = sin((pos.x + iTime * 0.15) * PI * 2.0) * 0.2 - 0.7;\n    \n    vec3 col = vec3(0.0);\n    col += vec3(1.0, 0.4, 0.0) / (1.0 + 30.0 * abs(top_y - pos.y));\n    col += vec3(1.0, 0.2, 0.4) / (1.0 + 30.0 * abs(mid_y - pos.y));\n    col += vec3(1.0, 0.0, 0.0) / (1.0 + 20.0 * abs(bot_y - pos.y));\n    \n    if (pos.y < ceil_y && pos.y > top_y) {\n        col = pow(col, vec3(0.5));\n    } else if (pos.y < top_y && pos.y > mid_y) {\n        col += palette(((pos.y - mid_y) / (top_y - mid_y)) * 10.0);\n    } else if (pos.y < mid_y && pos.y > bot_y) {\n        col += palette2(((pos.y - bot_y) / (mid_y - bot_y)) * 10.0);\n    } else if (pos.y < bot_y) {\n        col += checker(pos * 4.0) * (bot_y - pos.y);\n    }\n    \n    vec3 circle1_col = vec3(1.0, 1.0, 1.0);\n    vec3 circle2_col = vec3(1.0, 0.0, 0.0);\n    float inner_swelling = sin(iTime * PI) + 1.5;\n    float circle_de = length(vec2(mod((pos.x - 0.25 + iTime) + 0.5, 1.0) - 0.5, pos.y - 0.83));\n    float first_circle_de = abs(circle_de - 0.1);\n    float second_circle_de = abs(circle_de - 0.03 * inner_swelling);\n    col += circle1_col * clamp(pow(1.0 / (first_circle_de * 100.0 + 0.5), 2.0), 0.0, 1.0);\n    col += circle2_col * clamp(pow(1.0 / (second_circle_de * 100.0 + 0.5), 2.0), 0.0, 1.0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 53, 53, 134], [136, 136, 160, 160, 241], [243, 243, 267, 267, 375], [377, 377, 432, 432, 2058]], "test": "untested"}
{"id": "stdyRr", "name": "Rainbow Sand Playground", "author": "fenix", "description": "Will people like a shader that is interactive-only? What if it has a snazzy UI and content-aware anti-aliasing?\n* Dbl click on tool bar to: erase all, erase walls, change palette, select preset wall config\n* Shift to disable anti-aliasing", "tags": ["2d", "simulation", "particles", "antialias", "sand"], "likes": 14, "viewed": 329, "published": 3, "date": "1659316988", "time_retrieved": "2024-07-30T16:37:35.370528", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Particles are capable of falling or sliding down a slope greater than 45 degrees. \n//  Particle motion is performed within 2x2 cells. Buffer A's cells are in a natural\n//  alignment: cell 0, 0 includes the four cells (0 ... 1, 0 ... 1). Buffer B is offset\n//  by 1, 1 so it can advect particles across buffer A's cell boundaries. Buffers C and D\n//  are just copies of A and B respectively to get twice the integration speed.\n//\n//  v2: added auto-scroll based on deleting bottom row, removed horizontal black lines,\n//      mouse function determined by clicked region\n//  v3: better auto-scroll, new auto-spawner animation\n//\n//  \"playground\" v1: all the things\n//   * doubled pixels to increase activity at higher resolutions\n//   * added content-aware antialiasing to combat resultant blockiness\n//   * added walls\n//   * tool bar allowing selection of particlar colors, wall, and erase functions\n//   * selectable color palettes\n//   * noise added to particle color\n//   * double click detection\n//   * wall presets\n//   * \"sky\" instead of black void\n//\n// ---------------------------------------------------------------------------------------\n\n#define DISABLE_ANTIALIASING 0\n\nvec4 getPixel(ivec2 ifc)\n{\n    // to eliminate gaps as particles fall, combine neighboring pixels vertically for rendering\n    vec4 top = texelFetch(iChannel0, ivec2(ifc.x / 4, (ifc.y / 2) & ~1), 0);\n    vec4 bottom = texelFetch(iChannel0, ivec2(ifc.x / 4, (ifc.y / 2) | 1), 0);\n    return top == EMPTY ? bottom : top;\n}\n\n// are these colors different enough to apply anti-aliasing? (so that we blur only edges, not sand particles)\nfloat distantColor(vec4 a, vec4 b)\n{\n    // w component is sand type id\n    return floor(a.w) != floor(b.w) ? 1.0 : 0.0;\n}\n\nvec4 addSky(vec4 x, vec2 uv)\n{\n    if (x != EMPTY) return x;\n    \n    return mix(vec4(0.8, 0.8, 0.8, 1.0), vec4(0.0, 0.0, uv.y * 0.8, 1.0), sqrt(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x = fragCoord.x * (iResolution.x / (iResolution.x + 8.0)) + 4.0;\n    ivec2 ifc = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 origPixel = getPixel(ifc);\n    vec4 pixel = origPixel;\n    \n#if !DISABLE_ANTIALIASING\n    vec4 above = getPixel(ifc + ivec2(0, 2));\n    vec4 below = getPixel(ifc + ivec2(0, -2));\n    vec4 left = getPixel(ifc + ivec2(-4, 0));\n    vec4 right = getPixel(ifc + ivec2(4, 0));\n\n    float ulDist = distantColor(above, left);\n    float urDist = distantColor(above, right);\n    float llDist = distantColor(below, left);\n    float lrDist = distantColor(below, right);\n    float distAbove = distantColor(above, pixel);\n    float distBelow = distantColor(below, pixel);\n    float distLeft = distantColor(left, pixel);\n    float distRight = distantColor(right, pixel);\n#endif\n    \n    const float DIST_THRESHOLD = 0.1;\n    \n#if !DISABLE_ANTIALIASING\n    fragColor = addSky(pixel, uv);\n    vec2 subCell = mod(fragCoord, vec2(4.0, 4.0));\n    if (ulDist + lrDist < urDist + llDist && ulDist + lrDist < 0.5)\n    {\n        // we can create a smooth diagonal line from ll to ur\n        if (distAbove > distBelow && distAbove > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (4.0 + subCell.x - subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(above, left, 0.5), uv), addSky(pixel, uv), aa);\n        }\n        else if (distBelow > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (4.0 - subCell.x + subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(below, right, 0.5), uv), addSky(pixel, uv), aa);\n        }\n    }\n    else if (urDist + llDist < 0.5)\n    {\n        // we can create a smooth diagonal line from ul to lr\n        if (distAbove > distBelow && distAbove > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (8.0 - subCell.x - subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(above, right, 0.5), uv), addSky(pixel, uv), aa);\n        }\n        else if (distBelow > 0.1)\n        {\n            float aa = smoothstep(0.2, 0.8, (subCell.x + subCell.y) / 4.0);\n            fragColor = mix(addSky(mix(below, left, 0.5), uv), addSky(pixel, uv), aa);\n        }\n    }\n    else\n#endif\n    {\n        fragColor = addSky(pixel, uv);\n    }\n    \n    // (debug) disable antialiasing\n    bool disableAa = texelFetch(iChannel3,ivec2(KEY_SHIFT,0),0).x > 0.0;\n    if (disableAa) fragColor = addSky(pixel, uv);\n    \n    // draw UI\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float selection = state.z;\n    int pallette = int(state.y);\n    if (fragCoord.y > iResolution.y * 0.9)\n    {\n        float u = fragCoord.x / iResolution.x;\n        u *= SELECT_CHOICES;\n        \n        // anti-aliasing for UI (also creates curve for selection)\n        float alpha = clamp(fragCoord.y - (iResolution.y * (0.95 - smoothstep(0.0, 0.2, abs(u - round(u))) * 0.025)), 0.0, 1.0);\n        if (disableAa) alpha = floor(alpha);\n        \n        if (fragCoord.y > iResolution.y * 0.95 ||\n            (floor(u) == selection && alpha > 0.0))\n        {\n            vec4 uiColor;\n            if (u < S_RAINBOW)\n            {\n                // specific colors\n                uiColor = rainbow(int(u), pallette);\n            }\n            else if (u < S_WALL)\n            {\n                // color cycle (rainbow)\n                uiColor = colorByFrame(int(fragCoord.x / (iResolution.x * 0.02) * float(COLOR_CHANGE_FRAMES)), pallette);\n            }\n            else if (u < S_ERASE)\n            {\n                // walls\n                uiColor = vec4(1);\n            }\n            else\n            {\n                // eraser\n                uiColor = vec4(0);\n            }\n            fragColor = mix(fragColor, uiColor, alpha);\n        }\n    }    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(0));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// options\nconst float WALL_SIZE = 0.0025;\nconst float SPAWN_SIZE = 0.01;\nconst int COLOR_CHANGE_FRAMES = 200;\n\n// tool bar selections\n#define S_RAINBOW 7.0\n#define S_WALL 8.0\n#define S_ERASE 9.0\n#define SELECT_CHOICES 10.0\n\n// special pixel values\nconst vec4 EMPTY = vec4(0);\nconst vec4 WALL = vec4(1);\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nconst int NUM_PALLETTES = 3;\n\nvec4 rainbow(int i, int palette)\n{\n    switch(palette)\n    {\n        case 0: // actual rainbow\n            switch(i)\n            {\n                case 0:\n                    return vec4(1.0, 0.0, 0.0, 2.0);\n                case 1:\n                    return vec4(1.0, 0.5, 0.0, 3.0);\n                case 2:\n                    return vec4(1.0, 1.0, 0.0, 4.0);\n                case 3:\n                    return vec4(0.0, 1.0, 0.0, 5.0);\n                case 4:\n                    return vec4(0.0, 0.0, 1.0, 6.0);\n                case 5:\n                    return vec4(0.25, 0.0, 0.5, 7.0);\n                case 6:\n                    return vec4(0.5, 0.0, 0.7, 8.0);\n            }\n        case 1: // grey scale\n            switch(i)\n            {\n                case 0:\n                    return vec4(0.1, 0.1, 0.1, 9.0);\n                case 1:\n                    return vec4(0.25, 0.25, 0.25, 10.0);\n                case 2:\n                    return vec4(0.4, 0.4, 0.4, 11.0);\n                case 3:\n                    return vec4(0.55, 0.55, 0.55, 12.0);\n                case 4:\n                    return vec4(0.7, 0.7, 0.7, 13.0);\n                case 5:\n                    return vec4(0.85, 0.85, 0.85, 14.0);\n                case 6:\n                    return vec4(0.99, 0.99, 0.99, 15.0);\n            }\n        case 2: // natural colors (draw a mountain scene!)\n            switch(i)\n            {\n                case 0:\n                    return vec4(222.0 / 256.0, 204.0 / 256.0, 166.0 / 256.0, 16.0);\n                case 1:\n                    return vec4(164.0 / 256.0, 167.0 / 256.0, 38.0 / 256.0, 17.0);\n                case 2:\n                    return vec4(25.0 / 256.0, 121.0 / 256.0, 39.0 / 256.0, 18.0);\n                case 3:\n                    return vec4(100.0 / 256.0, 100.0 / 256.0, 110.0 / 256.0, 19.0);\n                case 4:\n                    return vec4(112.0 / 256.0, 100.0 / 256.0, 84.0 / 256.0, 20.0);\n                case 5:\n                    return vec4(148.0 / 256.0, 91.0 / 256.0, 20.0 / 256.0, 21.0);\n                case 6:\n                    return vec4(56.0 / 256.0, 29.0 / 256.0, 10.0 / 256.0, 22.0);\n            }\n    }    \n}\n\nvec4 colorByFrame(int frame, int pallette)\n{   \n    // compute the current color for the color-cycling rainbow spawn selection\n    int colorIndex = (frame / COLOR_CHANGE_FRAMES) % 7;\n    int nextColorIndex = (colorIndex + 1) % 7;\n    int blendIndex = frame % COLOR_CHANGE_FRAMES;\n    float blend = float(blendIndex) / float(COLOR_CHANGE_FRAMES);\n    return mix(rainbow(colorIndex, pallette), rainbow(nextColorIndex, pallette), blend);\n}\n\nfloat hash( int k )\n{\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        // line was very short anyway\n        closest = oldPos;\n    }\n\n    // distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return length2(closestDelta);\n}\n\nfloat dist2hopper(vec2 fragCoord, vec3 res, vec2 pos, vec2 dim, float opening)\n{\n    float dist2 =      linePointDist2(vec2(pos.x - dim.x, pos.y) * res.xy, vec2(pos.x - dim.x, pos.y + dim.y) * res.xy, fragCoord, res);\n    dist2 = min(dist2, linePointDist2(vec2(pos.x + dim.x, pos.y) * res.xy, vec2(pos.x + dim.x, pos.y + dim.y) * res.xy, fragCoord, res));\n    dist2 = min(dist2, linePointDist2(vec2(pos.x + dim.x, pos.y) * res.xy, vec2(pos.x + opening, pos.y) * res.xy, fragCoord, res));\n    dist2 = min(dist2, linePointDist2(vec2(pos.x - dim.x, pos.y) * res.xy, vec2(pos.x - opening, pos.y) * res.xy, fragCoord, res));\n    return dist2;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id( x,y)   floor(x)+100.*floor(y)\n\n// from maze 2 by FabriceNeyret2\n// https://www.shadertoy.com/view/4sSXWR\nfloat maze(vec2 u) {\n    float n = id(u.x,u.y);  u = fract(u);\n    return 1.-smoothstep(.1,.15,((rnd(n)>.5)?u.x:u.y));\n}\n\n// from Exercise: basic truchet tiling by endymion\n// https://www.shadertoy.com/view/WlcfWf\nfloat truchet(in vec3 res, in int frame, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * res.xy) / res.y;\n    \n    // Zoom;\n    float scale = 10.0;\n    uv *= scale; \n    \n    // Tiles from -.5 to .5\n    vec2 gv = fract(uv) - .5;\n    \n    // Rotate\n    vec2 id = floor(uv);\n    float r = hash(int(id.x + 37.5 * id.y + 9.0 * float(frame)));\n    if (r < .5) gv.x *= -1.;\n    \n    // Curves\n    float sgn = sign(gv.x + gv.y);\n    sgn = sgn == 0. ? 1. : sgn;\n    float dist = abs(abs(gv.x + gv.y) - .5);\n    dist = length(gv - sgn * .5) - .5;\n    float width = 0.002 * scale;\n    return smoothstep(scale/res.y, -scale/res.y, abs(dist) - width);\n}\n\nvoid handleDoubleClick(float selection, vec2 fragCoord, vec3 res, int iFrame, inout vec4 fragColor)\n{\n    bool shouldBeWall = false;\n    float dist2 = 1e6;\n    \n    // wall scenes you can select by double clicking on the specific color tabs\n    switch(int(selection))\n    {\n        case 0:\n            // big V\n            fragCoord.x = abs(fragCoord.x - res.x * 0.125) + res.x * 0.125;\n            dist2 = linePointDist2(vec2(0.13, 0.1) * res.xy, vec2(0.215, 0.4) * res.xy, fragCoord, res);\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 1:\n            // cascading hoppers\n            fragCoord.x = res.x * 0.125 - abs(fragCoord.x - res.x * 0.125);\n            dist2 =            dist2hopper(fragCoord, res, vec2(0.035, 0.35), vec2(0.025, 0.05), 0.003);\n            dist2 = min(dist2, dist2hopper(fragCoord, res, vec2(0.055, 0.25), vec2(0.025, 0.05), 0.003));\n            dist2 = min(dist2, dist2hopper(fragCoord, res, vec2(0.075, 0.15), vec2(0.025, 0.05), 0.003));\n            dist2 = min(dist2, dist2hopper(fragCoord, res, vec2(0.125, 0.05), vec2(0.06, 0.05), 0.003));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 2:\n            // horizontal lines\n            const float HEIGHT = 0.09;\n            fragCoord.x = abs(fragCoord.x - res.x * 0.125) + res.x * 0.125;\n            fragCoord.y = mod(fragCoord.y, res.x * HEIGHT * 1.25);\n            dist2 = linePointDist2(vec2(0.1, HEIGHT) * res.xy, vec2(0.15, HEIGHT) * res.xy, fragCoord, res);\n            dist2 = min(dist2, linePointDist2(vec2(0.175, HEIGHT) * res.xy, vec2(0.225, HEIGHT) * res.xy, fragCoord, res));\n            dist2 = min(dist2, linePointDist2(vec2(0.2, HEIGHT + HEIGHT) * res.xy, vec2(0.1375, HEIGHT + HEIGHT) * res.xy, fragCoord, res));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n\n        case 3:\n            // slopes\n            fragCoord.x = abs(fragCoord.x - res.x * 0.125) + res.x * 0.125;\n            fragCoord.y = mod(fragCoord.y, res.x * HEIGHT * 1.25);\n            dist2 = linePointDist2(vec2(0.125, HEIGHT * 1.2) * res.xy, vec2(0.15, HEIGHT) * res.xy, fragCoord, res);\n            dist2 = min(dist2, linePointDist2(vec2(0.175, HEIGHT) * res.xy, vec2(0.225, HEIGHT * 1.2) * res.xy, fragCoord, res));\n            dist2 = min(dist2, linePointDist2(vec2(0.2, HEIGHT * 2.2) * res.xy, vec2(0.1375, HEIGHT * 2.0) * res.xy, fragCoord, res));\n            shouldBeWall = dist2 < square(res.x * WALL_SIZE);\n\n            break;\n            \n        case 4:\n            // bowls\n            fragCoord.x = abs(fragCoord.x - res.x * 0.125) + res.x * 0.125;\n            fragCoord.y = res.y * 0.125 - fragCoord.y;\n            const float theta = 2.0;\n            const vec2 sc = vec2(sin(theta), cos(theta));\n            float dist = sdArc((fragCoord / res.x) - vec2(0.2, 0.0), sc, 0.02, 0.0);\n            dist = min(dist, sdArc((fragCoord / res.x) - vec2(0.15, -0.14), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fragCoord / res.x) - vec2(0.175, -0.07), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fragCoord / res.x) - vec2(0.2, -0.14), sc, 0.02, 0.0));\n            dist = min(dist, sdArc((fragCoord / res.x) - vec2(0.15, 0.0), sc, 0.02, 0.0));\n            shouldBeWall = dist < WALL_SIZE;\n\n            break;\n\n        case 5:\n            // maze       \n            fragCoord.x += mod(float(iFrame % 1000) * 10.0, res.x * 10.0);\n            const float MAZE_SCALE = 1.6;\n            dist = maze(MAZE_SCALE * vec2(square(res.x / res.y), 1.0)*fragCoord/(res.xy * 0.125));\n            shouldBeWall = dist > 0.060 * res.x * WALL_SIZE;\n\n            break;\n            \n        case 6:\n            // truchet\n            fragCoord.x *= res.x / res.y;\n            dist = truchet(res, iFrame, fragCoord);\n            shouldBeWall = dist > 0.060 * res.x * WALL_SIZE;\n\n            break;\n    }\n\n    if (shouldBeWall)\n        fragColor = WALL;\n    else if (fragColor == WALL)\n        fragColor = EMPTY;\n}\n\nvoid spawnSand(int frame, vec2 fragCoord, vec3 res, vec2 oldMouse, vec4 newMouse, float selection, int pallette, inout vec4 fragColor)\n{\n    if (newMouse.z > 0.0 && newMouse.y < res.y * 0.9)\n    {\n        // compute the distance to the line segment from oldMouse to newMouse\n        // using a capsule instead of a sphere prevents gaps when the mouse is moved quickly\n        vec2 spawnBegin = oldMouse / vec2(4.0, 2.0);\n        vec2 spawnEnd = newMouse.xy / vec2(4.0, 2.0);\n        if (newMouse.w > 0.0) spawnBegin = spawnEnd;\n        float dist2 = linePointDist2(spawnBegin, spawnEnd, fragCoord, res);\n        \n        if (selection == S_WALL)\n        {\n            if (dist2 < square(res.x * WALL_SIZE))\n            {\n                // wall selection (white)\n                fragColor = WALL;\n            }\n        }\n        else if (fragColor == EMPTY && dist2 < square(res.x * SPAWN_SIZE))\n        {\n            float noise = (0.55 + 0.45 * hash(frame * int(fragCoord.x) * int(fragCoord.y)));\n            if (selection < S_RAINBOW)\n            {\n                // specific color selection\n                fragColor = rainbow(int(selection), pallette) * vec4(noise, noise, noise, 1.0);\n            }\n            else\n            {\n                // rainbow selection\n                fragColor = colorByFrame(frame, pallette) * vec4(noise, noise, noise, 1.0);\n            }\n        }\n    }\n}\n\nvoid removeSand(int frame, vec2 fragCoord, vec3 res, vec2 oldMouse, vec4 newMouse, inout vec4 fragColor)\n{\n    if (newMouse.z > 0.0)\n    {\n        vec2 removeBegin = oldMouse / vec2(4.0, 2.0);\n        vec2 removeEnd = newMouse.xy / vec2(4.0, 2.0);\n        if (newMouse.w > 0.0) removeBegin = removeEnd;\n        float dist2 = linePointDist2(removeBegin, removeEnd, fragCoord, res);\n \n        if (dist2 < square(res.x * 0.01))\n        {\n            // erase selection (black)\n            fragColor = EMPTY;\n        }\n    }\n}\n\nvoid evolveByCells(sampler2D sampler, int frame, ivec2 coord, ivec2 offset, ivec2 ires, out vec4 fragColor)\n{\n    // compute coordinates for the four pixels in our cell\n    ivec2 cellCoord = (coord - offset) / 2;\n    ivec2 llCell = cellCoord * 2 + offset;\n    ivec2 lrCell = llCell + ivec2(1, 0);\n    ivec2 ulCell = llCell + ivec2(0, 1);\n    ivec2 urCell = llCell + ivec2(1, 1);\n   \n    if (!all(lessThan(urCell, ivec2(ires.x / 4, ires.y / 2))) ||\n        (offset != ivec2(0) && (coord.x == 0 || coord.y == 0)))\n    {\n        // don't move particles at the bottom of the screen or off the edge\n        fragColor = texelFetch(sampler, coord, 0);\n        return;\n    }\n    \n    // fetch the members of our cell\n    vec4 ulValue = texelFetch(sampler, ulCell, 0);\n    vec4 urValue = texelFetch(sampler, urCell, 0);\n    vec4 llValue = texelFetch(sampler, llCell, 0);\n    vec4 lrValue = texelFetch(sampler, lrCell, 0);\n    \n    // figure out which are empty\n    bvec4 cell = bvec4(ulValue != EMPTY, urValue != EMPTY, llValue != EMPTY, lrValue != EMPTY);\n    \n    // try to match a pattern that should fall\n    if ((cell == bvec4(true,  false,\n                      false, false) ||\n        cell == bvec4(true,  false,\n                      false, true)||\n        cell == bvec4(true,  true,\n                      false, true)) && ulValue != WALL)\n    {\n        // left side falls\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if ((cell == bvec4(false, true,\n                           false, false) ||\n             cell == bvec4(false, true,\n                           true, false) ||\n             cell == bvec4(true, true,\n                           true, false)) && urValue != WALL)\n    {\n        // right side falls\n        lrValue = urValue;\n        urValue = EMPTY;\n    }\n    else if (cell == bvec4(true, true,\n                           false, false))\n    {\n        // both sides fall\n        if (urValue != WALL)\n        {\n            lrValue = urValue;\n            urValue = EMPTY;\n        }\n        if (ulValue != WALL)\n        {\n            llValue = ulValue;\n            ulValue = EMPTY;\n        }\n    }\n    else if ((cell == bvec4(true, false,\n                           true, false)) && ulValue != WALL)\n    {\n        // left side collapses\n        lrValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if ((cell == bvec4(false, true,\n                           false, true)) && urValue != WALL)\n    {\n        // right side collapses\n        llValue = urValue;\n        urValue = EMPTY;\n    }\n\n    // record result\n    if (coord == llCell)\n    {\n        fragColor = llValue;\n    }\n    else if (coord == lrCell)\n    {\n        fragColor = lrValue;\n    }\n    else if (coord == ulCell)\n    {\n        fragColor = ulValue;\n    }\n    else if (coord == urCell)\n    {\n        fragColor = urValue;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(keySampler,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(keySampler,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvec4 updateState(sampler2D sandSampler, int iFrame, vec4 iMouse, vec3 iResolution)\n{\n    const float DOUBLE_CLICK_FRAMES = 40.0;\n    vec4 oldState = texelFetch(sandSampler, ivec2(0), 0);\n    if (iFrame == 0) oldState = vec4(0.0, 0.0, S_RAINBOW, 1.0); // init state\n    int palette = int(oldState.y);\n    float selection = oldState.z;\n    float clickState = oldState.w;\n    if (iMouse.z > 0.0 && iMouse.y > iResolution.y * 0.9)\n    {\n        float u = iMouse.x / iResolution.x;\n        float newSelection = floor(u * SELECT_CHOICES);\n\n        if (iMouse.w > 0.0)\n        {\n            if (clickState < 0.0 && clickState > -DOUBLE_CLICK_FRAMES && newSelection == selection)\n            {\n                // double click detected\n                clickState = 0.0;\n                \n                if (newSelection == S_RAINBOW)\n                {\n                    // change palette\n                    palette = (palette + 1) % NUM_PALLETTES;\n                }\n            }\n            else\n            {\n                clickState = 1.0;\n            }\n        }\n        else\n        {\n            // count frames held down\n            ++clickState;\n        }\n\n        selection = newSelection;\n    }\n    else\n    {\n        if (clickState < 0.0)\n        {\n            // count frames released...\n            --clickState;\n        }\n        else if (clickState > 1.0 && clickState < 1.0 + DOUBLE_CLICK_FRAMES)\n        {\n            // ...but only if it was held down only a short time.\n            clickState = -1.0;\n        }\n    }\n    \n    return vec4(iMouse.x * iResolution.y + iMouse.y, float(palette), selection, clickState);\n}\n\nvoid bufferMainInternal( out vec4 fragColor, in vec2 fragCoord, in ivec2 offset, in sampler2D sandSampler, in sampler2D keySampler, int iFrame, vec3 iResolution, vec4 iMouse)\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    // handle persistent state\n    if (ifc == ivec2(0, 0))\n    {\n        fragColor = updateState(sandSampler, iFrame, iMouse, iResolution);\n        return;\n    }\n    \n    vec4 state = texelFetch(sandSampler, ivec2(0), 0);\n    int pallette = int(state.y);\n    float selection = state.z;\n    bool doubleClick = state.w == 0.0;\n\n    // only use a quarter of the screen for simulation\n    if (fragCoord.x > iResolution.x * 0.25 || fragCoord.y > iResolution.y * 0.5)\n    {\n        return;\n    }\n    \n    // init scene\n    if (iFrame == 0 ||\n        keyDown(KEY_SPACE) ||\n        (doubleClick && selection == S_ERASE))\n    {\n        fragColor = EMPTY;\n        \n        return;\n    }\n\n    // integration step\n    evolveByCells(sandSampler, iFrame, ifc, offset, ivec2(iResolution.xy), fragColor);\n    \n    // user interaction\n    float oldEncodedMouse = state.x;\n    vec2 oldMouse = vec2(oldEncodedMouse / iResolution.y, mod(oldEncodedMouse, iResolution.y));\n    if (selection == S_ERASE)\n        removeSand(iFrame, fragCoord, iResolution, oldMouse, iMouse, fragColor);\n    else\n        spawnSand(iFrame, fragCoord, iResolution, oldMouse, iMouse, selection, pallette, fragColor);\n    \n    // perform double click action if requested\n    if (doubleClick && selection != S_RAINBOW) handleDoubleClick(selection, fragCoord, iResolution, iFrame, fragColor);\n}\n\n#define bufferMain(X, Y, Z) bufferMainInternal(X, Y, Z, iChannel0, iChannel3, iFrame, iResolution, iMouse)", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(1));\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(0));\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bufferMain(fragColor, fragCoord, ivec2(1));\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdyRr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1395, 1395, 1421, 1517, 1715], [1717, 1827, 1863, 1898, 1949], [1951, 1951, 1981, 1981, 2105]], "test": "untested"}
