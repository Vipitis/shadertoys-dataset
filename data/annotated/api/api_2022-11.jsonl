{"id": "ds2SzR", "name": "Yet Another Graph Plotter", "author": "mla", "description": "Yet another graph plotter framework, with some examples. GRAPH2 is a bit silly, but seems to work.\n\nI believe the macros are all bracketed correctly but may well be wrong (_XXX macros are not intended to be used directly).", "tags": ["graph", "plotter"], "likes": 5, "viewed": 213, "published": 3, "date": "1669846657", "time_retrieved": "2024-07-30T16:15:56.680815", "image_code": "#define GRAPH(p,f) _GRAPH((p).x,(p).y,f))\n#define GRAPH2(p,e) _GRAPH2((p).x,(p).y,(e))\n#define _GRAPH(x,y,f) (gdist(y,(x+px)-(x-px),(f((x-px))),(f(x)),(f((x+px))))\n#define _GRAPH2(x,y,e) (gdist(y,(x+px)-(x-px),_EVAL(x-px,e),_EVAL(x,e),_EVAL(x+px,e)))\n#define _EVAL(_x,e) (x = (_x),e)\nfloat gdist(float y, float dx, float f0, float f1, float f2) {\n  return abs(y-f1)/length(vec2((f2-f0)/dx,1.0));\n}\nfloat f(float x) {\n    x += 0.0001;\n    x /= exp(17.0*(0.5-0.5*cos(0.5*iTime))-2.0); // Zoom in\n    return sin(x)/x-0.5; \n}\n#define g(x) sin(x+0.618*iTime)*cos(4.0*x+iTime)\n#define h x = mod(4.0*x+iTime+2.0*sin(0.5*iTime),2.0), min(x,2.0-x)-0.5\n#define smoothstep(x,y,z) clamp(((z)-(x))/((y)-(x)), 0.0, 1.0) // @spalmer's suggestion - thanks!\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = fwidth(p.x),x;\n    vec3 col = vec3(0);\n    col = mix(vec3(1,0,0),col,smoothstep(0.0,3.0*px,GRAPH(p,f)-0.01));\n    col = mix(vec3(1,1,0),col,smoothstep(0.0,1.5*px,GRAPH(p,g)));\n    col = mix(vec3(0,1,0),col,smoothstep(0.0,px,GRAPH2(p,h)));\n    col = mix(vec3(0,0,1),col,smoothstep(0.0,px,GRAPH2(p,sin(4.0*cos(x)+iTime))-0.01));\n    col *= 0.8;\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2SzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 346, 346, 397], [398, 398, 416, 416, 521], [741, 741, 793, 793, 1276]], "test": "untested"}
{"id": "ddj3RW", "name": "Raymarched Lake", "author": "fishy", "description": "Phong distribution for the specular highlights. Now with ACES tonemapping from https://www.shadertoy.com/view/XsGfWV. Mouse, WASD, Space and Shift to move\nSkybox reflections! Sky color made by @nimitz", "tags": ["shadow", "raymarcher", "penumbra", "diffuse"], "likes": 9, "viewed": 275, "published": 3, "date": "1669839691", "time_retrieved": "2024-07-30T16:15:57.628282", "image_code": "#define PI 3.1415926535\n\n#define AMBIENT 0.01\n#define SHADOW_STRENGTH 0.9\n#define SHADOW_K 16.0\n#define AO_DIST 0.02\n#define AO_STRENGTH 0.3\n\n#define FOG_DIST 100.0\n\n#define FRESNEL_IOR 0.9\n#define FRESNEL_BASE 0.0\n\n\n//PROJECTION MODE (not intended to be physically accurate)\n// 0: Rectilinear lens\n// 1: Fisheye lens\n#define PROJECTION 1\n\n//54 seems to be a good value... 360 is also fun.\n#define FOV_X radians(54.)\n#define FOV_Y radians(54.)\n\n#define CAM_FAR     100.\n#define CAM_STEP    500\n#define MARCH_FAC   1.0\n#define SHADOW_FAR  50.\n#define SHADOW_STEP 1\n\nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float reflectivity;\n    float emission;\n    int matOverride;\n};\n\nvec3 evaluateMatOverride(int i, vec3 p, vec3 n, vec3 vDir, material mat, out vec3 normalMap)\n{\n    vec3 c;\n    normalMap = vec3(0.0);\n    switch (i)\n    {\n        case 0:\n            c = texture(iChannel2, p.xy*0.01*vec2(1.0, 5.0)).rgb;\n            break;\n        case 1:\n            c = texture(iChannel3, vec2(p.x+p.y, p.z)).rgb;\n            break;\n    }\n    return c;\n}\n\n\n\n\nfloat calcSpecular(vec3 e, vec3 n, vec3 l, float p)\n{\n    return pow(clamp(dot(l, reflect(e, n)), 0.0, 1.0), p);\n}\n\nfloat join(inout float a, float b, material bm, inout material m)\n{\n    if(a < b)\n    {\n        return a;\n    }\n    else\n    {\n        m = bm;\n        return b;\n    }\n    \n}\n\n\nfloat sjoin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat sdPlane(vec3 p, float y)\n{\n    return (p.y - y);\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n    return length(p - pos) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 bPos, vec3 b)\n{\n    return sdBox(p - bPos, b);\n}\nfloat sdCross( in vec3 p )\n{\n    float da = sdBox(p.xyz,vec3(100000.0,1.0,1.0));\n    float db = sdBox(p.yzx,vec3(1.0,100000.0,1.0));\n    float dc = sdBox(p.zxy,vec3(1.0,1.0,100000.0));\n    return min(da,min(db,dc));\n}\n\nfloat sdMenger(vec3 p)\n{\n    float d = sdBox(p,vec3(1.0));\n\n    float s = 1.0;\n    \n    for( int m=0; m<4; m++ )\n    {\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = 1.0 - 3.0*abs(a);\n\n        float c = sdCross(r)/s;\n        d = max(d,c);\n    }\n\n    return d;\n}\n\nfloat oceanHeight(in vec2 p, float o)\n{\n    float h = 0.0;\n    for(float i = 0.; i < 5.; i++)\n    {\n        p.xy = rotZ(p.xyx, hash11(float(i))*1.0).xy;\n        float fac = exp(-i*0.8);\n        h += sin(mod((p.x+o) / fac, 6.28))*fac;\n    }\n    return h;\n}\n\n#define join(a, m1, m2) join(dist, a, m1, m2)\n\nfloat sceneDist(vec3 p, out material m)\n{\n    p.y -= 0.3;\n    m = material(vec3(0.0, 0.0, 1.0), 1.0, 1.0, 0.0, 0);\n    float dist = CAM_FAR;\n    //\n    //dist = join(sdSphere(p, vec3(-0.3, sin(iTime)*0.1, 2.0), 0.2),\n    //            material(vec3(0.0, 0.5, 1.0), 8.0, 0.0, 2), m);\n    //\n    //dist = join(sdBox(p, vec3(0.0,-0.3, 2.0), vec3(0.5, 0.06, 0.5)) - 0.02,\n    //            material(vec3(1.0, 0.0, 0.0), 8.0, 1.0, -1), m);\n    //\n    //dist = join(sdMenger(p / 0.5 - vec3(0.5, 0.4, 8.0)) * 0.5,\n    //            material(vec3(1.0, 1.0, 1.0), 8.0, 1.0, 0), m);\n    dist = join(sdPlane(p, -0.5+oceanHeight(p.xz*0.5, iTime)*0.05),\n                material(vec3(0.1, 0.3, 0.9), 1.0, 1.0, 0.0, -1), m);\n    \n    dist = join(sdPlane(p, -0.9+fbm(p.xz*0.05, 4.0, 4.0, 0.0)*15.*smoothstep(90., 100., length(p.xz))),\n                material(vec3(0.1, 0.3, 0.1), 0.01, 0.0, 0.0, 0), m);\n    \n    \n    return dist;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p) by iq\n{\n    material m;\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h, m);\n    }\n    return normalize(n);\n}\n\nfloat calcAO(vec3 p, float dist)\n{\n    material m;\n    return 1.0 - sceneDist(p + dist*calcNormal(p), m) / dist;\n}\n\nvoid march(vec3 dir, inout vec3 p, int maxSteps, float maxDist, float minDist, out bool hit, out float depth, out vec3 normal, out material m, out int iter)\n{\n    vec3 oldP = p;\n    depth = 0.0;\n    int i;\n    for(i = 0; i < maxSteps && depth < maxDist && !hit; i++)\n    {\n        float sd = sceneDist(p+depth*dir, m);\n        depth += sd*MARCH_FAC;\n\n        hit = sd < minDist;\n    }\n    \n    p = p+depth*dir;\n    normal = calcNormal(p);\n    iter = i;\n}\n\nvoid marchShadow(vec3 dir, vec3 p, int maxSteps, float maxDist, float minDist, out float inShadow, float k)\n{\n    vec3 oldP = p;\n    float dist = 0.001;\n    float totalDist = dist;\n\n    p += dist*dir;\n    inShadow = 1.0;\n    material m = material(vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0);\n    for(int i = 0; totalDist < maxDist && i < maxSteps; i++)\n    {\n        dist = sceneDist(p, m);\n        totalDist += dist;\n\n        if(dist < minDist)\n        {\n            inShadow = 1.0;\n            return;\n        }\n        \n        p += dist*dir;\n        inShadow = min(inShadow, k*dist/totalDist);\n    }\n    inShadow = 1.0-inShadow;\n}\n\nfloat vignette(vec2 p, vec2 k)\n{\n    vec2 a = 1.-(2.*pow(abs(0.5-p), vec2(k)));\n    return a.y+a.x-1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec4 c = texture(iChannel0, vec2(0.0));\n    \n    vec2 empty = vec2(1.0, 0.0);\n    \n    vec3 eyeDir;\n    \n    switch(PROJECTION)\n    {\n\n    case(0):\n        eyeDir = normalize(vec3(uv * vec2(FOV_X, FOV_Y), 1.0));\n        eyeDir = rotX(eyeDir, -c.w);\n        eyeDir = rotY(eyeDir, -c.z);\n        break;\n    case(1):\n        eyeDir = empty.yyx;\n        eyeDir = rotX(eyeDir, -c.w-(uv.y*FOV_Y));\n        eyeDir = rotY(eyeDir, -c.z-(uv.x*FOV_X));\n    }\n    \n    vec3 eyePos = vec3(c.y, 0.9, c.x);\n    \n    vec3 lightingDir = normalize(vec3(0.0, 1.0, 1.0));\n    lightingDir = rotX(vec3(0.0, 0.0, 1.0), -3.341+mod(iTime*0.25, 3.6415));\n    if(iMouse.z > 0.0) { lightingDir = rotX(vec3(0.0, 0.0, 1.0), -iMouse.y/iResolution.y*3.0+0.5); }\n    \n\n    \n    bool hit = false;\n    float depth = 0.0;\n    vec3 normal = vec3(0.0);\n    vec3 normalMod = vec3(0.0);\n    material hitMat;\n    int cost;\n    march(eyeDir, eyePos, CAM_STEP, CAM_FAR, 0.05, hit, depth, normal, hitMat, cost);\n    float ao = calcAO(eyePos, AO_DIST);\n    if(hitMat.matOverride > -1)\n    {\n        hitMat.baseColor = evaluateMatOverride(hitMat.matOverride, eyePos, normal, eyeDir, hitMat, normalMod);\n        normal += normalMod;\n    }\n    float fresnel = FRESNEL_BASE+pow(abs(dot(normalize(eyeDir), normal)), FRESNEL_IOR)*(1.-FRESNEL_BASE);\n    hitMat.baseColor = mix(hitMat.baseColor, mix(skyTex(reflect(eyeDir, normal), lightingDir).rgb, hitMat.baseColor, fresnel), hitMat.reflectivity);\n    \n    float inShadow = 0.0;\n    marchShadow(lightingDir, eyePos, SHADOW_STEP, SHADOW_FAR, 0.0001, inShadow, SHADOW_K);\n    \n    vec3 fogColor = skyTex(vec3(eyeDir.xy, .0), lightingDir).rgb;\n    float skyBrightness = maxcomp(fogColor);\n    \n    float lighting = max(0.0, dot(normal, lightingDir)*skyBrightness);\n    float specular = calcSpecular(eyeDir, normal, lightingDir, 8.0 * hitMat.roughness);\n    inShadow *= float(hit);\n    inShadow = mix(0.0, inShadow, SHADOW_STRENGTH);\n\n\n    vec3 color = (((lighting + specular)*skyBrightness) * hitMat.baseColor) * (1.0-inShadow);\n\n    color = mix(color, hitMat.baseColor, AMBIENT);\n    color *= 1.0 - ao*AO_STRENGTH;\n    \n    color = mix(color, fogColor, pow(min(1.0, depth / FOG_DIST), 1.3));\n    color = hit? color : skyTex(eyeDir, lightingDir).rgb;\n    color = aces_tonemap(sqrt(color))*mix(vignette(fragCoord/iResolution.xy, vec2(2.5)), 1., 0.3);\n    \n    float fr = 1.-step(0., print((uv-vec2(0.474, 0.25))*9., iFrameRate, 0.3));\n\n    //fragColor = vec4(vec3(smoothstep(0.15, 0.099, ao)),1.0);\n    fragColor = vec4(color+fr,1.0);\n    //fragColor = vec4(float(cost)*0.01*(1.-float(hit)));\n    //fragColor = vec4(specular);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MOVE_SPEED 10.\n\nconst int keyW = 87;\nconst int keyA = 65;\nconst int keyS = 83;\nconst int keyD = 68;\nconst int keyLA = 37;\nconst int keyRA = 39;\nconst int keyUA = 38;\nconst int keyDA = 40;\n\nconst int keySpace = 16;\nconst int keyShift = 32;\n\n\n\nfloat keyPressed(int keyCode)\n{\n    return texelFetch(iChannel0, ivec2(keyCode, 0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 keyVec = texture(iChannel1, uv);\n    \n    if(iFrame == 0)\n    {\n        keyVec = vec4(0.0);\n    }\n    \n    keyVec.xy += rotMat(-keyVec.z)*vec2(keyPressed(keyW) - keyPressed(keyS), keyPressed(keyD) - keyPressed(keyA)) * iTimeDelta * MOVE_SPEED;\n    keyVec.zw += vec2(keyPressed(keyRA) - keyPressed(keyLA), keyPressed(keyUA) - keyPressed(keyDA)) * iTimeDelta;\n    \n    fragColor = keyVec;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Sky color made by @nimitz from https://www.shadertoy.com/view/wl3czN\n#define atmoDepth 8228.\n#define earthRadius 6371000.\n#define mieDepth 1800\n#define sunColor vec3( .95, 0.96, 1.2 )\n#define ozoneHeight 30000.\n#define ozoneCoefficient (vec3(3.426, 8.298, .356) * 6e-5 / 100.)\n#define mieCoefficient 16e-6 // adjust for foggier look\n\n// custom\n#define rayleighCoefficient vec3(0.0000056  , 0.0000125 , 0.000029)\n\nvec3 getThickness(vec3 rd)\n{\n    const vec4 cns = earthRadius + \n        \t\t\tvec4(atmoDepth, mieDepth, ozoneHeight, ozoneHeight + atmoDepth);\n    const float r2 = earthRadius * earthRadius;\n    float b = -rd.y*earthRadius;\n    vec4 z = sqrt( cns*cns + (b*b - r2) );\n    return vec3(b + z.xy, z.w - z.z);\n}\n\n#define addDepth 0.0\n\nvec4 skyTex(vec3 rd, vec3 lgt)\n{\n    const vec3 addCol = vec3(1.,1.,1.);\n    const mat3 coeffs = mat3(rayleighCoefficient, vec3(mieCoefficient), ozoneCoefficient)/0.693147;\n    vec3 thickness = getThickness(rd) + addDepth*addCol;\n    float rdl = max(dot(rd, lgt), 0.0);\n\n    vec3 rayleighScatter =(thickness.x * (0.4*rdl*rdl + 1.12))* rayleighCoefficient;\n    float g = 0.8 - lgt.y*0.15 - mieCoefficient*1500.;\n    float g2 = g*g;\n    float a = inversesqrt(g2 - (2.0*g*rdl - 1.0));\n    float phaseMie = (0.4 + lgt.y*0.1 + mieCoefficient*7000.)*(1.0 - g2)*a*a*a;\n    float mieScatter = thickness.y * phaseMie * mieCoefficient;\n\n    vec3 sunCoeff = coeffs*(getThickness(lgt) + addDepth*addCol);\n    vec3 viewCoeff = coeffs*thickness;\n    vec3 absorption = (exp2(-viewCoeff) - exp2(-sunCoeff))/((sunCoeff - viewCoeff)*0.693147);\n    \n    vec3 c = clamp(sunColor*(rayleighScatter + mieScatter)*absorption*(0.6 + lgt.y*0.3), 0., 100.5);\n    \n    vec3 sun = vec3(100.0, 50.0, 0.2) * smoothstep(1.-0.008726646, 1., 1.-clamp(acos(dot(rd, lgt)), 0.001, 1.0));\n    \n    c +=  sun * smoothstep(0.0, 0.2, lgt.y);\n\n    return vec4(c, sunCoeff);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    return vec3(p.x, p.yz * rotMat(r));\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    vec2 t = p.xz * rotMat(r);\n    return vec3(t.x, p.y, t.y);\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    return vec3(p.xy * rotMat(r), p.z);\n}\n\nvec3 aces_tonemap(vec3 color) // https://www.shadertoy.com/view/XsGfWV\n{\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat maxcomp(vec3 p) {return max(max(p.x,p.y),p.z);}\n\nvoid join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(r, box(p, vec2(0.1, 0.15)));\n            subt(r, box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(r, box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(r, box(p, vec2(0.1, 0.15)));\n            subt(r, box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(r, box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(r, box(p, vec2(0.1, 0.15)));\n            subt(r, box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(r, box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(r, box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(r, box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(r, box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(r, box(p, vec2(0.1, 0.15)));\n            subt(r, box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(r, box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(r, box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(r, box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(r, box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(r, box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(r, box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(r, box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(r, box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(r, box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(r, box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(r, box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(r, box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(r, box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(r, digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n}\n\nfloat perlinNoise(vec2 p, float s, float t)\n{\n    mat2 r = rotMat(t*2.0);\n    vec2 tlVal = r*hash22(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = r*hash22(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = r*hash22(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = r*hash22(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H, float time)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s, time);\n        f *= 2.0;\n        a *= G;\n    }\n    return t * 0.5;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddj3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[693, 693, 787, 787, 1065], [1070, 1070, 1123, 1123, 1184], [1186, 1186, 1253, 1253, 1359], [1362, 1362, 1406, 1406, 1505], [1511, 1511, 1554, 1554, 1654], [1656, 1656, 1688, 1688, 1712], [1714, 1714, 1757, 1757, 1791], [1793, 1793, 1824, 1824, 1915], [1917, 1917, 1958, 1958, 1991], [1992, 1992, 2020, 2020, 2209], [2211, 2211, 2235, 2235, 2498], [2500, 2500, 2539, 2539, 2755], [2804, 2804, 2845, 2845, 3722], [3724, 3724, 3781, 3781, 4061], [4063, 4063, 4097, 4097, 4177], [4179, 4179, 4337, 4337, 4633], [4635, 4635, 4744, 4744, 5264], [5266, 5266, 5298, 5298, 5370], [5372, 5372, 5429, 5479, 8208]], "test": "untested"}
{"id": "DdjSzR", "name": "Pixel Pusher", "author": "SnoopethDuckDuck", "description": "Press WASD or up/down/left/right to move, R to reset.\n\nThere's not really an objective, I was just playing with mechanics. But maybe see if you can make a blue diamond :)", "tags": ["game", "automata", "ca"], "likes": 8, "viewed": 295, "published": 3, "date": "1669822819", "time_retrieved": "2024-07-30T16:15:58.388754", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zm = 0.05; \n    vec2 res = floor(iResolution.xy);    \n    vec2 f = mod(fragCoord, res);\n    \n    vec3 col = texelFetch( iChannel0, ivec2(zm * f + 0.5 * (1.-zm) * res), 0).rgb;\n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n\n// white red green blue black yellow purple half-white half-red\n#define W vec4(1)\n#define R  vec4(1,0,0,0)\n#define G  vec4(0,1,0,0)\n#define BL vec4(0,0,1,0) \n#define B vec4(0)\n#define Y vec4(1,1,0,0)\n#define P vec4(1,0,1,0)\n#define HW vec4(0.5)\n#define HR vec4(0.5,0,0,0)\n\n#define hasNbr(c) (t==c||b==c||l==c||r==c)\n#define hasNbr2(c) (t==c||b==c||l==c||r==c||tl==c||tr==c||bl==c||br==c)\n#define allNbr(c) (t==c&&b==c&&l==c&&r==c)\n#define allNbr2(c) (t==c&&b==c&&l==c&&r==c&&tl==c&&tr==c&&bl==c&&br==c)\n//#define is(c) e==c\n\n// Mechanics:\n// W is player\n// R gets pushed, travels in G, turns P to Y\n// G gets pulled, turns into BL, turns into R\n// BL is a wall, turns R into BL, turns into W\n// B is empty space\n// P turns into Y\n// Y spawns R\n// HW used to make player move once per button press\n// HR used to make R travel in G\n\n// Bugs:\n// I think half reds can kill you, playing on paused is buggy\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgba;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    ivec2 px = ivec2(f);\n    int frame = iFrame;\n    \n    col = vec4(0);\n    if (frame == 0 || key_down(KEY_RESET)) {    \n        col = vec4(0);\n        if (length(f+.5-floor(0.5 * iResolution.xy)) < 1.)\n            col = W;\n            \n        if (length(f+.5+vec2(3,-1)-floor(.5 * iResolution.xy)) < 1.)\n            col = R; \n       \n        if (length(f+.5-vec2(3,1)-floor(.5 * iResolution.xy)) < 1.)\n            col = P;  \n        \n        return;\n    }\n           \n    // Center cell\n    vec4 e = cell(px);\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n      \n    col = e;\n    \n    int dirx = 0;\n    int diry = 0;\n    if (key_down(KEY_W) || key_down(KEY_UP))\n        diry++;\n    if (key_down(KEY_S) || key_down(KEY_DOWN))\n        diry--;\n    if (key_down(KEY_D) || key_down(KEY_RIGHT))\n        dirx++;\n    if (key_down(KEY_A) || key_down(KEY_LEFT))\n        dirx--;\n    \n    // player is moving\n    if (dirx != 0 || diry != 0) {\n        vec4 oc = cell(px + ivec2(dirx, diry));\n        vec4 c = cell(px - ivec2(dirx, diry));\n        vec4 c2 = cell(px - ivec2(2 * dirx, 2 * diry));\n        \n        if (e == W) {\n            if (c == G && oc == B) // fast travel in G\n                col = G;\n            else if (oc != BL && oc != Y && oc != P) // stop at walls\n                col = B;          \n        }\n        else if (e == R) { // get pushed\n            if (c == W)\n                col = HW;\n        } \n        else if (e == G) { // get fast travelled in\n            if (c == W)\n                col = W;       \n        }\n        else if (e == B) { \n            if (c == W) // get travelled in\n                col = HW;\n            else if (c == R && c2 == W) // get R travelled in\n                col = R;\n        }                 \n    }    \n    \n    // player is not moving (reset to W after buttons released)\n    else if (e == HW)\n        col = W;\n         \n    // independent of player (after movement)\n    if (e == R) {\n        if (hasNbr(G)) \n            col = HR;\n        else if (hasNbr(R))\n            col = G;\n        else if (hasNbr(BL))\n            col = BL;\n    }\n    else if (e == G) {\n        if (hasNbr(R))\n            col = R;\n        else if (allNbr2(G))\n            col = BL;\n    }\n    else if (e == BL) {\n        if (allNbr(BL))\n            col = W;\n        else if (allNbr(W))\n            col = W;\n    }\n    else if (e == B) {\n        if (hasNbr(Y))\n            col = R;\n        else if (allNbr(R))\n            col = Y;\n    }  \n    else if (e == P) {\n        if (hasNbr(R))\n            col = Y;\n    }\n    else if (e == HR) {\n        if (hasNbr(R))\n            col = B; // change me to P for something weird\n    } \n    \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjSzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 341]], "test": "untested"}
{"id": "dsSSRz", "name": "Fork Tileable W jackwaghor 489", "author": "jackwaghorn", "description": "Found this on GLSL sandbox. I really liked it, changed a few things and made it tile-able. \nCheck out the #define to see the tiling.\nSee it full-screen if you can.", "tags": ["water", "caustic"], "likes": 3, "viewed": 253, "published": 3, "date": "1669809527", "time_retrieved": "2024-07-30T16:15:59.146234", "image_code": "// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\n// :)\n// by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n\n// Redefine below to see the tiling...\n//#define SHOW_TILING\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .1;\n    // uv should be the 0-1 uv of texture...\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#ifdef SHOW_TILING\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\n#else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n#endif\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.1-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 12.0));\n    colour = clamp(colour + vec3(0.07, 0.3, 0.55), 0.0, 1.0);\n\t#ifdef SHOW_TILIN\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n\tfragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 335, 335, 1446]], "test": "untested"}
{"id": "DsBSzz", "name": "Convolution Filter Over Time", "author": "SpicyMelon", "description": "using a 3x3x3 filter to convolve over pixels on the screen each frame over time\n\nLook at Buffer A for instructions and info\n\n", "tags": ["cnn"], "likes": 5, "viewed": 246, "published": 3, "date": "1669789692", "time_retrieved": "2024-07-30T16:15:59.920165", "image_code": "// Nothing cool or needed here. Go to Buffer A\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// All filters I have messed around with are in the Common tab.\n// Only three are being used which are filter0, filter1, and filter2\n// This is why the rest are commented out to make them deactivated.\n\n// You can go here to make 3 new random filters, https://editor.p5js.org/SpicyMelon/sketches/UkJmR8moU\n// If it wasn't clear, there are 3 filters to make an rgb image rather than just a black and white image.\n// Its cooler with rgb.\n\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nivec2 pos;\nint width;\nint height;\n\nvec4 pixel(int x, int y) {\nivec2 npos = pos;\nnpos.x += x;\nnpos.y += y;\n\nnpos.x = int(mod(float(npos.x), float(width)));\nnpos.y = int(mod(float(npos.y), float(height)));\n\nreturn    texelFetch(iChannel0, npos, 0);\n}\n\nvec4 pixel(ivec2 v) {\nreturn  pixel(v.x, v.y);\n}\n\nfloat filterPixel(float[27] fil, int x, int y, int z) {\nint index = x + y * 3 + z * 3 * 3;\nreturn fil[index];\n}\n\nfloat filterForPos(float[27] fil) {\n    float v = 0.0;\n    vec4 p;\n\n        for(int y = -1; y <= 1; y++) {\n            for(int x = -1; x <= 1; x++) {\n            p = pixel(x, y);\n            v += p.r * filterPixel(fil, x + 1, y + 1, 0);\n            v += p.g * filterPixel(fil, x + 1, y + 1, 1);\n            v += p.b * filterPixel(fil, x + 1, y + 1, 2);\n\n    }\n    }\n    \n    \n    v = clamp(v, 0.0, 1.0);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pos = ivec2(fragCoord);\n    width = int(iResolution.x);\n    height = int(iResolution.y);\n\n\n    if(iFrame == 0) {\n        fragColor = vec4(rand(fragCoord * 0.01), rand((fragCoord + vec2(float(width) * 0.5, 0.0)) * 0.01), rand((0.0, fragCoord + vec2(float(height) * 0.5)) * 0.01), 1);\n    \n    } else {\n    \n        float vr, vg, vb;\n        vr  = filterForPos(filter0);\n        vg  = filterForPos(filter1);\n        vb  = filterForPos(filter2);\n\n\n\n        fragColor = vec4(vr, vg, vb, 1);\n        //fragColor = pixel(0, 0);\n    \n\n\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//rgb epilepsy\n//float[27] filter0 = float[](-0.9804343132248414, 0.3880082593908587, -0.873348322590926, -0.8157160970928912, 0.2510635028678605, -0.3014531295124807, -0.7234242314678516, 0.06909178462564824, -0.19291524868478138, 0.20065700096218464, -0.5588558254867784, 0.8047345344441941, -0.7050640632261116, 0.04556257192371893, -0.7562778600019704, 0.10166551908188604, 0.3256490785852022, -0.9693190685904027, 0.34829569499977797, -0.7113188397689676, 0.7632013352982474, -0.8486271294410566, 0.8354032265442033, 0.8876302317510669, -0.5259570704115801, 0.9609063191390224, 0.3813425215057271);\n//float[27] filter1 = float[](0.7931395145533462, 0.380928577942067, 0.5730740093769566, 0.3969134793953062, 0.8127857629336064, -0.7169886836826285, 0.08375770461906384, -0.04852441765068649, 0.7010984819371631, -0.9412244186321641, -0.3874298182174538, 0.47021984110067727, 0.30784400296234615, 0.8041937330003068, -0.5435837545545703, 0.5141849790987787, -0.15099058384973274, 0.04677990870623994, -0.9511125245437575, -0.36464743043174597, -0.659373405814121, -0.8250209272988669, 0.4815024140910089, -0.28614737036795734, -0.23190843622804636, -0.22567573741882896, -0.7458951158501002); \n//float[27] filter2 = float[](-0.6239377761399441, -0.6112561208235934, 0.9755885573123289, 0.3397811412573559, -0.4406018107854246, -0.921051287102653, -0.5611831045984879, -0.8755056281855178, 0.06356614818918205, -0.7361451033203035, 0.9520273955833489, 0.16044957615678257, 0.475661234667613, 0.9538397365125277, 0.7831424798759485, -0.8180241497335055, 0.39206749327335055, 0.8883238628675745, -0.8556470108384606, -0.48682865278771237, 0.18435305757693587, 0.8546698645905266, -0.088992820678234, -0.22041893544082614, -0.9271232802179785, -0.3233167566324515, 0.00943490768460764); \n\n//Angular ocean\n//float[27] filter0 = float[](-0.014520753356875193, -0.003997221620404723, -0.6191498768508681, -0.403944250628693, -0.96338761564509, -0.7488211609789301, 0.9708027474490541, -0.6408302917960707, 0.9381075293405106, 0.25216423503362595, -0.2978146060337292, 0.3165045540248532, -0.5460320008208774, -0.9357393732011694, 0.20602742628098092, -0.45902446718428047, -0.18559343426155994, 0.35187423233207005, 0.12946422924284828, 0.8147940242899225, 0.8555757006210807, 0.4260362864040874, -0.6191204974479776, -0.14235879894250614, -0.31843828202267543, 0.7369236691514995, 0.6310981155020259); \n//float[27] filter1 = float[](0.7728588399236265, -0.2894569850984601, 0.27491548208549155, -0.9908065861736781, -0.15444140308586451, 0.6902429361932088, 0.09558301453547102, -0.7060898672970679, 0.7108610750870334, -0.6114664535537302, -0.6695275893049581, -0.6274778355386914, -0.9321076745888344, -0.25875700079127695, 0.40888878892249725, -0.8331353665093997, -0.531444643666283, 0.3975135351206611, -0.24322607203217972, -0.8352022700557828, 0.1528801678952254, 0.9765707212846424, 0.6800290882631717, 0.1948692081281509, 0.8850778925128209, -0.5157620122155846, -0.7995930117642707); \n//float[27] filter2 = float[](-0.5613121721123226, -0.42083801735893855, 0.4512354841180355, 0.954662332143791, -0.4955592123958432, 0.31145408516026984, -0.08000121772499025, 0.7333390859470237, -0.022981703363329498, -0.8453580811557475, 0.6427890625909507, -0.1587394083483864, 0.33138086228576746, -0.41062842802701516, 0.6404321649021338, -0.4726405506593254, -0.7870706233947842, 0.12357970240053939, -0.8398476830347219, -0.5610969927979821, -0.43817367056958734, 0.4272782294616482, 0.797086975880744, -0.32026075598551795, -0.7152617969938206, -0.23224328345491063, -0.8947138084997648); \n\n//pink flames\n//float[27] filter0 = float[](-0.3824206403149435, 0.7841389323397658, 0.7738729197168963, 0.5986430160145422, -0.5724754099823199, -0.7827344221647738, -0.21415322099054146, 0.8558262761887896, -0.9954191357418258, 0.8056349847569018, -0.4274323743283954, -0.3184878887351559, -0.7276520163925402, -0.6595474794001208, -0.7804722587215132, -0.8043245836108635, 0.10236156735012836, -0.09225156891408481, 0.8849890310524455, 0.011008028052847063, -0.19720003853589674, 0.966052081484972, 0.013760116559135227, -0.058594940133061435, 0.05446779660135803, -0.22605332956330493, 0.9961478956168874); \n//float[27] filter1 = float[](0.10517837284480924, 0.5337700160637286, 0.08957404115020617, -0.23790402834946178, -0.45911319576851106, 0.10905138520655688, -0.198873119175615, 0.2258371036386002, 0.10896574665642733, -0.17131340966167352, -0.9490828799137008, -0.8275984576634481, -0.2080117559129695, -0.35706493163493924, -0.32365456081589716, 0.42991297307411847, -0.538735424518209, -0.0019676799926284794, -0.8488413468722524, -0.0010645210439990116, 0.49413796116976183, -0.1176241188544691, -0.6250520048762813, 0.7386480583948036, -0.3290022271049935, 0.7962099150943969, -0.9280696574271752); \n//float[27] filter2 = float[](0.2377942676513829, 0.10435893584099354, 0.9983186543805505, -0.06099318467709436, -0.4654243555078543, -0.3126274536831848, 0.6334633254534912, 0.27690986322355604, -0.6851333891550566, 0.8598170523553472, 0.8176682432341789, 0.12728752841144564, 0.7844273117791274, -0.5724944448072233, 0.7041719043144608, 0.268925025093643, -0.5443930010114286, 0.6672607188446387, -0.3714397556131135, -0.4414866544485254, 0.1114944455204685, 0.12984665636978887, -0.9461800826529871, 0.5795727635940153, 0.6608841646061436, 0.16941083510717103, -0.1909162638159243); \n\n//slither slime\n//float[27] filter0 = float[](0.41058762620232203, 0.9903967297930119, -0.7141992013265432, 0.24808913987818348, -0.7880798276016407, 0.7381335148610764, 0.6222589118309467, -0.47647182375671315, 0.9308036523871408, -0.45049930881859845, -0.2611589581917375, -0.17288507418304766, -0.44171251335733963, -0.4521635987747521, -0.9284982603983494, -0.9190484831133032, -0.12812961927889477, -0.42794628721888817, 0.8534998405924101, -0.20266133357258642, -0.7744809166260791, 10.49201554447288176, 10.4192562322639857, 0.3018507193315183, 0.1669527351315283, -0.16658130910648739, -0.24535140449030202); \n//float[27] filter1 = float[](0.06535995230876113, 0.07857522628661284, 0.4878496491680506, -0.16951981354877343, 0.3894434924216772, 0.32145653915889394, 0.09045900721709677, 0.5536055308104926, 0.2924525515684544, 0.2882511088056159, -0.04572546883778372, 0.04728039428989472, -0.327572425614461, 0.34915601897999693, -0.5425706504091563, -0.9969624072548804, -0.5459904661897235, -0.5708010079667076, 0.33665720363412, 0.23243522664537153, -0.9988874877324974, 0.16276503465346837, -0.06649472979057869, -0.37438614318657715, -0.7206184820540638, 0.6985856692686503, -0.42648513265491284); \n//float[27] filter2 = float[](-0.7796319609373765, 0.2468533020187813, 0.2775388063592348, 0.880402755630945, 0.11668893494399057, -0.19762084547706005, -0.3121171739511106, -0.9521610209217442, -0.70013173623961, -0.160916075541226, 0.10991019297444371, -0.9587967692031505, 0.9101775883149665, 0.9109532883046811, -0.35333387286174833, -0.1361833132752679, 0.029540478788852464, 0.9883051103344975, 0.16303847134071336, 0.9958285290404634, 0.4269363554661063, 0.6342483991675092, -100.40711851752193473, 0.47394200563365363, 0.05060447640570187, -0.9297952184699412, -0.08943558293927678); \n\n//red strings\nfloat[27] filter0 = float[](-0.1077809072276823, 0.4830991190100047, 0.18242868104324028, 0.1806713917168783, 0.2747248740188377, -0.4900890688339392, 0.7066703365224067, -0.41940860322048135, -0.8543595052290582, 0.2792444185284233, 0.6406656234578714, -0.053328744529867134, -0.5335999572436028, -0.17677136160696527, 0.7353059174050856, -0.1114352280377302, 0.6605685904475203, 0.6770220879444251, 0.14110173300542872, 0.8822168598833122, 0.1550752979031369, -0.19859170389362335, 0.4341469433833227, 0.3761549900631973, 0.5842256075124532, -0.9340294724543843, 0.8549392668959466); \nfloat[27] filter1 = float[](-0.9138610529700228, -0.3114128724707288, 0.4710602606014187, -0.6068866641950441, -0.5456662883592842, -0.12234771984734039, -0.9455570461917358, -0.5157915844041887, -0.29012051055816457, 0.47192117129458744, -0.9672992503427658, -0.9141355280675159, -0.28787366491131117, -0.8330056027213328, -0.7637187685151101, 0.08381426510477041, -0.48566154640311643, 0.23021467597737377, -0.3478153796427761, 0.641261603777346, -0.1402695333601902, -0.5924376172910275, 0.1509947268760108, 0.0023882754280082352, 0.6209809448402805, -0.051799723483665794, -0.47856689559956767); \nfloat[27] filter2 = float[](-0.6130046747494413, 0.25030847195517625, -0.5473240237259627, -0.4989128468132309, -0.839986222178613, -0.5978654854633656, -0.7564207984251836, 0.01017801193364365, 0.04140505399465111, -0.9881557300020778, 0.8697117377093164, 0.8912565976004214, 0.5385672689073964, 0.0283133288782218, 0.3398797334559531, 0.894443000098919, 0.2416376537362499, -0.3002707464605092, -0.3582712213063619, 0.2246045088805264, 0.2539959979237052, -0.42399610064138704, -0.6240854625173564, -0.9955023590415886, -0.15723482210447504, -0.3129798800340282, 0.24958864214351495); \n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBSzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 106, 167]], "test": "untested"}
{"id": "csSSRz", "name": "Hatchling's Graphing Calculator", "author": "Hatchling", "description": "Something I made for myself when I need to graph something with pretty antialiased lines.\nTrying to cram complex math statements into a single line as required by google's or wolfram's graphing calculator is simply annoying and messy.", "tags": ["graph", "aa"], "likes": 2, "viewed": 248, "published": 3, "date": "1669772538", "time_retrieved": "2024-07-30T16:16:00.805797", "image_code": "const vec4 BackgroundColor = vec4(0.0, 0.05, 0.1, 1);\n\nfloat myFunc(float x) \n{ \n    // Write your custom function to plot here.\n    x *= x; \n    return sin(x)/x; \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gFragCoord = fragCoord;\n    gResolution = iResolution.xy;\n    \n    fragColor = BackgroundColor;\n    \n    // Draw grids.\n    drawGrid(fragColor, vec2(0.1), vec4(1,0.5,0.5,0.02), vec4(0.5, 1, 0.5, 0.02));\n    drawGrid(fragColor, vec2(1), vec4(1,0.5,0.5,0.1), vec4(0.5, 1, 0.5, 0.1));\n    drawGrid(fragColor, vec2(10), vec4(1,0.5,0.5,0.5), vec4(0.5, 1, 0.5, 0.5));\n    \n    // Draw trig functions.\n    drawGraph(fragColor, tf(sin, fragCoord), vec4(1,0,0,1));\n    drawGraph(fragColor, tf(cos, fragCoord), vec4(0,0,1,1));\n    \n    // Draw custom function.\n    drawGraph(fragColor, tf(myFunc, fragCoord), vec4(1,1,0,1));\n    \n    // Add more functions to plot here.\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Displayed range of the graph.\nconst vec2 mini = vec2(-5, -2);\nconst vec2 maxi = vec2(5, 2);\n\n#define StLine 0\n#define StSolid 1\n#define Style StLine\n\n// Global vars used by overloads when you're lazy.\nvec2 gFragCoord;\nvec2 gResolution;\n\nvec2 fragToView(vec2 fragCoord, vec2 resolution)\n{\n    return mix(mini, maxi, fragCoord / resolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord, vec2 resolution)\n{\n    return (viewCoord - mini) / (maxi - mini) * resolution;\n}\n\nvec2 fragToView(vec2 fragCoord)\n{\n    return fragToView(fragCoord, gResolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord)\n{\n    return viewToFrag(viewCoord, gResolution);\n}\n\nfloat fragToViewX(float fragCoordX, float resolutionX)\n{\n    return mix(mini.x, maxi.x, fragCoordX / resolutionX);\n}\n\nfloat viewToFragY(float viewCoordY, float resolutionY)\n{\n    return (viewCoordY - mini.y) / (maxi.y - mini.y) * resolutionY;\n}\n\nfloat fragToViewX(float fragCoordX)\n{\n    return fragToViewX(fragCoordX, gResolution.x);\n}\n\nfloat viewToFragY(float viewCoordY)\n{\n    return viewToFragY(viewCoordY, gResolution.y);\n}\n\n#define tf(func, fragCoord) (viewToFragY(func(fragToViewX(fragCoord.x))))\n\nfloat getGraphOpacity( in float fragHeight, in float graphHeight )\n{\n    if(isnan(graphHeight) || isinf(graphHeight)) \n        return 0.0;\n    \n    float range = (1.0 + abs(dFdx(graphHeight)));\n    \n    #if Style == StLine\n        range *= 2.0;\n    #endif\n    \n    float upper = graphHeight + range;\n    float lower = graphHeight - range;\n    \n    float value = (fragHeight - lower) / (upper - lower);\n    \n    #if Style == StLine\n        value = (abs(value - 0.5) * 2.0);\n    #endif\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float fragHeight, in float graphHeight, in vec4 color )\n{\n    float opacity = getGraphOpacity(fragHeight, graphHeight);\n    \n    vec4 c = color;\n    c.a *= opacity;\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float graphHeight, in vec4 color )\n{\n    drawGraph(fragColor, gFragCoord.y, graphHeight, color);\n}\n\nvec2 getGridOpacity(in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing)\n{\n    vec2 viewCoord = fragToView(fragCoord, resolution) / gridSpacing;\n    vec2 nearestGridViewCoord = round(viewCoord) * gridSpacing;\n    vec2 nearestGridFragCoord = viewToFrag(nearestGridViewCoord);\n    \n    const vec2 range = vec2(2);\n    \n    vec2 upper = nearestGridFragCoord + range;\n    vec2 lower = nearestGridFragCoord - range;\n    \n    vec2 value = (fragCoord - lower) / (upper - lower);\n    \n    value = (abs(value - 0.5) * 2.0);\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    vec2 opacity = getGridOpacity(fragCoord, resolution, gridSpacing);\n    \n    vec4 cH = colorHorizLines;\n    cH.a *= opacity.y;\n    vec4 cV = colorVertLines;\n    cV.a *= opacity.x;\n    \n    float ratio = cV.a / (cV.a + cH.a);\n    \n    if(isnan(ratio) || isinf(ratio)) ratio = 0.5;\n    \n    vec4 c;\n    c.rgb = mix(cH.rgb, cV.rgb, ratio);\n    c.a = mix(cH.a, 1.0, cV.a);\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    drawGrid(fragColor, gFragCoord, gResolution, gridSpacing, colorHorizLines, colorVertLines);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 79, 128, 165], [168, 168, 225, 225, 891]], "test": "untested"}
{"id": "mdsXDs", "name": "Polygons on acid", "author": "ProceduralFish", "description": "psychedelic polygons on acid melting based on sines and cosines *-*", "tags": ["math", "colorful", "color", "psychedelic", "rainbow", "polygon", "visual"], "likes": 7, "viewed": 292, "published": 3, "date": "1669758410", "time_retrieved": "2024-07-30T16:16:01.601669", "image_code": "const float PI=3.1415926535;\nconst float SIDESPEED=.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord=(sin(iTime*.2)*10.6+22.6)*(fragCoord.xy-iResolution.xy/2.)/min(iResolution.y,iResolution.x);\n    \n    float sides=sin(iTime*SIDESPEED)*4.+6.;\n    \n    coord.x+=(sin(iTime+cos(coord.y))+sin(coord.x*2.))*(sin(iTime)+1.);\n    coord.y+=(cos(iTime+sin(coord.x))+cos(coord.y*2.))*(sin(iTime)+1.);\n    \n    float angle=atan(coord.x,coord.y);\n    float slice=PI*2./sides;\n    float shape=cos(floor(.5+angle/slice)*slice-angle)*length(coord);\n    \n    vec3 color=vec3(sin(shape*(cos(iTime*.1+26.)*2.+3.)),sin(shape*(cos(iTime*.1+25.)*2.+3.)),sin(shape*(atan(iTime*.1+13.)*2.+3.)));\n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 113, 733]], "test": "untested"}
{"id": "ddlXDs", "name": "UlaVa", "author": "ProceduralFish", "description": "My very first shader, it's basic and probably not very well optimized, but I liked it :))", "tags": ["uv", "colorful", "color", "rainbow"], "likes": 10, "viewed": 181, "published": 3, "date": "1669757310", "time_retrieved": "2024-07-30T16:16:02.431451", "image_code": "float shape(vec2 fragmentPosition,float radius,vec2 realPosition){\n    \n    return step(radius/fragmentPosition.x/fragmentPosition.y,length(fragmentPosition-realPosition));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 fragmentPosition=fragCoord/min(iResolution.y,iResolution.x);\n    \n    float circleRadius=.04;\n    \n    float frequency=1.;\n    float range=sin(iTime)*4.+6.;\n    vec2 center=vec2(.7,.5);\n    \n    //vec2 circlePosition=iMouse.xy/min(iResolution.y,iResolution.x);\n    vec2 circlePosition=vec2((sin(iTime*frequency)/range)+center.x,(cos(iTime*frequency)/range)+center.y);\n    \n    vec3 color=vec3(shape(fragmentPosition,circleRadius,circlePosition));\n    \n    if(length(color)==0.){\n        color=vec3(vec2(fragCoord/iResolution.xy),sin(iTime)*.3+.7);\n        \n    }\n    else{\n        color=vec3(sin(iTime)*.3+.7,vec2(fragCoord/iResolution.xy));\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 179], [182, 182, 239, 239, 937]], "test": "untested"}
{"id": "dssSDs", "name": "Lambmeow vortex", "author": "lambmeow", "description": "this is something i wanted to a college project\n\nmipmap kinda fucks it up though", "tags": ["vfx", "vortex", "polar", "lambmeow"], "likes": 2, "viewed": 169, "published": 3, "date": "1669757027", "time_retrieved": "2024-07-30T16:16:03.208373", "image_code": "void mainImage( out vec4 c, in vec2 f)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 r = iResolution.xy, u = (2. * f-r)/r.y;\n    \n    float a = iTime * 0.5, ca = cos(a), sa = sin(a);\n    u *= mat2(ca, -sa, sa, ca);\n    float rad = length(u);\n    float ang = (atan(u.y, u.x) + radians(180.)) /radians(360.);\n\n    \n    vec2 polar = vec2(rad, ang) +iTime * 0.01;\n    // Output to screen\n    c = texture(iChannel0,floor(polar * 20.)/20.) * 1.-rad;\n    \n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 90, 465]], "test": "untested"}
{"id": "mssXWs", "name": "Pretty Graph", "author": "pr1ncess_emily", "description": "A colorful moving graph with jagged peaks", "tags": ["graph"], "likes": 3, "viewed": 128, "published": 3, "date": "1669754927", "time_retrieved": "2024-07-30T16:16:04.006240", "image_code": "float getHeight(float x) {\n    x += fract(iTime);\n    vec4 tex = texture(iChannel0, vec2(x,x));\n    return (tex.x+tex.y+tex.z)/3.0;\n}\n\nvec4 getHue(float h) {\n    return vec4(1.0-h, h, 0.75, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if (uv.y <= getHeight(uv.x)) {\n        fragColor = getHue(uv.x);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 133], [135, 135, 157, 157, 197], [199, 199, 256, 306, 480]], "test": "untested"}
{"id": "dslXDl", "name": "The Metamorphosis", "author": "mrange", "description": "CC0: A weird torus\nBack to experimenting with 2D and psychedelic colors", "tags": ["2d"], "likes": 20, "viewed": 403, "published": 3, "date": "1669749095", "time_retrieved": "2024-07-30T16:16:04.760224", "image_code": "// CC0: The Metamorphosis\n//  Back to experimenting with 2D and psychedelic colors\n//  Perhaps just to my damaged mind but it looks a bit like a scarab transforming to an ethereal alien being\n\n// #define ORIGINAL\n\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define PI_2            (0.5*PI)\n#define TAU             (2.0*PI)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat starN(vec2 p, float r) {\n  const float n = 6.0;\n  const float m = 4.0;\n\n  // next 4 lines can be precomputed for a given shape\n  const float an = 3.141593/float(n);\n  const float en = 3.141593/m;  // m is between 2 and n\n  const vec2  acs = vec2(cos(an),sin(an));\n  const vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan_approx(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),pabs(sin(bn), 0.5));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat weirdTorus(vec3 p, vec3 d) {\n  vec2 q = vec2(length(p.xz) - d.x, p.y);\n  float a = atan_approx(p.x, p.z);\n  const float off = PI*0.875;\n  a = abs(a);\n  float b = a;\n  b -= off;\n  b = -pabs(b, 1.0);\n  b += off;\n  a *= b;\n  mat2 r = ROT(-4.0*a/6.0);\n  return starN(r*q, d.y)-d.z;\n}\n\nfloat dd(vec3 p) {\n  const float z = 0.25;\n  return weirdTorus(p/z, vec3(2.0, 0.65, 0.025))*z;\n}\n\nvec3 nn(vec3 pos, float aa) {\n  vec2  eps = vec2(aa,0.0);\n  vec3 nor;\n  nor.x = dd(pos+eps.xyy) - dd(pos-eps.xyy);\n  nor.y = dd(pos+eps.yxy) - dd(pos-eps.yxy);\n  nor.z = dd(pos+eps.yyx) - dd(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 effect2(vec2 p) {\n#ifdef ORIGINAL\n  const vec3 gcol0 = HSV2RGB(vec3(0.8, 0.95, 1.0));\n  const vec3 gcol1 = HSV2RGB(vec3(0.2, 0.95, 1.0));\n  const vec3 gcol2 = HSV2RGB(vec3(0.5, 0.95, 1.0));\n  const vec3 gcol3 = HSV2RGB(vec3(0.95, 0.9, 0.01));\n  const vec3 scol0 = HSV2RGB(vec3(0.95, 0.9, 1.0));\n  const vec3 scol1 = HSV2RGB(vec3(0.55, 0.8, 0.1));\n  const vec3 white = vec3(1.0);\n  \n  float aa = 2.0/RESOLUTION.y;\n  vec3 p3 = vec3(p.x, -0.15*cos(0.1*TIME), p.y);\n  float d = dd(p3);\n  vec3 n = nn(p3, aa);\n#else\n  float hoff = fract(0.05*p.y+0.1*p.x+0.02*TIME);\n  vec3 gcol0 = hsv2rgb(vec3(hoff+0.8, 0.95, 1.0));\n  vec3 gcol1 = hsv2rgb(vec3(hoff+0.2, 0.95, 1.0));\n  vec3 gcol2 = hsv2rgb(vec3(hoff+0.5, 0.95, 1.0));\n  vec3 gcol3 = hsv2rgb(vec3(hoff+0.95, 0.9, 0.01));\n  vec3 scol0 = hsv2rgb(vec3(0.95, 0.9, 1.0));\n  vec3 scol1 = hsv2rgb(vec3(0.55, 0.8, 0.1));\n  const vec3 white = vec3(1.0);\n  \n  \n  float aa = 2.0/RESOLUTION.y;\n  vec3 p3 = vec3(p.x, -0.15*cos(0.1*TIME), p.y);\n  float d = dd(p3);\n  p3.y = -0.15*cos(0.1*TIME-PI*smoothstep(0.55, 1.5, length(p)));\n  vec3 n = nn(p3, aa);\n#endif\n\n  d /= length(n.xz);\n  \n  vec3 col = vec3(0.05);\n  \n  vec3 gcol = vec3(0.0);\n  gcol += gcol0*abs(n.x);\n  gcol += gcol1*(n.y);\n  gcol += gcol2*(n.z);\n  \n  col += gcol;\n  vec3 bcol = col;\n  col *= mix(white, scol0, exp(-8.0*max(d-0.025, 0.0)));\n  col = mix(col, white, smoothstep(aa, -aa, d-0.01));\n  col = mix(col, scol1*bcol, smoothstep(aa, -aa, d));\n  col = max(col, 0.0);\n  col += gcol3*mix(1.0, 2.0, smoothstep(0.0, 1.0, sin((0.5*125.0/60.0)*TAU*TIME)))/dot(p, p);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect2(p);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 599, 621, 621, 767], [1062, 1148, 1185, 1185, 1292], [1294, 1394, 1433, 1433, 1518], [1520, 1608, 1638, 1638, 1666], [1668, 1668, 1698, 1698, 2228], [2230, 2230, 2264, 2264, 2515], [2517, 2517, 2535, 2535, 2613], [2615, 2615, 2644, 2644, 2846], [2848, 2848, 2870, 2870, 4429], [4431, 4431, 4486, 4486, 4736]], "test": "untested"}
{"id": "mdlXWl", "name": "Pipe sphere", "author": "me_123", "description": "A Sphere Made of connected pipes using wang face tiling.", "tags": ["3d", "raymarching", "sdf", "voxel", "wangtiles", "pipes"], "likes": 26, "viewed": 394, "published": 3, "date": "1669746224", "time_retrieved": "2024-07-30T16:16:05.515205", "image_code": "#define AA 2\nconst float eps = 0.0001;\nfloat s2;\nvec3 getRay(in vec3 cameraDir, in vec2 uv) {\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nfloat j(in float x) {\n    return fract(x)*mod(floor(x), 2.0)+floor(x*0.5)+2.0;\n}\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nconst uint k = 1234543210U;\nuint hash( uvec3 x )\n{\n\tvec3 z = vec3(x)-1000000.+0.5;\n    if (length(z) > s2-1.0) return 0u;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return uint((64.0*(float(x.x)/float(0xffffffffU))));\n}\nconst float s = 0.15;\nconst float ku = 0.68;\nfloat edge(in vec3 p, in uint d, in bool n) {\n    float ds = 1000.0;\n    if ((d&1u) != 0u) ds = min(ds, min(max(length(p.yz), -p.x+s)-s,max(length(p.yz), -p.x+ku)-s*1.3));\n    if ((d&2u) != 0u) ds = min(ds, min(max(length(p.yz), p.x+s)-s,max(length(p.yz), p.x+ku)-s*1.3));\n    if ((d&4u) != 0u) ds = min(ds, min(max(length(p.xz), -p.y+s)-s,max(length(p.xz), -p.y+ku)-s*1.3));\n    if ((d&8u) != 0u) ds = min(ds, min(max(length(p.xz), p.y+s)-s,max(length(p.xz), p.y+ku)-s*1.3));\n    if ((d&16u) != 0u) ds = min(ds, min(max(length(p.xy), -p.z+s)-s,max(length(p.xy), -p.z+ku)-s*1.3));\n    if ((d&32u) != 0u) ds = min(ds, min(max(length(p.xy), p.z+s)-s,max(length(p.xy), p.z+ku)-s*1.3));\n   \tif (d > 0u) ds = min(ds, length(p)-s); \n    return n?ds:max(ds, box(p, vec3(0.5)));\n}\nuint getState(in uvec3 id) {\n\t uint v = hash(id);\n    if ((id.x+id.y+id.z)%2u == 1u) {\n        v = ((hash(id-uvec3(1, 0, 0))&1u)<<1)|\n            ((hash(id+uvec3(1, 0, 0))&2u)>>1)|\n            ((hash(id-uvec3(0, 1, 0))&4u)<<1)|\n            ((hash(id+uvec3(0, 1, 0))&8u)>>1)|\n            ((hash(id-uvec3(0, 0, 1))&16u)<<1)|\n            ((hash(id+uvec3(0, 0, 1))&32u)>>1);\n    }\n    return v;\n}\nvec3 norm( vec3 p, in uint id)\n{\n    const float h = eps;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * edge(p + k.xyy * h, id, true) +\n                     k.yyx * edge(p + k.yyx * h, id, true) +\n                     k.yxy * edge(p + k.yxy * h, id, true) +\n                     k.xxx * edge(p + k.xxx * h, id, true));\n}\nfloat sphere(in vec3 ro, in vec3 rd, in float ra) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - ra*ra;\n    float h = b*b-c;\n    if (h < 0.0) return -1.;\n    h = sqrt(h);\n    return -b-h;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    float s = sphere(ro, rd, j(iTime));\n    if (s < 0.0) return vec3(1);\n    ro = ro+rd*(s*0.7);\n    vec3 p = vec3(ro);\n    vec3 mp = floor(p);\n    vec3 p1 = mp;\n    vec3 dd = 1./rd;\n    int ii;\n    bool h = false;\n    int c = 0;\n    for (int i = 0; i < 100; i += 1) {\n    \tvec3 a = -(p-mp)*dd;\n    \tvec3 b = -((p-mp)-1.0)*dd;\n        vec3 ax = max(a, b);\n        float m = min(min(ax.x, ax.y), ax.z);\n        p += rd*m;\n        if (m == ax.x) {p.x += sign(a.x-b.x);p1.x -= sign(a.x-b.x);};\n        if (m == ax.y) {p.y += sign(a.y-b.y);p1.y -= sign(a.y-b.y);};\n        if (m == ax.z) {p.z += sign(a.z-b.z);p1.z -= sign(a.z-b.z);};\n        if (length(p1) > s2*2.0) break;\n        float d0 = 0.0;\n        vec3 o = (p-mp)-0.5;//(fract(p)-0.5);\n        bool hit = false;\n        int n;\n        uint s = getState(uvec3((p1)+1000000.));\n        if (s != 0u) {\n            h = true;\n        \tfor (int n = 0; n < 200; n += 1) {\n                ii += 1;\n        \t\tvec3 pppp = o+rd*d0;\n        \t\tfloat ddd = edge(pppp, s, false);\n        \t    d0 += ddd;\n        \t    if (ddd < eps || d0 > 1.) {\n        \t    \tbreak;\n        \t    }\n        \t}\n        \tvec3 pp = o+rd*d0;\n            vec3 n = norm(pp, s);\n        \tif (d0 < 1.) return (1.-exp(-0.05/vec3(float(ii)*0.1*(dot(n, rd)+1.0))));\n    \t} else {\n            if (h) c += 1;\n        }\n        if (c > 10) break;\n    }\n    return vec3(1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    s2 = j(iTime);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.z<1.0?vec2(iTime*0.25+0.5, 3.141592*0.5+sin(iTime*0.5+2.0)*0.5):((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*3.0*s2*0.7;\n    vec3 rd = getRay(-normalize(ro), uv);\n    vec3 color = (1.-exp(-getColor(ro, rd)*2.0));\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 93, 93, 303], [304, 304, 325, 325, 384], [385, 385, 414, 414, 505], [813, 813, 858, 858, 1585], [1586, 1586, 1614, 1614, 1978], [1979, 1979, 2011, 2011, 2313], [2314, 2314, 2365, 2365, 2513], [2514, 2514, 2553, 2553, 3936], [3937, 3937, 3994, 3994, 4429]], "test": "untested"}
{"id": "cdfSWf", "name": "Wizk_Learn", "author": "wizk", "description": "Learn from IQ live", "tags": ["3d"], "likes": 0, "viewed": 157, "published": 3, "date": "1669730466", "time_retrieved": "2024-07-30T16:16:06.323046", "image_code": "float map(in vec3 pos)\n{\n    float d = length(pos) - 0.5;\n    \n    float d2 = pos.y - (-0.5);\n    \n    return min(d, d2);\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize( vec3(\n        map(pos + e.xyy) - map(pos-e.xyy),\n        map(pos + e.yxy) - map(pos-e.yxy),\n        map(pos + e.yyx) - map(pos-e.yyx) ));\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        \n        float h = map(pos);  // pos is in the edge or inside an object.\n        if (h < 0.001)\n        {\n            break;\n        }\n        \n        t += h;\n        if (t > 20.0) break;\n    }\n    if (t > 20.0) \n        t = -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize( vec3(p, -1.5) );\n    \n    vec3 col = vec3(0.0);\n    \n    float t = castRay(ro, rd);    \n    if (t > 0.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 sun_dir = normalize( vec3( 0.8, 0.4, 0.2 ) );\n        float sun_dif = clamp( dot (nor, sun_dir),0.0, 1.0);\n        float sun_shadow = step(castRay(pos + nor*0.001, sun_dir), 0.0);;\n        float sky_dif = clamp( 0.5 + 0.5*dot (nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        \n        col = vec3(1.0, 0.7, 0.5) * sun_dif * sun_shadow;\n        col += vec3(0.0, 0.1, 0.3) * sky_dif;\n        \n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 123], [125, 125, 156, 156, 350], [352, 352, 388, 388, 735], [737, 737, 794, 844, 1633]], "test": "untested"}
{"id": "dsfXDs", "name": "TruchetFlip2 - golf2 ( 281 ch)", "author": "FabriceNeyret2", "description": "golfing 360 char https://shadertoy.com/view/lst3R7\ngolfed variant from jt's https://www.shadertoy.com/view/4st3R7", "tags": ["2d", "truchettiles", "2tweets", "short", "golf"], "likes": 18, "viewed": 289, "published": 3, "date": "1669729949", "time_retrieved": "2024-07-30T16:16:07.078027", "image_code": "// Golfing 360 chars https://shadertoy.com/view/lst3R7\n// golfed variant from jt's https://www.shadertoy.com/view/4st3R7\n\n//  -5 by Fab\n\nvoid mainImage( out vec4 O,  vec2 U ) {\n    vec2  I = ceil( U /= .1*iResolution.y ), \n          s = mod(I+I.y,2.) - .5,                     // checkboard flip (for coloring) \n          w = .2 + 1.6*abs(fract(iTime/16.)-.5) +U-U; // 1/w in [1/5 .. 1]\n    texture(iChannel0, I/128. + iTime/1e3 ).x < .5 ? U.x *= -1., s=-s : s; // random flip (for orientation and coloring)\n    \n    O = pow( fract(vec4(U,-U)), 1./w.xxxx );\n    U = smoothstep(.45,.55, pow(O.xz+O.yw, w) );\n//      step(.05,          abs( () - .5 ) )        \n    \n    O = (.5+s - 2.*s * U * U.y ).xxxx;\n}\n\n\n\n\n\n/** // -3 by iq -3 by Fab\n\nvoid mainImage( out vec4 O,  vec2 U ) {\n    vec2  I = ceil( U /= .1*iResolution.y ), w,\n    s = sign( texture(iChannel0, I/128. + iTime/1e3 ).xx - .5 ); U.x *= s.x; // random flip (for orientation and coloring)\n // U.x *= s = expr   is bugged on OpenGL/Chrome/Nvidia\n    s *= mod(I+I.y,2.) - .5;                     // checkboard flip (for coloring)\n    \n    w = .2 + 1.6*abs(fract(iTime/16.)-.5) +U-U;        // 1/w in [1/5 .. 1]\n    O = pow( fract(vec4(U,-U)), 1./w.xxxx );\n    U = smoothstep(.45,.55, pow(O.xz+O.yw, w) );\n//      step(.05,          abs( () - .5 ) )        \n    \n    O = (.5+s - 2.*s * U * U.y ).xxxx;\n}\n\n/**/\n\n\n\n\n\n/** //  292 chars\n\nvoid mainImage( out vec4 O,  vec2 U ) {\n    vec2  I = ceil( U /= .1*iResolution.y ), w;\n    float t = iTime,\n    s = sign( texture(iChannel0, I/128. + t/1e3 ).x - .5 ); U.x *= s; // random flip (for orientation and coloring)\n // U.x *= s = expr   is bugged on OpenGL/Chrome/Nvidia\n    s *= 2.* mod(I.x+I.y,2.) - 1.;                 // checkboard flip (for coloring)\n    \n    w = .2 + 1.6*abs(fract(t/16.)-.5) +U-U;        // 1/w in [1/5 .. 1]\n    O = pow( fract(vec4(U,-U)), 1./w.xxxx );\n    U = smoothstep(.45,.55, pow(O.xz+O.yw, w) );\n//      step(.05,          abs( () - .5 ) )        \n    \n    O = .5+.5*s - s * U.xxxx * U.y;\n}\n\n/**/", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 176, 176, 704]], "test": "untested"}
{"id": "mdfSWs", "name": "game of life with lowres and fps", "author": "jonasfrey", "description": "i want to figure out how game of life works by not looking it up\n", "tags": ["automata"], "likes": 2, "viewed": 188, "published": 3, "date": "1669721101", "time_retrieved": "2024-07-30T16:16:07.836998", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trpino = fragCoord/iResolution.xy;\n    vec4 o_col = texture(iChannel0, o_trpino);\n    \n    \n    // Output to screen\n    fragColor = o_col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float f_n_rand(float n){\n    return fract(sin(n*1234.432)*1234.23);\n}\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float n_hz = 240.;\n    float n_fps = 30.;\n    vec2 o_scale = vec2(0.2);\n\n    vec2 o_fragCoord = floor((fragCoord.xy+vec2(1.))*o_scale);\n    vec2 o_mouseCoord = floor((iMouse.xy+vec2(1.))*o_scale);\n    vec2 o_iResolution = floor(iResolution.xy * o_scale);\n       \n    vec2 o_trpino = (o_fragCoord.xy)/ o_iResolution.xy;\n    vec2 o_trmono = (o_mouseCoord.xy)/ o_iResolution.xy;\n    //vec2 o_trpino = (fragCoord.xy)/ iResolution.xy;\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec4 o_col_last = texture(iChannel0, o_trpino);\n    vec4 o_fragColor = vec4(float(o_col_last.r > 0.5));\n    //float n_x_nor = 1./iResolution.x;\n    float n_x_nor = 1./o_iResolution.x;\n    //float n_y_nor = 1./iResolution.y;\n    float n_y_nor = 1./o_iResolution.y;\n\n    vec2 o_scpino = vec2(n_x_nor, n_y_nor);\n    \n    float n_index = fragCoord.y * iResolution.x + fragCoord.x;\n    \n    vec4 o_col_last_xp1yp1 = texture(iChannel0, o_trpino+vec2(1.,1.)*o_scpino);  //oox\n    vec4 o_col_last_xp1yp0 = texture(iChannel0, o_trpino+vec2(1.,0.)*o_scpino);  //o.x\n    vec4 o_col_last_xp1ym1 = texture(iChannel0, o_trpino+vec2(1.,-1.)*o_scpino); //oox\n    \n    vec4 o_col_last_xm1yp1 = texture(iChannel0, o_trpino+vec2(-1.,1.)*o_scpino); //xoo\n    vec4 o_col_last_xm1yp0 = texture(iChannel0, o_trpino+vec2(-1.,0.)*o_scpino); //x.o\n    vec4 o_col_last_xm1ym1 = texture(iChannel0, o_trpino+vec2(-1.,-1.)*o_scpino);//xoo\n    \n    vec4 o_col_last_xp0ym1 = texture(iChannel0, o_trpino+vec2(0.,-1.)*o_scpino); //oxo\n    vec4 o_col_last_xp0yp0 = texture(iChannel0, o_trpino+vec2(0.,0.)*o_scpino);  //oxo\n    vec4 o_col_last_xp0yp1 = texture(iChannel0, o_trpino+vec2(0.,1.)*o_scpino);  //oxo\n    \n    bool b_xp1yp1 = o_col_last_xp1yp1.x > 0.5;\n    bool b_xp1yp0 = o_col_last_xp1yp0.x > 0.5;\n    bool b_xp1ym1 = o_col_last_xp1ym1.x > 0.5;\n    bool b_xm1yp1 = o_col_last_xm1yp1.x > 0.5;\n    bool b_xm1yp0 = o_col_last_xm1yp0.x > 0.5;\n    bool b_xm1ym1 = o_col_last_xm1ym1.x > 0.5;\n    bool b_xp0ym1 = o_col_last_xp0ym1.x > 0.5;\n    bool b_xp0yp0 = o_col_last_xp0yp0.x > 0.5;\n    bool b_xp0yp1 = o_col_last_xp0yp1.x > 0.5;\n\n    float n_neightbors_on = \n        float(b_xp1yp1)+\n        float(b_xp1yp0)+\n        float(b_xp1ym1)+\n        float(b_xm1yp1)+\n        float(b_xm1yp0)+\n        float(b_xm1ym1)+\n        float(b_xp0ym1)+\n        float(b_xp0yp1);\n    fragColor = o_fragColor;\n\n\n    if(mod(float(iFrame), n_hz/n_fps) == 0.0){\n    \n        if(\n            (n_neightbors_on == 2. && b_xp0yp0)\n            ||\n            n_neightbors_on == 3.\n            ){\n             fragColor = vec4(1.);\n        }else{\n                fragColor = vec4(0.);\n        }\n\n\n        float n_t = iTime;\n\n\n        if(iFrame == 0){\n                fragColor = vec4(f_n_rand(o_trpino.y*o_trpino.x+o_trpino.x)-0.2);\n        }\n\n    }\n\n    if(float(iMouse.z >= 0.) != 0.){\n        float n = length(o_trpino-o_trmono);\n        n = smoothstep(0.2, 0.1, n);\n        fragColor = fragColor+vec4(n);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 259]], "test": "untested"}
{"id": "msfSDl", "name": "GLSL bug #71  ( chrome+OpenGL)", "author": "FabriceNeyret2", "description": "On OpenGL+Chrome I see white on left and black on right, while it should be all black\nno bug on OpenGL FF\nbug report: https://bugs.chromium.org/p/chromium/issues/detail?id=1394345", "tags": ["glsl", "bug"], "likes": 4, "viewed": 250, "published": 3, "date": "1669714552", "time_retrieved": "2024-07-30T16:16:08.636859", "image_code": "\n\nvoid mainImage( out vec4 O,  vec2 U ) {\n  \n   float s; \n   \n   if (U.x < iResolution.x/2.) \n       U.x *= s = sin(iTime);          // On OpenGL, does = instead of *=\n   else {\n       s = sin(iTime); U.x *= s; \n       }    \n       \n   O = vec4( U.x == s ); \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 41, 41, 260]], "test": "untested"}
{"id": "mssXDf", "name": "Particles Party", "author": "leon", "description": "simple colorful particles system", "tags": ["particles"], "likes": 90, "viewed": 1485, "published": 3, "date": "1669712431", "time_retrieved": "2024-07-30T16:16:09.661120", "image_code": "\n// Particles Party\n\n// simple colorful particles system\n// will try voronoi tracking next time\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    float rng = texture(iChannel1, fragCoord/1024.).r;\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1.);\n    \n    // data\n    vec4 data = texture(iChannel0, uv);\n    float shade = data.r;\n    float mat = data.g;\n    \n    // rainbow\n    color = .5+.5*cos(vec3(1,2,3)*4.9 + mat);\n    \n    // light\n    vec3 un = vec3(0.005*aspect, 0);\n    #define T(un) texture(iChannel0, uv+un).r\n    vec3 normal = normalize(vec3(T(un.xz)-T(-un.xz),T(un.zy)-T(-un.zy), .5));\n    float d = dot(normal, normalize(vec3(0,-2,1)))*.5+.5;\n    color += pow(d, 10.);\n    \n    // shadow\n    color *= smoothstep(.0,.01,shade);\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float count = 100.;\n\nfloat speed = .3;\nfloat friction = 3.;\nfloat fade = 0.1;\nfloat thin = 0.02;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // buffer\n    vec4 frame = texture(iChannel0, uv);\n    \n    // pixels are data (bottom left)\n    if (fragCoord.y < 1. && fragCoord.x < count)\n    {\n        float id = fragCoord.x;\n            \n        // init\n        if (iFrame < 1)\n        {\n            // random position and velocity\n            frame = vec4(hash41(id)*2.-1.);\n            frame.zw *= .01;\n        }\n        else\n        {\n            // coordinates\n            vec2 aspect = vec2(iResolution.x/iResolution.y, 1.);\n            vec2 p = frame.xy;\n            vec2 offset = vec2(0);\n            vec2 target = vec2(0);\n            \n            // respawn\n            float t = iTime * 10.;\n            float idd = id+floor(t) * count;\n            if (hash11(idd) > .95 && fract(t) < .1)\n            {\n                frame = hash41(idd)*2.-1.;\n                frame.xy *= aspect;\n                frame.zw *= .01;\n                fragColor = frame;\n                return;\n            }\n            \n            // interaction\n            if (iMouse.z > 0.)\n            {\n                target = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n            }\n            \n            // curl\n            float noise = fbm(vec3(p, length(p) + iTime));\n            float a = noise * 6.28;\n            offset += vec2(cos(a), sin(a));\n            \n            // target\n            offset += normalize(target.xy-p) * 2. * length(target.xy-p);\n            \n            // jitter\n            offset += (hash21(id)*2.-1.)*(.5+.5*sin(iTime));\n            \n            // inertia\n            vec2 velocity = frame.zw;\n            velocity = velocity * (1.-friction*iTimeDelta) + offset * speed * iTimeDelta;\n            \n            // apply\n            frame.xy += velocity;\n            frame.zw = velocity;\n        }\n    }\n    \n    // pixels are colors\n    else\n    {\n        float matID = 0.;\n        float dist = 100.;\n        float dither = texture(iChannel1, fragCoord/1024.).r;\n\n        for (float i = 0.; i < count; ++i)\n        {\n            // iterate pixel data\n            vec4 data = texelFetch(iChannel0, ivec2(i,0), 0);\n            \n            // circle shape (jitter blending with previous pos)\n            vec2 pos = data.xy - data.zw * dither;\n            float shape = length(pos-p);\n            matID = shape < dist ? i : matID;\n            dist = min(dist, shape);\n        }\n\n        // grayscale\n        float shade = smoothstep(thin,.0,dist);\n\n        // buffer\n        frame.r = max(frame.r - fade, shade);\n        \n        // material layer\n        if (dist < thin) frame.g = matID;\n    }\n    \n    fragColor = frame;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 3; ++i, a/=2.)\n    {\n        result += (gyroid(seed/a))*a;\n    }\n    return result;\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 154, 885]], "test": "untested"}
{"id": "mdXSWl", "name": "Strong Interlacing", "author": "MysteryPancake", "description": "This will be YouTube in 2007", "tags": ["video", "buffer", "interlace", "interlacing"], "likes": 5, "viewed": 277, "published": 3, "date": "1669705873", "time_retrieved": "2024-07-30T16:16:10.480929", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int scale = 16;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    if (int(fragCoord.y) % scale == iFrame % scale) {\n        fragColor = texture(iChannel0, uv);\n    } else {\n        fragColor = texture(iChannel1, uv);\n    }\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "DdfSDl", "name": "Fork alternativ timrolls 805", "author": "timrolls", "description": "repro of those cooool motion: [url]https://twitter.com/RavenKwok/status/1117347303105294337[/url] [url]https://twitter.com/RavenKwok/status/1120716979302592513[/url]", "tags": ["2d"], "likes": 35, "viewed": 462, "published": 3, "date": "1669689824", "time_retrieved": "2024-07-30T16:16:11.237905", "image_code": "float eb(float x) {\n    x = 1. - x;\n    float y = x*x*(3.*x-2.);\n    return 1. - y;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat getBound(vec2 seed, float i) {\n    float p = rand(seed.xy + 1.);\n    if(i < 1.) {\n    \treturn rand(seed) * 0.1 + 0.4;\n    }\n    if(i > 1.0) {\n\t    if(p < 0.07) return 0.;\n    \tif(p > 0.93) return 1.;\n    }\n    return rand(seed) * 0.4 + 0.3;\n}\nfloat getBound(vec2 seed1, vec2 seed2, float intv, float i) {\n    float v1 = getBound(seed1, i);\n    float v2 = getBound(seed2, i);\n    return mix(v1,v2,eb(clamp(intv*2.0-i*0.3-rand(seed1)*0.2,0.,1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y*2.1;\n    vec2 ouv = uv;\n    vec3 col = vec3(1);\n    float ti = iTime * 2.0;\n    vec2 seed1 = vec2(floor(ti),1);\n    vec2 seed2 = vec2(floor(ti)+1.,1);\n    vec2 le1 = vec2(floor(rand(seed1.yx)*16.),floor(rand(seed1.xx)*16.))/16.;\n    vec2 le2 = vec2(floor(rand(seed2.yx)*16.),floor(rand(seed2.xx)*16.))/16.;\n\n    float intv = fract(ti);\n    float ttv = intv;\n    if(abs(uv.x) > 2.0 || abs(uv.y) > 1.0) {\n    } else {\n        float dif = 1.0;\n        uv = uv * vec2(0.25,0.5) + 0.5;\n        vec2 center1 = vec2(0.5,0.5);\n        vec2 size1 = vec2(1,1);\n        vec2 center2 = vec2(0.5,0.5);\n        vec2 size2 = vec2(1,1);\n        for(int i=0;i<8;i++) {\n            float boundX = getBound(seed1,seed2,intv,float(i));\n            float boundX1 = getBound(seed1, float(i));\n            float boundX2 = getBound(seed2, float(i));\n            center1.x -= (0.5 - boundX1) * size1.x;\n            center2.x -= (0.5 - boundX2) * size2.x;\n            if(uv.x < boundX) {\n                uv.x /= boundX;\n                seed1.x += dif, seed2.x += dif;\n                size1.x *= boundX1, size2.x *= boundX2;\n                center1.x -= size1.x * 0.5, center2.x -= size2.x * 0.5;\n            } else {\n                uv.x = (uv.x - boundX) / (1. - boundX);\n                seed1.x -= dif, seed2.x -= dif;\n                size1.x *= 1. - boundX1, size2.x *= 1. - boundX2;\n                center1.x += size1.x * 0.5, center2.x += size2.x * 0.5;\n                intv += 0.15 * dif;\n            }\n\t        seed1 = seed1.yx;\n\t        seed2 = seed2.yx;\n            dif /= 2.0;\n            \n            if(i > 0) {\n                float boundY = getBound(seed1, seed2, intv, float(i));\n                float boundY1 = getBound(seed1, float(i));\n                float boundY2 = getBound(seed2, float(i));\n                center1.y -= (0.5 - boundY1) * size1.y;\n                center2.y -= (0.5 - boundY2) * size2.y;\n                if(uv.y < boundY) {\n                    uv.y /= boundY;\n                    seed1.y += dif, seed2.y += dif;\n                    size1.y *= boundY1, size2.y *= boundY2;\n                    center1.y -= size1.y * 0.5, center2.y -= size2.y * 0.5;\n                } else {\n                    uv.y = (uv.y - boundY) / (1. - boundY);\n                    seed1.y -= dif, seed2.y -= dif;\n                    size1.y *= 1. - boundY1, size2.y *= 1. - boundY2;\n                    center1.y += size1.y * 0.5, center2.y += size2.y * 0.5;\n                    intv += 0.15 * dif;\n                }\n            }\n            seed1 = seed1.yx;\n            seed2 = seed2.yx;\n            dif /= 2.0;\n        }\n        vec2 coord0 = (center1-vec2(0.25,0))/vec2(8.0,16.0);\n        vec2 coord1 = (center2-vec2(0.25,0))/vec2(8.0,16.0);\n        coord0 = clamp(coord0, 0., 1./16.);\n        coord1 = clamp(coord1, 0., 1./16.);\n        vec4 c0 = texture(iChannel0, coord0+le1).xyzw;\n        vec4 c1 = texture(iChannel0, coord1+le2).xyzw;\n        ttv = smoothstep(0.,1.,-0.7 + ttv*4.0 - rand(center1)*2.0);\n        float ld = rand(seed1+seed2) < 0.5 ? 1. : 0.;\n        float ldu = rand(seed1-seed2) < 0.5 ? 1. : 0.;\n        float lb = mix(1.,-1.,ldu);\n        float mixParam = ld < 0.5\n            ? step(uv.x, lb*ttv+ldu)\n            : step(uv.y, lb*ttv+ldu);\n        col *= 1. - mix(c1.x,c0.x,mixParam);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [86, 86, 106, 106, 178], [180, 180, 216, 216, 428], [429, 429, 490, 490, 633], [635, 635, 692, 692, 4089]], "test": "untested"}
{"id": "DslXWX", "name": "just a dot for my cat", "author": "jonasfrey", "description": "my cat likes to follow the cursor on my screen so i made her a dot to follow", "tags": ["dot"], "likes": 2, "viewed": 184, "published": 3, "date": "1669676607", "time_retrieved": "2024-07-30T16:16:12.041755", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 o_p_mouse_data = vec2(0.0, 0.0);\n    \n    //if(fragCoord == o_p_mouse_data){\n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(iMouse.x, iMouse.y, 0.0, 0.0);\n    }else{\n    \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 o_pixel_coo_nor = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n        vec2 o_mouse_coo_nor = (iMouse.xy-iResolution.xy*0.5)/iResolution.y;\n\n        vec4 o_iMouse_last = texture(iChannel0, o_p_mouse_data);\n        vec2 o_iMouse_delta = abs(iMouse.xy - o_iMouse_last.xy);\n        vec2 o_iMouse_delta_nor = (o_iMouse_delta.xy)/iResolution.xy;\n\n        float n_length = length(o_mouse_coo_nor-o_pixel_coo_nor);\n        // Output to screen\n        float n_len_mouse_delta = length(o_iMouse_delta_nor);\n        float n_size = 0.02+pow(n_len_mouse_delta, 1./1.4);\n        float n_size_min = o_iMouse_delta_nor.x;\n        float n_size_t = sin(iTime*2.)*(n_size/2.)+(n_size/2.)+n_size_min;\n        n_length = smoothstep(n_size*2., n_size, n_length);\n        \n        vec4 o_col_last = texture(iChannel0, uv);\n        fragColor = mix(o_col_last, (vec4(n_length)), 0.045);\n\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "dssSWf", "name": "weird tube draw", "author": "jonasfrey", "description": "use the mouse to draw!", "tags": ["dot"], "likes": 6, "viewed": 197, "published": 3, "date": "1669676450", "time_retrieved": "2024-07-30T16:16:12.801724", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// original: https://www.shadertoy.com/view/4djSRW\nfloat f_n_rand(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 o_p_mouse_data = vec2(0.0, 0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_pixel_coo_nor = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 o_mouse_coo_nor = (iMouse.xy-iResolution.xy*0.5)/iResolution.y;\n\n\n    if(iMouse.z == 0.0){\n        o_mouse_coo_nor = vec2(\n            sin(iTime+f_n_rand(iTime)*0.1)*0.5,\n            cos(iTime+f_n_rand(iTime)*0.1)*0.5\n        );\n        \n    }\n    //if(fragCoord == o_p_mouse_data){\n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(o_mouse_coo_nor, 0.0, 0.0);\n    }else{\n    \n\n        vec4 o_mosue_coo_nor_last = texture(iChannel0, o_p_mouse_data);\n        vec2 o_mosue_coo_nor_delta = abs(o_mouse_coo_nor.xy - o_mosue_coo_nor_last.xy);\n\n        float n_length = length(o_mouse_coo_nor-o_pixel_coo_nor);\n        // Output to screen\n        float n_len_mouse_delta = length(o_mosue_coo_nor_delta);\n        float n_size = 0.001+pow(n_len_mouse_delta, 1./1.4);\n        float n_size_min = o_mosue_coo_nor_delta.x;\n        float n_size_t = sin(iTime*2.)*(n_size/2.)+(n_size/2.)+n_size_min;\n        n_length = smoothstep(n_size*2., n_size, n_length);\n        \n        vec4 o_col_last = texture(iChannel0, uv);\n        fragColor = mix(o_col_last, (vec4(n_length)), n_length);\n\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "mdlSWf", "name": "vonoroi simple with colors", "author": "jonasfrey", "description": "just experimenting with vonoroi and colors", "tags": ["vonoroi"], "likes": 5, "viewed": 172, "published": 3, "date": "1669673491", "time_retrieved": "2024-07-30T16:16:14.027446", "image_code": "// credits: https://www.shadertoy.com/view/4djSRW\n\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = (fragCoord.xy - (iResolution.xy *0.5)) / iResolution.y;\n    o_trpino*=0.5;\n    float n_points = 200.;\n    float n_dist_min = 1.;\n    float n_dist_min2 = 2.;\n    float n_dist_min3 = 2.;\n    \n    float n_t = iTime*0.001;\n    \n    for(float n_p = 0.; n_p < n_points; n_p+=1.){\n        \n        float n_p_nor = ((1./n_points) * n_p);\n        \n        float n_rand = f_n_rand(n_p_nor+n_t)-0.5;\n        //float n_rand2 = f_n_rand(n_rand+n_t)-0.5;\n        float n_rand2 = f_n_rand(1.-n_p_nor)-0.5;\n        \n        vec2 o_rand = vec2(n_rand, n_rand2);\n        \n        float n_dist = length(o_trpino - o_rand);\n        \n        \n        if(n_dist < n_dist_min){\n            n_dist_min = n_dist;\n        }else{\n        \n            if(n_dist < n_dist_min2){\n                n_dist_min2 = n_dist;\n            }else{\n            \n                if(n_dist < n_dist_min3){\n                    n_dist_min3 = n_dist;\n                }\n            \n            }\n        }\n        //n_dist_min = min(n_dist, n_dist_min);\n        //n_dist_min2 = min(n_dist_min2, max(n_dist, n_dist_min));\n        //n_dist_min3 = min(n_dist_min3, max(n_dist, n_dist_min2));\n        \n                \n        \n    }\n    \n    fragColor = vec4(\n        n_dist_min,\n        n_dist_min2,\n        n_dist_min3,\n        1.0\n    );\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 76, 76, 161], [163, 163, 220, 220, 1566]], "test": "untested"}
{"id": "cdsSRf", "name": "The Way of Light", "author": "derSchamane", "description": "An experiment with a 3D transparent type of raymarcher.\nResults in a chain of constantly morphing kaleidoscopic menger cubes looking kind of sacred.\n\nRotate view by dragging mouse.\n\nsubstance reference: DPT (Dipropyltryptamine)", "tags": ["3d", "fractal", "tunnel", "transparent"], "likes": 17, "viewed": 519, "published": 3, "date": "1669673203", "time_retrieved": "2024-07-30T16:16:14.790406", "image_code": "//                    = The Way of Light =         \n//               by Maximilian Knape  ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(1) //vec3(.4545)\n\n#define MAX_STEPS 300\n#define MAX_DIST 500.\n#define MIN_DIST 10.\n#define STEP_FAC 5.\n\n#define SURF_DIST .001\n#define SURF_MUL 1000.\n#define SURF_EXP 5.\n\n#define PP_ACES 0.\n#define PP_CONT 0.8\n#define PP_VIGN 2.0\n\n#define iTime iTime*1.0\n#define PI 3.14159265358979\n#define TAU 6.28318530717958\n#define S(x,y,t) smoothstep(x,y,t)\n\nvec2 Map(vec3 p) \n{    \n    float d = MAX_DIST, col = 0.;\n    vec3 op = p;\n    \n    float s = 22.; //size\n    float sp = iTime*5.; //speed\n    \n    \n    p.z = mod(abs(s*2. - mod(p.z + sp, s*4.)), s*4.); //mirror\n    p.xy += normalize(p.xy) * (S(0., MAX_DIST, op.z)*40. - S(0., MAX_DIST, -op.z)*30.); //xy size\n    p.xy *= Rot(PI/4. * step(0., sin(PI*(op.z + sp) / (8.*s)))); //rotator\n    \n    float cy = length(op.xy);\n    if (cy < s*5.) //bounding cylinder\n    {\n        vec2 glow = sdKMC( //light fractal\n                p/8., 3, vec3(pow(sin(iTime/32. + op.z/s*.1), 3.)*2.), \n                vec3(pow(sin(iTime/42. + op.z/s*.01), 3.)*PI/4.), \n                vec4(1,3,5,5)); \n\n        float split = 30. + sin(iTime/13.)*10.; //two colors/materials\n        \n        glow.x = pow(glow.x, 1.5 + step(split, glow.y) * (sin(iTime - op.z/s)-1.)*.3); //color waves\n        glow.x -= (pow(sin(-(op.z + sp) / s), 2.) - step(split, glow.y))*.001; //thickness\n        \n        col = mix(col, 1.0 - step(glow.y, split), step(glow.x, d)); //color\n        d = min(glow.x, d); \n    }\n    else d = min(d, cy - s*7.);\n    \n    return vec2(d, col);\n}\n\nvec3 Palette(int index, float depth)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.)*.8;\n        case 1: return hsv2rgb_smooth(vec3(fract(depth), .9, 1.));\n    }\n    return vec3(0.);\n}\n\nvec3 RTM(vec3 ro, vec3 rd) \n{\n    int steps;\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIST;\n    const float a = 1. / float(MAX_STEPS); \n    vec3 p = vec3(0), col = vec3(1);\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIST * (pow(d/MAX_DIST, SURF_EXP)*SURF_MUL+1.)); //can be DOF\n        if (s < sd || d > MAX_DIST) break;\n        \n        steps = i;\n        p = ro + rd*d;\n        \n        vec2 map = Map(p);\n        col = mix(col, Palette(int(floor(map.y)), (p.z-iTime*5.)/MAX_DIST*.5), .02 * (1.-sum)); //color overlap\n        \n        s = max(abs(map.x), 2. * sd);\n        d += s * STEP_FAC * (1.1 - fract(map.y));\n        \n        sum += a;\n    }\n    \n    float dp = pow(1. - (length(ro - p) / MAX_DIST), SURF_EXP);\n    \n    col *= sum - dp;\n    \n    if (dp <= 10e-1) //Background\n    {\n        float dir = dot(vec3(0,0,1), rd)*.5+.5;\n        float bg = pow(dir, 5.)*.2; //glow\n        bg += pow(dir, 5000.)*.8; //core\n        bg *= (1. - S(.99, .9, dir) * //rays\n                    noise(normalize(vec2(abs(rd.x), rd.y)*Rot(iTime/25.)) * \n                    (10.+5.*sin(iTime/17.))));\n        \n        col += bg;\n    }\n    \n    col *= pow(1. - max(0., dot(vec3(0,0,-1.), rd)), .1);\n        \n    return col;\n}\n\nvec4 PP(vec3 col, vec2 uv) //PostProcessing\n{\n    col = mix(col, (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14), PP_ACES);\n    col = mix(col, S(vec3(0.1), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(0., 0., -10.);\n    ro.yz *= Rot(-m.y * PI + PI*.5);\n    ro.xz *= Rot(-m.x * PI*2. - PI);\n    vec3 rd = R(uv, ro, vec3(0., 0., 0.), .7);\n\n    fragColor = PP(RTM(ro, rd), uv);\n}", "image_inputs": [], "common_code": "//   -----= Inigo Quilez =-----\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); }\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n//   -------= IQ END =-------\n\nmat2 Rot(in float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(in vec3 p, in vec3 r) //las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\n\nvec2 sdKMC( in vec3 p,    //KIFS Mengerbox\n            in int iters,\n            in vec3 fTra,\n            in vec3 fRot,\n            in vec4 para)\n{\n    int i;\n    float d, col = 0.;\n    float x1, y1;\n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    \n    for(i = 0; i < iters && r < 10e2; i++)\n    {\n        p = abs(p);\n\n        if (p.x-p.y < 0.) { x1=p.y; p.y=p.x; p.x=x1;}\n        if (p.x-p.z < 0.) { x1=p.z; p.z=p.x; p.x=x1;}\n        if (p.y-p.z < 0.) { y1=p.z; p.z=p.y; p.y=y1;}\n\n        p.z -= 0.5 * para.x * (para.y - 1.) / para.y;\n        p.z = -abs(p.z);\n        p.z += 0.5 * para.x * (para.y - 1.) / para.y;\n\n        p.x = para.y * p.x - para.z * (para.y - 1.);\n        p.y = para.y * p.y - para.w * (para.y - 1.);\n        p.z = para.y * p.z;\n\n        col = r;\n        r = p.x*p.x + p.y*p.y + p.z*p.z;\n        \n        p -= fTra;\n        p = Rot(p, fRot);\n    }\n    \n    d = length(p) * pow(para.y, float(-i));\n\n    return vec2(d, col);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l, in float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsSRf.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[665, 665, 684, 684, 1801], [1803, 1803, 1841, 1841, 2006], [2008, 2008, 2037, 2037, 3271], [3273, 3273, 3318, 3318, 3583], [3585, 3585, 3640, 3640, 3976]], "test": "untested"}
{"id": "ddlXDX", "name": "Morse Audio", "author": "Peace", "description": "Morse Audio", "tags": ["audio", "code", "morse"], "likes": 5, "viewed": 170, "published": 3, "date": "1669668230", "time_retrieved": "2024-07-30T16:16:15.588273", "image_code": "void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(1.0 - step(abs(mainSound(0, iTime).x), 0.0));\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "sound_code": "// See Common", "sound_inputs": [], "common_code": "#define PI 3.14159\n#define TWO_PI 6.28318530718\n// Morse code audio frequency\n#define FREQ 800.0\n\nconst float DL = 0.05; // Dot (dit) length\nconst float SL = DL; // Space length\nconst float LS = DL * 3.0; // Letter space length\nconst float WS = DL * 7.0; // Word space length\nconst float _L = DL * 3.0; // Dash (dah) length\n\nfloat ct = 0.0; // Current time\nfloat st = 0.0; // Start time used for note timings\nstruct Wave {\n    float frequency;\n    float amplitude;\n    float phase;\n};\n\n// Pause for duration 'd'\nfloat p(float d) {\n    st += d;\n    return 0.0;\n}\n\n// Play frequency 'freq' for duration 'd'\nfloat f(float freq, float d) {\n    float fq = (ct >= st && ct < (st + d)) ? freq : 0.0;\n    p(d);\n    return fq;\n}\n\n// Makes a wave from frequency, amplitude and time\nfloat w(Wave w) {\n    return w.amplitude * sin(w.phase * w.frequency * TWO_PI);\n}\n\nfloat dit() {\n    return f(FREQ, DL) + p(SL);\n}\n\nfloat dah() {\n    return f(FREQ, _L) + p(SL);\n}\n\nfloat ls() {\n    return p(LS - SL);\n}\n\nfloat ws() {\n    return p(WS - SL);\n}\n\nfloat A() {\n    return dit() + dah() + ls();\n}\n\nfloat B() {\n    return dah() + dit() + dit() + dit() + ls();\n}\n\nfloat C() {\n    return dah() + dit() + dah() + dit() + ls();\n}\n\nfloat D() {\n    return dah() + dit() + dit() + ls();\n}\n\nfloat E() {\n    return dit();\n}\n\nfloat F() {\n    return dit() + dit() + dah() + dit() + ls();\n}\n\nfloat G() {\n    return dah() + dah() + dit() + ls();\n}\n\nfloat H() {\n    return dit() + dit() + dit() + dit() + ls();\n}\n\nfloat I() {\n    return dit() + dit() + ls();\n}\n\nfloat J() {\n    return dit() + dah() + dah() + dah() + ls();\n}\n\nfloat K() {\n    return dah() + dit() + dah() + ls();\n}\n\nfloat L() {\n    return dit() + dah() + dit() + dit() + ls();\n}\n\nfloat M() {\n    return dah() + dah() + ls();\n}\n\nfloat N() {\n    return dah() + dit() + ls();\n}\n\nfloat O() {\n    return dah() + dah() + dah() + ls();\n}\n\nfloat P() {\n    return dit() + dah() + dah() + dit() + ls();\n}\n\nfloat Q() {\n    return dah() + dah() + dit() + dah() + ls();\n}\n\nfloat R() {\n    return dit() + dah() + dit() + ls();\n}\n\nfloat S() {\n    return dit() + dit() + dit() + ls();\n}\n\nfloat T() {\n    return dah() + ls();\n}\n\nfloat U() {\n    return dit() + dit() + dah() + ls();\n}\n\nfloat V() {\n    return dit() + dit() + dit() + dah() + ls();\n}\n\nfloat W() {\n    return dit() + dah() + dah() + ls();\n}\n\nfloat X() {\n    return dah() + dit() + dit() + dah() + ls();\n}\n\nfloat Y() {\n    return dah() + dit() + dah() + dah() + ls();\n}\n\nfloat Z() {\n    return dah() + dah() + dit() + dit() + ls();\n}\n\nfloat w(float freq) {\n    return freq + ws();\n}\n\nvec2 mainSound(int samp, float time) {\n    ct = time;\n    float amplitude = 0.1;\n    float frequency = ws() + w(W() + H() + A() + T()) + w(A() + R() + E()) + w(Y() + O() + U()) + w(D() + O() + I() + N() + G());\n    \n    Wave w1 = Wave(frequency, amplitude, time);\n    \n    vec2 r = vec2(w(w1));\n    \n    return r * 0.2;\n}                            ", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 193]], "test": "untested"}
{"id": "mssXWX", "name": "Blackbody spectrum", "author": "fishy", "description": "Blackbody spectrum using Planck's law (I just copied the function from Wikipedia: https://en.wikipedia.org/wiki/Planck%27s_law#The_law) and an eye response curve (based on: https://commons.wikimedia.org/wiki/File:Cone-fundamentals-with-srgb-spectrum.svg)", "tags": ["spectrum", "blackbody"], "likes": 3, "viewed": 222, "published": 3, "date": "1669666940", "time_retrieved": "2024-07-30T16:16:16.343254", "image_code": "#define HPI 1.57079632679\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define sat(x) clamp(x, 0.0, 1.0)\n\nfloat blackbody(float v, float t)\n{\n    return 2.*v*v*v*(1./(exp(v/t) - 1.));\n}\n\nfloat responseCurve(float w, float p, float v)\n{\n    return sin(TAU*sat((v-p)/w + 0.5) - HPI)*0.5+0.5;\n}\n\nvec3 eyeResponsivity(float v)\n{\n    return vec3(responseCurve(100., 440., v),\n                responseCurve(200., 550., v),\n                responseCurve(200., 600., v)\n                );\n}\n\nvec3 getBlackbodyColor(float steps, float t)\n{\n    vec3 col = vec3(0);\n    vec3 m = vec3(0);\n    float stInc = 300./steps;\n    for(float v = 400.; v < 700.; v += stInc)\n    {\n        vec3 r = eyeResponsivity(v);\n        m += r;\n        col += blackbody(v, t)*r*vec3(0.11, 0.59, 0.3);\n    }\n    return col/m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(sqrt(getBlackbodyColor(20., uv.x*50.+15.) / (1.0 + getBlackbodyColor(20., uv.x*50.+15.))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 147, 147, 191], [193, 193, 241, 241, 297], [299, 299, 330, 330, 488], [490, 490, 536, 536, 799], [802, 802, 859, 909, 1093]], "test": "untested"}
{"id": "dslSWX", "name": "Greg 3", "author": "SnoopethDuckDuck", "description": "Make sure to pause and restart the sound so it syncs!\n\nThis is the long awaited prequel to Greg 2 https://www.youtube.com/watch?v=GmGLr3c-irA", "tags": ["greg", "greeg", "grog", "thegreggening", "garg", "gegr"], "likes": 12, "viewed": 200, "published": 3, "date": "1669662876", "time_retrieved": "2024-07-30T16:16:17.121174", "image_code": "#define MAX_STEPS 400\n\n// dont read this code, its not worth it\n// you will only find pain if you continue\n\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define rn 64.\n\nfloat getFreq(float x) {\n\treturn texture(iChannel0, vec2(floor(x * rn + 1.) / rn, 0)).x;\n}\n\nfloat getFreq_smooth(float x) {\n\tfloat index = floor(x * rn) / rn;\n    float next = floor(x * rn + 1.0) / rn;\n\treturn mix(getFreq(index), getFreq(next), smoothstep(0.0, 1.0, fract(x * rn)));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat sdSeg(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 rayOri() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float th = tanh(0.08 * iTime);\n    vec3 ro = vec3(0, 13, 3. + 40. * (1.-th));\n    if (iTime > 14.) {\n        float a = 2. * pi * h21(vec2(floor(0.5 * iTime), 11.));\n        if (iTime < 40.)\n            ro.xz *= rot(a + iTime * 10.);\n        else if (iTime > 90. && iTime < 105.) {\n            ro = vec3(0, 13, 3.);\n            ro.xz *= rot(iTime * 4.);\n        }            \n        else\n            ro.xz *= rot(a + iTime);\n        ro.y = 2. * a / pi;\n    }\n    if (iTime > 126.)\n        ro.x += 0.2 * iTime - 126.;\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat dist(vec3 p) {\n    float pd = p.y;\n    float f = getFreq_smooth(0.);\n    float s = 0.04;\n    \n    if (iTime > 90. && iTime < 127.) {\n        pd += 5. * f;\n    }\n    else {\n        if (iTime > 40.) {\n            //p.x += iTime * 1000.;\n            p.xz = mod(p.xz, s * iTime) - 0.5 * s * iTime;\n            p *= 0.6;\n            if (iTime > 50.)\n                p.xz *= rot(4. * iTime);\n                if (iTime > 60.) {\n                p.y -= 1.5;\n                p.yz *= rot(10. * iTime);\n                p.y += 1.5;\n            }\n    }     \n    }\n    \n    float sc = 2. * pow(f, 2.);//1.5 + 0.1 * thc(4., 2. * pi * h21(p.xz) + 10. * iTime);\n    \n    if (iTime > 14.)\n        p *= sc;\n    else\n        p *= 0.2;\n    if (iTime < 40.) {\n        p.y -= 1.5;\n\n        p.xy *= rot(pi-pi * thc(4., pi/2. + iTime));\n        p.y += 1.5;\n        p.xz *= rot(10. * thc(4., iTime));\n    }\n    float sd = length(p - vec3(0,3,0)) - 0.3;\n    float ld = sdSeg(p, vec3(0,1.5,0), vec3(0,3,0), 0.1);\n    float ld2 = sdSeg(p, vec3(-1,2.2,0), vec3(1,2.2,0), 0.075);\n    float ld3 = sdSeg(p, vec3(0,1.5,0), vec3(0.5,0,0), 0.1);\n    float ld4 = sdSeg(p, vec3(0,1.5,0), vec3(-0.5,0,0), 0.1);    \n    float d = min(pd, sd);\n    d = smin(d, ld, 0.12);\n    d = smin(d, ld2, 0.04);\n    d = min(d, ld3);\n    d = min(d, ld4);\n    \n    if (iTime < 14.)\n        return d / (2.);\n    return d / sc;\n}\n\nfloat march(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = dist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = dist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy),\n        dist(p-e.yxy),\n        dist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = rayOri();\n    \n    float fr = fract(0.5 * iTime);\n    \n    float h = h21(vec2(131., floor(0.5 * iTime)));\n    float th = tanh(0.2 * max(0., iTime - 12.));\n    if (iTime < 14.) {\n        th = 16.;\n        h = 0.;\n        fr = 1.;\n    }\n    vec3 rd = rayDir(uv, ro, vec3(0, th + h,0), 0.+ fr);\n    if (iTime > 90. && iTime < 105.)\n        rd = rayDir(uv, ro, vec3(0, th + h,0), 1.);\n    \n    vec3 col = vec3(0);\n   \n    float d = march(ro, rd, 1.);\n    \n    vec3 p = ro + rd * d;\n      vec3 n = normal(p);\n    float IOR = 1.2;\n    if(d<MAX_DIST) {        \n      \n        vec3 r = reflect(rd, n);\n\n\n        vec3 lightDir = normalize(vec3(cos(iTime),0.5 * sqrt(2.),sin(iTime)));\n        float dif  = dot(n,  lightDir)*.5+.5;\n        \n        float f = getFreq_smooth(0.);\n        \n        col = vec3(dif) * 10. * th * pow(f, 10.) * pal(4. * f, vec3(0,1,2)/3.); \n        if (p.y < 0.01) {\n            col *= 1./exp(f * 0.25 * length(p.xz));\n            col *= th;\n            col *= 0.75 + 0.25 * thc(4., 2. * pi * f + log(length(p.xz)) * 6. - iTime * 10.);\n            \n            if (iTime > 40. && iTime < 105.)\n                col *=.2 + .8 *mod(floor(0.39 * p.x) + floor(0.4 * p.z), 2.);\n        }\n        else \n            col = mix(vec3(1,0,0), vec3(1), 1.-sqrt(f)) * dif;\n    } \n    \n   // if (iTime > 0.)\n    vec3 tx = texture(iChannel1, p).rgb;\n    col = mix(col, tx, 1.-tanh(0.25 * iTime));\n    if (iTime > 105.)\n        col = mix(col, tx, 0.5 + .5*thc(4., iTime));      \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30621, "src": "https://soundcloud.com/athena-landsman/danger-4h30?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 194, 194, 260], [262, 262, 293, 293, 454], [456, 456, 485, 485, 566], [568, 568, 602, 602, 678], [680, 680, 726, 726, 847], [849, 849, 864, 864, 1508], [1510, 1510, 1530, 1530, 2886], [2888, 2888, 2928, 2928, 3232], [3234, 3234, 3255, 3255, 3433], [3435, 3435, 3482, 3482, 3673], [3675, 3675, 3732, 3732, 5382]], "test": "untested"}
{"id": "cdlSWf", "name": "Cracked heirloom", "author": "mrange", "description": "CC0: Cracked heirloom\nTinkering with distored toruses and a favorite shader \nTrippy Triangle by Tater: https://www.shadertoy.com/view/fslcDS\n", "tags": ["voronoi", "raymarch"], "likes": 44, "viewed": 637, "published": 3, "date": "1669655479", "time_retrieved": "2024-07-30T16:16:17.887126", "image_code": "// CC0: Cracked heirloom\n//  Tinkering with distored toruses and a favorite shader \n//  Trippy Triangle by Tater: https://www.shadertoy.com/view/fslcDS\n\n#define GLOW\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define PI_2            (0.5*PI)\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  12.0\n#define MAX_RAY_MARCHES 60\n#define MAX_SHADOW_MARCHES 30\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define H13(n) fract((n)*vec3(12.9898,78.233,45.6114)*43758.5453123)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat hexTorus(vec3 p, vec3 d) {\n  vec2 q = vec2(length(p.xz) - d.x, p.y);\n  float a = atan_approx(p.x, p.z);\n  const float off = PI*0.875;\n  a = abs(a);\n  float b = a;\n  b -= off;\n  b = -pabs(b, 1.0);\n  b += off;\n  a *= b;\n  mat2 r = ROT(-4.0*a/6.0);\n  return hex(r*q, d.y)-d.z;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nvec2 vor(vec2 v, vec3 p, vec3 s){\n  p = abs(fract(p-s)-0.5);\n  float a = max(p.x,max(p.y,p.z));\n  float b = min(v.x,a);\n  float c = max(v.x,min(v.y,a));\n  return vec2(b,c);\n}\n\n// https://www.shadertoy.com/view/7sByWR\nfloat vorMap(vec3 p){\n  const vec3 v0 = H13(0.96);\n  const vec3 v1 = H13(0.55);\n  const vec3 v2 = H13(0.718);\n  const vec3 v3 = H13(0.3);\n  const mat2 r0 = ROT(1.2);\n  const mat2 r1 = ROT(2.0);\n  const mat2 r2 = ROT(2.7);\n  vec2 v = vec2(5.0);\n  v = vor(v,p,v0);\n  p.xy*=r0;\n  v = vor(v,p,v1);\n  p.yz*=r1;\n  v = vor(v,p,v2);\n  p.zx*=r2;\n  v = vor(v,p,v3);\n  return v.y-v.x; \n}\n\nfloat df(vec3 p) {\n  vec3 p0 = p.zxy;\n  float d0 = hexTorus(p0, vec3(2.0, 0.65, 0.025));\n  float d1 = p.x+1.0;\n  vec2 pp = p.yz;\n  pp.y = -abs(pp.y);\n  const vec2 nn = normalize(vec2(1.5, 1.));\n  float vf = 0.025*dot(pp, nn);\n  float d2 = vorMap(p)-vf;\n  float d = d0;\n  d = pmax(d, -d2, 0.0125);\n  d = min(d, d1);\n\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\n\nfloat softShadow(vec3 ps, vec3 ld, float mint, float k) {\n  float res = 0.0;\n  float t = mint*7.0;\n  for (int i=0; i<MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = df(p);\n    if (d < 0.0) return 0.0;\n    res += 0.05*inversesqrt((d));\n    if (res > 1.0) {\n      return 0.0;\n    };\n    t += max(d, mint);\n  }\n  return clamp(1.0-res, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 lightPos = vec3(5.0, 3.0, 1.0)*2.;\n  const float i = 100.0; \n  const float h = 0.55;\n  const vec3 dcol = HSV2RGB(vec3(h, 0.25, i));\n  const vec3 scol = HSV2RGB(vec3(h, 0.25, i));\n  \n  float t = rayMarch(ro, rd);\n  vec3 col = vec3(0.0);\n\n#ifdef GLOW\n  float gf = 0.5+0.5*cos(TAU*TIME/10.0);\n  float gr = mix(0.62, 0.57, gf);\n  float gd = sphered(ro, rd, vec4(vec3(0.19, 2.0-0.025, 0.0), gr), t);\n  vec3 gcol = hsv2rgb(vec3(h, mix(0.75, 0.9, gf), mix(60.0, 2.0, gf)));\n#endif\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  vec3 ld = normalize(lightPos - p);\n  float ll2 = dot(lightPos - p, lightPos - p);\n  float sd = softShadow(p, ld, 0.025, 2.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 10.0);\n  if (t < MAX_RAY_LENGTH) {\n    col = dcol;\n    col *= mix(0.1, 1.0, dif);\n    col *= mix(0.2, 1.0, sd);\n    col += spe*sd*scol;\n    col /= ll2;\n  }\n#ifdef GLOW\n  col += gcol*gd;\n#endif  \n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const vec3 ro = vec3(5.0, 0.0, 0.01);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(1.75, 1.0-0.5, length(pp));\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[768, 768, 790, 790, 936], [1231, 1331, 1350, 1350, 1437], [1439, 1546, 1572, 1572, 1756], [1758, 1844, 1881, 1881, 1988], [1990, 2108, 2136, 2136, 2316], [2318, 2418, 2457, 2457, 2542], [2544, 2644, 2683, 2683, 2712], [2715, 2803, 2833, 2833, 2861], [2863, 2956, 2988, 2988, 3237], [3239, 3334, 3392, 3392, 3873], [3875, 3875, 3908, 3908, 4049], [4051, 4092, 4113, 4113, 4468], [4470, 4470, 4488, 4488, 4799], [4801, 4801, 4824, 4824, 5032], [5034, 5034, 5068, 5068, 5400], [5403, 5403, 5460, 5460, 5764], [5766, 5766, 5797, 5797, 6770], [6772, 6772, 6793, 6793, 7154], [7155, 7155, 7212, 7212, 7493]], "test": "untested"}
{"id": "dsfSWf", "name": "Maybe it's alive", "author": "Trixelized", "description": "A weird little blob", "tags": ["blob"], "likes": 21, "viewed": 454, "published": 3, "date": "1669642720", "time_retrieved": "2024-07-30T16:16:18.651084", "image_code": "float map(vec3 pos) {\n    \n    float ret = 0.0;\n    \n    ret += length(pos + vec3(\n        (sin(iTime * 0.9 + pos.y * 6.0) - cos(pos.z * 0.823)) * 0.1,\n        (cos(iTime * 0.8 + pos.x * 7.3) - cos(pos.x * 0.956)) * 0.1,\n        cos(iTime * 2.3 - pos.y * 8.0 + pos.x * 4.4) * 0.05));\n    \n    return ret;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    uv *= 1.75;\n    \n    vec3 off = vec3(1.0 / iResolution.xy, 0.0);\n    \n    vec3 col = vec3(0.0);\n    \n    for (int j=0; j<10; j++) {\n        \n        float js = pow(float(j) * 0.075, 2.5);\n        \n        vec3 pos = vec3(uv.x, uv.y, js - 0.5);\n        float v =\n            smoothstep(0.6 + js * 0.55, 0.5, map(pos))\n            * smoothstep(0.5, 0.6 + js * 0.25, map(pos + vec3(0.1, 0.2, 0.0)));\n        \n        float w =\n            smoothstep(0.9 + js * 0.55, 0.8, map(pos))\n            * smoothstep(0.6, 1.5 + js * 0.25, map(pos - vec3(0.2, 0.1, 0.0)));\n        \n        \n        col += v * vec3(0.5 + js, 0.5 - js, 1.0);\n        \n        col += w * vec3(0.05 + js, 0.0, 0.05 + js);\n        \n        col -= dot(pos - 15.5, off);\n    }\n    \n    col /= 10.0;\n    \n    \n    fragColor = vec4(smoothstep(0.0, 0.5, col), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 311], [313, 313, 370, 370, 1303]], "test": "untested"}
{"id": "mdXSWf", "name": "HudRemix", "author": "Del", "description": "Simple busy HUD (remix) - https://www.twitch.tv/videos/1662202941", "tags": ["circle", "hud"], "likes": 7, "viewed": 195, "published": 3, "date": "1669642069", "time_retrieved": "2024-07-30T16:16:19.430001", "image_code": "// Simple busy HUD - https://www.twitch.tv/videos/1662202941\n\n#define PI 3.141519\n#define TAU 6.283185\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// dashed circle - https://www.shadertoy.com/view/7tyGWw\nfloat sdDashedCircle(in vec2 p, float at, float inner,float outer,float nseg,float rat) \n{\n    float le = length(p);\n    float hw = (outer-inner)*0.5;\n    float ce = le - (outer-hw);\n    ce = abs(ce)-hw;\n    //float at = atan(p.x,p.y);\n    float gr = fract((at/TAU)*nseg); \n    gr = abs((gr-0.5)*2.0);\n    gr = gr-rat;\n    float an = gr * (PI/nseg);\n    mat2 rm = rot(an);\n    float c = rm[0][0];//cos(an);\n    float ep = clamp(c*le,inner,outer);\n    vec2  ne = p*rm;\n    ne *= ep/le;  \n    float ed = length(p-ne);\n    return (an>0.0) ? ed : (ce>0.0) ? ce : max(-ed,ce);\n}\n\nvec4 GetTimer(in vec2 p,float fill)\n{\n    vec3 col2 = vec3(0.95,0.75,0.25);\n    vec3 col1 = vec3(0.5,0.7,0.8);    // grey    \n    float totalsegs = 60.0;\n    float extra = 60.0;\n    float thresh = totalsegs+(extra*0.5);\n    fill *= (totalsegs+1.0+extra);\n    \n    float at = atan(p.x,p.y);\n    float count = floor(at/(TAU/totalsegs)) + totalsegs*0.5;\n    \n    float fade = clamp((fill-count)*0.1,0.0,1.0);\n    float fade2 = 1.0;\n    if (fill>thresh)\n        fade *= 1.0-clamp((fill-thresh)*0.05,0.0,1.0);\n\n    // render circle\n    float rad = 0.0+(fade*0.8);\n    float height = mix(0.00,0.08,fade);    \n    float inner = rad-height;\n    float outer = rad+height;\n    float rt = mix(0.0,0.65,fade);\n    float d = 1.0;\n    if (height>0.0)\n        d = sdDashedCircle(p,at,inner,outer,totalsegs,rt);\n    \n    float aa =  1.5*rt*fwidth(at);// 0.005\n    float cc = smoothstep(aa,0.0,d);\n    return vec4(mix(col2*cc,col1*cc,fade),cc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float t = iTime;\n    float fill = fract(t*0.4);\n    fragColor = GetTimer(-p,fill);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 123, 123, 199], [202, 259, 349, 349, 832], [834, 834, 871, 871, 1763], [1766, 1766, 1823, 1823, 1971]], "test": "untested"}
{"id": "dsXXWX", "name": "ocatve", "author": "Issam_X_Mhadhbi", "description": "ocatve", "tags": ["ocatvewave"], "likes": 1, "viewed": 139, "published": 3, "date": "1669635844", "time_retrieved": "2024-07-30T16:16:20.244823", "image_code": "\nvec4 deepColor = vec4(0.0, 0.3, 0.1, 1.0)  ; \nvec4 shallow = vec4( 1.0) ; \n\n\nfloat wave(vec2 position, vec2 direction, float amplitude, float frequency,float phase, float sharpness, float time){\n    return amplitude * pow(sin((position.x * direction.x + position.y * direction.y) * frequency + time * phase) \n    * 0.5 + 0.5, sharpness);\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x /iResolution.y;\n    vec3 col = 0.5 + 0.5*sin(uv.xyx+vec3(0,3,4)*iTime*0.1);\n    vec2 direction = vec2(1.0); \n    float amplitude = 0.8 ;  \n    float frequency = 30.0; \n    float phase = 3.14 ;\n    float sharpness = 1.5 ; \n    // Normalized pixel coordinates (from 0 to 1)\n    float w = wave(uv,direction, amplitude, frequency, phase,  sharpness,  iTime ) ; \n    vec4 color = mix(deepColor , shallow , w )  ; \n    \n    float r0 = 0.02037 ; \n\tfloat intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n\tvec3 n = vec3(vec2(w), sqrt(1. - dot(direction, direction)));\n\tvec3 x = color.xyz +  5.*pow(clamp(dot(n, normalize(vec3(w))), 0., 1.), 6.);\n\n    fragColor = vec4(x,1.0) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 195, 195, 340], [347, 347, 404, 404, 1178]], "test": "untested"}
{"id": "mdfXDj", "name": "SVG Interpreter", "author": "mla", "description": "Drawing fairly lightly processed SVG data, using 16-bit fixed point data packed into a single array. Each path includes a bounding box to help speed things up. Inspiration & image idea from @alro: [url]https://www.shadertoy.com/view/DdsXRl[/url]", "tags": ["svg", "interpreter"], "likes": 28, "viewed": 555, "published": 3, "date": "1669624064", "time_retrieved": "2024-07-30T16:16:21.372808", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// SVG Interpreter, mla, 2022\n//\n// Drawing fairly lightly processed SVG data, using 16-bit fixed \n// point data packed into a single array. Each path includes a \n// bounding box to help speed things up.\n//\n// Only L, C and M command are handled - relative commands are made\n// absolute and H,V and z commands replaced by L. Dimensions are\n// centered and rescaled to [0,1].\n//\n// Compile time on Windows/Nvidia GTX 1650 is a reasonable 1.4 seconds,\n// much less on Linux/Intel/Mesa and Linux/Nvidia. 60fps at HD\n// resolution for Nvidia, 40 fps at 512x288 for Intel.\n//\n// Data array generated by a little C++ program you can see in Buffer B\n// (this is for information only and is entirely unsupported).\n//\n// <mouse>: pan and zoom\n// 'r': autorotation\n// 'x': recalculate buffer data each frame (only useful with USETEXTURE)\n//\n// See also:\n//\n// https://www.shadertoy.com/view/DdsXRl by @alro\n// https://www.shadertoy.com/view/Wtt3Wl by @NinjaKoala\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Uncomment this to read data from Buffer A rather than directly from memory.\n#define USETEXTURE\n\nuvec4 fetchdata(int i) {\n#if !defined USETEXTURE\n  return data[i];\n#else\n  return floatBitsToUint(texelFetch(iChannel0,ivec2(i%64,i/64),0));\n#endif\n}\n\n// 16-bit data packed in pairs into a uvec4\nuint getdata0(int i) {\n  uvec4 v = fetchdata(i>>3);\n  i &= 7;\n  uint t = v[i>>1];\n  if ((i&1) == 0) t >>= 16;\n  return t & 0xffffu;\n}\n\nuint getdata(int i) {\n  // This version might be faster on some platforms\n  uvec4 v = fetchdata(i/8);\n  i %= 8;\n  uint t = v[i/2];\n  if (i%2 == 0) t >>= 16;\n  return t & 0xffffu;\n}\n\nvec2 getpos(int i) {\n  float x = float(getdata(i))/65535.0;\n  float y = float(getdata(i+1))/65535.0;\n  return vec2(x,y);\n}\n\nvoid polywind(vec2 p, vec2 q, vec2 r);\nfloat segment(vec2 p, vec2 a, vec2 b);\nfloat bezier(vec2 p, mat4x2 m);\n\nfloat draw(vec2 pos) {\n  float eps = fwidth(length(pos)); // Bounding box border\n  int i = 0;\n  float d = 1e8;\n  vec2 p;\n  while (true) {\n    int instr = int(getdata(i++)); // Increment i for command\n    // Instruction format is:\n    // <drawtype:3> <nargs:2> <count:11>\n    if (instr == 0) break;\n    int drawtype = instr>>13;\n    int nargs = (instr>>11)&3;\n    int count = instr&((1<<11)-1);\n    vec2 p0, p1, p2;\n    if (nargs > 0) p0 = getpos(i);\n    if (nargs > 1) p1 = getpos(i+2);\n    if (nargs > 2) p2 = getpos(i+4);\n    i += 2*nargs; // Increment i for arguments\n    if (drawtype == 1) {\n      // Cubic Bezier, drawn as line segments\n      vec2 minbox = min(min(p,p0),min(p1,p2))-eps;\n      vec2 maxbox = max(max(p,p0),max(p1,p2))+eps;\n      if (any(lessThan(pos,minbox)) || any(greaterThan(pos,maxbox))) {\n        polywind(pos,p,p2);\n      } else if (dot(p-p2,p-p2) < 10.0*eps*eps) {\n        d = min(d,segment(pos,p,p2));\n      } else {\n        d = min(d,bezier(pos,mat4x2(p,p0,p1,p2)));\n      }\n      p = p2;\n    } else if (drawtype == 2) {\n      // A plain old line segment\n      vec2 minbox = min(p,p0)-eps;\n      vec2 maxbox = max(p,p0)+eps;\n      if (any(lessThan(pos,minbox)) || any(greaterThan(pos,maxbox))) {\n        polywind(pos,p,p0);\n      } else {\n        d = min(d,segment(pos,p,p0));\n      }\n      p = p0;\n    } else if (drawtype == 3) {\n      // Move\n      p = p0;\n    } else if (drawtype == 4) {\n      // Start of path, skip if out of bounding box\n      p = vec2(0);\n      vec2 minbox = p0-eps, maxbox = p1+eps;\n      // If outside path bounding box, skip entire path.\n      if (any(lessThan(pos,minbox)) || any(greaterThan(pos,maxbox))) i += count;\n    }\n  }\n  return d;\n}\n\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  polywind(p,a,b);\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nconst int nbeziercoeffs = 16;\nvec4 beziercoeff(int i) {\n  // Matrix formulation due to Shane.\n  const int N = nbeziercoeffs;\n  float t = float(i)/float(N);\n  float u = 1.0-t, t2 = t*t, u2 = u*u;\n  return vec4(u*u2,3.0*t*u2,3.0*u*t2,t*t2);\n}\n\n// Distance to Cubic Bezier.\n// Split the path into N subsegments.\nfloat bezier(vec2 p, mat4x2 m) {\n  // Since we spend most of the time deciding not to draw\n  // curves, the value of N doesn't seem to be time critical.\n  const int N = nbeziercoeffs;\n  vec2 q = m[0];\n  float d = 1e8;\n  for (int i = 1; i <= N; i++) {\n    vec2 r = m*beziercoeff(i);\n    d = min(d,segment(p,q,r));\n    q = r;\n  }\n  return d;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvoid mainImage( out vec4 fragcolor, in vec2 fragcoord ) {\n  vec3 col = vec3(0.5);\n  float theta = 0.0;\n  if (!key(CHAR_R)) theta = 0.5*iTime;\n  float scale = 1.0/cos(theta);\n  // SVG is resized to have largest dimension 1 and centred about\n  // 0.5 in the other dimension. Here x is largest, so scale by that.\n  vec2 uv = (fragcoord-0.5*iResolution.xy)/iResolution.x;\n  if (iMouse.z > 0.0) {\n    uv -= 4.0*(iMouse.xy - 0.5*iResolution.xy)/iResolution.x;\n    scale /= 4.0;\n  }\n  float px = abs(scale/iResolution.x);\n  uv *= scale;\n  uv.y = -uv.y; // Keep SVG y direction\n  uv = rotate(uv,theta);\n  if (all(lessThanEqual(abs(uv),0.5*datadims+2.0*px))) { \n    float d = draw(uv+0.5); //// SVG is in [0,1] box\n    if ((wind&1) != 0) col = vec3(1,0,0);\n    col *= smoothstep(0.0,px,d);\n  };\n  if (alert) col.b = 1.0;\n  fragcolor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nconst vec2 datadims = vec2(1,0.279799);\nconst uvec4 data[] = uvec4[](\n  uvec4(0x91220000u,0x66242941u,0x95096800u,0x2938858cu),\n  uvec4(0x38002941u,0x890b27cbu,0x8c662539u,0x8eca3800u),\n  uvec4(0x230b90e5u,0x20279289u,0x1c8393a5u,0x380019c4u),\n  uvec4(0x948916e9u,0x9509140eu,0x95093800u,0x11a19509u),\n  uvec4(0x0f3494dbu,0x0ccf9480u,0x38000a22u,0x94240763u),\n  uvec4(0x93c90491u,0x936e3800u,0x043f936eu,0x03ec9377u),\n  uvec4(0x039a9380u,0x38000348u,0x938902ffu,0x93ae02b6u),\n  uvec4(0x93e53800u,0x0264941bu,0x0208945bu,0x01bf9492u),\n  uvec4(0x48000000u,0x823a4800u,0x019b820cu,0x380001d1u),\n  uvec4(0x834c022du,0x848302b6u,0x85b03800u,0x03638767u),\n  uvec4(0x045a8902u,0x059a8a66u,0x380008b5u,0x8d9d0cf4u),\n  uvec4(0x8f781173u,0x8f933800u,0x137c8fa5u,0x15728f1cu),\n  uvec4(0x17328e1cu,0x380018bbu,0x8d3819cdu,0x8bb81a1fu),\n  uvec4(0x8a023800u,0x1a3289a6u,0x1a3b8942u,0x1a3b88e7u),\n  uvec4(0x38001a44u,0x87de19e8u,0x86de1944u,0x860c3800u),\n  uvec4(0x18a08530u,0x17bb8495u,0x16b28443u,0x48000b07u),\n  uvec4(0x80713800u,0x08357f84u,0x06087e28u,0x04767c57u),\n  uvec4(0x380002bfu,0x7a5701d1u,0x77c501e4u,0x752a3800u),\n  uvec4(0x01e4714fu,0x03636dfeu,0x06636b50u,0x38000910u),\n  uvec4(0x68ec0c99u,0x675110fcu,0x666d3800u,0x12186636u),\n  uvec4(0x133c6624u,0x14576624u,0x3800160eu,0x662d17cdu),\n  uvec4(0x665b197bu,0x66b63800u,0x1b5f671au,0x1d4c677fu),\n  uvec4(0x1f5567dau,0x38001f83u,0x67da1fa7u,0x67da1fd5u),\n  uvec4(0x67d13800u,0x208c67a3u,0x2139675au,0x21de6708u),\n  uvec4(0x38002267u,0x66b622cbu,0x6676231eu,0x66514800u),\n  uvec4(0x249d74bcu,0x48002302u,0x753c3800u,0x22cb7486u),\n  uvec4(0x228273d8u,0x221e7334u,0x380020f0u,0x70fd1fb1u),\n  uvec4(0x6f6b1e43u,0x6e743800u,0x1d0c6dabu,0x1bc46d07u),\n  uvec4(0x1a686c99u,0x3800190du,0x6c2317a9u,0x6bec1645u),\n  uvec4(0x6be33800u,0x153c6be3u,0x14336c10u,0x13456c6cu),\n  uvec4(0x38001273u,0x6cbe11cfu,0x6d591161u,0x6e223800u),\n  uvec4(0x112a6e87u,0x10f36ef4u,0x10c66f62u,0x3800108fu),\n  uvec4(0x6ffd107cu,0x7099107cu,0x713d3800u,0x107c7234u),\n  uvec4(0x10e1732au,0x118f73d8u,0x38001273u,0x74c613ceu),\n  uvec4(0x758f15a9u,0x76214800u,0x204c798eu,0x3800231eu),\n  uvec4(0x7a7b254bu,0x7bf226ddu,0x7e043800u,0x2866800du),\n  uvec4(0x29388283u,0x2938858cu,0x48002938u,0x858c90b3u),\n  uvec4(0x25ef6636u,0x3ebd8143u,0x68003ebdu,0x6f624800u),\n  uvec4(0x3df46f99u,0x38003dabu,0x6e873d22u,0x6d903c6bu),\n  uvec4(0x6cb53800u,0x3bb56bc7u,0x3ac76b11u,0x39be6a91u),\n  uvec4(0x380038b5u,0x6a1a3791u,0x69da366cu,0x69e34800u),\n  uvec4(0x36767bc4u,0x48003676u,0x7c4d3800u,0x36767ce0u),\n  uvec4(0x367f7d69u,0x369a7dfbu,0x380036b6u,0x7e7236e3u),\n  uvec4(0x7ee8372cu,0x7f4d3800u,0x376c7fa8u,0x37c87ff1u),\n  uvec4(0x382c8016u,0x380038a3u,0x803a391au,0x804d3990u),\n  uvec4(0x80444800u,0x39908143u,0x48002b2eu,0x81434800u),\n  uvec4(0x2b2e8044u,0x38002b4au,0x803a2b6eu,0x803a2b8au),\n  uvec4(0x803a3800u,0x2c418031u,0x2cf77fe8u,0x2d777f5fu),\n  uvec4(0x38002dc9u,0x7f162e00u,0x7ebb2e1cu,0x7e4d3800u),\n  uvec4(0x2e2e7dc4u,0x2e377d32u,0x2e377ca0u,0x48002e37u),\n  uvec4(0x69e33800u,0x2d4a69dau,0x2c5c69feu,0x2b816a51u),\n  uvec4(0x38002a9cu,0x6aac29cau,0x6b2c290au,0x6bc73800u),\n  uvec4(0x288a6c3eu,0x28146cc7u,0x27b86d62u,0x38002741u),\n  uvec4(0x6e1026efu,0x6ec726b8u,0x6f874800u,0x25ef6f59u),\n  uvec4(0x480027ddu,0x66363800u,0x281d666du,0x286f66a4u),\n  uvec4(0x28c166c8u,0x380028efu,0x66da2926u,0x66e42953u),\n  uvec4(0x66e43800u,0x297866edu,0x299c66edu,0x29c166edu),\n  uvec4(0x48003afeu,0x66ed3800u,0x3b4766e4u,0x3b9966dau),\n  uvec4(0x3be266bfu,0x38003c47u,0x66a43ca2u,0x667f3cf4u),\n  uvec4(0x663f4800u,0x3ebd6f62u,0x48003ebdu,0x6f629131u),\n  uvec4(0x402266d1u,0x5d2e813au,0x68005d13u,0x813a4800u),\n  uvec4(0x4fd6813au,0x48004fd6u,0x80443800u,0x504c803au),\n  uvec4(0x50ba8016u,0x511e7fd6u,0x38005155u,0x7fa8517au),\n  uvec4(0x7f685171u,0x7f1f3800u,0x515e7e68u,0x51317dbbu),\n  uvec4(0x50de7d20u,0x3800509fu,0x7c8d4fe8u,0x7b324eb1u),\n  uvec4(0x79053800u,0x4e4d784eu,0x4dd677a1u,0x4d5676fcu),\n  uvec4(0x38004ccdu,0x76454c44u,0x75854bbbu,0x74cf4800u),\n  uvec4(0x4a577573u,0x48004a57u,0x7ce03800u,0x4a577d56u),\n  uvec4(0x4a607dcdu,0x4a7b7e44u,0x38004a8du,0x7e9f4ab2u),\n  uvec4(0x7ef14ae9u,0x7f313800u,0x4b207f7bu,0x4b697fbau),\n  uvec4(0x4bbb7fe8u,0x38004c04u,0x80044c56u,0x80164ca8u),\n  uvec4(0x801f4800u,0x4ca8811fu,0x48004022u,0x811f4800u),\n  uvec4(0x4022801fu,0x38004061u,0x801f40a1u,0x801640d8u),\n  uvec4(0x7ffa3800u,0x410f7fdfu,0x414f7fbau,0x417d7f8du),\n  uvec4(0x380041cfu,0x7f4d420fu,0x7efb422au,0x7e8d3800u),\n  uvec4(0x42467e16u,0x42587d96u,0x42587d20u,0x4800426au),\n  uvec4(0x6bec3800u,0x426a6b7eu,0x426a6b11u,0x42616aa3u),\n  uvec4(0x38004261u,0x69f5423du,0x695141fdu,0x68b63800u),\n  uvec4(0x41d8686cu,0x4198682cu,0x414f67ffu,0x38004106u),\n  uvec4(0x67da40b4u,0x67c84061u,0x67d14800u,0x406166d1u),\n  uvec4(0x480052d5u,0x66d13800u,0x54e766d1u,0x56706724u),\n  uvec4(0x578267c8u,0x3800588bu,0x68515938u,0x695a595du),\n  uvec4(0x6a7e3800u,0x59666ad1u,0x596f6b11u,0x596f6b2cu),\n  uvec4(0x38005966u,0x6c8758ddu,0x6dd957efu,0x6ed03800u),\n  uvec4(0x571d6fb4u,0x56277074u,0x551e7106u,0x38005439u),\n  uvec4(0x718f53b9u,0x71c65395u,0x71c63800u,0x548272f4u),\n  uvec4(0x55557406u,0x5602750fu,0x48005826u,0x78733800u),\n  uvec4(0x58e679e9u,0x59947b72u,0x5a2f7cfbu,0x38005addu),\n  uvec4(0x7eb25b78u,0x7fa85befu,0x7fd63800u,0x5c537ffau),\n  uvec4(0x5cc18016u,0x5d2e8028u,0x48005d13u,0x813a4800u),\n  uvec4(0x5d13813au,0x48005d13u,0x813a6800u,0x50de6c99u),\n  uvec4(0x380050deu,0x6bbe5071u,0x6aec4fbau,0x6a753800u),\n  uvec4(0x4efa69f5u,0x4e1f69beu,0x4d3b69c8u,0x38004c96u),\n  uvec4(0x69c84be9u,0x69e34b4du,0x6a233800u,0x4afb6a3eu),\n  uvec4(0x4abb6a7eu,0x4aa06ad1u,0x38004a7bu,0x6b2c4a69u),\n  uvec4(0x6b904a69u,0x6bf54800u,0x4a69728fu,0x48004b56u),\n  uvec4(0x72463800u,0x4c9f71d8u,0x4dd6712bu,0x4edf7046u),\n  uvec4(0x3800503au,0x6f2250deu,0x6de250deu,0x6c994800u),\n  uvec4(0x50de6c99u,0x480050deu,0x6c999119u,0x5e7766f6u),\n  uvec4(0x7c848156u,0x68007c84u,0x813a4800u,0x6eeb813au),\n  uvec4(0x48006eebu,0x803a3800u,0x6f478028u,0x6f99800du),\n  uvec4(0x6feb7fe8u,0x380070a2u,0x7f7b7106u,0x7ea870f4u),\n  uvec4(0x7dd63800u,0x70f47d96u,0x70eb7d5fu,0x70e27d20u),\n  uvec4(0x380070bdu,0x7c4d703du,0x7b606f59u,0x7a603800u),\n  uvec4(0x6e747957u,0x6d50787cu,0x6c1077eau,0x38006b63u),\n  uvec4(0x77aa6aacu,0x777c69f5u,0x77573800u,0x69357733u),\n  uvec4(0x686c7717u,0x67ad7717u,0x480065d1u,0x7c693800u),\n  uvec4(0x65927d0du,0x65767dc4u,0x65767e7bu,0x3800656du),\n  uvec4(0x7ebb657fu,0x7efb659bu,0x7f3b3800u,0x65c87f84u),\n  uvec4(0x66087fc4u,0x66517fe8u,0x3800669au,0x801666e4u),\n  uvec4(0x80286736u,0x80314800u,0x67368131u,0x48005e77u),\n  uvec4(0x81314800u,0x5e778031u,0x38005ec0u,0x801f5f00u),\n  uvec4(0x80045f40u,0x7fdf3800u,0x5f897fb1u,0x5fc97f7bu),\n  uvec4(0x60097f44u,0x3800606eu,0x7efb60c0u,0x7e9f6109u),\n  uvec4(0x7e3b3800u,0x61527dcdu,0x61897d5fu,0x61ae7ce0u),\n  uvec4(0x480068f5u,0x6a353800u,0x691169feu,0x692369d1u),\n  uvec4(0x692c699au,0x3800693fu,0x696c6948u,0x69356948u),\n  uvec4(0x69083800u,0x694868d1u,0x6935689au,0x691a686cu),\n  uvec4(0x38006908u,0x684868ecu,0x682c68c8u,0x681a3800u),\n  uvec4(0x68ac6808u,0x689167ffu,0x686c67f6u,0x4800686cu),\n  uvec4(0x66f64800u,0x740f66f6u,0x4800740fu,0x681a3800u),\n  uvec4(0x73b46811u,0x7358683fu,0x732a6891u,0x38007318u),\n  uvec4(0x68b6730fu,0x68da730fu,0x68ff3800u,0x730f6923u),\n  uvec4(0x73186951u,0x73216975u,0x38007334u,0x69a37346u),\n  uvec4(0x69d1734fu,0x69fe4800u,0x7a207e7bu,0x38007a45u),\n  uvec4(0x7ea87a57u,0x7edf7a69u,0x7efb3800u,0x7a977f44u),\n  uvec4(0x7ace7f8du,0x7b0e7fc4u,0x38007b3bu,0x7fe87b69u),\n  uvec4(0x80047ba0u,0x80163800u,0x7bd78028u,0x7c17803au),\n  uvec4(0x7c4d8044u,0x48007c4du,0x81564800u,0x7c84813au),\n  uvec4(0x48007c84u,0x813a6800u,0x6e8775a1u,0x48006b9au),\n  uvec4(0x6c594800u,0x691a73bdu,0x3800695au,0x73bd69a3u),\n  uvec4(0x73bd69e3u,0x73c63800u,0x6a5a73cfu,0x6ad173eau),\n  uvec4(0x6b3e740fu,0x38006becu,0x74466c99u,0x74866d3eu),\n  uvec4(0x74e13800u,0x6dab7518u,0x6e197558u,0x6e8775a1u),\n  uvec4(0x48006e87u,0x75a1911bu,0x7de966ffu,0x97a4813au),\n  uvec4(0x680097a4u,0x67f64800u,0x97096811u,0x380096adu),\n  uvec4(0x682c9664u,0x68639624u,0x68ac3800u,0x95d2691au),\n  uvec4(0x959b699au,0x95926a23u,0x38009580u,0x6aac9577u),\n  uvec4(0x6b35956du,0x6bbe4800u,0x956d7d3bu,0x3800956du),\n  uvec4(0x7d849577u,0x7dd69580u,0x7e323800u,0x95897e8du),\n  uvec4(0x95a47edfu,0x95d27f31u,0x38009600u,0x7f7b9640u),\n  uvec4(0x7fba9689u,0x7fd63800u,0x96db8004u,0x972d801fu),\n  uvec4(0x9788801fu,0x48009788u,0x811f4800u,0x8f93811fu),\n  uvec4(0x48008f93u,0x801f3800u,0x8fd3801fu,0x900a8016u),\n  uvec4(0x90418004u,0x3800911cu,0x7fba918au,0x7f0d918au),\n  uvec4(0x7ddf3800u,0x918a7d20u,0x915c7c57u,0x90f77bb2u),\n  uvec4(0x38009093u,0x7b04901cu,0x7a608f93u,0x79c54800u),\n  uvec4(0x838c6bacu,0x48008383u,0x7d443800u,0x83837d9fu),\n  uvec4(0x838c7e04u,0x839e7e5fu,0x380083b1u,0x7eb283ccu),\n  uvec4(0x7efb83f1u,0x7f443800u,0x84157f8du,0x844c7fc4u),\n  uvec4(0x848c7fe8u,0x380084deu,0x80168530u,0x8031858cu),\n  uvec4(0x803a4800u,0x858c813au,0x48007de9u,0x813a4800u),\n  uvec4(0x7de9803au,0x38007e1fu,0x803a7e5fu,0x80317e96u),\n  uvec4(0x801f3800u,0x7ec48016u,0x7ef17ffau,0x7f167fe8u),\n  uvec4(0x38007f71u,0x7fb17fb1u,0x7f3b7fdfu,0x7e843800u),\n  uvec4(0x800d7dbbu,0x801f7cf2u,0x80167c20u,0x48008016u),\n  uvec4(0x6b5a3800u,0x80166ad1u,0x800d6a48u,0x7ffa69beu),\n  uvec4(0x38007ff1u,0x695a7fd6u,0x68ff7f9fu,0x68b63800u),\n  uvec4(0x7f3b6848u,0x7ea86808u,0x7e1667ffu,0x48007e16u),\n  uvec4(0x66ff4800u,0x8d1d66ffu,0x48008d1du,0x67ff3800u),\n  uvec4(0x8cef67ffu,0x8cca6808u,0x8ca66823u,0x38008c81u),\n  uvec4(0x683f8c5du,0x68638c41u,0x68883800u,0x8c1d68acu),\n  uvec4(0x8c1468dau,0x8c146911u,0x38008c14u,0x695a8c26u),\n  uvec4(0x69a38c4au,0x69e33800u,0x8c666a11u,0x8c816a48u),\n  uvec4(0x8ca66a75u,0x480091eeu,0x710f4800u,0x91ee6ac7u),\n  uvec4(0x380091eeu,0x6a6c91e5u,0x6a1191dcu,0x69b53800u),\n  uvec4(0x91c0696cu,0x91a56923u,0x917768e3u,0x3800914au),\n  uvec4(0x689a9100u,0x686390b7u,0x68483800u,0x905c6823u),\n  uvec4(0x90016808u,0x8fa56808u,0x48008fa5u,0x67084800u),\n  uvec4(0x979b6708u,0x4800979bu,0x68084800u,0x97a467f6u),\n  uvec4(0x480097a4u,0x67f6910au,0x98da6624u,0xb755813au),\n  uvec4(0x6800b755u,0x72463800u,0xb69e7246u,0xb5f17298u),\n  uvec4(0xb57a732au,0x3800b531u,0x736ab503u,0x73c6b4f1u),\n  uvec4(0x742a3800u,0xb4de7498u,0xb4cc750fu,0xb4cc7585u),\n  uvec4(0x4800b4ccu,0x7e4d3800u,0xb4d57e9fu,0xb4f17ef1u),\n  uvec4(0xb51e7f3bu,0x3800b53au,0x7f84b571u,0x7fbab5bau),\n  uvec4(0x7fdf3800u,0xb603800du,0xb6558028u,0xb6b0803au),\n  uvec4(0x4800b6b0u,0x813a4800u,0xa98e813au,0x3800a66au),\n  uvec4(0x813aa3ebu,0x80e8a1fdu,0x80443800u,0x9fa27f7bu),\n  uvec4(0x9d907dfbu,0x9c117c04u,0x38009b08u,0x7ab29a36u),\n  uvec4(0x793c99b6u,0x77a13800u,0x992d760fu,0x98e47461u),\n  uvec4(0x98e472b4u,0x380098dau,0x70f49936u,0x6f3d99e3u),\n  uvec4(0x6da23800u,0x9a916c07u,0x9b9a6a9au,0x9cec697fu),\n  uvec4(0x38009e47u,0x685a9fd0u,0x6788a17du,0x67083800u),\n  uvec4(0xa359667fu,0xa53d6636u,0xa72a663fu,0x3800a833u),\n  uvec4(0x663fa945u,0x6651aa4eu,0x666d3800u,0xab736691u),\n  uvec4(0xac8e66bfu,0xada966ffu,0x3800ae3bu,0x671aaed6u),\n  uvec4(0x672daf72u,0x672d3800u,0xaffb6736u,0xb07b671au),\n  uvec4(0xb0f266dau,0x3800b13bu,0x66a4b184u,0x665bb1dfu),\n  uvec4(0x66244800u,0xb2f16f2bu,0x4800b24du,0x6f7d3800u),\n  uvec4(0xb2046ea2u,0xb1566dabu,0xb05f6c7eu,0x3800afc4u),\n  uvec4(0x6bb5aefbu,0x6b11ae20u,0x6aa33800u,0xac4569c8u),\n  uvec4(0xaa976951u,0xa9216951u,0x3800a6eau,0x6948a4d8u),\n  uvec4(0x6a63a3b4u,0x6c3e3800u,0xa2996de2u,0xa1f46ffdu),\n  uvec4(0xa1ab728fu,0x3800a1a2u,0x72b4a1a2u,0x72e1a1a2u),\n  uvec4(0x73064800u,0xa1a2738fu,0x3800a199u,0x7621a250u),\n  uvec4(0x78a0a3abu,0x7ac53800u,0xa53d7d4du,0xa74f7e96u),\n  uvec4(0xa9e17e96u,0x3800ab05u,0x7e96abe0u,0x7e3bac60u),\n  uvec4(0x7d843800u,0xace07ccdu,0xad177bf2u,0xad0e7b0eu),\n  uvec4(0x4800ad0eu,0x74e13800u,0xad177473u,0xad057406u),\n  uvec4(0xace973a1u,0x3800acd7u,0x7361acb2u,0x732aac7bu),\n  uvec4(0x72fd3800u,0xac207298u,0xaba0726bu,0xab207261u),\n  uvec4(0x4800aab3u,0x72614800u,0xaab3716bu,0x4800b74cu),\n  uvec4(0x716b4800u,0xb7557246u,0x4800b755u,0x72464800u),\n  uvec4(0xb7557246u,0x912ab88cu,0x666dd222u,0x81c36800u),\n  uvec4(0xd22277aau,0x4800cebeu,0x81c34800u,0xcdda8183u),\n  uvec4(0x3800cd88u,0x8168cd2cu,0x8156ccdau,0x81563800u),\n  uvec4(0xcc7f814cu,0xcc1a8143u,0xcbb68143u,0x4800b88cu),\n  uvec4(0x81434800u,0xb88c8044u,0x3800b8e7u,0x803ab939u),\n  uvec4(0x801fb98bu,0x80043800u,0xb9c27fe8u,0xb9f07fc4u),\n  uvec4(0xba147f8du,0x3800ba54u,0x7f44ba8bu,0x7ee8ba9du),\n  uvec4(0x7e8d3800u,0xbab97e1fu,0xbac27da9u,0xbac27d32u),\n  uvec4(0x4800bac2u,0x6a3e3800u,0xbac269e3u,0xbab96988u),\n  uvec4(0xbab06935u,0x3800ba9du,0x68ecba82u,0x68acba4bu),\n  uvec4(0x687f3800u,0xba1e6848u,0xb9e76823u,0xb9b06808u),\n  uvec4(0x3800b967u,0x67f6b91eu,0x67edb8cbu,0x67ed4800u),\n  uvec4(0xb8cb66edu,0x4800ca91u,0x66ed3800u,0xcb5166edu),\n  uvec4(0xcc1166dau,0xccc866bfu,0x3800cd35u,0x66adcd75u),\n  uvec4(0x66a4cd7fu,0x66a43800u,0xcdbf669au,0xcdfe667fu),\n  uvec4(0xce35666du,0x4800d023u,0x6f504800u,0xcf3e6ff4u),\n  uvec4(0x3800cedau,0x6e3ecdecu,0x6cb5cc9au,0x6b873800u),\n  uvec4(0xcbc86ad1u,0xcad16a48u,0xc9c869feu,0x3800c8bfu),\n  uvec4(0x69a3c7adu,0x6975c692u,0x69753800u,0xc5656975u),\n  uvec4(0xc48969a3u,0xc3f76a11u,0x3800c39cu,0x6a51c35cu),\n  uvec4(0x6aacc32eu,0x6b113800u,0xc3006b87u,0xc2ee6bfeu),\n  uvec4(0xc2f76c75u,0x4800c2f7u,0x6f594800u,0xc6a46f59u),\n  uvec4(0x3800c700u,0x6f59c752u,0x6f50c7a4u,0x6f343800u),\n  uvec4(0xc8006f19u,0xc8496eebu,0xc8926eabu,0x3800c924u),\n  uvec4(0x6e35c976u,0x6d7ec976u,0x6cbe4800u,0xc9766c59u),\n  uvec4(0x4800ca3fu,0x6c234800u,0xcc087621u,0x4800cb08u),\n  uvec4(0x764e3800u,0xcaed75d8u,0xcabf7561u,0xca7f74f3u),\n  uvec4(0x3800ca2du,0x7461c9c8u,0x73d8c952u,0x73613800u),\n  uvec4(0xc8db72fdu,0xc85b72abu,0xc7d27274u,0x3800c764u),\n  uvec4(0x723dc6e4u,0x7222c66eu,0x72184800u,0xc3137218u),\n  uvec4(0x4800c313u,0x7aa93800u,0xc3137b29u,0xc31c7ba9u),\n  uvec4(0xc3377c20u,0x3800c35cu,0x7c96c38au,0x7d04c3d3u),\n  uvec4(0x7d693800u,0xc42e7ddfu,0xc4a57e32u,0xc52e7e68u),\n  uvec4(0x3800c5d2u,0x7ea8c680u,0x7ec4c72du,0x7ebb3800u),\n  uvec4(0xc8097ebbu,0xc8e47e96u,0xc9bf7e5fu,0x3800ca91u),\n  uvec4(0x7e28cb64u,0x7dd6cc23u,0x7d5f3800u,0xcd517cb2u),\n  uvec4(0xce5a7bcdu,0xcf357ac5u,0x3800d02cu,0x79c5d0e3u),\n  uvec4(0x7885d150u,0x772a4800u,0xd22277aau,0x4800d222u),\n  uvec4(0x77aa9132u,0xd04766edu,0xffff925cu,0x6800ffffu),\n  uvec4(0x92494800u,0xea279249u,0x4800ea27u,0x90b73800u),\n  uvec4(0xeae790a5u,0xeb9e9065u,0xec4b900au,0x3800eca7u),\n  uvec4(0x8fdcecd4u,0x8f78ecd4u,0x8edc3800u,0xecd48e13u),\n  uvec4(0xec828d01u,0xebde8b94u,0x3800eb70u,0x8a9dea39u),\n  uvec4(0x885de843u,0x84de3800u,0xe79583bau,0xe6df829fu),\n  uvec4(0xe616818cu,0x3800e531u,0x8056e44du,0x7f1fe37bu),\n  uvec4(0x7df24800u,0xe1327f04u,0x4800e132u,0x8b423800u),\n  uvec4(0xe1328c01u,0xe13b8ccau,0xe1608d8au,0x3800e17bu),\n  uvec4(0x8e1ce1bbu,0x8ea5e216u,0x8f133800u,0xe2728f93u),\n  uvec4(0xe2e88ff8u,0xe3719041u,0x3800e3f1u,0x906ee471u),\n  uvec4(0x9093e4f1u,0x90a54800u,0xe4f1925cu,0x4800d047u),\n  uvec4(0x925c4800u,0xd04790a5u,0x3800d0acu,0x90a5d110u),\n  uvec4(0x909cd175u,0x90773800u,0xd1d9904au,0xd23e900au),\n  uvec4(0xd2908fc1u,0x3800d319u,0x8f5cd37du,0x8ecad3abu),\n  uvec4(0x8e263800u,0xd3d98d5du,0xd3f48c94u,0xd3eb8bc1u),\n  uvec4(0x4800d407u,0x6f6b3800u,0xd4076e87u,0xd4076dd0u),\n  uvec4(0xd3fd6d50u,0x3800d3d9u,0x6bc7d3abu,0x6abed350u),\n  uvec4(0x6a233800u,0xd31069a3u,0xd2ab6935u,0xd22b68f5u),\n  uvec4(0x3800d1acu,0x68b6d122u,0x689ad099u,0x68a34800u),\n  uvec4(0xd09966edu,0x4800eee6u,0x66ed3800u,0xf24166edu),\n  uvec4(0xf4dc6776u,0xf69c687fu,0x3800f849u,0x696cf96du),\n  uvec4(0x6b1af9a4u,0x6cfe3800u,0xf9ad6d59u,0xf9b66dbeu),\n  uvec4(0xf9c06e19u,0x3800f9c0u,0x703df8edu,0x723df740u),\n  uvec4(0x74213800u,0xf5ee7598u,0xf45c76d8u,0xf29c77ceu),\n  uvec4(0x3800f12fu,0x78a9f054u,0x790ef01du,0x790e3800u),\n  uvec4(0xf1a67afbu,0xf3017cc4u,0xf4257e72u,0x3800f54au),\n  uvec4(0x801ff677u,0x81faf7b7u,0x840c3800u,0xf85b8527u),\n  uvec4(0xf98087b0u,0xfb098b8bu,0x3800fc2du,0x8e5cfd24u),\n  uvec4(0x8ff8fde3u,0x90413800u,0xfe889081u,0xff3590aeu),\n  uvec4(0xffec90d3u,0x4800ffecu,0x925c4800u,0xffff9249u),\n  uvec4(0x4800ffffu,0x92496800u,0xebde703du,0x3800ebe7u),\n  uvec4(0x6ed0eb30u,0x6d7eea03u,0x6cb53800u,0xe8f06bf5u),\n  uvec4(0xe7956b9au,0xe5e86b9au,0x3800e4d6u,0x6b9ae3bbu),\n  uvec4(0x6bd0e2bbu,0x6c353800u,0xe2326c6cu,0xe1cd6cd0u),\n  uvec4(0xe1966d59u,0x3800e156u,0x6df5e13bu,0x6e99e144u),\n  uvec4(0x6f3d4800u,0xe1447a20u,0x4800e2c4u,0x79a03800u),\n  uvec4(0xe4df78e9u,0xe6df77c5u,0xe88c764eu,0x3800eaccu),\n  uvec4(0x7473ebdeu,0x726bebdeu,0x703d4800u,0xebde703du),\n  uvec4(0x90b32f77u,0x88024845u,0xa30f6800u,0x4845912eu),\n  uvec4(0x4800477cu,0x91653800u,0x47339053u,0x46a98f5cu),\n  uvec4(0x45f38e81u,0x3800453cu,0x8d9d444eu,0x8cdd4346u),\n  uvec4(0x8c5d3800u,0x423d8be6u,0x41188ba6u,0x3ff48bafu),\n  uvec4(0x48003ffdu,0x9d904800u,0x3ffd9e1au,0x38003ffdu),\n  uvec4(0x9eac4006u,0x9f354022u,0x9fc73800u,0x403da03eu),\n  uvec4(0x406ba0b4u,0x40b4a119u,0x380040f4u,0xa174414fu),\n  uvec4(0xa1bd41b4u,0xa1e23800u,0x422aa207u,0x42a1a219u),\n  uvec4(0x4318a210u,0x48004318u,0xa30f4800u,0x34b6a30fu),\n  uvec4(0x480034b6u,0xa2103800u,0x34d1a207u,0x34f6a207u),\n  uvec4(0x3511a207u,0x380035c8u,0xa1fd367fu,0xa1b436ffu),\n  uvec4(0xa12b3800u,0x3751a0e2u,0x3788a087u,0x37a3a019u),\n  uvec4(0x380037b5u,0x9f9037beu,0x9efe37beu,0x9e6c4800u),\n  uvec4(0x37be8bafu,0x380036d1u,0x8ba635edu,0x8bcb3508u),\n  uvec4(0x8c1d3800u,0x34248c78u,0x33528cf8u,0x32928d93u),\n  uvec4(0x38003212u,0x8e0a319bu,0x8e933140u,0x8f2f3800u),\n  uvec4(0x30c98fdcu,0x30779093u,0x30409153u,0x48002f77u),\n  uvec4(0x91254800u,0x315b8802u,0x3800319bu,0x883931edu),\n  uvec4(0x8870323fu,0x88943800u,0x326d88a7u,0x32a488b0u),\n  uvec4(0x32d288b0u,0x380032f6u,0x88b9331bu,0x88b9333fu),\n  uvec4(0x88b94800u,0x447c88b9u,0x380044c5u,0x88b04517u),\n  uvec4(0x88a74561u,0x888b3800u,0x45c58870u,0x4620884bu),\n  uvec4(0x4673880bu,0x48004845u,0x912e4800u,0x4845912eu),\n  uvec4(0x910c498eu,0x88c26624u,0xa2f46800u,0x662489c2u),\n  uvec4(0x380065e4u,0x89d465adu,0x89dd656du,0x89e63800u),\n  uvec4(0x65088a02u,0x64b68a42u,0x64768a94u,0x38006436u),\n  uvec4(0x8aef6412u,0x8b4b63f6u,0x8bb83800u,0x63e48c38u),\n  uvec4(0x63d28cb8u,0x63d28d38u,0x480063e4u,0x9f103800u),\n  uvec4(0x63e49f87u,0x63ed9ffeu,0x6409a075u,0x3800641bu),\n  uvec4(0xa0d0643fu,0xa1226476u,0xa1623800u,0x64e4a1c7u),\n  uvec4(0x6576a1fdu,0x6608a1f4u,0x48006608u,0xa2f44800u),\n  uvec4(0x594ba2f4u,0x4800594bu,0xa1fd3800u,0x59f8a207u),\n  uvec4(0x5a9da1b4u,0x5b0aa134u,0x38005b41u,0xa0f45b66u),\n  uvec4(0xa0a25b78u,0xa0503800u,0x5b8a9ff5u,0x5b9c9f90u),\n  uvec4(0x5b9c9f35u,0x48005b9cu,0x92774800u,0x53cc9277u),\n  uvec4(0x480053ccu,0x9f223800u,0x53cc9f87u,0x53d59febu),\n  uvec4(0x53e7a047u,0x380053f9u,0xa0995427u,0xa0e2545eu),\n  uvec4(0xa1223800u,0x54cba1abu,0x5579a1f4u,0x5627a1f4u),\n  uvec4(0x48005627u,0xa2f44800u,0x49a0a2f4u,0x480049a0u),\n  uvec4(0xa1fd3800u,0x49e0a1f4u,0x4a20a1e2u,0x4a57a1d0u),\n  uvec4(0x38004a96u,0xa1ab4acdu,0xa17d4b04u,0xa1473800u),\n  uvec4(0x4b4da0ebu,0x4b7ba07eu,0x4b8da010u,0x38004bbbu),\n  uvec4(0x9f754bcdu,0x9ed94bcdu,0x9e3e4800u,0x4bbb8d13u),\n  uvec4(0x48004bbbu,0x8cb83800u,0x4bbb8c4au,0x4bbb8bddu),\n  uvec4(0x4ba98b6fu,0x38004b96u,0x8b1d4b72u,0x8ad44b44u),\n  uvec4(0x8a943800u,0x4b168a54u,0x4ad68a1du,0x4a8d8a02u),\n  uvec4(0x38004a3bu,0x89e649e0u,0x89cb498eu,0x89c24800u),\n  uvec4(0x498e88c2u,0x48005630u,0x88c24800u,0x563089c2u),\n  uvec4(0x380055e7u,0x89c255a7u,0x89cb555eu,0x89e63800u),\n  uvec4(0x550b89f9u,0x54cb8a2fu,0x54958a6fu,0x38005402u),\n  uvec4(0x8b2653c2u,0x8c1d53c2u,0x8d534800u,0x53c28fd3u),\n  uvec4(0x48005b9cu,0x8fd34800u,0x5b9c8d66u,0x38005ba6u),\n  uvec4(0x8cc15b9cu,0x8c145b78u,0x8b6f3800u,0x5b5d8b14u),\n  uvec4(0x5b388ab8u,0x5af88a6fu,0x38005ab8u,0x8a2f5a6fu),\n  uvec4(0x8a025a14u,0x89ef3800u,0x59e689e6u,0x59af89ddu),\n  uvec4(0x595d89cbu,0x4800595du,0x88cb4800u,0x660888cbu),\n  uvec4(0x48006608u,0x89d44800u,0x662489c2u,0x48006624u),\n  uvec4(0x89c2908au,0x675188c2u,0x742aa2fdu,0x6800742au),\n  uvec4(0x89c23800u,0x73c689d4u,0x736a89efu,0x730f8a14u),\n  uvec4(0x380072d8u,0x8a3972a1u,0x8a66727du,0x8a9d3800u),\n  uvec4(0x723d8aefu,0x72188b54u,0x72068bb8u,0x380071f4u),\n  uvec4(0x8c4171ebu,0x8cca71ebu,0x8d534800u,0x71eb9efeu),\n  uvec4(0x380071ebu,0x9f7571f4u,0x9feb720fu,0xa0623800u),\n  uvec4(0x7218a0beu,0x723da110u,0x727da150u,0x380072b4u),\n  uvec4(0xa18772ebu,0xa1ab732au,0xa1d03800u,0x7374a1f4u),\n  uvec4(0x73bda207u,0x740fa1fdu,0x4800740fu,0xa2fd4800u),\n  uvec4(0x6751a2fdu,0x48006751u,0xa1fd3800u,0x67ffa1fdu),\n  uvec4(0x68a3a1abu,0x691aa122u,0x38006951u,0xa0e2697fu),\n  uvec4(0xa0996991u,0xa0473800u,0x69a39fe2u,0x69b59f87u),\n  uvec4(0x69b59f22u,0x480069b5u,0x8d663800u,0x69b58ccau),\n  uvec4(0x69ac8c38u,0x699a8b9du,0x38006988u,0x8b2f695au),\n  uvec4(0x8acb691au,0x8a6f3800u,0x68f58a39u,0x68bf8a14u),\n  uvec4(0x68888a02u,0x38006823u,0x89e667c8u,0x89cb6763u),\n  uvec4(0x89c24800u,0x676388c2u,0x4800742au,0x88c24800u),\n  uvec4(0x742a89c2u,0x4800742au,0x89c24800u,0x742a89c2u),\n  uvec4(0x911b756au,0x88cb8f1cu,0xa2f46800u,0x8f1c89c2u),\n  uvec4(0x48008e81u,0x89dd3800u,0x8e2689f9u,0x8ddc8a2fu),\n  uvec4(0x8d9d8a79u,0x38008d4au,0x8ae68d13u,0x8b668d0au),\n  uvec4(0x8bef3800u,0x8cf88c78u,0x8cef8d01u,0x8ce68d8au),\n  uvec4(0x48008ce6u,0x9f073800u,0x8ce69f50u,0x8cef9fa2u),\n  uvec4(0x8cf8a007u,0x38008d01u,0xa0628d1du,0xa0b48d4au),\n  uvec4(0xa0fe3800u,0x8d78a147u,0x8db8a187u,0x8e01a1a2u),\n  uvec4(0x38008e53u,0xa1d08ea5u,0xa1e28f01u,0xa1eb4800u),\n  uvec4(0x8f01a2ebu,0x48008715u,0xa2eb4800u,0x8715a1ebu),\n  uvec4(0x3800874bu,0xa1eb878bu,0xa1e287c2u,0xa1d03800u),\n  uvec4(0x889da187u,0x890ba0d0u,0x890b9facu,0x3800890bu),\n  uvec4(0x9eec88ddu,0x9e238879u,0x9d7e3800u,0x88149cd1u),\n  uvec4(0x879e9c2cu,0x87159b91u,0x48007b04u,0x8d664800u),\n  uvec4(0x7afb9efeu,0x38007afbu,0x9f597b04u,0x9fbe7b17u),\n  uvec4(0xa0193800u,0x7b29a06bu,0x7b44a0b4u,0x7b69a0feu),\n  uvec4(0x38007b8eu,0xa1477bc4u,0xa17d7c0du,0xa1a23800u),\n  uvec4(0x7c60a1d0u,0x7cb2a1ebu,0x7d0da1f4u,0x48007d0du),\n  uvec4(0xa2f44800u,0x756aa2f4u,0x4800756au,0xa1fd3800u),\n  uvec4(0x75a1a1fdu,0x75e1a1f4u,0x7618a1e2u,0x38007645u),\n  uvec4(0xa1d97673u,0xa1bd7698u,0xa1ab3800u,0x76f3a174u),\n  uvec4(0x7733a0feu,0x7761a047u,0x3800778eu,0x9f7e77a1u),\n  uvec4(0x9eb57797u,0x9de34800u,0x77978d26u,0x38007797u),\n  uvec4(0x8c9d778eu,0x8c14777cu,0x8b8b3800u,0x77738b26u),\n  uvec4(0x77578acbu,0x77218a82u,0x380076bcu,0x8a14762au),\n  uvec4(0x89d47598u,0x89cb4800u,0x759888cbu,0x4800849eu),\n  uvec4(0x88cb4800u,0x849e89cbu,0x38008470u,0x89cb844cu),\n  uvec4(0x89d48427u,0x89ef3800u,0x84038a0bu,0x83de8a2fu),\n  uvec4(0x83c38a54u,0x3800839eu,0x8a798395u,0x8aa68395u),\n  uvec4(0x8add3800u,0x83958b26u,0x83a78b6fu,0x83cc8bafu),\n  uvec4(0x380083e7u,0x8bdd8403u,0x8c148427u,0x8c414800u),\n  uvec4(0x897092dcu,0x48008970u,0x8c943800u,0x89708c38u),\n  uvec4(0x89668bddu,0x895d8b81u,0x38008942u,0x8b388926u),\n  uvec4(0x8aef88f9u,0x8aaf3800u,0x88cb8a66u,0x888b8a2fu),\n  uvec4(0x88398a0bu,0x380087deu,0x89e68782u,0x89cb8727u),\n  uvec4(0x89cb4800u,0x872788cbu,0x48008f1cu,0x88cb4800u),\n  uvec4(0x8f1c89c2u,0x48008f1cu,0x89c24800u,0x8f1c89c2u),\n  uvec4(0x91069053u,0x87f9aecdu,0xa3066800u,0xaecd9412u),\n  uvec4(0x3800ae17u,0x9412ad69u,0x9464acf2u,0x94f73800u),\n  uvec4(0xaca99537u,0xac7b9592u,0xac6995edu,0x3800ac57u),\n  uvec4(0x965bac45u,0x96d2ac45u,0x97484800u,0xac45a019u),\n  uvec4(0x3800ac4eu,0xa06bac69u,0xa0beac97u,0xa1073800u),\n  uvec4(0xacb2a150u,0xace9a187u,0xad29a1abu,0x3800ad72u),\n  uvec4(0xa1d9adc4u,0xa1f4ae20u,0xa2074800u,0xae20a306u),\n  uvec4(0x4800a0feu,0xa3063800u,0x9ddaa306u,0x9b5aa2b4u),\n  uvec4(0x996da219u,0x38009712u,0xa1479509u,0x9fd09380u),\n  uvec4(0x9dda3800u,0x92779c88u,0x91a59b11u,0x91259976u),\n  uvec4(0x3800909cu,0x97e49053u,0x96369053u,0x94893800u),\n  uvec4(0x905392c9u,0x90a59113u,0x91538f78u,0x38009200u),\n  uvec4(0x8ddc9309u,0x8c6f945bu,0x8b543800u,0x95b68a2fu),\n  uvec4(0x973f895du,0x98ed88ddu,0x38009ac8u,0x88549cacu),\n  uvec4(0x88149e99u,0x88143800u,0x9fb58814u,0xa0be8827u),\n  uvec4(0xa1bd8842u,0x4800a518u,0x88d43800u,0xa5aa88f0u),\n  uvec4(0xa6468902u,0xa6e18902u,0x3800a76au,0x890ba7eau),\n  uvec4(0x88f0a861u,0x88b03800u,0xa8aa8879u,0xa8f38830u),\n  uvec4(0xa94e87f9u,0x4800aa60u,0x91004800u,0xa9bc9153u),\n  uvec4(0x3800a973u,0x9077a8ceu,0x8f81a7cfu,0x8e533800u),\n  uvec4(0xa7338d8au,0xa66a8ce6u,0xa58f8c78u,0x3800a3b4u),\n  uvec4(0x8b9da206u,0x8b26a090u,0x8b263800u,0x9e598b1du),\n  uvec4(0x9c488c38u,0x9b238e13u,0x38009a08u,0x8fb8995au),\n  uvec4(0x91c9991au,0x94643800u,0x99119489u,0x991194b7u),\n  uvec4(0x991194dbu,0x48009911u,0x95643800u,0x990897f6u),\n  uvec4(0x99bf9a76u,0x9b1a9ca3u,0x38009cacu,0x9f2c9ebeu),\n  uvec4(0xa075a150u,0xa0753800u,0xa274a075u,0xa34fa019u),\n  uvec4(0xa3cf9f62u,0x3800a44fu,0x9eaca486u,0x9dd0a47du),\n  uvec4(0x9cec4800u,0xa47d96a4u,0x3800a486u,0x9636a47du),\n  uvec4(0x95d2a458u,0x95643800u,0xa4469524u,0xa42294edu),\n  uvec4(0xa3eb94c0u,0x3800a38fu,0x945ba30fu,0x9424a290u),\n  uvec4(0x942e4800u,0xa222942eu,0x4800a222u,0x932e4800u),\n  uvec4(0xaebb932eu,0x4800aecdu,0x94124800u,0xaecd9412u),\n  uvec4(0x4800aecdu,0x94129121u,0xb04d87deu,0xc8bfa3cfu),\n  uvec4(0x6800c8adu,0x9a913800u,0xc8ad9ca3u,0xc7d29ea3u),\n  uvec4(0xc652a010u,0x3800c4dcu,0xa162c31cu,0xa262c12fu),\n  uvec4(0xa2f43800u,0xbf93a37du,0xbde6a3c6u,0xbc2fa3cfu),\n  uvec4(0x3800bac2u,0xa3cfb94bu,0xa3b4b7deu,0xa37d3800u),\n  uvec4(0xb643a34fu,0xb49fa30fu,0xb2faa2e2u,0x3800b2cdu),\n  uvec4(0xa2e2b29fu,0xa2e2b271u,0xa2eb3800u,0xb244a2f4u),\n  uvec4(0xb216a306u,0xb1e8a322u,0x4800b14du,0xa3864800u),\n  uvec4(0xb04d98a4u,0x4800b144u,0x98883800u,0xb15f9948u),\n  uvec4(0xb19f99ffu,0xb1e89aacu,0x3800b24du,0x9bb5b2dfu),\n  uvec4(0x9ca3b39fu,0x9d753800u,0xb48c9e75u,0xb5a79f35u),\n  uvec4(0xb6e79fb5u,0x3800b815u,0xa035b95eu,0xa07ebaa7u),\n  uvec4(0xa07e3800u,0xbbd4a087u,0xbd0ba03eu,0xbe0b9f99u),\n  uvec4(0x3800bef8u,0x9f10bf93u,0x9e2cbfcau,0x9d233800u),\n  uvec4(0xbfd39cecu,0xbfdc9cb5u,0xbfdc9c7eu,0x3800bfdcu),\n  uvec4(0x9be3bfafu,0x9b48bf4au,0x9ac83800u,0xbee69a48u),\n  uvec4(0xbe5d99edu,0xbdcb99bfu,0x4800b6deu,0x97763800u),\n  uvec4(0xb53196e4u,0xb3e8961bu,0xb2fa9509u,0x3800b1f1u),\n  uvec4(0x93dbb168u,0x925cb171u,0x90ca3800u,0xb1688e8au),\n  uvec4(0xb2688c66u,0xb41f8af8u,0x3800b5bau,0x8994b7ccu),\n  uvec4(0x8894ba67u,0x880b3800u,0xbb0b87e7u,0xbbb987deu),\n  uvec4(0xbc6687deu,0x3800bd6fu,0x87debe6fu,0x87f9bf6fu),\n  uvec4(0x88303800u,0xc08a8867u,0xc1b888a7u,0xc2e588ddu),\n  uvec4(0x3800c300u,0x88ddc31cu,0x88ddc32eu,0x88d43800u),\n  uvec4(0xc39c88b9u,0xc4008894u,0xc465885du,0x4800c51cu),\n  uvec4(0x87f04800u,0xc6009077u,0x4800c509u,0x90c13800u),\n  uvec4(0xc4e59053u,0xc4b78feeu,0xc4808f8au,0x3800c3f7u),\n  uvec4(0x8e6fc32eu,0x8d78c237u,0x8cb83800u,0xc1818c41u),\n  uvec4(0xc0c18bddu,0xbfef8b9du,0x3800bf26u,0x8b54be4au),\n  uvec4(0x8b2fbd6fu,0x8b2f3800u,0xbcd48b2fu,0xbc398b4bu),\n  uvec4(0xbba68b81u,0x3800bb26u,0x8bb8bac2u,0x8c14ba82u),\n  uvec4(0x8c813800u,0xba5d8cc1u,0xba428d01u,0xba308d41u),\n  uvec4(0x3800ba0bu,0x8d9dba02u,0x8e01ba02u,0x8e5c3800u),\n  uvec4(0xba028eefu,0xba398f81u,0xba9d8fe5u,0x3800bb4bu),\n  uvec4(0x908abc26u,0x910abd14u,0x914a4800u,0xc3659352u),\n  uvec4(0x3800c4eeu,0x93c9c649u,0x94aec749u,0x95ed3800u),\n  uvec4(0xc8409752u,0xc8bf98edu,0xc8ad9a91u,0x4800c8adu),\n  uvec4(0x9a91900fu,0x00095c2fu,0xffff5f40u,0x68000009u),\n  uvec4(0x5c2f4800u,0xffff5c2fu,0x4800ffffu,0x5f404800u),\n  uvec4(0x00095f40u,0x48000009u,0x5c2f900fu,0x00099a36u),\n  uvec4(0x2ca59d47u,0x68000009u,0x9a364800u,0x2ca59a36u),\n  uvec4(0x48002ca5u,0x9d474800u,0x00099d47u,0x48000009u),\n  uvec4(0x9a36900fu,0xce3e9a36u,0xffff9d47u,0x6800ce3eu),\n  uvec4(0x9a364800u,0xffff9a36u,0x4800ffffu,0x9d474800u),\n  uvec4(0xce3e9d47u,0x4800ce3eu,0x9a360000u,0x00000000u)\n);\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   ivec2 ix = ivec2(fragCoord);\n   fragColor = texelFetch(iChannel0,ix,0);\n   if (iFrame > 0 && !key(CHAR_X)) return;\n   if (ix.x > 64) return;\n   int i = 64*ix.y+ix.x;\n   if (i >= data.length()) return;\n   fragColor = uintBitsToFloat(data[i]);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\n// This is the C++ program used to generate the data in Common  (datadims and data).\n//\n// Uses glm header-only library, modify #include to suit your local setup.\n//\n// Should compile & run just with:\n//\n// $ g++ -Wall stranger.cpp -o stranger\n// $ ./stranger > stranger.data\n//\n// Path data manually extracted from SVG but otherwise unmodified.\n// Not all path commands are handled. s and S are just treated as\n// lines.\n\n#if 0\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <math.h>\n#include <assert.h>\n#include <iostream>\n#include <vector>\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include \"cpp/glm/glm/glm.hpp\"\n#include \"cpp/glm/glm/ext.hpp\"\n\nusing namespace glm;\n\nstd::ostream& operator<<(std::ostream& out, const glm::vec2& g) {\n    return out << glm::to_string(g);\n}\n\nstd::ostream& operator<<(std::ostream& out, const glm::vec3& g) {\n    return out << glm::to_string(g);\n}\n\nstd::ostream& operator<<(std::ostream& out, const glm::vec4& g) {\n    return out << glm::to_string(g);\n}\n\nstd::ostream& operator<<(std::ostream& out, const glm::uvec4& g) {\n    return out << glm::to_string(g);\n}\n\nconst char *pathstrings[] = {\n   \"M173.2,306.3c0.1,9.8-4,19.2-11.2,25.9 c -6.1,5.9-14.2,10.5-24.4,13.6c-7.7,2.5-15.7,3.9-23.7,3.9\"\n   \"c-6.8,0-13.6-0.5-20.3-1.5c-7.5-1-15.2-2-23.1-3c-0.9,0-1.8,0.1-2.7,0.2c-0.9,0.1-1.7,0.5-2.5,1.1c-0.9,0.6-1.9,1.3-2.7,1.9\"\n   \"l-4.9-51.4l4.5-0.5c0.6,3.5,1.6,6.9,3.1,10.2c1.9,4.8,4.6,9.3,8.1,13.2c8.7,9,20.6,14.2,33.2,14.5c5.7,0.2,11.2-1.3,16.1-4.1\"\n   \"c4.3-2.5,7.3-6.7,8.2-11.5c0.2-1,0.3-2.1,0.3-3.1c0.1-2.9-0.9-5.7-2.7-8c-1.8-2.4-4.3-4.1-7.2-5L88.6,292c-7.9-2.6-14-6.4-18.4-11.5\"\n   \"c-4.8-5.6-7.4-12.8-7.2-20.1c0-10.8,4.2-20.1,12.6-27.6c7.5-6.7,17.4-11.2,29.7-13.7c3.1-0.6,6.3-0.8,9.4-0.8\"\n   \"c4.8,0.1,9.7,0.6,14.4,1.6c5.3,1.1,10.7,2.2,16.4,3.2c0.5,0,0.9,0,1.4-0.1c2-0.5,3.9-1.3,5.7-2.2c1.5-0.9,2.6-1.6,3.5-2l4.2,40.4\"\n   \"l-4.5,1.4c-0.6-2-1.4-3.9-2.5-5.7c-3.3-6.2-6.8-10.6-10.8-13.3c-3.4-2.2-7-4-10.8-5.2c-3.8-1.3-7.7-1.9-11.6-2\"\n   \"c-2.9,0-5.8,0.5-8.4,1.5c-2.3,0.9-4.1,2.6-5.3,4.8c-0.6,1.1-1.2,2.3-1.7,3.5c-0.6,1.7-0.8,3.4-0.8,5.2c0,2.7,1.1,5.4,3,7.3\"\n   \"c2.5,2.6,6.3,4.8,11.5,6.4l29.8,9.6c7.9,2.6,14,6.7,18.4,12.5C170.9,290.9,173.2,297.8,173.2,306.3z\",\n   \"M233.5,244.2l-2.2,0.6c-0.8-3-2.3-5.7-4.3-8.1c-2-2.6-4.6-4.6-7.5-6c-2.9-1.3-6.1-2-9.3-1.9l0.1,50.1v1.5\"\n   \"c0,1.6,0.1,3.1,0.4,4.7c0.3,1.3,0.8,2.6,1.6,3.7c0.7,1,1.7,1.8,2.8,2.2c1.3,0.4,2.6,0.6,3.9,0.5v2.8h-40.3v-2.8\"\n   \"c0.3-0.1,0.7-0.1,1-0.1c2-0.1,4-0.9,5.4-2.4c0.9-0.8,1.5-1.8,1.8-3c0.2-1.5,0.3-3.1,0.3-4.7v-52.5c-2.6-0.1-5.2,0.3-7.6,1.2\"\n   \"c-2.5,1-4.8,2.4-6.9,4.1c-1.4,1.3-2.7,2.8-3.7,4.5c-1.3,1.9-2.2,3.9-2.8,6l-2.2-0.5l5.4-25.6c0.7,0.6,1.6,1.2,2.5,1.6\"\n   \"c0.5,0.2,1.1,0.3,1.6,0.3c0.4,0.1,0.8,0.1,1.2,0.1H223c0.8-0.1,1.7-0.2,2.5-0.5c1.1-0.3,2.1-0.7,3-1.4L233.5,244.2z\",\n   \"M318.5,294.2h-37.1v-2.7c1.3-0.1,2.5-0.5,3.6-1.2c0.6-0.5,1-1.2,0.9-2c-0.2-2-0.7-3.9-1.6-5.6\"\n   \"c-0.7-1.6-2.7-5.4-6.1-11.5c-1.1-2-2.4-3.9-3.8-5.7c-1.5-2-3-4.1-4.5-6.1l-3.9,1.8v20.8c0,1.3,0.1,2.6,0.4,3.9\"\n   \"c0.2,1,0.6,1.9,1.2,2.6c0.6,0.8,1.4,1.5,2.3,2c0.8,0.3,1.7,0.5,2.6,0.6v2.8h-35.1v-2.8c0.7,0,1.4-0.1,2-0.4c0.6-0.3,1.3-0.7,1.8-1.2\"\n   \"c0.9-0.7,1.6-1.6,1.9-2.8c0.3-1.3,0.5-2.7,0.5-4l0.2-48.2c0-1.2,0-2.4-0.1-3.6c0-1.9-0.4-3.7-1.1-5.4c-0.4-0.8-1.1-1.5-1.9-2\"\n   \"c-0.8-0.4-1.7-0.6-2.6-0.5v-2.8h51.7c5.8,0,10.1,0.9,13.1,2.7c2.9,1.5,4.8,4.4,5.2,7.6c0.1,0.9,0.2,1.6,0.2,1.9\"\n   \"c-0.1,3.8-1.6,7.5-4.2,10.2c-2.3,2.5-5,4.6-7.9,6.2c-2.5,1.5-3.9,2.1-4.3,2.1c2.6,3.3,4.9,6.3,6.8,9.2s3.9,6,6,9.5\"\n   \"c2.1,4.1,4,8.4,5.7,12.7c1.9,4.8,3.6,7.5,4.9,8c1.1,0.4,2.3,0.7,3.5,0.9L318.5,294.2L318.5,294.2z M284.3,236.4c0-2.4-1.2-4.7-3.2-6\"\n   \"c-2.1-1.4-4.5-2-7-1.9c-1.8,0-3.7,0.3-5.4,1c-0.9,0.3-1.6,1-1.9,1.9c-0.4,1-0.6,2.1-0.6,3.2v18.5l2.6-0.8c3.6-1.2,7-3.1,9.9-5.6\"\n   \"C282.5,243.5,284.3,240,284.3,236.4L284.3,236.4z\",\n   \"M406.6,294.2h-38.1v-2.8c1-0.2,1.9-0.5,2.8-0.9c2-1.2,3.1-3.5,2.9-5.8c0-0.7-0.1-1.3-0.2-2\"\n   \"c-0.4-2.3-1.8-4.9-4.3-7.7c-2.5-2.9-5.7-5.3-9.2-6.9c-1.9-0.7-3.9-1.2-5.9-1.6c-2.1-0.4-4.3-0.7-6.4-0.7l-5.2,14.9\"\n   \"c-0.7,1.8-1,3.8-1,5.8c-0.1,0.7,0.1,1.4,0.4,2.1c0.5,0.8,1.2,1.5,2,1.9c0.8,0.5,1.6,0.7,2.5,0.8v2.8h-24.5v-2.8\"\n   \"c0.8-0.2,1.5-0.5,2.2-0.9c0.8-0.5,1.5-1.1,2.2-1.7c1.1-0.8,2-1.8,2.8-2.9c0.8-1.2,1.4-2.4,1.8-3.8l20.4-52.3\"\n   \"c0.3-0.6,0.5-1.1,0.6-1.7c0.2-0.5,0.3-1.1,0.3-1.6c0-0.6-0.2-1.2-0.5-1.7c-0.2-0.4-0.5-0.7-0.9-0.9c-0.3-0.2-0.6-0.3-1-0.4v-2.8\"\n   \"h32.6v3.2c-1-0.1-2,0.4-2.5,1.3c-0.2,0.4-0.3,0.8-0.3,1.2c0,0.4,0.1,0.9,0.2,1.3c0.2,0.5,0.4,1,0.5,1.5l19.1,57.4\"\n   \"c0.4,0.5,0.6,1.1,0.8,1.4c0.5,0.8,1.1,1.6,1.8,2.2c0.5,0.4,1,0.7,1.6,0.9c0.6,0.2,1.3,0.4,1.9,0.5v3L406.6,294.2z M367.4,261.7\"\n   \"l-8.2-26l-7,20.7c0.7,0,1.5,0,2.2,0.1c1.3,0.1,2.6,0.4,3.8,0.8c1.9,0.6,3.8,1.3,5.6,2.3C365,260.2,366.2,260.9,367.4,261.7z\",\n   \"M482.6,223.4l-1.7,0.3c-1,0.3-1.8,0.9-2.5,1.7c-0.9,1.2-1.5,2.6-1.6,4.1c-0.2,1.5-0.3,3-0.4,4.5v49\"\n   \"c0,0.8,0.1,1.7,0.2,2.7c0.1,1,0.4,1.9,0.9,2.8c0.5,0.8,1.2,1.5,2,1.8c0.9,0.5,1.8,0.8,2.8,0.8v2.8h-22.3v-2.8c0.7,0,1.3-0.1,1.9-0.3\"\n   \"c2.4-0.8,3.6-2.7,3.6-6c0-2.1-0.5-4.3-1.6-6.1c-1.1-1.9-2.4-3.7-3.9-5.4l-33.7-39.5l-0.1,49.3c0,1,0.1,2.1,0.3,3.1\"\n   \"c0.2,0.9,0.5,1.7,0.9,2.5c0.4,0.8,1,1.4,1.7,1.8c0.9,0.5,1.8,0.8,2.8,0.9v2.8h-21.4v-2.8c0.6,0,1.3-0.1,1.9-0.3\"\n   \"c0.5-0.1,1-0.4,1.4-0.6c1-0.6,1.7-1.9,2.2-3.9c0.5-2.2,0.7-4.4,0.6-6.7v-47c0-1.5-0.1-3-0.3-4.5c-0.1-1.1-0.4-2.1-1-2.9\"\n   \"c-1.1-1.2-2.7-1.9-4.3-2v-2.8h42.1v2.8c-0.5,0-0.9,0.1-1.3,0.4c-0.4,0.3-0.8,0.7-1.1,1.1c-0.4,0.4-0.5,0.9-0.5,1.5\"\n   \"c0,0.8,0.2,1.6,0.6,2.3c0.3,0.5,0.6,1.1,1,1.6l14.8,18.5v-17.6c0-1-0.1-2-0.2-3c-0.3-0.8-0.6-1.6-1.1-2.3c-0.5-0.8-1.3-1.4-2.1-1.7\"\n   \"c-1-0.4-2-0.7-3-0.7v-2.8h22.3v2.8L482.6,223.4z\",\n   \"M571.4,252.3c-2,0-3.9,0.9-5.2,2.5c-0.8,0.7-1.3,1.7-1.5,2.8c-0.2,1.2-0.4,2.5-0.4,3.8v24.6\"\n   \"c0.1,0.9,0.4,1.8,0.9,2.6c0.3,0.8,0.9,1.4,1.7,1.8c0.8,0.5,1.7,0.8,2.7,1v2.8h-36.8c-8.8,0-15.8-0.9-21.2-2.7\"\n   \"c-6.6-2.2-12.4-6.4-16.6-11.9c-2.9-3.7-5.2-7.8-6.6-12.3c-1.5-4.4-2.3-9.1-2.3-13.8c-0.1-4.9,0.9-9.7,2.8-14.2\"\n   \"c1.9-4.5,4.8-8.5,8.5-11.6c3.8-3.2,8.1-5.5,12.8-6.9c5.2-1.5,10.5-2.3,15.9-2.2c2.9,0,5.9,0.2,8.8,0.5c3.2,0.4,6.3,0.9,9.4,1.6\"\n   \"c1.6,0.3,3.3,0.5,5,0.5c1.5,0.1,2.9-0.2,4.2-0.9c0.8-0.6,1.6-1.4,2.6-2l3,25.3l-1.8,0.9c-0.8-2.4-2.7-5.1-5.4-8.4\"\n   \"c-1.7-2.2-3.9-4-6.3-5.2c-5.2-2.4-9.9-3.7-14-3.7c-6.2-0.1-12,3-15.2,8.2c-3.1,4.6-4.9,10.5-5.7,17.7c-0.1,0.4-0.1,0.9-0.1,1.3v1.5\"\n   \"c-0.1,7.2,1.9,14.2,5.7,20.2c4.4,7.1,10.2,10.7,17.4,10.7c3.2,0,5.6-1,7-3c1.4-2,2-4.4,1.9-6.9v-17.3c0.1-1.2-0.1-2.4-0.4-3.5\"\n   \"c-0.2-0.7-0.6-1.3-1.2-1.8c-1-1.1-2.4-1.6-3.8-1.7h-1.2v-2.7h35.3L571.4,252.3L571.4,252.3z\",\n   \"M646.5,267.4l-9.5,28.3l-2.5-0.7c-0.9-0.3-1.9-0.5-2.8-0.5c-1-0.1-2.1-0.2-3.2-0.2h-53.7v-2.8\"\n   \"c1-0.1,1.9-0.4,2.8-0.7c0.6-0.3,1.1-0.7,1.5-1.3c0.7-0.8,1.3-1.8,1.5-2.8c0.3-1.2,0.4-2.5,0.4-3.8v-53.1c0-1-0.1-2-0.2-2.9\"\n   \"c-0.2-0.8-0.5-1.5-1.1-2c-0.5-0.6-1.1-1-1.7-1.3c-0.8-0.2-1.6-0.3-2.5-0.3v-2.8h49.8c2.1,0,4.2-0.2,6.2-0.5c1.2-0.2,1.9-0.3,2-0.3\"\n   \"c0.7-0.1,1.4-0.4,2-0.6l5.4,24.9l-2.5,1.8c-1.1-4.8-3.7-9.1-7.4-12.4c-2.3-2-5-3.5-7.9-4.3c-2.9-1-5.9-1.5-9-1.5\"\n   \"c-3.3,0-5.7,0.5-7.3,1.7c-1,0.7-1.7,1.7-2.2,2.8c-0.5,1.3-0.7,2.6-0.6,3.9v8.1h10.3c1,0,1.9-0.1,2.8-0.4c1-0.3,1.8-0.8,2.6-1.5\"\n   \"c1.6-1.3,2.5-3.3,2.5-5.4v-1.1l2.2-0.6l5,28l-2.8,0.5c-0.3-1.3-0.8-2.6-1.5-3.8c-0.9-1.6-2-3.1-3.3-4.4c-1.3-1.1-2.7-2-4.2-2.6\"\n   \"c-1.2-0.6-2.6-0.9-3.9-1h-9.4v24c0,1.4,0.1,2.8,0.4,4.1c0.4,1.3,0.9,2.5,1.7,3.6c1,1.3,2.3,2.2,3.8,2.8c1.8,0.7,3.7,1,5.6,0.9\"\n   \"c2.4,0,4.8-0.4,7.2-1c2.3-0.6,4.6-1.5,6.7-2.8c3.3-1.9,6.2-4.4,8.6-7.3c2.7-2.8,4.7-6.3,5.9-10.1L646.5,267.4z\",\n   \"M775,342h-61.2v-4.4c2.1-0.2,4.1-0.9,6-1.9c1-0.5,1.5-1.6,1.5-3.3c0-2.2-0.9-5.2-2.7-9.2\"\n   \"c-1.2-2.7-4.6-9-10.1-18.8c-1.9-3.2-3.9-6.3-6.1-9.3c-2.5-3.4-5-6.8-7.3-10.1l-6.4,3v34.3c0,2.1,0.1,4.3,0.5,6.4\"\n   \"c0.3,1.6,1,3.1,2,4.3c1,1.4,2.3,2.5,3.8,3.3c1.4,0.5,2.8,0.9,4.2,1.1v4.8h-57.9v-4.8c1.1,0,2.2-0.1,3.3-0.5c1.1-0.5,2.2-1.2,3.1-2\"\n   \"c1.5-1.1,2.6-2.7,3.1-4.5c0.5-2.2,0.8-4.4,0.7-6.7l0.3-79.4c0-2.5,0-4.5-0.1-5.9c-0.4-4.3-0.9-7.2-1.9-8.9c-0.7-1.4-1.8-2.6-3.2-3.3\"\n   \"c-1.4-0.7-2.9-1-4.4-0.9v-4.8h84.9c9.4,0,16.7,1.5,21.6,4.4c4.7,2.6,7.9,7.3,8.5,12.6c0.1,1,0.2,2.1,0.3,3.1c0,6-2.3,11.6-7,16.9\"\n   \"c-3.7,4.1-8.1,7.6-13,10.3c-4,2.4-6.4,3.5-7,3.5c4.3,5.4,8.1,10.4,11.3,15.1c3.2,4.7,6.5,9.9,10,15.7c1.8,3.1,5,10.2,9.3,21\"\n   \"c3.2,7.9,5.9,12.4,8,13.2c1.8,0.7,3.7,1.2,5.7,1.6v4.3L775,342z M718.6,246.6c0.1-4-1.9-7.7-5.2-9.9c-3-2.1-6.8-3.1-11.5-3.1\"\n   \"c-3,0-6.1,0.6-8.9,1.7c-1.5,0.6-2.6,1.7-3.2,3.2c-0.7,1.7-1,3.5-0.9,5.3v30.5l4.2-1.4c5.9-2,11.5-5.2,16.2-9.3\"\n   \"C715.6,258.4,718.6,252.7,718.6,246.6z\",\n   \"M260.2,338.9l-2.2,0.6c-0.8-3-2.3-5.7-4.3-8.1c-2-2.5-4.6-4.6-7.5-6c-2.9-1.3-6.1-2-9.3-1.9l0.1,50.1v1.5\"\n   \"c0,1.6,0.1,3.1,0.4,4.7c0.3,1.3,0.8,2.6,1.6,3.7c0.7,1,1.7,1.8,2.8,2.2c1.3,0.4,2.6,0.6,3.9,0.5v2.8h-40.3v-2.8\"\n   \"c0.3-0.1,0.7-0.1,1-0.1c2-0.1,4-0.9,5.4-2.4c0.9-0.8,1.5-1.8,1.8-3c0.2-1.5,0.3-3.1,0.3-4.7v-52.5c-2.6-0.1-5.1,0.3-7.6,1.2\"\n   \"c-2.5,1-4.8,2.4-6.9,4.1c-1.4,1.3-2.7,2.8-3.7,4.5c-1.3,1.9-2.2,3.9-2.8,6l-2.2-0.5l5.3-25.6c0.7,0.6,1.6,1.2,2.5,1.6\"\n   \"c0.5,0.2,1.1,0.3,1.6,0.3c0.4,0.1,0.8,0.1,1.2,0.1h48.3c0.8-0.1,1.7-0.2,2.5-0.5c1.1-0.3,2.1-0.7,3-1.4L260.2,338.9z\",\n   \"M343.9,318.1c-0.7,0.2-1.3,0.3-2,0.4c-1.1,0.3-2,1-2.7,1.9c-0.7,1-1.1,2-1.4,3.2c-0.2,1.4-0.4,2.8-0.4,4.2\"\n   \"l0.2,50c0,1.3,0.1,2.6,0.4,3.9c0.2,1,0.6,1.9,1.2,2.6c1.2,1.1,2.8,1.7,4.4,1.6v2.8h-35.7V386c1.9,0.1,3.7-0.8,4.9-2.2\"\n   \"c0.6-0.7,1-1.6,1.2-2.5c0.2-1,0.4-2.1,0.4-3.1v-35.7h-21.9v35.5c0,1.1,0.1,2.2,0.3,3.2c0.2,0.9,0.7,1.7,1.3,2.4\"\n   \"c1.2,1.5,3.1,2.3,5,2.3v2.8h-35.1V386c0.7-0.1,1.4-0.3,2-0.5c0.7-0.4,1.3-0.9,1.9-1.5c0.8-1,1.3-2.2,1.5-3.4\"\n   \"c0.5-1.7,0.7-3.4,0.7-5.1l-0.2-48.1v-1c0-1.2,0-2.4-0.2-3.6c-0.2-0.9-0.6-1.7-1.1-2.4c-0.5-0.7-1.2-1.3-2-1.6\"\n   \"c-0.9-0.3-1.9-0.6-2.8-0.7v-2.8h35.4v2.8c-0.8,0-1.5,0.1-2.3,0.4c-0.9,0.2-1.6,0.8-2.2,1.5c-1.6,2-2.3,4.7-2.3,8.1v7h22v-6.8\"\n   \"c0.1-1.8,0-3.7-0.4-5.5c-0.3-1-0.7-2-1.4-2.8c-0.7-0.7-1.5-1.2-2.5-1.4c-0.5-0.1-1.1-0.2-2-0.4v-2.8h35.5v2.9L343.9,318.1z\",\n   \"M383.2,318.1c-1.1,0.2-2.1,0.5-3.1,0.9c-0.6,0.4-1.2,0.9-1.6,1.5c-0.7,0.9-1.1,2-1.3,3.1\"\n   \"c-0.2,1.5-0.3,3-0.3,4.5v49.5c0,1.3,0.1,2.6,0.4,3.9c0.1,1,0.5,1.9,1.2,2.6c0.6,0.6,1.2,1,1.9,1.4c0.8,0.4,1.6,0.6,2.5,0.5v2.8\"\n   \"h-35.7V386c1.9,0,3.7-0.9,5-2.4c0.6-0.7,1.1-1.5,1.3-2.4c0.2-1.1,0.4-2.1,0.4-3.2v-49.7c0-1.7-0.1-3.3-0.3-5\"\n   \"c-0.2-1.2-0.7-2.3-1.4-3.3c-0.4-0.6-1-1-1.6-1.2c-1.1-0.3-2.1-0.6-3.2-0.7v-2.8h35.8L383.2,318.1L383.2,318.1z\",\n   \"M458.7,318.1l-1.7,0.3c-1,0.3-1.8,0.9-2.5,1.7c-0.9,1.2-1.5,2.6-1.6,4.1c-0.2,1.5-0.3,3-0.4,4.5v49\"\n   \"c0,0.8,0.1,1.7,0.2,2.8c0.1,1,0.4,1.9,0.9,2.7c0.5,0.8,1.2,1.5,2,1.8c0.9,0.5,1.8,0.7,2.8,0.8v2.8h-22.2v-2.8c0.6,0,1.3-0.1,1.9-0.3\"\n   \"c2.4-0.8,3.6-2.8,3.6-6c0-2.1-0.5-4.3-1.6-6.1c-1.1-1.9-2.4-3.7-3.9-5.4l-33.8-39.7l-0.1,49.3c0,1,0.1,2.1,0.3,3.1\"\n   \"c0.2,0.9,0.5,1.7,0.9,2.5c0.4,0.8,1,1.4,1.8,1.8c0.9,0.5,1.8,0.8,2.8,0.9v2.8h-21.4V386c0.6,0,1.3-0.1,1.9-0.3\"\n   \"c0.5-0.1,1-0.4,1.4-0.6c1-0.6,1.7-1.9,2.2-3.9c0.5-2.2,0.7-4.4,0.6-6.7v-46.9c0-1.5-0.1-3-0.3-4.5c-0.1-1.1-0.4-2.1-1-2.9\"\n   \"c-1.1-1.2-2.7-1.9-4.3-2v-2.8h42.1v2.8c-0.5,0-0.9,0.1-1.3,0.4c-0.4,0.3-0.8,0.7-1.1,1.1c-0.4,0.4-0.5,0.9-0.5,1.5\"\n   \"c0,0.8,0.2,1.6,0.6,2.3c0.3,0.5,0.6,1.1,1,1.6l14.8,18.5v-17.6c0-1-0.1-2-0.2-3c-0.3-0.8-0.6-1.6-1.1-2.3c-0.5-0.8-1.2-1.4-2.1-1.8\"\n   \"c-1-0.4-2-0.7-3-0.7v-2.8h22.3L458.7,318.1L458.7,318.1z\",\n   \"M547.5,347c-2,0-3.9,0.9-5.2,2.5c-0.8,0.7-1.3,1.7-1.5,2.7c-0.2,1.2-0.4,2.5-0.4,3.8v24.7\"\n   \"c0.1,0.9,0.4,1.8,0.9,2.6c0.3,0.8,0.9,1.4,1.6,1.8c0.8,0.5,1.7,0.8,2.7,1v2.8h-36.8c-8.8,0-15.8-0.9-21.2-2.6\"\n   \"c-6.6-2.3-12.3-6.4-16.6-11.9c-2.9-3.7-5.2-7.8-6.6-12.3c-1.5-4.4-2.3-9.1-2.3-13.8c0-4.9,0.9-9.7,2.8-14.2\"\n   \"c1.9-4.5,4.8-8.5,8.5-11.6c3.8-3.2,8.1-5.5,12.8-6.9c5.2-1.5,10.5-2.2,15.9-2.2c3.1,0,6,0.2,8.8,0.5s5.9,0.8,9.4,1.6\"\n   \"c1.6,0.3,3.3,0.5,5,0.5c1.5,0.1,2.9-0.2,4.2-0.9c0.8-0.6,1.6-1.4,2.6-2l3,25.3l-1.8,0.9c-0.8-2.4-2.6-5.1-5.4-8.4\"\n   \"c-1.7-2.2-3.9-4-6.3-5.2c-5.2-2.4-9.9-3.7-14-3.7c-6.2-0.1-12,3-15.2,8.2c-3.1,4.6-5,10.4-5.7,17.7c-0.1,0.4-0.1,0.9-0.1,1.3v1.5\"\n   \"c-0.1,7.2,1.9,14.2,5.7,20.3c4.4,7.1,10.2,10.7,17.4,10.7c3.2,0,5.6-1,7-3c1.4-2,2-4.4,1.9-6.9v-17.6c0.1-1.2,0-2.3-0.4-3.5\"\n   \"c-0.2-0.7-0.6-1.3-1.2-1.8c-1-1.1-2.4-1.7-3.8-1.6h-1.2v-2.8h35.3L547.5,347L547.5,347z\",\n   \"M620,365.2c0,5.8-2.4,11.4-6.6,15.4c-4.1,3.7-9,6.5-14.4,8.1c-4.5,1.5-9.2,2.3-14,2.4c-4,0-8.1-0.3-12.1-0.9\"\n   \"c-4.5-0.5-9.1-1.2-13.7-1.7c-0.5,0-1,0-1.5,0.1c-0.5,0.1-1,0.3-1.5,0.6l-1.7,1.1l-2.8-30.5l2.7-0.3c0.3,2.1,1,4.1,1.8,6\"\n   \"c1.1,2.9,2.7,5.5,4.8,7.8c2.6,2.8,5.7,4.9,9.2,6.3c3.3,1.4,6.9,2.2,10.5,2.2c3.3,0.1,6.7-0.7,9.5-2.5c2.6-1.5,4.3-4,4.9-6.9\"\n   \"c0.1-0.6,0.2-1.2,0.2-1.8c0-1.7-0.5-3.4-1.6-4.8c-1.1-1.4-2.6-2.4-4.2-2.9l-19.4-6.4c-4.7-1.6-8.3-3.8-10.9-6.8\"\n   \"c-2.9-3.3-4.4-7.5-4.3-11.9c-0.1-6.3,2.7-12.3,7.5-16.3c4.5-3.9,10.3-6.7,17.6-8.2c1.8-0.4,3.7-0.5,5.6-0.5c2.9,0,5.7,0.3,8.5,0.9\"\n   \"c3.1,0.6,6.4,1.3,9.7,1.9c0.3,0,0.6,0,0.8-0.1c1.2-0.3,2.3-0.7,3.4-1.3l2-1.2l2.5,23.9l-2.7,0.8c-0.4-1.2-0.9-2.3-1.5-3.4\"\n   \"c-1.5-3.1-3.7-5.8-6.4-7.9c-2-1.3-4.1-2.4-6.4-3.1c-2.2-0.8-4.6-1.2-7-1.2c-1.7,0-3.4,0.3-5,0.9c-1.4,0.6-2.5,1.6-3.2,2.8\"\n   \"c-0.4,0.7-0.7,1.4-0.9,2.1c-0.4,1-0.5,2.1-0.5,3.1c0,1.6,0.6,3.2,1.7,4.3c1.9,1.8,4.3,3.2,6.9,3.9l17.7,5.7\"\n   \"c4.3,1.3,8.1,3.8,10.9,7.3C618.8,356.1,620.2,360.6,620,365.2z\",\n};\n\n// Original bounding box, not needed as we recalculate\n// vec2(57.700008, 218.299988) vec2(775.000000, 391.100006)\n\n// These need to added in by hand\n//rect x=\"57.8\" y=\"190.4\" class=\"st0\" width=\"717.2\" height=\"8.6\"\n//rect x=\"57.8\" y=\"364.2\" class=\"st0\" width=\"125\" height=\"8.6\"\n//rect x=\"635.6\" y=\"364.2\" class=\"st0\" width=\"139.4\" height=\"8.6\"\n\ntypedef unsigned int uint;\n\nvec2 poffset;\nfloat pscale;\nuvec2 fixed(vec2 p) {\n  vec2 p0 = p;\n  p -= poffset;\n  p /= pscale;\n  p *= 65535.0;\n  uvec2 n = uvec2(p);\n  if (n.x >= 65536 || n.y >= 65536) fprintf(stderr,\"%u %u %g %g\\n\",n.x,n.y,p0.x,p0.y);\n  assert(n.x < 65536);\n  assert(n.y < 65536);\n  return n;\n}\n\nvoid dopath(const char *s, std::vector<float> &pathdata) {\n  while (*s != 0) {\n    if (*s == '-' || isdigit(*s)) {\n      char *t = 0;\n      float x = strtod(s,&t);\n      pathdata.push_back(x);\n      s = t;\n    } else {\n      if (isalpha(*s)) {\n        pathdata.push_back(float(*s));\n      }\n      s++;\n    }\n  }\n}\n\nuint encode(uint a, uint b) {\n  assert(a < (1<<16));\n  assert(b < (1<<16));\n  return (a<<16) | b;\n}\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\nconst int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\nconst int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\nconst int CHAR_V = 86;\n// const int CHAR_W = 87;\n// const int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nconst int CHAR_c = CHAR_C + 32;\nconst int CHAR_l = CHAR_L + 32;\nconst int CHAR_h = CHAR_H + 32;\nconst int CHAR_p = CHAR_P + 32;\nconst int CHAR_s = CHAR_S + 32;\nconst int CHAR_v = CHAR_V + 32;\nconst int CHAR_z = CHAR_Z + 32;\n\n// Inverse function, useful for debugging\nuint getdata(int i, const std::vector<uvec4> &data) {\n  uvec4 v = data[i/8];\n  i %= 8;\n  uint t = v[i/2];\n  i %= 2;\n  return (t >> (1-i)*16) & 0xffffu;\n}\n\nvec2 getpos(const std::vector<float> &pathdata,int i) {\n  return vec2(pathdata[i],pathdata[i+1]);\n}\n\n// Encode \"instruction\"\nuint instr(int drawtype, int nargs, int count = 0) {\n  assert(drawtype >= 0 && drawtype < 8);\n  assert(nargs >= 0 && nargs < 4);\n  assert(count >= 0 && count < (1<<11));\n  uint i = (drawtype << 13)|(nargs << 11)|count;\n  //fprintf(stderr,\"%d %d %d: %04x\\n\", drawtype, nargs, count, i);\n  //fprintf(stderr,\"%d %d %d\\n\", i>>13, (i>>11)&3,i&((1<<11)-1));\n  return i;\n}\n\nvoid append(std::vector<uint> &data,vec2 p) {\n  uvec2 n = fixed(p);\n  data.push_back(n.x);\n  data.push_back(n.y);\n}\n\nvoid docubic(std::vector<uint> &data, vec2 &minbox, vec2 &maxbox, vec2 p0, vec2 p1, vec2 p2) {\n  minbox = min(minbox,p0);\n  maxbox = max(maxbox,p0);\n  minbox = min(minbox,p1);\n  maxbox = max(maxbox,p1);\n  minbox = min(minbox,p2);\n  maxbox = max(maxbox,p2);\n  data.push_back(instr(1,3,0));\n  append(data,p0);\n  append(data,p1);\n  append(data,p2);\n}\n\nvoid doline(std::vector<uint> &data, vec2 &minbox, vec2 &maxbox, vec2 p0) {\n  minbox = min(minbox,p0);\n  maxbox = max(maxbox,p0);\n  data.push_back(instr(2,1,0));\n  append(data,p0);\n}\n\nvoid domove(std::vector<uint> &data, vec2 &minbox, vec2 &maxbox, vec2 p0) {\n  minbox = min(minbox,p0);\n  maxbox = max(maxbox,p0);\n  data.push_back(instr(3,1,0));\n  append(data,p0);\n}\n\nvec2 tminbox = vec2(1e8), tmaxbox = vec2(-1e8); // Total bounding box\nint tsegcount = 0;\nvoid analyse(const std::vector<float> &pathdata, std::vector<uint> &data) {\n  int pathstart = data.size();\n  for (int i = 0; i < 5; i++) data.push_back(0); // Placeholder for instr + bounding box\n  vec2 p = vec2(0), p0,p1,p2,pstart;\n  vec2 minbox = vec2(1e8), maxbox = vec2(-1e8); // Path bounding box\n  int segcount = 0;\n  for (int i = 0; i < int(pathdata.size()); ) {\n    segcount++; tsegcount++;\n    uint c = uint(pathdata[i++]);\n    assert(c > 0 && c < 256);\n    switch(int(c)) {\n    case CHAR_M:\n      p = getpos(pathdata,i);\n      pstart = p;\n      domove(data,minbox,maxbox,p);\n      i += 2;\n      break;\n    case CHAR_c:\n      p0 = p+getpos(pathdata,i);\n      p1 = p+getpos(pathdata,i+2);\n      p2 = p+getpos(pathdata,i+4);\n      docubic(data,minbox,maxbox,p0,p1,p2);\n      p = p2;\n      i += 6;\n      break;\n    case CHAR_C:\n      p0 = getpos(pathdata,i);\n      p1 = getpos(pathdata,i+2);\n      p2 = getpos(pathdata,i+4);\n      docubic(data,minbox,maxbox,p0,p1,p2);\n      p = p2;\n      i += 6;\n      break;\n    case CHAR_l:\n      p0 = p+getpos(pathdata,i);\n      doline(data,minbox,maxbox,p0);\n      p = p0;\n      i += 2;\n      break;\n    case CHAR_L:\n      p0 = getpos(pathdata,i);\n      doline(data,minbox,maxbox,p0);\n      p = p0;\n      i += 2;\n      break;\n    case CHAR_s:\n      // Do this properly!\n      p1 = p+getpos(pathdata,i);\n      p2 = p+getpos(pathdata,i+2);\n      //docubic(p0,p1,p2);\n      doline(data,minbox,maxbox,p2);\n      p = p2;\n      i += 4;\n      break;\n    case CHAR_S:\n      assert(false);\n      break;\n    case CHAR_h:\n      p0 = p+vec2(pathdata[i],0);\n      doline(data,minbox,maxbox,p0);\n      p = p0;\n      i += 1;\n      break;\n    case CHAR_H:\n      p0 = vec2(pathdata[i],p.y);\n      doline(data,minbox,maxbox,p0);\n      p = p0;\n      i += 1;\n      break;\n    case CHAR_v:\n      p0 = p+vec2(0,pathdata[i]);\n      doline(data,minbox,maxbox,p0);\n      p = p0;\n      i += 1;\n      break;\n    case CHAR_V:\n      p0 = vec2(p.x,pathdata[i]);\n      doline(data,minbox,maxbox,p0);\n      p = p0;\n      i += 1;\n      break;\n    case CHAR_z:\n      p0 = pstart;\n      doline(data,minbox,maxbox,p0);\n      p = p0;\n      break;\n    default:\n      assert(c == 0u);\n      break;\n    }\n  }\n  tminbox = min(tminbox,minbox);\n  tmaxbox = max(tmaxbox,maxbox);\n  int nitems = data.size()-pathstart-5;\n  std::cerr << nitems << \" \" << segcount << \" \" << minbox << \" \" << maxbox << \"\\n\";\n  data[pathstart+0] = instr(4,2,nitems);\n  uvec2 umin = fixed(minbox);\n  uvec2 umax = fixed(maxbox);\n  data[pathstart+1] = umin.x;\n  data[pathstart+2] = umin.y;\n  data[pathstart+3] = umax.x;\n  data[pathstart+4] = umax.y;\n}\n\nvoid dorect(std::vector<uint> &data, float x, float y, float w, float h) {\n  vec2 minbox = vec2(x,y);\n  vec2 maxbox = vec2(x+w,y+h);\n  tminbox = min(tminbox,minbox);\n  tmaxbox = max(tmaxbox,maxbox);\n  int pathstart = data.size();\n  data.push_back(0);\n  append(data,minbox);\n  append(data,maxbox);\n  data.push_back(instr(3,1,0));\n  append(data,vec2(x,y));\n  data.push_back(instr(2,1,0));\n  append(data,vec2(x+w,y));\n  data.push_back(instr(2,1,0));\n  append(data,vec2(x+w,y+h));\n  data.push_back(instr(2,1,0));\n  append(data,vec2(x,y+h));\n  data.push_back(instr(2,1,0));\n  append(data,vec2(x,y));\n  data[pathstart] = instr(4,2,data.size()-pathstart-5);\n}\n\nint main() {\n  std::vector<uint> data;\n  std::vector<float> pathdata;\n  int N = sizeof(pathstrings)/sizeof(pathstrings[0]);\n  for (int j = 0; j < 2; j++) {\n    // Do this twice, the first time gets the correct bounding box\n    // for the second time.\n    std::cerr << tminbox << \" \" << tmaxbox << \"\\n\";\n    data.clear();\n    for (int i = 0; i < N; i++) {\n      dopath(pathstrings[i],pathdata);\n      analyse(pathdata, data);\n      pathdata.clear();\n    }\n    dorect(data,57.8,190.4,717.2,8.6);\n    dorect(data,57.8,364.2,125,8.6);\n    dorect(data,635.6,364.2,139.4,8.6);\n\n    data.push_back(0); // Zero terminate commands\n    while (data.size()%8 != 0) data.push_back(0); // And pad\n\n    // Now pack into uvec4 format\n    vec2 dims  = tmaxbox - tminbox;\n    pscale = max(dims.x,dims.y);\n    poffset = tminbox;\n    if (dims.x > dims.y) poffset.y -= 0.5*(dims.x-dims.y);\n    else poffset.x -= 0.5*(dims.y-dims.x);\n  }\n  int datasize = data.size();\n\n  std::vector<uvec4> vdata;\n  for (int i = 0; i < datasize; i += 8) {\n    vdata.push_back(uvec4(encode(data[i+0],data[i+1]),\n                          encode(data[i+2],data[i+3]),\n                          encode(data[i+4],data[i+5]),\n                          encode(data[i+6],data[i+7])));\n  }\n  int vdatasize = vdata.size();\n  vec2 tdims = (tmaxbox-tminbox)/pscale;\n  printf(\"const vec2 datadims = vec2(%g,%g);\\n\",tdims.x,tdims.y);\n  printf(\"const uvec4 data[] = uvec4[](\\n\");\n  for (int i = 0; i < vdatasize; i++) {\n    printf(\"  uvec4(0x%08xu,0x%08xu,0x%08xu,0x%08xu)%s\\n\",\n           vdata[i][0],vdata[i][1],vdata[i][2],vdata[i][3],\n           i == vdatasize-1 ? \"\" : \",\");\n  }\n  printf(\");\\n\");\n  fprintf(stderr,\"vdatasize: %d segments: %d\\n\", vdatasize, tsegcount);\n}\n#endif\n\n", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1221, 1221, 1245, 1245, 1370], [1372, 1416, 1438, 1438, 1549], [1551, 1551, 1572, 1624, 1731], [1733, 1733, 1753, 1753, 1855], [1968, 1968, 1990, 1990, 3666], [3683, 3714, 3753, 3788, 3973], [3975, 3975, 4014, 4014, 4134], [4166, 4166, 4191, 4229, 4376], [4378, 4445, 4477, 4597, 4786], [4788, 4819, 4849, 4849, 4894], [4896, 4896, 4953, 4953, 5736]], "test": "untested"}
{"id": "cssSRs", "name": "Arctic Fireflies", "author": "fenix", "description": "Beneath a soft blanket of mist, by the light a full moon, arctic fireflies make highways of the valleys between the glaciers.\nTerrain: jarble's Glacial Valleys: https://www.shadertoy.com/view/NscGWl\n\n*mouse: cam\n*shift: no MSAA\n*ctrl: no FXAA\n*alt: no fog", "tags": ["3d", "collision", "simulation", "fbm", "particles", "volumetric", "lights", "fxaa", "physics", "deferred"], "likes": 41, "viewed": 573, "published": 3, "date": "1669622570", "time_retrieved": "2024-07-30T16:16:22.426988", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Beneath a soft blanket of mist, arctic fireflies make highways of the valleys\n//  between the glaciers.\n//\n//  The techniques here are an evolution of those in Spark on Swiss Cheese Mountain:\n//\n//      https://www.shadertoy.com/view/7tyyW1\n//\n//  Although the terrain FBM is now based on jarble's Glacial valleys:\n//\n//      https://www.shadertoy.com/view/NscGWl\n//\n//  The main idea is to use deferred rendering to allow each particle to be a local\n//  light source. Potentially thousands of light sources are possible, but only four\n//  can affect each pixel so they need to be spaced out to avoid artifacts.\n//\n//  I also attempted to create a volumetric fog near the ground, which I think mostly\n//  worked as intended. The effect is a combination of gaussian blur and height-based\n//  lightening. It does obscure the light effect somewhat, though, so to see the\n//  particles and lighting more clearly, hold down the ALT key. It also hides some\n//  artifacts so it seemed like a net win for the shader.\n//\n//  I struggled with anti-aliasing as usual, but I eliminated a lot of the artifacts\n//  while keeping most of the speed, so I'm mostly happy with the result. You can disable\n//  MSAA with SHIFT and FXAA with CTRL. There are a few ideas that might be interesting:\n//\n//  * When doing multisample raymarches, don't start from the camera position for each\n//    sample. The t value of the first sample provides a good starting place for the\n//    other samples.\n//\n//  * Multisampling is done during the G buffer pass, so per-sample calculations are\n//    the absolute minimum. Combined with the warm start march, I was able to leave MSAA\n//    set to 9x. 16x, 25x are probably worth trying with a faster GPU.\n//\n//  * FXAA is applied during the final render to areas not being blurred. It's not\n//    as significant a difference as the MSAA but it does help with some high frequency\n//    shadow areas.\n//\n//  * A slight temporal blur is applied at low resolutions only, beacuse at low frame\n//    rates it looks bad. I tuned this based on my graphics card, so fingers crossed\n//    the settings work well enough for everyone. I tried basing it on iFrameRate and\n//    iTimeDelta but having it switch back and forth looks terrible. I don't like it\n//    but it is the only way I could find to tame some aliasing vibrations along\n//    thin shadow boundaries.\n//\n//  This is my first attempt at stars or a moon, so I have no idea if there are better\n//  ways. Of course I am happy to discuss ideas about any part of this (or any other)\n//  shader!\n//\n//  Buffer A computes the particle positions\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders the background with depth in the w component\n//  Buffer D combines scene\n//  Image applies fog and distance blur (and re-renders for adaptive AA)\n//\n// ---------------------------------------------------------------------------------------\n\n#if FXAA\n// From reinder's  Post process - FXAA\n//    https://www.shadertoy.com/view/ls3GWS\n// he got it from:\n//    http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 AArender( vec2 uv2 )\n{    \n    uv2 /= iResolution.xy;\n    vec2 rcpFrame = 1. / iResolution.xy;\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\n    vec3 rgbNW = textureLod(iChannel2, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(iChannel2, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(iChannel2, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(iChannel2, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(iChannel2, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(iChannel2, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel2, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(iChannel2, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel2, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n#endif // FXAA\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n// this is used for fog and distance blurring\n\nint           N =  11;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*iResolution.y/float(N))));   // N/w = res/2^z\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel2, (U+w*P) *iResolution.y/iResolution.xy, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float depth = texelFetch(iChannel2, ivec2(u), 0).w;\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    g_GroundFog = state.z == 0.;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, iTime, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n      \n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 groundPos = cameraPos + rayDir * depth;\n\n    // Blur based on depth and height from ground\n    w = max(0., max((depth-15.)*.0, g_GroundFog ? .5-groundPos.y : 0.)) * 0.03;\n    if (depth > FAR_CLIP) w = 0.; // except don't blur sky\n    \n    if (w > 0.002)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / iResolution.y;  \n            O = convol2D(U);\n        }\n    }\n    else\n    {\n#if FXAA\n        if (!keyDown(KEY_CTRL) && depth < FAR_CLIP)\n        {\n            O.xyz = AArender(u);\n        }\n        else\n#endif\n        O = texture(iChannel2, u/iResolution.xy);\n    }\n    \n    O.xyz = ACESFilm(sqrt(O.xyz));\n\n    O.w = 1.;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float MAX_AGE = 30.0;\nconst int MAX_PARTICLES = 10000;\nconst float PARTICLE_SPEED = 0.01;\n#define PER_PARTICLE_LIGHTING 1\n#define SHADOWS 1 // Disable for faster speed\n#define FXAA 1\n#define TEMPORAL_BLUR 1\n#define FOG_BLUR 1\nconst vec3 GROUND_FOG_COLOR = vec3(.03, .03, .05);\nconst int TERRAIN_ITERS = 7;\nconst int SHADOW_ITERS = 5;\nconst float FAR_CLIP = 20.;\nconst vec3 MOON_DIR = normalize(vec3(0, .2, 1));\nconst vec3 MOON_COLOR = vec3(.1, .15, .3);\n\nbool g_GroundFog = true;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// From jarble's Glacial valleys: https://www.shadertoy.com/view/NscGWl\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.2;\n    float freq = 0.5,n2=0.;\n    vec2 n1 = vec2(0.);\n    for (int i = 0; i < octaves; i++)\n    {\n        n2 = sin(uv.x*freq)+cos(uv.y*freq);\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n2-value) * amplitude);\n        amplitude *= .37;\n        freq *= 2.05;\n        uv = vec2(uv.y,uv.x+n2/(freq));\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t, int iters)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy, iters) - f(p + eps.xyy, iters),\n                1. * eps.x,\n                f(p - eps.yyx, iters) - f(p + eps.yyx, iters));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax, int octaves)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 200; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,octaves);\n\t\tif( abs(h) < (0.001 * t) || t > tMax)\n            break;\n\t\tt += 0.5 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 camPath(float time)\n{\n    vec3 camPos = vec3(cos(time*.2)*.4 + time*.2, cos(time*.2)*.5 + 1.5, 2.0 + (time*.2));\n    camPos.y = max(camPos.y, f(camPos, 3) + .1);\n    return camPos;\n}\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nmat2 rotMat(float a)\n{\n    vec2 sc = vec2(cos(a), sin(a));\n    return mat2(sc.x, sc.y, -sc.y, sc.x);\n}\n\nvoid fxCalcCamera(in vec4 state, in float iTime, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = camPath(iTime);\n    cameraPos\t= camPath(iTime - 2.);\n    cameraLookAt.y = max(cameraLookAt.y, cameraPos.y - .1 - state.y);\n    cameraPos.y = cameraLookAt.y + .1 + state.y;\n    vec3 cameraNextPos\t= camPath(iTime + 2.);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraFwd.xz *= rotMat(state.x*4.);\n    float tilt = -.5 * cross2(cameraNextPos.xz - cameraPos.xz, cameraPos.xz - cameraLookAt.xz);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)) + vec3(0, tilt, 0));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p, float ar)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2((p - b * h) * vec2(ar, 1)); // squared dist to segment\n}\n\nconst float PI = 3.141592653589793;\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS 0\n#define VEL 1\n#define NUM_PARTICLE_DATA_TYPES 2\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    float age;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xyz;\n    particle.vel = particleData1.xyz;\n    particle.age = particleData0.w;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:  \n        return vec4(p.pos, p.age);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\nvec3 sky(vec3 rayDir, vec3 res)\n{\n    vec3 stars = vec3(smoothstep(.5, .8, pow(float(hash(uvec4(rayDir * res.y + 4000., 1)).r) / 4.35e9, 50.))) * 4.;\n    vec3 moon = MOON_COLOR * (1. + f(rayDir.xxy * 100., 3));\n    return mix(moon, stars, smoothstep(.03, .03 + 2./res.y, distance(rayDir, MOON_DIR)));\n}\n\nvec3 lighting(vec3 normal, vec3 L, vec3 V, bool shadow)\n{\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.) * float(!shadow);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.) * float(!shadow);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.)*.7;\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    vec3 col = diff * MOON_COLOR;\n    col += spec * MOON_COLOR;\n    col += sky * vec3(0., .3, 0.5) * .05;\n    \n   \treturn col;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvec4 render( vec2 fragCoord, vec3 iResolution, float iTime, vec4 iMouse, sampler2D gbuffer, sampler2D voronoi, sampler2D particles)\n{\n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // fetch precomputed background geometry\n    vec4 normalAndZ = texelFetch(gbuffer, ivec2(fragCoord), 0);\n    //normalAndZ = vec4(0,0,0,tMax); // disable terrain render\n    vec4 state = texelFetch(voronoi, ivec2(0), 0);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, iTime, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n      \n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    float zDist = normalAndZ.w;\n    vec3 groundPos = cameraPos + rayDir * zDist;\n\n    float shadowHit = 1e6;\n    float tMin = .010;\n#if SHADOWS\n    shadowHit = rayMarching(groundPos + normalAndZ.xyz * 0.03, MOON_DIR, tMin, FAR_CLIP, SHADOW_ITERS);\n#endif\n\n    vec4 fragColor;\n    fragColor.xyz = lighting(normalAndZ.xyz, MOON_DIR, -cameraFwd, shadowHit < FAR_CLIP); //vec4(groundColor, 0.0) * smoothstep(-50.0, -17.0, -zDist);\n    fragColor.a = 1.;\n\n    ivec4 old = fxGetClosestInternal( voronoi, ivec2(fragCoord) );      \n\n    for(int j=0; j<4; j++)\n    {\n        int particle = old[j];\n        if (particle < 0 || particle >= MAX_PARTICLES) continue;\n        fxParticle data = fxGetParticleInternal(particles, int(iResolution.x), particle);\n        \n        float dim = (1. - smoothstep(.9, 1., data.age)) * smoothstep(0., .1, data.age);\n        vec3 oldPos = data.pos;\n        vec3 newPos = data.pos + data.vel;\n        const vec3 PARTICLE_COLOR = vec3(.7,1,.2);\n#if PER_PARTICLE_LIGHTING\n        const float GLOW_INTENSITY = 0.03;\n        vec3 groundDelta = oldPos - groundPos.xyz;\n        float groundDotParticle = dot(groundDelta, normalAndZ.xyz);\n        \n        if (groundDotParticle > 0.001)\n        {\n            float distToGround = length(groundDelta);\n            float glow = GLOW_INTENSITY * normalize(groundDotParticle) / (distToGround);\n            vec3 glowTemp  = PARTICLE_COLOR * glow * dim;\n            fragColor = min(vec4(1), fragColor + vec4(glow * glowTemp, 0.0));\n        }\n#endif // PER_PARTICLE_LIGHTING\n \n        // convert to camera space\n        vec3 oldPosCamera = (w2c * vec4(oldPos,1.0)).xyz;\n        oldPosCamera.xy = oldPosCamera.xy / oldPosCamera.z;\n        vec3 newPosCamera = (w2c * vec4(newPos,1.0)).xyz;\n        newPosCamera.xy = newPosCamera.xy / newPosCamera.z;\n        \n        // if in front of clipping plane, not occluded by scene\n        if(oldPosCamera.z > 0.01 && newPosCamera.z > 0.01 && zDist > oldPosCamera.z && zDist > newPosCamera.z)\n        {\n            float dist2 = fxLinePointDist2(oldPosCamera.xy, newPosCamera.xy, p, 1.);\n            float dist = sqrt(dist2);\n            \n            float PARTICLE_SIZE = 0.02 / oldPosCamera.z;\n            float particleTemp = max(0.0, PARTICLE_SIZE*PARTICLE_SIZE - dist2)  / (PARTICLE_SIZE* PARTICLE_SIZE);\n        \n            if (dist < PARTICLE_SIZE)\n            {\n                vec4 pColor = vec4(PARTICLE_COLOR * particleTemp, 1) * dim;\n                fragColor = min(vec4(1), fragColor + pColor);\n            }\n        }\n    }\n    \n    const float FOG_START = .7;\n    if (zDist > FAR_CLIP * FOG_START)\n    {\n        if (zDist >= FAR_CLIP )\n            fragColor.xyz = sky(rayDir, iResolution);\n        else\n            fragColor.xyz = mix(fragColor.xyz, vec3(0), smoothstep(FAR_CLIP*FOG_START, FAR_CLIP, zDist));\n    }\n    else if (g_GroundFog)\n        fragColor.xyz += GROUND_FOG_COLOR*max(0., .5 - groundPos.y);\n\n    //fragColor.xyz = ACESFilm(sqrt(fragColor.xyz));\n    fragColor.w = zDist;\n    return fragColor;\n}", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position and velocity of each particle, one per texture fragment.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(-0.0005,-0.0001,-0.0005);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=MAX_PARTICLES) return;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    fxParticle p = fxGetParticle(id);\n    \n    // Integrate velocities\n    vec3 newVel = p.vel + GRAVITY;\n    ivec3 newMapPos = ivec3(floor(p.pos + newVel));\n\n    // Limit vertical movement\n    if (p.pos.y > 0.4)\n    {\n        p.pos.y = mix(p.pos.y, 0.4, .6);\n    }\n    \n    // Detect if we're about to pass through the boundary and bounce off\n    float rc = f(p.pos + p.vel, 8);\n    if (rc > p.pos.y - .1)// && rc < length(p.vel))\n    {\n        vec3 g = getNormal(p.pos, 10., 8);\n        p.pos.y = mix(p.pos.y, rc + .1, .2);\n\n        newVel.y = abs(newVel.y);\n        newVel.xz -= 1.0 * min(0.0, dot(g, newVel)) * g.xz;\n    }\n    \n    // Ensure constant speed\n    float len = length(newVel);\n    if (len > 1e-6)\n    {\n        newVel = PARTICLE_SPEED * normalize(newVel);\n    }\n    else\n    {\n        newVel = PARTICLE_SPEED * normalize(vec3(-1, 0, -1));\n    }\n    \n    p.vel = newVel;\n\n    vec3 newPos = p.pos + newVel;\n    float newAge = p.age + min(iTimeDelta, 0.033) / MAX_AGE;\n    \n    p.pos = newPos;\n        \n    // Reset particles that have gotten too old\n    if (iFrame == 0 || newAge > 1.0 || state.w < 0.)\n    {\n        p.vel = normalize(vec3(-.2, 0, -.2)) * PARTICLE_SPEED;\n\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(state, iTime, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n        cameraFwd.y = 0.0;\n\n        p.pos.y = 1e6;\n        const float XZ_SPREAD = 0.001;\n        const float Y_SPREAD = 0.0003;\n        const float Y_SPRAY = 0.0;\n\n        for (int i = 0; i < 10; ++i)\n        {\n            vec4 nse = noise(ivec2(id, id + i)) - .5;\n            vec3 pos = cameraPos + nse.xyz * vec3(100, 1, 100);//vec3(0.0, 1.5, 0.0) + p.vel;\n            pos.y = 0.;\n            \n            if (f(pos, 8) < .1)\n            {\n                p.pos = pos;\n                newAge = nse.w + 0.5;\n                break;\n            }\n        }\n        \n    }\n    \n    p.age = newAge;\n    \n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Computes closest 4 particles to each screen pixel, to accelate rendering.\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew){\n    if(id==-1) return 1e20;\n    vec3 worldPos = fxGetParticleData(id, POS).xyz + fxGetParticleData(id, VEL).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    vec2 delta = (screenPos.xy)-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    if(iFragCoord == ivec2(0))\n    {\n        // Reset if resolution changes\n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.w))\n        {\n            state = vec4(0, 0, 0, -iResolution.x * iResolution.y);\n        }\n        else\n        {\n            state.w = abs(state.w);\n        }\n        if (iMouse.z > 0.)\n        {\n            state.xy = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n        }\n        state.z = keyDown(KEY_ALT) ? 1. : 0.;\n        \n        fragColor = state;\n        return;\n    }\n    if (state.w < 0.) { fragColor = vec4(0); return; }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, iTime, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    ivec4 old   = fxGetClosest( iFragCoord );      \n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, p, w2c);\n        insertion_sort( new, dis, id, dis2 );\n    }\n\n    uint searchRange = 15u;\n    uint searchCount = 8u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    int searchIterations = 10;\n\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n\n        //pick random id of particle\n        int id = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Background rendering based on \"Glacial Valleys\" by jarble\n//    https://www.shadertoy.com/view/NscGWl\n//\n// All of jarble's code is in common, since it's used both here and for the particle\n// boundary, and again for the final render if adaptive AA is enabled. This buffer just\n// calls raycast to generate a texture full of normals and z distances (the G-buffer).\n// ---------------------------------------------------------------------------------------\n\n#define MSAA_N 3 // 2 for 4xMSAA, 3 for 9xMSAA, etc.\n\nvec4 renderGBuffer(vec2 fragCoord, vec3 cameraPos, vec3 cameraFwd, vec3 cameraUp, vec3 cameraLeft, inout float tMin)\n{\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    float t = rayMarching(cameraPos, rayDir, tMin, FAR_CLIP, TERRAIN_ITERS);\n    \n    vec3 normal = vec3(0.);\n    \n    if (t < FAR_CLIP)\n    {\n        vec3 p = cameraPos + rayDir * t;\n        normal = getNormal(p, t, 12);\n    }\n    \n    tMin = t; // start next raymarch at the previous t value\n\n    return vec4(normal, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    g_GroundFog = state.z == 0.;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, iTime, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    \n    float tMin = .1;\n    float tMax = 0.;\n\n#if MSAA_N > 1\n    if (!keyDown(KEY_SHIFT))\n    {\n        fragColor = vec4(0.);\n        for (int x = 0; x < MSAA_N; ++x)\n        for (int y = 0; y < MSAA_N; ++y)\n        {\n            vec2 offset = (vec2(x, y) - .5 * float(MSAA_N - 1)) * 2. / float(MSAA_N);\n            vec4 pass = renderGBuffer(fragCoord + offset, cameraPos, cameraFwd, cameraUp, cameraLeft, tMin);\n            \n            fragColor += pass;\n        }\n        fragColor.xyz = normalize(fragColor.xyz);\n        fragColor.w = fragColor.w / float(MSAA_N * MSAA_N);\n        return;\n    }\n#endif\n\n    fragColor = renderGBuffer(fragCoord, cameraPos, cameraFwd, cameraUp, cameraLeft, tMin);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Main render, temporal blur\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    if (state.w < 0.) { fragColor = vec4(0); return; }\n    g_GroundFog = state.z == 0.;\n    \n    vec4 new = render(fragCoord, iResolution, iTime, iMouse, iChannel2, iChannel1, iChannel0);\n    \n#if TEMPORAL_BLUR\n    // Don't apply temporal blur at very high resolutions, assuming frame rate will be crap\n    if (iResolution.x * iResolution.y < 1e6 && new.w < FAR_CLIP)\n    {\n        vec4 old = texelFetch(iChannel3, ivec2(fragCoord), 0);\n        float temporalBlur = 1. - .5*smoothstep(3., 8., old.w);\n        fragColor = mix(old, new, temporalBlur);\n        fragColor.w = new.a;\n        return;\n    }\n#endif\n\n    fragColor = new;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssSRs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[5888, 5888, 5911, 5911, 6540]], "test": "untested"}
{"id": "cdfSWX", "name": "odos | spiral2", "author": "ErinZ", "description": "ref to https://www.shadertoy.com/view/lsS3WV", "tags": ["spiral", "archimedes"], "likes": 3, "viewed": 276, "published": 3, "date": "1669618624", "time_retrieved": "2024-07-30T16:16:23.285692", "image_code": "#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\nconst float kRadius = 0.4;\nconst float kPi = 3.14159;\nconst float k2Pi = kPi*2.0;\nconst float kA = kRadius / kPi;\n\nconst float rotatespeed = 1.5;\n\nfloat random (vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nfloat arclength(float a, float theta) {\n\tfloat d = theta * sqrt(abs(1.0 - theta*theta));\n\treturn 0.5 * a * (d*2.0 + log(d));\n}\n\nvec3 spiral(vec2 uv)\n{\n    float ang = atan(uv.y,uv.x);\n    float turn = (length(uv)/kRadius - ang/k2Pi);\n    ang += ceil(turn)*k2Pi;\n\tfloat d = arclength(kA, ang)  - iTime * rotatespeed;\n\treturn vec3(fract(d), fract(turn),floor(d));\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\n//https://www.shadertoy.com/view/NslXDM\nfloat sdRoundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :\n           sqrt(min(dot2(p-vec2(0,h)),\n                    dot2(p-vec2(1,0))));\n}\n\n//https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 spiral_uv = spiral(uv)-0.5;\n    vec2 uv1 = spiral_uv.xy;\n    float offset = abs(fract(iTime*0.5)-0.5)*0.2+0.2;\n    float startex = smoothstep(0.1,0.05,sdRoundedCross(uv1,1.0)+offset);\n    float index = spiral_uv.z;\n    vec3 starcolor = (spiral_uv.y+0.3) *\n              pal(random(vec2(index)), \n                  vec3(0.9,0.7,0.4),\n                  vec3(0.8,0.2,0.9),\n                  vec3(1.0,1.0,1.0),\n                  vec3(0.3,0.3,0.6) );;\n    starcolor = mix(starcolor,vec3(0.2,0.7,1.0),0.5);\n\n    vec3 col = startex*starcolor;\n    col +=logo(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 247, 247, 322], [324, 324, 356, 356, 415], [417, 417, 456, 456, 543], [545, 545, 567, 567, 780], [781, 781, 806, 806, 825], [826, 866, 913, 913, 1165], [1167, 1210, 1278, 1278, 1321], [1323, 1323, 1380, 1380, 2067], [2071, 2071, 2091, 2091, 2480]], "test": "untested"}
{"id": "mdsSD2", "name": "name this", "author": "lomateron", "description": "click to interact\nkey W to reset\n.xy = velocity\n.z = mass\nBuffer A tab applies some convolution and the result is in .xy\nthis result is added to the velocity in Buffer B tab", "tags": ["fluid"], "likes": 34, "viewed": 393, "published": 3, "date": "1669610691", "time_retrieved": "2024-07-30T16:16:24.252108", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = (vec4(length(a.xy),a.xy,0)*.4+.5)*pow(a.z,.25)*.8;\n    //fragColor = a.zzzz;\n    //fragColor = a;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        float b = length(a2.xy)-length(a.xy);\n        r.xy += c*b*exp(-l*l*.2);\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*min(0.,t.z-1.)*.2;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j));\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j));\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/450.;\n        a += vec4(m,0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        vec2 m = 4.*(u*2.-iResolution.xy)/iResolution.y;\n        a = vec4(0,0,1,0)-vec4(m,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsSD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 247]], "test": "untested"}
{"id": "dsfXDj", "name": "transparent background", "author": "janpitokiala", "description": "I used Font 1 because it has an \"alpha\" channel, which is just red", "tags": ["checkerboard", "transparent"], "likes": 2, "viewed": 499, "published": 3, "date": "1669608952", "time_retrieved": "2024-07-30T16:16:25.195586", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Extract alpha\n    vec4 foreground = texture(iChannel1, uv).rrrr;\n    // Rotating color\n    foreground *= vec4(sin(vec3(0.,2.,4.)+iTime),1.);\n    \n    vec4 background = texture(iChannel0, uv);\n    \n    background *= 1. - foreground.a;\n    //foreground *= vec4(foreground.aaa,1.); //Premultiplied already\n    // Output to screen\n    fragColor = background+foreground;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int xPos = int(fragCoord.x);\n    int yPos = int(fragCoord.y);\n    \n    float color = 0.;\n    if((xPos & 16) > 1) {\n        color = 1. - color;\n    }\n    if((yPos & 16) > 1) {\n        color = 1. - color;\n    }\n    color = .3 * color + .7;\n    fragColor = vec4(vec3(color),1.);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 527]], "test": "untested"}
{"id": "msXXDM", "name": "mandelbrot with varying zc", "author": "janpitokiala", "description": "rainbow mandelbrot set with varying zc component from -10 to 10", "tags": ["mandelbrot", "rainbow"], "likes": 2, "viewed": 86, "published": 3, "date": "1669608828", "time_retrieved": "2024-07-30T16:16:26.238797", "image_code": "vec2 square(inout vec2 num) {\n    num = vec2(num.x*num.x-num.y*num.y,2.*num.x*num.y);\n    return num;\n}\nvec2 mul(in vec2 one, in vec2 two) {\n    vec2 result = vec2(one.x*two.x-one.y*two.y,one.x*two.y+one.y*two.x);\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = 5.*uv.x - 2.5;\n    uv.y = 3.*uv.y - 1.5;\n    vec2 z = vec2(0.,0.);\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = 0;i < 255; i = i + 1) {\n        z = square(z) + uv + mul(z, uv)*vec2(iTime-10.);\n        if (length(z) > 5.) {\n            float tint = float(i)/16.0;\n            col = tint*sin(iTime+vec3(0.,2.,4.));\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 103], [104, 104, 140, 140, 234], [235, 235, 292, 342, 801]], "test": "untested"}
{"id": "msfSDM", "name": "rainbow polybrot for varying z", "author": "janpitokiala", "description": "rainbow mandelbrot set for varying powers, with z starting at mouse cursor", "tags": ["mandelbrot", "rainbow", "tribrot"], "likes": 0, "viewed": 80, "published": 3, "date": "1669608696", "time_retrieved": "2024-07-30T16:16:29.817229", "image_code": "vec2 square(in vec2 num, in int power) {\n    vec2 final = vec2(1.,0.);\n    for(int i = 0;i<power;i=i+1) {\n        final=vec2(num.x*final.x-num.y*final.y,num.x*final.y+num.y*final.x);\n    }\n    return final;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    int power = int(floor(iTime/5.))+2;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    muv += iMouse.xy==vec2(0.,0.)?.5:0.;\n    uv.x = 5.*uv.x - 2.5;\n    muv.x = 5.*muv.x - 2.5;\n    uv.y = 3.*uv.y - 1.5;\n    muv.y = 3.*muv.y - 1.5;\n    vec2 z = muv;\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = 0;i < 255; i = i + 1) {\n        z = square(z, power) + uv;\n        if (length(z) > 2.) {\n            float tint = float(i)/16.0;\n            col = tint*sin(iTime+vec3(0.,2.,4.));\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 208], [209, 209, 266, 316, 923]], "test": "untested"}
{"id": "DdsSR7", "name": "rainbow polybrot", "author": "janpitokiala", "description": "rainbow mandelbrot set for varying powers", "tags": ["mandelbrot", "rainbow", "tribrot"], "likes": 0, "viewed": 85, "published": 3, "date": "1669608678", "time_retrieved": "2024-07-30T16:16:30.790626", "image_code": "vec2 square(vec2 num, int power) {\n    vec2 final = vec2(1.,0.);\n    for(int i = 0;i<power;i=i+1) {\n        final=vec2(num.x*final.x-num.y*final.y,num.x*final.y+num.y*final.x);\n    }\n    return final;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    int power = int(floor(iTime/2.))+2;\n    uv.x = 5.*uv.x - 2.5;\n    uv.y = 3.*uv.y - 1.5;\n    vec2 z = vec2(0.,0.);\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = 0;i < 255; i = i + 1) {\n        z = square(z, power) + uv;\n        if (length(z) > 2.) {\n            float tint = float(i)/8.0;\n            col = tint*sin(iTime+vec3(0.,2.,4.));\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdsSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 202], [203, 203, 260, 310, 786]], "test": "untested"}
{"id": "ddsSD2", "name": "Britney Sphears", "author": "janpitokiala", "description": "Mapping normal to texture\nMost of this code is not mine. I only mapped a texture on according to the normal map. You can change iChannel0 or change the distance function. Be sure to include the \"Rotation?\" part too!", "tags": ["raymarch"], "likes": 3, "viewed": 115, "published": 3, "date": "1669608615", "time_retrieved": "2024-07-30T16:16:31.546605", "image_code": "#define C 0.15915494309189535\n// 1 / 2pi\n\n//#define TORUS\n\n#ifdef TORUS\nfloat m( vec3 p ){\n    //Rotation?\n    float rand = 0.62;\n    p.xy = vec2(cos(iTime*rand)*p.x-sin(iTime*rand)*p.y,sin(iTime*rand)*p.x+cos(iTime*rand)*p.y);\n    p.yz = vec2(cos(iTime)*p.y-sin(iTime)*p.z,sin(iTime)*p.y+cos(iTime)*p.z);\n    \n    return length(vec2(length(p.zx)-0.5,p.y))-.25;\n}\n#else\nfloat m( vec3 p ){\n    return length(p)-.5;\n}\n#endif\n\nvec3 n( vec3 p ){\n    vec2 e = vec2(0.001,0.0);\n    return normalize(vec3(\n        m(p + e.xyy)-m(p - e.xyy),\n        m(p + e.yxy)-m(p - e.yxy),\n        m(p + e.yyx)-m(p - e.yyx)\n    ));\n}\n\nfloat r( vec3 ro, vec3 rd ){\n    float t = 0.0;\n    for( int i=0; i<100; i++ ){\n        vec3 p = ro+rd*t;\n        float d = m(p);\n        if(d<0.001) break;\n        t += d;\n        if(t>20.0) break;\n    }\n    if(t>20.0) t=-1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 Pixar, in vec2 Pixel ){\n\n    vec2 p = (2.0*Pixel-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(p,1.5);\n    vec3 rd = normalize(vec3(0.0,0.0,-1.5));\n    float t = r(ro,rd);\n    vec4 col = vec4(1.);\n    \n    if( t>0.0 ){\n        vec3 pos = ro+rd*t;\n        vec3 nor = n(pos);\n        vec3 non = nor;\n        //Rotation?\n        float rand = 0.62;\n        nor.xy = vec2(cos(iTime*rand)*nor.x-sin(iTime*rand)*nor.y,sin(iTime*rand)*nor.x+cos(iTime*rand)*nor.y);\n        nor.yz = vec2(cos(iTime)*nor.y-sin(iTime)*nor.z,sin(iTime)*nor.y+cos(iTime)*nor.z);\n        \n        col = pow(texture(iChannel0, vec2(.5+C*atan(nor.x,nor.z),2.*C*(acos(-nor.y)))),vec4(2.2));\n        \n        //Remove one slash from the line below to remove shading (eg, for doing shading in the texture)\n        //*\n        vec3 dir = normalize(vec3(2.0,1.0,1.0));\n        float dif = clamp(dot(non,dir),0.0,1.0);\n        col *= mix(0.2,1.0,dif);\n        //*/\n    }\n    \n    Pixar = pow(col,vec4(1./2.2));\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsSD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[424, 424, 441, 441, 612], [614, 614, 642, 642, 857], [859, 859, 907, 907, 1861]], "test": "untested"}
{"id": "7djyDc", "name": "Game Environment - Starter Kit", "author": "Dirk", "description": "SDF Game Starter Kit\n\nWORK IN PROGRESS\n\n+ Character Object\n+ World Object\n   - Water\n+ Materials\n   - Fresnel\n   - Reflective\n+ Camera Orbit", "tags": ["noise", "reflection", "terrain", "raymarch", "shadow", "water", "camera", "fresnel", "boilerplate", "gamedev", "gamedesign"], "likes": 6, "viewed": 259, "published": 3, "date": "1669589192", "time_retrieved": "2024-07-30T16:16:32.473128", "image_code": "\n    \n    vec2 world( vec3 p, float t ){\n        float mate = 1.0;\n        vec3 wp = p;\n        float v = getNoise(p,vec2(0.0),2.0,t);\n        v = mix( v , getNoise(p,vec2(0.0,0.0),5.0,t), 0.0 );\n        float w = wp.y - ( -0.5 ) - v*3.5 + texture(iChannel1,p.xz).r*0.02;\n        float b = p.y  - ( 0.5 -0.05*getNoise(p,vec2(0.9,0.0),20.0,t) );\n        if(b<w) mate = 3.0;\n        w = min(b,w);\n        return vec2(w,mate);\n    }\n    vec2 map( in vec3 pos ){\n        vec2 c = char(pos,iTime);\n        vec2 w = world(pos,iTime);\n        if( c.x < w.x ){\n             return c;\n        }else{\n            return w;\n        }\n\n    }\n    vec3 calcNormal( in vec3 pos ){\n        vec2 e = vec2(0.0001,0.0);\n        return normalize(vec3(map(pos+e.xyy).x-map(pos-e.xyy).x,\n                              map(pos+e.yxy).x-map(pos-e.yxy).x,\n                              map(pos+e.yyx).x-map(pos-e.yyx).x));\n\n    }\n    vec3 castRay( in vec3 ro, vec3 rd ){\n        float m = -1.0;\n        float t=0.01;\n        float a=0.0;\n        for( int i=0; i<100; i++ ){\n            vec3 pos = ro + t*rd;\n            vec2 h = map(pos);\n            m = h.y;\n            if(abs(h.x)<0.001)break;\n            t += h.x; \n            a++;\n            if( t>40.0 ) break;\n        }\n        if(t>40.0) m=-1.0;\n        return vec3( t,m,a );\n    }\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;   \n        vec2 an = vec2(10.0*iMouse.x/iResolution.x, iMouse.y/iResolution.y) + 2.0;\n        vec3 ro = vec3(5.0*sin(an.x),5.0*sin(an.y), 5.0*cos(an.x));\n        vec3 ta = vec3(0.0,1.0,0.0);\n        vec3 ww = normalize( ta- ro );\n        vec3 uu = normalize( cross(ww,vec3(0,1,0)));\n        vec3 vv = normalize( cross(uu,ww) );\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        vec3 col = vec3(0.4,0.75,1.0)-0.7*rd.y;\n        col = mix( col, vec3(0.01,0.8,1.0), exp(-10.0*rd.y) );\n        vec3 tm = castRay(ro,rd);\n        if( tm.y>0.0 ){\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 r = reflect(rd, nor);\n            vec3 ref = texture( iChannel2, r ).rgb;\n            float exponent = 1.0;\n            float fresnel = pow(clamp(1. - dot(nor, -rd), 0., 1.), exponent);\n            vec3 rimColor = vec3(0.05, 1.5*(pos.y/5.), 0.05);\n            vec3 fres = vec3(0.0);\n            vec3 mate = vec3(0.18);\n            if( tm.y<1.5 ){\n                fres = fresnel * rimColor * 1.75;\n                float n1 = getNoise(pos*0.01,vec2(0.0),2.0,iTime);\n                vec3 yell = vec3(0.1*abs(p.y),0.1*abs(p.y),0.0);\n                mate = mix(vec3(0.0,n1,0.0), vec3(1.0,0.4,0.0)*(pos.y+0.2)*0.2, 0.8);\n            }else if( tm.y<2.5 ){\n                fres = fresnel * rimColor * 1.75;\n                mate = vec3(0.2,0.3,0.2);\n            }else if( tm.y<3.5 ){\n                fres = fresnel * rimColor * 1.75;\n                float n1 = getNoise(pos,vec2(0.0),2.0,iTime);\n                float n2 = getNoise(pos*.5,vec2(0.0),2.0,iTime)*0.5-0.15;\n                pos.y += 0.1*iTime;\n                float n3 = getNoise(pos*10.0,vec2(0.0),2.0,iTime)*0.5-0.15;\n                ref = texture( iChannel2, r ).rgb+abs(n2);\n                mate = mix( ref*vec3(0.2,0.2,0.05),vec3(n2,n1,0.5*(n1+n2)+n3*0.2),0.8);\n            }\n            vec3  sun_dir = normalize( vec3(0.8,0.4,0.2) );\t\t\t\t\t\t\t//Sun Direction\n            float sun_dif = clamp( dot(nor,sun_dir),0.0,1.0);\t\t\t\t\t\t//Sun Difuse\n            float sun_sha = step(castRay( pos+nor*0.001,sun_dir ).y,0.0);\t\t\t//Sun Shadow\n            float sky_dif = clamp( dot(0.5+0.5*nor,vec3(0.0,1.0,0.0)),0.0,1.0);\t    //Sky Difuse\n            float bou_dif = clamp( dot(0.5+0.5*nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\t//Bounce Difuse\n            col =  mate*vec3(3.0,2.0,2.5)*sun_dif*sun_sha+fres;\n            col += mate*vec3(0.5,0.5,3.4)*sky_dif;\n            col += mate*vec3(1.0,2.0,0.9)*bou_dif;\n            col += vec3(0.01,0.8,1.0)*pow(tm.x*0.01,1.5);\n            col *= 0.8;\n        }\n        col = pow( col, vec3(0.4545) );\n        fragColor = vec4(col,1.0);\n    }\n    \n    \n    \n    \n    \n    ", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "    \n    \n    vec3 WORLD_POS = vec3( 0.0 );\n    vec2 grad( ivec2 z )  {\n        int n = z.x+z.y*11111;\n            n = (n<<13)^n;\n            n = (n*(n*n*15731+789221)+1376312589)>>16;\n    #if 0\n        return vec2(cos(float(n)),sin(float(n)));\n    #else\n        n &= 7;\n        vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n        return ( n>=6 )?vec2(0.0,gr.x):(n>=4)?vec2(gr.x,0.0):gr;\n    #endif                              \n    }\n    float noise( in vec2 p ){\n        ivec2 i = ivec2(floor( p ));\n        vec2  f = fract( p );\n        vec2  u = f*f*(3.0-2.0*f);\n        return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                         dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                    mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                         dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n    }\n    float getNoise( in vec3 pos, vec2 speed, float size, float t ){\n        vec2 uv = pos.xz*0.2;\n        float f = 0.0;\n        uv *= size;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n        f += 0.5000*noise( uv + t*speed ); uv = m*uv;\n        return 0.3 + 0.7*f;\n    }\n    float ball( vec3 p, float r ){ return length(p) - r;}\n    vec2  char( vec3 pos, float fra ){\n        float b = ball(pos+vec3(0.0,-1.0,0.),0.25);\n        return vec2( b , 2.0 );\n    }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 40, 40, 429], [434, 434, 458, 458, 629], [634, 634, 665, 665, 904], [909, 909, 945, 945, 1316], [1321, 1321, 1377, 1377, 4106]], "test": "untested"}
{"id": "DslXW2", "name": "Synthwave Triangles", "author": "elloskelling", "description": "Based on https://www.shadertoy.com/view/tsfyzn\nAdded some beat pops", "tags": ["retro", "landscape", "synthwave"], "likes": 13, "viewed": 636, "published": 3, "date": "1669588746", "time_retrieved": "2024-07-30T16:16:33.296925", "image_code": "// credits to @spalmer for grid smooth function https://www.shadertoy.com/view/wl3Sz2\n#define MAX_STEPS 156\n#define MIN_DISTANCE 0.01\n#define MAX_DISTANCE 16.\n#define GRID_SIZE 4.\n#define speed 6.\n#define MOUNTAIN_COLOR vec3(0.54, 0.11, 1.)\n#define COLOR_PURPLE vec3(0.81, 0.19, 0.78)\n#define COLOR_LIGHT vec3(0.14, 0.91, 0.98)\n#define COLOR_SUN vec3(1., 0.56, 0.098)\n#define MATERIAL_PLANE 1.\n#define MATERIAL_BACK 2.\n#define GRID_THICKNESS .2\n#define COLOR_NIGHT_GRID vec3(0., .15, 0.)\n#define COLOR_NIGHT_SUN vec3(0.5, .0, 0.)\n#define COLOR_NIGHT_MOUNTAIN vec3(0.9, .3, 0.1)\n#define SUNSET_SPEED 3.\n\n\n#define beatScale 3.7\n#define beatBias 0.\n\n\nvec3 lightPos = vec3(0., 3., -10.);\n\nstruct traceResult {\n    bool  isHit;\n    float distanceTo;\n    float material;\n    float planeHeight;\n    vec3 planeNormal;\n};\n\nstruct getDistResult {\n    float distanceTo;\n    float material;\n    float planeHeight;\n    vec3 planeNormal;\n};\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat N21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*5677.)*4332.23);\n}\n\nmat2 rot2d(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(vec2(c,-s), vec2(s,c));\n}\n\nfloat getHeight(vec2 id) {\n    //return 0.;\n    float ax = abs(id.x);\n    if (ax < GRID_SIZE) {\n        return 0.;\n    }\n\n    float n = N21(id);\n\n    float wave = sin(id.y/9. + cos(id.x/3.))*sin(id.x/9. + sin(id.y/4.));\n\n    wave = clamp((wave * .5 + .5) + n*.15 - .6, 0., 1.);\n    if (ax < (GRID_SIZE + 5.) && ax >= GRID_SIZE) {\n        wave *= (ax - GRID_SIZE + 1.)*.2;\n    }\n    return (wave*10.);\n}\n\n\ngetDistResult getDist(vec3 p) {\n    float size = GRID_SIZE;\n    vec3 nuv = p * size + vec3(0., 0., iTime * speed);\n    vec2 uv = fract(nuv).xz;\n    vec2 id = floor(nuv).xz;\n\n    vec2 lv = uv;\n\n    float bl = getHeight(id);\n    float br = getHeight(id + vec2(1., 0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = getHeight(id + vec2(0., 1.));\n    float tr = getHeight(id + vec2(1., 1.));\n    float t = mix(tl, tr, lv.x);\n\n    float height = mix(b,t, lv.y);\n\n    float O = bl;\n    float R = br;\n    float T = getHeight(id + vec2(0. -1.));\n    float B = tl;\n    float L = getHeight(id + vec2(-1., 0));\n\n    vec3 n = vec3(2.*(R-L), 2.*(B-T), -4.);\n\n\n    float d = sdPlane(p, -.5 + 0.3*height);\n\n    float db = -p.z + MAX_DISTANCE*.4;\n    d = min(d, db);\n\n    getDistResult result;\n\n    result.distanceTo = d;\n    result.material = MATERIAL_PLANE;\n    result.planeHeight = height;\n    result.planeNormal = normalize(n);\n\n    if (d == db) {\n        result.material = MATERIAL_BACK;\n    }\n\n    return result;\n}\n\ntraceResult trace(vec3 ro, vec3 rd) {\n    traceResult result;\n    float ds, dt;\n    getDistResult dist;\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        vec3 p = ro + rd * ds;\n        dist = getDist(p);\n        dt = dist.distanceTo;\n        ds += dt * .6;\n        if (abs(dt) < MIN_DISTANCE || ds > MAX_DISTANCE) {\n            break;\n        }\n    }\n    result.isHit = abs(dt) < MIN_DISTANCE;\n    result.distanceTo = ds;\n    result.material = dist.material;\n    result.planeHeight = dist.planeHeight;\n    result.planeNormal = dist.planeNormal;\n    return result;\n}\n\nfloat getLightDiffuse(vec3 p, float material, float height, vec3 normal) {\n    vec3 l = normalize(lightPos - p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    return dif;\n}\n\nvec3 starsLayer(vec2 ouv) {\n    vec3 col = vec3(0.);\n\n    vec2 uv = fract(ouv) - .5;\n\n    float d;\n\n    for(int x = -1 ; x <= 1; x++) {\n        for(int y = -1 ; y <= 1; y++) {\n            vec2 offset = vec2(x,y);\n            vec2 id = floor(ouv) + offset;\n            float n = N21(id);\n            if (n > .6) {\n                float n1 = fract(n*123.432);\n                float n2 = fract(n*1234.2432);\n\n                float size = .01 + 0.05 * (n1 - .5);\n\n                vec2 shift = vec2(n1 - .5, n2 - .5);\n                d = max(d, size/length(uv - offset + shift));\n            }\n        }\n    }\n\n\n    return col + d*vec3(.1, .9, .1);\n}\n\nvec3 backgroundStars(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float t = iTime * (speed / 30.);\n\n    float layers = 3.;\n\n    for(float i = 0. ; i < 1. ; i+= 1./layers) {\n        float depth = fract(i + t);\n        float scale = mix(20., .5, depth);\n        float fade = depth * smoothstep(1., .9, depth);\n\n        col += starsLayer(uv * scale + i * 456.32) * fade;\n    }\n    return col;\n}\n\nvec3 getOthersideBackground(vec2 uv) {\n    return backgroundStars(uv/8. + sin(iTime/(speed)));\n}\n\nvec3 getBackground(vec2 uv) {\n    float set = 0. - clamp(sin(iTime/SUNSET_SPEED)*3., -1., 2.);\n\n    float sunDist = length(uv + vec2(0., -2.5 - set));\n    float sun = 1. - smoothstep(2.35, 2.5, sunDist);\n\n    float gradient = sin(uv.y/4. - 3.14/32. + set/3.)*2.;\n    float bands = abs(sin(uv.y * 8. + iTime*2.)) * (1. - step(2.5 + set, uv.y));\n\n    float skyTop = 2.12/distance(uv, vec2(uv.x, 9.5));\n    float skyBottom = 1.12/distance(uv, vec2(uv.x, -1.5));\n\n    vec3 result;\n\n    // sun\n\n    if (set < -1.8) {\n        result = vec3(sun) * (bands > 0. ? bands : 1.) * mix(vec3(0.), COLOR_NIGHT_SUN, ((abs(set) - 1.6) -.2) * 15.);\n        float glow = smoothstep(.1, .5, (1.1)/sunDist);\n        result += glow * COLOR_NIGHT_SUN;\n    } else {\n        result = vec3(sun * gradient * (bands > 0. ? bands : 1.)) * COLOR_SUN;\n        //glow\n        float glow = smoothstep(.1, .5, (1.1)/sunDist) + clamp(-1., 1., set);\n        // result += glow * COLOR_PURPLE;\n\n        // sky\n        result += max(glow * COLOR_PURPLE, ((skyTop * MOUNTAIN_COLOR) + (skyBottom * COLOR_PURPLE))*(1. + set));\n    }\n\n\n\n    if (sun < .5) {\n        // stars\n        vec2 nuv = uv*2.;// + vec2(iTime, 0.);\n        vec2 rize = vec2(-10., 12.);\n        nuv -= rize;\n        nuv *= rot2d(mod(-iTime/15., 6.28));\n        nuv += rize;\n        uv = fract(nuv);\n        vec2 id = floor(nuv);\n        uv -= .5;\n\n        float n = N21(id);\n        uv.x += fract(n*100.32) - .5;\n        uv.y += fract(n*11323.432) - .5;\n\n        float star = smoothstep(.5, 1., (0.03 + (0.02 * (fract(n*353.32) - .5)))/length(uv));\n\n        result += star * step(.8, n);\n    }\n\n    return result;\n}\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\n// (c) spalmer https://www.shadertoy.com/view/wl3Sz2\nfloat gridPow(vec2 uv)\n{\n    vec2 p = uv * GRID_SIZE + vec2(0., iTime * speed);\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    f = max(vec2(0), 1. - f + .5*GRID_THICKNESS);\n    f = pow(f, vec2(fadePower));\n    float g = f.x+f.y; //max(f.x, f.y); //\n    float s = sqrt(GRID_THICKNESS);\n    return mix(g, s, exp2(-.01 / filterWidth2(p)));\n}\n\nvec3 getAlbedo(vec3 p, float material, float height, vec3 normal) {\n    if (material == MATERIAL_BACK) {\n        return getBackground(p.xy);\n    }\n\n    float sunSet = sin(iTime/SUNSET_SPEED)*.5 + .5;\n\n    vec3 col = vec3(0.);\n    float grid = gridPow(p.xz);\n\n    float maxHeight = 2.5;\n\n    vec3 grid_color = COLOR_PURPLE;\n    vec3 cell_color = vec3(0.);\n    vec3 mountain_color = MOUNTAIN_COLOR;\n    mountain_color = mix(mountain_color, COLOR_NIGHT_MOUNTAIN, sunSet);\n\n\n\n    if (height > 0.) {\n        grid_color = mix(COLOR_PURPLE, COLOR_LIGHT, height/maxHeight);\n        cell_color = mountain_color * mix(vec3(0.), mountain_color, height/maxHeight);\n    }\n\n    grid_color = mix(grid_color, COLOR_NIGHT_GRID, sunSet);\n\n    col = mix(vec3(0.), grid_color, grid) + cell_color;\n\n    return vec3(col);\n}\n\nfloat polarTriangle(vec2 uv, float offset) {\n    float a = atan(uv.x, uv.y) + offset;\n    float b = 6.28 / 3.;\n    float l = length(uv);\n\n    float d = cos(a - floor(.5 + a/b) * b) * l;\n\n    return d;\n}\n\nfloat triangleMask(vec2 uv) {\n    return polarTriangle(uv + vec2(0., -.1),3.14 + .5*sin(iTime));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // lightPos.z = sin(iTime/3.)*100.;\n\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05,  0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.17, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.25, 0.25 ) ).x;\n\n    //////////////////\n\n    float beat = 0.25*freqs[0]*freqs[0]\n                +0.35*freqs[1]*freqs[1]\n                +0.25*freqs[2]*freqs[2]\n                +0.15*freqs[3]*freqs[3];\n    beat = sqrt(beat) * beatScale + beatBias;\n\n\n    float beat2 = 0.3*freqs[3]*freqs[3]\n                 +0.4*freqs[4]*freqs[4]\n                 +0.3*freqs[5]*freqs[5];\n    beat2 = sqrt(beat2) * beatScale + beatBias;\n\n    //////////////////\n\n    mouse.x = 0.5;\n    mouse.y = 0.;\n\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(0., .5, -.4);\n    vec3 lookat = vec3(mouse.x*2.-1., 1. - mouse.y - .6, 0.);\n    float zoom = .4;\n\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0.);\n\n    traceResult tr = trace(ro, rd);\n\n    if (tr.isHit) {\n\n        p = ro + rd * tr.distanceTo;\n\n        vec3 albedo = getAlbedo(p, tr.material, tr.planeHeight, tr.planeNormal);\n\n        float diffuse = getLightDiffuse(p, tr.material, tr.planeHeight, tr.planeNormal)*beat2;\n\n        float fade = 1.;// - clamp((p.z-ro.z)/(MAX_DISTANCE * .8), 0., 1.);\n\n        if (tr.material == MATERIAL_BACK) {\n            col = albedo;\n        } else {\n            col = diffuse * albedo * fade;\n        }\n\n        float triangle = triangleMask(uv*(1.-beat/5.));\n        float fd = fract(triangle - clamp(sin(iTime/3.), 0., 2.));\n        float bc = (1. - step(.2, fd));\n\n        col *= (tr.material == MATERIAL_BACK) ? bc : 1.;\n        if (bc == 0.) {\n            if (tr.material == MATERIAL_BACK) {\n                col = getOthersideBackground(p.xy);\n            } else {\n                col *= vec3(.8);\n            }\n        }\n\n        col += ((1. - step(.2, fd)) - (1. - step(.19, fd)))*.3;\n\n    }\n\n\n    fragColor = vec4(col, 1.);\n    // fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[928, 928, 960, 960, 982], [984, 984, 1003, 1003, 1058], [1060, 1060, 1081, 1081, 1167], [1169, 1169, 1195, 1212, 1571], [1574, 1574, 1605, 1605, 2582], [2584, 2584, 2621, 2621, 3150], [3152, 3152, 3226, 3226, 3329], [3331, 3331, 3358, 3358, 3976], [3978, 3978, 4009, 4009, 4365], [4367, 4367, 4405, 4405, 4463], [4465, 4465, 4494, 4494, 6108], [6109, 6109, 6138, 6138, 6226], [6228, 6281, 6305, 6305, 6658], [6660, 6660, 6727, 6727, 7461], [7463, 7463, 7507, 7507, 7665], [7667, 7667, 7696, 7696, 7765], [7768, 7768, 7824, 7824, 10307]], "test": "untested"}
{"id": "cdsXW2", "name": "Triangle Galaxy Red Clean", "author": "elloskelling", "description": "Mashup of Inigo Quilez's triangle disrance demo and Simplicity Galaxy by JoshP and CBS with some tweaks to look good in VirtualDJ", "tags": ["triangle", "simplicitygalaxy", "microphon"], "likes": 3, "viewed": 366, "published": 3, "date": "1669588704", "time_retrieved": "2024-07-30T16:16:34.254365", "image_code": "// Mashup of:\n/////////////\n// https://www.shadertoy.com/view/MslGWN\n/////////////\n// and\n////////////\n// https://www.shadertoy.com/view/XsXSz4\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n////////////\n\n// These are tuned to look good in VirtualDJ. You may want to pull them down for other things.\n#define beatScale 3.7\n#define beatBias 0.\n#define fieldScale 1.3\n#define fieldBias 0.2\n#define starScale 1.5\n\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pp = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tpp *= 1.5;\n\n//////////////////////\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05,  0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[4]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[5]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n    \t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\n    \n    vec4 fC = fieldBias+fieldScale*(mix(freqs[5]-.3, 1., v) * vec4(1.5*freqs[4] * t * t* t , 1.2*freqs[3] * t * t, freqs[5]*t, 1.0)+c2)+starScale*starcolor;\n\n\n//////////////////\n\n    float beat = 0.25*freqs[0]*freqs[0]\n                +0.25*freqs[1]*freqs[1]\n                +0.25*freqs[2]*freqs[2]\n                +0.25*freqs[3]*freqs[3];\n    beat = sqrt(beat) * beatScale + beatBias;\n\n\n/*    float beat2 = 0.3*freqs[3]*freqs[3]\n                 +0.4*freqs[4]*freqs[4]\n                 +0.3*freqs[5]*freqs[5];\n    beat2 = sqrt(beat2) * beatScale + beatBias;*/\n\n    \n    float s = 2.3;\n    \n\n    // animate\n\tvec2 v1 = vec2(0.0,0.577-0.1)*(s);\n\tvec2 v2 = vec2(-0.5,-0.289-0.1)*(s);\n\tvec2 v3 = vec2(0.5,-0.289-0.1)*(s);\n\n    // distance\n\tfloat d = sdTriangle( pp, v1, v2, v3 );\n    \n    // color\n    vec3 col = beat - sign(d)*vec3(0.1,0.4,0.7);\n\t\n    if (d>0.){\n        col += fC.xyz - beat;\n    }else{\n        col *= 0.8 + 0.2*cos(120.0*d);\n        col *= vec3(1.,0.,0.);\n    }\n    \n    col *= 1.0 - exp(-2.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsXW2.jpg", "access": "api", "license": "mit", "functions": [[1440, 1440, 1472, 1472, 1859], [1861, 1897, 1931, 1931, 2318], [2320, 2320, 2344, 2344, 2527], [2529, 2565, 2632, 2632, 3233], [3235, 3235, 3292, 3292, 5912]], "test": "untested"}
{"id": "DdsXW2", "name": "Triangle Galaxy Red Lines", "author": "elloskelling", "description": "Mashup of Inigo Quilez's triangle disrance demo and Simplicity Galaxy by JoshP and CBS with some tweaks to look good in VirtualDJ", "tags": ["triangle", "simplicitygalaxy", "microphon"], "likes": 3, "viewed": 235, "published": 3, "date": "1669588684", "time_retrieved": "2024-07-30T16:16:35.213800", "image_code": "// Mashup of:\n/////////////\n// https://www.shadertoy.com/view/MslGWN\n/////////////\n// and\n////////////\n// https://www.shadertoy.com/view/XsXSz4\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n////////////\n\n// These are tuned to look good in VirtualDJ. You may want to pull them down for other things.\n#define beatScale 3.7\n#define beatBias 0.\n#define fieldScale 1.3\n#define fieldBias 0.2\n#define starScale 1.5\n\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pp = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tpp *= 1.5;\n\n//////////////////////\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05,  0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[4]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[5]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n    \t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\n    \n    vec4 fC = fieldBias+fieldScale*(mix(freqs[5]-.3, 1., v) * vec4(1.5*freqs[4] * t * t* t , 1.2*freqs[3] * t * t, freqs[5]*t, 1.0)+c2)+starScale*starcolor;\n\n\n//////////////////\n\n    float beat = 0.25*freqs[0]*freqs[0]\n                +0.25*freqs[1]*freqs[1]\n                +0.25*freqs[2]*freqs[2]\n                +0.25*freqs[3]*freqs[3];\n    beat = sqrt(beat) * beatScale + beatBias;\n\n\n/*    float beat2 = 0.3*freqs[3]*freqs[3]\n                 +0.4*freqs[4]*freqs[4]\n                 +0.3*freqs[5]*freqs[5];\n    beat2 = sqrt(beat2) * beatScale + beatBias;*/\n\n    \n    float s = 2.3;\n    \n\n    // animate\n\tvec2 v1 = vec2(0.0,0.577-0.1)*(s);\n\tvec2 v2 = vec2(-0.5,-0.289-0.1)*(s);\n\tvec2 v3 = vec2(0.5,-0.289-0.1)*(s);\n\n    // distance\n\tfloat d = sdTriangle( pp, v1, v2, v3 );\n    \n    // color\n    vec3 col = beat - sign(d)*vec3(0.1,0.4,0.7);\n\t\n    if (d>0.){\n        col += fC.xyz - beat;\n    }else{\n        col *= vec3(1.,0.,0.);\n    }\n    \n    col *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdsXW2.jpg", "access": "api", "license": "mit", "functions": [[1440, 1440, 1472, 1472, 1859], [1861, 1897, 1931, 1931, 2318], [2320, 2320, 2344, 2344, 2527], [2529, 2565, 2632, 2632, 3233], [3235, 3235, 3292, 3292, 5905]], "test": "untested"}
{"id": "DssXW2", "name": "Fractal Flower Fork", "author": "elloskelling", "description": "Based on https://www.shadertoy.com/view/Xs3yDH, updating brightness for VirtualDJ which runs darker\n---------------------------------------------\nTesting music integration into one of my previous shaders.\nOriginal https://www.shadertoy.com/view/llSSDV\n", "tags": ["fractal", "music"], "likes": 7, "viewed": 605, "published": 3, "date": "1669588656", "time_retrieved": "2024-07-30T16:16:35.972771", "image_code": "const float iter    = 64.,\n            divAng  = 24. * 6.2831853/360.,\n            circRad = .23, \n    \t    rat     = .045/circRad;\n\nfloat nearestMult(float v, float of) {\n\tfloat m = mod(v, of);\n\tv -= m * sign(of/2. - m);\n\treturn v - mod(v,of);\n}\n\n//Color palette function taken from iq's shader @ https://www.shadertoy.com/view/ll2GD3\n#define  pal(t) ( .5 + .5* cos( 6.283*( t + vec4(0,1,2,0)/3.) ) )\n\n\n\n\nvoid mainImage( out vec4 o, vec2 uv ) {\n    vec2 R = iResolution.xy,\n         center = vec2(0.), p;\n    float M = max(R.x, R.y);\n    uv = ( uv -.5*R) / M / .7;\n    float l = length(uv);\n    float sl = texture(iChannel0, vec2(0.)).x ;\n    float sl2 = texture(iChannel0, vec2(0.25)).x * .5 ;\n    float sm = texture(iChannel0, vec2(0.5)).x * .2 ;\n    float sm2 = texture(iChannel0, vec2(0.75)).x * .2 ;\n    float sh = texture(iChannel0, vec2(1.)).x * .2;\n    float st = (sl+sl2+sm+sm2+sh);// / 5.;\n\tfloat time = iTime,\n          sCircRad = circRad*rat, \n          ds = (2.+ 1.4*((st)) /*abs(sin(time/10.))*/) * rat,\n          ang, dist;\n    \n \t\n    o = vec4(0.1);\n\tfor(float i=0.;i< iter;i+=1.) {\n        p = uv-center;\n\t\tang =  atan(p.y,p.x);\t\t\n        ang = nearestMult(ang, divAng);     \n\t\tcenter += sCircRad/rat* vec2(cos(ang), sin(ang));\n\t\tdist = distance( center, uv);\n\n\t\tif( dist <=sCircRad )\n             o += 30.*dist * pal( fract(dist/sCircRad + st+l/*+ abs(sin(time/2.))*/) );\n   \n  \t\tsCircRad *= ds;\n\t}\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 171, 171, 246], [406, 406, 445, 445, 1419]], "test": "untested"}
{"id": "cssXW2", "name": "Triangle Galaxy White", "author": "elloskelling", "description": "Mashup of Inigo Quilez's triangle disrance demo and Simplicity Galaxy by JoshP and CBS with some tweaks to look good in VirtualDJ", "tags": ["triangle", "simplicitygalaxy", "microphon"], "likes": 4, "viewed": 188, "published": 3, "date": "1669588646", "time_retrieved": "2024-07-30T16:16:37.239385", "image_code": "// Mashup of:\n/////////////\n// https://www.shadertoy.com/view/MslGWN\n/////////////\n// and\n////////////\n// https://www.shadertoy.com/view/XsXSz4\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n////////////\n\n// These are tuned to look good in VirtualDJ. You may want to pull them down for other things.\n#define beatScale 3.7\n#define beatBias 0.\n#define fieldScale 1.3\n#define fieldBias 0.2\n#define starScale 1.5\n\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pp = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tpp *= 1.5;\n\n//////////////////////\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05,  0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[4]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[5]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n    \t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\n    \n    vec4 fC = fieldBias+fieldScale*(mix(freqs[5]-.3, 1., v) * vec4(1.5*freqs[4] * t * t* t , 1.2*freqs[3] * t * t, freqs[5]*t, 1.0)+c2)+starScale*starcolor;\n\n\n//////////////////\n\n    float beat = 0.25*freqs[0]*freqs[0]\n                +0.25*freqs[1]*freqs[1]\n                +0.25*freqs[2]*freqs[2]\n                +0.25*freqs[3]*freqs[3];\n    beat = sqrt(beat) * beatScale + beatBias;\n\n\n/*    float beat2 = 0.3*freqs[3]*freqs[3]\n                 +0.4*freqs[4]*freqs[4]\n                 +0.3*freqs[5]*freqs[5];\n    beat2 = sqrt(beat2) * beatScale + beatBias;*/\n\n    \n    float s = 2.3;\n    \n\n    // animate\n\tvec2 v1 = vec2(0.0,0.577-0.1)*(s);\n\tvec2 v2 = vec2(-0.5,-0.289-0.1)*(s);\n\tvec2 v3 = vec2(0.5,-0.289-0.1)*(s);\n\n    // distance\n\tfloat d = sdTriangle( pp, v1, v2, v3 );\n    \n    // color\n    vec3 col = beat - sign(d)*vec3(0.1,0.4,0.7);\n\t\n    if (d>0.){\n        col += fC.xyz - beat;\n    }\n    \n    col *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssXW2.jpg", "access": "api", "license": "mit", "functions": [[1440, 1440, 1472, 1472, 1859], [1861, 1897, 1931, 1931, 2318], [2320, 2320, 2344, 2344, 2527], [2529, 2565, 2632, 2632, 3233], [3235, 3235, 3292, 3292, 5863]], "test": "untested"}
{"id": "cdlSW2", "name": "Keyboard, Variables, QOL", "author": "raymarchingenthusiast", "description": " A compilation of useful things. I made a keyboard (references used) and variable systems. Vignette, mouse glow, et.c. Thanks to FabriceNeyret2. Frame independence.", "tags": ["key", "keyboard", "variable", "variables", "qol"], "likes": 3, "viewed": 200, "published": 3, "date": "1669587920", "time_retrieved": "2024-07-30T16:16:38.077145", "image_code": "#define s__VP 3.\n#define s_VA 3.\n\nint currKeyPressed() {\n    int CKP = -1;         //Thanks FabriceNeyret2 for this.\n    bool b = false;       //(I made some edits so that it works outside of their demo)\n    for (int i=0; i<256; i++) if (bool(key(i)) )  CKP = i, b=true;\n    return CKP;\n}\n\n#define CKP currKeyPressed()\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = UV(fragCoord,iResolution.xy);\n    vec2 muv = UV(iMouse.xy,iResolution.xy);\n    vec4 vars = getVars(fragCoord);\n    \n    vec3 col = texture(iChannel0,(vars.zw/100.+UV(fragCoord,iResolution.xy))*2.).xyz;\n    \n    col *= 1.-pow(s__VP*length(uv-.75),s_VA);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nint currKeyPressed() {\n    int CKP = -1;         //Thanks FabriceNeyret2 for this.\n    bool b = false;       //(I made some edits so that it works outside of their demo)\n    for (int i=0; i<256; i++) if (bool(key(i)) )  CKP = i, b=true;\n    return CKP;\n}\n\n#define CKP currKeyPressed()\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 last = getVars(fragCoord);\n    if(iFrame<2) last = vec4(0.);\n    \n    vec4 new = last;\n    new.xy *= .8;\n    new.x += .2*(key(68)-key(65))*iTimeDelta*60.;  //*iTimeDelta*60. makes it\n    new.y += .2*(key(87)-key(83))*iTimeDelta*60.;  //frame rate independent\n    \n    \n    fragColor = vec4(new.xy,last.zw+new.xy);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define getVars(texturePos) texture(iChannel3,texturePos)\n#define key(code) float(texelFetch(iChannel0,ivec2(code,0),0).x>0.)\n#define PI 3.141592653589793\n#define lerp(a,b,t) a*(1.-t)+b*t\n#define UV(p,r) .5+.5*p/r\n#define unUV(p,r) (p-.5)*2.*r\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 56, 56, 288], [320, 320, 377, 377, 682]], "test": "untested"}
{"id": "mdfXD2", "name": "Impossible refractions", "author": "mrange", "description": "CC0: Impossible refractions\nTinkering with an old shader + new distance field\nLooked interesting enough to share.\n\n", "tags": ["raymarch", "refraction"], "likes": 34, "viewed": 393, "published": 3, "date": "1669574496", "time_retrieved": "2024-07-30T16:16:39.111379", "image_code": "// CC0: Impossible refractions\n//  Tinkering with an old shader + new distance field\n//  Looked interesting enough to share.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define PI_2            (0.5*PI)\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  12.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define MAX_BOUNCES     5\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nmat3 g_rot  = mat3(1.0); \nvec3 g_mat  = vec3(0.0);\nvec3 g_beer = vec3(0.0);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 skyCol     = HSV2RGB(vec3(0.6, 0.86, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\n\nconst float initt       = 0.1; \n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat hexTorus(vec3 p, vec3 d) {\n  vec2 q = vec2(length(p.xz) - d.x, p.y);\n  float a = atan_approx(p.x, p.z);\n  mat2 r = ROT(1.0*a);\n  return hex(r*q, d.y)-d.z;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df10(vec3 p) {\n  vec3 mat = vec3(0.9, 0.85, 1.5);\n  const vec3 gcol = -4.0*(HSV2RGB(vec3(0.05, 0.925, 1.0)));\n  vec3 beer = gcol;\n\n  float d0 = hexTorus(p, vec3(2.0, 0.65, 0.025));\n  float d1 = torus(p, vec2(2.0, 0.25));\n  float d = d0;\n  \n  d = max(d, -(d1- 0.05));\n  if (d1 < d) {\n    const vec3 gcol = -10.*(HSV2RGB(vec3(0.55, 0.5, 1.0)));\n    beer = gcol;\n    d = d1;\n  }\n\n  g_mat = mat;\n  g_beer = beer;\n\n  return d;\n}\n\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  p = p.xzy;\n  return df10(p);\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = min(min(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    vec3 mat = g_mat;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n//    fre = clamp(abs(fre), 0.0, 1.0);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    float re    = mat.z;\n    float ire   = 1.0/re;\n    vec3 refr   = refract(rd, sn, !isInside ? re : ire);\n    vec3 rsky   = skyColor(sp, ref);\n    const vec3 dcol = HSV2RGB(vec3(0.6, 0.85, 1.0));\n    vec3 col = vec3(0.0);    \n    col += dcol*dif*dif*(1.0-mat.x);\n    float edge = smoothstep(1.0, 0.9, fre);\n    col += rsky*mat.y*fre*vec3(1.0)*edge;\n    if (isInside) {\n      ragg *= exp(-st*g_beer);\n    }\n    agg += ragg*col;\n\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      ragg *= mat.x;\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    // TODO: if beer is active should also computer it based on initt    \n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  float a = 0.05*TIME;\n  g_rot = rot_x(2.0*a)*rot_y(3.0*a)*rot_z(5.0*a);\n  vec3 ro = vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[731, 731, 753, 753, 899], [1329, 1429, 1448, 1448, 1535], [1537, 1644, 1670, 1670, 1854], [1856, 1942, 1979, 1979, 2086], [2088, 2206, 2235, 2235, 2300], [2302, 2420, 2448, 2448, 2628], [2630, 2723, 2755, 2755, 2885], [2887, 3005, 3032, 3032, 3108], [3110, 3222, 3264, 3264, 3311], [3313, 3313, 3334, 3334, 3434], [3436, 3436, 3457, 3457, 3557], [3559, 3559, 3580, 3580, 3683], [3685, 3685, 3718, 3718, 4392], [4394, 4394, 4414, 4414, 4823], [4826, 4826, 4844, 4844, 4891], [4893, 4893, 4916, 4916, 5124], [5126, 5126, 5187, 5187, 5511], [5513, 5513, 5544, 5544, 7052], [7054, 7054, 7075, 7075, 7500], [7502, 7502, 7559, 7559, 7777]], "test": "untested"}
{"id": "dsXXW2", "name": "Reactor Core", "author": "pr1ncess_emily", "description": "My first published shader!\nA series of green rings with a glowing bar in the center, indicating potential radioactive properties...", "tags": ["sdf", "glow"], "likes": 3, "viewed": 189, "published": 3, "date": "1669571067", "time_retrieved": "2024-07-30T16:16:39.987038", "image_code": "#define DISTANCE_THRESHOLD 0.01\n#define GLOW_RADIUS 0.05\n\n// Inigo Quilez segment sdf\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Center bar coordinates\n    float x = 0.35*cos(iTime);\n    float y = 0.35*sin(iTime);\n    \n    float x2 = (0.35*cos(iTime + radians(180.0)));\n    float y2 = (0.35*sin(iTime + radians(180.0)));\n    \n    float dist = sdSegment(uv, vec2(x,y), vec2(x2,y2));\n\n    vec3 col = vec3(0.0,0.0,0.0);\n\n    if (dist < DISTANCE_THRESHOLD) {\n        // Inside center bar\n        col = vec3(0.0,1.0,0.0);\n    } else if (dist < GLOW_RADIUS) {\n        // Outside bar, but within glow radius\n        float glow = GLOW_RADIUS * abs(sin(iTime));\n        float distUV = dist * (1.0/glow);\n        float g = smoothstep(1.0,0.0,distUV);\n        col = vec3(0.0,g,0.0);\n    } else {\n        // Outside glow radius\n        float ringFrequency = 10.0;\n        float ringDecay = 30.0;\n        float g = step(0.8, fract(dist * ringFrequency)) / floor(dist * ringDecay);\n        col = vec3(0.0,g,0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 138, 190, 190, 309], [311, 311, 368, 418, 1433]], "test": "untested"}
{"id": "msfSDj", "name": "busyHUD", "author": "Del", "description": "A simple busy spinner for a HUD - https://youtu.be/qzMAGAn3QE8", "tags": ["polar", "spinner", "repeat"], "likes": 10, "viewed": 245, "published": 3, "date": "1669564440", "time_retrieved": "2024-07-30T16:16:40.907577", "image_code": "// Simple busy HUD - https://youtu.be/qzMAGAn3QE8\n\n#define PI 3.141519\n#define TAU 6.283185\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// dashed circle - https://www.shadertoy.com/view/7tyGWw\nfloat sdDashedCircle(in vec2 p, float at, float inner,float outer,float nseg,float rat) \n{\n    float le = length(p);\n    float hw = (outer-inner)*0.5;\n    float ce = le - (outer-hw);\n    ce = abs(ce)-hw;\n    //float at = atan(p.x,p.y);\n    float gr = fract((at/TAU)*nseg); \n    gr = abs((gr-0.5)*2.0);\n    gr = gr-rat;\n    float an = gr * (PI/nseg);\n    mat2 rm = rot(an);\n    float c = rm[0][0];//cos(an);\n    float ep = clamp(c*le,inner,outer);\n    vec2  ne = p*rm;\n    ne *= ep/le;  \n    float ed = length(p-ne);\n    return (an>0.0) ? ed : (ce>0.0) ? ce : max(-ed,ce);\n}\n\nvec4 GetTimer(in vec2 p,float fill)\n{\n    vec3 col1 = vec3(0.95,0.75,0.25);    // orange\n    vec3 col2 = vec3(0.2,0.2,0.2);    // grey    \n    float totalsegs = 60.0;\n    float extra = 40.0;\n    float thresh = totalsegs+(extra*0.5);\n    fill *= (totalsegs+1.0+extra);\n    \n    float at = atan(p.x,p.y);\n    float count = floor(at/(TAU/totalsegs)) + totalsegs*0.5;\n    \n    float fade = clamp((fill-count)*0.1,0.0,1.0);\n    float fade2 = 1.0;\n    if (fill>thresh)\n        fade *= 1.0-clamp((fill-thresh)*0.05,0.0,1.0);\n\n    // render circle\n    float rad = 0.8;\n    float height = mix(0.02,0.04,fade);    \n    float inner = rad-height;\n    float outer = rad+height;\n    float rt = 0.65;//float rt = mix(0.25,0.6,fade);\n    float d =  sdDashedCircle(p,at,inner,outer,totalsegs,rt);\n    float aa = 1.5*rt*fwidth(at); //2./iResolution.y; // 0.005\n    float cc = smoothstep(aa,0.0,d);\n    return vec4(mix(col2*cc,col1*cc,fade),cc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float t = iTime;\n    float fill = fract(t*0.4);\n    fragColor = GetTimer(-p,fill);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 112, 112, 188], [190, 247, 337, 337, 820], [822, 822, 859, 859, 1750], [1753, 1753, 1810, 1810, 1958]], "test": "untested"}
{"id": "DsfSWj", "name": "Light beam", "author": "Yahor10", "description": "light ray with sdf  line, can be apply for  black and white texture(mask)", "tags": ["beam", "lightrays", "shining"], "likes": 7, "viewed": 402, "published": 3, "date": "1669563219", "time_retrieved": "2024-07-30T16:16:41.710430", "image_code": "const float PI = 3.14159265359f;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;            \n    // Calculate polar coordinates\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);       \n    // Draw the lines\n    const float it = 5.0;\n    float c = 0.0;\n    for( float i = 0.0 ; i < it ; i += 1.0 )// line copy from here https://www.shadertoy.com/view/MtBGRt\n    {\n        float i01 = i / it;\n        float rnd = .0;\n        float react = .0;          \n        float c1 = (uv.x + 1.1 + react) * 0.004 * abs( 1.0 / sin( (uv.y +0.15) +\n                                                         sin(uv.x * .5) *\n                                                                 (0.51 + 0.35)) );\n        c = clamp(c + c1, 0.0, 1.0);\n    }    \n    vec2 origin = vec2(c);    \n    float timeValue = iTime ;\n    float angleRad = cos(timeValue);    \n    float offset = mix(.77, 0.5, angleRad); //aligned by 2    \n    vec2 e = origin;\n    \n    vec2 cylinderTexCoords = e; // coordinates for shining. Can be apply with sdf or black/white texture( mask)\n    cylinderTexCoords.x = (asin(2.0 * origin.x - 1.0)) / (PI) + (offset * origin.y) + 0.5;        \n    \n    //vec4 textureShine = texture(blackwhitemask,cylinderTexCoords);\n    vec2 inverseCylinderTexCoords = origin;\n    inverseCylinderTexCoords.x = cylinderTexCoords.x - (2.0 * offset * origin.y);\n    //vec4 textureShineInverse = texture(blackwhitemask,inverseCylinderTexCoords);\n     fragColor = vec4(c +(cylinderTexCoords.x * inverseCylinderTexCoords.x) )*vec4(240.0, 177.0, 90.0, 255.0) / 255.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 90, 90, 1667]], "test": "untested"}
{"id": "ddfXWj", "name": "Time Traveller", "author": "SnoopethDuckDuck", "description": "This is the best thing I've ever made. Click pause and reset a few times if the audio isn't working.\n\nPls don't read the code, it's bad, and ty to the forked duck.", "tags": ["reactive", "audio", "visual"], "likes": 22, "viewed": 254, "published": 3, "date": "1669562002", "time_retrieved": "2024-07-30T16:16:42.510292", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\nconst float rn = 64.0;\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n// i dont understand this function at all (from iq, ty!)\nfloat arc(in vec2 p, in vec2 sc, in float ra, float rb){\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat getFreq(float x) {\n\treturn texture(iChannel0, vec2(floor(x * rn + 1.) / rn, 0)).x;\n}\n\n\nfloat getFreq_smooth(float x) {\n\tfloat index = floor(x * rn) / rn;\n    float next = floor(x * rn + 1.0) / rn;\n\treturn mix(getFreq(index), getFreq(next), smoothstep(0.0, 1.0, fract(x * rn)));\n}\n\nfloat getFreq_blend(float x) {\n    return mix(getFreq(x), getFreq_smooth(x), 0.5);\n}\n\n#define pi 3.14159\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    \n    float freq = getFreq_smooth(abs(uv.x));\n\tvec3 col = vec3(freq);\n\n    float v = getFreq_smooth(0.);\n    uv.x = abs(uv.x);\n    uv.y += 0.15;\n    vec2 o = vec2(0.05 + 0.2 * v * v, 0.25);\n    float d = length(uv - o);\n    float t = -pi/4. + v * pi/2. + pi / 8. * cos(2. * pi * v);\n    float d2 = arc(-uv + vec2(0,0.2*v), \n                   vec2(cos(t), sin(t)),\n                   0.25* v * v, 0.);\n\n    float thk = 0.01; //0.005 + 0.01 * v;\n    float k = 1. / iResolution.y;\n    float s = smoothstep(-k, k, abs(-d + 0.1 * v * v) - thk);\n    float s2 = smoothstep(-k ,k, abs(-d2 + 0.1 * pow(v,2.5)) - thk);\n    float d3 = length(uv - o);\n\n    uv.y -= 0.15;\n    float d4 = length(uv);\n    float s3 = smoothstep(-k, k, -d3 + 0.05 * v * v);\n    float s4 = smoothstep(-k, k, abs(-d4 + 0.2 + 0.2 * v) - thk);\n\n    col = vec3((s * s2-s3) * s4);\n    float r2 = .2 + .2 * v;\n    vec3 col2 = col * (1.-pow(1.-v,2.)) * \n               (step(d4,r2) + exp(-(20. + 20. * (1.-v)) * abs(d4 - thk - r2)));\n    float tnh = tanh(0.25 * max(0., iTime - 4.));\n    //if (iTime > 7. * pi) \n    //    tnh = pow(0.5 - 0.5 * thc(5., 1. * iTime), 40.);\n    // Uncomment this if you want to lose your eyesight\n    // (STROBE WARNING)\n    //tnh *= 0.5 + 0.5 * thc(4., 30. * iTime + 0. * pi * v);\n    \n    col = mix(col, col2, tnh);\n    //col = mix(col, 0.5 + vec3(ouv.x, ouv.y, 0.), 0.1);\n    col = mix(col, col * vec3(1,v,1.-v) * (0.85 + uv.y), tnh);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30608, "src": "https://soundcloud.com/knowermusic/time-traveler-2?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 172, 228, 228, 362], [364, 364, 388, 388, 454], [457, 457, 488, 488, 649], [651, 651, 681, 681, 735], [756, 756, 813, 813, 2362]], "test": "untested"}
{"id": "DsfXD2", "name": "planet01 forked by CJ", "author": "chrisjj", "description": "реймарчинг\n\nForked https://www.shadertoy.com/view/ttyBz1 , fixed error by commenting-out function at line 67.", "tags": ["raymarching"], "likes": 5, "viewed": 147, "published": 3, "date": "1669558817", "time_retrieved": "2024-07-30T16:16:43.403902", "image_code": "#define ITERATION 500\n#define MAX_DIST 10.\n#define EX vec3(0.001, 0., 0.)\n#define EY vec3(0., 0.001, 0.)\n#define EZ vec3(0., 0., 0.001)\n#define w iResolution.x\n#define h iResolution.y\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (vec2 st) {\n    \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return fract(abs(sin(st)*43758.5453123));\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .6;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat dist(vec3 a, vec3 b) { //Считает расстояние между точками в трехмерном пространстве\n\treturn sqrt(pow(a.x - b.x, 2.) + pow(a.y - b.y, 2.) + pow(a.z - b.z, 2.));\n}\n\n// CJ fix for error\n//vec3 normalize(vec3 a) { //Нормализует вектор\n// 'normalize' : Name of a built-in function cannot be redeclared as function\n//    float l = dist(a, vec3(0.,0.,0.));\n//    return vec3(a.x / l, a.y / l, a.z / l);\n//}\n\nvec3 sum(vec3 a, vec3 b) { //Суммирует вектора\n\treturn vec3(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\nvec3 sub(vec3 a, vec3 b) { //Вычитает вектора\n\treturn vec3(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\nvec3 mul(vec3 a, float value) { //Умножает вектор на значение\n\treturn vec3(a.x * value, a.y * value, a.z * value);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat m = max(min(0.5 + 0.5 * (b - a) / k, 1.), 0.);\n\treturn a * m + b * (1. - m) - k * m * (1. - m);\n}\n\n\n\n\nfloat getDistdotsentra(vec3 p) { //ПОЛУЧИТЬ РАССТОЯНИЕ ОТ ТОЧКИ ДО центра сферы\n\tvec3 sphere = vec3(0.,0.,0.);\n\tfloat sphereDist = dist(p, sphere) - 1.5 ;\n\tfloat d = sphereDist;\n\treturn d;\n\n}\n\nvec3 normalforlit(vec3 p) {\n\tfloat d = getDistdotsentra(p);\n\tfloat p1 = getDistdotsentra(sub(p, EX));\n\tfloat p2 = getDistdotsentra(sub(p, EY));\n\tfloat p3 = getDistdotsentra(sub(p, EZ));\n\tvec3 tri = vec3(p1, p2, p3);\n\tvec3 n = sub(vec3(d,d,d), tri);\n\treturn normalize(n);\n}\n\n\nvec2 getDist(vec3 p) { //ПОЛУЧИТЬ РАССТОЯНИЕ ОТ ТОЧКИ ДО СФЕРЫ\n\tvec3 sphere = vec3(0.,0.,0.);\n    vec3 n = normalforlit(p);\n    \n    vec2 st = p.xy;\n    \n    st.y+= iTime*0.1;\n    \n     // Масштаб\n    float mashtab = 15.;\n    st *= mashtab;\n\n    // Разбиение пространства\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 100.0;\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Соседняя клетка\n            vec2 neighbor = vec2(float(x),float(y));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5+0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st; //вектор до точки\n            float dist = length(diff) + 1.*sin(point.x); // Расстояние до точки\n            m_dist = min(m_dist, dist); // Сохранить наименьшее расстояние\n        }\n    }\n\n    //float line = 1./(iResolution.y/mashtab);\n    //vec3 col = vec3(m_dist);\n    //fragColor = vec4(col,1.0);\n    \n    \n\tfloat sphereDist = dist(p, sphere) - m_dist*0.1 - 1.3 ;\n    float fraktal_noise = dist(p, sphere)  - fbm(vec2(n.x*4.+iTime*0.7, n.y*4.))*0.7 - 1. ; \n    \n    float d = smin(sphereDist, fraktal_noise, 0.1);\n    //  + fbm(vec2(n.x*5.+iTime, n.y*5.))*0.5\n    // фрактальный шум\n    float t = 0.;\n    if (sphereDist>fraktal_noise) t = 1.;\n    \n\t//float d = sphereDist;\n\treturn vec2(d, t);\n\n}\n\n\nvec3 normal(vec3 p) {\n\tfloat d = getDist(p).x;\n\tfloat p1 = getDist(sub(p, EX)).x;\n\tfloat p2 = getDist(sub(p, EY)).x;\n\tfloat p3 = getDist(sub(p, EZ)).x;\n\tvec3 tri = vec3(p1, p2, p3);\n\tvec3 n = sub(vec3(d,d,d), tri);\n\treturn normalize(n);\n}\n\n\n\n\n\nfloat light(vec3 p) {\n\t//vec3 lightPos = vec3(-10., 4., 0.);\n    vec3 lightPos = vec3(sin(iTime)*3., 1., cos(iTime)*3.);\n\tvec3 lightDir = normalize(sub(lightPos, p));\n\tvec3 n = normalforlit(p);\n\treturn dot(n, lightDir) * 0.5  + 0.5;\n}\n\nvec3 rayMarching(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tfor (int i = -0; i < 500; i++){\n\t\tfloat d = getDist(p).x;\n        float t = getDist(p).y;\n\t\tif (d > MAX_DIST) {break;}\n\t\tp = sum(p, mul(rd, d));\n\t\tif (d < 0.0001){\n\t\t\t//let dif = i / ITERATION\n\t\t\t//dif = dif+dif\n            float l = light(p);\n            float n = 2.;\n\t\t\treturn vec3(\n            pow(l*t,5.),\n            pow(l,n),\n            pow(l*(1.-t),n)\n            \n            );\n\t\t} \n\t}\n\treturn vec3(0.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int iteration = 500;\n    const float max_dist = 10.0;\n\n\t//координаты камеры\n\tvec3 ro = vec3(0., 0., -2.5);\n\n    float x = (fragCoord.x / w) * 2. - 1.;\n    float y = (fragCoord.y / h) * 2. - 1.;\n    x *= w / h;\n\n    //направление луча\n    vec3 rd = vec3(x, y , 1.);\n    rd = normalize(rd);\n\n    //круг\n    vec3 color = rayMarching(ro, rd);\n\t\t\t\n\t\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 320, 320, 397], [399, 399, 421, 421, 554], [556, 634, 660, 660, 1040], [1060, 1060, 1084, 1106, 1360], [1363, 1363, 1391, 1504, 1582], [1839, 1839, 1865, 1901, 1950], [1952, 1952, 1978, 2012, 2061], [2063, 2063, 2094, 2148, 2203], [2205, 2205, 2244, 2244, 2349], [2354, 2354, 2386, 2471, 2583], [2585, 2585, 2612, 2612, 2857], [2860, 2860, 2882, 2954, 4372], [4375, 4375, 4396, 4396, 4613], [4619, 4619, 4640, 4679, 4853], [4855, 4855, 4891, 4891, 5329], [5331, 5331, 5388, 5388, 5853]], "test": "untested"}
{"id": "DslXD7", "name": "My first gyroid :)", "author": "z0rg", "description": "Gyroid :)", "tags": ["sphere", "bubble", "gyroid"], "likes": 13, "viewed": 273, "published": 3, "date": "1669546662", "time_retrieved": "2024-07-30T16:16:44.171850", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 20\n#define GLOW_DISTANCE 0.05\n#define GLOW_POW 1.9\n#define GLOW_OPACITY .7\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 3.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    float sz = 5.;\n    float gyroid = abs(dot(sin(p*sz), cos(p.yzx*sz+iTime))/sz)-.01;\n    sz = 18.;\n    gyroid = max(gyroid, dot(sin(p*sz), cos(p.yzx*sz+iTime))/sz);\n    gyroid = max(gyroid, length(p)-1.);\n    \n    gyroid = max(gyroid, -(length(p)-.8));\n    acc = _min(acc, vec2(gyroid, 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 20.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.5;\n        accCol += (normalize(p)*.5+.5)*(1.-sat(res.x/.3))*.02;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float d = 1.5;\n    float t = iTime*.3;\n    uv *= r2d(sin(t));\n    vec3 ro = vec3(sin(t)*d,sin(t)*d*cos(t),cos(t)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n    }\n    col += accCol;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true)// Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 1.9/(col+1.);\n    col = sat(col);\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .7);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslXD7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1087]], "test": "untested"}
{"id": "DdXSWj", "name": "Graphic Design Experiment 4", "author": "yasuo", "description": "Graphic Design Experiment 4", "tags": ["font", "graphicdesign", "cineshader"], "likes": 30, "viewed": 2567, "published": 3, "date": "1669539897", "time_retrieved": "2024-07-30T16:16:45.121310", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n#define FS 0.46 // font size\n#define FGS FS/5. // font grid size\n//#define OUTLINE\n\n// fully modified version of the Letterform Variations font\n#define char_0 0\n#define char_1 1\n#define char_2 2\n#define char_3 3\n#define char_4 4\n#define char_5 5\n#define char_6 6\n#define char_7 7\n#define char_8 8\n#define char_9 9\n#define char_A 10\n#define char_B 11\n#define char_C 12\n#define char_D 13\n#define char_E 14\n#define char_F 15\n#define char_G 16\n#define char_H 17\n#define char_I 18\n#define char_J 19\n#define char_K 20\n#define char_L 21\n#define char_M 22\n#define char_N 23\n#define char_O 24\n#define char_P 25\n#define char_Q 26\n#define char_R 27\n#define char_S 28\n#define char_T 29\n#define char_U 30\n#define char_V 31\n#define char_W 32\n#define char_X 33\n#define char_Y 34\n#define char_Z 35\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat charA(vec2 p){\n    vec2 prevP = p;\n    float d = B(p-vec2(0.0,FGS*4.),vec2(FS,FGS));\n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    p.x = abs(p.x);\n    d2 = B(p-vec2(FGS*4.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charB(vec2 p) {\n    vec2 prevP = p;\n    p.y = abs(p.y);\n    float d = B(p-vec2(0.0,FGS*4.),vec2(FS,FGS));\n    p = prevP;\n    float d2 = B(p-vec2(-FGS,0.0),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    \n    p.y = abs(p.y);\n    p-=vec2(FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charC(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.0,FGS*4.),vec2(FS,FGS));\n    \n    float d2 = B(p-vec2(FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,-FGS*2.);\n    p*=Rot(radians(-45.));\n    \n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charD(vec2 p){\n    vec2 prevP = p;\n    p.y=abs(p.y);\n    float d = B(p-vec2(0.0,FGS*4.),vec2(FS,FGS));\n    p = prevP;\n    float d2 = B(p-vec2(FGS*4.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    \n    d2 = B(p,vec2(FGS,FS));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charE(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = charC(p);\n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charF(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.0,FGS*4.),vec2(FS,FGS));\n    \n    float d2 = B(p-vec2(-FGS,0.),vec2(FGS*4.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p-=vec2(0.,-FGS*2.);\n    \n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charG(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = charC(p);\n    float d2 = B(p-vec2(FGS*2.,0.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charH(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*4.,0.0),vec2(FGS,FS));\n    \n    float d2 = B(p-vec2(0.0,0.0),vec2(FGS,FS));\n    d = min(d,d2);\n    d2 = B(p-vec2(FGS*2.,0.0),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    p.y = abs(p.y);\n    d2 = B(p-vec2(-FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charI(vec2 p) {\n    vec2 prevP = p;\n    p.y = abs(p.y);\n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    p = prevP;\n    float d2 = B(p,vec2(FGS,FS));\n    d = min(d,d2);\n    d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charJ(vec2 p) {\n    vec2 prevP = p;\n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    float d2 = B(p-vec2(0.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    d2 = B(p-vec2(-FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    \n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat charK(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,0.0),vec2(FGS,FS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(FGS*2.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charL(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    \n    float d2 = B(p-vec2(FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    \n    p-=vec2(-FGS*2.,-FGS*2.);\n    p*=Rot(radians(-45.));\n    \n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charM(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p,vec2(FS,FGS));\n    \n    float d2 = B(p,vec2(FGS,FS));\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    d2 = B(p-vec2(FGS*4.,-FGS),vec2(FGS,FGS*4.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charN(vec2 p) {\n    vec2 prevP = p;\n    \n    p.x = abs(p.x);\n    float d = B(p-vec2(FGS*4.,0.),vec2(FGS,FS));\n    \n    p = prevP;\n    float d2 = B(p,vec2(FGS,FS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n        \n    d2 = B(p-vec2(FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charO(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    \n    p = prevP;\n    float d2 = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(-FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p =prevP;    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charP(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*2.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n        \n    d2 = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charQ(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = charO(p);\n    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS*3.,FGS));\n    d = min(d,d2);\n\n    return d;\n}\n\nfloat charR(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n        \n    d2 = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n        \n    d2 = B(p-vec2(0.0,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);    \n            \n    d2 = B(p-vec2(FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);  \n    \n    return d;\n}\n\nfloat charS(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(-FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charT(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,FGS*2.),vec2(FS,FGS));\n    \n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charU(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,-FGS*2.),vec2(FS,FGS));\n    \n    p.x = abs(p.x);\n    float d2 = B(p-vec2(FGS*2.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charV(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    \n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charW(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    \n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p,vec2(FGS,FS));\n    d = min(d,d2);\n    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(FGS*3.,FGS));\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat charX(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    \n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charY(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    \n    float d2 = B(p-vec2(0.,-FGS),vec2(FGS,FGS*4.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat charZ(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,FGS*3.),vec2(FGS,FGS*2.));\n    \n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(FGS*4.,-FGS*3.),vec2(FGS,FGS*2.));\n    d = min(d,d2);\n    \n    p.y = abs(p.y);\n    d2 = B(p-vec2(0., FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char1(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p,vec2(FGS,FS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(0.,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char2(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    d2 = B(p-vec2(FGS*2.,0.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(0.,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    p-=vec2(-FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat char3(vec2 p) {\n    vec2 prevP = p;\n    \n    p.y = abs(p.y);\n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    p = prevP;\n    p.x = abs(p.x);\n    float d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(FGS*2.,0.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n\n    p-=vec2(FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);   \n\n    return d;\n}\n\nfloat char4(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,-FGS*2.),vec2(FS,FGS));\n    \n    float d2 = B(p-vec2(-FGS*2.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(FGS*2.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n\n    return d;\n}\n\nfloat char5(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(-FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char6(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(0.,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char7(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p,vec2(FS,FGS));\n    \n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    p = prevP;\n\n    \n    d2 = B(p-vec2(0., FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char8(vec2 p) {\n    vec2 prevP = p;\n    \n    p.y = abs(p.y);\n    float d = B(p-vec2(0., FGS*4.),vec2(FS,FGS));\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char9(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    \n    p = prevP;\n    float d2 = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(-FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p =prevP;    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char0(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    \n    float d2 = B(p-vec2(-FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(0.0,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(FGS*2.,FGS*2.);\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p =prevP;  \n    d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat drawFont(vec2 p, int char){\n    float d = char0(p)*checkChar(char_0,char);\n    d += char1(p)*checkChar(char_1,char);\n    d += char2(p)*checkChar(char_2,char);\n    d += char3(p)*checkChar(char_3,char);\n    d += char4(p)*checkChar(char_4,char);\n    d += char5(p)*checkChar(char_5,char);\n    d += char6(p)*checkChar(char_6,char);\n    d += char7(p)*checkChar(char_7,char);\n    d += char8(p)*checkChar(char_8,char);\n    d += char9(p)*checkChar(char_9,char);\n    d += charA(p)*checkChar(char_A,char);\n    d += charB(p)*checkChar(char_B,char);\n    d += charC(p)*checkChar(char_C,char);\n    d += charD(p)*checkChar(char_D,char);\n    d += charE(p)*checkChar(char_E,char);\n    d += charF(p)*checkChar(char_F,char);\n    d += charG(p)*checkChar(char_G,char);\n    d += charH(p)*checkChar(char_H,char);\n    d += charI(p)*checkChar(char_I,char);\n    d += charJ(p)*checkChar(char_J,char);\n    d += charK(p)*checkChar(char_K,char);\n    d += charL(p)*checkChar(char_L,char);\n    d += charM(p)*checkChar(char_M,char);\n    d += charN(p)*checkChar(char_N,char);\n    d += charO(p)*checkChar(char_O,char);\n    d += charP(p)*checkChar(char_P,char);\n    d += charQ(p)*checkChar(char_Q,char);\n    d += charR(p)*checkChar(char_R,char);\n    d += charS(p)*checkChar(char_S,char);\n    d += charT(p)*checkChar(char_T,char);\n    d += charU(p)*checkChar(char_U,char);\n    d += charV(p)*checkChar(char_V,char);\n    d += charW(p)*checkChar(char_W,char);\n    d += charX(p)*checkChar(char_X,char);\n    d += charY(p)*checkChar(char_Y,char);\n    d += charZ(p)*checkChar(char_Z,char);\n    \n    float a = radians(45.);\n    p = abs(p)-0.37;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    #ifdef OUTLINE\n        return abs(d)-0.01;\n    #endif\n    \n    return d;\n}\n\nfloat dSlopeLines(vec2 p){\n    float lineSize = 24.;\n    float d = tan((mix(p.x,p.y,0.7)+(-iTime*1.5/lineSize))*lineSize)*lineSize;\n    return d;\n}\n\nfloat blocks(vec2 p){\n    vec2 prevP = p;\n    \n    p.x = mod(p.x,0.24)-0.12;\n    float d = B(p, vec2(FGS*0.55));\n    p = prevP;\n    p.x+=0.12;\n    p.x = mod(p.x,0.24)-0.12;\n    p.y = abs(p.y)-0.12;\n    float d2 = B(p, vec2(FGS*0.55));\n    return min(d,d2);\n}\n\nfloat blocks2(vec2 p){\n    p.y = mod(p.y,0.92)-0.46;\n    vec2 prevP = p;\n    p.y-=FGS*2.5;\n    float d = abs(B(p,vec2(FGS*1.7)))-0.03;\n    float d2 = B(p,vec2(FGS*0.5));\n    d = min(d,d2);\n    p = prevP;\n    p.y-=-FGS*2.5;\n    d2 = abs(B(p,vec2(FGS)))-0.03;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat drawFonts4GridsSpace(int char, float scale, vec2 grd, vec2 prevGrd, vec2 pa, vec2 pb, vec2 pc, vec2 pd){\n    grd-=pa;\n    grd*=scale;\n\n    float d = drawFont(grd,char);\n    grd = prevGrd;\n\n    grd -=pb;\n    grd*=scale;\n    float d2 = drawFont(grd,(char+1>=35)?10:char+1);\n    d = min(d,d2);\n    grd = prevGrd;\n\n    grd -=pc;\n    grd*=scale;\n    d2 = drawFont(grd,(char+2>=35)?10:char+2);\n    d = min(d,d2);\n    grd = prevGrd;\n\n    grd -=pd;\n    grd*=scale;\n    d2 = drawFont(grd,(char+3>=35)?10:char+3);\n    d = min(d,d2);\n    return d;\n}\n\nfloat gridSystem(vec2 p){\n    vec2 prevP = p;\n    p*=3.;\n    p.y+=iTime*0.5;\n    vec2 id = floor(p);\n    vec2 grd = fract(p)-0.5;\n    \n    float n = random(id);\n    float nChar = random(id)*35.0;\n    int char = int(nChar);\n    float d = drawFont(grd,char);\n    if(n>=0.1 && n<0.2 && char < 10){\n        int num = int(mod(iTime*float(nChar),10.0));\n        d = drawFont(grd,num);\n    }\n    \n    float d2 = 10.;\n    \n    vec2 prevGrd = grd;\n    float scale = 2.1;\n    if(n>=0.2 && n<0.5){\n    \n        float frame = mod(iTime,10.0);\n        float time = frame;\n\n        vec2 pa = vec2(-0.24,0.24);\n        vec2 pb = vec2(-0.24,-0.24);\n        vec2 pc = vec2(0.24,-0.24);\n        vec2 pd = vec2(0.24,0.24);\n        if(frame>=1. && frame<3.){\n            time = getTime(time-1.,0.6);\n            float val = cubicInOut(time)*0.48;\n            pa = vec2(-0.24,0.24-val);\n            pb = vec2(-0.24+val,-0.24);\n            pc = vec2(0.24,-0.24+val);\n            pd = vec2(0.24-val,0.24);\n        } else if(frame>=3. && frame<5.){\n            time = getTime(time-3.,0.6);\n            float val = cubicInOut(time)*0.48;\n            pa = vec2(-0.24+val,-0.24);\n            pb = vec2(0.24,-0.24+val);\n            pc = vec2(0.24-val,0.24);\n            pd = vec2(-0.24,0.24-val);\n        } else if(frame>=5. && frame<7.){\n            time = getTime(time-5.,0.6);\n            float val = cubicInOut(time)*0.48;\n            pa = vec2(0.24,-0.24+val);\n            pb = vec2(0.24-val,0.24);\n            pc = vec2(-0.24,0.24-val);\n            pd = vec2(-0.24+val,-0.24);\n        } else if(frame>=7. && frame<10.){\n            time = getTime(time-7.,0.6);\n            float val = cubicInOut(time)*0.48;\n            pa = vec2(0.24-val,0.24);\n            pb = vec2(-0.24,0.24-val);\n            pc = vec2(-0.24+val,-0.24);\n            pd = vec2(0.24,-0.24+val);\n        }\n        \n        d = drawFonts4GridsSpace(char, scale, grd, prevGrd, pa, pb, pc, pd);\n        \n    } else if(n>=0.5 && n<0.6){\n        // up\n        grd-=vec2(-0.24,0.24);\n        grd*=scale;\n        d = drawFont(grd,char);\n        grd = prevGrd;\n        \n        grd -= vec2(0.24,0.24);\n        grd*=scale;\n        d2 = drawFont(grd,(char+1>=35)?10:char+1);\n        d = min(d,d2);\n        grd = prevGrd;\n        \n        float d3 = B(grd-vec2(0.,-0.24),vec2(0.46,0.22));\n        \n        float dir = (n>=0.55)?-1.:1.;\n        grd.x*=dir;\n        grd.x+=iTime*n*0.5;\n        grd.x = mod(grd.x,0.2)-0.1;\n        grd.x+=0.1;\n        grd-=vec2(0.,-0.24);\n        grd*=Rot(radians(-90.));\n        \n        d2 = Tri(grd,vec2(FGS*2.),radians(45.));\n        float mask = Tri(grd-vec2(0.0,-FGS),vec2(FGS*2.),radians(45.));\n        d2 = max(-mask,d2);\n        d2 = max(d3,d2);\n        d2 = min(d2,abs(d3)-0.01);\n        d = min(d,d2);\n        \n    } else if(n>=0.7 && n<0.8){\n        // down\n        grd-=vec2(-0.24,-0.24);\n        grd*=scale;\n        d = drawFont(grd,char);\n        grd = prevGrd;\n        \n        grd -= vec2(0.24,-0.24);\n        grd*=scale;\n        d2 = drawFont(grd,(char+1>=35)?10:char+1);\n        d = min(d,d2);\n        grd = prevGrd;        \n        \n        float d3 = B(grd-vec2(0.,0.24),vec2(0.46,0.22));\n        \n        float dir = (n>=0.75)?-1.:1.;\n        grd.x += dir*iTime*0.2;\n        d2 = blocks(grd-vec2(0.,0.24));\n        d2 = max(d3,d2);\n        d2 = min(d2,abs(d3)-0.01);\n        d = min(d,d2);\n    } else if(n>=0.8 && n<0.9){\n        // left\n        grd-=vec2(-0.24,0.24);\n        grd*=scale;\n        d = drawFont(grd,char);\n        grd = prevGrd;        \n        \n        grd -= vec2(-0.24,-0.24);\n        grd*=scale;\n        d2 = drawFont(grd,(char+1>=35)?10:char+1);\n        d = min(d,d2);\n        grd = prevGrd;     \n        \n        \n        float d3 = B(grd-vec2(0.24,0.0),vec2(0.22,0.46));\n        \n        grd-=vec2(0.24,0.0);\n        d2 = dSlopeLines(grd);\n        d2 = max(d3,d2);\n        d2 = min(d2,abs(d3)-0.01);\n        d = min(d,d2);\n    } else if(n>=0.9 && n<1.){\n        // right\n        grd-=vec2(0.24,0.24);\n        grd*=scale;\n        d = drawFont(grd,char);\n        grd = prevGrd;            \n        \n        grd -= vec2(0.24,-0.24);\n        grd*=scale;\n        d2 = drawFont(grd,(char+1>=35)?10:char+1);\n        d = min(d,d2);\n        grd = prevGrd;   \n        \n        float d3 = B(grd-vec2(-0.24,0.0),vec2(0.22,0.46));\n        \n        float dir = (n>=0.95)?-1.:1.;\n        grd.y += dir*iTime*0.2;\n        d2 = blocks2(grd-vec2(-0.24,0.0));\n        d2 = max(d3,d2);\n        d2 = min(d2,abs(d3)-0.01);\n        \n        d = min(d,d2);\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col =vec3(0.0);\n\n    float d = gridSystem(p);\n\n    col = mix(col,vec3(1.),S(d,0.0));\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1226, 1226, 1249, 1249, 1322], [1324, 1324, 1344, 1344, 1566], [1568, 1568, 1589, 1589, 1986], [1988, 1988, 2009, 2009, 2383], [2385, 2385, 2405, 2405, 2645], [2647, 2647, 2668, 2668, 2791], [2793, 2793, 2814, 2814, 3149], [3151, 3151, 3172, 3172, 3387], [3389, 3389, 3410, 3410, 3738], [3740, 3740, 3761, 3761, 3981], [3983, 3983, 4004, 4004, 4366], [4368, 4368, 4389, 4389, 4697], [4699, 4699, 4720, 4720, 5030], [5032, 5032, 5053, 5053, 5284], [5286, 5286, 5307, 5307, 5653], [5655, 5655, 5676, 5676, 6268], [6270, 6270, 6291, 6291, 6593], [6595, 6595, 6616, 6616, 6799], [6801, 6801, 6822, 6822, 7293], [7295, 7295, 7316, 7316, 7792], [7794, 7794, 7815, 7815, 7998], [8000, 8000, 8021, 8021, 8211], [8213, 8213, 8234, 8234, 8418], [8420, 8420, 8441, 8441, 8808], [8810, 8810, 8831, 8831, 9167], [9169, 9169, 9190, 9190, 9513], [9515, 9515, 9536, 9536, 9909], [9911, 9911, 9932, 9932, 10159], [10161, 10161, 10182, 10182, 10745], [10747, 10747, 10768, 10768, 11198], [11200, 11200, 11221, 11221, 11465], [11467, 11467, 11488, 11488, 11922], [11924, 11924, 11945, 11945, 12398], [12400, 12400, 12421, 12421, 12678], [12680, 12680, 12701, 12701, 13018], [13020, 13020, 13041, 13041, 13607], [13609, 13609, 13630, 13630, 14079], [14081, 14081, 14123, 14123, 14183], [14185, 14185, 14218, 14218, 15916], [15918, 15918, 15944, 15944, 16065], [16067, 16067, 16088, 16088, 16325], [16327, 16327, 16349, 16349, 16624], [16626, 16626, 16653, 16653, 16737], [16739, 16739, 16778, 16778, 16823], [21940, 21940, 21997, 21997, 22191]], "test": "untested"}
{"id": "mdlXDS", "name": "Fractal mountain terrain", "author": "jarble", "description": "A simple fractal terrain using triangle waves.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "alps", "mountain", "erosion"], "likes": 13, "viewed": 390, "published": 3, "date": "1669515162", "time_retrieved": "2024-07-30T16:16:45.878286", "image_code": "//based on\n//https://www.shadertoy.com/view/3dXcW2\n\n#define SC (250.0)\n\nvec2 triwave(vec2 uv){\n    return\n        abs(fract(uv)-.5)\n        //max(abs(fract(uv)-.5),abs(fract(uv.yx+.5)-.5))\n    ;\n}\n\n#define OCTAVES 8\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.,\n    value1=value,\n    amplitude = 2.;\n    uv /= 32./4.;\n    vec2 t1 = vec2(0.);\n    mat2 r = rotate2D(12.);\n    vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //t1 *= rotate2D((t1.x+t1.y));\n        t1 =\n            //(triwave(uv-triwave(uv1*r/2.15))-t1.yx)\n            triwave(uv)\n            //(triwave(uv1-triwave(uv*r))-t1.yx)\n            //(triwave(uv/2.15-triwave(uv1*r))-t1.yx)\n        ;\n        value1=sqrt(value1*value1+value*value+.01);\n        value = abs(abs(t1.x-t1.y) * amplitude-value);\n        amplitude /= 2.15;\n        uv1 = uv;\n        uv = (uv.yx*2.15 + t1)*r;\n    }\n    \n    return value1;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    \n    //vec2 prev = vec2(0.);\n    //float t_prev = 0.;\n    \n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n        float f1 = f(pos,OCTAVES);\n\t\tfloat h = pos.y - f1;\n        //if(prev.y < h && prev.y < prev.x)\n        //return t_prev;\n        //prev = vec2(prev.y,h);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n        //t_prev = t;\n        \n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iTime/8.-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlXDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 94, 94, 196], [217, 217, 241, 241, 293], [295, 295, 330, 379, 1033], [1035, 1035, 1057, 1057, 1087], [1089, 1089, 1119, 1119, 1169], [1171, 1171, 1191, 1191, 1238], [1240, 1240, 1273, 1273, 1467], [1469, 1469, 1536, 1536, 1973], [2347, 2347, 2399, 2399, 2944], [2946, 2946, 2997, 2997, 3198], [3200, 3200, 3226, 3226, 3302], [3370, 3370, 3427, 3427, 5400]], "test": "untested"}
{"id": "DdlSDB", "name": "Separable Scharr Filter", "author": "CaffeinePwrdAl", "description": "Example of a 3x3 separable Scharr filter for edge detection. A gaussian blur applied first significantly improves the result for noisy input. At the end I apply a threshold to reduce unwanted edges. Works nice with 'Google Logo' or Webcam input.", "tags": ["sobel", "webcam", "scharr", "separablefilter"], "likes": 10, "viewed": 603, "published": 3, "date": "1669514859", "time_retrieved": "2024-07-30T16:16:46.817774", "image_code": "float luminance(in vec3 colour)\n{\n    const vec3 srgb_factors = vec3(0.2126, 0.7152, 0.0722);\n    return dot(srgb_factors, colour);\n}\n\n//#define THRESHOLD_SCALE_BIAS\n//#define THRESHOLD_CUT\n#define THRESHOLD_SMOOTHSTEP\n\n#if defined (THRESHOLD_SCALE_BIAS)\nvec2 threshold(in float threshold, in float colour)\n{\n    float upper = (colour - threshold) * (1.0 / (1.0 - threshold));\n    //float lower = -min(0.0, (colour - threshold)) * (1.0 / threshold);\n    float lower = colour - upper;\n    return vec2(clamp(upper, 0.0, 1.0), lower);\n}\n#elif defined(THRESHOLD_CUT)\nvec2 threshold(in float threshold, in float colour)\n{\n    float upper = (colour < threshold)?(0.0):(colour);\n    float lower = (colour < threshold)?(colour):(0.0);\n    return vec2(upper, lower );\n}\n#elif defined (THRESHOLD_SMOOTHSTEP)\nvec2 threshold(in float threshold, in float colour)\n{\n    float upper = smoothstep(0.0, 1.0 - threshold, colour - threshold);\n    float lower = colour - upper;\n    return vec2(upper, lower);\n}\n#endif\n\nvec3 apply_filter_result(vec3 rgb, float filter_result)\n{\n    if (mod(iTime, 10.0) < 5.0)\n    {\n        return rgb * (1.0 - filter_result);\n    }\n    else\n    {\n        return vec3(1.0 - filter_result);\n    }\n}\n\n/*\n// Cycle between full screen application of the effect and a set of\n// animating bands showing different aspects of the filter and the\n// effect of applying the threshold\n*/\nbool showFullScreenEffect()\n{\n    //return true;\n    return mod(iTime, 20.0) > 10.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    vec4 filter_result = texelFetch(iChannel0, coord, 0).rgba;\n    \n    vec3 colour = filter_result.rgb;\n    float scharr = filter_result.a;\n    \n    /*\n    // Threshold test to remove some of the finer edges.\n    // Cycle it over time to show the effect of variation\n    */\n    float thres_cycle = 0.5 + 0.3 * sin(iTime * 2.0);\n    vec2 thres = threshold(thres_cycle, scharr);\n    \n    if (showFullScreenEffect())\n    {\n        thres = threshold(0.6, scharr);\n        colour *= (1.0 - thres.r);\n    }\n    else\n    {\n        // Just some maths to draw the bars of different outputs\n        float res_l1 = iResolution.x + iResolution.y;\n        float wipe  = (res_l1 * 0.3) * cos(iTime * 0.5);\n        float bar_s = (res_l1 * 0.10);\n        float bar_m = (res_l1 * 0.50);\n        float bar_e = (res_l1 * 0.90);\n\n        float fragCoord_l1 = fragCoord.x + fragCoord.y;\n\n        if (fragCoord_l1 < bar_s + wipe)\n        {\n            // Original Image\n            colour = filter_result.rgb;\n        }\n        else if (fragCoord_l1 < bar_s + wipe + 4.0)\n        {\n            colour *= 0.5;\n        }\n        else if (fragCoord_l1 < bar_m + wipe)\n        {\n            // Edges that passed the threshold test\n            colour = apply_filter_result(colour, thres.r);       \n        }\n        else if (fragCoord_l1 < bar_m + wipe + 4.0)\n        {\n            colour *= 0.5;\n        }\n        else if (fragCoord_l1 < bar_e + wipe)\n        {\n            // Original Scharr Result\n            colour = apply_filter_result(colour, scharr);\n        }\n        else if (fragCoord_l1 < bar_e + wipe + 4.0)\n        {\n            colour *= 0.5;\n        }\n        else\n        {\n            // The edges below the threshold we're excluding\n            colour = apply_filter_result(colour, scharr - thres.r);\n        }\n    }\n    \n    fragColor.rgb = colour;\n    //fragColor.rgb = filter_result.aaa;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define USE_WEBCAM\n//#define USE_VIDEO\n#define USE_TEXTURE\n\n#if defined(USE_WEBCAM)\n#define CHANNEL_IDX 2\n#define SAMPLER iChannel2\n#elif defined (USE_VIDEO)\n#define CHANNEL_IDX 1\n#define SAMPLER iChannel1\n#else\n#define CHANNEL_IDX 0\n#define SAMPLER iChannel0\n#endif\n\n\n/*\n// Scale-to-fit whatever image/source I'm using, maintaining aspect ratio and covering the screen.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    \n    float aspect_screen = iResolution.x / iResolution.y;\n    float aspect_image = iChannelResolution[CHANNEL_IDX].x / iChannelResolution[CHANNEL_IDX].y;\n    \n    if (aspect_image > aspect_screen)\n    {\n        uv.x *= aspect_screen / aspect_image;\n    }\n    else\n    {\n        uv.y *= aspect_image / aspect_screen;\n    }\n    \n    uv += vec2(0.5);\n    \n    fragColor = texture(SAMPLER, uv).rgba;\n}\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n// Performs a separable gaussian blur on the input image\n*/\n\n#define SEPARABLE_9\n\n#if defined(SEPARABLE_15)\n#define TAPS 15\n#endif\n#if defined(SEPARABLE_9)\n#define TAPS 9\n#endif\n#if defined(SEPARABLE_5)\n#define TAPS 5\n#endif\n#if !defined(TAPS)\n#define TAPS 3\n#endif\n\n/*\n// Convert sRGB to Luminance\n*/\nfloat luminance(in vec3 colour)\n{\n    const vec3 srgb_factors = vec3(0.2126, 0.7152, 0.0722);\n    return dot(srgb_factors, colour);\n}\n\n/*\n// Can do this better, but this works for now while I work out how much of a\n// blur I want prior to the Scharr filter being applied. This is helpful on\n// noisier input.\n*/\nfloat WideSeparableL(ivec2 fragCoord, ivec2 delta, const float taps[TAPS/2+1])\n{\n\tfloat ret;\n\tivec2 coord = fragCoord - (TAPS/2) * delta;\n\n\tret = taps[0] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n\tret += taps[1] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 5)\n\tret += taps[2] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 7)\n\tret += taps[3] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 9)\n\tret += taps[4] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 11)\n\tret += taps[5] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 13)\n\tret += taps[6] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#if (TAPS >= 15)\n\tret += taps[7] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n\tret += taps[6] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[5] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[4] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[3] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[2] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[1] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\tcoord += delta;\n#endif\n\tret += taps[0] * luminance(texelFetch(iChannel0, coord, 0).rgb);\n\n\treturn ret;\n}\n\n\n/*\n// Chooses a set of gaussian filter taps based upon defines and passes\n// them to the separable filter function above\n*/\nfloat gaussian_filter_3x3(in ivec2 fragCoord)\n{\n#if defined (SEPARABLE_15)\n\tconst float taps[8] = float[](\n\t\t// Sig = 3.0\n\t\t//0.009033,\t0.018476,\t0.033851,\t0.055555,\t0.08167,\t0.107545,\t0.126854,\t0.134032\n        // Sig = 1.4\n\t\t0.000002,\t0.000041,\t0.000611,\t0.005556,\t0.030863,\t0.104916,\t0.218504,\t0.279015\n\t);\n#elif defined (SEPARABLE_9)\n\tconst float taps[5] = float[5](\n\t\t// Sigma = 3\n\t\t//0.063327, 0.093095, 0.122589, 0.144599, 0.152781\n\t\t// Sigma = 2\n\t\t0.028532, 0.067234, 0.12400, 0.179044, 0.20236\n\t\t// Sigma = 1.4\n\t\t//0.005563, 0.030904, 0.105053, 0.21879, 0.27938\n\t\t// Sigma = 1 -- Nice round shape, but almost too much falloff, makes the \n\t\t// outer taps of too low a value - especially in multi pass filtering\n\t\t//0.000229, 0.005977, 0.060598, 0.241732, 0.382928\n\t);\n#elif defined (SEPARABLE_5)\n    const float taps[3] = float[3](\n        // Sigma = 3\n        //0.1784, 0.210431, 0.222338\n        // Sigma = 2\n        0.153388, 0.221461, 0.250301\n        // Sigma = 1.4\n        //0.113318, 0.236003, 0.30136\n        // Sigma = 1\n        //0.06136, 0.24477, 0.38774\n        // NOP\n        //0.0, 0.0, 1.0\n    );\n#else /*defined (SEPARABLE_3)*/\n    const float taps[2] = float[2](\n        // Sigma = 3\n        //0.327162, 0.345675\n        // Sigma = 2\n        0.319466, 0.361069\n        // Sigma = 1.4\n        //0.305163, 0.389673\n        // Sigma = 1\n        //0.27901, 0.44198\n        // NOP\n        //0.0, 1.0\n    );\n#endif\n\n    float x = WideSeparableL(fragCoord, ivec2(1,0), taps);\n    float y = WideSeparableL(fragCoord, ivec2(0,1), taps);\n    \n    return 0.5 * (x + y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurred_luminance = gaussian_filter_3x3(ivec2(fragCoord));\n    vec3 original = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // Output original image colour and the blurred luminance\n    fragColor = vec4(original, blurred_luminance);\n    //fragColor = vec4(original, luminance(original));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Perform a separable scharr filter in X\nfloat scharr_x(in float texels[9])\n{ \n    const float weights[9] = float[](\n         -3.0,  0.0,   3.0,\n        -10.0,  0.0,  10.0,\n         -3.0,  0.0,   3.0\n    );\n    \n    float filtered = 0.0;\n    \n    for (int y = 0; y < 3; y++)\n    {\n        for (int x = 0; x < 3; x++)\n        {\n            int idx = y * 3 + x;\n            filtered += weights[idx] * texels[idx];\n        }\n    }\n    return filtered;\n}\n\n// Perform a separable scharr filter in Y\nfloat scharr_y(in float texels[9])\n{\n    const float weights[9] = float[](\n          3.0,  10.0,  3.0,\n          0.0,   0.0,  0.0,\n         -3.0, -10.0, -3.0\n    );\n    \n    float filtered = 0.0;\n    \n    for (int y = 0; y < 3; y++)\n    {\n        for (int x = 0; x < 3; x++)\n        {\n            int idx = y * 3 + x;\n            filtered += weights[idx] * texels[idx];\n        }\n    }\n    return filtered;\n}\n\n/*\n// Scharr Filter\n//\n// This is a specialisation of the 3x3 Sobel edge detection filter where\n// the filter kernel produces a nice rotationally consistent result.\n//\n// This implementation first samples the pool of 9 texels we need for the\n// filter, then runs our x and y separable filter kernels over them, \n// and combining them to give us our final gradient value\n*/\n#define USE_TEXEL_FETCH\n#if defined(USE_TEXEL_FETCH)\nfloat scharr_filter_3x3(in ivec2 fragCoord)\n{\n    float texels[9];\n    \n    // Little heuristic that seems to make the sampling behaviour consistent-ish\n    // across different screen resolutions. Originally I used texelFetch as I was\n    // just applying the filter at the source resolution, but when you stretch the\n    // image across the screen you change the response of the filter. Might be\n    // better to switch back to normal image sampling.\n    float offset = max(iResolution.x, iResolution.y) / 400.0;\n    offset = sqrt(offset);\n    \n    texels[0] = (texelFetch(iChannel0, fragCoord + ivec2(-offset, -offset), 0).a);\n    texels[1] = (texelFetch(iChannel0, fragCoord + ivec2(      0, -offset), 0).a);\n    texels[2] = (texelFetch(iChannel0, fragCoord + ivec2( offset, -offset), 0).a);\n    \n    texels[3] = (texelFetch(iChannel0, fragCoord + ivec2(-offset,  0), 0).a);\n    texels[4] = (texelFetch(iChannel0, fragCoord + ivec2(      0,  0), 0).a);\n    texels[5] = (texelFetch(iChannel0, fragCoord + ivec2( offset,  0), 0).a);\n    \n    texels[6] = (texelFetch(iChannel0, fragCoord + ivec2(-offset,  offset), 0).a);\n    texels[7] = (texelFetch(iChannel0, fragCoord + ivec2(      0,  offset), 0).a);\n    texels[8] = (texelFetch(iChannel0, fragCoord + ivec2( offset,  offset), 0).a);\n    \n    float x = scharr_x(texels);\n    float y = scharr_y(texels);\n    \n    //return abs(x) + abs(y);\n    return sqrt(x*x + y*y);\n}\n#else\nfloat scharr_filter_3x3(in ivec2 fragCoord)\n{\n    float texels[9];\n    \n    // Little heuristic that seems to make the sampling behaviour consistent-ish\n    // across different screen resolutions. Originally I used texelFetch as I was\n    // just applying the filter at the source resolution, but when you stretch the\n    // image across the screen you change the response of the filter. Might be\n    // better to switch back to normal image sampling.\n    float delta = sqrt(max(iResolution.x, iResolution.y) / 400.0);\n    delta = sqrt(delta);\n    \n    vec2 offset = vec2(delta);\n    vec2 uv = vec2(fragCoord) / iResolution.xy;\n    offset /= iResolution.xy;\n    \n    texels[0] = (texture(iChannel0, uv + vec2(-offset.x, -offset.y)).a);\n    texels[1] = (texture(iChannel0, uv + vec2(        0, -offset.y)).a);\n    texels[2] = (texture(iChannel0, uv + vec2( offset.x, -offset.y)).a);\n    \n    texels[3] = (texture(iChannel0, uv + vec2(-offset.x,  0)).a);\n    texels[4] = (texture(iChannel0, uv + vec2(        0,  0)).a);\n    texels[5] = (texture(iChannel0, uv + vec2( offset.x,  0)).a);\n    \n    texels[6] = (texture(iChannel0, uv + vec2(-offset.x,  offset.y)).a);\n    texels[7] = (texture(iChannel0, uv + vec2(        0,  offset.y)).a);\n    texels[8] = (texture(iChannel0, uv + vec2( offset.x,  offset.y)).a);\n    \n    float x = scharr_x(texels);\n    float y = scharr_y(texels);\n    \n    //return abs(x) + abs(y);\n    return sqrt(x*x + y*y);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scharr = scharr_filter_3x3(ivec2(fragCoord));  \n    vec4 original = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n\n    // Store the original image, and the scharr filter result\n    fragColor = vec4(original.rgb, scharr);\n    //fragColor = vec4(original);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 133], [999, 999, 1056, 1056, 1209], [1211, 1388, 1417, 1436, 1474], [1476, 1476, 1533, 1533, 3455]], "test": "untested"}
{"id": "dslSDS", "name": "interlaced 704i", "author": "jonasfrey", "description": "my understanding of interlaced after watching captain disillusions video https://www.youtube.com/watch?v=5eu_KjKsnpM&ab_channel=CaptainDisillusion", "tags": ["interlaced", "webcam", "interlacing", "theiinthe1080i"], "likes": 2, "viewed": 439, "published": 3, "date": "1669511847", "time_retrieved": "2024-07-30T16:16:47.582729", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trpino = fragCoord/iResolution.xy;\n    float n_scanlines = 66.;\n    //n_scanlines = iResolution.y/2.;\n    vec2 o_subdivs = vec2(1.,n_scanlines);\n    vec2 o_trpi_big = o_trpino * o_subdivs;\n    vec2 o_trpi_big_fract = fract(o_trpi_big);\n    vec4 o_col = texture(iChannel0, o_trpino);\n    if(o_trpi_big_fract.y > (1./2.)){\n        o_col = texture(iChannel0, o_trpino);\n        \n    }else{\n        o_col = texture(iChannel1, o_trpino);\n    \n    }\n    // Output to screen\n    fragColor = o_col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trpino = fragCoord/iResolution.xy;\n    \n\n    \n    float fps = 10.0; \n    \n    fragColor = texture(iChannel0, o_trpino);\n    if(mod(float(iFrame), 60.0 / fps) == 0.0){\n   \n        vec4 o_col_webcam = texture(iChannel1, o_trpino);\n        vec4 o_col = texture(iChannel2, o_trpino);\n        // Output to screen\n        fragColor = o_col;\n    }\n    \n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = fragCoord/iResolution.xy;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, o_trpino);\n    \n\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = fragCoord/iResolution.xy;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float fps = 5.0; \n    \n    fragColor = texture(iChannel0, o_trpino);\n    if(mod(float(iFrame), 60.0 / fps) == 0.0){\n\n        vec4 o_col = texture(iChannel1, o_trpino);\n        // Output to screen\n        fragColor = o_col;\n    }\n    \n    \n\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 611]], "test": "untested"}
{"id": "ddsXRf", "name": "Sliding Tiles II", "author": "mla", "description": "Tiles sliding in spiral paths in two directions on a sphere. Default is interior view. Mouse rotates, for other controls, see code header. ", "tags": ["tiles", "sliding"], "likes": 29, "viewed": 407, "published": 3, "date": "1669494774", "time_retrieved": "2024-07-30T16:16:50.942746", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Sliding Tiles II, mla 2022\n//\n// Tiles sliding in spiral paths in two directions on a sphere. Default view\n// is from just inside the sphere, so is a stereographic projection. Alternative\n// views are from the centre and from an external location.\n//\n// <mouse>: rotate view\n// 'a': MSAA\n// 'g': show grid\n// 'h': grid thickness\n// 'f': show flat tiling\n// 'r': autorotation\n// 'c': show centre view\n// 'e': show external view\n// 'l': London view\n// 's': alternate tile orientation\n// 't': tile coloring\n//\n////////////////////////////////////////////////////////////////////////////////\n\nivec2 getindex(int t, vec2 uv) {\n  assert(t >= 0);\n  // Calculate which tile appears at point uv at time t.\n  // Other patterns should be possible.\n  ivec2 ix = ivec2(floor(uv));\n  if (odd(ix.x) && odd(ix.y)) return ix; // Stationary tiles\n  ix -= t/6*2; // Tiles move 2 every 6 cycles\n  t %= 6;\n  for ( ; t != 0; t--) {\n    // A neat recurrence. Maybe this could be simplified.\n    if (even(t)) {\n      if (even(ix.x)) ix.y--;\n    } else {\n      if (even(ix.y)) ix.x--;\n    }\n  }\n  return ix;\n}\n\nvec3 slider(vec2 uv, mat2 dxdy) {\n  //uv.x = mod(uv.x+1.0,2.0)-1.0; // Sanity check - should have no effect\n  //uv *= 3.0; // Zoom out\n  float theta = -PI/4.0;\n  uv = rotate(uv,theta);\n  uv *= sqrt(2.0), dxdy *= sqrt(2.0);\n  int N = 5;\n  float scale = float(N);\n  uv *= scale; dxdy *= scale;\n  float t = 0.5*max(0.0,iTime-1.0); // 1 second delay before moving\n  int cycle = int(t);\n  t = smoothstep(0.0,1.0,fract(t));\n  // Move those tiles\n  if (even(cycle)) {\n    if (mod(uv.y,2.0) < 1.0) {\n      uv.x -= t;\n    }\n  } else {\n    if (mod(uv.x,2.0) < 1.0) {\n      uv.y -= t;\n    }\n  }\n  ivec2 ix = getindex(cycle, uv);\n  ix -= N; // Image boundary to 0,0\n  // This has the effect of horizontal periodicity, but not vertical. \n  int k = idiv(ix.x,10);\n  ix.x -= 2*N*k; //\n  ix.y += 2*N*k;\n  ix += N; // Image centre to 0,0\n\n  // Now fetch the texture\n  float tscale = 0.5/scale;\n  vec2 tuv = tscale*(vec2(ix)+fract(uv));\n  tuv += 0.5;\n  vec3 col = vec3(1);\n  if (!key(CHAR_S) && ((ix.x+ix.y)&1) == 1) tuv = tuv.yx;\n  \n  vec2 dx = tscale*dxdy[0], dy = tscale*dxdy[1];\n  col = key(CHAR_L) ? textureGrad(iChannel0,tuv,dx,dy).rgb :\n                      textureGrad(iChannel1,tuv,dx,dy).rgb;\n  //col = texture(iChannel0,tuv).rgb; // See those artefacts!\n  col = pow(col,vec3(2.2));\n  col = 1.2*col;\n  uint h = ihash(uint(ix.y*1024+ix.x));\n  if (!key(CHAR_T)) col *= 0.2+0.8*h2rgb(float(h)/exp2(32.0));\n  if (key(CHAR_G)) {\n    // Draw grid\n    float px = length(dxdy[0]); // ?!\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    float d = min(uv.x,uv.y);\n    float gwidth = !key(CHAR_H) ? 0.0 : 0.015;\n    col = mix(vec3(0),col,smoothstep(0.0,px,d-gwidth));\n  }\n  col = 2.0*col/(1.0+col);\n  return col;\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord ) {\n  // Flat image\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = slider(uv,mat2(dFdx(uv),dFdy(uv)));\n  col = pow(col,vec3(0.4545));\n  if (abs(uv.x) > 1.0) col *= 0.8; //Show central region\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}\n\nvec3 getColor(vec3 p) {\n  float x = atan(p.x,p.z);       // Longitude\n  float y = asin(p.y/length(p)); // Latitude\n  y = log(tan(0.25*PI+0.5*y));   // Mercator\n  vec2 uv = vec2(x,y)/PI;\n  // mipmap shenanigans, each of dxdy, dxdy1 have\n  // discontinuities, but at different places,\n  // so choose the best one.\n  vec2 uv1 = vec2(mod(uv.x,2.0),uv.y);\n  mat2 dxdy = mat2(dFdx(uv),dFdy(uv));\n  mat2 dxdy1 = mat2(dFdx(uv1),dFdy(uv1));\n  if (abs(uv.x) > 0.5) dxdy = dxdy1;\n  float scale = 2.0;\n  return slider(scale*uv,scale*dxdy);\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t <= 0.001) t = t1;\n  if (t <= 0.001) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  Sphere s = Sphere(1.0, vec3(0));\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec3(0);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n = -n;\n    vec3 basecolor = getColor(hit.n);\n    vec3 color = basecolor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),10.0);\n    vec3 speccolor = vec3(1);\n    color += 0.25*specular*speccolor;\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return color;\n  }\n}\n\nvec3 transform0(vec3 p) {\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  return transform0(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (key(CHAR_F)) { mainImage0(fragColor,fragCoord); return; }\n  float camera = 1.0, fov = 1.0;\n  if (key(CHAR_C)) {\n    camera = 0.0;\n  } else if (key(CHAR_E)) {\n    camera = 3.0;\n    fov = 2.0;\n  }\n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  light = vec3(0.25,camera > 1.0 ? 1.0 : -1.0,-0.25);\n  light = transform0(light);\n  light = normalize(light);\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec3 col = vec3(0);\n  float AA = 1.0;\n  if (key(CHAR_A)) AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,fov);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      col += solve(Ray(p,r));\n    }\n  }\n  col /= AA*AA;\n  col *= 2.0/(1.0+col);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.14159;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nbool even(int n) { return (n&1) == 0; }\nbool odd(int n) { return !even(n); }\n\nint idiv(int a,int b) {\n  return a >= 0 ? a/b : -((-a+b-1)/b); // Careful with bracket here!\n}\n\nint imod(int a, int b) {\n  return a-b*idiv(a,b);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = smoothstep(0.0,1.0,rgb);\n  return rgb;\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\nconst int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\n// const int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 676, 708, 708, 1171], [1173, 1173, 1206, 1307, 2869], [2871, 2871, 2929, 2945, 3197], [3199, 3199, 3222, 3222, 3728], [3972, 3972, 4026, 4026, 4517], [4519, 4519, 4560, 4560, 4668], [4713, 4713, 4732, 4732, 5180], [5182, 5182, 5207, 5207, 5323], [5325, 5325, 5352, 5352, 5597], [5599, 5599, 5656, 5656, 6554]], "test": "untested"}
{"id": "DsXSzf", "name": "Rotational Symmetry SDF", "author": "mla", "description": "Exact distance to a 2D rotationally symmetric object. The pattern shouldn't extend beyond the adjacent segments, and should join up smoothly between segments, or overlaps won't be correct. Mouse sets some parameters, see code for other controls.", "tags": ["sdf", "rotation", "polygon", "asymmetric"], "likes": 16, "viewed": 262, "published": 3, "date": "1669473833", "time_retrieved": "2024-07-30T16:16:51.925119", "image_code": "//////////////////////////////////////////////////////////////////\n//\n// Rotational Symmetry SDF, mla, 2022\n// Exact distance to a shape with purely rotational symmetries.\n// Fold down to a fundamental region, but unlike the dihedral case\n// we need to take account of adjacent regions to correctly\n// compute the SDF, though we only need to check the adjacent\n// half regions, so drawing 2 region's worth in total.\n\n// Here we also draw a non-convex polygon, using winding number\n// to find the interior.\n//\n// <mouse>: set rotation and pattern parameter\n// 'r': autorotation\n// 's': skip the folding step\n// 'x': show fundamental region boundaries\n//\n//////////////////////////////////////////////////////////////////\n\nint wind = 0;\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  // Conveniently, this works by shooting out a ray to right, which\n  // handily fits in with our fundamental region construction\n  // which also makes the region face out to the right.\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  polywind(p,q,r);\n  p -= r; q -= r;\n  float k = dot(p,q)/dot(q,q);\n  k = clamp(k,0.0,1.0);\n  return distance(p,k*q);\n}\n\nfloat ray(vec2 p, vec2 r, vec2 q) {\n  p -= r; q -= r;\n  float k = dot(p,q)/dot(q,q);\n  k = max(k,0.0);\n  return distance(p,k*q);\n}\n\nfloat polydist(float N, vec2 p) {\n    float k = PI/N;\n    float s = cos(k), t = sin(k);\n    float theta = atan(p.y,p.x);\n    if (!key(CHAR_S)) theta = mod(theta+k,2.0*k)-k; \n    // The nearest point in the pattern could be in either of the\n    // two nearest segments, so need to check them both.\n    float r = 0.5*sin(0.5*iTime)+1.0;\n    if (iMouse.x > 0.0) r = 2.0*iMouse.y/iResolution.y;\n    p = length(p)*vec2(cos(theta),sin(theta));\n    vec2 q3 = vec2(r,0);\n    vec2 q0 = rotate(2.0*k)*q3;\n    vec2 q6 = rotate(-2.0*k)*q3;\n    vec2 q1 = vec2(0.75,0);\n    vec2 q4 = rotate(-2.0*k)*q1;\n    vec2 q2 = 0.4*q0;\n    vec2 q5 = 0.4*q3;\n    float d = 1e8;\n    d = min(d,segment(p,q0,q1));\n    d = min(d,segment(p,q1,q2));\n    d = min(d,segment(p,q2,q3));\n    d = min(d,segment(p,q3,q4));\n    d = min(d,segment(p,q4,q5));\n    d = min(d,segment(p,q5,q6));\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 1.1*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    if (!key(CHAR_R)) p *= rotate(-0.2*iTime);\n    float N = 5.0;\n    if (iMouse.x > 0.0) N = floor(10.0*iMouse.x/iResolution.x)+3.0;\n    float d = polydist(N,p);\n    float px = fwidth(p.x);\n    vec3 col = vec3(0.75+0.25*cos(20.0*PI*d));\n    if ((wind&1) != 0) col.b = 0.0;\n    col = mix(vec3(1,0,0),col,vec3(smoothstep(0.0,px,d-0.005)));\n    if (key(CHAR_X)) {\n      float d = 1e8;\n      d = min(d,ray(p,vec2(0),vec2(cos(PI/N),sin(PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(cos(PI/N),-sin(PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(cos(2.0*PI/N),sin(2.0*PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(cos(2.0*PI/N),-sin(2.0*PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(1,0)));\n      col = mix(vec3(0),col,smoothstep(0.0,px,d-0.0025));\n    }\n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst float PI = 3.141592654;\nmat2 rotate(float t) { return mat2(cos(t),sin(t),-sin(t),cos(t)); }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[735, 735, 774, 995, 1180], [1182, 1182, 1221, 1221, 1341], [1343, 1343, 1378, 1378, 1473], [1475, 1475, 1508, 1508, 2340], [2342, 2342, 2394, 2394, 3272]], "test": "untested"}
{"id": "DsfXDB", "name": "HUDFillBar", "author": "Del", "description": "simple UI shader for showing audio volumes...\nhttps://www.twitch.tv/videos/1662202941", "tags": ["bars"], "likes": 2, "viewed": 244, "published": 3, "date": "1669457890", "time_retrieved": "2024-07-30T16:16:52.693066", "image_code": "// UI audio fill bar - https://www.twitch.tv/videos/1662202941\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy) / iResolution.xy; // uv0-1\n\n    vec4 backcol = vec4(0.1,0.1,0.1,1.0);\n    vec4 barcolempty = vec4(0.2,0.2,0.2,1.0);\n    vec4 barcolfull = vec4(0.8,0.8,0.2,1.0);\n\n    float nseg = 10.0;\n    \n    float fill = fract(iTime*0.3)*(nseg+1.0);\n    //float fill = 5.;     // 0-10\n    fill = clamp(fill-1.0,0.0,nseg);\n    \n    float sx = 0.4;\n   \tfloat sy = 0.4;\n    \n\tuv.y -= 0.5;\n    \n    float c = (floor(uv.x*(nseg)));\n\tuv.x = mod(uv.x, 1.0/nseg)-(0.5/nseg);\n\tfloat r = length(max(abs(uv) - vec2(sx/nseg,sy),0.0));\n    \n    float b = 1.0/iResolution.y; // 0.005\n    \n\tr = smoothstep(b,0.0,r);\n    \n    vec4 col = (fill<=c) ?  barcolempty : barcolfull;\n\tfragColor = mix(backcol,col,r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 121, 121, 831]], "test": "untested"}
{"id": "csXXWB", "name": "Glitched Pixel Sorting", "author": "MysteryPancake", "description": "The sand walls consume you", "tags": ["video", "pixel", "glitch", "sort", "sorting", "sand"], "likes": 9, "viewed": 377, "published": 3, "date": "1669444460", "time_retrieved": "2024-07-30T16:16:53.534815", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame < 1) {\n        // Initialize color to blue\n        fragColor = vec4(0.1, 0.1, 0.2, 0.0);\n    } else {\n        // Use video color when above color key threshold\n        vec4 vid = texture(iChannel1, fragCoord / iResolution.xy);\n        ivec2 pos = ivec2(fragCoord);\n        if (distance(vid.rgb, vec3(0.0, 1.0, 0.0)) > 0.8) {\n            fragColor = vid;\n        } else {\n            // Oscillate background for extra movement\n            fragColor = texelFetch(iChannel0, pos + ivec2(0, sin(iTime * 4.0) * 8.0), 0);\n            // Force extra sorting\n            fragColor.rgb -= 0.01;\n        }\n        \n        // Compare pixels in pairs, sliding window along 1 pixel per frame\n        bool sampleTop = pos.x % 2 == iFrame % 2;\n        \n        // Move brighter pixels more than darker ones\n        int jump = max(0, 2 * int(fragColor.r * 256.0)) + 1;\n        ivec2 offset = pos + ivec2(sampleTop ? jump : -jump, 0);\n        \n        // Don't read out of bounds pixels\n        ivec2 dims = textureSize(iChannel0, 0);\n        if (offset.x < 0 || offset.x >= dims.x || offset.y < 0 || offset.y >= dims.y) {\n            return;\n        }\n        \n        // Compare red channel and alpha to know whether we need to swap\n        vec4 neighbour = texelFetch(iChannel0, offset, 0);\n        if (fragColor.a <= 0.0 || length(fragColor.rgb) < length(neighbour.rgb) == sampleTop) {\n            fragColor = neighbour;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXXWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 136]], "test": "untested"}
{"id": "7dVcDR", "name": "SDF boxes", "author": "Zyphery", "description": "signed distance fields", "tags": ["sdf"], "likes": 0, "viewed": 109, "published": 3, "date": "1669438908", "time_retrieved": "2024-07-30T16:16:54.311738", "image_code": "float distToBox(vec2 pos, float rotation, vec2 size, vec2 uv) {\n    float cr = cos(rotation);\n    float sr = sin(rotation);\n    \n    uv -= pos;\n    uv = vec2(uv.x * cr - uv.y * sr, uv.x * sr + uv.y * cr);\n    \n    vec2 q = abs(uv) - size;\n    return length(max(q,0.0f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n    // Time varying pixel color\n    vec3 col;\n    \n    float b0 = distToBox(iMouse.xy, iTime * 0.5, vec2(200,80), uv);\n    float b1 = distToBox(vec2(50,100), iTime * 0.25, vec2(50,100), uv);\n    //float b1 = distToBox(vec2(50,100), iTime / 2.0, vec2(10,50), uv);\n    \n    col = vec3(min(sin(0.1 * b0), sin(0.1 * b1)));\n    //col = vec3(sin(0.1 * b0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVcDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 272], [274, 274, 331, 381, 817]], "test": "untested"}
{"id": "st3yz2", "name": "Anti-Aliased Circle sample", "author": "Zyphery", "description": "Anti-Aliased circle, just a sample", "tags": ["aliasing"], "likes": 0, "viewed": 107, "published": 3, "date": "1669438853", "time_retrieved": "2024-07-30T16:16:55.241253", "image_code": "bool Sample(uvec2 UV, vec2 subUV, float AA) {\n    vec2 uv = (vec2(UV) + 0.5) - subUV + vec2(1.0 / AA);\n    \n    vec2 circle = vec2(180.0 + sin(iTime) * 2.5, 150.0 + cos(iTime) * 2.5);\n    float radius = 100.0;\n    \n    float dist = distance(circle, uv);\n    \n    return dist < radius && dist > radius - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n\n    vec3 col = vec3(0.0);\n    \n    float AA = 16.0;\n    vec3 aCol = vec3(0.0);\n    for(float subX = 0.0; subX <= 1.0; subX += 1.0 / AA)\n        for(float subY = 0.0; subY <= 1.0; subY += 1.0 / AA) {\n            if(Sample(uvec2(fragCoord), vec2(subX,subY), AA))\n                aCol += vec3(1.0);\n        }\n        \n    col = aCol / (AA * AA);\n\n    \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3yz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 309], [311, 311, 368, 368, 778]], "test": "untested"}
{"id": "dssXzs", "name": "radioactive water", "author": "lomateron", "description": "click to interact\nkey W to reset\n.xy = velocity\n.z = mass\nBuffer A tab applies some convolution and the result is in .xy\nthis result is added to the velocity in Buffer B tab", "tags": ["fluid"], "likes": 14, "viewed": 260, "published": 3, "date": "1669427143", "time_retrieved": "2024-07-30T16:16:56.008202", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = (vec4(a.x,length(a.xy),a.y,0)*.5+.5)*(.4/length(a.xyz));\n    //fragColor = a.zzzz;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        //r.xy += c*(sin(length(b.xy)*9.3))*exp(-l*l*.2)*-.05;\n        r.xy += c*(cos(length(a2.xyz)*11.))*exp(-l*l*.2)*-.05;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy +B(u).xy;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j));\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j));\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/444.;\n        a += vec4(-normalize(m),0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        vec2 m = 16.*(u-iResolution.xy*.5)/444.;\n        a = vec4(0,0,.9,0)-2.*vec4(m,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 232]], "test": "untested"}
{"id": "mslSRs", "name": "walls", "author": "lomateron", "description": "click to interact\nkey W to reset\n.xy = velocity\n.z = mass\nBuffer A tab applies some convolution and the result is in .xy\nthis result is added to the velocity in Buffer B tab\n", "tags": ["fluid"], "likes": 17, "viewed": 305, "published": 3, "date": "1669420314", "time_retrieved": "2024-07-30T16:16:56.976613", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = (vec4(length(a.xy),a.xy,0)*.5+.5)*pow(a.z,.3)*.8;\n    //fragColor = a.zzzz;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        r.xy += c*b.z*cos(-b.z*2.)*exp(-l*l*.2)*.02;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy +B(u).xy;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j));\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j));\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/444.;\n        a += vec4(-normalize(m),0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        vec2 m = 22.*(u-iResolution.xy*.5)/444.;\n        a = vec4(0,0,1,0)-4.*vec4(m,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 225]], "test": "untested"}
{"id": "mdsSzl", "name": "webcam buffer delay effect", "author": "jonasfrey", "description": "funny or not? ", "tags": ["webcam"], "likes": 4, "viewed": 451, "published": 3, "date": "1669415517", "time_retrieved": "2024-07-30T16:16:57.732592", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 o_col = texture(iChannel0, uv);\n    // Output to screen\n    fragColor = o_col;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trpino = fragCoord/iResolution.xy;\n\n        float fps = 60.0;\n    vec4 o_col_webcam = texture(iChannel1, o_trpino);\n    \n\n    //limit fps from here: https://www.shadertoy.com/view/wtscDj\n    if(mod(float(iFrame), 60.0 / fps) == 0.0){\n            vec2 o_subdivs = vec2(10., 10.);\n        vec2 o_trpino_big = o_trpino * o_subdivs;\n        vec2 o_trpino_big_fract = fract(o_trpino_big);\n        vec2 o_trpino_big_floor = floor(o_trpino_big);\n        float n_index = (o_trpino_big_floor.y * o_subdivs.x) + o_trpino_big_floor.x;\n        float n_index_norm = n_index / (o_subdivs.x * o_subdivs.y);\n        \n        float n_index_last = n_index - 1.;\n        float n_x_last = mod(n_index_last, o_subdivs.x);\n        float n_y_last = floor(n_index_last / o_subdivs.y);\n        vec2 o_trpino_big_floor_last = vec2(n_x_last, n_y_last);\n        \n        vec2 o_trpino_big_fract_last = \n            vec2(n_x_last*(1./o_subdivs.x), n_y_last*(1./o_subdivs.y))\n            + (o_trpino_big_fract / o_subdivs);\n        \n        vec4 o_col_buffer = texture(iChannel0, o_trpino_big_fract_last);\n        vec4 o_col_webcam = texture(iChannel1, o_trpino_big_fract);\n        if(n_index == 0.0){\n            fragColor = o_col_webcam;\n        }else{\n            fragColor = o_col_buffer;\n        }\n    }else{\n    \n        fragColor = texture(iChannel0, o_trpino);\n    \n    }\n    \n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 331]], "test": "untested"}
{"id": "dssXRl", "name": "webcam effect 1#: mirror", "author": "jonasfrey", "description": "so simple and yet so fun!", "tags": ["webcam"], "likes": 1, "viewed": 515, "published": 3, "date": "1669411911", "time_retrieved": "2024-07-30T16:16:58.518490", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n\n    vec2 o = (fragCoord.xy / iResolution.xy);\n    //https://www.desmos.com/calculator/lcwyvnubf7\n    float n_x = abs(o.x-(1./2.))*-1.+(1./2.);\n    float n_y = o.y;\n    vec4 o_col_webcam = texture(iChannel0, vec2(n_x, n_y));\n    \n    fragColor = o_col_webcam;\n    \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 397]], "test": "untested"}
{"id": "ddlSRl", "name": "Video Pixel Sorting 2", "author": "MysteryPancake", "description": "Improved video sorting using my faster sorting algorithm (shadertoy.com/view/DslSRs)", "tags": ["fast", "pixel", "sort", "sorting"], "likes": 4, "viewed": 209, "published": 3, "date": "1669406820", "time_retrieved": "2024-07-30T16:16:59.490890", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame < 1) {\n        // Initialize color to blue\n        fragColor = vec4(0.1, 0.1, 0.2, 0.0);\n    } else {\n        // Use video color when above color key threshold\n        vec4 vid = texture(iChannel1, fragCoord / iResolution.xy);\n        ivec2 pos = ivec2(fragCoord);\n        if (distance(vid.rgb, vec3(0.0, 1.0, 0.0)) > 0.8) {\n            fragColor = vid;\n        } else {\n            fragColor = texelFetch(iChannel0, pos, 0);\n        }\n        \n        // Compare pixels in pairs, sliding window along 1 pixel per frame\n        bool sampleTop = pos.y % 2 == iFrame % 2;\n        \n        // Faster sorting, see shadertoy.com/view/DslSRs\n        int jump = max(0, 16 + 2 * int(sin(iTime * 8.0) * 8.0)) + 1;\n        ivec2 offset = pos + ivec2(0, sampleTop ? jump : -jump);\n        \n        // Don't read out of bounds pixels\n        ivec2 dims = textureSize(iChannel0, 0);\n        if (offset.x < 0 || offset.x >= dims.x || offset.y < 0 || offset.y >= dims.y) {\n            return;\n        }\n        \n        // Compare red channel and alpha to know whether we need to swap\n        vec4 neighbour = texelFetch(iChannel0, offset, 0);\n        if (fragColor.a <= 0.0 || length(fragColor.rgb) > length(neighbour.rgb) == sampleTop) {\n            fragColor = neighbour;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 136]], "test": "untested"}
{"id": "cssXRl", "name": "2.5D Ancient Confetti", "author": "SnoopethDuckDuck", "description": "there's a million things you can do with this - super fun and a little bit laggy\n\nSimpler version to play with: https://www.shadertoy.com/view/ddsSzl\n", "tags": ["grid", "spiral", "layers"], "likes": 8, "viewed": 212, "published": 3, "date": "1669404043", "time_retrieved": "2024-07-30T16:17:00.297733", "image_code": "#define pi 3.14159\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define pal(t,b) .5+.5*cos(2.*pi*(t+b))\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// Distance function for each cell (ipos unused)\nfloat dist(vec2 ipos, vec2 fpos, vec2 uv, float io, float t) {\n    float r = 0.25 + 0.25 * cos(4. * length(uv) - t);\n    vec2  p = r * vec2(cos(io + t), sin(io + 2. * t));\n    float c = 0.5 + 0.5 * cos(10. * length(uv) - 2. * t);\n    return seg(fpos, c * uv, c * p);\n}\n\n// Min distance for this cell and neighbour cells\nfloat dist2(vec2 ipos, vec2 fpos, vec2 uv, float io, float t) {\n    float d = 1e5;\n    for (float i = -1.; i <= 1.; i++) \n        for (float j = -1.; j <= 1.; j++) \n            d = min(d, dist(ipos, fpos - vec2(i,j), uv, io, t));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 ouv = (fragCoord - 0.5 * res) / res.y;\n    \n    float t = iTime;  \n    // Unused time stuff\n    //float l = 2. * log(1. + length(ouv));\n    //float f = pow(fract(t - l), 2.);\n    //t = floor(t - l) + smoothstep(0.,1.,f);\n    //t = mix(t, iTime, 1.-exp(-0.25 * iTime));\n    //t = floor(t) + smoothstep(0., 1., fract(t));    \n    float th = tanh(0.25 * t);\n\n    float s = 0.;\n    \n    // Loop different layers (grids)\n    float n = 40.; // 50. looks better maybe\n    for (float i = n - 1.; i >= 0.; i--) {\n        float io = 2. * pi * i / n;     \n        float xp = 1. - exp(-0.12 * i);        \n        \n        // Rotate each layer (oscillate between 2 rotation modes)\n        float c = 0.5 + 0.5 * cos(io - t);\n        vec2 uv1 = ouv * rot(0.2 * t + io);\n        vec2 uv2 = ouv * rot(0.4 * t + io * 10.);\n        float c2 = 0.5 - 0.5 * thc(3., 0.1 * io - 0.25 * t);\n        vec2 uv = (1. + 0.2 * c * i) * mix(uv1, uv2, c2);\n        \n        // Scaled grid for each layer\n        float sc = 1. + 0.4 * sqrt(i);\n        vec2 ipos = floor(sc * uv) + 0.5;\n        vec2 fpos = sc * uv - ipos;\n\n        // Distance function for each cell (on each layer)\n        float d = dist2(ipos, fpos, uv, io, t);\n        float r = 0.13 * (0.75 + 0.25 * cos(io + t));\n        float k = (1. + 3. * xp) * sc / res.y;\n        //float s2 = smoothstep(-k, k, -abs(-d + r) + 0.01);\n        float r2 = 0.05 * cos(10. * d + uv.x * (20. + 3. * i));\n        float s2 = smoothstep(-k, k, -abs(-d + r) + r2);\n\n        // Add stuff to s (can replace float with vec3, and s with col)\n        s *= 1. - s2; // s = mix(s, 0., s2);\n        float fog = exp(0.02 - 0.5 * dot(uv,uv));      \n        s = mix(s, fog, (0.5 - 0.4 * th) * xp);\n    }\n    \n    s = clamp(s, 0., 1.); \n    vec3 col = vec3(s);\n   \n    // Contrast mode\n    //col = vec3(pow(4.*s*(1.-s),2.));\n   \n    // Blood mode\n    //col *= pal(0.15 * length(ouv), vec3(0,1,2)/3.);\n    \n    // Yellow mode\n    col *= pal(0.15 * length(ouv), 0.5 * vec3(0,1,2)/3.);\n    \n    // Gamma correction\n    col = pow(col, vec3(1./2.2));\n    \n    // Black bars at start\n    col *= step(abs(ouv.x), 0.52 * res.x/res.y * th);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 194, 194, 319], [321, 370, 432, 432, 638], [640, 690, 753, 753, 935], [937, 937, 994, 994, 3202]], "test": "untested"}
{"id": "cslXRs", "name": "Aldebaran's Sanctuary", "author": "kishimisu", "description": "It seems to produce a mystic energy... \n\nUse the mouse to change the time !", "tags": ["raymarching", "terrain", "fbm", "fast", "lighting", "repetition", "polar", "snow", "scene", "alps", "realistic", "snowy", "moutains"], "likes": 63, "viewed": 1532, "published": 3, "date": "1669401098", "time_retrieved": "2024-07-30T16:17:01.327979", "image_code": "/* \"Aldebaran's Sanctuary\" by @kishimisu (2022) - https://www.shadertoy.com/view/cslXRs\n\n   Switch to day/night mode with the mouse !\n   \n   This is the completion of my recent quest for fast fbm terrain generation. \n   Using various techniques that I listed in my shader demonstration\n   (https://www.shadertoy.com/view/msXSR2), I was able to get much better \n   performances that my previous realistic scene \"Lost Monoliths\" \n   (https://www.shadertoy.com/view/mdfSWr).\n   \n   However after finishing this scene I realized that I've made it more complex \n   than my previous one, so even if the terrain is calculated much faster it is\n   a bit demanding on the performances. (Even if it still runs 3x faster than\n   my previous one).\n   \n   I also tried to make reflective water, and it's one of these things that is really \n   beautiful for very few lines of code. Simply invert the ray y direction when it is \n   below a specific level, and add a bit of noise to its direction to simulate water \n   ripples. Terribly easy !\n   To make the water stand out nicely, the terrain close to the water gets darker to \n   simulate being wet. Also the color gets tinted with dark blue if the ray has been \n   reflected by the water.\n   \n   The space is repeated around the y axis, so there is only one pillar and one distant \n   monolith that are being checked at each step, and the trees are simple cones with \n   various offset, height, and colors. Finally, the terrain is made with 3 rings of\n   mountains that are more and more distance and high (see terrainH)\n*/\n\nvoid mainImage(out vec4 O, vec2 F) {    \n    vec3 col = texelFetch(iChannel0, ivec2(F-0.5), 0).rgb;\n    col *= pow(smoothstep(1., 0., length(F/iResolution.xy-.5)), .4);\n    O = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30574, "src": "https://soundcloud.com/spiritualmoment/ultra-sleep-meditation-music-sleep-hypnosis-music-for-deep-sleep?in=billie-kihega/sets/billies-sleep-sounds", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "#define ALTERNATE_VIEWS 1 // Set to 0 to prevent camera from switching viewpoints\n\n#define MOTION_BLUR     10.\n#define MAX_ITERATIONS 100.\n#define MAX_DISTANCE   120.\n#define EPSILON        .001\n\n#define FBM_LAYERS  8\n#define FAST_LAYERS 4\n#define SHADOW_FBM_LAYERS 4\n#define RELAXATION  1.\n\n#define VOLUME_STEPS    20.\n#define VOLUME_DENSITY  .8\n#define VOLUME_LIGHT    0.7\n\n#define sunCycle (iMouse.z == 0. ? smoothstep(-2.,10.,iTime) : iMouse.x/iResolution.x*.9+.1)\n#define sunColor vec3(1.2,0.671,0.376)*(sunCycle*.9+.15)\n#define skyColor vec3(0.604,0.784,0.976)*(sunCycle*.9+.15)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define treeRep 24.\n\n// Value noise - https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise2( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://shadertoyunofficial.wordpress.com/2019/01/02/\nvec3 hash33(vec3 p) {\n    return fract(cos((p)*mat3(127.1,311.7,74.7,269.5,183.3,246.1,113.5,271.9,124.6))*43758.5453123);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// https://www.shadertoy.com/view/3ddGzn\nfloat noise3(vec3 p) {\n\tvec3 ip=floor(p), s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp-=ip; p=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm3(vec3 p) { \n    p += vec3(iTime*.1, iTime*.1, 0.);\n    float f = 1.0, a = 1.0,\n          t = noise3(p);\n    for(int i=1; i<5; i++) {\n        t += a*noise3(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\n\nfloat fastnoise2(vec2 p) {\n    return (sin(p.x)-cos(p.y))*.5+.5;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone(vec3 p) {\n    const vec2 c = vec2(0.198669, 0.980067);\n    vec2   q = vec2( length(p.xz), -p.y );\n    float  d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0) - .1;\n}\nfloat sdArc( in vec2 p, in float ra, float rb ) {\n    const vec2 sc = vec2(0.808496, -0.588501);\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\nfloat sdCircle(vec2 p, float ra, float rb) {\n    return abs(length(p) - ra) - rb;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad)  {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// Smarter fbm calculation - https://www.shadertoy.com/view/msXSR2\nfloat fbm(vec2 p, float h, int layers) {\n    float n = fastnoise2(p); \n    float a = 1.;\n    \n    for (int i = 0; i < layers; i++) {\n        if (h > n + a) break;\n        \n        p *= 2.; a *= .5;\n   \n        if (i < FAST_LAYERS) \n            n -= a*abs(fastnoise2(p)-n);\n        else                \n            n -= a*noise2(p);      \n    } \n    \n    return n;\n}\n\nfloat terrainH(vec3 p, int layers) {    \n    float mnt =  smoothstep(0., 1., -sdArc(vec2(p.z, -p.x - 4.), 6. , 1.));\n    mnt += 2.2 * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 22., 5.)); \n    mnt += 4.  * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 36., 5.));         \n    return fbm(p.xz*.5, p.y - mnt, layers) + mnt;\n}\n\nvec2 map(vec3 p, int layers, inout vec3 light) {\n    float l = length(p.xz);\n    // Terrain\n    float ground = 1e6;\n    if (p.y < 5.) {\n        float terrain = terrainH(p, layers);\n        ground  = p.y - terrain;\n    }\n    \n    // Trees\n    float trees = 1e6;\n    if (ground < 1.) {\n        float sm  = smoothstep(5.5, 6., l);\n        float rep = mix(treeRep, 10., sm);\n        vec3  fp  = fract(p*rep)-.5; \n        vec3  id  = floor(p*rep)+.5;\n        vec3  r   = hash32(id.xz);\n        float fh  = fbm(id.xz*.5/rep, p.y-.1, layers); \n\n        float h  = 3. + r.y*sm*.4;\n        vec3 off = vec3(1.,0.,1.)*r*.4*sm;\n        fp.y = (p.y - fh) * rep - h;\n        trees = (sdCone(fp - off) + smoothstep(.5, .9, noise2(p.xz))) / rep;  \n    }\n    \n    // Structures\n    float shape = 1e6, cables = 1e6;\n    if (l < 12.) {\n        vec3  sp  = p;\n        float an  = 6.283185 / 16.;\n        float aid = (round((atan(p.z, p.x)-an/2.)/an)*an)+an/2.;\n        vec3  rs  = hash31(aid);\n        sp.xz *= rot(-aid);\n\n        shape = sdBox(sp - vec3(8.5,0,0), vec3(.3,3.,.45));\n        float hole  = sdBox(sp - vec3(8.5,1.8,0), vec3(.35, .9, .3));\n        shape = smax(shape, -hole, .1);\n\n        float center = length(p+vec3(0,.2,0))-.35;\n        float doors = sdBox(sp + vec3(0,.2,0), vec3(.4, .25*(sin(iTime*.1)*.5+.5), .04));\n        center = smax(center, - doors, .03);\n        center = min(center, sdCylinder(sp - vec3(1,-.5,0), .04, .5+rs.z*.2 + sin(.2*iTime+aid*10.)*.06));\n        shape  = min(shape, center) - .01;\n\n        // These aren't real objects, their signed distance is always strictly positive. It's only\n        // captured in lighting as it increases the iteration count near these phantom cables.\n        sp.z = abs(sp.z);\n        cables = sdCapsule(sp, vec3(1,0,0), vec3(9,3,.4), -.01-smoothstep(0.4, 0.6, sunCycle));\n\n        // Lighting\n        vec3 lc = 0.06 * (vec3(.7,.7,1.) - rs*.2);\n        light += lc / (1. + pow(abs(hole), 1.4));\n        light += 1.5*lc * vec3(0.447,0.118,0.600) / (1. + pow(abs(center*5.), 1.4));\n        light += 1.5*lc * vec3(0.118,0.600,0.522) / (1. + pow(abs(doors*5.), 1.4));\n    }\n    \n    vec2 res = vec2(ground, 0.);\n    if (trees < res.x) res = vec2(trees, 1.);\n    if (shape < res.x) res = vec2(shape, 2.);\n    if (cables < res.x) res = vec2(cables,3.);\n    \n    return res; \n}\n\nvec3 ltmp;\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*map(p + e.xyy, FBM_LAYERS,ltmp).x + e.yyx*map(p + e.yyx, FBM_LAYERS,ltmp).x + \n\t\t\t\t\t e.yxy*map(p + e.yxy, FBM_LAYERS,ltmp).x + e.xxx*map(p + e.xxx, FBM_LAYERS,ltmp).x);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.1, res = 1., k = 10.;\n    for (float i = 0.; i < MAX_ITERATIONS*.7; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p, SHADOW_FBM_LAYERS,ltmp).x;\n        res = min(res, k*d/t);\n        t += d;\n        if (t > maxt) return res;\n        if (d < EPSILON) return 0.;\n    }\n    return 0.;\n}\n\nvec3 volumeColor(vec3 ro, vec3 rd, float near, float far, vec3 sunDir, vec3 col) {\n    vec3 vcol  = vec3(0.);\n    float mask = 1.;\n    float vstep = (far - near) / VOLUME_STEPS;\n    const float dh = 1./VOLUME_DENSITY;\n\n    for (float t = near, i = 0.; t <= far && i < VOLUME_STEPS; t += vstep, i++) {\n        vec3 p = ro + t*rd;\n        \n        float dens = fbm3(p/6.);\n        dens = smoothstep(dh, dh+1., dens);\n\n        float prev = mask;\n        mask *= exp(-dens * vstep * .3);\n        float absorbed = prev - mask;\n        \n        vec3 light = 1.5-vec3(smoothstep(dh, dh+.6, fbm3((p-sunDir*.1)/6.)));\n        vcol += vec3(.9,1.,.7) * sunColor * absorbed * vstep * light * VOLUME_LIGHT;          \n    }\n    \n    return col*mask + min(vcol, vec3(1.));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy*2.-1.; \n    float t = iTime*.1, tt = 0.;\n    ro = vec3(0., -.1 + cos(t*1.1)*.1, 3. + sin(t*1.2)*.3);\n#if ALTERNATE_VIEWS\n    tt = step(20., mod(iTime, 35.)); \n#endif\n    ro.yz *= rot(cos(t*1.15)*.05-mix(.5, .1, tt));\n    ro.zx *= rot(sin(t)*.3-mix(-1.2, 1.2, tt)); \n    vec3 f = normalize(vec3(cos(t)*.01,.5+cos(t)*.02,sin(t)*.015)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec2 res;\n    vec3 ro, rd;\n\n    initRayOriginAndDirection(uv, ro, rd);\n    \n    bool hitWater = false;\n    float t   = 0., i;\n    vec3  p   = ro, \n        col   = skyColor, \n      light   = vec3(0.);  \n        \n    for (i = 0.; i < MAX_ITERATIONS; i++) {\n        res = map(p, hitWater ? 5 : FBM_LAYERS, light);\n        \n        if (p.y < -.33) {\n            // Reflect if ray hit water level\n            p.y += 2.*abs(p.y+.33);\n            rd.y = -rd.y;\n            rd = normalize(rd + (noise2(p.xz*80.+iTime*.2)-.5)*.06);\n            hitWater = true;\n        }\n        \n        float d = res.x > 0. ? res.x*.9 : res.x*.3;\n        t += d;\n        p += rd * d;\n\n        if (res.x < EPSILON*(1. + t*RELAXATION) || t > MAX_DISTANCE) break;\n    }\n    \n    float phi = 0.32 * 6.28, the = -0.00 * 3.14 + 1.27 + (1.-sunCycle)*.2;\n    vec3 lightDir = normalize(vec3(sin(the)*sin(phi), cos(the), sin(the)*cos(phi)));\n    \n    if (t < MAX_DISTANCE) {\n        // Hit object\n        float th = terrainH(p, FBM_LAYERS);\n        vec3  id = floor(p*treeRep)+.5;\n        vec3   r = hash32(id.xz);\n        vec3   n = getNormal(p - rd*EPSILON*4., t);\n        float sunLight    = max(.1, dot(n, lightDir));\n        float sunShadow   = max(.02, getShadow(p + n*EPSILON*4., lightDir, MAX_DISTANCE));\n        float skyLight    = max(.0, n.y);\n        float bounceLight = max(.0, dot(n, -lightDir));\n        float spec        = max(.0, dot((rd + n)/2., lightDir));\n\n        if (res.y == 0.) {\n            // Terrain\n            col = vec3(1.);\n            col *= .4+smoothstep(.55, .7, skyLight );\n            col *= .05 + 1.*sunColor * sunLight * sunShadow;\n        } else if (res.y == 1.) {\n            // Trees\n            col = mix(\n                vec3(.2,.6 + (r.y-.5)*.5,.4)*.25, \n                vec3(1.)   + (r.x-.5)*.5, \n                smoothstep(0., .13, p.y - th + t * .0) \n            );\n            col *= .25*(sunCycle+.1) + 1.*sunColor * sunLight * sunShadow;  \n        } else {\n            // Structures\n            col = 1. - texture(iChannel1, p.xy*4.).rrr*.4;\n            col *= .2 + 1.*sunColor * sunLight * sunShadow;\n        }\n        \n        col *= smoothstep(.2, .4, length(p + vec3(0,.2,0)));\n\n        col += 0.2*skyColor * skyLight;\n        col += 0.1*vec3(.4,.2,0.) * bounceLight;\n        col += 1.5*pow(spec, 4.)*sunCycle;\n    } \n    \n    // Clouds\n    vec2 hit = boxIntersection(ro - vec3(0, 8, 0), rd, vec3(200., 4., 200.));\n    if (hit.x >= 0. && hit.x < t) {\n        col = volumeColor(ro, rd, hit.x, min(hit.y, t), lightDir, col);\n        t = min(hit.x, t);\n    }\n    \n    // Water occlusion\n    if (hitWater) col *= vec3(.7,.7,.9);\n    col *= mix(0.4, 1., smoothstep(-.35, -.25, p.y));\n    \n    // Apply fog\n    vec3 fog = exp2(-t*0.07*vec3(1,1.8,4)); \n    col = mix(clamp(skyColor - vec3(1.,1.5,2.)*abs(rd.y)*.3, vec3(0.), vec3(1.)), col, fog);   \n    \n    // Color adjust\n    col = pow(col, vec3(.99,.88,.95));\n    col = smoothstep(vec3(0.04), vec3(1), col);\n    col = pow(col, vec3(.4545));\n    \n    // Night lighting\n    col += light * smoothstep(.8, 0., sunCycle);\n           \n    // Accumulate frames\n    vec3 ocol = texelFetch( iChannel0, ivec2(F-0.5), 0 ).xyz;\n    if(iFrame==0) ocol = col;\n    col = mix(ocol, col, 1./MOTION_BLUR);\n    O = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1563, 1563, 1599, 1599, 1756]], "test": "untested"}
{"id": "DslSRs", "name": "Much Faster Pixel Sorting", "author": "MysteryPancake", "description": "I had an idea to speed up pixel sorting using chunks, maybe similar to merge sort? It doesn't always end in exact order, but usually looks identical.", "tags": ["fast", "pixel", "sort", "sorting"], "likes": 5, "viewed": 412, "published": 3, "date": "1669399736", "time_retrieved": "2024-07-30T16:17:02.306363", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Loop every 128 frames\n    int frame = iFrame % 128;\n    \n    if (frame < 1) {\n        // Initialize color to texture\n        fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    } else {\n        // Start with original color\n        ivec2 pos = ivec2(fragCoord);\n        fragColor = texelFetch(iChannel0, pos, 0);\n        \n        // Compare pixels in pairs, sliding window along 1 pixel per frame\n        bool sampleTop = pos.y % 2 == frame % 2;\n        \n        // SPEEDUP: Sort larger chunks first, then smaller chunks\n        int jump = max(0, 96 - (frame * 2)) + 1;\n        ivec2 offset = pos + ivec2(0, sampleTop ? jump : -jump);\n        \n        // Don't read out of bounds pixels\n        ivec2 dims = textureSize(iChannel0, 0);\n        if (offset.x < 0 || offset.x >= dims.x || offset.y < 0 || offset.y >= dims.y) {\n            return;\n        }\n        \n        // Compare red channel and alpha to know whether we need to swap\n        vec4 neighbour = texelFetch(iChannel0, offset, 0);\n        if (length(fragColor.rgb) > length(neighbour.rgb) == sampleTop) {\n            fragColor = neighbour;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 136]], "test": "untested"}
{"id": "cdsXzl", "name": "CamGlowyPe2", "author": "Sergeindamix", "description": "playing with glow and other things. recalculating the ray direction is kind of weird", "tags": ["glow"], "likes": 0, "viewed": 319, "published": 3, "date": "1669398943", "time_retrieved": "2024-07-30T16:17:03.263803", "image_code": "float rectangle(vec2 position, vec2 scale)\n{\n    scale = vec2(0.5) - scale * 0.5;\n    vec2 shape = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    shape *= vec2(step(scale.x, 1.0 - position.x), step(scale.y, 1.0 - position.y));\n    \n    return shape.x * shape.y;\n\n}\nvec2 remap2(vec2 p)\n\t\t\t{\n\t\t\t\tp.xy *= .5 + .5;\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\tvec2 remap3(vec2 p)\n\t\t\t{\n                float s=.5;\n                p-=s/2.;\n\t\t\t\tp = remap2(p)/s;\n\t\t\t\t\n\t\t\t\treturn p;\n\t\t\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv = fragCoord/iResolution.xy;\n    uv/=2.0;\n    uv+=.25;\n    float mask = rectangle(uv, vec2(0.19, 0.5));\n    vec3 col = texture(iChannel0, remap3(uv)).rgb;\n    col = texture(iChannel2, remap3(uv)).rgb;\n    //col = texture(iChannel3, remap3(uv)).rgb;\n    col = mix(col, texture(iChannel1, remap3(uv)).rgb,mask);\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "buffer_b_code": "//STARNEST\n#define iterations 12\n#define formuparam 0.44\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoomS   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n//CLOUDS\n#define SAMPLE_COUNT 32\n#define DIST_MAX 32.\n#define MOUSEY (3.*iMouse.y/iResolution.y)\n#define SAMPLES_ADAPTIVITY 0.02\n\n// mouse toggle\nbool useNewApproach = true;\n\n// cam moving in a straight line\nvec3 lookDir = vec3(-1.,0.,0.5);\nvec3 camVel = vec3(-1.,0.,0.);\nfloat zoom = 1.8; // 1.5;\n\n// cam spin around on spot\nfloat samplesCurvature = 0.; // can mix between fixed z and fixed radius sampling\n\nvec3 sundir = normalize(vec3(-1.0,0.0,-1.));\n\n// LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\nvec4 stars(in vec2 fragCoord){\n//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoomS,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\treturn vec4(v*.01,1.);\t\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.1 + .8 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;\n\n    vec3 q = p;\n    float f;\n    \n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n    d += 2.75 * f;\n\n    d = clamp( d, 0.0, 1.0 );\n    \n    vec4 res = vec4( d );\n    \n    vec3 col = 1.15 * vec3(1.0,0.95,0.8);\n    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);\n    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );\n    \n    return res;\n}\n\n// compute desired spacing between samples, modelled as a 1/z curve\nfloat spacing(float t )\n{\n    // restrict to domain\n    t = max(t,0.);\n    \n    // unnorm pdf - plot this in graphtoy to see shape\n    float pdf = 1. / (SAMPLES_ADAPTIVITY*t + 1.);\n\t// integral of pdf over dist\n\tfloat norm = (1. / SAMPLES_ADAPTIVITY)*log(1. + SAMPLES_ADAPTIVITY*DIST_MAX);\n    // norm pdf\n    pdf /= norm;\n    \n    // sample spacing for our sample count\n    return 1. / (float(SAMPLE_COUNT) * pdf);\n}\n\n// mod but moves the boundaries to keep them stationary with the camera\nfloat mov_mod( float x, float y )\n{\n    return mod(x + (useNewApproach ? dot(camVel*iTime,lookDir) : 0.), y) ;\n}\n\nbool on_boundary( float x, float y )\n{\n    // the +0.25 solves numerical issues without changing the result\n    float numericalFixOffset = y*0.25;\n    return mov_mod( x + numericalFixOffset, y ) < y*0.5;\n}\n\n// put t on an appropriate sample location and initialise sampling data\nvoid firstT( out float t, out float dt, out float wt, out bool even )\n{\n    dt = exp2(floor(log2(spacing(0.))));\n    t = dt - mov_mod(t,dt);\n    even = on_boundary(t,2.*dt);\n    wt = 1.;\n}\n\n// advance t to next sample location\nvoid nextT( inout float t, inout float dt, inout float wt, inout bool even )\n{\n    float s = spacing(t); // get desired sample spacing\n    if( s < dt ) { dt /= 2.; even = true; } // can immediately move to higher density\n    else if( even && s > 2.*dt ) { dt *= 2.; wt = 1.; even = on_boundary(t,2.*dt); } // move to lower density if a sample is there\n\n    if( even ) wt = clamp( 2. - s/dt,0.,1.); // update wt for next odd sample - based on how far this even sample is into its band\n    \n    // next sample\n    t += dt;\n    even = !even;\n}\n\n// wt for blending in/out samples without pops\nfloat sampleWt( float wt, bool even )\n{\n    return even ? (2.-wt) : wt;\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 sum = vec4(0, 0, 0, 0);\n    \n    // setup sampling\n    float t, dt, wt; bool even;\n    firstT( t, dt, wt, even );\n    \n    for(int i=0; i<SAMPLE_COUNT; i++)\n    {\n        if( sum.a > 0.99 ) continue;\n\n        vec3 pos = ro + t*rd;\n        vec4 col = map( pos );\n        \n        // iqs goodness\n        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );\n        vec3 lin = vec3(0.51, 0.53, 0.63)*1.35 + 0.55*vec3(0.85, 0.57, 0.3)*dif;\n        col.xyz *= lin;\n        \n        col.xyz *= col.xyz;\n        \n        col.a *= 0.35;\n        col.rgb *= col.a;\n\n        // fade samples at far field\n        float fadeout = 1.-clamp((t/(DIST_MAX*.3)-.85)/.15,0.,1.); // .3 is an ugly fudge factor due to oversampling\n            \n        // integrate\n        float thisDt = dt * sampleWt( wt, even); // blend in dts\n        thisDt = sqrt(thisDt/5. )*5.; // hack to soften and brighten\n        sum += thisDt * col * (1.0 - sum.a) * fadeout;\n\n        // next sample\n        nextT( t, dt, wt, even );\n    }\n\n    sum.xyz /= (0.001+sum.w);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec3 sky( vec3 rd )\n{\n    vec3 col = vec3(0.);\n    \n    float hort = 1. - clamp(abs(rd.y), 0., 1.);\n    col += 0.5*vec3(.99,.5,.0)*exp2(hort*8.-8.);\n    col += 0.1*vec3(.5,.9,1.)*exp2(hort*3.-3.);\n    col += 0.55*vec3(.6,.6,.9);\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    col += .2*vec3(1.0,0.3,0.2)*pow( sun, 2.0 );\n    col += .5*vec3(1.,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(1.,.7,0.)*exp2(sun*50.-50.);\n    col += .5*vec3(1.,0.3,0.05)*exp2(sun*10.-10.); \n    \n    float ax = atan(rd.y,length(rd.xz))/1.;\n    float ay = atan(rd.z,rd.x)/2.;\n    float st = texture( iChannel0, vec2(ax,ay) ).x;\n    float st2 = texture( iChannel0, .25*vec2(ax,ay) ).x;\n    st *= st2;\n    st = smoothstep(0.65,.9,st);\n    col = mix(col,col+1.8*st,clamp(1.-1.1*length(col),0.,1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n   \n    // camera\n    vec3 ro = vec3(0.,1.9,0.) + iTime*camVel;\n    vec3 ta = ro + lookDir; //vec3(ro.x, ro.y, ro.z-1.);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + 1.2*p.y*vv + 1.5*ww );\n    \n    // sky\n    vec3 col = vec3(0.0,0.0,0.0);// sky(rd);\n    \n    // divide by forward component to get fixed z layout instead of fixed dist layout\n    vec3 rd_layout = rd/mix(dot(rd,ww),1.0,samplesCurvature);\n    vec4 clouds = raymarch( ro, rd_layout );\n    \n    col = mix( col, clouds.xyz, clouds.w );\n    \n\tcol = clamp(col, 0., 1.);\n    col = smoothstep(0.,1.,col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n    vec4 black = vec4(0.0,0.0,0.0,1.0);\n    fragColor = vec4( col, 1.0 );\n    if(fragColor.r <= 0.2 && fragColor.g <= 0.2 && fragColor.b <= 0.2 )\n    {fragColor = stars(fragCoord);}\n}\n", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define R2(p,t) p*cos(t)+vec2(p.y,-p.x)*sin(t)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,q,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    float i=0.,e,g=0.,t=iTime;\n\tfor(;i++<90.;)\n    {\n        p=R(g*d,normalize(H(t*.03)*2.-1.),g*.02);\n        q=p;\n        p.z+=t*3.;\n        p=abs(fract(p)-.5);\n        e=length(p)-.15;\n        p=p.x<p.z?p.zyx:p;\n        p=p.x>p.y?p.yxz:p;\n        p.xy=R2(p.xy,.98-sin(length(q.xy)));\n        g+=e=max(-e,length(p.xz))*.6;\n\t    c+=mix(vec3(1),H(q.z*.05+.4),.7)*.4/exp(30.*e)/g;\n\t}\n    O=vec4(c,1);\n}", "buffer_a_inputs": [], "buffer_c_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\n// tweaked as the center aligned horizontal capsule. \nfloat sdHorizontalCapsule( vec3 p, float w, float r )\n{\n  p.x-= clamp( p.x, -w*0.5, w*0.5 );\n  return length( p ) - r;\n}\n\nfloat speaker(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p, vec3(0.45,0.95,0.34))-0.03;\n    float d2 = length(p-vec3(0.,-0.2,-0.53))-0.38;\n    \n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.,-0.2,-0.36),vec2(0.36,0.03));\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.,-0.2,-0.32),vec2(0.32,0.025));\n    d = min(d,d2);\n    d2 = length(p-vec3(0.,-0.25,-0.08))-0.12;\n    d = min(d,d2);\n    \n    d2 = sdHorizontalCapsule(p-vec3(0.,-0.75,-0.36),0.6,0.06);\n    d = max(-d2,d);\n    \n    d2 = length(p-vec3(0.,0.55,-0.36))-0.2;\n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.,0.55,-0.36),vec2(0.2,0.03));\n    d = min(d,d2);\n    \n    p.z-=-0.36;\n    p.x = abs(p.x)-0.4;\n    p.y = abs(p.y)-0.9;\n    d2 = length(p)-0.03;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat speaker2(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p, vec3(0.95,0.45,0.34))-0.03;\n    float d2 = sdBox(p-vec3(0.,0.,-0.35), vec3(0.9,0.4,0.01))-0.03;\n    d = max(-d2,d);\n    \n    p.x = abs(p.x);\n    d2 = length(p-vec3(0.4,0.,-0.5))-0.36;\n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.4,0.,-0.3),vec2(0.34,0.03));\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.4,0.,-0.29),vec2(0.3,0.025));\n    d = min(d,d2);\n    d2 = length(p-vec3(0.45,0.,-0.08))-0.1;\n    d = min(d,d2);\n    \n    p.z-=-0.3;\n    p.x = abs(p.x)-0.86;\n    p.y = abs(p.y)-0.36;\n    d2 = length(p)-0.03;\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat speaker3(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p, vec3(0.95,0.95,0.34))-0.03;\n    \n    float d2 = length(p-vec3(0.0,0.,-0.68))-0.66;\n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.35),vec2(0.64,0.05));\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.33),vec2(0.6,0.045));\n    d = min(d,d2);\n    \n    d2 = length(p-vec3(0.0,0.,0.1))-0.2;\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.3),vec2(0.56,0.035));\n    d = min(d,d2);    \n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.24),vec2(0.52,0.035));\n    d = min(d,d2);        \n        \n    d2 = sdTorus(p-vec3(0.0,0.,-0.19),vec2(0.47,0.035));\n    d = min(d,d2);  \n    \n    d2 = abs(length(p.xy)-0.73)-0.07;\n    d = min(d,max((abs(p.z)-0.38),d2));\n    \n    p.z-=-0.37;\n    p.x = abs(p.x)-0.86;\n    p.y = abs(p.y)-0.86;\n    d2 = length(p)-0.03;\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.z-=-0.37;\n    p.xy = DF(p.xy,3.0);\n    p.xy -= vec2(0.52);\n    d2 = length(p)-0.03;\n    d = min(d,d2); \n    \n    p = prevP;\n    p.xy*=Rot(radians(sin(iTime)*120.));\n    p.z-=-0.37;\n    p.y=abs(p.y)-0.93;\n    d2 = Tri(p.xy,vec2(0.08),radians(45.));\n    d = min(d,max((abs(p.z)-0.02),d2));    \n    \n    p = prevP;\n    p.xy*=Rot(radians(90.+sin(iTime)*120.));\n    p.z-=-0.37;\n    p.y=abs(p.y)-0.93;\n    d2 = Tri(p.xy,vec2(0.08),radians(45.));\n    d = min(d,max((abs(p.z)-0.02),d2));      \n    \n    return d;\n}\n\nfloat changeSpeakers(vec3 p, float start, float speed){\n    vec3 prevP = p;\n    float endTime = 3.;\n    float t = iTime*speed;\n    float scenes[3] = float[](0.,1.,2.);\n    for(int i = 0; i<scenes.length(); i++){\n        scenes[i] = mod(scenes[i]+start,endTime);\n    }\n    \n    float scene = scenes[int(mod(t,endTime))];\n    \n    float d = 10.;\n    if(scene<1.) {\n        p.x=abs(p.x)-0.5;\n        d = speaker(p);\n    } else if (scene >= 1. && scene<2.){\n        p.y=abs(p.y)-0.5;\n        d = speaker2(p);\n    } else {\n        d = speaker3(p);\n    }\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.y -=iTime*0.5;\n    vec2 id = floor(p.xy*0.5);\n    p.z-=3.;\n    p.xy = mod(p.xy,2.0)-1.0;\n\n    id*=.5;\n    float rand = Hash21(id);\n    \n    float d = 10.;\n    p.z-=rand*0.3;\n    if(rand<0.3) {\n        d = changeSpeakers(p,1.,0.5+rand);\n    } else if(rand>=0.3 && rand<0.7) {\n        d = speaker3(p);\n    } else {\n        p.x=abs(p.x)-0.5;\n        d = speaker(p);\n    }\n    \n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.3));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.5);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float scene = mod(iTime,15.);\n        float rotY = -10.;\n        float rotX = 0.;\n        if(scene>=5. && scene<10.){\n            rotY = 0.;\n            rotX = -30.;\n        } else if(scene>=10.){\n            rotY = 0.;\n            rotX = 30.;\n        }\n        \n        ro.yz *= Rot(radians(rotY));\n        ro.xz *= Rot(radians(rotX));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(sqrt(col),1.0);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsXzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 281], [282, 282, 306, 306, 346], [350, 350, 374, 374, 472], [474, 474, 531, 531, 944]], "test": "untested"}
{"id": "DssXRl", "name": "Video Pixel Sorting", "author": "MysteryPancake", "description": "My first attempt at pixel sorting, extremely slow but looks cool", "tags": ["video", "pixel", "sort", "sorting"], "likes": 4, "viewed": 278, "published": 3, "date": "1669394773", "time_retrieved": "2024-07-30T16:17:04.079622", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame < 1) {\n        // Initialize color to blue\n        fragColor = vec4(0.1, 0.1, 0.2, 0.0);\n    } else {\n        // Use video color when above color key threshold\n        vec4 vid = texture(iChannel1, fragCoord / iResolution.xy);\n        if (distance(vid.rgb, vec3(0.0, 1.0, 0.0)) > 0.8) {\n            fragColor = vid;\n            return;\n        }\n    \n        // Start with original color\n        ivec2 pos = ivec2(fragCoord);\n        fragColor = texelFetch(iChannel0, pos, 0);\n        \n        // Compare pixels in pairs, sliding window along 1 pixel per frame\n        bool sampleLeft = pos.x % 2 == iFrame % 2;\n        ivec2 offset = pos + ivec2(sampleLeft ? -1 : 1, 0);\n        \n        // Don't read out of bounds pixels\n        ivec2 dims = textureSize(iChannel0, 0);\n        if (offset.x < 0 || offset.x >= dims.x || offset.y < 0 || offset.y >= dims.y) {\n            return;\n        }\n        \n        // Compare red channel and alpha to know whether we need to swap\n        vec4 neighbour = texelFetch(iChannel0, offset, 0);\n        if (fragColor.a <= 0.0 || length(fragColor.rgb) > length(neighbour.rgb) == sampleLeft) {\n            fragColor = neighbour;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 136]], "test": "untested"}
{"id": "cdlSRl", "name": "star nest fork for cineshader", "author": "ElMehdiBouamama", "description": "star nest shader fork for cineshader test", "tags": ["cineshader"], "likes": 13, "viewed": 2481, "published": 3, "date": "1669391777", "time_retrieved": "2024-07-30T16:17:04.846571", "image_code": "// Star Nest by Pablo Roman Andrioli\n\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   abs(cos(cos(iTime/10.)))\n#define tile   0.850\n#define speed  0.001 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,v);\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 372, 400, 1623]], "test": "untested"}
{"id": "dsXXzs", "name": "Ocean toon", "author": "Issam_X_Mhadhbi", "description": "simple ocean", "tags": ["ocean"], "likes": 1, "viewed": 160, "published": 3, "date": "1669390200", "time_retrieved": "2024-07-30T16:17:05.740182", "image_code": "const vec2 vp = vec2(320.0, 200.0);\n\n\n\nconst float pi = 3.1415926435;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime * 10.0 + iMouse.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p0 = (uv - 0.5) * vp;\n    vec2 hvp = vp * 0.5;\n\tvec2 p1d = vec2(cos( t / 98.0),  sin( t / 178.0)) * hvp - p0;\n\tvec2 p2d = vec2(sin(-t / 124.0), cos(-t / 104.0)) * hvp - p0;\n\tvec2 p3d = vec2(cos(-t / 165.0), cos( t / 45.0))  * hvp - p0;\n    float sum = 1.0 + 0.5 * (\n\t\tcos(length(p1d) / 10.0) +\n\t\tcos(length(p2d) / 20.0) +\n\t\tsin(length(p3d) / 20.0) * sin(p3d.x / 20.0) * sin(p3d.y / 15.0));\n \n    float i = fragCoord.x / iResolution.x;\n    vec3 ti = (iTime + iMouse.y) / vec3(63.0, 78.0, 45.0);\n    vec3 csi = cos(i * pi * 2.0 + vec3(0.0, 1.0, -0.5) * pi + ti);\n    vec3 colorx = normalize(vec3(vec3( 255, 87, 51 )));\n\n    \n    //---\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uvi = p*vec2(iResolution.x/iResolution.y,1.0); \n    vec3 colorup = vec3(9,108,167) ; \n    vec3 colordown = vec3(250,242,239) ; //vec3(0, 71, 171) ; \n    colordown = normalize(colordown) ;\n    colorup = normalize(colorup) ; \n    vec3 mixed = mix(colordown,colorup,p.y*fract(sum)) ; \n    fragColor = vec4(mixed,1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 130, 130, 1218]], "test": "untested"}
{"id": "msfXRs", "name": "dotnut", "author": "Alie", "description": "donut of dottiness", "tags": ["2d", "3d", "donut"], "likes": 11, "viewed": 181, "published": 3, "date": "1669389692", "time_retrieved": "2024-07-30T16:17:09.297670", "image_code": "// Rotates a 2d point by an angle\n#define Rotate2D(p,a) p = cos(a) * p + sin(a) * vec2(-p.y, p.x)\n#define PI acos(-1.0)\n\n// Dot size and torus sections\nconst float dotSize = 0.02;\nconst float torusSectionsA = 12.0, torusSectionsB = 24.0;\nconst float torusRadiusA = 0.3, torusRadiusB = 0.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalised coords (from -1 to 1)\n    vec2 uv = fragCoord * 2.0 - iResolution.xy;\n    uv /= iResolution.xx;\n\n    // base colour\n    vec3 col = vec3(1.0, 0.45, 0.55);\n\n    // pixel size (for AA)\n    float pixSize = 2.0 / iResolution.x;\n    \n    // We start with a point offset a bit from the centre\n    vec3 p = vec3(0,torusRadiusA,0);\n    \n    // Iterate to rotate the point to form a circle\n    for (float i=0.0; i<=1.0; i+=1./torusSectionsA) {\n    \n        // Make a copy of the point and rotate it on the xy plane\n        vec3 pos1 = p;\n        Rotate2D(pos1.xy, i * PI * 2.);\n        \n        // Shift it across so it's a cross section through one side of the torus\n        pos1.x += torusRadiusB;\n        \n        // We now have a slice of torus, iterate to rotate around a second circle to finish it\n        for(float j = 0.0; j <= 1.0; j+= 1. / torusSectionsB) {\n        \n            // make a copy and roate again, this time on the xz plane\n            vec3 pos2 = pos1;\n            Rotate2D(pos2.xz, j * PI * 2.);\n            \n            // rotate the whole donut so it spins in 3d\n            Rotate2D(pos2.xy, iTime * .55);\n            Rotate2D(pos2.xz, iTime * .34);\n            \n            // a bit of fudged perspective...\n            pos2.z = -pos2.z * 0.5 + 0.5;\n            pos2.xy *= pos2.z+0.5;\n            \n            // add to the colour if we're inside the dot\n            // The dot size gets scaled by the z position for perspective\n            // Smoothstep is used betwee the dotsize and dotsize + pixSize, which gives us some AA\n            col += 1. - smoothstep(dotSize * pos2.z, dotSize * pos2.z + pixSize, length(uv - pos2.xy));\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 348, 388, 2095]], "test": "untested"}
{"id": "msXSzs", "name": "circular blur without for loop", "author": "axiomgraph", "description": "this shader is for those who want to know how this circular blur works. this can be converted into for loop.", "tags": ["circularblur", "rotationalblur"], "likes": 3, "viewed": 238, "published": 3, "date": "1669389607", "time_retrieved": "2024-07-30T16:17:10.419670", "image_code": "vec2 pivot = vec2(0.0);\n\n\nvec2 rotate(vec2 uv, vec2 p, float angle)\n{\n\tmat2 rotation = mat2(vec2(cos(angle), -sin(angle)),\n\t\t\t\t\t\tvec2(sin(angle), cos(angle)));\n\tuv -= p;\n\tuv = uv * rotation;\n\tuv += p;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n  \n    \n    vec4 COLOR = vec4(0.0);    \n\t\n\t\t\n\t\n\t\tCOLOR = texture(iChannel0, rotate(uv, pivot + 0.5, 0.01))+\n                texture(iChannel0, rotate(uv, pivot + 0.5, 0.02))+\n                texture(iChannel0, rotate(uv, pivot + 0.5, .03)) +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .04)) +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .05)) +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .06)) +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .07)) +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .08)) +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .09)) +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .1))  +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .2))  +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .3))  +\n                texture(iChannel0, rotate(uv, pivot + 0.5, .4))\n        \n        ;\n        \n        fragColor = vec4(COLOR/12.0); // Output to screen\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 69, 69, 214], [216, 216, 273, 273, 1313]], "test": "untested"}
{"id": "msfSzs", "name": "Magma blue", "author": "Issam_X_Mhadhbi", "description": "itial magma", "tags": ["magma"], "likes": 2, "viewed": 142, "published": 3, "date": "1669389187", "time_retrieved": "2024-07-30T16:17:11.324252", "image_code": "const vec2 vp = vec2(320.0, 200.0);\n\n\n\nconst float pi = 3.1415926435;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime * 10.0 + iMouse.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p0 = (uv - 0.5) * vp;\n    vec2 hvp = vp * 0.5;\n\tvec2 p1d = vec2(cos( t / 98.0),  sin( t / 178.0)) * hvp - p0;\n\tvec2 p2d = vec2(sin(-t / 124.0), cos(-t / 104.0)) * hvp - p0;\n\tvec2 p3d = vec2(cos(-t / 165.0), cos( t / 45.0))  * hvp - p0;\n    float sum = 0.5 + 0.5 * (\n\t\tcos(length(p1d) / 30.0) +\n\t\tcos(length(p2d) / 20.0) +\n\t\tsin(length(p3d) / 25.0) * sin(p3d.x / 20.0) * sin(p3d.y / 15.0));\n \n    float i = fragCoord.x / iResolution.x;\n    vec3 ti = (iTime + iMouse.y) / vec3(63.0, 78.0, 45.0);\n    vec3 csi = cos(i * pi * 2.0 + vec3(0.0, 1.0, -0.5) * pi + ti);\n    vec3 colorx = normalize(vec3(vec3( 255, 87, 51 )));\n    fragColor = vec4(fract(sum)*2.0*colorx, 1)+ 0.5 ; \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 130, 130, 891]], "test": "untested"}
{"id": "dssXzX", "name": "game of life with lineage", "author": "Dirk", "description": "Simple implementation of the game of life with a buffer layer for baking an oscillating color heatmap.", "tags": ["gameoflife", "heatmap", "lineage"], "likes": 4, "viewed": 226, "published": 3, "date": "1669385801", "time_retrieved": "2024-07-30T16:17:12.162012", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 life = texture(iChannel0, uv);\n    vec4 ancestors = texture(iChannel1, uv);\n    vec3 final = life.xyz+ancestors.xyz;\n    \n    \n    \n\tfragColor = vec4(final, 1.0);\n\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    float neighbors = 0.0;\n    \n    for(float i = -1.0; i <= 1.0; i += 1.0){\n        for( float j = -1.0; j <= 1.0; j += 1.0){\n        \tvec2 offset = vec2(i, j) / iResolution.xy;\t\t \n        \tvec4 lookup = texture(iChannel0, uv + offset); \n        \tneighbors += lookup.x;\t\t\t\t\t\t\t \n        }\n    }\n    \n    float cell = texture(iChannel0, uv).x;\n    if(cell > 0.0) {\n        if(neighbors >= 3.0 && neighbors <= 4.0) { color = vec3(1.0); }\n    }else\n    if(neighbors > 2.0 && neighbors < 4.0) { color = vec3(1.0); }\n    \n    if(iTime < 0.05) { color = vec3(texture(iChannel1, fragCoord.xy / iResolution.xx).x); }\n    \n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bionary = texture(iChannel0, uv);\n    vec4 color = texture(iChannel1, uv);\n    \n    \n    if(bionary.x == 1.0){\n        color.x += 0.02*abs(sin(iTime*0.5));\n        color.y += 0.02*abs(sin(iTime*0.55));\n        color.z += 0.02*abs(sin(iTime*0.6));\n    }else{\n        color.x -= 0.0005*abs(sin(iTime*0.5));\n        color.y -= 0.0005*abs(sin(iTime*0.55));\n        color.z -= 0.0005*abs(sin(iTime*0.6));\n    }\n    if( color.x > 0.1 ) color.x -= 0.01*sin(iTime*0.52);\n    if( color.y > 0.1 ) color.y -= 0.01*sin(iTime*0.56);\n    if( color.z > 0.1 ) color.z -= 0.01*sin(iTime*0.59);\n    \n\tfragColor = vec4(color.xyz, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 274]], "test": "untested"}
{"id": "ddlSzX", "name": "Triangulated Spiral Pattern", "author": "Shane", "description": "Reproducing a common op-art inspired triangulated spiral pattern.", "tags": ["triangle", "spiral", "optical", "pattern", "polar", "art"], "likes": 36, "viewed": 434, "published": 3, "date": "1669378715", "time_retrieved": "2024-07-30T16:17:13.362801", "image_code": "/*\n\n    Triangulated Spiral Pattern\n    ---------------------------\n    \n    This is a pretty common op-art related tessellated spiral pattern -- or \n    double spiral pattern, if you prefer. It's a pretty simple variation, but \n    there are other far more interesting ones out there. There'd be cleverer \n    ways to produce it, and I'm sure the code golf crowd could make a much more \n    concise version. However, I took a direct approach and used a triangle grid, \n    which was converted to polar coordinates.\n    \n    For anyone not familiar with the geometric double spiral trick, you take a \n    regular circular pattern, then shift the top and bottom halves by a radial \n    cell unit.\n    \n    I happen to like the flat shaded black and white op-art look, but figured \n    I should at least attempt to lift the pattern a bit, so added highlights \n    and a splash of color. Grey tones with a splash of color is a design cliche, \n    but it saves having to think of color combinations to use. :)\n    \n    \n    Other examples:\n    \n    // Another polar black and white pattern. The spiral is cleverly\n    // created via optical illusion.\n    entangled circles - FabriceNeyret2\n    https://www.shadertoy.com/view/cdsXRX\n    \n    // A more interesting black and white op-art example.\n    drain vortex marching-less - FabriceNeyret2\n    https://www.shadertoy.com/view/ws23D3\n    \n*/\n\n\n// Shifting upper and lower halves to create the spiral pattern.\n// Commenting this out will display a regular polar pattern.\n#define SPIRAL\n\n// Use highlighting. Commenting it out will display the flat shaded \n// pattern -- Depending on the situation, sometimes that is preferable.\n#define HIGHLIGHT\n\n// Add the colorful blinking lights.\n#define BLINK\n\n// Rounded spiral, as opposed to straight edge sections.\n#define ROUND\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// IQ's vec2 to float hash formula. I remember coming across a discussion regarding\n// the origins of this formula, but have since forgotten. However, it was definitely\n// popularized by people like IQ, the authors of \"The Book of Shaders\", etc.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.617, 57.643)))*43758.5453); }\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n\n\tvec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nvec2 scale = vec2(1./18., 1./6.);//vec2(1./8., 1./1.);\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(length(vec2(1./3., 1)), 1))*scale;\n    //vec2 rect = (vec2(1, 1))*scale.x;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale.y; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    // Base on the bottom (1.) or upside down (-1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = vec2[3](vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = vec2[3](vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float iRes = iResolution.y;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iRes;\n \n    // Falloff factor: Sometimes,  we might have to use \"fwidth(d),\" \n    // a numeric solution, or use a constant.\n    float sf = 1./iRes; \n    \n    // Scaling (trivial, in this case) and rotation.\n    vec2 p = r2(iTime/16.)*uv;\n    \n    // Coordinate perturbation.\n    //p += sin(p*3.35 + cos(p.yx*5. + iTime)*1.57)*.004;\n    \n    // Concave warping.\n    //p *= (1.05 - dot(uv, uv)*.1);\n    \n    \n    vec2 ld = normalize(vec2(-1, -1));  // Light direction.\n    //ld *= r2(-iTime/16.); // Rotating the light to match, if desired.\n    \n    \n     // Radial rings.\n    const float rNum = 6.;\n      \n    \n    #ifdef SPIRAL\n    // If you're not aware of the geometric spriral trick, you simply shift \n    // the lower (or upper) half of a polar pattern along one radial unit.\n    // Omitting this will give you a regular polar pattern again.\n    float yDir = p.y<0.? -1. : 1.;\n    p.x -= yDir*length(vec2(1./3., 2))/rNum/4.; \n    #endif\n \n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    // Only 18 will work at present, but I'm pretty sure other numbers working\n    // when I first put this together... I'll take a look later.\n    const float CELL_NUM = 18.;\n    float na = floor(a/6.2831853*CELL_NUM);\n    // Partitioning the angle into the number of cells.\n    float ia = (na + .5)/CELL_NUM;\n \n  \n    // Converting square coordinates to polar ones. I.e. Angular and radial.\n    // Technically, the above statement isn't entirely correct, since we're \n    // merely rotating plane coordinates in a fan shape to create wedges, but\n    // it's similar.\n    p *= r2(ia*6.2831853);\n     \n    // Transforming the lighting to match above.\n    ld *= r2(ia*6.2831853);\n    \n    #ifdef ROUND\n    // At present, the coordinates are still in square form, so this hack will\n    // round things off... There are other ways to do this.\n    p.x = length(p); // Circular coordinates.\n    #endif\n \n    // Radial region number. Only used for debugging below.\n    float iR = floor(p.x/scale.y); \n \n    // Triangle IDs and vertices.\n    vec2[3] vID, v;\n    \n    \n     // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    //scale = 1./2.5; //1./2.\n    vec4 p4 = getTriVerts(p.yx, vID, v);//vec2(a/6.2831*ir, p.x)//r2(3.14159/CELL_NUM)*\n    p = p4.xy;\n    \n    \n    // Triangle distance, and a nearby sample for highlighting.\n    float tri = sdTri(p, v[0], v[1], v[2]);\n    float triHi = sdTri(p - ld.yx*.001, v[0], v[1], v[2]);\n    //float tri = length(p) - .02;\n    //float triHi = length(p - ld.yx*.001) - .02;\n    \n    // Bump highlights from either direction. It's a cheap way to add\n    // two colored lights from opposing directions.\n    float b = max(triHi - tri, 0.)/.001;\n    float b2 = max(tri - triHi, 0.)/.001;\n    \n    // Variable to determine alternate cells... Only useful for even cell numbers.\n    float dir = mod(na, 2.)<.5? -1. : 1.;  \n  \n    \n    // Triangle color.\n    vec3 tCol = vec3(.9, .95, 1);\n    // Multicolored.\n    //vec3 tCol = .6 + .4*cos(6.2831*hash21(p4.zw + na + dir*iR*128.) + vec3(0, 1, 2)*1.5);\n     \n    #ifdef BLINK\n    // Randomly highlihgt cells in a blinking fashion. If you want to animate something\n    // bland, but aren't sure what to do, this can sometimes help. \n    float rnd = hash21(p4.zw + na + dir*iR*128.);\n    float blink = smoothstep(.96, .985, sin(6.2831*rnd + mod(iTime, 6.2831))*.5 + .5);\n    //\n    if(gTri*dir>0.) tCol = mix(tCol, tCol*vec3(3, .9, .35), blink); // White cells turn orange.\n    else tCol = mix(tCol, tCol*vec3(1.25, 1, .75), blink); // Slight highlighting for dark cells.\n    \n    // Gradient coloring.\n    tCol = mix(tCol, tCol.xzy, max(-uv.y, 0.));\n    #endif\n \n    // Highlight color.\n    #ifdef HIGHLIGHT\n    vec3 lCol = vec3(.3, .6, 1)*b*b + vec3(1, .6, .2)*b2*b2;\n    #else \n    vec3 lCol = vec3(.66); // No highlights.\n    if(gTri*dir<0.) lCol *= .4; // Make the dark a bit darker.\n    #endif\n    \n    // Applying the highlight colors to the triangle.\n    tCol = tCol*(.65 + lCol*.5);\n    \n    // Rendering alternate triangles in a darker color. You don't have to do this,\n    // but the pattern doesn't look as interesting without it.\n    if(gTri*dir<0.) tCol = tCol/4.*(.35 + lCol);\n    \n    // Region debug.\n    //if(iR == 0.) tCol *= vec3(.8, 1.5, .4);\n  \n    \n    \n    // Apply the triangles to the canvas.\n    vec3 col = mix(vec3(.05), tCol, 1. - smoothstep(0., sf, tri + .02*scale.y));\n    #ifdef HIGHLIGHT\n    // Edge shading for some subtle faux ambient occlusion.\n    float shF = iResolution.y/450.; // Resolution shadow width factor.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*shF*4., abs(tri)))*.35);\n    #endif\n    \n    // Vignette.\n    // Using IQ's box formula to produce a more configurable border overlay.\n    // Equivalent to: float bord = sBox(uv, vec2(iResolution.x/iResolution.y, 1)/2.);\n    vec2 d = abs(uv) - vec2(iResolution.x/iResolution.y, 1)/2.;\n    float bord = min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n    col = mix(col, vec3(.3, .6, 1)/8., (1. - smoothstep(0., .05, abs(bord)))*.5);\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1818, 1851, 1871, 1871, 1929], [1931, 2177, 2198, 2198, 2260], [2263, 2305, 2364, 2364, 2939], [3162, 3225, 3253, 3253, 3283], [3285, 3350, 3380, 3380, 3419], [5992, 6020, 6067, 6067, 6156]], "test": "untested"}
{"id": "cdfSzl", "name": "Monorail", "author": "dr2", "description": "Monorail track based on generalized hexagonal Truchet tiles (mouseable, multiple views)", "tags": ["truchet", "train", "track", "monorail"], "likes": 26, "viewed": 359, "published": 3, "date": "1669365361", "time_retrieved": "2024-07-30T16:17:14.483804", "image_code": "// \"Monorail\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_CAR 5   // any reasonable value\n#define PLEN 17\n\nvec4 cPath[PLEN], carPos[N_CAR];\nvec3 qHit, sunDir;\nvec2 cId, cMid;\nfloat dstFar, tCur, gSize, tEnd[PLEN + 1], tLen, trVel, cDir, cType, gHt, bHt, trSzFac;\nint idObj;\nconst int idGrnd = 1, idFenc = 2, idRail = 3, idSup = 4, idBld = 5, idMast = 6, \n   idWhl = 7, idCar = 8;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{ // (from \"Forest Train Ride\")\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cId.x - cId.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = sign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cId.x - cId.y;\n  cyo = (mod (cId.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. || \n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n  return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * gSize;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / trSzFac;\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    d = abs (SmoothMax (PrRoundBox2Df (q.xz, vec2 (0.3, 1.1), 0.4), abs (q.y) - 0.7, 0.1)) - 0.02;\n    d = max (d, - min (PrBox2Df (vec2 (q.x, q.y - 0.25), vec2 (0.4, 0.25)),\n       PrBox2Df (vec2 (abs (q.z) - 0.5, q.y - 0.25), vec2 (0.4, 0.25))));\n    DMINQ (idCar + k);\n    q.z = abs (q.z);\n    q.yz -= vec2 (1.19, 0.6);\n    d = max (max (PrCaps2Df (q.zy, 0.12, 0.9), max (abs (q.x) - 0.13, -0.5 - q.y)),\n       max (min (0.07 - abs (q.x), 0.4 - abs (q.y)), min (0.22 - abs (q.y - 0.7), 0.07 - q.x)));\n    DMINQ (idMast);\n    q.xy -= vec2 (0.02, 0.85);\n    d = PrCylDf (q.yzx, 0.11, 0.12);\n    DMINQ (idWhl);\n  }\n  return dMin * trSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / trSzFac;\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    d = max (PrRoundBox2Df (q.xz, vec2 (0.3, 1.1), 0.4), abs (q.y) - 0.6);\n    DMIN (0);\n  }\n  return dMin * trSzFac;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid SetGConf ()\n{\n  float h, cxy;\n  cMid = HexToPix (cId * gSize);\n  h = Hashfv2 (cId);\n  if (Hashfv2 (17.11 * cId) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cId.x - cId.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cId.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cId.x, 2.) - 1.;\n  }\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 b;\n  float dMin, d, dt, dWid, eWid, rc, ac, dh, h, a;\n  bool onTrk;\n  dWid = 0.3;\n  eWid = 0.1;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    q.xz = (q.xz - cMid) / gSize;\n    cm3 = TruchSDist (q.xz);\n    dt = gSize * abs (cm3.x);\n    rc = abs (cm3.y);\n    ac = 18. * cm3.z;\n    dh = gSize * HexEdgeDist (q.xz);\n    onTrk = (cType <= 2. && rc != 0. && OnTrk (q.xz));\n    if (onTrk) {\n      a = (fract (3. * rc * ac + 0.5) - 0.5) / 3.;\n      d = PrRoundBox2Df (vec2 (dt, q.y - 0.4), vec2 (0.002, 0.01), 0.001);\n      DMIN (idRail);\n      if (cm3.y < 0.) {\n        b = vec2 (dt - 0.18, q.y - 0.4);\n        d = max (min (min (max (abs (b.x - 0.002) - 0.008, b.y), max (abs (b.y) - 0.006,\n           b.x - 0.01)), max (abs (dot (b, sign (0.25 * pi + vec2 (0.5 * pi, 0.))) + \n           0.05) - 0.005, Maxv2 (b))), abs (a) - 0.0013);\n        d = min (d, max (max (abs (b.x) - 0.02, abs (a) - 0.004), q.y - 0.03));\n        DMIN (idSup);\n      }\n      if (abs (cm3.y) == 1.5 || cm3.x > 0.) {\n        d = max (PrBox2Df (vec2 (dt - dWid - 0.75, fract (rc * ac + 0.5) - 0.5),\n           vec2 (0.2, 0.2)), q.y - ((cm3.y > 0.) ? 4. : 2.) * bHt - gHt);\n        DMIN (idBld);\n      }\n      d = min (length (vec2 (dt - dWid, q.y - 0.1)) - 0.008,\n         max (PrRoundBox2Df (vec2 (dt - dWid, (fract (10. * rc * ac + 0.5) - 0.5) / 10.),\n         vec2 (0.007, 0.002), 0.001), q.y - 0.1));\n      d = max (d, eWid - dh);\n      DMIN (idFenc);\n    }\n    d = q.y - gHt;\n    h = PrBox2Df (vec2 (dh, q.y - gHt), vec2 (eWid, 0.01));\n    if (onTrk) h = min (h, min (PrBox2Df (vec2 (dt, q.y - gHt), vec2 (dWid - 0.1, 0.01)),\n       PrBox2Df (vec2 (abs (abs (dt - 1.05) - 0.3), q.y - gHt), vec2 (0.05, 0.01))));\n    d = SmoothMax (d, - h, 0.01);\n    DMIN (idGrnd);\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = gSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / gSize;\n  pM = HexToPix (PixToHex (ro.xz / gSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    cId = PixToHex (p.xz / gSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetGConf ();\n    }\n    d = GObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    cId = PixToHex (p.xz / gSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetGConf ();\n    }\n    h = GObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > gSize) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 GroundCol (vec3 p, inout vec2 vf)\n{\n  vec4 col4, gCol;\n  vec3 cm3;\n  vec2 w;\n  float dt, rc, ac;\n  gCol = vec4 (0.1, 0.5, 0.1, 0.1);\n  if (p.y < 0.024) {\n    col4 = mix (vec4 (0.5, 0.55, 0.5, 0.), gCol, smoothstep (0., 0.2,\n       abs (Rot2D (p.xz, pi / 3.).x) / (5. * gSize) - 1.));\n    vf = vec2 (64., 1.);\n  } else {\n    col4 = gCol * (0.7 + 0.3 * Fbm2 (0.5 * p.xz));\n    vf = vec2 (32., 2.);\n  }\n  w = (p.xz - cMid) / gSize;\n  cm3 = TruchSDist (w);\n  dt = gSize * abs (cm3.x);\n  rc = abs (cm3.y);\n  ac = 18. * cm3.z;\n  if (cType <= 2. && rc != 0. && OnTrk (w)) {\n    if (dt < 0.025 && step (0.3, abs (fract (16. * rc * ac + 0.5) - 0.5)) > 0.)\n       col4 = vec4 (0.5, 0.5, 0.4, 0.);\n  }\n  return col4;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rs, cm3, roo;\n  vec2 vf;\n  float dstObj, dstObjB, dstTrObj, sh, dt, rc, ac;\n  int idObjB;\n  bool isLit;\n  vf = vec2 (0.);\n  roo = ro;\n  dstObjB = GObjRay (ro, rd);\n  idObjB = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObjB < dstObj) {\n    dstObj = dstObjB;\n    idObj = idObjB;\n  }\n  isLit = false;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjB) {\n      cId = PixToHex (ro.xz / gSize);\n      SetGConf ();\n      vn = GObjNf (ro);\n    } else {\n      vn = ObjNf (ro);\n    }\n    if (idObj == idRail || idObj == idBld || idObj == idSup) {\n      cm3 = TruchSDist ((ro.xz - cMid) / gSize);\n      dt = gSize * abs (cm3.x);\n      rc = abs (cm3.y);\n      ac = 18. * cm3.z;\n    }\n    if (idObj == idFenc) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.) * (0.5 + 0.5 * smoothstep (0., 0.001,\n           abs (fract (3. * rc * ac + 0.5) - 0.5) - 0.001));\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.6, 0.6, 0.65, 0.);\n      if (abs (dt - 0.183) < 0.01 && ro.y < 0.395 && ro.y > 0.03)\n         col4 *= 0.8 + 0.2 * step (0.1, abs (fract (128. * ro.y + 0.5) - 0.5));\n    } else if (idObj == idBld) {\n      col4 = vec4 (HsvToRgb (vec3 (Hashfv2 (19.11 * cId), 0.2, 0.9)), 0.) * (0.8 +\n         0.2 * smoothstep (0., 0.002, abs (fract ((ro.y + 0.5 - gHt) / bHt) - 0.5) - 0.02));\n      if (abs (fract ((ro.y - gHt - 0.01) / bHt) - 0.5) < 0.15 &&\n         min (abs (fract (24. * rc * ac + 0.5) - 0.5) - 0.15,\n         abs (abs (dt - 1.05) - 0.07) - 0.02) < 0.) col4 = vec4 (0.3, 0.2, 0., -1.);\n      else vf = vec2 (128., 0.2);\n    } else if (idObj == idGrnd) {\n      col4 = GroundCol (ro, vf);\n    } else if (idObj == idMast) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.1);\n    } else if (idObj == idWhl) {\n      col4 = vec4 (0.5, 0.5, 0.6, 0.1);\n    } else if (idObj >= idCar) {\n      col4 = vec4 (HsvToRgb (vec3 (float (idObj - idCar) / float (N_CAR), 0.8, 1.)), 0.2);\n      col4 = (qHit.y < 0.65) ? col4 : vec4 (0.7, 0.7, 0.75, 0.2) * (0.95 +\n         0.05 * step (0.1, abs (fract (8. * qHit.x + 0.5) - 0.5)));\n      if (max (PrRoundBox2Df (qHit.xz, vec2 (0.3, 1.1), 0.4), abs (qHit.y) - 0.7) < -0.01)\n         col4 *= 0.5;\n      else if (abs (qHit.y + 0.2) < 0.05) col4 *= 0.8;\n      else if (length (vec2 (qHit.x, qHit.y + 0.4)) < 0.15) {\n        if (ShowInt (vec2 (qHit.x - 0.13 * sign (qHit.z), qHit.y + 0.46),\n           0.25 * vec2 (sign (qHit.z), 0.5), 2.,\n           float (idObj - idCar + 31)) != 0.) col4 = vec4 (vec3 (0.8), -1.);\n        else col4 *= 0.8;\n      }\n      if (abs (qHit.y) < 0.6 && abs (qHit.z) < 1.) col4 *= 0.5 + 0.5 * smoothstep (0., 0.001,\n         min (abs (abs (abs (qHit.z) - 0.5) - 0.5) - 0.03, abs (abs (qHit.y) - 0.6) - 0.015));\n    }\n    if (col4.a >= 0.) {\n      rs = ro + 0.01 * vn;\n      sh = min (ObjSShadow (rs, sunDir), GObjSShadow (rs, sunDir));\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      isLit = true;\n    } else {\n      col = col4.rgb * (0.2 + 0.8 * max (- dot (rd, vn), 0.));\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    vn = vec3 (0., 1., 0.);\n    col4 = 0.8 * vec4 (0.1, 0.5, 0.1, 0.);\n    sh = 1.;\n    isLit = true;\n  } else {\n    col = SkyCol (rd);\n  }\n  if (isLit) {\n    col = col4.rgb * (0.3 + 0.2 * max (- dot (sunDir, vn), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    col = mix (col, SkyCol (rd), 1. - exp (min (0., 1. - 5. * dstObj / dstFar)));\n  }\n  dstTrObj = TrObjRay (roo, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro = roo + dstTrObj * rd;\n    vn = TrObjNf (ro);\n    col = mix (0.8 * col, SkyCol (reflect (rd, vn)), 0.3 +\n       0.6 * pow (1. - abs (dot (vn, rd)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  3\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd, pAv;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, pc[3];\n  float el, az, zmFac, asp, sr, t, cGap, nc;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  gSize = 8.;\n  gHt = 0.03;\n  bHt = 0.2;\n  SetPath ();\n  trSzFac = 0.1;\n  trVel = 0.2;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az -= 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  cGap = 0.3;\n  pAv = vec3 (0.);\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    t = (tCur + 30.) * trVel - float (k) * cGap;\n    for (int j = VAR_ZERO; j < 3; j ++)\n       pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * 0.06 : 0.));\n    carPos[k].xz = pc[0];\n    carPos[k].y = 0.22;\n    pAv += carPos[k].xyz;\n    vd.xz = pc[2] - pc[1];\n    carPos[k].w = 0.5 * pi - atan (vd.z, vd.x);\n  }\n  nc = float (N_CAR);\n  pAv /= nc;\n  t = (tCur + 30.) * trVel;\n  if (vuId == 0 || vuId == 3) {\n    if (uv.x / asp > -1.+ 2. * SmoothBump (0.25, 0.75, 0.01, fract (0.025 * tCur)))\n       vuId = 3 - vuId;\n    ro.xz = EvalPPos (t - ((vuId == 0) ? nc + 0.5 : -1.5) * cGap);\n    ro.x += 0.1;\n    ro.y = (vuId == 0) ? 0.2 : 0.5;\n    vd = normalize (((vuId == 0) ? carPos[N_CAR - 1].xyz : carPos[0].xyz) - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += asin (vd.y);\n    el = clamp (el, -0.15 * pi, 0.15 * pi);\n    zmFac = 3.5;\n    dstFar = 12. * gSize;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 30., (-3. * sqrt3 + (2. / tLen) * t) * gSize);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x += 1.6 * gSize;\n    az += pi / 3.;\n    el -= 0.2 * pi;\n    el = clamp (el, -0.4 * pi, -0.13 * pi);\n    zmFac = 3.;\n    dstFar = 40. * gSize;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 20., (-1.5 * sqrt3 + (2. / tLen) * t) * gSize);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x -= 1.5 * gSize;\n    vd = normalize (pAv - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 30.;\n    dstFar = 30. * gSize;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (-2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfSzl.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[1452, 1452, 1473, 1473, 1496], [1498, 1498, 1524, 1554, 2536], [2538, 2538, 2559, 2559, 3200], [3202, 3202, 3219, 3219, 4064], [4066, 4066, 4091, 4091, 4741], [4743, 4743, 4765, 4765, 5582], [5584, 5584, 5617, 5617, 5800], [5802, 5802, 5823, 5823, 6080], [6082, 6082, 6106, 6106, 6401], [6403, 6403, 6438, 6438, 6622], [6624, 6624, 6647, 6647, 6906], [6908, 6908, 6945, 6945, 7188], [7190, 7190, 7208, 7208, 7907], [7909, 7909, 7932, 7932, 9718], [9720, 9720, 9754, 9754, 10991], [10993, 10993, 11015, 11015, 11273], [11275, 11275, 11313, 11313, 11726], [11728, 11728, 11768, 11768, 12440], [12442, 12442, 12465, 12465, 12628], [12630, 12630, 12665, 12665, 16487], [16507, 16507, 16563, 16563, 20267], [20269, 20269, 20302, 20302, 20391], [20393, 20393, 20440, 20440, 20487], [20489, 20489, 20531, 20531, 20582], [20584, 20584, 20628, 20628, 20688], [20690, 20690, 20714, 20714, 20944], [20946, 20946, 20970, 20970, 21030], [21032, 21032, 21060, 21060, 21140], [21142, 21142, 21164, 21164, 21191], [21193, 21193, 21215, 21215, 21242], [21244, 21244, 21266, 21266, 21304], [21306, 21306, 21328, 21328, 21366], [21368, 21368, 21413, 21413, 21505], [21507, 21507, 21552, 21552, 21590], [21592, 21592, 21649, 21649, 21732], [21734, 21734, 21758, 21758, 21880], [21882, 21882, 21918, 21918, 22124], [22126, 22126, 22156, 22156, 22269], [22271, 22271, 22302, 22302, 22366], [22368, 22368, 22391, 22391, 22495], [22568, 22568, 22600, 22600, 23148], [23150, 23150, 23210, 23210, 23752], [23786, 23786, 23810, 23810, 23870], [23872, 23872, 23896, 23896, 24008], [24010, 24010, 24034, 24034, 24177], [24179, 24179, 24204, 24204, 24390], [24392, 24392, 24413, 24413, 24568], [24570, 24570, 24599, 24599, 24811], [24813, 24813, 24852, 24852, 25104]], "test": "untested"}
{"id": "dslSRf", "name": "[phreax] birth of the universe", "author": "phreax", "description": "Playing with spectral color and feedback\nUse the mouse to modulate the effect.\n\nAlso checkout the watercolor version my uncommenting line 12 ", "tags": ["fft", "spiral", "multipass", "zucconi"], "likes": 14, "viewed": 462, "published": 3, "date": "1669341298", "time_retrieved": "2024-07-30T16:17:15.550950", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30627, "src": "https://soundcloud.com/tycho/into-the-woods?si=f75f3cd81732472394d176eade07d309&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU 2.*PI\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define SIN(x) (sin(x)*.5+.5)\n#define BEND .8     \n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define COUNT 100.\n#define DISTORT 2.\n#define COLOR 1.\n#define SPIRAL 3.\n#define S(a, b, x) smoothstep(a, b, x)\n\n//#define WATERCOLOR\n//#define TUNNEL\n#define FFT 0.\n\n\nfloat tt, bass;\n\n\nfloat bassFFT() {\n    int bandLimit = 5;\n    \n    float avg = 0.;\n    for(int i=0; i<bandLimit; i++) {\n        avg += texelFetch(iChannel1, ivec2(i, 0), 0).x;\n    }\n    return avg/float(bandLimit);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\nfloat triangle(vec2 uv, float w, float blur) {   \n  int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulate the distance\n  float d = 1.-cos(floor(.5+a/r)*r-a)*length(uv);\n  return smoothstep(blur, .0, abs(d)-w)*(0.3/blur);\n}\n\nvec3 spiral(vec2 uv, float z) {  \n\n    float spiralAmp = (3.*SIN(.5*PI+iMouse.y/360.*2.*PI));\n    \n    uv *= rot((z*TAU-.2*tt)*spiralAmp);\n    \n    #ifdef TUNNEL\n    uv.y += 1.7*sin(.4*z+2.4*tt);\n    uv.x -= .9*sin(.3*z+1.8*tt);\n    #endif\n    float soundMod = bass*FFT*(3.*sqrt(z)+.2);\n    float dist = DISTORT * sin(.25*PI+iMouse.x/640.*2.*PI+soundMod);\n\n    uv += dist*sin(vec2(5)*uv.yx+.2*tt);//.3*pow(sin(.2*tt+z+uv.x), 2.);\n\n    float blur = exp(-19.*z);\n    float luma = exp(-19.5*z);\n    vec3 col = spectral_zucconi6(fract(2.*z+.2*tt+uv.x*.2+bass*sqrt(z)*2.*FFT))*.8;\n    \n\n    \n    float size = .05;\n    return triangle(uv, size, blur)*luma*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec4 tex = texture(iChannel0, fragCoord/iResolution.xy);\n    if (tex.a != iResolution.x) tex = vec4(0);\n    tt = iTime*.2;\n    \n    bass = bassFFT();\n\n    uv *= 100.;\n\n    float s = 1./COUNT; \n    \n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        float fade = smoothstep(1., .9, z);\n        vec2 UV = uv;\n        col += spiral(UV*z, z)*fade;\n        \n    }\n    col = pow(col, vec3(0.5));\n    #ifdef WATERCOLOR\n    col = 1.05-col;\n    col = pow(col, vec3(2.2));\n    col = clamp(col, vec3(0), vec3(1));\n    #endif\n    \n    col = mix(col, tex.rgb, 0.98);\n   \n    // Output to screen\n    fragColor = vec4(col, iResolution.x);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30563, "src": "https://soundcloud.com/tycho/into-the-woods?si=816dd2ba919b4d2e948f64aceda5cab1&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslSRf.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[87, 87, 144, 144, 277]], "test": "untested"}
{"id": "mslSRX", "name": "draw / backdraw / buffer", "author": "jonasfrey", "description": "use the mouse to draw!", "tags": ["draw"], "likes": 3, "viewed": 205, "published": 3, "date": "1669333691", "time_retrieved": "2024-07-30T16:17:16.753735", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this function simply animates the mouse movement\nvec2 f_o_anim_h(float n_t){\n    float n_parts = 3.0;\n    float n_part_quotient = 1./n_parts;\n    float n_t_modnor = mod(n_t, n_part_quotient) / n_part_quotient;\n    float n_index = floor(n_t / n_part_quotient);\n    \n    vec2[] a_o = vec2[](\n        vec2(0.0, n_t_modnor), \n        vec2(1.0, n_t_modnor), \n        vec2(n_t_modnor, 0.5)\n    );\n    \n    return a_o[int(n_index)]-vec2(0.5,0.5);\n}\nvec2 f_o_anim_e(float n_t){\n    float n_parts = 2.0;\n    float n_part_quotient = 1./n_parts;\n    float n_t_modnor = mod(n_t, n_part_quotient) / n_part_quotient;\n    float n_index = floor(n_t / n_part_quotient);\n    \n    float n_rad = 0.5;\n    float n_rot = 6.2831/4.;\n    float n_radia = 6.2831 * 0.9;\n    vec2[] a_o = vec2[](\n        vec2(sin(n_t_modnor*-n_radia+n_rot)*n_rad,cos(n_t_modnor*-n_radia+n_rot)*n_rad), \n        vec2(n_t_modnor-0.5, 0.0)\n    );\n    \n    return a_o[int(n_index)];\n}\nvec2 f_o_anim_l(float n_t){\n    float n_parts = 1.0;\n    float n_part_quotient = 1./n_parts;\n    float n_t_modnor = mod(n_t, n_part_quotient) / n_part_quotient;\n    float n_index = floor(n_t / n_part_quotient);\n\n    vec2[] a_o = vec2[](\n        vec2(0.5, n_t_modnor)\n    );\n    \n    return a_o[int(n_index)]-vec2(0.5);\n}\nvec2 f_o_anim_o(float n_t){\n    float n_parts = 1.0;\n    float n_part_quotient = 1./n_parts;\n    float n_t_modnor = mod(n_t, n_part_quotient) / n_part_quotient;\n    float n_index = floor(n_t / n_part_quotient);\n    float n_tau = 6.2831;\n    float n_rad = 0.5;\n    vec2[] a_o = vec2[](\n        vec2(sin(n_t_modnor*n_tau)*n_rad,cos(n_t_modnor*n_tau)*n_rad)\n    );\n    \n    return a_o[int(n_index)];\n}\nvec2 f_o_anim_exm(float n_t){\n    float n_parts = 2.0;\n    float n_part_quotient = 1./n_parts;\n    float n_t_modnor = mod(n_t, n_part_quotient) / n_part_quotient;\n    float n_index = floor(n_t / n_part_quotient);\n    float n_rad = 0.1;\n    float n_tau = 6.2831;\n    vec2[] a_o = vec2[](\n        vec2(0.0, 0.5-n_t_modnor*0.8),\n        vec2(sin(n_t_modnor*n_tau)*n_rad,cos(n_t_modnor*n_tau)*n_rad)+vec2(0.0, - 0.6)\n    );\n    \n    return a_o[int(n_index)];\n}\nvec2 f_o_mou_coo_nor(){\n    float n_rad = 0.2;\n    \n    float n_index = floor(iTime);\n    float n_t = fract(iTime);\n    vec2[] a_o = vec2[](\n        f_o_anim_h(n_t),\n        f_o_anim_e(n_t),\n        f_o_anim_l(n_t),\n        f_o_anim_l(n_t),\n        f_o_anim_o(n_t),\n        f_o_anim_exm(n_t)\n    );\n    vec2 o = a_o[int(n_index)];\n    float n_margin = 0.5;\n    o = (o+vec2(n_index+(n_margin*n_index)-(float(a_o.length())/2.0), 0.0))*0.1;\n    if(n_index > float(a_o.length())-1.){\n        o = vec2(sin(iTime)*0.5,cos(iTime)*0.5);\n    }\n    return o;\n    //vec2[] a_o_anim = vec2[] (\n    //    vec2()\n    //);\n    //return vec2(sin(iTime)*n_rad, cos(iTime)*n_rad);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o_pix_coo_nor = (fragCoord.xy - (iResolution.xy*0.5)) / iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy - (iResolution.xy*0.5)) / iResolution.y;\n    if(iMouse.w == 0.0){\n        o_mou_coo_nor = f_o_mou_coo_nor();\n    }\n    vec4 o_col_last = texture(iChannel0, uv);\n    \n    float n_dist = length(o_pix_coo_nor-o_mou_coo_nor);\n    float n_pen_size_nor = 0.005;\n    float n_dist_smoothstep = smoothstep(n_pen_size_nor+(n_pen_size_nor*2.), n_pen_size_nor, n_dist);\n    vec4 o_col_curr = vec4(n_dist_smoothstep);\n    \n    // by keeping only the higher color value we will overdraw everything\n    float n_max = max(o_col_curr.r, o_col_last.r);\n    \n    fragColor = vec4(n_max);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 213]], "test": "untested"}
{"id": "DssSzf", "name": "Sun in the sky", "author": "Issam_X_Mhadhbi", "description": "sun in the sky ", "tags": ["sun", "sky"], "likes": 4, "viewed": 162, "published": 3, "date": "1669323619", "time_retrieved": "2024-07-30T16:17:17.991426", "image_code": "float sunR = 0.05 ; \nvec3 sunColor = vec3(1.0,1.0,0.8) ; \nvec2 sunpos = vec2(0.5, 0.5  ) ; \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    sunpos  = sunpos*vec2(iResolution.x/iResolution.y,1.0) ; \n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p *vec2(iResolution.x/iResolution.y,1.0); \n    vec3 colorup = vec3(9,108,167) ; \n    vec3 colordown = vec3(250,242,239) ; \n    colordown = normalize(colordown) ;\n    colorup = normalize(colorup) ; \n    vec3 mixed = mix(colordown,colorup,p.y) ; \n    fragColor = vec4(mixed,1.0); \n    float distance_cubic = (uv.x - sunpos.x)*(uv.x - sunpos.x) + (uv.y - sunpos.y)*(uv.y - sunpos.y) ; \n    if (distance_cubic < sunR*sunR ){\n\n    \tfragColor = vec4(sunColor,1.0) ; \n    }\n    else{\n\n    \tfragColor = vec4(mix(mixed , sunColor, (sunR*sunR)/distance_cubic),1) ; \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 151, 151, 837]], "test": "untested"}
{"id": "DssXRf", "name": "Gradient Color // (OY)", "author": "Issam_X_Mhadhbi", "description": "create gradient color ", "tags": ["gradient"], "likes": 1, "viewed": 191, "published": 3, "date": "1669320478", "time_retrieved": "2024-07-30T16:17:18.811233", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0); \n    vec3 colorup = vec3(9,108,167) ; \n    vec3 colordown = vec3(250,242,239) ; \n    colordown = normalize(colordown) ;\n    colorup = normalize(colorup) ; \n    vec3 mixed = mix(colordown,colorup,p.y) ; \n    fragColor = vec4(mixed,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 392]], "test": "untested"}
{"id": "DdlSzX", "name": "luminance is late.", "author": "FabriceNeyret2", "description": "luminance is 8 frames late over chrominance.\n( see variant )", "tags": ["video", "delay"], "likes": 6, "viewed": 313, "published": 3, "date": "1669312346", "time_retrieved": "2024-07-30T16:17:19.634034", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n // O  = T0 * T1.a;             // variant: just reapply lum(t-8) \n    \n    O  = T0;\n    O *= T1.a / length(O.rgb);  // replace lum(t) with lum(t-8)\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = vec4( length( T0.rgb ) , T1 );\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R  iResolution.xy\n#define T0 texture(iChannel0, u/R )\n#define T1 texture(iChannel1, u/R )", "buffer_b_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = vec4( T0.a , T1 );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 105, 189]], "test": "untested"}
{"id": "cdsXRX", "name": "entangled circles", "author": "FabriceNeyret2", "description": "these are concentric circles.\nreference:  [url]  https://twitter.com/AkiyoshiKitaoka/status/1595731173850112000  [/url]", "tags": ["2d", "opticalillusion", "perception", "short", "golf", "reproduction", "3tweets"], "likes": 21, "viewed": 300, "published": 3, "date": "1669310611", "time_retrieved": "2024-07-30T16:17:20.632365", "image_code": "#define sS(a,v)   ( 2.* smoothstep( a, -a, (v)*R.y ) - 1. )                // signed smoothstep\n#define S(k)    sS( 2., abs( l - k*L - .01*L* sin(2.*a*6.28) ) - .007*L )  // sinusoidal circle\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, U = ( u+u - R ) / R.y;        // normalized coordinates     \n    float l = length(U),  a = 30.* atan(U.y,U.x)/ 6.283,    // polar coords\n          z = floor(2.*log2(l)), L = exp2(z/2.);            // circles radii\n    int(z)%2 < 1 ? a = -a : a;                              // alternate sin orientation\n    \n    O = vec4( .5 + .5* sS( 8./l, abs( fract(a)-.5 ) -.25 )  // rays\n                     * S( 1.1 ) * S( 1.2 )                  // pairs of circles\n            ) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cslSRX", "name": "lit", "author": "lomateron", "description": "click to interact\nkey W to reset\n.xy = velocity\n.z = mass\nBuffer A tab applies some convolution and the result is in .xy\nthis result is added to the velocity in Buffer B tab", "tags": ["fluid"], "likes": 37, "viewed": 439, "published": 3, "date": "1669306047", "time_retrieved": "2024-07-30T16:17:21.690535", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = (cos(length(a.xy)*-2.+vec4(0,1,2,4))*.5+.5)*a.z;\n    //fragColor = a.zzzz;\n    //fragColor = a;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        //r.xy += c*b.z*cos(dot(b.xy,c.yx*vec2(-1,1))*8.)*exp(-l*l*.2)*.5;\n        r.xy += c*min(b.z,0.)*cos(dot(b.xy,c.yx*vec2(-1,1))*16.)*exp(-l*l*.2)*.5;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy +B(u).xy;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j));\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j));\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/450.;\n        a += vec4(-normalize(m),0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        vec2 m = 22.*(u-iResolution.xy*.5)/450.;\n        a = vec4(0,0,.4,0)-vec4(0,2,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 245]], "test": "untested"}
{"id": "ddXSRf", "name": "pixel art font string", "author": "jonasfrey", "description": "still working on it \nfont taken from here\nhttps://opengameart.org/content/8x8-ascii-bitmap-font-with-c-source", "tags": ["pixel", "bitmap", "font"], "likes": 2, "viewed": 153, "published": 3, "date": "1669295407", "time_retrieved": "2024-07-30T16:17:22.546247", "image_code": "bool f_b_64bitchar_bitset(vec2 o_point, float n_char){\n    if(n_char == -1.){return false;}\n    //uint: an unsigned 32-bit integer\n    //only 32 bit numbers can be stored, thats why we need a modulo here\n    uint[] a_n_u32_charparts = uint[256] (2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,0u,0u,269488144u,4096u,5140u,0u,339612672u,5182u,940865552u,1064016u,1746282758u,24724u,2550400056u,39012u,4112u,0u,67373072u,4104u,538972168u,2064u,947664980u,84u,2081427456u,4112u,0u,528384u,1006632960u,0u,0u,4096u,135274560u,516u,1111630872u,6180u,269490192u,14352u,404767292u,32260u,404767292u,15426u,303306768u,4158u,1077805694u,15426u,1111360060u,15426u,135274622u,516u,1111245372u,15426u,2084717116u,15424u,1048576u,4096u,1048576u,528384u,102260736u,24600u,8257536u,126u,1612187136u,1560u,404759068u,2048u,958544896u,939801129u,1008998424u,16962u,572400158u,7714u,16851484u,7202u,572662302u,7714u,35521086u,15874u,35521086u,514u,956375580u,7202u,1115570754u,16962u,269488252u,31760u,538976312u,7202u,235541026u,8722u,33686018u,32258u,2460665474u,33410u,1380599362u,16994u,1145324600u,14404u,35529246u,514u,1145324600u,4208708u,169746974u,8722u,805848120u,14404u,269488382u,4112u,1111638594u,15426u,608322177u,6180u,2861728386u,33478u,404235330u,16932u,271074434u,4112u,135274622u,32260u,67372060u,7172u,268960770u,16416u,269488156u,7184u,5128u,0u,0u,32256u,0u,0u,4104u,0u,2084584448u,23650u,1111360002u,14918u,70778880u,14340u,1115439168u,23650u,2118269952u,15362u,470292480u,2056u,841744384u,471870498u,605815812u,9252u,269484048u,4112u,270008336u,235933712u,337904644u,13324u,134744072u,6152u,1516634112u,16962u,1282670592u,17476u,1111228416u,15426u,1178206208u,33701442u,1650196480u,1077967938u,1278476288u,1028u,402929664u,7200u,138151936u,6152u,1145307136u,22628u,1111621632u,6180u,2172715008u,26202u,608305152u,26136u,1145176064u,101191720u,272367616u,15368u,202115128u,14344u,269488144u,1052688u,808456220u,7184u,1275068416u,50u,2122219134u,32382u);\n    //if(o_point.x > 7. || o_point.y > 7.){return false;}\n    vec2 o_point_mod = floor(mod(o_point, 8.));\n    o_point_mod.y = 7.-o_point_mod.y;\n    float n_y_floor = floor(o_point_mod.y / 4.); // 4 = half height of 8 max height\n\n    float n_pixel_index = (o_point_mod.y * 8.) + o_point_mod.x;\n    float n_pixel_index_mod = mod(n_pixel_index, 32.);\n    uint b_bitset = \n        a_n_u32_charparts[int((n_char*2.)+(n_y_floor))] & (1u<<uint(n_pixel_index_mod));\n    return b_bitset > 0u;\n}\nbool f_b_64bitchar_bitset_string(\n    vec2 o_point,\n    float[5] a_n_char\n){\n    vec2 o_point_mod = floor(mod(o_point, 8.*float(a_n_char.length())));\n    float n_index_a_n_char = floor(o_point_mod.x / 8.);\n    \n    return f_b_64bitchar_bitset(o_point, a_n_char[int(n_index_a_n_char)]);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    fragCoord = floor(fragCoord *0.3);\n    \n    float _em = 33.,_dq = 34.,_ht = 35.,_dl = 36.,_pc = 37.,_as = 38.,_sq = 39.,_rbo = 40.,_rbc = 41.,_str = 42.,_pls = 43., eql = 44.,_mns = 45.,_dot = 46.,_sls = 47.,_0 = 48.,_1 = 49.,_2 = 50.,_3 = 51.,_4 = 52.,_5 = 53.,_6 = 54.,_7 = 55.,_8 = 56.,_9 = 57.,_dqt = 58.,_smc = 59.,_lt = 60.,_eql = 61.,_gt = 62.,_qm = 63.,_at = 64.,_A = 65.,_B = 66.,_C = 67.,_D = 68.,_E = 69.,_F = 70.,_G = 71.,_H = 72.,_I = 73.,_J = 74.,_K = 75.,_L = 76.,_M = 77.,_N = 78.,_O = 79.,_P = 80.,_Q = 81.,_R = 82.,_S = 83.,_T = 84.,_U = 85.,_V = 86.,_W = 87.,_X = 88.,_Y = 89.,_Z = 90.,_sbo = 91.,_sbc = 93.,_pow = 94.,usc_ = 95.,_btc = 96.,_a = 97.,_b = 98.,_c = 99.,_d = 100.,_e = 101.,_f = 102.,_g = 103.,_h = 104.,_i = 105.,_j = 106.,_k = 107.,_l = 108.,_m = 109.,_n = 110.,_o = 111.,_p = 112.,_q = 113.,_r = 114.,_s = 115.,_t = 116.,_u = 117.,_v = 118.,_w = 119.,_x = 120.,_y = 121.,_z = 122.,_cbo = 123.,_pip = 124.,_cbc = 125.,_tld = 126.;\n    fragColor = vec4(\n        float(\n            f_b_64bitchar_bitset_string(\n                fragCoord,\n                float[5](_i, -1., _a, _m, -1.)\n            )\n        )\n    );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3273, 3273, 3330, 3380, 4586]], "test": "untested"}
{"id": "msfXzX", "name": "windows tile mouse hover effect", "author": "jonasfrey", "description": "i cannot remember the effect exactly", "tags": ["preset"], "likes": 2, "viewed": 201, "published": 3, "date": "1669292752", "time_retrieved": "2024-07-30T16:17:23.458807", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy - iResolution.xy*0.5)/iResolution.y;\n    \n    if(iMouse.w == 0.){\n        o_mou_coo_nor = vec2(sin(iTime)*0.3, cos(iTime)*0.3);\n    }\n    //float n_freqs = o_mou_coo_nor.x*1000.0;\n    float n_subdivisions = 5.;\n    vec2 o_opcn_big = o_pix_coo_nor*vec2(n_subdivisions);\n    vec2 o_opcn_big_mod = fract(o_opcn_big);\n    vec2 o_opcn_big_floor = floor(o_opcn_big);\n    \n    vec2 o_mpcn_big = o_mou_coo_nor*vec2(n_subdivisions);\n    vec2 o_mpcn_big_mod = fract(o_mpcn_big);\n    vec2 o_mpcn_big_floor = floor(o_mpcn_big);\n    \n    float n_dist = length(o_mpcn_big_mod - o_opcn_big_mod);\n    float n_dist2 = length(o_mpcn_big - o_opcn_big);\n    float n_dist3 = length(o_pix_coo_nor - o_mou_coo_nor);\n    n_dist3 = pow(n_dist3, 0.5);\n    float n_inside = float(o_mpcn_big_floor == o_opcn_big_floor);\n    vec2 n_col_mask = o_mpcn_big_mod / n_subdivisions;\n    \n    \n    fragColor = vec4((1.-(n_dist3*n_subdivisions/2.))*n_inside);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1144]], "test": "untested"}
{"id": "mssXz2", "name": "2.5D Orange Trails", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 32, "viewed": 413, "published": 3, "date": "1669292322", "time_retrieved": "2024-07-30T16:17:24.493042", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define mlength(p) max(abs((p).x),abs((p).y))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    float t = iTime;\n    vec3 s = vec3(0);\n    float n = 45.;\n    float k = 4. / res.y;\n    vec2 p = 0.25 * vec2(cos(iTime), sin(iTime));\n    for (float i = 0.; i < n; i++) {\n        float io = 2. * pi * i / n;\n        float a = atan(uv.y, uv.x);\n        \n        // uncomment these and comment other uv stuff, looks cool\n        //uv *= 1. + 0.025 * cos(-5. * a + io + 1.5 * t);\n        //uv *= rot(0.0025 * t * i / n + 0.04 * cos(-a-4. * log(length(uv)) + 0.25 * io + t));\n        uv.x = (1. - i/n) * ouv.x + 0.05 * cos(0.5 * io + t);\n        uv.y = (1. - i/n) * ouv.y + 0.05 * sin(0.5 * io + 0.75 * t);\n        float sc = 10. + 0.2 * i;//exp(-0.1 * i);\n        vec2 ipos = floor(sc * uv) + 0.5;\n        vec2 fpos = fract(sc * uv) - 0.5;\n\n        float th = 0.5 + 0.5 * thc(4., 10. * ipos.x - 4. * t + 4. * io);\n        float th2 = 0.5 + 0.5 * thc(4., length(ipos) + 2. * t + 1.5 * io);\n\n        float d  = length(fpos-p);\n        float d2 = mlength(fpos-p);\n        float r2 = (0.5 + 0.5 * cos(io + t)) * th2;\n        float s2 = step(abs(d2 - 0.3 * r2), 0.02);\n        s = max(s, exp(-3. * r2) * (1.-r2) * i* smoothstep(-k, k, -abs(d-r2) + 0.01) / n);\n        \n        float v = mix(10., 40., th);\n        vec3 col2 = mix(vec3(0), vec3(1, 0.5,0.1), i/n);\n        vec3 col3 = mix(vec3(0), vec3(0,1,1), i/n);\n        s += .3*smoothstep(-k,k,-d+i/n * mix(0.12,0.05,th)) * col2;\n        s = max(s, exp(-v * d) * pow(i / n, 2.) * col2);\n        \n       // s = max(s, exp(-v * abs(d2-r2)) * pow(i/n,2.) * col3);\n       // s = max(s, r2 * s2 * pow(i/n,2.) * col3);\n    }\n    vec3 col = 0.05 + vec3(s);\n    col *= 1./cosh(length(ouv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 213, 213, 1974]], "test": "untested"}
{"id": "ddfXRX", "name": "Porter Robinson - Language Cover", "author": "MysteryPancake", "description": "Made a rough recreation of Porter Robinson's Language, pretty happy with how it turned out :)", "tags": ["procedural", "sound", "music", "audio", "language", "synthesis", "synth", "saw", "sawtooth", "gpusound", "supersaw", "chords", "unison", "porterrobinson"], "likes": 11, "viewed": 301, "published": 3, "date": "1669291872", "time_retrieved": "2024-07-30T16:17:29.705107", "image_code": "// From https://www.shadertoy.com/view/ltfSRr\nfloat message(vec2 uv) {\n\tuv -= vec2(1.0, 10.0);\n\tif ((uv.x < 0.0) || (uv.x >= 32.0) || (uv.y < 0.0) || (uv.y >= 3.0)) return -1.0;\n\tint i = 1, bit = int(exp2(floor(32.0 - uv.x)));\n\tif (int(uv.y) == 2) i = 928473456 / bit;\n\tif (int(uv.y) == 1) i = 626348112 / bit;\n\tif (int(uv.y) == 0) i = 1735745872 / bit;\n\treturn float(i - 2 * (i / 2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tif (iResolution.y < 2000.0) {\n\t\tfloat c = message(fragCoord / 8.0);\n\t\tif (c >= 0.0){\n\t\t\tfragColor = vec4(c);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    // Lens distortion, see https://www.shadertoy.com/view/stdcRf\n    vec2 uv = fragCoord / iResolution.xy;\n    const vec2 center = vec2(0.5);\n\tfloat dist = distance(uv, center);\n\tvec2 dir = uv - center;\n    float time = mod(iTime, SPB * LOOPS);\n    float beat = mod(time, SPB);\n\tfloat lens = time >= SPB * 32.0 ? 0.3 / beat : max(0.0, 0.75 - beat);\n    vec4 color = vec4(uv, 0.5, 0.0) * dist * lens;\n\tfragColor = texture(iChannel0, uv - dist * dir * lens) + color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "const float PI = 3.1415926;\nconst float TAU = 6.28318530;\n\n#define NOTE(note, start, end) if (time >= start * SPB && time < end * SPB) result += note;\n#define NOTE_SAW(note, start, end) NOTE(superSaw(noteFreq(note), time, voices, detune) * amplitude, start, end);\n#define NOTE_SINE(note, start, end) NOTE(superSine(noteFreq(note), time - start * SPB, voices, detune) * amplitude, start, end);\n#define NOTE_BASS(note, start, end) NOTE(sine(noteFreq(note), time - start * SPB, 0.0, fade) * amplitude, start, end);\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2((note - MIDIOFFSET) / 12.0);\n}\n\n// For sawtooth synths\nfloat saw(float freq, float time, float phase) {\n\treturn fract(phase + freq * time) * 2.0 - 1.0;\n}\n\n// For lead whistle\nfloat sine(float freq, float time, float phase, float fade) {\n\treturn sin(freq * (time + phase) * TAU) * exp(-fade * time);\n}\n\n// For cymbals\nvec2 noiseHit(float time, float fade) {\n\treturn (vec2(hash(time * 512.0), hash(time * 1024.0)) - 0.5) * exp(-fade * time);\n}\n\n// Multiple saws detuned to make a unison effect\nvec2 superSaw(float freq, float time, float voices, float detune) {\n    vec2 result = vec2(0.0);\n    // See https://www.shadertoy.com/view/mdlSRj\n    for (float i = -voices; i <= voices; i++) {\n        float frequency = freq + i * detune;\n        result.x += saw(frequency, time, hash(2.0 * i));\n        result.y += saw(frequency, time, hash(2.0 * i + 1.0));\n    }\n    return result / voices / 2.0;\n}\n\n// Multiple sines detuned to make a unison effect\nvec2 superSine(float freq, float time, float voices, float detune) {\n    vec2 result = vec2(0.0);\n    // See https://www.shadertoy.com/view/mdlSRj\n    for (float i = -voices; i <= voices; i++) {\n        float frequency = freq + i * detune;\n        result.x += sine(frequency, time, hash(2.0 * i) * PI, 1.5);\n        result.y += sine(frequency, time, hash(2.0 * i + 1.0) * PI, 1.5);\n    }\n    return result / voices / 2.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float Q) {\n    // Forgot to remap the hash to -1, 1, whoops\n    return sin(TAU * freq * fract(time)) * hash(time * Q);\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time, float freq) {\n    const float df = 512.0, dftime = 0.01;\n    float phase = TAU * (freq * time - df * dftime * exp(-time / dftime));\n    float body = sin(phase) * smoothstep(0.15, 0.0, time) * 2.0;\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.01, 0.0, time);\n    return body + click;\n}\n\n// Cheap snare or clap effect\nvec2 snare(float time, float freq, float fade) {\n    return noiseHit(time, fade) * abs(sin(freq * time * TAU));\n}\n\nvec2 leadBass(float time, float voices, float detune, float amplitude) {\n    time = mod(time, SPB * 16.0);\n    vec2 result = vec2(0.0);\n    NOTE_SAW(57.0, 0.0, 2.0);\n    NOTE_SAW(38.0, 0.0, 2.0);\n    NOTE_SAW(57.0, 2.5, 6.0);\n    NOTE_SAW(38.0, 2.5, 6.0);\n    NOTE_SAW(57.0, 6.5, 8.0);\n    NOTE_SAW(38.0, 6.5, 8.0);\n    NOTE_SAW(61.0, 8.0, 9.5);\n    NOTE_SAW(42.0, 8.0, 9.5);\n    NOTE_SAW(59.0, 9.5, 10.0);\n    NOTE_SAW(40.0, 9.5, 10.0);\n    NOTE_SAW(59.0, 10.5, 12.0);\n    NOTE_SAW(40.0, 10.5, 12.0);\n    NOTE_SAW(56.0, 12.0, 13.5);\n    NOTE_SAW(37.0, 12.0, 13.5);\n    NOTE_SAW(57.0, 13.5, 14.0);\n    NOTE_SAW(38.0, 13.5, 14.0);\n    NOTE_SAW(57.0, 14.5, 16.0);\n    NOTE_SAW(38.0, 14.5, 16.0);\n    return result;\n}\n\nvec2 leadChords(float time, float voices, float detune, float amplitude, float offset) {\n    time = mod(time, SPB * 16.0);\n    vec2 result = vec2(0.0);\n    \n    // Optimize since every 2nd note is the same\n    if (mod(time + SPB * offset, SPB) >= SPB * 0.5) {\n        result += superSaw(noteFreq(64.0), time, voices, detune) * amplitude;\n    }\n    \n    NOTE_SAW(66.0, 0.5, 1.0);\n    NOTE_SAW(66.0, 1.5, 2.0);\n    NOTE_SAW(66.0, 2.5, 3.0);\n    NOTE_SAW(66.0, 3.5, 4.0);\n    NOTE_SAW(69.0, 4.5, 5.0);\n    NOTE_SAW(69.0, 5.5, 6.0);\n    NOTE_SAW(69.0, 6.5, 7.0);\n    NOTE_SAW(69.0, 7.5, 8.0);\n    NOTE_SAW(69.0, 8.5, 9.0);\n    NOTE_SAW(68.0, 9.5, 10.0);\n    NOTE_SAW(68.0, 10.5, 11.0);\n    NOTE_SAW(68.0, 11.5, 12.0);\n    NOTE_SAW(73.0, 12.5, 13.0);\n    NOTE_SAW(66.0, 13.5, 14.0);\n    NOTE_SAW(66.0, 14.5, 15.0);\n    NOTE_SAW(66.0, 15.5, 16.0);\n    return result;\n}\n\nvec2 leadSine(float time, float voices, float detune, float amplitude) {\n    time = mod(time, SPB * 32.0);\n    vec2 result = vec2(0.0);\n    NOTE_SINE(88.0, 0.0, 1.5);\n    NOTE_SINE(100.0, 0.0, 1.5);\n    NOTE_SINE(93.0, 1.5, 7.0);\n    NOTE_SINE(81.0, 1.5, 7.0);\n    NOTE_SINE(102.0, 7.0, 8.0);\n    NOTE_SINE(90.0, 7.0, 8.0);\n    NOTE_SINE(88.0, 8.0, 9.5);\n    NOTE_SINE(100.0, 8.0, 9.5);\n    NOTE_SINE(85.0, 9.5, 11.0);\n    NOTE_SINE(97.0, 9.5, 11.0);\n    NOTE_SINE(92.0, 11.0, 12.5);\n    NOTE_SINE(80.0, 11.0, 12.5);\n    NOTE_SINE(93.0, 12.5, 13.5);\n    NOTE_SINE(81.0, 12.5, 13.5);\n    NOTE_SINE(90.0, 13.5, 16.0);\n    NOTE_SINE(78.0, 13.5, 16.0);\n    NOTE_SINE(88.0, 16.0, 17.5);\n    NOTE_SINE(100.0, 16.0, 17.5);\n    NOTE_SINE(81.0, 17.5, 23.0);\n    NOTE_SINE(93.0, 17.5, 23.0);\n    NOTE_SINE(90.0, 23.0, 24.0);\n    NOTE_SINE(102.0, 23.0, 24.0);\n    NOTE_SINE(88.0, 24.0, 25.5);\n    NOTE_SINE(100.0, 24.0, 25.5);\n    NOTE_SINE(85.0, 25.5, 28.0);\n    NOTE_SINE(97.0, 25.5, 28.0);\n    NOTE_SINE(88.0, 28.0, 29.0);\n    NOTE_SINE(100.0, 28.0, 29.0);\n    NOTE_SINE(90.0, 29.0, 29.5);\n    NOTE_SINE(102.0, 29.0, 29.5);\n    NOTE_SINE(81.0, 29.5, 32.0);\n    NOTE_SINE(93.0, 29.5, 32.0);\n    return result;\n}\n\nvec2 bass(float time, float fade, float amplitude) {\n    time = mod(time, SPB * 16.0);\n    vec2 result = vec2(0.0);\n    NOTE_BASS(38.0, 0.5, 1.0);\n    NOTE_BASS(38.0, 1.0, 1.5);\n    NOTE_BASS(38.0, 1.5, 2.0);\n    NOTE_BASS(38.0, 2.5, 3.0);\n    NOTE_BASS(38.0, 3.0, 3.5);\n    NOTE_BASS(38.0, 3.5, 4.0);\n    NOTE_BASS(38.0, 4.0, 4.5);\n    NOTE_BASS(38.0, 4.5, 5.0);\n    NOTE_BASS(38.0, 5.0, 5.5);\n    NOTE_BASS(38.0, 5.5, 6.0);\n    NOTE_BASS(38.0, 6.5, 7.0);\n    NOTE_BASS(38.0, 7.0, 7.5);\n    NOTE_BASS(38.0, 7.5, 8.0);\n    NOTE_BASS(42.0, 8.0, 8.5);\n    NOTE_BASS(42.0, 8.5, 9.0);\n    NOTE_BASS(42.0, 9.0, 9.5);\n    NOTE_BASS(40.0, 9.5, 10.0);\n    NOTE_BASS(40.0, 10.5, 11.0);\n    NOTE_BASS(40.0, 11.0, 11.5);\n    NOTE_BASS(40.0, 11.5, 12.0);\n    NOTE_BASS(37.0, 12.0, 12.5);\n    NOTE_BASS(37.0, 12.5, 13.0);\n    NOTE_BASS(37.0, 13.0, 13.5);\n    NOTE_BASS(38.0, 13.5, 14.0);\n    NOTE_BASS(38.0, 14.5, 15.0);\n    NOTE_BASS(38.0, 15.0, 15.5);\n    NOTE_BASS(38.0, 15.5, 16.0);\n    return result;\n}\n\nvec2 cymbals(float time, float amplitude) {\n    //vec2 pan = mod(time + STEP * 0.5, STEP * 2.0) > STEP ? vec2(0.5, 1.0) : vec2(1.0, 0.5);\n    vec2 pan = mod(time, SPB * 2.0) > SPB ? vec2(0.5, 1.0) : vec2(1.0, 0.5);\n    return noiseHit(mod(time + SPB * 0.5, SPB), 3.0) * amplitude * pan;\n}\n\n// For debugging\nvec2 metronome(float time) {\n    return vec2(sin(PI * 880.0 * time) * exp(-32.0 * time));\n}\n\nvec2 mainSound(int samp, float iTime) {\n    \n    float time = mod(iTime, SPB * LOOPS);\n    float beat = mod(time, SPB);\n    vec2 result = vec2(0.0);\n    float sidechain = 1.0;\n    \n    if (time >= SPB * 16.0) {\n        sidechain = 1.0 - exp(-6.0 * beat);\n        result += cymbals(time, 0.4);\n    }\n    \n    if (time >= SPB * 32.0) {\n        result += kick(beat, noteFreq(33.0)) * 0.4;\n        result += leadSine(time, 2.0, 4.0, 0.35);\n        result += snare(mod(time + SPB, SPB * 2.0), noteFreq(21.0), 4.0);\n        result += bass(time, 6.0, 0.6 * sidechain);\n    }\n    \n    if (time < SPB * 30.5 || time >= SPB * 32.0) {\n        result += leadBass(time, 1.0, 0.5, 0.4 * sidechain);\n    }\n    \n    // Make it more funky every 2nd loop\n    float funk = int(iTime / (SPB * LOOPS)) % 2 == 0 ? 0.5 : 0.0;\n    result += leadChords(time, 2.0, 0.5, 0.6 * sidechain, funk);\n    \n    //result += metronome(beat);\n    \n    return result;\n}", "sound_inputs": [], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float time = mod(iTime, SPB * LOOPS);\n    if (mod(time, SPB) < 0.05 || time >= SPB * 32.0) {\n        vec4 vid1 = texture(iChannel0, uv);\n        vec4 vid2 = texture(iChannel2, uv);\n        fragColor = mod(time * 0.5, SPB * 2.0) < SPB ? vid1 : vid2;\n    } else {\n        fragColor = texture(iChannel1, uv);\n    }\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float BPM = 128.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat\n\nconst float LOOPS = 96.0;\n\nconst float MIDIOFFSET = 69.0;", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 70, 70, 387], [389, 389, 444, 444, 1045]], "test": "untested"}
{"id": "DsXSRf", "name": "Rotational blur  ", "author": "axiomgraph", "description": "rotational blur", "tags": ["blur", "spin"], "likes": 4, "viewed": 271, "published": 3, "date": "1669265059", "time_retrieved": "2024-07-30T16:17:30.987678", "image_code": "const int samples =100;\n\n\nfloat gain = 1.0; // gain : (gain), min = 0., max = 50.\n\nfloat blur_x =50.0; // X blur : (X blur), min = 0, max = 1000.\nfloat blur_y = 50.0; // Y blur : (Y blur), min = 0, max = 1000.\n\n\n\nvec2 rotate(vec2 uv, vec2 p, float angle)\n{\n\tmat2 rotation = mat2(vec2(cos(angle), -sin(angle)),\n\t\t\t\t\t\tvec2(sin(angle), cos(angle)));\n\tuv -= p;\n\tuv = uv * rotation;\n\tuv += p;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat Angle = 22.0/-100.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 origin;\n    \n    \n    \nfloat precompute = Angle * (1.0 / float(samples - 1));\n    \n    \n\n   origin = vec2(iMouse.x,iMouse.y)/vec2(iResolution.x,iResolution.y); // position\n    vec4 color = vec4(0.0);\n    float ws = 0.0;\n    \n     vec2 center = vec2(0.5,0.5);\n\n\tfor(int i = 0; i <= samples; i++)\n    {\n        float p =  (float(i)* precompute);\n        float w = 1.0 ;\n       \n        color += texture(iChannel0, rotate(uv,origin, p)) * w;\n        ws += w;\n    }\n   \n\n\tfragColor = vec4(color.rgb / ws * gain, 1.0);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 256, 256, 401]], "test": "untested"}
{"id": "csXSRf", "name": "Regular Prism SDF - no exact!", "author": "SONENEIS", "description": "a regular prism sdf in raymarching.", "tags": ["ray", "raymarch", "sdf", "triangle", "marching", "prism", "raymaching", "hex", "march", "regular", "trigon"], "likes": 4, "viewed": 196, "published": 3, "date": "1669261945", "time_retrieved": "2024-07-30T16:17:31.903230", "image_code": "#define pi 3.141592\n#define tau pi * 2.0\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat sdPrism(vec3 p,float f,vec2 s){\n    float a = atan(p.z,p.x);\n    float b = tau / f;\n    float h = cos(floor(0.5 + a/b) * b-a);\n\tvec2 d = abs(vec2(length(p.xz)*h,p.y)) - s;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 p){\n    p.zx *= rot(iTime*2.0);\n    return sdPrism(p.yzx,3.0+floor(iTime*2.0/pi),vec2(0.5,0.25));\n}\n\nvec3 calcNormal(vec3 p){\n\tvec2 e = vec2(-1.0,1.0) * 0.0001;\n\treturn normalize(vec3(\n\t  e.yyx * scene(p + e.yyx) +\n\t  e.xyy * scene(p + e.xyy) +\n\t  e.yxy * scene(p + e.yxy) +\n\t  e.xxx * scene(p + e.xxx)\n\t));\n}\n\nfloat calcAO(vec3 p,vec3 n){\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor(int i=0;i<5;i++){\n        float hr = 0.01+0.15*float(i)/4.0;\n        vec3 aopos = n*hr + p;\n        float dd = scene(aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n\t}\n\n\treturn clamp(1.0-occ*1.5,0.0,1.0);\n}\n\nfloat raymarch(vec3 ro,vec3 rd){\n    float d = 0.0;\n    for(int i=0;i<256;i++){\n        vec3 p = ro+rd*d;\n        float h = abs(scene(p));\n        d += h;\n        if(h < 0.001 || d > 20.0) break;\n    }\n    if(d > 20.0) d = -0.0;\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  vec3 ro = vec3(0.0,0.0,3.0);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  float d = raymarch(ro,rd);\n  vec3 pos = ro+rd*d;\n\n   if(d > 0.0 && d < 20.0){\n  \tvec3 nor = calcNormal(pos);\n\n    vec3 lig = normalize(vec3(0.5));\n  \tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n  \tfloat occ = calcAO(pos,nor);\n    vec3 hal = normalize(lig-rd);\n  \tfloat spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n  \tfloat amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n  \tfloat sha = raymarch(pos+nor*0.02,lig);\n  \tif(sha > 20.0) sha = -1.0;\n  \tdif *= step(sha,0.0);\n  \tspe *= dif;\n  \tcol += vec3(0.5,1.0,1.2)*amb*occ;\n  \tcol += vec3(2.8,2.2,1.8) * dif;\n  \tcol *= 0.22;\n  \tcol += vec3(2.8,2.2,1.8) * spe*3.0;\n  }\n\n  col = pow(col,vec3(1.0/2.2));\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 129, 129, 323], [325, 325, 345, 345, 441], [443, 443, 467, 467, 651], [653, 653, 681, 681, 940], [942, 942, 974, 974, 1186], [1188, 1188, 1238, 1238, 2115]], "test": "untested"}
{"id": "cdXSRf", "name": "Icy island terrain", "author": "jarble", "description": "A fractal terrain that looks like an archipelago of frozen islands.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "erosion"], "likes": 24, "viewed": 399, "published": 3, "date": "1669260304", "time_retrieved": "2024-07-30T16:17:32.811801", "image_code": "#define SC (250.0)\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8,n2=0.;\n    vec2 n1 = vec2(0.);\n    for (int i = 0; i < octaves; i++)\n    {\n        value = abs(value-abs(n2-value) * amplitude);\n        n2 = max(sin(uv.x*freq)+cos(uv.y*freq),-n2);\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = min(value,abs(value-abs(n2-value) * amplitude));\n        \n        amplitude *= .37;\n\n        freq *= 2.05;\n\n        uv = vec2(uv.y,uv.x+n2/(freq));\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,4)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iTime/8.-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 73, 122, 658], [660, 660, 682, 682, 712], [714, 714, 744, 744, 794], [796, 796, 816, 816, 863], [865, 865, 898, 898, 1092], [1094, 1094, 1161, 1161, 1379], [1381, 1381, 1433, 1433, 1978], [1980, 1980, 2031, 2031, 2232], [2234, 2234, 2260, 2260, 2336], [2404, 2404, 2461, 2461, 4428]], "test": "untested"}
{"id": "ddsXz2", "name": "pixel art font", "author": "jonasfrey", "description": "still working on it \nfont taken from here\nhttps://opengameart.org/content/8x8-ascii-bitmap-font-with-c-source", "tags": ["pixel", "bitmap", "font"], "likes": 7, "viewed": 195, "published": 3, "date": "1669248355", "time_retrieved": "2024-07-30T16:17:33.646568", "image_code": "bool f_b_64bitchar_bitset(vec2 o_point, float n_char){\n    //uint: an unsigned 32-bit integer\n    //only 32 bit numbers can be stored, thats why we need a modulo here\n    uint[] a_n_u32_charparts = uint[256] (2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,2122219134u,32382u,0u,0u,269488144u,4096u,5140u,0u,339612672u,5182u,940865552u,1064016u,1746282758u,24724u,2550400056u,39012u,4112u,0u,67373072u,4104u,538972168u,2064u,947664980u,84u,2081427456u,4112u,0u,528384u,1006632960u,0u,0u,4096u,135274560u,516u,1111630872u,6180u,269490192u,14352u,404767292u,32260u,404767292u,15426u,303306768u,4158u,1077805694u,15426u,1111360060u,15426u,135274622u,516u,1111245372u,15426u,2084717116u,15424u,1048576u,4096u,1048576u,528384u,102260736u,24600u,8257536u,126u,1612187136u,1560u,404759068u,2048u,958544896u,939801129u,1008998424u,16962u,572400158u,7714u,16851484u,7202u,572662302u,7714u,35521086u,15874u,35521086u,514u,956375580u,7202u,1115570754u,16962u,269488252u,31760u,538976312u,7202u,235541026u,8722u,33686018u,32258u,2460665474u,33410u,1380599362u,16994u,1145324600u,14404u,35529246u,514u,1145324600u,4208708u,169746974u,8722u,805848120u,14404u,269488382u,4112u,1111638594u,15426u,608322177u,6180u,2861728386u,33478u,404235330u,16932u,271074434u,4112u,135274622u,32260u,67372060u,7172u,268960770u,16416u,269488156u,7184u,5128u,0u,0u,32256u,0u,0u,4104u,0u,2084584448u,23650u,1111360002u,14918u,70778880u,14340u,1115439168u,23650u,2118269952u,15362u,470292480u,2056u,841744384u,471870498u,605815812u,9252u,269484048u,4112u,270008336u,235933712u,337904644u,13324u,134744072u,6152u,1516634112u,16962u,1282670592u,17476u,1111228416u,15426u,1178206208u,33701442u,1650196480u,1077967938u,1278476288u,1028u,402929664u,7200u,138151936u,6152u,1145307136u,22628u,1111621632u,6180u,2172715008u,26202u,608305152u,26136u,1145176064u,101191720u,272367616u,15368u,202115128u,14344u,269488144u,1052688u,808456220u,7184u,1275068416u,50u,2122219134u,32382u);\n    //if(o_point.x > 7. || o_point.y > 7.){return false;}\n    vec2 o_point_mod = floor(mod(o_point, 8.));\n    o_point_mod.y = 7.-o_point_mod.y;\n    float n_y_floor = floor(o_point_mod.y / 4.); // 4 = half height of 8 max height\n\n    float n_pixel_index = (o_point_mod.y * 8.) + o_point_mod.x;\n    float n_pixel_index_mod = mod(n_pixel_index, 32.);\n    uint b_bitset = \n        a_n_u32_charparts[int((n_char*2.)+(n_y_floor))] & (1u<<uint(n_pixel_index_mod));\n    return b_bitset > 0u;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float A = 65.; \n    float B = 66.;\n    //...\n    \n    fragCoord = floor(fragCoord *0.2);\n    \n    bool b_64bitchar_bitset = f_b_64bitchar_bitset(fragCoord, 1.);\n    float n_x = floor((fragCoord.x / 8.));\n    float n_y = floor((fragCoord.y / 8.));\n\n    float n_index_char = (n_y * 8.) + n_x; \n    b_64bitchar_bitset = f_b_64bitchar_bitset(fragCoord, mod((n_index_char+32.),128.));\n\n    if(b_64bitchar_bitset){\n        fragColor = vec4(1.);\n    }else{\n        fragColor = vec4(0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2948, 2948, 3005, 3055, 3592]], "test": "untested"}
{"id": "cdXSRX", "name": "Time-step visualizations", "author": "Zyphery", "description": "Visiualizing time-steps and different formulas to change speed and smoothness of flow", "tags": ["time", "visualization", "step"], "likes": 2, "viewed": 129, "published": 3, "date": "1669244291", "time_retrieved": "2024-07-30T16:17:34.670831", "image_code": "#define PI  3.141592653589\n#define TAU PI * 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.y - 0.5);\n\n    vec3 col = vec3(0.0);\n    \n    \n    float t0 = mod(iTime * 0.25, 1.0);\n    float t1 = smoothstep(0.0, 1.0, t0);\n    float t2 = t0 * t0;\n    float t3 = t0 * t0 * t0;\n    float t4 = cos(t0 * PI / 2.0 - PI);\n    float t5 = sqrt(t0);\n    \n    vec2 p0 = vec2(sin(t0 * TAU), cos(t0 * TAU)) * .05;\n    vec2 p1 = vec2(sin(t1 * TAU), cos(t1 * TAU)) * .1;\n    vec2 p2 = vec2(sin(t2 * TAU), cos(t2 * TAU)) * .15;\n    vec2 p3 = vec2(sin(t3 * TAU), cos(t3 * TAU)) * .2;\n    vec2 p4 = vec2(sin(t4 * TAU), cos(t4 * TAU)) * .25;\n    vec2 p5 = vec2(sin(t5 * TAU), cos(t5 * TAU)) * .3;\n    \n    col += step(length(uv), .02) * vec3(1,1,1);\n    col += step(length(p0 - uv), .02) * vec3(1,0,0);\n    col += step(length(p1 - uv), .02) * vec3(0,1,0);\n    col += step(length(p2 - uv), .02) * vec3(0,0,1);\n    col += step(length(p3 - uv), .02) * vec3(1,0,1);\n    col += step(length(p4 - uv), .02) * vec3(0,1,1);\n    col += step(length(p5 - uv), .02) * vec3(1,1,0);\n    col += step(abs(uv.x), .002) * step(0., uv.y) * vec3(1,1,1);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 106, 1196]], "test": "untested"}
{"id": "mdlXz2", "name": "Ray Tracer from RIOW [WIP]", "author": "raianmr", "description": "GLSL implementation of RIOW.", "tags": ["raytracing"], "likes": 3, "viewed": 258, "published": 3, "date": "1669243925", "time_retrieved": "2024-07-30T16:17:35.536515", "image_code": "// written for shader toy\n\n// config\n\n#define MAX_DEPTH 5\n#define N_SAMPLES 5\n#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-3\n\n#define SPEED     0.25\n#define SCALE_ON  true // not implemented\n#define ROTATE_ON true\n\n\n// constants\n\n#define PI 3.14159265359\n\n// random number generation based on https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y>>3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1, seed+=0.1)));\n    return float(n) / float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1, seed+=0.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1, seed+=0.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat global_seed = 0.0;\n\nfloat get_seed(vec2 inp) {\n    return float(base_hash(floatBitsToUint(inp))) / float(0xffffffffU) + iTime;\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.0,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1.0/3.0);\n\treturn r * vec3(sqrt(1.0-h.x*h.x) * vec2(sin(phi), cos(phi)), h.x);\n}\n\n// rays\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nfloat schlick_approx(float cosine, float ior) {\n    float r0 = (1.0-ior) / (1.0+ior);\n    r0 = r0*r0;\n    return r0 + (1.0-r0) * pow((1.0-cosine), 5.0);\n}\n\nbool does_refract(\n    const in vec3 v, \n    const in vec3 n, \n    const in float ni_over_nt, \n    out vec3 refracted\n    ) {\n    float dt = dot(v, n);\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt*dt);\n    \n    if (discriminant > 0.0) {\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\n        return true;\n    } else { \n        return false;\n    }\n}\n\n// materials\n\n#define METAL      0\n#define LAMBERTIAN 1\n#define DIELECTRIC 2\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float v;\n};\n\n// hittable\n\nstruct hit_record {\n    float t;\n    vec3 p, normal;\n    material mat;\n};\n\nstruct hitable { // sphere, for now\n    vec3 center;\n    float radius;\n};\n\nbool hittable_hit( // only for spheres\n    const in hitable h, \n    const in ray r, \n    const in float t_min, \n    const in float t_max, \n    inout hit_record rec\n    ) {\n    vec3 oc = r.origin - h.center;\n    float b = dot(oc, r.direction);\n    float c = dot(oc, oc) - h.radius * h.radius;\n    \n    float discriminant = b * b - c;\n    if (discriminant < 0.0) {\n        return false;\n    }\n\n\tfloat s = sqrt(discriminant);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\tfloat t = t1 < t_min ? t2 : t1;\n    if (t < t_max && t > t_min) {\n        rec.t = t;\n        rec.p = r.origin + t*r.direction;\n        rec.normal = (rec.p - h.center) / h.radius;\n\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\n// camera and scatter\n\nbool scatter(\n    const in ray r_in, \n    const in hit_record rec, \n    out vec3 attenuation, \n    out ray scattered\n    ) {\n    if(rec.mat.type == LAMBERTIAN) {\n        vec3 scatter_dir = normalize(rec.normal + random_in_unit_sphere(global_seed));\n        scattered = ray(rec.p, scatter_dir);\n        attenuation = rec.mat.albedo;\n\n        return true;\n    } \n    \n    if(rec.mat.type == METAL) {\n        vec3 scatter_dir = reflect(r_in.direction, rec.normal);\n        scattered = ray(rec.p, normalize(scatter_dir + rec.mat.v * random_in_unit_sphere(global_seed)));\n        attenuation = rec.mat.albedo;\n\n        return true;\n    } \n    \n    if(rec.mat.type == DIELECTRIC) {\n        vec3 outward_normal, refracted;\n        vec3 reflected = reflect(r_in.direction, rec.normal);\n        float ni_over_nt, reflect_prob, cosine;\n        \n        attenuation = vec3(1);\n        if (dot(r_in.direction, rec.normal) > 0.0) {\n            outward_normal = -rec.normal;\n            ni_over_nt = rec.mat.v;\n            cosine = dot(r_in.direction, rec.normal);\n            cosine = sqrt(1.0 - rec.mat.v * rec.mat.v * (1.0-cosine*cosine));\n        } else {\n            outward_normal = rec.normal;\n            ni_over_nt = 1.0 / rec.mat.v;\n            cosine = -dot(r_in.direction, rec.normal);\n        }\n        \n        if (does_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n\t        reflect_prob = schlick_approx(cosine, rec.mat.v);\n        } else {\n            reflect_prob = 1.0;\n        }\n        \n        if (hash1(global_seed) < reflect_prob) {\n            scattered = ray(rec.p, reflected);\n        } else {\n            scattered = ray(rec.p, refracted);\n        }\n        return true;\n    }\n    \n    return false;\n}\n\nstruct camera {\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\n    float lens_radius;\n};\n\ncamera new_camera(\n    const in vec3 lookfrom, \n    const in vec3 lookat, \n    const in vec3 vup, \n    const in float vfov, \n    const in float aspect_ratio, \n    const in float aperture, \n    const in float focus_dist\n    ) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.0;\n    float theta = vfov * PI / 180.0;\n    float half_height = tan(theta / 2.0);\n    float half_width = aspect_ratio * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u - half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.0 * half_width * focus_dist * cam.u;\n    cam.vertical = 2.0 * half_height * focus_dist * cam.v;\n\n    return cam;\n}\n    \nray get_ray(camera c, vec2 uv) {\n    vec2 rd = c.lens_radius * random_in_unit_disk(global_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    vec3 dir = normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset);\n    \n    return ray(c.origin + offset, dir);\n}\n\n// scene\n\nbool world_hit(const in ray r, const in float t_min, \n               const in float t_max, out hit_record rec) {\n    rec.t = t_max;\n    bool hit = false;\n\n  \tif (hittable_hit(hitable(vec3(0,-1000,-1),1000.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(LAMBERTIAN, vec3(.5),0.);\n    }\n  \tif (hittable_hit(hitable(vec3( 0,1,0),1.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(DIELECTRIC, vec3(0),1.5);\n    } \n    if (hittable_hit(hitable(vec3(-4,1,0),1.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(LAMBERTIAN, vec3(.4,.2,.1),0.);\n    }       \n\tif (hittable_hit(hitable(vec3( 4,1,0),1.),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.mat = material(METAL, vec3(.7,.6,.5),0.);\n    }       \n    \n    for (int a = -4; a < 4; a++) {\n        for (int b = -4; b < 4; b++) {\n            float m_seed = float(a) + float(b)/1000.;\n            vec3 rand1 = hash3(m_seed);            \n            vec3 center = vec3(float(a)+.9*rand1.x,.2,float(b)+.9*rand1.y); \n            float choose_mat = rand1.z;\n            \n            if (distance(center,vec3(4,.2,0)) > .9) {\n                if (choose_mat < .8) { // diffuse\n                    if (hittable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(LAMBERTIAN, hash3(m_seed)* hash3(m_seed),0.);\n                    }\n                } else if (choose_mat < 0.95) { // metal\n                    if (hittable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(METAL,.5*(hash3(m_seed)+1.),.5*hash1(m_seed));\n                    }\n                } else { // glass\n                    if (hittable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(DIELECTRIC,vec3(0),1.5);\n                    }\n                }\n            }\n        }\n    }\n    \n    return hit;\n}\n\nvec3 sky_color(ray r)\n{\n    vec3 unit_direction = normalize(r.direction);\n    float t = 0.5 * (unit_direction.y + 1.0);\n\n    vec3 day = vec3(0.5, 0.7, 1.0);\n    vec3 night = vec3(0.0, 0.2, 0.5);\n\n    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * mix(day, night, abs(sin(iTime)) * SPEED);\n}\n\nvec3 ray_color(in ray r, int depth) {\n\thit_record rec;\n    vec3 color = vec3(1.0);  \n    \n    for (int i=0; i<depth; i++) {\n    \tif (world_hit(r, MIN_FLOAT, MAX_FLOAT, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            if (scatter(r, rec, attenuation, scattered)) {\n                color *= attenuation;\n                r = scattered;\n            } else {\n                color *= vec3(0.0);\n                break;\n            }\n\t    } else {\n            color *= sky_color(r);\n            break;\n    \t}\n    }\n\n    return color;\n}\n\nvoid animate(out vec3 lookfrom) {\n    if(ROTATE_ON) {\n        float angle = iTime * SPEED;\n    \tmat4 rotation_mat1 = mat4(\n            cos(angle), 0.0, -sin(angle), 0.0,\n                   0.0, 1.0,         0.0, 0.0,\n            sin(angle), 0.0,  cos(angle), 0.0,\n                   0.0, 0.0,         0.0, 1.0\n        );\n        mat4 rotation_mat2 = mat4(\n             cos(angle), sin(angle), 0.0, 0.0,\n            -sin(angle), cos(angle), 0.0, 0.0,\n                    0.0,        0.0, 1.0, 0.0,\n                    0.0,        0.0, 0.0, 1.0\n        );\n    \n    \tvec3 transformed = vec3(rotation_mat2 * rotation_mat1 * vec4(lookfrom, 1.0));\n        // prevent camera from going through floor\n        lookfrom = vec3(transformed.x, abs(transformed.y), transformed.z); \n    }\n\n    // if(SCALE_ON) {\n    // ...\n    // }\n}   \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    global_seed = get_seed(fragCoord);\n\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 lookfrom = vec3(13, 2, 3);\n    vec3 lookat = vec3(0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 20.0;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n\n    animate(lookfrom);\n\n    camera cam = new_camera(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, focus_dist);\n\n    vec3 color = vec3(0.0);\n    for (int s=0; s<N_SAMPLES; s++)\n    {\n        vec2 uv = (fragCoord + hash2(global_seed))/iResolution.xy;\n\n        ray r = get_ray(cam, uv);\n        color += ray_color(r, MAX_DEPTH);\n    }\n    color /= float(N_SAMPLES);\n\n    // gamma correction\n    color = sqrt(color);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 355, 355, 481], [483, 483, 514, 514, 627], [629, 629, 659, 659, 830], [832, 832, 862, 862, 1040], [1068, 1068, 1094, 1094, 1176], [1178, 1178, 1222, 1222, 1360], [1362, 1362, 1408, 1408, 1605], [1661, 1661, 1708, 1708, 1815], [5915, 5915, 5947, 5947, 6206], [8138, 8138, 8161, 8161, 8426], [8428, 8428, 8465, 8465, 8984], [8986, 8986, 9019, 9019, 9805], [9810, 9810, 9865, 9865, 10590]], "test": "untested"}
{"id": "dssSz2", "name": "Rainbow Bubble Cube", "author": "Aurcereal", "description": "Click and drag to orbit the camera - Pausing before orbiting the camera is less disorienting\n\nI was working on a different shader and I encountered a glitch that I thought looked cool so I leaned into it a bit further and made this (Anti-Aliasing is on)\n", "tags": ["raymarching"], "likes": 5, "viewed": 890, "published": 3, "date": "1669242661", "time_retrieved": "2024-07-30T16:17:36.514899", "image_code": "//THIS CODE IS REALLY UNORGANIZED SORRY\n\n//Camera\n//vec3 cameraPos = vec3(0.0, 0., -19.0);\nvec3 cameraPos;\nvec3 cameraForward;\n\n//Camera transforms\nvec3 SS2WS(vec2 p, vec3 forward, vec3 up, float fovY)\n{\n    //to view space\n    float z = 1.0;\n    \n    float y = z * tan(fovY*.5);\n    float x = y * iResolution.x/iResolution.y;\n\n    //to world space\n    vec3 right = cross(up, forward);\n    \n    return normalize(right*p.x*x + up*p.y*y + forward*z);\n}\n\nvec3 SS2WS(vec2 p, float fovY) //choose cam specs in method\n{\n    return SS2WS(p, cameraForward, normalize(proj(vec3(0.0, 1.0, 0.0), cameraForward)), fovY);\n}\n\n//Raymarch + SDF\n/*#define boxPos vec3(0.0, 0.0, 5.0)\n\n#define boxForward  vec3(0.0, 0.0, 1.0)\n#define boxUp vec3(0.0, 1.0, 0.0)\n#define boxRight vec3(1.0, 0.0, 0.0)\n\n#define boxScale vec3(5.0, 5.0, 5.0)*/\n\nmat4 transform;\n\nfloat sdf(vec3 p)\n{\n    return sdEdgedCube(p, transform, 0.3);\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(NORMALEPS, 0.0);\n    \n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n        ));\n}\n\nfloat trace(vec3 ro, vec3 rd, out int steps)\n{\n    float sd,dist = 0.0;\n\n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        sd = sdf(ro+rd*dist);\n        dist += sd;\n        \n        if(abs(sd) < SDEPS) {steps = i; return dist;}\n    }\n    \n    steps = MAXSTEPS;\n    return dist;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 rdSS = (fragCoord/iResolution.xy)*2.0-1.0;\n    \n    vec3 roWS = cameraPos;\n    vec3 rdWS = SS2WS(rdSS, 60.*D2R);\n    \n    int steps = 0;\n    float dist = trace(roWS, rdWS, steps);\n    \n    vec3 col = vec3(0.2, 0.1, 0.4) * (1.0-acos(rdWS.y)/PI);\n    \n    if(dist < MAXDIST)\n    {\n        col = norm(roWS + rdWS*dist)*0.5+0.5 + step(55., dist);\n    }\n    \n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //camera specs\n    cameraPos = texelFetch(iChannel0, ivec2(0,1), 0).xyz;\n    cameraForward = texelFetch(iChannel0, ivec2(1,1), 0).xyz;\n    \n    //box specs\n    vec3 boxPos = vec3(0.0, 0.0, 0.0); //z = -5.\n\n    //vec3 boxForward = vec3(0.0, sin(iTime), cos(iTime));\n    vec3 boxForward = normalize(vec3(cos(iTime)*sin(iTime*1.4), sin(iTime), cos(iTime)*cos(iTime*1.4)));\n    vec3 boxUp = vec3(0.0, 1.0, 0.0);//vec3(0.0, sin(iTime+PI*.5), cos(iTime+PI*.5));\n    boxUp = normalize(boxUp - dot(boxForward, boxUp) * boxForward);\n    vec3 boxRight = cross(boxUp, boxForward);\n\n    vec3 boxScale = vec3(5.0, 5.0, 5.0)*.95;\n\n    //setup cube transform\n    transform =\n        mat4(1.0, 0.0, 0.0, -boxPos.x,\n             0.0, 1.0, 0.0, -boxPos.y,\n             0.0, 0.0, 1.0, -boxPos.z,\n             0.0, 0.0, 0.0, 1.0) *\n        mat4(boxRight.x,   boxRight.y,   boxRight.z,   0.0,\n             boxUp.x,      boxUp.y,      boxUp.z,      0.0,\n             boxForward.x, boxForward.y, boxForward.z, 0.0,\n             0.0, 0.0, 0.0, 1.0) *\n        mat4(1.0/boxScale.x, 0.0, 0.0, 0.0,\n             0.0, 1.0/boxScale.y, 0.0, 0.0,\n             0.0, 0.0, 1.0/boxScale.z, 0.0,\n             0.0, 0.0, 0.0, 1.0);\n\n    vec3 pDim = vec3(vec2(1.0), 0.0); //was 1./iResolution.xy not right\n    \n    fragColor = (render(fragCoord) + render(fragCoord + pDim.xz) + render(fragCoord + pDim.zy) + render(fragCoord + pDim.xy)) * .25;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define IPI .318309886\n#define D2R .0174532925\n#define R2D 57.2957795\n\n#define MAXDIST 60.\n#define MAXSTEPS 30 //Bandaid - deal with corners that make steps tiny - will only be used for few rays\n\n#define SDEPS 0.007\n#define NORMALEPS 0.001\n\n//HELP\n\nvec3 arot(vec3 vec, vec3 axis, float theta) //axis rotation\n{\n    vec3 proj = vec - dot(axis, vec) * axis;\n    vec3 up = normalize(cross(proj, axis));\n    \n    return dot(vec, axis) * vec + normalize(proj) * cos(theta) * length(proj) + up * sin(theta) * length(proj);\n}\n\nvec3 crot(vec3 vec, vec3 pole, float minTheta) //clamp rotation\n{\n    float correctTheta = max(0., minTheta - acos(dot(normalize(vec), pole)));\n    vec3 axis = normalize(cross(vec, pole));\n    \n    return arot(vec, axis, correctTheta);\n}\n\nvec3 crotdoubleend(vec3 vec, vec3 pole, float minTheta) //clamp rotation on both ends of the pole\n{\n    return crot(crot(vec, pole, minTheta), -pole, minTheta);\n}\n\nvec3 proj(vec3 vec, vec3 axis)\n{\n    return vec - dot(vec, axis) * axis;\n}\n\n//SDFs\n\nfloat sdRectPrism(vec3 p, vec3 forward, vec3 up, float thickness, float len) //origin = vec3(0.0)\n{\n    vec3 right = cross(forward, up);\n\n    p = vec3(dot(p, right), dot(p, up), dot(p, forward));\n    p = vec3(p.x - .5*thickness, p.y - .5*thickness, p.z - len * .5);\n    p = abs(p);\n    \n    float dist2D = 0.0;\n    \n    float distX = p.x - .5*thickness;\n    float distY = p.y - .5*thickness;\n    float distZ = p.z - .5 * len;\n    \n    if(distX > 0. && distY > 0.)\n    {\n        dist2D = sqrt(distX*distX + distY*distY);\n    }\n    else if(distY > 0.)\n    {\n        dist2D = distY;\n    }\n    else if(distX > 0.)\n    {\n        dist2D = distX;\n    }\n    else\n    {\n        return max(distZ, max(distX, distY));\n    }\n    \n    return sqrt(pow(dist2D,2.) + pow(max(0., distZ),2.));\n    \n}\nfloat sdEdgedCube(vec3 p, mat4 transform, float thickness) //column order -> p(rows) * transform(columns)\n{\n    //cube is in (-1, 1) after transformation\n    p = abs(vec4(p, 1.0) * transform).xyz;\n    \n    //3 distances to the edges\n    p = p - vec3(1., 1., 1.);\n    \n    float distX = sdRectPrism(p, vec3(-1.0, 0.0, 0.0), vec3(0.0, 0.0, -1.0), thickness, 1.);\n    float distY = sdRectPrism(p, vec3(0.0, -1.0, 0.0), vec3(-1.0, 0.0, 0.0), thickness, 1.);\n    float distZ = sdRectPrism(p, vec3(0.0, 0.0, -1.0), vec3(0.0, -1.0, 0.0), thickness, 1.);\n    \n    return min(distX, min(distY, distZ));\n}\n", "buffer_a_code": "ivec2 dataOffset = ivec2(0);\nfloat startWait = .1;\n\nvec3 SS2WS(vec2 p, vec3 forward, float fovY)\n{\n    //to view space\n    float y = tan(fovY*.5);\n    float x = y * iResolution.x/iResolution.y;\n\n    //to world space\n    vec3 up = normalize(vec3(0.0, 1.0, 0.0) - dot(forward, vec3(0.0, 1.0, 0.0)) * forward);\n    vec3 right = cross(up, forward);\n    \n    return normalize(right*p.x*x + up*p.y*y + forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouseCurr = iMouse;\n    vec4 mousePrev = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(1,0), 0) : mouseCurr;\n    \n    //Get camera data\n    vec3 camPos = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(0,1), 0).xyz : vec3(0.0, 0.0, -24.0);\n    vec3 camForward = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(1,1), 0).xyz : vec3(0.0, 0.0, 1.0);\n    \n    //get previous slide data\n    //vec4 slideOld = iTime > startWait ? texelFetch(iChannel0, dataOffset+ivec2(0,2), 0) : vec4(0.0);\n    \n    vec3 slide = SS2WS((mouseCurr.xy/iResolution.xy)*2.0-1.0, camForward, 60.*D2R) - SS2WS((mousePrev.xy/iResolution.xy)*2.0-1.0, camForward, 60.*D2R);\n    vec3 slideAxis = (sign(mousePrev.z) == 1.0 && sign(mouseCurr.z) == 1.0) ? normalize(cross(slide, camPos)) : vec3(0.);\n    \n    camPos = (length(slideAxis) >= 1.) ? crotdoubleend(arot(camPos, slideAxis, -length(slide)*10.0), vec3(0.0, 1.0, 0.0), PI*.2) : camPos;\n    camForward = normalize(-camPos);\n\n    //Store data\n    if(ivec2(fragCoord) == dataOffset + ivec2(0,0)) {fragColor = mousePrev;}\n    if(ivec2(fragCoord) == dataOffset + ivec2(1,0)) {fragColor = mouseCurr;}\n    \n    if(ivec2(fragCoord) == dataOffset + ivec2(0,1)) {fragColor = vec4(camPos, 1.0);}\n    if(ivec2(fragCoord) == dataOffset + ivec2(1,1)) {fragColor = vec4(camForward, 1.0);}\n    \n    //if(ivec2(fragCoord) == dataOffset + ivec2(0,2)) {fragColor = vec4(slideAxis, slideMag);}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 148, 203, 223, 450], [452, 452, 513, 513, 610], [836, 836, 855, 855, 900], [902, 902, 921, 921, 1124], [1126, 1126, 1172, 1172, 1403], [1405, 1405, 1434, 1434, 1826], [1828, 1828, 1885, 1904, 3295]], "test": "untested"}
{"id": "ddlSzj", "name": "Voronoi Visualization", "author": "Zyphery", "description": "Voronoi Noise explanation\nSample multiple points, find the minimum distance or closest points, give each point a unique color", "tags": ["voronoinoise"], "likes": 3, "viewed": 161, "published": 3, "date": "1669231309", "time_retrieved": "2024-07-30T16:17:37.406515", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Random points\n    vec2 p0 = vec2(sin(iTime*.72)*.5+.5, sin(iTime*1.21-.34)*.5+.5);\n    vec2 p1 = vec2(sin(iTime*.31+2.53)*.5+.5, sin(iTime*.13+.92)*.5+.5);\n    vec2 p2 = vec2(sin(iTime*.96-5.35)*.5+.5, sin(iTime*.35-1.41)*.5+.5);\n    vec2 p3 = vec2(sin(iTime*.15+.56)*.5+.5, sin(iTime*.26+.51)*.5+.5);\n    \n    // Length of each point to current sample (uv)\n    float p0Len = length(p0 - uv);\n    float p1Len = length(p1 - uv);\n    float p2Len = length(p2 - uv);\n    float p3Len = length(p3 - uv);\n    \n    vec3 col = vec3(0);\n    \n    // Minimum Length\n    float mLen = min(p0Len, min(p1Len, min(p2Len, p3Len)));\n    \n    // Each point gets a unique color\n    if(mLen == p0Len)\n        col = vec3(1,0,0);\n    else if(mLen == p1Len)\n        col = vec3(1,1,0);\n    else if(mLen == p2Len)\n        col = vec3(0,1,0);\n    else if(mLen == p3Len)\n        col = vec3(0,1,1);\n    \n    // Show the point\n    col = col * step(.05, mLen);    \n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlSzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1078]], "test": "untested"}
{"id": "ddsSRj", "name": "Watercolor Effect", "author": "Peace", "description": "Watercolor effect", "tags": ["watercolor"], "likes": 5, "viewed": 524, "published": 3, "date": "1669229739", "time_retrieved": "2024-07-30T16:17:38.621267", "image_code": "// Turns color to water color\nvec3 getWaterColor(vec3 color) {\n    // Makes so each channel of the color has definition of \"bands\" (instead of normal color definition of 256)  \n    const float bands = 6.0;\n    vec3 col = round(color * bands) / bands;\n    // \"length(col)\" make brightness of \"color\" limited, since \"col\" has limited definition and we are grabbing brightness from that\n    // While \"normalize(color)\" get's only color, which has normal definition\n    // So multiplying length(col) with normalize(color) gives color which has low definition brightness but high definition color\n    // Making it look similar to watercolor painting\n    // Then it interpolates normal color with this constrained color to add a bit of detail\n    return mix(color, length(col) * normalize(color), 0.7);\n}\n\n// get's random number for 2D coordinate\nfloat rand(vec2 uv) {\n\treturn fract(sin(dot(vec2(12.9898,78.233), uv)) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Split's screen in 2 parts for comparision\n    if(uv.x >= 0.5) // watercolored texture color\n    {\n        // this adds some randomness to the uv, making it look grainy        \n        vec2 ruv = clamp(uv + (vec2(rand(uv), rand(uv + vec2(13.61, -21.35))) * 2.0 - 1.0) / iResolution.xy * 2., vec2(0), vec2(1));\n        // mixing between grainy and smooth texture\n        vec3 t = mix(textureLod(iChannel0, ruv, 2.0).rgb, textureLod(iChannel0, uv, 2.0).rgb, 0.5);\n        fragColor.rgb = getWaterColor(t);\n    }\n    else // normal texture color\n    {\n        fragColor.rgb = texture(iChannel0, uv).rgb;\n    }\n    \n    // middle line in split screen\n    float d = abs(uv.x - 0.5) / 0.005;\n    if(d < 1.0) \n    {\n        // Added smoothstep interpolation to make middle line look smoother\n        fragColor.rgb = mix(vec3(0), fragColor.rgb, smoothstep(0.0, 1.0, d * d));\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 62, 176, 798], [800, 841, 862, 862, 931], [933, 933, 985, 985, 1913]], "test": "untested"}
{"id": "mdlSRj", "name": "Supersaw Unison Experiment", "author": "MysteryPancake", "description": "Supersaw unison effect, similar to Serum", "tags": ["sound", "music", "audio", "synthesis", "synth", "saw", "song", "sawtooth", "gpusound", "supersaw", "chords", "unison"], "likes": 6, "viewed": 270, "published": 3, "date": "1669227194", "time_retrieved": "2024-07-30T16:17:39.362286", "image_code": "// From https://www.shadertoy.com/view/ltfSRr\nfloat message(vec2 uv) {\n\tuv -= vec2(1.0, 10.0);\n\tif ((uv.x < 0.0) || (uv.x >= 32.0) || (uv.y < 0.0) || (uv.y >= 3.0)) return -1.0;\n\tint i = 1, bit = int(exp2(floor(32.0 - uv.x)));\n\tif (int(uv.y) == 2) i = 928473456 / bit;\n\tif (int(uv.y) == 1) i = 626348112 / bit;\n\tif (int(uv.y) == 0) i = 1735745872 / bit;\n\treturn float(i - 2 * (i / 2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tif (iResolution.y < 2000.0) {\n\t\tfloat c = message(fragCoord / 8.0);\n\t\tif (c >= 0.0){\n\t\t\tfragColor = vec4(c);\n\t\t\treturn;\n\t\t}\n\t}\n\tfragColor = vec4(fragCoord / iResolution.xy, 0.5 + mod(iTime, 0.5), 1.0);\n}", "image_inputs": [], "sound_code": "const float PI = 3.1415926;\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2((note - 69.0) / 12.0);\n}\n\n// For sawtooth synth\nfloat saw(float freq, float time, float phase) {\n\treturn fract(phase + freq * time) * 2.0 - 1.0;\n}\n\n// For kick drum (808?)\nfloat drum(float freq, float time) {\n\treturn sin(freq * time * PI) * exp(-4.0 * time);\n}\n\n// For snares and hi-hats\nvec2 noise(float time, float fade) {\n\treturn (vec2(hash(time * 512.0), hash(time * 1024.0)) - 0.5) * exp(-fade * time);\n}\n\nvec2 mainSound(int samp, float time) {\n    \n    // MIDI notes to play\n\tfloat a = 49.0;\n\tfloat b = 53.0;\n\tfloat c = 56.0;\n\tfloat d = 60.0;\n\tfloat e = 68.0;\n    float f = 75.0;\n    \n    // Hi-hat rhythm divisions per beat\n\tfloat rhythm = 4.0;\n    \n    // Base note for the drum (808?)\n\tfloat drumNote = 34.0;\n\t\n    // Swap notes every 2 beats\n\tif (fract(time / 4.0) > 0.5) {\n\t\ta += 2.0;\n\t\tb += 3.0;\n\t\tc += 2.0;\n\t\td += 3.0;\n\t\te += 7.0;\n        f += 4.0;\n\t\tdrumNote += 2.0;\n\t\trhythm -= 1.0;\n\t}\n\t\n\tfloat[] notes = float[] (noteFreq(a), noteFreq(b), noteFreq(c), noteFreq(d), noteFreq(e), noteFreq(f));\n\t\n    // Unison spread, notes to place around each note\n\tconst float spread = 4.0;\n    \n    // Detune factor in Hertz\n    const float detune = 0.3;\n    \n\tvec2 result = vec2(0.0);\n\t\n    // Apply unison effect to each note\n\tfor (int i = 0; i < notes.length(); i++) {\n    \n\t\t// Place notes around center frequency\n\t\tfor (float j = -spread; j <= spread; j++) {\n\t\t\tfloat frequency = notes[i] + j * detune;\n\t\t\tresult.x += saw(frequency, time, hash(2.0 * j));\n\t\t\tresult.y += saw(frequency, time, hash(2.0 * j + 1.0));\n\t\t}\n\t}\n    \n    // Prevent volume clipping\n\tresult /= float(notes.length()) * spread;\n    \n    // Sidechain to sine wave\n    result *= abs(sin(time * PI * 2.0));\n    \n    // Distort drum by making it 2x louder, then clamp to hard clip it\n\tresult += clamp(drum(noteFreq(drumNote), fract(time * 2.0)) * 2.0, -0.9, 0.9);\n    \n    // Add snare every 2 drums\n\tresult += noise(fract(time + 0.5), 5.0) * 0.6;\n    \n    // Add hi-hats depending on rhythm division\n\tresult += noise(fract(time * rhythm), 7.0) * 0.5;\n    \n\treturn result;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 70, 70, 387], [389, 389, 444, 444, 649]], "test": "untested"}
{"id": "DslSz2", "name": "Fence Squeezer", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 8, "viewed": 165, "published": 3, "date": "1669227137", "time_retrieved": "2024-07-30T16:17:40.105300", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat seg( in vec2 p, in vec2 a, in vec2 b, float o )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    //h += 0.01 * cos(4. * iTime + 16. * h);\n    return (4. + 3.4 * thc(4., pi * o + .75 * length(ba) * pi * h)) * length( pa - ba*h );\n}\n\nfloat bleh(vec2 uv) { \n    uv.x += 0.1 * iTime;\n\n    float sc = 16.;\n    uv *= sc;\n    float ix = floor(uv.x);\n    uv.x = fract(uv.x) - 0.5;\n    \n    float t = 1.5 * iTime + 0.25 * ix;\n    float o = 0.125 * cos(0.125 * uv.y + 1.5 * t);\n    uv.x += o;\n    uv.y -= 0.1 * sc * sin(uv.x);\n    \n    vec2 p = vec2(0, 0.35 * sc * cos(pi * t * 0.125));\n    vec2 q = vec2(0, 0.15 * sc * cos(pi * t * 0.3 - 0.25 * pi));\n    float d = seg(uv, p, q, ix);\n    // no smoothstep because modified seg() function isn't an SDF\n    return step(d, (0.02 + 0.015 * cos(0.5 * t)) * sc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n\n    float s = 0., s2 = 0.;\n    float n = 5.;\n    float zm = mix(2., 1., tanh(0.4 * iTime));\n    for(float i = 0.; i < n; i++) {\n        s  += bleh(uv * (zm + 0.02 * i / n)) / n;\n        s2 += bleh(uv * (zm + 0.02 * i / n) - vec2(.015,0)) / n;\n    }\n    vec3 col = (1.-s) * mix(vec3(210), vec3(240), 0.5 - uv.y) / 255.;\n    vec3 col2 = (0.5 + 0.5 * cos(0.75 * iTime)) * vec3(1,.5,.15);\n    col = mix(col, (uv.x + 0.5 * res.x/res.y) * col2, s2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 115, 115, 338], [340, 340, 361, 361, 906], [908, 908, 965, 965, 1522]], "test": "untested"}
{"id": "msXSR2", "name": "Even faster fbm terrain gen.", "author": "kishimisu", "description": "Left : total number of fbm loops executed during the whole raymarching\nBlue (low values) to Red (high values)\nSlide the panel with the mouse !", "tags": ["raymarching", "terrain", "fast", "gradient", "planet", "fog", "performance", "optimization", "quick", "computation", "tips", "techniques"], "likes": 31, "viewed": 630, "published": 3, "date": "1669220680", "time_retrieved": "2024-07-30T16:17:40.982953", "image_code": "/* A new attempt at fast fbm terrain raymarching  \n   combining multiple techniques I've learned so far:\n   \n   - Break the fbm loop early if the point is located above the current noise\n     value to prevent unecessary noise calculations. (BREAK_EARLY) \n     \n   - Increase the minimum distance considered as a surface hit the further\n     away from the camera the point is. (RELAXATION)\n     \n   - Calculate only a smaller amount of fbm layers when raymarching\n     shadows. (SHADOW_FBM_LAYERS)\n     \n   - I also tried to use a simpler and faster noise function as seen in\n     this shader: https://www.shadertoy.com/view/NscGWl. \n     However, the terrain gets sharper so I decided to use a mix of this \n     new noise and value noise: for the first 4 fbm layers (the ones that \n     are computed most frequently), I use this fast noise but for the \n     later layers I use value noise. This is a good compromise\n     between performance and nice terrain shape. (FAST_LAYERS)\n     \n   - Finally I added a visual improvement thanks to @Dave_Hoskins's comment,\n     the step size for the normal calculation increases with the distance in\n     order to reduce aliasing artefacts (REDUCE_ALIASING)\n     \n   Left panel: total number of fbm loops executed during the whole raymarching\n   (blue: low values, red: high values). Slide with the mouse.\n*/\n\n// Set to 0 to disable all optimizations (except FAST_LAYERS that changes the terrain)\n// On my machine the improvement is pretty huge, 40fps vs 20fps.\n\n#define OPTIMIZE 1       // <-- Change this to compare the performances\n\n// Total number of fbm layers\n// Increase this to make your fps drop\n\n#define FBM_LAYERS 10\n\n// Number of layers that will use the fast noise function\n// instead of value noise (in addition to the first layer)\n\n#define FAST_LAYERS 3\n\n// Visual improvement only: reduce aliasing in the distance\n\n#define REDUCE_ALIASING 1\n\n#if OPTIMIZE\n    // Break out of the fbm loop when possible\n    #define BREAK_EARLY       1\n    // Number of layers computed while raymarching shadows\n    #define SHADOW_FBM_LAYERS 5\n    // Min. Surface distance increase\n    #define RELAXATION        0.2\n#else\n    // Default parameters (no optimization)\n    #define BREAK_EARLY       0\n    #define SHADOW_FBM_LAYERS FBM_LAYERS\n    #define RELAXATION        0.\n#endif\n\nfloat total_fbm_loop_count = 0.; \n\nfloat fastnoise2(vec2 p) {\n    return (sin(p.x)-cos(p.y))*.5+.5;\n}\n\nfloat fbm(vec2 p, float h, int layers) {\n    float n = fastnoise2(p); // The first layer is calculated with fast noise\n    float a = 1.;\n    \n    for (int i = 0; i < layers; i++) {\n#if BREAK_EARLY  \n        if (h > n + a*2.) break; // Break early if the point is above the noise\n#endif \n        \n        p *= 2.; a *= .5;\n        total_fbm_loop_count++;\n   \n        if (i < FAST_LAYERS) // Fast calculations for the first layers\n            n -= a*abs(fastnoise2(p)-n);\n        else                 // Value noise for the last layers\n            n -= a*noise2(p);      \n    } \n    \n    return n;\n}\n\nfloat map(vec3 p, int layers) {\n    p.y *= .8;\n    p.y -= .6;\n    float terrain = p.y - fbm(p.xz*.5, p.y, layers);\n    \n    return terrain;\n}\n\n#define MAX_ITERATIONS 100.\n#define MAX_DISTANCE 100.\n#define EPSILON 0.001\n\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0025;\n    \n#if REDUCE_ALIASING\n    e *= d; // Increase the step size with the distance to reduce aliasing\n#endif\n\n    return normalize(e.xyy*map(p + e.xyy, FBM_LAYERS) + e.yyx*map(p + e.yyx, FBM_LAYERS) + \n\t\t\t\t\t e.yxy*map(p + e.yxy, FBM_LAYERS) + e.xxx*map(p + e.xxx, FBM_LAYERS));\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.1, res = 1., k = 10.;\n    for (float i = 0.; i < MAX_ITERATIONS; i++) {\n        vec3 p = ro + t*rd;\n        // Use a smaller number of fbm terrain layers for the shadow\n        float d = map(p, SHADOW_FBM_LAYERS);\n        res = min(res, k*d/t);\n        t += d*1.;\n        if (t > maxt) return res;\n        if (d < EPSILON) return 0.;\n    }\n    return 0.;\n}\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy*2.-1.; \n    ro = vec3(0., 3., 3.);\n    ro.zx *= rot(iTime*.1); \n    vec3 f = normalize(vec3(0.,1.,0.)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col = vec3(1.);\n    float t = 0., d;\n\n    initRayOriginAndDirection(uv, ro, rd);\n        \n    for (float i = 0.; i < MAX_ITERATIONS; i++) {\n        p = ro + t*rd;\n        d = map(p, FBM_LAYERS);\n        t += d > 0. ? d*.9 : d*.2;\n        // EPSILON is the minimum surface distance considered as a hit.\n        // We increase it the further away as we don't need as much details\n        if (abs(d) < EPSILON*(1. + t*RELAXATION) || t > MAX_DISTANCE) break;\n    }\n    \n    float phi = 0.32 * 6.28, the = -0.00 * 3.14 + 1.27;\n    vec3 lightDir = normalize(vec3(sin(the)*sin(phi), cos(the), sin(the)*cos(phi)));\n    vec3 skyColor = vec3(1.2,.8,.3);\n    \n    if (t < MAX_DISTANCE) {\n        vec3 n = getNormal(p - rd*EPSILON*4., t);\n        float sunLight    = max(.0, dot(n, lightDir));\n        float sunShadow   = max(.0, getShadow(p + n*EPSILON*4., lightDir, MAX_DISTANCE));\n        float skyLight    = max(.0, n.y);\n        float bounceLight = max(.0, dot(n, -lightDir));\n        float spec        = max(.0, dot((rd + n)/2., lightDir));\n        \n        col *= 1.0*vec3(1.,1.,.8) * sunLight * sunShadow;\n        col += 0.1*skyColor * skyLight;\n        col += 0.1*vec3(.4,.2,0.) * bounceLight;\n        col += 0.8*vec3(1.)*pow(spec, 4.);\n    }\n         \n    float groundFog = min(.5-ro.y/rd.y, t) - (0.1-ro.y)/rd.y;\n    if (groundFog > 0.) {\n        col = mix(vec3(1.,.8,.6), col, exp(-groundFog));\n    }\n    \n    vec3 fog = exp2(-t*0.05*vec3(1,1.8,4)); \n    col = mix(clamp(skyColor - vec3(1.,1.5,2.)*abs(rd.y)*.7, vec3(0.), vec3(1.)), col, fog);   \n    \n    col = pow(col, vec3(.4545));\n    \n    float mp = iMouse.z == 0. ? -smoothstep(0., 3., iTime)*.6+cos(iTime*3.)*.04 : 3.55*(iMouse.x/iResolution.x-.5);\n    if (uv.x < mp) col = palette(0.014 * total_fbm_loop_count / float(FBM_LAYERS));\n       \n    O = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "// Value noise - https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise2( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Heatmap color palette - https://www.shadertoy.com/view/wlGcWG\nvec3 palette( float h ) {\n    vec3 col =    vec3(0.0,0.3,1.0);\n    col = mix(col,vec3(1.0,0.8,0.0),smoothstep(0.33-0.2,0.33+0.2,h));\n    col = mix(col,vec3(1.0,0.0,0.0),smoothstep(0.66-0.2,0.66+0.2,h));\n    col.y += 0.5*(1.0-smoothstep(0.0,0.2,abs(h-0.33)));\n    col *= 0.5 + 0.5*h;\n    return col;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXSR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2351, 2351, 2377, 2377, 2417], [2419, 2419, 2459, 2459, 3016], [3018, 3018, 3049, 3049, 3159], [3238, 3238, 3271, 3271, 3592], [3594, 3594, 3641, 3641, 4014], [4069, 4069, 4140, 4140, 4404], [4406, 4406, 4445, 4445, 6342]], "test": "untested"}
{"id": "cslSR2", "name": "less bitdepth", "author": "jonasfrey", "description": "from left to right \n1bit 2 colors, \n2bit 4 colors \n3bit 8 colors \n4bit 16 colors\n5bit 32 colors \n6bit 64 colors\n7bit 128 colors\n8bit 255 colors\nmouse x-axis: repetitions \n mouse y-axis: comparison\n", "tags": ["bitdepth"], "likes": 0, "viewed": 169, "published": 3, "date": "1669220344", "time_retrieved": "2024-07-30T16:17:41.756884", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o_mou_coo_nor = iMouse.xy/iResolution.xy;\n    vec2 uv_big_frac = fract(uv*(o_mou_coo_nor.x*10.));\n    if(iMouse.w == 0.0){\n        o_mou_coo_nor = vec2(0.0, 0.5);\n    }\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 o_col_img = texture(iChannel0, uv);\n    // Output to screen\n    float n_colors = 2.;\n    float n_expnt_max = 8.;\n    float n_expnt_min = 1.;\n    float n_expnt_range = n_expnt_max - n_expnt_min;\n    float n_numerus = 0.;\n    for(float n_expnt = n_expnt_min; n_expnt < n_expnt_max; n_expnt+=1.){\n        n_numerus = pow(2., n_expnt);\n        if(uv_big_frac.x > ((1./n_expnt_range)*(n_expnt-n_expnt_min))){\n\n            n_colors = n_numerus;\n            fragColor = floor(o_col_img*n_colors)/(n_colors);\n            if(uv.y > o_mou_coo_nor.y){\n                fragColor = o_col_img;\n            }\n        }\n\n    }\n\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1042]], "test": "untested"}
{"id": "DssSzj", "name": "simple frequencydomain eq #3", "author": "jonasfrey", "description": "simple eq inside the frequency domain", "tags": ["eq"], "likes": 3, "viewed": 147, "published": 3, "date": "1669217660", "time_retrieved": "2024-07-30T16:17:42.606612", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy - iResolution.xy*0.5)/iResolution.y;\n    \n    if(iMouse.w == 0.){\n        o_mou_coo_nor = vec2(0.01, 0.0);\n    }\n    \n    float n_freqs = o_mou_coo_nor.x*1000.0;\n    n_freqs = 222.; //tmp static\n    vec2 o_opcn_big = o_pix_coo_nor*vec2(n_freqs);\n    vec2 o_opcn_big_mod = fract(o_opcn_big);\n    vec2 o_opcn_big_floor = floor(o_opcn_big);\n    // 0.1, 0.1, 0.1, instead of 0.13, 0.16, 0.19...\n    vec2 o_pix_coo_nor_subdivfloor = vec2(1.) / o_opcn_big_floor;\n    \n    float n_0to1 = o_opcn_big_mod.x;\n    //https://www.desmos.com/calculator/krkptci6rn\n    float n_0to1to0 = (abs((n_0to1*2.)-1.)-1.)*-1.;\n    float n_dist1 = o_opcn_big_mod.x;//\n    float n_freq_norm = abs(o_opcn_big_floor.x) / n_freqs;\n    //todo: float n_freq_norm_logarhitmic = abs(o_opcn_big_floor.x) / n_freqs;\n    float n_amp = texture(iChannel0, vec2(n_freq_norm, 0.0)).x;\n    n_amp*=0.5;\n    fragColor = vec4(n_0to1to0*n_amp);\n     \n    float n_delta = abs(o_pix_coo_nor.y) - n_amp;\n    float n_delta_nor = n_delta / (1.-n_amp);\n    if(n_delta > 0.){\n        \n        fragColor = vec4(n_delta_nor);\n    }\n    \n\n}", "image_inputs": [{"id": 30556, "src": "https://soundcloud.com/user18081971/avril-14th-reversed-music-not-audio", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssSzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1349]], "test": "untested"}
{"id": "DdlSzj", "name": "Binaural Beats 🔊", "author": "blurryroots", "description": "Turn your sound on and synchronize your brain waves. Wobble. Jives quite nicely with the song.\nLines based on Siri Ripples by MatHack https://www.shadertoy.com/view/4sVSzw", "tags": ["sound", "audio", "beats", "binaural"], "likes": 4, "viewed": 298, "published": 3, "date": "1669213424", "time_retrieved": "2024-07-30T16:17:43.668772", "image_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n#define SOUND_IN_PIXEL 0\n#define SOUND_IN_SOUND 1\n\n#define SOUND_IN_TYPE SOUND_IN_PIXEL\n\n#if (SOUND_IN_TYPE == SOUND_IN_SOUND)\n// Message code by FabriceNeyret2 => https://www.shadertoy.com/view/MtyXRW\n\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0.);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n#else\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    #if (SOUND_IN_TYPE == SOUND_IN_SOUND)\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {\n        float c = message((fragCoord/iResolution.y-vec2(.01,.1))*8.);\n        if(c>=0.) {\n            vec3 cc = vec3(\n                0.1 + 0.9 * texture(iChannel0, vec2(0.11,0.0)).x,\n                0.1, //+ 0.2 * texture(iChannel0, vec2(0.33,0.0)).x,\n                0.5 //+ 0.5 * texture(iChannel0, vec2(0.66,0.0)).x\n            );\n            fragColor = vec4(c*cc, 1.0);\n            return;\n        }\n    }\n    #else\n    // Overlay by FabriceNeyret2 https://www.shadertoy.com/view/MtyXRW\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n    #endif\n\n    const int WAVES = 3;\n    vec2 uvn = fragCoord.xy / iResolution.xy;\n\tvec2 uv = -1.0 + 2.0 * uvn;\n    float time = iTime * 10.3;\n       \n  \tvec4 cc = vec4(0.0);    \n    vec3 r = vec3(1.0, 0.0, 0.0);\n    vec3 g = vec3(0.0, 1.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 1.0);\n    float thickness = 0.004;     \n\n    // Lines concept by MatHack\n    // --- https://www.shadertoy.com/view/4sVSzw\n    for(int k=0; k<WAVES; k++) {\n        float i = float(k);\n\n        float K = 2.5 + 3.;\n        float B = 1.0 + 2.0;\n        float x = uv.x * 3.;\n        float bounce = 2.0*texture(iChannel0, vec2(0.33,0.0)).x;\n        float att = (1.0 - (i*0.3)) * 0.4 * bounce;\n        float split = uv.y + (att*pow((K/(K+pow(x, K))), K) * cos((B*x)-(time+(i*10.*phi))));\n        \n        vec3 c;\n        \n        if (0 == k) {\n            c = r;\n        }\n        else if (1 == k) {\n            c = g;\n        }\n        else if (2 == k) {\n            c = b;\n        }\n      \n        vec3 line = smoothstep(0.0, 1.0-phi0, abs(thickness / split)) * c;\n        cc += vec4(line, 1.0);\n    }\n    // ---\n    \n    fragColor = cc;\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\nvec2\nprocess_beat (float base, float beat, float time) {\n    float l = sin(TWOPI * (base + 00.0) * time);\n    float r = sin(TWOPI * (base + beat) * time);\n    \n    return vec2 (l, r);\n}\n\nvec2\nmainSound (int samp, float time) {\n    float volume = phi0;\n    float base = 432.0;\n    \n    vec2 s1 = process_beat (base / (phi),    beat, time);\n    vec2 s2 = process_beat (base / (PI*phi), beat, time);\n    vec2 s = vec2 (0.0);\n         s = mix (s, s1, 1.00);\n         s = mix (s, s2, phi0i);\n    \n    return volume * s;\n}", "sound_inputs": [], "common_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\nconst float phi = (1. + sqrt (5.)) / 2.;\nconst float phi0 = phi - 1.;\nconst float phi0i = 1. - phi0;\nconst float PI = 355./113.;\nconst float TWOPI = 2.0*PI;\n\nfloat beat = PI*phi;\n\nfloat psin (float t) { return (sin (t) + 1.0) / 2.0; }\nfloat pcos (float t) { return (cos (t) + 1.0) / 2.0; }", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlSzj.jpg", "access": "api", "license": "proprietary-license", "functions": [[2548, 2548, 2605, 2605, 4445]], "test": "untested"}
{"id": "DdlXRj", "name": "Supah geometric experiment #7", "author": "supah", "description": "Supah geometric experiment #7", "tags": ["lines", "experiment", "shape", "geometric", "supah"], "likes": 11, "viewed": 281, "published": 3, "date": "1669211194", "time_retrieved": "2024-07-30T16:17:44.505535", "image_code": "#define R iResolution.xy\n#define S smoothstep\n#define P 3.14159265\n#define offset .1257\n#define lines 250.\nmat2 rot(float a) {\n    return mat2(cos(a), sin(-a), sin(a), cos(a));\n}\nfloat C (vec2 uv, float angle) {\n    vec2 st = uv * rot(angle);\n    float m = smoothstep(-.75, .3, atan(st.x, st.y)/P); \n    return S(.5,.75, cos(length(uv) * lines))* S(0.001, 0., abs(length(uv)- offset)-.12) * m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*R.xy)/R.y,\n        st = uv - vec2(-offset, offset);\n    if (st.x > 0. && st.y < 0. && st.y > -offset * 2.) st.y = 0.;\n    float c = C(st, P*1.5);\n    \n    st = uv - vec2(offset, -offset);\n    if (st.x < 0. && st.y > 0. && st.y < offset * 2.) st.y = 1.;\n    c += C(st, P*.5);\n    \n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 126, 126, 178], [179, 179, 211, 211, 395], [396, 396, 453, 453, 788]], "test": "untested"}
{"id": "msXSRB", "name": "Water effect (use mouse)", "author": "rubioh", "description": "Based on https://hal.inria.fr/inria-00596050/document,\nfound in https://www.shadertoy.com/view/4tGfDW.\nIt's my first EDP's implementation i'm new on this topic.", "tags": ["water", "navier", "stokes"], "likes": 17, "viewed": 406, "published": 3, "date": "1669209420", "time_retrieved": "2024-07-30T16:17:45.551738", "image_code": "#define A(u) texture(iChannel0, u)\n#define PI 3.14159\n#define dx vec2(1./iResolution.x, 0)\n#define dy vec2(0, 1./iResolution.y)\n\nfloat smooth_damier(vec2 uv){\n    float a = (.32035*atan(sin(PI*uv.x)/0.05)+.5);\n    float b = (.32035*atan(sin(PI*uv.y)/0.05)+.5);\n    return a*(1.-b)+b*(1.-a);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvf = (fragCoord.xy/iResolution.xy);\n    ivec2 uv = ivec2(fragCoord.xy);\n\n\n    float D = texture(iChannel0, uvf).z;\n    vec4 sl = A(uvf-dx);\n    vec4 sr = A(uvf+dx);\n    vec4 su = A(uvf-dy);\n    vec4 sd = A(uvf+dy);\n           \n    vec3 normal = normalize(vec3(uvf, sl.z-sr.z) + vec3(uvf, su.z-sd.z) + vec3(uvf, D));\n    \n\n    vec3 col = vec3(.0, .7, .8)*.7;\n    \n    vec3 ld = vec3(1.,1.,2.);\n    \n    vec3 rd = vec3(uvf, -1.);\n    \n    float L = dot(normal, ld);\n    L = pow(L, .5);\n\n    // Some refraction effect\n    vec3 rr = refract(rd, normal, .1);\n    vec3 ro = vec3(uv, D);\n    float depth = -ro.z/rr.z*20.;\n    vec2 st = (ro+rr*depth).xy;\n    \n    // Smoothed version of a chessboard\n    float d = clamp(smooth_damier(st/40.)+.6, 0., 1.);\n\n    // Ambient + Diffuse lightning\n    col = col*L*4. + 5.*col*(.5+.5*normal.z);\n    \n    // Gamma correction\n    col = vec3(3.*pow(d*col/8., vec3(3.)));\n    \n    fragColor = vec4(col, 1.);\n    }\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float v = .2; // Viscosity factor\nconst float K = .1; // Normalization factor\nconst float dt = .1; // delta t\nconst float kappa = .6; // Diffusion factor\nconst float N = 2.; // Advection factor\n\n\nfloat Bound(vec2 uvf){\n    float res;\n    res = 1.-smoothstep(.49, .5, abs(uvf.y-0.5)); \n    res *= 1.- smoothstep(.49, .5, abs(uvf.x-0.5));\n    return res;\n}", "buffer_a_code": "#define A(u) textureLod(iChannel0, u, 0.)\n#define R iResolution.xy\n#define dx vec2(1./iResolution.x, 0)\n#define dy vec2(0, 1./iResolution.y)\nvec4 init_lattice(vec2 uv){\n    return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 m = (vec2(cos(iTime*3.), sin(iTime*6.))*.3+.5);\n    if (iMouse.z > 0.){\n        m = iMouse.xy/iResolution.xy;\n    }\n    ivec2 uv = ivec2(fragCoord.xy);\n    vec2 uvf = fragCoord.xy/R.xy;\n    \n    vec4 state;    \n    // Init lattice\n    if (iFrame < 1){\n        state = init_lattice(uvf);\n    }    \n        \n    else{\n        // X,Y is for velocity, Z for density, W is not used here.\n        state = A(uvf);                \n               \n        float S = K/dt;\n        vec4 sl = A(uvf-dx);\n        vec4 sr = A(uvf+dx);\n        vec4 su = A(uvf-dy);\n        vec4 sd = A(uvf+dy);\n        \n        \n        vec4 Udx = (sr-sl)*.5; // Differential respect to x\n        vec4 Udy = (su-sd)*.5; // Differential respect to y\n        \n        float Udiv = Udx.x + Udy.y; // Velocity divergence\n        vec2 DdX = vec2(Udx.z, Udy.z); // density's gradient\n        \n        // Diffusion        \n        state.z -= kappa*dt* dot(vec3(DdX, Udiv), state.xyz);        \n        \n        // Pressure Thing's\n        vec2 PdX = S*DdX; // grad P = K * grad rho\n        vec2 L = (sl.xy + sr.xy + su.xy + sd.xy) - 4.*state.xy; // velocity's laplacian \n        vec2 viscosity = v*L; \n\n        // Semi Lagrangian advection\n        vec2 where = uvf - (dt*state.xy)*N/iResolution.xy; \n        state.xy = A(where).xy;\n        \n        // Correct the advection to reduce the divergence. \n        // It's not a real constraint on divergence since the divergences is not 0\n        // after this correction. \n        // But it correct it enough to allow a full explicit scheme of the equation\n        state.xy += dt*(viscosity - PdX);\n        \n        // Change density when click\n        state.z += 3.*(1.-smoothstep(0., .02, length(uvf-m)));\n        \n        // Boundaries\n        state.xy *= Bound(uvf);\n        \n        state.z *= .999; // Stability\n\n        // Clamping in order to mitigate exploding scheme. This setting is completly arbitrary\n        state = clamp(state, vec4(vec2(-10.), .5, -10.), vec4(vec2(10), 3., 10.));\n    }\n    \n    \n    fragColor = state;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) textureLod(iChannel0, u, 0.)\n#define R iResolution.xy\n#define dx vec2(1./iResolution.x, 0)\n#define dy vec2(0, 1./iResolution.y)\nvec4 init_lattice(vec2 uv){\n    return vec4(0.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    ivec2 uv = ivec2(fragCoord.xy);\n    vec2 uvf = fragCoord.xy/R.xy;\n    \n    vec4 state;    \n    // Init lattice\n    if (iFrame < 1){\n        state = init_lattice(uvf);\n    }    \n        \n    else{\n        // X,Y is for velocity, Z for density, W is not used here.\n        state = A(uvf);                \n               \n        float S = K/dt;\n        vec4 sl = A(uvf-dx);\n        vec4 sr = A(uvf+dx);\n        vec4 su = A(uvf-dy);\n        vec4 sd = A(uvf+dy);\n        \n        \n        vec4 Udx = (sr-sl)*.5; // Differential respect to x\n        vec4 Udy = (su-sd)*.5; // Differential respect to y\n        \n        float Udiv = Udx.x + Udy.y; // Velocity divergence\n        vec2 DdX = vec2(Udx.z, Udy.z); // density's gradient\n        \n        // Diffusion        \n        state.z -= kappa*dt* dot(vec3(DdX, Udiv), state.xyz);        \n        \n        // Pressure Thing's\n        vec2 PdX = S*DdX; // grad P = K * grad rho\n        vec2 L = (sl.xy + sr.xy + su.xy + sd.xy) - 4.*state.xy; // velocity's laplacian \n        vec2 viscosity = v*L; \n\n        // Semi Lagrangian advection\n        vec2 where = uvf - (dt*state.xy)*N/iResolution.xy; \n        state.xy = A(where).xy;\n        \n        // Correct the advection to reduce the divergence. \n        // It's not a real constraint on divergence since the divergences is not 0\n        // after this correction. \n        // But it correct it enough to allow a full explicit scheme of the equation\n        state.xy += dt*(viscosity - PdX);\n        \n        // Boundaries\n        state.xy *= Bound(uvf); \n\n        // Clamping in order to mitigate exploding scheme. This setting is completly arbitrary\n        state = clamp(state, vec4(vec2(-10.), .5, -10.), vec4(vec2(10), 3., 10.));\n    }\n    \n    \n    fragColor = state;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) textureLod(iChannel0, u, 0.)\n#define R iResolution.xy\n#define dx vec2(1./iResolution.x, 0)\n#define dy vec2(0, 1./iResolution.y)\nvec4 init_lattice(vec2 uv){\n    return vec4(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    ivec2 uv = ivec2(fragCoord.xy);\n    vec2 uvf = fragCoord.xy/R.xy;\n    \n    vec4 state;    \n    // Init lattice\n    if (iFrame < 1){\n        state = init_lattice(uvf);\n    }    \n        \n    else{\n        // X,Y is for velocity, Z for density, W is not used here.\n        state = A(uvf);                \n               \n        float S = K/dt;\n        vec4 sl = A(uvf-dx);\n        vec4 sr = A(uvf+dx);\n        vec4 su = A(uvf-dy);\n        vec4 sd = A(uvf+dy);\n        \n        \n        vec4 Udx = (sr-sl)*.5; // Differential respect to x\n        vec4 Udy = (su-sd)*.5; // Differential respect to y\n        \n        float Udiv = Udx.x + Udy.y; // Velocity divergence\n        vec2 DdX = vec2(Udx.z, Udy.z); // density's gradient\n        \n        // Diffusion        \n        state.z -= kappa*dt* dot(vec3(DdX, Udiv), state.xyz);        \n        \n        // Pressure Thing's\n        vec2 PdX = S*DdX; // grad P = K * grad rho\n        vec2 L = (sl.xy + sr.xy + su.xy + sd.xy) - 4.*state.xy; // velocity's laplacian \n        vec2 viscosity = v*L; \n\n        // Semi Lagrangian advection\n        vec2 where = uvf - (dt*state.xy)*N/iResolution.xy; \n        state.xy = A(where).xy;\n        \n        // Correct the advection to reduce the divergence. \n        // It's not a real constraint on divergence since the divergences is not 0\n        // after this correction. \n        // But it correct it enough to allow a full explicit scheme of the equation\n        state.xy += dt*(viscosity - PdX);\n                \n        // Boundaries\n        state.xy *= Bound(uvf); \n\n        // Clamping in order to mitigate exploding scheme. This setting is completly arbitrary\n        state = clamp(state, vec4(vec2(-10.), .5, -10.), vec4(vec2(10), 3., 10.));\n    }\n    \n    \n    fragColor = state;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 158, 158, 292], [293, 293, 350, 350, 1304]], "test": "untested"}
{"id": "mdXSRj", "name": "My Raytrace", "author": "SONENEIS", "description": "...", "tags": ["raytracing", "ray", "raycasting", "lighting", "spheres", "raytrace", "pathtracing", "tracing", "tracing", "chess", "scene", "trace", "path", "cast", "casting"], "likes": 2, "viewed": 155, "published": 3, "date": "1669187562", "time_retrieved": "2024-07-30T16:17:46.419417", "image_code": "#define AA 1\n\nstruct Inter{\n  float t;\n  vec3 nor;\n  float id;\n};\n\nInter iUn(Inter a,Inter b){\n  if(b.t > -1.0 && b.t < a.t) return b;\n  return a;\n}\n\nInter iSphere(float id,vec3 ro,vec3 rd,Inter a,vec4 sph){\n\tInter t;\n\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tt.t = -b - sqrt(h);\n\tif(h < 0.0) t.t = -1.0;\n\n\tt.id = id;\n\n\tvec3 pos = ro+rd*iUn(a,t).t;\n\tt.nor = (pos-sph.xyz)/sph.w;\n\n\treturn t;\n}\n\nInter iPlane(float id,vec3 ro,vec3 rd,vec4 pln){\n\tInter t;\n\tt.t = -(dot(rd,pln.xyz)+pln.w)/dot(rd,pln.xyz)+pln.w;\n\tt.id = id;\n\tt.nor = pln.xyz;\n\treturn t;\n}\n\nInter raycast(vec3 ro,vec3 rd){\n\tInter t;\n\tt.id = -1.0;\n\tt.t = 99999999.9;\n    t.nor = vec3(0.0);\n\tvec3 pos = ro+rd*t.t;\n\n  // scene //\n\n\tt = iUn(t,iPlane(3.0,ro,rd,vec4(0.0,1.0,0.0,1.0)));\n\tt = iUn(t,iSphere(1.0,ro,rd,t,vec4(0.0,0.0,0.0,1.0)));\n\tt = iUn(t,iSphere(2.0,ro,rd,t,vec4(1.0,-0.7,1.0,0.3)));\n\tt = iUn(t,iSphere(0.0,ro,rd,t,vec4(-0.8,-0.85,1.0,0.15)));\n\n\treturn t;\n}\n\nvec3 render(vec2 uv){\n\tvec3 col = vec3(0.0);\n\n\tvec3 ro = vec3(0.0,0.0,3.5);\n\tvec3 rd = normalize(vec3(uv,-2.0));\n\n\tInter t = raycast(ro,rd);\n\tvec3 nor = t.nor;\n\tvec3 pos = ro+rd*t.t;\n  vec3 mate = vec3(0.0);\n\n\tif(t.id == 0.0){\n\t\tmate = vec3(0.0,0.0,1.0);\n\t}else if(t.id == 1.0){\n\t\tmate = vec3(1.0,0.0,0.0);\n\t}else if(t.id == 2.0){\n\t\tmate = vec3(0.0,1.0,0.0);\n\t}else if(t.id == 3.0){\n\t\tmate += 0.5+0.5*mod(floor(pos.x*5.0)+floor(pos.z*5.0),2.0);\n\t}\n\n\tvec3 bgCol = vec3(0.5,0.5,0.5);\n\tvec3 fogCol = vec3(0.0,0.0,0.0);\n\tvec3 fog = mix(bgCol,fogCol,1.0-rd.y);\n\n\tif(t.id != -1.0){\n\t\tcol = vec3(0.0);\n\t\tvec3 lig = normalize(vec3(0.5));\n\t\tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n\t\tfloat sha = step(1.0,raycast(pos+0.58,lig).t);\n\t\tcol += mate * dif * sha;\n\t}\n\n\tcol = mix(col,fog,clamp(0.0001*t.t*t.t*t.t,0.0,1.0));\n\n\t//col = pow(col,vec3(1.0/3.3));\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec3 col = vec3(0.0);\n\n  #if AA > 1\n  for(int i=0;i<AA;i++)\n  for(int j=0;j<AA;j++){\n    vec2 o = vec2(float(i),float(j));\n    vec2 uv = (2.0*(fragCoord-o)-iResolution.xy)/iResolution.y;\n  #else\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  #endif\n    col += render(uv);\n  #if AA > 1\n  }\n  col /= float(AA*AA);\n  #endif\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 94, 94, 148], [150, 150, 207, 207, 457], [459, 459, 507, 507, 615], [617, 617, 648, 648, 993], [995, 995, 1016, 1016, 1852]], "test": "untested"}
{"id": "DsfSz2", "name": "point step", "author": "lomateron", "description": "click to interact\n.xy = velocity\n.z = mass\nBuffer A tab applies some convolution and the result is in .xy\nthis result is added to the velocity in Buffer B tab", "tags": ["simulation"], "likes": 26, "viewed": 325, "published": 3, "date": "1669184698", "time_retrieved": "2024-07-30T16:17:50.093594", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = a.zzzz;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        r.xy += c   *(sin(dot(b.xy,vec2(i,j))))*exp(-l*l*.2)*-.06;\n        r.xy += a.xy*(sin(dot(b.xy,vec2(i,j))))*exp(-l*l*.3)*.45;\n        r.xy += a.xy*(cos(dot(b.xy,vec2(i,j))))*exp(-l*l*.3)*-.1;\n        \n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy +B(u).xy;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j));\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j));\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(-normalize(m),0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        vec2 m = 8.*(u-iResolution.xy*.5)/450.;\n        a = vec4(0,0,.5,0)-vec4(8,8,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 157]], "test": "untested"}
{"id": "ddlXzB", "name": "ferquency domain eq #2", "author": "jonasfrey", "description": "simple eq inside the frequency domain", "tags": ["eq"], "likes": 8, "viewed": 188, "published": 3, "date": "1669162686", "time_retrieved": "2024-07-30T16:17:51.263466", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy - iResolution.xy*0.5)/iResolution.y;\n    \n    if(iMouse.w == 0.){\n        o_mou_coo_nor = vec2(0.01, 0.0);\n    }\n    \n    float n_freqs = o_mou_coo_nor.x*1000.0;\n    n_freqs = 111.; //tmp static\n    vec2 o_opcn_big = o_pix_coo_nor*vec2(n_freqs);\n    vec2 o_opcn_big_mod = fract(o_opcn_big);\n    vec2 o_opcn_big_floor = floor(o_opcn_big);\n    // 0.1, 0.1, 0.1, instead of 0.13, 0.16, 0.19...\n    vec2 o_pix_coo_nor_subdivfloor = vec2(1.) / o_opcn_big_floor;\n    \n    float n_amp = texture(iChannel0,abs(o_pix_coo_nor_subdivfloor)).x; \n    n_amp *=0.5;\n    fragColor = vec4(length(o_opcn_big_mod-vec2(0.5)));\n    //if(n_amp < abs(o_pix_coo_nor.y)){\n    float n_delta = (n_amp*n_freqs) - abs(o_opcn_big.y);\n    if(n_delta < 0.){\n        vec2 o_mod = fract(vec2(o_opcn_big.x, (n_amp*2.0*n_freqs)));\n        \n        float n_length = length(o_mod-vec2(0.5));\n        //fragColor = vec4(abs(n_delta/n_freqs));\n        fragColor = vec4(n_length*fract(n_delta));\n    }\n    \n\n}", "image_inputs": [{"id": 30554, "src": "https://soundcloud.com/mmw/sham-time?in=mmw/sets/mmw-tracks&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1233]], "test": "untested"}
{"id": "DdXSRj", "name": "subdivision preset", "author": "jonasfrey", "description": "mouse x-axis : change the size of the subdivision grid", "tags": ["preset"], "likes": 1, "viewed": 144, "published": 3, "date": "1669161151", "time_retrieved": "2024-07-30T16:17:52.389455", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy - iResolution.xy*0.5)/iResolution.y;\n    \n    if(iMouse.w == 0.){\n        o_mou_coo_nor = vec2(0.2, 0.0);\n    }\n    float n_freqs = o_mou_coo_nor.x*1000.0;\n    \n    vec2 o_opcn_big = o_pix_coo_nor*vec2(n_freqs);\n    vec2 o_opcn_big_mod = fract(o_opcn_big);\n\n    fragColor = vec4(length(o_opcn_big_mod-vec2(0.5)));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 536]], "test": "untested"}
{"id": "dssXzB", "name": "Kleinian - \"Grandma's Recipe\"", "author": "amoser", "description": "An \"escape time\" algorithm for drawing limit sets based on \"Grandma's Recipe\" from Indra's Pearls. See comments.", "tags": ["fractal", "math", "mobius", "kleinian", "set", "limit", "pearls", "indras"], "likes": 26, "viewed": 513, "published": 3, "date": "1669160394", "time_retrieved": "2024-07-30T16:17:53.561323", "image_code": "// An algorithm for drawing limit sets of Kleinian groups specified by \"Grandma's Recipe\" from the book \n// Indra's Pearls by David Mumford, Caroline Series, and David Wright. It's somewhat similar in spirit to\n// Jos Leys' algorithm https://www.shadertoy.com/view/MtKXRh , but it also supports groups where traces of \n// both generators are complex (i.e. groups that are not Maskit groups). It's also slower and less robust,\n// at least at the moment.\n\n// The ultimate goal is to use this to render 3D limit sets (which is also why this code features lots of\n// quaternions for seemingly no reason) since it should be applicable pretty directly, but I thought this\n// version looked pretty OK in its own right and might be useful to someone.\n\n// I hope it's relatively readable as well.\n\n// Uncomment to view the estimated Schottky curves used to determine which transformation to apply at\n// each iteration.\n//#define DEBUG_VIEW\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.0;\n    vec2 z = zoom*(2.0*(fragCoord.xy) - iResolution.xy) / iResolution.y;\n    \n    vec2[] ta = vec2[]\n    (\n        vec2(2,0),\n        vec2(2,0.2),\n        vec2(2,0.2),\n        vec2(2,-0.2),\n        vec2(2,-0.2),\n        vec2(1.8,-0.2),\n        vec2(1.8,-0.2),\n        vec2(2,0),\n        vec2(2,0),\n        vec2(1.8,-0.2),\n        vec2(2.2,0),\n        vec2(2.1,-0.4),\n        vec2(2,-0.9),\n        vec2(1.9,-1.4)\n    );\n    vec2[] tb = vec2[]\n    (\n        vec2(2,0),\n        vec2(2,0),\n        vec2(2,0.2),\n        vec2(2,0.2),\n        vec2(2,-0.2),\n        vec2(2,-0.2),\n        vec2(1.8,-0.2),\n        vec2(2,0),\n        vec2(1.8,0.2),\n        vec2(1.8,0.2),\n        vec2(2.2,0),\n        vec2(2.1,-0.4),\n        vec2(2,-0.9),\n        vec2(1.9,-1.4)\n    );\n    \n\n    float time = mod(iTime/2.0,float(ta.length()));\n    int index = int(floor(time));\n    float blend = fract(time);\n    vec2 tracea = mix(ta[index],ta[(index + 1)%ta.length()],smoothstep(0.0,1.0,smoothstep(0.0,1.0,blend)));\n    vec2 traceb = mix(tb[index],tb[(index + 1)%ta.length()],smoothstep(0.0,1.0,smoothstep(0.0,1.0,blend)));\n\n    // The actual generators to be calculated based on their traces.\n    transform a;\n    transform b;\n    transform A;\n    transform B;\n\n    // Construct the generating transformationa a, b, A, and B.\n    grandmaRecipe(vec4(tracea, 0, 0), vec4(traceb, 0, 0), a, b, A, B);\n    \n    // We're specifically interested in the properties of the fixed points of the commutators since they\n    // give useful information about the Schottky curves we need to make the algorithm work.\n    transform comAB = commutator(A,B);\n    transform comAb = commutator(A,b);\n\n    vec4 comabf1, comabf2, comABf1, comABf2, comaBf1, comaBf2, comAbf1, comAbf2;\n    fixedPoints(comAB,comABf1,comABf2);\n    fixedPoints(comAb,comAbf1,comAbf2);\n    // No need to calculate these two, since they're always the same for this family of groups.\n    comabf1 = vec4(1,0,0,0);\n    comaBf1 = vec4(-1,0,0,0);\n    \n    vec4 fa1, fb1, fA1, fB1, fa2, fb2, fA2, fB2;\n    fixedPoints(a,fa1,fa2);\n    fixedPoints(b,fb1,fb2);\n    fixedPoints(A,fA1,fA2);\n    fixedPoints(B,fB1,fB2);\n    \n    vec3 col = vec3(1);\n    \n    const int maxIter = 30;\n    float scale = 1.0;\n    float de = 1.0;\n    \n    // Stores the z value whenever we apply transformation b.\n    // If we're at the same position the next time we apply this transformation, we know that the orbit\n    // has become periodic and can break out of the main loop.\n    vec2 lastb = vec2(-10000);\n\n#ifdef DEBUG_VIEW\n    col *= 0.5;\n    \n    // Triangles used as a base for estimating the Schottky curves. Two vertices are placed\n    // at the fixed points of the commutators, which are always points where the Schottky\n    // curves touch. The third vertex is placed at a fixed point of the inverse transformation,\n    // which will be the \"tip\" of the limit set.\n    // There are some really obvious ways to make the estimate much more accurate that I'll get to\n    // eventually.\n    col.g += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy))));\n    col.rg += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy))));\n    col.b += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy))));\n    col.r += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy))));\n    col.r += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy))));\n    col.r += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))));\n    \n    // Final (estimated) Schottky regions determined by choosing the closest triangle to a given point.\n    // You can observe (at least in cases where the Schottky regions are valid) that each colored region\n    // contains a distorted copy of all of the other colored regions, wich is the key to why this works.\n    if(sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n    {\n        col.g += 0.1;\n    }\n    else if((z.x >= comaBf1.x\n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n        || (z.x < comaBf1.x && z.y < comaBf1.y))\n    {\n        col.rg += 0.1;\n    }\n    else if((z.x <= comabf1.x\n        && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n        && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n        || (z.x > comabf1.x && z.y < comabf1.y))\n    {\n        col.b += 0.1;\n    }\n    else\n    {\n        col.r += 0.1;\n    }\n#endif\n\n    // The actual \"escape time\" algorithm based on the regions above.\n    for(int i = 0; i < maxIter; i++)\n    {\n        // Add the known limit set points to distance estimate. \n        // By definition, they'll remain in the limit set after each transformation is applied.\n        de = min(de, scale*min(min(distance(z, fB1.xy), distance(z, comABf1.xy)),distance(z, comaBf1.xy)));\n        de = min(de, scale*min(min(distance(z, fb1.xy), distance(z, comabf1.xy)),distance(z, comAbf1.xy)));\n        de = min(de, scale*min(distance(z, fA1.xy), distance(z, -fA1.xy)));\n        de = min(de, scale*min(distance(z, -fB1.xy), distance(z, -comABf1.xy)));\n        de = min(de, scale*min(distance(z, -fb1.xy), distance(z, -comAbf1.xy)));\n\n        // Apply relevant transformation based on which Schottky region we're in.\n        if(sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n        {\n            scale /= clamp(jacobian(a, vec4(z,0,0)),-40.0,40.0);\n            z = applyTransform(a, vec4(z,0,0)).xy;\n        }\n        else if((z.x >= comaBf1.x\n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n            || (z.x < comaBf1.x && z.y < comaBf1.y))\n        {\n            if(distance(z, lastb) < 0.00001)\n            {\n                // Orbit has become periodic.\n                break;\n            }\n            lastb = z;\n            scale /= clamp(jacobian(b, vec4(z,0,0)),-40.0,40.0);\n            z = applyTransform(b, vec4(z,0,0)).xy;\n        }\n        else if((z.x <= comabf1.x\n            && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n            && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n            || (z.x > comabf1.x && z.y < comabf1.y))\n        {\n            scale /= clamp(jacobian(B, vec4(z,0,0)),-40.0,40.0);\n            z = applyTransform(B, vec4(z,0,0)).xy;\n        }\n        else\n        {\n            // Just exploiting that \"Grandma's\" groups are defined in such a way that they all have 180 degree\n            // rotational symmetry, so we don't need to do anything about the upper Schottky region directly.\n            // Applying the A transformation would also work, but it's slower to calculate and introduces more\n            // distortion into the distance estimate.\n            z = -z;\n        }\n    }\n    \n    col *= min(1.0, (0.5/zoom)*iResolution.y*de);\n\n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "\n// Mobius transformation (az+b)/(cz+d) with quaternion a, b, c, d\n// Quaternions are used only to allow the transformations to be applied to 3D points for a future version of \n// this algorithm. As such, most of the operations aren't guaranteed to work in general but should be correct \n// for complex valued transformations.\n// Thanks to https://www.shadertoy.com/view/MddfD7 for making me realize that this actually does \"just work\"\n// to apply mobius transformations to points in 3D space.\nstruct transform\n{\n    vec4 a;\n\tvec4 b;\n\tvec4 c;\n\tvec4 d;\n};\n\nvec4 qconj(in vec4 q)\n{\n    return vec4(q.x, -q.yzw);\n}\n\nvec4 qinv(in vec4 q)\n{\n \treturn qconj(q) / dot(q,q);\n}\n\nvec4 qmul(in vec4 p, in vec4 q)\n{\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\n\nvec4 qdiv(in vec4 p, in vec4 q)\n{\n    return qmul(p, qinv(q));\n}\n\nvec4 qmobius(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 z)\n{ \n    return qdiv(qmul(a,z) + b, qmul(c,z) + d);\n}\n\nvec2 cmul(in vec2 za, in vec2 zb)\n{\n    return za*mat2(zb.x, -zb.y, zb.yx);\n}\n\nvec2 cinv(in vec2 z) \n{\n    return z*vec2(1, -1)/dot(z,z);\n}\n\nvec2 cdiv(in vec2 za, in vec2 zb)\n{\n    return cmul(za, cinv(zb));\n}\n\nvec2 cexp(in vec2 z) \n{\n    return exp(z.x)*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 clog(in vec2 z) \n{\n    return vec2(log(length(z)), atan(z.y,z.x));\n}\n\nvec2 cpow(in vec2 z, in float n)\n{\n    return cexp(n*clog(z));\n}\n\nvec2 csqrt(in vec2 z)\n{\n    return cpow(z, 0.5);\n}\n\nvec4 applyTransform(in transform t, in vec4 z)\n{\n    vec4 res = qmobius(t.a, t.b, t.c, t.d, z);\n    return res;\n}\n\ntransform composeTransform(in transform a, in transform b)\n{\n    transform res;\n    \n    res.a = qmul(b.a, a.a) + qmul(b.b, a.c);\n    res.b = qmul(b.a, a.b) + qmul(b.b, a.d);\n    res.c = qmul(b.c, a.a) + qmul(b.d, a.c);\n    res.d = qmul(b.d, a.d) + qmul(b.c, a.b);\n        \n    return res;\n}\n\ntransform invertTransform(in transform t)\n{\n    transform res;\n    \n    res.a = t.d;\n    res.b = -t.b;\n    res.c = -t.c;\n    res.d = t.a;\n    \n    return res;\n}\n\ntransform commutator(in transform a, in transform b)\n{\n    transform A = invertTransform(a);\n    transform B = invertTransform(b);\n    transform res = composeTransform(A, composeTransform(B, composeTransform(a, b)));\n    \n    return res;\n}\n\nvec4 discriminant(in transform t)\n{\n    return qmul(t.a+t.d, t.a+t.d)-qmul(vec4(4,0,0,0),qmul(t.a,t.d)-qmul(t.b,t.c));\n}\n\nvoid fixedPoints(in transform t, out vec4 f1, out vec4 f2)\n{\n    f1 = qdiv((t.a-t.d)+vec4(csqrt(discriminant(t).xy),0,0), qmul(vec4(2,0,0,0), t.c));\n    f2 = qdiv((t.a-t.d)-vec4(csqrt(discriminant(t).xy),0,0), qmul(vec4(2,0,0,0), t.c));\n}\n\nfloat jacobian(in transform t, in vec4 z)\n{\n    vec4 denom = qmul(t.c, z) + t.d;\n    return length(qdiv(qmul(t.a,t.d)-qmul(t.b,t.c), qmul(denom, denom)));\n}\n\n// https://www.shadertoy.com/view/XsXSz4\n// ...with some added clamping as an ad hoc correction for some sloppiness I've introduced\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.00001, 0.9999 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.00001, 0.9999 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.00001, 0.9999 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// From Indra's Pearls by David Mumford, Caroline Series, and David Wright p. 229\nvoid grandmaRecipe(in vec4 ta, in vec4 tb, out transform a, out transform b, out transform A, out transform B)\n{\n    vec4 tmp = qmul(qmul(tb, ta), vec4(0.5,0,0,0));\n    vec4 tab = tmp-qmul(vec4(0,1,0,0),vec4(csqrt(-(qmul(tmp,tmp)-qmul(ta,ta)-qmul(tb,tb)).xy),0,0));\n\n    vec4 z0 = qdiv(qmul(tab - vec4(2,0,0,0),tb), qmul(tb,tab) - qmul(vec4(2,0,0,0),ta) + qmul(vec4(0,2,0,0), tab));\n    a.a = qmul(ta, vec4(0.5,0,0,0));\n    a.b = qdiv(qmul(ta, tab) - qmul(tb, vec4(2,0,0,0)) + vec4(0,4,0,0), qmul(qmul(tab, vec4(2,0,0,0)) + vec4(4,0,0,0), z0 ));\n    a.c = qdiv(qmul(qmul(ta, tab) - qmul(tb, vec4(2,0,0,0)) - vec4(0,4,0,0), z0), qmul(tab, vec4(2,0,0,0)) - vec4(4,0,0,0));\n    a.d = qmul(ta, vec4(0.5,0,0,0));\n\n    b.a = qmul(tb - vec4(0,2,0,0), vec4(0.5,0,0,0));\n    b.b = qmul(tb, vec4(0.5,0,0,0));\n    b.c = qmul(tb, vec4(0.5,0,0,0));\n    b.d = qmul(tb + vec4(0,2,0,0), vec4(0.5,0,0,0));\n    \n    B = invertTransform(b);\n    A = invertTransform(a);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mslSzS", "name": "Alpha Channel Debug Info", "author": "mla", "description": "I expect this has been done before: move shader code to a buffer and output debug information in alpha channel. Here we return the number of iterations of the main loop for the pixel under the mouse.", "tags": ["debug", "alpha", "sh17b"], "likes": 3, "viewed": 224, "published": 3, "date": "1669144509", "time_retrieved": "2024-07-30T16:17:55.095221", "image_code": "///////////////////////////////////////////////////////////////\n//\n// Alpha Channel Debug Info, mla, 2022.\n//\n// Main shader runs in a buffer. Image just copies through\n// from the buffer, but also reads and displays debug information\n// from the alpha channel for the pixel under the mouse.\n//\n///////////////////////////////////////////////////////////////\n\nfloat hud(vec2 fragCoord, vec4 data) {\n  const int digits = 7, nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1; // Reverse order of rows\n  if (column > 1 || row > 0) return 0.0;\n  float x = data[3-column];\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  // Get diffs for textureGrad\n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = printfloat(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c > 0) {\n    float charstart = charwidth*float(charpos); // character start\n    uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  }\n  vec4 t = textureGrad(iChannel3,uv,dx,dy);\n  if (c > 0) return t.x;\n  return 0.0;  \n}\n\nvoid mainImage( out vec4 o, in vec2 C ) {\n  o = texelFetch(iChannel0,ivec2(C),0).xyyy;\n  vec4 data = texelFetch(iChannel0,ivec2(iMouse.xy),0);\n  o = mix(o,vec4(1),hud(C,data));\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Original shader by Trisomie21\n\nvec2 Path(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\treturn textureLod(iChannel2, (p+vec2(37.5,17.5) + f)/256.0, 0.).xy;\n}\n\n#define S(x) vec4(Path(x*vec2(.04,.1))*vec2(6,9),0,0)\n\nvoid mainImage( out vec4 o, in vec2 C ) {\n    vec4 p = vec4(C.xy,0,0)/iResolution.xyxy-.5, d=p, t, c, s;\n    p.z += iTime*8.;\n    p -= S(p.z);\n    float x, r, w, i;\n    float count = 0.0;\n    float maxx = -1e8;\n    for(i=1.5; i>0.; i-=.01)\n    {\n        count++;\n        // Select one of 5 type of wood beam separation\n        vec2 z = (p.zz-2.)*.25;\n        z = Path(z - fract(z))*4.+.5;\n        z = (z - fract(z))/10.;\n        z = mix(z, vec2(1.), step(vec2(.4), z));      \n        z *= step(4., mod(p.z-2., 8.));\n\t\tfloat f = mix(z.x, z.y, step(p.x, 0.));                \n        \n        t = abs(mod(c=p+S(p.z), 8.)-4.);\n        w = step(0., c.y);\n        r = (step(2.6, t.x) - step(2.8, t.x)) * w;        \n        s = texture(iChannel0, (c.y*t.x > 3. ? t.zxy:t.yzx)-3.);\n        x = min(t.x + f, t.y)-s.x * (1.-r) - r*.8;  \n        maxx = max(x,maxx);               \n        if(x < .01) break;\n        p -= d*x*.5;\n     }\n    w = step(t.x, 0.8) * step(2.8, t.z) + step(2.8, t.x) * step(0., c.y);\n\to = p.wyyw*.02 + 1.3* mix(s, vec4(.8), r) * mix(vec4(1), vec4(1,.5,.2,1), w ) * i/p.w;\n    o.z = maxx;\n    o.w = count;\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\nint printfloat(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return 0;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  const int SPACE = 0x20;\n  if (isinf(x)) {\n    if (x < 0.0) CHAR(MINUS);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    if (1.0/x < 0.0) CHAR(MINUS);\n    CHAR(ZERO);\n  } else {\n    if (x < 0.0) CHAR(MINUS) // No semicolon!\n    else CHAR(SPACE);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return 0;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 398, 398, 1527], [1529, 1529, 1570, 1570, 1707]], "test": "untested"}
{"id": "7sKfzD", "name": "Shadow and Noob", "author": "snack19", "description": "a basic render of a noob", "tags": ["noob"], "likes": 3, "viewed": 123, "published": 3, "date": "1669139596", "time_retrieved": "2024-07-30T16:17:55.983845", "image_code": "vec2 opU(in vec2 a, in vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\n\nvec3 fog(in vec3 col, in float t){\n    vec3 ext = exp2(-t*1.25*vec3(0.000,0.518,1.000));\n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58);\n}\n\nvec2 sdNoob(in vec3 pos){\n    vec2 res = vec2(1000.0, -1.0);\n    vec3 torsoPos = vec3(0.0,0.0,0.0);\n    \n    vec3 ju = torsoPos + vec3(0.0,0.10,0.0);\n    vec3 jd = torsoPos + vec3(0.0,-0.10,0.0);\n    \n    vec3 jul = ju + vec3(0.0,0.0,0.17);\n    vec3 jur = ju + vec3(0.0,0.0,-0.17);\n    \n    vec3 jdl = jd + vec3(0.0,0.0,0.055);\n    vec3 jdr = jd + vec3(0.0,0.0,-0.055);\n    \n    vec3 headEuler = vec3(0.0,0.0,0.0);\n    \n    res = opU(res, vec2(sdSphere(pos - ju, 0.025), 3.0));\n    res = opU(res, vec2(sdRoundBox(pos - torsoPos , vec3(0.05,0.10,0.10), 0.01), 6.0));//Torso\n    \n    res = opU(res, vec2(sdRoundedCylinder((pos - ju  - vec3(0.0,0.067,0.0)), 0.032, 0.025, 0.032), 7.0));//Head\n    \n    res = opU(res, vec2(sdRoundBox(pos - jul - vec3(0.0,-0.1,0.0), vec3(0.05,0.10,0.05), 0.01), 7.0));//Left arm(z)\n    res = opU(res, vec2(sdRoundBox(pos - jur - vec3(0.0,-0.1,-0.0), vec3(0.05,0.10,0.05), 0.01), 7.0));//Right arm(-z)\n    \n    res = opU(res, vec2(sdRoundBox(pos - jdl - vec3(0.0,-0.12,0.0), vec3(0.05,0.10,0.045), 0.01), 8.0));//Left leg(z)\n    res = opU(res, vec2(sdRoundBox(pos - jdr - vec3(0.0,-0.12,0.00), vec3(0.05,0.10,0.045), 0.01), 8.0));//Left leg(z)\n    \n    return res;\n}\n\nvec2 map(in vec3 pos){\n    vec2 res = vec2(pos.y+0.5, 2.0);\n    res = opU(res, vec2(sdSphere(pos - vec3(0.5,0.0,0.0), 0.025), 3.0));\n    res = opU(res, vec2(sdSphere(pos - vec3(0.0,0.5,0.0), 0.025), 4.0));\n    res = opU(res, vec2(sdSphere(pos - vec3(0.0,0.0,0.5), 0.025), 5.0));\n    res = opU(res, sdNoob(pos));\n    return res;\n}\n\nvec2 rayCast(in vec3 ro, in vec3 rd, in int steps){\n    float t = 0.0;\n    float mate = -1.0;\n    for(int i=0;i<steps;i++){\n        vec2 d = map(ro + t*rd);\n        mate = d.y;\n        if(d.x < 0.0001 || t > 1000.0) break;\n        t += d.x;\n    }\n    if(t > 1000.0) mate = -1.0;\n    return vec2(t, mate);\n}\n\nvec3 calcNormal(vec3 p){\n    /*\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    ));\n    */\n    \n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e).x;\n    }\n    return normalize(n); \n}\n\nmat3 setCam(in vec3 ori, in vec3 tar, in vec3 up){\n    vec3 a = normalize(tar - ori);\n    vec3 b = normalize(cross(a, up));\n    vec3 c = normalize(cross(b, a));\n    return mat3(b, c, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float mo = (1.0 - iMouse.x / iResolution.x);\n    float moy = iMouse.y / iResolution.y;\n    float moz = iMouse.w / 800.0;\n    //vec3 ro = vec3(1.0*moz*cos(3.0*mo*radians(360.0)),2.0*moy-1.0 ,1.0*moz*sin(3.0*mo*radians(360.0)));\n    vec3 ro = vec3(0.0,0.5,0.0) * fromEuler(vec3(moy*1.0*radians(180.0),mo*1.0*radians(360.0),0.0));\n    vec3 rd =  setCam(ro, vec3(0.0,0.0,0.0), vec3(0.0,1.0,0.0))*normalize(vec3(uv, 1.5));\n    if(iMouse.xy == vec2(0)) ro = 5.*vec3(cos(iTime), 0., sin(iTime));\n    vec3 lightPos = normalize(vec3(1.0,1.0,0.5));\n    \n    float m = 9.0;\n    vec3 col = mix(vec3(0.831,0.961,0.969), vec3(0.090,0.569,0.631), -exp(-m*rd.y) + 1.0);\n    \n    vec2 hit = rayCast(ro, rd, 200);//Lighting\n    float t = hit.x;\n    float mate = hit.y;\n    if(mate > 0.0){\n        //Basic lighting\n        vec3 hitPos = ro + t*rd;\n        vec3 nor = calcNormal(hitPos);\n        \n        vec3 materialColor = vec3(0.471,0.471,0.471);\n        switch(int(mate)){\n            case 1:\n                materialColor = vec3(0.580,0.580,0.580);\n            break;\n            case 2:\n                materialColor = vec3(0.522,0.522,0.522);\n            break;\n            case 3:\n                materialColor = vec3(1.0,0.0,0.0);    \n            break;\n            case 4:\n                materialColor = vec3(0.0,1.0,0.0);\n            break;\n            case 5:\n                materialColor = vec3(0.0,0.0,1.0);\n            break;\n            case 6:\n                materialColor = vec3(25.0, 89.0, 154.0)/255.0;\n            break;\n            case 7:\n                materialColor = vec3(237, 230, 14)/255.0;\n            break;\n            case 8:\n                materialColor = vec3(144, 181, 74)/255.0;\n            break;\n            \n            \n        }\n        \n        float lightDif = clamp(dot(nor, lightPos), 0.0, 1.0);\n        float shaDif = step(rayCast(hitPos + 0.0001*nor, lightPos, 100).y, 0.0);\n        \n        col = vec3(0.529,0.529,0.529)*materialColor + lightDif * materialColor * vec3(0.902,0.686,0.216) * shaDif;\n        \n        //Fog\n        \n        int shadowStep = 40;\n        float fogLitPercent = 0.0f;\n        /*\n        for(int i=0;i<shadowStep;i++){\n            vec3 testPos = ro + rd * t * float(i)/float(shadowStep);\n            vec2 shaHit = rayCast(testPos, lightPos, 100);\n            fogLitPercent = mix(fogLitPercent, step(shaHit.y, 0.0), 1.0 / float(i+1));\n            \n        } \n        */\n        \n        //vec3 fogColor = mix(vec3(0.459,0.459,0.459), vec3(0.831,0.929,0.910), fogLitPercent);\n        //float absorb = exp(-t*0.2);\n        \n        \n        \n        col = fog(col, t);\n    }\n         \n         \n    if(mate < 0.0){\n    float sun = clamp(dot(lightPos, rd),0.0,1.0);\n    col += 1.5*vec3(0.8,0.4,0.2)*pow( sun, 13.0 );\n    }\n    col = pow(col, vec3(0.9));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\nmat3 rotateX(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        1,0,0,\n        0,c,s,\n        0,-s,c\n    );\n}\n\nmat3 rotateY(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        c,0,s,\n        0,1,0,\n        -s,0,c\n    );\n}\n\nmat3 rotateZ(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        c,s,0,\n        -s,c,0,\n        0,0,1\n    );\n}\n\nmat3 fromEuler(vec3 ro){\n    return rotateX(ro.x) * rotateY(ro.y) * rotateZ(ro.z);\n}\n\nfloat Noise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 65], [68, 68, 102, 102, 211], [213, 213, 238, 238, 1407], [1409, 1409, 1431, 1431, 1738], [1740, 1740, 1791, 1791, 2046], [2048, 2048, 2072, 2287, 2504], [2506, 2506, 2556, 2556, 2694], [2696, 2696, 2753, 2753, 5670]], "test": "untested"}
{"id": "mdsSRS", "name": "Infinite maze", "author": "jarble", "description": "An infinite procedural maze.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 5, "viewed": 284, "published": 3, "date": "1669138776", "time_retrieved": "2024-07-30T16:17:57.033040", "image_code": "float threshold = .5;\nint iters = 4;\n\n#define noise2D(p) float(((p).x * 68657387u ^ (p).y * 361524851u + (p).x) % 890129u) / 890128.\n\nbool labyrinth(uvec3 U,float n2){\n    //to do: make this work in 3 dimensions\n    //this would need a 3D noise function\n    uint c1 = 1u; //change this constant to get more interesting patterns\n    bvec3 b = bvec3(U & 1u+(U%c1));\n    return (b.x && b.y || b.x != b.y && n2 < threshold);\n}\n\nbool labyrinth(uvec2 U,float n2){\n    return labyrinth(uvec3(U,0.),n2);\n}\n\nvec4 maze1(uvec2 I){\n    vec4 O = vec4(1);\n    bool b = false;\n    float threshold = .5;\n    float n = 0.;\n    for(int i = 0; i++ < iters;I =\n    //Multiply and divide by prime numbers to get interesting patterns\n    I*2u/3u\n    //I*13u/17u\n    ){\n        //I += uint(i)+1u+uint(b);\n        \n        n =\n            noise2D(I)\n            //(noise2D(I)+n)/2.\n        ;\n        \n        //vertical tunnels\n        //I.y += uint(n*2.);\n        \n        //I.x += uint(n<1./16.);\n\n        b =\n            !b || labyrinth(I,n)\n            //!b || labyrinth(I,n) || labyrinth(I/2u,n)\n            //!b || labyrinth(I,n) || n > (8.*abs(.5-fract(iTime/16.))-.5);\n        ;\n        O -= float(n > .125)/float(iters)/4.;\n        \n        //some random-looking distortion\n        //{I = I+I.yx/(31u)-I.yx/(29u)-I.yx/(23u);}\n        //{I = I-I.yx/13u/11u/7u/5u+I.yx/11u/7u/5u-I.yx/7u/5u;}\n    }\n    if (b) O = 1.-O;\n    return O;\n}\n\nvec4 maze(uvec2 I){\n    return\n        maze1(I)\n        //max(maze1(I),maze1(I/2u))\n        //min(maze1(I),maze1(I/3u))\n    ;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = maze(I);\n}", "image_inputs": [], "sound_code": "\n#define fmod(x,y) floor(max(mod(floor(-(x))/2.,y),mod(floor(x),y)))\n\nvec2 mainSound(int samp, float time){\n  \n  time /= 8.;\n  float s1 =\n      5.,\n\n  s2 = 7.,\n\n  m1 =\n      fmod(time/s1,s2)\n  ,\n  t=\n      time*s2\n  ,\n  m4 =\n      fmod(t*s1,s2)\n  ,\n  m3 =\n      fmod((t+m4)*s1,s2);\n\n  float m2 =\n      1. + fmod(t,s1);\n  ;\n  \n  float a=\n      //32.*pow((1.-sqrt(fract(t*s1/4.)/(1.+m1)))/4.,2.)\n      log(1./4.+fract(-t*s1/4.)/4.)\n      //pow((1.-log(fract(t*s1/4.)/(1.+m1))),2.)\n  ;\n  \n  float nb = time*pow(2.,(m3+m2)/5.+9.5);\n\n  return\n      log(.1+abs(.5-vec2(fract(nb*.998),fract(nb))))*a\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 167, 253, 422], [424, 424, 457, 457, 497], [499, 499, 519, 519, 1417], [1419, 1419, 1438, 1438, 1546], [1548, 1548, 1584, 1584, 1641]], "test": "untested"}
{"id": "DdsSRS", "name": "Complex Cubic Equation Solver", "author": "mla", "description": "Take three complex numbers as roots of a cubic equation, compute the equation, then solve and compare with the original roots. The solved roots are marked by rings and the contours show the roots of the equation directly.\n\nUse mouse to drag roots around.", "tags": ["function", "complex", "cubic", "equation", "rational"], "likes": 17, "viewed": 288, "published": 3, "date": "1669135512", "time_retrieved": "2024-07-30T16:17:58.091211", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Complex Cubic Equations, mla, 2022.\n//\n// Take three complex numbers as roots of a cubic equation, compute the equation,\n// then solve and compare with the original roots. The solved roots are marked\n// by rings and the contours show the roots of the equation directly.\n//\n// Not visually very exciting as the root finding is pretty much spot on (at\n// least in the part of the complex plane we can see on the screen).\n\n// Use mouse to drag roots around.\n// 'a': hide axes\n// 'r': rotation\n// 'h': hide hud\n// 's': clamp roots to real line\n// 'n': apply final Newton-Raphson correction to all roots\n// 'c': apply NR step to complex cube root calculation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 ccuberoot(vec2 z) {\n  float t = carg(z)/3.0;\n  vec2 u = vec2(cos(t),sin(t));\n  float r = length(z);\n  z /= r;\n  if (key(CHAR_C)) {\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n\nmat3x2 solvecubic(vec2 p, vec2 q) {\n  // Solve depressed cubic: x³+3px+q = 0 - note factor of 3!\n  // Put x = u+v and get x³ = u³+v³+3xuv\n  // Substitute in original equation and get:\n  // u³+v³+(3uv+3p)x + q = 0\n  // Now let's constrain u,v so that uv+p = 0, and then:\n  // uv = -p ie. u³v³ = -p³ and u³+v³ = -q\n  // This gives a quadratic equation in t with roots u³ and v³:\n  // t²+qt-p³ = 0 so try to solve as:\n  // u³ = -q + sqrt(q²+4p³), v³ = -q - sqrt(q²+4p³)\n  // and take cube roots to get solution x = u+v.\n  //\n  // HOWEVER, we can't just combine any cube roots of the\n  // quadratic solutions, the condition uv+p = 0 above must also\n  // hold, so what we do is take either one of the quadratic\n  // solutions with its three cube roots as the three values\n  // of u, and derive the corresponding v's directly as v = -p/u.\n  // As with solving a real quadratic equation, it seems prudent\n  // to use the quadratic root with the largest absolute magnitude,\n  // and given one cube root, we can easily find the others by\n  // multiplying by the cube roots of unity, ω and ω².\n  vec2 q2 = cmul(q,q);\n  vec2 p3 = cmul(p,cmul(p,p));\n  vec2 s = csqrt(q2+4.0*p3);\n  float sign = dot(q,s) > 0.0 ? -1.0 : 1.0; // Get largest magnitude root\n  vec2 u3 = 0.5*(-q+sign*s);\n  vec2 u = ccuberoot(u3);\n  vec2 u1 = cmul(u,omega); // Get other cuberoots by multiplying by ω and ω².\n  vec2 u2 = cmul(u,omega2);\n  return mat3x2(u-cdiv(p,u), u1-cdiv(p,u1), u2-cdiv(p,u2));\n}\n\nmat3x2 solvecubic(vec2 B, vec2 C, vec2 D) {\n  // Solve x³+Bx²+Cx+D = 0\n  B /= 3.0; C /= 3.0;  // Simplifies sums\n  vec2 B2 = cmul(B,B); // Depress with x->x+B\n  // p = c-b*b\n  vec2 p = C-B2;\n  // q = 2.0*b*b*b - 3.0*b*c + d\n  vec2 q = cmul(B,2.0*B2-3.0*C) + D;\n  mat3x2 res = solvecubic(p,q);\n  // Undepress by subtracting B\n  return mat3x2(res[0]-B,res[1]-B,res[2]-B);\n}\n \nvec2 evalcubic(vec2 a, vec2 b, vec2 c, vec2 z) {\n  //(x-a)(x-b)(x-c)\n  vec2 res = z-a;\n  res = cmul(res,z-b);\n  res = cmul(res,z-c);\n  return res;\n}\n\nfloat hud(vec2 fragCoord, mat3x2 rootsin, mat3x2 rootsout) {\n  const int digits = 7;\n  const int nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1;\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  float x = 1.234;\n  if (row > 2) return 0.0;\n  for (int i = 0; i < 3; i++) {\n    if (row == i) {\n      if (column == 0) x = rootsin[i].x;\n      if (column == 1) x = rootsin[i].y;\n      if (column == 2) x = rootsout[i].x;\n      if (column == 3) x = rootsout[i].y;\n    }\n  }\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = floatchar(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c < 0) return 0.0;\n  float charstart = charwidth*float(charpos); // character start\n  uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  return t.x;  \n}\n\nmat3x2 sort(mat3x2 a) {\n  vec2 tmp;\n  if (a[0].x > a[1].x) tmp = a[0], a[0] = a[1], a[1] = tmp;\n  if (a[1].x > a[2].x) tmp = a[1], a[1] = a[2], a[2] = tmp;\n  if (a[0].x > a[1].x) tmp = a[0], a[0] = a[1], a[1] = tmp;\n  return a;\n}\n\nfloat showkeys(vec2 fragCoord) {\n  float K = 30.0;\n  if (fragCoord.y > K) return 0.0;\n  int box = int(fragCoord.x/K);\n  if (box >= 2) return 0.0;\n  if (box == 0 && !key(CHAR_N)) return 0.0;\n  if (box == 1 && !key(CHAR_C)) return 0.0;\n  vec2 boxcoord = mod(fragCoord,K)/K-0.5;\n  float px = 0.5/K;\n  return 1.0-smoothstep(-px,px,length(boxcoord)-0.4);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    setscale();\n    vec2 z = map(fragCoord);\n    vec2 a = getselection(0);\n    vec2 b = getselection(1);\n    vec2 c = getselection(2);\n    if (key(CHAR_S)) a.y = b.y = c.y = 0.0; \n    vec3 col1 = vec3(1,1,0);\n    vec3 col2 = vec3(0,1,1);\n    vec3 neutral = vec3(1,0,0);\n\n    vec2 w = evalcubic(a,b,c,z);\n    if (!key(CHAR_R)) {\n      float t = 0.25*iTime;\n      w = cmul(w,vec2(cos(t),sin(t)));\n    }\n    w = clog(w);\n    float alpha = w.y/PI;\n    vec3 basecol = alpha < 0.0 ? col1 : col2;\n    vec3 color = mix(neutral,basecol,abs(alpha));\n    \n    float px = fwidth(length(z));\n    if (!key(CHAR_A)) {\n      // Draw axes\n      float eps = 0.05;\n      float d = min(abs(z.x),abs(z.y));\n      float x = z.x-round(z.x);\n      float y = z.y-round(z.y);\n      d = min(d,segment(vec2(x,z.y),vec2(0,-eps),vec2(0,eps)));\n      d = min(d,segment(vec2(z.x,y),vec2(-eps,0),vec2(eps,0)));\n      color = mix(vec3(0),color,smoothstep(0.0,px,d));\n    }\n    float t = 0.5+atan(w.x)/PI;\n    vec2 uv = 10.0*w/PI;\n    float px2 = fwidth(uv.x);// fwidth for function result\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    color = mix(vec3(t),color,smoothstep(0.0,px2,min(uv.x,uv.y)));\n    // Now let's solve the cubic equation and see if we get the\n    // original roots back.\n    // x³+Ax²+Bx+C = 0\n    vec2 A = -(a+b+c);\n    vec2 B = cmul(a,b)+cmul(b,c)+cmul(c,a);\n    vec2 C = -cmul(a,cmul(b,c));\n    mat3x2 roots = solvecubic(A,B,C);\n    if (key(CHAR_N)) {\n     for (int i = 0; i < 3; i++) {\n        vec2 z = roots[i];\n        z -= cdiv(C+cmul(z,B+cmul(z,A+z)),B+cmul(z,2.0*A+3.0*z));\n        roots[i] = z;\n      }\n    }\n    roots = sort(roots);\n    for (int i = 0; i < 3; i++) {\n      vec2 w = roots[i];\n      // Draw a little circle around each root.\n      color *= smoothstep(0.0,px,abs(distance(w,z)-0.05));\n    }\n    if (!key(CHAR_H)) {\n      color = mix(color,vec3(0),hud(fragCoord,sort(mat3x2(a,b,c)),roots));\n      color = mix(color,vec3(0),showkeys(fragCoord));\n    }\n    \n    color = pow(color,vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n#define SELECTIONS\nconst int nselections = 3;\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-sqrt(3.0),-1);\n  if (i == 1) return vec2( sqrt(3.0),-1);\n  if (i == 2) return vec2(0,1.5);\n  return vec2(0);\n}\n\nconst float PI = 3.14159265;\nconst float TWOPI = 2.0*PI;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\n\nvec2 csqrt(vec2 z) {\n  float t = carg(z);\n  return sqrt(length(z))*vec2(cos(0.5*t),sin(0.5*t));\n}\n\nvec2 ccbrt0(vec2 z) {\n  // Trigless Newton Raphson verson\n  float r = length(z);\n  z /= r; // Normalize z\n  vec2 u = z+vec2(1,0); // First approximation (when normalized)\n  for (int i = 0; i < 4; i++) {\n    u = normalize(u);\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n\n// cuberoots of 1.\nconst vec2 omega = 0.5*vec2(-1,sqrt(3.0));\nconst vec2 omega2 = omega*vec2(1,-1);\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat scale = 1.0;\nvoid setscale() {\n  scale = 2.5;\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\nconst int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n#define SIGN(x) { if ((x) < 0.0) CHAR(MINUS) else CHAR(SPACE) } \n\n// Format x to digits precision and return the character at cindex,\n// or -1 if cindex is out of range.\nint floatchar(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return -1;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int SPACE = 0x20, ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    SIGN(x);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    // Maybe show the bits\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    SIGN(x);\n    CHAR(ZERO);\n  } else {\n    SIGN(x);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // This is a delicate business if we aren't to\n    // lose too much precision\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have a correctly rounded integer representation together\n    // with the correct exponent. The rest is just formatting.\n\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return -1;\n}", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0 && iFrame != 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.z = 1234.0;\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdsSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[826, 826, 850, 850, 1055], [1057, 1057, 1092, 2164, 2547], [2549, 2549, 2592, 2621, 2922], [2925, 2925, 2973, 2993, 3073], [3075, 3075, 3135, 3135, 4400], [4402, 4402, 4425, 4425, 4631], [4633, 4633, 4665, 4665, 4984], [4986, 4986, 5038, 5038, 7109]], "test": "untested"}
{"id": "DslSRS", "name": "Copperfield", "author": "SnoopethDuckDuck", "description": "kinda looks like a forcefield (fork is just an earlier version)", "tags": ["fractal", "stuff", "outline", "cool", "thing"], "likes": 10, "viewed": 204, "published": 3, "date": "1669134948", "time_retrieved": "2024-07-30T16:17:58.893067", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define piston(p) min(length(p.xy), min(mlength(p.xz), length(p.yz)))\n\n//nabbed from here: (i dont get it but it looks cool)\n//https://www.shadertoy.com/view/7stGWj\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvec3 rayOri() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 6. * cos(0.25 * iTime), 10);\n    ro.xz *= rot(pi/12. * thc(2., 0.5 * iTime));\n    return ro;\n}\n\nfloat dist(vec3 p) {\n    // rotate space + camera \n    // (rotating space changes reflections, rotating camera doesn't)\n    p.xz *= rot(pi/12. * thc(2., 0.5 * iTime));\n    \n    // distance to 2 planes\n    float pd = 2.5 * p.z + 7. + 0.5 - abs(p.x);  \n    \n    // fractal (i dont want to comment this =])\n    float d = MAX_DIST;  \n    float osc = 0.5 + 0.25 * cos(pi * exp(-length(p)) - iTime);\n    float m = 1. - osc;\n    float th = tanh(0.04 * iTime);\n    for (float i = 0.; i < 4.; i++) {\n        float io = pi * i / 4.;\n        p = sabs(p) - sqrt(2.) * m;\n        p.xy *= rot(io + 0.5 * iTime);\n        p.yz *= rot(io + 0.25 * iTime);\n        d = smin(d, \n                 smax(piston(p),\n                      length(p) - (1. + th * ths(2., io + iTime)) * m, \n                      0.02) - 0.75 * m, \n                 0.1);\n        m *= osc;\n    }\n    return min(pd, d);\n}\n\nfloat march(vec3 ro, vec3 rd, float z) {\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = dist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }    \n    return min(dO, MAX_DIST);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = dist(p);\n    vec2 e = vec2(.001, 0);    \n    vec3 n = d - vec3(\n        dist(p-e.xyy),\n        dist(p-e.yxy),\n        dist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\t \n    vec3  ro = rayOri();  \n    float th = tanh(0.1 * iTime);\n    vec3  rd = rayDir(uv, ro, vec3(0), 0.75 + 1.25 * th);\n    \n    vec3 col = vec3(0);\n      \n    float d = march(ro, rd, 1.);\n    vec3  p = ro + rd * d;\n    \n    if(d<MAX_DIST) {        \n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3    ld = normalize(vec3(1,3,3));\n        float  dif = 0.5 + 0.5 * dot(n,  ld);\n        float spec = pow(dif, 32.);\n        \n        // specular and shadows (I think)\n        vec3   q = p + 2. * SURF_DIST * n;\n        float d2 = march(q, ld, 1.);\n             col = spec * vec3(clamp(0.15 * d2, 0., 1.));\n        \n        // 50.->150. determines thickness of blue outline (sort of)       \n        vec3  q2 = p + mix(50., 150., th) * SURF_DIST * r;\n        float d3 = march(q2, rd, 1.);\n        vec3  p2 = q2 + rd * d3;\n        \n        // triplanar texture map (makes it darker and redder)\n        vec3 c1 = texture(iChannel0, p2.xy).rgb;\n        vec3 c2 = texture(iChannel0, p2.yz).rgb;\n        vec3 c3 = texture(iChannel0, p2.zx).rgb;\n              n = abs(n);\n        vec3  c = n.z * c1 + n.x * c2 + n.y * c3;\n            col *= c;\n        \n        // cubemap reflections (looks okay without)\n        vec3 tx3 = texture(iChannel1, r).rgb;\n             col *= 2. * (1. + thc(4., pi * 1.1 + 4. * tx3)) * tx3;\n             col = clamp(col, 0., 1.);\n\n        // blue outline\n        col = mix(col, vec3(1.-c), clamp(0.25 * d3, 0., 1.));\n  \n        // fog\n        vec3 fogCol = mix(vec3(0), vec3(234,201,103)/255., 1.-th);\n        col = mix(col, fogCol, 1.-1./cosh(.06*length(p.xy)));\n        \n        // tonemapping (probably)\n        col = ACESFilm(col);\n    }\n\n    col = pow(col, vec3(1./2.6));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh2(a*cos(b))/tanh2(a)\n#define ths(a,b) tanh2(a*sin(b))/tanh2(a)\n#define sabs(x) sqrt(x*x+1e-3)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// tanh approximation\n#define tanh2(a) clamp(a*(27.+a*a)/(27.+9.*a*a),-1.,1.) \n                 \n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 311, 333, 333, 421], [423, 423, 438, 438, 594], [596, 596, 616, 715, 1472], [1474, 1474, 1514, 1514, 1815], [1817, 1817, 1838, 1838, 2015], [2017, 2017, 2064, 2064, 2255], [2257, 2257, 2314, 2314, 4152]], "test": "untested"}
{"id": "cdsXRB", "name": "microscope test mobile", "author": "jonasfrey", "description": "original: https://www.shadertoy.com/view/DdlSzS\nthis is a test for mobile devices \n", "tags": ["microscope"], "likes": 0, "viewed": 165, "published": 3, "date": "1669132386", "time_retrieved": "2024-07-30T16:17:59.646053", "image_code": "//https://stackoverflow.com/questions/72479232/shader-fails-on-mobile\nprecision highp float; // Define float precision\nprecision highp int;   // Define int precision\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float n = 5.;\n\n    float n_x = mod(uv.x * (iResolution.x/n), 1.0);\n    if(n_x >= (1./n)*0.){\n        fragColor = vec4(1.);\n    }\n    if(n_x >= (1./n)*1.){\n        fragColor = vec4(0.);\n    }\n    if(n_x >= (1./n)*2.){\n        fragColor = vec4(0.5);\n    }\n    if(n_x >= (1./n)*3.){\n        fragColor = vec4(mod(iTime,1.));\n    }\n    if(n_x >= (1./n)*4.){\n        fragColor = vec4(float(mod(iTime,2.) > 1.));\n    }\n\n\n    // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 224, 276, 850]], "test": "untested"}
{"id": "DdlSzS", "name": "microscope screen test", "author": "jonasfrey", "description": "i am viewing a few of my screens under my microscope, therefore this shader can be used to compare\n\nmy current tests \nhttps://youtu.be/SU-Ut8GnZTc\nhttps://youtu.be/0SJ5WlnCmwA\nhttps://youtu.be/eXxBXS3zL98", "tags": ["microscope"], "likes": 2, "viewed": 161, "published": 3, "date": "1669129530", "time_retrieved": "2024-07-30T16:18:00.431952", "image_code": "//https://stackoverflow.com/questions/72479232/shader-fails-on-mobile\nprecision highp float; // Define float precision\nprecision highp int;   // Define int precision\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    bool b_matepad = false;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4[] a_o_col = vec4[](\n        vec4(1.),\n        vec4(0.), \n        vec4(0.5), \n        vec4(mod(iTime,1.)),\n        vec4(float(mod(iTime,2.) > 1.))\n    );\n    \n    float n_index = mod(fragCoord.x, float(a_o_col.length()));\n    if(!b_matepad){\n        fragColor = a_o_col[int(n_index)];\n    }\n    \n    // the above array technique is not working on my huawei matepad so i try this\n    n_index = mod(fragCoord.x, 2.);\n    float n = 5.;\n    \n    if(b_matepad){\n\n        uv.x = mod(uv.x * (iResolution.x/n), 1.0);\n        if(uv.x >= (1./n)*0.){\n            fragColor = vec4(1.);\n        }\n        if(uv.x >= (1./n)*1.){\n            fragColor = vec4(0.);\n        }\n        if(uv.x >= (1./n)*2.){\n            fragColor = vec4(0.5);\n        }\n        if(uv.x >= (1./n)*3.){\n            fragColor = vec4(mod(iTime,1.));\n        }\n        if(uv.x >= (1./n)*4.){\n            fragColor = vec4(float(mod(iTime,2.) > 1.));\n        }\n    \n    }\n\n\n    // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "csXSzS", "name": "[phreax] curved space", "author": "phreax", "description": "Experimenting with torus knots and iridescent metal shading as well as bump mapping (thanks to Shane)", "tags": ["raymarching", "metal", "moebius", "iridescent", "torusknot"], "likes": 20, "viewed": 413, "published": 3, "date": "1669127162", "time_retrieved": "2024-07-30T16:18:01.243782", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define PHI 1.618033988749895\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n//#define KALEIDOSCOPIC \n//#define POLARKALEI \n#define THICKNESS .01\n#define AA 0\n#define BUMP_EPS 0.004\n\n\nfloat tt, g_mat;\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nfloat fadeInOut(float t1, float t2, float fadeTime) {\n    return smoothstep(t1, t1+fadeTime, iTime)-smoothstep(t2-fadeTime, t2, iTime);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n// Amazing fractal texture from jarble https://www.shadertoy.com/view/csl3zl\nvec2 triangle_wave(vec2 a){\n    \n    vec2 a2 = vec2(1.,0.5),\n    \n    a1 = a-a2;\n    \n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\nvec3 kalei(vec3 p) {\n    float iter = 3.;\n    p.yz *= rot(tt);\n    p.xy = abs(p.xy)+.9;\n    \n    #ifdef POLARKALEI\n    p.xy = vec2(length(p.xy)*.8, atan(p.y, p.x));\n    #endif\n   \n    float s= 1.;\n    for(float i=0.; i< iter; i++) {\n        p = abs(p);  \n        p.xz *= rot(i/iter*PI+.2*tt);\n        p.xz += .2 - .1*i + sin(p.y*.2) + .2*exp(.01+p.z*.2);\n        p.z -= .2*sin(p.z*.5*i/iter*2.*PI);\n        p -= .2;\n         \n    }\n\n    return clamp(p, -1e5, 1e5);\n\n}\n\n// fold space for toroid\nvec3 transform(vec3 p) {\n    p.yz *= rot(PI*.25 + .1*tt);\n    p.xz *= rot(.2*tt);\n    \n    #ifdef KALEIDOSCOPIC\n    p = kalei(p);\n    #endif\n\n    float r = 1.9;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n    \n\n    float rev = 2.5;\n    float a = atan(p.z, p.x);\n    \n \n    cp *= rot(rev*a+.3*tt);\n    cp= abs(cp) - mix(.1, 1., SIN(tt));\n    cp *= rot(.5*tt);\n\n\n    return vec3(cp, p.z);\n}\n\n\nfloat map(vec3 p) {   \n  \n    vec3 bp = p;\n    float edge = 0.01;\n   \n    vec2 cp = transform(p).xy;\n    float dr = rect(cp.xy, vec2(.8, THICKNESS), edge);\n    \n    // g_mat = db < dr ? 1. : 0.;\n    float d = dr;\n    return .2*d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat bumpSurf3D( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*2., 2.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = vec3( bumpSurf3D(vec3(p.x-eps, p.y, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y-eps, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        if(abs(d) < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    return vec2(t, mat);\n}\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0);\n    #if AA>0\n    \n    for(int m=0; m<AA; m++) \n    for(int n=0; n<AA; n++) { \n        vec2 off = vec2(float(m), float(n));\n  \t    vec2 uv = (fragCoord+off - .5*iResolution.xy)/iResolution.y;\n    #else\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    #endif\n\n    tt = iTime + 17.;\n    vec3 ro = vec3(uv*6.,-4.),\n          rd = vec3(0,0,.6),\n          lp = vec3(2., 2., -10),\n          lp2 = vec3(-2., -3., -5);\n\n    vec3 col;\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.000,1.000,0.835);\n    vec3 c2 = vec3(1.000,0.494,0.078);\n    \n    // light color\n    vec3 lc1 = vec3(0.961,0.816,0.737);\n    vec3 lc2 = vec3(0.588,0.992,0.945);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 250.;\n        vec2 rm = raymarch(ro, rd, steps);\n        mat = rm.y;\n        \n        vec3 p = ro + rm.x*rd;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n        vec3 pt = transform(p);\n        vec3 np = transform(n);\n        n = doBumpMap(pt, n, .004);\n    \n     \n        if(rm.x < 50.) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n            float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n            vec3 iri = spectral_zucconi6(height*1.11)*smoothstep(.8, .2, abs(n2.z));\n       \n            col += dif*lc1*.6 + .8*dif2*lc2 + .8*iri + .1;\n           \n            if(mat == 0.) {\n                n += .5*texture(iChannel1, n.xy*100.).rgb;\n                rd = reflect(rd, n);\n         \n                vec3 refl = texture(iChannel0, rd).rgb;\n                \n                refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .6); // reflect rainbows too\n                col = mix(col, refl, .7);\n                \n                float height = atan(n.y, n.x);\n              \n            } \n\n        } else {\n            col =  mix(c1-.5, c2, (.9-pow(dot(uv, uv), .3)))*.2+.7; // background\n            \n        } \n    \n    }\n\n    \n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    col = pow(col, vec3(.7)); // gamma\n    \n    tot += col;\n    #if AA>0\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30403, "src": "https://soundcloud.com/irsodeh/hang-massive-warmth-of-the-sun-s-rays-official?si=c480cd1a77ee4cf4b7e5272752e38314&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXSzS.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[370, 370, 389, 389, 437], [439, 439, 492, 492, 576], [578, 671, 707, 707, 794], [797, 797, 830, 830, 1289], [1291, 1368, 1395, 1395, 1499], [1502, 1502, 1541, 1541, 1634], [1637, 1637, 1657, 1657, 2104], [2106, 2131, 2155, 2155, 2516], [2519, 2519, 2538, 2538, 2750], [2753, 2753, 2777, 2777, 3052], [3054, 3054, 3083, 3083, 3228], [3230, 3292, 3349, 3349, 3777], [3779, 3779, 3825, 3825, 4148], [4150, 4150, 4169, 4169, 4238], [4240, 4240, 4261, 4261, 4464]], "test": "untested"}
{"id": "dssXR7", "name": "Extruded Semi-regular Tiling", "author": "Shane", "description": "Rendering an extruded 3.4.6.4 semi-regular tessellation onto some warped planes.", "tags": ["raymarching", "demoscene", "warp", "glow", "tiling", "tile", "regular", "extrude", "semiregular"], "likes": 66, "viewed": 1027, "published": 3, "date": "1669125855", "time_retrieved": "2024-07-30T16:18:02.492443", "image_code": "/*\n\n    Extruded Semi-regular Tiling\n    ----------------------------    \n\n    A while ago, after looking at Fizzer's \"Wythoff Uniform Tilings + Duals\" example, I \n    got curious as to what one of the semi-regular tilings would look like in extruded\n    form. The variation I chose was a 3.4.6.4 semi-regular tessellation, which is formed \n    using a triangle, square and regular hexagon. I like it because it resembles \n    overlapping dodecahedrons. I'm not sure if the configuration has a special name, but \n    it's very common.\n    \n    Raymarching extruded grid tiles in realtime requires more planning and trickery than \n    their 2D counterparts. Luckily, the variation I chose came together fairly easily. \n    The extruded heightfield in planar form was kind of interesting, but a little \n    underwhelming, so I decided to jazz it up a bit by using a few cheap demoscene \n    cliches -- Warped space, cheap transparent tubes to emulate light rays, etc.\n    \n    I had the cathedral scene from Farbrausch's \"fr-08, .the .product\" 64k demo in the \n    back of my mind, when making this, for anyone who still remembers that. This is the \n    geometric alien chamber version... It's a very loose connection. :)\n    \n    As an aside, I went searching for examples of extruded semi-regular pattern imagery \n    and found none, which surprised me, since extruded regular prismatic square, hexagon, \n    etc, and simple variations are commonplace amongst the Blender, stock imagery crowd, \n    and so forth. Semi-regular variations are a natural extension of the aforementioned,\n    so I figured it'd be a common thing. There are probably examples out there, but it\n    was clear that the graphics crowd haven't adopted the more interesting variations yet.\n    \n    Anyway, for anyone ever in need of one of these, here's the code. I've explained the \n    general process inside the distance function. I'll leave the cell by cell traversal \n    as an exercise for the reader. :)\n\n\n    \n    Related examples:\n    \n    // There are a heap of standard semi-regular tilings in this example, and\n    // their duals, which is very handy when trying to visualize things.\n    Wythoff Uniform Tilings + Duals  - fizzer\n    https://www.shadertoy.com/view/3tyXWw\n    \n    // Hyperbolic semi-regular tilings. A really nice example. As an aside,\n    // I have an extruded hyperbolic regular tiled example somewhere.\n    Wythoffian Tiling Generator - mla\n    https://www.shadertoy.com/view/wlGSWc\n\n    \n*/\n\n  \n// Scene theme -- Timber: 0, Metallic\\Green: 1, Metallic\\Purple: 2.\n#define SCENE 0\n\n// I put this in as an afterthought, just to show that it could be done. At \n// present, it doesn't look very interesting, but I intend to produce a tailored\n// example with a different tiling arrangement later.\n//#define CYLINDRICAL\n\n// Global tile scale -- Left over from an old shader, so it needs to\n// be left alone... I'll tidy it up later.\nconst vec2 scale = vec2(1./8.);\n\n// Max ray distance.\n#define FAR 30.\n\n\n// Scene object ID.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    #ifdef CYLINDRICAL\n    // Wrapping for a cylinder.\n    p.x = mod(p.x, 1./scale.x);\n    #endif\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    // Reading into \"Buffer A\".\n    // Stretching to account for the varying buffer size.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    return texture(iChannel0, p + .5).x;\n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n//////////////////\n\n// Standard polar partitioning.\nvec2 polRot(vec2 p, inout float na, float aN){\n\n    float a = atan(p.y, p.x);\n    na = mod(floor(a/6.2831*aN), aN);\n    float ia = (na + .5)/aN;\n    p *= rot2(-ia*6.2831);\n\n    return p;\n}\n\n\n// Flat top hexagon scaling.\nconst vec2 s = vec2(1.7320508, 1);\n\n// Hexagon edge and vertex IDs. They're useful for neighboring edge comparisons,\n// etc. Multiplying them by \"s\" gives the actual vertex postion.\n//\n// Vertices and edges: Clockwise from the left.\n//\n// Note that these are all six times larger than usual. We're doing this to \n// get rid of decimal places, especially those that involve division by three.\n// I't a common accuracy hack. Unfortunately, \"1. - 1./3.\" is not always the \n// same as \"2./3.\" on a GPU.\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat getHex(in vec2 p, float r, in float sf){\n    \n      // Flat top.\n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n      // Pointed top.\n      //const vec3 k = vec3(.5, -.8660254, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      // Flat top.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n      // Pointed top.\n      //return length(p - vec2(r, clamp(p.y, -k.z*r, k.z*r)))*sign(p.x - r) - sf;\n    \n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n\n// IQ's signed box formula.\nfloat getSq(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 hexGrid(vec2 p){\n\n    // Extra scaling to wrap the pattern around a cylinder along the longer X-axis.\n    // If we were using the shorter one, it wouldn't matter.\n    //p *= s.x; \n   //p = p.yx;\n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n} \n\n// This mess is to account for cylindrical mapping, when used, but\n// it's not really needed here.\nconst float gridScale = 3./3.14159*1.*s.x;//3./3.14159*2.;\n\nfloat getHeight(vec3 c){ return dot(c, vec3(.299, .587, .114))*.3; }\n\nvec3 getColor(vec2 p){\n    \n    // The ID is in index form (multiplied by 12), so\n    // needs to be multiplied by \"s\". Plus there's the global scale, \"gridScale\" to consider.\n    // Viewport stretching, if needed.\n    // p *= vec2(iResolution.y/iResolution.x, 1);\n\n    p.x = mod(p.x, 1./scale.x);\n    \n    #if SCENE == 0\n    vec3 tx = texture(iChannel0, (p*s/gridScale/12./4. + .5), -100.).xyz; // Timber.\n    #else\n    vec3 tx = texture(iChannel1, (p*s/gridScale/12./4. + .5), -100.).xyz; // Metallic.\n    #endif\n    return tx*tx;\n    \n    //float rnd = hash21(p);\n    //return .5 + .45*cos(6.2831*rnd + vec3(0, 1, 2)*1.5);\n}\n\n\n// Z-axis twist. It's another demoscene cliche. Return mat2(1, 0, 0, 1) to see the\n// non-warped planes.\nmat2 mTwist(float z){ return rot2(z*.35); }\n\n// Space warping.\nvec3 coordTrans(vec3 p){\n    \n    #ifdef CYLINDRICAL\n    // Cylindrical transform.\n    const float aN = 1.;\n    //p.xy *= rot2(3.14159/aN);\n    float a = atan(p.x, p.y); // XY-plane pixel angle.\n    //float ia = floor(a/6.2831*aN);\n    //ia = (ia + .5)/aN;\n    //p.xy *= rot2(ia*6.2831);\n    // XY-plane polar coordinate.\n    p.xy = vec2(mod(a, 6.2831/aN) - 6.2831/aN/2., length(p.xy));\n    // Moving the radial surface out.\n    p.y = .5 - p.y;\n    #else\n    // Twisted planes transform. It's a demoscene favorite,\n    // since it's simple cheap and cool looking.\n    p.xy *= mTwist(p.z);\n    // Breaking up the symmetry between the top and bottom planes.\n    //p.xz += p.y<.0? vec2(0) : vec2(0, 4.5);\n    // Splitting into two planes.\n    p.y = .5 - abs(p.y);\n    #endif\n    \n    return p;\n\n}\n\n//////////////////\n\n\n// A global to stored the pylon's 2D face field value, the pylon height,\n// and the face's central position based ID.\nvec4 gVal;\nvec3 glow, lCol; // Global glow and glow color variables.\n\n// The scene.\nfloat map(vec3 p){\n\n    \n    // Apply the space transform.\n    p = coordTrans(p);\n    \n    // Floor -- I'm leaving it in, but we don't need it here.\n    float fl = 1e5;//(p.y + 32.) - 32.005; // Adding a touch of thickness to alleviate artifacts.\n \n \n    // The extruded 3.4.6.4 semi-regular tiling. First things first, pick any vertex on\n    // the plane, find the face with the lowest number of vertices (in this case a triangle),\n    // then proceed a full revolution counting the face vertices as you go along. You'll see\n    // that it's triangle, square, hexagon, square, or 3.4.6.4. That's how mathematicians\n    // decided to name these things.\n    //\n    // Anyway, in order to raymarch any extruded tiling pattern, you need to find a way to\n    // render overlaying grids of repeat objects that don't touch. It can be confusing at first,\n    // but you get used to it. For instance, in this pattern, the repeat hexagons don't touch\n    // one another, so you can render those. Note that the triangles don't touch either, so you\n    // can render those in polar form. That leaves the squares, which you'll see do touch in\n    // the corners. The trick there is to split them into two groups of three that are spaced\n    // apart... Yeah, as mentioned it's confusing at first, but you get used to it.\n    //\n    // The following is just an application of the above. I've renderd four interwoven repeat\n    // grids... which I complicated by including glow. However, for anyone wishing to do this,\n    // start from scratch, and use this as a guide, if need be.\n    \n    \n    // Hexagon grid. Returns the local coordinate and hexagon ID.\n    vec4 h = hexGrid(p.xz*gridScale);\n    \n    // Local coordinates.\n    vec2 q = h.xy;\n    // Face ID. It's multiplied by 12 to avoid GPU accuracy errors when dividing by 3...\n    // I've explained it before, but basically, \"1./3.\" and \"1. - 2./3.\" are not the same\n    // on a GPU due to rounding errors. However, \"4.\" and \"12. - 8.\" are equal.\n    vec2 id = h.zw*12.;\n    \n    // Face heights, 2D distance field values and associated 3D prism field values. \n    vec4 hgt4, d2D4, d3D4;\n    mat4x2 mID; // Four face IDs.\n    \n    mat4x2 svP; // Saving local coordinates.\n    \n    float r = sqrt(1./7.)*.8660254;\n    float ew = .01*gridScale;\n    \n\n    // Central hexagon values.\n    d2D4.x = getHex(q, r - ew, 0.);  \n    d2D4.x /= gridScale;\n    svP[0] = q;\n    mID[0] = id;\n    vec3 hCol = getColor(mID[0]);\n     // Extruding the 2D field.\n    hgt4.x = getHeight(hCol);\n    \n    \n    // Surrounding triangle values.\n    float na;\n    q = rot2(3.14159/6.)*h.xy;\n    q = polRot(q, na, 6.);\n    q.x -= .5/.8660254;\n    q *= rot2(3.14159/6.);\n    d2D4.y = getTri(q, r*.57735 - ew); // Triangle.\n    d2D4.y /= gridScale;\n    svP[1] = q;\n    //\n    // Moving the polar index to the correct starting position, since the polar index\n    // represents a different part of the hexagon. Thankfully, that didn't take me\n    // too long to figure out. :)\n    int ind = int(mod(8. - na, 6.));\n    mID[1] = id + vID[(ind)%6];\n    vec3 tCol = getColor(mID[1]);//vec3(.25, .6, 1)\n    hgt4.y = getHeight(tCol);\n \n    \n    // Three spaced out surrounding square values.\n    q = rot2(-3.14159/6.)*h.xy;\n    q = polRot(q, na, 3.);\n    q.x -= .5;\n    //d2D4.z = max(abs(q.x), abs(q.y)) - r*.57735 + ew; // Square one.\n    d2D4.z = getSq(q, vec2(r*.57735 - ew), 0.); // Square one.\n    d2D4.z /= gridScale;\n    svP[2] = q;\n    //\n    ind = int(mod(8. - na*2., 6.));\n    mID[2] = id + eID[(ind)%6];\n    vec3 sCol1 = getColor(mID[2]);//vec3(1, .9, .1)\n    //\n    hgt4.z =  getHeight(sCol1);\n\n\n    // The other three spaced out surrounding square values.\n    q = rot2(3.14159/6.)*h.xy;\n    q = polRot(q, na, 3.);\n    q.x -= .5;\n    //\n    d2D4.w = getSq(q, vec2(r*.57735 - ew), 0.); // Square two.\n    d2D4.w /= gridScale;\n    svP[3] = q;\n    //\n    ind = int(mod(7. - na*2., 6.)); // One less rotation, so one less index.\n    mID[3] = id + eID[(ind)%6];\n    vec3 sCol2 = getColor(mID[3]);//vec3(.5, 1, .2)  \n    //\n    hgt4.w = getHeight(sCol2);\n\n    // Glow colum variables.\n    float dd = 1e5, cLight = 1e5;\n    vec2 lgtID = vec2(0);\n    \n    \n    // Tapering ratio, relative to shape area.\n    //vec4 sL = vec4(1, 1./4.5, 1./18.,  1./18.);\n    //vec4 sL = vec4(1, .57735, .57735/2., .57735/2.);\n   \n\n    float d = 1e5;\n    for(int i = 0; i<4; i++){\n         \n        // Random face value.\n        float rndI = hash21(mID[i] + .05);\n        // Column type.\n        int type = 0;\n        float sv2D = d2D4.x; // Face distance value.\n        if(rndI<.35){ \n           \n            type = 1; // Non glowing, but flat.\n            // Random columns not running through the center.\n            if(rndI<.25 && abs(mID[i].x)>1.){\n                type = 2; // Flag it to glow.\n            }\n            \n            // For glowing or flat faced column, we only want the face edge.\n            d2D4.x = abs(d2D4.x + .02) - .02;\n         \n        }\n        \n        // The 3D extruded face. \n        d3D4.x = opExtrusion(d2D4.x, p.y - (hgt4.x/2. - 8.), hgt4.x/2. + 8.);\n        d3D4.x += d2D4.x*.25; // Raised tops.\n        // Not glowing, so cap off the hole... I was going to open and close\n        // the top to stream light through, but I ran out of steam. I might\n        // arrange for that later though.\n        if(type==1) d3D4.x = min(d3D4.x, max(sv2D, abs(p.y + .5) - .5)); \n        \n        // Minimum pylon distance.\n        if(d3D4.x<d){\n\n           d = d3D4.x;\n           // Saving global pylon values for later use.\n           gVal.x = d2D4.x; // 2D face field.\n           gVal.y = hgt4.x; // Pylon height.\n           gVal.zw = mID[i]; // Pylong ID.\n\n        }\n        \n        \n        // Constructing the light beams eminating from various grid shapes.\n        if(type == 2){\n            float cL = sv2D + .02; // Light colum, the same shape as the face. \n            //float cL = length(svP[i]) - pw.x*2.;//length(svP[i]) - .1;//\n            cL /= gridScale;\n            // Taper off the light rays as they get further from the source. The smaller windows\n            // are tapered off by a factor relative to the square of the side length.\n            cL += p.y*p.y*.2;//*sL[i]; \n            //cL *= 1./(1. + p.y*p.y*8.);    // Alternative way to do it.\n            // Save the closest beam and beam ID.\n            if(cL<dd){\n                dd = cL;\n                lgtID = mID[i];\n            }\n        }\n        \n        // Cyberjax's loop shuffling trick, which saves considerably on compiler time.\n        d3D4 = d3D4.yzwx;\n        d2D4 = d2D4.yzwx;\n        hgt4 = hgt4.yzwx;\n        \n    }\n    \n    // Overall object ID.\n    objID = fl<d? 1. : 0.;\n    \n    // Combining the floor with the extruded object. Redundant here.\n    d = min(fl, d);\n\n\n    // The glow color, which is just a smoothstepped 2D distance field\n    // column. I don't see glow calculated this way, but it's the way\n    // I prefer to do it. The glow calculation doesn't effect the scene \n    // geometry, but is passed on to the distance function for accumulation.\n    //\n    // No glow.\n    lCol = vec3(0);\n    // If the pylon is flagged to pass a glow colum through it, then \n    // calculate the glow field, and color.\n    if(dd<d){\n        dd = max(-dd, 0.);\n        vec3 cCol = .5 + .45*cos(6.2831*hash21(lgtID + .12)/4. + vec3(0, 1, 2));\n        //lCol = cCol.yxz*clamp(.0001/(.001 + dd*dd*4.), 0., 1.);\n        lCol = cCol*smoothstep(.0, .25, dd); //max(dd, 0.)*8.;\n    }\n        \n    \n    \n    // Return the minimum scene distance.\n    return  d;\n \n}\n\n// 3D noise texture. It's way faster than a handcoded one.\nvec3 n3DT(vec3 p){ return texture(iChannel3, p).xyz; }\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = hash31(fract(ro/7.319) + rd)*.1, d;\n    //float t = 0., d;\n    \n    glow = vec3(0);\n    \n    for(int i = min(0, iFrame); i<128; i++){\n    \n        vec3 p = ro + rd*t;\n        d = map(p);\n\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if((abs(d)<.001) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n       \n        // Accumulate the glow color.\n        glow += lCol;///(1. + t);\n        \n        // Note that the ray is capped (to .1). It's slower, but is necessary for the\n        // glow to work. I guess it could also help with overstepping the mark a bit.\n        t += min(d*.7, .1); \n    }\n\n    // Minimum distance. Since FAR is theoretically the furthest the ray can do, \n    // technically, this should be done. Depending on the situation, it can sometimes \n    // help avoid far plane artifacts as well.\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .005, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 1., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    \n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, iTime/2.);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    vec3 camH = vec3(0, 0, -1);\n    camH.xy *= mTwist(-(lk.z + camH.z));\n    vec3 ro = lk + camH; // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n    vec3 lpH = vec3(0, 0, .75);\n    #ifdef CYLINDRICAL\n    lpH = vec3(0, 0, 1.);\n    #endif\n    lpH.xy *= mTwist(-(lk.z + lpH.z));\n \tvec3 lp = lk + lpH;// Put it a bit in front of the camera.\n\t\n    \n    // Using the above to produce the unit ray-direction vector.\n    //\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd));// Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n    // Camera.\n    //mat3 mCam = mat3(rgt, up, fwd);\n    // rd - Ray direction.\n    //vec3 rd = mCam*normalize(vec3(uv, 1./FOV));//\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Substle camera direction movement.\n    rd.xy *= rot2(-iTime/32.);\n    rd.yz *= rot2(sin(iTime/8.)*.05);\n \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the object ID.\n    float svObjID = objID;\n    \n    vec4 svVal = gVal;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.1);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Texture coordinates.\n        vec3 txP = sp;\n       \n        // Matching the coordinate space warping in the \n        // distance function with the texture coordinates.\n        //\n        // Apply the space transform.\n        txP = coordTrans(txP);\n        \n        float sf = 1.5/iResolution.y; // Smoothing factor.\n        const float ew = .001; // Edge width.\n        \n         // Texel color. \n\t    vec3 texCol = vec3(0); \n       \n\n        \n        if(svObjID<.5){\n            \n            \n            // The extruded pattern.\n            \n            // Texture color lookup, based on the central ID of the\n            // extruded prism we've hit. In this case, it'll be a hexagon,\n            // square or triangle.\n            texCol = getColor(svVal.zw)*2.;\n            \n            // Apply some edging.\n            float d = abs(svVal.x) - ew;\n            float h = svVal.y; // Object height.\n            d = max(d, abs(txP.y - h) - ew);\n            \n            d *= 1./(1. + t*.25); // Taper the edging effect further away to reduce banding.\n            \n            // Apply the edge.\n            texCol = mix(texCol, texCol*.1, 1. - smoothstep(0., sf, d)); \n            \n            // Tri-planar texture lookup.\n            vec3 tx = tex3D(iChannel1, sp, sn);\n            \n            // Combine for the final surface color.\n            texCol *= tx*2.;\n           \n            // Ramping up the diffuse for a more metallic look.\n            //diff = pow(diff, 4.)*2.;\n      \n \n        }\n        else {\n            \n            // The floor. Redundant here, but sometimes the \n            // background floor can be visible.\n             \n            \n            // Background.\n            texCol = vec3(0);\n            \n            /*\n            vec3 tx = tex3D(iChannel1, sp, sn);\n            texCol *= tx*2.;\n            // Ground rim.\n            float d = abs(svVal.x) - ew*1.5;\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, d));\n            */\n          \n        }\n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel2, ref).xyz; refTx *= refTx;\n        refTx = (texCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n        float spRef = pow(max(dot(hv, sn), 0.), 8.); // Specular reflection.\n        float rf = (svObjID == 1.)? .25 : 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .08));\n        texCol += spRef*refTx*rf*2.; //smoothstep(.03, 1., spRef) \n\n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .2 + vec3(1, .97, .92)*spec*freS*2.*sh);\n        \n        //col += col.xxx*spRef*refTx*rf*16.; //smoothstep(.03, 1., spRef) \n        \n        // Arranging for some fine particles to stream into the chamber by\n        // applying some fine dust to the rays... Technically, this should be\n        // processed inside the raymarching loop, but this is way cheaper and\n        // still conveys the general idea.\n        vec3 nSp = vec3(8, 4, 8)*txP + vec3(1, -4, 1)*iTime/8.;\n        vec3 ns = mix(n3DT(nSp), n3DT(nSp*2.), 1./3.);\n        mix(ns, n3DT(nSp*4.), 1./7.);\n        glow = vec3(1)*glow*(ns*.75 + .25);//*hash31(sp/vec3(1, 8, 1) + tm);// dot(glow, vec3(.299, .587, .114))\n        \n        // Apply the glow to the warped planes.\n        // It doesn't quite look right with a straight cylinder, but I think I'll\n        // make a specific tunnel example later.\n        #ifndef CYLINDRICAL\n        \n            #if SCENE == 0\n            // Warm hues.\n            glow = mix(glow, glow.yxz, max(txP.y, 0.));\n            glow = mix(glow, glow.xxx, .5);\n            col = col/2. + col*glow*32.;\n            #else\n            // Cliche Borg green.\n            glow = mix(glow.yxz, glow.zyx, min(txP.y*txP.y*12., 1.)); \n                #if SCENE == 2\n                // Purple.\n                glow = glow.xzy; \n                //glow = mix(glow.xzy, glow.yzx, floor(hash21(svVal.zw)*4.999)/4.);\n                #endif\n            col = col/3. + col*glow*32.;\n            #endif\n        \n        #endif\n \n      \n        // Shading.\n        col *= ao*atten;\n        \n        \n        \n        // It's sometimes helpful to check things like shadows and AO by themselves.\n        //col = vec3(ao);\n          \n\t\n\t}\n    \n    // Horizon fog. Not visible here, but provided for completeness.\n    col = mix(col, vec3(.5, .7, 1)*0., smoothstep(0., .99, t/FAR));\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3040, 3073, 3095, 3095, 3153], [3156, 3184, 3205, 3205, 3372], [3374, 3402, 3423, 3423, 3501], [3504, 3584, 3630, 3630, 4542], [4544, 4565, 4585, 4726, 4774], [4777, 4804, 4861, 4861, 5167], [5189, 5221, 5267, 5267, 5409], [6246, 6387, 6433, 6457, 6976], [6978, 7071, 7107, 7107, 7316], [7318, 7346, 7393, 7393, 7483], [7486, 7703, 7724, 7902, 8097], [8259, 8259, 8283, 8283, 8327], [8329, 8329, 8351, 8593, 8956], [8959, 9064, 9085, 9085, 9107], [9109, 9127, 9151, 9151, 9920], [10131, 10145, 10163, 10203, 17714], [17716, 17775, 17793, 17793, 17829], [17831, 17852, 17888, 17937, 18953], [18956, 19047, 19083, 19426, 19698], [19701, 19892, 19944, 20025, 21291], [21294, 21446, 21481, 21481, 21726], [21730, 21730, 21786, 21819, 29481]], "test": "untested"}
{"id": "csfSRS", "name": "Bending Squares (432 chars)", "author": "fenix", "description": "Reproduction of Charlie Deck (@BigBlueBoo)'s post here:\nhttps://bigblueboo.tumblr.com/post/77072352738\n\nI think the optical illusion effect is really strong in this very clever animation.\n*mouse x to zoom*", "tags": ["illusion", "codegolf", "reproduction"], "likes": 17, "viewed": 245, "published": 3, "date": "1669102567", "time_retrieved": "2024-07-30T16:18:03.300283", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Reproduction of Charlie Deck (@BigBlueBoo)'s post here:\n//     https://bigblueboo.tumblr.com/post/77072352738\n\n// I think the optical illusion effect is really strong in this very clever animation.\n// I couldn't find one on Shadertoy so hopefully Mr. Deck approves.  I tried to golf\n// this, as usual, but futher contributions are welcome.\n\n// I recommend experimenting with the scale (currently the 9. * in the lastest version\n// on the first line inside the loop). A good choice might be: .1*iMouse.x. It seems like\n// the scale of the image has a huge effect on the intensity of the optical illusion.\n// Especially when going full screen it helps to increase the scale value above 9.\n\n// Adding mouse control to FabriceNeyret2's version: 432 chars\n//*\n#define P .13 - abs( .6* smoothstep(1.25, .75, abs( mod(t,4.) - vec2(2,1) -.25 ) )  + .2  - fract(u) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = (3.*iMouse.x/R.x + 1.) * 9. * ( U - R/2. ) / R.y,\n         v = abs(u),\n         V = mod( u += .5 , 2.) - 1., \n         B = min(v,v.y) - .5,\n         t = iTime * .2 \n           + vec2( u.y > 1. && u.x > 1. || u.y < 0. && u.x < 0. )\n           + ( B.x<0. ?   u.y > 1. ? 1. \n                        : u.x > 1. ? 2. \n                        : u.y < 0. ? 3. \n                      : 0. : 0.),\n         a = P; \n    t += B.x<0. ? 1. : 2.;\n    t = V * V.y * max( min(a,a.y), min(P,P.y) );\n    O = vec4( max(v.x,v.y) > .5 ? smoothstep(-.8,.8, t/fwidth(t) ).x : 0. );\n}\n/**/\n\n// From FabriceNeyret2, with direct AA: 416 chars!\n/*\n#define P -.13 + abs( .6* smoothstep(1.25, .75, abs( mod(t,4.) - vec2(2,1) -.25 ) )  + .2  - fract(u) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 t,a,R = iResolution.xy,\n         u = 9. * ( U - R/2. ) / R.y,\n         v = abs(u),\n         V = mod( u += .5 , 2.) - 1.; \n\n    bool B = min(v.x,v.y) < .5;\n    t = iTime * .4 \n        + vec2( u.y > 1. && u.x > 1. || u.y < 0. && u.x < 0. )\n        + ( B ?   u.y > 1. ? 1. \n                : u.x > 1. ? 2. \n                : u.y < 0. ? 3. \n              : 0. : 0.);\n    a = P; \n    t += B ? 1. : 2.;\n    t = V * V.y * min( max(a.x,a.y), max(P.x,P.y) );\n    O = vec4(max(v.x,v.y) > .5 ? smoothstep(.8,-.8, t/fwidth(t) ).x : 0.);\n}\n/**/\n\n// From FabriceNeyret2, with motion blur and soft focus: 469 chars!\n/*\n#define P  ( g = .6* smoothstep(0., .5, mod(t,4.) - vec4(0,1,2,3) ),    \\\n             abs( g.yx - g.wz + .2  - fract(u) )  - .13                 \\\n           )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 u,v,V,a,R = iResolution.xy;\n    vec4 t,g;\n    O *= 0.;\n    for(int i = 0; i < 40; ++i)\n    {\n        v = abs( u = 9. * ( U -R/2. + vec2(i+i & 2, i & 2) -1. ) / R.y );\n        V = mod( u += .5 , 2.) - 1.; \n        bool  B = min(v.x,v.y) < .5 ;\n        t = iTime * .4 + vec4(i/4) /250.\n            + vec4( u.y > 1. && u.x > 1. || u.y < 0. && u.x < 0. )\n            + ( B ?   u.y > 1. ? 1. \n                    : u.x > 1. ? 2. \n                    : u.y < 0. ? 3. \n                  : 0. : 0.);\n        a = P; \n        t += B ? 1. : 2.;\n        max(v.x,v.y) > .5 &&  V.x * V.y * min( max(a.x,a.y), max(P.x,P.y) ) < 0.\n          ? O+= .025 : O;\n    }\n}\n/**/\n\n// Couldn't resist adding aa and motion blur, back up to 583 chars :D\n/*\n#define p(t) (g = smoothstep(f, f + .125, vec4(fract(t))), vec2(g.y - g.w, g.x - g.z) * .6 + .2)\n#define b(v) abs((v).x) < .13 && abs((v).y) < .13\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec4 R = iResolution.xyyy, f = vec4(0, 1, 2, 3) * .25, g, a;\n    O *= 0.;\n    for(int i = 0; i < 40; ++i)\n    {\n        vec2 u = 4.5 * (U + vec2((i & 1) * 2 - 1, (i & 2) - 1) - .5 * R.xy) / R.y + .25,\n            v = abs(u - .25) - .25;\n        float t = iTime * .1 + float(i / 4) * .001 + (u.y > .5 && u.x > .5 || u.y < 0. && u.x < 0. ? .25 : 0.) +\n            (v.x < .0 || v.y < .0 ? u.y > .5 ? .25 : u.x > .5 ? .5 : u.y < .0 ? .75 : 0. : 0.);\n        u = fract(u);\n        a = vec4((u.x < .5) ^^ (u.y < .5));\n        u = fract(u * 2.);\n\n        if (b(u - p(t)) || b(u - p(v.x < .0 || v.y < .0 ? .25 + t : .5 + t))) a = 1.-a;\n        a = v.x < .0 && v.y < .0 ? vec4(0) : a; // clear center square\n        O += a * .025;\n    }\n}\n/**/\n\n// My golfing attempt, before aa and motion blur: 498 chars\n/*\n#define p(t) (g = smoothstep(f, f + .125, vec4(fract(t))), vec2(g.y - g.w, g.x - g.z) * .6 + .2)\n#define b(v) abs((v).x) < .13 && abs((v).y) < .13\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec4 R = iResolution.xyyy, f = vec4(0, 1, 2, 3) * .25, g;\n    u = 4.5 * (u - .5 * R.xy) / R.y + .25;\n    vec2 v = abs(u - .25) - .25;\n    float t = iTime * .1 + (u.y > .5 && u.x > .5 || u.y < 0. && u.x < 0. ? .25 : 0.) +\n        (v.x < .0 || v.y < .0 ? u.y > .5 ? .25 : u.x > .5 ? .5 : u.y < .0 ? .75 : 0. : 0.);\n    u = fract(u);\n    O = vec4((u.x < .5) ^^ (u.y < .5));\n    u = fract(u * 2.);\n\n    if (b(u - p(t)) || b(u - p(v.x < .0 || v.y < .0 ? .25 + t : .5 + t))) O = 1.-O;\n    O = v.x < .0 && v.y < .0 ? vec4(0) : O; // clear center square\n}\n/**/\n\n// Original: 775 chars\n/*\nvec2 path(float t)\n{\n    vec4 v = smoothstep(vec4(0, 1, 2, 3) * .25, vec4(0, 1, 2, 3) * .25 + .125, vec4(fract(t)));\n    return (vec2(v.y - v.w, v.x - v.z) + .5) * .6 - .1;\n}\n\nvec4 aaImage( vec2 u, float t )\n{\n    u = 4.5*((u - .5*iResolution.xy) / iResolution.y + .055);\n    float dt = .5;\n    if (u.y > 0. && u.y < .5 || u.x > 0. && u.x < .5)\n    {\n        if (u.y > .5) t += .25;\n        else if (u.y < .0) t += .75;\n        else if (u.x > .5) t += .5;\n        else if (u.x > 0.) return vec4(0);\n        dt = .25;\n    }\n    if (u.y > .5 && u.x > .5 || u.y < 0. && u.x < 0.) t += .25;\n    u = fract(u);\n    vec4 O = vec4((u.x < .5) ^^ (u.y < .5));\n    u = fract(u * 2.);\n    \n    vec2 p = path(t);\n    if (abs(u.x - p.x) < .13 && abs(u.y - p.y) < .13) O = 1.-O;\n    p = path(t + dt);\n    if (abs(u.x - p.x) < .13 && abs(u.y - p.y) < .13) O = 1.-O;\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 d = vec2(1, -1);\n    O *= 0.;\n    for (float i = 0.; i < 10.; ++i)\n    {\n        float t = iTime * .1 + i * .001;\n\n        O += (aaImage(u + d.xx, t) + aaImage(u + d.xy, t) + aaImage(u + d.yx, t) + aaImage(u + d.yy, t)) * .025;\n    }\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfSRS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1069, 1069, 1107, 1107, 1709]], "test": "untested"}
{"id": "DdXXzB", "name": "Infinite roguelike dungeon 5", "author": "jarble", "description": "Another infinite roguelike dungeon map.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 10, "viewed": 240, "published": 3, "date": "1669102328", "time_retrieved": "2024-07-30T16:18:04.278667", "image_code": "float threshold = .5;\nint iters = 4;\n\n#define noise2D(p) float(((p).x * 68657387u ^ (p).y * 361524851u + (p).x) % 890129u) / 890128.\n\nbool labyrinth(uvec2 U,float n2){\n    bvec2 b = bvec2(U & 1u);\n    return (b.x && b.y || b.x != b.y  && n2 < threshold);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false,l1=false;\n    float n = 0.;\n    I += 1u;\n    for(int i = 0; i++ < iters;I = \n    //Multiply and divide by prime numbers to get interesting patterns\n    I*2u/3u\n    //I*13u/17u\n    ){\n        \n        //I += uint(i)+uint(b);\n        \n        n = noise2D(I);\n        l1 = labyrinth(I,n),\n        b =\n            //!(b || l1) || n > (8.*abs(.5-fract(iTime/16.))-.5)\n            !(b || l1)\n            //!b || labyrinth(I,n) || labyrinth(I/2u,n)\n            //!(b || l1) && n > .1\n            //!b && l1 //another interesting pattern\n            //l1 //simple maze\n            //!b || l1 //a more complicated maze\n        ;\n        O -= float(n > .125)/float(iters)/4.;\n        //some random-looking distortion\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n        //{I = I-I.yx/13u/11u/7u/5u+I.yx/11u/7u/5u-I.yx/7u/5u;}\n    }\n    if (b) O = 1.-O;\n}", "image_inputs": [], "sound_code": "#define fmod(x,y) floor(max(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\n#define fmod1(x,y) floor(min(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\nvec2 mainSound(int samp, float time){  \n  float\n  s1 = pow(2.,1.+fmod(time*8.,3.)),\n  s2 = pow(2.,1.+fmod1(time*8.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1+1.,2.)),\n  t = time/8.,\n  m4 = fmod1(t*s1/(1.+fmod(t/s1,2.)),s2),\n  m3 = fmod((t+m4)*s1/m1,s2);\n  t *= s1*s1/(1.+fmod(t/s1,2.));\n  float m2 = 1. + fmod(t/s1,s1);\n  float a = 64.*pow((1.-sqrt(fract(t/s1)/m1))/4.,2.);\n  float nb = time*pow(2.,(m3+m2)/5.+6.5);\n  return abs(.5-vec2(fract(nb*.998),fract(nb)))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 167, 167, 256], [258, 258, 294, 294, 1217]], "test": "untested"}
{"id": "cdXXRB", "name": "Square tile mosaic", "author": "jarble", "description": "A mosaic pattern made of square tiles.", "tags": ["mosaic"], "likes": 7, "viewed": 218, "published": 3, "date": "1669092666", "time_retrieved": "2024-07-30T16:18:05.141360", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord)/iResolution.y*4.;\n    uv.y += iTime;\n    vec3 col = vec3(0);\n    vec2 offset = vec2(0.),\n    uv1 = uv;\n    for(int k = 0; k < 4; k++){\n        uv =\n            abs(fract(uv.yx+floor(uv1.y+floor(uv.y))/8.)-.5)\n            //abs(fract(uv.yx+floor(uv1.y+floor(uv.y*8.)/8.)/8.)-.5)\n            //abs(fract(uv.yx+sign(uv.y-uv.x)*floor(uv1.y+floor(uv.y))/8.)-.5)\n        ;\n        if(uv.y < uv.x) col =\n            //vec3(col.yz,abs(min(uv.x,uv.y)))\n            vec3(col.yz,abs(max(uv.x,uv.y)))\n        ;\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "\n\nvec2 mainSound(int samp, float time){\n //time /= 1.5;\n float s1 =\n      8.;\n  \n  time += floor(time*s1)/s1;\n  \n  float s2 = 8.,\n  m4 =\n      sqmod(floor(time*s1)/s1,2.)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      sqmod(floor(t*s1)/s1,s2)\n      //fmod(floor(t/(1.+m4))*floor(t*s1),s2)\n      //fmod(floor(t/s1)*(floor(t*s1)+floor(t)),s2)\n  ,\n  m3 =\n      sqmod(floor(t*s1+m1),s2);\n      //sqmod(floor(t*s1*abs(5.-floor(m4))*2.+m1),s2);\n  t /=\n      (1.+sqmod(t/s1,2.))\n      //(1.+fmod(t/(1.+m1),2.))\n  ;\n  t *=\n      s1*s1\n  ;\n\n    float m2 =\n      1. + sqmod(t/s1,s1)\n  ;\n  \n  float a = 64.*sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2,\n\n  nb = time*pow(2.,(m3+m2)/5.+6.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}", "sound_inputs": [], "common_code": "#define fmod(x,y) mod(floor(x),y)\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)/4.,y*y)/y)\n//#define sqmod(a, b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))\n#define floor2(x) floor(x)*pow(floor(mod((x)/4.,3.)),2.)", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 665]], "test": "untested"}
{"id": "csfXRS", "name": "Aniso BDRF Simulated Microfacets", "author": "Hatchling", "description": "Simulates microfacet lighting. When tracing into the scene, at each hit point, it sumulates another raytrace against a microfacet surface. Calcs visibility of each facet from the viewing point and light source (facet self shadowing).", "tags": ["raytrace", "brdf", "montecarlo"], "likes": 13, "viewed": 324, "published": 3, "date": "1669080768", "time_retrieved": "2024-07-30T16:18:06.532641", "image_code": "// Simulates the interaction between light rays and microfacets on surfaces.\n\n// Changes: ------------------------------------\n//\n//     - Fixed self-shadowing bug that occurs when viewing the\n//       microfacet surface from below or along the horizon.\n//     - Fixed sampling on blue noise - it is now \"nearest\"\n//       instead of \"bilinear\".\n\n// Controls: ------------------------------------\n//\n// Mouse click and drag : Change light direction.\n//\n// To change the bumpmap:\n//\n//     1. Navigate to Buffer A.\n//     2. Change IChannel0 to a different texture.\n//     3. Restart the shader.\n//\n//     You'll notice that the specular highlights will\n//     be sensitive to the distribution of \n//     intensity gradients on the texture you choose.\n//\n// To change the smoothness:\n//\n//     1. Navigate to Buffer A.\n//     2. Scroll to the top.\n//     3. Find a variable called \"anisotropicSmoothness\".\n//     4. Change the value for horizontal and vertical smoothness.\n//     5. Do not use the value 0! (Otherwise you'll divide by 0.)\n//     6. Compile.\n//     7. Restart the shader.\n//\n//     Note that if you make the smoothness too small,\n//     the raymarcher might miss some facets when\n//     the angle is nearly parallel,\n//     which will break self-shadowing.\n//\n// To view the underlying microfacet structure:\n// \n//     1. Navigate to Buffer A.\n//     2. Change USE_NOISE to 0.\n//     3. Compile.\n//     4. Restart the shader.\n//     5. Pause the shader.\n//     6. Click to reroll a microfacet structure sample.\n//     7. Unpause to see the undithered samples converge.\n//     \n//     You'll see the microfacet surface that is being traced against.\n//     This surface is normally different per pixel, per frame.\n\n// How it works: ------------------------------------\n//\n//     1.  Raytrace a scene in a typical way:\n//         Get hits for a plane and a sphere.\n//\n//     2.  Create a \"microfacet surface\" at the hit point, \n//         aligned to the normal, and trace against it.\n//         This surface contains a bump map and will be used\n//         to calculate what normal direction is visible\n//         from our view.\n//\n//     3.  Trace from the microfacet hit point to the light,\n//         for self-shadowing.\n//\n//     The microfacet surface sample varies per pixel, per frame.\n//     We're integrating over the entire bumpmap, \n//     and these facets are treated as infinitesimally small.\n//\n//     The lighting model used by individual facets is also\n//     physically based. The intention is to compound\n//     their effects by starting with an already good\n//     microfacet approximation.\n\n// Future work: ------------------------------------\n//\n// I'd like to \"bake\" the results of this into a lookup table.\n// Perhaps one could provide the dot products between:\n//     - Normal direction\n//     - Tangent direction\n//     - Light direction\n//     - View direction\n// \n// (This would be a 4 dimensional function). \n//\n// Given these dot products, one could look up the value needed\n// from a lookup table.\n//\n// Then I'd like to fit curves to this function to remove the need\n// for a lookup table altogether.\n\n// Interesting stuff I noticed: ------------------------------------\n//\n//     - It looks like the specular pattern resembles\n//       the fourier spectrum of the bumpmap.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, 0.125);\n    fragColor /= fragColor.a;\n    \n    fragColor.rgb = linearToGamma(fragColor.rgb);\n    fragColor.rgb /= (0.5 + fragColor.rgb);\n    fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\n// Constants ----------------------------------\n\nconst float Pi = 3.14159265358979;\nconst float Tau = Pi * 2.0;\nconst float InvPi = 1.0 / 3.14159265358979;\n\n// HLSL support -------------------------------\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define half  float\n#define half2 vec2\n#define half3 vec3\n#define half4 vec4\n\n#define fixed  float\n#define fixed2 vec2\n#define fixed3 vec3\n#define fixed4 vec4\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n#define lerp mix\n\n#define decl_saturate(type)            \\\ntype saturate(type x)                  \\\n{                                      \\\n    return clamp(x, type(0), type(1)); \\\n} \n\ndecl_saturate(float)\ndecl_saturate(vec2)\ndecl_saturate(vec3)\ndecl_saturate(vec4)\n\n// Boolean -------------------------------\n\nbool  isinf2(float v) { return isinf(v); } \nbvec2 isinf2(vec2 v)\n{\n    return bvec2\n    (\n        isinf(v.x),\n        isinf(v.y)\n    );\n}\nbvec3 isinf2(vec3 v)\n{\n    return bvec3\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z)\n    );\n}\nbvec4 isinf2(vec4 v)\n{\n    return bvec4\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z),\n        isinf(v.w)\n    );\n}\n\nbool  isnan2(float v) { return isnan(v); } \nbvec2 isnan2(vec2 v)\n{\n    return bvec2\n    (\n        isnan(v.x),\n        isnan(v.y)\n    );\n}\nbvec3 isnan2(vec3 v)\n{\n    return bvec3\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z)\n    );\n}\nbvec4 isnan2(vec4 v)\n{\n    return bvec4\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z),\n        isnan(v.w)\n    );\n}\n\nbool bnot(bool b) { return !b; }\nbvec2 bnot(bvec2 b) \n{ \n    return bvec2(!b.x, !b.y); \n}\nbvec3 bnot(bvec3 b) \n{ \n    return bvec3(!b.x, !b.y, !b.z); \n}\nbvec4 bnot(bvec4 b) \n{ \n    return bvec4(!b.x, !b.y, !b.z, !b.w); \n}\n\nbool band(bool a, bool b) { return a && b; }\nbvec2 band(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x && b.x,\n        a.y && b.y\n    ); \n}\nbvec3 band(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z\n    ); \n}\nbvec4 band(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z,\n        a.w && b.w\n    ); \n}\n\nbool bor(bool a, bool b) { return a || b; }\nbvec2 bor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x || b.x,\n        a.y || b.y\n    ); \n}\nbvec3 bor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z\n    ); \n}\nbvec4 bor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z,\n        a.w || b.w\n    ); \n}\n\nbool bxor(bool a, bool b) { return a != b; }\nbvec2 bxor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x != b.x,\n        a.y != b.y\n    ); \n}\nbvec3 bxor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z\n    ); \n}\nbvec4 bxor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z,\n        a.w != b.w\n    ); \n}\n\n#define decl_isfinite(retType, type) \\\nretType isfinite(type v)             \\\n{                                    \\\n    return band                      \\\n    (                                \\\n        bnot(isinf2(v)),             \\\n        bnot(isnan2(v))              \\\n    );                               \\\n} \ndecl_isfinite(bool, float)\ndecl_isfinite(bvec2, vec2)\ndecl_isfinite(bvec3, vec3)\ndecl_isfinite(bvec4, vec4)\n\nfloat select(bool s, float a, float b)\n{\n    return s ? a : b;\n}\n\nvec2 select(bvec2 s, vec2 a, vec2 b)\n{\n    return vec2\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y\n    );  \n}\n\nvec3 select(bvec3 s, vec3 a, vec3 b)\n{\n    return vec3\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z\n    );  \n}\n\nvec4 select(bvec4 s, vec4 a, vec4 b)\n{\n    return vec4\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z,\n        s.w ? a.w : b.w\n    );  \n}\n\n// Vector math -------------------\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) \\\nretType lengthSqr(type a)             \\\n{                                     \\\n    return dot2(a,a);                 \\\n}                                     \n\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) \\\nretType distSqr(type a, type b)     \\\n{                                   \\\n    type diff = a-b;                \\\n    return lengthSqr(diff);         \\\n}                                   \n\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// Borrowed from UnityEngine\n#define decl_safeNormalize(type)                 \\\ntype safeNormalize(type inVec)                   \\\n{                                                \\\n    float dp3 = max(0.001f, dot2(inVec, inVec)); \\\n    return inVec / sqrt(dp3);                    \\\n}\ndecl_safeNormalize(vec2)\ndecl_safeNormalize(vec3)\ndecl_safeNormalize(vec4)\n\n// Trig Math ----------------------\n\n#define decl_cosToTan(type)\\\ntype cosToTan(type cosine)\\\n{\\\n    return (sqrt(type(1.0)-cosine)*sqrt(cosine+type(1.0))) / cosine;\\\n}\ndecl_cosToTan(float)\ndecl_cosToTan(vec2)\ndecl_cosToTan(vec3)\ndecl_cosToTan(vec4)\n\n#define decl_tanToCos(type)\\\ntype tanToCos(type tangent)\\\n{\\\n    return type(1.0)/sqrt(tangent*tangent+type(1.0));\\\n}\ndecl_tanToCos(float)\ndecl_tanToCos(vec2)\ndecl_tanToCos(vec3)\ndecl_tanToCos(vec4)\n\n// Misc. math --------------------\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type)              \\\nretType floorToInt(type a)                          \\\n{                                                   \\\n    return retType(floor(a) + sign(a) * type(0.5)); \\\n}                                                   \n\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n\n#define decl_invMix(type) \\\ntype invMix(type a, type b, type t) \\\n{                                   \\\n    type result = (t-a)/(b-a);      \\\n    return select(isfinite(result), result, type(0.5)); \\\n}\n\ndecl_invMix(float)\ndecl_invMix(vec2)\ndecl_invMix(vec3)\ndecl_invMix(vec4)\n\n#define invLerp invMix\n\n#define decl_square(type)\\\ntype square(type a)\\\n{\\\n    return a*a;\\\n}\n\ndecl_square(int)\ndecl_square(ivec2)\ndecl_square(ivec3)\ndecl_square(ivec4)\ndecl_square(float)\ndecl_square(vec2)\ndecl_square(vec3)\ndecl_square(vec4)\n\nhalf Pow5 (half x)\n{\n    return x*x * x*x * x;\n}\n\nhalf2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}\n\n// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\n// Color -------------------------------\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\nstruct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nquaternion LookRotation(float3 forward, float3 up)\n{\n    quaternion q;\n    forward = safeNormalize(forward);\n    q = FromToRotation(vec3(0,0,1), forward);\n    up = up - dot(forward, up) * forward;\n    vec3 upFrom = mul(q, vec3(0,1,0));\n    q = mul(FromToRotation(upFrom, up), q);\n    return q;\n}\n\nvoid sincos(vec3 x, out vec3 s, out vec3 c)\n{\n    s = sin(x);\n    c = cos(x);\n}\n        \nquaternion EulerZXY(float3 xyz)\n{\n    vec3 s, c;\n    sincos(vec3(0.5) * xyz, s, c);\n\n    return quaternion\n    (\n        vec4(s.xyz, c.x) * c.yxxy * c.zzyz \n      + s.yxxy * s.zzyz * vec4(c.xyz, s.x) * vec4(1, -1, -1, 1)\n    );\n}\n\nmat4x4 RotationMatrix(quaternion q)\n{\n    float q0 = q.value.x;\n    float q1 = q.value.y;\n    float q2 = q.value.z;\n    float q3 = q.value.w;\n        \n    /*# First row of the rotation matrix\n    r00 = 2 * (q0 * q0 + q1 * q1) - 1\n    r01 = 2 * (q1 * q2 - q0 * q3)\n    r02 = 2 * (q1 * q3 + q0 * q2)\n     \n    # Second row of the rotation matrix\n    r10 = 2 * (q1 * q2 + q0 * q3)\n    r11 = 2 * (q0 * q0 + q2 * q2) - 1\n    r12 = 2 * (q2 * q3 - q0 * q1)\n     \n    # Third row of the rotation matrix\n    r20 = 2 * (q1 * q3 - q0 * q2)\n    r21 = 2 * (q2 * q3 + q0 * q1)\n    r22 = 2 * (q0 * q0 + q3 * q3) - 1*/\n        \n    float r00 = 2. * (q0 * q0 + q1 * q1) - 1.;\n    float r01 = 2. * (q1 * q2 - q0 * q3);\n    float r02 = 2. * (q1 * q3 + q0 * q2);\n                                        \n    float r10 = 2. * (q1 * q2 + q0 * q3);\n    float r11 = 2. * (q0 * q0 + q2 * q2) - 1.;\n    float r12 = 2. * (q2 * q3 - q0 * q1);\n                                         \n    float r20 = 2. * (q1 * q3 - q0 * q2);\n    float r21 = 2. * (q2 * q3 + q0 * q1);\n    float r22 = 2. * (q0 * q0 + q3 * q3) - 1.;\n                             \n    return mat4x4\n    (\n        mul(q, vec3(1,0,0)), 0,\n        mul(q, vec3(0,1,0)), 0,\n        mul(q, vec3(0,0,1)), 0,\n        0,   0,   0,   1\n    );\n}\n\nmat4x4 TRS(vec3 translation, quaternion rotation, vec3 scale)\n{\n    mat4x4 float3x = RotationMatrix(rotation);\n    return mat4x4\n    (\n        vec4(float3x[0] * scale.x), \n        vec4(float3x[1] * scale.y), \n        vec4(float3x[2] * scale.z), \n        vec4(translation, 1)\n    );\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n// PBR Lighting ------------------------------\n// Borrowed from UnityEngine\nstruct MaterialMetallic\n{\n    fixed3 albedo;      // base (diffuse or specular) color\n    half metallic;      // 0=non-metal, 1=metal\n    half smoothness;    // 0=rough, 1=smooth\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specColor;\n    float oneMinusReflectivity;\n    float smoothness;\n};\n\nstruct Light\n{\n    half3 color;\n    half3 dir;\n};\n\nstruct Indirect\n{\n    half3 diffuse;\n    half3 specular;\n};\n\nconst float4 dielectricSpec = float4(0.04, 0.04, 0.04, 1.0 - 0.04);\n\nhalf OneMinusReflectivityFromMetallic(half metallic)\n{\n    half oneMinusDielectricSpec = dielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nhalf3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (dielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}\n\nMaterial toMaterial(MaterialMetallic i)\n{\n    Material o;\n    \n    o.albedo = i.albedo;\n    o.smoothness = i.smoothness;\n    \n    half oneMinusReflectivity;\n    half3 specColor;\n    o.albedo = DiffuseAndSpecularFromMetallic (o.albedo, i.metallic, o.specColor, o.oneMinusReflectivity);\n    \n    return o;\n}\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1.0 - smoothness);\n}\n\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\nhalf DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    half viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return InvPi * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nhalf3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\n\nhalf3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}\n\n\nhalf3 brdf (half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = safeNormalize(float3(light.dir) + viewDir);\n\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl / 3.1415927;\n\n    // Specular term\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    \n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n\n    float specularTerm = V*D; // Torrance-Sparrow model, Fresnel is applied later\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0.0, specularTerm * nl);\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n    surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    //specularTerm *= (specColor != vec3(0)) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1.0-oneMinusReflectivity));\n    half3 color =   albedo * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, vec3(grazingTerm), nv)\n                    ;\n\n    return half3(color);\n}\n\nvec3 lighting(MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect)\n{\n    Material m = toMaterial(mat);\n    \n    return brdf(m.albedo, m.specColor, m.oneMinusReflectivity, m.smoothness,\n    normal, viewDir, light, indirect);\n}\n\n// RAYTRACING -----------------------------\n// Taken from https://www.shadertoy.com/view/MtcXWr\n// Credit: Zavie\n\nstruct Ray\n{\n    vec3 origin;\t\n    vec3 direction;\t\t\n};\n\nstruct Hit\n{\n    float distance;\n    vec3 normal;\t\n};\nconst Hit noHit = Hit(1e10, vec3(0.));\n\nstruct Plane\n{\n    float offset;\n    vec3 normal;\n};\n\nstruct Sphere\n{\n\tfloat radius;\n    vec3 center;\n};\n\nstruct Cone\n{\n    float cosa;\t// cosine of half cone angle\n    float height;\n    float thickness;\n    vec3 origin;\n    vec3 axis;\n};\n\nstruct Capsule\n{\n    vec3 start;\n    vec3 end;\n    float startRadius;\n    float endRadius;\n};\n\nstruct HeightPlane\n{\n    mat4x4 localToWorld;\n    vec2 uvOffset;\n};\n\nvec3 getPoint(in Ray r, float dist)\n{\n    return r.origin + r.direction * dist;\n}\n\nvec3 getPoint(in Ray r, in Hit hit)\n{\n    return r.origin + r.direction * hit.distance;\n}\n\nbool swapIfCloser(inout Hit current, Hit candidate)\n{\n    if (candidate.distance < current.distance && candidate.distance >= 0.0)\n    {\n        current = candidate;\n        return true;\n    }\n    return false;\n}\n\nHit intersectPlane(Plane plane, Ray ray)\n{\n    float dotnd = -dot(plane.normal, ray.direction);\n    float heightAbovePlane = dot(ray.origin, plane.normal) - plane.offset;\n\n    float t = heightAbovePlane / dotnd;\n    //if(!(t >= 0.0))\n    //    return noHit;\n        \n    return Hit(t, plane.normal * sign(dotnd));\n}\n\nHit intersectSphere(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.center - ray.origin;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (ray.origin + t*ray.direction - sphere.center) / sphere.radius);\n}\n\nHit intersectCapsule(Capsule capsule, Ray ray)\n{\n    vec3 rayDirection = ray.direction;\n    vec3 relativeOrigin = ray.origin - capsule.start;\n    vec3 coneDirection = normalize(capsule.end - capsule.start);\n    float coneLength = distance(capsule.end, capsule.start);\n    float changeInRadiusWithLength = (capsule.endRadius - capsule.startRadius) / coneLength;\n    float whatever = 1.0 - square(changeInRadiusWithLength);\n    \n    if(whatever <= 0.0)\n    {\n    \tif(capsule.endRadius < capsule.startRadius)\n    \t{\n    \t\tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \t\treturn intersectSphere(s, ray);    \n        }\n   \t\telse\n        {\n            Sphere s = Sphere(capsule.endRadius, capsule.end);\n            return intersectSphere(s, ray);   \n        } \n    }\n    \n    float sideB = sqrt(whatever);\n    float changeInThicknessWithLength = changeInRadiusWithLength / sideB;\n    \n    float radiusToThickness = changeInThicknessWithLength/changeInRadiusWithLength;\n    float startThickness = capsule.startRadius * radiusToThickness;\n    float endThickness = capsule.endRadius * radiusToThickness;\n    \n    if((coneLength+capsule.endRadius) < capsule.startRadius)\n    {\n    \tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \treturn intersectSphere(s, ray);    \n    }\n    if((coneLength+capsule.startRadius) < capsule.endRadius)\n    {\n    \tSphere s = Sphere(capsule.endRadius, capsule.end);\n    \treturn intersectSphere(s, ray);    \n    }\n    \n    float c = lengthSqr(relativeOrigin)\n            - square(dot(relativeOrigin, coneDirection))\n            - square(dot(relativeOrigin, coneDirection*changeInThicknessWithLength))\n            - square(startThickness) \n            - 2.0*changeInThicknessWithLength*startThickness*dot(relativeOrigin, coneDirection);\n\n    float b = 2.0*dot(relativeOrigin, rayDirection)\n            - 2.0*dot(relativeOrigin, coneDirection)*dot(rayDirection, coneDirection)\n            - 2.0*dot(relativeOrigin, coneDirection*changeInThicknessWithLength)*dot(rayDirection, coneDirection*changeInThicknessWithLength)\n            - 2.0*changeInThicknessWithLength*startThickness*dot(rayDirection, coneDirection);\n\n    float a = 1.0\n            - square(dot(rayDirection, coneDirection))\n            - square(dot(rayDirection, coneDirection*changeInThicknessWithLength));\n        \n    float det = b*b - 4.*a*c;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return noHit;\n    \n    vec3 relativeRayHit = ray.origin + t*ray.direction - capsule.start;\n    float actualDistanceOfPointAlongAxis = dot(relativeRayHit, coneDirection);\n    float distanceOfPointAlongAxis = actualDistanceOfPointAlongAxis;//square(fract(iTime * 0.25 / coneLength)) * coneLength;//dot(relativeRayHit, coneDirection);\n    \n    \n    float thicknessAtPoint = distanceOfPointAlongAxis * changeInThicknessWithLength + startThickness;\n    \n    Hit hit1;\n    \n    if(actualDistanceOfPointAlongAxis < distanceOfPointAlongAxis)\n    {\n    \thit1 = Hit(t*0.25, vec3(1));    \n    }\n    else\n    {\n    \thit1 = Hit(t, vec3(-1));  \n    }\n    \n    float distanceOfSphereAlongAxis = distanceOfPointAlongAxis + (thicknessAtPoint * changeInRadiusWithLength / sideB);\n    \n    distanceOfSphereAlongAxis = clamp(distanceOfSphereAlongAxis, 0.0, coneLength);\n\n    float sphereRadius = distanceOfSphereAlongAxis * changeInRadiusWithLength + capsule.startRadius;\n\n    Sphere s = Sphere(sphereRadius, capsule.start + coneDirection * distanceOfSphereAlongAxis);\n    \n    Hit hit2 = intersectSphere(s, ray);\n    hit2.distance *= 0.5;\n    swapIfCloser(hit1, hit2);\n    \n    return hit2;\n}\n\nHit intersectHeightPlane(HeightPlane plane, Ray ray, sampler2D heightMap, vec2 heightMapSize)\n{\n    Ray origRay = ray;\n    mat4x4 worldToLocal = inverse(plane.localToWorld);\n\n    ray.origin = (worldToLocal * vec4(ray.origin, 1)).xyz; \n    ray.direction = normalize((worldToLocal * vec4(ray.direction, 0)).xyz); \n\n    Plane maxPlane = Plane(-1.0, vec3(0,0,1));\n    Plane minPlane = Plane( 0.0, vec3(0,0,1));\n    \n    Hit maxHit = intersectPlane(maxPlane, ray);\n    Hit minHit = intersectPlane(minPlane, ray);\n    \n    \n    //if(maxHit == noHit || minHit == noHit)\n    //    return noHit;\n    \n    float nearDist = min(minHit.distance, maxHit.distance);\n    float farDist  = max(minHit.distance, maxHit.distance);\n    \n    if(farDist < 0.0)\n        return noHit;\n        \n    if(nearDist < 0.0)\n        nearDist = 0.0;\n        \n    //return maxHit;\n    \n    //vec3 nearHit = ray.origin + ray.direction * nearDist;\n    //vec3 farHit = ray.origin + ray.direction * farDist;\n    \n    vec3 hitPos;\n    \n    \n    bool hit = false;\n    float increment = max(0.00001, 0.0001 / abs(nearDist-farDist));\n    for(float i = 0.0; i <= 1.0; i += increment)\n    {\n        float marchDist = mix(nearDist, farDist, i);\n        hitPos = ray.origin + ray.direction * marchDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r*1.0 - 1.0;\n        \n        if(hitPos.z <= depth)\n        {\n            hitPos.z = depth;\n            farDist = marchDist;\n            hit = true;\n            break;\n        }\n        else\n        {\n            nearDist = marchDist;\n        }\n    }\n    \n    if(!hit) return noHit;\n    \n    farDist = (nearDist + farDist) * 0.5;\n    float stepSize = (farDist - nearDist) * 0.5;\n    for(int i = 0; i < 12; i++, stepSize *= 0.5)\n    {\n        hitPos = ray.origin + ray.direction * farDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r - 1.0;\n        \n        if(hitPos.z > depth)\n        {\n            nearDist = farDist;\n            farDist += stepSize;\n        }\n        else\n        {\n            hitPos.z = depth;\n            farDist -= stepSize;\n        }\n    }\n    \n    ray = origRay;\n    \n    const float sampleSpacing = 0.5;\n    vec4 uvOffset = vec4(-sampleSpacing, -sampleSpacing, sampleSpacing, sampleSpacing) / heightMapSize.xyxy;\n    \n    vec3 p00, p10, p01, p11;\n    p00 = vec3(hitPos.xy + uvOffset.xy, 0);\n    p10 = vec3(hitPos.xy + uvOffset.zy, 0);\n    p01 = vec3(hitPos.xy + uvOffset.xw, 0);\n    p11 = vec3(hitPos.xy + uvOffset.zw, 0);\n    \n    p00.z = textureLod(heightMap, p00.xy + plane.uvOffset, 0.0).r - 1.0;\n    p10.z = textureLod(heightMap, p10.xy + plane.uvOffset, 0.0).r - 1.0;\n    p01.z = textureLod(heightMap, p01.xy + plane.uvOffset, 0.0).r - 1.0;\n    p11.z = textureLod(heightMap, p11.xy + plane.uvOffset, 0.0).r - 1.0;\n    \n    p00 = (plane.localToWorld * vec4(p00, 1)).xyz;\n    p10 = (plane.localToWorld * vec4(p10, 1)).xyz;\n    p01 = (plane.localToWorld * vec4(p01, 1)).xyz;\n    p11 = (plane.localToWorld * vec4(p11, 1)).xyz;\n    \n    Hit outHit;\n    outHit.normal = cross(p11 - p00, p01 - p10);\n    \n    hitPos = (plane.localToWorld * vec4(hitPos, 1)).xyz; \n    outHit.normal = normalize(outHit.normal);\n    outHit.distance = dot(hitPos - ray.origin, ray.direction);\n    \n    return outHit;\n}\n\nvec2[4] getMSAACoords()\n{\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n    return msaa;\n}\n\nRay uvToRay(vec2 uv, float aspect, float zoom, vec2 offset)\n{\n    uv = uv * vec2(2.0) - 1.0;\n    uv.x *= aspect;\n    uv += offset;\n    return Ray(vec3(0), normalize(vec3(uv,zoom)));\n}\n\n#define render(color, scene, camtf, frag, res, zoom, msaa, count, data)\\\n{\\\n    color = vec3(0.);\\\n    vec2 r = res;\\\n    vec2 f = frag;\\\n    vec2 uv = f / r;\\\n    const int c = count;\\\n    vec2[c] m = msaa;\\\n    float weight = 1.0 / float(c);\\\n    for (int i = 0; i < c; ++i)\\\n    {\\\n        Ray r = uvToRay\\\n        (\\\n            uv,\\\n            r.x/r.y,\\\n            zoom,\\\n            m[i] / r.y\\\n        );\\\n        r = camtf(r,f,data);\\\n        color += scene(r,f,data);\\\n    }\\\n    color *= weight;\\\n}\n", "buffer_a_code": "#define USE_NOISE 1\n\nconst vec2 anisotropicSmoothness = vec2(200, 1000);\n\nvec2 mouse;\n\n// Creates an abstract surface at the hit point with random geometry\n// that can be used to simulate microfacet rendering.\nHeightPlane getMicrofacetSurface(in Ray ray, in Hit hit, vec3 tangent, vec2 anisoSmoothness, vec2 fragCoord, inout uint rngState)\n{\n    HeightPlane hPlane;\n    \n    #if USE_NOISE != 0\n        // Use blue noise in screen space to randomize\n        // the abstract plane per pixel.\n        //\n        // We randomize the abstract surface because\n        // we want to integrate the visibility of the surface\n        // from this ray over the entire heightmap, not just a single point.\n        // Adding per-pixel randomization helps create the appearance\n        // of convergence earlier. (Swaps banding with noise).\n        vec4 noise = sampleBlueNoise(iChannel3, fragCoord, rngState);\n\n        // Randomize the uv per pixel so that the entire heightmap\n        // is sampled.\n        hPlane.uvOffset = noise.xy;\n    #else\n        // Use blue noise in screen space to randomize\n        // the abstract plane per pixel.\n        //\n        // We randomize the abstract surface because\n        // we want to integrate the visibility of the surface\n        // from this ray over the entire heightmap, not just a single point.\n        // Adding per-pixel randomization helps create the appearance\n        // of convergence earlier. (Swaps banding with noise).\n        vec4 noise = sampleBlueNoise(iChannel3, vec2(0), rngState);\n\n        // Randomize the uv per pixel so that the entire heightmap\n        // is sampled.\n        hPlane.uvOffset = noise.xy;\n    #endif\n    \n    // Plane is at the hit point.\n    vec3 hPlanePos = getPoint(ray, hit);\n    \n    // Rotate the plane to point in the same direction as the hit point \"hit\",\n    // with the plane's \"up\" direction pointing along the \"tangent\". \n    // This will define the direction of anisotropy.\n    quaternion hPlaneRotation = LookRotation(hit.normal, tangent);\n    \n    // Scale does the following.\n    //     x : stretches out the texels horizontally.\n    //     y : stretches out the texels vertically.\n    //     z : the depth variation in world units\n    //\n    // A surface can be made smoother by spreading out heightmap texels.\n    // If you have different smoothness along the x and y, you can\n    // get an anisotropic brdf.\n    vec3 hPlaneScale = vec3\n    (\n        anisoSmoothness,\n        1\n    );\n    \n    hPlane.localToWorld = TRS(hPlanePos, hPlaneRotation, hPlaneScale);\n    \n\n\n    return hPlane;\n}\n\nvec3 scene(Ray r, in vec2 fragCoord, inout uint rngState)\n{\n    // need to add a nonzero value to the x or z here \n    // or else it doesn't draw the plane... wtf?\n    Plane p = Plane(-1.0, vec3(0.001,1,0));\n    Sphere s = Sphere(0.5, vec3(0));\n    Hit sceneHit = intersectSphere(s, r);\n    \n    swapIfCloser(sceneHit, intersectPlane(p, r));\n    \n    if(sceneHit.distance >= noHit.distance)\n        return vec3(0.0);\n    \n    HeightPlane mfSurf = getMicrofacetSurface(r, sceneHit, vec3(0,1,-1), anisotropicSmoothness, fragCoord, rngState);\n    \n    Hit microHit = intersectHeightPlane(mfSurf, r, iChannel0, iChannelResolution[1].xy);\n\n    Light light;\n    vec2 m = mouse.xy / iResolution.xy;\n    m = m * 2.0 - 1.0;\n    m.x *= iResolution.x / iResolution.y;\n    m.x = -m.x;\n    quaternion lightRotation = FromAngleAxis(vec3\n    (\n        m.yx * vec2(Pi, Pi), \n        0\n    ));\n    \n    light.dir = mul(lightRotation, vec3(0,0,-1));//normalize(vec3(iMouse.xy / iResolution.xy * 2.0 - 1.0, -0.2));\n    light.color = vec3(100);\n    \n    // Microfacet self shadowing.\n    {\n        Ray lightRay;\n        lightRay.direction = -light.dir;\n        const float lightMfSurfDist = 100.0;\n        lightRay.origin = getPoint(r, microHit) + light.dir * lightMfSurfDist;\n\n        Hit lightMfHit = intersectHeightPlane(mfSurf, lightRay, iChannel0, iChannelResolution[1].xy);\n\n        if(lightMfSurfDist-0.0001 > lightMfHit.distance)\n        {\n            light.color = vec3(0);\n        }\n    }\n    \n    // Fixed self shadowing, no longer needed!\n    // EDIT: Still a weird edge case for stuff opposite to the light source.\n    if(dot(light.dir, sceneHit.normal) <= 0.)\n        light.color = vec3(0);\n    \n        \n    Indirect ind;\n    {\n        ind.diffuse = vec3(0);\n        ind.specular = vec3(0);\n    }\n    \n    MaterialMetallic mat;\n    {\n        mat.albedo  = vec3(0.01, 0.1, 1.0);\n        mat.smoothness = 1.0;\n        mat.metallic = 0.9;\n    }\n    \n    vec3 color = lighting(mat, microHit.normal, -r.direction, light, ind);\n    return color;\n}\n\nRay camTF(Ray r, in vec2 fragCoord, inout uint rngState)\n{\n    r.origin = vec3(0, 0, -1.25);\n    \n    /*quaternion q = EulerZXY(vec3\n    (\n        iMouse.yx / iResolution.yx * vec2(-Tau, Tau) - vec2(Pi, Pi), \n        0\n    ));\n    \n    r.origin = mul(q, r.origin);\n    r.direction = mul(q, r.direction);*/\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.xy != vec2(0))\n    {\n        mouse = iMouse.xy;\n    }\n    else\n    {\n        mouse = iResolution.xy * vec2(0.4, 0.6);\n    }\n\n    // Write screen size to pixel 0,0\n    {\n        ivec2 iFragCoord = floorToInt(fragCoord);\n        if(iFragCoord == ivec2(0,0))\n        {\n            fragColor = iResolution.xyxy;\n            return;\n        }\n    }\n\n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n    \n    // We're averaging samples together, so only render one sample per frame\n    // with random offsets.\n    vec2[1] msaaCoords;\n    msaaCoords[0] = uniform01ToGauss(sampleBlueNoise(iChannel3, fragCoord, rngState).xy) * 1.0;\n\n\tvec3 color = vec3(0);\n    render\n    (\n        color, \n        \n        // Scene to render\n        scene, \n        \n        // Camera transform function\n        camTF,\n        \n        fragCoord, \n        iResolution.xy, \n        \n        // Zoom\n        2.0,\n        \n        // MSAA coords and count\n        msaaCoords, \n        1,\n        \n        rngState\n    );\n\n\tfragColor = vec4(color,1.0);\n    \n    bool usePreviousSamples = true;\n    {\n        // Mouse changed scene?\n        if(iMouse.z > 0.5)\n            usePreviousSamples = false;\n\n        // Screen size changed?\n        else if(texelFetch(iChannel1, ivec2(0), 0).rg != iResolution.xy)\n            usePreviousSamples = false;\n    }\n    \n    if(usePreviousSamples)\n        fragColor += texture(iChannel1, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3317, 3317, 3374, 3374, 3641]], "test": "untested"}
{"id": "DdfSRS", "name": "Text Console Demo II", "author": "mla", "description": "Variation on nice idea by Hatchling: [url]https://www.shadertoy.com/view/mdsSD7[/url] - just keep track of the current \"writing position\" and only draw the box containing the current pixel. \n\nShows data under mouse (or screen centre until mouse pressed).", "tags": ["text", "font", "console", "sh17b"], "likes": 8, "viewed": 940, "published": 3, "date": "1669072407", "time_retrieved": "2024-07-30T16:18:07.347462", "image_code": "// Adding debug output to a shader, basic idea from Hatchling\n\nvoid print(float x); // The debug function, definition down below\n\n// Original shader by Trisomie21\n\nvec2 Path(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\treturn textureLod(iChannel2, (p+vec2(37.5,17.5) + f)/256.0, 0.).xy;\n}\n\n#define S(x) vec4(Path(x*vec2(.04,.1))*vec2(6,9),0,0)\n\nvec4 mainimage(in vec2 C ) {\n    vec4 o = vec4(0);\n    vec4 p = vec4(C.xy,0,0)/iResolution.xyxy-.5, d=p, t, c, s;\n    p.z += iTime*8.;\n    p -= S(p.z);\n    float x, r, w, i;\n    for(i=1.5; i>0.; i-=.01)\n    {\n        // Select one of 5 type of wood beam separation\n        vec2 z = (p.zz-2.)*.25;\n        z = Path(z - fract(z))*4.+.5;\n        z = (z - fract(z))/10.;\n        z = mix(z, vec2(1.), step(vec2(.4), z));      \n        z *= step(4., mod(p.z-2., 8.));\n\t\tfloat f = mix(z.x, z.y, step(p.x, 0.));                \n        \n        t = abs(mod(c=p+S(p.z), 8.)-4.);\n        w = step(0., c.y);\n        r = (step(2.6, t.x) - step(2.8, t.x)) * w;        \n        s = texture(iChannel0, (c.y*t.x > 3. ? t.zxy:t.yzx)-3.);\n        x = min(t.x + f, t.y)-s.x * (1.-r) - r*.8;  \n        print(x);\n        if(x < .01) break;\n        p -= d*x*.5;\n     }\n    w = step(t.x, 0.8) * step(2.8, t.z) + step(2.8, t.x) * step(0., c.y);\n\to = p.wyyw*.02 + 1.3* mix(s, vec4(.8), r) * mix(vec4(1), vec4(1,.5,.2,1), w ) * i/p.w;\n    return o;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Debug apparatus\n//////////////////////////////////////////////////////////////////////////\n\nconst int nrows = 25, ncols = 7, digits = 7;\nint gethudpos(vec2 fragCoord) {\n  // Compute where this pixel is in the hud table\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int col = cellindex.x;\n  int row = nrows-1-cellindex.y;\n  return row*ncols+col;\n}\n\nfloat hud(vec2 fragCoord, float hudval) {\n  // Write the hud value.\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  // Get diffs for textureGrad\n  float sharpness = 0.5;\n  float uvscale = sharpness/16.0/fsize;\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n  //ivec2 cellindex = ivec2(fragCoord/cellsize);\n  //int col = cellindex.x;\n  //int row = cellindex.y;\n  vec2 p = mod(fragCoord,cellsize)/fsize; // Cell coordinates\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = floatchar(hudval,digits,charpos); // Get character at charpos, 0 if out of range\n  if (floor(hudval) == hudval) {\n    int h = int(hudval);\n    if (h%15 == 0) c = charpos >= 9 ? -1 : int[](32,70,73,90,90,66,85,90,90)[charpos];\n    else if (h%3 ==0) c = charpos >= 5 ? -1 : int[](32,70,73,90,90)[charpos];\n    else if (h%5 == 0) c = charpos >= 5 ? -1 : int[](32,66,85,90,90)[charpos];\n  }\n  if (c < 0) return 0.0;\n  float charstart = charwidth*float(charpos); // character start\n  uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  vec4 t = textureGrad(iChannel3,uv,dx,dy);\n  return t.x;  \n}\n\nint hudpos = -1;        // The hud position this pixel is in\nint hudwritepos = 0;    // Position being written to\nfloat hudval;           // The value to write\nbool gothudval = false; // Indicate if a value has been written\n\nvoid print(float x) {\n  if (hudpos < 0 || hudpos != hudwritepos++) return;\n  gothudval = true;\n  hudval = x;\n  if (key(CHAR_Z) && (hudpos%3 == 0 || hudpos%5 == 0)) hudval = float(hudpos);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = mainimage(fragCoord);\n  //return; // Uncomment to compare version without debug\n  vec2 mouse = 0.5*iResolution.xy;\n  if (iMouse.x > 0.0) mouse = iMouse.xy;\n  hudpos = gethudpos(fragCoord);\n  // Rerun shader with constant coords\n  mainimage(mouse);\n  // And display any debug output.\n  if (gothudval) {\n    float h = hud(fragCoord,hudval);\n    fragColor.xyz = mix(fragColor.xyz,vec3(1),h);\n  }\n  if (alert) fragColor.xyz = 1.0-fragColor.xyz;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel1, ivec2((code),2),0).x != 0.0)\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n#define SIGN(x) { if ((x) < 0.0) CHAR(MINUS) else CHAR(SPACE) } \n\n// Format x to digits precision and return the character at cindex,\n// or -1 if cindex is out of range.\nint floatchar(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return -1;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int SPACE = 0x20, ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    SIGN(x);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    // Maybe show the bits\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    SIGN(x);\n    CHAR(ZERO);\n  } else {\n    SIGN(x);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // This is a delicate business if we aren't to\n    // lose too much precision\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have a correctly rounded integer representation together\n    // with the correct exponent. The rest is just formatting.\n\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return -1;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 183, 183, 320], [377, 377, 405, 405, 1401], [1618, 1618, 1649, 1699, 1949], [3513, 3513, 3534, 3534, 3702], [3704, 3704, 3756, 3756, 4213]], "test": "untested"}
{"id": "cdXXRS", "name": "Layered Value Noise (fractal)", "author": "Street56", "description": "Spins around a map of fractal noise", "tags": ["valuenoise", "fractalnoise"], "likes": 2, "viewed": 170, "published": 3, "date": "1669070765", "time_retrieved": "2024-07-30T16:18:08.189211", "image_code": "float seed[] = float[](3.6f, 2.2f, 9.7f, 1.1f, 6.2f, 9.3f, 6.9f, 8.4f, 2.3f, 5.1f, 6.2f, 7.0f, 1.6f, 3.1f, 8.0f, 6.9f, 6.3f, 9.6f, 2.6f, 8.0f, 0.6f, 9.8f, 3.7f, 0.7f, 8.5f, 1.1f, 7.8f, \n5.2f, 8.5f, 8.7f, 4.6f, 5.7f, 8.8f, 2.7f, 1.7f, 5.2f, 1.4f, 2.3f, 3.5f, 3.5f, 7.9f, 3.2f, 7.7f, 2.0f, 2.4f, 3.6f, 1.0f, 4.3f, 0.9f, 7.8f, 4.2f, 1.4f, 4.8f, 4.8f, \n6.0f, 9.6f, 5.8f, 8.4f, 1.1f, 8.8f, 0.7f, 1.5f, 5.1f, 8.7f, 2.8f, 4.7f, 4.9f, 7.1f, 9.0f, 2.3f, 2.4f, 5.3f, 2.4f, 3.2f, 7.2f, 2.4f, 1.4f, 9.0f, 8.5f, 6.9f, 9.8f, \n7.0f, 4.7f, 8.8f, 1.2f, 4.1f, 3.9f, 5.9f, 9.1f, 1.1f, 3.5f, 2.5f, 7.7f, 4.2f, 2.3f, 5.7f, 9.5f, 1.5f, 1.0f, 9.4f, 9.2f, 2.5f, 3.6f, 5.5f, 3.8f, 1.6f, 2.1f, 0.5f, \n1.5f, 1.5f, 8.9f, 5.3f, 1.0f, 6.1f, 0.1f, 2.5f, 6.0f, 9.9f, 3.4f, 2.9f, 5.0f, 9.9f, 6.6f, 7.2f, 6.2f, 2.0f, 9.8f, 7.7f, 0.1f, 3.6f, 5.5f, 4.5f, 0.1f, 2.8f, 9.8f, \n5.5f, 1.0f, 6.0f, 3.6f, 0.4f, 6.0f, 1.0f, 7.8f, 2.6f, 1.7f, 4.1f, 8.8f, 5.2f, 8.2f, 4.3f, 1.8f, 4.3f, 2.7f, 6.0f, 2.3f, 8.8f, 1.0f, 8.3f, 3.0f, 2.7f, 2.5f, 4.2f, \n2.5f, 2.9f, 5.1f, 6.0f, 0.3f, 6.2f, 4.0f, 8.2f, 5.3f, 8.6f, 5.1f, 7.0f, 1.5f, 9.0f, 2.7f, 0.2f, 4.3f, 6.7f, 7.1f, 8.1f, 3.0f, 8.9f, 7.6f, 5.0f, 2.1f, 8.1f, 4.2f, \n8.8f, 8.7f, 7.1f, 0.1f, 8.3f, 0.0f, 2.3f, 4.6f, 1.4f, 7.6f, 4.1f, 5.7f, 2.9f, 4.6f, 4.6f, 8.0f, 0.2f, 2.6f, 7.0f, 9.9f, 8.5f, 8.8f, 1.6f, 6.5f, 1.8f, 3.5f, 4.4f, \n3.0f, 1.7f, 0.1f, 3.7f, 2.1f, 2.0f, 4.8f, 0.3f, 2.4f, 7.9f, 7.4f, 3.1f, 5.1f, 5.5f, 0.3f, 6.7f, 0.2f, 9.7f, 4.6f, 0.8f, 5.4f, 3.0f, 4.2f, 1.1f, 2.1f, 3.1f, 5.8f, \n6.5f, 6.7f, 4.7f, 8.7f, 9.2f, 4.0f, 8.2f, 8.9f, 6.4f, 2.6f, 6.4f, 0.3f, 1.2f);\n\n// Made by StoneTrench\n\nint seedSize = 16;\n\nfloat smoothStep(float x){\n    float x3 = x * x * x;\n    return 6.0 * (x3 * x * x) - 15.0 * (x3 * x) + 10.0 * (x3);\n}\nfloat lerp(float a, float b, float t){\n    return a + t * (b - a);\n}\n\n\nfloat sampleSeed(float _x, float _y){\n    vec2 pF = mod(abs(vec2(_x, _y)), float(seedSize));\n\n    int x = int(pF.x);\n    int y = int(pF.y);\n\n    return seed[x + (y * seedSize)] / 10.0f;\n}\n\nfloat sampleNoise(vec2 p){\n    float scale = 100.0f;\n    vec2 s = p / scale;\n    vec2 f = floor(s);\n    vec2 c = s;\n    \n    float s0 = sampleSeed(f.x, f.y);\n    float s1 = sampleSeed(f.x + 1.0f, f.y);\n    float s2 = sampleSeed(f.x, f.y + 1.0f);\n    float s3 = sampleSeed(f.x + 1.0f, f.y + 1.0f);\n    \n    float lx = lerp(s0, s1, (c.x - f.x));\n    float ly = lerp(s2, s3, (c.x - f.x));\n    \n    return lerp(lx, ly, (c.y - f.y));\n}\n\nfloat Octaves(vec2 fragCoord, int octaves){\n    float result = 0.0;\n    \n    float b = 1.0;\n    for (int i = 0; i < octaves; i++){\n        b *= 2.0;\n        result += sampleNoise(b * fragCoord);\n    }\n    \n    return sin(result / float(octaves));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 100.0;\n    float t = iTime / r * 100.0;\n    float noise = abs(Octaves(fragCoord + vec2(sin(t), cos(t)) * r, 4));\n\n    fragColor = vec4(1.0) * noise;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1614, 1614, 1640, 1640, 1731], [1732, 1732, 1770, 1770, 1800], [1803, 1803, 1840, 1840, 1990], [1992, 1992, 2018, 2018, 2422], [2424, 2424, 2467, 2467, 2672], [2674, 2674, 2731, 2731, 2896]], "test": "untested"}
{"id": "mdsSD7", "name": "Text Console Demo", "author": "Hatchling", "description": "Modified the text console (based on conversation with mla), created a demo to show debugging capabilities.\nUnderlying shader is [url]https://www.shadertoy.com/view/Ms2fWW[/url] by sh17b. (How the heck is this shader so small?)", "tags": ["draw", "debug", "int", "float", "debugging", "write"], "likes": 2, "viewed": 633, "published": 3, "date": "1669066463", "time_retrieved": "2024-07-30T16:18:09.004033", "image_code": "vec2 Path(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\treturn textureLod(iChannel2, (p+vec2(37.5,17.5) + f)/256.0, 0.).xy;\n}\n\n#define S(x) vec4(Path(x*vec2(.04,.1))*vec2(6,9),0,0)\n\nvoid hellCarting( out vec4 o, in vec2 C, inout TextCursor textCur ) \n{\n    vec4 p = vec4(C.xy,0,0)/iResolution.xyxy-.5, d=p, t, c, s;\n    p.z += iTime*8.;\n    p -= S(p.z);\n    float x, r, w, i;\n    for(i=1.5; i>0.; i-=.01)\n    {\n        // Select one of 5 type of wood beam separation\n        vec2 z = (p.zz-2.)*.25;\n        z = Path(z - fract(z))*4.+.5;\n        z = (z - fract(z))/10.;\n        z = mix(z, vec2(1.), step(vec2(.4), z));      \n        z *= step(4., mod(p.z-2., 8.));\n\t\tfloat f = mix(z.x, z.y, step(p.x, 0.));                \n        \n        t = abs(mod(c=p+S(p.z), 8.)-4.);\n        w = step(0., c.y);\n        r = (step(2.6, t.x) - step(2.8, t.x)) * w;        \n        s = texture(iChannel0, (c.y*t.x > 3. ? t.zxy:t.yzx)-3.);\n        x = min(t.x + f, t.y)-s.x * (1.-r) - r*.8;  \n         \n        // Hacky way of doing word wrapping.\n        {\n            TextCursor temp = textCur;             \n            printFloat(x, temp);   \n            if(temp.coord.y != textCur.coord.y)\n            {\n                printChar(cNl, textCur);       \n            }\n        }\n        printFloat(x, textCur);\n        printChar(cSp, textCur);\n                     \n        if(x < .01) break;\n        p -= d*x*.5;\n     }\n    w = step(t.x, 0.8) * step(2.8, t.z) + step(2.8, t.x) * step(0., c.y);\n\to = p.wyyw*.02 + 1.3* mix(s, vec4(.8), r) * mix(vec4(1), vec4(1,.5,.2,1), w ) * i/p.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Draw the scene normally.\n    TextCursor tDummy;\n    hellCarting(fragColor, fragCoord, tDummy);\n\n    // Draw debugging info.\n    {\n        Font f;\n        f.texSize = iChannelResolution[3].xy;\n        f.charSize = iChannelResolution[3].xy / vec2(16, 16);\n\n        TextCursor t;\n        const vec2 charScale = vec2(15, 15);\n        t.startPos = vec2(0, iResolution.y);\n        t.coord = ivec2(0);\n        t.font = f;\n        t.color = vec4(1,1,0,1);\n        t.charSize = vec2(1,1) * charScale;\n        t.charSpace = vec2(1, 1) * charScale;\n        t.pageWidth = int(iResolution.x / t.charSize.x);\n        t.fragCoord = fragCoord;\n    \n        vec4 colorDummy;\n        hellCarting(colorDummy, iMouse.xy, t);\n        drawText(t, iChannel3, fragColor);\n    }\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String\n{\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font\n{\n    vec2 texSize;\n    vec2 charSize;\n};\n\nstruct TextCursor\n{\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char)\n{\n    vec2 uvSize = f.charSize / f.texSize;\n    return vec4(char, char+ivec2(1)) * uvSize.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t)\n{\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV)\n    {\n        return;\n    }\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n\nvoid printInt(int val, inout TextCursor t)\n{\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)\n    {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n}\n\nvoid printFloat(float val, inout TextCursor t)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n    \n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor)\n{\n    vec4 color = t.outColor;\n    color.a *= texture(fontTexture, t.outUV).r;\n    blend(color, fragColor);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 156], [213, 213, 283, 283, 1599], [1602, 1602, 1659, 1691, 2422]], "test": "untested"}
{"id": "ddsXWM", "name": "The Waste Land", "author": "mla", "description": "T.S. Eliot's great modernist poem, first published 1922. Horizontal mouse scrolls vertically, vertical mouse changes scrolling speed.", "tags": ["text", "font", "tseliot"], "likes": 15, "viewed": 382, "published": 3, "date": "1669062821", "time_retrieved": "2024-07-30T16:18:11.544241", "image_code": "/////////////////////////////////////////////////////////////\n//\n// The Waste Land, mla, 2022 (with help from T.S. Eliot)\n//\n// Simple but efficient scrolling text display.\n//\n// Text from Project Gutenberg.\n//\n/////////////////////////////////////////////////////////////\n\nconst int nlines = lines.length();\n\nint getchar(int col, int row) {\n  if (row < 0 || row >= nlines) return -1;\n  //return col>=64?-1:row%4*64+col%64; // Debug\n  int linestart = lines[row];\n  int lineend = lines[row+1];\n  int index = linestart+col;\n  if (index >= lineend) return -1;\n  uvec4 v = data[index/16];\n  index %= 16;\n  uint t = v[index/4];\n  index %= 4;\n  t >>= ((3-index)*8);\n  return int(t)&0xff;\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return fract((vec2(c,15-c/16)+p)/16.0);\n}\n\nfloat hud(vec2 fragCoord) {\n  vec4 metrics = vec4(0.25,0.75,0,1); // Region of font to display, z & w ignored\n  float charwidth = metrics.y-metrics.x;\n  float ncols = 78.0;\n\n  fragCoord.y = iResolution.y-fragCoord.y; // Flip vertically\n  float fsize = iResolution.x/(charwidth*ncols); // 'Font size' = line height in pixels\n  vec2 uv = fragCoord / fsize; \n  float scrollspeed = 0.75;\n  if (iMouse.x > 0.0) scrollspeed = 2.0*iMouse.y/iResolution.y;\n  uv.y += scrollspeed*max(0.0,iTime-2.0);\n  if (iMouse.x > 0.0) uv.y += iMouse.x/iResolution.x*(float(nlines)-iResolution.y/fsize);\n\n  int row = int(floor(uv.y));\n  int col = int(floor(uv.x/charwidth));\n  int c = getchar(col,row); // Get character at charpos, 0 if out of range\n  if (c < 0) return 0.0;\n  float x = uv.x-charwidth*float(col)+metrics.x;\n  float y = fract(-uv.y);\n  vec2 tuv = char(vec2(x,y),c);\n  // diffs for textureGrad \n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n  vec4 t = textureGrad(iChannel0,tuv,dx,dy);\n  return t.x;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 col = vec3(hud(fragCoord));\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if 1\nconst uvec4 data[] = uvec4[](\n  uvec4(0x20202020u,0x20205448u,0x45205741u,0x53544520u),\n  uvec4(0x4c414e44u,0x20202020u,0x20204279u,0x20542e20u),\n  uvec4(0x532e2045u,0x6c696f74u,0x436f6e74u,0x656e7473u),\n  uvec4(0x20202020u,0x20202020u,0x20202049u,0x2e205448u),\n  uvec4(0x45204255u,0x5249414cu,0x204f4620u,0x54484520u),\n  uvec4(0x44454144u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x49492e20u,0x41204741u,0x4d45204fu,0x46204348u),\n  uvec4(0x45535320u,0x20202020u,0x20202020u,0x20202049u),\n  uvec4(0x49492e20u,0x54484520u,0x46495245u,0x20534552u),\n  uvec4(0x4d4f4e20u,0x20202020u,0x20202020u,0x20202049u),\n  uvec4(0x562e2044u,0x45415448u,0x20425920u,0x57415445u),\n  uvec4(0x52202020u,0x20202020u,0x20202020u,0x20562e20u),\n  uvec4(0x57484154u,0x20544845u,0x20544855u,0x4e444552u),\n  uvec4(0x20534149u,0x44202020u,0x20202020u,0x20202020u),\n  uvec4(0x204e4f54u,0x4553204fu,0x4e202254u,0x48452057u),\n  uvec4(0x41535445u,0x204c414eu,0x44222020u,0x20224e61u),\n  uvec4(0x6d205369u,0x62796c6cu,0x616d2071u,0x75696465u),\n  uvec4(0x6d204375u,0x6d697320u,0x65676f20u,0x69707365u),\n  uvec4(0x206f6375u,0x6c697320u,0x6d656973u,0x20207669u),\n  uvec4(0x64692069u,0x6e20616du,0x70756c6cu,0x61207065u),\n  uvec4(0x6e646572u,0x652c2065u,0x74206375u,0x6d20696cu),\n  uvec4(0x6c692070u,0x75657269u,0x20646963u,0x6572656eu),\n  uvec4(0x743a2020u,0x95698175u,0x86868020u,0x8c692085u),\n  uvec4(0x84868469u,0x8b3b2072u,0x6573706fu,0x6e646562u),\n  uvec4(0x61742069u,0x6c6c613au,0x2080896fu,0x85807684u),\n  uvec4(0x69762085u,0x84868f2eu,0x22202020u,0x20202020u),\n  uvec4(0x2020466fu,0x7220457au,0x72612050u,0x6f756e64u),\n  uvec4(0x20202020u,0x20202020u,0x20696c20u,0x6d69676cu),\n  uvec4(0x696f7220u,0x66616262u,0x726f2020u,0x20202020u),\n  uvec4(0x492e2054u,0x48452042u,0x55524941u,0x4c204f46u),\n  uvec4(0x20544845u,0x20444541u,0x44202041u,0x7072696cu),\n  uvec4(0x20697320u,0x74686520u,0x63727565u,0x6c6c6573u),\n  uvec4(0x74206d6fu,0x6e74682cu,0x20627265u,0x6564696eu),\n  uvec4(0x6720204cu,0x696c6163u,0x73206f75u,0x74206f66u),\n  uvec4(0x20746865u,0x20646561u,0x64206c61u,0x6e642c20u),\n  uvec4(0x6d697869u,0x6e672020u,0x4d656d6fu,0x72792061u),\n  uvec4(0x6e642064u,0x65736972u,0x652c2073u,0x74697272u),\n  uvec4(0x696e6720u,0x2044756cu,0x6c20726fu,0x6f747320u),\n  uvec4(0x77697468u,0x20737072u,0x696e6720u,0x7261696eu),\n  uvec4(0x2e202057u,0x696e7465u,0x72206b65u,0x70742075u),\n  uvec4(0x73207761u,0x726d2c20u,0x636f7665u,0x72696e67u),\n  uvec4(0x20204561u,0x72746820u,0x696e2066u,0x6f726765u),\n  uvec4(0x7466756cu,0x20736e6fu,0x772c2066u,0x65656469u),\n  uvec4(0x6e672020u,0x41206c69u,0x74746c65u,0x206c6966u),\n  uvec4(0x65207769u,0x74682064u,0x72696564u,0x20747562u),\n  uvec4(0x6572732eu,0x20205375u,0x6d6d6572u,0x20737572u),\n  uvec4(0x70726973u,0x65642075u,0x732c2063u,0x6f6d696eu),\n  uvec4(0x67206f76u,0x65722074u,0x68652053u,0x7461726eu),\n  uvec4(0x62657267u,0x65727365u,0x65202057u,0x69746820u),\n  uvec4(0x61207368u,0x6f776572u,0x206f6620u,0x7261696eu),\n  uvec4(0x3b207765u,0x2073746fu,0x70706564u,0x20696e20u),\n  uvec4(0x74686520u,0x636f6c6fu,0x6e6e6164u,0x652c2020u),\n  uvec4(0x416e6420u,0x77656e74u,0x206f6e20u,0x696e2073u),\n  uvec4(0x756e6c69u,0x6768742cu,0x20696e74u,0x6f207468u),\n  uvec4(0x6520486fu,0x66676172u,0x74656e2cu,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x31302020u,0x416e6420u),\n  uvec4(0x6472616eu,0x6b20636fu,0x66666565u,0x2c20616eu),\n  uvec4(0x64207461u,0x6c6b6564u,0x20666f72u,0x20616e20u),\n  uvec4(0x686f7572u,0x2e202042u,0x696e2067u,0x6172206bu),\n  uvec4(0x65696e65u,0x20527573u,0x73696e2cu,0x20737461u),\n  uvec4(0x6d6d2720u,0x61757320u,0x4c697461u,0x75656e2cu),\n  uvec4(0x20656368u,0x74206465u,0x75747363u,0x682e2020u),\n  uvec4(0x416e6420u,0x7768656eu,0x20776520u,0x77657265u),\n  uvec4(0x20636869u,0x6c647265u,0x6e2c2073u,0x74617969u),\n  uvec4(0x6e672061u,0x74207468u,0x65206172u,0x63686475u),\n  uvec4(0x6b652773u,0x2c20204du,0x7920636fu,0x7573696eu),\n  uvec4(0x27732c20u,0x68652074u,0x6f6f6b20u,0x6d65206fu),\n  uvec4(0x7574206fu,0x6e206120u,0x736c6564u,0x2c202041u),\n  uvec4(0x6e642049u,0x20776173u,0x20667269u,0x67687465u),\n  uvec4(0x6e65642eu,0x20486520u,0x73616964u,0x2c204d61u),\n  uvec4(0x7269652cu,0x20204d61u,0x7269652cu,0x20686f6cu),\n  uvec4(0x64206f6eu,0x20746967u,0x68742e20u,0x416e6420u),\n  uvec4(0x646f776eu,0x20776520u,0x77656e74u,0x2e202049u),\n  uvec4(0x6e207468u,0x65206d6fu,0x756e7461u,0x696e732cu),\n  uvec4(0x20746865u,0x72652079u,0x6f752066u,0x65656c20u),\n  uvec4(0x66726565u,0x2e202049u,0x20726561u,0x642c206du),\n  uvec4(0x75636820u,0x6f662074u,0x6865206eu,0x69676874u),\n  uvec4(0x2c20616eu,0x6420676fu,0x20736f75u,0x74682069u),\n  uvec4(0x6e207468u,0x65207769u,0x6e746572u,0x2e202057u),\n  uvec4(0x68617420u,0x61726520u,0x74686520u,0x726f6f74u),\n  uvec4(0x73207468u,0x61742063u,0x6c757463u,0x682c2077u),\n  uvec4(0x68617420u,0x6272616eu,0x63686573u,0x2067726fu),\n  uvec4(0x7720204fu,0x7574206fu,0x66207468u,0x69732073u),\n  uvec4(0x746f6e79u,0x20727562u,0x62697368u,0x3f20536fu),\n  uvec4(0x6e206f66u,0x206d616eu,0x2c202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202032u,0x30202059u),\n  uvec4(0x6f752063u,0x616e6e6fu,0x74207361u,0x792c206fu),\n  uvec4(0x72206775u,0x6573732cu,0x20666f72u,0x20796f75u),\n  uvec4(0x206b6e6fu,0x77206f6eu,0x6c792020u,0x41206865u),\n  uvec4(0x6170206fu,0x66206272u,0x6f6b656eu,0x20696d61u),\n  uvec4(0x6765732cu,0x20776865u,0x72652074u,0x68652073u),\n  uvec4(0x756e2062u,0x65617473u,0x2c202041u,0x6e642074u),\n  uvec4(0x68652064u,0x65616420u,0x74726565u,0x20676976u),\n  uvec4(0x6573206eu,0x6f207368u,0x656c7465u,0x722c2074u),\n  uvec4(0x68652063u,0x7269636bu,0x6574206eu,0x6f207265u),\n  uvec4(0x6c696566u,0x2c202041u,0x6e642074u,0x68652064u),\n  uvec4(0x72792073u,0x746f6e65u,0x206e6f20u,0x736f756eu),\n  uvec4(0x64206f66u,0x20776174u,0x65722e20u,0x4f6e6c79u),\n  uvec4(0x20205468u,0x65726520u,0x69732073u,0x6861646fu),\n  uvec4(0x7720756eu,0x64657220u,0x74686973u,0x20726564u),\n  uvec4(0x20726f63u,0x6b2c2020u,0x28436f6du,0x6520696eu),\n  uvec4(0x20756e64u,0x65722074u,0x68652073u,0x6861646fu),\n  uvec4(0x77206f66u,0x20746869u,0x73207265u,0x6420726fu),\n  uvec4(0x636b292cu,0x2020416eu,0x64204920u,0x77696c6cu),\n  uvec4(0x2073686fu,0x7720796fu,0x7520736fu,0x6d657468u),\n  uvec4(0x696e6720u,0x64696666u,0x6572656eu,0x74206672u),\n  uvec4(0x6f6d2065u,0x69746865u,0x72202059u,0x6f757220u),\n  uvec4(0x73686164u,0x6f772061u,0x74206d6fu,0x726e696eu),\n  uvec4(0x67207374u,0x72696469u,0x6e672062u,0x6568696eu),\n  uvec4(0x6420796fu,0x7520204fu,0x7220796fu,0x75722073u),\n  uvec4(0x6861646fu,0x77206174u,0x20657665u,0x6e696e67u),\n  uvec4(0x20726973u,0x696e6720u,0x746f206du,0x65657420u),\n  uvec4(0x796f753bu,0x20204920u,0x77696c6cu,0x2073686fu),\n  uvec4(0x7720796fu,0x75206665u,0x61722069u,0x6e206120u),\n  uvec4(0x68616e64u,0x66756c20u,0x6f662064u,0x7573742eu),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20203330u),\n  uvec4(0x20202020u,0x20202046u,0x72697363u,0x68207765u),\n  uvec4(0x68742064u,0x65722057u,0x696e6420u,0x20202020u),\n  uvec4(0x20204465u,0x72204865u,0x696d6174u,0x207a7520u),\n  uvec4(0x20202020u,0x20204d65u,0x696e2049u,0x72697363u),\n  uvec4(0x68204b69u,0x6e642c20u,0x20202020u,0x2020576fu),\n  uvec4(0x20776569u,0x6c657374u,0x2064753fu,0x20202259u),\n  uvec4(0x6f752067u,0x61766520u,0x6d652068u,0x79616369u),\n  uvec4(0x6e746873u,0x20666972u,0x73742061u,0x20796561u),\n  uvec4(0x72206167u,0x6f3b2020u,0x22546865u,0x79206361u),\n  uvec4(0x6c6c6564u,0x206d6520u,0x74686520u,0x68796163u),\n  uvec4(0x696e7468u,0x20676972u,0x6c2e2220u,0x202d2059u),\n  uvec4(0x65742077u,0x68656e20u,0x77652063u,0x616d6520u),\n  uvec4(0x6261636bu,0x2c206c61u,0x74652c20u,0x66726f6du),\n  uvec4(0x20746865u,0x20487961u,0x63696e74u,0x68206761u),\n  uvec4(0x7264656eu,0x2c202059u,0x6f757220u,0x61726d73u),\n  uvec4(0x2066756cu,0x6c2c2061u,0x6e642079u,0x6f757220u),\n  uvec4(0x68616972u,0x20776574u,0x2c204920u,0x636f756cu),\n  uvec4(0x64206e6fu,0x74202053u,0x7065616bu,0x2c20616eu),\n  uvec4(0x64206d79u,0x20657965u,0x73206661u,0x696c6564u),\n  uvec4(0x2c204920u,0x77617320u,0x6e656974u,0x68657220u),\n  uvec4(0x204c6976u,0x696e6720u,0x6e6f7220u,0x64656164u),\n  uvec4(0x2c20616eu,0x64204920u,0x6b6e6577u,0x206e6f74u),\n  uvec4(0x68696e67u,0x2c202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20343020u,0x204c6f6fu),\n  uvec4(0x6b696e67u,0x20696e74u,0x6f207468u,0x65206865u),\n  uvec4(0x61727420u,0x6f66206cu,0x69676874u,0x2c207468u),\n  uvec4(0x65207369u,0x6c656e63u,0x652e2020u,0x4f656427u),\n  uvec4(0x20756e64u,0x206c6565u,0x72206461u,0x73204d65u),\n  uvec4(0x65722e20u,0x204d6164u,0x616d6520u,0x536f736fu),\n  uvec4(0x73747269u,0x732c2066u,0x616d6f75u,0x7320636cu),\n  uvec4(0x61697276u,0x6f79616eu,0x74652c20u,0x20486164u),\n  uvec4(0x20612062u,0x61642063u,0x6f6c642cu,0x206e6576u),\n  uvec4(0x65727468u,0x656c6573u,0x73202049u,0x73206b6eu),\n  uvec4(0x6f776e20u,0x746f2062u,0x65207468u,0x65207769u),\n  uvec4(0x73657374u,0x20776f6du,0x616e2069u,0x6e204575u),\n  uvec4(0x726f7065u,0x2c202057u,0x69746820u,0x61207769u),\n  uvec4(0x636b6564u,0x20706163u,0x6b206f66u,0x20636172u),\n  uvec4(0x64732e20u,0x48657265u,0x2c207361u,0x69642073u),\n  uvec4(0x68652c20u,0x20497320u,0x796f7572u,0x20636172u),\n  uvec4(0x642c2074u,0x68652064u,0x726f776eu,0x65642050u),\n  uvec4(0x686f656eu,0x69636961u,0x6e205361u,0x696c6f72u),\n  uvec4(0x2c202028u,0x54686f73u,0x65206172u,0x65207065u),\n  uvec4(0x61726c73u,0x20746861u,0x74207765u,0x72652068u),\n  uvec4(0x69732065u,0x7965732eu,0x204c6f6fu,0x6b212920u),\n  uvec4(0x20486572u,0x65206973u,0x2042656cu,0x6c61646fu),\n  uvec4(0x6e6e612cu,0x20746865u,0x204c6164u,0x79206f66u),\n  uvec4(0x20746865u,0x20526f63u,0x6b732c20u,0x20546865u),\n  uvec4(0x206c6164u,0x79206f66u,0x20736974u,0x75617469u),\n  uvec4(0x6f6e732eu,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20353020u,0x20486572u,0x65206973u),\n  uvec4(0x20746865u,0x206d616eu,0x20776974u,0x68207468u),\n  uvec4(0x72656520u,0x73746176u,0x65732c20u,0x616e6420u),\n  uvec4(0x68657265u,0x20746865u,0x20576865u,0x656c2c20u),\n  uvec4(0x20416e64u,0x20686572u,0x65206973u,0x20746865u),\n  uvec4(0x206f6e65u,0x2d657965u,0x64206d65u,0x72636861u),\n  uvec4(0x6e742c20u,0x616e6420u,0x74686973u,0x20636172u),\n  uvec4(0x642c2020u,0x57686963u,0x68206973u,0x20626c61u),\n  uvec4(0x6e6b2c20u,0x69732073u,0x6f6d6574u,0x68696e67u),\n  uvec4(0x20686520u,0x63617272u,0x69657320u,0x6f6e2068u),\n  uvec4(0x69732062u,0x61636b2cu,0x20205768u,0x69636820u),\n  uvec4(0x4920616du,0x20666f72u,0x62696464u,0x656e2074u),\n  uvec4(0x6f207365u,0x652e2049u,0x20646f20u,0x6e6f7420u),\n  uvec4(0x66696e64u,0x20205468u,0x65204861u,0x6e676564u),\n  uvec4(0x204d616eu,0x2e204665u,0x61722064u,0x65617468u),\n  uvec4(0x20627920u,0x77617465u,0x722e2020u,0x49207365u),\n  uvec4(0x65206372u,0x6f776473u,0x206f6620u,0x70656f70u),\n  uvec4(0x6c652c20u,0x77616c6bu,0x696e6720u,0x726f756eu),\n  uvec4(0x6420696eu,0x20612072u,0x696e672eu,0x20205468u),\n  uvec4(0x616e6b20u,0x796f752eu,0x20496620u,0x796f7520u),\n  uvec4(0x73656520u,0x64656172u,0x204d7273u,0x2e204571u),\n  uvec4(0x7569746fu,0x6e652c20u,0x2054656cu,0x6c206865u),\n  uvec4(0x72204920u,0x6272696eu,0x67207468u,0x6520686fu),\n  uvec4(0x726f7363u,0x6f706520u,0x6d797365u,0x6c663a20u),\n  uvec4(0x204f6e65u,0x206d7573u,0x74206265u,0x20736f20u),\n  uvec4(0x63617265u,0x66756c20u,0x74686573u,0x65206461u),\n  uvec4(0x79732e20u,0x20556e72u,0x65616c20u,0x43697479u),\n  uvec4(0x2c202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20363020u),\n  uvec4(0x20556e64u,0x65722074u,0x68652062u,0x726f776eu),\n  uvec4(0x20666f67u,0x206f6620u,0x61207769u,0x6e746572u),\n  uvec4(0x20646177u,0x6e2c2020u,0x41206372u,0x6f776420u),\n  uvec4(0x666c6f77u,0x6564206fu,0x76657220u,0x4c6f6e64u),\n  uvec4(0x6f6e2042u,0x72696467u,0x652c2073u,0x6f206d61u),\n  uvec4(0x6e792c20u,0x20492068u,0x6164206eu,0x6f742074u),\n  uvec4(0x686f7567u,0x68742064u,0x65617468u,0x20686164u),\n  uvec4(0x20756e64u,0x6f6e6520u,0x736f206du,0x616e792eu),\n  uvec4(0x20205369u,0x6768732cu,0x2073686fu,0x72742061u),\n  uvec4(0x6e642069u,0x6e667265u,0x7175656eu,0x742c2077u),\n  uvec4(0x65726520u,0x65786861u,0x6c65642cu,0x2020416eu),\n  uvec4(0x64206561u,0x6368206du,0x616e2066u,0x69786564u),\n  uvec4(0x20686973u,0x20657965u,0x73206265u,0x666f7265u),\n  uvec4(0x20686973u,0x20666565u,0x742e2020u,0x466c6f77u),\n  uvec4(0x65642075u,0x70207468u,0x65206869u,0x6c6c2061u),\n  uvec4(0x6e642064u,0x6f776e20u,0x4b696e67u,0x2057696cu),\n  uvec4(0x6c69616du,0x20537472u,0x6565742cu,0x2020546fu),\n  uvec4(0x20776865u,0x72652053u,0x61696e74u,0x204d6172u),\n  uvec4(0x7920576fu,0x6f6c6e6fu,0x7468206bu,0x65707420u),\n  uvec4(0x74686520u,0x686f7572u,0x73202057u,0x69746820u),\n  uvec4(0x61206465u,0x61642073u,0x6f756e64u,0x206f6e20u),\n  uvec4(0x74686520u,0x66696e61u,0x6c207374u,0x726f6b65u),\n  uvec4(0x206f6620u,0x6e696e65u,0x2e202054u,0x68657265u),\n  uvec4(0x20492073u,0x6177206fu,0x6e652049u,0x206b6e65u),\n  uvec4(0x772c2061u,0x6e642073u,0x746f7070u,0x65642068u),\n  uvec4(0x696d2c20u,0x63727969u,0x6e672022u,0x53746574u),\n  uvec4(0x736f6e21u,0x20202259u,0x6f752077u,0x686f2077u),\n  uvec4(0x65726520u,0x77697468u,0x206d6520u,0x696e2074u),\n  uvec4(0x68652073u,0x68697073u,0x20617420u,0x4d796c61u),\n  uvec4(0x65212020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20203730u),\n  uvec4(0x20202254u,0x68617420u,0x636f7270u,0x73652079u),\n  uvec4(0x6f752070u,0x6c616e74u,0x6564206cu,0x61737420u),\n  uvec4(0x79656172u,0x20696e20u,0x796f7572u,0x20676172u),\n  uvec4(0x64656e2cu,0x20202248u,0x61732069u,0x74206265u),\n  uvec4(0x67756e20u,0x746f2073u,0x70726f75u,0x743f2057u),\n  uvec4(0x696c6c20u,0x69742062u,0x6c6f6f6du,0x20746869u),\n  uvec4(0x73207965u,0x61723f20u,0x20224f72u,0x20686173u),\n  uvec4(0x20746865u,0x20737564u,0x64656e20u,0x66726f73u),\n  uvec4(0x74206469u,0x73747572u,0x62656420u,0x69747320u),\n  uvec4(0x6265643fu,0x2020224fu,0x68206b65u,0x65702074u),\n  uvec4(0x68652044u,0x6f672066u,0x61722068u,0x656e6365u),\n  uvec4(0x2c207468u,0x61742773u,0x20667269u,0x656e6420u),\n  uvec4(0x746f206du,0x656e2c20u,0x20224f72u,0x20776974u),\n  uvec4(0x68206869u,0x73206e61u,0x696c7320u,0x6865276cu),\n  uvec4(0x6c206469u,0x67206974u,0x20757020u,0x61676169u),\n  uvec4(0x6e212020u,0x22596f75u,0x21206879u,0x706f6372u),\n  uvec4(0x69746520u,0x6c656374u,0x65757221u,0x202d206du),\n  uvec4(0x6f6e2073u,0x656d626cu,0x61626c65u,0x2c202d20u),\n  uvec4(0x6d6f6e20u,0x6672e872u,0x65212220u,0x20202020u),\n  uvec4(0x20202020u,0x2049492eu,0x20412047u,0x414d4520u),\n  uvec4(0x4f462043u,0x48455353u,0x20205468u,0x65204368u),\n  uvec4(0x61697220u,0x73686520u,0x73617420u,0x696e2c20u),\n  uvec4(0x6c696b65u,0x20612062u,0x75726e69u,0x73686564u),\n  uvec4(0x20746872u,0x6f6e652cu,0x2020476cu,0x6f776564u),\n  uvec4(0x206f6e20u,0x74686520u,0x6d617262u,0x6c652c20u),\n  uvec4(0x77686572u,0x65207468u,0x6520676cu,0x61737320u),\n  uvec4(0x2048656cu,0x64207570u,0x20627920u,0x7374616eu),\n  uvec4(0x64617264u,0x73207772u,0x6f756768u,0x74207769u),\n  uvec4(0x74682066u,0x72756974u,0x65642076u,0x696e6573u),\n  uvec4(0x20204672u,0x6f6d2077u,0x68696368u,0x20612067u),\n  uvec4(0x6f6c6465u,0x6e204375u,0x7069646fu,0x6e207065u),\n  uvec4(0x65706564u,0x206f7574u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20203830u,0x20202841u),\n  uvec4(0x6e6f7468u,0x65722068u,0x69642068u,0x69732065u),\n  uvec4(0x79657320u,0x62656869u,0x6e642068u,0x69732077u),\n  uvec4(0x696e6729u,0x2020446fu,0x75626c65u,0x64207468u),\n  uvec4(0x6520666cu,0x616d6573u,0x206f6620u,0x73657665u),\n  uvec4(0x6e627261u,0x6e636865u,0x64206361u,0x6e64656cu),\n  uvec4(0x61627261u,0x20205265u,0x666c6563u,0x74696e67u),\n  uvec4(0x206c6967u,0x68742075u,0x706f6e20u,0x74686520u),\n  uvec4(0x7461626cu,0x65206173u,0x20205468u,0x6520676cu),\n  uvec4(0x69747465u,0x72206f66u,0x20686572u,0x206a6577u),\n  uvec4(0x656c7320u,0x726f7365u,0x20746f20u,0x6d656574u),\n  uvec4(0x2069742cu,0x20204672u,0x6f6d2073u,0x6174696eu),\n  uvec4(0x20636173u,0x65732070u,0x6f757265u,0x6420696eu),\n  uvec4(0x20726963u,0x68207072u,0x6f667573u,0x696f6e2eu),\n  uvec4(0x2020496eu,0x20766961u,0x6c73206fu,0x66206976u),\n  uvec4(0x6f727920u,0x616e6420u,0x636f6c6fu,0x75726564u),\n  uvec4(0x20676c61u,0x73732020u,0x556e7374u,0x6f707065u),\n  uvec4(0x7265642cu,0x206c7572u,0x6b656420u,0x68657220u),\n  uvec4(0x73747261u,0x6e676520u,0x73796e74u,0x68657469u),\n  uvec4(0x63207065u,0x7266756du,0x65732c20u,0x20556e67u),\n  uvec4(0x75656e74u,0x2c20706fu,0x77646572u,0x65642c20u),\n  uvec4(0x6f72206cu,0x69717569u,0x642d7472u,0x6f75626cu),\n  uvec4(0x65642c20u,0x636f6e66u,0x75736564u,0x2020416eu),\n  uvec4(0x64206472u,0x6f776e65u,0x64207468u,0x65207365u),\n  uvec4(0x6e736520u,0x696e206fu,0x646f7572u,0x733b2073u),\n  uvec4(0x74697272u,0x65642062u,0x79207468u,0x65206169u),\n  uvec4(0x72202054u,0x68617420u,0x66726573u,0x68656e65u),\n  uvec4(0x64206672u,0x6f6d2074u,0x68652077u,0x696e646fu),\n  uvec4(0x772c2074u,0x68657365u,0x20617363u,0x656e6465u),\n  uvec4(0x64202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202039u,0x30202049u),\n  uvec4(0x6e206661u,0x7474656eu,0x696e6720u,0x74686520u),\n  uvec4(0x70726f6cu,0x6f6e6765u,0x64206361u,0x6e646c65u),\n  uvec4(0x2d666c61u,0x6d65732cu,0x2020466cu,0x756e6720u),\n  uvec4(0x74686569u,0x7220736du,0x6f6b6520u,0x696e746fu),\n  uvec4(0x20746865u,0x206c6171u,0x75656172u,0x69612c20u),\n  uvec4(0x20537469u,0x7272696eu,0x67207468u,0x65207061u),\n  uvec4(0x74746572u,0x6e206f6eu,0x20746865u,0x20636f66u),\n  uvec4(0x66657265u,0x64206365u,0x696c696eu,0x672e2020u),\n  uvec4(0x48756765u,0x20736561u,0x2d776f6fu,0x64206665u),\n  uvec4(0x64207769u,0x74682063u,0x6f707065u,0x72202042u),\n  uvec4(0x75726e65u,0x64206772u,0x65656e20u,0x616e6420u),\n  uvec4(0x6f72616eu,0x67652c20u,0x6672616du,0x65642062u),\n  uvec4(0x79207468u,0x6520636fu,0x6c6f7572u,0x65642073u),\n  uvec4(0x746f6e65u,0x2c202049u,0x6e207768u,0x69636820u),\n  uvec4(0x73616420u,0x6c696768u,0x74206120u,0x63617276u),\n  uvec4(0xe8642064u,0x6f6c7068u,0x696e2073u,0x77616d2eu),\n  uvec4(0x20204162u,0x6f766520u,0x74686520u,0x616e7469u),\n  uvec4(0x71756520u,0x6d616e74u,0x656c2077u,0x61732064u),\n  uvec4(0x6973706cu,0x61796564u,0x20204173u,0x2074686fu),\n  uvec4(0x75676820u,0x61207769u,0x6e646f77u,0x20676176u),\n  uvec4(0x65207570u,0x6f6e2074u,0x68652073u,0x796c7661u),\n  uvec4(0x6e207363u,0x656e6520u,0x20546865u,0x20636861u),\n  uvec4(0x6e676520u,0x6f662050u,0x68696c6fu,0x6d656c2cu),\n  uvec4(0x20627920u,0x74686520u,0x62617262u,0x61726f75u),\n  uvec4(0x73206b69u,0x6e672020u,0x536f2072u,0x7564656cu),\n  uvec4(0x7920666fu,0x72636564u,0x3b207965u,0x74207468u),\n  uvec4(0x65726520u,0x74686520u,0x6e696768u,0x74696e67u),\n  uvec4(0x616c6520u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x31303020u,0x2046696cu,0x6c656420u,0x616c6c20u),\n  uvec4(0x74686520u,0x64657365u,0x72742077u,0x69746820u),\n  uvec4(0x696e7669u,0x6f6c6162u,0x6c652076u,0x6f696365u),\n  uvec4(0x2020416eu,0x64207374u,0x696c6c20u,0x73686520u),\n  uvec4(0x63726965u,0x642c2061u,0x6e642073u,0x74696c6cu),\n  uvec4(0x20746865u,0x20776f72u,0x6c642070u,0x75727375u),\n  uvec4(0x65732c20u,0x20224a75u,0x67204a75u,0x67222074u),\n  uvec4(0x6f206469u,0x72747920u,0x65617273u,0x2e202041u),\n  uvec4(0x6e64206fu,0x74686572u,0x20776974u,0x68657265u),\n  uvec4(0x64207374u,0x756d7073u,0x206f6620u,0x74696d65u),\n  uvec4(0x20205765u,0x72652074u,0x6f6c6420u,0x75706f6eu),\n  uvec4(0x20746865u,0x2077616cu,0x6c733b20u,0x73746172u),\n  uvec4(0x696e6720u,0x666f726du,0x7320204cu,0x65616e65u),\n  uvec4(0x64206f75u,0x742c206cu,0x65616e69u,0x6e672c20u),\n  uvec4(0x68757368u,0x696e6720u,0x74686520u,0x726f6f6du),\n  uvec4(0x20656e63u,0x6c6f7365u,0x642e2020u,0x466f6f74u),\n  uvec4(0x73746570u,0x73207368u,0x7566666cu,0x6564206fu),\n  uvec4(0x6e207468u,0x65207374u,0x6169722eu,0x2020556eu),\n  uvec4(0x64657220u,0x74686520u,0x66697265u,0x6c696768u),\n  uvec4(0x742c2075u,0x6e646572u,0x20746865u,0x20627275u),\n  uvec4(0x73682c20u,0x68657220u,0x68616972u,0x20205370u),\n  uvec4(0x72656164u,0x206f7574u,0x20696e20u,0x66696572u),\n  uvec4(0x7920706fu,0x696e7473u,0x2020476cu,0x6f776564u),\n  uvec4(0x20696e74u,0x6f20776fu,0x7264732cu,0x20746865u),\n  uvec4(0x6e20776fu,0x756c6420u,0x62652073u,0x61766167u),\n  uvec4(0x656c7920u,0x7374696cu,0x6c2e2020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20203131u,0x30202022u,0x4d79206eu,0x65727665u),\n  uvec4(0x73206172u,0x65206261u,0x6420746fu,0x2d6e6967u),\n  uvec4(0x68742e20u,0x5965732cu,0x20626164u,0x2e205374u),\n  uvec4(0x61792077u,0x69746820u,0x6d652e20u,0x20225370u),\n  uvec4(0x65616b20u,0x746f206du,0x652e2057u,0x68792064u),\n  uvec4(0x6f20796fu,0x75206e65u,0x76657220u,0x73706561u),\n  uvec4(0x6b2e2053u,0x7065616bu,0x2e202022u,0x57686174u),\n  uvec4(0x20617265u,0x20796f75u,0x20746869u,0x6e6b696eu),\n  uvec4(0x67206f66u,0x3f205768u,0x61742074u,0x68696e6bu),\n  uvec4(0x696e673fu,0x20576861u,0x743f2020u,0x2249206eu),\n  uvec4(0x65766572u,0x206b6e6fu,0x77207768u,0x61742079u),\n  uvec4(0x6f752061u,0x72652074u,0x68696e6bu,0x696e672eu),\n  uvec4(0x20546869u,0x6e6b2e22u,0x20204920u,0x7468696eu),\n  uvec4(0x6b207765u,0x20617265u,0x20696e20u,0x72617473u),\n  uvec4(0x2720616cu,0x6c657920u,0x20576865u,0x72652074u),\n  uvec4(0x68652064u,0x65616420u,0x6d656e20u,0x6c6f7374u),\n  uvec4(0x20746865u,0x69722062u,0x6f6e6573u,0x2e202022u),\n  uvec4(0x57686174u,0x20697320u,0x74686174u,0x206e6f69u),\n  uvec4(0x73653f22u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202054u,0x68652077u,0x696e6420u,0x756e6465u),\n  uvec4(0x72207468u,0x6520646fu,0x6f722e20u,0x20225768u),\n  uvec4(0x61742069u,0x73207468u,0x6174206eu,0x6f697365u),\n  uvec4(0x206e6f77u,0x3f205768u,0x61742069u,0x73207468u),\n  uvec4(0x65207769u,0x6e642064u,0x6f696e67u,0x3f222020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x204e6f74u),\n  uvec4(0x68696e67u,0x20616761u,0x696e206eu,0x6f746869u),\n  uvec4(0x6e672e20u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x31323020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202022u),\n  uvec4(0x446f2020u,0x22596f75u,0x206b6e6fu,0x77206e6fu),\n  uvec4(0x7468696eu,0x673f2044u,0x6f20796fu,0x75207365u),\n  uvec4(0x65206e6fu,0x7468696eu,0x673f2044u,0x6f20796fu),\n  uvec4(0x75207265u,0x6d656d62u,0x65722020u,0x224e6f74u),\n  uvec4(0x68696e67u,0x3f222020u,0x20202049u,0x2072656du),\n  uvec4(0x656d6265u,0x72202054u,0x686f7365u,0x20617265u),\n  uvec4(0x20706561u,0x726c7320u,0x74686174u,0x20776572u),\n  uvec4(0x65206869u,0x73206579u,0x65732e20u,0x20224172u),\n  uvec4(0x6520796fu,0x7520616cu,0x6976652cu,0x206f7220u),\n  uvec4(0x6e6f743fu,0x20497320u,0x74686572u,0x65206e6fu),\n  uvec4(0x7468696eu,0x6720696eu,0x20796f75u,0x72206865u),\n  uvec4(0x61643f22u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20204275u,0x7420204fu),\n  uvec4(0x204f204fu,0x204f2074u,0x68617420u,0x5368616bu),\n  uvec4(0x65737065u,0x68657269u,0x616e2052u,0x6167202du),\n  uvec4(0x20204974u,0x27732073u,0x6f20656cu,0x6567616eu),\n  uvec4(0x74202053u,0x6f20696eu,0x74656c6cu,0x6967656eu),\n  uvec4(0x74202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202031u,0x33302020u),\n  uvec4(0x22576861u,0x74207368u,0x616c6c20u,0x4920646fu),\n  uvec4(0x206e6f77u,0x3f205768u,0x61742073u,0x68616c6cu),\n  uvec4(0x20492064u,0x6f3f2220u,0x20492073u,0x68616c6cu),\n  uvec4(0x20727573u,0x68206f75u,0x74206173u,0x20492061u),\n  uvec4(0x6d2c2061u,0x6e642077u,0x616c6b20u,0x74686520u),\n  uvec4(0x73747265u,0x65742020u,0x22576974u,0x68206d79u),\n  uvec4(0x20686169u,0x7220646fu,0x776e2c20u,0x736f2e20u),\n  uvec4(0x57686174u,0x20736861u,0x6c6c2077u,0x6520646fu),\n  uvec4(0x20746f6du,0x6f72726fu,0x773f2020u,0x22576861u),\n  uvec4(0x74207368u,0x616c6c20u,0x77652065u,0x76657220u),\n  uvec4(0x646f3f22u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202054u,0x68652068u),\n  uvec4(0x6f742077u,0x61746572u,0x20617420u,0x74656e2eu),\n  uvec4(0x2020416eu,0x64206966u,0x20697420u,0x7261696eu),\n  uvec4(0x732c2061u,0x20636c6fu,0x73656420u,0x63617220u),\n  uvec4(0x61742066u,0x6f75722eu,0x2020416eu,0x64207765u),\n  uvec4(0x20736861u,0x6c6c2070u,0x6c617920u,0x61206761u),\n  uvec4(0x6d65206fu,0x66206368u,0x6573732cu,0x20205072u),\n  uvec4(0x65737369u,0x6e67206cu,0x69646c65u,0x73732065u),\n  uvec4(0x79657320u,0x616e6420u,0x77616974u,0x696e6720u),\n  uvec4(0x666f7220u,0x61206b6eu,0x6f636b20u,0x75706f6eu),\n  uvec4(0x20746865u,0x20646f6fu,0x722e2020u,0x5768656eu),\n  uvec4(0x204c696cu,0x27732068u,0x75736261u,0x6e642067u),\n  uvec4(0x6f742064u,0x656d6f62u,0x6265642cu,0x20492073u),\n  uvec4(0x61696420u,0x2d202049u,0x20646964u,0x6e277420u),\n  uvec4(0x6d696e63u,0x65206d79u,0x20776f72u,0x64732c20u),\n  uvec4(0x49207361u,0x69642074u,0x6f206865u,0x72206d79u),\n  uvec4(0x73656c66u,0x2c202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202031u),\n  uvec4(0x34302020u,0x48555252u,0x59205550u,0x20504c45u),\n  uvec4(0x41534520u,0x49542753u,0x2054494du,0x4520204eu),\n  uvec4(0x6f772041u,0x6c626572u,0x74277320u,0x636f6d69u),\n  uvec4(0x6e672062u,0x61636b2cu,0x206d616bu,0x6520796fu),\n  uvec4(0x75727365u,0x6c662061u,0x20626974u,0x20736d61u),\n  uvec4(0x72742e20u,0x20486527u,0x6c6c2077u,0x616e7420u),\n  uvec4(0x746f206bu,0x6e6f7720u,0x77686174u,0x20796f75u),\n  uvec4(0x20646f6eu,0x65207769u,0x74682074u,0x68617420u),\n  uvec4(0x6d6f6e65u,0x79206865u,0x20676176u,0x6520796fu),\n  uvec4(0x75202054u,0x6f206765u,0x7420796fu,0x75727365u),\n  uvec4(0x6c662073u,0x6f6d6520u,0x74656574u,0x682e2048u),\n  uvec4(0x65206469u,0x642c2049u,0x20776173u,0x20746865u),\n  uvec4(0x72652e20u,0x20596f75u,0x20686176u,0x65207468u),\n  uvec4(0x656d2061u,0x6c6c206fu,0x75742c20u,0x4c696c2cu),\n  uvec4(0x20616e64u,0x20676574u,0x2061206eu,0x69636520u),\n  uvec4(0x7365742cu,0x20204865u,0x20736169u,0x642c2049u),\n  uvec4(0x20737765u,0x61722c20u,0x49206361u,0x6e277420u),\n  uvec4(0x62656172u,0x20746f20u,0x6c6f6f6bu,0x20617420u),\n  uvec4(0x796f752eu,0x2020416eu,0x64206e6fu,0x206d6f72u),\n  uvec4(0x65206361u,0x6e277420u,0x492c2049u,0x20736169u),\n  uvec4(0x642c2061u,0x6e642074u,0x68696e6bu,0x206f6620u),\n  uvec4(0x706f6f72u,0x20416c62u,0x6572742cu,0x20204865u),\n  uvec4(0x27732062u,0x65656e20u,0x696e2074u,0x68652061u),\n  uvec4(0x726d7920u,0x666f7572u,0x20796561u,0x72732c20u),\n  uvec4(0x68652077u,0x616e7473u,0x20612067u,0x6f6f6420u),\n  uvec4(0x74696d65u,0x2c202041u,0x6e642069u,0x6620796fu),\n  uvec4(0x7520646fu,0x6e277420u,0x67697665u,0x20697420u),\n  uvec4(0x68696d2cu,0x20746865u,0x72652773u,0x206f7468u),\n  uvec4(0x65727320u,0x77696c6cu,0x2c204920u,0x73616964u),\n  uvec4(0x2e20204fu,0x68206973u,0x20746865u,0x72652c20u),\n  uvec4(0x73686520u,0x73616964u,0x2e20536fu,0x6d657468u),\n  uvec4(0x696e6720u,0x6f272074u,0x6861742cu,0x20492073u),\n  uvec4(0x6169642eu,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202031u,0x35302020u),\n  uvec4(0x5468656eu,0x2049276cu,0x6c206b6eu,0x6f772077u),\n  uvec4(0x686f2074u,0x6f207468u,0x616e6b2cu,0x20736865u),\n  uvec4(0x20736169u,0x642c2061u,0x6e642067u,0x69766520u),\n  uvec4(0x6d652061u,0x20737472u,0x61696768u,0x74206c6fu),\n  uvec4(0x6f6b2e20u,0x20485552u,0x52592055u,0x5020504cu),\n  uvec4(0x45415345u,0x20495427u,0x53205449u,0x4d452020u),\n  uvec4(0x49662079u,0x6f752064u,0x6f6e2774u,0x206c696bu),\n  uvec4(0x65206974u,0x20796f75u,0x2063616eu,0x20676574u),\n  uvec4(0x206f6e20u,0x77697468u,0x2069742cu,0x20492073u),\n  uvec4(0x6169642eu,0x20204f74u,0x68657273u,0x2063616eu),\n  uvec4(0x20706963u,0x6b20616eu,0x64206368u,0x6f6f7365u),\n  uvec4(0x20696620u,0x796f7520u,0x63616e27u,0x742e2020u),\n  uvec4(0x42757420u,0x69662041u,0x6c626572u,0x74206d61u),\n  uvec4(0x6b657320u,0x6f66662cu,0x20697420u,0x776f6e27u),\n  uvec4(0x74206265u,0x20666f72u,0x206c6163u,0x6b206f66u),\n  uvec4(0x2074656cu,0x6c696e67u,0x2e202059u,0x6f75206fu),\n  uvec4(0x75676874u,0x20746f20u,0x62652061u,0x7368616du),\n  uvec4(0x65642c20u,0x49207361u,0x69642c20u,0x746f206cu),\n  uvec4(0x6f6f6b20u,0x736f2061u,0x6e746971u,0x75652e20u),\n  uvec4(0x2028416eu,0x64206865u,0x72206f6eu,0x6c792074u),\n  uvec4(0x68697274u,0x792d6f6eu,0x652e2920u,0x20492063u),\n  uvec4(0x616e2774u,0x2068656cu,0x70206974u,0x2c207368u),\n  uvec4(0x65207361u,0x69642c20u,0x70756c6cu,0x696e6720u),\n  uvec4(0x61206c6fu,0x6e672066u,0x6163652cu,0x20204974u),\n  uvec4(0x27732074u,0x68656d20u,0x70696c6cu,0x73204920u),\n  uvec4(0x746f6f6bu,0x2c20746fu,0x20627269u,0x6e672069u),\n  uvec4(0x74206f66u,0x662c2073u,0x68652073u,0x6169642eu),\n  uvec4(0x20202853u,0x68652773u,0x20686164u,0x20666976u),\n  uvec4(0x6520616cu,0x72656164u,0x792c2061u,0x6e64206eu),\n  uvec4(0x6561726cu,0x79206469u,0x6564206fu,0x6620796fu),\n  uvec4(0x756e6720u,0x47656f72u,0x67652e29u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20203136u,0x30202054u),\n  uvec4(0x68652063u,0x68656d69u,0x73742073u,0x61696420u),\n  uvec4(0x69742077u,0x6f756c64u,0x20626520u,0x616c6c20u),\n  uvec4(0x72696768u,0x742c2062u,0x75742049u,0x27766520u),\n  uvec4(0x6e657665u,0x72206265u,0x656e2074u,0x68652073u),\n  uvec4(0x616d652eu,0x2020596fu,0x75206172u,0x65206120u),\n  uvec4(0x70726f70u,0x65722066u,0x6f6f6c2cu,0x20492073u),\n  uvec4(0x6169642eu,0x20205765u,0x6c6c2c20u,0x69662041u),\n  uvec4(0x6c626572u,0x7420776fu,0x6e277420u,0x6c656176u),\n  uvec4(0x6520796fu,0x7520616cu,0x6f6e652cu,0x20746865u),\n  uvec4(0x72652069u,0x74206973u,0x2c204920u,0x73616964u),\n  uvec4(0x2c202057u,0x68617420u,0x796f7520u,0x67657420u),\n  uvec4(0x6d617272u,0x69656420u,0x666f7220u,0x69662079u),\n  uvec4(0x6f752064u,0x6f6e2774u,0x2077616eu,0x74206368u),\n  uvec4(0x696c6472u,0x656e3f20u,0x20485552u,0x52592055u),\n  uvec4(0x5020504cu,0x45415345u,0x20495427u,0x53205449u),\n  uvec4(0x4d452020u,0x57656c6cu,0x2c207468u,0x61742053u),\n  uvec4(0x756e6461u,0x7920416cu,0x62657274u,0x20776173u),\n  uvec4(0x20686f6du,0x652c2074u,0x68657920u,0x68616420u),\n  uvec4(0x6120686fu,0x74206761u,0x6d6d6f6eu,0x2c202041u),\n  uvec4(0x6e642074u,0x68657920u,0x61736b65u,0x64206d65u),\n  uvec4(0x20696e20u,0x746f2064u,0x696e6e65u,0x722c2074u),\n  uvec4(0x6f206765u,0x74207468u,0x65206265u,0x61757479u),\n  uvec4(0x206f6620u,0x69742068u,0x6f74202du,0x20204855u),\n  uvec4(0x52525920u,0x55502050u,0x4c454153u,0x45204954u),\n  uvec4(0x27532054u,0x494d4520u,0x20485552u,0x52592055u),\n  uvec4(0x5020504cu,0x45415345u,0x20495427u,0x53205449u),\n  uvec4(0x4d452020u,0x476f6f6eu,0x69676874u,0x2042696cu),\n  uvec4(0x6c2e2047u,0x6f6f6e69u,0x67687420u,0x4c6f752eu),\n  uvec4(0x20476f6fu,0x6e696768u,0x74204d61u,0x792e2047u),\n  uvec4(0x6f6f6e69u,0x6768742eu,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x31373020u),\n  uvec4(0x20546120u,0x74612e20u,0x476f6f6eu,0x69676874u),\n  uvec4(0x2e20476fu,0x6f6e6967u,0x68742e20u,0x20476f6fu),\n  uvec4(0x64206e69u,0x6768742cu,0x206c6164u,0x6965732cu),\n  uvec4(0x20676f6fu,0x64206e69u,0x6768742cu,0x20737765u),\n  uvec4(0x6574206cu,0x61646965u,0x732c2067u,0x6f6f6420u),\n  uvec4(0x6e696768u,0x742c2067u,0x6f6f6420u,0x6e696768u),\n  uvec4(0x742e2020u,0x20202020u,0x20202020u,0x4949492eu),\n  uvec4(0x20544845u,0x20464952u,0x45205345u,0x524d4f4eu),\n  uvec4(0x20205468u,0x65207269u,0x76657227u,0x73207465u),\n  uvec4(0x6e742069u,0x73206272u,0x6f6b656eu,0x3a207468u),\n  uvec4(0x65206c61u,0x73742066u,0x696e6765u,0x7273206fu),\n  uvec4(0x66206c65u,0x61662020u,0x436c7574u,0x63682061u),\n  uvec4(0x6e642073u,0x696e6b20u,0x696e746fu,0x20746865u),\n  uvec4(0x20776574u,0x2062616eu,0x6b2e2054u,0x68652077u),\n  uvec4(0x696e6420u,0x2043726fu,0x73736573u,0x20746865u),\n  uvec4(0x2062726fu,0x776e206cu,0x616e642cu,0x20756e68u),\n  uvec4(0x65617264u,0x2e205468u,0x65206e79u,0x6d706873u),\n  uvec4(0x20617265u,0x20646570u,0x61727465u,0x642e2020u),\n  uvec4(0x53776565u,0x74205468u,0x616d6573u,0x2c207275u),\n  uvec4(0x6e20736fu,0x66746c79u,0x2c207469u,0x6c6c2049u),\n  uvec4(0x20656e64u,0x206d7920u,0x736f6e67u,0x2e202054u),\n  uvec4(0x68652072u,0x69766572u,0x20626561u,0x7273206eu),\n  uvec4(0x6f20656du,0x70747920u,0x626f7474u,0x6c65732cu),\n  uvec4(0x2073616eu,0x64776963u,0x68207061u,0x70657273u),\n  uvec4(0x2c202053u,0x696c6b20u,0x68616e64u,0x6b657263u),\n  uvec4(0x68696566u,0x732c2063u,0x61726462u,0x6f617264u),\n  uvec4(0x20626f78u,0x65732c20u,0x63696761u,0x72657474u),\n  uvec4(0x6520656eu,0x64732020u,0x4f72206fu,0x74686572u),\n  uvec4(0x20746573u,0x74696d6fu,0x6e79206fu,0x66207375u),\n  uvec4(0x6d6d6572u,0x206e6967u,0x6874732eu,0x20546865u),\n  uvec4(0x206e796du,0x70687320u,0x61726520u,0x64657061u),\n  uvec4(0x72746564u,0x2e202041u,0x6e642074u,0x68656972u),\n  uvec4(0x20667269u,0x656e6473u,0x2c207468u,0x65206c6fu),\n  uvec4(0x69746572u,0x696e6720u,0x68656972u,0x73206f66u),\n  uvec4(0x20636974u,0x79206469u,0x72656374u,0x6f72733bu),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202031u),\n  uvec4(0x38302020u,0x44657061u,0x72746564u,0x2c206861u),\n  uvec4(0x7665206cu,0x65667420u,0x6e6f2061u,0x64647265u),\n  uvec4(0x73736573u,0x2e202042u,0x79207468u,0x65207761u),\n  uvec4(0x74657273u,0x206f6620u,0x4c656d61u,0x6e204920u),\n  uvec4(0x73617420u,0x646f776eu,0x20616e64u,0x20776570u),\n  uvec4(0x74202e20u,0x2e202e20u,0x20537765u,0x65742054u),\n  uvec4(0x68616d65u,0x732c2072u,0x756e2073u,0x6f66746cu),\n  uvec4(0x79207469u,0x6c6c2049u,0x20656e64u,0x206d7920u),\n  uvec4(0x736f6e67u,0x2c202053u,0x77656574u,0x20546861u),\n  uvec4(0x6d65732cu,0x2072756eu,0x20736f66u,0x746c792cu),\n  uvec4(0x20666f72u,0x20492073u,0x7065616bu,0x206e6f74u),\n  uvec4(0x206c6f75u,0x64206f72u,0x206c6f6eu,0x672e2020u),\n  uvec4(0x42757420u,0x6174206du,0x79206261u,0x636b2069u),\n  uvec4(0x6e206120u,0x636f6c64u,0x20626c61u,0x73742049u),\n  uvec4(0x20686561u,0x72202054u,0x68652072u,0x6174746cu),\n  uvec4(0x65206f66u,0x20746865u,0x20626f6eu,0x65732c20u),\n  uvec4(0x616e6420u,0x63687563u,0x6b6c6520u,0x73707265u),\n  uvec4(0x61642066u,0x726f6d20u,0x65617220u,0x746f2065u),\n  uvec4(0x61722e20u,0x20412072u,0x61742063u,0x72657074u),\n  uvec4(0x20736f66u,0x746c7920u,0x7468726fu,0x75676820u),\n  uvec4(0x74686520u,0x76656765u,0x74617469u,0x6f6e2020u),\n  uvec4(0x44726167u,0x67696e67u,0x20697473u,0x20736c69u),\n  uvec4(0x6d792062u,0x656c6c79u,0x206f6e20u,0x74686520u),\n  uvec4(0x62616e6bu,0x20205768u,0x696c6520u,0x49207761u),\n  uvec4(0x73206669u,0x7368696eu,0x6720696eu,0x20746865u),\n  uvec4(0x2064756cu,0x6c206361u,0x6e616c20u,0x204f6e20u),\n  uvec4(0x61207769u,0x6e746572u,0x20657665u,0x6e696e67u),\n  uvec4(0x20726f75u,0x6e642062u,0x6568696eu,0x64207468u),\n  uvec4(0x65206761u,0x73686f75u,0x73652020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20313930u,0x20204d75u,0x73696e67u),\n  uvec4(0x2075706fu,0x6e207468u,0x65206b69u,0x6e67206du),\n  uvec4(0x79206272u,0x6f746865u,0x72277320u,0x77726563u),\n  uvec4(0x6b202041u,0x6e64206fu,0x6e207468u,0x65206b69u),\n  uvec4(0x6e67206du,0x79206661u,0x74686572u,0x27732064u),\n  uvec4(0x65617468u,0x20626566u,0x6f726520u,0x68696d2eu),\n  uvec4(0x20205768u,0x69746520u,0x626f6469u,0x6573206eu),\n  uvec4(0x616b6564u,0x206f6e20u,0x74686520u,0x6c6f7720u),\n  uvec4(0x64616d70u,0x2067726fu,0x756e6420u,0x20416e64u),\n  uvec4(0x20626f6eu,0x65732063u,0x61737420u,0x696e2061u),\n  uvec4(0x206c6974u,0x746c6520u,0x6c6f7720u,0x64727920u),\n  uvec4(0x67617272u,0x65742c20u,0x20526174u,0x746c6564u),\n  uvec4(0x20627920u,0x74686520u,0x72617427u,0x7320666fu),\n  uvec4(0x6f74206fu,0x6e6c792cu,0x20796561u,0x7220746fu),\n  uvec4(0x20796561u,0x722e2020u,0x42757420u,0x6174206du),\n  uvec4(0x79206261u,0x636b2066u,0x726f6d20u,0x74696d65u),\n  uvec4(0x20746f20u,0x74696d65u,0x20492068u,0x65617220u),\n  uvec4(0x20546865u,0x20736f75u,0x6e64206fu,0x6620686fu),\n  uvec4(0x726e7320u,0x616e6420u,0x6d6f746fu,0x72732c20u),\n  uvec4(0x77686963u,0x68207368u,0x616c6c20u,0x6272696eu),\n  uvec4(0x67202053u,0x7765656eu,0x65792074u,0x6f204d72u),\n  uvec4(0x732e2050u,0x6f727465u,0x7220696eu,0x20746865u),\n  uvec4(0x20737072u,0x696e672eu,0x20204f20u,0x74686520u),\n  uvec4(0x6d6f6f6eu,0x2073686fu,0x6e652062u,0x72696768u),\n  uvec4(0x74206f6eu,0x204d7273u,0x2e20506fu,0x72746572u),\n  uvec4(0x2020416eu,0x64206f6eu,0x20686572u,0x20646175u),\n  uvec4(0x67687465u,0x72202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20203230u,0x30202054u),\n  uvec4(0x68657920u,0x77617368u,0x20746865u,0x69722066u),\n  uvec4(0x65657420u,0x696e2073u,0x6f646120u,0x77617465u),\n  uvec4(0x72202045u,0x74204f20u,0x63657320u,0x766f6978u),\n  uvec4(0x20642765u,0x6e66616eu,0x74732c20u,0x6368616eu),\n  uvec4(0x74616e74u,0x2064616eu,0x73206c61u,0x20636f75u),\n  uvec4(0x706f6c65u,0x21202054u,0x77697420u,0x74776974u),\n  uvec4(0x20747769u,0x7420204au,0x7567206au,0x7567206au),\n  uvec4(0x7567206au,0x7567206au,0x7567206au,0x75672020u),\n  uvec4(0x536f2072u,0x7564656cu,0x7920666fu,0x72632764u),\n  uvec4(0x2e202054u,0x65726575u,0x2020556eu,0x7265616cu),\n  uvec4(0x20436974u,0x79202055u,0x6e646572u,0x20746865u),\n  uvec4(0x2062726fu,0x776e2066u,0x6f67206fu,0x66206120u),\n  uvec4(0x77696e74u,0x6572206eu,0x6f6f6e20u,0x204d722eu),\n  uvec4(0x20457567u,0x656e6964u,0x65732c20u,0x74686520u),\n  uvec4(0x536d7972u,0x6e61206du,0x65726368u,0x616e7420u),\n  uvec4(0x20556e73u,0x68617665u,0x6e2c2077u,0x69746820u),\n  uvec4(0x6120706fu,0x636b6574u,0x2066756cu,0x6c206f66u),\n  uvec4(0x20637572u,0x72616e74u,0x73202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20323130u,0x2020432eu),\n  uvec4(0x692e662eu,0x204c6f6eu,0x646f6e3au,0x20646f63u),\n  uvec4(0x756d656eu,0x74732061u,0x74207369u,0x6768742cu),\n  uvec4(0x20204173u,0x6b656420u,0x6d652069u,0x6e206465u),\n  uvec4(0x6d6f7469u,0x63204672u,0x656e6368u,0x2020546fu),\n  uvec4(0x206c756eu,0x6368656fu,0x6e206174u,0x20746865u),\n  uvec4(0x2043616eu,0x6e6f6e20u,0x53747265u,0x65742048u),\n  uvec4(0x6f74656cu,0x2020466fu,0x6c6c6f77u,0x65642062u),\n  uvec4(0x79206120u,0x7765656bu,0x656e6420u,0x61742074u),\n  uvec4(0x6865204du,0x6574726fu,0x706f6c65u,0x2e202041u),\n  uvec4(0x74207468u,0x65207669u,0x6f6c6574u,0x20686f75u),\n  uvec4(0x722c2077u,0x68656e20u,0x74686520u,0x65796573u),\n  uvec4(0x20616e64u,0x20626163u,0x6b202054u,0x75726e20u),\n  uvec4(0x75707761u,0x72642066u,0x726f6d20u,0x74686520u),\n  uvec4(0x6465736bu,0x2c207768u,0x656e2074u,0x68652068u),\n  uvec4(0x756d616eu,0x20656e67u,0x696e6520u,0x77616974u),\n  uvec4(0x7320204cu,0x696b6520u,0x61207461u,0x78692074u),\n  uvec4(0x68726f62u,0x62696e67u,0x20776169u,0x74696e67u),\n  uvec4(0x2c202049u,0x20546972u,0x65736961u,0x732c2074u),\n  uvec4(0x686f7567u,0x6820626cu,0x696e642cu,0x20746872u),\n  uvec4(0x6f626269u,0x6e672062u,0x65747765u,0x656e2074u),\n  uvec4(0x776f206cu,0x69766573u,0x2c20204fu,0x6c64206du),\n  uvec4(0x616e2077u,0x69746820u,0x7772696eu,0x6b6c6564u),\n  uvec4(0x2066656du,0x616c6520u,0x62726561u,0x7374732cu),\n  uvec4(0x2063616eu,0x20736565u,0x20204174u,0x20746865u),\n  uvec4(0x2076696fu,0x6c657420u,0x686f7572u,0x2c207468u),\n  uvec4(0x65206576u,0x656e696eu,0x6720686fu,0x75722074u),\n  uvec4(0x68617420u,0x73747269u,0x76657320u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20203232u,0x30202048u,0x6f6d6577u,0x6172642cu),\n  uvec4(0x20616e64u,0x20627269u,0x6e677320u,0x74686520u),\n  uvec4(0x7361696cu,0x6f722068u,0x6f6d6520u,0x66726f6du),\n  uvec4(0x20736561u,0x2c202054u,0x68652074u,0x79706973u),\n  uvec4(0x7420686fu,0x6d652061u,0x74207465u,0x6174696du),\n  uvec4(0x652c2063u,0x6c656172u,0x73206865u,0x72206272u),\n  uvec4(0x65616b66u,0x6173742cu,0x206c6967u,0x68747320u),\n  uvec4(0x20486572u,0x2073746fu,0x76652c20u,0x616e6420u),\n  uvec4(0x6c617973u,0x206f7574u,0x20666f6fu,0x6420696eu),\n  uvec4(0x2074696eu,0x732e2020u,0x4f757420u,0x6f662074u),\n  uvec4(0x68652077u,0x696e646fu,0x77207065u,0x72696c6fu),\n  uvec4(0x75736c79u,0x20737072u,0x65616420u,0x20486572u),\n  uvec4(0x20647279u,0x696e6720u,0x636f6d62u,0x696e6174u),\n  uvec4(0x696f6e73u,0x20746f75u,0x63686564u,0x20627920u),\n  uvec4(0x74686520u,0x73756e27u,0x73206c61u,0x73742072u),\n  uvec4(0x6179732cu,0x20204f6eu,0x20746865u,0x20646976u),\n  uvec4(0x616e2061u,0x72652070u,0x696c6564u,0x20286174u),\n  uvec4(0x206e6967u,0x68742068u,0x65722062u,0x65642920u),\n  uvec4(0x2053746fu,0x636b696eu,0x67732c20u,0x736c6970u),\n  uvec4(0x70657273u,0x2c206361u,0x6d69736fu,0x6c65732cu),\n  uvec4(0x20616e64u,0x20737461u,0x79732e20u,0x20492054u),\n  uvec4(0x69726573u,0x6961732cu,0x206f6c64u,0x206d616eu),\n  uvec4(0x20776974u,0x68207772u,0x696e6b6cu,0x65642064u),\n  uvec4(0x75677320u,0x20506572u,0x63656976u,0x65642074u),\n  uvec4(0x68652073u,0x63656e65u,0x2c20616eu,0x6420666fu),\n  uvec4(0x7265746fu,0x6c642074u,0x68652072u,0x65737420u),\n  uvec4(0x2d202049u,0x20746f6fu,0x20617761u,0x69746564u),\n  uvec4(0x20746865u,0x20657870u,0x65637465u,0x64206775u),\n  uvec4(0x6573742eu,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202032u,0x33302020u),\n  uvec4(0x48652c20u,0x74686520u,0x796f756eu,0x67206d61u),\n  uvec4(0x6e206361u,0x7262756eu,0x63756c61u,0x722c2061u),\n  uvec4(0x72726976u,0x65732c20u,0x20412073u,0x6d616c6cu),\n  uvec4(0x20686f75u,0x73652061u,0x67656e74u,0x27732063u),\n  uvec4(0x6c65726bu,0x2c207769u,0x7468206fu,0x6e652062u),\n  uvec4(0x6f6c6420u,0x73746172u,0x652c2020u,0x4f6e6520u),\n  uvec4(0x6f662074u,0x6865206cu,0x6f77206fu,0x6e207768u),\n  uvec4(0x6f6d2061u,0x73737572u,0x616e6365u,0x20736974u),\n  uvec4(0x73202041u,0x73206120u,0x73696c6bu,0x20686174u),\n  uvec4(0x206f6e20u,0x61204272u,0x6164666fu,0x7264206du),\n  uvec4(0x696c6c69u,0x6f6e6169u,0x72652e20u,0x20546865u),\n  uvec4(0x2074696du,0x65206973u,0x206e6f77u,0x2070726fu),\n  uvec4(0x70697469u,0x6f75732cu,0x20617320u,0x68652067u),\n  uvec4(0x75657373u,0x65732c20u,0x20546865u,0x206d6561u),\n  uvec4(0x6c206973u,0x20656e64u,0x65642c20u,0x73686520u),\n  uvec4(0x69732062u,0x6f726564u,0x20616e64u,0x20746972u),\n  uvec4(0x65642c20u,0x20456e64u,0x6561766fu,0x75727320u),\n  uvec4(0x746f2065u,0x6e676167u,0x65206865u,0x7220696eu),\n  uvec4(0x20636172u,0x65737365u,0x73202057u,0x68696368u),\n  uvec4(0x20737469u,0x6c6c2061u,0x72652075u,0x6e726570u),\n  uvec4(0x726f7665u,0x642c2069u,0x6620756eu,0x64657369u),\n  uvec4(0x7265642eu,0x2020466cu,0x75736865u,0x6420616eu),\n  uvec4(0x64206465u,0x63696465u,0x642c2068u,0x65206173u),\n  uvec4(0x7361756cu,0x74732061u,0x74206f6eu,0x63653b20u),\n  uvec4(0x20457870u,0x6c6f7269u,0x6e672068u,0x616e6473u),\n  uvec4(0x20656e63u,0x6f756e74u,0x6572206eu,0x6f206465u),\n  uvec4(0x66656e63u,0x653b2020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20323430u,0x20204869u),\n  uvec4(0x73207661u,0x6e697479u,0x20726571u,0x75697265u),\n  uvec4(0x73206e6fu,0x20726573u,0x706f6e73u,0x652c2020u),\n  uvec4(0x416e6420u,0x6d616b65u,0x73206120u,0x77656c63u),\n  uvec4(0x6f6d6520u,0x6f662069u,0x6e646966u,0x66657265u),\n  uvec4(0x6e63652eu,0x20202841u,0x6e642049u,0x20546972u),\n  uvec4(0x65736961u,0x73206861u,0x76652066u,0x6f726573u),\n  uvec4(0x75666665u,0x72656420u,0x616c6c20u,0x20456e61u),\n  uvec4(0x63746564u,0x206f6e20u,0x74686973u,0x2073616du),\n  uvec4(0x65206469u,0x76616e20u,0x6f722062u,0x65643b20u),\n  uvec4(0x20492077u,0x686f2068u,0x61766520u,0x73617420u),\n  uvec4(0x62792054u,0x68656265u,0x73206265u,0x6c6f7720u),\n  uvec4(0x74686520u,0x77616c6cu,0x2020416eu,0x64207761u),\n  uvec4(0x6c6b6564u,0x20616d6fu,0x6e672074u,0x6865206cu),\n  uvec4(0x6f776573u,0x74206f66u,0x20746865u,0x20646561u),\n  uvec4(0x642e2920u,0x20426573u,0x746f7773u,0x206f6e65u),\n  uvec4(0x2066696eu,0x616c2070u,0x6174726fu,0x6e697369u),\n  uvec4(0x6e67206bu,0x6973732cu,0x2020416eu,0x64206772u),\n  uvec4(0x6f706573u,0x20686973u,0x20776179u,0x2c206669u),\n  uvec4(0x6e64696eu,0x67207468u,0x65207374u,0x61697273u),\n  uvec4(0x20756e6cu,0x6974202eu,0x202e202eu,0x20205368u),\n  uvec4(0x65207475u,0x726e7320u,0x616e6420u,0x6c6f6f6bu),\n  uvec4(0x73206120u,0x6d6f6d65u,0x6e742069u,0x6e207468u),\n  uvec4(0x6520676cu,0x6173732cu,0x20204861u,0x72646c79u),\n  uvec4(0x20617761u,0x7265206fu,0x66206865u,0x72206465u),\n  uvec4(0x70617274u,0x6564206cu,0x6f766572u,0x3b202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20203235u,0x30202048u,0x65722062u,0x7261696eu),\n  uvec4(0x20616c6cu,0x6f777320u,0x6f6e6520u,0x68616c66u),\n  uvec4(0x2d666f72u,0x6d656420u,0x74686f75u,0x67687420u),\n  uvec4(0x746f2070u,0x6173733au,0x20202257u,0x656c6c20u),\n  uvec4(0x6e6f7720u,0x74686174u,0x27732064u,0x6f6e653au),\n  uvec4(0x20616e64u,0x2049276du,0x20676c61u,0x64206974u),\n  uvec4(0x2773206fu,0x7665722eu,0x22202057u,0x68656e20u),\n  uvec4(0x6c6f7665u,0x6c792077u,0x6f6d616eu,0x2073746fu),\n  uvec4(0x6f707320u,0x746f2066u,0x6f6c6c79u,0x20616e64u),\n  uvec4(0x20205061u,0x63657320u,0x61626f75u,0x74206865u),\n  uvec4(0x7220726fu,0x6f6d2061u,0x6761696eu,0x2c20616cu),\n  uvec4(0x6f6e652cu,0x20205368u,0x6520736du,0x6f6f7468u),\n  uvec4(0x73206865u,0x72206861u,0x69722077u,0x69746820u),\n  uvec4(0x6175746fu,0x6d617469u,0x63206861u,0x6e642c20u),\n  uvec4(0x20416e64u,0x20707574u,0x73206120u,0x7265636fu),\n  uvec4(0x7264206fu,0x6e207468u,0x65206772u,0x616d6f70u),\n  uvec4(0x686f6e65u,0x2e202022u,0x54686973u,0x206d7573u),\n  uvec4(0x69632063u,0x72657074u,0x20627920u,0x6d652075u),\n  uvec4(0x706f6e20u,0x74686520u,0x77617465u,0x72732220u),\n  uvec4(0x20416e64u,0x20616c6fu,0x6e672074u,0x68652053u),\n  uvec4(0x7472616eu,0x642c2075u,0x70205175u,0x65656e20u),\n  uvec4(0x56696374u,0x6f726961u,0x20537472u,0x6565742eu),\n  uvec4(0x20204f20u,0x43697479u,0x20636974u,0x792c2049u),\n  uvec4(0x2063616eu,0x20736f6du,0x6574696du,0x65732068u),\n  uvec4(0x65617220u,0x20426573u,0x69646520u,0x61207075u),\n  uvec4(0x626c6963u,0x20626172u,0x20696e20u,0x4c6f7765u),\n  uvec4(0x72205468u,0x616d6573u,0x20537472u,0x6565742cu),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20323630u),\n  uvec4(0x20205468u,0x6520706cu,0x65617361u,0x6e742077u),\n  uvec4(0x68696e69u,0x6e67206fu,0x66206120u,0x6d616e64u),\n  uvec4(0x6f6c696eu,0x65202041u,0x6e642061u,0x20636c61u),\n  uvec4(0x74746572u,0x20616e64u,0x20612063u,0x68617474u),\n  uvec4(0x65722066u,0x726f6d20u,0x77697468u,0x696e2020u),\n  uvec4(0x57686572u,0x65206669u,0x73686d65u,0x6e206c6fu),\n  uvec4(0x756e6765u,0x20617420u,0x6e6f6f6eu,0x3a207768u),\n  uvec4(0x65726520u,0x74686520u,0x77616c6cu,0x7320204fu),\n  uvec4(0x66204d61u,0x676e7573u,0x204d6172u,0x74797220u),\n  uvec4(0x686f6c64u,0x2020496eu,0x6578706cu,0x69636162u),\n  uvec4(0x6c652073u,0x706c656eu,0x646f7572u,0x206f6620u),\n  uvec4(0x496f6e69u,0x616e2077u,0x68697465u,0x20616e64u),\n  uvec4(0x20676f6cu,0x642e2020u,0x20202020u,0x20546865u),\n  uvec4(0x20726976u,0x65722073u,0x77656174u,0x73202020u),\n  uvec4(0x20202020u,0x4f696c20u,0x616e6420u,0x74617220u),\n  uvec4(0x20202020u,0x20205468u,0x65206261u,0x72676573u),\n  uvec4(0x20647269u,0x66742020u,0x20202020u,0x20576974u),\n  uvec4(0x68207468u,0x65207475u,0x726e696eu,0x67207469u),\n  uvec4(0x64652020u,0x20202020u,0x20526564u,0x20736169u),\n  uvec4(0x6c732020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x32373020u),\n  uvec4(0x20202020u,0x20205769u,0x64652020u,0x20202020u),\n  uvec4(0x20546f20u,0x6c656577u,0x6172642cu,0x20737769u),\n  uvec4(0x6e67206fu,0x6e207468u,0x65206865u,0x61767920u),\n  uvec4(0x73706172u,0x2e202020u,0x20202020u,0x54686520u),\n  uvec4(0x62617267u,0x65732077u,0x61736820u,0x20202020u),\n  uvec4(0x20204472u,0x69667469u,0x6e67206cu,0x6f677320u),\n  uvec4(0x20202020u,0x2020446fu,0x776e2047u,0x7265656eu),\n  uvec4(0x77696368u,0x20726561u,0x63682020u,0x20202020u),\n  uvec4(0x20506173u,0x74207468u,0x65204973u,0x6c65206fu),\n  uvec4(0x6620446fu,0x67732e20u,0x20202020u,0x20202020u),\n  uvec4(0x20202057u,0x6569616cu,0x616c6120u,0x6c656961u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x57616c6cu),\n  uvec4(0x616c6120u,0x6c656961u,0x6c616c61u,0x20202020u),\n  uvec4(0x20202045u,0x6c697a61u,0x62657468u,0x20616e64u),\n  uvec4(0x204c6569u,0x63657374u,0x65722020u,0x20202020u),\n  uvec4(0x20426561u,0x74696e67u,0x206f6172u,0x73202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x32383020u,0x20202020u,0x20205468u),\n  uvec4(0x65207374u,0x65726e20u,0x77617320u,0x666f726du),\n  uvec4(0x65642020u,0x20202020u,0x20412067u,0x696c6465u),\n  uvec4(0x64207368u,0x656c6c20u,0x20202020u,0x20205265u),\n  uvec4(0x6420616eu,0x6420676fu,0x6c642020u,0x20202020u),\n  uvec4(0x20546865u,0x20627269u,0x736b2073u,0x77656c6cu),\n  uvec4(0x20202020u,0x20202052u,0x6970706cu,0x65642062u),\n  uvec4(0x6f746820u,0x73686f72u,0x65732020u,0x20202020u),\n  uvec4(0x20536f75u,0x74687765u,0x73742077u,0x696e6420u),\n  uvec4(0x20202020u,0x20204361u,0x72726965u,0x6420646fu),\n  uvec4(0x776e2073u,0x74726561u,0x6d202020u,0x20202020u),\n  uvec4(0x54686520u,0x7065616cu,0x206f6620u,0x62656c6cu),\n  uvec4(0x73202020u,0x20202020u,0x57686974u,0x6520746fu),\n  uvec4(0x77657273u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x57656961u,0x6c616c61u,0x206c6569u,0x61202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20203239u),\n  uvec4(0x30202020u,0x20202020u,0x20202020u,0x2057616cu),\n  uvec4(0x6c616c61u,0x206c6569u,0x616c616cu,0x61202022u),\n  uvec4(0x5472616du,0x7320616eu,0x64206475u,0x73747920u),\n  uvec4(0x74726565u,0x732e2020u,0x48696768u,0x62757279u),\n  uvec4(0x20626f72u,0x65206d65u,0x2e205269u,0x63686d6fu),\n  uvec4(0x6e642061u,0x6e64204bu,0x65772020u,0x556e6469u),\n  uvec4(0x64206d65u,0x2e204279u,0x20526963u,0x686d6f6eu),\n  uvec4(0x64204920u,0x72616973u,0x6564206du,0x79206b6eu),\n  uvec4(0x65657320u,0x20537570u,0x696e6520u,0x6f6e2074u),\n  uvec4(0x68652066u,0x6c6f6f72u,0x206f6620u,0x61206e61u),\n  uvec4(0x72726f77u,0x2063616eu,0x6f652e22u,0x2020224du),\n  uvec4(0x79206665u,0x65742061u,0x72652061u,0x74204d6fu),\n  uvec4(0x6f726761u,0x74652c20u,0x616e6420u,0x6d792068u),\n  uvec4(0x65617274u,0x2020556eu,0x64657220u,0x6d792066u),\n  uvec4(0x6565742eu,0x20416674u,0x65722074u,0x68652065u),\n  uvec4(0x76656e74u,0x20204865u,0x20776570u,0x742e2048u),\n  uvec4(0x65207072u,0x6f6d6973u,0x65642027u,0x61206e65u),\n  uvec4(0x77207374u,0x61727427u,0x2e202049u,0x206d6164u),\n  uvec4(0x65206e6fu,0x20636f6du,0x6d656e74u,0x2e205768u),\n  uvec4(0x61742073u,0x686f756cu,0x64204920u,0x72657365u),\n  uvec4(0x6e743f22u,0x2020224fu,0x6e204d61u,0x72676174u),\n  uvec4(0x65205361u,0x6e64732eu,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20203330u),\n  uvec4(0x30202049u,0x2063616eu,0x20636f6eu,0x6e656374u),\n  uvec4(0x20204e6fu,0x7468696eu,0x67207769u,0x7468206eu),\n  uvec4(0x6f746869u,0x6e672e20u,0x20546865u,0x2062726fu),\n  uvec4(0x6b656e20u,0x66696e67u,0x65726e61u,0x696c7320u),\n  uvec4(0x6f662064u,0x69727479u,0x2068616eu,0x64732e20u),\n  uvec4(0x204d7920u,0x70656f70u,0x6c652068u,0x756d626cu),\n  uvec4(0x65207065u,0x6f706c65u,0x2077686fu,0x20657870u),\n  uvec4(0x65637420u,0x204e6f74u,0x68696e67u,0x2e222020u),\n  uvec4(0x20202020u,0x206c6120u,0x6c612020u,0x546f2043u),\n  uvec4(0x61727468u,0x61676520u,0x7468656eu,0x20492063u),\n  uvec4(0x616d6520u,0x20427572u,0x6e696e67u,0x20627572u),\n  uvec4(0x6e696e67u,0x20627572u,0x6e696e67u,0x20627572u),\n  uvec4(0x6e696e67u,0x20204f20u,0x4c6f7264u,0x2054686fu),\n  uvec4(0x7520706cu,0x75636b65u,0x7374206du,0x65206f75u),\n  uvec4(0x7420204fu,0x204c6f72u,0x64205468u,0x6f752070u),\n  uvec4(0x6c75636bu,0x65737420u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202033u,0x31302020u),\n  uvec4(0x6275726eu,0x696e6720u,0x20202020u,0x20202020u),\n  uvec4(0x2049562eu,0x20444541u,0x54482042u,0x59205741u),\n  uvec4(0x54455220u,0x2050686cu,0x65626173u,0x20746865u),\n  uvec4(0x2050686fu,0x656e6963u,0x69616e2cu,0x20612066u),\n  uvec4(0x6f72746eu,0x69676874u,0x20646561u,0x642c2020u),\n  uvec4(0x466f7267u,0x6f742074u,0x68652063u,0x7279206fu),\n  uvec4(0x66206775u,0x6c6c732cu,0x20616e64u,0x20746865u),\n  uvec4(0x20646565u,0x70207365u,0x61207377u,0x656c6c20u),\n  uvec4(0x20416e64u,0x20746865u,0x2070726fu,0x66697420u),\n  uvec4(0x616e6420u,0x6c6f7373u,0x2e202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x41206375u,0x7272656eu,0x7420756eu),\n  uvec4(0x64657220u,0x73656120u,0x20506963u,0x6b656420u),\n  uvec4(0x68697320u,0x626f6e65u,0x7320696eu,0x20776869u),\n  uvec4(0x73706572u,0x732e2041u,0x73206865u,0x20726f73u),\n  uvec4(0x6520616eu,0x64206665u,0x6c6c2020u,0x48652070u),\n  uvec4(0x61737365u,0x64207468u,0x65207374u,0x61676573u),\n  uvec4(0x206f6620u,0x68697320u,0x61676520u,0x616e6420u),\n  uvec4(0x796f7574u,0x68202045u,0x6e746572u,0x696e6720u),\n  uvec4(0x74686520u,0x77686972u,0x6c706f6fu,0x6c2e2020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202047u,0x656e7469u,0x6c65206fu),\n  uvec4(0x72204a65u,0x7720204fu,0x20796f75u,0x2077686fu),\n  uvec4(0x20747572u,0x6e207468u,0x65207768u,0x65656c20u),\n  uvec4(0x616e6420u,0x6c6f6f6bu,0x20746f20u,0x77696e64u),\n  uvec4(0x77617264u,0x2c202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202033u),\n  uvec4(0x32302020u,0x436f6e73u,0x69646572u,0x2050686cu),\n  uvec4(0x65626173u,0x2c207768u,0x6f207761u,0x73206f6eu),\n  uvec4(0x63652068u,0x616e6473u,0x6f6d6520u,0x616e6420u),\n  uvec4(0x74616c6cu,0x20617320u,0x796f752eu,0x20202020u),\n  uvec4(0x20202020u,0x2020562eu,0x20574841u,0x54205448u),\n  uvec4(0x45205448u,0x554e4445u,0x52205341u,0x49442020u),\n  uvec4(0x41667465u,0x72207468u,0x6520746fu,0x7263686cu),\n  uvec4(0x69676874u,0x20726564u,0x206f6e20u,0x73776561u),\n  uvec4(0x74792066u,0x61636573u,0x20204166u,0x74657220u),\n  uvec4(0x74686520u,0x66726f73u,0x74792073u,0x696c656eu),\n  uvec4(0x63652069u,0x6e207468u,0x65206761u,0x7264656eu),\n  uvec4(0x73202041u,0x66746572u,0x20746865u,0x2061676fu),\n  uvec4(0x6e792069u,0x6e207374u,0x6f6e7920u,0x706c6163u),\n  uvec4(0x65732020u,0x54686520u,0x73686f75u,0x74696e67u),\n  uvec4(0x20616e64u,0x20746865u,0x20637279u,0x696e6720u),\n  uvec4(0x20507269u,0x736f6e20u,0x616e6420u,0x70616c61u),\n  uvec4(0x63652061u,0x6e642072u,0x65766572u,0x62657261u),\n  uvec4(0x74696f6eu,0x20204f66u,0x20746875u,0x6e646572u),\n  uvec4(0x206f6620u,0x73707269u,0x6e67206fu,0x76657220u),\n  uvec4(0x64697374u,0x616e7420u,0x6d6f756eu,0x7461696eu),\n  uvec4(0x73202048u,0x65207768u,0x6f207761u,0x73206c69u),\n  uvec4(0x76696e67u,0x20697320u,0x6e6f7720u,0x64656164u),\n  uvec4(0x20205765u,0x2077686fu,0x20776572u,0x65206c69u),\n  uvec4(0x76696e67u,0x20617265u,0x206e6f77u,0x20647969u),\n  uvec4(0x6e672020u,0x57697468u,0x2061206cu,0x6974746cu),\n  uvec4(0x65207061u,0x7469656eu,0x63652020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x33333020u),\n  uvec4(0x20486572u,0x65206973u,0x206e6f20u,0x77617465u),\n  uvec4(0x72206275u,0x74206f6eu,0x6c792072u,0x6f636b20u),\n  uvec4(0x20526f63u,0x6b20616eu,0x64206e6fu,0x20776174u),\n  uvec4(0x65722061u,0x6e642074u,0x68652073u,0x616e6479u),\n  uvec4(0x20726f61u,0x64202054u,0x68652072u,0x6f616420u),\n  uvec4(0x77696e64u,0x696e6720u,0x61626f76u,0x6520616du),\n  uvec4(0x6f6e6720u,0x74686520u,0x6d6f756eu,0x7461696eu),\n  uvec4(0x73202057u,0x68696368u,0x20617265u,0x206d6f75u),\n  uvec4(0x6e746169u,0x6e73206fu,0x6620726fu,0x636b2077u),\n  uvec4(0x6974686fu,0x75742077u,0x61746572u,0x20204966u),\n  uvec4(0x20746865u,0x72652077u,0x65726520u,0x77617465u),\n  uvec4(0x72207765u,0x2073686fu,0x756c6420u,0x73746f70u),\n  uvec4(0x20616e64u,0x20647269u,0x6e6b2020u,0x416d6f6eu),\n  uvec4(0x67737420u,0x74686520u,0x726f636bu,0x206f6e65u),\n  uvec4(0x2063616eu,0x6e6f7420u,0x73746f70u,0x206f7220u),\n  uvec4(0x7468696eu,0x6b202053u,0x77656174u,0x20697320u),\n  uvec4(0x64727920u,0x616e6420u,0x66656574u,0x20617265u),\n  uvec4(0x20696e20u,0x74686520u,0x73616e64u,0x20204966u),\n  uvec4(0x20746865u,0x72652077u,0x65726520u,0x6f6e6c79u),\n  uvec4(0x20776174u,0x65722061u,0x6d6f6e67u,0x73742074u),\n  uvec4(0x68652072u,0x6f636b20u,0x20446561u,0x64206d6fu),\n  uvec4(0x756e7461u,0x696e206du,0x6f757468u,0x206f6620u),\n  uvec4(0x63617269u,0x6f757320u,0x74656574u,0x68207468u),\n  uvec4(0x61742063u,0x616e6e6fu,0x74207370u,0x69742020u),\n  uvec4(0x48657265u,0x206f6e65u,0x2063616eu,0x206e6569u),\n  uvec4(0x74686572u,0x20737461u,0x6e64206eu,0x6f72206cu),\n  uvec4(0x6965206eu,0x6f722073u,0x69742020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x33343020u,0x20546865u),\n  uvec4(0x72652069u,0x73206e6fu,0x74206576u,0x656e2073u),\n  uvec4(0x696c656eu,0x63652069u,0x6e207468u,0x65206d6fu),\n  uvec4(0x756e7461u,0x696e7320u,0x20427574u,0x20647279u),\n  uvec4(0x20737465u,0x72696c65u,0x20746875u,0x6e646572u),\n  uvec4(0x20776974u,0x686f7574u,0x20726169u,0x6e202054u),\n  uvec4(0x68657265u,0x20697320u,0x6e6f7420u,0x6576656eu),\n  uvec4(0x20736f6cu,0x69747564u,0x6520696eu,0x20746865u),\n  uvec4(0x206d6f75u,0x6e746169u,0x6e732020u,0x42757420u),\n  uvec4(0x72656420u,0x73756c6cu,0x656e2066u,0x61636573u),\n  uvec4(0x20736e65u,0x65722061u,0x6e642073u,0x6e61726cu),\n  uvec4(0x20204672u,0x6f6d2064u,0x6f6f7273u,0x206f6620u),\n  uvec4(0x6d756463u,0x7261636bu,0x65642068u,0x6f757365u),\n  uvec4(0x73202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x49662074u),\n  uvec4(0x68657265u,0x20776572u,0x65207761u,0x74657220u),\n  uvec4(0x20416e64u,0x206e6f20u,0x726f636bu,0x20204966u),\n  uvec4(0x20746865u,0x72652077u,0x65726520u,0x726f636bu),\n  uvec4(0x2020416eu,0x6420616cu,0x736f2077u,0x61746572u),\n  uvec4(0x2020416eu,0x64207761u,0x74657220u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20203335u,0x30202041u),\n  uvec4(0x20737072u,0x696e6720u,0x20412070u,0x6f6f6c20u),\n  uvec4(0x616d6f6eu,0x67207468u,0x6520726fu,0x636b2020u),\n  uvec4(0x49662074u,0x68657265u,0x20776572u,0x65207468u),\n  uvec4(0x6520736fu,0x756e6420u,0x6f662077u,0x61746572u),\n  uvec4(0x206f6e6cu,0x7920204eu,0x6f742074u,0x68652063u),\n  uvec4(0x69636164u,0x61202041u,0x6e642064u,0x72792067u),\n  uvec4(0x72617373u,0x2073696eu,0x67696e67u,0x20204275u),\n  uvec4(0x7420736fu,0x756e6420u,0x6f662077u,0x61746572u),\n  uvec4(0x206f7665u,0x72206120u,0x726f636bu,0x20205768u),\n  uvec4(0x65726520u,0x74686520u,0x6865726du,0x69742d74u),\n  uvec4(0x68727573u,0x68207369u,0x6e677320u,0x696e2074u),\n  uvec4(0x68652070u,0x696e6520u,0x74726565u,0x73202044u),\n  uvec4(0x72697020u,0x64726f70u,0x20647269u,0x70206472u),\n  uvec4(0x6f702064u,0x726f7020u,0x64726f70u,0x2064726fu),\n  uvec4(0x70202042u,0x75742074u,0x68657265u,0x20697320u),\n  uvec4(0x6e6f2077u,0x61746572u,0x20205768u,0x6f206973u),\n  uvec4(0x20746865u,0x20746869u,0x72642077u,0x686f2077u),\n  uvec4(0x616c6b73u,0x20616c77u,0x61797320u,0x62657369u),\n  uvec4(0x64652079u,0x6f753f20u,0x20576865u,0x6e204920u),\n  uvec4(0x636f756eu,0x742c2074u,0x68657265u,0x20617265u),\n  uvec4(0x206f6e6cu,0x7920796fu,0x7520616eu,0x64204920u),\n  uvec4(0x746f6765u,0x74686572u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20333630u,0x20204275u,0x74207768u,0x656e2049u),\n  uvec4(0x206c6f6fu,0x6b206168u,0x65616420u,0x75702074u),\n  uvec4(0x68652077u,0x68697465u,0x20726f61u,0x64202054u),\n  uvec4(0x68657265u,0x20697320u,0x616c7761u,0x79732061u),\n  uvec4(0x6e6f7468u,0x6572206fu,0x6e652077u,0x616c6b69u),\n  uvec4(0x6e672062u,0x65736964u,0x6520796fu,0x75202047u),\n  uvec4(0x6c696469u,0x6e672077u,0x72617074u,0x20696e20u),\n  uvec4(0x61206272u,0x6f776e20u,0x6d616e74u,0x6c652c20u),\n  uvec4(0x686f6f64u,0x65642020u,0x4920646fu,0x206e6f74u),\n  uvec4(0x206b6e6fu,0x77207768u,0x65746865u,0x72206120u),\n  uvec4(0x6d616e20u,0x6f722061u,0x20776f6du,0x616e2020u),\n  uvec4(0x2d204275u,0x74207768u,0x6f206973u,0x20746861u),\n  uvec4(0x74206f6eu,0x20746865u,0x206f7468u,0x65722073u),\n  uvec4(0x69646520u,0x6f662079u,0x6f753f20u,0x20576861u),\n  uvec4(0x74206973u,0x20746861u,0x7420736fu,0x756e6420u),\n  uvec4(0x68696768u,0x20696e20u,0x74686520u,0x61697220u),\n  uvec4(0x204d7572u,0x6d757220u,0x6f66206du,0x61746572u),\n  uvec4(0x6e616c20u,0x6c616d65u,0x6e746174u,0x696f6e20u),\n  uvec4(0x2057686fu,0x20617265u,0x2074686fu,0x73652068u),\n  uvec4(0x6f6f6465u,0x6420686fu,0x72646573u,0x20737761u),\n  uvec4(0x726d696eu,0x6720204fu,0x76657220u,0x656e646cu),\n  uvec4(0x65737320u,0x706c6169u,0x6e732c20u,0x7374756du),\n  uvec4(0x626c696eu,0x6720696eu,0x20637261u,0x636b6564u),\n  uvec4(0x20656172u,0x74682020u,0x52696e67u,0x65642062u),\n  uvec4(0x79207468u,0x6520666cu,0x61742068u,0x6f72697au),\n  uvec4(0x6f6e206fu,0x6e6c7920u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x33373020u,0x20576861u,0x74206973u,0x20746865u),\n  uvec4(0x20636974u,0x79206f76u,0x65722074u,0x6865206du),\n  uvec4(0x6f756e74u,0x61696e73u,0x20204372u,0x61636b73u),\n  uvec4(0x20616e64u,0x20726566u,0x6f726d73u,0x20616e64u),\n  uvec4(0x20627572u,0x73747320u,0x696e2074u,0x68652076u),\n  uvec4(0x696f6c65u,0x74206169u,0x72202046u,0x616c6c69u),\n  uvec4(0x6e672074u,0x6f776572u,0x7320204au,0x65727573u),\n  uvec4(0x616c656du,0x20417468u,0x656e7320u,0x416c6578u),\n  uvec4(0x616e6472u,0x69612020u,0x5669656eu,0x6e61204cu),\n  uvec4(0x6f6e646fu,0x6e202055u,0x6e726561u,0x6c202041u),\n  uvec4(0x20776f6du,0x616e2064u,0x72657720u,0x68657220u),\n  uvec4(0x6c6f6e67u,0x20626c61u,0x636b2068u,0x61697220u),\n  uvec4(0x6f757420u,0x74696768u,0x74202041u,0x6e642066u),\n  uvec4(0x6964646cu,0x65642077u,0x68697370u,0x6572206du),\n  uvec4(0x75736963u,0x206f6e20u,0x74686f73u,0x65207374u),\n  uvec4(0x72696e67u,0x73202041u,0x6e642062u,0x61747320u),\n  uvec4(0x77697468u,0x20626162u,0x79206661u,0x63657320u),\n  uvec4(0x696e2074u,0x68652076u,0x696f6c65u,0x74206c69u),\n  uvec4(0x67687420u,0x20576869u,0x73746c65u,0x642c2061u),\n  uvec4(0x6e642062u,0x65617420u,0x74686569u,0x72207769u),\n  uvec4(0x6e677320u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20333830u),\n  uvec4(0x2020416eu,0x64206372u,0x61776c65u,0x64206865u),\n  uvec4(0x61642064u,0x6f776e77u,0x61726420u,0x646f776eu),\n  uvec4(0x20612062u,0x6c61636bu,0x656e6564u,0x2077616cu),\n  uvec4(0x6c202041u,0x6e642075u,0x70736964u,0x6520646fu),\n  uvec4(0x776e2069u,0x6e206169u,0x72207765u,0x72652074u),\n  uvec4(0x6f776572u,0x73202054u,0x6f6c6c69u,0x6e672072u),\n  uvec4(0x656d696eu,0x69736365u,0x6e742062u,0x656c6c73u),\n  uvec4(0x2c207468u,0x6174206bu,0x65707420u,0x74686520u),\n  uvec4(0x686f7572u,0x73202041u,0x6e642076u,0x6f696365u),\n  uvec4(0x73207369u,0x6e67696eu,0x67206f75u,0x74206f66u),\n  uvec4(0x20656d70u,0x74792063u,0x69737465u,0x726e7320u),\n  uvec4(0x616e6420u,0x65786861u,0x75737465u,0x64207765u),\n  uvec4(0x6c6c732eu,0x2020496eu,0x20746869u,0x73206465u),\n  uvec4(0x63617965u,0x6420686fu,0x6c652061u,0x6d6f6e67u),\n  uvec4(0x20746865u,0x206d6f75u,0x6e746169u,0x6e732020u),\n  uvec4(0x496e2074u,0x68652066u,0x61696e74u,0x206d6f6fu),\n  uvec4(0x6e6c6967u,0x68742c20u,0x74686520u,0x67726173u),\n  uvec4(0x73206973u,0x2073696eu,0x67696e67u,0x20204f76u),\n  uvec4(0x65722074u,0x68652074u,0x756d626cu,0x65642067u),\n  uvec4(0x72617665u,0x732c2061u,0x626f7574u,0x20746865u),\n  uvec4(0x20636861u,0x70656c20u,0x20546865u,0x72652069u),\n  uvec4(0x73207468u,0x6520656du,0x70747920u,0x63686170u),\n  uvec4(0x656c2c20u,0x6f6e6c79u,0x20746865u,0x2077696eu),\n  uvec4(0x64277320u,0x686f6d65u,0x2e202049u,0x74206861u),\n  uvec4(0x73206e6fu,0x2077696eu,0x646f7773u,0x2c20616eu),\n  uvec4(0x64207468u,0x6520646fu,0x6f722073u,0x77696e67u),\n  uvec4(0x732c2020u,0x44727920u,0x626f6e65u,0x73206361u),\n  uvec4(0x6e206861u,0x726d206eu,0x6f206f6eu,0x652e2020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x33393020u),\n  uvec4(0x204f6e6cu,0x79206120u,0x636f636bu,0x2073746fu),\n  uvec4(0x6f64206fu,0x6e207468u,0x6520726fu,0x6f667472u),\n  uvec4(0x65652020u,0x436f2063u,0x6f207269u,0x636f2063u),\n  uvec4(0x6f20636fu,0x20726963u,0x6f202049u,0x6e206120u),\n  uvec4(0x666c6173u,0x68206f66u,0x206c6967u,0x68746e69u),\n  uvec4(0x6e672e20u,0x5468656eu,0x20612064u,0x616d7020u),\n  uvec4(0x67757374u,0x20204272u,0x696e6769u,0x6e672072u),\n  uvec4(0x61696e20u,0x2047616eu,0x67612077u,0x61732073u),\n  uvec4(0x756e6b65u,0x6e2c2061u,0x6e642074u,0x6865206cu),\n  uvec4(0x696d7020u,0x6c656176u,0x65732020u,0x57616974u),\n  uvec4(0x65642066u,0x6f722072u,0x61696e2cu,0x20776869u),\n  uvec4(0x6c652074u,0x68652062u,0x6c61636bu,0x20636c6fu),\n  uvec4(0x75647320u,0x20476174u,0x68657265u,0x64206661u),\n  uvec4(0x72206469u,0x7374616eu,0x742c206fu,0x76657220u),\n  uvec4(0x48696d61u,0x76616e74u,0x2e202054u,0x6865206au),\n  uvec4(0x756e676cu,0x65206372u,0x6f756368u,0x65642c20u),\n  uvec4(0x68756d70u,0x65642069u,0x6e207369u,0x6c656e63u),\n  uvec4(0x652e2020u,0x5468656eu,0x2073706fu,0x6b652074u),\n  uvec4(0x68652074u,0x68756e64u,0x65722020u,0x44412020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x34303020u,0x20446174u,0x74613a20u),\n  uvec4(0x77686174u,0x20686176u,0x65207765u,0x20676976u),\n  uvec4(0x656e3f20u,0x204d7920u,0x66726965u,0x6e642c20u),\n  uvec4(0x626c6f6fu,0x64207368u,0x616b696eu,0x67206d79u),\n  uvec4(0x20686561u,0x72742020u,0x54686520u,0x61776675u),\n  uvec4(0x6c206461u,0x72696e67u,0x206f6620u,0x61206d6fu),\n  uvec4(0x6d656e74u,0x27732073u,0x75727265u,0x6e646572u),\n  uvec4(0x20205768u,0x69636820u,0x616e2061u,0x6765206fu),\n  uvec4(0x66207072u,0x7564656eu,0x63652063u,0x616e206eu),\n  uvec4(0x65766572u,0x20726574u,0x72616374u,0x20204279u),\n  uvec4(0x20746869u,0x732c2061u,0x6e642074u,0x68697320u),\n  uvec4(0x6f6e6c79u,0x2c207765u,0x20686176u,0x65206578u),\n  uvec4(0x69737465u,0x64202057u,0x68696368u,0x20697320u),\n  uvec4(0x6e6f7420u,0x746f2062u,0x6520666fu,0x756e6420u),\n  uvec4(0x696e206fu,0x7572206fu,0x62697475u,0x61726965u),\n  uvec4(0x7320204fu,0x7220696eu,0x206d656du,0x6f726965u),\n  uvec4(0x73206472u,0x61706564u,0x20627920u,0x74686520u),\n  uvec4(0x62656e65u,0x66696365u,0x6e742073u,0x70696465u),\n  uvec4(0x7220204fu,0x7220756eu,0x64657220u,0x7365616cu),\n  uvec4(0x73206272u,0x6f6b656eu,0x20627920u,0x74686520u),\n  uvec4(0x6c65616eu,0x20736f6cu,0x69636974u,0x6f722020u),\n  uvec4(0x496e206fu,0x75722065u,0x6d707479u,0x20726f6fu),\n  uvec4(0x6d732020u,0x44412020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x34313020u),\n  uvec4(0x20446179u,0x61646876u,0x616d3a20u,0x49206861u),\n  uvec4(0x76652068u,0x65617264u,0x20746865u,0x206b6579u),\n  uvec4(0x20205475u,0x726e2069u,0x6e207468u,0x6520646fu),\n  uvec4(0x6f72206fu,0x6e636520u,0x616e6420u,0x7475726eu),\n  uvec4(0x206f6e63u,0x65206f6eu,0x6c792020u,0x57652074u),\n  uvec4(0x68696e6bu,0x206f6620u,0x74686520u,0x6b65792cu),\n  uvec4(0x20656163u,0x6820696eu,0x20686973u,0x20707269u),\n  uvec4(0x736f6e20u,0x20546869u,0x6e6b696eu,0x67206f66u),\n  uvec4(0x20746865u,0x206b6579u,0x2c206561u,0x63682063u),\n  uvec4(0x6f6e6669u,0x726d7320u,0x61207072u,0x69736f6eu),\n  uvec4(0x20204f6eu,0x6c792061u,0x74206e69u,0x67687466u),\n  uvec4(0x616c6c2cu,0x20616574u,0x68657269u,0x616c2072u),\n  uvec4(0x756d6f75u,0x72732020u,0x52657669u,0x76652066u),\n  uvec4(0x6f722061u,0x206d6f6du,0x656e7420u,0x61206272u),\n  uvec4(0x6f6b656eu,0x20436f72u,0x696f6c61u,0x6e757320u),\n  uvec4(0x20444120u,0x2044616du,0x79617461u,0x3a205468u),\n  uvec4(0x6520626fu,0x61742072u,0x6573706fu,0x6e646564u),\n  uvec4(0x20204761u,0x696c792cu,0x20746f20u,0x74686520u),\n  uvec4(0x68616e64u,0x20657870u,0x65727420u,0x77697468u),\n  uvec4(0x20736169u,0x6c20616eu,0x64206f61u,0x72202054u),\n  uvec4(0x68652073u,0x65612077u,0x61732063u,0x616c6d2cu),\n  uvec4(0x20796f75u,0x72206865u,0x61727420u,0x776f756cu),\n  uvec4(0x64206861u,0x76652072u,0x6573706fu,0x6e646564u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202034u,0x32302020u,0x4761696cu),\n  uvec4(0x792c2077u,0x68656e20u,0x696e7669u,0x7465642cu),\n  uvec4(0x20626561u,0x74696e67u,0x206f6265u,0x6469656eu),\n  uvec4(0x74202054u,0x6f20636fu,0x6e74726fu,0x6c6c696eu),\n  uvec4(0x67206861u,0x6e647320u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20204920u),\n  uvec4(0x73617420u,0x75706f6eu,0x20746865u,0x2073686fu),\n  uvec4(0x72652020u,0x46697368u,0x696e672cu,0x20776974u),\n  uvec4(0x68207468u,0x65206172u,0x69642070u,0x6c61696eu),\n  uvec4(0x20626568u,0x696e6420u,0x6d652020u,0x5368616cu),\n  uvec4(0x6c204920u,0x6174206cu,0x65617374u,0x20736574u),\n  uvec4(0x206d7920u,0x6c616e64u,0x7320696eu,0x206f7264u),\n  uvec4(0x65723f20u,0x204c6f6eu,0x646f6e20u,0x42726964u),\n  uvec4(0x67652069u,0x73206661u,0x6c6c696eu,0x6720646fu),\n  uvec4(0x776e2066u,0x616c6c69u,0x6e672064u,0x6f776e20u),\n  uvec4(0x66616c6cu,0x696e6720u,0x646f776eu,0x2020506fu),\n  uvec4(0x69207327u,0x6173636fu,0x7365206eu,0x656c2066u),\n  uvec4(0x6f636f20u,0x63686520u,0x676c6920u,0x61666669u),\n  uvec4(0x6e612020u,0x5175616eu,0x646f2066u,0x69616d20u),\n  uvec4(0x63657520u,0x6368656cu,0x69646f6eu,0x202d204fu),\n  uvec4(0x20737761u,0x6c6c6f77u,0x20737761u,0x6c6c6f77u),\n  uvec4(0x20204c65u,0x20507269u,0x6e636520u,0x64274171u),\n  uvec4(0x75697461u,0x696e6520u,0xe0206c61u,0x20746f75u),\n  uvec4(0x72206162u,0x6f6c6965u,0x20205468u,0x65736520u),\n  uvec4(0x66726167u,0x6d656e74u,0x73204920u,0x68617665u),\n  uvec4(0x2073686fu,0x72656420u,0x61676169u,0x6e737420u),\n  uvec4(0x6d792072u,0x75696e73u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20203433u,0x30202057u,0x68792074u,0x68656e20u),\n  uvec4(0x496c6520u,0x66697420u,0x796f752eu,0x20486965u),\n  uvec4(0x726f6e79u,0x6d6f2773u,0x206d6164u,0x20616761u),\n  uvec4(0x696e652eu,0x20204461u,0x7474612eu,0x20446179u),\n  uvec4(0x61646876u,0x616d2e20u,0x44616d79u,0x6174612eu),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20536861u),\n  uvec4(0x6e746968u,0x20202020u,0x7368616eu,0x74696820u),\n  uvec4(0x20202073u,0x68616e74u,0x69682020u,0x4c696e65u),\n  uvec4(0x20343135u,0x20616574u,0x68657269u,0x616c5d20u),\n  uvec4(0x61657468u,0x65726561u,0x6c20204cu,0x696e6520u),\n  uvec4(0x34323820u,0x6365755du,0x20757469u,0x2d204564u),\n  uvec4(0x69746f72u,0x20202020u,0x20202020u,0x20204e4fu),\n  uvec4(0x54455320u,0x4f4e2022u,0x54484520u,0x57415354u),\n  uvec4(0x45204c41u,0x4e442220u,0x20202020u,0x204e6f74u),\n  uvec4(0x206f6e6cu,0x79207468u,0x65207469u,0x746c652cu),\n  uvec4(0x20627574u,0x20746865u,0x20706c61u,0x6e20616eu),\n  uvec4(0x64206120u,0x676f6f64u,0x20646561u,0x6c206f66u),\n  uvec4(0x20746865u,0x20202020u,0x2020696eu,0x63696465u),\n  uvec4(0x6e74616cu,0x2073796du,0x626f6c69u,0x736d206fu),\n  uvec4(0x66207468u,0x6520706fu,0x656d2077u,0x65726520u),\n  uvec4(0x73756767u,0x65737465u,0x64206279u,0x204d6973u),\n  uvec4(0x73204a65u,0x73736965u,0x204c2e20u,0x20202020u),\n  uvec4(0x20576573u,0x746f6e27u,0x7320626fu,0x6f6b206fu),\n  uvec4(0x6e207468u,0x65204772u,0x61696c20u,0x6c656765u),\n  uvec4(0x6e643a20u,0x46726f6du,0x20526974u,0x75616c20u),\n  uvec4(0x746f2052u,0x6f6d616eu,0x63652020u,0x20202020u),\n  uvec4(0x284d6163u,0x6d696c6cu,0x616e2c20u,0x43616d62u),\n  uvec4(0x72696467u,0x65292049u,0x6e646565u,0x642c2073u),\n  uvec4(0x6f206465u,0x65706c79u,0x20616d20u,0x4920696eu),\n  uvec4(0x64656274u,0x65642c20u,0x4d697373u,0x20202020u),\n  uvec4(0x20205765u,0x73746f6eu,0x27732062u,0x6f6f6b20u),\n  uvec4(0x77696c6cu,0x20656c75u,0x63696461u,0x74652074u),\n  uvec4(0x68652064u,0x69666669u,0x63756c74u,0x69657320u),\n  uvec4(0x6f662074u,0x68652070u,0x6f656d20u,0x6d756368u),\n  uvec4(0x20202020u,0x20206265u,0x74746572u,0x20746861u),\n  uvec4(0x6e206d79u,0x206e6f74u,0x65732063u,0x616e2064u),\n  uvec4(0x6f3b2061u,0x6e642049u,0x20726563u,0x6f6d6d65u),\n  uvec4(0x6e642069u,0x74202861u,0x70617274u,0x2066726fu),\n  uvec4(0x6d207468u,0x65202020u,0x20202067u,0x72656174u),\n  uvec4(0x20696e74u,0x65726573u,0x74206f66u,0x20746865u),\n  uvec4(0x20626f6fu,0x6b206974u,0x73656c66u,0x2920746fu),\n  uvec4(0x20616e79u,0x2077686fu,0x20746869u,0x6e6b2073u),\n  uvec4(0x75636820u,0x20202020u,0x20656c75u,0x63696461u),\n  uvec4(0x74696f6eu,0x206f6620u,0x74686520u,0x706f656du),\n  uvec4(0x20776f72u,0x74682074u,0x68652074u,0x726f7562u),\n  uvec4(0x6c652e20u,0x546f2061u,0x6e6f7468u,0x65722077u),\n  uvec4(0x6f726b20u,0x6f662020u,0x20202020u,0x616e7468u),\n  uvec4(0x726f706fu,0x6c6f6779u,0x20492061u,0x6d20696eu),\n  uvec4(0x64656274u,0x65642069u,0x6e206765u,0x6e657261u),\n  uvec4(0x6c2c206fu,0x6e652077u,0x68696368u,0x20686173u),\n  uvec4(0x20696e66u,0x6c75656eu,0x63656420u,0x20202020u),\n  uvec4(0x206f7572u,0x2067656eu,0x65726174u,0x696f6e20u),\n  uvec4(0x70726f66u,0x6f756e64u,0x6c793b20u,0x49206d65u),\n  uvec4(0x616e2054u,0x68652047u,0x6f6c6465u,0x6e20426fu),\n  uvec4(0x7567683bu,0x20492068u,0x61766520u,0x75736564u),\n  uvec4(0x20202020u,0x20206573u,0x70656369u,0x616c6c79u),\n  uvec4(0x20746865u,0x2074776fu,0x20766f6cu,0x756d6573u),\n  uvec4(0x2041646fu,0x6e69732cu,0x20417474u,0x69732c20u),\n  uvec4(0x4f736972u,0x69732e20u,0x416e796fu,0x6e652077u),\n  uvec4(0x686f2069u,0x73202020u,0x20202061u,0x63717561u),\n  uvec4(0x696e7465u,0x64207769u,0x74682074u,0x68657365u),\n  uvec4(0x20776f72u,0x6b732077u,0x696c6c20u,0x696d6d65u),\n  uvec4(0x64696174u,0x656c7920u,0x7265636fu,0x676e6973u),\n  uvec4(0x6520696eu,0x20746865u,0x20202020u,0x2020706fu),\n  uvec4(0x656d2063u,0x65727461u,0x696e2072u,0x65666572u),\n  uvec4(0x656e6365u,0x7320746fu,0x20766567u,0x65746174u),\n  uvec4(0x696f6e20u,0x63657265u,0x6d6f6e69u,0x65732e20u),\n  uvec4(0x20202020u,0x20202020u,0x20492e20u,0x54484520u),\n  uvec4(0x42555249u,0x414c204fu,0x46205448u,0x45204445u),\n  uvec4(0x41442020u,0x20202020u,0x20202020u,0x4c696e65u),\n  uvec4(0x2032302eu,0x20204366u,0x2e202045u,0x7a656b69u),\n  uvec4(0x656c2032u,0x3a312e20u,0x20202020u,0x20202020u),\n  uvec4(0x2032332eu,0x20204366u,0x2e202045u,0x63636c65u),\n  uvec4(0x73696173u,0x74657320u,0x31323a35u,0x2e202020u),\n  uvec4(0x20202020u,0x20202033u,0x312e2020u,0x562e2020u),\n  uvec4(0x54726973u,0x74616e20u,0x756e6420u,0x49736f6cu),\n  uvec4(0x64652c20u,0x692c2076u,0x65727365u,0x7320352du),\n  uvec4(0x382e2020u,0x20202020u,0x20202020u,0x34322e20u),\n  uvec4(0x2049642eu,0x20206969u,0x692c2076u,0x65727365u),\n  uvec4(0x2032342eu,0x20202020u,0x20202020u,0x20203436u),\n  uvec4(0x2e202049u,0x20616d20u,0x6e6f7420u,0x66616d69u),\n  uvec4(0x6c696172u,0x20776974u,0x68207468u,0x65206578u),\n  uvec4(0x61637420u,0x636f6e73u,0x74697475u,0x74696f6eu),\n  uvec4(0x206f6620u,0x74686520u,0x5461726fu,0x74202020u),\n  uvec4(0x20202070u,0x61636b20u,0x6f662063u,0x61726473u),\n  uvec4(0x2c206672u,0x6f6d2077u,0x68696368u,0x20492068u),\n  uvec4(0x61766520u,0x6f627669u,0x6f75736cu,0x79206465u),\n  uvec4(0x70617274u,0x65642074u,0x6f207375u,0x6974206du),\n  uvec4(0x79202020u,0x2020206fu,0x776e2063u,0x6f6e7665u),\n  uvec4(0x6e69656eu,0x63652e20u,0x54686520u,0x48616e67u),\n  uvec4(0x6564204du,0x616e2c20u,0x61206d65u,0x6d626572u),\n  uvec4(0x206f6620u,0x74686520u,0x74726164u,0x6974696fu),\n  uvec4(0x6e616c20u,0x20202020u,0x20706163u,0x6b2c2066u),\n  uvec4(0x69747320u,0x6d792070u,0x7572706fu,0x73652069u),\n  uvec4(0x6e207477u,0x6f207761u,0x79733a20u,0x20626563u),\n  uvec4(0x61757365u,0x20686520u,0x69732061u,0x73736f63u),\n  uvec4(0x69617465u,0x6420696eu,0x20202020u,0x20206d79u),\n  uvec4(0x206d696eu,0x64207769u,0x74682074u,0x68652048u),\n  uvec4(0x616e6765u,0x6420476fu,0x64206f66u,0x20467261u),\n  uvec4(0x7a65722cu,0x20616e64u,0x20626563u,0x61757365u),\n  uvec4(0x20492061u,0x73736f63u,0x69617465u,0x20202020u),\n  uvec4(0x20206869u,0x6d207769u,0x74682074u,0x68652068u),\n  uvec4(0x6f6f6465u,0x64206669u,0x67757265u,0x20696e20u),\n  uvec4(0x74686520u,0x70617373u,0x61676520u,0x6f662074u),\n  uvec4(0x68652064u,0x69736369u,0x706c6573u,0x20746f20u),\n  uvec4(0x20202020u,0x20456d6du,0x61757320u,0x696e2050u),\n  uvec4(0x61727420u,0x562e2054u,0x68652050u,0x686f656eu),\n  uvec4(0x69636961u,0x6e205361u,0x696c6f72u,0x20616e64u),\n  uvec4(0x20746865u,0x204d6572u,0x6368616eu,0x74206170u),\n  uvec4(0x70656172u,0x20202020u,0x20206c61u,0x7465723bu),\n  uvec4(0x20616c73u,0x6f207468u,0x65202263u,0x726f7764u),\n  uvec4(0x73206f66u,0x2070656fu,0x706c652cu,0x2220616eu),\n  uvec4(0x64204465u,0x61746820u,0x62792057u,0x61746572u),\n  uvec4(0x20697320u,0x20202020u,0x20657865u,0x63757465u),\n  uvec4(0x6420696eu,0x20506172u,0x74204956u,0x2e202054u),\n  uvec4(0x6865204du,0x616e2077u,0x69746820u,0x54687265u),\n  uvec4(0x65205374u,0x61766573u,0x2028616eu,0x20617574u),\n  uvec4(0x68656e74u,0x69632020u,0x20202020u,0x6d656d62u),\n  uvec4(0x6572206fu,0x66207468u,0x65205461u,0x726f7420u),\n  uvec4(0x7061636bu,0x29204920u,0x6173736fu,0x63696174u),\n  uvec4(0x652c2071u,0x75697465u,0x20617262u,0x69747261u),\n  uvec4(0x72696c79u,0x2c207769u,0x74682020u,0x20202020u),\n  uvec4(0x74686520u,0x46697368u,0x6572204bu,0x696e6720u),\n  uvec4(0x68696d73u,0x656c662eu,0x20202020u,0x20202020u),\n  uvec4(0x20203630u,0x2e202043u,0x662e2020u,0x42617564u),\n  uvec4(0x656c6169u,0x72653a20u,0x20202020u,0x20202020u),\n  uvec4(0x20202246u,0x6f75726du,0x696c6c61u,0x6e746520u),\n  uvec4(0x636974e9u,0x2c206369u,0x74e93b20u,0x706c6569u),\n  uvec4(0x6e652064u,0x652072eau,0x7665732cu,0x20202020u),\n  uvec4(0x2020204fu,0xf9206c65u,0x20737065u,0x63747265u),\n  uvec4(0x20656e20u,0x706c6569u,0x6e206a6fu,0x75722072u),\n  uvec4(0x61636372u,0x6f636865u,0x206c6520u,0x70617373u),\n  uvec4(0x616e742eu,0x22202020u,0x20202020u,0x20202036u),\n  uvec4(0x332e2020u,0x43662e20u,0x20496e66u,0x65726e6fu),\n  uvec4(0x2c206969u,0x692e2020u,0x35352d37u,0x2e202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202273u,0x69206c75u,0x6e676120u),\n  uvec4(0x74726174u,0x74612020u,0x20202020u,0x20646920u),\n  uvec4(0x67656e74u,0x652c2063u,0x6827696fu,0x206e6f6eu),\n  uvec4(0x20617672u,0x6569206du,0x61692063u,0x72656475u),\n  uvec4(0x746f2020u,0x20202020u,0x20636865u,0x206d6f72u),\n  uvec4(0x74652074u,0x616e7461u,0x206e2761u,0x76657373u),\n  uvec4(0x65206469u,0x73666174u,0x74612e22u,0x20202020u),\n  uvec4(0x20202020u,0x20203634u,0x2e202043u,0x662e2020u),\n  uvec4(0x496e6665u,0x726e6f2cu,0x2069762eu,0x20203235u),\n  uvec4(0x2d373a20u,0x20202020u,0x20202020u,0x20202251u),\n  uvec4(0x75697669u,0x2c207365u,0x636f6e64u,0x6f206368u),\n  uvec4(0x65207065u,0x72206173u,0x636f6c74u,0x6172652cu),\n  uvec4(0x20202020u,0x20202022u,0x6e6f6e20u,0x61766561u),\n  uvec4(0x20706961u,0x6e746f2cu,0x206d6127u,0x20636865u),\n  uvec4(0x20646920u,0x736f7370u,0x6972692cu,0x20202020u),\n  uvec4(0x20202022u,0x63686520u,0x6c276175u,0x72612065u),\n  uvec4(0x7465726eu,0x61206661u,0x63657661u,0x6e207472u),\n  uvec4(0x656d6172u,0x652e2220u,0x20202020u,0x20202020u),\n  uvec4(0x2036382eu,0x20204120u,0x7068656eu,0x6f6d656eu),\n  uvec4(0x6f6e2077u,0x68696368u,0x20492068u,0x61766520u),\n  uvec4(0x6f667465u,0x6e206e6fu,0x74696365u,0x642e2020u),\n  uvec4(0x20202020u,0x20202020u,0x37342e20u,0x2043662eu),\n  uvec4(0x20207468u,0x65204469u,0x72676520u,0x696e2057u),\n  uvec4(0x65627374u,0x65722773u,0x20576869u,0x74652044u),\n  uvec4(0x6576696cu,0x2e202020u,0x20202020u,0x20202037u),\n  uvec4(0x362e2020u,0x562e2042u,0x61756465u,0x6c616972u),\n  uvec4(0x652c2050u,0x72656661u,0x63652074u,0x6f20466cu),\n  uvec4(0x65757273u,0x20647520u,0x4d616c2eu,0x20202020u),\n  uvec4(0x20202020u,0x20204949u,0x2e202041u,0x2047414du),\n  uvec4(0x45204f46u,0x20434845u,0x53532020u,0x20202020u),\n  uvec4(0x20202020u,0x37372e20u,0x2043662eu,0x2020416eu),\n  uvec4(0x746f6e79u,0x20616e64u,0x20436c65u,0x6f706174u),\n  uvec4(0x72612c20u,0x49492e20u,0x69692e2cu,0x206c2e20u),\n  uvec4(0x3139302eu,0x20202020u,0x20202020u,0x20203932u),\n  uvec4(0x2e20204cu,0x61717565u,0x61726961u,0x2e202056u),\n  uvec4(0x2e202041u,0x656e6569u,0x642c2049u,0x2e203732u),\n  uvec4(0x363a2020u,0x20202020u,0x20202020u,0x20646570u),\n  uvec4(0x656e6465u,0x6e74206cu,0x7963686eu,0x69206c61u),\n  uvec4(0x71756561u,0x72696275u,0x73206175u,0x72656973u),\n  uvec4(0x20202020u,0x20202069u,0x6e63656eu,0x73692c20u),\n  uvec4(0x6574206eu,0x6f637465u,0x6d20666cu,0x616d6d69u),\n  uvec4(0x73206675u,0x6e616c69u,0x61207669u,0x6e63756eu),\n  uvec4(0x742e2020u,0x20202020u,0x20202020u,0x39382e20u),\n  uvec4(0x2053796cu,0x76616e20u,0x7363656eu,0x652e2020u),\n  uvec4(0x562e204du,0x696c746fu,0x6e2c2050u,0x61726164u),\n  uvec4(0x69736520u,0x4c6f7374u,0x2c206976u,0x2e202031u),\n  uvec4(0x34302e20u,0x20202020u,0x20202020u,0x2039392eu),\n  uvec4(0x2020562eu,0x204f7669u,0x642c204du,0x6574616du),\n  uvec4(0x6f727068u,0x6f736573u,0x2c207669u,0x2c205068u),\n  uvec4(0x696c6f6du,0x656c612eu,0x20202020u,0x20202020u),\n  uvec4(0x20203130u,0x302e2020u,0x43662e20u,0x20506172u),\n  uvec4(0x74204949u,0x492c206cu,0x2e203230u,0x342e2020u),\n  uvec4(0x20202020u,0x20202020u,0x3131352eu,0x20204366u),\n  uvec4(0x2e202050u,0x61727420u,0x4949492cu,0x206c2e20u),\n  uvec4(0x3139352eu,0x20202020u,0x20202020u,0x20203131u),\n  uvec4(0x382e2020u,0x43662e20u,0x20576562u,0x73746572u),\n  uvec4(0x3a202022u,0x49732074u,0x68652077u,0x696e6420u),\n  uvec4(0x696e2074u,0x68617420u,0x646f6f72u,0x20737469u),\n  uvec4(0x6c6c3f22u,0x20202020u,0x20202020u,0x20203132u),\n  uvec4(0x362e2020u,0x43662e20u,0x20506172u,0x7420492cu),\n  uvec4(0x206c2e20u,0x33372c20u,0x34382e20u,0x20202020u),\n  uvec4(0x20202020u,0x20313338u,0x2e202043u,0x662e2020u),\n  uvec4(0x74686520u,0x67616d65u,0x206f6620u,0x63686573u),\n  uvec4(0x7320696eu,0x204d6964u,0x646c6574u,0x6f6e2773u),\n  uvec4(0x20576f6du,0x656e2062u,0x65776172u,0x6520576fu),\n  uvec4(0x6d656e2eu,0x20202020u,0x20202020u,0x20204949u),\n  uvec4(0x492e2020u,0x54484520u,0x46495245u,0x20534552u),\n  uvec4(0x4d4f4e20u,0x20202020u,0x20202020u,0x20313736u),\n  uvec4(0x2e202056u,0x2e205370u,0x656e7365u,0x722c2050u),\n  uvec4(0x726f7468u,0x616c616du,0x696f6e2eu,0x20202020u),\n  uvec4(0x20202020u,0x20203139u,0x322e2020u,0x43662e20u),\n  uvec4(0x20546865u,0x2054656du,0x70657374u,0x2c20492eu),\n  uvec4(0x20206969u,0x2e202020u,0x20202020u,0x20202031u),\n  uvec4(0x39362e20u,0x2043662eu,0x20204d61u,0x7276656cu),\n  uvec4(0x6c2c2054u,0x6f204869u,0x7320436fu,0x79204d69u),\n  uvec4(0x73747265u,0x73732e20u,0x20202020u,0x20202020u),\n  uvec4(0x20313937u,0x2e202043u,0x662e2020u,0x4461792cu),\n  uvec4(0x20506172u,0x6c69616du,0x656e7420u,0x6f662042u),\n  uvec4(0x6565733au,0x20202020u,0x20202020u,0x20202022u),\n  uvec4(0x5768656eu,0x206f6620u,0x74686520u,0x73756464u),\n  uvec4(0x656e2c20u,0x6c697374u,0x656e696eu,0x672c2079u),\n  uvec4(0x6f752073u,0x68616c6cu,0x20686561u,0x722c2020u),\n  uvec4(0x20202020u,0x20224120u,0x6e6f6973u,0x65206f66u),\n  uvec4(0x20686f72u,0x6e732061u,0x6e642068u,0x756e7469u),\n  uvec4(0x6e672c20u,0x77686963u,0x68207368u,0x616c6c20u),\n  uvec4(0x6272696eu,0x67202020u,0x20202020u,0x22416374u),\n  uvec4(0x61656f6eu,0x20746f20u,0x4469616eu,0x6120696eu),\n  uvec4(0x20746865u,0x20737072u,0x696e672cu,0x20202020u),\n  uvec4(0x20202022u,0x57686572u,0x6520616cu,0x6c207368u),\n  uvec4(0x616c6c20u,0x73656520u,0x68657220u,0x6e616b65u),\n  uvec4(0x6420736bu,0x696e202eu,0x202e202eu,0x22202020u),\n  uvec4(0x20202020u,0x20202031u,0x39392e20u,0x20492064u),\n  uvec4(0x6f206e6fu,0x74206b6eu,0x6f772074u,0x6865206fu),\n  uvec4(0x72696769u,0x6e206f66u,0x20746865u,0x2062616cu),\n  uvec4(0x6c616420u,0x66726f6du,0x20776869u,0x63682074u),\n  uvec4(0x68657365u,0x20202020u,0x20206c69u,0x6e657320u),\n  uvec4(0x61726520u,0x74616b65u,0x6e3a2020u,0x69742077u),\n  uvec4(0x61732072u,0x65706f72u,0x74656420u,0x746f206du),\n  uvec4(0x65206672u,0x6f6d2053u,0x79646e65u,0x792c2041u),\n  uvec4(0x75737472u,0x616c6961u,0x2e202020u,0x20202020u),\n  uvec4(0x20202032u,0x30322e20u,0x20562e20u,0x5665726cu),\n  uvec4(0x61696e65u,0x2c205061u,0x72736966u,0x616c2e20u),\n  uvec4(0x20202020u,0x20202020u,0x20323130u,0x2e202054u),\n  uvec4(0x68652063u,0x75727261u,0x6e747320u,0x77657265u),\n  uvec4(0x2071756fu,0x74656420u,0x61742061u,0x20707269u),\n  uvec4(0x63652022u,0x63617272u,0x69616765u,0x20616e64u),\n  uvec4(0x20696e73u,0x7572616eu,0x63652020u,0x20202020u),\n  uvec4(0x66726565u,0x20746f20u,0x4c6f6e64u,0x6f6e223bu),\n  uvec4(0x20616e64u,0x20746865u,0x2042696cu,0x6c206f66u),\n  uvec4(0x204c6164u,0x696e6720u,0x6574632eu,0x20776572u),\n  uvec4(0x6520746fu,0x20626520u,0x68616e64u,0x65642020u),\n  uvec4(0x20202020u,0x746f2074u,0x68652062u,0x75796572u),\n  uvec4(0x2075706fu,0x6e207061u,0x796d656eu,0x74206f66u),\n  uvec4(0x20746865u,0x20736967u,0x68742064u,0x72616674u),\n  uvec4(0x2e202020u,0x20202020u,0x20202032u,0x31302e20u),\n  uvec4(0x20224361u,0x72726961u,0x67652061u,0x6e642069u),\n  uvec4(0x6e737572u,0x616e6365u,0x20667265u,0x65225d20u),\n  uvec4(0x22636f73u,0x742c2069u,0x6e737572u,0x616e6365u),\n  uvec4(0x20616e64u,0x20202020u,0x20206672u,0x65696768u),\n  uvec4(0x74222d45u,0x6469746fu,0x722e2020u,0x20202020u),\n  uvec4(0x20202020u,0x3231382eu,0x20205469u,0x72657369u),\n  uvec4(0x61732c20u,0x616c7468u,0x6f756768u,0x2061206du),\n  uvec4(0x65726520u,0x73706563u,0x7461746fu,0x7220616eu),\n  uvec4(0x64206e6fu,0x7420696eu,0x64656564u,0x20612020u),\n  uvec4(0x20202020u,0x22636861u,0x72616374u,0x65722c22u),\n  uvec4(0x20697320u,0x79657420u,0x74686520u,0x6d6f7374u),\n  uvec4(0x20696d70u,0x6f727461u,0x6e742070u,0x6572736fu),\n  uvec4(0x6e616765u,0x20696e20u,0x74686520u,0x706f656du),\n  uvec4(0x2c202020u,0x20202075u,0x6e697469u,0x6e672061u),\n  uvec4(0x6c6c2074u,0x68652072u,0x6573742eu,0x204a7573u),\n  uvec4(0x74206173u,0x20746865u,0x206f6e65u,0x2d657965u),\n  uvec4(0x64206d65u,0x72636861u,0x6e742c20u,0x73656c6cu),\n  uvec4(0x6572206fu,0x66202020u,0x20202063u,0x75727261u),\n  uvec4(0x6e74732cu,0x206d656cu,0x74732069u,0x6e746f20u),\n  uvec4(0x74686520u,0x50686f65u,0x6e696369u,0x616e2053u),\n  uvec4(0x61696c6fu,0x722c2061u,0x6e642074u,0x6865206cu),\n  uvec4(0x61747465u,0x72206973u,0x206e6f74u,0x20202020u),\n  uvec4(0x20207768u,0x6f6c6c79u,0x20646973u,0x74696e63u),\n  uvec4(0x74206672u,0x6f6d2046u,0x65726469u,0x6e616e64u),\n  uvec4(0x20507269u,0x6e636520u,0x6f66204eu,0x61706c65u),\n  uvec4(0x732c2073u,0x6f20616cu,0x6c207468u,0x6520776fu),\n  uvec4(0x6d656e20u,0x20202020u,0x20617265u,0x206f6e65u),\n  uvec4(0x20776f6du,0x616e2c20u,0x616e6420u,0x74686520u),\n  uvec4(0x74776f20u,0x73657865u,0x73206d65u,0x65742069u),\n  uvec4(0x6e205469u,0x72657369u,0x61732e20u,0x20576861u),\n  uvec4(0x74205469u,0x72657369u,0x61732020u,0x20202020u),\n  uvec4(0x73656573u,0x2c20696eu,0x20666163u,0x742c2069u),\n  uvec4(0x73207468u,0x65207375u,0x62737461u,0x6e636520u),\n  uvec4(0x6f662074u,0x68652070u,0x6f656d2eu,0x20205468u),\n  uvec4(0x65207768u,0x6f6c6520u,0x70617373u,0x61676520u),\n  uvec4(0x20202020u,0x2066726fu,0x6d204f76u,0x69642069u),\n  uvec4(0x73206f66u,0x20677265u,0x61742061u,0x6e746872u),\n  uvec4(0x6f706f6cu,0x6f676963u,0x616c2069u,0x6e746572u),\n  uvec4(0x6573743au,0x20202020u,0x20202020u,0x20202027u),\n  uvec4(0x2e202e20u,0x2e204375u,0x6d204975u,0x6e6f6e65u),\n  uvec4(0x20696f63u,0x6f732065u,0x74206d61u,0x696f7220u),\n  uvec4(0x76657374u,0x72612070u,0x726f6665u,0x63746f20u),\n  uvec4(0x65737420u,0x20202020u,0x20205175u,0x616d2c20u),\n  uvec4(0x71756165u,0x20636f6eu,0x74696e67u,0x6974206du),\n  uvec4(0x61726962u,0x75732c27u,0x20646978u,0x69737365u),\n  uvec4(0x2c202776u,0x6f6c7570u,0x7461732eu,0x27202020u),\n  uvec4(0x20202020u,0x496c6c61u,0x206e6567u,0x61743b20u),\n  uvec4(0x706c6163u,0x75697420u,0x71756165u,0x20736974u),\n  uvec4(0x2073656eu,0x74656e74u,0x69612064u,0x6f637469u),\n  uvec4(0x20202020u,0x20202051u,0x75616572u,0x65726520u),\n  uvec4(0x54697265u,0x73696165u,0x3a207665u,0x6e757320u),\n  uvec4(0x68756963u,0x20657261u,0x74207574u,0x72617175u),\n  uvec4(0x65206e6fu,0x74612e20u,0x20202020u,0x20204e61u),\n  uvec4(0x6d206475u,0x6f206d61u,0x676e6f72u,0x756d2076u),\n  uvec4(0x69726964u,0x6920636fu,0x65756e74u,0x69612073u),\n  uvec4(0x696c7661u,0x20202020u,0x20202043u,0x6f72706fu),\n  uvec4(0x72612073u,0x65727065u,0x6e74756du,0x20626163u),\n  uvec4(0x756c6920u,0x76696f6cu,0x61766572u,0x61742069u),\n  uvec4(0x63747520u,0x20202020u,0x20204465u,0x71756520u),\n  uvec4(0x7669726fu,0x20666163u,0x7475732cu,0x206d6972u),\n  uvec4(0x6162696cu,0x652c2066u,0x656d696eu,0x61207365u),\n  uvec4(0x7074656du,0x20202020u,0x20202045u,0x67657261u),\n  uvec4(0x74206175u,0x74756d6eu,0x6f733b20u,0x6f637461u),\n  uvec4(0x766f2072u,0x75727375u,0x7320656fu,0x7364656du),\n  uvec4(0x20202020u,0x20202056u,0x69646974u,0x20657420u),\n  uvec4(0x27657374u,0x20766573u,0x74726165u,0x20736920u),\n  uvec4(0x74616e74u,0x6120706fu,0x74656e74u,0x69612070u),\n  uvec4(0x6c616761u,0x652c2720u,0x20202020u,0x20204469u),\n  uvec4(0x78697420u,0x27757420u,0x61756374u,0x6f726973u),\n  uvec4(0x20736f72u,0x74656d20u,0x696e2063u,0x6f6e7472u),\n  uvec4(0x61726961u,0x206d7574u,0x65742c20u,0x20202020u),\n  uvec4(0x20204e75u,0x6e632071u,0x756f7175u,0x6520766fu),\n  uvec4(0x73206665u,0x7269616du,0x21272070u,0x65726375u),\n  uvec4(0x73736973u,0x20616e67u,0x75696275u,0x73206973u),\n  uvec4(0x64656d20u,0x20202020u,0x2020466fu,0x726d6120u),\n  uvec4(0x7072696fu,0x72207265u,0x64696974u,0x2067656eu),\n  uvec4(0x65746976u,0x61717565u,0x2076656eu,0x69742069u),\n  uvec4(0x6d61676fu,0x2e202020u,0x20202020u,0x41726269u),\n  uvec4(0x74657220u,0x68696320u,0x69676974u,0x75722073u),\n  uvec4(0x756d7074u,0x75732064u,0x65206c69u,0x74652069u),\n  uvec4(0x6f636f73u,0x61202020u,0x20202020u,0x44696374u),\n  uvec4(0x6120496fu,0x76697320u,0x6669726du,0x61743b20u),\n  uvec4(0x67726176u,0x69757320u,0x53617475u,0x726e6961u),\n  uvec4(0x20697573u,0x746f2020u,0x20202020u,0x204e6563u),\n  uvec4(0x2070726fu,0x206d6174u,0x65726961u,0x20666572u),\n  uvec4(0x74757220u,0x646f6c75u,0x69737365u,0x20737569u),\n  uvec4(0x71756520u,0x20202020u,0x20204975u,0x64696369u),\n  uvec4(0x73206165u,0x7465726eu,0x61206461u,0x6d6e6176u),\n  uvec4(0x6974206cu,0x756d696eu,0x61206e6fu,0x6374652cu),\n  uvec4(0x20202020u,0x20202041u,0x74207061u,0x74657220u),\n  uvec4(0x6f6d6e69u,0x706f7465u,0x6e732028u,0x6e657175u),\n  uvec4(0x6520656eu,0x696d206cu,0x69636574u,0x20696e72u),\n  uvec4(0x69746120u,0x63756971u,0x75616d20u,0x20202020u),\n  uvec4(0x20204661u,0x63746120u,0x64656920u,0x66656369u),\n  uvec4(0x73736520u,0x64656f29u,0x2070726fu,0x206c756du),\n  uvec4(0x696e6520u,0x6164656du,0x70746f20u,0x20202020u),\n  uvec4(0x20205363u,0x69726520u,0x66757475u,0x72612064u),\n  uvec4(0x65646974u,0x20706f65u,0x6e616d71u,0x7565206cu),\n  uvec4(0x65766176u,0x69742068u,0x6f6e6f72u,0x652e2020u),\n  uvec4(0x20202020u,0x20202020u,0x3232312eu,0x20205468u),\n  uvec4(0x6973206du,0x6179206eu,0x6f742061u,0x70706561u),\n  uvec4(0x72206173u,0x20657861u,0x63742061u,0x73205361u),\n  uvec4(0x7070686fu,0x2773206cu,0x696e6573u,0x2c206275u),\n  uvec4(0x74204920u,0x68616420u,0x20202020u,0x20696e20u),\n  uvec4(0x6d696e64u,0x20746865u,0x20226c6fu,0x6e677368u),\n  uvec4(0x6f726522u,0x206f7220u,0x22646f72u,0x79222066u),\n  uvec4(0x69736865u,0x726d616eu,0x2c207768u,0x6f207265u),\n  uvec4(0x7475726eu,0x73206174u,0x20202020u,0x20206e69u),\n  uvec4(0x67687466u,0x616c6c2eu,0x20202020u,0x20202020u),\n  uvec4(0x20203235u,0x332e2020u,0x562e2047u,0x6f6c6473u),\n  uvec4(0x6d697468u,0x2c207468u,0x6520736fu,0x6e672069u),\n  uvec4(0x6e205468u,0x65205669u,0x63617220u,0x6f662057u),\n  uvec4(0x616b6566u,0x69656c64u,0x2e202020u,0x20202020u),\n  uvec4(0x20202032u,0x35372e20u,0x20562e20u,0x20546865u),\n  uvec4(0x2054656du,0x70657374u,0x2c206173u,0x2061626fu),\n  uvec4(0x76652e20u,0x20202020u,0x20202020u,0x20323634u),\n  uvec4(0x2e202054u,0x68652069u,0x6e746572u,0x696f7220u),\n  uvec4(0x6f662053u,0x742e204du,0x61676e75u,0x73204d61u),\n  uvec4(0x72747972u,0x20697320u,0x746f206du,0x79206d69u),\n  uvec4(0x6e64206fu,0x6e65206fu,0x66202020u,0x20202074u),\n  uvec4(0x68652066u,0x696e6573u,0x7420616du,0x6f6e6720u),\n  uvec4(0x5772656eu,0x27732069u,0x6e746572u,0x696f7273u),\n  uvec4(0x2e202053u,0x65652054u,0x68652050u,0x726f706fu),\n  uvec4(0x73656420u,0x44656d6fu,0x6c697469u,0x6f6e2020u),\n  uvec4(0x20202020u,0x6f66204eu,0x696e6574u,0x65656e20u),\n  uvec4(0x43697479u,0x20436875u,0x72636865u,0x73202850u),\n  uvec4(0x2e20532eu,0x204b696eu,0x67202620u,0x536f6e2cu),\n  uvec4(0x204c7464u,0x2e292e20u,0x20202020u,0x20202020u),\n  uvec4(0x20323636u,0x2e202054u,0x68652053u,0x6f6e6720u),\n  uvec4(0x6f662074u,0x68652028u,0x74687265u,0x65292054u),\n  uvec4(0x68616d65u,0x732d6461u,0x75676874u,0x65727320u),\n  uvec4(0x62656769u,0x6e732068u,0x6572652eu,0x20202020u),\n  uvec4(0x20204672u,0x6f6d206cu,0x696e6520u,0x32393220u),\n  uvec4(0x746f2033u,0x30362069u,0x6e636c75u,0x73697665u),\n  uvec4(0x20746865u,0x79207370u,0x65616b20u,0x696e2074u),\n  uvec4(0x75726e2eu,0x20202020u,0x2020562eu,0x202047f6u),\n  uvec4(0x74746572u,0x64e46d6du,0x6572756eu,0x672c2049u),\n  uvec4(0x49492e20u,0x20693a20u,0x20746865u,0x20526869u),\n  uvec4(0x6e652d64u,0x61756768u,0x74657273u,0x2e202020u),\n  uvec4(0x20202020u,0x20202032u,0x37392e20u,0x20562e20u),\n  uvec4(0x46726f75u,0x64652c20u,0x456c697au,0x61626574u),\n  uvec4(0x682c2056u,0x6f6c2e20u,0x20492c20u,0x63682e20u),\n  uvec4(0x2069762cu,0x206c6574u,0x74657220u,0x6f662044u),\n  uvec4(0x65202020u,0x20202051u,0x75616472u,0x6120746fu),\n  uvec4(0x20506869u,0x6c697020u,0x6f662053u,0x7061696eu),\n  uvec4(0x3a202020u,0x20202020u,0x20202022u,0x496e2074u),\n  uvec4(0x68652061u,0x66746572u,0x6e6f6f6eu,0x20776520u),\n  uvec4(0x77657265u,0x20696e20u,0x61206261u,0x7267652cu),\n  uvec4(0x20776174u,0x6368696eu,0x67207468u,0x65206761u),\n  uvec4(0x6d657320u,0x6f6e2074u,0x68652020u,0x20202020u),\n  uvec4(0x72697665u,0x722e2028u,0x54686520u,0x71756565u),\n  uvec4(0x6e292077u,0x61732061u,0x6c6f6e65u,0x20776974u),\n  uvec4(0x68204c6fu,0x72642052u,0x6f626572u,0x7420616eu),\n  uvec4(0x64206d79u,0x73656c66u,0x206f6e20u,0x74686520u),\n  uvec4(0x20202020u,0x20706f6fu,0x702c2077u,0x68656e20u),\n  uvec4(0x74686579u,0x20626567u,0x616e2074u,0x6f207461u),\n  uvec4(0x6c6b206eu,0x6f6e7365u,0x6e73652cu,0x20616e64u),\n  uvec4(0x2077656eu,0x7420736fu,0x20666172u,0x20746861u),\n  uvec4(0x74204c6fu,0x72642020u,0x20202020u,0x526f6265u),\n  uvec4(0x72742061u,0x74206c61u,0x73742073u,0x6169642cu),\n  uvec4(0x20617320u,0x49207761u,0x73206f6eu,0x20746865u),\n  uvec4(0x2073706fu,0x74207468u,0x65726520u,0x77617320u),\n  uvec4(0x6e6f2072u,0x6561736fu,0x6e207768u,0x79202020u),\n  uvec4(0x20202074u,0x68657920u,0x73686f75u,0x6c64206eu),\n  uvec4(0x6f742062u,0x65206d61u,0x72726965u,0x64206966u),\n  uvec4(0x20746865u,0x20717565u,0x656e2070u,0x6c656173u),\n  uvec4(0x65642e22u,0x20202020u,0x20202020u,0x20203239u),\n  uvec4(0x332e2020u,0x43662e20u,0x20507572u,0x6761746fu),\n  uvec4(0x72696f2cu,0x20762e20u,0x20313333u,0x3a202020u),\n  uvec4(0x20202020u,0x20202020u,0x22526963u,0x6f726469u),\n  uvec4(0x74692064u,0x69206d65u,0x2c206368u,0x6520736fu),\n  uvec4(0x6e206c61u,0x20506961u,0x3b202020u,0x20202020u),\n  uvec4(0x5369656eu,0x61206d69u,0x20666527u,0x2c206469u),\n  uvec4(0x73666563u,0x656d6920u,0x4d617265u,0x6d6d612eu),\n  uvec4(0x22202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20333037u,0x2e202056u,0x2e205374u,0x2e204175u),\n  uvec4(0x67757374u,0x696e6527u,0x7320436fu,0x6e666573u),\n  uvec4(0x73696f6eu,0x733a2020u,0x22746f20u,0x43617274u),\n  uvec4(0x68616765u,0x20746865u,0x6e204920u,0x20202020u),\n  uvec4(0x2063616du,0x652c2077u,0x68657265u,0x20612063u),\n  uvec4(0x61756c64u,0x726f6e20u,0x6f662075u,0x6e686f6cu),\n  uvec4(0x79206c6fu,0x76657320u,0x73616e67u,0x20616c6cu),\n  uvec4(0x2061626fu,0x7574206du,0x696e6520u,0x65617273u),\n  uvec4(0x2e222020u,0x20202020u,0x20202020u,0x3330382eu),\n  uvec4(0x20205468u,0x6520636fu,0x6d706c65u,0x74652074u),\n  uvec4(0x65787420u,0x6f662074u,0x68652042u,0x75646468u),\n  uvec4(0x61277320u,0x46697265u,0x20536572u,0x6d6f6e20u),\n  uvec4(0x28776869u,0x63682020u,0x20202020u,0x636f7272u),\n  uvec4(0x6573706fu,0x6e647320u,0x696e2069u,0x6d706f72u),\n  uvec4(0x74616e63u,0x6520746fu,0x20746865u,0x20536572u),\n  uvec4(0x6d6f6e20u,0x6f6e2074u,0x6865204du,0x6f756e74u),\n  uvec4(0x29206672u,0x6f6d2077u,0x68696368u,0x20202020u),\n  uvec4(0x20207468u,0x65736520u,0x776f7264u,0x73206172u),\n  uvec4(0x65207461u,0x6b656e2cu,0x2077696cu,0x6c206265u),\n  uvec4(0x20666f75u,0x6e642074u,0x72616e73u,0x6c617465u),\n  uvec4(0x6420696eu,0x20746865u,0x206c6174u,0x65204865u),\n  uvec4(0x6e727920u,0x20202020u,0x20436c61u,0x726b6520u),\n  uvec4(0x57617272u,0x656e2773u,0x20427564u,0x64686973u),\n  uvec4(0x6d20696eu,0x20547261u,0x6e736c61u,0x74696f6eu),\n  uvec4(0x20284861u,0x72766172u,0x64204f72u,0x69656e74u),\n  uvec4(0x616c2020u,0x20202020u,0x53657269u,0x6573292eu),\n  uvec4(0x204d722eu,0x20576172u,0x72656e20u,0x77617320u),\n  uvec4(0x6f6e6520u,0x6f662074u,0x68652067u,0x72656174u),\n  uvec4(0x2070696fu,0x6e656572u,0x73206f66u,0x20427564u),\n  uvec4(0x64686973u,0x74202020u,0x20202073u,0x74756469u),\n  uvec4(0x65732069u,0x6e207468u,0x65204f63u,0x63696465u),\n  uvec4(0x6e742e20u,0x20202020u,0x20202020u,0x20333039u),\n  uvec4(0x2e202046u,0x726f6d20u,0x53742e20u,0x41756775u),\n  uvec4(0x7374696eu,0x65277320u,0x436f6e66u,0x65737369u),\n  uvec4(0x6f6e7320u,0x61676169u,0x6e2e2020u,0x54686520u),\n  uvec4(0x636f6c6cu,0x6f636174u,0x696f6e20u,0x20202020u),\n  uvec4(0x206f6620u,0x74686573u,0x65207477u,0x6f207265u),\n  uvec4(0x70726573u,0x656e7461u,0x74697665u,0x73206f66u),\n  uvec4(0x20656173u,0x7465726eu,0x20616e64u,0x20776573u),\n  uvec4(0x7465726eu,0x20617363u,0x65746963u,0x69736d2cu),\n  uvec4(0x20202020u,0x20206173u,0x20746865u,0x2063756cu),\n  uvec4(0x6d696e61u,0x74696f6eu,0x206f6620u,0x74686973u),\n  uvec4(0x20706172u,0x74206f66u,0x20746865u,0x20706f65u),\n  uvec4(0x6d2c2069u,0x73206e6fu,0x7420616eu,0x20616363u),\n  uvec4(0x6964656eu,0x742e2020u,0x20202020u,0x20202020u),\n  uvec4(0x562e2057u,0x48415420u,0x54484520u,0x5448554eu),\n  uvec4(0x44455220u,0x53414944u,0x20202020u,0x20202020u),\n  uvec4(0x2020496eu,0x20746865u,0x20666972u,0x73742070u),\n  uvec4(0x61727420u,0x6f662050u,0x61727420u,0x56207468u),\n  uvec4(0x72656520u,0x7468656du,0x65732061u,0x72652065u),\n  uvec4(0x6d706c6fu,0x7965643au,0x20202020u,0x20207468u),\n  uvec4(0x65206a6fu,0x75726e65u,0x7920746fu,0x20456d6du),\n  uvec4(0x6175732cu,0x20746865u,0x20617070u,0x726f6163u),\n  uvec4(0x6820746fu,0x20746865u,0x20436861u,0x70656c20u),\n  uvec4(0x50657269u,0x6c6f7573u,0x20202020u,0x20202873u),\n  uvec4(0x6565204du,0x69737320u,0x57657374u,0x6f6e2773u),\n  uvec4(0x20626f6fu,0x6b292061u,0x6e642074u,0x68652070u),\n  uvec4(0x72657365u,0x6e742064u,0x65636179u,0x206f6620u),\n  uvec4(0x65617374u,0x65726e20u,0x4575726fu,0x70652e20u),\n  uvec4(0x20202020u,0x20202020u,0x20333537u,0x2e202054u),\n  uvec4(0x68697320u,0x69732054u,0x75726475u,0x7320616fu),\n  uvec4(0x6e616c61u,0x7363686bu,0x61652070u,0x616c6c61u),\n  uvec4(0x7369692cu,0x20746865u,0x20686572u,0x6d69742du),\n  uvec4(0x74687275u,0x73682020u,0x20202020u,0x77686963u),\n  uvec4(0x68204920u,0x68617665u,0x20686561u,0x72642069u),\n  uvec4(0x6e205175u,0x65626563u,0x20436f75u,0x6e74792eu),\n  uvec4(0x20204368u,0x61706d61u,0x6e207361u,0x79732028u),\n  uvec4(0x48616e64u,0x626f6f6bu,0x206f6620u,0x20202020u),\n  uvec4(0x20426972u,0x6473206fu,0x66204561u,0x73746572u),\n  uvec4(0x6e204e6fu,0x72746820u,0x416d6572u,0x69636129u),\n  uvec4(0x20226974u,0x20697320u,0x6d6f7374u,0x20617420u),\n  uvec4(0x686f6d65u,0x20696e20u,0x7365636cu,0x75646564u),\n  uvec4(0x20202020u,0x2020776fu,0x6f646c61u,0x6e642061u),\n  uvec4(0x6e642074u,0x6869636bu,0x65747920u,0x72657472u),\n  uvec4(0x65617473u,0x2e202e20u,0x2e202e20u,0x49747320u),\n  uvec4(0x6e6f7465u,0x73206172u,0x65206e6fu,0x74202020u),\n  uvec4(0x20202072u,0x656d6172u,0x6b61626cu,0x6520666fu),\n  uvec4(0x72207661u,0x72696574u,0x79206f72u,0x20766f6cu),\n  uvec4(0x756d652cu,0x20627574u,0x20696e20u,0x70757269u),\n  uvec4(0x74792061u,0x6e642073u,0x77656574u,0x6e657373u),\n  uvec4(0x206f6620u,0x20202020u,0x20746f6eu,0x6520616eu),\n  uvec4(0x64206578u,0x71756973u,0x69746520u,0x6d6f6475u),\n  uvec4(0x6c617469u,0x6f6e2074u,0x68657920u,0x61726520u),\n  uvec4(0x756e6571u,0x75616c6cu,0x65642e22u,0x20204974u),\n  uvec4(0x73202020u,0x20202022u,0x77617465u,0x722d6472u),\n  uvec4(0x69707069u,0x6e672073u,0x6f6e6722u,0x20697320u),\n  uvec4(0x6a757374u,0x6c792063u,0x656c6562u,0x72617465u),\n  uvec4(0x642e2020u,0x20202020u,0x20202020u,0x3336302eu),\n  uvec4(0x20205468u,0x6520666fu,0x6c6c6f77u,0x696e6720u),\n  uvec4(0x6c696e65u,0x73207765u,0x72652073u,0x74696d75u),\n  uvec4(0x6c617465u,0x64206279u,0x20746865u,0x20616363u),\n  uvec4(0x6f756e74u,0x206f6620u,0x6f6e6520u,0x20202020u),\n  uvec4(0x206f6620u,0x74686520u,0x416e7461u,0x72637469u),\n  uvec4(0x63206578u,0x70656469u,0x74696f6eu,0x73202849u),\n  uvec4(0x20666f72u,0x67657420u,0x77686963u,0x682c2062u),\n  uvec4(0x75742049u,0x20746869u,0x6e6b206fu,0x6e652020u),\n  uvec4(0x20202020u,0x6f662053u,0x6861636bu,0x6c65746fu),\n  uvec4(0x6e277329u,0x3a206974u,0x20776173u,0x2072656cu),\n  uvec4(0x61746564u,0x20746861u,0x74207468u,0x65207061u),\n  uvec4(0x72747920u,0x6f662065u,0x78706c6fu,0x72657273u),\n  uvec4(0x2c202020u,0x20202061u,0x74207468u,0x65206578u),\n  uvec4(0x7472656du,0x69747920u,0x6f662074u,0x68656972u),\n  uvec4(0x20737472u,0x656e6774u,0x682c2068u,0x61642074u),\n  uvec4(0x68652063u,0x6f6e7374u,0x616e7420u,0x64656c75u),\n  uvec4(0x73696f6eu,0x20202020u,0x20207468u,0x61742074u),\n  uvec4(0x68657265u,0x20776173u,0x206f6e65u,0x206d6f72u),\n  uvec4(0x65206d65u,0x6d626572u,0x20746861u,0x6e20636fu),\n  uvec4(0x756c6420u,0x61637475u,0x616c6c79u,0x20626520u),\n  uvec4(0x636f756eu,0x7465642eu,0x20202020u,0x20202020u),\n  uvec4(0x20203336u,0x362d3736u,0x2e204366u,0x2e202048u),\n  uvec4(0x65726d61u,0x6e6e2048u,0x65737365u,0x2c20426cu),\n  uvec4(0x69636b20u,0x696e7320u,0x4368616fu,0x733a2020u),\n  uvec4(0x20202020u,0x20202020u,0x22536368u,0x6f6e2069u),\n  uvec4(0x73742068u,0x616c6220u,0x4575726fu,0x70612c20u),\n  uvec4(0x7363686fu,0x6e206973u,0x74207a75u,0x6d696e64u),\n  uvec4(0x65737420u,0x64657220u,0x68616c62u,0x65204f73u),\n  uvec4(0x74656e20u,0x20202020u,0x20457572u,0x6f706173u),\n  uvec4(0x20617566u,0x2064656du,0x20576567u,0x65207a75u),\n  uvec4(0x6d204368u,0x616f732cu,0x2066e468u,0x72742062u),\n  uvec4(0x65747275u,0x6e6b656eu,0x20696d20u,0x6865696cu),\n  uvec4(0x6967656du,0x20576168u,0x6e202020u,0x20202061u),\n  uvec4(0x6d204162u,0x6772756eu,0x6420656eu,0x746c616eu),\n  uvec4(0x6720756eu,0x64207369u,0x6e677420u,0x64617a75u),\n  uvec4(0x2c207369u,0x6e677420u,0x62657472u,0x756e6b65u),\n  uvec4(0x6e20756eu,0x64206879u,0x6d6e6973u,0x63682020u),\n  uvec4(0x20202020u,0x77696520u,0x446d6974u,0x7269204bu),\n  uvec4(0x6172616du,0x61736f66u,0x66207361u,0x6e672e20u),\n  uvec4(0x55656265u,0x72206469u,0x65736520u,0x4c696564u),\n  uvec4(0x6572206cu,0x61636874u,0x20646572u,0x2042fc72u),\n  uvec4(0x67657220u,0x20202020u,0x2062656cu,0x65696469u),\n  uvec4(0x67742c20u,0x64657220u,0x4865696cu,0x69676520u),\n  uvec4(0x756e6420u,0x53656865u,0x722068f6u,0x72742073u),\n  uvec4(0x6965206du,0x69742054u,0x72e46e65u,0x6e2e2220u),\n  uvec4(0x20202020u,0x20202020u,0x20343031u,0x2e202022u),\n  uvec4(0x44617474u,0x612c2064u,0x61796164u,0x6876616du),\n  uvec4(0x2c206461u,0x6d796174u,0x61222028u,0x47697665u),\n  uvec4(0x2c207379u,0x6d706174u,0x68697a65u,0x2c202020u),\n  uvec4(0x20202063u,0x6f6e7472u,0x6f6c292eu,0x20546865u),\n  uvec4(0x20666162u,0x6c65206fu,0x66207468u,0x65206d65u),\n  uvec4(0x616e696eu,0x67206f66u,0x20746865u,0x20546875u),\n  uvec4(0x6e646572u,0x20697320u,0x666f756eu,0x64202020u),\n  uvec4(0x20202069u,0x6e207468u,0x65204272u,0x69686164u),\n  uvec4(0x6172616eu,0x79616b61u,0x2d557061u,0x6e697368u),\n  uvec4(0x61642c20u,0x352c2031u,0x2e202041u,0x20747261u),\n  uvec4(0x6e736c61u,0x74696f6eu,0x20697320u,0x666f756eu),\n  uvec4(0x64202020u,0x20202069u,0x6e204465u,0x75737365u),\n  uvec4(0x6e277320u,0x53656368u,0x7a696720u,0x5570616eu),\n  uvec4(0x69736861u,0x64732064u,0x65732056u,0x6564612cu),\n  uvec4(0x20702e20u,0x20343839u,0x2e202020u,0x20202020u),\n  uvec4(0x20202034u,0x30372e20u,0x2043662eu,0x20205765u),\n  uvec4(0x62737465u,0x722c2054u,0x68652057u,0x68697465u),\n  uvec4(0x20446576u,0x696c2c20u,0x762e2020u,0x76693a20u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20222e20u,0x2e202e20u),\n  uvec4(0x74686579u,0x276c6c20u,0x72656d61u,0x72727920u),\n  uvec4(0x20202020u,0x45726520u,0x74686520u,0x776f726du),\n  uvec4(0x20706965u,0x72636520u,0x796f7572u,0x2077696eu),\n  uvec4(0x64696e67u,0x2d736865u,0x65742c20u,0x65726520u),\n  uvec4(0x74686520u,0x73706964u,0x65722020u,0x2020204du),\n  uvec4(0x616b6520u,0x61207468u,0x696e2063u,0x75727461u),\n  uvec4(0x696e2066u,0x6f722079u,0x6f757220u,0x65706974u),\n  uvec4(0x61706873u,0x2e222020u,0x20202020u,0x20202020u),\n  uvec4(0x3431312eu,0x20204366u,0x2e202049u,0x6e666572u),\n  uvec4(0x6e6f2c20u,0x78787869u,0x69692e20u,0x2034363au),\n  uvec4(0x20202020u,0x20202020u,0x20202020u,0x20202020u),\n  uvec4(0x22656420u,0x696f2073u,0x656e7469u,0x69206368u),\n  uvec4(0x69617661u,0x72206c27u,0x75736369u,0x6f206469u),\n  uvec4(0x20736f74u,0x746f2020u,0x20202020u,0x20202020u),\n  uvec4(0x2020616cu,0x6c276f72u,0x72696269u,0x6c652074u),\n  uvec4(0x6f727265u,0x2e222020u,0x20202020u,0x20202020u),\n  uvec4(0x416c736fu,0x20462e20u,0x482e2042u,0x7261646cu),\n  uvec4(0x65792c20u,0x41707065u,0x6172616eu,0x63652061u),\n  uvec4(0x6e642052u,0x65616c69u,0x74792c20u,0x702e2020u),\n  uvec4(0x3334363au,0x20202020u,0x20202020u,0x2020224du),\n  uvec4(0x79206578u,0x7465726eu,0x616c2073u,0x656e7361u),\n  uvec4(0x74696f6eu,0x73206172u,0x65206e6fu,0x206c6573u),\n  uvec4(0x73207072u,0x69766174u,0x6520746fu,0x206d7973u),\n  uvec4(0x656c6620u,0x7468616eu,0x20617265u,0x206d7920u),\n  uvec4(0x20202020u,0x2074686fu,0x75676874u,0x73206f72u),\n  uvec4(0x206d7920u,0x6665656cu,0x696e6773u,0x2e202049u),\n  uvec4(0x6e206569u,0x74686572u,0x20636173u,0x65206d79u),\n  uvec4(0x20657870u,0x65726965u,0x6e636520u,0x66616c6cu),\n  uvec4(0x73202020u,0x20202077u,0x69746869u,0x6e206d79u),\n  uvec4(0x206f776eu,0x20636972u,0x636c652cu,0x20612063u),\n  uvec4(0x6972636cu,0x6520636cu,0x6f736564u,0x206f6e20u),\n  uvec4(0x74686520u,0x6f757473u,0x6964653bu,0x20616e64u),\n  uvec4(0x2c207769u,0x74682020u,0x20202020u,0x616c6c20u),\n  uvec4(0x69747320u,0x656c656du,0x656e7473u,0x20616c69u),\n  uvec4(0x6b652c20u,0x65766572u,0x79207370u,0x68657265u),\n  uvec4(0x20697320u,0x6f706171u,0x75652074u,0x6f207468u),\n  uvec4(0x65206f74u,0x68657273u,0x20202020u,0x20207768u),\n  uvec4(0x69636820u,0x73757272u,0x6f756e64u,0x2069742eu),\n  uvec4(0x202e202eu,0x202e2049u,0x6e206272u,0x6965662cu),\n  uvec4(0x20726567u,0x61726465u,0x64206173u,0x20616e20u),\n  uvec4(0x65786973u,0x74656e63u,0x65207768u,0x69636820u),\n  uvec4(0x20202020u,0x20617070u,0x65617273u,0x20696e20u),\n  uvec4(0x6120736fu,0x756c2c20u,0x74686520u,0x77686f6cu),\n  uvec4(0x6520776fu,0x726c6420u,0x666f7220u,0x65616368u),\n  uvec4(0x20697320u,0x70656375u,0x6c696172u,0x20616e64u),\n  uvec4(0x20202020u,0x20207072u,0x69766174u,0x6520746fu),\n  uvec4(0x20746861u,0x7420736fu,0x756c2e22u,0x20202020u),\n  uvec4(0x20202020u,0x20203432u,0x342e2020u,0x562e2057u),\n  uvec4(0x6573746fu,0x6e2c2046u,0x726f6d20u,0x52697475u),\n  uvec4(0x616c2074u,0x6f20526fu,0x6d616e63u,0x653b2063u),\n  uvec4(0x68617074u,0x6572206fu,0x6e207468u,0x65204669u),\n  uvec4(0x73686572u,0x20202020u,0x20204b69u,0x6e672e20u),\n  uvec4(0x20202020u,0x20202020u,0x20343237u,0x2e202056u),\n  uvec4(0x2e202050u,0x75726761u,0x746f7269u,0x6f2c2078u),\n  uvec4(0x7876692eu,0x20203134u,0x382e2020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x20202227u,0x41726120u),\n  uvec4(0x766f7320u,0x70726563u,0x20706572u,0x20617175u),\n  uvec4(0x656c6c61u,0x2076616cu,0x6f722020u,0x20202020u),\n  uvec4(0x20202020u,0x20202027u,0x71756520u,0x766f7320u),\n  uvec4(0x67756964u,0x6120616cu,0x20736f6du,0x20646520u),\n  uvec4(0x6c276573u,0x63616c69u,0x6e612c20u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x27736f76u,0x65676e61u),\n  uvec4(0x20766f73u,0x20612074u,0x656d7073u,0x20646520u),\n  uvec4(0x6d612064u,0x6f6c6f72u,0x2e272020u,0x20202020u),\n  uvec4(0x20202020u,0x20202020u,0x506f6920u,0x73276173u),\n  uvec4(0x636f7365u,0x206e656cu,0x20666f63u,0x6f206368u),\n  uvec4(0x6520676cu,0x69206166u,0x66696e61u,0x2e222020u),\n  uvec4(0x20202020u,0x20202020u,0x3432382eu,0x2020562eu),\n  uvec4(0x20205065u,0x72766967u,0x696c6975u,0x6d205665u),\n  uvec4(0x6e657269u,0x732e2020u,0x43662e20u,0x20506869u),\n  uvec4(0x6c6f6d65u,0x6c612069u,0x6e205061u,0x72747320u),\n  uvec4(0x49492061u,0x6e642020u,0x20202020u,0x4949492eu),\n  uvec4(0x20202020u,0x20202020u,0x20203432u,0x392e2020u),\n  uvec4(0x562e2047u,0x65726172u,0x64206465u,0x204e6572u),\n  uvec4(0x76616c2cu,0x20536f6eu,0x6e657420u,0x456c2044u),\n  uvec4(0x65736469u,0x63686164u,0x6f2e2020u,0x20202020u),\n  uvec4(0x20202020u,0x3433312eu,0x2020562eu,0x204b7964u),\n  uvec4(0x27732053u,0x70616e69u,0x73682054u,0x72616765u),\n  uvec4(0x64792e20u,0x20202020u,0x20202020u,0x20343333u),\n  uvec4(0x2e202053u,0x68616e74u,0x69682e20u,0x20526570u),\n  uvec4(0x65617465u,0x64206173u,0x20686572u,0x652c2061u),\n  uvec4(0x20666f72u,0x6d616c20u,0x656e6469u,0x6e672074u),\n  uvec4(0x6f20616eu,0x20202020u,0x20205570u,0x616e6973u),\n  uvec4(0x6861642eu,0x20275468u,0x65205065u,0x61636520u),\n  uvec4(0x77686963u,0x68207061u,0x73736574u,0x6820756eu),\n  uvec4(0x64657273u,0x74616e64u,0x696e6727u,0x20697320u),\n  uvec4(0x61206665u,0x65626c65u,0x20202020u,0x20207472u),\n  uvec4(0x616e736cu,0x6174696fu,0x6e206f66u,0x20746865u),\n  uvec4(0x20636f6eu,0x74656e74u,0x206f6620u,0x74686973u),\n  uvec4(0x20776f72u,0x642e0000u,0x00000000u,0x00000000u)\n);\nconst int[] lines = int[](\n  0,20,20,40,40,40,40,40,40,48,52,85,89,116,120,148,\n  152,178,182,214,218,251,251,251,251,251,300,354,409,409,432,458,\n  458,458,458,458,489,489,489,529,566,595,625,656,690,724,777,830,\n  906,949,1006,1061,1101,1140,1181,1221,1277,1277,1329,1405,1450,1497,1557,1600,\n  1638,1684,1737,1781,1828,1904,1931,1951,1975,1996,2038,2075,2133,2181,2223,2299,\n  2346,2371,2371,2411,2441,2485,2531,2577,2623,2667,2743,2799,2850,2904,2948,2986,\n  3036,3079,3119,3155,3155,3231,3270,3315,3360,3404,3450,3500,3545,3593,3652,3728,\n  3780,3831,3876,3927,3970,4031,4031,4031,4031,4031,4056,4056,4056,4104,4143,4192,\n  4268,4308,4356,4392,4436,4480,4518,4571,4620,4673,4749,4792,4831,4878,4909,4965,\n  5008,5048,5095,5142,5219,5264,5315,5341,5376,5417,5466,5500,5548,5576,5653,5653,\n  5707,5753,5802,5848,5848,5879,5917,5917,5940,5995,6046,6123,6194,6250,6262,6262,\n  6277,6315,6372,6445,6480,6497,6574,6615,6662,6714,6740,6800,6840,6876,6938,6938,\n  6981,7058,7085,7139,7201,7251,7300,7348,7404,7461,7521,7598,7667,7694,7748,7790,\n  7849,7903,7931,7980,8032,8109,8180,8212,8273,8327,8354,8413,8476,8503,8530,8607,\n  8635,8710,8710,8710,8710,8710,8736,8736,8736,8790,8835,8894,8941,8993,9046,9109,\n  9186,9221,9271,9317,9374,9413,9475,9518,9556,9595,9672,9713,9760,9803,9847,9894,\n  9935,9985,10024,10064,10141,10177,10229,10229,10245,10270,10289,10296,10296,10309,10347,10383,\n  10460,10496,10524,10564,10605,10605,10649,10705,10737,10793,10840,10917,10965,11023,11062,11099,\n  11156,11199,11243,11283,11329,11406,11447,11498,11537,11579,11623,11667,11705,11748,11791,11868,\n  11902,11940,11979,12015,12056,12099,12136,12188,12188,12232,12309,12360,12409,12448,12484,12527,\n  12565,12565,12607,12656,12691,12768,12805,12846,12893,12916,12966,12966,12989,13007,13030,13058,\n  13135,13146,13189,13211,13231,13258,13287,13312,13340,13370,13447,13474,13495,13514,13536,13562,\n  13583,13609,13633,13652,13729,13757,13757,13782,13818,13859,13900,13900,13940,13972,14009,14052,\n  14129,14144,14167,14207,14243,14254,14266,14266,14291,14291,14324,14353,14430,14430,14443,14443,\n  14443,14443,14443,14467,14467,14467,14510,14559,14585,14647,14698,14741,14766,14821,14898,14960,\n  14960,14960,14960,14960,14990,14990,14990,15032,15073,15106,15135,15172,15217,15248,15282,15359,\n  15359,15391,15429,15473,15516,15562,15605,15644,15687,15742,15819,15863,15901,15946,15984,16017,\n  16095,16108,16128,16144,16221,16231,16254,16293,16309,16332,16364,16413,16449,16472,16472,16519,\n  16596,16637,16685,16726,16766,16811,16811,16847,16879,16917,16966,17043,17080,17129,17145,17174,\n  17189,17197,17197,17241,17285,17331,17408,17457,17493,17541,17604,17604,17646,17692,17735,17785,\n  17826,17903,17938,17961,18004,18019,18019,18058,18099,18137,18178,18202,18279,18307,18342,18384,\n  18428,18469,18513,18561,18606,18626,18703,18736,18778,18819,18864,18902,18943,18947,18976,19021,\n  19098,19137,19159,19159,19218,19258,19299,19356,19394,19440,19480,19557,19604,19632,19690,19690,\n  19721,19752,19752,19752,19752,19752,19783,19783,19783,19844,19915,19978,20044,20112,20181,20243,\n  20310,20379,20448,20517,20584,20639,20643,20674,20678,20711,20715,20749,20753,20802,20806,20836,\n  20840,20909,20977,21043,21112,21180,21247,21316,21379,21446,21514,21544,21548,21575,21579,21579,\n  21628,21689,21725,21729,21729,21782,21826,21872,21907,21911,21911,21952,21996,22043,22094,22098,\n  22149,22153,22204,22208,22234,22238,22292,22296,22338,22342,22342,22384,22438,22499,22503,22552,\n  22556,22590,22594,22628,22632,22692,22696,22731,22735,22804,22808,22835,22839,22876,22880,22917,\n  22921,22967,22971,23012,23016,23016,23070,23125,23164,23217,23284,23353,23357,23391,23395,23466,\n  23534,23585,23589,23652,23674,23678,23742,23809,23877,23948,24019,24090,24159,24212,24216,24216,\n  24275,24333,24384,24439,24484,24531,24580,24624,24679,24731,24787,24837,24885,24934,24979,25024,\n  25083,25131,25186,25186,25255,25320,25336,25340,25401,25405,25443,25447,25513,25582,25639,25643,\n  25708,25764,25821,25825,25889,25921,25925,25994,26063,26134,26205,26260,26264,26301,26305,26305,\n  26345,26389,26395,26459,26530,26534,26598,26668,26739,26802,26869,26899,26903,26971,27040,27110,\n  27114,27144,27148,27208,27272,27343,27347,27414,27483,27552,27613,27683,27745,27794,27798,27867,\n  27934,28001,28068,28136,28140,28190,28194,28259,28329,28398,28467,28527,28531,28589,28653,28721,\n  28777,28781,28831,28835,28835,28911,28970,29018,29056,29060,29060,29110,29146,29204,29208,29279,\n  29345,29414,29480,29551,29616,29644,29648,29716,29727,29731,29770,29774,29774,29818,29867,29914,\n  29970,30038,30048,30052,30106,30110,30147,30151,30212,30280,30326\n);\n#else\nconst uvec4 data[] = uvec4[](\n  uvec4(0x4c455320u,0x464c4555u,0x52532044u,0x55204d41u),\n  uvec4(0x4c706172u,0x43484152u,0x4c455320u,0x42415544u),\n  uvec4(0x454c4149u,0x52454155u,0x204c4543u,0x54455552u),\n  uvec4(0x20204c61u,0x20736f74u,0x74697365u,0x2c206c27u),\n  uvec4(0x65727265u,0x75722c20u,0x6c652070u,0xe96368e9u),\n  uvec4(0x2c206c61u,0x206ce973u,0x696e652cu,0x20204f63u),\n  uvec4(0x63757065u,0x6e74206eu,0x6f732065u,0x73707269u),\n  uvec4(0x74732065u,0x74207472u,0x61766169u,0x6c6c656eu),\n  uvec4(0x74206e6fu,0x7320636fu,0x7270732cu,0x20204574u),\n  uvec4(0x206e6f75u,0x7320616cu,0x696d656eu,0x746f6e73u),\n  uvec4(0x206e6f73u,0x2061696du,0x61626c65u,0x73207265u),\n  uvec4(0x6d6f7264u,0x732c2020u,0x436f6d6du,0x65206c65u),\n  uvec4(0x73206d65u,0x6e646961u,0x6e747320u,0x6e6f7572u),\n  uvec4(0x72697373u,0x656e7420u,0x6c657572u,0x20766572u),\n  uvec4(0x6d696e65u,0x2e20204eu,0x6f732070u,0xe96368e9u),\n  uvec4(0x7320736fu,0x6e742074u,0xea747573u,0x2c206e6fu),\n  uvec4(0x73207265u,0x70656e74u,0x69727320u,0x736f6e74u),\n  uvec4(0x206ce263u,0x6865732cu,0x20204e6fu,0x7573206eu),\n  uvec4(0x6f757320u,0x66616973u,0x6f6e7320u,0x70617965u),\n  uvec4(0x72206772u,0x61737365u,0x6d656e74u,0x206e6f73u),\n  uvec4(0x20617665u,0x75782c20u,0x20457420u,0x6e6f7573u),\n  uvec4(0x2072656eu,0x74726f6eu,0x73206761u,0xee6d656eu),\n  uvec4(0x74206461u,0x6e73206cu,0x65206368u,0x656d696eu),\n  uvec4(0x20626f75u,0x72626575u,0x782c2020u,0x43726f79u),\n  uvec4(0x616e7420u,0x70617220u,0x64652076u,0x696c7320u),\n  uvec4(0x706c6575u,0x7273206cu,0x61766572u,0x20746f75u),\n  uvec4(0x74657320u,0x6e6f7320u,0x74616368u,0x65732e20u),\n  uvec4(0x20537572u,0x206c276fu,0x7265696cu,0x6c657220u),\n  uvec4(0x6475206du,0x616c2063u,0x27657374u,0x20536174u),\n  uvec4(0x616e2054u,0x7269736du,0xe9676973u,0x74652020u),\n  uvec4(0x51756920u,0x62657263u,0x65206c6fu,0x6e677565u),\n  uvec4(0x6d656e74u,0x206e6f74u,0x72652065u,0x73707269u),\n  uvec4(0x7420656eu,0x6368616eu,0x74e92c20u,0x20457420u),\n  uvec4(0x6c652072u,0x69636865u,0x206de974u,0x616c2064u),\n  uvec4(0x65206e6fu,0x74726520u,0x766f6c6fu,0x6e74e920u),\n  uvec4(0x20457374u,0x20746f75u,0x74207661u,0x706f7269u),\n  uvec4(0x73e92070u,0x61722063u,0x65207361u,0x76616e74u),\n  uvec4(0x20636869u,0x6d697374u,0x652e2020u,0x43276573u),\n  uvec4(0x74206c65u,0x20446961u,0x626c6520u,0x71756920u),\n  uvec4(0x7469656eu,0x74206c65u,0x73206669u,0x6c732071u),\n  uvec4(0x7569206eu,0x6f757320u,0x72656d75u,0x656e7421u),\n  uvec4(0x20204175u,0x78206f62u,0x6a657473u,0x2072e970u),\n  uvec4(0x75676e61u,0x6e747320u,0x6e6f7573u,0x2074726fu),\n  uvec4(0x75766f6eu,0x73206465u,0x73206170u,0x7061733bu),\n  uvec4(0x20204368u,0x61717565u,0x206a6f75u,0x72207665u),\n  uvec4(0x7273206cu,0x27456e66u,0x6572206eu,0x6f757320u),\n  uvec4(0x64657363u,0x656e646fu,0x6e732064u,0x27756e20u),\n  uvec4(0x7061732cu,0x20205361u,0x6e732068u,0x6f727265u),\n  uvec4(0x75722c20u,0xe0207472u,0x61766572u,0x73206465u),\n  uvec4(0x732074e9u,0x6ee86272u,0x65732071u,0x75692070u),\n  uvec4(0x75656e74u,0x2e202041u,0x696e7369u,0x20717527u),\n  uvec4(0x756e2064u,0xe9626175u,0x6368e920u,0x70617576u),\n  uvec4(0x72652071u,0x75692062u,0x61697365u,0x20657420u),\n  uvec4(0x6d616e67u,0x6520204cu,0x65207365u,0x696e206du),\n  uvec4(0x61727479u,0x726973e9u,0x20642775u,0x6e652061u),\n  uvec4(0x6e746971u,0x75652063u,0x6174696eu,0x2c20204eu),\n  uvec4(0x6f757320u,0x766f6c6fu,0x6e732061u,0x75207061u),\n  uvec4(0x73736167u,0x6520756eu,0x20706c61u,0x69736972u),\n  uvec4(0x20636c61u,0x6e646573u,0x74696e20u,0x20517565u),\n  uvec4(0x206e6f75u,0x73207072u,0x6573736fu,0x6e732062u),\n  uvec4(0x69656e20u,0x666f7274u,0x20636f6du,0x6d652075u),\n  uvec4(0x6e652076u,0x6965696cu,0x6c65206fu,0x72616e67u),\n  uvec4(0x652e2020u,0x53657272u,0xe92c2066u,0x6f75726du),\n  uvec4(0x696c6c61u,0x6e742c20u,0x636f6d6du,0x6520756eu),\n  uvec4(0x206d696cu,0x6c696f6eu,0x20642768u,0x656c6d69u),\n  uvec4(0x6e746865u,0x732c2020u,0x44616e73u,0x206e6f73u),\n  uvec4(0x20636572u,0x76656175u,0x78207269u,0x626f7465u),\n  uvec4(0x20756e20u,0x70657570u,0x6c652064u,0x652044e9u),\n  uvec4(0x6d6f6e73u,0x2c202045u,0x742c2071u,0x75616e64u),\n  uvec4(0x206e6f75u,0x73207265u,0x73706972u,0x6f6e732cu),\n  uvec4(0x206c6120u,0x4d6f7274u,0x2064616eu,0x73206e6fu),\n  uvec4(0x7320706fu,0x756d6f6eu,0x73202044u,0x65736365u),\n  uvec4(0x6e642c20u,0x666c6575u,0x76652069u,0x6e766973u),\n  uvec4(0x69626c65u,0x2c206176u,0x65632064u,0x6520736fu),\n  uvec4(0x75726465u,0x7320706cu,0x61696e74u,0x65732e20u),\n  uvec4(0x20536920u,0x6c652076u,0x696f6c2cu,0x206c6520u),\n  uvec4(0x706f6973u,0x6f6e2c20u,0x6c652070u,0x6f69676eu),\n  uvec4(0x6172642cu,0x206c2769u,0x6e63656eu,0x6469652cu),\n  uvec4(0x20204e27u,0x6f6e7420u,0x70617320u,0x656e636fu),\n  uvec4(0x72652062u,0x726f64e9u,0x20646520u,0x6c657572u),\n  uvec4(0x7320706cu,0x61697361u,0x6e747320u,0x64657373u),\n  uvec4(0x65696e73u,0x20204c65u,0x2063616eu,0x65766173u),\n  uvec4(0x2062616eu,0x616c2064u,0x65206e6fu,0x73207069u),\n  uvec4(0x74657578u,0x20646573u,0x74696e73u,0x2c202043u),\n  uvec4(0x27657374u,0x20717565u,0x206e6f74u,0x726520e2u),\n  uvec4(0x6d652c20u,0x68e96c61u,0x7321206eu,0x27657374u),\n  uvec4(0x20706173u,0x20617373u,0x657a2068u,0x61726469u),\n  uvec4(0x652e2020u,0x4d616973u,0x20706172u,0x6d69206cu),\n  uvec4(0x65732063u,0x68616361u,0x6c732c20u,0x6c657320u),\n  uvec4(0x70616e74u,0x68e87265u,0x732c206cu,0x6573206cu),\n  uvec4(0x69636573u,0x2c20204cu,0x65732073u,0x696e6765u),\n  uvec4(0x732c206cu,0x65732073u,0x636f7270u,0x696f6e73u),\n  uvec4(0x2c206c65u,0x73207661u,0x75746f75u,0x72732c20u),\n  uvec4(0x6c657320u,0x73657270u,0x656e7473u,0x2c20204cu),\n  uvec4(0x6573206du,0x6f6e7374u,0x72657320u,0x676c6170u),\n  uvec4(0x69737361u,0x6e74732cu,0x20687572u,0x6c616e74u),\n  uvec4(0x732c2067u,0x726f676eu,0x616e7473u,0x2c207261u),\n  uvec4(0x6d70616eu,0x74732020u,0x44616e73u,0x206c6120u),\n  uvec4(0x6de96e61u,0x67657269u,0x6520696eu,0x66e26d65u),\n  uvec4(0x20646520u,0x6e6f7320u,0x76696365u,0x732c2020u),\n  uvec4(0x496c2065u,0x6e206573u,0x7420756eu,0x20706c75u),\n  uvec4(0x73206c61u,0x69642c20u,0x706c7573u,0x206de963u),\n  uvec4(0x68616e74u,0x2c20706cu,0x75732069u,0x6d6d6f6eu),\n  uvec4(0x64652120u,0x2051756fu,0x69717527u,0x696c206eu),\n  uvec4(0x6520706fu,0x75737365u,0x206e6920u,0x6772616eu),\n  uvec4(0x64732067u,0x65737465u,0x73206e69u,0x20677261u),\n  uvec4(0x6e647320u,0x63726973u,0x2c202049u,0x6c206665u),\n  uvec4(0x72616974u,0x20766f6cu,0x6f6e7469u,0x65727320u),\n  uvec4(0x6465206cu,0x61207465u,0x72726520u,0x756e2064u),\n  uvec4(0xe9627269u,0x73202045u,0x74206461u,0x6e732075u),\n  uvec4(0x6e2062e2u,0x696c6c65u,0x6d656e74u,0x20617661u),\n  uvec4(0x6c657261u,0x6974206cu,0x65206d6fu,0x6e64653bu),\n  uvec4(0x20204327u,0x65737420u,0x6c27456eu,0x6e756921u),\n  uvec4(0x2d2d4c27u,0x6f65696cu,0x20636861u,0x7267e920u),\n  uvec4(0x6427756eu,0x20706c65u,0x75722069u,0x6e766f6cu),\n  uvec4(0x6f6e7461u,0x6972652cu,0x2020496cu,0x2072ea76u),\n  uvec4(0x65206427u,0xe9636861u,0x66617564u,0x7320656eu),\n  uvec4(0x2066756du,0x616e7420u,0x736f6e20u,0x686f756bu),\n  uvec4(0x612e2020u,0x5475206cu,0x6520636fu,0x6e6e6169u),\n  uvec4(0x732c206cu,0x65637465u,0x75722c20u,0x6365206du),\n  uvec4(0x6f6e7374u,0x72652064u,0xe96c6963u,0x61742c20u),\n  uvec4(0x202d2d48u,0x79706f63u,0x72697465u,0x206c6563u),\n  uvec4(0x74657572u,0x2c2d2d6du,0x6f6e2073u,0x656d626cu),\n  uvec4(0x61626c65u,0x2c2d2d6du,0x6f6e2066u,0x72e87265u),\n  uvec4(0x21202053u,0x504c4545u,0x4e204554u,0x204944c9u),\n  uvec4(0x414c2020u,0x42454e45u,0x44494354u,0x494f4e20u),\n  uvec4(0x204c6f72u,0x73717565u,0x2c207061u,0x7220756eu),\n  uvec4(0x2064e963u,0x72657420u,0x64657320u,0x70756973u),\n  uvec4(0x73616e63u,0x65732073u,0x757072eau,0x6d65732cu),\n  uvec4(0x20204c65u,0x20506fe8u,0x74652061u,0x70706172u),\n  uvec4(0x61ee7420u,0x656e2063u,0x65206d6fu,0x6e646520u),\n  uvec4(0x656e6e75u,0x79e92c20u,0x20536120u,0x6de87265u),\n  uvec4(0x20e9706fu,0x7576616eu,0x74e96520u,0x65742070u),\n  uvec4(0x6c65696eu,0x65206465u,0x20626c61u,0x737068e8u),\n  uvec4(0x6d657320u,0x20437269u,0x73706520u,0x73657320u),\n  uvec4(0x706f696eu,0x67732076u,0x65727320u,0x44696575u),\n  uvec4(0x2c207175u,0x69206c61u,0x20707265u,0x6e642065u),\n  uvec4(0x6e207069u,0x7469e93au,0x2020ab20u,0x41682120u),\n  uvec4(0x71756520u,0x6e276169u,0x2d6a6520u,0x6d697320u),\n  uvec4(0x62617320u,0x746f7574u,0x20756e20u,0x6e6f6575u),\n  uvec4(0x64206465u,0x20766970u,0xe8726573u,0x2c202050u),\n  uvec4(0x6c7574f4u,0x74207175u,0x65206465u,0x206e6f75u),\n  uvec4(0x72726972u,0x20636574u,0x74652064u,0xe9726973u),\n  uvec4(0x696f6e21u,0x20204d61u,0x75646974u,0x6520736fu),\n  uvec4(0x6974206cu,0x61206e75u,0x69742061u,0x75782070u),\n  uvec4(0x6c616973u,0x69727320u,0xe97068e9u,0x6de87265u),\n  uvec4(0x7320204fu,0xf9206d6fu,0x6e207665u,0x6e747265u),\n  uvec4(0x20612063u,0x6f6ee775u,0x206d6f6eu,0x20657870u),\n  uvec4(0x69617469u,0x6f6e2120u,0x20ab2050u,0x75697371u),\n  uvec4(0x75652074u,0x75206d27u,0x61732063u,0x686f6973u),\n  uvec4(0x69652065u,0x6e747265u,0x20746f75u,0x74657320u),\n  uvec4(0x6c657320u,0x66656d6du,0x65732020u,0x506f7572u),\n  uvec4(0x20ea7472u,0x65206c65u,0x2064e967u,0x6ffb7420u),\n  uvec4(0x6465206du,0x6f6e2074u,0x72697374u,0x65206d61u),\n  uvec4(0x72692c20u,0x20457420u,0x71756520u,0x6a65206eu),\n  uvec4(0x65207075u,0x69732070u,0x61732072u,0x656a6574u),\n  uvec4(0x65722064u,0x616e7320u,0x6c657320u,0x666c616du),\n  uvec4(0x6d65732cu,0x2020436fu,0x6d6d6520u,0x756e2062u),\n  uvec4(0x696c6c65u,0x74206427u,0x616d6f75u,0x722c2063u),\n  uvec4(0x65206d6fu,0x6e737472u,0x65207261u,0x626f7567u),\n  uvec4(0x72692c20u,0x20ab204au,0x65206665u,0x72616920u),\n  uvec4(0x72656a61u,0x696c6c69u,0x72206c61u,0x20686169u),\n  uvec4(0x6e652071u,0x7569206du,0x27616363u,0x61626c65u),\n  uvec4(0x20205375u,0x72206c27u,0x696e7374u,0x72756d65u),\n  uvec4(0x6e74206du,0x61756469u,0x74206465u,0x20746573u),\n  uvec4(0x206de963u,0x68616e63u,0x6574e973u,0x2c202045u),\n  uvec4(0x74206a65u,0x20746f72u,0x64726169u,0x20736920u),\n  uvec4(0x6269656eu,0x20636574u,0x20617262u,0x7265206du),\n  uvec4(0x6973e972u,0x61626c65u,0x2c202051u,0x7527696cu),\n  uvec4(0x206e6520u,0x706f7572u,0x72612070u,0x6f757373u),\n  uvec4(0x61207365u,0x7320626fu,0x75746f6eu,0x7320656du),\n  uvec4(0x70657374u,0xe9732120u,0xbb202045u,0x6c6c6520u),\n  uvec4(0x72617661u,0x6c652061u,0x696e7369u,0x206c27e9u),\n  uvec4(0x63756d65u,0x20646520u,0x73612068u,0x61696e65u),\n  uvec4(0x2c202045u,0x742c206eu,0x6520636fu,0x6d707265u),\n  uvec4(0x6e616e74u,0x20706173u,0x206c6573u,0x20646573u),\n  uvec4(0x7365696eu,0x7320e974u,0x65726e65u,0x6c732c20u),\n  uvec4(0x20456c6cu,0x652d6deau,0x6d652070u,0x72e97061u),\n  uvec4(0x72652061u,0x7520666fu,0x6e642064u,0x65206c61u),\n  uvec4(0x2047e968u,0x656e6e65u,0x20204c65u,0x732062fbu),\n  uvec4(0x63686572u,0x7320636fu,0x6e736163u,0x72e97320u),\n  uvec4(0x61757820u,0x6372696du,0x6573206du,0x61746572u),\n  uvec4(0x6e656c73u,0x2e202050u,0x6f757274u,0x616e742cu),\n  uvec4(0x20736f75u,0x73206c61u,0x20747574u,0x656c6c65u),\n  uvec4(0x20696e76u,0x69736962u,0x6c652064u,0x27756e20u),\n  uvec4(0x416e6765u,0x2c20204cu,0x27456e66u,0x616e7420u),\n  uvec4(0x64e97368u,0xe9726974u,0xe9207327u,0x656e6976u),\n  uvec4(0x72652064u,0x6520736fu,0x6c65696cu,0x2c202045u),\n  uvec4(0x74206461u,0x6e732074u,0x6f757420u,0x63652071u),\n  uvec4(0x7527696cu,0x20626f69u,0x74206574u,0x2064616eu),\n  uvec4(0x7320746fu,0x75742063u,0x65207175u,0x27696c20u),\n  uvec4(0x6d616e67u,0x65202052u,0x6574726fu,0x75766520u),\n  uvec4(0x6c27616du,0x62726f69u,0x73696520u,0x6574206cu),\n  uvec4(0x65206e65u,0x63746172u,0x20766572u,0x6d65696cu),\n  uvec4(0x2e202049u,0x6c206a6fu,0x75652061u,0x76656320u),\n  uvec4(0x6c652076u,0x656e742cu,0x20636175u,0x73652061u),\n  uvec4(0x76656320u,0x6c65206eu,0x75616765u,0x20204574u),\n  uvec4(0x20732765u,0x6e697672u,0x6520656eu,0x20636861u),\n  uvec4(0x6e74616eu,0x74206475u,0x20636865u,0x6d696e20u),\n  uvec4(0x6465206cu,0x61206372u,0x6f69783bu,0x20204574u),\n  uvec4(0x206c2745u,0x73707269u,0x74207175u,0x69206c65u),\n  uvec4(0x20737569u,0x74206461u,0x6e732073u,0x6f6e2070u),\n  uvec4(0xe86c6572u,0x696e6167u,0x65202050u,0x6c657572u),\n  uvec4(0x65206465u,0x206c6520u,0x766f6972u,0x20676169u),\n  uvec4(0x20636f6du,0x6d652075u,0x6e206f69u,0x73656175u),\n  uvec4(0x20646573u,0x20626f69u,0x732e2020u,0x546f7573u),\n  uvec4(0x20636575u,0x78207175u,0x27696c20u,0x76657574u),\n  uvec4(0x2061696du,0x6572206cu,0x276f6273u,0x65727665u),\n  uvec4(0x6e742061u,0x76656320u,0x63726169u,0x6e74652cu),\n  uvec4(0x20204f75u,0x20626965u,0x6e2c2073u,0x27656e68u),\n  uvec4(0x61726469u,0x7373616eu,0x74206465u,0x20736120u),\n  uvec4(0x7472616eu,0x7175696cu,0x6c6974e9u,0x2c202043u),\n  uvec4(0x68657263u,0x68656e74u,0x20e02071u,0x75692073u),\n  uvec4(0x61757261u,0x206c7569u,0x20746972u,0x65722075u),\n  uvec4(0x6e652070u,0x6c61696eu,0x74652c20u,0x20457420u),\n  uvec4(0x666f6e74u,0x20737572u,0x206c7569u,0x206c2765u),\n  uvec4(0x73736169u,0x20646520u,0x6c657572u,0x2066e972u),\n  uvec4(0x6f636974u,0xe92e2020u,0x44616e73u,0x206c6520u),\n  uvec4(0x7061696eu,0x20657420u,0x6c652076u,0x696e2064u),\n  uvec4(0x65737469u,0x6ee97320u,0xe0207361u,0x20626f75u),\n  uvec4(0x63686520u,0x20496c73u,0x206dea6cu,0x656e7420u),\n  uvec4(0x6465206cu,0x61206365u,0x6e647265u,0x20617665u),\n  uvec4(0x63206427u,0x696d7075u,0x72732063u,0x72616368u),\n  uvec4(0x6174733bu,0x20204176u,0x65632068u,0x79706f63u),\n  uvec4(0x72697369u,0x6520696cu,0x73206a65u,0x7474656eu),\n  uvec4(0x74206365u,0x20717527u,0x696c2074u,0x6f756368u),\n  uvec4(0x652c2020u,0x45742073u,0x27616363u,0x7573656eu),\n  uvec4(0x74206427u,0x61766f69u,0x72206d69u,0x73206c65u),\n  uvec4(0x75727320u,0x70696564u,0x73206461u,0x6e732073u),\n  uvec4(0x65732070u,0x61732e20u,0x20536120u,0x66656d6du),\n  uvec4(0x65207661u,0x20637269u,0x616e7420u,0x73757220u),\n  uvec4(0x6c657320u,0x706c6163u,0x65732070u,0x75626c69u),\n  uvec4(0x71756573u,0x3a2020abu,0x20507569u,0x73717527u),\n  uvec4(0x696c206du,0x65207472u,0x6f757665u,0x20617373u),\n  uvec4(0x657a2062u,0x656c6c65u,0x20706f75u,0x72206d27u),\n  uvec4(0x61646f72u,0x65722c20u,0x204a6520u,0x66657261u),\n  uvec4(0x69206c65u,0x206de974u,0x69657220u,0x64657320u),\n  uvec4(0x69646f6cu,0x65732061u,0x6e746971u,0x7565732cu),\n  uvec4(0x20204574u,0x20636f6du,0x6d652065u,0x6c6c6573u),\n  uvec4(0x206a6520u,0x76657578u,0x206d6520u,0x66616972u),\n  uvec4(0x65207265u,0x646f7265u,0x723b2020u,0xab204574u),\n  uvec4(0x206a6520u,0x6d652073u,0x6ffb6c65u,0x72616920u),\n  uvec4(0x6465206eu,0x6172642cu,0x20642765u,0x6e63656eu),\n  uvec4(0x732c2064u,0x65206d79u,0x72726865u,0x2c202044u),\n  uvec4(0x652067e9u,0x6e75666cu,0x6578696fu,0x6e732c20u),\n  uvec4(0x64652076u,0x69616e64u,0x65732065u,0x74206465u),\n  uvec4(0x2076696eu,0x732c2020u,0x506f7572u,0x20736176u),\n  uvec4(0x6f697220u,0x7369206au,0x65207075u,0x69732064u),\n  uvec4(0x616e7320u,0x756e2063u,0x6f657572u,0x20717569u),\n  uvec4(0x206d2761u,0x646d6972u,0x65202055u,0x73757270u),\n  uvec4(0x65722065u,0x6e207269u,0x616e7420u,0x6c657320u),\n  uvec4(0x686f6d6du,0x61676573u,0x20646976u,0x696e7321u),\n  uvec4(0x2020ab20u,0x45742c20u,0x7175616eu,0x64206a65u),\n  uvec4(0x206d2765u,0x6e6e75eeu,0x72616920u,0x64652063u),\n  uvec4(0x65732066u,0x61726365u,0x7320696du,0x70696573u),\n  uvec4(0x2c20204au,0x6520706fu,0x73657261u,0x69207375u),\n  uvec4(0x72206c75u,0x69206d61u,0x206672eau,0x6c652065u),\n  uvec4(0x7420666fu,0x72746520u,0x6d61696eu,0x3b202045u),\n  uvec4(0x74206d65u,0x73206f6eu,0x676c6573u,0x2c207061u),\n  uvec4(0x7265696cu,0x73206175u,0x78206f6eu,0x676c6573u),\n  uvec4(0x20646573u,0x20686172u,0x70696573u,0x2c202053u),\n  uvec4(0x6175726fu,0x6e74206au,0x75737175u,0x27e02073u),\n  uvec4(0x6f6e2063u,0x6f657572u,0x20736520u,0x66726179u),\n  uvec4(0x65722075u,0x6e206368u,0x656d696eu,0x2e2020abu),\n  uvec4(0x20436f6du,0x6d652075u,0x6e20746fu,0x7574206au),\n  uvec4(0x65756e65u,0x206f6973u,0x65617520u,0x71756920u),\n  uvec4(0x7472656du,0x626c6520u,0x65742071u,0x75692070u),\n  uvec4(0x616c7069u,0x74652c20u,0x204a2761u,0x72726163u),\n  uvec4(0x68657261u,0x69206365u,0x20636f65u,0x75722074u),\n  uvec4(0x6f757420u,0x726f7567u,0x65206465u,0x20736f6eu),\n  uvec4(0x20736569u,0x6e2c2020u,0x45742c20u,0x706f7572u),\n  uvec4(0x20726173u,0x73617369u,0x6572206du,0x612062eau),\n  uvec4(0x74652066u,0x61766f72u,0x6974652cu,0x20204a65u),\n  uvec4(0x206c6520u,0x6c756920u,0x6a657474u,0x65726169u),\n  uvec4(0x20706172u,0x20746572u,0x72652061u,0x76656320u),\n  uvec4(0x64e96461u,0x696e2120u,0xbb202056u,0x65727320u),\n  uvec4(0x6c652043u,0x69656c2cu,0x206ff920u,0x736f6e20u),\n  uvec4(0x6f65696cu,0x20766f69u,0x7420756eu,0x207472f4u),\n  uvec4(0x6e652073u,0x706c656eu,0x64696465u,0x2c20204cu),\n  uvec4(0x6520506fu,0xe8746520u,0x73657265u,0x696e206cu),\n  uvec4(0xe8766520u,0x73657320u,0x62726173u,0x20706965u),\n  uvec4(0x75782c20u,0x20457420u,0x6c657320u,0x76617374u),\n  uvec4(0x657320e9u,0x636c6169u,0x72732064u,0x6520736fu),\n  uvec4(0x6e206573u,0x70726974u,0x206c7563u,0x69646520u),\n  uvec4(0x204c7569u,0x2064e972u,0x6f62656eu,0x74206c27u),\n  uvec4(0x61737065u,0x63742064u,0x65732070u,0x6575706cu),\n  uvec4(0x65732066u,0x75726965u,0x75783a20u,0x20ab2053u),\n  uvec4(0x6f79657au,0x2062e96eu,0x692c206du,0x6f6e2044u),\n  uvec4(0x6965752cu,0x20717569u,0x20646f6eu,0x6e657a20u),\n  uvec4(0x6c612073u,0x6f756666u,0x72616e63u,0x65202043u),\n  uvec4(0x6f6d6d65u,0x20756e20u,0x64697669u,0x6e207265u),\n  uvec4(0x6de86465u,0x20e0206eu,0x6f732069u,0x6d707572u),\n  uvec4(0x6574e973u,0x2c202045u,0x7420636fu,0x6d6d6520u),\n  uvec4(0x6c61206du,0x65696c6cu,0x65757265u,0x20657420u),\n  uvec4(0x6c612070u,0x6c757320u,0x70757265u,0x20657373u),\n  uvec4(0x656e6365u,0x20205175u,0x69207072u,0xe9706172u),\n  uvec4(0x65206c65u,0x7320666fu,0x72747320u,0x61757820u),\n  uvec4(0x7361696eu,0x74657320u,0x766f6c75u,0x7074e973u),\n  uvec4(0x212020abu,0x204a6520u,0x73616973u,0x20717565u),\n  uvec4(0x20766f75u,0x73206761u,0x7264657au,0x20756e65u),\n  uvec4(0x20706c61u,0x63652061u,0x7520506fu,0xe8746520u),\n  uvec4(0x2044616eu,0x73206c65u,0x73207261u,0x6e677320u),\n  uvec4(0x6269656eu,0x68657572u,0x65757820u,0x64657320u),\n  uvec4(0x7361696eu,0x74657320u,0x4ce96769u,0x6f6e732cu),\n  uvec4(0x20204574u,0x20717565u,0x20766f75u,0x73206c27u),\n  uvec4(0x696e7669u,0x74657a20u,0xe0206c27u,0xe9746572u),\n  uvec4(0x6e656c6cu,0x652066eau,0x74652020u,0x44657320u),\n  uvec4(0x5472f46eu,0x65732c20u,0x64657320u,0x56657274u),\n  uvec4(0x75732c20u,0x64657320u,0x446f6d69u,0x6e617469u),\n  uvec4(0x6f6e732eu,0x2020ab20u,0x4a652073u,0x61697320u),\n  uvec4(0x71756520u,0x6c612064u,0x6f756c65u,0x75722065u),\n  uvec4(0x7374206cu,0x61206e6fu,0x626c6573u,0x73652075u),\n  uvec4(0x6e697175u,0x6520204fu,0xf9206e65u,0x206d6f72u),\n  uvec4(0x64726f6eu,0x74206a61u,0x6d616973u,0x206c6120u),\n  uvec4(0x74657272u,0x65206574u,0x206c6573u,0x20656e66u),\n  uvec4(0x6572732cu,0x20204574u,0x20717527u,0x696c2066u),\n  uvec4(0x61757420u,0x706f7572u,0x20747265u,0x73736572u),\n  uvec4(0x206d6120u,0x636f7572u,0x6f6e6e65u,0x206d7973u),\n  uvec4(0x74697175u,0x65202049u,0x6d706f73u,0x65722074u),\n  uvec4(0x6f757320u,0x6c657320u,0x74656d70u,0x73206574u),\n  uvec4(0x20746f75u,0x73206c65u,0x7320756eu,0x69766572u),\n  uvec4(0x732e2020u,0xab204d61u,0x6973206cu,0x65732062u),\n  uvec4(0x696a6f75u,0x78207065u,0x72647573u,0x20646520u),\n  uvec4(0x6c27616eu,0x74697175u,0x65205061u,0x6c6d7972u),\n  uvec4(0x652c2020u,0x4c657320u,0x6de97461u,0x75782069u),\n  uvec4(0x6e636f6eu,0x6e75732cu,0x206c6573u,0x20706572u),\n  uvec4(0x6c657320u,0x6465206cu,0x61206d65u,0x722c2020u),\n  uvec4(0x50617220u,0x766f7472u,0x65206d61u,0x696e206du),\n  uvec4(0x6f6e74e9u,0x732c206eu,0x6520706fu,0x75727261u),\n  uvec4(0x69656e74u,0x20706173u,0x20737566u,0x66697265u),\n  uvec4(0x20204120u,0x63652062u,0x65617520u,0x64696164u),\n  uvec4(0xe86d6520u,0xe9626c6fu,0x75697373u,0x616e7420u),\n  uvec4(0x65742063u,0x6c616972u,0x3b2020abu,0x20436172u),\n  uvec4(0x20696c20u,0x6e652073u,0x65726120u,0x66616974u),\n  uvec4(0x20717565u,0x20646520u,0x70757265u,0x206c756du),\n  uvec4(0x69e87265u,0x2c202050u,0x756973e9u,0x65206175u),\n  uvec4(0x20666f79u,0x65722073u,0x61696e74u,0x20646573u),\n  uvec4(0x20726179u,0x6f6e7320u,0x7072696du,0x69746966u),\n  uvec4(0x732c2020u,0x45742064u,0x6f6e7420u,0x6c657320u),\n  uvec4(0x79657578u,0x206d6f72u,0x74656c73u,0x2c206461u),\n  uvec4(0x6e73206cu,0x65757220u,0x73706c65u,0x6e646575u),\n  uvec4(0x7220656eu,0x7469e872u,0x652c2020u,0x4e652073u),\n  uvec4(0x6f6e7420u,0x71756520u,0x64657320u,0x6d69726fu),\n  uvec4(0x69727320u,0x6f627363u,0x75726369u,0x73206574u),\n  uvec4(0x20706c61u,0x696e7469u,0x66732120u,0xbb20204cu),\n  uvec4(0x27414c42u,0x4154524fu,0x53202053u,0x6f757665u),\n  uvec4(0x6e742c20u,0x706f7572u,0x20732761u,0x6d757365u),\n  uvec4(0x722c206cu,0x65732068u,0x6f6d6d65u,0x73206427u),\n  uvec4(0xe9717569u,0x70616765u,0x20205072u,0x656e6e65u),\n  uvec4(0x6e742064u,0x65732061u,0x6c626174u,0x726f732cu),\n  uvec4(0x20766173u,0x74657320u,0x6f697365u,0x61757820u),\n  uvec4(0x64657320u,0x6d657273u,0x2c202051u,0x75692073u),\n  uvec4(0x75697665u,0x6e742c20u,0x696e646fu,0x6c656e74u),\n  uvec4(0x7320636fu,0x6d706167u,0x6e6f6e73u,0x20646520u),\n  uvec4(0x766f7961u,0x67652c20u,0x204c6520u,0x6e617669u),\n  uvec4(0x72652067u,0x6c697373u,0x616e7420u,0x73757220u),\n  uvec4(0x6c657320u,0x676f7566u,0x66726573u,0x20616d65u),\n  uvec4(0x72732e20u,0x20412070u,0x65696e65u,0x206c6573u),\n  uvec4(0x206f6e74u,0x2d696c73u,0x2064e970u,0x6f73e973u),\n  uvec4(0x20737572u,0x206c6573u,0x20706c61u,0x6e636865u),\n  uvec4(0x732c2020u,0x51756520u,0x63657320u,0x726f6973u),\n  uvec4(0x20646520u,0x6c27617au,0x75722c20u,0x6d616c61u),\n  uvec4(0x64726f69u,0x74732065u,0x7420686fu,0x6e746575u),\n  uvec4(0x782c2020u,0x4c616973u,0x73656e74u,0x20706974u),\n  uvec4(0x65757365u,0x6d656e74u,0x206c6575u,0x72732067u),\n  uvec4(0x72616e64u,0x65732061u,0x696c6573u,0x20626c61u),\n  uvec4(0x6e636865u,0x73202043u,0x6f6d6d65u,0x20646573u),\n  uvec4(0x20617669u,0x726f6e73u,0x20747261u,0xee6e6572u),\n  uvec4(0x20e02063u,0xf474e920u,0x64276575u,0x782e2020u),\n  uvec4(0x43652076u,0x6f796167u,0x65757220u,0x61696ce9u),\n  uvec4(0x2c20636fu,0x6d6d6520u,0x696c2065u,0x73742067u),\n  uvec4(0x61756368u,0x65206574u,0x20766575u,0x6c652120u),\n  uvec4(0x204c7569u,0x2c206e61u,0x6775e872u,0x65207369u),\n  uvec4(0x20626561u,0x752c2071u,0x7527696cu,0x20657374u),\n  uvec4(0x20636f6du,0x69717565u,0x20657420u,0x6c616964u),\n  uvec4(0x2120204cu,0x27756e20u,0x61676163u,0x6520736fu),\n  uvec4(0x6e206265u,0x63206176u,0x65632075u,0x6e206272u),\n  uvec4(0xfb6c652du,0x67756575u,0x6c652c20u,0x204c2761u),\n  uvec4(0x75747265u,0x206d696du,0x652c2065u,0x6e20626fu),\n  uvec4(0x6974616eu,0x742c206cu,0x27696e66u,0x69726d65u),\n  uvec4(0x20717569u,0x20766f6cu,0x61697421u,0x20204c65u),\n  uvec4(0x20506fe8u,0x74652065u,0x73742073u,0x656d626cu),\n  uvec4(0x61626c65u,0x20617520u,0x7072696eu,0x63652064u),\n  uvec4(0x6573206eu,0x75e96573u,0x20205175u,0x69206861u),\n  uvec4(0x6e746520u,0x6c612074u,0x656d70eau,0x74652065u),\n  uvec4(0x74207365u,0x20726974u,0x20646520u,0x6c276172u),\n  uvec4(0x63686572u,0x3b202045u,0x78696ce9u,0x20737572u),\n  uvec4(0x206c6520u,0x736f6c20u,0x6175206du,0x696c6965u),\n  uvec4(0x75206465u,0x73206875u,0xe965732cu,0x20205365u),\n  uvec4(0x73206169u,0x6c657320u,0x64652067u,0xe9616e74u),\n  uvec4(0x206c2765u,0x6d70ea63u,0x68656e74u,0x20646520u),\n  uvec4(0x6d617263u,0x6865722eu,0x2020454cu,0x45564154u),\n  uvec4(0x494f4e20u,0x2041752du,0x64657373u,0x75732064u),\n  uvec4(0x657320e9u,0x74616e67u,0x732c2061u,0x752d6465u),\n  uvec4(0x73737573u,0x20646573u,0x2076616cu,0x6ce96573u),\n  uvec4(0x2c202044u,0x6573206du,0x6f6e7461u,0x676e6573u),\n  uvec4(0x2c206465u,0x7320626fu,0x69732c20u,0x64657320u),\n  uvec4(0x6e756167u,0x65732c20u,0x64657320u,0x6d657273u),\n  uvec4(0x2c202050u,0x61722064u,0x656ce020u,0x6c652073u),\n  uvec4(0x6f6c6569u,0x6c2c2070u,0x61722064u,0x656ce020u),\n  uvec4(0x6c657320u,0xe9746865u,0x72732c20u,0x20506172u),\n  uvec4(0x2064656cu,0xe0206c65u,0x7320636fu,0x6e66696eu),\n  uvec4(0x73206465u,0x73207370u,0x68e87265u,0x7320e974u),\n  uvec4(0x6f696ce9u,0x65732c20u,0x204d6f6eu,0x20657370u),\n  uvec4(0x7269742cu,0x20747520u,0x7465206du,0x65757320u),\n  uvec4(0x61766563u,0x20616769u,0x6c6974e9u,0x2c202045u),\n  uvec4(0x742c2063u,0x6f6d6d65u,0x20756e20u,0x626f6e20u),\n  uvec4(0x6e616765u,0x75722071u,0x75692073u,0x652070e2u),\n  uvec4(0x6d652064u,0x616e7320u,0x6c276f6eu,0x64652c20u),\n  uvec4(0x20547520u,0x73696c6cu,0x6f6e6e65u,0x73206761u),\n  uvec4(0xee6d656eu,0x74206c27u,0x696d6d65u,0x6e736974u),\n  uvec4(0xe9207072u,0x6f666f6eu,0x64652020u,0x41766563u),\n  uvec4(0x20756e65u,0x20696e64u,0x69636962u,0x6c652065u),\n  uvec4(0x74206de2u,0x6c652076u,0x6f6c7570u,0x74e92e20u),\n  uvec4(0x20456e76u,0x6f6c652du,0x746f6920u,0x6269656eu),\n  uvec4(0x206c6f69u,0x6e206465u,0x20636573u,0x206d6961u),\n  uvec4(0x736d6573u,0x206d6f72u,0x62696465u,0x732c2020u),\n  uvec4(0x56612074u,0x65207075u,0x72696669u,0x65722064u),\n  uvec4(0x616e7320u,0x6c276169u,0x72207375u,0x70e97269u),\n  uvec4(0x6575722cu,0x20204574u,0x20626f69u,0x732c2063u),\n  uvec4(0x6f6d6d65u,0x20756e65u,0x20707572u,0x65206574u),\n  uvec4(0x20646976u,0x696e6520u,0x6c697175u,0x6575722cu),\n  uvec4(0x20204c65u,0x20666575u,0x20636c61u,0x69722071u),\n  uvec4(0x75692072u,0x656d706cu,0x6974206cu,0x65732065u),\n  uvec4(0x73706163u,0x6573206cu,0x696d7069u,0x6465732eu),\n  uvec4(0x20204465u,0x727269e8u,0x7265206cu,0x65732065u),\n  uvec4(0x6e6e7569u,0x73206574u,0x206c6573u,0x20766173u),\n  uvec4(0x74657320u,0x63686167u,0x72696e73u,0x20205175u),\n  uvec4(0x69206368u,0x61726765u,0x6e742064u,0x65206c65u),\n  uvec4(0x75722070u,0x6f696473u,0x206c2765u,0x78697374u),\n  uvec4(0x656e6365u,0x20627275u,0x6d657573u,0x652c2020u),\n  uvec4(0x48657572u,0x65757820u,0x63656c75u,0x69207175u),\n  uvec4(0x69207065u,0x75742064u,0x27756e65u,0x2061696cu),\n  uvec4(0x65207669u,0x676f7572u,0x65757365u,0x20205327u),\n  uvec4(0xe96c616eu,0x63657220u,0x76657273u,0x206c6573u),\n  uvec4(0x20636861u,0x6d707320u,0x6c756d69u,0x6e657578u),\n  uvec4(0x20657420u,0x73657265u,0x696e7321u,0x20204365u),\n  uvec4(0x6c756920u,0x646f6e74u,0x206c6573u,0x2070656eu),\n  uvec4(0x73657273u,0x2c20636fu,0x6d6d6520u,0x64657320u),\n  uvec4(0x616c6f75u,0x65747465u,0x732c2020u,0x56657273u),\n  uvec4(0x206c6573u,0x20636965u,0x7578206cu,0x65206d61u),\n  uvec4(0x74696e20u,0x7072656eu,0x6e656e74u,0x20756e20u),\n  uvec4(0x6c696272u,0x65206573u,0x736f722cu,0x20202d2du),\n  uvec4(0x51756920u,0x706c616eu,0x65207375u,0x72206c61u),\n  uvec4(0x20766965u,0x20657420u,0x636f6d70u,0x72656e64u),\n  uvec4(0x2073616eu,0x73206566u,0x666f7274u,0x20204c65u),\n  uvec4(0x206c616eu,0x67616765u,0x20646573u,0x20666c65u),\n  uvec4(0x75727320u,0x65742064u,0x65732063u,0x686f7365u),\n  uvec4(0x73206d75u,0x65747465u,0x73212020u,0x4c455320u),\n  uvec4(0x50484152u,0x45532020u,0x52756265u,0x6e732c20u),\n  uvec4(0x666c6575u,0x76652064u,0x276f7562u,0x6c692c20u),\n  uvec4(0x6a617264u,0x696e2064u,0x65206c61u,0x20706172u),\n  uvec4(0x65737365u,0x2c20204fu,0x7265696cu,0x6c657220u),\n  uvec4(0x64652063u,0x68616972u,0x20667261u,0xee636865u),\n  uvec4(0x206ff920u,0x6c276f6eu,0x206e6520u,0x70657574u),\n  uvec4(0x2061696du,0x65722c20u,0x204d6169u,0x73206ff9u),\n  uvec4(0x206c6120u,0x76696520u,0x6166666cu,0x75652065u),\n  uvec4(0x74207327u,0x61676974u,0x65207361u,0x6e732063u),\n  uvec4(0x65737365u,0x2c202043u,0x6f6d6d65u,0x206c2761u),\n  uvec4(0x69722064u,0x616e7320u,0x6c652063u,0x69656c20u),\n  uvec4(0x6574206cu,0x61206d65u,0x72206461u,0x6e73206cu),\n  uvec4(0x61206d65u,0x723b2020u,0x4ce96f6eu,0x61726420u),\n  uvec4(0x64652056u,0x696e6369u,0x2c206d69u,0x726f6972u),\n  uvec4(0x2070726fu,0x666f6e64u,0x20657420u,0x736f6d62u),\n  uvec4(0x72652c20u,0x204ff920u,0x64657320u,0x616e6765u),\n  uvec4(0x73206368u,0x61726d61u,0x6e74732cu,0x20617665u),\n  uvec4(0x6320756eu,0x20646f75u,0x7820736fu,0x75726973u),\n  uvec4(0x2020546fu,0x75742063u,0x68617267u,0xe9206465u),\n  uvec4(0x206d7973u,0x74e87265u,0x2c206170u,0x70617261u),\n  uvec4(0x69737365u,0x6e7420e0u,0x206c276fu,0x6d627265u),\n  uvec4(0x20204465u,0x7320676cu,0x61636965u,0x72732065u),\n  uvec4(0x74206465u,0x73207069u,0x6e732071u,0x75692066u),\n  uvec4(0x65726d65u,0x6e74206cu,0x65757220u,0x70617973u),\n  uvec4(0x3b202052u,0x656d6272u,0x616e6474u,0x2c207472u),\n  uvec4(0x69737465u,0x2068f470u,0x6974616cu,0x20746f75u),\n  uvec4(0x74207265u,0x6d706c69u,0x20646520u,0x6d75726du),\n  uvec4(0x75726573u,0x2c202045u,0x74206427u,0x756e2067u),\n  uvec4(0x72616e64u,0x20637275u,0x63696669u,0x782064e9u),\n  uvec4(0x636f72e9u,0x20736575u,0x6c656d65u,0x6e742c20u),\n  uvec4(0x204ff920u,0x6c612070u,0x7269e872u,0x6520656eu),\n  uvec4(0x20706c65u,0x75727320u,0x73276578u,0x68616c65u),\n  uvec4(0x20646573u,0x206f7264u,0x75726573u,0x2c202045u),\n  uvec4(0x74206427u,0x756e2072u,0x61796f6eu,0x20642768u),\n  uvec4(0x69766572u,0x20747261u,0x76657273u,0xe9206272u),\n  uvec4(0x75737175u,0x656d656eu,0x743b2020u,0x4d696368u),\n  uvec4(0x656c2d41u,0x6e67652cu,0x206c6965u,0x75207661u),\n  uvec4(0x67756520u,0x6ff9206cu,0x276f6e20u,0x766f6974u),\n  uvec4(0x20646573u,0x20486572u,0x63756c65u,0x73202053u),\n  uvec4(0x65206deau,0x6c657220u,0xe0206465u,0x73204368u),\n  uvec4(0x72697374u,0x2c206574u,0x20736520u,0x6c657665u),\n  uvec4(0x7220746fu,0x75742064u,0x726f6974u,0x73202044u),\n  uvec4(0x65732066u,0x616e74f4u,0x6d657320u,0x70756973u),\n  uvec4(0x73616e74u,0x732c2071u,0x75692064u,0x616e7320u),\n  uvec4(0x6c657320u,0x6372e970u,0x75736375u,0x6c657320u),\n  uvec4(0x2044e963u,0x68697265u,0x6e74206cu,0x65757220u),\n  uvec4(0x73756169u,0x72652065u,0x6e20e974u,0x6972616eu),\n  uvec4(0x74206c65u,0x75727320u,0x646f6967u,0x74733b20u),\n  uvec4(0x20436f6cu,0xe8726573u,0x20646520u,0x626f7865u),\n  uvec4(0x75722c20u,0x696d7075u,0x64656e63u,0x65732064u),\n  uvec4(0x65206661u,0x756e652cu,0x2020546fu,0x69207175u),\n  uvec4(0x69207375u,0x73207261u,0x6d617373u,0x6572206cu),\n  uvec4(0x61206265u,0x617574e9u,0x20646573u,0x20676f75u),\n  uvec4(0x6a617473u,0x2c202047u,0x72616e64u,0x20636f65u),\n  uvec4(0x75722067u,0x6f6e666cu,0xe9206427u,0x6f726775u),\n  uvec4(0x65696c2cu,0x20686f6du,0x6d652064u,0xe962696cu),\n  uvec4(0x65206574u,0x206a6175u,0x6e652c20u,0x20507567u),\n  uvec4(0x65742c20u,0x6de96c61u,0x6e636f6cu,0x69717565u),\n  uvec4(0x20656d70u,0x65726575u,0x72206465u,0x7320666fu),\n  uvec4(0x72e76174u,0x733b2020u,0x57617474u,0x6561752cu),\n  uvec4(0x20636520u,0x6361726eu,0x6176616cu,0x206ff920u),\n  uvec4(0x6269656eu,0x20646573u,0x20636f65u,0x75727320u),\n  uvec4(0x696c6c75u,0x73747265u,0x732c2020u,0x436f6d6du),\n  uvec4(0x65206465u,0x73207061u,0x70696c6cu,0x6f6e732cu),\n  uvec4(0x20657272u,0x656e7420u,0x656e2066u,0x6c616d62u),\n  uvec4(0x6f79616eu,0x742c2020u,0x44e9636fu,0x72732066u),\n  uvec4(0x72616973u,0x20657420u,0x6ce96765u,0x727320e9u),\n  uvec4(0x636c6169u,0x72e97320u,0x70617220u,0x64657320u),\n  uvec4(0x6c757374u,0x72657320u,0x20517569u,0x20766572u),\n  uvec4(0x73656e74u,0x206c6120u,0x666f6c69u,0x6520e020u),\n  uvec4(0x63652062u,0x616c2074u,0x6f75726eu,0x6f79616eu),\n  uvec4(0x743b2020u,0x476f7961u,0x2c206361u,0x75636865u),\n  uvec4(0x6d617220u,0x706c6569u,0x6e206465u,0x2063686fu),\n  uvec4(0x73657320u,0x696e636fu,0x6e6e7565u,0x732c2020u),\n  uvec4(0x44652066u,0x6f657475u,0x73207175u,0x276f6e20u),\n  uvec4(0x66616974u,0x20637569u,0x72652061u,0x75206d69u),\n  uvec4(0x6c696575u,0x20646573u,0x20736162u,0x62617473u),\n  uvec4(0x2c202044u,0x65207669u,0x65696c6cu,0x65732061u),\n  uvec4(0x75206d69u,0x726f6972u,0x20657420u,0x6427656eu),\n  uvec4(0x66616e74u,0x7320746fu,0x75746573u,0x206e7565u),\n  uvec4(0x732c2020u,0x506f7572u,0x2074656eu,0x74657220u),\n  uvec4(0x6c657320u,0x44e96d6fu,0x6e732061u,0x6a757374u),\n  uvec4(0x616e7420u,0x6269656eu,0x206c6575u,0x72732062u),\n  uvec4(0x61733b20u,0x2044656cu,0x6163726fu,0x69782c20u),\n  uvec4(0x6c616320u,0x64652073u,0x616e6720u,0x68616e74u),\n  uvec4(0xe9206465u,0x73206d61u,0x75766169u,0x7320616eu),\n  uvec4(0x6765732cu,0x20204f6du,0x62726167u,0xe9207061u),\n  uvec4(0x7220756eu,0x20626f69u,0x73206465u,0x20736170u),\n  uvec4(0x696e2074u,0x6f756a6fu,0x75727320u,0x76657274u),\n  uvec4(0x2c20204fu,0xf92c2073u,0x6f757320u,0x756e2063u),\n  uvec4(0x69656c20u,0x63686167u,0x72696e2cu,0x20646573u),\n  uvec4(0x2066616eu,0x66617265u,0x7320e974u,0x72616e67u),\n  uvec4(0x65732020u,0x50617373u,0x656e742cu,0x20636f6du),\n  uvec4(0x6d652075u,0x6e20736fu,0x75706972u,0x20e9746fu),\n  uvec4(0x756666e9u,0x20646520u,0x57656265u,0x723b2020u),\n  uvec4(0x43657320u,0x6d616ce9u,0x64696374u,0x696f6e73u),\n  uvec4(0x2c206365u,0x7320626cu,0x61737068u,0xe86d6573u),\n  uvec4(0x2c206365u,0x7320706cu,0x61696e74u,0x65732c20u),\n  uvec4(0x20436573u,0x20657874u,0x61736573u,0x2c206365u),\n  uvec4(0x73206372u,0x69732c20u,0x63657320u,0x706c6575u),\n  uvec4(0x72732c20u,0x63657320u,0x5f546520u,0x4465756du),\n  uvec4(0x2c5f2020u,0x536f6e74u,0x20756e20u,0xe963686fu),\n  uvec4(0x20726564u,0x69742070u,0x6172206du,0x696c6c65u),\n  uvec4(0x206c6162u,0x7972696eu,0x74686573u,0x3b202043u),\n  uvec4(0x27657374u,0x20706f75u,0x72206c65u,0x7320636fu),\n  uvec4(0x65757273u,0x206d6f72u,0x74656c73u,0x20756e20u),\n  uvec4(0x64697669u,0x6e206f70u,0x69756d2eu,0x20204327u),\n  uvec4(0x65737420u,0x756e2063u,0x72692072u,0xe970e974u),\n  uvec4(0xe9207061u,0x72206d69u,0x6c6c6520u,0x73656e74u),\n  uvec4(0x696e656cu,0x6c65732cu,0x2020556eu,0x206f7264u),\n  uvec4(0x72652072u,0x656e766fu,0x79e92070u,0x6172206du),\n  uvec4(0x696c6c65u,0x20706f72u,0x74652d76u,0x6f69783bu),\n  uvec4(0x20204327u,0x65737420u,0x756e2070u,0x68617265u),\n  uvec4(0x20616c6cu,0x756de920u,0x73757220u,0x6d696c6cu),\n  uvec4(0x65206369u,0x74616465u,0x6c6c6573u,0x2c202055u),\n  uvec4(0x6e206170u,0x70656c20u,0x64652063u,0x68617373u),\n  uvec4(0x65757273u,0x20706572u,0x64757320u,0x64616e73u),\n  uvec4(0x206c6573u,0x20677261u,0x6e647320u,0x626f6973u),\n  uvec4(0x21202043u,0x61722063u,0x27657374u,0x20767261u),\n  uvec4(0x696d656eu,0x742c2053u,0x6569676eu,0x6575722cu),\n  uvec4(0x206c6520u,0x6d65696cu,0x6c657572u,0x2074e96du),\n  uvec4(0x6f69676eu,0x61676520u,0x20517565u,0x206e6f75u),\n  uvec4(0x73207075u,0x69737369u,0x6f6e7320u,0x646f6e6eu),\n  uvec4(0x65722064u,0x65206e6fu,0x74726520u,0x6469676eu),\n  uvec4(0x6974e920u,0x20517565u,0x20636574u,0x20617264u),\n  uvec4(0x656e7420u,0x73616e67u,0x6c6f7420u,0x71756920u),\n  uvec4(0x726f756cu,0x65206427u,0xe2676520u,0x656e20e2u),\n  uvec4(0x67652020u,0x45742076u,0x69656e74u,0x206d6f75u),\n  uvec4(0x72697220u,0x61752062u,0x6f726420u,0x64652076u),\n  uvec4(0x6f747265u,0x20e97465u,0x726e6974u,0xe9212020u),\n  uvec4(0x4c41204du,0x55534520u,0x56454e41u,0x4c452020u),\n  uvec4(0x4f204d75u,0x73652064u,0x65206d6fu,0x6e20636fu),\n  uvec4(0x6575722cu,0x20616d61u,0x6e746520u,0x64657320u),\n  uvec4(0x70616c61u,0x69732c20u,0x20417572u,0x61732d74u),\n  uvec4(0x752c2071u,0x75616e64u,0x204a616eu,0x76696572u),\n  uvec4(0x206ce263u,0x68657261u,0x20736573u,0x20426f72u),\n  uvec4(0xe965732cu,0x20204475u,0x72616e74u,0x206c6573u),\n  uvec4(0x206e6f69u,0x72732065u,0x6e6e7569u,0x73206465u),\n  uvec4(0x73206e65u,0x69676575u,0x73657320u,0x736f6972u),\n  uvec4(0xe965732cu,0x2020556eu,0x20746973u,0x6f6e2070u),\n  uvec4(0x6f757220u,0x63686175u,0x66666572u,0x20746573u),\n  uvec4(0x20646575u,0x78207069u,0x65647320u,0x76696f6cu),\n  uvec4(0x6574733fu,0x20205261u,0x6e696d65u,0x7261732du),\n  uvec4(0x74752064u,0x6f6e6320u,0x74657320u,0xe9706175u),\n  uvec4(0x6c657320u,0x6d617262u,0x72e96573u,0x20204175u),\n  uvec4(0x78206e6fu,0x63747572u,0x6e657320u,0x7261796fu),\n  uvec4(0x6e732071u,0x75692070u,0x65726365u,0x6e74206cu),\n  uvec4(0x65732076u,0x6f6c6574u,0x733f2020u,0x53656e74u),\n  uvec4(0x616e7420u,0x74612062u,0x6f757273u,0x6520e020u),\n  uvec4(0x73656320u,0x61757461u,0x6e742071u,0x75652074u),\n  uvec4(0x6f6e2070u,0x616c6169u,0x732c2020u,0x52e9636fu),\n  uvec4(0x6c746572u,0x61732d74u,0x75206c27u,0x6f722064u),\n  uvec4(0x65732076u,0x6ffb7465u,0x7320617au,0x7572e965u),\n  uvec4(0x733f2020u,0x496c2074u,0x65206661u,0x75742c20u),\n  uvec4(0x706f7572u,0x20676167u,0x6e657220u,0x746f6e20u),\n  uvec4(0x7061696eu,0x20646520u,0x63686171u,0x75652073u),\n  uvec4(0x6f69722cu,0x2020436fu,0x6d6d6520u,0x756e2065u),\n  uvec4(0x6e66616eu,0x74206465u,0x2063686fu,0x6575722cu),\n  uvec4(0x206a6f75u,0x65722064u,0x65206c27u,0x656e6365u),\n  uvec4(0x6e736f69u,0x722c2020u,0x4368616eu,0x74657320u),\n  uvec4(0x64657320u,0x5f546520u,0x4465756du,0x5f206175u),\n  uvec4(0x78717565u,0x6c732074u,0x75206e65u,0x2063726fu),\n  uvec4(0x69732067u,0x75e87265u,0x2c20204fu,0x752c2073u),\n  uvec4(0x616c7469u,0x6d62616eu,0x71756520u,0xe0206a65u),\n  uvec4(0x756e2c20u,0xe974616cu,0x6572206cu,0x65732061u),\n  uvec4(0x70706173u,0x20204574u,0x20746f6eu,0x20726972u),\n  uvec4(0x65207472u,0x656d70e9u,0x20646520u,0x706c6575u),\n  uvec4(0x72732071u,0x75276f6eu,0x206e6520u,0x766f6974u),\n  uvec4(0x20706173u,0x2c202050u,0x6f757220u,0x66616972u),\n  uvec4(0x6520e970u,0x616e6f75u,0x6972206cu,0x61207261u),\n  uvec4(0x74652064u,0x75207675u,0x6c676169u,0x72652e20u),\n  uvec4(0x204c2745u,0x4e4e454du,0x4920204du,0x61206a65u),\n  uvec4(0x756e6573u,0x7365206eu,0x65206675u,0x74207175u),\n  uvec4(0x27756e20u,0x74e96ee9u,0x62726575u,0x78206f72u),\n  uvec4(0x6167652cu,0x20205472u,0x61766572u,0x73e920e7u),\n  uvec4(0x61206574u,0x206ce020u,0x70617220u,0x64652062u),\n  uvec4(0x72696c6cu,0x616e7473u,0x20736f6cu,0x65696c73u),\n  uvec4(0x3b20204cu,0x6520746fu,0x6e6e6572u,0x72652065u),\n  uvec4(0x74206c61u,0x20706c75u,0x6965206fu,0x6e742066u),\n  uvec4(0x61697420u,0x756e2074u,0x656c2072u,0x61766167u),\n  uvec4(0x65202051u,0x7527696cu,0x20726573u,0x74652065u),\n  uvec4(0x6e206d6fu,0x6e206a61u,0x7264696eu,0x20626965u),\n  uvec4(0x6e207065u,0x75206465u,0x20667275u,0x69747320u),\n  uvec4(0x7665726du,0x65696c73u,0x2e202056u,0x6f696ce0u),\n  uvec4(0x20717565u,0x206a2761u,0x6920746fu,0x756368e9u),\n  uvec4(0x206c2761u,0x75746f6du,0x6e652064u,0x65732069u),\n  uvec4(0x64e96573u,0x2c202045u,0x74207175u,0x27696c20u),\n  uvec4(0x66617574u,0x20656d70u,0x6c6f7965u,0x72206c61u),\n  uvec4(0x2070656cu,0x6c652065u,0x74206c65u,0x732072e2u),\n  uvec4(0x74656175u,0x78202050u,0x6f757220u,0x72617373u),\n  uvec4(0x656d626cu,0x657220e0u,0x206e6575u,0x66206c65u),\n  uvec4(0x73207465u,0x72726573u,0x20696e6fu,0x6e64e965u),\n  uvec4(0x732c2020u,0x4ff9206cu,0x27656175u,0x20637265u),\n  uvec4(0x75736520u,0x64657320u,0x74726f75u,0x73206772u),\n  uvec4(0x616e6473u,0x20636f6du,0x6d652064u,0x65732074u),\n  uvec4(0x6f6d6265u,0x6175782eu,0x20204574u,0x20717569u),\n  uvec4(0x20736169u,0x74207369u,0x206c6573u,0x20666c65u),\n  uvec4(0x75727320u,0x6e6f7576u,0x656c6c65u,0x73207175u),\n  uvec4(0x65206a65u,0x2072ea76u,0x65202054u,0x726f7576u),\n  uvec4(0x65726f6eu,0x74206461u,0x6e732063u,0x6520736fu),\n  uvec4(0x6c206c61u,0x76e92063u,0x6f6d6d65u,0x20756e65u),\n  uvec4(0x206772e8u,0x76652020u,0x4c65206du,0x79737469u),\n  uvec4(0x71756520u,0x616c696du,0x656e7420u,0x71756920u),\n  uvec4(0x66657261u,0x6974206cu,0x65757220u,0x76696775u),\n  uvec4(0x6575723fu,0x20202d2du,0x4f20646fu,0x756c6575u),\n  uvec4(0x722120f4u,0x20646f75u,0x6c657572u,0x21204c65u),\n  uvec4(0x2054656du,0x7073206du,0x616e6765u,0x206c6120u),\n  uvec4(0x7669652cu,0x20204574u,0x206c276fu,0x62736375u),\n  uvec4(0x7220456eu,0x6e656d69u,0x20717569u,0x206e6f75u),\n  uvec4(0x7320726fu,0x6e676520u,0x6c652063u,0x6f657572u),\n  uvec4(0x20204475u,0x2073616eu,0x67207175u,0x65206e6fu),\n  uvec4(0x75732070u,0x6572646fu,0x6e732063u,0x726fee74u),\n  uvec4(0x20657420u,0x73652066u,0x6f727469u,0x66696521u),\n  uvec4(0x20204c41u,0x20564945u,0x20414e54u,0x45524945u),\n  uvec4(0x55524520u,0x204a2761u,0x69206c6fu,0x6e677465u),\n  uvec4(0x6d707320u,0x68616269u,0x74e92073u,0x6f757320u),\n  uvec4(0x64652076u,0x61737465u,0x7320706fu,0x72746971u),\n  uvec4(0x75657320u,0x20517565u,0x206c6573u,0x20736f6cu),\n  uvec4(0x65696c73u,0x206d6172u,0x696e7320u,0x74656967u),\n  uvec4(0x6e616965u,0x6e742064u,0x65206d69u,0x6c6c6520u),\n  uvec4(0x66657578u,0x2c202045u,0x74207175u,0x65206c65u),\n  uvec4(0x75727320u,0x6772616eu,0x64732070u,0x696c6965u),\n  uvec4(0x72732c20u,0x64726f69u,0x74732065u,0x74206d61u),\n  uvec4(0x6a657374u,0x75657578u,0x2c202052u,0x656e6461u),\n  uvec4(0x69656e74u,0x20706172u,0x65696c73u,0x2c206c65u),\n  uvec4(0x20736f69u,0x722c2061u,0x75782067u,0x726f7474u),\n  uvec4(0x65732062u,0x6173616cu,0x74697175u,0x65732e20u),\n  uvec4(0x204c6573u,0x20686f75u,0x6c65732cu,0x20656e20u),\n  uvec4(0x726f756cu,0x616e7420u,0x6c657320u,0x696d6167u),\n  uvec4(0x65732064u,0x65732063u,0x69657578u,0x2c20204du),\n  uvec4(0xea6c6169u,0x656e7420u,0x6427756eu,0x65206661u),\n  uvec4(0xe76f6e20u,0x736f6c65u,0x6e6e656cu,0x6c652065u),\n  uvec4(0x74206d79u,0x73746971u,0x75652020u,0x4c657320u),\n  uvec4(0x746f7574u,0x2d707569u,0x7373616eu,0x74732061u),\n  uvec4(0x63636f72u,0x64732064u,0x65206c65u,0x75722072u),\n  uvec4(0x69636865u,0x206d7573u,0x69717565u,0x20204175u),\n  uvec4(0x7820636fu,0x756c6575u,0x72732064u,0x7520636fu),\n  uvec4(0x75636861u,0x6e742072u,0x65666ce9u,0x74e92070u),\n  uvec4(0x6172206du,0x65732079u,0x6575782eu,0x20204327u),\n  uvec4(0x65737420u,0x6ce02071u,0x7565206au,0x27616920u),\n  uvec4(0x76e96375u,0x2064616eu,0x73206c65u,0x7320766fu),\n  uvec4(0x6c757074u,0xe9732063u,0x616c6d65u,0x732c2020u),\n  uvec4(0x4175206du,0x696c6965u,0x75206465u,0x206c2761u),\n  uvec4(0x7a75722cu,0x20646573u,0x20766167u,0x7565732cu),\n  uvec4(0x20646573u,0x2073706cu,0x656e6465u,0x75727320u),\n  uvec4(0x20457420u,0x64657320u,0x6573636cu,0x61766573u),\n  uvec4(0x206e7573u,0x2c20746fu,0x75742069u,0x6d7072e9u),\n  uvec4(0x676ee973u,0x2064276fu,0x64657572u,0x732c2020u),\n  uvec4(0x51756920u,0x6d652072u,0x61667261u,0xee636869u),\n  uvec4(0x73736169u,0x656e7420u,0x6c652066u,0x726f6e74u),\n  uvec4(0x20617665u,0x63206465u,0x73207061u,0x6c6d6573u),\n  uvec4(0x2c202045u,0x7420646fu,0x6e74206cu,0x27756e69u),\n  uvec4(0x71756520u,0x736f696eu,0x20e97461u,0x69742064u),\n  uvec4(0x27617070u,0x726f666fu,0x6e646972u,0x20204c65u),\n  uvec4(0x20736563u,0x72657420u,0x646f756cu,0x6f757265u),\n  uvec4(0x75782071u,0x7569206du,0x65206661u,0x69736169u),\n  uvec4(0x74206c61u,0x6e677569u,0x722e2020u,0x424f4845u),\n  uvec4(0x4d49454eu,0x5320454eu,0x20564f59u,0x41474520u),\n  uvec4(0x204c6120u,0x74726962u,0x75207072u,0x6f7068e9u),\n  uvec4(0x74697175u,0x65206175u,0x78207072u,0x756e656cu),\n  uvec4(0x6c657320u,0x61726465u,0x6e746573u,0x20204869u),\n  uvec4(0x65722073u,0x27657374u,0x206d6973u,0x6520656eu),\n  uvec4(0x20726f75u,0x74652c20u,0x656d706fu,0x7274616eu),\n  uvec4(0x74207365u,0x73207065u,0x74697473u,0x20205375u),\n  uvec4(0x7220736fu,0x6e20646fu,0x732c206fu,0x75206c69u),\n  uvec4(0x7672616eu,0x7420e020u,0x6c657572u,0x73206669u),\n  uvec4(0x65727320u,0x617070e9u,0x74697473u,0x20204c65u),\n  uvec4(0x207472e9u,0x736f7220u,0x746f756au,0x6f757273u),\n  uvec4(0x207072eau,0x74206465u,0x73206d61u,0x6d656c6cu),\n  uvec4(0x65732070u,0x656e6461u,0x6e746573u,0x2e20204cu),\n  uvec4(0x65732068u,0x6f6d6d65u,0x7320766fu,0x6e7420e0u),\n  uvec4(0x20706965u,0x6420736fu,0x7573206cu,0x65757273u),\n  uvec4(0x2061726du,0x6573206cu,0x75697361u,0x6e746573u),\n  uvec4(0x20204c65u,0x206c6f6eu,0x67206465u,0x73206368u),\n  uvec4(0x6172696fu,0x7473206fu,0xf9206c65u,0x73206c65u),\n  uvec4(0x75727320u,0x736f6e74u,0x20626c6fu,0x74746973u),\n  uvec4(0x2c202050u,0x726f6d65u,0x6e616e74u,0x20737572u),\n  uvec4(0x206c6520u,0x6369656cu,0x20646573u,0x20796575u),\n  uvec4(0x78206170u,0x70657361u,0x6e746973u,0x20205061u),\n  uvec4(0x72206c65u,0x206d6f72u,0x6e652072u,0x65677265u),\n  uvec4(0x74206465u,0x73206368u,0x696de872u,0x65732061u),\n  uvec4(0x6273656eu,0x7465732eu,0x20204475u,0x20666f6eu),\n  uvec4(0x64206465u,0x20736f6eu,0x2072e964u,0x75697420u),\n  uvec4(0x7361626cu,0x6f6e6e65u,0x75782c20u,0x6c652067u),\n  uvec4(0x72696c6cu,0x6f6e2c20u,0x204c6573u,0x20726567u),\n  uvec4(0x61726461u,0x6e742070u,0x61737365u,0x722c2072u),\n  uvec4(0x65646f75u,0x626c6520u,0x73612063u,0x68616e73u),\n  uvec4(0x6f6e3b20u,0x20437962u,0xe86c652cu,0x20717569u),\n  uvec4(0x206c6573u,0x2061696du,0x652c2061u,0x75676d65u),\n  uvec4(0x6e746520u,0x73657320u,0x76657264u,0x75726573u),\n  uvec4(0x2c202046u,0x61697420u,0x636f756cu,0x6572206cu),\n  uvec4(0x6520726fu,0x63686572u,0x20657420u,0x666c6575u),\n  uvec4(0x72697220u,0x6c652064u,0xe9736572u,0x74202044u),\n  uvec4(0x6576616eu,0x74206365u,0x7320766fu,0x79616765u),\n  uvec4(0x7572732cu,0x20706f75u,0x72206c65u,0x73717565u),\n  uvec4(0x6c732065u,0x7374206fu,0x75766572u,0x7420204cu),\n  uvec4(0x27656d70u,0x69726520u,0x66616d69u,0x6c696572u),\n  uvec4(0x20646573u,0x2074e96eu,0xe8627265u,0x73206675u),\n  uvec4(0x74757265u,0x732e2020u,0x4c27484fu,0x4d4d4520u),\n  uvec4(0x4554204cu,0x41204d45u,0x52202048u,0x6f6d6d65u),\n  uvec4(0x206c6962u,0x72652c20u,0x746f756au,0x6f757273u),\n  uvec4(0x20747520u,0x6368e972u,0x69726173u,0x206c6120u),\n  uvec4(0x6d657221u,0x20204c61u,0x206d6572u,0x20657374u),\n  uvec4(0x20746f6eu,0x206d6972u,0x6f69723bu,0x20747520u),\n  uvec4(0x636f6e74u,0x656d706cu,0x65732074u,0x6f6e20e2u),\n  uvec4(0x6d652020u,0x44616e73u,0x206c6520u,0x64e9726fu),\n  uvec4(0x756c656du,0x656e7420u,0x696e6669u,0x6e692064u),\n  uvec4(0x65207361u,0x206c616du,0x652c2020u,0x45742074u),\n  uvec4(0x6f6e2065u,0x73707269u,0x74206e27u,0x65737420u),\n  uvec4(0x70617320u,0x756e2067u,0x6f756666u,0x7265206du),\n  uvec4(0x6f696e73u,0x20616d65u,0x722e2020u,0x54752074u),\n  uvec4(0x6520706cu,0x61697320u,0xe020706cu,0x6f6e6765u),\n  uvec4(0x72206175u,0x20736569u,0x6e206465u,0x20746f6eu),\n  uvec4(0x20696d61u,0x67653b20u,0x20547520u,0x6c27656du),\n  uvec4(0x62726173u,0x73657320u,0x64657320u,0x79657578u),\n  uvec4(0x20657420u,0x64657320u,0x62726173u,0x2c206574u),\n  uvec4(0x20746f6eu,0x20636f65u,0x75722020u,0x53652064u),\n  uvec4(0x69737472u,0x61697420u,0x7175656cu,0x71756566u),\n  uvec4(0x6f697320u,0x64652073u,0x61207072u,0x6f707265u),\n  uvec4(0x2072756du,0x65757220u,0x20417520u,0x62727569u),\n  uvec4(0x74206465u,0x20636574u,0x74652070u,0x6c61696eu),\n  uvec4(0x74652069u,0x6e646f6du,0x70746162u,0x6c652065u),\n  uvec4(0x74207361u,0x75766167u,0x652e2020u,0x566f7573u),\n  uvec4(0x20ea7465u,0x7320746fu,0x7573206cu,0x65732064u),\n  uvec4(0x65757820u,0x74e96ee9u,0x62726575u,0x78206574u),\n  uvec4(0x20646973u,0x63726574u,0x732c2020u,0x486f6d6du),\n  uvec4(0x652c206eu,0x756c206eu,0x27612073u,0x6f6e64e9u),\n  uvec4(0x206c6520u,0x666f6e64u,0x20646520u,0x74657320u),\n  uvec4(0x6162ee6du,0x65733b20u,0x204f206du,0x65722c20u),\n  uvec4(0x6e756c20u,0x6e652063u,0x6f6e6e61u,0xee742074u),\n  uvec4(0x65732072u,0x69636865u,0x73736573u,0x20696e74u),\n  uvec4(0x696d6573u,0x2c202054u,0x616e7420u,0x766f7573u),\n  uvec4(0x20ea7465u,0x73206a61u,0x6c6f7578u,0x20646520u),\n  uvec4(0x67617264u,0x65722076u,0x6f732073u,0x65637265u),\n  uvec4(0x74732120u,0x20457420u,0x63657065u,0x6e64616eu),\n  uvec4(0x7420766fu,0x696ce020u,0x64657320u,0x7369e863u),\n  uvec4(0x6c657320u,0x696e6e6fu,0x6d627261u,0x626c6573u),\n  uvec4(0x20205175u,0x6520766fu,0x75732076u,0x6f757320u),\n  uvec4(0x636f6d62u,0x61747465u,0x7a207361u,0x6e732070u),\n  uvec4(0x697469e9u,0x206e6920u,0x72656d6fu,0x72642c20u),\n  uvec4(0x2054656cu,0x6c656d65u,0x6e742076u,0x6f757320u),\n  uvec4(0x61696d65u,0x7a206c65u,0x20636172u,0x6e616765u),\n  uvec4(0x20657420u,0x6c61206du,0x6f72742cu,0x20204f20u),\n  uvec4(0x6c757474u,0x65757273u,0x20e97465u,0x726e656cu),\n  uvec4(0x732c20f4u,0x206672e8u,0x72657320u,0x696d706cu),\n  uvec4(0x61636162u,0x6c657321u,0x2020444fu,0x4e204a55u),\n  uvec4(0x414e2041u,0x55582045u,0x4e464552u,0x53202051u),\n  uvec4(0x75616e64u,0x20646f6eu,0x204a7561u,0x6e206465u),\n  uvec4(0x7363656eu,0x64697420u,0x76657273u,0x206c276fu),\n  uvec4(0x6e646520u,0x736f7574u,0x65727261u,0x696e652cu),\n  uvec4(0x20204574u,0x206c6f72u,0x73717527u,0x696c2065u),\n  uvec4(0x75742064u,0x6f6e6ee9u,0x20736f6eu,0x206f626fu),\n  uvec4(0x6c6520e0u,0x20436861u,0x726f6e2cu,0x2020556eu),\n  uvec4(0x20736f6du,0x62726520u,0x6d656e64u,0x69616e74u),\n  uvec4(0x2c206c27u,0x6f65696cu,0x20666965u,0x7220636fu),\n  uvec4(0x6d6d6520u,0x416e7469u,0x737468e8u,0x6e652c20u),\n  uvec4(0x20442775u,0x6e206272u,0x61732076u,0x656e6765u),\n  uvec4(0x75722065u,0x7420666fu,0x72742073u,0x61697369u),\n  uvec4(0x74206368u,0x61717565u,0x20617669u,0x726f6e2eu),\n  uvec4(0x20204d6fu,0x6e747261u,0x6e74206cu,0x65757273u),\n  uvec4(0x20736569u,0x6e732070u,0x656e6461u,0x6e747320u),\n  uvec4(0x6574206cu,0x65757273u,0x20726f62u,0x6573206fu),\n  uvec4(0x75766572u,0x7465732cu,0x20204465u,0x73206665u),\n  uvec4(0x6d6d6573u,0x20736520u,0x746f7264u,0x6169656eu),\n  uvec4(0x7420736fu,0x7573206cu,0x65206e6fu,0x69722066u),\n  uvec4(0x69726d61u,0x6d656e74u,0x2c202045u,0x742c2063u),\n  uvec4(0x6f6d6d65u,0x20756e20u,0x6772616eu,0x64207472u),\n  uvec4(0x6f757065u,0x61752064u,0x65207669u,0x6374696du),\n  uvec4(0x6573206fu,0x66666572u,0x7465732cu,0x20204465u),\n  uvec4(0x727269e8u,0x7265206cu,0x75692074u,0x7261ee6eu),\n  uvec4(0x6169656eu,0x7420756eu,0x206c6f6eu,0x67206d75u),\n  uvec4(0x67697373u,0x656d656eu,0x742e2020u,0x5367616eu),\n  uvec4(0x6172656cu,0x6c652065u,0x6e207269u,0x616e7420u),\n  uvec4(0x6c756920u,0x72e9636cu,0x616d6169u,0x74207365u),\n  uvec4(0x73206761u,0x6765732cu,0x20205461u,0x6e646973u),\n  uvec4(0x20717565u,0x20646f6eu,0x204c7569u,0x73206176u),\n  uvec4(0x65632075u,0x6e20646fu,0x69677420u,0x7472656du),\n  uvec4(0x626c616eu,0x7420204du,0x6f6e7472u,0x61697420u),\n  uvec4(0xe020746fu,0x7573206cu,0x6573206du,0x6f727473u),\n  uvec4(0x20657272u,0x616e7420u,0x73757220u,0x6c657320u),\n  uvec4(0x72697661u,0x67657320u,0x204c6520u,0x66696c73u),\n  uvec4(0x20617564u,0x61636965u,0x75782071u,0x75692072u),\n  uvec4(0x61696c6cu,0x6120736fu,0x6e206672u,0x6f6e7420u),\n  uvec4(0x626c616eu,0x632e2020u,0x46726973u,0x736f6e6eu),\n  uvec4(0x616e7420u,0x736f7573u,0x20736f6eu,0x20646575u),\n  uvec4(0x696c2c20u,0x6c612063u,0x68617374u,0x65206574u),\n  uvec4(0x206d6169u,0x67726520u,0x456c7669u,0x72652c20u),\n  uvec4(0x205072e8u,0x73206465u,0x206c27e9u,0x706f7578u),\n  uvec4(0x20706572u,0x66696465u,0x20657420u,0x71756920u),\n  uvec4(0x66756920u,0x736f6e20u,0x616d616eu,0x74202053u),\n  uvec4(0x656d626cu,0x61697420u,0x6c756920u,0x72e9636cu),\n  uvec4(0x616d6572u,0x20756e20u,0x73757072u,0xea6d6520u),\n  uvec4(0x736f7572u,0x69726520u,0x204ff920u,0x6272696cu),\n  uvec4(0x6ce27420u,0x6c612064u,0x6f756365u,0x75722064u),\n  uvec4(0x6520736fu,0x6e207072u,0x656d6965u,0x72207365u),\n  uvec4(0x726d656eu,0x742e2020u,0x546f7574u,0x2064726fu),\n  uvec4(0x69742064u,0x616e7320u,0x736f6e20u,0x61726d75u),\n  uvec4(0x72652c20u,0x756e2067u,0x72616e64u,0x20686f6du),\n  uvec4(0x6d652064u,0x65207069u,0x65727265u,0x20205365u),\n  uvec4(0x2074656eu,0x61697420u,0xe0206c61u,0x20626172u),\n  uvec4(0x72652065u,0x7420636fu,0x75706169u,0x74206c65u),\n  uvec4(0x20666c6fu,0x74206e6fu,0x69723b20u,0x204d6169u),\n  uvec4(0x73206c65u,0x2063616cu,0x6d652068u,0xe9726f73u),\n  uvec4(0x2c20636fu,0x757262e9u,0x20737572u,0x20736120u),\n  uvec4(0x72617069u,0xe872652cu,0x20205265u,0x67617264u),\n  uvec4(0x61697420u,0x6c652073u,0x696c6c61u,0x67652065u),\n  uvec4(0x74206e65u,0x20646169u,0x676e6169u,0x74207269u),\n  uvec4(0x656e2076u,0x6f69722eu,0x20204348u,0x4154494du),\n  uvec4(0x454e5420u,0x4445204cu,0x274f5247u,0x5545494cu),\n  uvec4(0x2020456eu,0x20636573u,0x2074656du,0x7073206du),\n  uvec4(0x65727665u,0x696c6c65u,0x7578206fu,0xf9206c61u),\n  uvec4(0x205468e9u,0x6f6c6f67u,0x69652020u,0x466c6575u),\n  uvec4(0x72697420u,0x61766563u,0x206c6520u,0x706c7573u),\n  uvec4(0x20646520u,0x73e87665u,0x20657420u,0x6427e96eu),\n  uvec4(0x65726769u,0x652c2020u,0x4f6e2072u,0x61636f6eu),\n  uvec4(0x74652071u,0x7527756eu,0x206a6f75u,0x7220756eu),\n  uvec4(0x20646f63u,0x74657572u,0x20646573u,0x20706c75u),\n  uvec4(0x73206772u,0x616e6473u,0x20202d2du,0x417072e8u),\n  uvec4(0x73206176u,0x6f697220u,0x666f7263u,0xe9206c65u),\n  uvec4(0x7320636fu,0x65757273u,0x20696e64u,0x696666e9u),\n  uvec4(0x72656e74u,0x732c2020u,0x4c657320u,0x61766f69u),\n  uvec4(0x72207265u,0x6d75e973u,0x2064616eu,0x73206c65u),\n  uvec4(0x75727320u,0x70726f66u,0x6f6e6465u,0x75727320u),\n  uvec4(0x6e6f6972u,0x65733b20u,0x20417072u,0xe8732061u),\n  uvec4(0x766f6972u,0x20667261u,0x6e636869u,0x20766572u),\n  uvec4(0x73206c65u,0x732063e9u,0x6c657374u,0x65732067u),\n  uvec4(0x6c6f6972u,0x65732020u,0x44657320u,0x6368656du),\n  uvec4(0x696e7320u,0x73696e67u,0x756c6965u,0x727320e0u),\n  uvec4(0x206c7569u,0x2d6dea6du,0x6520696eu,0x636f6e6eu),\n  uvec4(0x75732c20u,0x204ff920u,0x6c657320u,0x70757273u),\n  uvec4(0x20457370u,0x72697473u,0x20736575u,0x6c732070u),\n  uvec4(0x6575742du,0xea747265u,0x20e97461u,0x69656e74u),\n  uvec4(0x2076656eu,0x75732c20u,0x202d2d43u,0x6f6d6d65u),\n  uvec4(0x20756e20u,0x686f6d6du,0x65206d6fu,0x6e74e920u),\n  uvec4(0x74726f70u,0x20686175u,0x742c2070u,0x72697320u),\n  uvec4(0x64652070u,0x616e6971u,0x75652c20u,0x205327e9u),\n  uvec4(0x63726961u,0x2c207472u,0x616e7370u,0x6f7274e9u),\n  uvec4(0x20642775u,0x6e206f72u,0x67756569u,0x6c207361u),\n  uvec4(0x74616e69u,0x7175653au,0x2020ab20u,0x4ae97375u),\n  uvec4(0x732c2070u,0x65746974u,0x204ae973u,0x75732120u),\n  uvec4(0x6a652074u,0x27616920u,0x706f7573u,0x73e92062u),\n  uvec4(0x69656e20u,0x68617574u,0x2120204du,0x6169732cu),\n  uvec4(0x20736920u,0x6a276176u,0x61697320u,0x766f756cu),\n  uvec4(0x75207427u,0x61747461u,0x71756572u,0x20617520u),\n  uvec4(0x64e96661u,0x75742020u,0x4465206cu,0x2761726du),\n  uvec4(0x7572652cu,0x20746120u,0x686f6e74u,0x6520e967u),\n  uvec4(0x616c6572u,0x61697420u,0x74612067u,0x6c6f6972u),\n  uvec4(0x652c2020u,0x45742074u,0x75206e65u,0x20736572u),\n  uvec4(0x61697320u,0x706c7573u,0x20717527u,0x756e2066u),\n  uvec4(0x6f657475u,0x732064e9u,0x7269736fu,0x69726521u),\n  uvec4(0x20bb2020u,0x496d6de9u,0x64696174u,0x656d656eu),\n  uvec4(0x74207361u,0x20726169u,0x736f6e20u,0x7327656eu),\n  uvec4(0x20616c6cu,0x612e2020u,0x4c27e963u,0x6c617420u),\n  uvec4(0x64652063u,0x6520736fu,0x6c65696cu,0x20642775u),\n  uvec4(0x6e206372u,0xea706520u,0x73652076u,0x6f696c61u),\n  uvec4(0x3b202054u,0x6f757420u,0x6c652063u,0x68616f73u),\n  uvec4(0x20726f75u,0x6c612064u,0x616e7320u,0x63657474u),\n  uvec4(0x6520696eu,0x74656c6cu,0x6967656eu,0x63652c20u),\n  uvec4(0x2054656du,0x706c6520u,0x61757472u,0x65666f69u),\n  uvec4(0x73207669u,0x76616e74u,0x2c20706cu,0x65696e20u),\n  uvec4(0x64276f72u,0x64726520u,0x65742064u,0x276f7075u),\n  uvec4(0x6c656e63u,0x652e2020u,0x536f7573u,0x206c6573u),\n  uvec4(0x20706c61u,0x666f6e64u,0x73206475u,0x7175656cu),\n  uvec4(0x2074616eu,0x74206465u,0x20706f6du,0x70652061u),\n  uvec4(0x76616974u,0x206c7569u,0x2e20204cu,0x65207369u),\n  uvec4(0x6c656e63u,0x65206574u,0x206c6120u,0x6e756974u),\n  uvec4(0x20732769u,0x6e737461u,0x6c6ce872u,0x656e7420u),\n  uvec4(0x656e206cu,0x75692c20u,0x20436f6du,0x6d652064u),\n  uvec4(0x616e7320u,0x756e2063u,0x61766561u,0x7520646fu),\n  uvec4(0x6e74206cu,0x6120636cu,0x65662065u,0x73742070u),\n  uvec4(0x65726475u,0x652e2020u,0x44e87320u,0x6c6f7273u),\n  uvec4(0x20696c20u,0x66757420u,0x73656d62u,0x6c61626cu),\n  uvec4(0x65206175u,0x782062eau,0x74657320u,0x6465206cu),\n  uvec4(0x61207275u,0x652c2020u,0x45742c20u,0x7175616eu),\n  uvec4(0x6420696cu,0x20732765u,0x6e20616cu,0x6c616974u),\n  uvec4(0x2073616eu,0x73207269u,0x656e2076u,0x6f69722cu),\n  uvec4(0x20e02074u,0x72617665u,0x72732020u,0x4c657320u),\n  uvec4(0x6368616du,0x70732c20u,0x73616e73u,0x20646973u),\n  uvec4(0x74696e67u,0x75657220u,0x6c657320u,0xe974e973u),\n  uvec4(0x20646573u,0x20686976u,0x6572732cu,0x20205361u),\n  uvec4(0x6c652c20u,0x696e7574u,0x696c6520u,0x6574206cu),\n  uvec4(0x61696420u,0x636f6d6du,0x6520756eu,0x65206368u),\n  uvec4(0x6f736520u,0x7573e965u,0x2c202049u,0x6c206661u),\n  uvec4(0x69736169u,0x74206465u,0x7320656eu,0x66616e74u),\n  uvec4(0x73206c61u,0x206a6f69u,0x65206574u,0x206c6120u),\n  uvec4(0x726973e9u,0x652e2020u,0x4c412042u,0x45415554u),\n  uvec4(0x4520204au,0x65207375u,0x69732062u,0x656c6c65u),\n  uvec4(0x2c20f420u,0x6d6f7274u,0x656c7321u,0x20636f6du),\n  uvec4(0x6d652075u,0x6e2072eau,0x76652064u,0x65207069u),\n  uvec4(0x65727265u,0x2c202045u,0x74206d6fu,0x6e207365u),\n  uvec4(0x696e2c20u,0x6ff92063u,0x68616375u,0x6e207327u),\n  uvec4(0x65737420u,0x6d657572u,0x74726920u,0x746f7572u),\n  uvec4(0x20e02074u,0x6f75722cu,0x20204573u,0x74206661u),\n  uvec4(0x69742070u,0x6f757220u,0x696e7370u,0x69726572u),\n  uvec4(0x20617520u,0x706fe874u,0x6520756eu,0x20616d6fu),\n  uvec4(0x75722020u,0x45746572u,0x6e656c20u,0x6574206du),\n  uvec4(0x75657420u,0x61696e73u,0x69207175u,0x65206c61u),\n  uvec4(0x206d6174u,0x69e87265u,0x2e20204au,0x65207472u),\n  uvec4(0xf46e6520u,0x64616e73u,0x206c2761u,0x7a757220u),\n  uvec4(0x636f6d6du,0x6520756eu,0x20737068u,0x696e7820u),\n  uvec4(0x696e636fu,0x6d707269u,0x733b2020u,0x4a27756eu),\n  uvec4(0x69732075u,0x6e20636fu,0x65757220u,0x6465206eu),\n  uvec4(0x65696765u,0x20e0206cu,0x6120626cu,0x616e6368u),\n  uvec4(0x65757220u,0x64657320u,0x6379676eu,0x65733b20u),\n  uvec4(0x204a6520u,0x68616973u,0x206c6520u,0x6d6f7576u),\n  uvec4(0x656d656eu,0x74207175u,0x692064e9u,0x706c6163u),\n  uvec4(0x65206c65u,0x73206c69u,0x676e6573u,0x2c202045u),\n  uvec4(0x74206a61u,0x6d616973u,0x206a6520u,0x6e652070u),\n  uvec4(0x6c657572u,0x65206574u,0x206a616du,0x61697320u),\n  uvec4(0x6a65206eu,0x65207269u,0x732e2020u,0x4c657320u),\n  uvec4(0x706fe874u,0x65732c20u,0x64657661u,0x6e74206du),\n  uvec4(0x65732067u,0x72616e64u,0x65732061u,0x74746974u),\n  uvec4(0x75646573u,0x2e202051u,0x7565206au,0x27616920u),\n  uvec4(0x6c276169u,0x72206427u,0x656d7072u,0x756e7465u),\n  uvec4(0x72206175u,0x7820706cu,0x75732066u,0x69657273u),\n  uvec4(0x206d6f6eu,0x756d656eu,0x74732c20u,0x20436f6eu),\n  uvec4(0x73756d65u,0x726f6e74u,0x206c6575u,0x7273206au),\n  uvec4(0x6f757273u,0x20656e20u,0x64276175u,0x7374e872u),\n  uvec4(0x657320e9u,0x74756465u,0x733b2020u,0x43617220u),\n  uvec4(0x6a276169u,0x2c20706fu,0x75722066u,0x61736369u),\n  uvec4(0x6e657220u,0x63657320u,0x646f6369u,0x6c657320u),\n  uvec4(0x616d616eu,0x74732c20u,0x20446520u,0x70757273u),\n  uvec4(0x206d6972u,0x6f697273u,0x20717569u,0x20666f6eu),\n  uvec4(0x7420746fu,0x75746573u,0x2063686fu,0x73657320u),\n  uvec4(0x706c7573u,0x2062656cu,0x6c65733au,0x20204d65u),\n  uvec4(0x73207965u,0x75782c20u,0x6d657320u,0x6c617267u),\n  uvec4(0x65732079u,0x65757820u,0x61757820u,0x636c6172u),\n  uvec4(0x74e97320u,0xe9746572u,0x6e656c6cu,0x65732120u),\n  uvec4(0x204c2749u,0x4445414cu,0x20204365u,0x206e6520u),\n  uvec4(0x7365726fu,0x6e74206au,0x616d6169u,0x73206365u),\n  uvec4(0x73206265u,0x617574e9u,0x73206465u,0x20766967u),\n  uvec4(0x6e657474u,0x65732c20u,0x2050726fu,0x64756974u),\n  uvec4(0x73206176u,0x617269e9u,0x732c206eu,0xe9732064u),\n  uvec4(0x27756e20u,0x7369e863u,0x6c652076u,0x61757269u),\n  uvec4(0x656e2c20u,0x20436573u,0x20706965u,0x647320e0u),\n  uvec4(0x2062726fu,0x64657175u,0x696e732cu,0x20636573u),\n  uvec4(0x20646f69u,0x67747320u,0xe0206361u,0x73746167u),\n  uvec4(0x6e657474u,0x65732c20u,0x20517569u,0x20736175u),\n  uvec4(0x726f6e74u,0x20736174u,0x69736661u,0x69726520u),\n  uvec4(0x756e2063u,0x6f657572u,0x20636f6du,0x6d65206cu),\n  uvec4(0x65206d69u,0x656e2e20u,0x204a6520u,0x6c616973u),\n  uvec4(0x73652c20u,0xe0204761u,0x7661726eu,0x692c2070u),\n  uvec4(0x6fe87465u,0x20646573u,0x2063686cu,0x6f726f73u),\n  uvec4(0x65732c20u,0x20536f61u,0x2074726fu,0x75706561u),\n  uvec4(0x75206761u,0x7a6f7569u,0x6c6c616eu,0x74206465u),\n  uvec4(0x20626561u,0x7574e973u,0x20642768u,0xf4706974u),\n  uvec4(0x616c2c20u,0x20436172u,0x206a6520u,0x6e652070u),\n  uvec4(0x75697320u,0x74726f75u,0x76657220u,0x7061726du),\n  uvec4(0x69206365u,0x732070e2u,0x6c657320u,0x726f7365u),\n  uvec4(0x73202055u,0x6e652066u,0x6c657572u,0x20717569u),\n  uvec4(0x20726573u,0x73656d62u,0x6c6520e0u,0x206d6f6eu),\n  uvec4(0x20726f75u,0x67652069u,0x64e9616cu,0x2e202043u),\n  uvec4(0x65207175u,0x27696c20u,0x66617574u,0x20e02063u),\n  uvec4(0x6520636fu,0x65757220u,0x70726f66u,0x6f6e6420u),\n  uvec4(0x636f6d6du,0x6520756eu,0x206162eeu,0x6d652c20u),\n  uvec4(0x20432765u,0x73742076u,0x6f75732cu,0x204c6164u),\n  uvec4(0x79204d61u,0x63626574u,0x682c20e2u,0x6d652070u),\n  uvec4(0x75697373u,0x616e7465u,0x20617520u,0x6372696du),\n  uvec4(0x652c2020u,0x52ea7665u,0x20642745u,0x73636879u),\n  uvec4(0x6c6520e9u,0x636c6f73u,0x20617520u,0x636c696du),\n  uvec4(0x61742064u,0x65732061u,0x7574616eu,0x733b2020u),\n  uvec4(0x4f752062u,0x69656e20u,0x746f692cu,0x20677261u),\n  uvec4(0x6e64204eu,0x7569742cu,0x2066696cu,0x6c652064u),\n  uvec4(0x65204d69u,0x6368656cu,0x2d416e67u,0x652c2020u),\n  uvec4(0x51756920u,0x746f7273u,0x20706169u,0x7369626cu),\n  uvec4(0x656d656eu,0x74206461u,0x6e732075u,0x6e652070u),\n  uvec4(0x6f736520u,0xe9747261u,0x6e676520u,0x20546573u),\n  uvec4(0x20617070u,0x61732066u,0x61e76f6eu,0x6ee97320u),\n  uvec4(0x61757820u,0x626f7563u,0x68657320u,0x64657320u),\n  uvec4(0x54697461u,0x6e73212eu,0x2e2e0000u,0x00000000u)\n);\nconst int[] lines = int[](\n  0,17,17,20,20,38,38,48,48,48,92,140,182,229,229,280,\n  327,378,431,431,478,523,559,602,602,656,704,756,805,805,853,893,\n  939,994,994,1046,1093,1145,1199,1199,1248,1300,1341,1394,1394,1445,1501,1558,\n  1598,1598,1651,1705,1749,1792,1792,1848,1890,1935,1985,1985,1985,1985,1985,2002,\n  2002,2015,2015,2015,2064,2103,2147,2200,2200,2253,2292,2337,2375,2375,2426,2467,\n  2516,2563,2563,2608,2653,2697,2745,2745,2785,2831,2872,2917,2917,2965,3005,3061,\n  3105,3105,3148,3196,3241,3290,3290,3344,3389,3435,3478,3478,3523,3572,3618,3671,\n  3671,3717,3767,3808,3850,3850,3901,3942,3993,4032,4032,4081,4125,4173,4221,4221,\n  4279,4326,4364,4409,4409,4461,4499,4543,4587,4587,4637,4677,4724,4769,4769,4815,\n  4864,4906,4948,4948,4997,5044,5093,5138,5138,5186,5230,5280,5321,5321,5365,5410,\n  5466,5517,5517,5517,5517,5517,5529,5529,5529,5576,5625,5671,5715,5715,5762,5810,\n  5861,5902,5902,5951,6001,6043,6092,6092,6136,6181,6220,6264,6264,6264,6264,6264,\n  6275,6275,6275,6321,6369,6411,6455,6455,6493,6543,6586,6623,6623,6670,6708,6752,\n  6800,6800,6844,6894,6940,6988,6988,7034,7084,7132,7178,7178,7178,7178,7178,7190,\n  7190,7190,7237,7287,7333,7382,7382,7427,7472,7520,7569,7569,7621,7663,7709,7754,\n  7754,7805,7853,7903,7951,7951,7992,8037,8091,8134,8134,8186,8230,8279,8322,8322,\n  8366,8417,8466,8515,8515,8564,8609,8658,8702,8702,8751,8802,8845,8892,8892,8936,\n  8976,9021,9073,9073,9127,9171,9218,9262,9262,9262,9262,9262,9278,9278,9278,9319,\n  9364,9412,9460,9460,9500,9546,9594,9634,9634,9684,9734,9785,9785,9828,9877,9919,\n  9919,9919,9919,9919,9929,9929,9929,9972,10017,10065,10121,10121,10165,10213,10258,10312,\n  10312,10361,10406,10452,10452,10500,10544,10592,10592,10592,10592,10592,10611,10611,10611,10659,\n  10709,10761,10815,10815,10861,10906,10956,11004,11004,11054,11103,11150,11150,11201,11244,11290,\n  11290,11290,11290,11290,11311,11311,11311,11356,11404,11452,11501,11501,11552,11601,11644,11688,\n  11688,11735,11779,11825,11825,11869,11917,11958,11958,11958,11958,11958,11977,11977,11977,12020,\n  12066,12106,12154,12154,12199,12250,12295,12346,12346,12394,12439,12485,12531,12531,12576,12623,\n  12668,12712,12712,12712,12712,12712,12733,12733,12733,12784,12828,12879,12928,12928,12984,13033,\n  13084,13130,13130,13176,13221,13271,13318,13318,13375,13421,13463,13510,13510,13564,13611,13656,\n  13704,13704,13704,13704,13704,13728,13728,13728,13770,13814,13864,13910,13959,14006,14051,14103,\n  14155,14200,14249,14294,14338,14386,14386,14422,14465,14511,14566,14617,14663,14710,14758,14810,\n  14860,14905,14950,14950,14950,14950,14950,14961,14961,14961,15013,15064,15106,15145,15145,15194,\n  15247,15293,15338,15338,15381,15435,15482,15482,15527,15580,15631,15631,15631,15631,15631,15640,\n  15640,15640,15687,15731,15783,15831,15831,15875,15923,15969,16013,16013,16063,16114,16158,16158,\n  16206,16251,16295,16295,16298\n);\n#endif", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 341, 341, 683], [685, 726, 752, 834, 878], [1946, 1946, 2003, 2003, 2069]], "test": "untested"}
{"id": "mdsXW7", "name": "simple clock #2", "author": "jonasfrey", "description": "clock i guess time is in UTC (universal time coordinated)", "tags": ["clock"], "likes": 1, "viewed": 152, "published": 3, "date": "1669060826", "time_retrieved": "2024-07-30T16:18:12.392972", "image_code": "const float n_tau = 6.283185;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_pix_coo_nor = ( fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    //matrix rotation \n    float n_rot_radia = n_tau/4.;\n\n    float n_angle_nor = (atan( o_pix_coo_nor.x , o_pix_coo_nor.y)+(n_tau/2.))/n_tau;\n    \n    float n_dist_center = length(o_pix_coo_nor);\n    \n    float n_dist_angle = smoothstep(n_dist_center, n_dist_center, n_angle_nor);\n    \n    float n_t_yea = floor(iDate.x);//year-1\n    float n_t_mon = floor(iDate.y);//month-1\n    float n_t_day = floor(iDate.z);//day-1\n    float n_t_sec = floor(iDate.w);//secs since midnight\n    float n_t_min_nor = fract(n_t_sec/60./60.);\n    float n_t_hou = floor(n_t_sec/60./60.);\n    float n_rot_nor = 0.0;\n    float n_ang_sec_nor = mod(-(1./60.)*n_t_sec+n_rot_nor,1.);\n    float n_ang_min_nor = mod(-n_t_min_nor+n_rot_nor,1.);\n    float n_ang_hou_nor = mod(-(1./24.)*n_t_hou+n_rot_nor,1.);\n    \n    float n_radius_sec = min(0.5, n_dist_center);\n    float n_radius_min = min(0.25, n_dist_center);\n    float n_radius_hou = min(0.1, n_dist_center);\n\n    float n_dist2_sec = length( o_pix_coo_nor - vec2(\n        n_radius_sec * cos(n_ang_sec_nor*n_tau),\n        n_radius_sec * sin(n_ang_sec_nor*n_tau)\n    ));\n    n_dist2_sec = sqrt(n_dist2_sec);\n    float n_dist2_min = length( o_pix_coo_nor - vec2(\n        n_radius_min * cos(n_ang_min_nor*n_tau),\n        n_radius_min * sin(n_ang_min_nor*n_tau)\n    ));\n    n_dist2_min = sqrt(n_dist2_min);\n    \n    float n_dist2_hou = length( o_pix_coo_nor - vec2(\n        n_radius_hou * cos(n_ang_hou_nor*n_tau),\n        n_radius_hou * sin(n_ang_hou_nor*n_tau)\n    ));\n    \n    n_dist2_hou = sqrt(n_dist2_hou);\n    \n    fragColor = vec4(\n        n_dist2_sec*5.,\n        n_dist2_min*5.,\n        n_dist2_hou*5., \n        1.\n    );\n    \n    \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 137, 1881]], "test": "untested"}
{"id": "mslXWM", "name": "drain vortex marching-less -golf", "author": "FabriceNeyret2", "description": "Hey, I  never golfed that guy ! :-p\ngolfing 1439 chars [url]https://shadertoy.com/view/ws23D3[/url]\nsimplifying 2586 chars skaplun's [url]https://www.shadertoy.com/view/3s2GW3[/url]", "tags": ["cubic", "polynomial", "tuto", "solve", "degree3"], "likes": 46, "viewed": 658, "published": 3, "date": "1669046379", "time_retrieved": "2024-07-30T16:18:13.153937", "image_code": "// golfing 1439 chars https://shadertoy.com/view/ws23D3\n// inspired by 2586 chars skaplun's https://www.shadertoy.com/view/3s2GW3 , but with analytical ray-intersection instead of marching.\n\n#define N          normalize\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    vec3  P = vec3(0, 6, 3.2),\n          D = N( vec3(0,1,0) - P ), f;\n      //  f = N(vec3(D.y,0,9));    // right\n      //  D = N( D*3.5*R.y + U.x*f + U.y*cross(f,D) );\n          D = N( D*3.5*R.y - U.xyy*vec3(1,-D.z,D.y) );\n    float t = iTime,\n          l = dot(R=D.xy,R),\n          L = 36.,     // dot(P.xy,P.xy),\n          o = 12.*D.y, // dot(P.xy,D.xy)*2.,\n          b = ( P/D + o/l ).z /3., \n          c = ( L +o*P/D ).z /l, \n          p = b*b - c/3.,\n          s = sqrt(abs(p)),\n          q = b*c - ( L*P.z + 1. ) /l/D.z - 2.*b*b*b; // -\n         \n    if ( q*q/4. < p*p*p )                     // --- if 3 sol\n        l = acos(q/2./s/s/s), \n        l = 2.*s* cos((l+round(1.5-l/6.283)*6.283)/3.);  // sol(k)\n    else                                      // --- if 1 sol\n        l = s+s,\n        L = abs(q/p/l), q = sign(q),\n        l *= p < 0. ? sinh(q*asinh(L)/3.) // - sinh(asinh(-q/p/-l)/3.) , fix asinh() symetry error \n                    : q*cosh(acosh(L)/3.);\n    l -= b;\n    O *= 0.;\n    if ( l > 0. )\n        P += l*D,\n        P.xy *= mat2(cos( (length(P.xy) + P.z) /2. -t/2. + vec4(0,33,11,0))), // rot(time/2.), twist(P, -.25);\n        P = vec3( length(P.xy)*4. + t+t , atan(P.y,P.x) * 25. , t * .05 ),\n        f = fract(P), P -= f,\n        f = f*f*(3.-f-f),                      \n     // U = textureLod( iChannel0, ((P.xy+vec2(37,17)*P.z) + f.xy+.5)/256., 0. ).yx, // old fashion t3D emulation\n     // c =  mix( U.x, U.y, f.z ) -.3 ,                   //  noise( P );\n        c =  texture( iChannel1, (P+f+.5)/32. ).x -.3,\n        O += smoothstep(.75, -.75, c/fwidth(c) );\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 259, 259, 1905]], "test": "untested"}
{"id": "cslSDM", "name": "Sphere&Camera", "author": "CodeJUN", "description": "个人练习", "tags": ["3d", "camera"], "likes": 2, "viewed": 181, "published": 3, "date": "1669024339", "time_retrieved": "2024-07-30T16:18:13.897948", "image_code": "#define TMIN 0.1\n#define TMAX 20.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.14159265\n\nvec2 fixUV(in vec2 c)\n{\n    return(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n}\n\nfloat sdfSphere(in vec3 p)//球体\n{\n    return length(p) - 1.5 ;\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd)//射线方向和源头\n{\n    float t=TMIN;\n    for(int i=0;i<RAYMARCH_TIME &&t<TMAX;i++)\n    {\n        vec3 p=ro+t*rd;\n        float d=sdfSphere(p);\n        if(d<PRECISION)\n        {\n            //return t;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)//光照\n{\n    const float h=0.0001;;\n    const vec2 k= vec2 (1,-1);\n   return normalize(k.xyy * sdfSphere(p + k.xyy * h) +\n        k.yyx * sdfSphere(p + k.yyx * h) +\n        k.yxy * sdfSphere(p + k.yxy * h) +\n        k.xxx * sdfSphere(p + k.xxx * h));\n}\n\nmat3 setCamera(vec3 ta,vec3 ro,float cr)//摄像机围绕球体旋转\n{\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr) , cos(cr),0.);\n    vec3 x= normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n\n}\n\nvec3 render(vec2 uv )\n{\n    vec3 color =vec3(.05);\n    vec3 ro =vec3 (2.*cos(iTime),1.,2.*sin(iTime));//球体旋转\n    if(iMouse.z>0.001)//鼠标控制\n    {\n        float theta=iMouse.x/iResolution.x*2.*PI;\n        ro=vec3(2.*cos(theta),1.+0.2*cos(iTime),2.*sin(theta));\n    }\n    vec3 ta=vec3(0.);\n    mat3 cam=setCamera(ta,ro,0.);\n    vec3 rd =normalize(cam*vec3 (uv,1.));\n    float t=rayMarch(ro,rd);\n    if(t<TMAX)\n    {\n        vec3 p=ro+t*rd;\n        vec3 n= calcNormal(p);\n        vec3 light =vec3 (2.*cos(iTime),2.,2.*sin(iTime+2.));//光线移动\n        //vec3 light =vec3 (2.,2.,2.);\n        float dif=clamp(dot(normalize(light-p),n),0.,1.);\n\n        float amd=0.5+0.5*dot(n,vec3(0.,1.,0));//环境灯光亮度\n\n        color=amd*vec3(0.05)+dif*vec3(.6);\n\n    }\n    return sqrt(color);//幂\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 color=vec3(0.);\n    for(int m =0;m<AA;m++)\n    {\n        for(int n=0; n<AA;n++)\n        {\n            vec2 offset=2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            vec2 uv = fixUV(fragCoord+offset);\n            color += render(uv);\n        }\n    }\n    fragColor=vec4(color/float(AA*AA),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 142, 142, 211], [213, 213, 249, 249, 280], [282, 282, 345, 345, 594], [596, 642, 678, 678, 922], [924, 924, 995, 995, 1150], [1152, 1152, 1175, 1175, 1959], [1961, 1961, 2015, 2015, 2323]], "test": "untested"}
{"id": "ddfXDM", "name": "giggle worm", "author": "Wholeness", "description": "FOR FABRICE BABY\n\nvive la France", "tags": ["beginner", "newbie", "noob", "firstshader"], "likes": 3, "viewed": 159, "published": 3, "date": "1668999842", "time_retrieved": "2024-07-30T16:18:14.742689", "image_code": "#define SS(a,b,c) smoothstep(a-b, a+b, c)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 andy = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 brian = vec3(0.);\n    brian = vec3(andy.x, andy.y, 1.);\n    brian = 0.5 + 0.5 * cos(andy.xyx + iTime + vec3(0,2,4));\n    float christy = 0.; // sin(andy.x * 200. + iTime * sin(andy.y)) * 0.04;\n    christy += sin(andy.x*50. + iTime*10.)*0.01;\n    \n    // float greg = smoothstep( 0.001, 0.05 + christy, abs (andy.y-0.5)); \n    float greg = SS(christy + 0.05, 0.1, abs(andy.y-0.5+sin(iTime*2. + andy.x*2.)*0.2) );\n\n    brian = mix (brian, vec3(sin(iTime*0.3 + andy.x)), 1.-greg);\n\n    // Output to screen\n    fragColor = vec4(brian,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 100, 150, 775]], "test": "untested"}
{"id": "mdXXWM", "name": "Soft dip", "author": "PauloFalcao", "description": "Something I had made sometime ago in MaterialMaker", "tags": ["materialmaker", "shadershrinker"], "likes": 36, "viewed": 622, "published": 3, "date": "1668994000", "time_retrieved": "2024-07-30T16:18:15.519612", "image_code": "// Soft dip\n//\n// Generated in Material Maker by PauloFalcao\n//\n// The music is also done by me BTW :)\n//\n// You can now use #MaterialMaker on the browser!!!\n//\n// https://materialmaker.org/public/mm_web/\n//\n// Loading this example https://twitter.com/paulofalcao/status/1597367766507737090\n//\n// // You can find the original Material Maker file here\n// https://www.materialmaker.org/material?id=577\n//\n// A video playing with this on Material Maker\n// https://youtu.be/uBpX1CG28c4\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 18,337 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n#define v4\tvec4\n#define v3\tvec3\n#define v2\tvec2\n#define RET\treturn\n#define NM\tnormalize\n#define _c\tclamp\n#define _f\tfloat\n#define iT\tiTime\n#define iR\tiResolution\n\nvec3 x3(v3 c) {\n\t_f j = 4096. * sin(dot(c, v3(17, 59.4, 15)));\n\tv3 r;\n\tr.z = fract(512. * j);\n\tj *= .125;\n\tr.x = fract(512. * j);\n\tj *= .125;\n\tr.y = fract(512. * j);\n\tRET r - .5;\n}\n\nfloat Xd(v3 p) {\n\tv3 s = floor(p + dot(p, v3(.3333333))),\n\t   x = p - s + dot(s, v3(.1666667)),\n\t   e = step(v3(0), x - x.yzx),\n\t   H = e * (1. - e.zxy),\n\t   I = 1. - e.zxy * (1. - e),\n\t   X1 = x - H + .1666667,\n\t   X2 = x - I + .33333,\n\t   X3 = x - .5;\n\tv4 w, d;\n\tw.x = dot(x, x);\n\tw.y = dot(X1, X1);\n\tw.z = dot(X2, X2);\n\tw.w = dot(X3, X3);\n\tw = max(.6 - w, 0.);\n\td.x = dot(x3(s), x);\n\td.y = dot(x3(s + H), X1);\n\td.z = dot(x3(s + I), X2);\n\td.w = dot(x3(s + 1.), X3);\n\tw *= w;\n\tw *= w;\n\td *= w;\n\tRET dot(d, v4(52));\n}\n\nfloat g(v3 UV, v3 s) {\n\tv3 q = abs(UV) - s;\n\tRET length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nvec3 rd(v3 p, v3 a) {\n\t_f c = cos(a.x),\n\t   s = sin(a.x);\n\tv3 RV;\n\tRV.x = p.x;\n\tRV.y = p.y * c + p.z * s;\n\tRV.z = -p.y * s + p.z * c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = RV.x * c + RV.z * s;\n\tp.y = RV.y;\n\tp.z = -RV.x * s + RV.z * c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\tRV.x = p.x * c + p.y * s;\n\tRV.y = -p.x * s + p.y * c;\n\tRV.z = p.z;\n\tRET RV;\n}\n\nvec3 sY(v3 p) {\n\t_f d, x, C,\n\t   s = 6.;\n\ts *= .5;\n\td = length(p.xz);\n\tx = asin(sin(atan(p.x, p.z) * s) * .493) * d;\n\tC = d * s;\n\tRET v3(x / s, p.y, mix(C, 2. * C - sqrt(x * x + C * C), 1.) / s - 1.148);\n}\n\nvec3 P(v3 p, v3 a) {\n\t_f c = cos(a.x),\n\t   s = sin(a.x);\n\tv3 RV;\n\tRV.x = p.x;\n\tRV.y = p.y * c + p.z * s;\n\tRV.z = -p.y * s + p.z * c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = RV.x * c + RV.z * s;\n\tp.y = RV.y;\n\tp.z = -RV.x * s + RV.z * c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\tRV.x = p.x * c + p.y * s;\n\tRV.y = -p.x * s + p.y * c;\n\tRV.z = p.z;\n\tRET RV;\n}\n\nfloat we(_f x) { RET .5 - .5 * cos(6.28319 * x); }\n\nfloat U(_f x, _f y, _f z) {\n\t_f XY = min(x + y, 2. - x - y);\n\tRET min(XY + z, 2. - XY - z);\n}\n\nfloat S(_f a, _f b, _f k) {\n\t_f h = max(k - abs(a - b), 0.) / k;\n\tRET min(a, b) - h * h * k * .25;\n}\n\nvec4 R(v4 a, v4 b) {\n\t_f h,\n\t   k = 1.;\n\tk = max(k, .001);\n\th = S(a.w, b.w, k);\n\tv2 n = NM(v2(S(a.w + .001, b.w, k) - S(a.w - .001, b.w, k), S(a.w, b.w + .001, k) - S(a.w, b.w - .001, k)));\n\tRET v4(mix(a.xyz, b.xyz, atan(abs(n.y), abs(n.x)) / 1.5708), h);\n}\n\nvec4 Q(v4 J) {\n\tconst v4 K = v4(0, 0, 0, 9999999),\n\t         L = v4(0, 0, 0, 9999999),\n\t         M = v4(0, 0, 0, 9999999);\n\tv4 t = (J.w < K.w) ? v4(J) : v4(K);\n\tt = (t.w < K.w) ? t : v4(K);\n\tt = (t.w < L.w) ? t : v4(L);\n\tRET (t.w < M.w) ? t : v4(M);\n}\n\nfloat t0(v3 v, _f _) {\n\t_f X = 0.,\n\t   ve = 0.,\n\t   se = 1.,\n\t   SE = 1.;\n\tfor (int i = 0; i < 6; i++) {\n\t\tve += Xd(v * SE) * se;\n\t\tX += se;\n\t\tSE *= 2.;\n\t\tse *= .5;\n\t}\n\n\tRET ve / X;\n}\n\nfloat s0(_f f, _f _) { RET f * 15.505 - 7.2525; }\n\nvec3 l0(v4 p, _f _) { RET _c(v3(s0(t0((p).xyz * 4.56 + v3(0), _) * .5 + .5, _)), v3(0), v3(1)); }\n\nfloat m0(v4 p, _f _) { RET 1.; }\n\nfloat q0(v4 p, _f _) { RET 1.; }\n\nfloat o0(v4 p, _f _) { RET 1.; }\n\nvec3 k0(v4 p, _f _) { RET v3(1); }\n\nvec3 n0(v4 p, _f _) { RET v3(0, 1, 0); }\n\nfloat i0(v4 p, _f _) { RET 1.; }\n\nfloat j0(v4 p, _f _) { RET 1.; }\n\nfloat p0(v3 p, _f _) { RET (v2(g(rd(sY(p), -v3(-32, -106, -129) * .01745329), v3(.22, 1.94, .25)) - .06, 0)).x; }\n\nvec4 P5(v4 UV, _f _) {\n\tUV.xyz = P(UV.xyz - v3(0, sin(iT * .5) + 1., 0), v3(iT * .041, iT * .05, iT * .043) * 6.2831853) / .815;\n\t_f sf = p0(UV.xyz, _) * .815;\n\tif (UV.w > 18.5) RET v4(0. * j0(v4(UV.xyz, 19), _), 0, 0, sf);\n\tif (UV.w > 14.5) RET v4(0. * i0(v4(UV.xyz, 15), _), 0, 0, sf);\n\tif (UV.w > 13.5) RET v4(0. * n0(v4(UV.xyz, 14), _), sf);\n\tif (UV.w > 12.5) RET v4(0. * k0(v4(UV.xyz, 13), _), sf);\n\tif (UV.w > 4.5) RET v4(0. * o0(v4(UV.xyz, 5), _), 0, 0, sf);\n\tif (UV.w > 3.5) RET v4(.306 * q0(v4(UV.xyz, 4), _), 0, 0, sf);\n\tif (UV.w > 1.5) RET v4(0. * m0(v4(UV.xyz, 2), _), 0, 0, sf);\n\tif (UV.w > .5) RET v4(v4(1, 0, 0, 1).rgb * l0(v4(UV.xyz, 1), _), sf);\n\tRET v4(v3(0), sf);\n}\n\nfloat om(v3 v, _f _) {\n\t_f X = 0.,\n\t   ve = 0.,\n\t   se = 1.,\n\t   SE = 1.;\n\tfor (int i = 0; i < 6; i++) {\n\t\tve += Xd(v * SE) * se;\n\t\tX += se;\n\t\tSE *= 2.;\n\t\tse *= .5049;\n\t}\n\n\tRET ve / X;\n}\n\nfloat oc(_f f, _f _) { RET f * 2.42737 - .71368; }\n\nfloat OM(v3 v, _f _) {\n\t_f X = 0.,\n\t   ve = 0.,\n\t   se = 1.,\n\t   SE = 1.;\n\tfor (int i = 0; i < 6; i++) {\n\t\tve += Xd(v * SE) * se;\n\t\tX += se;\n\t\tSE *= 2.;\n\t\tse *= 0.;\n\t}\n\n\tRET ve / X;\n}\n\nfloat OC(_f f, _f _) { RET f * 1.927 - .4635; }\n\nvec3 OD(v4 p, _f _) {\n\tv3 g0 = v3(oc(om((p).xyz * 1.36 + v3(0.), _) * .5 + .5, _)),\n\t   h0 = v3(OC(OM((v4((p).xyz + (g0 * .655 - .5), 0)).xyz * v3(.62504, 0, .56013), _) * .5 + .5, _));\n\tRET v3(U(we(.79 * (v4((v4((p).xyz + (g0 * .655 - .5), 0)).xyz + (h0 * .82 - .5), 0)).x), we(0. * (v4((v4((p).xyz + (g0 * .655 - .5), 0)).xyz + (h0 * .82 - .5), 0)).y), we(0. * (v4((v4((p).xyz + (g0 * .655 - .5), 0)).xyz + (h0 * .82 - .5), 0)).z)));\n}\n\nfloat b0(v4 p, _f _) { RET 1.; }\n\nfloat f0(v4 p, _f _) { RET 1.; }\n\nfloat d0(v4 p, _f _) { RET 1.; }\n\nvec3 a0(v4 p, _f _) { RET v3(1); }\n\nvec3 c0(v4 p, _f _) { RET v3(0, 1, 0); }\n\nfloat Z(v4 p, _f _) { RET 1.; }\n\nfloat od(v4 p, _f _) { RET 1.; }\n\nfloat of(v3 p, _f _) { RET g(p, v3(5, .07, 5)) - .08; }\n\nvec3 r0(v4 p, _f _) { RET v3(sin(length((p).xz) * 6.18 - mod(iT * 8., 6.283))); }\n\nfloat B(v3 UV, _f _) { RET of(UV - r0(v4(UV, 0), _) * v3(0, .062, 0), _); }\n\nfloat e0(v3 p, _f _) { RET B(p, _); }\n\nvec4 P9(v4 UV, _f _) {\n\tUV.xyz = P(UV.xyz - v3(0), v3(0));\n\t_f sf = e0(UV.xyz, _);\n\tif (UV.w > 18.5) RET v4(0. * od(v4(UV.xyz, 19), _), 0, 0, sf);\n\tif (UV.w > 14.5) RET v4(0. * Z(v4(UV.xyz, 15), _), 0, 0, sf);\n\tif (UV.w > 13.5) RET v4(0. * c0(v4(UV.xyz, 14), _), sf);\n\tif (UV.w > 12.5) RET v4(0. * a0(v4(UV.xyz, 13), _), sf);\n\tif (UV.w > 4.5) RET v4(0. * d0(v4(UV.xyz, 5), _), 0, 0, sf);\n\tif (UV.w > 3.5) RET v4(.5 * f0(v4(UV.xyz, 4), _), 0, 0, sf);\n\tif (UV.w > 1.5) RET v4(0. * b0(v4(UV.xyz, 2), _), 0, 0, sf);\n\tif (UV.w > .5) RET v4(v4(1).rgb * OD(v4(UV.xyz, 1), _), sf);\n\tRET v4(v3(0), sf);\n}\n\nvec4 Y(v4 p, _f _) { RET Q(R(P5(p, _), P9(p, _))); }\n\nvec3 E(v3 p, _f PO) {\n\tp = p.yzx;\n\tRET pow(texture(iChannel0, p).xyz, v3(2.2)) + pow(texture(iChannel0, p).xxx, v3(16)) * PO;\n}\n\nvec3 W(v3 p, _f _) {\n\tconst v3 e = v3(.001, -.001, 0);\n\t_f V1 = Y(v4(p + e.xyy, 0), _).w,\n\t   V2 = Y(v4(p + e.yyx, 0), _).w,\n\t   V3 = Y(v4(p + e.yxy, 0), _).w,\n\t   V4 = Y(v4(p + e.xxx, 0), _).w;\n\tRET NM(v3(V4 + V1 - V3 - V2, V3 + V4 - V1 - V2, V2 + V4 - V3 - V1));\n}\n\nvoid O(inout float d, inout vec3 p, _f D, v3 RO, v3 RD, _f _) {\n\tfor (int i = 0; i < 500; i++) {\n\t\tp = RO + RD * d;\n\t\tD = Y(v4(p, 0), _).w;\n\t\td += D;\n\t\tif (d > 50. || abs(D) < 1e-4) break;\n\t}\n}\n\nfloat i(v3 ps, v3 V, _f _) {\n\t_f u0 = 0.,\n\t   sa = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\t_f h = .001 + .25 * _f(i) / 4.,\n\t\t   d = Y(v4(ps + h * V, 0), _).w;\n\t\tu0 += (h - d) * sa;\n\t\tsa *= .98;\n\t}\n\n\tRET _c(1. - 1.6 * u0, 0., 1.);\n}\n\nfloat m(v3 RO, v3 RD, _f _) {\n\t_f rs = 1.,\n\t   t = .05;\n\tfor (int i = 0; i < 32; i++) {\n\t\t_f h = Y(v4(RO + RD * t, 0), _).w;\n\t\trs = min(rs, 10. * h / t);\n\t\tt += h;\n\t\tif (rs < 1e-4 || t > 5.) break;\n\t}\n\n\tRET _c(rs, 0., 1.);\n}\n\nvec3 r1(v2 UV) {\n\t_f OR, os,\n\t   _ = 0.,\n\t   d = 0.,\n\t   D = 0.;\n\tUV -= .5;\n\tv3 or, N,\n\t   u = v3(0),\n\t   o = v3(sin(iT * .1) * 5., 4.077, cos(iT * .13) * 5.) * 1.153,\n\t   ry = NM(v3(0, .289, 0) - o),\n\t   A = NM(cross(v3(0, 1, 0), ry)),\n\t   RD = NM(ry * 1.5 + A * UV.x + NM(cross(A, ry)) * UV.y),\n\t   RO = o,\n\t   p = v3(0);\n\tO(d, p, D, RO, RD, _);\n\tor = Y(v4(p, 1), _).xyz;\n\tOR = Y(v4(p, 4), _).x * .2;\n\tos = Y(v4(p, 5), _).x;\n\tN = v3(22e-5, 1, 22e-5);\n\tif (d < 50.) {\n\t\tv3 rf, OF,\n\t\t   n = W(p, _);\n\t\t_f l = _c(dot(-N, -n), 0., 1.);\n\t\trf = NM(reflect(RD, -n));\n\t\tu = min(v3(max(mix(1., m(p, N, _), 1.), .07)), max(l, .07)) * max(mix(1., i(p, n, _), 1.), .07) * or + 4. * pow(_c(dot(rf, N), 0., 1.), pow(256., 1. - os)) * OR;\n\t\td = .01;\n\t\tO(d, p, D, p, rf, _);\n\t\tOF = v3(0);\n\t\tif (d < 50.) {\n\t\t\tOF = Y(v4(p, 1), _).xyz;\n\t\t\tn = W(p, _);\n\t\t\tl = _c(dot(-N, -n), 0., 1.);\n\t\t\tOF = max(l, .07) * OF;\n\t\t}\n\t\telse OF = E(rf.xzy, 6.);\n\n\t\tu = mix(u, OF, OR);\n\t}\n\telse u = E(RD.xzy, 0.);\n\n\tRET pow(u, v3(.50942));\n}\n\nvoid mainImage(out vec4 F, v2 G) {\n\t_f T = min(iR.x, iR.y);\n\tF = v4(r1(v2(0, 1) + v2(1, -1) * (G - .5 * (iR.xy - v2(T))) / T), 1);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30555, "src": "https://soundcloud.com/paulofalcao/landscape", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1582, 1582, 1603, 1603, 1924], [2133, 2133, 2153, 2153, 2474], [2984, 2984, 2998, 2998, 3235], [3820, 3820, 3842, 3842, 3933], [5998, 5998, 6020, 6020, 6035], [6634, 6634, 6654, 6654, 6686], [7085, 7085, 7148, 7148, 7278], [8741, 8741, 8775, 8775, 8873]], "test": "untested"}
{"id": "csfXW7", "name": "Text Console", "author": "Hatchling", "description": "Building off of https://www.shadertoy.com/view/XsfyDl by ChuckNorris, I implemented a text thingy. I meant to use this for debugging.", "tags": ["draw", "debug", "int", "float", "debugging", "write"], "likes": 2, "viewed": 659, "published": 3, "date": "1668986740", "time_retrieved": "2024-07-30T16:18:16.270604", "image_code": "#define fontTex iChannel3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    Font f;\n    f.texSize = iChannelResolution[3].xy;\n    f.charSize = iChannelResolution[3].xy / vec2(16, 16);\n    \n    const vec2 charScale = vec2(20, 20);\n    TextCursor t;\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0);\n    t.font = f;\n    t.color = vec4(1,1,0,1);\n    t.charSize = vec2(1,1) * charScale;\n    t.charSpace = vec2(0.475, 0.8) * charScale;\n    t.pageWidth = 40;\n\n    declString(s, 11, (cH, cE, cL, cL, cO, cSp, cW, cO, cR, cL, cD));  \n    \n    for(int i = 0; i < 10; i++)\n    {\n        pline(s, t);\n    }\n    \n    pnl(t);\n    \n    for(int i = 0; i < 10; i++)\n    {\n        pstr(s, t);\n        pch(cSp, t);\n    }\n    \n    t.color = vec4(0,1,1,1);\n    \n    for(int i = 0; i < 10; i++)\n    {\n        pch(Digits[i], t);\n    }\n    \n    pch(cNl, t);\n    \n    for(int i = 0; i < 26; i++)\n    {\n        pch(Uppercase[i], t);\n        pch(Lowercase[i], t);\n    }\n    \n    t.color = vec4(1,1,1,1);\n    \n    pnl(t);\n    pint(int(iTime * 1000.0), t);\n    pnl(t);\n    pfloat(iTime, t);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\n// To use, #define fontTex and have local vars named fragCoord and fragColor\n#define pch(c, t) printChar(c, t, fontTex, fragCoord, fragColor)\n#define pstr(s, t) printString(s, t, fontTex, fragCoord, fragColor)\n#define pline(s, t) printLine(s, t, fontTex, fragCoord, fragColor)\n#define pnl(t) printChar(cNl, t, fontTex, fragCoord, fragColor)\n#define pint(i, t) printInt(i, t, fontTex, fragCoord, fragColor)\n#define pfloat(f, t) printFloat(f, t, fontTex, fragCoord, fragColor)\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String\n{\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font\n{\n    vec2 texSize;\n    vec2 charSize;\n};\n\nstruct TextCursor\n{\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char)\n{\n    vec2 uvSize = f.charSize / f.texSize;\n    return vec4(char, char+ivec2(1)) * uvSize.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvec4 getCharFrag(ivec2 char, in TextCursor t, sampler2D tex, in vec2 fragCoord)\n{\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV)\n        return vec4(0);\n    \n    vec2 fontRectUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    \n    float opacity = texture(tex, fontRectUV).r;\n    \n    vec4 color = t.color;\n    color.a *= opacity;\n    return color;\n}\n\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    blend(getCharFrag(char, t, tex, fragCoord), fragColor);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t, tex, fragCoord, fragColor);\n    }\n}\n\nvoid printLine(String s, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t, tex, fragCoord, fragColor);\n    }\n    printChar(cNl, t, tex, fragCoord, fragColor);\n}\n\nvoid printInt(int val, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(val < 0)\n    {\n        printChar(cMinus, t, tex, fragCoord, fragColor);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)\n    {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t, tex, fragCoord, fragColor);\n    } \n}\n\nvoid printFloat(float val, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t, tex, fragCoord, fragColor);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t, tex, fragCoord, fragColor);\n    } \n    \n    printChar(cDot, t, tex, fragCoord, fragColor);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t, tex, fragCoord, fragColor);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nint idiv(int a, int b){\n    // If you encounter precision loss, this is probably the reason.\n    return int(float(a)/float(b));\n    \n    String s;\n    setString(s, 11, (cH, cE, cL, cL, cO, cSp, cW, cO, cR, cL, cD));  \n}\n\nint imod(int a, int b){\n    return a - idiv(a, b)*b;\n}\n\n\n\n\n\n\n#if 0\n// draw a character where p is bottom left\nfloat draw_char(vec2 p, vec2 char_position)\n{\n    vec2 uv = (gl_FragCoord.xy - p)/vec2(DIGIT_WIDTH, DIGIT_HEIGHT);\n    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0){\n        return texture(iChannel3, (uv + char_position)/16.0).r;\n    }\n    return 0.0;\n}\n\n// draw a digit between 0-9\nfloat draw_digit(vec2 p, int digit)\n{\n    return draw_char(p, vec2(float(digit), 12.0));\n}\n\n// draw an unsigned integer\nfloat draw_uint(vec2 p, int number)\n{\n    number = abs(number);\n    \n    // we draw numbers from right to left because we get digits in that order\n    p.x += float(MAX_DIGITS - 1)*DIGIT_WIDTH;\n    \n    float color = 0.0;\n    \n    // decompose number into digits\n    for (int i = 0; i < MAX_DIGITS; i++){\n        int digit = imod(number, BASE);\n        number = idiv(number, BASE);\n        \n        color += draw_digit(p, digit);\n        \n        p.x -= DIGIT_WIDTH;\n    }\n    \n    return color;\n}\n\n// draw an unsigned integer with a sign in front\nfloat draw_uint_with_sign(vec2 p, int number, bool negative){\n    // draw sign\n    float color = draw_char(p, negative ? MINUS_SIGN : PLUS_SIGN);\n    p.x += DIGIT_WIDTH;\n    \n    // draw uint\n    color += draw_uint(p, number);\n    \n    return color;\n}\n\nfloat draw_int(vec2 p, int number){\n    return draw_uint_with_sign(p, number, number < 0);\n}\n\nfloat draw_float(vec2 p, float f){\n    float color = draw_uint_with_sign(p, int(f), f < 0.0);\n    p.x += float(MAX_DIGITS + 1)*DIGIT_WIDTH;\n    \n    // draw dot\n    color += draw_char(p, DOT);\n    p.x += DIGIT_WIDTH;\n    \n    // remove integer part\n    f -= float(int(f));\n    // shift fractional part into integer part\n    f *= pow(float(BASE), float(MAX_DIGITS));\n    \n    // draw fractional part\n    color += draw_uint(p, int(f));\n    \n    return color;\n}\n#endif", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 1122]], "test": "untested"}
{"id": "cdfXW7", "name": "F# Weekly Windows Terminal", "author": "mrange", "description": "CC0: F# Weekly Windows Terminal Shader\nA shader background for Windows Terminal featuring the F# weekly logo\n", "tags": ["windowsterminal", "fsharp"], "likes": 12, "viewed": 330, "published": 3, "date": "1668979977", "time_retrieved": "2024-07-30T16:18:17.079442", "image_code": "// CC0: F# Weekly Windows Terminal Shader\n//  A shader background for Windows Terminal featuring the F# weekly logo\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 skyCol   = HSV2RGB(vec3(0.58, 0.86, 1.0));\nconst vec3 speCol1  = HSV2RGB(vec3(0.55, 0.9, 1.0));\nconst vec3 speCol2  = HSV2RGB(vec3(0.8 , 0.6, 1.0));\nconst vec3 speCol3  = HSV2RGB(vec3(0.9, 0.86, 4.0));\nconst vec3 matCol   = HSV2RGB(vec3(0.8,0.50, 0.5)); \nconst vec3 diffCol1 = HSV2RGB(vec3(0.60,0.90, 2.0)); \nconst vec3 diffCol2 = HSV2RGB(vec3(0.85,0.90, 2.0));\nconst vec3 sunDir1  = normalize(vec3(0.9, -0.4, 1.0));\nconst vec3 sunDir2  = normalize(vec3(-0.9 , 0.0, 1.0));\n\n\nconst float outerZoom = 1.5;\nconst float innerZoom = 1.0-0.4;\nconst float height = -0.065*outerZoom;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  p = abs(p);\n  return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat equilateralTriangle(vec2 p) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 pmin(vec2 a, vec2 b, float k) {\n  vec2 h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 pabs(vec2 a, float k) {\n  return -pmin(-a, a, k);\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\nvec2 dfsharp(vec2 p) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  vec2 p3 = p;\n  const float sm = 0.03;\n  p0 = pabs(p0, sm);\n  const vec2 n = normalize(vec2(1.0));\n  float d0 = abs(dot(n, p0)-0.38)-0.12;\n  float d1 = abs(p1.x)-0.025;\n  float d2 = dot(n, p0)-0.19;\n  float d3 = -p3.x-0.025;\n  d2 = pmax(d2, -d3, sm);\n  float d = d0;\n\n  d = pmax(d, -d1, sm);\n  d = min(d,  d2);\n  return vec2(d, p.x > 0.0 ? 1.0 : 0.0);\n}\n\nvec2 dfsharpWeekly(vec2 p, vec2 off) {\n  const mat2 rot45 = ROT(PI/4.0);\n  const vec2 refN = SCA(-PI/4.0);\n  const float r = 0.125;\n  const float rr = 2.0*r*sqrt(2.0);\n  vec2 p0 = p;\n  vec2 p1 = p-off;\n  p0 = abs(p0);\n  ref(p0, refN);\n  p0.y -= rr;\n  float d0 = roundedX(p0, rr, r);\n  float d1 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.0, 1.0))-r;\n  float d2 = segment(p1, rr*vec2(0.5, -0.5), rr*vec2(0.0, -1.0))-r;\n  float d3 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.5, -1.5))-r;\n  float d = d0;\n  float dd = d1;\n  dd = min(dd, d2);\n  dd = min(dd, d3);\n  \n  return vec2(d, dd);\n}\n\nvec2 df(vec2 p) {\n  const mat2 rot45 = ROT(PI/4.0);\n  p *= transpose(rot45);\n  vec2 cp = (p-0.5);\n  vec2 cn = round(cp);\n  cp -= cn;\n  cp *= rot45;\n  \n  return dfsharp(cp/innerZoom)*innerZoom;\n}\n\nfloat hf(vec2 p) {\n  const float a = .05;\n  p += 0.125*sin(vec2(1.0, sqrt(0.5))*TIME*a)/a;\n  const float aa = 0.06;\n  p /= outerZoom;\n  vec2 d2 = df(p);\n  float h = smoothstep(aa, -0.5*aa, (d2.x-0.0125));\n  h *= height;\n  return h;\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n\n  vec3 n;\n\n  n.x = hf(p + eps.xy) - hf(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = hf(p + eps.yx) - hf(p - eps.yx);\n\n  return normalize(n);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col = 0.025*skyCol;\n//  col += speCol3*0.25E-3/max(abs(rd.y-0.35), 0.0001);\n  col += speCol1*0.25E-2/pow((1.0001+((dot(sunDir1, rd)))), 2.0);\n  col += speCol2*0.25E-2/pow((1.0001+((dot(sunDir2, rd)))), 2.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec3 fsharpEffect(vec2 p) {\n  float s = 1.5;\n  vec3 lp1 = sunDir1;\n  vec3 lp2 = sunDir2;\n  float h  = hf(p);\n  vec3 n   = normal(p);\n  vec3 ro  = vec3(0.0, 10.0, 0.0);\n  vec3 pp  = vec3(p.x, h, p.y);\n  vec3 rd  = normalize(pp-ro);\n  vec3 ref = reflect(rd, n);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n\n  const mat2 rot = ROT(-PI/2.0+0.4); \n  ref.zy *= rot;\n\n  const float dm = 1.0;\n  float diff1 = pow(max(dot(ld1, n), 0.0), dm);\n  float diff2 = pow(max(dot(ld2, n), 0.0), dm);\n  vec3 rsky   = skyColor(pp, ref);\n\n  vec3 col = vec3(0.0);\n\n  float hh = smoothstep(0.00, height, h);\n  col += (matCol*diffCol1)*diff1*mix(0.2, 1.0, hh);\n  col += (matCol*diffCol2)*diff2*mix(0.2, 1.0, hh);\n  col += rsky*mix(1.0, 0.5, hh);\n  col -= 0.05*vec3(2.0, 2.0, 1.0);\n\n  return col;\n}\n\nvec3 stars(vec2 sp, float hh) {\n  const vec3 scol0 = HSV2RGB(vec3(0.85, 0.8, 1.0));\n  const vec3 scol1 = HSV2RGB(vec3(0.65, 0.5, 1.0));\n  vec3 col = vec3(0.0);\n  \n  const float m = 4.0;\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    pp += o*dim*0.5;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*mix(scol0, scol1, h1*h1);\n\n    vec3 ccol = col + exp(-0.5*(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    ccol *= mix(0.125, 1.0, smoothstep(1.0, 0.99, sin(0.25*TIME+TAU*h.y)));\n    col = ccol;\n  }\n  \n  return col;\n}\n\nvec3 triEffect(vec3 col, vec2 p) {\n  vec2 op = p;\n  const vec2 n = SCA(-PI/3.0);\n  float hoff = 0.15*dot(n, p);\n  vec3 gcol = hsv2rgb(vec3(clamp(0.7+hoff, 0.6, 0.8), 0.90, 0.02));\n  vec2 pt = p;\n  pt.y -= 0.3;\n  pt.y = -pt.y;\n  const float zt = 1.0;\n  float dt = equilateralTriangle(pt/zt)*zt;\n  col = dt < 0.0 ? col : stars(op, 0.8);\n  col += 2.0*gcol;\n  col = dt < 0.0 ? fsharpEffect(p) : col;\n  col += gcol/abs(dt);\n  return col;  \n}\n\nvec3 fsharpWeeklyEffect(vec3 col, float aa, vec2 p) {\n  const vec2 n = SCA(-PI/4.0);\n\n  vec2 pf = p;\n  pf.y -= -0.32;\n  float hoff = 0.15*dot(n, pf);\n  vec3 gcol = hsv2rgb(vec3(0.625+hoff, 0.85, 1.0));\n  \n  vec2 df2 = dfsharpWeekly(pf, vec2(0.0));\n\n  col = mix(col, col*sqrt(gcol), smoothstep(aa, -aa, df2.x));\n  col += 0.005*gcol/abs(df2.x);\n\n  float fy = pf.y+0.18;\n  vec3 skyCol = hsv2rgb(vec3(0.7+0.125*fy, 0.95, 0.3*(1.0+.0*abs(fy))));\n  vec3 fcol = vec3(0.0);\n  fcol += clamp(skyCol/pow(abs(fy), 0.65), 0.0, 10.0);\n  col = mix(col, fcol, smoothstep(aa, -aa, df2.y));\n  col = mix(col, vec3(2.0), smoothstep(aa, -aa, abs(df2.y)-0.003));\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n\n  col = triEffect(col, p);\n  col = fsharpWeeklyEffect(col, aa, p);\n  \n  col *= smoothstep(1.5, 0.25, length(pp));\n  col *= mix(vec3(0.5), vec3(1.0),smoothstep(-0.9, 0.9, sin(0.25*TAU*p.y/aa+TAU*vec3(0.0, 1., 2.0)/3.0)));\n\n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 490, 512, 512, 658], [1541, 1641, 1660, 1660, 1747], [1749, 1856, 1882, 1882, 2066], [2068, 2154, 2190, 2190, 2284], [2286, 2346, 2366, 2366, 2478], [2480, 2598, 2625, 2625, 2701], [2703, 2821, 2863, 2863, 2922], [2924, 3042, 3081, 3081, 3193], [3195, 3313, 3348, 3348, 3547], [3549, 3661, 3703, 3703, 3750], [3752, 3852, 3891, 3891, 3976], [3978, 3978, 4017, 4017, 4046], [4048, 4148, 4184, 4184, 4268], [4270, 4270, 4298, 4298, 4326], [4328, 4328, 4361, 4361, 4442], [4444, 4444, 4466, 4466, 4851], [4853, 4853, 4891, 4891, 5438], [5440, 5440, 5457, 5457, 5634], [5636, 5636, 5654, 5654, 5869], [5871, 5871, 5892, 5892, 6073], [6075, 6075, 6108, 6108, 6790], [6792, 6792, 6819, 6819, 7588], [7590, 7590, 7621, 7621, 8431], [8433, 8433, 8467, 8467, 8869], [8871, 8871, 8924, 8924, 9528], [9530, 9530, 9560, 9560, 9899], [9901, 9901, 9957, 9957, 10129]], "test": "untested"}
{"id": "cdlXDH", "name": "Gummy Worm Pachinko", "author": "fenix", "description": "Nothing revolutionary here, just dipping my toes barely into soft body simulation using position based dynamics. Collisions (including self-collisions) are resolved via neighbors.\n\n*mouse to attract gummies*\n*space to reset* \n*shift to render neighbors*", "tags": ["2d", "voronoi", "simulation", "particles", "physics", "softbody", "gummy", "pdb"], "likes": 41, "viewed": 1027, "published": 3, "date": "1668974347", "time_retrieved": "2024-07-30T16:18:18.408887", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Nothing revolutionary here, just dipping my toes barely into soft body simulation\n//  using position based dynamics. Rendering is substantially the same as Four-Phase\n//  Fluid Mixer, except I render all densities together because I'm not trying to create\n//  oil-in-water droplets. Also, no need to blur the particles means that performance is\n//  a lot better. The particle sim was converted to position-based (verlet) dynamics to\n//  simplify computations.\n//\n//  Collisions (including self-collisions) are resolved via neighbors as before, but the\n//  worm particles are implicitly aware of the other particles within their own worm. Each\n//  particle solves a length constraint with every other particle in each worm, providing\n//  stretching and bending resistance.\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//  Buffer C renders the particles: rgb contains color, alpha contains density\n//\n// ---------------------------------------------------------------------------------------\n\nvec2 gradient(vec2 fragCoord)\n{\n    vec2 delta = vec2(1., 0);\n    float xGrad = texture(iChannel0, (fragCoord + delta.xy) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.xy) / iResolution.xy).a;\n        \n    float yGrad = texture(iChannel0, (fragCoord + delta.yx) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.yx) / iResolution.xy).a;\n\n    return 10.*(vec2(xGrad, yGrad));\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{   \n    fragCoord *= VIEW_RESTRICT;\n    vec2 grad = gradient(fragCoord);\n\n    vec4 color = texture(iChannel0, fragCoord/iResolution.xy);\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec4 background = textureLod(iChannel1, p, 5.0);\n    float density = color.a;\n    const vec3 lightDir = normalize(vec3(1,-1,1));\n    float gummySpec = computeSpecular(0.8, 15.0, normalize(vec3(-grad.x, 1, -grad.y)), lightDir, vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    color += gummySpec;\n    vec4 water = texture(iChannel1, p + grad * 0.2) * color; // Refract :)\n    fragColor = mix(background, water, smoothstep(0.5, 1.0, density)); // Blur worm edges\n\n    fxState state = fxGetState();\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y) * 0.004);\n\n    float wallDist = distanceFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution);\n    \n    vec3 steelNorm = texture(iChannel2, steelCoord/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution) * (1.0 - smoothstep(0.007, 0.01, -wallDist));\n\n    steelNorm = normalize(steelNorm);\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, lightDir, vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.5 + 0.3;\n\n    fragColor = mix(fragColor, steel, vec4(clamp(-wallDist*iResolution.y, 0.0, 1.0)));\n    if (keyDown(KEY_SHIFT))\n        fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgba);\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int PARTICLES_PER_WORM = 16;\nconst int MAX_PARTICLES = 1600 * PARTICLES_PER_WORM; \nconst float PARTICLE_REPEL_SIZE = .013;\nconst float VIEW_RESTRICT = .82; // don't show entire image since worms get a bit crowded at the very top when collision first kicks in\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat opRepCircle( in vec2 p, in vec2 c, float r )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    if (mod(p.y+.5, c.y*2.) < c.y) q.x = mod(p.x, c.x) - 0.5*c.x;\n    return sdCircle( q, r );\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x);\n    minDist = min(minDist, VIEW_RESTRICT * resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.);\n    //if (point.y > 0. && point.y < 1.)\n        minDist = min(minDist, opRepCircle(point - 0.5, vec2(0.15), 0.02));\n        \n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution )\n{\n\tvec2 delta = vec2( 0.001, 0.0 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + delta.xy, resolution ); \n    float downTinyChangeInX = distanceFromWalls( point - delta.xy, resolution ); \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    float upTinyChangeInY   = distanceFromWalls( point + delta.yx, resolution ); \n    float downTinyChangeInY = distanceFromWalls( point - delta.yx, resolution ); \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n\tvec2 normal = vec2(tinyChangeInX, tinyChangeInY);\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 prev;\n    \n    ivec4 neighbors[4];\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.prev = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS:  \n        return vec4(p.pos, p.prev);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nstruct fxState\n{\n    float resolution;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    fxState state;\n    state.resolution = data.x;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, 0, 0, 0);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p, float ar)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2((p - b * h) * vec2(ar, 1)); // squared dist to segment\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes particle positions and neighbors\n// ---------------------------------------------------------------------------------------\n\nconst vec2 GRAVITY = vec2(0., -.00002);\nconst float COLLISION_STIFFNESS = .05;\nconst float CONSTRAINT_STIFFNESS = .3;\nconst float BEND_RESISTANCE = .1;\nconst float MAX_VEL = .003;\nconst float DAMPING = .97;\nconst float BOUNDARY_DIST = .004;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate MAX_PARTICLES amount of particles\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=MAX_PARTICLES) return;\n    \n    fxParticle data = fxGetParticle(id);\n    fxState state = fxGetState();\n    \n    if (dataType >= POS)\n    {\n        if (iFrame == 0 || state.resolution < 0.)\n        {\n            // init particles\n            int wormId = id / PARTICLES_PER_WORM;\n            vec3 h1 = hash3(uvec3(wormId) * uvec3(3, 6, 9));\n\n            data.pos = .9*VIEW_RESTRICT * vec2(1, 2) * h1.xy * iResolution.x / iResolution.y + vec2(0, 0);\n            data.pos += rot2(h1.z) * vec2(1, 0) * PARTICLE_REPEL_SIZE * float(id % PARTICLES_PER_WORM);\n            data.prev = data.pos;\n        }\n        else\n        {\n            // handle collisions with neighbors\n            for(int i = 0; i < 4; i++)\n            {\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid == id - 1 || cid == id + 1 || cid==-1 || cid == 0 || cid >= MAX_PARTICLES) continue;\n                    \n                    fxParticle n = fxGetParticle(cid);\n                    \n                    vec2 deltaPos = data.pos - n.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    vec2 dir = deltaPos / dist;\n \n                    if (dist < PARTICLE_REPEL_SIZE)\n                    {\n                        data.pos = mix(data.pos, n.pos + PARTICLE_REPEL_SIZE * dir, COLLISION_STIFFNESS);\n                    }\n                }\n            }       \n\n            bool offScreen = data.pos.y < -.5;\n\n            // handle internal worm constraints\n            int wormId = id / PARTICLES_PER_WORM;\n            int beginP = wormId * PARTICLES_PER_WORM;\n            int endP = min(MAX_PARTICLES - 1, beginP + PARTICLES_PER_WORM) - 1;\n            \n            for (int i = beginP; i < endP; ++i)\n            {\n                if (i != id && i < MAX_PARTICLES)// && abs(i - id) <= 1)\n                {\n                    float cLen = abs(float(i - id)) * PARTICLE_REPEL_SIZE * .5;\n                    fxParticle w = fxGetParticle(i);\n                    \n                    if (w.pos.y > -.5) offScreen = false;\n                    \n                    float f = 1. / square(abs(float(i - id)));\n                    if (distance(w.pos, data.pos) < cLen)\n                    {\n                        f *= BEND_RESISTANCE;\n                    }\n                    \n                    data.pos = mix(data.pos, w.pos + cLen * normalize(data.pos - w.pos), CONSTRAINT_STIFFNESS * f);\n                }\n            }\n            \n            // handle teleporting back to top after falling off the bottom (has to be entire worms at once)\n            if (offScreen)\n            {\n                float h = hash3(uvec3(wormId, wormId * iFrame, iFrame)).x;\n                data.pos.x = VIEW_RESTRICT * h * iResolution.x / iResolution.y;\n                data.pos.y += 2.5;\n                data.prev = data.pos;\n            }\n            \n            // handle mouse input\n            if (iMouse.z > 0.)\n            {\n                vec2 m = VIEW_RESTRICT * (iMouse.xy) / iResolution.y;\n                const float MOUSE_RANGE = .05;\n                if (distance(m, data.pos) < MOUSE_RANGE)\n                {\n                    const float MOUSE_STRENGTH = .01;\n                    data.pos = mix(data.pos, m, MOUSE_STRENGTH);\n                }\n            }\n            \n            // handle boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution);\n            if (distToScene < BOUNDARY_DIST)\n            {\n                vec2 distNormal = getNormalFromWalls(data.pos, iResolution);\n                data.pos -= 1.0 * distNormal * (distToScene - BOUNDARY_DIST);\n            }\n            \n            // handle position integration\n            vec2 prev = data.prev;\n            vec2 deltaPos = prev - data.pos;\n            float vel2 = length2(deltaPos);\n            if (vel2 > MAX_VEL * MAX_VEL)\n            {\n                prev = data.pos + inversesqrt(vel2) * deltaPos * MAX_VEL;\n            }\n            data.prev = data.pos;\n            data.pos = data.pos + GRAVITY + (data.pos - prev) * DAMPING;\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 2;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k);\n            //pick random id of particle\n            int p = int(mod(h*34534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Computes neighbors to each screen pixel to accelerate rendering\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord)\n{\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        fxState state = fxGetState();\n        \n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution) || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y;\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n        }\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 8u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    // search the worm associated with the closest particle, because some of those particles\n    // are likely to be nearby\n    int id = old[0];\n    int wormId = id / PARTICLES_PER_WORM;\n    int beginP = wormId * PARTICLES_PER_WORM;\n    int endP = min(MAX_PARTICLES - 1, beginP + PARTICLES_PER_WORM) - 1;\n    beginP += iFrame % 5;\n\n    for (int i = beginP; i < endP; i += 5)\n    {\n        if (i != id && i < MAX_PARTICLES)// && abs(i - id) <= 1)\n        {\n            insertion_sort(new, dis, i, distance2Particle(i, screen2world(fragCoord)));\n        }\n    }\n\n    int searchIterations = 2;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash3(uvec3(fragCoord, iFrame * searchIterations + k)).x;\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Renders particles: rgb contains color, alpha contains density\n// ---------------------------------------------------------------------------------------\n\nconst vec3 lightDir = normalize(vec3(1,-1,1));\n\nconst float PARTICLE_SIZE = .005;\n\nconst vec3[5] MAT_COLORS = vec3[](vec3(0., 1., 0.),\n                                  vec3(1., .7, 0.),\n                                  vec3(1., 0., 0.),\n                                  vec3(1., 1., 0.),\n                                  vec3(.9, .9, .6));\n\n\nvoid renderParticle(in fxParticle p, int id, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    p.prev.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(fxLinePointDist2(p.pos, p.prev, fragCoord, iResolution.x / iResolution.y));\n   \n    int material = int(id * 4 / PARTICLES_PER_WORM) % 5;\n    fragColor.a = max(fragColor.a, mix(fragColor.a, 1., 1.-smoothstep(PARTICLE_SIZE * .15, PARTICLE_SIZE * 2., dist)));\n    if (dist < PARTICLE_SIZE)\n    {\n        if (fragColor.xyz == vec3(0))\n            fragColor.xyz = MAT_COLORS[material];\n        else\n            fragColor.xyz = mix(fragColor.xyz, MAT_COLORS[material], .5);\n    }\n    \n    // Render neighbor lines\n    if (keyDown(KEY_SHIFT))\n    {\n        for(int i = 0; i < 4; i++){\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==-1 || cid >= MAX_PARTICLES || cid == 0) continue;\n\n                vec2 otherPos = fxGetParticleData(cid, POS).xy;\n                otherPos.x *= iResolution.y / iResolution.x;\n\n                float distToLin = fxLinePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution.x / iResolution.y);\n                fragColor.xyz += iResolution.x* max(0.0, 0.001 - sqrt(distToLin)) / (0.0004);\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fragColor = vec4(0);\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n\n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, id, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlXDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1291, 1291, 1322, 1322, 1709], [1711, 1711, 1874, 1874, 2079], [2081, 2081, 2135, 2135, 3605]], "test": "untested"}
{"id": "cslXR7", "name": "Neon Sliced Gyroid", "author": "byt3_m3chanic", "description": "Sliced Gyroid Fly Though 2 - Dream Flight & Neon Lights. ", "tags": ["raymarching", "gyroid", "sliced"], "likes": 36, "viewed": 490, "published": 3, "date": "1668972731", "time_retrieved": "2024-07-30T16:18:19.585742", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Neon Sliced Gyroid - Dream Flight & Neon Lights\n    11/20/22 | @byt3_m3chanic\n\n    Somewhat abstract and organic field sliced into ribbons based\n    on @smjtyazdi formula listed below. Added an etra iteration to \n    clear up some backside artifacts in the sdf. \n\n    my original shader which has a polar warp and pretty forward\n    camera track > https://www.shadertoy.com/view/dssXzN both \n    about the same visually - but I like the cameara motion in this\n    version. Using a few sin/cos time based formulas to simulate \n    some wander/drag though the gyroid space.\n    \n    @smjtyazdi https://twitter.com/smjtyazdi/status/1484828390104485896\n\n*/\n\n#define R     iResolution\n#define T     iTime\n#define M     iMouse\n#define PI    3.14159265358\n#define PI2   6.28318530718\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.34,35.34)))*483434.);}\n\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\n//globals\nmat2 trot;\nfloat glo1=0.,slo1=0.,glo2=0.,slo2=0.;\nconst float ofx = 1.125;\n\nfloat gyroid(vec3 p, float s, float t, float b) {\n    p *= s;\n    return abs(dot(sin(p*ofx),cos(p.zxy))-b)/(s*ofx)-t;\n}\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,1.);\n\n    p.xy *= trot;\n    p.yz += vec2(-1.25, -T);\n    \n    float m1 = 4.85+4.75*sin(T*.15);\n    float m2 = 5.85+5.75*cos(T*.35);\n    \n    float d = .65, mf = 1e5;\n    for(float j=-1.;j<2.;j++){\n        vec3 nf =p;\n        nf.z=round(nf.z/d+j)*d;\n \n        float idx = mod(nf.z+5.,10.);\n        float idy = mod(nf.z,12.);\n\n        float fd = gyroid(nf, .75, .0, .525);\n        fd=abs(fd)-.045;\n        nf.z=clamp(p.z,nf.z-d/3.5,nf.z+d/3.5);\n        fd=length(vec2(max(.0,fd), nf.z-p.z));\n\n        if(idx<m1+.15&&idx>m1) slo1+=.002/(.015+fd*fd);\n        if(idy<m2+.15&&idy>m2) slo2+=.002/(.015+fd*fd);\n   \n        mf=min(mf,fd);\n    }\n    if(mf<res.x) res=vec2(mf,3.);\n    return res;\n}\n\nvec3 normal(vec3 p, float t){\n    vec2 e=vec2(t*1e-4,0.);\n    float d = map(p).x;\n    vec3 n = d-vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 topLayer(in vec3 C, in vec2 uv) {\n    float ft = floor(T);\n    uv*=rot(.05);\n \n    float d = box(uv-vec2(.075,.0),vec2(.85,.4))-.01;\n\n    vec2 pv = uv*2.;\n    \n    float md = floor((pv.y+.05)/.1);\n    float mf = mix(hash21(vec2(ft)+md),hash21(vec2(ft+1.)+md),pow(smoothstep(0.,1.,fract(T)), 22.))*.22;\n    \n    pv.y=mod(pv.y+.05,.1)-.05;\n    float ff=.075;\n    float e = box(pv+vec2(1.75-ff,.0),vec2(.15+ff,.025))-.01;\n    float ex = box(pv+vec2(1.89-mf,.0),vec2(mf,.015))-.005;\n    \n    float px = 4./R.x;\n    float ei = smoothstep(px,-px,abs(e)-.002);\n          ex = smoothstep(px,-px,ex);\n          e  = smoothstep(px,-px,e);\n          \n    px = 2./R.x;\n    float c = smoothstep(px,-px,d);\n          d = smoothstep(px,-px,abs(abs(d)-.005)-.00125);\n    \n    uv.x-=T*.05;\n    \n    vec2 f=fract(uv*25.*rot(-.78))-.5;\n    \n    C=mix(C,C.xxx*.15,1.-c);\n    if(mod(f.x,2.)<1.) C=mix(C,C+vec3(.015),1.-c);\n    C=mix(C,vec3(1),d);\n    if(abs(md)<6.5) C=mix(C,vec3(.001),e);\n    if(abs(md)<6.5) C=mix(C,mix(vec3(.0,.09,.3),vec3(.52,.09,.58),clamp((uv.y+.25)*2.,0.,1.)),ex);\n    if(abs(md)<6.5) C=mix(C,vec3(1),ei);\n\n    return C;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 F )\n{\n    //precal\n    trot = rot(T*.072);\n    \n    //set uv\n\tvec2 uv = (2.*F.xy - R.xy)/max(R.x,R.y);\n    vec2 vv=uv;\n\n\tvec3 C = vec3(0);\n    vec3 ro = vec3(0,0,.15),rd = normalize(vec3(uv, -1.0));\n\n    const float dof = .001;\n    const float dofdist = 1./15.;\n    vec2 off=vec2(0);\n    \n    //mouse\n    float x = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.x/R.x * 1. - .5) * PI;\n\n    mat2 rx = rot(x),ry = rot(M.z < 1.?y+1.725*sin(PI*sin(T*.07)):y);\n\n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n   \n    //loop\n    float fa=0.;\n    for(int k=0;k<2;k++){\n    \n        vec3 p = ro;\n        float d = 0., m = 0.;\n        vec3 RC = vec3(0);\n        \n        for(int i=0;i<172;i++){\n            \n            //modified jitter/dof \n            //inspiration @Nusan https://www.shadertoy.com/view/3sXyRN\n            if(mod(float(i),2.)<1.){\n                off= texture(iChannel1,F.xy/1024.).rg*2.-1.;\n                vec2 focus = off*dof;\n                ro.xy+= focus*(d)*.01;\n                rd.xy+= focus*(d*d)*dofdist*.01;\n            }\n\n            p=ro+d*rd;\n            vec2 ray = map(p);\n            m=ray.y;\n            d+= i<82?ray.x*.4:ray.x*.8;\n            if(ray.x<d*1e-3||d>40.)break;\n        }\n\n        if(k==0) {fa=d;glo1=slo1;glo2=slo2;}\n        \n        if(d<40.) {\n            vec3 n = normal(p,d);\n            vec3 l = normalize(vec3(-2,15,-10)-p);\n            float spec = .45 * pow(max(dot(normalize(p-ro),reflect(l,n)),0.),24.);\n            RC += vec3(.0) +spec;  \n    \n            ro = p+n*.001;\n            rd = reflect(rd,n);\n        }\n\n        if(k>0) RC *=.3;\n        C += RC;\n\n    }\n    \n    float sp = .2+.2*sin(uv.x*4.2+T*.2);\n    vec3 fog = mix(vec3(.20,.52,.85),vec3(.69,.16,.77),clamp((uv.y+.5-sp),0.,1.));\n\n    C = mix(C,vec3(glo1*.125,glo1*.55,glo1),clamp(glo1,.0,.6));\n    C = mix(C,vec3(glo2,glo2*.125,glo2*.75),clamp(glo2,.0,.8));\n    C = mix(C,fog, 1.-exp(-.00015*fa*fa*fa));\n    \n    C = topLayer(C, uv);\n    C = clamp(C,vec3(0),vec3(1));\n    \n    //gamma + out\n    C = pow(C,vec3(.4545));\n\tfragColor = vec4(C,1.);\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslXR7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[880, 880, 899, 899, 942], [943, 943, 964, 964, 1018], [1020, 1020, 1046, 1046, 1122], [1210, 1210, 1259, 1259, 1329], [1331, 1331, 1349, 1349, 2060], [2062, 2062, 2091, 2091, 2269], [2271, 2271, 2309, 2309, 3401], [3403, 3403, 3452, 3465, 5585]], "test": "untested"}
{"id": "DsXSDM", "name": "F# Weekly Windows Neon style", "author": "mrange", "description": "CC0: F# Weekly Windows Neon style\nA shader background for Windows Terminal featuring the F# weekly logo\nEnded up being kind of a neon style shader\n", "tags": ["windowsterminal"], "likes": 14, "viewed": 323, "published": 3, "date": "1668972487", "time_retrieved": "2024-07-30T16:18:20.443448", "image_code": "// CC0: F# Weekly Windows Neon style\n//  A shader background for Windows Terminal featuring the F# weekly logo\n//  Ended up being kind of a neon style shader\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 skyCol   = HSV2RGB(vec3(0.58, 0.86, 1.0));\nconst vec3 speCol1  = HSV2RGB(vec3(0.55, 0.9, 1.0));\nconst vec3 speCol2  = HSV2RGB(vec3(0.8 , 0.6, 1.0));\nconst vec3 speCol3  = HSV2RGB(vec3(0.9, 0.86, 4.0));\nconst vec3 matCol   = HSV2RGB(vec3(0.8,0.50, 0.5)); \nconst vec3 diffCol1 = HSV2RGB(vec3(0.60,0.90, 2.0)); \nconst vec3 diffCol2 = HSV2RGB(vec3(0.85,0.90, 2.0));\nconst vec3 sunDir1  = normalize(vec3(0.9, -0.4, 1.0));\nconst vec3 sunDir2  = normalize(vec3(-0.9 , 0.0, 1.0));\n\n\nconst float outerZoom = 1.50;\nconst float innerZoom = 1.0-0.4;\nconst float height = -0.065*outerZoom;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  p = abs(p);\n  return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 pmin(vec2 a, vec2 b, float k) {\n  vec2 h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 pabs(vec2 a, float k) {\n  return -pmin(-a, a, k);\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\nvec2 dfsharp(vec2 p) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  vec2 p3 = p;\n  const float sm = 0.03;\n  p0 = pabs(p0, sm);\n  const vec2 n = normalize(vec2(1.0));\n  float d0 = abs(dot(n, p0)-0.38)-0.12;\n  float d1 = abs(p1.x)-0.025;\n  float d2 = dot(n, p0)-0.19;\n  float d3 = -p3.x-0.025;\n  d2 = pmax(d2, -d3, sm);\n  float d = d0;\n\n  d = pmax(d, -d1, sm);\n  d = min(d,  d2);\n  return vec2(d, p.x > 0.0 ? 1.0 : 0.0);\n}\n\nvec2 dfsharpWeekly(vec2 p, vec2 off) {\n  const mat2 rot45 = ROT(PI/4.0);\n  const vec2 refN = SCA(-PI/4.0);\n  const float r = 0.125;\n  const float rr = 2.0*r*sqrt(2.0);\n  vec2 p0 = p;\n  vec2 p1 = p-off;\n  p0 = abs(p0);\n  ref(p0, refN);\n  p0.y -= rr;\n  float d0 = roundedX(p0, rr, r);\n  float d1 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.0, 1.0))-r;\n  float d2 = segment(p1, rr*vec2(0.5, -0.5), rr*vec2(0.0, -1.0))-r;\n  float d3 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.5, -1.5))-r;\n  float d = d0;\n  float dd = d1;\n  dd = min(dd, d2);\n  dd = min(dd, d3);\n  \n  return vec2(d, dd);\n}\n\nvec2 df(vec2 p) {\n  const mat2 rot45 = ROT(PI/4.0);\n  p *= transpose(rot45);\n  vec2 cp = (p-0.5);\n  vec2 cn = round(cp);\n  cp -= cn;\n  cp *= rot45;\n  \n  return dfsharp(cp/innerZoom)*innerZoom;\n}\n\nfloat hf(vec2 p) {\n  const float a = .05;\n  p += 0.125*sin(vec2(1.0, sqrt(0.5))*TIME*a)/a;\n  const float aa = 0.06;\n  p /= outerZoom;\n  vec2 d2 = df(p);\n  float h = smoothstep(aa, -0.5*aa, (d2.x-0.0125));\n  h *= height;\n  return h;\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n\n  vec3 n;\n\n  n.x = hf(p + eps.xy) - hf(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = hf(p + eps.yx) - hf(p - eps.yx);\n\n  return normalize(n);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col = 0.025*skyCol;\n  col += speCol3*0.25E-3/max(abs(rd.y-0.35), 0.0001);\n  col += speCol1*0.25E-2/pow((1.0001+((dot(sunDir1, rd)))), 2.0);\n  col += speCol2*0.25E-2/pow((1.0001+((dot(sunDir2, rd)))), 2.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec3 bkg(vec2 p) {\n  float s = 1.5;\n  vec3 lp1 = sunDir1;\n  vec3 lp2 = sunDir2;\n  float h  = hf(p);\n  vec3 n   = normal(p);\n  vec3 ro  = vec3(0.0, 10.0, 0.0);\n  vec3 pp  = vec3(p.x, h, p.y);\n  vec3 rd  = normalize(pp-ro);\n  vec3 ref = reflect(rd, n);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n\n  const mat2 rot = ROT(-PI/2.0+0.4); \n  ref.zy *= rot;\n\n  const float dm = 1.0;\n  float diff1 = pow(max(dot(ld1, n), 0.0), dm);\n  float diff2 = pow(max(dot(ld2, n), 0.0), dm);\n  vec3 rsky   = skyColor(pp, ref);\n\n  vec3 col = vec3(0.0);\n\n  float hh = smoothstep(0.00, height, h);\n  col += (matCol*diffCol1)*diff1*mix(0.2, 1.0, hh);\n  col += (matCol*diffCol2)*diff2*mix(0.2, 1.0, hh);\n  col += rsky*mix(1.0, 0.5, hh);\n  col -= 0.05*vec3(2.0, 2.0, 1.0);\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const vec3 fcol0 = HSV2RGB(vec3(0.62, 0.95, 2.0));\n  const vec3 fcol1 = HSV2RGB(vec3(0.62, 0.70, 2.0));\n\n  float aa = 2.0/RESOLUTION.y;\n  const float zf = 1.5;\n  vec2 pf = p/zf;\n  \n  const vec2 soff = -vec2(0.01, -0.01)*1.25;\n  vec2 df2 = dfsharpWeekly(pf, 0.5*soff)*zf;\n  vec2 dfs2 = dfsharpWeekly(pf+soff, 0.5*soff)*zf;\n\n  vec3 col = vec3(0.0);\n  col = bkg(p);\n  col = mix(col, col*0.2, smoothstep(aa, -aa, 0.125*dfs2.x));\n  col = mix(col, fcol1, smoothstep(aa, -aa, df2.x));\n  col = mix(col, col*0.2, smoothstep(aa, -aa, 0.125*dfs2.y));\n  col = mix(col, fcol0, smoothstep(aa, -aa, df2.y));\n  col *= 1.5*smoothstep(1.5, 0.25, length(pp));\n  col *= mix(vec3(0.5), vec3(1.0),smoothstep(-0.9, 0.9, sin(0.25*TAU*p.y/aa+TAU*vec3(0.0, 1., 2.0)/3.0)));\n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 532, 554, 554, 700], [1584, 1684, 1703, 1703, 1790], [1792, 1899, 1925, 1925, 2109], [2111, 2229, 2256, 2256, 2332], [2334, 2452, 2494, 2494, 2553], [2555, 2673, 2712, 2712, 2824], [2826, 2938, 2980, 2980, 3027], [3029, 3129, 3168, 3168, 3253], [3255, 3255, 3294, 3294, 3323], [3325, 3425, 3461, 3461, 3545], [3547, 3547, 3575, 3575, 3603], [3605, 3605, 3638, 3638, 3719], [3721, 3721, 3743, 3743, 4128], [4130, 4130, 4168, 4168, 4715], [4717, 4717, 4734, 4734, 4911], [4913, 4913, 4931, 4931, 5146], [5148, 5148, 5169, 5169, 5350], [5352, 5352, 5385, 5385, 6065], [6067, 6067, 6085, 6085, 6854], [6856, 6856, 6886, 6886, 7697], [7699, 7699, 7751, 7751, 7923]], "test": "untested"}
{"id": "cdfSWM", "name": "swirl explosion", "author": "lomateron", "description": "click to interact\nkey W to reset\nsimilar to https://www.shadertoy.com/view/7lVGzD\nbut this one has mass appart from just 2D velocity vectors", "tags": ["fluid"], "likes": 30, "viewed": 423, "published": 3, "date": "1668968381", "time_retrieved": "2024-07-30T16:18:21.631271", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = (+sin(a.x+vec4(0,1,2,4)+5.)*.5\n                 +sin(a.y+vec4(5,3,1,4)+5.)*.5+1.)*a.z;\n    //fragColor = a.zzzz;\n    //fragColor = a;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        r.xy += c*b.z*cos(dot(b.yx*vec2(-1,1),vec2(i,j))*.3)*exp(-l*l*.1)*.5;\n        //r.xy += c*min(b.z,0.)*cos(dot(b.yx*vec2(-1,1),vec2(i,j))*.2)*exp(-l*l*.1)*.5;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy +B(u).xy;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j));\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j));\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(-normalize(m),0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        vec2 m = 22.*(u-iResolution.xy*.5)/450.;\n        a = vec4(0,0,.5,0)-vec4(8,8,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 283]], "test": "untested"}
{"id": "dslSDN", "name": "Orthogonal clusters", "author": "A_Toaster", "description": "Two orthogonal star clusters in the 4d spacetime described by Greg Egan in his Orthogonal series. Different wavelengths have a different angle relative to the observer's time, leading to the spectral star trails.", "tags": ["raymarching", "volumetric", "4d", "orthogonal"], "likes": 7, "viewed": 316, "published": 3, "date": "1668960831", "time_retrieved": "2024-07-30T16:18:23.189106", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture( iChannel0, uv ).xyz * 0.5;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nconst float FIELD_OF_VIEW = 1.2;\n\n// camera directions\nconst vec4 FWD_4 = vec4(1., 0., 0., 0.);\nconst vec4 UP_4 = vec4(0., 0., 1., 0.);\n\n// raymarching parameters\nconst float GLOW_DIST = 0.05;\n#ifdef HIGH_QUALITY\n\nconst float MAX_DIST = 300.;\n#define MAX_ITERATIONS 64\nconst float STAR_SIZE = 0.15;\n#else\n#ifdef POTATO_QUALITY\nconst float MAX_DIST = 200.;\n#define MAX_ITERATIONS 16\nconst float STAR_SIZE = 0.3;\n#else\nconst float MAX_DIST = 200.;\n#define MAX_ITERATIONS 64\nconst float STAR_SIZE = 0.2;\n#endif\n#endif\n\n// cluster settings\nconst float CLUSTER_CELL_SIZE = 15.;\nconst float CLUSTER_RAND_VEL = float(STAR_VELOCITY);\nconst vec4 CLUSTER_FUTURE = vec4(0., 0., 0., 1.);\n// Used to keep stars centered within their domains\nconst float CENTER_LIGHT_TIME_VEL = 1. / sqrt(1. + 0.5 * 0.5);\n\n// projection operator\nvec4 proj(vec4 u, vec4 v) {\n    return (u * dot(u,v)) / dot(u, u);\n}\n\n// Calculate a vector orthogonal (but not orthonormal) to three other 4-vectors\nvec4 cross4(vec4 u, vec4 v, vec4 t){\n    return vec4(\n        ( u.w * v.z - u.z * v.w) * t.y + (-u.w * v.y + u.y * v.w) * t.z + (-u.y * v.z + u.z * v.y) * t.w,\n        (-u.w * v.z + u.z * v.w) * t.x + ( u.w * v.x - u.x * v.w) * t.z + ( u.x * v.z - u.z * v.x) * t.w,\n        ( u.w * v.y - u.y * v.w) * t.x + (-u.w * v.x + u.x * v.w) * t.y + (-u.x * v.y + u.y * v.x) * t.w,\n        ( u.y * v.z - u.z * v.y) * t.x + (-u.x * v.z + u.z * v.x) * t.y + ( u.x * v.y - u.y * v.x) * t.z\n    \n    );\n}\n\n// Returns a 4-d ray direction orthogonal to the time vector given a set of camera parameters.\nvec4 camera_spacelike_dir(vec2 uv, vec4 cameraDirection, vec4 cameraUp, vec4 cameraFuture) {\n    \n\tuv = uv * FIELD_OF_VIEW;\n    \n    // Up/fwd vec orthogonal to future\n    vec4 fut = cameraFuture;\n    vec4 up_vec = normalize(cameraUp - proj(fut, cameraUp));\n    vec4 fwd_vec = normalize(cameraDirection - proj(fut, cameraDirection));\n    // Right vec orthogonal to all other directions\n    vec4 right_vec = normalize(cross4(up_vec, fwd_vec, fut));\n    \n    vec4 spacelike_dir = normalize(fwd_vec + uv.y * up_vec + uv.x * right_vec);\n    \n    return spacelike_dir;\n}\n\n// Returns 4-d ray direction given a spacelike direction and a velocity in the timelike direction.\nvec4 camera(vec4 spacelike_dir, vec4 cameraFuture, float futureVel) {\n    vec4 timelike_dir = cameraFuture * futureVel;\n    \n    return normalize(spacelike_dir + timelike_dir);\n}\n\nint hash(ivec3 co){\n    return co.x + 123 * co.y + 12345 * co.z;\n}\n\n\nvec4 rand1_4(float i) {\n    vec2 co = vec2(i, floor(i / iChannelResolution[0].x));\n    return texture(iChannel0, co);\n}\n\nvec3 rand3_3(ivec3 i) {\n    ivec2 co = ivec2(mod(float(i.x + 13 * i.z), iChannelResolution[0].x), mod(float(i.y + 29 * i.z), iChannelResolution[0].y));\n    return texelFetch(iChannel0, co, 0).rgb;\n}\n\nvec3 rand3_1(ivec3 i) {\n    ivec2 co = ivec2(mod(float(i.x + 13 * i.z), iChannelResolution[0].x), mod(float(i.y + 29 * i.z), iChannelResolution[0].y));\n    return texelFetch(iChannel0, co, 0).rgb;\n}\n\nvec4 orth(vec4 p){\n    return p.xwzy;\n}\n\n// Nebula density\nfloat nebula(vec4 p) {\n    // Component in space directions\n    vec3 p_s = p.xyz;\n    \n    float n0 = texture(iChannel1, p_s * 0.005).r;\n    float n1 = texture(iChannel1, p_s * 0.001).r;\n    float n2 = texture(iChannel1, p_s * 0.0002).r;\n\n    return clamp(n0 * n1  * n1 * n2 - 0.1, 0., 1.);\n}\n\n// 4D star cluster SDF\n// SDF between a cluster and a dispersing line of light of different wavelengths.\n// 'elongation' is a vector from the point at one end of the spectrum to the other.\nfloat sdCluster (vec4 p, vec4 elongation, vec4 d) {\n    float dist = CLUSTER_CELL_SIZE;\n    \n    ivec3 p_idx = ivec3(floor(p.xyz / CLUSTER_CELL_SIZE));\n    \n    // Loop over adjacent cells\n    #ifdef HIGH_QUALITY\n    for(int x = -1; x <= 1; x++) {\n        for(int y = -1; y <= 1; y++) {\n            for(int z = -1; z <= 1; z++) {\n    #else\n    int x,y,z = 0;\n    #endif\n                ivec3 idx = p_idx + ivec3(x, y, z);\n                \n                vec3 star_future_3 = (rand3_3(idx) - vec3(0.5)) * CLUSTER_RAND_VEL;\n                vec4 star_future = normalize(CLUSTER_FUTURE + vec4(star_future_3, 0.));\n                \n                // Stars don't emit light into the past\n                if(dot(d, star_future) > 0.){\n                    vec3 star_pos_3 = rand3_3(idx + ivec3(17, 37, 49)) * CLUSTER_CELL_SIZE * 0.5 + CLUSTER_CELL_SIZE * 0.25;\n                    vec4 star_pos = vec4(star_pos_3 + vec3(idx) * CLUSTER_CELL_SIZE, 0.);\n                    vec4 pa = p - star_pos;\n\n                    // Elongate along elongation vector\n                    vec4 orth_elongation = elongation - proj(star_future, elongation);\n                    float t2 = dot(pa, orth_elongation)/dot(orth_elongation, orth_elongation);\n                    pa = pa - clamp(t2, -1., 0.) * orth_elongation;\n\n                    // Elongate (infinitely) along star future\n                    float t1 = dot(pa, star_future)/dot(star_future, star_future);\n                    pa = pa - t1 * star_future;\n\n                    // Calculate distance to star\n                    dist = min(dist, length(pa));\n                    }\n    #ifdef HIGH_QUALITY\n            }\n        }\n    }\n    #endif\n    return dist;\n}\n\nfloat sdClusters (vec4 p, vec4 elongation, vec4 dir) {\n    return min(sdCluster(p, elongation, dir), sdCluster(orth(p), orth(elongation), orth(dir)));\n}\n\n// Volumetric 4d raymarching\nfloat raymarch4d(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    //Accumulated density\n    float a = 0.;\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        vec4 p = ray_pos + l * lower_ray_dir;\n        d = sdClusters(ray_pos + l * lower_ray_dir, l * elongation_vec, lower_ray_dir);\n        a += min(1., exp2(STAR_SIZE - d / GLOW_DIST));\n        l += d + STAR_SIZE * 0.5;\n        if (l > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return a;\n    \n}\n\nvec2 raymarch4dNebula(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    //Accumulated density\n    vec2 a = vec2(0.);\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        vec4 p = ray_pos + l * lower_ray_dir;\n        d = sdClusters(ray_pos + l * lower_ray_dir, l * elongation_vec, lower_ray_dir);\n        float intensity = clamp(20. / (d), 5., 20.);\n        a += vec2(nebula(p.xyzw), nebula(orth(p))) * intensity;\n        \n        l += 5.;\n        if (l > MAX_DIST) {\n            \n            break;\n        }\n    }\n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cam_uv = ((fragCoord/iResolution.xy) - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.);\n    \n    // Calculate camera position & direction. The requires 3 orthogonal vectors to define in 4d.\n    float orbit_rate = 0.05; // radians/sec\n    \n    vec2 m = iMouse.xy / iResolution.xy * 6. - vec2(3.);\n    \n    float radius = 10.;\n    float center = 0.;\n    \n    vec4 future = vec4(0., -sin(iTime/radius), 0., cos(iTime/radius));\n    vec4 ray_pos = vec4(0., center + radius * cos(iTime/radius), m.y, radius * sin(iTime/radius));\n    \n    vec4 fwd = normalize(vec4(sin(m.x), -cos(iTime/radius) * cos(m.x), 0., -sin(iTime/radius) * cos(m.x)));\n    vec4 camera_d = camera_spacelike_dir(cam_uv, fwd, UP_4, future);\n    \n    \n    // Raymarch 4 different wavelength/velocity ranges\n    float r = raymarch4d(camera_d, ray_pos, future, 0.95, 1.2); // Red light is slowest (Pointed most towards the camera's future)\n    float g = raymarch4d(camera_d, ray_pos, future, 0.8, 1.05);\n    float b = raymarch4d(camera_d, ray_pos, future, 0.65, 0.9);\n    float v = raymarch4d(camera_d, ray_pos, future, 0.5, 0.75); // Violet light is fastest\n    \n    vec2 n = raymarch4dNebula(camera_d, ray_pos, future, 0.5, 1.2) / float(MAX_ITERATIONS);\n    \n    // Wavelength range colors\n    vec3 r_col = vec3(0.8, 0.1, 0.);\n    vec3 g_col = vec3(0.1, 0.8, 0.);\n    vec3 b_col = vec3(0., 0.2, 0.4);\n    vec3 v_col = vec3(0.25, 0., 0.6);\n    vec3 nebula_col1 = vec3(1., 0.5, 0.);\n    vec3 nebula_col2 = vec3(0.5, 0.0, 1.);\n    // Additively mix final color\n    vec3 col = r * r_col + g * g_col + b * b_col + v * v_col + n.x * nebula_col1 + n.y * nebula_col2;\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Flying a circle through two orthogonal starfields in the 4-D spacetime described by \n// Greg Egan in his Orthogonal series.\n//\n// The universe rendered here is mostly accurate to the one described by Greg Egan in his Orthogonal \n// series.\n//\n// This scene shows a universe with 4 dimensions, much like our own, except that there is no special\n// \"time\" dimension. Objects are free to move in any direction (Always with a velocity of 1).\n// For any given observer, their direction of motion dictates their own arrow of time.\n//\n// Stars are modelled as infinitely long 4-d lines. Because these lines are not parallel (The stars\n// are moving), the 3-D domain repetition is a bit of a hack and sometimes ends up cutting off parts\n// of stars. It only works well when the stars' arrows of time are approximately parallel.\n// \n// One consequence of this universe is that the speed of light depends on its wavelength (which\n// depends on its orientation relative to you). This creates the streaks seen behind the stars.\n// For the sake of accuracy, rendering is done by sampling light is sampled at a few different \n// wavelength ranges. This also contributes to slow rendering.\n//\n// Another consequence is that a constantly accelerating object will eventually have a direction\n// orthogonal to its original direction, which would appear to a stationary observer like moving at an\n// infinite velocity.\n//\n// For a more complete explaination of the physics/geometry of Riemmanian spacetime,\n// see http://gregegan.net/ORTHOGONAL/ORTHOGONAL.html\n\n\n\n// ------------------------------------------ SETTINGS ------------------------------------------\n// More stars & less artifacts - uncomment if your computer can handle it\n//#define HIGH_QUALITY\n\n// Less stars and more performance\n//#define POTATO_QUALITY\n\n// Controls how long star trails are.\n#define STAR_VELOCITY 0.05\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslSDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 184]], "test": "untested"}
{"id": "dssSD4", "name": "Reaction Diffusion Bloody", "author": "rubioh", "description": "Reaction-Diffusion Grey Scott Model.\n", "tags": ["diffusion", "reaction", "greyscott"], "likes": 8, "viewed": 247, "published": 3, "date": "1668960775", "time_retrieved": "2024-07-30T16:18:24.018888", "image_code": "vec3 getH(vec2 uv, float d){\n    vec2 newc = texture(iChannel0, uv).xy;\n    float h =  pow(dot2(1.-newc), d);\n    return vec3(uv, h/2.);\n}\n\n//vec3 palette(float t, float t2){\n//   return mix(vec3(.3, .53, .37), vec3(.57,.17,.09)/1., t2)*(t+.1);\n//}\nvec3 palette( in float t, float t2 )\n{\n    vec3 a = vec3(0.4, 0.2, 1.);\n    vec3 b = vec3(0.75, 0.7, 0.7);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.6, 0.35, 0.05);\n\n    return a*.2 + .2*b*cos( 6.28318*(c*t*2.+d*t2*.1) );\n}\n\nvec3 calcnormal(vec2 p, float d){\n\n    vec2 e = vec2(1.0, -1.0) * 0.001;    \n    return normalize(\n      e.xyx*getH(p + e.xy, d) +\n      e.yxx*getH(p + e.yx, d) +\n      e.xxx*getH(p + e.xx, d));\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col) {\n  // ambient\n  vec3 ambient = col*(.5);\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = col * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = col* pow(dotRV, 16.);\n\n  return ambient + diffuse + 2.*specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    \n    \n    float t2 = pow(clamp(getH(uv, 24.).z, 0., 1.), .4);\n    \n    \n    vec3 normal = calcnormal(uv, 16.);\n    \n    vec3 ld = vec3(.5, .5, 4.5);\n    \n    vec3 rd = vec3(uv, getH(uv, 4.).z);\n    \n    vec3 col = palette(1.-rd.z, t2);\n    \n    col = phong(ld, normal, rd, col);\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt 1.\n#define Da .21\n#define Db .105\n#define PI 3.14159\n#define f .039\n#define k .06\n\nfloat dot2(vec2 p){\n    return dot(p,p);\n}\nvec2 hash22(vec2 p){\n    vec2 a = vec2(94.86, 43.46);\n    vec2 b = vec2(72.67, 13.48);\n    p = vec2(dot(p, a), dot(p, b));\n    return fract(sin(p*10.29)*48.47);\n}\nfloat getf(){\n    return .016; // .01 0.014 .018 .02\n}\n\nfloat getk(){\n    return .047;\n}\n\nmat2 rot(float t){\n return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nvec4 Laplacian(ivec2 uv, sampler2D Chan){\n\n    ivec2 dx = ivec2(1, 0);\n    ivec2 dy = ivec2(0, 1);\n    \n    vec4 L = vec4(0.);\n    \n    L += texelFetch(Chan, uv+dx, 0);\n    L += texelFetch(Chan, uv+dy, 0);\n    L += texelFetch(Chan, uv-dx, 0);\n    L += texelFetch(Chan, uv-dy, 0);\n    \n    L += .5*texelFetch(Chan, uv+dx+dy, 0);\n    L += .5*texelFetch(Chan, uv+dy-dx, 0);\n    L += .5*texelFetch(Chan, uv-dx-dy, 0);\n    L += .5*texelFetch(Chan, uv-dy+dx, 0);\n        \n    L -= texelFetch(Chan, uv, 0)*6.;\n \n    return L;\n\n}", "buffer_a_code": "vec4 init(vec2 uv){\n    float init_A = 1.;\n    float init_B = 0.;\n        \n    return vec4(init_A, init_B, .21, .105);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 m = vec2(.5, 0.);\n    if (iMouse.z > 0.){\n        m = iMouse.xy/iResolution.xy;\n    }\n\n    ivec2 uv = ivec2(fragCoord.xy);\n    vec2 uvf = fragCoord.xy/iResolution.xy;\n    vec4 state;    \n    // Init lattice\n    if (iFrame <= 0){\n        state = init(uvf);\n        }    \n       \n    else{\n\n        state = texelFetch(iChannel0, uv, 0).xyzw;\n        \n        float a = state.x;\n        float b = state.y;\n            \n        vec4 L = Laplacian(uv, iChannel0);\n        \n        \n        float na = a + (L.x*Da - a*b*b + f*(1.-a))*dt;\n        float nb = b + (L.y*Db + a*b*b - (k+f)*b)*dt;\n        \n        nb += .4*(1.-smoothstep(0., .01, length(uvf-m)));\n        na = clamp(na, 0., .9);\n        nb = clamp(nb, 0., .9);\n        \n        state.xy = vec2(na, nb);\n        state.zw = vec2(na,nb);\n        \n    }\n    \n    \n    fragColor = vec4(state);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.z == 0.){\n        m = vec2(-10.);\n    }\n\n    ivec2 uv = ivec2(fragCoord.xy);\n    vec2 uvf = fragCoord.xy/iResolution.xy;\n\n    vec4 state = texelFetch(iChannel0, uv, 0).xyzw;\n\n    float a = state.x;\n    float b = state.y;\n\n        vec4 L = Laplacian(uv, iChannel0);\n\n    float na = a + (L.x*Da - a*b*b + f*(1.-a))*dt;\n    float nb = b + (L.y*Db + a*b*b - (k+f)*b)*dt;\n        na = clamp(na, 0., .9);\n        nb = clamp(nb, 0., .9);\n\n    //nb += 1.-smoothstep(0., .05, length(uvf-m));\n    //nb = clamp(nb, 0., 1.);\n    state.xy = vec2(na, nb);\n    state.zw = vec2(a,b);\n\n    fragColor = vec4(state);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.z == 0.){\n        m = vec2(-10.);\n    }\n\n    ivec2 uv = ivec2(fragCoord.xy);\n    vec2 uvf = fragCoord.xy/iResolution.xy;\n\n    vec4 state = texelFetch(iChannel0, uv, 0).xyzw;\n\n    float a = state.x;\n    float b = state.y;\n\n        vec4 L = Laplacian(uv, iChannel0);\n\n    float na = a + (L.x*Da - a*b*b + f*(1.-a))*dt;\n    float nb = b + (L.y*Db + a*b*b - (k+f)*b)*dt;\n        na = clamp(na, 0., .9);\n        nb = clamp(nb, 0., .9);\n\n    //nb += 1.-smoothstep(0., .05, length(uvf-m));\n    //nb = clamp(nb, 0., 1.);\n    state.xy = vec2(na, nb);\n    state.zw = vec2(a,b);\n\n    fragColor = vec4(state);\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 138], [140, 249, 287, 287, 481], [483, 483, 516, 516, 679], [681, 681, 740, 753, 1046], [1048, 1048, 1105, 1105, 1471]], "test": "untested"}
{"id": "7lGGR3", "name": "2022", "author": "catafest", "description": "Happy New Year 2022! \n\nmy shader builds for the year 2022.", "tags": ["catafest", "2022"], "likes": 4, "viewed": 150, "published": 3, "date": "1668954048", "time_retrieved": "2024-07-30T16:18:24.901528", "image_code": "#define PRACTICLES_COUNT 23.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - vec2(0.5 * iResolution.x, 0.0)) / iResolution.y;\n    vec3 color2 = mix(vec3(0.0, 0.0, 0.99), vec3(0.01, 0.0, 0.0), sin(iTime) * (length(uv) - 0.12));\n    \n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));     // Time varying pixel color\n    vec3 col = vec3(0)+color2;\n    vec3 color = sin(vec3(.34,.54,.43) *floor(iTime)* .5 + .5);\n    float t = fract(iTime);\n    for( float i =0.0; i < PRACTICLES_COUNT; i++)\n    {\n        float r = texture( iChannel0, vec2(iTime, 0.0) ).x;\n        //vec2 dir = vec2(sin(iTime + 1.0) * .5,rstandard);\n        \n        float d = length(uv - i* tan(t));\n        \n        float brightness = mix( 0.005, .0001, smoothstep(0.005, 0.0, t) );\n        brightness *= sin(t*20.0 + i)* .5 +.5;\n        brightness*= smoothstep(1.,.5,r);\n        col += brightness/d * color;\n    }\n    \n    col*= 2.0;\n    fragColor = vec4(col,1.0);     // Output to screen\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 1002]], "test": "untested"}
{"id": "mssSWN", "name": "math - rotate uv 001", "author": "catafest", "description": "This is a simple demo about how to use algebra matrix rotation with sine and cosine functions. \nYou can see each step is commented.", "tags": ["example", "simple", "math", "uv", "rotation", "algebra", "matrixrotation"], "likes": 3, "viewed": 367, "published": 3, "date": "1668951429", "time_retrieved": "2024-07-30T16:18:31.288451", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set the uv to a proper size on the center of screen \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    // set rotation angle value\n    float rot = radians(0.0);\n    // this set rotation by time and \n    rot = iTime;\n    // algebra formula for rotation by matrix , https://en.wikipedia.org/wiki/Rotation_matrix\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    // rotation of uv with matrix algebra formula where is set the rotation angle \n    uv = m* uv;\n    // define float by function module from 1.0 and uv.x - uv.y\n    float d = mod(uv.x - uv.y, 1.0);\n    // color for fragColor is value of fload d by module function\n    vec4 col = vec4(vec3(d), 1.0);\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 116, 803]], "test": "untested"}
{"id": "ddsSWN", "name": "Spiral #5 (web)", "author": "lsdlive", "description": "@lsdlive\nCC-BY-NC-SA\n\nSpiral #5 (web)", "tags": ["raymarching", "spiral"], "likes": 13, "viewed": 408, "published": 3, "date": "1668950342", "time_retrieved": "2024-07-30T16:18:32.220958", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nSpiral #5 (web)\n\nGeometries are generated with sphere-tracing algorithm:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\n*/\n\n\n#define speed .75\n\n#define pi 3.141592\n#define tau (pi*2.)\n\n#define time (speed*iTime)\n//#define bpm 120.\n//#define time (speed*(bpm/60.)*iTime)\n\n#define pex(x) ex(abs(mod((fract(x) + .5) * 2., 2.) - 1.))\n#define psin(x) (.5+.5*sin(x))\n\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 black = vec3(.133, .137, .137);\nvec3 white = vec3(.941, .965, .941);\n\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat ex(float t) {\n    if (t == 0. || t == 1.) return t;\n    return (t *= 2.) < 1. ? .5 * exp2(10. * (t - 1.)) : .5 * (-exp2(-10. * (t - 1.)) + 2.);\n}\n\nfloat repeat(float pos, float dist) {\n    return mod(pos - dist * .5, dist) - dist * .5;\n}\n\nvoid repeat_angle(inout vec2 pos, float m) {\n    float a = repeat(atan(pos.y, pos.x), m);\n    pos = vec2(cos(a), sin(a)) * length(pos);\n}\n\nvoid mirror(inout vec2 pos, vec2 dist) {\n    pos = abs(pos) - dist;\n    if (pos.y > pos.x)\n        pos = pos.yx;\n}\n\nfloat sdf_cross(vec3 pos, float dist) {\n    pos = abs(pos);\n    pos = max(pos, pos.yzx);\n    return min(pos.x, min(pos.y, pos.z)) - dist;\n}\n\nfloat sdf_cylinder(vec2 pos, float dist) {\n    return length(pos) - dist;\n}\n\nfloat shape1(vec3 p) {\n    // probably overkill for what we get visually,\n    // but it's the result of iterative experimentation & exploration (wont rewrite)\n    repeat_angle(p.xy, tau / 3.);\n    p.z = repeat(p.z, 1.);\n    mirror(p.xz, vec2(1, 4));\n    p.x = abs(p.x) - 14.;\n    mirror(p.xz, vec2(1, 3));\n    mirror(p.xy, vec2(8));\n    return sdf_cross(p, .1);\n}\n\nfloat shape2(vec3 p) {\n    p.xy *= r2d(p.z * .02);\n    mirror(p.xy, vec2(11, 12));\n    repeat_angle(p.xy, tau / 7.);\n    mirror(p.xy, vec2(12. * pex(time * .5), 1.6));\n    p.x = abs(p.x) - 4. + pex(time * .5);\n    p.xy *= r2d(p.z * .2 + time);\n    p.x = abs(p.x) - .3;\n    return sdf_cylinder(p.xy, .15);\n}\n\nfloat de(vec3 p) {\n    p.xy *= r2d(time * .1);\n    return min(shape1(p), shape2(p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 ray_origin = vec3(0, 0, time * 12.);\n    vec3 ray_direction = normalize(vec3(uv, 1)), p;\n    vec3 pos;\n\n    float iterations = 0.;\n    float tdist = 0.; // total distance from the ray origin to the point\n    // Sphere-tracing\n    for (float i = 0.; i < 1.; i += .01) {// 100 iterations\n        iterations = i;\n        pos = ray_origin + ray_direction * tdist;\n        float dist = de(pos); // signed distance field\n        if (dist < .01)\n            break;\n        tdist += dist;\n    }\n\n    vec3 color = mix(white, black, iterations);\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsSWN.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[603, 603, 622, 622, 688], [690, 690, 709, 709, 841], [843, 843, 880, 880, 933], [935, 935, 979, 979, 1072], [1074, 1074, 1114, 1114, 1188], [1190, 1190, 1229, 1229, 1329], [1331, 1331, 1373, 1373, 1406], [1408, 1408, 1430, 1566, 1771], [1773, 1773, 1795, 1795, 2079], [2081, 2081, 2099, 2099, 2167], [2169, 2169, 2224, 2224, 2869]], "test": "untested"}
{"id": "mdlSWN", "name": "Equirectangular Proj.", "author": "Tech_", "description": "Just a small shader showing of equirectangular projection!", "tags": ["simple", "projection"], "likes": 4, "viewed": 321, "published": 3, "date": "1668948286", "time_retrieved": "2024-07-30T16:18:33.078664", "image_code": "/*\n    Equirectangular Projection & Inverse\n    by TechDev\n\n    CC0 1.0 Universal (CC0 1.0) Public Domain Dedication\n*/\n\n#define rcp(x) (1.0 / (x))\n\nconst float TAU = radians(360.0);\nconst float INV_TAU = rcp(TAU);\n\nconst float PI = radians(180.0);\nconst float INV_PI = rcp(PI);\n\nvec3 EquirectangularToView(vec2 coord)\n{\n    coord = coord * TAU - PI; \n    \n    float theta  = coord.x;\n    float phi    = coord.y * 0.5;\n    float cosPhi = cos(phi);\n    \n    return vec3(\n        cosPhi * cos(theta),\n        sin(phi)           ,\n        cosPhi * sin(theta)\n    );\n}\n\nvec2 ViewToEquirectangular(vec3 view)\n{\n    return vec2(\n        atan(view.z, view.x) * INV_TAU + 0.5,\n        1.0 - acos(view.y) * INV_PI\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy; \n    vec3 cubeMapDir = EquirectangularToView(coord);\n\t\n    fragColor = texture(iChannel0, EquirectangularToView(coord));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlSWN.jpg", "access": "api", "license": "cc0-1.0", "functions": [[280, 280, 320, 320, 564], [566, 566, 605, 605, 713], [715, 715, 772, 772, 943]], "test": "untested"}
{"id": "ddsXD4", "name": "Basic \"new shader\" template", "author": "kishimisu", "description": "Just a basic \"new shader\", nothing to see here..", "tags": ["hack", "code", "hidden", "malicious"], "likes": 18, "viewed": 502, "published": 3, "date": "1668944854", "time_retrieved": "2024-07-30T16:18:33.940360", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       float t,i,d=1.,s=iTime*.6;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));                                                                                                                                                                                                                                                                                                                                                                                                                                                         // https://www.shadertoy.com/view/ddlSRn\n    \n    // Output to screen \n    fragColor = vec4(col,1.0);                                                                                                                                                                                                                                                                             for(vec2 r=iResolution.xy;d>.001&&++i<1e2;t+=d=(length(fract(vec3((fragCoord*2.-r)/r.y/8.*t*t*(sin(s)+1.2),t+s))-.5)-sin(s+t*5.)*.15-.2)/3.)fragColor=mix(fragColor,(cos(t+vec4(0,1,2,0))+i*.03)/exp(t*.2),smoothstep(-1.,1.,sin(s+4.3)*2.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1783]], "test": "untested"}
{"id": "ddlXD4", "name": "Tux Family Trip", "author": "dr2", "description": "The Tux penguins have finally learned to walk", "tags": ["gait", "walk", "penguin", "tux"], "likes": 23, "viewed": 271, "published": 3, "date": "1668942322", "time_retrieved": "2024-07-30T16:18:34.888825", "image_code": "// \"Tux Family Trip\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 14 in \"Penguin\" series; others are listed in \"Antarctic Flag\" (sdlSRl).\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_WLK 4\n\nstruct Leg {\n  vec2 cs1, cs2, cs3;\n};\nstruct Walker {\n  Leg leg[2];\n  vec3 wPos;\n  vec2 csHead, csBod;\n  float szFac, hHip, lLeg, tPhs;\n};\nWalker wlk[N_WLK];\n\nvec3 sunDir, qHit, wPos;\nfloat tCur, dstFar, spd, fAng;\nint idObj;\nconst int idLeg = 1, idFoot = 2, idBod = 3, idHead = 4, idBk = 5, idEye = 6, idFlp = 7;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetWlkConf ()\n{  // (based on \"Walkers\")\n  float sDir, t, tH, tt, tV, limT, fUp, limEx, a1, a2, fh;\n  tH = 0.01;\n  tV = 0.3;\n  limT = 0.5;\n  limEx = 0.95;\n  fUp = 1.;\n  for (int j = 0; j < N_WLK; j ++) {\n    wlk[j].szFac = 1. - 0.4 * float (j) / float (N_WLK);\n    wlk[j].lLeg = 0.9;\n    wlk[j].hHip = limEx * 4. * wlk[j].lLeg * cos (atan (limT));\n    wlk[j].tPhs = mod (tCur * spd / (wlk[j].szFac * wlk[j].hHip * limT * (2./3.)), 4.);\n    for (int k = 0; k < 2; k ++) {\n      t = mod (wlk[j].tPhs + float (2 * k), 4.);\n      if (t > 1.) {\n        sDir = -1.;\n        t = (t - 1.) / 3.;\n      } else sDir = 1.;\n      tt = 0.5 - abs (t - 0.5);\n      a1 = atan (limT * (((tt < tH) ? tt * tt / tH : 2. * tt - tH) / (1. - tH) - 1.)) *\n         sign (0.5 - t) * sDir;\n      fh = wlk[j].hHip;\n      if (sDir > 0.) fh -= fUp * smoothstep (0., tV, tt);\n      a2 = - acos (fh / (4. * wlk[j].lLeg * cos (a1)));\n      wlk[j].leg[k].cs1 = CosSin (-0.5 * pi + a1 + a2);\n      wlk[j].leg[k].cs2 = CosSin (-2. * a2);\n      wlk[j].leg[k].cs3 = CosSin (0.5 * pi - a1 + a2);\n    }\n    wlk[j].csBod = CosSin (0.05 * pi * sin (0.5 * pi * wlk[j].tPhs + pi));\n    wlk[j].csHead = CosSin (0.2 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       mod (0.4 * tCur / wlk[j].szFac, 1.)) - 1.));\n    wlk[j].wPos = wPos - vec3 (0., 0., 8. * float (j));\n  }\n}\n\nfloat PengDf (vec3 p, float dMin, Walker wk)\n{  // (based on \"Tux the Penguin\")\n  vec3 pp, q, qq, fSize;\n  float d, legRad;\n  p.y -= wk.hHip;\n  if (! isSh) d = PrSphDf (p, 7.);\n  if (isSh || d < dMin) {\n    legRad = 0.12;\n    pp = p;\n    p.xy = Rot2Cs (p.xy, wk.csBod);\n    p.y -= 0.9;\n    p.xz = - p.xz;\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (2.6, 2.4, 2.8));\n    DMINQ (idBod);\n    q = p;\n    q.xz = Rot2Cs (q.xz, wk.csHead);\n    qq = q;\n    q.y -= 3.;\n    d = PrEllipsDf (q.xzy, vec3 (1.6, 1.2, 2.6));\n    q.x = abs (q.x);\n    q -= vec3 (0.6, 1., -0.8);\n    d = max (d, - PrCylDf (q, 0.3, 0.5));\n    DMINQ (idHead);\n    q = qq;\n    q.x = abs (q.x);\n    q -= vec3 (0.6, 4., -0.8);\n    d = PrSphDf (q, 0.3);\n    DMINQ (idEye);\n    q = qq;\n    q.yz -= vec2 (3., -1.2);\n    d = max (PrEllipsDf (q, vec3 (0.8, 0.4, 1.2)), 0.01 - abs (q.y));\n    DMINQ (idBk);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (2.2, 0.6, -0.4);\n    q.yz = Rot2D (q.yz, -0.25 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0.2, -0.8);\n    d = PrEllipsDf (q.xzy, vec3 (0.2, 0.5, 1.8));\n    DMINQ (idFlp);\n    for (int k = 0; k < 2; k ++) {\n      p = pp;\n      p.x += 1. * sign (float (k) - 0.5);\n      p.y -= -0.2;\n      q = p.yxz;\n      q.xz = Rot2Cs (q.xz, wk.leg[k].cs1);\n      q.z -= wk.lLeg;\n      d = PrCapsDf (q, legRad, wk.lLeg);\n      DMINQ (idLeg);\n      q.z -= wk.lLeg;\n      q.xz = Rot2Cs (q.xz, wk.leg[k].cs2);\n      q.z -= wk.lLeg;\n      d = PrCapsDf (q, legRad, wk.lLeg);\n      DMINQ (idLeg);\n      q.z -= wk.lLeg + 0.1;\n      q.xy = q.yx;\n      q.yz = Rot2Cs (q.yz, wk.leg[k].cs3);\n      q.z = - q.z;\n      q.xz = Rot2D (q.xz, 0.05 * pi * sign (float (k) - 0.5)) + vec2 (0., 0.8);\n      fSize = vec3 (0.3, 0.13, 1.);\n      d = SmoothMin (PrEllipsDf (vec3 (Rot2D (vec2 (abs (q.x), q.z - 0.8), -0.15 * pi) +\n         vec2 (0., 0.8), q.y).xzy, fSize), PrEllipsDf (q, fSize), 0.05);\n      d = SmoothMin (d, PrEllipsDf (q, fSize), 0.05);\n      DMINQ (idFoot);\n    }\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int j = VAR_ZERO; j < N_WLK; j ++) {\n    q = p - wlk[j].wPos;\n    d = wlk[j].szFac * PengDf (q / wlk[j].szFac, dMin / wlk[j].szFac, wlk[j]);\n    dMin = min (d, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.7, 0.7, 0.75);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.7 * Fbm2 (0.1 * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh, nDotL;\n  fAng = -0.2 * pi + 0.15 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (8. * pi * tCur);\n  SetWlkConf ();\n  isSh = false;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj == idBod) {\n      col4 = (qHit.z > -1.3) ? vec4 (0.15, 0.15, 0.25, 0.1) :\n         vec4 (0.95, 0.95, 0.95, 0.05);\n    } else if (idObj == idHead) {\n      col4 = (qHit.z < 0.5 && length (qHit.xy) < 0.4) ?\n         vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.15, 0.15, 0.25, 0.1);\n    } else if (idObj == idBk) {\n      col4 = vec4 (1., 0.8, 0.2, 0.2);\n    } else if (idObj == idEye) {\n      col4 = vec4 (0., 0., 0., -1.);\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.8, 0.8, 0.2, 0.2) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05,\n         fract (8. * qHit.z)));\n    } else if (idObj == idFoot) {\n      col4 = vec4 (0.8, 0.8, 0.1, 0.2);\n    } else if (idObj == idFlp) {\n      col4 = vec4 (0.15, 0.15, 0.25, 0.1);\n    }\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = mix (vec4 (1., 1., 1., 0.), vec4 (0.95, 0.95, 1., 0.),\n       smoothstep (0.45, 0.55, Fbm2 (0.25 * ro.xz)));\n    vn = GrndNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (col4.a >= 0.) {\n    if (dstObj < dstFar || rd.y < 0.) {\n      isSh = true;\n      sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    }\n    if (rd.y < 0. && dstObj >= dstFar) col = mix (col, vec3 (0.7, 0.7, 0.75),\n       pow (1. + rd.y, 16.));\n  } else {\n    col = mix (vec3 (0., 0.3, 0.), SkyBgCol (ro, reflect (rd, vn)), 0.5);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  spd = 3.;\n  wPos = vec3 (0., 0., spd * tCur);\n  az = 0.7 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n  }\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = wPos - vec3 (0., 0., 10.) + vuMat * vec3 (0., 3.5, -45.);\n  zmFac = 4.;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (0.5, 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlXD4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1243, 1243, 1263, 1288, 2574], [2576, 2576, 2622, 2655, 4577], [4579, 4579, 4601, 4601, 4840], [4842, 4842, 4875, 4875, 5058], [5060, 5060, 5081, 5081, 5336], [5338, 5338, 5375, 5375, 5618], [5620, 5620, 5654, 5654, 6412], [6414, 6414, 6437, 6437, 6473], [6475, 6475, 6497, 6497, 6641], [6643, 6643, 6678, 6678, 8684], [8686, 8686, 8742, 8742, 9875], [9877, 9877, 9910, 9910, 9937], [9939, 9939, 9981, 9981, 10032], [10034, 10034, 10077, 10077, 10141], [10143, 10143, 10178, 10178, 10240], [10242, 10242, 10287, 10287, 10379], [10381, 10381, 10438, 10438, 10521], [10523, 10523, 10559, 10559, 10765], [10767, 10767, 10797, 10797, 10910], [10912, 10912, 10943, 10943, 11007], [11041, 11041, 11065, 11065, 11118], [11120, 11120, 11144, 11144, 11256], [11258, 11258, 11283, 11283, 11429], [11431, 11431, 11456, 11456, 11642], [11644, 11644, 11666, 11666, 11820], [11822, 11822, 11843, 11843, 11998], [12000, 12000, 12029, 12029, 12241], [12243, 12243, 12282, 12282, 12539]], "test": "untested"}
{"id": "dsfXDN", "name": "Three Circles", "author": "mla", "description": "Three circles & their chords of intersection. This is quite fiddly, but seems to work.\n\nMouse moves circle 2, see header for other controls.", "tags": ["circles", "three"], "likes": 16, "viewed": 259, "published": 3, "date": "1668938774", "time_retrieved": "2024-07-30T16:18:35.700654", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Three Circles\n//\n// Draw three circles and their chords of intersection (segments between the\n// points of intersection of each pair). If the chords themselves intersect,\n// just show the 'external' parts of the chords.\n//\n// Finds nearest points (q0,q1,q2) on the visible part of each of the three circles.\n//\n// 'x': show chords\n// '1'-'3': show distance from q0,q1,q2\n// 'd': show distance field\n// 'r': show full circles & chords, for reference\n// 's': use 'large' radius for free circle (c2)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Circles represented by vec3(centre,radius)\n// Lines represented as vec3(n,d) where |n| = 1 and dot(l,p) = 0 iff p lies on l.\n\n// eps is fudge to deal with points 'exactly' on the circle, which we don't\n// want to count as inside.\nbool inside(vec2 p, vec3 c, float eps) {\n  p -= c.xy;\n  return dot(p,p) <= c.z*c.z - eps;\n}\n\nbool inside(vec2 p, vec3 c) {\n  return inside(p,c,0.0);\n}\n\n// Find the radical axis of two circles, \"line of equal power\"\nvec3 axis(vec2 c, float r, vec2 d, float s) {\n  // power(p,c,r) = p² - 2p.c + c² - r²\n  // power(p,d,s) = p² - 2p.d + d² - s²\n  // So: 2p.(c-d) - (c²-r²-d²+s²) = 0\n  vec3 res = vec3(2.0*(c-d),dot(d+c,d-c)+(r-s)*(r+s));\n  return res/length(res.xy);\n}\n\nvec3 axis(vec3 c0, vec3 c1) {\n  return axis(c0.xy,c0.z,c1.xy,c1.z);\n}\n\nvec4 points(vec3 l) {\n  // Return two points on the line l, packed in a vec4\n  vec2 n = l.xy;\n  float d = l.z;\n  // want kn.n+d = 0\n  // but n is normalized\n  vec2 p0 = -d*l.xy;\n  vec2 p1 = p0+vec2(-n.y,n.x);\n  return vec4(p0,p1);\n}\n\nfloat linedistance(vec2 p, vec3 l) {\n  return dot(l,vec3(p,1));\n}\n\n// Intersect a line through points p,q with circle c\nbool intersect(vec2 p, vec2 q, vec3 c, out vec4 res) {\n  vec2 r = q-p; // direction\n  p -= c.xy;    // rebase\n  p -= dot(p,r)*r; // Now p.r = 0\n  // Want |p+tr| = c.z, so p.p + t²r.r = c.z²\n  float t = (c.z*c.z-dot(p,p))/dot(r,r);\n  if (t < 0.0) return false;\n  t = sqrt(t);\n  p += c.xy; // undo rebase\n  res = vec4(p+t*r,p-t*r);\n  return true;\n}\n\n// Intersect line l with circle c\nbool intersect(vec3 l, vec3 c, out vec4 res) {\n  vec4 pq = points(l);\n  return intersect(pq.xy,pq.zw,c,res);\n}\n\n// Closest point to p on circle c\nvec2 closest(vec2 p, vec3 c) {\n  p -= c.xy;\n  return p*c.z/length(p)+c.xy;\n}\n\n// Whichever of q or r is nearest to p\nvec2 nearest(vec2 p, vec2 q, vec2 r) {\n  if (distance(p,q) < distance(p,r)) return q;\n  else return r;\n}\n\n// q and r packed in a vec4\nvec2 nearest(vec2 p, vec4 qr) {\n  vec2 q = qr.xy, r = qr.zw;\n  return nearest(p,q,r);\n}\n\n// Projective magic\nvec2 intersectlines(vec3 l, vec3 m) {\n  vec3 p = cross(l,m);\n  return p.xy/p.z;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float scale = 2.0;\n  vec2 mouse = vec2(0,-1);\n  vec2 p = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  if (iMouse.x > 0.0) mouse = scale*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  float px = fwidth(length(p));\n  float lwidth = 0.01;\n  float pwidth = 3.0*lwidth;\n  vec3 c0 = vec3(-0.5,0,1);\n  vec3 c1 = vec3(0.5,0.0,1.2);\n  vec3 c2 = vec3(mouse,key(CHAR_S)?1.4:0.8);\n  \n  // Radical axes\n  vec3 a0 = axis(c0,c1), a1 = axis(c1,c2), a2 = axis(c2,c0);\n  vec4 i0,i1,i2; // Chords of intersection\n  bool b0 = intersect(a0,c0,i0), b1 = intersect(a1,c1,i1), b2 = intersect(a2,c2,i2);\n  vec2 q0 = closest(p,c0), q1 = closest(p,c1), q2 = closest(p,c2);\n  float d = 1e8;\n  vec3 col = vec3(0.8);\n  if (!key(CHAR_R)) {\n    // Show the full circles, for reference.\n    d = min(d,distance(p,q0));\n    d = min(d,distance(p,q1));\n    d = min(d,distance(p,q2));\n    if (b0) d = min(d,segment(p,i0));\n    if (b1) d = min(d,segment(p,i1));\n    if (b2) d = min(d,segment(p,i2));\n    col = 0.6+0.2*vec3(smoothstep(0.0,px,d-lwidth));\n  }\n  // d0-d2 indicate if c0-c2 should be drawn at all\n  bool d0 = true, d1 = true, d2 = true;\n  vec2 pcentre = intersectlines(a0,a1); // The \"centre of power\"!\n  d = 1e8;\n  // If the power centre is inside the circles, then we have\n  // three segments meeting at the centre.\n  if (inside(pcentre,c0)) {\n    // Get external ends of the segments\n    vec2 r0 = !inside(i0.xy,c2) ? i0.xy : i0.zw;\n    vec2 r1 = !inside(i1.xy,c0) ? i1.xy : i1.zw;\n    vec2 r2 = !inside(i2.xy,c1) ? i2.xy : i2.zw;\n    // If closest on circle is inside the others, use segment ends \n    if (inside(q0,c1) || inside(q0,c2)) q0 = nearest(p,r0,r2);\n    if (inside(q1,c2) || inside(q1,c0)) q1 = nearest(p,r1,r0);\n    if (inside(q2,c0) || inside(q2,c1)) q2 = nearest(p,r2,r1);\n    d = min(d,distance(p,q0));\n    d = min(d,distance(p,q1));\n    d = min(d,distance(p,q2));\n    if (!key(CHAR_X)) {\n      d = min(d,segment(p,pcentre,r0));\n      d = min(d,segment(p,pcentre,r1));\n      d = min(d,segment(p,pcentre,r2));\n    }\n    \n  } else {\n    // Chords of intersections of the three pairs of circles are disjoint,\n    // if they exist. Lots of cases & no obvious way to simplify.\n    if (inside(q0,c1)) {\n      if (!b0) d0 = false;\n      else q0 = nearest(p,i0);\n    }\n    if (inside(q0,c2)) {\n      if (!b2) d0 = false;\n      else q0 = nearest(p,i2);\n    }\n    if (inside(q1,c2)) {\n      if (!b1) d1 = false;\n      else q1 = nearest(p,i1);\n    }\n    if (inside(q1,c0)) {\n      if (!b0) d1 = false;\n      else q1 = nearest(p,i0);\n    }\n    if (inside(q2,c0)) {\n     if (!b2) d2 = false;\n     else q2 = nearest(p,i2);\n    }\n    if (inside(q2,c1)) {\n      if (!b1) d2 = false;\n      else q2 = nearest(p,i1);\n    }\n    if (true) {\n      // This covers the case where one circle is entirely within\n      // the other two together, but not entirely within either on its own.\n      // A cleaner solution would be nice.\n      float eps = 1e-4; // Yuk!\n      if (inside(q0,c1,eps) || inside(q0,c2,eps)) d0 = false;\n      if (inside(q1,c2,eps) || inside(q1,c0,eps)) d1 = false;\n      if (inside(q2,c0,eps) || inside(q2,c1,eps)) d2 = false;\n    }\n    \n    if (d0) d = min(d,distance(p,q0));\n    if (d1) d = min(d,distance(p,q1));\n    if (d2) d = min(d,distance(p,q2));\n    if (!key(CHAR_X)) {\n      if (b0 && !inside(i0.xy,c2)) d = min(d,segment(p,i0));\n      if (b1 && !inside(i1.xy,c0)) d = min(d,segment(p,i1));\n      if (b2 && !inside(i2.xy,c1)) d = min(d,segment(p,i2));\n    }\n  }\n  if (key(CHAR_0+1) && d0) col.r *= 0.5-0.5*cos(20.0*PI*distance(p,q0));\n  else if (key(CHAR_0+2) && d1) col.g *= 0.5-0.5*cos(20.0*PI*distance(p,q1));\n  else if (key(CHAR_0+3) && d2) col.b *= 0.5-0.5*cos(20.0*PI*distance(p,q2));\n  else if (key(CHAR_D)) col *= 0.75-0.15*cos(20.0*PI*d);\n  col *= smoothstep(0.0,px,d-lwidth);\n  col = pow(col,vec3(0.4545));\n  col = max(col,alert);\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592654;\n\nvec3 alert = vec3(0);\nvoid assert(bool b, int i) {\n  if (!b) alert[i] = 1.0;\n}\nvoid assert(bool b) {\n  assert(b,0);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat segment(vec2 p, vec4 ab) {\n  return segment(p,ab.xy,ab.zw);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[798, 902, 942, 942, 993], [995, 995, 1024, 1024, 1052], [1054, 1117, 1162, 1290, 1376], [1378, 1378, 1407, 1407, 1447], [1449, 1449, 1470, 1525, 1681], [1683, 1683, 1719, 1719, 1748], [1750, 1803, 1857, 1857, 2151], [2153, 2187, 2233, 2233, 2297], [2299, 2333, 2363, 2363, 2409], [2411, 2450, 2488, 2488, 2554], [2556, 2584, 2615, 2615, 2671], [2673, 2693, 2730, 2730, 2774], [2776, 2776, 2828, 2828, 6715]], "test": "untested"}
{"id": "ddsXW4", "name": "malicious code in shadertoy 3", "author": "FabriceNeyret2", "description": "another pretty obvious one.  ;-)", "tags": ["hack", "code", "malicious"], "likes": 5, "viewed": 255, "published": 3, "date": "1668938141", "time_retrieved": "2024-07-30T16:18:36.532430", "image_code": "#define INIT        /*________________ does the magic initialization _______________*/ \\\nU = mod(ceil(_U*.1),2.);                 /* ___ print _ it _ strong _ in _ memory _ */_\\\nU = vec2(0);                             /* ___ now _ forget _ it */\n\n// ===================   this is another example of malicous code  ===================== \nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\nvec2 _U = fragCoord, U; \nINIT\nfragColor = U.xyxy; \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 338, 392, 392, 445]], "test": "untested"}
{"id": "dslXW4", "name": "deceiving code - just for fun", "author": "FabriceNeyret2", "description": "this one will only puzzle noobs :-p", "tags": ["hack", "code", "malicious"], "likes": 14, "viewed": 243, "published": 3, "date": "1668937188", "time_retrieved": "2024-07-30T16:18:37.433022", "image_code": "\n       come on baby to the locomotion yeah do it \n\n", "image_inputs": [], "common_code": "#define come         void\n#define on           mainImage(\n#define baby         out\n#define to           vec4\n#define locomotion , vec2\n#define yeah         u )\n#define do           { the =\n#define it           mod(ceil(u*.1),2.).xyxy; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ddlXW4", "name": "malicious code in shadertoy 2", "author": "FabriceNeyret2", "description": "another pretty obvious one.  ;-)", "tags": ["hack", "code", "malicious"], "likes": 10, "viewed": 225, "published": 3, "date": "1668936453", "time_retrieved": "2024-07-30T16:18:38.325636", "image_code": "float A = 0.;            \n\n// ===================   this is another example of malicous code  ===================== \\\\\nvoid mainImage( out vec4 O, vec2 u ) { O = vec4(A); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* what are you looking for ? :-D */", "image_inputs": [], "common_code": "#define R iResolution.xy\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* what are you looking for ? :-D */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define float void mainImage( out vec4 O, vec2 u ) { O = mod(ceil(u*.1),2.).xyxy; } float", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mslSW4", "name": "skateboard with fractal", "author": "yasuo", "description": "skateboard with fractal", "tags": ["fractal", "skateboard", "cineshader"], "likes": 31, "viewed": 2434, "published": 3, "date": "1668931536", "time_retrieved": "2024-07-30T16:18:39.129486", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n#define EDGE_WIDTH 0.01\n#define MATERIAL0 0\n#define MATERIAL1 1\n\nfloat edge;\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinderX( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinderZ( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\n// tweaked as the center aligned horizontal capsule. \nfloat sdHorizontalCapsule( vec3 p, float w, float r )\n{\n      p.x-= clamp( p.x, -w*0.5, w*0.5 );\n      return length( p ) - r;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat board(vec3 p){\n    vec3 prevP = p;\n    float thick = 0.01;\n    float r = 0.37;\n    float h = 0.75;\n    \n    float d = sdBox(p,vec3(r,h,thick));\n    p.y=abs(p.y)-h;\n    p.yz*= Rot(radians(-10.));\n    float d2 = sdCappedCylinderZ(p,r,thick);\n    d2 = max(-p.y,d2);\n    d = min(d,d2);\n    return d;\n}\n\nfloat trackWithWheel(vec3 p){\n    vec3 prevP = p;\n\n    float d = sdHorizontalCapsule(p,0.63,0.035);\n    p.y+=0.03;\n    float d2 = sdCappedCylinderZ(p,0.15,0.03);\n    d2 = max(p.y,d2);\n    d = opSmoothUnion(d,d2,0.05);\n    p.y+=0.08;\n    d2 = sdCappedCylinderZ(p,0.05,0.1);\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.z-=0.12;\n    p.y+=0.075;\n    d2 = sdBox(p,vec3(0.12,0.15,0.015));\n    d = min(d,d2);\n    p.z+=0.025;\n    d2 = sdBox(p,vec3(0.05,0.15,0.05));\n    \n    float a = radians(-45.);\n    p.y=abs(p.y)-0.13;\n    d2 = max(dot(p.yz,vec2(cos(a),sin(a))),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.z-=0.02;\n    p.y+=0.1;\n    d2 = sdCappedCylinderZ(p,0.04,0.05);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.3;\n    d2 = sdCappedCylinderX(p,0.08,0.04)-0.03;\n    d2 = max(-sdCappedCylinderX(p,0.04,0.2),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.z-=0.12;\n    p.y+=0.07;\n    p.x = abs(p.x)-0.085;\n    p.y = abs(p.y)-0.11;\n    d2 = sdCappedCylinderZ(p,0.01,0.04);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat arrowFractal(vec2 p, int dir, float num){\n        float d = 10.;\n        \n        float dist = 0.07;\n        if(dir == 0){\n            p.y = abs(p.y)-0.5;\n            p*=Rot(radians(90.0));\n        } else {\n            p.x = abs(p.x)-1.5;\n            dist = 0.06;\n        }\n\n        for(float i = 0.; i<num; i++){\n            p*=Rot(radians(i*30.0+iTime*sin(i)*20.));\n            p*=0.9-i*0.1;\n            p = abs(p)-dist;\n            p-=0.025+i*0.01;\n\n            d = Tri(p,vec2(0.1),radians(45.));\n            p.y+=0.05;\n            float d2 = Tri(p,vec2(0.1),radians(45.));\n            d = max(-d2,d);\n\n            float d3 = B(p-vec2(0.,-0.03),vec2(0.017,0.06));\n            d = abs(min(d,d3))-0.005;\n            \n            if(dir == 1){\n                d = abs(d)-0.0005;\n            }\n        }\n        return d;\n}\n\nvec3 skateboardAnim(vec3 p){\n\n    float rotX = 0.;\n    float rotY = 0.;\n\n    float frame = mod(iTime,15.0);\n    float time = frame;\n\n    if(frame>=2.5 && frame<5.){\n        time = getTime(time-2.5,0.6);\n\n        rotX = cubicInOut(time)*90.0;\n    } else if(frame>=5. && frame<7.5){\n        time = getTime(time-5.0,0.6);\n\n        rotX = 90.+cubicInOut(time)*90.0;\n    } else if(frame>=7.5 && frame<10.){\n        time = getTime(time-7.5,0.6);\n\n        rotX = 180.+cubicInOut(time)*180.0;\n    } else if(frame>=10. && frame<12.5){\n        time = getTime(time-10.,0.6);\n\n        rotY = cubicInOut(time)*180.0;\n    } else if(frame>=12.5 && frame<15.){\n        time = getTime(time-12.5,0.6);\n\n        rotY = 180.+cubicInOut(time)*180.0;\n    }\n\n    p.xz*=Rot(radians(rotX));\n    p.yz*=Rot(radians(rotY));\n    return p;\n}\n\nvec2 skateboard(vec3 p) {\n     vec3 prevP = p;\n     \n     p = skateboardAnim(p);\n     \n     float d = board(p-vec3(0.0,0.0,0.07));\n     float mask = board(prevP-vec3(0.0,0.0,0.07));\n     \n     p.y=abs(p.y)-0.7;\n     float d2 = trackWithWheel(p-vec3(0.0,0.0,-0.07));\n     \n     p = prevP;\n     float d3 = arrowFractal(p.xy,1,5.);\n     d3 = max(abs(p.z)-0.001,d3);\n     d3 = max(-(mask-0.13),d3);\n     \n     vec2 res = combine( combine(vec2(d,MATERIAL0),vec2(d2,MATERIAL1)),vec2(d3,MATERIAL1));\n     \n     return res;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    vec2 res = skateboard(p);\n    \n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    float lastDistEval = 10.; \n    float dist;\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dist = dS.x;\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(stepnum == MAX_STEPS){\n            if (lastDistEval < EDGE_WIDTH && dist > lastDistEval) {\n                edge = 1.0;\n            }\n            if (dist < lastDistEval) lastDistEval = dist;\n        }      \n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.3));\n    if(mat == MATERIAL0){\n        p = skateboardAnim(p);\n        float d = arrowFractal(p.xy,0,3.);\n        col = mix(col,vec3(0.),S(d,0.0));\n    }\n    return col;\n}\n\nvec3 bg(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p*=6.;\n    p.y-=iTime*0.5;\n    vec2 id = floor(p);\n    vec2 grid = fract(p)-0.5;\n    vec2 prevGrid = grid;\n    \n    float n = random(id);\n    float speed = random(id*6.)*0.5;\n    float display = 0.;\n    if(n>=0.1 && n<0.2){\n        grid*=Rot(radians(90.));\n    } else if(n>=0.2 && n<0.3){\n        grid*=Rot(radians(180.));\n    } else if(n>=0.3 && n<0.4){\n        grid*=Rot(radians(270.));\n    } else if(n>=0.4){\n        display =-1.;\n        if(n>=0.8){\n            grid*=Rot(radians(45.));\n        }\n        float d2 = abs(abs(B(grid,vec2(0.15)))-0.05)-0.01;\n        col = mix(col,vec3(0.03),S(d2,0.0));\n    }\n    \n    if(n<0.4){\n        float d2 = abs(B(grid,vec2(0.45)))-0.01;\n        \n        float mask = B(grid,vec2(0.2,0.8));\n        d2 = max(-mask,d2);\n        mask = B(grid,vec2(0.8,0.2));\n        d2 = max(-mask,d2);\n        \n        col = mix(col,vec3(0.03),S(d2,0.0));\n    }\n    \n    grid.y-=iTime*(0.5+speed);\n    grid.y-=0.45;\n    grid.y=mod(grid.y,0.74)-0.37;\n    \n    grid.y-=0.18;\n\n    float d = Tri(grid,vec2(0.36),radians(45.));\n    grid.y+=0.18;\n    float d2 = Tri(grid,vec2(0.36),radians(45.));\n    d = max(-d2,d);\n\n    float d3 = B(grid-vec2(0.,-0.16),vec2(0.07,0.2));\n    d = abs(min(d,d3))-0.015;\n    \n    d = max(B(prevGrid,vec2(0.45)),d);\n    col = mix(col,vec3(0.1),S(d,display));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -2.5);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        \n        float rotX = 0.;\n        float rotY = 0.;\n        \n        float frame = mod(iTime,20.);\n        float time = frame;\n\n        if(frame>=5.0 && frame<10.){\n            time = getTime(time-5.0,1.);\n            \n            rotX = -cubicInOut(time)*20.0;\n        } else if(frame>=10. && frame<15.){\n            time = getTime(time-10.0,1.5);\n            \n            rotX = -20.+cubicInOut(time)*40.0;\n        } else if(frame>=15.){\n            time = getTime(time-15.0,1.);\n            \n            rotX = 20.-cubicInOut(time)*20.0;\n        }\n        \n        ro.xz *= Rot(radians(rotX));\n        ro.yz *= Rot(radians(rotY));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col = mix(col,vec3(0.0),edge);\n    } else {\n        col = bg(uv,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 617, 640, 640, 713], [715, 715, 751, 751, 793], [795, 853, 905, 905, 1005], [1007, 1065, 1096, 1096, 1187], [1189, 1247, 1300, 1300, 1411], [1413, 1471, 1524, 1524, 1635], [1637, 1749, 1804, 1804, 1877], [1879, 1879, 1906, 1906, 1990], [1992, 1992, 2031, 2031, 2076], [2078, 2078, 2098, 2098, 2381], [2383, 2383, 2412, 2412, 3415], [3417, 3417, 3464, 3464, 4245], [4247, 4247, 4275, 4275, 5058], [5060, 5060, 5085, 5085, 5577], [5579, 5579, 5601, 5601, 5679], [5681, 5681, 5739, 5739, 6301], [6303, 6303, 6327, 6327, 6528], [6530, 6530, 6572, 6572, 6767], [6769, 6810, 6859, 6859, 7153], [7155, 7155, 7212, 7212, 7833], [7835, 7835, 7894, 7894, 8105], [8107, 8107, 8133, 8133, 9484], [9486, 9486, 9543, 9543, 10956]], "test": "untested"}
{"id": "cssSWN", "name": "[steve] T-Rex game", "author": "import_shader_steve", "description": "The classic Chrome T-Rex game!", "tags": ["game", "chrome", "trex", "internet"], "likes": 1, "viewed": 145, "published": 3, "date": "1668906985", "time_retrieved": "2024-07-30T16:18:39.894441", "image_code": "#define PI 3.14159\n#define S(a,b,t) smoothstep(a,b,t)\n\nfloat box(vec2 uv, float width, float height, float stroke) {\n    float blur = 0.01;\n    // outer part\n    float outer_horizontal = S(height/2., height/2. - blur, abs(uv.y));\n    float outer_vertical = S(width/2., width/2. - blur, abs(uv.x));\n    float outer = outer_horizontal * outer_vertical;\n    // inner part\n    float inner_horizontal = S(height/2.-stroke, height/2.-stroke - blur, abs(uv.y));\n    float inner_vertical = S(width/2.-stroke, width/2.-stroke - blur, abs(uv.x));\n    float inner = inner_horizontal * inner_vertical;\n    // box\n    float box = outer - inner;\n    return box;\n}\n\nfloat makeBump(vec2 uv, float groundYoffset) {\n    uv.x = fract(uv.x) - .5;\n    float box = box(uv - vec2(0., groundYoffset), .3, .2, .02);\n    return box;\n}\n\n// on every frame, triggers on every pixel on the screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.x += iTime*.1;\n    uv.x *= 5.;\n    \n    vec3 color = vec3(0.);\n    \n    // ground\n    float thickness = 0.005;\n    float groundYoffset = .2;\n    float ground = S(.001, .0009, abs(uv.y+groundYoffset)-thickness/2.);\n    color.r += ground;\n    color.g += ground;\n    color.b += ground;\n    \n    // bumps\n    float bump = makeBump(uv, groundYoffset);\n    color.r += bump;\n    color.g += bump;\n    color.b += bump;\n    //color.g += S(0.001, .0009, abs(uv.x)-.005);\n    //color.rg = uv;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 116, 116, 649], [651, 651, 697, 697, 808], [810, 867, 924, 924, 1512]], "test": "untested"}
{"id": "mdfXDN", "name": "Riemmanian Starfield", "author": "A_Toaster", "description": "A starfield 4-D spacetime described by Greg Egan in his Orthogonal series. Different wavelengths have a different angle relative to the observer's time, leading to the spectral star trails. Can you spot the Peerless?", "tags": ["raymarching", "volumetric", "4d", "orthogonal"], "likes": 7, "viewed": 519, "published": 3, "date": "1668905719", "time_retrieved": "2024-07-30T16:18:40.880804", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture( iChannel0, uv ).xyz * 0.5;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nconst float FIELD_OF_VIEW = 1.2;\n\n// camera directions\nconst vec4 FWD_4 = vec4(1., 0., 0., 0.);\nconst vec4 UP_4 = vec4(0., 0., 1., 0.);\n\n// raymarching parameters\nconst float GLOW_DIST = 0.05;\n#ifdef HIGH_QUALITY\n\nconst float MAX_DIST = 300.;\n#define MAX_ITERATIONS 64\nconst float STAR_SIZE = 0.15;\n#else\n#ifdef POTATO_QUALITY\nconst float MAX_DIST = 200.;\n#define MAX_ITERATIONS 16\nconst float STAR_SIZE = 0.3;\n#else\nconst float MAX_DIST = 300.;\n#define MAX_ITERATIONS 32\nconst float STAR_SIZE = 0.2;\n#endif\n#endif\n\n// cluster settings\nconst float CLUSTER_CELL_SIZE = 15.;\nconst float CLUSTER_RAND_VEL = float(STAR_VELOCITY);\nconst vec4 CLUSTER_FUTURE = vec4(0., 0., 0., 1.);\n// Used to keep stars centered within their domains\nconst float CENTER_LIGHT_TIME_VEL = 1. / sqrt(1. + 0.5 * 0.5);\n\n// projection operator\nvec4 proj(vec4 u, vec4 v) {\n    return (u * dot(u,v)) / dot(u, u);\n}\n\n// Calculate a vector orthogonal (but not orthonormal) to three other 4-vectors\nvec4 cross4(vec4 u, vec4 v, vec4 t){\n    return vec4(\n        ( u.w * v.z - u.z * v.w) * t.y + (-u.w * v.y + u.y * v.w) * t.z + (-u.y * v.z + u.z * v.y) * t.w,\n        (-u.w * v.z + u.z * v.w) * t.x + ( u.w * v.x - u.x * v.w) * t.z + ( u.x * v.z - u.z * v.x) * t.w,\n        ( u.w * v.y - u.y * v.w) * t.x + (-u.w * v.x + u.x * v.w) * t.y + (-u.x * v.y + u.y * v.x) * t.w,\n        ( u.y * v.z - u.z * v.y) * t.x + (-u.x * v.z + u.z * v.x) * t.y + ( u.x * v.y - u.y * v.x) * t.z\n    \n    );\n}\n\n// Returns a 4-d ray direction orthogonal to the time vector given a set of camera parameters.\nvec4 camera_spacelike_dir(vec2 uv, vec4 cameraDirection, vec4 cameraUp, vec4 cameraFuture) {\n    \n\tuv = uv * FIELD_OF_VIEW;\n    \n    // Up/fwd vec orthogonal to future\n    vec4 fut = cameraFuture;\n    vec4 up_vec = normalize(cameraUp - proj(fut, cameraUp));\n    vec4 fwd_vec = normalize(cameraDirection - proj(fut, cameraDirection));\n    // Right vec orthogonal to all other directions\n    vec4 right_vec = normalize(cross4(up_vec, fwd_vec, fut));\n    \n    vec4 spacelike_dir = normalize(fwd_vec + uv.y * up_vec + uv.x * right_vec);\n    \n    return spacelike_dir;\n}\n\n// Returns 4-d ray direction given a spacelike direction and a velocity in the timelike direction.\nvec4 camera(vec4 spacelike_dir, vec4 cameraFuture, float futureVel) {\n    vec4 timelike_dir = cameraFuture * futureVel;\n    \n    return normalize(spacelike_dir + timelike_dir);\n}\n\nint hash(ivec3 co){\n    return co.x + 123 * co.y + 12345 * co.z;\n}\n\n\nvec4 rand1_4(float i) {\n    vec2 co = vec2(i, floor(i / iChannelResolution[0].x));\n    return texture(iChannel0, co);\n}\n\nvec3 rand3_3(ivec3 i) {\n    ivec2 co = ivec2(mod(float(i.x + 13 * i.z), iChannelResolution[0].x), mod(float(i.y + 29 * i.z), iChannelResolution[0].y));\n    return texelFetch(iChannel0, co, 0).rgb;\n}\n\nvec3 rand3_1(ivec3 i) {\n    ivec2 co = ivec2(mod(float(i.x + 13 * i.z), iChannelResolution[0].x), mod(float(i.y + 29 * i.z), iChannelResolution[0].y));\n    return texelFetch(iChannel0, co, 0).rgb;\n}\n\n// Nebula density\nfloat nebula(vec4 p) {\n    // Component in space directions\n    vec3 p_s = p.xyz;\n    \n    float n0 = texture(iChannel1, p_s * 0.005).r;\n    float n1 = texture(iChannel1, p_s * 0.001).r;\n    float n2 = texture(iChannel1, p_s * 0.0002).r;\n\n    return clamp(n0 * n1  * n1 * n2 - 0.1, 0., 1.);\n}\n\n// 4D star cluster SDF\n// SDF between a cluster and a dispersing line of light of different wavelengths.\n// 'elongation' is a vector from the point at one end of the spectrum to the other.\nfloat sdCluster (vec4 p, vec4 elongation, float l) {\n    float dist = CLUSTER_CELL_SIZE;\n    \n    ivec3 p_idx = ivec3(floor(p.xyz / CLUSTER_CELL_SIZE));\n    \n    // Loop over adjacent cells\n    #ifdef HIGH_QUALITY\n    for(int x = -1; x <= 1; x++) {\n        for(int y = -1; y <= 1; y++) {\n            for(int z = -1; z <= 1; z++) {\n    #else\n    int x,y,z = 0;\n    #endif\n                ivec3 idx = p_idx + ivec3(x, y, z);\n                \n                vec3 star_future_3 = (rand3_3(idx) - vec3(0.5)) * CLUSTER_RAND_VEL;\n                vec4 star_future = normalize(CLUSTER_FUTURE + vec4(star_future_3, 0.));\n\n                vec3 star_pos_3 = rand3_3(idx + ivec3(17, 37, 49)) * CLUSTER_CELL_SIZE * 0.5 + CLUSTER_CELL_SIZE * 0.25;\n                vec4 star_pos = vec4(star_pos_3 + vec3(idx) * CLUSTER_CELL_SIZE, CENTER_LIGHT_TIME_VEL * length(vec3(idx)));\n                vec4 pa = p - star_pos;\n\n                // Elongate along elongation vector\n                vec4 orth_elongation = elongation - proj(star_future, elongation);\n                float t2 = dot(pa, orth_elongation)/dot(orth_elongation, orth_elongation);\n                pa = pa - clamp(t2, -1., 0.) * orth_elongation;\n\n                // Elongate (infinitely) along star future\n                float t1 = dot(pa, star_future)/dot(star_future, star_future);\n                pa = pa - t1 * star_future;\n\n                // Calculate distance to star\n                dist = min(dist, length(pa));\n                \n    #ifdef HIGH_QUALITY\n            }\n        }\n    }\n    #endif\n    return dist;\n}\n\n// Volumetric 4d raymarching\nfloat raymarch4d(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    //Accumulated density\n    float a = 0.;\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        vec4 p = ray_pos + l * lower_ray_dir;\n        d = sdCluster(ray_pos + l * lower_ray_dir, l * elongation_vec, l);\n        a += min(1., exp2(STAR_SIZE - d / GLOW_DIST));\n        l += d + STAR_SIZE * 0.5;\n        if (l > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return a;\n    \n}\n\nvec2 raymarch4dNebula(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    //Accumulated density\n    vec2 a = vec2(0.);\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        vec4 p = ray_pos + l * lower_ray_dir;\n        d = sdCluster(ray_pos + l * lower_ray_dir, l * elongation_vec, l);\n        float intensity = clamp(20. / (d), 5., 20.);\n        a += vec2(nebula(p), nebula(p + vec4(1000., 0.,0.,0.))) * intensity;\n        \n        l += 5.;\n        if (l > MAX_DIST) {\n            \n            break;\n        }\n    }\n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cam_uv = ((fragCoord/iResolution.xy) - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.);\n    \n    // Calculate camera position & direction. The requires 3 orthogonal vectors to define in 4d.\n    float orbit_rate = 0.05; // radians/sec\n    \n    vec2 m = iMouse.xy / iResolution.xy * 30. - vec2(15.);\n    \n    vec4 fwd = vec4(sin(iTime * orbit_rate), cos(iTime * orbit_rate), 0., 0.);\n    #ifdef CAMERA_MOTION\n    float vel = (0.1 - 0.1 * cos(iTime * 0.1));\n    vec4 future = normalize(vec4(0., -0.5 * vel, 0., 1.));\n    #else\n    vec4 future = vec4(0.,0.,0.,1.);\n    #endif\n    vec4 camera_d = camera_spacelike_dir(cam_uv, fwd, UP_4, future);\n    vec4 base_pos = 20. * (0.1 * iTime - sin(iTime * 0.1)) * vec4(0., 1.,0.,0.);\n    #ifdef STARS_MOVE\n    vec4 ray_pos = base_pos + fwd * m.x + UP_4 * m.y -future * iTime;\n    #else\n    vec4 ray_pos = base_pos + fwd * m.x + UP_4 * m.y;\n    #endif\n    \n    \n    // Raymarch 4 different wavelength/velocity ranges\n    float r = raymarch4d(camera_d, ray_pos, future, 0.58, 0.65); // Red light is slowest (Pointed most towards the camera's future)\n    float g = raymarch4d(camera_d, ray_pos, future, 0.51, 0.59);\n    float b = raymarch4d(camera_d, ray_pos, future, 0.46, 0.54);\n    float v = raymarch4d(camera_d, ray_pos, future, 0.44, 0.48); // Violet light is fastest\n    \n    vec2 n = raymarch4dNebula(camera_d, ray_pos, future, 0.44, 0.65) / float(MAX_ITERATIONS);\n    \n    // Wavelength range colors\n    vec3 r_col = vec3(0.8, 0.1, 0.);\n    vec3 g_col = vec3(0.1, 0.8, 0.);\n    vec3 b_col = vec3(0., 0.2, 0.4);\n    vec3 v_col = vec3(0.25, 0., 0.6);\n    vec3 nebula_col1 = vec3(1., 0.5, 0.);\n    vec3 nebula_col2 = vec3(0.5, 0.0, 1.);\n    // Additively mix final color\n    vec3 col = r * r_col + g * g_col + b * b_col + v * v_col + n.x * nebula_col1 + n.y * nebula_col2;\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// A starfield 4-D spacetime described by Greg Egan in his Orthogonal series.\n//\n// The universe rendered here is mostly accurate to the one described by Greg Egan in his Orthogonal \n// series.\n//\n// This scene shows a universe with 4 dimensions, much like our own, except that there is no special\n// \"time\" dimension. Objects are free to move in any direction (Always with a velocity of 1).\n// For any given observer, their direction of motion dictates their own arrow of time.\n//\n// Stars are modelled as infinitely long 4-d lines. Because these lines are not parallel (The stars\n// are moving), the 3-D domain repetition is a bit of a hack and sometimes ends up cutting off parts\n// of stars. It only works well when the observer's arrow of time is approximately parallel with\n// the stars.\n// \n// One consequence of this universe is that the speed of light depends on its wavelength (which\n// depends on its orientation relative to you). This creates the streaks seen behind the stars.\n// For the sake of accuracy, rendering is done by sampling light is sampled at a few different \n// wavelength ranges. This also contributes to slow rendering.\n//\n// Another consequence is that a constantly accelerating object will eventually have a direction\n// orthogonal to its original direction, which would appear to a stationary observer like moving at an\n// infinite velocity.\n//\n// One aspect which is not modelled is that this universe must be a finite, compact manifold thanks to\n// the properties of light waves. This could likely be modelled by domain repitition, but care would\n// have to be taken to ensure that every star loops back to its original position after exactly one lap.\n//\n// For a more complete explaination of the physics/geometry of Riemmanian spacetime,\n// see http://gregegan.net/ORTHOGONAL/ORTHOGONAL.html\n\n\n\n// ------------------------------------------ SETTINGS ------------------------------------------\n// More stars & less artifacts - uncomment if your computer can handle it\n\n//#define HIGH_QUALITY\n\n// Less stars and more performance\n\n//#define POTATO_QUALITY\n\n// Stars will actually move through the 4d spacetime.\n// This causes artefacts with the domain repetition after some time\n\n//#define STARS_MOVE\n\n// Controls how long star trails are.\n#define STAR_VELOCITY 0.1\n\n// Take camera velocity into account when rendering stars.\n// This will give a more realistic perspective of a moving observer.\n#define CAMERA_MOTION\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 184]], "test": "untested"}
{"id": "cdsSW4", "name": "Wireworld Cellular Automaton", "author": "oneshade", "description": "A circuit in wireworld.", "tags": ["automata", "ca", "wireworld", "circuits"], "likes": 27, "viewed": 363, "published": 3, "date": "1668895112", "time_retrieved": "2024-07-30T16:18:41.709588", "image_code": "#define BLANK 0\n#define COPPER 1\n#define HEAD 2\n#define TAIL 3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Cells\n    fragCoord *= 40.0 / iResolution.y;\n    int state = int(texelFetch(iChannel0, ivec2(fragCoord), 0).x);\n    if (state == COPPER) color = vec3(1.0, 0.75, 0.0);\n    if (state == HEAD) color = vec3(0.0, 0.0, 1.0);\n    if (state == TAIL) color = vec3(1.0, 0.0, 0.0);\n\n    // Grid\n    color = mix(color, vec3(0.5), smoothstep(50.0 / iResolution.y, 0.0, abs(fract(fragCoord.x + 0.5) - 0.5)));\n    color = mix(color, vec3(0.5), smoothstep(50.0 / iResolution.y, 0.0, abs(fract(fragCoord.y + 0.5) - 0.5)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BLANK 0\n#define COPPER 1\n#define HEAD 2\n#define TAIL 3\n\nbool point(in ivec2 cell, in int x, in int y) {\n    return cell.x == x && cell.y == y;\n}\n\nbool wire(in ivec2 cell, in int y, in int x0, in int x1) {\n    return cell.y == y && cell.x >= x0 && cell.x <= x1;\n}\n\nbool clock(in ivec2 cell, in int y, in int x0, in int x1) {\n    bool etch = cell.y == y && (cell.x == x0 || cell.x == x1);\n    etch = etch || (abs(cell.y - y) == 1 && cell.x >= x0 + 1 && cell.x <= x1 - 1);\n    return etch;\n}\n\nbool diode(in ivec2 cell, in int x, in int y, in int dir) {\n    cell.x *= dir, x *= dir;\n    bool etch = abs(cell.y - y) == 1 && cell.x >= x - 1 && cell.x <= x;\n    etch = etch || (cell.y == y && cell.x == x - 1);\n    return etch;\n}\n\nbool and(in ivec2 cell, in int x, in int y, in int dir) {\n    cell.x *= dir, x *= dir;\n    cell -= ivec2(5, -3);\n    bool etch = cell.y == y + 3 && cell.x >= x - 4 && cell.x <= x + 2;\n    etch = etch || (abs(cell.x - x + 3) == 1 && cell.y >= y - 3 && cell.y <= y - 1);\n    etch = etch || (cell.x == x - 3 && cell.y == y - 4);\n    etch = etch || (cell.x == x && abs(cell.y - y) < 2);\n    etch = etch || (cell.y == y && abs(cell.x - x) == 1);\n    etch = etch || (cell.x == x + 2 && abs(cell.y - y) == 1);\n    etch = etch || (cell.x == x + 4 && abs(cell.y - y + 2) < 2);\n    etch = etch || (cell.y == y - 2 && abs(cell.x - x - 4) == 1);\n    etch = etch || (cell.y == y + 2 && cell.x >= x + 3 && cell.x <= x + 5);\n    etch = etch || (cell.x == x + 6 && cell.y >= y - 1 && cell.y <= y + 1);\n    etch = etch || (cell.y == y - 3 && cell.x >= x + 6 && cell.x <= x + 7);\n    etch = etch || (cell.x == x + 8 && cell.y == y - 2);\n    etch = etch || (cell.y == y - 1 && cell.x >= x + 9 && cell.x <= x + 10);\n    return etch;\n}\n\nbool or(in ivec2 cell, in int x, in int y, in int dir) {\n    cell.x *= dir, x *= dir;\n    cell -= ivec2(1, -2);\n    bool etch = cell.x == x && abs(cell.y - y) < 2;\n    etch = etch || (abs(cell.x - x) < 2 && cell.y == y);\n    return etch;\n}\n\nbool xor(in ivec2 cell, in int x, in int y, in int dir) {\n    cell.x *= dir, x *= dir;\n    cell -= ivec2(1, -3);\n    bool etch = cell.x == x - 1 && abs(cell.y - y) < 2;\n    etch = etch || (abs(cell.y - y) == 1 && cell.x >= x - 1 && cell.x <= x + 2);\n    etch = etch || (cell.y == y && cell.x >= x + 2 && cell.x <= x + 3);\n    etch = etch || (cell.x == x && abs(cell.y - y) == 2);\n    return etch;\n}\n\nbool flipflop(in ivec2 cell, in int x, in int y, in int dir) {\n    cell.x *= dir, x *= dir;\n    bool etch = cell.x == x + 1 && cell.y == y;\n    etch = etch || (cell.x == x + 2 && abs(cell.y - y + 2) < 2);\n    etch = etch || (abs(cell.x - x - 2) == 1 && cell.y == y - 2);\n    etch = etch || (cell.x == x + 1 && cell.y >= y - 7 && cell.y <= y - 4);\n    etch = etch || (abs(cell.x - x - 1) == 1 && cell.y == y - 6);\n    etch = etch || (cell.x == x + 3 && cell.y >= y - 5 && cell.y <= y - 4);\n    return etch;\n}\n\n#define Etch(copper) etch = etch || (copper)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(BLANK);\n    ivec2 cell = ivec2(fragCoord - 0.5);\n    if (iFrame == 0) {\n        // Fast clock (1/6)cycles/frame\n        bool etch = clock(cell, 2, 1, 4);\n        Etch(wire(cell, 2, 5, 11));\n        Etch(wire(cell, 6 - 3, 12, 16));\n        Etch(wire(cell.yx, 17, 4, 19));\n        Etch(wire(cell, 20, 18, 20));\n\n        // 3x slower than first clock\n        Etch(clock(cell, 6, 1, 10));\n        Etch(wire(cell, 6, 11, 14));\n        Etch(wire(cell.yx, 15, 7, 22));\n        Etch(wire(cell, 23, 16, 20));\n\n        Etch(and(cell, 20, 23, 1));\n\n        // Slooow clock (1/124)cycles/frame\n        Etch(wire(cell, 13, 20, 33));\n        Etch(point(cell, 19, 12));\n        Etch(wire(cell, 11, 20, 31));\n        Etch(point(cell, 32, 10));\n        Etch(point(cell, 19, 8));\n        Etch(wire(cell, 9, 20, 31));\n        Etch(wire(cell, 7, 20, 40));\n        Etch(point(cell, 41, 6));\n        Etch(wire(cell, 5, 20, 40));\n        Etch(point(cell, 19, 4));\n        Etch(wire(cell, 3, 20, 42));\n        Etch(wire(cell.yx, 43, 4, 8));\n        Etch(wire(cell, 9, 35, 42));\n        Etch(wire(cell.yx, 34, 10, 12));\n\n        // Flipflop\n        Etch(flipflop(cell, 35, 19, 1));\n        Etch(wire(cell, 15, 39, 45));\n\n        // Display\n        Etch(wire(cell.yx, 46, 16, 36));\n        Etch(point(cell, 47, 37));\n        Etch(wire(cell.yx, 48, 16, 36));\n        Etch(point(cell, 49, 15));\n        Etch(wire(cell.yx, 50, 16, 36));\n        Etch(point(cell, 51, 37));\n        Etch(wire(cell.yx, 52, 16, 36));\n        Etch(point(cell, 53, 15));\n        Etch(wire(cell.yx, 54, 16, 36));\n\n        if (etch) fragColor = vec4(COPPER);\n\n        if (point(cell, 4, 2)) fragColor = vec4(HEAD);\n        if (point(cell, 3, 1)) fragColor = vec4(TAIL);\n\n        if (point(cell, 10, 6)) fragColor = vec4(HEAD);\n        if (point(cell, 9, 5)) fragColor = vec4(TAIL);\n\n        if (point(cell, 34, 12)) fragColor = vec4(HEAD);\n        if (point(cell, 33, 13)) fragColor = vec4(TAIL);\n    }\n\n    else {\n        fragColor = texelFetch(iChannel0, cell, 0);\n        if (iFrame % 5 == 0) {\n            int state = int(texelFetch(iChannel0, cell, 0).x);\n\n            int heads = 0;\n            for (int i=-1; i <= 1; i++) {\n                for (int j=-1; j <= 1; j++) {\n                    if (!(i == 0 && j == 0)) {\n                        int neighbor = int(texelFetch(iChannel0, cell + ivec2(i, j), 0).x);\n                        if (neighbor == HEAD) heads++;\n                    }\n                }\n            }\n\n            if (state == COPPER && (heads == 1 || heads == 2)) state = HEAD;\n            else if (state == HEAD) state = TAIL;\n            else if (state == TAIL) state = COPPER;\n\n            fragColor = vec4(state);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 119, 119, 802]], "test": "untested"}
{"id": "ddfXWN", "name": "Glowy Pearl Balls", "author": "SnoopethDuckDuck", "description": "playing with glow and other things. recalculating the ray direction is kind of weird", "tags": ["glow"], "likes": 39, "viewed": 508, "published": 3, "date": "1668887817", "time_retrieved": "2024-07-30T16:18:42.562308", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 rayOri() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float mx = 0.5 - 0.5 * thc(4., 0.2 * iTime);\n    vec3 ro = vec3(0, mix(1.5, 0.1, mx), mix(-3., -18., mx));\n   // ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat dist(vec3 p) { \n    p.y += 250. + iTime; // + 2. * cc(1., 0.06 * p.z - iTime);\n    p.xz *= rot(3. * atan(p.y,p.z) - 0.1 * iTime);\n   // p.y += 0.5 * cos(10. * floor(p.x/3.) + 8. * floor(p.z/3.));\n    p = mod(p, 3.) - 1.5;\n    float d = length(p) - 0.5;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, float z) {\t\n    float dO=0.;\n    float s = sign(z);\n    float steps = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = dist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) {\n            steps = float(i);\n            break;\n        }\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }      \n        dO += dS*z; \n    }\n    \n    return vec2(min(dO, MAX_DIST), steps);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = dist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy),\n        dist(p-e.yxy),\n        dist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = rayOri();\n    \n    vec3 rd = rayDir(uv, ro, vec3(0), 1.45);\n    vec3 col = vec3(0);\n   \n    vec2 m = march(ro, rd, 1.);\n    float d = m.x;\n\n    vec3 p = ro + rd * d;      \n    vec3 n = normal(p);\n    \n    rd = mix(rd, \n             rayDir(uv, ro, vec3(0), dist(p)), \n             0.25 + 0.25 * thc(10., 0.5 * length(p) + iTime));\n    rd = normalize(rd);\n    \n    vec3 r = reflect(rd, n);\n    vec3 lightDir = normalize(vec3(1,2,3));\n    float dif  = dot(n,  lightDir)*.5+.5;\n    float fres = pow(1. + dot(rd, n),  4.);\n    float v = exp(-0.03 * m.y);\n    if (d == MAX_DIST)\n        v = 0.;   \n\n    vec3 tx = texture(iChannel0, r).rgb;\n  \n    // mixing with p.y oversaturates but looks cool\n    vec3 bg = mix(vec3(1), \n                  pal(1.25 + 0.05 * cos(0.25 * iTime),\n                      0.5 * vec3(0,1,2)/3.), \n                  -abs(p.y));\n    \n    col = mix(bg * exp(-0.2 * abs(p.y)), \n              0.5 + 0.5 * n,  // was r\n              v);\n   \n    col = mix(col, tx, v * (1.-fres));\n\n    //col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 207, 207, 283], [285, 285, 323, 323, 388], [390, 390, 409, 409, 492], [494, 494, 523, 523, 604], [606, 606, 640, 640, 716], [718, 718, 733, 733, 967], [969, 969, 989, 989, 1243], [1245, 1245, 1284, 1284, 1682], [1684, 1684, 1705, 1705, 1883], [1885, 1885, 1932, 1932, 2123], [2125, 2125, 2182, 2182, 3347]], "test": "untested"}
{"id": "dsfSWH", "name": "Floyd–Steinberg dithering", "author": "Rutvik_Tak", "description": "Trying out recreation of Floyd–Steinberg dithering in GLSL\n", "tags": ["grayscale", "imagefilter", "image", "pixelation"], "likes": 0, "viewed": 409, "published": 3, "date": "1668886111", "time_retrieved": "2024-07-30T16:18:43.419017", "image_code": "\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    // Output to screen\n    \n    vec4 mycolor=vec4(uv.xyx,1.);\n    \n    //vec4 color = texture( iChannel0, uv.xy );\n    \n    vec4 bitRateColor=vec4(sin(mycolor.x*700.)*.3,cos(mycolor.y*700.)*.3,1.,1.);\n    vec2 res=iResolution.xy/3.;\n    vec2 pos=floor(uv*res)/res;\n    //if(max(abs(pos.x-.5),abs(pos.y-.5))>.5){\n   //     fragColor=vec4(0.);\n  //  }\n    \n    vec4 imagePixel=texture(iChannel0,pos.xy);\n    float factor = 1.0;\n    \n    //vec4 imagetopixelcolor=vec4(bitRateColor.xy,imagePixel.x,imagePixel.x);\n    \n   // float grayScaleValue=(imagetopixelcolor.x+imagetopixelcolor.y+imagetopixelcolor.z)/3.;\n    float newR = round(factor*imagePixel.r)*1./factor;\n    float newG = round(factor*imagePixel.g)*1./factor;\n    float newB = round(factor*imagePixel.b)*1./factor;//step(0.5,imagePixel.b);\n    \n    float errR = imagePixel.r - newR;\n    float errG = imagePixel.g - newG;\n    float errB = imagePixel.b - newB;\n    \n    \n    \n   // pixels[x + 1][y    ] := pixels[x + 1][y    ] + quant_error × 7 / 16\n  //  pixels[x - 1][y + 1] := pixels[x - 1][y + 1] + quant_error × 3 / 16\n  //  pixels[x    ][y + 1] := pixels[x    ][y + 1] + quant_error × 5 / 16\n  //  pixels[x + 1][y + 1] := pixels[x + 1][y + 1] + quant_error × 1 / 16\n\n\n    \n    vec3 filteredColor = vec3(errR,errG,errB);\n        fragColor=vec4(filteredColor,1.);\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 55, 105, 1483]], "test": "untested"}
{"id": "mdfXW4", "name": "Multiple inputs quick test", "author": "PauloFalcao", "description": "A quick Multiple inputs quick test generated in Material Maker", "tags": ["materialmaker", "shadershrinker"], "likes": 11, "viewed": 273, "published": 3, "date": "1668880705", "time_retrieved": "2024-07-30T16:18:44.325593", "image_code": "// Multiple inputs quick test\n//\n// Generated in Material Maker by PauloFalcao\n//\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 11,817 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n#define v4\tvec4\n#define v3\tvec3\n#define v2\tvec2\n#define RET\treturn\n#define NM\tnormalize\n#define FC\tfract\n#define _c\tclamp\n#define _f\tfloat\n#define iT\tiTime\n#define iR\tiResolution\n\nfloat SD(v2 p) {\n\tp *= 2.;\n\tv2 i,\n\t   w = max(abs(dFdx(p)), abs(dFdy(p))) + 1e-5;\n\tif (max(w.x, w.y) > 1.) RET mod(floor(p.x) + floor(p.y), 2.);\n\ti = ((1. - abs(2. * FC((p + .5 * w) / 2.) - 1.)) - (1. - abs(2. * FC((p - .5 * w) / 2.) - 1.))) / w;\n\tRET .5 - .5 * i.x * i.y;\n}\n\nvec3 M(v3 p, v3 a) {\n\t_f c = cos(a.x),\n\t   s = sin(a.x);\n\tv3 RV;\n\tRV.x = p.x;\n\tRV.y = p.y * c + p.z * s;\n\tRV.z = -p.y * s + p.z * c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = RV.x * c + RV.z * s;\n\tp.y = RV.y;\n\tp.z = -RV.x * s + RV.z * c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\tRV.x = p.x * c + p.y * s;\n\tRV.y = -p.x * s + p.y * c;\n\tRV.z = p.z;\n\tRET RV;\n}\n\nfloat A(v3 p) {\n\tv3 w = max(abs(dFdx(p)), abs(dFdy(p))) + 1e-4,\n\t   i = ((1. - abs(2. * FC((p + .5 * w) / 2.) - 1.)) - (1. - abs(2. * FC((p - .5 * w) / 2.) - 1.))) / w;\n\tRET .5 - .5 * i.x * i.y * i.z;\n}\n\nfloat ss(v3 p) {\n\tconst v2 t = v2(.3, .15);\n\tRET length(v2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec3 x3(v3 c) {\n\t_f j = 4096. * sin(dot(c, v3(17, 59.4, 15)));\n\tv3 r;\n\tr.z = FC(512. * j);\n\tj *= .125;\n\tr.x = FC(512. * j);\n\tj *= .125;\n\tr.y = FC(512. * j);\n\tRET r - .5;\n}\n\nfloat Xd(v3 p) {\n\tv3 s = floor(p + dot(p, v3(.3333333))),\n\t   x = p - s + dot(s, v3(.1666667)),\n\t   e = step(v3(0), x - x.yzx),\n\t   F = e * (1. - e.zxy),\n\t   G = 1. - e.zxy * (1. - e),\n\t   X1 = x - F + .1666667,\n\t   X2 = x - G + .33333,\n\t   X3 = x - .5;\n\tv4 w, d;\n\tw.x = dot(x, x);\n\tw.y = dot(X1, X1);\n\tw.z = dot(X2, X2);\n\tw.w = dot(X3, X3);\n\tw = max(.6 - w, 0.);\n\td.x = dot(x3(s), x);\n\td.y = dot(x3(s + F), X1);\n\td.z = dot(x3(s + G), X2);\n\td.w = dot(x3(s + 1.), X3);\n\tw *= w;\n\tw *= w;\n\td *= w;\n\tRET dot(d, v4(52));\n}\n\nvec2 C(v3 y) { RET v2(atan(y.y, y.x), acos(y.z)) / v2(6.28319, 3.1415926); }\n\nfloat S2(v2 p) {\n\tv3 P3 = FC(p.xyx * .1031);\n\tP3 += dot(P3, P3.yzx + 33.33);\n\tRET FC((P3.x + P3.y) * P3.z);\n}\n\nfloat Se(v2 v) {\n\tv2 V1 = floor(v),\n\t   V2 = smoothstep(0., 1., FC(v));\n\tRET mix(mix(S2(V1), S2(V1 + v2(0, 1)), V2.y), mix(S2(V1 + v2(1, 0)), S2(V1 + v2(1)), V2.y), V2.x);\n}\n\nfloat St(v2 p) { RET Se(p) * .5 + Se(p * 2. + 13.) * .25 + Se(p * 4. + 23.) * .15 + Se(p * 8. + 33.) * .1 + Se(p * 16. + 43.) * .05; }\n\nvec3 SR(v3 p) {\n\tv3 v = (St(p.xz * .1) - .5) * v3(1);\n\t_f d = length(p);\n\tRET mix(v3(.15, .3, .6) + v, v3(.2, .5, 1) + v * 12. / max(d, 20.), _c(d * .1, 0., 1.));\n}\n\nvec3 Sr(v3 p) { RET (St(p.xz * .1) * .5 + .25) * v3(.7, .5, .4); }\n\nvec3 S0(v3 RD, v3 sn) {\n\tv3 p, c;\n\tif (RD.y > 0.) {\n\t\tp = RD * 5. / RD.y;\n\t\tc = SR(p);\n\t}\n\telse {\n\t\tp = RD * -10. / RD.y;\n\t\tc = mix(Sr(p), v3(.5, .7, 1), _c(1. - sqrt(-RD.y) * 3., 0., 1.));\n\t}\n\n\t_f z = _c(dot(sn, RD), 0., 1.);\n\tv3 sc = (z > .9997 ? v3(2) : v3(0)) + pow(z, 512.) * 4. + pow(z, 128.) * v3(.5) + pow(z, 4.) * v3(.5);\n\tif (RD.y > 0.) c += v3(.3) * pow(1. - abs(RD.y), 3.) * .7;\n\tRET c + sc;\n}\n\nvec3 Si(v2 p) {\n\tv3 sn = v3(-.68041, .68041, -.27217);\n\tv2 ti = (p * 2. - v2(1)) * v2(3.1415926, 1.5708);\n\tRET S0(v3(cos(ti.y) * cos(ti.x), sin(ti.y), cos(ti.y) * sin(ti.x)), sn);\n}\n\nfloat R(v3 p, _f _) { RET max((p).y + 1., length(v3((p).x, (p).y - 1., (p).z)) - 6.); }\n\nvec3 V(v4 p, _f _) { RET v3(SD((p).xz)) * .9 + .1; }\n\nfloat S(v3 p, _f _) { RET (length(M((p).xyz - v3(0, sin(iT) * .5, 0), v3(iT * 11., iT * 13., iT * 17.) * .01745329) / 1.98) - .4) * 1.98; }\n\nvec4 OT(_f x) {\n\tif (x < 0.) RET v4(.87109398, .87109398, .87109398, 1);\n\tif (x < 1.) RET mix(v4(.87109398, .87109398, .87109398, 1), v4(.230469, .230469, .230469, 1), x);\n\tRET v4(.230469, .230469, .230469, 1);\n}\n\nvec3 W(v4 p, _f _) { RET OT(dot(v3(A(M((p).xyz - v3(0, sin(iT) * .5, 0), v3(iT * 11., iT * 13., iT * 17.) * .01745329) / .198)), v3(1)) / 3.).rgb; }\n\nfloat T(v3 p, _f _) { RET ss((M((p).xyz - v3(1.012, -.001, 0), v3(iT * 29., iT * 31., iT * 33.) * .01745329) / 1.774).yzx) * 1.774; }\n\nfloat om(v3 q, _f _) {\n\t_f P = 0.,\n\t   ve = 0.,\n\t   se = 1.,\n\t   SE = 1.;\n\tfor (int i = 0; i < 6; i++) {\n\t\tve += Xd(q * SE) * se;\n\t\tP += se;\n\t\tSE *= 2.;\n\t\tse *= .5;\n\t}\n\n\tRET ve / P;\n}\n\nfloat Z(_f f, _f _) { RET f * 8.936 - 3.968; }\n\nvec3 X(v4 p, _f _) { RET _c(v3(Z(om((M((p).xyz - v3(1.012, -.001, 0), v3(iT * 29., iT * 31., iT * 33.) * .01745329) / 1.774).xyz * 2. + v3(0), _) * .5 + .5, _)), v3(0), v3(1)); }\n\nfloat U(v3 p, _f _) { RET ss((M((p).xyz - v3(-1.509, -.001, 0), v3(iT * 21., iT * 23., iT * 27.) * .01745329) / 1.774).yzx) * 1.774; }\n\nvec4 ot(_f x) {\n\tif (x < .4) RET v4(0, 0, 1, 1);\n\tif (x < .663636) RET mix(v4(0, 0, 1, 1), v4(1), (x - .4) / .26364);\n\tRET v4(1);\n}\n\nfloat OM(v3 q, _f _) {\n\t_f P = 0.,\n\t   ve = 0.,\n\t   se = 1.,\n\t   SE = 1.;\n\tfor (int i = 0; i < 6; i++) {\n\t\tve += Xd(q * SE) * se;\n\t\tP += se;\n\t\tSE *= 2.;\n\t\tse *= .451;\n\t}\n\n\tRET ve / P;\n}\n\nfloat oc(_f f, _f _) { RET f * 8.936 - 3.968; }\n\nvec3 Y(v4 p, _f _) { RET ot(dot(_c(v3(oc(OM((M((p).xyz - v3(-1.509, -.001, 0), v3(iT * 21., iT * 23., iT * 27.) * .01745329) / 1.774).xyz * 3.77 + v3(0), _) * .5 + .5, _)), v3(0), v3(1)), v3(1)) / 3.).rgb; }\n\nvec3 Q(v2 UV, _f _) { RET Si(v2((UV).x, -(UV).y + 1.)); }\n\nvec2 I(v3 p, _f _) {\n\tv2 sf = v2(999999, 0);\n\t_f m = R(p, _);\n\tif (m < sf.x) sf = v2(m, 1);\n\tm = S(p, _);\n\tif (m < sf.x) sf = v2(m, 2);\n\tm = T(p, _);\n\tif (m < sf.x) sf = v2(m, 3);\n\tm = U(p, _);\n\tif (m < sf.x) sf = v2(m, 4);\n\tRET sf;\n}\n\nvec3 t6(v3 p, _f H, _f _) {\n\tv3 t = v3(0);\n\tif (H > .5 && H < 1.5) t = V(v4(p, H), _);\n\tif (H > 1.5 && H < 2.5) t = W(v4(p, H), _);\n\tif (H > 2.5 && H < 3.5) t = X(v4(p, H), _);\n\tif (H > 3.5 && H < 4.5) t = Y(v4(p, H), _);\n\tRET t;\n}\n\nvec3 O(v3 p, _f _) {\n\tconst v3 e = v3(.001, -.001, 0);\n\t_f V1 = I(p + e.xyy, _).x,\n\t   V2 = I(p + e.yyx, _).x,\n\t   V3 = I(p + e.yxy, _).x,\n\t   V4 = I(p + e.xxx, _).x;\n\tRET NM(v3(V4 + V1 - V3 - V2, V3 + V4 - V1 - V2, V2 + V4 - V3 - V1));\n}\n\nvoid K(inout float d, inout vec3 p, inout vec2 B, v3 RO, v3 RD, _f _) {\n\tfor (int i = 0; i < 500; i++) {\n\t\tp = RO + RD * d;\n\t\tB = I(p, _);\n\t\td += B.x;\n\t\tif (d > 50. || abs(B.x) < 1e-4) break;\n\t}\n}\n\nfloat b(v3 ps, v3 N, _f _) {\n\t_f OC = 0.,\n\t   sa = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\t_f h = .001 + .25 * _f(i) / 4.,\n\t\t   d = I(ps + h * N, _).x;\n\t\tOC += (h - d) * sa;\n\t\tsa *= .98;\n\t}\n\n\tRET _c(1. - 1.6 * OC, 0., 1.);\n}\n\nfloat g(v3 RO, v3 RD, _f _) {\n\t_f rs = 1.,\n\t   t = .05;\n\tfor (int i = 0; i < 32; i++) {\n\t\t_f h = I(RO + RD * t, _).x;\n\t\trs = min(rs, 10. * h / t);\n\t\tt += h;\n\t\tif (rs < 1e-4 || t > 5.) break;\n\t}\n\n\tRET _c(rs, 0., 1.);\n}\n\nvec3 r6(v2 UV) {\n\t_f _ = 0.,\n\t   d = 0.;\n\tUV -= .5;\n\tv3 or, J,\n\t   k = v3(sin(sin(iT * .2) * 2.) * 4., 2, sin(cos(iT) * 1.9) * 3.) * 1.338,\n\t   ry = NM(v3(0, .3, 0) - k),\n\t   u = NM(cross(v3(0, 1, 0), ry)),\n\t   RD = NM(ry * 1.864 + u * UV.x + NM(cross(u, ry)) * UV.y),\n\t   RO = k,\n\t   p = v3(0),\n\t   o = v3(0);\n\tv2 B = v2(0);\n\tK(d, p, B, RO, RD, _);\n\tor = t6(p, B.y, _);\n\tJ = v3(.68041, .68041, .27217);\n\tif (d < 50.) {\n\t\tv3 rf, of,\n\t\t   n = O(p, _);\n\t\t_f l = _c(dot(-J, -n), 0., 1.);\n\t\trf = NM(reflect(RD, -n));\n\t\to = min(v3(max(mix(1., g(p, J, _), 1.), .25)), max(l, .25)) * max(mix(1., b(p, n, _), 1.), .25) * or;\n\t\td = .01;\n\t\tK(d, p, B, p, rf, _);\n\t\tof = v3(0);\n\t\tif (d < 50.) {\n\t\t\tof = t6(p, B.y, _);\n\t\t\tn = O(p, _);\n\t\t\tl = _c(dot(-J, -n), 0., 1.);\n\t\t\tof = max(l, .25) * of;\n\t\t}\n\t\telse of = Q(C(rf.xzy), _).xyz;\n\n\t\to = mix(o, of, .144);\n\t}\n\telse o = Q(C(RD.xzy), _).xyz;\n\n\tRET o;\n}\n\nvoid mainImage(out vec4 D, v2 E) {\n\t_f L = min(iR.x, iR.y);\n\tD = v4(r6(v2(0, 1) + v2(1, -1) * (E - .5 * (iR.xy - v2(L))) / L), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 667, 687, 687, 1008], [3468, 3468, 3489, 3489, 3607], [5294, 5294, 5314, 5314, 5528], [5530, 5530, 5557, 5557, 5761], [6003, 6003, 6074, 6074, 6199], [6643, 6643, 6659, 6659, 7529], [7531, 7531, 7565, 7565, 7663]], "test": "untested"}
{"id": "cdXXWN", "name": "Simple voxel raytracer V1", "author": "NikZapp", "description": "Volume of voxels with densities and colors being raytraced (no reflections, just stepping the ray).\nTODO: optimize voxel traversal and implement octree loading.", "tags": ["simple", "ray", "voxel", "raytrace", "trace"], "likes": 7, "viewed": 429, "published": 3, "date": "1668864036", "time_retrieved": "2024-07-30T16:18:45.367807", "image_code": "float screenDist = 1.0;\nfloat rayLength = 0.001;\nfloat screenSize = 1.5;\n\nint ITER = 1000;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - vec2(1.0);\n    uv.x /= iResolution.y / iResolution.x;\n    vec3 camera_pos = (vec3(sin(iTime), cos(iTime), -3.0) * 0.1) + vec3(0.5, 0.5, 0.0);\n    vec3 ray_pos = camera_pos;\n    \n    vec3 ray_step = normalize(vec3(uv * screenSize, screenDist)) * rayLength;\n\n    vec4 color = vec4(0.0);\n    \n    for (int i = 0; i < ITER; i++) {\n        ray_pos += ray_step;\n        vec4 voxel = texture(iChannel0, ray_pos);\n        \n        // (optional) Making dense voxels more clumped \n        voxel += texture(iChannel0, ray_pos / 2.0);\n        voxel += texture(iChannel0, ray_pos / 4.0);\n        voxel += texture(iChannel0, ray_pos / 8.0);\n        voxel *= 0.25;\n        \n        // (optional) Making density more different\n        voxel.a = smoothstep(0.0, 1.0, pow(voxel.a, 10.0));\n        \n        // Compute absolute density\n        voxel.a = mix(voxel.a, 1.0, color.a) - color.a; \n        \n        // Applying color\n        color.rgb += voxel.rgb * voxel.a;\n        color.a += voxel.a;\n    }\n    \n    fragColor = color;\n    \n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 149, 149, 1217]], "test": "untested"}
{"id": "DdfXW4", "name": "F# Windows Terminal Shader", "author": "mrange", "description": "CC0: F# Windows Terminal Shader\nA shader background for Windows Terminal featuring the F# logo\n", "tags": ["f", "windowsterminal"], "likes": 19, "viewed": 448, "published": 3, "date": "1668855771", "time_retrieved": "2024-07-30T16:18:46.172655", "image_code": "// CC0: F# Windows Terminal Shader\n//  A shader background for Windows Terminal featuring the F# logo\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n//  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  const vec3 k = 0.5*vec3(-sqrt(3.0),1.0,sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 pmin(vec2 a, vec2 b, float k) {\n  vec2 h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 pabs(vec2 a, float k) {\n  return -pmin(-a, a, k);\n}\n\nvec2 dfsharp(vec2 p) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  vec2 p3 = p;\n  const float sm = 0.03;\n  p0 = pabs(p0, sm);\n  const vec2 n = normalize(vec2(1.0));\n  float d0 = abs(dot(n, p0)-0.38)-0.12;\n  float d1 = abs(p1.x)-0.025;\n  float d2 = dot(n, p0)-0.19;\n  float d3 = -p3.x-0.025;\n  d2 = pmax(d2, -d3, sm);\n  float d = d0;\n\n  d = pmax(d, -d1, sm);\n  d = min(d,  d2);\n  return vec2(d, p.x > 0.0 ? 1.0 : 0.0);\n}\n\nfloat cellf(vec2 p, vec2 n) {\n  const float lw = 0.01;\n  return -hexagon(p.yx, 0.5-lw);\n}\n\nvec2 df(vec2 p, out vec2 hn0, out vec2 hn1) {\n  const float sz = 0.25;\n  p /= sz;\n  vec2 hp0 = p;\n  vec2 hp1 = p+vec2(1.0, sqrt(1.0/3.0));\n\n  hn0 = hextile(hp0);\n  hn1 = hextile(hp1);\n\n  float d0 = cellf(hp0, hn0);\n  float d1 = cellf(hp1, hn1);\n  float d2 = length(hp0);\n\n  float d = d0;\n  d = min(d0, d1);\n\n  return vec2(d, d2)*sz;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float pa = 20.0;\n  const float pf = 0.0025;\n  const float hoff = 0.0;\n  const vec3 fcol0 = HSV2RGB(vec3(hoff+0.62, 0.95, 1.0));\n  const vec3 fcol1 = HSV2RGB(vec3(hoff+0.62, 0.75, 1.0));\n  const vec3 bcol0 = HSV2RGB(vec3(hoff+0.63, 0.85, 0.5));\n\n  float aa = 2.0/RESOLUTION.y;\n  vec2 hn0;\n  vec2 hn1;\n  vec2 df2 = dfsharp(p);\n  vec2 dfs2 = dfsharp(p-vec2(0.01, -0.01));\n  vec2 pb = p + pa*sin(TIME*pf*vec2(1.0, sqrt(0.5)));\n  vec2 d2 = df(pb, hn0, hn1);\n\n  vec3 col = vec3(0.0);\n\n  float h0 = hash(hn1);\n  float l = mix(0.25, 0.75, h0);\n\n  if (hn0.x <= hn1.x+0.5) {\n    l *= 0.5;\n  }\n\n  if (hn0.y <= hn1.y) {\n    l *= 0.75;\n  }\n  \n  col += l*bcol0;\n  \n  col = mix(col, vec3(0.), smoothstep(aa, -aa, d2.x));\n  col *= mix(0.75, 1.0, smoothstep(0.01, 0.2, d2.y));\n  col = mix(col, col*0.2, smoothstep(aa, -aa, 0.125*dfs2.x));\n  col = mix(col, smoothstep(-1.5, 0.5, p.y)*mix(fcol0, fcol1, df2.y > 0.0 ? 1.0 : 0.0), smoothstep(aa, -aa, df2.x)); \n  col *= 1.25*smoothstep(1.5, 0.25, length(pp));\n//  col *= mix(vec3(0.5), vec3(1.0),smoothstep(-0.9, 0.9, sin(0.25*TAU*p.y/aa+TAU*vec3(0.0, 1., 2.0)/3.0)));\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 377, 399, 399, 545], [840, 900, 921, 921, 991], [993, 1093, 1132, 1132, 1217], [1219, 1337, 1369, 1424, 1608], [1610, 1711, 1739, 1838, 2165], [2167, 2167, 2206, 2206, 2235], [2237, 2237, 2273, 2273, 2357], [2359, 2359, 2387, 2387, 2415], [2417, 2417, 2439, 2439, 2824], [2826, 2826, 2855, 2855, 2915], [2917, 2917, 2962, 2962, 3251], [3253, 3253, 3283, 3283, 4405], [4408, 4408, 4465, 4465, 4657]], "test": "untested"}
{"id": "cdfSzM", "name": "Realistic Raymarcher", "author": "raymarchingenthusiast", "description": "A raymarcher. Some aspects based on Art Of Code on YT. Some references were used from Inigo Quilez's website. Drag your mouse to look around.", "tags": ["raymarching", "realistic", "cabin"], "likes": 0, "viewed": 234, "published": 3, "date": "1668821541", "time_retrieved": "2024-07-30T16:18:46.959551", "image_code": "#define MAX_STEPS 250\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define SSK 8.\n#define PI 3.14159265\n#define FOV 90.\n#define OFFSET SURF_DIST*1.05\n#define bounces 1\n#define GI vec3(1.,.9,.75)*.1\n#define LP vec3(1.25*sin(iTime*2./PI),22.5,1.25*cos(iTime*2./PI));\n#define LC vec4(1.,.95,.85,fract(356.*sin(floor(iTime*230.)/230.))/.99 > 1. ? .4 : 2.)\n\n//////\nvec4 texture2(sampler2D s,vec2 p) {\n    return pow(texture(s,p),vec4(2.2));\n}\n\nvec3 skybox(vec3 rd) {\n    vec3 skybox = pow(texture(iChannel0,rd).xyz,vec3(2.2));\n    //vec3 skybox = vec3(.5,.75,.95);  //blue sky\n    return skybox;\n}\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\n\n/////World\nfloat map(in vec3 p, bool il){\n    vec3 lp = LP;\n    float d0 = sdBox(p,vec3(0.,0.,0.),vec4(10.5,0.,10.5,.5));\n    float d1 = sdBox(p,vec3(0.,-1.,0.),vec4(25.,1.,25.,0.));\n    float d2 = sdBox(p,vec3(0.,10.,0.),vec4(25.,20.,25.,.1));\n    float d3 = sdSphere(p,vec4(25.,11.,3.,5.));\n    float d4 = sdBox(p,vec3(6.,8.5,25.),vec4(4.,8.,.4,0.));\n    float d5 = max(sdBox(p,vec3(6.,8.5,25.),vec4(4.5,8.5,.5,0.)),-sdBox(p,vec3(6.,8.5,25.),vec4(4.,8.,.55,0.)));\n    float d6 = il ? sdSphere(p,vec4(lp,.5)) : MAX_DIST;\n    vec3 cp = lp+normalize(vec3(0.,30.,0.)-lp)*.1;\n    float d7 = il ? sdCapsule(p,vec3(0.,30.,0.),cp,.1) : MAX_DIST;\n    float d = min(d7,min(d6,min(min(min(d0,min(d1,max(abs(d2)-.4,-d3))),d4),d5)));\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    float d0 = map(p,true);\n    vec2 e = vec2(.01,0.);\n    vec3 n = d0-vec3(\n    map(p-e.xyy,true),\n    map(p-e.yxy,true),\n    map(p-e.yyx,true));\n    \n    return normalize(n);\n}\n\nvec3 trimap(vec3 p, sampler2D s, float k, float rk) {\n    vec3 n = pow(getNormal(p),vec3(k));\n    vec3 tx = texture2(s, p.yz/rk).xyz;\n    vec3 ty = texture2(s, p.xz/rk).xyz;\n    vec3 tz = texture2(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvoid getMat(in vec3 p, out vec3 objc, out vec3 objld, out vec2 objrd, out bool frneliz) {\n    vec3 lp = LP;\n    float d0 = sdBox(p,vec3(0.,0.,0.),vec4(10.5,0.,10.5,.5));\n    float d1 = sdBox(p,vec3(0.,-1.,0.),vec4(25.,1.,25.,0.));\n    float d2 = sdBox(p,vec3(0.,10.,0.),vec4(25.,20.,25.,.1));\n    float d3 = sdSphere(p,vec4(25.,11.,3.,5.));\n    float d4 = sdBox(p,vec3(6.,8.5,25.),vec4(4.,8.,.4,0.));\n    float d5 = max(sdBox(p,vec3(6.,8.5,25.),vec4(4.5,8.5,.5,0.)),-sdBox(p,vec3(6.,8.5,25.),vec4(4.,8.,.55,0.)));\n    float d6 = sdSphere(p,vec4(lp,.5));\n    vec3 cp = lp+normalize(vec3(0.,30.,0.)-lp)*.1;\n    float d7 = sdCapsule(p,vec3(0.,30.,0.),cp,.1);\n    float d = min(d7,min(d6,min(min(min(d0,min(d1,max(abs(d2)-.4,-d3))),d4),d5)));\n    \n    if(d==d1){\n        objc = vec3(.8,.95,1.)*texture2(iChannel2,p.xz/14.).xyz;\n        objld = vec3(1.,.3,60.);\n        objrd = vec2(.1,.1);\n        frneliz = true;\n    } else if(d==d0) {\n        objc = vec3(.8,.3,.25)*texture2(iChannel1,p.xz/14.).xyz;\n        objld = vec3(1.,.0,0.);\n        objrd = vec2(.0,1.);\n        frneliz = false;\n    } else if(d==max(abs(d2)-.4,-d3)) {\n        objc = vec3(.8,.95,1.)*trimap(p,iChannel2,10.,14.);\n        objld = vec3(1.,.3,60.);\n        objrd = vec2(.1,.1);\n        frneliz = true;\n    } else if(d==d4) {\n        objc = ((1.-vec3(1.,.9,.75))+vec3(.75))/1.75;\n        objld = vec3(.7,.2,60.);\n        objrd = vec2(.7,1.);\n        frneliz = false;\n    } else if(d==d5) {\n        objc = vec3(.9,.8,.6);\n        objld = vec3(1.,.1,120.);\n        objrd = vec2(.1,.3);\n        frneliz = true;\n    } else if(d==d6) {\n        objc = vec3(LC.xyz*LC.w/1.5);\n        objld = vec3(1.,1.,5.);\n        objrd = vec2(.1,1.);\n        frneliz = false;\n    } else if(d==d7) {\n        objc = vec3(0.,0.,0.);\n        objld = vec3(0.,0.,0.);\n        objrd = vec2(.0,1.);\n        frneliz = false;\n    }\n    \n}\n\n\nfloat raymarch(in vec3 rd, in vec3 ro, out bool hit,float maxd) {  \n    float h = 0.;                                                         \n    hit = false;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        float d = map(p,true);\n        if (d < SURF_DIST) {\n            hit = true;\n            break;\n        }\n        if (h > maxd) break;\n        h += d;\n    }\n    return h;\n}\n\nfloat shadow(vec3 p, vec3 rd, float len) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,false);\n       if(d < SURF_DIST) return 0.;\n       h += d;\n       ss = min(ss,SSK*d/h);\n    }\n    return ss;\n}\n\nvec3 diffuse(vec3 p,vec3 lp0, vec4 lc, vec3 objc) {\n    vec3 n = getNormal(p);\n    vec3 l = normalize(lp0);\n    \n    float ss = shadow(p+n*OFFSET,l,length(lp0));\n    float dif = dot(l,n);\n    return dif*lc.xyz*ss*objc*lc.w;\n}\n\nvec3 specular(vec3 p,vec3 ev, vec3 lv, vec4 lc, float ld) {\n    vec3 n = getNormal(p);\n    vec3 r = reflect(ev,n);\n    float spec = pow(max(dot(lv,r),0.),ld);\n    return lc.xyz*spec*lc.w;\n}\n\n\n//////Drawing\nvoid castAndCol(inout vec3 rd, inout vec3 ro, inout vec3 col, float refPow, out float refPowMult) {\n    vec3 lp1 = LP;\n    vec4 lc1 = LC;\n\n    bool hit = false;\n    \n    float d = raymarch(rd,ro,hit,MAX_DIST);\n\n    if (hit == true) {\n        vec3 objc = vec3(.8,.85,1.);\n        vec3 objld = vec3(1.,1.,10.);\n        vec2 objrd = vec2(.5);\n        bool frneliz = true;\n    \n        vec3 p = ro+rd*d;\n        vec3 n = getNormal(p);\n        vec3 r = reflect(rd,n);\n        getMat(p,objc,objld,objrd,frneliz);\n        \n        float refAmt = 1.;\n        if(frneliz == true) {\n            refAmt = clamp(pow(1.-dot(-rd,n),8.),0.,1.)/objrd.y;\n        }\n        \n        vec3 dif = diffuse(p,lp1-p,lc1,objc);\n        vec3 bdif = diffuse(p,p-.1*normalize(lp1-p),lc1,objc);\n        vec3 spec = specular(p,rd,normalize(lp1-p),lc1,objld.z);\n        col += dif*objld.x*refPow;\n        col += bdif*objld.x*refPow/2.;\n        col += spec*objld.y*refPow;\n        \n        refPowMult = refAmt*objrd.x;\n\n        ro = p+n*OFFSET;\n        rd = r;\n    } else {\n        vec3 sky = skybox(rd);\n        col += sky*refPow;\n        refPowMult = 0.;\n        \n    }\n}\n\nvec3 crd(vec3 ro, vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = PI*((vec2(iMouse.x*2.,iMouse.y)/iResolution.xy)-.5);\n    if(iMouse.xy == vec2(0.)) mouse.xy = vec2(PI/8.,-PI*.025);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(atan(ro.x,-ro.z),mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 mouse = PI*((vec2(iMouse.x*2.,iMouse.y)/iResolution.xy)-.5);\n    vec3 ro = vec3(20.*sin(-mouse.x),10.,-20.*cos(-mouse.x));\n    vec3 rd = crd(ro,fragCoord);\n    vec3 rdOrig = rd;\n    \n    vec3 col = vec3(0.);\n    float refPow = 1.;\n    float refPowMult = 1.;\n    castAndCol(rd,ro,col,refPow,refPowMult);\n    \n    for(int i = 0; i < bounces; i++) {\n        refPow *= refPowMult;\n        castAndCol(rd,ro,col,refPow,refPowMult);\n    }\n    \n    col += GI;\n\n    fragColor = vec4(clamp(pow(col,vec3(1./2.2)),0.,1.),1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 359, 394, 394, 436], [438, 438, 460, 460, 591], [593, 593, 619, 619, 683], [696, 696, 733, 733, 777], [779, 779, 831, 831, 952], [954, 954, 991, 991, 1086], [1089, 1100, 1130, 1130, 1827], [1829, 1829, 1853, 1853, 2032], [2034, 2034, 2087, 2087, 2300], [2303, 2303, 2392, 2392, 4177], [4180, 4180, 4245, 4245, 4587], [4589, 4589, 4631, 4631, 4880], [4882, 4882, 4933, 4933, 5107], [5109, 5109, 5168, 5168, 5298], [5301, 5315, 5414, 5414, 6456], [6458, 6458, 6493, 6493, 6958], [6960, 6960, 7017, 7017, 7543]], "test": "untested"}
{"id": "cslXDH", "name": "Simple Distortion Effects", "author": "eo", "description": "Comparing 3 distortion effects: radial shear (TR), twirl (BL) and spherize (BR) applied to a texture (TL).\nMouse controls the effect centering. Works on videos too.\n\nPorted from Unity's shader graph documentation", "tags": ["distortion", "sphere", "twirl", "spherize", "shear"], "likes": 8, "viewed": 304, "published": 3, "date": "1668816192", "time_retrieved": "2024-07-30T16:18:47.725503", "image_code": "/*\nSimple distortion effects, ported from Unity's shader graph documentation:\nhttps://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/UV-Nodes.html\n\nCode for effects is found in the common tab!\n\nEffect order:\n  ┌────────────────┬───────────────┐\n  │  Source image  │  Radial shear │\n  ├────────────────┼───────────────┤\n  │     Twirl      │    Spherize   │\n  └────────────────┴───────────────┘\n  \nThe mouse controls the effect centering\n*/\n\n\n\n// Uncomment to see how the effects distort uv-space\n//#define SHOW_UV\n\n// Controls the effect strengths\nvec2 radial_strength = vec2(5.0);\nvec2 spherize_strength = vec2(15.0);\nfloat twirl_strength = 10.0;\n\n// Set to 0 to turn off animations\nfloat ANIMATION = 1.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get 2x2 tiled uvs, centered on screen\n    // -> uv_n1p1 is 'uvs going from negative 1 to positive 1'\n    // -> uv_01_tile is 'uvs going from 0 to 1, tiled'\n    vec2 cen_coord = fragCoord - vec2(iResolution.x * 0.5, 0);\n    vec2 uv_n1p1 = 2.0 * (cen_coord / iResolution.y) - vec2(0.0, 1.0);\n    vec2 uv_01_tile = fract(uv_n1p1);\n    \n    // For helping to debug the uv mess\n    //fragColor = vec4(uv_n1p1,0,1); return;\n    //fragColor = vec4(uv_01_tile, 0, 1); return;\n    \n    // Knock out side bars\n    bool is_out_of_bounds = abs(uv_n1p1.x) > 1.0;\n    if(is_out_of_bounds) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    // Control the effect centering with the mouse\n    float is_mouse_down = clamp(iMouse.z, 0., 1.);\n    vec2 mouse_center_px = iMouse.xy - vec2(iResolution.x * 0.5, 0);\n    vec2 mouse_center_01 = fract(2.0 * (mouse_center_px / iResolution.y) - vec2(0.0, 1.0));\n    vec2 center = mix(vec2(0.5), mouse_center_01, is_mouse_down);\n    \n    // For clarity\n    bool is_top_left = (uv_n1p1.x < 0.0) && (uv_n1p1.y > 0.0);\n    bool is_top_right = (uv_n1p1.x > 0.0) && (uv_n1p1.y > 0.0);\n    bool is_bot_left = (uv_n1p1.x < 0.0) && (uv_n1p1.y < 0.0);\n    bool is_bot_right = (uv_n1p1.x > 0.0) && (uv_n1p1.y < 0.0);\n    vec2 warp_uv;\n    \n    // No warping    \n    if (is_top_left) {\n        warp_uv = uv_01_tile;\n    }\n    \n    // Radial shear (the flowing effect)\n    if (is_top_right) {\n        warp_uv = radial_shear(uv_01_tile, center, radial_strength);\n        warp_uv += vec2(iTime * 0.5, 0.0) * ANIMATION;\n        \n        // For nicer uv debug coloring, not needed for the effect (needed for videos!)\n        // -> Introduces a slight glitch at uv boundaries\n        warp_uv = fract(warp_uv);\n    }\n    \n    // Twirl\n    if (is_bot_left) {\n        twirl_strength *= cos(iTime * 0.25 * ANIMATION);\n        warp_uv = twirl(uv_01_tile, center, twirl_strength);\n    }\n    \n    // Spherize\n    if (is_bot_right) {\n        spherize_strength *= cos(iTime * 0.5 * ANIMATION);\n        warp_uv = spherize(uv_01_tile, center, spherize_strength);\n    }\n    \n    // Look up pixel values using distorted uvs\n    fragColor = texture(iChannel0, warp_uv);\n    \n    // Show uv coloring for debug\n    #ifdef SHOW_UV\n        fragColor = vec4(warp_uv, 0, 1);\n    #endif\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec2 radial_shear(vec2 uv, vec2 center, vec2 strength)\n{\n    /*\n    Source:\n    https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Radial-Shear-Node.html\n    */\n    vec2 uv_cen = uv - center;\n    vec2 scaled_dist_sq = strength * dot(uv_cen, uv_cen);\n    return uv + vec2(uv_cen.y, -uv_cen.x) * scaled_dist_sq;\n}\n\nvec2 twirl(vec2 uv, vec2 center, float strength)\n{\n    /*\n    Source:\n    https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Twirl-Node.html\n    */\n\n    vec2 uv_cen = uv - center;\n    float scaled_dist = strength * length(uv_cen);\n    vec2 cs = vec2(cos(scaled_dist), sin(scaled_dist));\n    \n    float x_twirl = dot(cs * vec2(1.0, -1.0), uv_cen);\n    float y_twirl = dot(cs.yx, uv_cen);\n    \n    return vec2(x_twirl + center.x, y_twirl + center.y);\n}\n\nvec2 spherize(vec2 uv, vec2 center, vec2 strength)\n{\n    /*\n    Source:\n    https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Spherize-Node.html\n    */\n    vec2 uv_cen = uv - center;\n    float dist_sq = dot(uv_cen, uv_cen);\n    float dist_to_4th = dist_sq * dist_sq;\n    vec2 sphere_offset = strength * dist_to_4th;\n    return uv + uv_cen * sphere_offset;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[936, 936, 993, 1156, 3284]], "test": "untested"}
{"id": "cdsXWH", "name": "3D Raytracing Template", "author": "Hatchling", "description": "Raytracing Template", "tags": ["raytrace", "template"], "likes": 2, "viewed": 231, "published": 3, "date": "1668814639", "time_retrieved": "2024-07-30T16:18:48.667983", "image_code": "vec3 scene(Ray r, in vec2 fragCoord, inout uint rngState)\n{\n    Sphere background = Sphere(100000., vec3(0));\n    Sphere s = Sphere(0.5, vec3(0));\n    \n    Hit hit = intersectSphere(background, r);\n    swapIfCloser(hit, intersectSphere(s, r));\n   \n    vec3 color = (hit.normal + vec3(1)) * 10.0;\n    color -= floor(color);\n    return (color + hit.normal * 0.5 + 0.5) * 0.5;\n}\n\nRay camTF(Ray r, in vec2 fragCoord, inout uint rngState)\n{\n    r.origin = vec3(0, 0, -1.5);\n    \n    quaternion q = EulerZXY(vec3\n    (\n        (iMouse.yx / iResolution.yx * 2.0 - 1.0) * vec2(-Pi, Pi), \n        0\n    ));\n    \n    r.origin = mul(q, r.origin);\n    r.direction = mul(q, r.direction);\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n    \n    // Using time-varying blue noise as subpixel offsets \n    // will kill persistent moire patterns.\n    // If you modify the shader to accumulate,\n    // it'll converge on a nice image with no aliasing.\n    // (It uses gaussian windowing, not an ideal lowpass filter however.)\n    vec4 blueNoise = sampleBlueNoise(iChannel3, fragCoord, rngState);\n    vec4 gaussCoords = uniform01ToGauss(blueNoise.xy).xyxy * (vec4(1, 1, -1, -1) * 1.0);\n    const int msaaCount = 4;\n    vec2[msaaCount] msaaCoords;\n    msaaCoords[0] = gaussCoords.xy;\n    msaaCoords[1] = gaussCoords.wx;\n    msaaCoords[2] = gaussCoords.zw;\n    msaaCoords[3] = gaussCoords.yz;\n\n\tvec3 color = vec3(0);\n    render\n    (\n        color, \n        \n        // Scene to render\n        scene, \n        \n        // Camera transform function\n        camTF,\n        \n        fragCoord, \n        iResolution.xy, \n        \n        // Zoom\n        2.0,\n        \n        // MSAA coords and count\n        msaaCoords, \n        msaaCount,\n        \n        rngState\n    );\n\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\n// Constants ----------------------------------\n\nconst float Pi = 3.14159265358979;\nconst float Tau = Pi * 2.0;\nconst float InvPi = 1.0 / 3.14159265358979;\n\n// HLSL support -------------------------------\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define half  float\n#define half2 vec2\n#define half3 vec3\n#define half4 vec4\n\n#define fixed  float\n#define fixed2 vec2\n#define fixed3 vec3\n#define fixed4 vec4\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n#define lerp mix\n\n#define decl_saturate(type)            \\\ntype saturate(type x)                  \\\n{                                      \\\n    return clamp(x, type(0), type(1)); \\\n} \n\ndecl_saturate(float)\ndecl_saturate(vec2)\ndecl_saturate(vec3)\ndecl_saturate(vec4)\n\n// Boolean -------------------------------\n\nbool  isinf2(float v) { return isinf(v); } \nbvec2 isinf2(vec2 v)\n{\n    return bvec2\n    (\n        isinf(v.x),\n        isinf(v.y)\n    );\n}\nbvec3 isinf2(vec3 v)\n{\n    return bvec3\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z)\n    );\n}\nbvec4 isinf2(vec4 v)\n{\n    return bvec4\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z),\n        isinf(v.w)\n    );\n}\n\nbool  isnan2(float v) { return isnan(v); } \nbvec2 isnan2(vec2 v)\n{\n    return bvec2\n    (\n        isnan(v.x),\n        isnan(v.y)\n    );\n}\nbvec3 isnan2(vec3 v)\n{\n    return bvec3\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z)\n    );\n}\nbvec4 isnan2(vec4 v)\n{\n    return bvec4\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z),\n        isnan(v.w)\n    );\n}\n\nbool bnot(bool b) { return !b; }\nbvec2 bnot(bvec2 b) \n{ \n    return bvec2(!b.x, !b.y); \n}\nbvec3 bnot(bvec3 b) \n{ \n    return bvec3(!b.x, !b.y, !b.z); \n}\nbvec4 bnot(bvec4 b) \n{ \n    return bvec4(!b.x, !b.y, !b.z, !b.w); \n}\n\nbool band(bool a, bool b) { return a && b; }\nbvec2 band(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x && b.x,\n        a.y && b.y\n    ); \n}\nbvec3 band(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z\n    ); \n}\nbvec4 band(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z,\n        a.w && b.w\n    ); \n}\n\nbool bor(bool a, bool b) { return a || b; }\nbvec2 bor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x || b.x,\n        a.y || b.y\n    ); \n}\nbvec3 bor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z\n    ); \n}\nbvec4 bor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z,\n        a.w || b.w\n    ); \n}\n\nbool bxor(bool a, bool b) { return a != b; }\nbvec2 bxor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x != b.x,\n        a.y != b.y\n    ); \n}\nbvec3 bxor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z\n    ); \n}\nbvec4 bxor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z,\n        a.w != b.w\n    ); \n}\n\n#define decl_isfinite(retType, type) \\\nretType isfinite(type v)             \\\n{                                    \\\n    return band                      \\\n    (                                \\\n        bnot(isinf2(v)),             \\\n        bnot(isnan2(v))              \\\n    );                               \\\n} \ndecl_isfinite(bool, float)\ndecl_isfinite(bvec2, vec2)\ndecl_isfinite(bvec3, vec3)\ndecl_isfinite(bvec4, vec4)\n\nfloat select(bool s, float a, float b)\n{\n    return s ? a : b;\n}\n\nvec2 select(bvec2 s, vec2 a, vec2 b)\n{\n    return vec2\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y\n    );  \n}\n\nvec3 select(bvec3 s, vec3 a, vec3 b)\n{\n    return vec3\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z\n    );  \n}\n\nvec4 select(bvec4 s, vec4 a, vec4 b)\n{\n    return vec4\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z,\n        s.w ? a.w : b.w\n    );  \n}\n\n// Vector math -------------------\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) \\\nretType lengthSqr(type a)             \\\n{                                     \\\n    return dot2(a,a);                 \\\n}                                     \n\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) \\\nretType distSqr(type a, type b)     \\\n{                                   \\\n    type diff = a-b;                \\\n    return lengthSqr(diff);         \\\n}                                   \n\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// Borrowed from UnityEngine\n#define decl_safeNormalize(type)                 \\\ntype safeNormalize(type inVec)                   \\\n{                                                \\\n    float dp3 = max(0.001f, dot2(inVec, inVec)); \\\n    return inVec / sqrt(dp3);                    \\\n}\ndecl_safeNormalize(vec2)\ndecl_safeNormalize(vec3)\ndecl_safeNormalize(vec4)\n\n// Trig Math ----------------------\n\n#define decl_cosToTan(type)\\\ntype cosToTan(type cosine)\\\n{\\\n    return (sqrt(type(1.0)-cosine)*sqrt(cosine+type(1.0))) / cosine;\\\n}\ndecl_cosToTan(float)\ndecl_cosToTan(vec2)\ndecl_cosToTan(vec3)\ndecl_cosToTan(vec4)\n\n#define decl_tanToCos(type)\\\ntype tanToCos(type tangent)\\\n{\\\n    return type(1.0)/sqrt(tangent*tangent+type(1.0));\\\n}\ndecl_tanToCos(float)\ndecl_tanToCos(vec2)\ndecl_tanToCos(vec3)\ndecl_tanToCos(vec4)\n\n// Misc. math --------------------\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type)              \\\nretType floorToInt(type a)                          \\\n{                                                   \\\n    return retType(floor(a) + sign(a) * type(0.5)); \\\n}                                                   \n\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n\n#define decl_invMix(type) \\\ntype invMix(type a, type b, type t) \\\n{                                   \\\n    type result = (t-a)/(b-a);      \\\n    return select(isfinite(result), result, type(0.5)); \\\n}\n\ndecl_invMix(float)\ndecl_invMix(vec2)\ndecl_invMix(vec3)\ndecl_invMix(vec4)\n\n#define invLerp invMix\n\n#define decl_square(type)\\\ntype square(type a)\\\n{\\\n    return a*a;\\\n}\n\ndecl_square(int)\ndecl_square(ivec2)\ndecl_square(ivec3)\ndecl_square(ivec4)\ndecl_square(float)\ndecl_square(vec2)\ndecl_square(vec3)\ndecl_square(vec4)\n\nhalf Pow5 (half x)\n{\n    return x*x * x*x * x;\n}\n\nhalf2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}\n\n// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\n// Color -------------------------------\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\nstruct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nquaternion LookRotation(float3 forward, float3 up)\n{\n    quaternion q;\n    forward = safeNormalize(forward);\n    q = FromToRotation(vec3(0,0,1), forward);\n    up = up - dot(forward, up) * forward;\n    vec3 upFrom = mul(q, vec3(0,1,0));\n    q = mul(FromToRotation(upFrom, up), q);\n    return q;\n}\n\nvoid sincos(vec3 x, out vec3 s, out vec3 c)\n{\n    s = sin(x);\n    c = cos(x);\n}\n        \nquaternion EulerZXY(float3 xyz)\n{\n    vec3 s, c;\n    sincos(vec3(0.5) * xyz, s, c);\n\n    return quaternion\n    (\n        vec4(s.xyz, c.x) * c.yxxy * c.zzyz \n      + s.yxxy * s.zzyz * vec4(c.xyz, s.x) * vec4(1, -1, -1, 1)\n    );\n}\n\nmat4x4 RotationMatrix(quaternion q)\n{\n    float q0 = q.value.x;\n    float q1 = q.value.y;\n    float q2 = q.value.z;\n    float q3 = q.value.w;\n        \n    /*# First row of the rotation matrix\n    r00 = 2 * (q0 * q0 + q1 * q1) - 1\n    r01 = 2 * (q1 * q2 - q0 * q3)\n    r02 = 2 * (q1 * q3 + q0 * q2)\n     \n    # Second row of the rotation matrix\n    r10 = 2 * (q1 * q2 + q0 * q3)\n    r11 = 2 * (q0 * q0 + q2 * q2) - 1\n    r12 = 2 * (q2 * q3 - q0 * q1)\n     \n    # Third row of the rotation matrix\n    r20 = 2 * (q1 * q3 - q0 * q2)\n    r21 = 2 * (q2 * q3 + q0 * q1)\n    r22 = 2 * (q0 * q0 + q3 * q3) - 1*/\n        \n    float r00 = 2. * (q0 * q0 + q1 * q1) - 1.;\n    float r01 = 2. * (q1 * q2 - q0 * q3);\n    float r02 = 2. * (q1 * q3 + q0 * q2);\n                                        \n    float r10 = 2. * (q1 * q2 + q0 * q3);\n    float r11 = 2. * (q0 * q0 + q2 * q2) - 1.;\n    float r12 = 2. * (q2 * q3 - q0 * q1);\n                                         \n    float r20 = 2. * (q1 * q3 - q0 * q2);\n    float r21 = 2. * (q2 * q3 + q0 * q1);\n    float r22 = 2. * (q0 * q0 + q3 * q3) - 1.;\n                             \n    return mat4x4\n    (\n        mul(q, vec3(1,0,0)), 0,\n        mul(q, vec3(0,1,0)), 0,\n        mul(q, vec3(0,0,1)), 0,\n        0,   0,   0,   1\n    );\n}\n\nmat4x4 TRS(vec3 translation, quaternion rotation, vec3 scale)\n{\n    mat4x4 float3x = RotationMatrix(rotation);\n    return mat4x4\n    (\n        vec4(float3x[0] * scale.x), \n        vec4(float3x[1] * scale.y), \n        vec4(float3x[2] * scale.z), \n        vec4(translation, 1)\n    );\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n// PBR Lighting ------------------------------\n// Borrowed from UnityEngine\nstruct MaterialMetallic\n{\n    fixed3 albedo;      // base (diffuse or specular) color\n    half metallic;      // 0=non-metal, 1=metal\n    half smoothness;    // 0=rough, 1=smooth\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specColor;\n    float oneMinusReflectivity;\n    float smoothness;\n};\n\nstruct Light\n{\n    half3 color;\n    half3 dir;\n};\n\nstruct Indirect\n{\n    half3 diffuse;\n    half3 specular;\n};\n\nconst float4 dielectricSpec = float4(0.04, 0.04, 0.04, 1.0 - 0.04);\n\nhalf OneMinusReflectivityFromMetallic(half metallic)\n{\n    half oneMinusDielectricSpec = dielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nhalf3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (dielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}\n\nMaterial toMaterial(MaterialMetallic i)\n{\n    Material o;\n    \n    o.albedo = i.albedo;\n    o.smoothness = i.smoothness;\n    \n    half oneMinusReflectivity;\n    half3 specColor;\n    o.albedo = DiffuseAndSpecularFromMetallic (o.albedo, i.metallic, o.specColor, o.oneMinusReflectivity);\n    \n    return o;\n}\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1.0 - smoothness);\n}\n\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\nhalf DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    half viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return InvPi * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nhalf3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\n\nhalf3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}\n\n\nhalf3 brdf (half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = safeNormalize(float3(light.dir) + viewDir);\n\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl / 3.1415927;\n\n    // Specular term\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    \n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n\n    float specularTerm = V*D; // Torrance-Sparrow model, Fresnel is applied later\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0.0, specularTerm * nl);\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n    surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    //specularTerm *= (specColor != vec3(0)) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1.0-oneMinusReflectivity));\n    half3 color =   albedo * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, vec3(grazingTerm), nv)\n                    ;\n\n    return half3(color);\n}\n\nvec3 lighting(MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect)\n{\n    Material m = toMaterial(mat);\n    \n    return brdf(m.albedo, m.specColor, m.oneMinusReflectivity, m.smoothness,\n    normal, viewDir, light, indirect);\n}\n\n// RAYTRACING -----------------------------\n// Taken from https://www.shadertoy.com/view/MtcXWr\n// Credit: Zavie\n\nstruct Ray\n{\n    vec3 origin;\t\n    vec3 direction;\t\t\n};\n\nstruct Hit\n{\n    float distance;\n    vec3 normal;\t\n};\nconst Hit noHit = Hit(1e10, vec3(0.));\n\nstruct Plane\n{\n    float offset;\n    vec3 normal;\n};\n\nstruct Sphere\n{\n\tfloat radius;\n    vec3 center;\n};\n\nstruct Cone\n{\n    float cosa;\t// cosine of half cone angle\n    float height;\n    float thickness;\n    vec3 origin;\n    vec3 axis;\n};\n\nstruct Capsule\n{\n    vec3 start;\n    vec3 end;\n    float startRadius;\n    float endRadius;\n};\n\nstruct HeightPlane\n{\n    mat4x4 localToWorld;\n    vec2 uvOffset;\n};\n\nvec3 getPoint(in Ray r, float dist)\n{\n    return r.origin + r.direction * dist;\n}\n\nvec3 getPoint(in Ray r, in Hit hit)\n{\n    return r.origin + r.direction * hit.distance;\n}\n\nbool swapIfCloser(inout Hit current, Hit candidate)\n{\n    if (candidate.distance < current.distance && candidate.distance >= 0.0)\n    {\n        current = candidate;\n        return true;\n    }\n    return false;\n}\n\nHit intersectPlane(Plane plane, Ray ray)\n{\n    float dotnd = -dot(plane.normal, ray.direction);\n    float heightAbovePlane = dot(ray.origin, plane.normal) - plane.offset;\n\n    float t = heightAbovePlane / dotnd;\n    //if(!(t >= 0.0))\n    //    return noHit;\n        \n    return Hit(t, plane.normal * sign(dotnd));\n}\n\nHit intersectSphere(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.center - ray.origin;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (ray.origin + t*ray.direction - sphere.center) / sphere.radius);\n}\n\nHit intersectCapsule(Capsule capsule, Ray ray)\n{\n    vec3 rayDirection = ray.direction;\n    vec3 relativeOrigin = ray.origin - capsule.start;\n    vec3 coneDirection = normalize(capsule.end - capsule.start);\n    float coneLength = distance(capsule.end, capsule.start);\n    float changeInRadiusWithLength = (capsule.endRadius - capsule.startRadius) / coneLength;\n    float whatever = 1.0 - square(changeInRadiusWithLength);\n    \n    if(whatever <= 0.0)\n    {\n    \tif(capsule.endRadius < capsule.startRadius)\n    \t{\n    \t\tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \t\treturn intersectSphere(s, ray);    \n        }\n   \t\telse\n        {\n            Sphere s = Sphere(capsule.endRadius, capsule.end);\n            return intersectSphere(s, ray);   \n        } \n    }\n    \n    float sideB = sqrt(whatever);\n    float changeInThicknessWithLength = changeInRadiusWithLength / sideB;\n    \n    float radiusToThickness = changeInThicknessWithLength/changeInRadiusWithLength;\n    float startThickness = capsule.startRadius * radiusToThickness;\n    float endThickness = capsule.endRadius * radiusToThickness;\n    \n    if((coneLength+capsule.endRadius) < capsule.startRadius)\n    {\n    \tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \treturn intersectSphere(s, ray);    \n    }\n    if((coneLength+capsule.startRadius) < capsule.endRadius)\n    {\n    \tSphere s = Sphere(capsule.endRadius, capsule.end);\n    \treturn intersectSphere(s, ray);    \n    }\n    \n    float c = lengthSqr(relativeOrigin)\n            - square(dot(relativeOrigin, coneDirection))\n            - square(dot(relativeOrigin, coneDirection*changeInThicknessWithLength))\n            - square(startThickness) \n            - 2.0*changeInThicknessWithLength*startThickness*dot(relativeOrigin, coneDirection);\n\n    float b = 2.0*dot(relativeOrigin, rayDirection)\n            - 2.0*dot(relativeOrigin, coneDirection)*dot(rayDirection, coneDirection)\n            - 2.0*dot(relativeOrigin, coneDirection*changeInThicknessWithLength)*dot(rayDirection, coneDirection*changeInThicknessWithLength)\n            - 2.0*changeInThicknessWithLength*startThickness*dot(rayDirection, coneDirection);\n\n    float a = 1.0\n            - square(dot(rayDirection, coneDirection))\n            - square(dot(rayDirection, coneDirection*changeInThicknessWithLength));\n        \n    float det = b*b - 4.*a*c;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return noHit;\n    \n    vec3 relativeRayHit = ray.origin + t*ray.direction - capsule.start;\n    float actualDistanceOfPointAlongAxis = dot(relativeRayHit, coneDirection);\n    float distanceOfPointAlongAxis = actualDistanceOfPointAlongAxis;//square(fract(iTime * 0.25 / coneLength)) * coneLength;//dot(relativeRayHit, coneDirection);\n    \n    \n    float thicknessAtPoint = distanceOfPointAlongAxis * changeInThicknessWithLength + startThickness;\n    \n    Hit hit1;\n    \n    if(actualDistanceOfPointAlongAxis < distanceOfPointAlongAxis)\n    {\n    \thit1 = Hit(t*0.25, vec3(1));    \n    }\n    else\n    {\n    \thit1 = Hit(t, vec3(-1));  \n    }\n    \n    float distanceOfSphereAlongAxis = distanceOfPointAlongAxis + (thicknessAtPoint * changeInRadiusWithLength / sideB);\n    \n    distanceOfSphereAlongAxis = clamp(distanceOfSphereAlongAxis, 0.0, coneLength);\n\n    float sphereRadius = distanceOfSphereAlongAxis * changeInRadiusWithLength + capsule.startRadius;\n\n    Sphere s = Sphere(sphereRadius, capsule.start + coneDirection * distanceOfSphereAlongAxis);\n    \n    Hit hit2 = intersectSphere(s, ray);\n    hit2.distance *= 0.5;\n    swapIfCloser(hit1, hit2);\n    \n    return hit2;\n}\n\nHit intersectHeightPlane(HeightPlane plane, Ray ray, sampler2D heightMap, vec2 heightMapSize)\n{\n    Ray origRay = ray;\n    mat4x4 worldToLocal = inverse(plane.localToWorld);\n\n    ray.origin = (worldToLocal * vec4(ray.origin, 1)).xyz; \n    ray.direction = normalize((worldToLocal * vec4(ray.direction, 0)).xyz); \n\n    Plane maxPlane = Plane(-1.0, vec3(0,0,1));\n    Plane minPlane = Plane( 0.0, vec3(0,0,1));\n    \n    Hit maxHit = intersectPlane(maxPlane, ray);\n    Hit minHit = intersectPlane(minPlane, ray);\n    \n    \n    //if(maxHit == noHit || minHit == noHit)\n    //    return noHit;\n    \n    float nearDist = min(minHit.distance, maxHit.distance);\n    float farDist  = max(minHit.distance, maxHit.distance);\n    \n    if(farDist < 0.0)\n        return noHit;\n        \n    if(nearDist < 0.0)\n        nearDist = 0.0;\n        \n    //return maxHit;\n    \n    //vec3 nearHit = ray.origin + ray.direction * nearDist;\n    //vec3 farHit = ray.origin + ray.direction * farDist;\n    \n    vec3 hitPos;\n    \n    \n    bool hit = false;\n    float increment = max(0.00001, 0.0001 / abs(nearDist-farDist));\n    for(float i = 0.0; i <= 1.0; i += increment)\n    {\n        float marchDist = mix(nearDist, farDist, i);\n        hitPos = ray.origin + ray.direction * marchDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r*1.0 - 1.0;\n        \n        if(hitPos.z <= depth)\n        {\n            hitPos.z = depth;\n            farDist = marchDist;\n            hit = true;\n            break;\n        }\n        else\n        {\n            nearDist = marchDist;\n        }\n    }\n    \n    if(!hit) return noHit;\n    \n    farDist = (nearDist + farDist) * 0.5;\n    float stepSize = (farDist - nearDist) * 0.5;\n    for(int i = 0; i < 12; i++, stepSize *= 0.5)\n    {\n        hitPos = ray.origin + ray.direction * farDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r - 1.0;\n        \n        if(hitPos.z > depth)\n        {\n            nearDist = farDist;\n            farDist += stepSize;\n        }\n        else\n        {\n            hitPos.z = depth;\n            farDist -= stepSize;\n        }\n    }\n    \n    ray = origRay;\n    \n    const float sampleSpacing = 0.5;\n    vec4 uvOffset = vec4(-sampleSpacing, -sampleSpacing, sampleSpacing, sampleSpacing) / heightMapSize.xyxy;\n    \n    vec3 p00, p10, p01, p11;\n    p00 = vec3(hitPos.xy + uvOffset.xy, 0);\n    p10 = vec3(hitPos.xy + uvOffset.zy, 0);\n    p01 = vec3(hitPos.xy + uvOffset.xw, 0);\n    p11 = vec3(hitPos.xy + uvOffset.zw, 0);\n    \n    p00.z = textureLod(heightMap, p00.xy + plane.uvOffset, 0.0).r - 1.0;\n    p10.z = textureLod(heightMap, p10.xy + plane.uvOffset, 0.0).r - 1.0;\n    p01.z = textureLod(heightMap, p01.xy + plane.uvOffset, 0.0).r - 1.0;\n    p11.z = textureLod(heightMap, p11.xy + plane.uvOffset, 0.0).r - 1.0;\n    \n    p00 = (plane.localToWorld * vec4(p00, 1)).xyz;\n    p10 = (plane.localToWorld * vec4(p10, 1)).xyz;\n    p01 = (plane.localToWorld * vec4(p01, 1)).xyz;\n    p11 = (plane.localToWorld * vec4(p11, 1)).xyz;\n    \n    Hit outHit;\n    outHit.normal = cross(p11 - p00, p01 - p10);\n    \n    hitPos = (plane.localToWorld * vec4(hitPos, 1)).xyz; \n    outHit.normal = normalize(outHit.normal);\n    outHit.distance = dot(hitPos - ray.origin, ray.direction);\n    \n    return outHit;\n}\n\nvec2[4] getMSAACoords()\n{\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n    return msaa;\n}\n\nRay uvToRay(vec2 uv, float aspect, float zoom, vec2 offset)\n{\n    uv = uv * vec2(2.0) - 1.0;\n    uv.x *= aspect;\n    uv += offset;\n    return Ray(vec3(0), normalize(vec3(uv,zoom)));\n}\n\n#define render(color, scene, camtf, frag, res, zoom, msaa, count, data)\\\n{\\\n    color = vec3(0.);\\\n    vec2 r = res;\\\n    vec2 f = frag;\\\n    vec2 uv = f / r;\\\n    const int c = count;\\\n    vec2[c] m = msaa;\\\n    float weight = 1.0 / float(c);\\\n    for (int i = 0; i < c; ++i)\\\n    {\\\n        Ray r = uvToRay\\\n        (\\\n            uv,\\\n            r.x/r.y,\\\n            zoom,\\\n            m[i] / r.y\\\n        );\\\n        r = camtf(r,f,data);\\\n        color += scene(r,f,data);\\\n    }\\\n    color *= weight;\\\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 375], [377, 377, 435, 435, 695]], "test": "untested"}
{"id": "7dByDm", "name": "Wobbly hex glitched", "author": "JennySchub", "description": "I know this is very inefficient :) feel free to optimize", "tags": ["wobble", "hexagon"], "likes": 6, "viewed": 222, "published": 3, "date": "1668800890", "time_retrieved": "2024-07-30T16:18:49.515717", "image_code": "#define PI 3.14159265359\n\nvec3 colMap(float v) {\n\n\tv=mod(v, PI+1.3)-.8;\t\n    return vec3(\n\t\tsin(sin(v-.6)),\n\t\tsin(sin(v)),\n\t\tsin(sin(v+.6))\n\t);\n\n} \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    fragColor.xyz = colMap(texture(iChannel0, fragCoord/iResolution.xy).r).xzy;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 realuv = (fragCoord/iResolution.xy - .5)*iResolution.xy/iResolution.xx*2.;\n    \n    float a = .1;\n    float sq3 = sqrt(3.);\n    float aM = 1./cos(PI/3.);\n    vec3 col = vec3(1.);\n    vec2 uv;\n    mat2 rot;\n    float tim = iTime * .1;\n    float sinus, cosinus,angle;\n    float count = (sin(iTime*.3)*.5+.53)*50.;\n    for(float i=0.; i<1.; i+=1./count){\n        angle=sin(i*.4*tim+tim)*PI;\n        sinus=sin(angle);\n        cosinus=cos(angle);\n        rot=mat2(cosinus, -sinus, sinus, cosinus);\n        uv=realuv*rot;\n        a=i;\n        col = vec3(\n            min(col.x, \n                (i+\n                    max(\n                        max(\n                            smoothstep(a,a+1./iResolution.y, abs(uv.y)),\n                            smoothstep(a*aM,a*aM+aM/iResolution.y, abs(uv.y+uv.x*sq3))\n                        ),\n                        smoothstep(a*aM,a*aM+aM/iResolution.y, abs(uv.y-uv.x*sq3))\n                    )\n                )\n            )        \n        );\n    }\n    \n    col = vec3(col.x*(sin(iTime)*.5+1.)*2.+iTime);\n    \n    vec3 blurred = vec3(0.);\n    float bs =25.;\n    for(float x=-bs; x<=bs; x+=bs){\n        for(float y=-bs; y<=bs; y+=bs){\n            blurred+=texture(iChannel0, (fragCoord+vec2(x,y))/iResolution.xy).xyz;\n        }\n    }\n    blurred/=9.;\n    float mx=.95;\n    col = col*(1.+mx)-mx*blurred;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dByDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 146], [148, 148, 205, 229, 311]], "test": "untested"}
{"id": "msXXDH", "name": "vonoroi noise neighbours", "author": "jonasfrey", "description": "this aproach looks at the direct neighbours 3x3 kernel and looks who has the least distance\nthis way we can have more cells, but their movement is one cell at max\nthe possible movement corresponds to the kernel size", "tags": ["pixels"], "likes": 10, "viewed": 198, "published": 3, "date": "1668796715", "time_retrieved": "2024-07-30T16:18:50.283663", "image_code": "\nfloat f_n_rand(\n    vec2 o\n){\n    return fract(sin(o.x*331.5543+o.y*173.32112)*11.23*3232.33 + o.x*o.y);\n}\nfloat f_n_dist(\n    vec2 o_pix_coo_nor, \n    vec2 o_pix_coo_nor_ds,\n    float n_ds\n){\n    float n_rand = f_n_rand(o_pix_coo_nor_ds);\n    float n_t = iTime*20.;\n    float n_rand2 = sin(n_rand*n_t);\n    float n_rand3 = cos(n_rand*n_t);\n    vec2 o_half = vec2(1./(iResolution.x/n_ds));\n    vec2 o_rand = vec2(\n        o_half.x*(n_rand2),\n        o_half.x*(n_rand3)\n        );\n    float n_dist = length(o_pix_coo_nor_ds+o_half+o_rand - o_pix_coo_nor);\n    return n_dist;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_coo_nor = ((fragCoord.xy) - (iResolution.xy)*0.5) /(iResolution.y);\n    vec2 o_mou_coo_nor = ((iMouse.xy) - (iResolution.xy)*0.5) /(iResolution.y);\n    \n    float n_new_pixel_size = 1.0;//(99.*o_mou_coo_nor.x);\n    \n    float [] a_n_new_pixel_size = float[] (1.,2.,3.,4.,9.,15.,33.,66., 99.);\n    for(float n_i = 0.0; n_i < float(a_n_new_pixel_size.length()); n_i+=1.){\n        if(o_pix_coo_nor.x > (1./float(a_n_new_pixel_size.length()))*n_i-0.5){\n            n_new_pixel_size = a_n_new_pixel_size[int(n_i)];\n        \n        }\n    }\n    \n    vec2 o_fragCoord_ds = floor(fragCoord / n_new_pixel_size);\n    vec3 o_iRes_ds = (iResolution / n_new_pixel_size);\n    vec2 o_pix_coo_nor_ds = ((o_fragCoord_ds.xy) - (o_iRes_ds.xy * 0.5)) / o_iRes_ds.y; \n    \n    float n_dist = f_n_dist(o_pix_coo_nor, o_pix_coo_nor_ds, n_new_pixel_size);\n    \n    vec2 o_kernel = vec2(3.);\n    float n_dist_min = 1.;\n    for(float n_i_kernel = 0.0; n_i_kernel<(o_kernel.x*o_kernel.y); n_i_kernel+=1.){\n        float n_x_k = mod(n_i_kernel, o_kernel.x);\n        float n_y_k = floor(n_i_kernel / o_kernel.x);\n        n_x_k-=1.;\n        n_y_k-=1.;\n        \n        vec2 o_fragCoord_ds2 = floor((fragCoord) / n_new_pixel_size) + vec2(n_x_k, n_y_k);\n        vec2 o_pix_coo_nor_ds2 = ((o_fragCoord_ds2.xy) - (o_iRes_ds.xy * 0.5)) / o_iRes_ds.y; \n    \n        float n_dist2 = f_n_dist(\n            o_pix_coo_nor,\n            o_pix_coo_nor_ds2,\n            n_new_pixel_size\n        );\n        n_dist_min = min(n_dist_min, n_dist2);\n        fragColor = mix(fragColor, vec4(n_dist2), 0.2);\n\n    }\n    float n_max_dist = sqrt(pow(iResolution.y/n_new_pixel_size, 2.));\n    fragColor = vec4(n_dist_min*n_max_dist);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 107], [108, 108, 193, 193, 576]], "test": "untested"}
{"id": "cslSW8", "name": "Basic Fractal Brownian Motion", "author": "oseday", "description": "looks kinda cool", "tags": ["basic", "fbm"], "likes": 8, "viewed": 229, "published": 3, "date": "1668796090", "time_retrieved": "2024-07-30T16:18:51.038646", "image_code": "vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\n// rotation on all axis\nconst float matm = 0.485;\n\nconst mat3 m1 = mat3( \n 1.6, 1.2, 0.0,\n-1.2, 1.6, 0.0,\n 0.0, 0.0, 1.0\n) * matm;\n\nconst mat3 m2 = m1 + mat3(\n 1.0, 0.0, 0.0, \n 0.0, 1.6, 1.2, \n 0.0,-1.2, 1.6\n) * matm;\n\nconst mat3 m3 = m2 + mat3(\n 1.6, 0.0, 1.2,\n 0.0, 1.0, 0.0, \n-1.2, 0.0, 1.6\n) * matm;\n\n//fbm from: https://www.shadertoy.com/view/4tdSWr\nfloat fbm(vec3 n) {\n\tfloat total = 0.0, amplitude = 0.70;\n\tfor (int i = 0; i < 8; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m3 * n;\n\t\tamplitude *= 0.55;\n\t}\n\treturn total;\n}\n\nfloat ftmod(float x, float d) {\n    return mod(x,d)/d;\n}\nvec3 ftmod(vec3 x, float d) {\n    return mod(x,d)/d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    float ta = iTime*0.025;\n    vec2 targetuv = mat2(cos(ta), sin(ta), -sin(ta), cos(ta)) * (uv - vec2(0.5*iResolution.x/iResolution.y, 0.5));\n    \n    uv += iMouse.xy*0.01;\n    \n    float angle = iTime*0.1;\n    float q = fbm(vec3(uv,0.0) + vec3(cos(angle)*0.1, sin(angle)*0.1, iTime*0.0068));\n    \n    targetuv -= q*3.6;\n\n    vec4 tex = textureLod(iChannel0, targetuv*1.2, 1.0);\n\n    fragColor = vec4(tex.rgb,1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 65], [66, 66, 84, 84, 123], [125, 125, 145, 145, 636], [944, 994, 1013, 1013, 1170], [1172, 1172, 1203, 1203, 1228], [1229, 1229, 1258, 1258, 1283], [1285, 1285, 1342, 1342, 1805]], "test": "untested"}
{"id": "mdfSDH", "name": "bigger pixels #2 simpler", "author": "jonasfrey", "description": "if we divide the frac coord by a num and then take the rounded down floor\nwe will get a 'bigger' pixel\ndrag the mouse on x-axis to change pixel size", "tags": ["pixels"], "likes": 1, "viewed": 143, "published": 3, "date": "1668791221", "time_retrieved": "2024-07-30T16:18:51.910314", "image_code": "\nfloat f_n_rand(\n    vec2 o\n){\n    return fract(sin(o.x*33134.5543+o.y*3121.32112)*12.23*3232.33);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_coo_nor = ((fragCoord.xy) - (iResolution.xy)*0.5) /(iResolution.y);\n    vec2 o_mou_coo_nor = ((iMouse.xy) - (iResolution.xy)*0.5) /(iResolution.y);\n    if(iMouse.z == 0.0){\n    o_mou_coo_nor = vec2(0.35,0.0);\n    }\n    float n_ds = 1./(99.*o_mou_coo_nor.x);\n    vec2 o_fragCoord_ds = floor(fragCoord * n_ds);\n    vec3 o_iRes_ds = floor(iResolution * n_ds);\n    vec2 o_pix_coo_nor_ds = ((o_fragCoord_ds.xy) - (o_iRes_ds.xy * 0.5)) / o_iRes_ds.y; \n\n    float n_dist = length(o_pix_coo_nor_ds);\n    fragColor.gb = (o_pix_coo_nor_ds);\n    fragColor.r = n_dist;\n    fragColor = vec4(n_dist);\n    \n    if(o_pix_coo_nor.x > o_pix_coo_nor.y){\n        fragColor = vec4(length(o_pix_coo_nor));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 100], [101, 101, 158, 158, 865]], "test": "untested"}
{"id": "DdlSWr", "name": "Star Chart", "author": "mla", "description": "The 2000 brightest stars, shown in equirectangular projection. Best viewed full screen.", "tags": ["stars", "chart", "ra", "dec"], "likes": 7, "viewed": 289, "published": 3, "date": "1668786374", "time_retrieved": "2024-07-30T16:18:53.401328", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Star Chart. mla, 2022.\n//\n// The 2000 brightest stars. Equirectangular RA/Declination projection.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nfloat bvfact = 4.0;\nvec3 bvcol(float bv) {\n  // Some attempt to show \"bv\" colour so eg. Betelgeuse comes out as pinkish.\n  vec3 col = vec3(1);\n  if (bv > 0.0) {\n\tif (bv > bvfact) bv = bvfact;\n\tcol.gb *= (bvfact - bv)/bvfact;\n  } else if (bv < 0.0) {\n    if (bv < -bvfact) bv = -bvfact;\n\tcol.rg *= (bvfact + bv)/bvfact;\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n  float px = PI*fwidth(length(p));\n  float ra = PI*(1.0-p.x);\n  float dec = PI*p.y;\n  ra = mod(ra-0.1*iTime,TWOPI);\n  float delta = 0.02; // Search range\n  float rastart = mod(ra-delta,TWOPI); // Start of range\n  int i = 0, j = nstars;\n  while (i != j) {\n    // Binary search\n    int k = i+(j-i)/2;\n    if (RA(stars[k]) < rastart) i = k+1;\n    else j = k;\n  }\n  assert(i == 0 || RA(stars[i-1]) < rastart);\n  assert(i == nstars || RA(stars[i]) >= rastart);\n  vec3 col = abs(dec)<0.5*PI ? vec3(0,0,0.01) : vec3(0);\n  for (int j = 0; j < 60; j++) {\n    assert(j < 59);\n    vec4 star = stars[(i+j)%nstars];\n    float ra1 = RA(star);\n    if (mod(ra1-rastart,TWOPI) > 2.0*delta) break;\n    float dec1 = DEC(star);\n    if (abs(dec-dec1) > delta) continue;\n    float mag = 0.5*exp(-0.4*MAG(star));\n    float bv = BV(star);\n    vec3 starcol = vec3(1);\n    starcol *= bvcol(bv);\n    // Adjust brightness\n    float thresh = 50.0;\n    if (mag/thresh < px) starcol *= pow(mag/(thresh*px),3.0);\n    float d = distance(vec2(ra,dec),vec2(ra1,dec1));\n    col = mix(starcol,col,smoothstep(0.0,max(px,mag/thresh),d));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "#define PI 3.14159265359\n#define TWOPI (2.0*PI)\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Each star encoded as vec4(ra,dec,magnitude,bv)\n// We could halve the encoding size by using fixed point for RA & Dec\n// and half floats for mag & bv.\n\n#define RA(star) ((star).x)\n#define DEC(star) ((star).y)\n#define MAG(star) ((star).z)\n#define BV(star) ((star).w)\n\n// Nvidia doesn't like more than 2047 vectors, so make it a round 2000.\n// Could double this with encoding as above.\nconst vec4 stars[2000] =\n  vec4[](vec4(  0.006959, -1.345052,  4.78,  1.27),   // 9084    The Oct\n         vec4(  0.007956, -0.052840,   5.1, -0.12),   // 9087  29    Psc\n         vec4(  0.008553, -0.104967,  4.41,  1.63),   // 9089  30    Psc\n         vec4(  0.010174, -0.518717,  5.01, -0.15),   // 9091    Zet Scl\n         vec4(  0.016318, -0.302572,  4.55, -0.05),   // 9098   2    Cet\n         vec4(  0.019643, -0.183424,  4.94,  1.63),   // 9103   3    Cet\n         vec4(  0.023279, -0.099615,  4.61,  1.04),   //    3  33    Psc\n         vec4(  0.036602,  0.507726,  2.06, -0.11),   //   15  21Alp And\n         vec4(  0.040047,  1.032357,  2.27,  0.34),   //   21  11Bet Cas\n         vec4(  0.041066, -0.798445,  3.88,  1.03),   //   25    Eps Phe\n         vec4(  0.045037,  0.804112,  5.03,   0.4),   //   27  22    And\n         vec4(  0.049153, -0.269969,  4.89,  0.49),   //   33   6    Cet\n         vec4(  0.057756,  0.265004,  2.83, -0.23),   //   39  88Gam Peg\n         vec4(  0.063094, -0.135796,  5.12,  1.62),   //   46           \n         vec4(  0.063719,  0.352673,   4.8,  1.57),   //   45  89Chi Peg\n         vec4(  0.063879, -0.330439,  4.44,  1.66),   //   48   7    Cet\n         vec4(  0.074576,  0.675123,  4.61,  0.06),   //   63  24The And\n         vec4(  0.079972,  0.642024,  4.52,  0.05),   //   68  25Sig And\n         vec4(  0.084773, -0.154006,  3.56,  1.22),   //   74   8Iot Cet\n         vec4(  0.087580, -1.132277,  4.23,  0.58),   //   77    Zet Tuc\n         vec4(  0.092161,  0.662677,  5.18,  0.42),   //   82  27Rho And\n         vec4(  0.094997, -0.350074,  5.12,  1.82),   //   85           \n         vec4(  0.112362, -1.348340,   2.8,  0.62),   //   98    Bet Hyi\n         vec4(  0.114333, -0.762360,  3.94,  0.17),   //  100    Kap Phe\n         vec4(  0.114684, -0.738381,  2.39,  1.09),   //   99    Alp Phe\n         vec4(  0.121860, -0.576085,  4.81,  1.64),   //  105    Eta Scl\n         vec4(  0.122383,  0.312293,  5.06,  1.65),   //  103  47    Psc\n         vec4(  0.123169,  0.774829,  5.17,  0.03),   //  104           \n         vec4(  0.137081, -0.851784,  4.77,  0.02),   //  125    Lam1Phe\n         vec4(  0.137641, -1.098825,  4.37, -0.07),   //  126    Bet1Tuc\n         vec4(  0.137706, -1.098961,  4.54,  0.15),   //  127    Bet2Tuc\n         vec4(  0.138638,  0.951592,  4.73,  -0.1),   //  123  14Lam Cas\n         vec4(  0.142812, -1.100100,  5.09,  0.04),   //  136    Bet3Tuc\n         vec4(  0.143990,  1.098365,  4.16,  0.14),   //  130  15Kap Cas\n         vec4(  0.157684,  0.945421,  5.08, -0.11),   //  144           \n         vec4(  0.160467,  0.776473,  5.13,   1.6),   //  152           \n         vec4(  0.160925,  0.588515,  4.36, -0.14),   //  154  29Pi  And\n         vec4(  0.161318,  0.940679,  3.66,  -0.2),   //  153  17Zet Cas\n         vec4(  0.168227,  0.511585,  4.37,  0.87),   //  163  30Eps And\n         vec4(  0.171602,  0.538623,  3.27,  1.28),   //  165  31Del And\n         vec4(  0.176751,  0.986761,  2.23,  1.17),   //  168  18Alp Cas\n         vec4(  0.180322, -0.804335,  4.59,  0.97),   //  180    Mu  Phe\n         vec4(  0.183542,  0.881609,   4.8, -0.11),   //  179  19Xi  Cas\n         vec4(  0.189166, -1.002920,  4.36,     0),   //  191    Eta Phe\n         vec4(  0.189666,  0.820736,  4.94,  0.18),   //  184  20Pi  Cas\n         vec4(  0.190197, -0.313927,  2.04,  1.02),   //  188  16Bet Cet\n         vec4(  0.192815, -0.185170,  4.76,  1.01),   //  194  17Phi1Cet\n         vec4(  0.195150,  0.842722,  4.54, -0.07),   //  193  22Omi Cas\n         vec4(  0.206552,  0.423543,  4.06,  1.12),   //  215  34Zet And\n         vec4(  0.212013, -1.307659,  5.07,  1.37),   //  236    Lam Hyi\n         vec4(  0.212421,  0.132383,  4.43,   1.5),   //  224  63Del Psc\n         vec4(  0.213084,  0.889565,  4.89, -0.11),   //  223  25Nu  Cas\n         vec4(  0.213709,  0.295669,  5.07,  0.51),   //  225  64    Psc\n         vec4(  0.214238,  1.009077,  3.44,  0.57),   //  219  24Eta Cas\n         vec4(  0.217351,  0.716962,  4.53, -0.15),   //  226  35Nu  And\n         vec4(  0.231292, -0.019970,  4.77,  1.57),   //  248  20    Cet\n         vec4(  0.231554,  1.066818,  4.82,  0.53),   //  244           \n         vec4(  0.239989,  1.029269,  4.83,  1.21),   //  253  26Ups1Cas\n         vec4(  0.247241,  1.032905,  4.63,  0.96),   //  265  28Ups2Cas\n         vec4(  0.247437,  1.059706,  2.47, -0.15),   //  264  27Gam Cas\n         vec4(  0.247633,  0.671942,  3.87,  0.13),   //  269  37Mu  And\n         vec4(  0.249610,  0.408712,  4.42,  0.94),   //  271  38Eta And\n         vec4(  0.255720, -0.512385,  4.31, -0.16),   //  280    Alp Scl\n         vec4(  0.274643,  0.137706,  4.28,  0.96),   //  294  71Eps Psc\n         vec4(  0.288343, -0.815394,  3.31,  0.89),   //  322    Bet Phe\n         vec4(  0.296771,  0.766932,  5.03,  0.11),   //  324  41    And\n         vec4(  0.297899,  0.958540,  5.17,  0.69),   //  321  30Mu  Cas\n         vec4(  0.298386, -0.964222,  3.92, -0.08),   //  338    Zet Phe\n         vec4(  0.299281, -0.177713,  3.45,  1.16),   //  334  31Eta Cet\n         vec4(  0.299957,  1.505468,  4.25,  1.21),   //  285           \n         vec4(  0.303266,  0.824527,  4.25, -0.07),   //  335  42Phi And\n         vec4(  0.304261,  0.621696,  2.06,  1.58),   //  337  43Bet And\n         vec4(  0.310248,  0.962544,  4.33,  0.17),   //  343  33The Cas\n         vec4(  0.310290,  0.548465,  5.16,  0.23),   //  349  82    Psc\n         vec4(  0.311774,  0.367125,  4.66,  1.03),   //  351  84Chi Psc\n         vec4(  0.312675,  0.525165,  4.51,  1.09),   //  352  83Tau Psc\n         vec4(  0.321788,  0.429065,  4.65,  1.04),   //  360  85Phi Psc\n         vec4(  0.324631, -0.138283,  5.13,  0.46),   //  366  37    Cet\n         vec4(  0.328056, -0.794673,  4.96,  0.58),   //  370    Nu  Phe\n         vec4(  0.330603, -1.202115,  4.86,  0.47),   //  377    Kap Tuc\n         vec4(  0.339467,  0.063084,  5.16,  0.07),   //  378  89    Psc\n         vec4(  0.346738,  0.475850,  4.76,  0.03),   //  383  90Ups Psc\n         vec4(  0.349421,  1.016334,  4.98,  0.68),   //  382  34Phi Cas\n         vec4(  0.359275,  0.794629,  4.88,  1.08),   //  390  46Xi  And\n         vec4(  0.366621, -0.142826,   3.6,  1.06),   //  402  45The Cet\n         vec4(  0.373588, -0.254799,   4.9,  1.23),   //  412  46    Cet\n         vec4(  0.374446,  1.051304,  2.68,  0.13),   //  403  37Del Cas\n         vec4(  0.374954,  1.189093,  4.74,  1.05),   //  399  36Psi Cas\n         vec4(  0.382473,  0.792496,  4.83,  0.42),   //  417  48Ome And\n         vec4(  0.385565, -0.756047,  3.41,  1.57),   //  429    Gam Phe\n         vec4(  0.390961, -0.377505,  5.12,  0.02),   //  433  48    Cet\n         vec4(  0.393505,  0.107231,  4.84,  1.37),   //  434  98Mu  Psc\n         vec4(  0.398160, -0.856482,  3.95,  0.99),   //  440    Del Phe\n         vec4(  0.399171,  0.267835,  3.62,  0.97),   //  437  99Eta Psc\n         vec4(  0.409855,  1.033792,  4.71,     1),   //  442  39Chi Cas\n         vec4(  0.422356,  0.722663,  4.09,  0.54),   //  458  50Ups And\n         vec4(  0.426361, -0.998968,  0.46, -0.16),   //  472    Alp Eri\n         vec4(  0.427576,  0.848725,  3.57,  1.28),   //  464  51    And\n         vec4(  0.433495,  0.774684,  4.98,  0.89),   //  469  52Chi And\n         vec4(  0.438862,  0.708201,  4.94, -0.09),   //  477  53Tau And\n         vec4(  0.442580,  0.095775,  4.44,  1.36),   // 4891 06Nu  PscB\n         vec4(  0.444127,  0.743748,  4.95,  0.62),   //  483           \n         vec4(  0.448222, -0.064408,  4.99,  1.38),   //  500           \n         vec4(  0.452303,  0.884683,  4.07, -0.04),   //  496    Phi Per\n         vec4(  0.454083, -0.278162,   3.5,  0.72),   //  509  52Tau Cet\n         vec4(  0.459866,  0.159833,  4.26,  0.96),   // 5101 10Omi PscB\n         vec4(  0.462971, -0.934134,  5.04,  0.04),   //  520           \n         vec4(  0.478156, -0.186513,  4.67,  0.33),   //  531  53Chi Cet\n         vec4(  0.486337, -0.180380,  3.73,  1.14),   //  539  55Zet Cet\n         vec4(  0.493411,  0.516249,  3.41,  0.49),   //  544   2Alp Tri\n         vec4(  0.495369,  0.336737,  4.75, -0.04),   //  546   5Gam2Ari\n         vec4(  0.495476,  0.055632,  4.62,  0.94),   // 5491 11Xi  PscB\n         vec4(  0.495877, -0.808131,  4.41,  1.59),   //  555    Psi Phe\n         vec4(  0.499018, -0.741712,  5.11, -0.06),   //  558    Phi Phe\n         vec4(  0.499141,  1.111251,  3.38, -0.15),   //  542  45Eps Cas\n         vec4(  0.500212,  0.363169,  2.64,  0.13),   //  553   6Bet Ari\n         vec4(  0.501498, -1.180667,  4.69,  0.95),   //  570    Eta2Hyi\n         vec4(  0.505964, -0.900745,   3.7,  0.85),   //  566    Chi Eri\n         vec4(  0.506145,  1.198784,  4.99,  -0.1),   //  548  46Ome Cas\n         vec4(  0.509069, -0.393169,  4.85,  1.42),   //  565  56    Cet\n         vec4(  0.511237, -0.827024,  4.83,  0.88),   //  574           \n         vec4(  0.512043,  0.310974,   5.1,  0.92),   //  563   8Iot Ari\n         vec4(  0.514559,  0.411830,  4.79,  0.28),   //  569   9Lam Ari\n         vec4(  0.518232, -1.074594,  2.86,  0.28),   //  591    Alp Hyi\n         vec4(  0.523620, -0.367877,     4,  1.57),   //  585  59Ups Cet\n         vec4(  0.531044, -0.780400,  5.14,  1.49),   //  602    Chi Phe\n         vec4(  0.532136,  1.237560,  4.54,  0.16),   //  575  48    Cas\n         vec4(  0.532529,  0.048234,  4.33,  0.03),   // 5961 13Alp PscB\n         vec4(  0.533641,  0.950986,  5.04, -0.08),   //  590   4    Per\n         vec4(  0.538587,  1.263992,  3.98, -0.01),   //  580  50    Cas\n         vec4(  0.540616,  0.738793,  2.26,  1.37),   //  603  57Gam1And\n         vec4(  0.540666,  0.738812,  4.84,  0.03),   //  604  57Gam2And\n         vec4(  0.543189, -0.511328,  4.69, -0.17),   //  612    Nu  For\n         vec4(  0.552245,  0.395288,  5.03,  0.11),   //  613  12Kap Ari\n         vec4(  0.554900,  0.409498,     2,  1.15),   //  617  13Alp Ari\n         vec4(  0.560636,  0.660767,  4.82,  0.12),   //  620  58    And\n         vec4(  0.564709,  0.452734,  4.98,  0.33),   //  623  14    Ari\n         vec4(  0.565241,  0.610642,     3,  0.14),   //  622   4Bet Tri\n         vec4(  0.577579,  0.528888,  4.94,  0.78),   //  642   6    Tri\n         vec4(  0.580323,  0.154404,  4.37,  0.89),   //  649  65Xi 1Cet\n         vec4(  0.581289,  0.771988,  4.83,  1.48),   //  643  60    And\n         vec4(  0.595638, -0.899058,  3.56, -0.12),   //  674    Phi Eri\n         vec4(  0.598007,  0.597324,  4.87,  0.61),   //  660   8Del Tri\n         vec4(  0.599149,  0.590745,  4.01,  0.02),   //  664   9Gam Tri\n         vec4(  0.606283,  0.499906,  5.03,  0.04),   //  675  10    Tri\n         vec4(  0.608008, -0.051967,  3.04,  1.42),   //  681  68Omi Cet\n         vec4(  0.618493, -1.198333,  4.09,  0.03),   //  705    Del Hyi\n         vec4(  0.621148,  0.974689,  5.17,  0.37),   //  685   9    Per\n         vec4(  0.623394, -1.285362,  5.01,  1.09),   //  715    Kap Hyi\n         vec4(  0.635403,  0.877527,  4.71,  1.53),   //  699  65    And\n         vec4(  0.636827, -0.214511,  4.89, -0.03),   //  708  72Rho Cet\n         vec4(  0.641343, -0.832590,  4.25, -0.14),   //  721    Kap Eri\n         vec4(  0.645896, -0.590115,  5.14,   0.1),   //  724    Phi For\n         vec4(  0.646464,  0.147655,  4.28, -0.06),   //  718  73Xi 2Cet\n         vec4(  0.650425,  1.176396,  4.52,  0.12),   //  707    Iot Cas\n         vec4(  0.662402,  1.557954,  2.02,   0.6),   //  424   1Alp UMi\n         vec4(  0.663604, -0.266071,  4.75,  0.45),   //  740  76Sig Cet\n         vec4(  0.663677,  0.630888,  5.15,  1.47),   //  736  14    Tri\n         vec4(  0.671275, -0.492750,   4.9, -0.05),   //  749    Ome For\n         vec4(  0.680134,  0.097622,  4.86,  0.87),   //  754  78Nu  Cet\n         vec4(  0.689551,  1.270920,  5.16,  0.88),   //  743           \n         vec4(  0.695879,  0.005735,  4.07, -0.22),   //  779  82Del Cet\n         vec4(  0.696227, -0.207209,  4.84,  0.45),   //  781  83Eps Cet\n         vec4(  0.696342, -1.191483,  4.11, -0.06),   //  806    Eps Hyi\n         vec4(  0.697258, -0.748601,  4.75,  0.06),   //  789           \n         vec4(  0.701041, -0.695611,  4.11,  1.02),   //  794    Iot Eri\n         vec4(  0.707942,  0.701516,  4.91,  0.59),   //  788  12    Per\n         vec4(  0.712532,  0.056476,  3.47,  0.09),   //  804  86Gam Cet\n         vec4(  0.713191,  0.483582,  4.66, -0.13),   //  801  35    Ari\n         vec4(  0.716123, -0.241878,  4.25, -0.14),   //  811  89Pi  Cet\n         vec4(  0.716459,  0.859196,  4.12,  0.49),   //  799  13The Per\n         vec4(  0.719694,  0.176526,  4.27,  0.31),   //  813  87Mu  Cet\n         vec4(  0.719773,  0.217221,  5.18,  0.24),   //  812  38    Ari\n         vec4(  0.720399, -0.324151,  4.47,  0.48),   //  818   1Tau1Eri\n         vec4(  0.722320, -1.180134,  4.84,  0.06),   //  837    Zet Hyi\n         vec4(  0.732638,  0.510460,  4.51,  1.11),   //  824  39    Ari\n         vec4(  0.737795, -0.565588,  4.46,  0.99),   //  841    Bet For\n         vec4(  0.741693,  0.475787,  3.63,  -0.1),   //  838  41    Ari\n         vec4(  0.743838, -1.310165,  4.75,  1.33),   //  872    Nu  Hyi\n         vec4(  0.744317,  0.668786,  4.23,  0.34),   //  840  16    Per\n         vec4(  0.744804,  0.975562,  3.76,  1.68),   //  834  15Eta Per\n         vec4(  0.746296, -0.366592,  4.75,  0.91),   //  850   2Tau2Eri\n         vec4(  0.748369,  0.611908,  4.53,  1.56),   //  843  17    Per\n         vec4(  0.758703, -0.870750,     4,  2.11),   //  868           \n         vec4(  0.760347,  0.920879,  3.95,  0.74),   //  854  18Tau Per\n         vec4(  0.769813, -0.155300,  3.89,  1.11),   //  874   3Eta Eri\n         vec4(  0.770664, -0.064790,  5.17,  0.08),   //  875           \n         vec4(  0.773567,  0.557356,  5.11, -0.01),   //  873  21    Per\n         vec4(  0.777814, -0.703450,  3.24,  0.14),   //  897    The1Eri\n         vec4(  0.777856, -0.703445,  4.35,  0.08),   //  898    The2Eri\n         vec4(  0.779995,  0.692246,   4.7,  0.06),   //  879  22Pi  Per\n         vec4(  0.780146, -1.118257,  4.99,  0.13),   //  909    Bet Hor\n         vec4(  0.781304,  0.614060,  4.93,  1.23),   //  882  24    Per\n         vec4(  0.781958,  0.372458,  4.63,  0.04),   //  887  48Eps Ari\n         vec4(  0.781958,  0.372458,  4.63,  0.04),   //  888  48Eps Ari\n         vec4(  0.784155,  0.155465,   4.7, -0.12),   //  896  91Lam Cet\n         vec4(  0.795347,  0.071379,  2.53,  1.64),   //  911  92Alp Cet\n         vec4(  0.795834, -0.412324,  4.09,  0.16),   //  919  11Tau3Eri\n         vec4(  0.801164, -1.042621,  5.11,  0.34),   //  934    Mu  Hor\n         vec4(  0.806326,  0.933863,  2.93,   0.7),   //  915  23Gam Per\n         vec4(  0.807986,  0.677891,  3.39,  1.65),   //  921  25Rho Per\n         vec4(  0.809570,  0.989703,  4.76,  1.02),   //  918           \n         vec4(  0.821040,  0.714809,  2.12, -0.05),   //  936  26Bet Per\n         vec4(  0.824959,  0.865916,  4.05,  0.59),   //  937    Iot Per\n         vec4(  0.826836,  0.782906,   3.8,  0.98),   //  941  27Kap Per\n         vec4(  0.834661,  0.691354,  4.63,  1.11),   //  947  28Ome Per\n         vec4(  0.836143,  0.344295,  4.35,  1.03),   //  951  57Del Ari\n         vec4(  0.837488,  1.298413,  4.87,  0.02),   //  932           \n         vec4(  0.838070, -0.505918,  3.87,  0.52),   //  963    Alp For\n         vec4(  0.841133, -0.020876,  5.06,  0.57),   //  962  94    Cet\n         vec4(  0.850419,  0.367295,  4.89, -0.01),   //  972  58Zet Ari\n         vec4(  0.854484, -0.153933,   4.8,  0.23),   //  984  13Zet Eri\n         vec4(  0.856100,  0.889032,  5.03,  1.15),   //  969           \n         vec4(  0.865545, -0.392898,  4.88,   0.9),   //  994  15    Eri\n         vec4(  0.866687,  0.876543,  5.15, -0.06),   //  987  29    Per\n         vec4(  0.867124,  0.597300,  4.82,  1.49),   //  991           \n         vec4(  0.868855,  0.874323,  5.03, -0.06),   //  989  31    Per\n         vec4(  0.869878,  0.058822,  4.83,  0.68),   //  996  96Kap1Cet\n         vec4(  0.870556, -0.379745,  3.69,  1.62),   // 1003  16Tau4Eri\n         vec4(  0.872352, -0.751708,  4.27,  0.71),   // 1008           \n         vec4(  0.872622,  1.145847,  4.84, -0.15),   //  985           \n         vec4(  0.874148,  0.506989,  4.47,  1.55),   //  999           \n         vec4(  0.878955,  0.756241,  4.95,  0.04),   // 1002  32    Per\n         vec4(  0.884678,  0.362015,  5.09,  1.24),   // 1015  63Tau2Ari\n         vec4(  0.891529,  0.870241,  1.79,  0.48),   // 1017  33Alp Per\n         vec4(  0.893668,  0.157584,   3.6,  0.89),   // 1030   1Omi Tau\n         vec4(  0.903949,  0.169869,  3.74, -0.09),   // 1038   2Xi  Tau\n         vec4(  0.907797,  0.856307,  4.98, -0.09),   // 1034           \n         vec4(  0.912232,  1.046155,  4.21,  0.41),   // 1035           \n         vec4(  0.913541,  0.864093,  4.67, -0.09),   // 1044  34    Per\n         vec4(  0.913586, -1.098467,  4.72,   0.4),   // 1083    Kap Ret\n         vec4(  0.915926,  1.027626,  4.54,  0.56),   // 1040           \n         vec4(  0.916314,  0.967819,  5.09,  0.05),   // 1046           \n         vec4(  0.918081,  0.197857,  5.14, -0.03),   // 1061   4    Tau\n         vec4(  0.918806,  0.837676,  4.36,  1.35),   // 1052  35Sig Per\n         vec4(  0.918997, -0.088580,  4.73, -0.09),   // 1070  17    Eri\n         vec4(  0.920110,  0.225788,  4.11,  1.12),   // 1066   5    Tau\n         vec4(  0.929081, -0.165079,  3.73,  0.88),   // 1084  18Eps Eri\n         vec4(  0.932828, -0.377563,  4.27, -0.11),   // 1088  19Tau5Eri\n         vec4(  0.944617,  0.841123,  4.23, -0.06),   // 1087  37Psi Per\n         vec4(  0.946290,  0.007010,  4.28,  0.58),   // 1101  10    Tau\n         vec4(  0.947256, -0.702926,  4.58,  1.04),   // 1106           \n         vec4(  0.969333,  1.103339,   5.1,  1.63),   // 1105           \n         vec4(  0.969742, -0.557429,     5, -0.16),   // 1134    Del For\n         vec4(  0.970294,  0.592801,  4.97, -0.01),   // 1123  40    Per\n         vec4(  0.972302, -0.651245,  4.59,   1.2),   // 1143           \n         vec4(  0.972695,  0.834049,  3.01, -0.13),   // 1122  39Del Per\n         vec4(  0.974106, -0.170402,  3.54,  0.92),   // 1136  23Del Eri\n         vec4(  0.978258, -1.131094,  3.85,  1.13),   // 1175    Bet Ret\n         vec4(  0.978774,  0.563538,  3.83,  0.05),   // 1131  38Omi Per\n         vec4(  0.981203,  0.420857,   3.7, -0.11),   // 1142  17    Tau\n         vec4(  0.982591,  0.743137,  3.77,  0.42),   // 1135  41Nu  Per\n         vec4(  0.982656,  0.427034,   4.3, -0.11),   // 1145  19    Tau\n         vec4(  0.985355,  0.425298,  3.87, -0.07),   // 1149  20    Tau\n         vec4(  0.986279,  1.105579,   4.8,   0.8),   // 1129           \n         vec4(  0.986730, -0.211214,  4.42,  1.63),   // 1162  26Pi  Eri\n         vec4(  0.987536,  0.417977,  4.18, -0.06),   // 1156  23    Tau\n         vec4(  0.989814, -0.405784,  4.23,  0.42),   // 1173  27Tau6Eri\n         vec4(  0.991515, -1.295713,  3.24,  1.62),   // 1208    Gam Hyi\n         vec4(  0.992591,  0.420712,  2.87, -0.09),   // 1165  25Eta Tau\n         vec4(  0.996024,  0.194488,  5.07, -0.13),   // 1174  30    Tau\n         vec4(  0.997448, -0.656603,  4.73, -0.03),   // 1190           \n         vec4(  0.999906,  0.419810,  3.63, -0.09),   // 1178  27    Tau\n         vec4(  1.000016,  0.421264,  5.09, -0.08),   // 1180  28    Tau\n         vec4(  1.001186, -0.631814,  4.17,  0.95),   // 1195           \n         vec4(  1.001469,  1.143646,  4.47,  1.88),   // 1155           \n         vec4(  1.001571,  0.577554,  5.11,  0.07),   // 1177  42    Per\n         vec4(  1.005129,  1.244982,  4.63,  0.03),   // 1148    Gam Cam\n         vec4(  1.019483, -0.606192,  5.11, -0.13),   // 1214           \n         vec4(  1.019753, -0.429569,  4.65, -0.13),   // 1213  33Tau8Eri\n         vec4(  1.021591,  0.556474,  2.85,  0.12),   // 1203  44Zet Per\n         vec4(  1.022290, -0.051570,  4.79,  0.94),   // 1212  32    Eri\n         vec4(  1.034712,  1.066551,     5,  1.45),   // 1205           \n         vec4(  1.035961,  1.100818,  5.03, -0.09),   // 1204           \n         vec4(  1.037830,  0.698311,  2.89, -0.18),   // 1220  45Eps Per\n         vec4(  1.038603, -0.235770,  2.95,  1.59),   // 1231  34Gam Eri\n         vec4(  1.041721, -1.071637,  4.56,  1.62),   // 1247    Del Ret\n         vec4(  1.042682,  0.624673,  4.04,  0.01),   // 1228  46Xi  Per\n         vec4(  1.046870, -0.419165,  4.66, -0.13),   // 1240  36Tau9Eri\n         vec4(  1.050164,  0.217997,  3.47, -0.12),   // 1239  35Lam Tau\n         vec4(  1.051109, -1.084887,  4.51,  1.65),   // 1264    Gam Ret\n         vec4(  1.052884, -1.066028,  4.97,  1.42),   // 1266    Iot Ret\n         vec4(  1.060971,  0.104531,  3.91,  0.03),   // 1251  38Nu  Tau\n         vec4(  1.066628,  1.032459,  5.06,   0.5),   // 1242           \n         vec4(  1.067683,  0.385403,  4.36,  1.07),   // 1256  37    Tau\n         vec4(  1.075922,  0.878798,  4.29,  0.02),   // 1261  47Lam Per\n         vec4(  1.084991,  0.832740,  4.04, -0.03),   // 1273  48    Per\n         vec4(  1.091033,  1.408456,   5.1,  0.56),   // 1230           \n         vec4(  1.094510, -0.732927,  4.93,  0.33),   // 1302    Del Hor\n         vec4(  1.098968, -0.119337,  4.04,  0.33),   // 1298  38Omi1Eri\n         vec4(  1.108021,  0.161680,  4.84,   0.8),   // 1311  47    Tau\n         vec4(  1.108291, -0.738177,  3.86,   1.1),   // 1326    Alp Hor\n         vec4(  1.110009, -0.179008,  4.87,  1.17),   // 1318  39    Eri\n         vec4(  1.110139, -1.090375,  3.35,  0.91),   // 1336    Alp Ret\n         vec4(  1.112160,  0.706572,  4.71,  1.01),   // 1306  52    Per\n         vec4(  1.112205,  0.844904,  4.14,  0.95),   // 1303  51Mu  Per\n         vec4(  1.113833, -0.133566,  4.43,  0.82),   // 1325  40Omi2Eri\n         vec4(  1.114983,  0.155199,  4.29, -0.06),   // 1320  49Mu  Tau\n         vec4(  1.117127, -0.898612,  4.25,   0.3),   // 1338    Gam Dor\n         vec4(  1.119111, -1.035014,  4.44,  1.08),   // 1355    Eps Ret\n         vec4(  1.122509,  0.359165,  4.94,  0.26),   // 1329  50Ome2Tau\n         vec4(  1.125279, -0.589892,  3.56, -0.12),   // 1347  41Ups4Eri\n         vec4(  1.126800,  0.877823,  4.61,  0.04),   // 1324           \n         vec4(  1.133562,  0.272751,  3.65,  0.99),   // 1346  54Gam Tau\n         vec4(  1.136013,  0.477362,  4.95,  1.15),   // 1348  52Phi Tau\n         vec4(  1.136254,  0.603302,  4.93,  0.94),   // 1343  54    Per\n         vec4(  1.141241,  0.811559,  4.85, -0.03),   // 1350  53    Per\n         vec4(  1.147270,  0.306174,  3.76,  0.98),   // 1373  61Del1Tau\n         vec4(  1.150522, -0.065372,  5.17,  0.08),   // 1383  42Xi  Eri\n         vec4(  1.151328,  0.165123,  5.12,  0.07),   // 1381  66    Tau\n         vec4(  1.152077, -0.593708,  3.96,  1.49),   // 1393  43    Eri\n         vec4(  1.152339,  0.304453,   4.8,  0.15),   // 1380  64Del2Tau\n         vec4(  1.157889,  0.389102,  4.22,  0.13),   // 1387  65Kap1Tau\n         vec4(  1.158418,  0.312904,  4.29,  0.05),   // 1389  68Del3Tau\n         vec4(  1.161989,  0.398173,  4.28,  0.26),   // 1392  69Ups Tau\n         vec4(  1.162156,  0.272591,  4.49,  0.25),   // 1394  71    Tau\n         vec4(  1.163290,  0.256801,  4.69,  0.98),   // 1396  73Pi  Tau\n         vec4(  1.171291,  0.285531,  4.97,  1.13),   // 1407  75    Tau\n         vec4(  1.171880,  0.278593,  3.84,  0.95),   // 1411  77The1Tau\n         vec4(  1.172060,  0.334759,  3.53,  1.01),   // 1409  74Eps Tau\n         vec4(  1.172257,  0.276998,   3.4,  0.18),   // 1412  78The2Tau\n         vec4(  1.173021,  0.227722,  5.03,  0.23),   // 1414  79    Tau\n         vec4(  1.180548,  0.282637,  4.78,  0.17),   // 1427           \n         vec4(  1.181741, -0.784593,  5.07, -0.19),   // 1443    Del Cae\n         vec4(  1.186294, -0.000766,  4.91,  1.32),   // 1437  45    Eri\n         vec4(  1.193412, -0.519526,  4.51,  0.98),   // 1453  50Ups1Eri\n         vec4(  1.194889,  0.259084,  4.65,  0.25),   // 1444  86Rho Tau\n         vec4(  1.195536, -0.960716,  3.27,  -0.1),   // 1465    Alp Dor\n         vec4(  1.196394, -0.143665,  5.11,   1.7),   // 1451  47    Eri\n         vec4(  1.202314, -0.533411,  3.82,  0.98),   // 1464  52Ups2Eri\n         vec4(  1.202772,  0.177340,  4.25,  0.18),   // 1458  88    Tau\n         vec4(  1.203929,  0.288139,  0.85,  1.54),   // 1457  87Alp Tau\n         vec4(  1.205667, -0.058512,  3.93, -0.21),   // 1463  48Nu  Eri\n         vec4(  1.207288,  0.720205,  4.25,  1.22),   // 1454  58    Per\n         vec4(  1.213694,  0.218355,  4.27,  0.12),   // 1473  90    Tau\n         vec4(  1.213788, -0.249650,  3.87,  1.09),   // 1481  53    Eri\n         vec4(  1.216901, -0.211587,  5.01,  0.07),   // 1483           \n         vec4(  1.218037,  0.275757,  5.07,  0.15),   // 1478  91Sig1Tau\n         vec4(  1.218566,  0.277823,  4.69,  0.15),   // 1479  92Sig2Tau\n         vec4(  1.221344,  0.926416,  5.05,  1.07),   // 1467   3    Cam\n         vec4(  1.223658, -0.343335,  4.32,  1.61),   // 1496  54    Eri\n         vec4(  1.224182, -0.730663,  4.45,  0.34),   // 1502    Alp Cae\n         vec4(  1.230711, -0.648293,  5.05,  0.37),   // 1503    Bet Cae\n         vec4(  1.231525,  0.400674,  4.28, -0.13),   // 1497  94Tau Tau\n         vec4(  1.245736, -0.056806,  4.02, -0.15),   // 1520  57Mu  Eri\n         vec4(  1.264666,  0.121499,  3.19,  0.45),   // 1543   1Pi 3Ori\n         vec4(  1.264970,  0.654295,  4.88,  1.44),   // 1533           \n         vec4(  1.266208, -0.283044,  5.03,  0.98),   // 1549  60    Eri\n         vec4(  1.268033,  0.155339,  4.36,  0.01),   // 1544   2Pi 2Ori\n         vec4(  1.270628,  0.097826,  3.69, -0.17),   // 1552   3Pi 4Ori\n         vec4(  1.271363,  0.328815,   5.1,  0.21),   // 1547  97    Tau\n         vec4(  1.276419,  0.248719,  4.74,  1.84),   // 1556   4Omi1Ori\n         vec4(  1.276853,  0.640589,  4.78,  1.41),   // 1551   2    Aur\n         vec4(  1.277995, -0.095169,  4.39,  0.25),   // 1560  61Ome Eri\n         vec4(  1.283034,  1.157900,  4.29,  0.03),   // 1542   9Alp Cam\n         vec4(  1.283914,  0.042596,  3.72, -0.18),   // 1567   8Pi 5Ori\n         vec4(  1.286728,  0.177165,  4.65,  0.09),   // 1570   7Pi 1Ori\n         vec4(  1.293166,  0.235871,  4.07,  1.15),   // 1580   9Omi2Ori\n         vec4(  1.295878,  0.578858,  2.69,  1.53),   // 1577   3Iot Aur\n         vec4(  1.297158,  0.938153,  4.47, -0.02),   // 1568   7    Cam\n         vec4(  1.302664,  0.029918,  4.47,   1.4),   // 1601  10Pi 6Ori\n         vec4(  1.305753,  0.661310,  4.94,  0.04),   // 1592   4Ome Aur\n         vec4(  1.308691, -0.218821,  4.79,  0.26),   // 1611  64    Eri\n         vec4(  1.310502,  1.417101,  5.07,  1.28),   // 1523           \n         vec4(  1.315223, -0.349972,  4.91, -0.05),   // 1621           \n         vec4(  1.315272, -0.125208,  4.81, -0.19),   // 1617  65Psi Eri\n         vec4(  1.317587,  0.764861,  2.99,  0.54),   // 1605   7Eps Aur\n         vec4(  1.318437, -0.458585,  5.02,  1.07),   // 1628           \n         vec4(  1.319812,  0.716908,  3.75,  1.22),   // 1612   8Zet Aur\n         vec4(  1.322501,  0.376817,  4.64,  0.16),   // 1620 102Iot Tau\n         vec4(  1.323912,  1.054916,  4.03,  0.92),   // 1603  10Bet Cam\n         vec4(  1.328224, -0.619301,  4.55,   1.2),   // 1652    Gam1Cae\n         vec4(  1.328930,  0.268853,  4.68, -0.06),   // 1638  11    Ori\n         vec4(  1.330669, -0.865296,  5.03,  1.49),   // 1663    Eta2Pic\n         vec4(  1.332829, -0.390450,  3.19,  1.46),   // 1654   2Eps Lep\n         vec4(  1.333038, -1.003089,  4.72,  0.52),   // 1674    Zet Dor\n         vec4(  1.335795,  1.029264,  5.08, -0.08),   // 1622  11    Cam\n         vec4(  1.337423,  0.719677,  3.17, -0.18),   // 1641  10Eta Aur\n         vec4(  1.338130,  0.900551,     5,  0.33),   // 1637   9    Aur\n         vec4(  1.338499, -0.081245,  5.12, -0.06),   // 1657  66    Eri\n         vec4(  1.341505,  0.325417,     5,  0.65),   // 1656 104    Tau\n         vec4(  1.343248, -0.088774,  2.79,  0.13),   // 1666  67Bet Eri\n         vec4(  1.347073, -0.077774,  5.12,  0.44),   // 1673  68    Eri\n         vec4(  1.348906, -0.152789,  4.27, -0.19),   // 1679  69Lam Eri\n         vec4(  1.351322,  0.272223,  4.82,  0.32),   // 1676  15    Ori\n         vec4(  1.362658, -0.207156,  4.45,  -0.1),   // 1696   3Iot Lep\n         vec4(  1.365423, -0.282840,  3.31, -0.11),   // 1702   5Mu  Lep\n         vec4(  1.366732, -0.225870,  4.36,  -0.1),   // 1705   4Kap Lep\n         vec4(  1.366993,  0.049936,  4.46,  1.19),   // 1698  17Rho Ori\n         vec4(  1.367590,  0.671680,  4.86,  0.18),   // 1689  11Mu  Aur\n         vec4(  1.369022, -1.172604,  4.83,  1.28),   // 1744    The Dor\n         vec4(  1.372434, -0.143146,  0.12, -0.03),   // 1713  19Bet Ori\n         vec4(  1.376214, -0.470250,  5.07,  -0.1),   // 1723           \n         vec4(  1.376222,  0.570509,  5.02,  0.23),   // 1706  14    Aur\n         vec4(  1.381822,  0.802818,  0.08,   0.8),   // 1708  13Alp Aur\n         vec4(  1.385291, -0.609038,  4.83,     1),   // 1743    Omi Col\n         vec4(  1.385819, -0.119458,   3.6, -0.11),   // 1735  20Tau Ori\n         vec4(  1.388314,  0.582446,  4.54,  1.27),   // 1726  16    Aur\n         vec4(  1.392519,  0.699863,  4.71,  0.63),   // 1729  15Lam Aur\n         vec4(  1.393108,  0.385655,  4.94,  0.93),   // 1739 109    Tau\n         vec4(  1.394409, -0.229976,  4.29, -0.26),   // 1756   6Lam Lep\n         vec4(  1.396328,  0.592680,  5.03,  0.27),   // 1740  19    Aur\n         vec4(  1.398221, -0.370698,  4.71, -0.05),   // 1762           \n         vec4(  1.403949, -0.006676,  4.73, -0.17),   // 1765  22    Ori\n         vec4(  1.403986, -0.432371,  5.06,  0.67),   // 1771           \n         vec4(  1.407426,  1.382844,  5.05,  0.47),   // 1686           \n         vec4(  1.408627,  0.061862,     5, -0.15),   // 1770  23    Ori\n         vec4(  1.413484, -0.136276,  4.14,  0.96),   // 1784  29    Ori\n         vec4(  1.415565,  0.303396,  4.99,  0.53),   // 1780 111    Tau\n         vec4(  1.415795, -0.041834,  3.36, -0.17),   // 1788  28Eta Ori\n         vec4(  1.415819, -0.015558,  5.08,  0.96),   // 1787  27    Ori\n         vec4(  1.416568,  0.652501,  4.99,  1.42),   // 1773  21Sig Aur\n         vec4(  1.416973,  0.032226,  4.95,  -0.2),   // 1789  25Psi1Ori\n         vec4(  1.418654,  0.110824,  1.64, -0.22),   // 1790  24Gam Ori\n         vec4(  1.423715,  0.499295,  1.65, -0.13),   // 1791 112Bet Tau\n         vec4(  1.423846, -1.028217,  5.14,     1),   // 1836    Lam Dor\n         vec4(  1.426095,  0.054028,  4.59, -0.21),   // 1811  30Psi2Ori\n         vec4(  1.429577,  0.382872,  4.88, -0.15),   // 1810 114    Tau\n         vec4(  1.429637,  0.601717,  5.07,   1.4),   // 1805  24Phi Aur\n         vec4(  1.432239, -0.362321,  2.84,  0.82),   // 1829   9Bet Lep\n         vec4(  1.438734, -0.019063,  4.71,  1.57),   // 1834  31    Ori\n         vec4(  1.443321,  0.103813,   4.2, -0.14),   // 1839  32    Ori\n         vec4(  1.445182, -0.619078,  3.87,  1.14),   // 1862    Eps Col\n         vec4(  1.448319, -0.127433,  4.62, -0.26),   // 1855  36Ups Ori\n         vec4(  1.448651, -0.005222,  2.23, -0.22),   // 1852  34Del Ori\n         vec4(  1.449554,  0.324534,  4.38,  2.07),   // 1845 119    Tau\n         vec4(  1.451801,  0.561855,  4.76,  0.34),   // 1843  25Chi Aur\n         vec4(  1.451808, -0.311056,  2.58,  0.21),   // 1865  11Alp Lep\n         vec4(  1.455715, -1.090651,  3.76,  0.82),   // 1922    Bet Dor\n         vec4(  1.460927,  0.165622,  4.41, -0.16),   // 1876  37Phi1Ori\n         vec4(  1.461909, -0.104754,  4.78, -0.25),   // 1887           \n         vec4(  1.462317,  0.173384,  3.54, -0.18),   // 1879  39Lam Ori\n         vec4(  1.462914, -0.094068,  5.13,  0.02),   // 1895  41The1Ori\n         vec4(  1.463377, -0.094529,  5.08, -0.09),   // 1897  43The2Ori\n         vec4(  1.463401, -0.084445,  4.59, -0.19),   // 1892  42    Ori\n         vec4(  1.463605, -0.103149,  2.77, -0.24),   // 1899  44Iot Ori\n         vec4(  1.467009, -0.020978,   1.7, -0.19),   // 1903  46Eps Ori\n         vec4(  1.470025,  0.162151,  4.09,  0.95),   // 1907  40Phi2Ori\n         vec4(  1.473255,  0.369006,     3, -0.19),   // 1910 123Zet Tau\n         vec4(  1.478062, -0.045379,  3.81, -0.24),   // 1931  48Sig Ori\n         vec4(  1.478664, -0.125892,   4.8,  0.13),   // 1937  49    Ori\n         vec4(  1.479973,  0.071932,  4.57, -0.11),   // 1934  47Ome Ori\n         vec4(  1.481997, -0.594706,  2.64, -0.12),   // 1956    Alp Col\n         vec4(  1.486840, -0.033908,  2.05, -0.21),   // 1948  50Zet Ori\n         vec4(  1.487209, -0.019703,  4.95, -0.21),   // 1952           \n         vec4(  1.489180,  0.288571,  4.86, -0.13),   // 1946 126    Tau\n         vec4(  1.494335,  0.025739,  4.91,  1.17),   // 1963  51    Ori\n         vec4(  1.503006, -0.391797,   3.6,  0.47),   // 1983  13Gam Lep\n         vec4(  1.504357, -1.147302,  4.35,  0.21),   // 2015    Del Dor\n         vec4(  1.509703, -0.563853,  5.17, -0.28),   // 1996    Mu  Col\n         vec4(  1.513876, -0.258692,  3.55,   0.1),   // 1998  14Zet Lep\n         vec4(  1.515316, -0.891277,  3.85,  0.17),   // 2020    Bet Pic\n         vec4(  1.517374, -0.168768,  2.06, -0.17),   // 2004  53Kap Ori\n         vec4(  1.522871,  0.428784,  4.86,  1.01),   // 2002 132    Tau\n         vec4(  1.523563,  0.683839,  4.52,  0.94),   // 1995  29Tau Aur\n         vec4(  1.525194,  0.220804,  4.91, -0.07),   // 2010 134    Tau\n         vec4(  1.526414, -0.980293,  4.51,   1.1),   // 2042    Gam Pic\n         vec4(  1.526699, -1.167645,  5.11, -0.14),   // 2064    Eps Dor\n         vec4(  1.531032, -0.909472,  5.17,  0.99),   // 2049           \n         vec4(  1.531351, -0.624275,  3.12,  1.16),   // 2040    Bet Col\n         vec4(  1.531702,  0.651105,  4.74,  1.62),   // 2011  31Ups Aur\n         vec4(  1.532930, -0.364410,  3.81,  0.99),   // 2035  15Del Lep\n         vec4(  1.533665,  0.683272,  3.97,  1.13),   // 2012  32Nu  Aur\n         vec4(  1.537810,  0.032376,  4.78,  1.38),   // 2037  56    Ori\n         vec4(  1.540755, -0.589946,  4.87, -0.15),   // 2056    Lam Col\n         vec4(  1.541679,  0.481924,  4.58, -0.02),   // 2034 136    Tau\n         vec4(  1.545059, -1.101128,  4.65,  1.05),   // 2102           \n         vec4(  1.546281,  0.353885,  4.41,  0.59),   // 2047  54Chi1Ori\n         vec4(  1.548310,  0.972270,  4.99,  0.05),   // 2029  30Xi  Aur\n         vec4(  1.549729,  0.129275,   0.5,  1.85),   // 2061  58Alp Ori\n         vec4(  1.551154, -0.647881,  4.97,  1.11),   // 2087    Xi  Col\n         vec4(  1.555109, -0.247274,  3.71,  0.33),   // 2085  16Eta Lep\n         vec4(  1.560047, -0.615810,  4.36, -0.18),   // 2106    Gam Col\n         vec4(  1.562047,  0.452981,  4.82, -0.06),   // 2084 139    Tau\n         vec4(  1.566746, -0.166824,  5.03,  0.19),   // 2108   2    Mon\n         vec4(  1.567073, -0.747268,  3.96,  1.14),   // 2120    Eta Col\n         vec4(  1.568731,  0.947447,  3.72,     1),   // 2077  33Del Aur\n         vec4(  1.568739,  0.784482,   1.9,  0.03),   // 2088  34Bet Aur\n         vec4(  1.569582,  0.649481,  2.62, -0.08),   // 2095  37The Aur\n         vec4(  1.570514,  0.801751,  4.26,  1.72),   // 2091  35Pi  Aur\n         vec4(  1.571042, -0.053654,  4.53,  1.22),   // 2113           \n         vec4(  1.578826, -0.184971,  4.95, -0.12),   // 2128   3    Mon\n         vec4(  1.581195,  0.168381,  4.12,  0.16),   // 2124  61Mu  Ori\n         vec4(  1.585015, -0.458750,  5.04,  1.34),   // 2140           \n         vec4(  1.585871,  0.343665,  5.14, -0.11),   // 2130  64    Ori\n         vec4(  1.587900,  0.351480,  4.63,  0.28),   // 2135  62Chi2Ori\n         vec4(  1.588774,  0.406022,  4.16,  0.82),   // 2134   1    Gem\n         vec4(  1.592547, -0.287708,  4.93,  0.24),   // 2148  17    Lep\n         vec4(  1.597652, -0.260670,  4.67,  0.05),   // 2155  18The Lep\n         vec4(  1.601587, -1.084805,  5.05,  1.25),   // 2196           \n         vec4(  1.603637, -0.650189,  5.02, -0.11),   // 2177    The Col\n         vec4(  1.603833,  0.257756,  4.42, -0.17),   // 2159  67Nu  Ori\n         vec4(  1.608917, -1.201543,  5.06, -0.08),   // 2221    Nu  Dor\n         vec4(  1.615478, -1.304687,  5.09,  0.72),   // 2261    Alp Men\n         vec4(  1.615732, -0.959383,  4.81, -0.23),   // 2212    Del Pic\n         vec4(  1.619884, -1.144752,  5.01,  1.62),   // 2245    Eta2Dor\n         vec4(  1.622559, -0.114324,  5.05,  -0.2),   // 2205           \n         vec4(  1.622894,  0.247992,  4.48, -0.18),   // 2199  70Xi  Ori\n         vec4(  1.623397,  0.281531,  4.95, -0.14),   // 2198  69    Ori\n         vec4(  1.635613, -0.109515,  3.98,  1.32),   // 2227   5Gam Mon\n         vec4(  1.635707,  0.392816,  3.28,   1.6),   // 2216   7Eta Gem\n         vec4(  1.637898,  0.514838,  4.35,  1.02),   // 2219  44Kap Aur\n         vec4(  1.639511, -0.239430,  5.01, -0.08),   // 2244           \n         vec4(  1.642545,  0.214191,  5.04,  0.42),   // 2241  74    Ori\n         vec4(  1.643016, -0.613319,  4.37,     1),   // 2256    Kap Col\n         vec4(  1.648006, -0.293492,  5.14,   1.3),   // 2260           \n         vec4(  1.648959,  1.073644,  4.98,  1.83),   // 2215   1    Lyn\n         vec4(  1.653030,  1.209857,   4.8,  0.03),   // 2209           \n         vec4(  1.656421,  1.029933,  4.48,  0.01),   // 2238   2    Lyn\n         vec4(  1.658033, -0.051390,   4.9,   1.6),   // 2275           \n         vec4(  1.659431, -0.524704,  3.02, -0.19),   // 2282   1Zet CMa\n         vec4(  1.667285, -0.583575,  3.85,  0.88),   // 2296    Del Col\n         vec4(  1.669843, -0.313388,  1.98, -0.23),   // 2294   2Bet CMa\n         vec4(  1.670979,  0.392937,  2.88,  1.64),   // 2286  13Mu  Gem\n         vec4(  1.674506,  0.080159,  4.44,  0.18),   // 2298   8Eps Mon\n         vec4(  1.675304, -0.919716, -0.72,  0.15),   // 2326    Alp Car\n         vec4(  1.679435,  0.860239,  4.91,  1.97),   // 2289  46Psi1Aur\n         vec4(  1.692795, -0.083116,  5.06, -0.17),   // 2344  10    Mon\n         vec4(  1.693703, -0.568628,  4.48, -0.17),   // 2361    Lam CMa\n         vec4(  1.696533, -0.122745,   4.6,  -0.1),   // 2356  11Bet Mon\n         vec4(  1.697172,  0.352770,  4.15, -0.13),   // 2343  18Nu  Gem\n         vec4(  1.707733, -0.216275,  5.15,  1.27),   // 2379           \n         vec4(  1.709791, -0.408727,  4.33, -0.24),   // 2387   4Xi 1CMa\n         vec4(  1.714365,  0.127986,   4.5,     0),   // 2385  13    Mon\n         vec4(  1.717543, -0.021298,   5.1, -0.14),   // 2395           \n         vec4(  1.723410, -0.924598,  4.39, -0.02),   // 2435           \n         vec4(  1.723760, -0.400810,  4.54, -0.05),   // 2414   5Xi 2CMa\n         vec4(  1.730858, -0.336078,  3.95,  1.06),   // 2429   7Nu 2CMa\n         vec4(  1.735345,  0.286220,  1.93,     0),   // 2421  24Gam Gem\n         vec4(  1.735562, -0.753914,  3.17, -0.11),   // 2451    Nu  Pup\n         vec4(  1.736123, -0.318304,  4.43,  1.15),   // 2443   8Nu 3CMa\n         vec4(  1.739338, -0.841603,  4.93,  0.87),   // 2462           \n         vec4(  1.742181, -0.246891,  4.82,   1.5),   // 2450           \n         vec4(  1.742414,  0.741571,  4.79,  1.23),   // 2427  50Psi2Aur\n         vec4(  1.749598,  0.172710,  4.66, -0.25),   // 2456  15    Mon\n         vec4(  1.758784,  0.777098,  5.02,  1.48),   // 2459  55Psi4Aur\n         vec4(  1.762483,  0.438621,  2.98,   1.4),   // 2473  27Eps Gem\n         vec4(  1.762732,  0.230868,  4.49,  1.16),   // 2478  30    Gem\n         vec4(  1.767793, -0.291751, -1.46,     0),   // 2491   9Alp CMa\n         vec4(  1.768410,  0.225070,  3.36,  0.43),   // 2484  31Xi  Gem\n         vec4(  1.772534,  1.037453,  4.87,  0.08),   // 2470  12    Lyn\n         vec4(  1.777311,  0.140276,  4.77,   1.4),   // 2503  17    Mon\n         vec4(  1.778571, -0.157050,  5.07,   1.8),   // 2508           \n         vec4(  1.779626,  0.042101,  4.47,  1.11),   // 2506  18    Mon\n         vec4(  1.781066, -1.081081,  3.27,  0.21),   // 2550    Alp Pic\n         vec4(  1.788270, -0.567382,  3.96, -0.23),   // 2538  13Kap CMa\n         vec4(  1.788331, -0.935884,   4.4,  0.92),   // 2554           \n         vec4(  1.788569, -0.813580,  5.14,  0.45),   // 2548           \n         vec4(  1.788687, -0.883394,  2.93,   1.2),   // 2553    Tau Pup\n         vec4(  1.792300,  0.729223,  5.02,  1.27),   // 2516  58Psi7Aur\n         vec4(  1.792773, -0.599821,  4.99,  1.38),   // 2549           \n         vec4(  1.793114,  1.179353,  5.14, -0.17),   // 2490  42    Cam\n         vec4(  1.801130,  0.592733,   3.6,   0.1),   // 2540  34The Gem\n         vec4(  1.804444, -0.352978,  4.83, -0.21),   // 2571  15    CMa\n         vec4(  1.805122,  1.202328,  5.12, -0.13),   // 2511  43    Cam\n         vec4(  1.806989, -0.422089,  3.87,  1.73),   // 2580  16Omi1CMa\n         vec4(  1.807246, -0.210113,  4.07,  1.43),   // 2574  14The CMa\n         vec4(  1.809230,  0.229996,  4.65,   0.3),   // 2564  38    Gem\n         vec4(  1.813500, -0.351446,  4.68,  0.37),   // 2590  19Pi  CMa\n         vec4(  1.815623, -0.245107,     5,  1.18),   // 2593  18Mu  CMa\n         vec4(  1.815739, -0.297651,  4.37, -0.07),   // 2596  20Iot CMa\n         vec4(  1.816307, -0.850344,  4.95,  1.69),   // 2608           \n         vec4(  1.820705,  1.019665,  4.35,  0.85),   // 2560  15    Lyn\n         vec4(  1.822205,  0.787042,   4.9,  0.03),   // 2585  16    Lyn\n         vec4(  1.825695, -0.595361,  5.06, -0.16),   // 2619           \n         vec4(  1.826595, -0.505661,   1.5, -0.21),   // 2618  21Eps CMa\n         vec4(  1.831905, -1.185360,  5.17,   1.4),   // 2662           \n         vec4(  1.832886,  1.343511,  4.55,  1.36),   // 2527           \n         vec4(  1.836342, -0.897143,  5.14,  1.61),   // 2652           \n         vec4(  1.840094, -0.487553,  3.47,  1.73),   // 2646  22Sig CMa\n         vec4(  1.843125,  0.422636,  5.18,  0.94),   // 2630  42Ome Gem\n         vec4(  1.845309, -0.073987,  4.99,  -0.2),   // 2648  19    Mon\n         vec4(  1.845796, -0.415970,  3.02, -0.08),   // 2653  24Omi2CMa\n         vec4(  1.848450,  0.191143,  5.13,  1.39),   // 2649           \n         vec4(  1.848995, -0.272853,  4.12, -0.12),   // 2657  23Gam CMa\n         vec4(  1.849592, -0.865402,  4.93,  0.13),   // 2672           \n         vec4(  1.850521,  0.359019,  3.79,  0.79),   // 2650  43Zet Gem\n         vec4(  1.851380, -0.990470,  5.17, -0.04),   // 2683           \n         vec4(  1.869211, -0.460651,  1.84,  0.68),   // 2693  25Del CMa\n         vec4(  1.870769, -1.230438,  3.78,  1.04),   // 2736    Gam2Vol\n         vec4(  1.871219, -0.692125,  4.83, -0.18),   // 2702           \n         vec4(  1.877225, -0.073953,  4.92,  1.03),   // 2701  20    Mon\n         vec4(  1.879683, -0.854028,  5.14,  1.24),   // 2719           \n         vec4(  1.881204,  0.527880,  4.41,  1.26),   // 2697  46Tau Gem\n         vec4(  1.883450,  0.686273,   4.9,  1.45),   // 2696  63    Aur\n         vec4(  1.884367, -0.008601,  4.15, -0.01),   // 2714  22Del Mon\n         vec4(  1.887398, -0.816106,  4.49,  0.32),   // 2740           \n         vec4(  1.890294, -0.788593,  4.89, -0.02),   // 2746           \n         vec4(  1.890940,  0.282026,     5,  1.66),   // 2717  51    Gem\n         vec4(  1.891676, -0.779110,   5.1,  1.56),   // 2748           \n         vec4(  1.894789, -0.459938,  4.66, -0.19),   // 2745  27    CMa\n         vec4(  1.896459, -0.842500,  4.76,  -0.1),   // 2762           \n         vec4(  1.897224, -0.467273,  3.85, -0.17),   // 2749  28Ome CMa\n         vec4(  1.904955, -0.486617,  4.64,   1.6),   // 2766           \n         vec4(  1.905085, -0.406933,  4.79,  1.71),   // 2764           \n         vec4(  1.906010, -0.638665,  5.03, -0.17),   // 2770           \n         vec4(  1.906031, -1.186077,  3.98,  0.79),   // 2803    Del Vol\n         vec4(  1.907397, -0.647474,   2.7,  1.62),   // 2773    Pi  Pup\n         vec4(  1.911544,  0.288682,  3.58,  0.11),   // 2763  54Lam Gem\n         vec4(  1.912473, -0.641132,  4.66,  -0.1),   // 2787           \n         vec4(  1.913455,  0.863327,  5.05,  0.08),   // 2751           \n         vec4(  1.913913, -0.641282,  5.11, -0.16),   // 2790           \n         vec4(  1.914065, -0.428634,  4.98, -0.15),   // 2781  29    CMa\n         vec4(  1.914219, -0.435532,   4.4, -0.15),   // 2782  30Tau CMa\n         vec4(  1.920401,  0.383662,  3.53,  0.34),   // 2777  55Del Gem\n         vec4(  1.928357,  0.356808,   5.1,  1.52),   // 2795  56    Gem\n         vec4(  1.928778,  0.641593,  5.13,  1.08),   // 2793  65    Aur\n         vec4(  1.929572, -0.331904,  4.96, -0.04),   // 2812           \n         vec4(  1.935025,  0.437215,  5.03,   0.9),   // 2808  57    Gem\n         vec4(  1.937729, -0.511435,  2.45, -0.08),   // 2827  31Eta CMa\n         vec4(  1.944507,  0.161899,  4.99,  1.01),   // 2828   2Eps CMi\n         vec4(  1.944850,  0.485168,  3.79,  1.03),   // 2821  60Iot Gem\n         vec4(  1.947636, -0.890438,   5.1,  1.06),   // 2862           \n         vec4(  1.949154,  0.858901,  4.64, -0.02),   // 2818  21    Lyn\n         vec4(  1.951060,  0.144678,   2.9, -0.09),   // 2845   3Bet CMi\n         vec4(  1.955482,  0.155780,  4.32,  1.43),   // 2854   4Gam CMi\n         vec4(  1.959618,  0.554743,  4.18,  0.32),   // 2852  62Rho Gem\n         vec4(  1.960137, -0.755752,  3.25,  1.51),   // 2878    Sig Pup\n         vec4(  1.960616,  0.490753,  5.05,  0.11),   // 2857  64    Gem\n         vec4(  1.962608,  0.209556,  4.54,  1.28),   // 2864   6    CMi\n         vec4(  1.962673,  0.487228,  5.01,  1.11),   // 2861  65    Gem\n         vec4(  1.962870, -0.401852,  4.85,  0.23),   // 2874           \n         vec4(  1.966587, -0.540393,  4.65,  0.93),   // 2881           \n         vec4(  1.968179,  1.438350,  4.96,  1.66),   // 2742           \n         vec4(  1.980070, -0.253490,  4.97,  1.41),   // 2902           \n         vec4(  1.981183, -0.389141,  4.45,  0.51),   // 2906           \n         vec4(  1.983568,  0.556556,  1.98,  0.03),   // 2891  66Alp Gem\n         vec4(  1.983568,  0.556561,  2.88,  0.04),   // 2890  66Alp Gem\n         vec4(  1.986971, -0.495140,  4.64, -0.11),   // 2922           \n         vec4(  1.988199, -0.916889,  4.94,   1.4),   // 2934           \n         vec4(  1.989333,  0.469421,  4.06,  1.54),   // 2905  69Ups Gem\n         vec4(  1.995254, -0.071752,  5.13,  0.44),   // 2927  25    Mon\n         vec4(  1.995647, -0.610317,  4.53, -0.09),   // 2937           \n         vec4(  1.999710, -0.442698,   4.7, -0.11),   // 2944           \n         vec4(  2.001988, -0.467777,   4.5, -0.17),   // 2948           \n         vec4(  2.003485,  0.603608,   4.9,   0.4),   // 2930  71Omi Gem\n         vec4(  2.004082,  0.091193,  0.38,  0.42),   // 2943  10Alp CMi\n         vec4(  2.004758, -0.668607,  4.84, -0.19),   // 2961           \n         vec4(  2.004844,  0.308482,  5.05,  1.56),   // 2938  74    Gem\n         vec4(  2.008816, -0.266400,  4.94,  1.56),   // 2959           \n         vec4(  2.009347,  1.518785,  5.07,  1.63),   // 2609           \n         vec4(  2.012567, -0.166698,  3.93,  1.02),   // 2970  26Alp Mon\n         vec4(  2.015070, -1.267216,  3.95,  1.04),   // 3024    Zet Vol\n         vec4(  2.020015, -0.788423,  5.06,  0.78),   // 2998           \n         vec4(  2.020248,  1.024688,  4.99,  0.08),   // 2946  24    Lyn\n         vec4(  2.021578,  0.504114,  4.28,  1.12),   // 2973  75Sig Gem\n         vec4(  2.022576, -0.495867,  4.59,  1.63),   // 2993   1    Pup\n         vec4(  2.023267, -0.714431,  5.17,   1.1),   // 3002           \n         vec4(  2.023746, -0.505355,  3.96,  0.18),   // 2996   3    Pup\n         vec4(  2.026531,  0.425826,  3.57,  0.93),   // 2985  77Kap Gem\n         vec4(  2.030058, -0.662677,  3.61,  1.73),   // 3017           \n         vec4(  2.030320,  0.489148,  1.14,     1),   // 2990  78Bet Gem\n         vec4(  2.033084, -0.254188,  5.04,  0.33),   // 3015   4    Pup\n         vec4(  2.033846,  0.323060,  4.88,  1.45),   // 3003  81    Gem\n         vec4(  2.039490, -0.672146,  5.08,  -0.1),   // 3035           \n         vec4(  2.039875,  0.583212,  5.14,   1.6),   // 3013  80Pi  Gem\n         vec4(  2.042412, -0.452690,   4.5, -0.05),   // 3034    Omi Pup\n         vec4(  2.043512, -0.821662,  4.71,  1.06),   // 3046           \n         vec4(  2.047439, -0.809367,  4.11, -0.18),   // 3055           \n         vec4(  2.047685, -0.433884,  3.34,  1.24),   // 3045   7Xi  Pup\n         vec4(  2.058181,  0.030839,  5.14, -0.12),   // 3059  13Zet CMi\n         vec4(  2.058492, -0.242567,  5.17,   0.6),   // 3064   9    Pup\n         vec4(  2.060435, -0.708182,  3.73,  1.04),   // 3080           \n         vec4(  2.060631, -0.605721,  5.01,  0.44),   // 3079           \n         vec4(  2.062304, -0.678288,  4.49, -0.19),   // 3084           \n         vec4(  2.064121, -0.865911,  4.63, -0.23),   // 3089           \n         vec4(  2.065176, -0.839557,  4.24, -0.14),   // 3090           \n         vec4(  2.066019,  0.467152,  4.97,  0.09),   // 3067  83Phi Gem\n         vec4(  2.080339, -0.924714,  3.47, -0.18),   // 3117    Chi Car\n         vec4(  2.080687, -0.399331,   4.2,  0.72),   // 3102  11    Pup\n         vec4(  2.082643, -0.769860,  5.09, -0.17),   // 3116           \n         vec4(  2.084222, -0.529441,  4.79,  0.15),   // 3113           \n         vec4(  2.085072, -0.795482,  5.17,  1.27),   // 3121           \n         vec4(  2.086717, -0.859487,  4.41, -0.17),   // 3129           \n         vec4(  2.090447, -0.406846,  5.11,  1.12),   // 3123  12    Pup\n         vec4(  2.092767, -1.057442,  5.17,  1.74),   // 3153           \n         vec4(  2.093238, -0.064223,  4.93,  1.21),   // 3122  27    Mon\n         vec4(  2.093814, -0.321126,  4.61,  0.08),   // 3131           \n         vec4(  2.095851, -1.109462,  4.82, -0.17),   // 3159           \n         vec4(  2.099725, -0.024304,  4.68,  1.49),   // 3141  28    Mon\n         vec4(  2.104278,  0.040744,  4.39,  1.25),   // 3145           \n         vec4(  2.109747,  0.485100,  4.94,  1.12),   // 3149    Chi Gem\n         vec4(  2.110038, -0.698190,  2.25, -0.26),   // 3165    Zet Pup\n         vec4(  2.116538,  0.228953,  5.12,  0.01),   // 3163   8    Cnc\n         vec4(  2.123513, -0.790048,  5.05,   1.5),   // 3187           \n         vec4(  2.127309, -0.424188,  2.81,  0.43),   // 3185  15Rho Pup\n         vec4(  2.128997, -1.197596,  4.35, -0.11),   // 3223    Eps Vol\n         vec4(  2.131293,  0.898961,  4.84,  0.05),   // 3173  27    Lyn\n         vec4(  2.131890, -0.052079,  4.34,  0.97),   // 3188  29Zet Mon\n         vec4(  2.133715, -1.069931,  4.76,  0.43),   // 3220           \n         vec4(  2.133780, -0.335889,   4.4, -0.15),   // 3192  16    Pup\n         vec4(  2.135796, -0.826341,  4.27, -0.23),   // 3206    Gam1Vel\n         vec4(  2.135992, -0.826181,  1.78, -0.22),   // 3207    Gam2Vel\n         vec4(  2.143577, -0.225618,  4.72,  0.95),   // 3211  19    Pup\n         vec4(  2.143956, -0.691475,  4.45,  1.62),   // 3225           \n         vec4(  2.144276, -0.750269,  4.75,  0.18),   // 3226           \n         vec4(  2.152572, -0.275558,  4.99,  1.07),   // 3229  20    Pup\n         vec4(  2.153271, -0.626568,  4.78, -0.11),   // 3237           \n         vec4(  2.153750, -0.820164,  5.13, -0.14),   // 3244           \n         vec4(  2.155366, -0.633947,  5.08, -0.19),   // 3240           \n         vec4(  2.155693, -0.704207,  4.44,  1.17),   // 3243           \n         vec4(  2.161002, -1.098088,  5.16,  0.09),   // 3260           \n         vec4(  2.166456,  0.160318,  3.52,  1.48),   // 3249  17Bet Cnc\n         vec4(  2.174309, -1.145169,  5.07,  1.15),   // 3280           \n         vec4(  2.175234, -1.342502,  4.07,  0.39),   // 3318    Alp Cha\n         vec4(  2.175357, -0.639828,  4.45,  0.22),   // 3270           \n         vec4(  2.181946,  0.475040,  5.14,  0.47),   // 3262  18Chi Cnc\n         vec4(  2.184462, -1.352359,  4.35,  1.16),   // 3340    The Cha\n         vec4(  2.187698, -0.576909,  4.83,  1.45),   // 3282           \n         vec4(  2.192628, -1.038641,  1.86,  1.28),   // 3307    Eps Car\n         vec4(  2.192685, -0.846315,  4.82, -0.15),   // 3294           \n         vec4(  2.194031,  0.753774,  4.25,  1.55),   // 3275  31    Lyn\n         vec4(  2.205733, -0.902825,  5.17, -0.16),   // 3330           \n         vec4(  2.206359, -0.068179,   3.9, -0.02),   // 3314           \n         vec4(  2.206692, -1.154307,  3.77,  1.13),   // 3347    Bet Vol\n         vec4(  2.207464,  0.132024,  5.13,  0.94),   // 3306           \n         vec4(  2.214860, -0.926571,  5.09,  0.25),   // 3350           \n         vec4(  2.222939, -0.780599,  4.99, -0.16),   // 3359           \n         vec4(  2.226452,  1.059730,  3.36,  0.84),   // 3323   1Omi UMa\n         vec4(  2.245919, -0.871690,  5.01,  1.33),   // 3407           \n         vec4(  2.248538, -1.012451,  4.86,     1),   // 3414           \n         vec4(  2.258653, -0.750303,  4.14,  0.11),   // 3426           \n         vec4(  2.258703,  0.099547,  4.16,     0),   // 3410   4Del Hya\n         vec4(  2.263502,  0.058318,  4.44,  1.21),   // 3418   5Sig Hya\n         vec4(  2.265146, -0.395525,  5.05,  0.73),   // 3430           \n         vec4(  2.267657, -0.515939,  4.89,   0.9),   // 3433    Zet Pyx\n         vec4(  2.269036, -0.217735,  4.98,  1.42),   // 3431   6    Hya\n         vec4(  2.269379, -0.616247,  3.97,  0.94),   // 3438    Bet Pyx\n         vec4(  2.269859,  1.122732,   4.6,  1.17),   // 3403   4Pi 2UMa\n         vec4(  2.270209, -0.923662,  3.62, -0.18),   // 3447           \n         vec4(  2.271618, -1.043028,  4.33, -0.11),   // 3457           \n         vec4(  2.271662, -0.814177,  3.84,  0.71),   // 3445           \n         vec4(  2.274243, -0.825836,  4.77,  0.12),   // 3452           \n         vec4(  2.276440, -0.278264,  4.88,  1.06),   // 3441   9    Hya\n         vec4(  2.279508, -0.927012,  4.86, -0.17),   // 3467           \n         vec4(  2.283001,  0.059317,   4.3,  -0.2),   // 3454   7Eta Hya\n         vec4(  2.283262,  0.374698,  4.66,  0.02),   // 3449  43Gam Cnc\n         vec4(  2.284600, -0.579212,  3.68, -0.18),   // 3468    Alp Pyx\n         vec4(  2.284949, -0.869572,  5.16,  -0.2),   // 3476           \n         vec4(  2.284956, -0.126250,  4.62,  0.84),   // 3459           \n         vec4(  2.288127, -0.744368,  4.07,  0.87),   // 3477           \n         vec4(  2.289370,  0.316850,  3.94,  1.08),   // 3461  47Del Cnc\n         vec4(  2.289451, -0.954841,  1.96,  0.04),   // 3485    Del Vel\n         vec4(  2.295232, -0.803579,  3.91,     0),   // 3487           \n         vec4(  2.296745, -0.236453,  4.32,   0.9),   // 3484  12    Hya\n         vec4(  2.298148,  0.501957,  4.02,  1.01),   // 3475  48Iot Cnc\n         vec4(  2.298198, -0.990819,  4.49, -0.17),   // 3498           \n         vec4(  2.298496,  0.112031,  3.38,  0.68),   // 3482  11Eps Hya\n         vec4(  2.305725,  0.101888,  4.36, -0.04),   // 3492  13Rho Hya\n         vec4(  2.311668, -0.790775,  4.93,  0.05),   // 3520           \n         vec4(  2.314880, -0.483631,  4.01,  1.27),   // 3518    Gam Pyx\n         vec4(  2.314998, -0.812087,   5.1, -0.21),   // 3527           \n         vec4(  2.321056,  0.763174,  5.15,  0.98),   // 3508  35    Lyn\n         vec4(  2.334581, -1.058450,  3.84,  -0.1),   // 3571           \n         vec4(  2.336094,  0.103770,  3.11,     1),   // 3547  16Zet Hya\n         vec4(  2.336669, -0.483141,  4.89,  0.11),   // 3556    Del Pyx\n         vec4(  2.340152, -0.920201,  4.69, -0.12),   // 3574           \n         vec4(  2.342989, -1.033749,  4.92, -0.19),   // 3582           \n         vec4(  2.349592,  0.206957,  4.25,  0.14),   // 3572  65Alp Cnc\n         vec4(  2.351270, -0.824401,  5.18,  0.25),   // 3588           \n         vec4(  2.352734,  0.838485,  3.14,  0.19),   // 3569   9Iot UMa\n         vec4(  2.353585, -1.031204,  5.16,  0.42),   // 3598           \n         vec4(  2.356587, -0.720016,  4.45,  0.65),   // 3591           \n         vec4(  2.358988,  0.729247,  3.97,  0.44),   // 3579           \n         vec4(  2.366871, -1.158831,     4,  0.14),   // 3615    Alp Vol\n         vec4(  2.367300,  1.180361,  4.76,  1.53),   // 3576   8Rho UMa\n         vec4(  2.372012,  0.823039,   3.6,     0),   // 3594  12Kap UMa\n         vec4(  2.374324, -0.822011,  3.75,   1.2),   // 3614           \n         vec4(  2.378652, -1.267158,  4.48,  0.61),   // 3643           \n         vec4(  2.380796, -1.231136,  4.71, -0.15),   // 3642           \n         vec4(  2.382259,  0.088876,  4.97,  1.22),   // 3613  18Ome Hya\n         vec4(  2.384686,  0.671118,  4.56,  1.04),   // 3612           \n         vec4(  2.391087, -0.758040,  2.21,  1.66),   // 3634    Lam Vel\n         vec4(  2.391312, -0.451313,  4.58,  1.59),   // 3628    Kap Pyx\n         vec4(  2.392818,  1.167160,  5.14,  1.51),   // 3609  11Sig1UMa\n         vec4(  2.394904,  0.900672,  4.48,  0.27),   // 3619  15    UMa\n         vec4(  2.397027,  0.384768,  5.14,  0.97),   // 3627  77Xi  Cnc\n         vec4(  2.401515,  1.171722,   4.8,  0.49),   // 3616  13Sig2UMa\n         vec4(  2.403834,  1.108522,  4.67,  0.35),   // 3624  14Tau UMa\n         vec4(  2.404046, -1.029167,  3.44, -0.19),   // 3659           \n         vec4(  2.404512, -0.783095,     5,  0.23),   // 3654           \n         vec4(  2.405397, -1.087641,  3.97, -0.18),   // 3663           \n         vec4(  2.413790, -1.216795,  1.68,     0),   // 3685    Bet Car\n         vec4(  2.418781,  1.072039,  5.13,  0.58),   // 3648  16    UMa\n         vec4(  2.418875,  0.040390,  3.88, -0.06),   // 3665  22The Hya\n         vec4(  2.424312, -0.673174,  4.94,  1.11),   // 3682           \n         vec4(  2.424925, -0.652986,  4.62,  0.45),   // 3684           \n         vec4(  2.426831,  0.942861,  4.83,  0.19),   // 3662  18    UMa\n         vec4(  2.426896, -1.004287,  4.34,  1.63),   // 3696           \n         vec4(  2.427687, -0.772585,  5.12,  1.67),   // 3692           \n         vec4(  2.430763, -1.034549,  2.25,  0.18),   // 3699    Iot Car\n         vec4(  2.438421,  0.642325,  3.82,  0.06),   // 3690  38    Lyn\n         vec4(  2.442473, -0.209003,  4.79,  0.93),   // 3706  26    Hya\n         vec4(  2.445570, -0.166781,   4.8,  0.93),   // 3709  27    Hya\n         vec4(  2.447591, -1.089168,  4.81,  0.94),   // 3728           \n         vec4(  2.448065,  0.600262,  3.13,  1.55),   // 3705  40Alp Lyn\n         vec4(  2.449976, -0.453185,  4.72,  1.63),   // 3718    The Pyx\n         vec4(  2.452683, -0.960120,   2.5, -0.18),   // 3734    Kap Vel\n         vec4(  2.457445, -0.503246,  4.69,  0.92),   // 3733    Lam Pyx\n         vec4(  2.463773,  0.456966,  4.46,  1.23),   // 3731   1Kap Leo\n         vec4(  2.470957, -0.931642,  5.11, -0.11),   // 3753           \n         vec4(  2.475342, -0.389974,  4.69,  1.14),   // 3749           \n         vec4(  2.476565, -0.151121,  1.98,  1.44),   // 3748  30Alp Hya\n         vec4(  2.483379, -0.048326,   4.6,  0.46),   // 3759  31Tau1Hya\n         vec4(  2.483801, -0.627470,  4.51,  1.44),   // 3765    Eps Ant\n         vec4(  2.490149, -0.706277,   3.6,  0.36),   // 3786    Psi Vel\n         vec4(  2.492424, -0.995439,  3.13,  1.55),   // 3803           \n         vec4(  2.493762,  1.100639,  3.67,  0.33),   // 3757  23    UMa\n         vec4(  2.494600,  0.400868,  4.31,  1.54),   // 3773   4Lam Leo\n         vec4(  2.495582,  0.197217,  4.97,  1.05),   // 3782   5Xi  Leo\n         vec4(  2.495647,  0.169573,  5.07,  1.37),   // 3779   6    Leo\n         vec4(  2.495741, -0.020682,  4.57,   0.1),   // 3787  32Tau2Hya\n         vec4(  2.499559,  0.901938,  3.17,  0.46),   // 3775  25The UMa\n         vec4(  2.501093, -0.368541,  5.01,  1.02),   // 3808           \n         vec4(  2.503420, -0.855299,  5.12, -0.12),   // 3817           \n         vec4(  2.504054, -1.412694,  5.11, -0.14),   // 3860    Zet Cha\n         vec4(  2.505187, -0.894573,  5.01, -0.18),   // 3819           \n         vec4(  2.505522,  0.635256,  4.55,  0.92),   // 3800  10    LMi\n         vec4(  2.506489, -1.033749,  4.08,  0.01),   // 3825           \n         vec4(  2.506648,  1.218768,  4.56,  0.77),   // 3771  24    UMa\n         vec4(  2.508148,  0.908468,   4.5,  0.01),   // 3799  26    UMa\n         vec4(  2.509187,  0.691524,  4.81,  0.99),   // 3809           \n         vec4(  2.516882, -0.861412,  4.35,  0.17),   // 3836           \n         vec4(  2.518015,  1.419413,  4.29,  1.48),   // 3751           \n         vec4(  2.518560,  0.119308,     5,  1.05),   // 3827  10    Leo\n         vec4(  2.523987,  0.081143,  4.68,  1.32),   // 3834           \n         vec4(  2.527890, -1.070377,  4.52, -0.07),   // 3856           \n         vec4(  2.530102, -0.019945,  3.91,  1.32),   // 3845  35Iot Hya\n         vec4(  2.532066, -0.250144,  5.06, -0.15),   // 3849  38Kap Hya\n         vec4(  2.535744,  0.172652,  3.52,  0.49),   // 3852  14Omi Leo\n         vec4(  2.536328, -0.411752,  4.77, -0.12),   // 3858           \n         vec4(  2.540501, -0.417405,  4.94,  0.53),   // 3862           \n         vec4(  2.543614,  1.261044,  5.17,  1.04),   // 3839  27    UMa\n         vec4(  2.549059, -0.484668,  4.79,  0.51),   // 3871    The Ant\n         vec4(  2.553620, -1.090967,  3.69,  1.22),   // 3884           \n         vec4(  2.556259,  0.414938,  2.98,   0.8),   // 3873  17Eps Leo\n         vec4(  2.561715, -1.135720,  3.01,  0.28),   // 3890    Ups Car\n         vec4(  2.568208,  0.803220,  5.09,  0.62),   // 3881           \n         vec4(  2.574150, -0.798188,  5.08,  -0.1),   // 3898           \n         vec4(  2.578679,  1.030418,   3.8,  0.29),   // 3888  29Ups UMa\n         vec4(  2.580811, -0.259123,  4.12,  0.92),   // 3903  39Ups1Hya\n         vec4(  2.581690, -0.812412,  4.58,   1.2),   // 3912           \n         vec4(  2.583552,  0.943603,  4.59,  0.03),   // 3894  30Phi UMa\n         vec4(  2.585298, -0.141459,  5.05,  0.04),   // 3909   8Gam Sex\n         vec4(  2.586418,  0.453907,  3.88,  1.22),   // 3905  24Mu  Leo\n         vec4(  2.592710, -0.452608,  4.88,  1.23),   // 3919           \n         vec4(  2.595610, -0.331777,  4.94,  1.57),   // 3923           \n         vec4(  2.604307, -0.952387,  3.54, -0.08),   // 3940    Phi Vel\n         vec4(  2.607894,  0.716555,  5.14,  0.46),   // 3928  19    LMi\n         vec4(  2.618926,  0.140397,   4.7,   1.6),   // 3950  29Pi  Leo\n         vec4(  2.640357, -0.228022,   4.6, -0.09),   // 3970  40Ups2Hya\n         vec4(  2.644996, -0.826762,  5.08,  0.88),   // 3976           \n         vec4(  2.649991,  0.292566,  3.52, -0.03),   // 3975  30Eta Leo\n         vec4(  2.650413,  0.615136,  4.48,  0.18),   // 3974  21    LMi\n         vec4(  2.652486,  0.174489,  4.37,  1.45),   // 3980  31    Leo\n         vec4(  2.652632, -0.006487,  4.49, -0.04),   // 3981  15Alp Sex\n         vec4(  2.654523,  0.208867,  1.35, -0.11),   // 3982  32Alp Leo\n         vec4(  2.656994, -0.904275,  4.86, -0.12),   // 3990           \n         vec4(  2.664194, -0.215621,  3.61,  1.01),   // 3994  41Lam Hya\n         vec4(  2.676944, -1.158429,  5.16,  0.21),   // 4025           \n         vec4(  2.677930, -1.222395,  3.32, -0.08),   // 4037    Ome Car\n         vec4(  2.682295, -0.735167,  3.85,  0.05),   // 4023           \n         vec4(  2.690819,  0.408708,  3.44,  0.31),   // 4031  36Zet Leo\n         vec4(  2.692533, -1.070449,   3.4,  1.54),   // 4050           \n         vec4(  2.692591,  0.748998,  3.45,  0.03),   // 4033  33Lam UMa\n         vec4(  2.703573, -0.960445,  4.57,  1.62),   // 4063           \n         vec4(  2.704105,  0.339830,  4.79,  0.45),   // 4054  40    Leo\n         vec4(  2.705137,  0.346302,  2.61,  1.15),   // 4057  41Gam1Leo\n         vec4(  2.709247, -0.978136,   4.5, -0.12),   // 4074           \n         vec4(  2.715412, -0.726930,  4.83,  1.12),   // 4080           \n         vec4(  2.715420,  0.724302,  3.05,  1.59),   // 4069  34Mu  UMa\n         vec4(  2.718213, -1.167655,  4.99, -0.13),   // 4089           \n         vec4(  2.723287,  1.144349,  4.97, -0.06),   // 4072           \n         vec4(  2.724437, -1.292096,     4,  0.35),   // 4102           \n         vec4(  2.731070,  0.589853,  4.74,  0.25),   // 4090  30    LMi\n         vec4(  2.731832, -0.293850,  3.81,  1.48),   // 4094  42Mu  Hya\n         vec4(  2.736466, -0.542235,  4.25,  1.45),   // 4104    Alp Ant\n         vec4(  2.737579, -1.005988,  4.66,  0.51),   // 4110           \n         vec4(  2.739636, -1.025197,  3.82,  0.31),   // 4114           \n         vec4(  2.739657,  0.640662,  4.21,   0.9),   // 4100  31Bet LMi\n         vec4(  2.750166, -0.011117,  5.09, -0.14),   // 4119  30Bet Sex\n         vec4(  2.750355, -1.256516,  4.74,  0.04),   // 4138           \n         vec4(  2.751627,  0.977045,  4.84,  0.52),   // 4112  36    UMa\n         vec4(  2.753402, -1.277959,  4.93,  1.68),   // 4142           \n         vec4(  2.754842, -0.937513,  4.89,   0.5),   // 4134           \n         vec4(  2.757722, -1.076611,  3.32, -0.09),   // 4140           \n         vec4(  2.761162,  0.162432,  3.85, -0.14),   // 4133  47Rho Leo\n         vec4(  2.761759, -0.820363,  5.02,  1.04),   // 4143           \n         vec4(  2.762994,  0.705559,  4.75,  0.23),   // 4132           \n         vec4(  2.766413, -0.414433,  5.08,   1.6),   // 4145  44    Hya\n         vec4(  2.769838,  0.121363,  5.08,  0.94),   // 4146  48    Leo\n         vec4(  2.771110,  1.321442,  4.84,  0.96),   // 4126           \n         vec4(  2.771416,  0.996282,  5.16,  0.34),   // 4141  37    UMa\n         vec4(  2.772754, -1.371965,  4.11,  1.58),   // 4174    Gam Cha\n         vec4(  2.773278, -1.004573,  4.45,  1.62),   // 4159           \n         vec4(  2.776550, -1.039600,  5.08,  1.18),   // 4164           \n         vec4(  2.780433, -0.478438,  4.89,  1.62),   // 4162           \n         vec4(  2.780752, -0.841700,  3.84,   0.3),   // 4167           \n         vec4(  2.781852, -0.233603,  4.82,  2.68),   // 4163           \n         vec4(  2.786347, -0.294553,  4.91,  0.92),   // 4171    Phi3Hya\n         vec4(  2.786941,  0.558088,  4.71,  0.81),   // 4166  37    LMi\n         vec4(  2.787080, -1.032939,  4.66,  1.48),   // 4177           \n         vec4(  2.789501, -0.970461,  4.28,  1.04),   // 4180           \n         vec4(  2.801008,  1.146968,  5.12,   1.2),   // 4178  38    UMa\n         vec4(  2.802272, -1.125151,  4.82, -0.14),   // 4196           \n         vec4(  2.805427, -1.123895,  2.76, -0.22),   // 4199    The Car\n         vec4(  2.805916,  1.205606,     5,  1.38),   // 4181           \n         vec4(  2.807435,  0.404713,  5.08,  0.04),   // 4192  41    LMi\n         vec4(  2.807950, -1.057088,  4.57,  1.71),   // 4200           \n         vec4(  2.808011,  0.806410,  5.18,  0.33),   // 4191           \n         vec4(  2.810482, -1.116332,  4.82, -0.13),   // 4205           \n         vec4(  2.817747, -1.405693,  4.45, -0.19),   // 4234    Del2Cha\n         vec4(  2.822067, -0.862542,  2.69,   0.9),   // 4216    Mu  Vel\n         vec4(  2.822431, -1.123701,  4.85, -0.15),   // 4222           \n         vec4(  2.834523, -0.282632,  3.11,  1.25),   // 4232    Nu  Hya\n         vec4(  2.850610,  0.597164,  3.83,  1.04),   // 4247  46    LMi\n         vec4(  2.851404, -1.027184,  3.78,  0.95),   // 4257           \n         vec4(  2.851760,  0.952688,   5.1,  1.36),   // 4246  44    UMa\n         vec4(  2.853519,  0.753808,  4.71, -0.05),   // 4248  45Ome UMa\n         vec4(  2.860653,  0.431964,   4.5,  0.01),   // 4259  54    Leo\n         vec4(  2.861205,  0.584806,  5.03,   1.1),   // 4258  46    UMa\n         vec4(  2.865475, -0.648177,   4.6,  1.03),   // 4273    Iot Ant\n         vec4(  2.877466,  0.705642,  5.05,  0.61),   // 4277  47    UMa\n         vec4(  2.878812, -0.319376,  4.08,  1.09),   // 4287   7Alp Crt\n         vec4(  2.880469, -0.736980,  4.39,  0.11),   // 4293           \n         vec4(  2.882236,  0.063137,  4.84,  1.16),   // 4291  58    Leo\n         vec4(  2.883050,  0.106489,  4.99,  0.16),   // 4294  59    Leo\n         vec4(  2.883458,  0.684382,  5.08,  0.24),   // 4288  49    UMa\n         vec4(  2.887770, -0.043367,  4.74,  1.62),   // 4299  61    Leo\n         vec4(  2.887828,  0.984060,  2.37, -0.02),   // 4295  48Bet UMa\n         vec4(  2.889959,  0.352203,  4.42,  0.05),   // 4300  60    Leo\n         vec4(  2.896062,  1.077755,  1.79,  1.07),   // 4301  50Alp UMa\n         vec4(  2.901682,  0.128039,  4.63,  0.33),   // 4310  63Chi Leo\n         vec4(  2.903057, -0.476363,  4.94,  0.36),   // 4314    Chi1Hya\n         vec4(  2.908330, -1.089507,  4.61,  1.03),   // 4325           \n         vec4(  2.911544, -0.744184,  5.15,  0.03),   // 4327           \n         vec4(  2.917173, -1.081183,  5.13,  0.22),   // 4338           \n         vec4(  2.917275, -1.029308,  3.91,  1.23),   // 4337           \n         vec4(  2.921959,  0.776647,  3.01,  1.14),   // 4335  52Psi UMa\n         vec4(  2.930664, -0.398386,  4.48,  0.03),   // 4343  11Bet Crt\n         vec4(  2.934771, -1.052739,   4.6,  0.55),   // 4352           \n         vec4(  2.941353,  0.358205,  2.56,  0.12),   // 4357  68Del Leo\n         vec4(  2.941926,  0.269295,  3.34, -0.01),   // 4359  70The Leo\n         vec4(  2.946131,  0.403094,  4.63,  1.66),   // 4362  72    Leo\n         vec4(  2.952492, -0.063734,  4.47,  0.21),   // 4368  74Phi Leo\n         vec4(  2.959134,  0.550288,  4.41,  0.59),   // 4375  53Xi  UMa\n         vec4(  2.960420,  0.577602,  3.48,   1.4),   // 4377  54Nu  UMa\n         vec4(  2.963271,  0.666464,  4.78,  0.12),   // 4380  55    UMa\n         vec4(  2.964187, -0.257935,  3.56,  1.12),   // 4382  12Del Crt\n         vec4(  2.971452, -0.951049,  3.89, -0.15),   // 4390    Pi  Cen\n         vec4(  2.972020,  0.105234,  4.05, -0.06),   // 4386  77Sig Leo\n         vec4(  2.979392,  0.758918,  4.99,  0.99),   // 4392  56    UMa\n         vec4(  2.981073, -0.631193,     5,  1.46),   // 4396           \n         vec4(  2.981735, -1.133679,  5.11, -0.08),   // 4401           \n         vec4(  2.981743, -0.327773,  5.09,  0.42),   // 4395  13Lam Crt\n         vec4(  2.984186,  0.183769,  3.94,  0.41),   // 4399  78Iot Leo\n         vec4(  2.987176, -0.189533,  4.83,  1.56),   // 4402  14Eps Crt\n         vec4(  2.988359, -0.308642,  4.08,  0.21),   // 4405  15Gam Crt\n         vec4(  2.992019, -1.116536,  5.17,   0.5),   // 4413           \n         vec4(  3.001690,  0.049849,  4.95,     1),   // 4418  84Tau Leo\n         vec4(  3.004520, -0.744805,  5.08, -0.03),   // 4423           \n         vec4(  3.012068, -0.052423,  4.77,  1.54),   // 4432  87    Leo\n         vec4(  3.016816,  1.210056,  3.84,  1.62),   // 4434   1Lam Dra\n         vec4(  3.018409, -1.037462,  5.13,  1.08),   // 4441    Omi1Cen\n         vec4(  3.018605, -1.038747,  5.15,  0.49),   // 4442    Omi2Cen\n         vec4(  3.023354, -0.542574,  5.04,  1.58),   // 4449           \n         vec4(  3.023791, -0.556023,  3.54,  0.94),   // 4450    Xi  Hya\n         vec4(  3.031469, -0.947088,  4.62, -0.08),   // 4460           \n         vec4(  3.035912, -1.099902,  3.13, -0.04),   // 4467    Lam Cen\n         vec4(  3.039847, -0.171081,   4.7, -0.08),   // 4468  21The Crt\n         vec4(  3.041012, -0.014380,   4.3,     1),   // 4471  91Ups Leo\n         vec4(  3.041279, -1.069596,  5.15,  1.12),   // 4475           \n         vec4(  3.046130, -1.079074,  5.15, -0.02),   // 4487           \n         vec4(  3.052102, -1.141407,  5.17,   0.8),   // 4492           \n         vec4(  3.055257, -0.606410,   4.7, -0.07),   // 4494    Omi Hya\n         vec4(  3.058225, -1.083675,  4.94,  1.15),   // 4499           \n         vec4(  3.069684, -1.090647,  5.03,   0.8),   // 4511           \n         vec4(  3.075111, -0.320282,  4.73,  0.97),   // 4514  27Zet Crt\n         vec4(  3.077387,  0.144135,  4.85,  0.18),   // 4515   2Xi  Vir\n         vec4(  3.078790, -1.164634,  3.64,  0.16),   // 4520    Lam Mus\n         vec4(  3.079894,  0.113960,  4.03,  1.51),   // 4517   3Nu  Vir\n         vec4(  3.080724,  0.833909,  3.71,  1.18),   // 4518  63Chi UMa\n         vec4(  3.082746, -1.067763,  4.11,   0.9),   // 4522           \n         vec4(  3.082769, -0.706868,  4.91,  0.66),   // 4523           \n         vec4(  3.089168,  0.352886,  4.53,  0.55),   // 4527  93    Leo\n         vec4(  3.090272, -1.166137,  4.72,  1.54),   // 4530    Mu  Mus\n         vec4(  3.092513, -0.466871,  5.11,   1.6),   // 4532           \n         vec4(  3.093859,  0.254328,  2.14,  0.09),   // 4534  94Bet Leo\n         vec4(  3.096584, -1.113316,  4.32, -0.15),   // 4537           \n         vec4(  3.097713, -1.225672,  4.97,   1.4),   // 4538           \n         vec4(  3.100993,  0.030800,  3.61,  0.55),   // 4540   5Bet Vir\n         vec4(  3.102957, -0.788428,  4.46,   1.3),   // 4546           \n         vec4(  3.106045, -1.138061,   4.9, -0.11),   // 4549           \n         vec4(  3.110656, -0.591807,  4.28,  -0.1),   // 4552    Bet Hya\n         vec4(  3.114672,  0.937150,  2.44,     0),   // 4554  64Gam UMa\n         vec4(  3.139941, -1.365230,  4.91, -0.06),   // 4583    Eps Cha\n         vec4(  3.145405,  0.115439,  4.66,  0.13),   // 4589   8Pi  Vir\n         vec4(  3.154793, -1.105016,  4.33,  0.27),   // 4599    The1Cru\n         vec4(  3.157562, -0.740616,  5.15,  0.41),   // 4600           \n         vec4(  3.160442, -1.102447,  4.72, -0.08),   // 4603    The2Cru\n         vec4(  3.162427, -1.335512,  5.04,  1.49),   // 4605    Kap Cha\n         vec4(  3.164320,  0.152421,  4.12,  0.98),   // 4608   9Omi Vir\n         vec4(  3.171618, -1.127720,  4.15,  0.34),   // 4616    Eta Cru\n         vec4(  3.176878, -0.884208,  4.47, -0.15),   // 4618           \n         vec4(  3.178064, -0.885275,   2.6, -0.12),   // 4621    Del Cen\n         vec4(  3.178302, -0.431601,  4.02,  0.32),   // 4623   1Alp Crv\n         vec4(  3.185771, -0.394789,     3,  1.33),   // 4630   2Eps Crv\n         vec4(  3.192431, -0.914005,  3.96, -0.15),   // 4638    Rho Cen\n         vec4(  3.194819,  1.354662,  5.14,  0.33),   // 4646           \n         vec4(  3.207676, -1.025362,   2.8, -0.23),   // 4656    Del Cru\n         vec4(  3.208904,  0.995405,  3.31,  0.08),   // 4660  69Del UMa\n         vec4(  3.210561, -0.306165,  2.59, -0.11),   // 4662   4Gam Crv\n         vec4(  3.211420,  0.260035,   5.1,  0.06),   // 4663   6    Com\n         vec4(  3.212896,  0.417924,  4.95,  0.97),   // 4667   7    Com\n         vec4(  3.213595,  0.577030,     5,  1.14),   // 4668           \n         vec4(  3.218250, -1.186140,  4.11,  1.58),   // 4671    Eps Mus\n         vec4(  3.221638, -1.384259,  4.26, -0.12),   // 4674    Bet Cha\n         vec4(  3.222031, -1.117064,  4.04, -0.17),   // 4679    Zet Cru\n         vec4(  3.224473, -0.962428,     5,  1.59),   // 4682           \n         vec4(  3.228453, -0.011640,  3.89,  0.02),   // 4689  15Eta Vir\n         vec4(  3.230387,  0.057814,  4.96,  1.16),   // 4695  16    Vir\n         vec4(  3.231987,  0.310543,  4.74,  1.01),   // 4697  11    Com\n         vec4(  3.232911, -0.236764,  5.14,  1.05),   // 4699           \n         vec4(  3.234793, -1.054198,  3.59,  1.42),   // 4700    Eps Cru\n         vec4(  3.238115, -1.178480,  5.15,  0.19),   // 4703    Zet2Mus\n         vec4(  3.239788,  0.451100,  4.81,  0.49),   // 4707  12    Com\n         vec4(  3.246423,  0.899931,   4.8,  0.87),   // 4716   5    CVn\n         vec4(  3.247658,  0.455507,  5.18,  0.08),   // 4717  13    Com\n         vec4(  3.254379,  0.681003,  5.02,  0.96),   // 4728   6    CVn\n         vec4(  3.256792,  0.475922,  4.95,  0.27),   // 4733  14    Com\n         vec4(  3.257287, -1.101696,  4.86, -0.12),   // 4729           \n         vec4(  3.257337, -0.897986,  4.82, -0.14),   // 4732           \n         vec4(  3.257651, -1.101288,  1.33, -0.24),   // 4730    Alp1Cru\n         vec4(  3.257693, -1.101293,  1.73, -0.26),   // 4731    Alp2Cru\n         vec4(  3.259133,  0.493375,  4.36,  1.13),   // 4737  15Gam Com\n         vec4(  3.259353,  0.468194,     5,  0.08),   // 4738  16    Com\n         vec4(  3.263940, -0.876689,  3.91, -0.19),   // 4743    Sig Cen\n         vec4(  3.271903, -0.288251,  2.95, -0.05),   // 4757   7Del Crv\n         vec4(  3.272979,  1.207787,  4.95,  1.62),   // 4765   4    Dra\n         vec4(  3.277576, -0.996816,  1.63,  1.59),   // 4763    Gam Cru\n         vec4(  3.281525, -0.282675,  4.31,  0.38),   // 4775   8Eta Crv\n         vec4(  3.283255, -1.258959,  3.87, -0.15),   // 4773    Gam Mus\n         vec4(  3.287692,  1.218036,  3.87, -0.13),   // 4787   5Kap Dra\n         vec4(  3.288818,  0.721825,  4.26,  0.59),   // 4785   8Bet CVn\n         vec4(  3.291633, -0.408349,  2.65,  0.89),   // 4786   9Bet Crv\n         vec4(  3.293146,  1.222113,  4.94,  1.31),   // 4795   6    Dra\n         vec4(  3.293661,  0.394954,  4.81,     0),   // 4789  23    Com\n         vec4(  3.294876,  0.320738,  5.02,  1.15),   // 4792  24    Com\n         vec4(  3.297617, -0.715968,  5.13,  0.22),   // 4794           \n         vec4(  3.303835, -1.206643,  2.69,  -0.2),   // 4798    Alp Mus\n         vec4(  3.306105, -0.847202,  3.86,  0.05),   // 4802    Tau Cen\n         vec4(  3.312838, -0.139549,  4.66,  1.23),   // 4813  26Chi Vir\n         vec4(  3.315579, -0.697914,  4.64, -0.08),   // 4817           \n         vec4(  3.322742, -0.854508,  2.17, -0.01),   // 4819    Gam Cen\n         vec4(  3.323368, -0.025298,  3.65,  0.36),   // 4825  29Gam Vir\n         vec4(  3.324350,  0.178644,  4.88,  0.09),   // 4828  30Rho Vir\n         vec4(  3.324606, -1.041714,  4.93, -0.04),   // 4823           \n         vec4(  3.327426, -0.851949,  4.66,  1.09),   // 4831           \n         vec4(  3.338510,  0.793083,  4.99,  2.54),   // 4846           \n         vec4(  3.340699, -1.064321,  4.69,  1.05),   // 4842    Iot Cru\n         vec4(  3.343534, -1.188710,  3.05, -0.18),   // 4844    Bet Mus\n         vec4(  3.343956, -0.985917,  4.65, -0.16),   // 4848           \n         vec4(  3.345121,  0.289332,  5.12,  1.35),   // 4851  27    Com\n         vec4(  3.349810, -1.041763,  1.25, -0.23),   // 4853    Bet Cru\n         vec4(  3.362756, -0.593402,  4.91, -0.04),   // 4874           \n         vec4(  3.367170,  0.480673,  4.94,  0.67),   // 4883  31    Com\n         vec4(  3.373351, -0.854222,  4.33,  1.37),   // 4888           \n         vec4(  3.374144,  0.370795,   4.9,   0.9),   // 4894  35    Com\n         vec4(  3.374754, -0.701254,  4.27,  0.21),   // 4889           \n         vec4(  3.377335,  0.976681,  1.77, -0.02),   // 4905  77Eps UMa\n         vec4(  3.378754, -0.166485,  4.79,   1.6),   // 4902  40Psi Vir\n         vec4(  3.379802, -0.997941,  4.03, -0.17),   // 4898    Mu 1Cru\n         vec4(  3.379888, -0.997776,  5.17, -0.12),   // 4899    Mu 2Cru\n         vec4(  3.380063, -1.032304,  4.62, -0.15),   // 4897    Lam Cru\n         vec4(  3.384207,  0.059298,  3.38,  1.58),   // 4910  43Del Vir\n         vec4(  3.386064,  0.668781,   2.9, -0.12),   // 4915  12Alp2CVn\n         vec4(  3.390621, -0.893584,  5.16, -0.06),   // 4913           \n         vec4(  3.398696,  0.303852,  4.78,  1.56),   // 4920  36    Com\n         vec4(  3.404591,  0.537300,   4.9,  1.17),   // 4924  37    Com\n         vec4(  3.406578,  0.983779,  4.93,  0.36),   // 4931  78    UMa\n         vec4(  3.412890,  0.191274,  2.83,  0.94),   // 4932  47Eps Vir\n         vec4(  3.413296, -1.248764,  3.62,  1.18),   // 4923    Del Mus\n         vec4(  3.418896, -0.864413,  4.85,  0.02),   // 4933    Xi 1Cen\n         vec4(  3.430787, -0.845850,  4.71, -0.14),   // 4940           \n         vec4(  3.433543, -0.871026,  4.27, -0.19),   // 4942    Xi 2Cen\n         vec4(  3.434714,  0.482142,   4.8,  1.48),   // 4954  41    Com\n         vec4(  3.442903, -0.403486,  4.95,  1.05),   // 4958  45Psi Hya\n         vec4(  3.446806, -0.096672,  4.38, -0.01),   // 4963  51The Vir\n         vec4(  3.455199,  0.486564,  4.26,  0.57),   // 4983  43Bet Com\n         vec4(  3.455985, -0.659788,  4.85,   0.7),   // 4979           \n         vec4(  3.456006, -0.282719,  5.04,  0.46),   // 4981  53    Vir\n         vec4(  3.457017, -1.045816,   4.6, -0.08),   // 4975           \n         vec4(  3.463242,  0.700798,  4.92,  1.06),   // 4997           \n         vec4(  3.465554, -1.031548,  4.92,  0.48),   // 4989           \n         vec4(  3.469926, -1.184982,   4.8, -0.08),   // 4993    Eta Mus\n         vec4(  3.477068, -0.549885,   5.1,  0.96),   // 5006           \n         vec4(  3.478513, -1.165594,  4.87,   1.5),   // 5002           \n         vec4(  3.479932,  0.708124,  4.73,   0.3),   // 5017  20    CVn\n         vec4(  3.480209,  0.095465,   4.8,  1.67),   // 5015  60Sig Vir\n         vec4(  3.482987,  0.867113,  5.15, -0.07),   // 5023  21    CVn\n         vec4(  3.483699, -0.319594,  4.74,  0.71),   // 5019  61    Vir\n         vec4(  3.485953, -0.404422,     3,  0.92),   // 5020  46Gam Hya\n         vec4(  3.493263, -0.640749,  2.75,  0.04),   // 5028    Iot Cen\n         vec4(  3.502140, -1.064447,  4.53, -0.13),   // 5035           \n         vec4(  3.507785,  0.958627,  2.27,  0.02),   // 5054  79Zet UMa\n         vec4(  3.507850,  0.958564,  3.95,  0.13),   // 5055  79Zet UMa\n         vec4(  3.508148, -1.126363,  4.53,  0.85),   // 5041           \n         vec4(  3.512992, -1.307038,  5.05,  1.11),   // 5042    Iot1Mus\n         vec4(  3.513319, -0.194803,  0.98, -0.23),   // 5056  67Alp Vir\n         vec4(  3.513458,  0.959723,  4.01,  0.16),   // 5062  80    UMa\n         vec4(  3.517406, -0.693861,  5.09,   1.2),   // 5058           \n         vec4(  3.523181, -0.278792,  4.76,  1.09),   // 5068  69    Vir\n         vec4(  3.527441,  0.240487,  4.98,  0.71),   // 5072  70    Vir\n         vec4(  3.531760, -0.893003,  5.06,  0.07),   // 5071           \n         vec4(  3.533040, -0.406337,  4.97,   1.6),   // 5080           \n         vec4(  3.538852, -0.687791,  3.88,  1.17),   // 5089           \n         vec4(  3.542866, -0.109185,  4.69,  1.62),   // 5095  74    Vir\n         vec4(  3.552319,  0.063860,  4.94,  0.03),   // 5105  78    Vir\n         vec4(  3.553731,  0.855492,   4.7,  0.12),   // 5112  24    CVn\n         vec4(  3.554770, -0.010399,  3.37,  0.11),   // 5107  79Zet Vir\n         vec4(  3.555220,  0.648957,  4.98,   0.4),   // 5110           \n         vec4(  3.566841,  0.633467,  4.82,  0.23),   // 5127  25    CVn\n         vec4(  3.577431, -0.933165,   2.3, -0.22),   // 5132    Eps Cen\n         vec4(  3.581146,  0.954375,  4.66,  1.64),   // 5154  83    UMa\n         vec4(  3.584966, -0.151897,  5.01,  1.63),   // 5150  82    Vir\n         vec4(  3.585539, -0.952252,  5.01, -0.05),   // 5141           \n         vec4(  3.602737, -0.576725,  4.23,  0.38),   // 5168   1    Cen\n         vec4(  3.606962, -0.897671,  4.65,  0.96),   // 5172           \n         vec4(  3.608206, -0.632716,  5.15, -0.02),   // 5174           \n         vec4(  3.609609,  0.304676,   4.5,  0.48),   // 5185   4Tau Boo\n         vec4(  3.610824,  0.860680,  1.86, -0.19),   // 5191  85Eta UMa\n         vec4(  3.619136, -0.601280,  4.19,   1.5),   // 5192   2    Cen\n         vec4(  3.619274,  0.275723,  4.07,  1.52),   // 5200   5Ups Boo\n         vec4(  3.619397, -0.727589,  3.41, -0.22),   // 5190    Nu  Cen\n         vec4(  3.619884, -0.741309,  3.04, -0.17),   // 5193    Mu  Cen\n         vec4(  3.620309,  0.371130,  4.91,  1.43),   // 5201   6    Boo\n         vec4(  3.620997, -0.316501,  4.97,  1.06),   // 5196  89    Vir\n         vec4(  3.627804,  1.129635,  4.65,  1.58),   // 5226  10    Dra\n         vec4(  3.629375,  0.601164,  4.74,  1.66),   // 5219           \n         vec4(  3.629529, -0.575862,  4.56, -0.13),   // 5210   3    Cen\n         vec4(  3.635558, -0.557245,  4.73, -0.14),   // 5221   4    Cen\n         vec4(  3.642001,  0.321102,  2.68,  0.58),   // 5235   8Eta Boo\n         vec4(  3.642072, -0.026233,  5.15,  1.08),   // 5232  90    Vir\n         vec4(  3.645732, -0.825337,  2.55, -0.22),   // 5231    Zet Cen\n         vec4(  3.650224,  0.479825,  5.01,  1.42),   // 5247   9    Boo\n         vec4(  3.654931, -1.111542,  4.71,  1.11),   // 5241           \n         vec4(  3.657649, -0.734798,  3.83, -0.21),   // 5248    Phi Cen\n         vec4(  3.658728, -0.435847,  5.15,  -0.1),   // 5250  47    Hya\n         vec4(  3.659432, -0.781971,  3.87,  -0.2),   // 5249    Ups1Cen\n         vec4(  3.672375,  0.026956,  4.26,   0.1),   // 5264  93Tau Vir\n         vec4(  3.672710, -0.795933,  4.34,   0.6),   // 5260    Ups2Cen\n         vec4(  3.681873, -1.053709,  0.61, -0.23),   // 5267    Bet Cen\n         vec4(  3.684340,  1.123570,  3.65, -0.05),   // 5291  11Alp Dra\n         vec4(  3.691576, -0.718722,  4.36, -0.19),   // 5285    Chi Cen\n         vec4(  3.692992, -0.465698,  3.27,  1.12),   // 5287  49Pi  Hya\n         vec4(  3.694353, -0.634776,  2.06,  1.01),   // 5288   5The Cen\n         vec4(  3.703799,  1.353459,  4.82,  1.36),   // 5321   4    UMi\n         vec4(  3.708446, -0.932689,  4.75,  0.94),   // 5297           \n         vec4(  3.710564,  0.437932,  4.83,  0.54),   // 5304  12    Boo\n         vec4(  3.712496, -0.284523,  4.91,  1.72),   // 5301           \n         vec4(  3.718701,  0.042053,  5.01, -0.12),   // 5313           \n         vec4(  3.720897, -0.475796,  5.08,  1.16),   // 5312  50    Hya\n         vec4(  3.721462, -0.179308,  4.19,  1.33),   // 5315  98Kap Vir\n         vec4(  3.724023,  0.903911,  4.54,   0.2),   // 5329  17Kap2Boo\n         vec4(  3.730424, -0.996336,  5.07, -0.08),   // 5316           \n         vec4(  3.733529,  0.334798, -0.04,  1.23),   // 5340  16Alp Boo\n         vec4(  3.735071, -0.104730,  4.08,  0.52),   // 5338  99Iot Vir\n         vec4(  3.735725,  0.896527,  4.75,   0.2),   // 5350  21Iot Boo\n         vec4(  3.736678,  0.804393,  4.18,  0.08),   // 5351  19Lam Boo\n         vec4(  3.743716,  0.619757,  4.81,  1.06),   // 5361           \n         vec4(  3.744734, -1.413853,  4.91,  0.25),   // 5303    Eta Aps\n         vec4(  3.748574, -0.233370,  4.52,  0.13),   // 5359 100Lam Vir\n         vec4(  3.749855, -0.803860,  3.55, -0.18),   // 5354    Iot Lup\n         vec4(  3.750457, -0.039541,  5.14,  1.02),   // 5366 102Ups Vir\n         vec4(  3.751381,  0.284610,  4.86,  1.23),   // 5370  20    Boo\n         vec4(  3.753876, -0.984133,  4.33,  0.12),   // 5358           \n         vec4(  3.754887, -0.661223,  4.05, -0.03),   // 5367    Psi Cen\n         vec4(  3.755549, -0.788666,  4.77,  0.31),   // 5364           \n         vec4(  3.762835, -1.398164,  5.06,  -0.1),   // 5336    Eps Aps\n         vec4(  3.763874, -1.020310,  4.92,  0.86),   // 5371           \n         vec4(  3.765707, -0.689618,  4.42, -0.18),   // 5378           \n         vec4(  3.765969, -0.484397,  4.77,  1.31),   // 5381  51    Hya\n         vec4(  3.767199,  0.147422,  5.12, -0.02),   // 5386           \n         vec4(  3.770734,  0.101578,   5.1,  0.12),   // 5392           \n         vec4(  3.775131,  0.904968,  4.05,   0.5),   // 5404  23The Boo\n         vec4(  3.779234, -0.789262,  4.56, -0.15),   // 5395    Tau1Lup\n         vec4(  3.779423, -0.792021,  4.35,  0.43),   // 5396    Tau2Lup\n         vec4(  3.782629, -1.460278,  4.32,  1.31),   // 5339    Del Oct\n         vec4(  3.785292,  1.321146,  4.25,  1.44),   // 5430   5    UMi\n         vec4(  3.788122, -0.514727,  4.97, -0.07),   // 5407  52    Hya\n         vec4(  3.788245, -0.038887,  4.81,   0.7),   // 5409 105Phi Vir\n         vec4(  3.804076,  0.530081,  3.58,   1.3),   // 5429  25Rho Boo\n         vec4(  3.805160,  0.668607,  3.03,  0.19),   // 5435  27Gam Boo\n         vec4(  3.807501, -0.880640,  4.42, -0.19),   // 5425    Sig Lup\n         vec4(  3.816511,  0.519148,  4.46,  0.36),   // 5447  28Sig Boo\n         vec4(  3.820119, -0.735792,  2.31, -0.19),   // 5440    Eta Cen\n         vec4(  3.830502, -0.862644,  4.05, -0.15),   // 5453    Rho Lup\n         vec4(  3.837971, -1.061776, -0.01,  0.71),   // 5459    Alp1Cen\n         vec4(  3.837987, -1.061781,  1.33,  0.88),   // 5460    Alp2Cen\n         vec4(  3.842896,  0.286554,  4.94, -0.03),   // 5475  29Pi 1Boo\n         vec4(  3.844736,  0.239605,  4.43,  0.05),   // 5478  30Zet Boo\n         vec4(  3.846909,  0.142448,  4.86,     1),   // 5480  31    Boo\n         vec4(  3.848145, -0.827082,   2.3,  -0.2),   // 5469    Alp Lup\n         vec4(  3.848276, -0.659623,     4, -0.17),   // 5471           \n         vec4(  3.850661, -1.134033,  3.19,  0.24),   // 5463    Alp Cir\n         vec4(  3.853077, -0.098756,  3.88,  0.38),   // 5487 107Mu  Vir\n         vec4(  3.854661,  0.462997,  4.81,  1.66),   // 5490  34    Boo\n         vec4(  3.855679, -0.613895,  4.05,  1.35),   // 5485           \n         vec4(  3.861483,  0.472533,   2.7,  0.97),   // 5506  36Eps Boo\n         vec4(  3.861483, -0.614215,  4.92,  0.01),   // 5489           \n         vec4(  3.862596,  0.296085,   4.6,  0.98),   // 5502  35Omi Boo\n         vec4(  3.865911, -0.444065,  4.94,  0.35),   // 5497  54    Hya\n         vec4(  3.866989,  0.033035,  3.72, -0.01),   // 5511 109    Vir\n         vec4(  3.874021, -1.379591,  3.83,  1.43),   // 5470    Alp Aps\n         vec4(  3.884616, -0.487999,  4.41,   1.4),   // 5526  58    Hya\n         vec4(  3.886354, -0.279204,  5.15,  0.41),   // 5530   8Alp1Lib\n         vec4(  3.886433,  1.294259,  2.08,  1.47),   // 5563   7Bet UMi\n         vec4(  3.887190, -0.279980,  2.75,  0.15),   // 5531   9Alp2Lib\n         vec4(  3.887794, -0.040128,  4.94,  0.98),   // 5535  11    Lib\n         vec4(  3.889415,  0.333377,  4.55,  0.76),   // 5544  37Xi  Boo\n         vec4(  3.890514, -0.760537,  4.32, -0.15),   // 5528    Omi Lup\n         vec4(  3.895800, -0.659793,  5.03, -0.16),   // 5543           \n         vec4(  3.912739, -1.095732,  5.11,     0),   // 5551    The Cir\n         vec4(  3.914702, -0.075859,  4.49,  0.32),   // 5570  16    Lib\n         vec4(  3.916445,  1.150739,   4.6,  1.59),   // 5589           \n         vec4(  3.920585, -0.752828,  2.68, -0.22),   // 5571    Bet Lup\n         vec4(  3.923333, -0.734856,  3.13,  -0.2),   // 5576    Kap Cen\n         vec4(  3.931237, -0.148683,  4.92,     0),   // 5586  19Del Lib\n         vec4(  3.935484,  0.704948,   3.5,  0.97),   // 5602  42Bet Boo\n         vec4(  3.936191,  0.436473,  4.81,   1.5),   // 5600  41Ome Boo\n         vec4(  3.939644,  0.036502,   4.4,  1.04),   // 5601 110    Vir\n         vec4(  3.943529,  0.831727,  4.76,  0.65),   // 5618  44    Boo\n         vec4(  3.944749, -0.441253,  3.29,   1.7),   // 5603  20Sig Lib\n         vec4(  3.946385,  0.470323,  4.54,  1.24),   // 5616  43Psi Boo\n         vec4(  3.947951, -1.117563,  5.17,  0.93),   // 5593    Eta Cir\n         vec4(  3.949330, -0.821197,  4.72, -0.14),   // 5605    Pi  Lup\n         vec4(  3.950197, -0.716758,  5.15,  1.01),   // 5607           \n         vec4(  3.958849,  0.434049,  4.93,  0.43),   // 5634  45    Boo\n         vec4(  3.965578, -0.790280,  4.05, -0.18),   // 5626    Lam Lup\n         vec4(  3.979068, -0.850635,  3.87, -0.05),   // 5646    Kap1Lup\n         vec4(  3.980317, -0.345430,  4.54, -0.08),   // 5652  24Iot1Lib\n         vec4(  3.980594, -0.909302,  3.41,  0.92),   // 5649    Zet Lup\n         vec4(  3.982950, -0.776681,  4.82, -0.17),   // 5651           \n         vec4(  3.990789, -0.550113,  4.91,  0.37),   // 5660   1    Lup\n         vec4(  3.990862,  1.175421,  5.13,  0.53),   // 5691           \n         vec4(  3.994637,  0.581452,  3.47,  0.95),   // 5681  49Del Boo\n         vec4(  3.997096, -0.724156,  5.16,  0.58),   // 5667           \n         vec4(  4.000928, -1.063909,  5.09, -0.06),   // 5664    Del Cir\n         vec4(  4.001195, -0.163765,  2.61, -0.11),   // 5685  27Bet Lib\n         vec4(  4.001596,  1.253563,  5.02,  1.37),   // 5714  11    UMi\n         vec4(  4.003407, -1.026273,  4.07,  0.09),   // 5670    Bet Cir\n         vec4(  4.003996, -1.110214,  4.86,  1.25),   // 5666    Eps Cir\n         vec4(  4.004795, -0.526197,  4.34,   1.1),   // 5686   2    Lup\n         vec4(  4.007858, -0.835576,  4.27, -0.08),   // 5683    Mu  Lup\n         vec4(  4.009502, -1.198683,  2.89,     0),   // 5671    Gam TrA\n         vec4(  4.011261,  0.030810,  5.06,  0.54),   // 5694   5    Ser\n         vec4(  4.017435,  1.253738,  3.05,  0.05),   // 5735  13Gam UMi\n         vec4(  4.020241, -0.709433,  3.22, -0.22),   // 5695    Del Lup\n         vec4(  4.022139, -0.632881,  3.56,  1.54),   // 5705    Phi1Lup\n         vec4(  4.023587, -0.836498,     5,   0.5),   // 5698    Nu 1Lup\n         vec4(  4.025959, -0.779978,  3.37, -0.18),   // 5708    Eps Lup\n         vec4(  4.028030, -0.643304,  4.54, -0.15),   // 5712    Phi2Lup\n         vec4(  4.028998, -1.035344,  4.51,  0.19),   // 5704    Gam Cir\n         vec4(  4.032577, -0.180157,  4.94,  0.44),   // 5723  31Eps Lib\n         vec4(  4.033849,  0.652356,  4.31,  0.31),   // 5733  51Mu 1Boo\n         vec4(  4.035769,  1.029153,  3.29,  1.16),   // 5744  12Iot Dra\n         vec4(  4.037544, -0.676029,   4.6,     0),   // 5724           \n         vec4(  4.039520,  0.269270,  5.17,  1.66),   // 5739   9Tau1Ser\n         vec4(  4.048416,  0.507993,  3.68,  0.28),   // 5747   3Bet CrB\n         vec4(  4.051942,  0.032153,  5.17,  0.23),   // 5746  10    Ser\n         vec4(  4.061948,  0.712671,  5.02,  1.59),   // 5763  52Nu 1Boo\n         vec4(  4.064064,  1.350002,  4.96,  1.58),   // 5826  15The UMi\n         vec4(  4.065671,  0.713830,  5.02,  0.07),   // 5774  53Nu 2Boo\n         vec4(  4.070674,  0.547321,  4.14, -0.13),   // 5778   4The CrB\n         vec4(  4.076122, -0.175658,  4.62,  1.01),   // 5777  37    Lib\n         vec4(  4.077280, -0.160279,  5.17, -0.09),   // 5780           \n         vec4(  4.078057, -0.489511,  5.15,   1.3),   // 5775  36    Lib\n         vec4(  4.078348,  0.466260,  2.23, -0.02),   // 5793   5Alp CrB\n         vec4(  4.078843,  0.183914,   3.8,  0.26),   // 5788  13Del Ser\n         vec4(  4.078843,  0.183943,   3.8,  0.26),   // 5789  13Del Ser\n         vec4(  4.080324, -0.718499,  2.78,  -0.2),   // 5776    Gam Lup\n         vec4(  4.080798,  0.680853,  5.11,  1.64),   // 5800   6Mu  CrB\n         vec4(  4.082005, -0.258124,  3.91,  1.01),   // 5787  38Gam Lib\n         vec4(  4.083576, -0.784676,  4.54, -0.18),   // 5781           \n         vec4(  4.087212, -1.157449,  4.11,  1.17),   // 5771    Eps TrA\n         vec4(  4.088542, -0.491048,  3.58,  1.38),   // 5794  39Ups Lib\n         vec4(  4.093029, -0.742943,  4.33,  1.42),   // 5797    Ome Lup\n         vec4(  4.095663, -0.519720,  3.66, -0.17),   // 5812  40Tau Lib\n         vec4(  4.098813,  0.639416,  5.07, -0.12),   // 5834   7Zet2CrB\n         vec4(  4.100506, -0.600602,  4.67,  0.99),   // 5820   3Psi1Lup\n         vec4(  4.102753, -0.415704,  4.96,  1.33),   // 5824  42    Lib\n         vec4(  4.106708, -0.779483,  4.64,   0.4),   // 5825           \n         vec4(  4.108295,  0.343311,  4.52,  0.04),   // 5842  21Iot Ser\n         vec4(  4.110017, -0.343461,  4.74,  1.57),   // 5838  43Kap Lib\n         vec4(  4.113232, -0.605814,  4.75, -0.14),   // 5839   4Psi2Lup\n         vec4(  4.113494,  0.458944,  3.84,     0),   // 5849   8Gam CrB\n         vec4(  4.119233,  1.357769,  4.32,  0.04),   // 5903  16Zet UMi\n         vec4(  4.120149,  0.112147,  2.65,  1.17),   // 5854  24Alp Ser\n         vec4(  4.128527,  0.269164,  3.67,  0.06),   // 5867  28Bet Ser\n         vec4(  4.129639,  0.128335,  4.43,   0.6),   // 5868  27Lam Ser\n         vec4(  4.139658,  0.316632,  4.09,  1.62),   // 5879  35Kap Ser\n         vec4(  4.143389,  0.454978,  4.63,   0.8),   // 5889  10Del CrB\n         vec4(  4.143499, -0.059870,  3.53, -0.04),   // 5881  32Mu  Ser\n         vec4(  4.148719,  0.078152,  3.71,  0.15),   // 5892  37Eps Ser\n         vec4(  4.149340, -0.586906,  3.95, -0.04),   // 5883   5Chi Lup\n         vec4(  4.149426, -0.449447,  4.64, -0.05),   // 5885   1    Sco\n         vec4(  4.150531,  0.622341,  4.82,     1),   // 5901  11Kap CrB\n         vec4(  4.150654, -0.053940,  5.11,  0.12),   // 5895  36    Ser\n         vec4(  4.150677,  0.366131,  4.76,  1.54),   // 5899  38Rho Ser\n         vec4(  4.156830,  0.740921,  4.62,  0.56),   // 5914   1Chi Her\n         vec4(  4.159709, -0.351984,  5.03, -0.01),   // 5902  45Lam Lib\n         vec4(  4.160917, -0.442043,  4.59, -0.07),   // 5904   2    Sco\n         vec4(  4.161846, -0.291984,  4.15,  1.02),   // 5908  46The Lib\n         vec4(  4.167593, -1.107072,  2.85,  0.29),   // 5897    Bet TrA\n         vec4(  4.169127, -1.197349,  5.09,  1.13),   // 5891    Kap TrA\n         vec4(  4.173316,  0.273348,  3.85,  0.48),   // 5933  41Gam Ser\n         vec4(  4.175198, -0.509883,  3.88,  -0.2),   // 5928   5Rho Sco\n         vec4(  4.175227, -0.592825,  5.12,  0.12),   // 5925    Xi 1Lup\n         vec4(  4.178269,  0.469106,  4.15,  1.23),   // 5947  13Eps CrB\n         vec4(  4.179148,  0.955563,  4.95,  0.26),   // 5960           \n         vec4(  4.180892, -0.249223,  4.88,  -0.1),   // 5941  48    Lib\n         vec4(  4.183779, -0.455778,  2.89, -0.19),   // 5944   6Pi  Sco\n         vec4(  4.186623,  0.452394,     2,   0.1),   // 5958           \n         vec4(  4.186631, -0.728578,  4.99,     1),   // 5943           \n         vec4(  4.189322, -0.670153,  3.41, -0.22),   // 5948    Eta Lup\n         vec4(  4.190246, -0.394823,  2.32, -0.12),   // 5953   7Del Sco\n         vec4(  4.194194,  0.310989,  5.12,  0.99),   // 5966   5    Her\n         vec4(  4.195089,  0.521000,  4.99, -0.07),   // 5971  14Iot CrB\n         vec4(  4.197029,  1.022157,  4.01,  0.52),   // 5986  13The Dra\n         vec4(  4.198804,  0.398013,  4.83,  0.07),   // 5972  44Pi  Ser\n         vec4(  4.201001,  0.803491,  4.76, -0.11),   // 5982   6Ups Her\n         vec4(  4.202817, -0.859221,  4.65,  0.92),   // 5962    Eta Nor\n         vec4(  4.203378, -0.451434,     5,  1.22),   // 5969           \n         vec4(  4.203640, -0.673741,  4.89, -0.14),   // 5967           \n         vec4(  4.204200, -1.008369,  4.63,  0.24),   // 5961    Iot1Nor\n         vec4(  4.207852, -0.198497,  4.77,  0.47),   // 5978    Xi  Sco\n         vec4(  4.212512, -0.345672,  2.62, -0.07),   // 5984   8Bet1Sco\n         vec4(  4.212533, -0.345609,  4.92, -0.02),   // 5985   8Bet2Sco\n         vec4(  4.217109, -0.788423,  4.72,  0.23),   // 5980    Del Nor\n         vec4(  4.217552, -0.642320,  4.23, -0.17),   // 5987    The Lup\n         vec4(  4.218489, -0.360745,  3.96, -0.04),   // 5993   9Ome1Sco\n         vec4(  4.221102, -0.364226,  4.32,  0.84),   // 5997  10Ome2Sco\n         vec4(  4.224023,  0.297525,     5,  0.95),   // 6008   7Kap Her\n         vec4(  4.227057,  0.784264,  4.26, -0.07),   // 6023  11Phi Her\n         vec4(  4.227937,  0.636885,  4.76,  1.01),   // 6018  16Tau CrB\n         vec4(  4.236932, -0.513413,  5.13,  1.12),   // 6017           \n         vec4(  4.241129, -0.339651,  4.01,  0.04),   // 6027  14Nu  Sco\n         vec4(  4.241150, -0.175653,  4.94,  0.09),   // 6031  15Psi Sco\n         vec4(  4.242475, -0.487407,  4.59, -0.16),   // 6028  13    Sco\n         vec4(  4.247601, -0.953483,  4.94,  1.04),   // 6024    Kap Nor\n         vec4(  4.251381, -0.064480,  2.74,  1.58),   // 6056   1Del Oph\n         vec4(  4.255352, -0.826801,  5.14, -0.13),   // 6045    The Nor\n         vec4(  4.256154, -1.111523,  3.85,  1.11),   // 6030    Del TrA\n         vec4(  4.263031, -0.873857,  4.99,   0.8),   // 6058    Gam1Nor\n         vec4(  4.265171,  1.322179,  4.95,  0.37),   // 6116  21Eta UMi\n         vec4(  4.268631, -0.499407,  4.78,  0.02),   // 6070           \n         vec4(  4.268734, -0.081900,  3.24,  0.96),   // 6075   2Eps Oph\n         vec4(  4.274922,  0.808320,  3.89, -0.15),   // 6092  22Tau Her\n         vec4(  4.275360, -0.875380,  4.02,  1.08),   // 6072    Gam2Nor\n         vec4(  4.277569, -1.373501,  4.68,  1.69),   // 6020    Del1Aps\n         vec4(  4.278834, -0.421836,  4.55,  0.84),   // 6081  19Omi Sco\n         vec4(  4.281242, -0.446678,  2.89,  0.13),   // 6084  20Sig Sco\n         vec4(  4.284433,  0.334284,  3.75,  0.27),   // 6095  20Gam Her\n         vec4(  4.285103,  0.017962,  4.82,  0.34),   // 6093  50Sig Ser\n         vec4(  4.285206,  0.539166,  4.85,  0.97),   // 6103  19Xi  CrB\n         vec4(  4.293474,  1.073625,  2.74,  0.91),   // 6132  14Eta Dra\n         vec4(  4.293960, -0.349720,   4.5,  1.01),   // 6104   4Psi Oph\n         vec4(  4.299691,  0.244928,  4.57,     0),   // 6117  24Ome Her\n         vec4(  4.300432, -0.409231,  5.02,  0.24),   // 6112   5Rho Oph\n         vec4(  4.306702, -0.322125,  4.42,  0.28),   // 6118   7Chi Oph\n         vec4(  4.307406, -0.829991,  4.47, -0.07),   // 6115    Eps Nor\n         vec4(  4.310098, -0.146113,  4.63,  0.17),   // 6129   3Ups Oph\n         vec4(  4.310891,  1.200229,     5, -0.06),   // 6161  15    Dra\n         vec4(  4.313006, -1.223204,  4.91,  0.55),   // 6098    Zet TrA\n         vec4(  4.313763,  0.730973,  5.04,  1.52),   // 6146  30    Her\n         vec4(  4.317101, -0.461324,  0.96,  1.83),   // 6134  21Alp Sco\n         vec4(  4.320591, -0.438339,  4.79, -0.11),   // 6141  22    Sco\n         vec4(  4.320651,  0.375066,  2.77,  0.94),   // 6148  27Bet Her\n         vec4(  4.323675,  0.034625,  3.82,  0.01),   // 6149  10Lam Oph\n         vec4(  4.324656, -0.289948,  4.28,  0.92),   // 6147   8Phi Oph\n         vec4(  4.325719, -0.605707,  4.23, -0.16),   // 6143           \n         vec4(  4.329013, -0.374659,  4.45,  0.13),   // 6153   9Ome Oph\n         vec4(  4.331058,  0.200504,  4.84,  1.49),   // 6159  29    Her\n         vec4(  4.334744, -1.377016,  3.89,  0.91),   // 6102    Gam Aps\n         vec4(  4.337508, -0.768735,  4.94,  0.05),   // 6155    Mu  Nor\n         vec4(  4.337595,  0.740664,   4.2, -0.01),   // 6168  35Sig Her\n         vec4(  4.345362, -0.492464,  2.82, -0.25),   // 6165  23Tau Sco\n         vec4(  4.346867,  0.923706,  5.08, -0.04),   // 6185  17    Dra\n         vec4(  4.347507, -0.615326,  4.16,  1.57),   // 6166           \n         vec4(  4.350925, -0.184433,  2.56,  0.02),   // 6175  13Zet Oph\n         vec4(  4.357863,  0.853961,   4.9,  1.55),   // 6200  42    Her\n         vec4(  4.367330,  1.127294,  4.83,  1.22),   // 6223  18    Dra\n         vec4(  4.368937,  0.551577,  2.81,  0.65),   // 6212  40Zet Her\n         vec4(  4.370188, -0.309660,  4.96,  1.11),   // 6196           \n         vec4(  4.375961,  0.679321,  3.53,  0.92),   // 6220  44Eta Her\n         vec4(  4.376747, -1.352936,  4.24,  1.06),   // 6163    Bet Aps\n         vec4(  4.386433,  0.991032,  4.85,  0.38),   // 6237           \n         vec4(  4.388769,  0.149793,  5.15,  1.53),   // 6228  43    Her\n         vec4(  4.389365,  1.431819,  4.23,  0.89),   // 6322  22Eps UMi\n         vec4(  4.392413, -1.171286,  5.13, -0.08),   // 6204           \n         vec4(  4.401131, -1.204762,  1.92,  1.44),   // 6217    Alp TrA\n         vec4(  4.403625,  0.802561,  4.82,  0.09),   // 6254  52    Her\n         vec4(  4.406018, -1.030467,  3.76,  1.57),   // 6229    Eta Ara\n         vec4(  4.406230, -0.188200,  4.65,  0.47),   // 6243  20    Oph\n         vec4(  4.407670, -0.598532,  2.29,  1.15),   // 6241  26Eps Sco\n         vec4(  4.414613,  0.430335,  5.04,  1.25),   // 6270  51    Her\n         vec4(  4.415116, -0.664054,  3.08,  -0.2),   // 6247    Mu 1Sco\n         vec4(  4.417145, -0.663531,  3.57, -0.21),   // 6252    Mu 2Sco\n         vec4(  4.424388, -0.739360,  4.73,  0.49),   // 6262    Zet1Sco\n         vec4(  4.424447,  0.177418,  4.38, -0.08),   // 6281  25Iot Oph\n         vec4(  4.426954, -0.739346,  3.62,  1.37),   // 6271    Zet2Sco\n         vec4(  4.433261,  1.136815,  4.89,  0.48),   // 6315  19    Dra\n         vec4(  4.440416,  0.163625,   3.2,  1.15),   // 6299  27Kap Oph\n         vec4(  4.444568, -0.977215,  3.13,   1.6),   // 6285    Zet Ara\n         vec4(  4.448778, -0.927827,  4.06,  1.45),   // 6295    Eps1Ara\n         vec4(  4.451854,  0.539767,  3.92, -0.01),   // 6324  58Eps Her\n         vec4(  4.455216, -0.073697,  4.82,  1.48),   // 6318  30    Oph\n         vec4(  4.458786, -0.561012,  5.03,  -0.1),   // 6316           \n         vec4(  4.464248,  0.245951,  4.98,   1.6),   // 6337           \n         vec4(  4.471636, -0.595555,  4.87,  0.26),   // 6334           \n         vec4(  4.474057,  0.222369,  4.91,  0.12),   // 6355  60    Her\n         vec4(  4.488928,  1.146938,  3.17, -0.12),   // 6396  22Zet Dra\n         vec4(  4.492281,  0.711697,  5.08,  1.28),   // 6388           \n         vec4(  4.495873, -0.274448,  2.43,  0.06),   // 6378  35Eta Oph\n         vec4(  4.497300, -0.777675,  5.08,  0.86),   // 6371           \n         vec4(  4.503620, -0.754666,  3.33,  0.41),   // 6380    Eta Sco\n         vec4(  4.514506,  0.251158,  3.48,  1.44),   // 6406  64Alp1Her\n         vec4(  4.516179,  0.433525,  3.14,  0.08),   // 6410  65Del Her\n         vec4(  4.516244,  0.642441,  3.16,  1.44),   // 6418  67Pi  Her\n         vec4(  4.517553, -0.464282,  5.07,  0.85),   // 6402  36    Oph\n         vec4(  4.517566, -0.464306,  5.11,  0.86),   // 6401  36    Oph\n         vec4(  4.523071, -0.007772,  4.73,  1.14),   // 6415  41    Oph\n         vec4(  4.526184,  0.577704,  4.82, -0.17),   // 6431  68    Her\n         vec4(  4.527698,  0.650862,  4.65,  0.05),   // 6436  69    Her\n         vec4(  4.531821,  0.189620,  5.03,  1.55),   // 6433           \n         vec4(  4.539229,  0.315158,     5,  1.62),   // 6452           \n         vec4(  4.541471, -0.224221,  4.33,  0.03),   // 6446  53Nu  Ser\n         vec4(  4.541798,  0.427596,  5.12, -0.03),   // 6457  70    Her\n         vec4(  4.542235, -0.368488,  4.39,  0.39),   // 6445  40Xi  Oph\n         vec4(  4.546539, -1.182819,  4.78,  1.21),   // 6417    Zet Aps\n         vec4(  4.546626, -0.436323,  3.27, -0.22),   // 6453  42The Oph\n         vec4(  4.553927,  0.648317,  4.52, -0.03),   // 6485  75Rho Her\n         vec4(  4.556255, -0.770781,  5.12, -0.06),   // 6460           \n         vec4(  4.560983, -0.969181,  2.85,  1.46),   // 6461    Bet Ara\n         vec4(  4.561388, -0.983973,  3.34, -0.13),   // 6462    Gam Ara\n         vec4(  4.565650, -0.421938,  4.17,  0.28),   // 6486  44    Oph\n         vec4(  4.566284,  0.072262,  4.34,   1.5),   // 6498  49Sig Oph\n         vec4(  4.566792, -0.088779,  4.54,  0.39),   // 6493           \n         vec4(  4.569949, -0.521276,  4.29,   0.4),   // 6492  45    Oph\n         vec4(  4.583379,  0.912832,  2.79,  0.98),   // 6536  23Bet Dra\n         vec4(  4.584712,  0.455715,  4.41,  1.44),   // 6526  76Lam Her\n         vec4(  4.584819, -0.650935,  2.69, -0.22),   // 6508  34Ups Sco\n         vec4(  4.586283, -1.059134,  3.62,  -0.1),   // 6500    Del Ara\n         vec4(  4.587670, -0.418229,  4.81,     0),   // 6519  51    Oph\n         vec4(  4.589524, -0.870502,  2.95, -0.17),   // 6510    Alp Ara\n         vec4(  4.590063,  1.189180,  5.05,  1.08),   // 6566  27    Dra\n         vec4(  4.590988,  0.963145,  4.88,  0.26),   // 6554  24Nu 1Dra\n         vec4(  4.591155,  1.511218,  4.36,  0.02),   // 6789  23Del UMi\n         vec4(  4.591381,  0.962952,  4.87,  0.28),   // 6555  25Nu 2Dra\n         vec4(  4.597234, -0.647585,  1.63, -0.22),   // 6527  35Lam Sco\n         vec4(  4.603023,  0.219213,  2.08,  0.15),   // 6556  55Alp Oph\n         vec4(  4.606185, -0.811675,  4.59, -0.03),   // 6537   1Sig Ara\n         vec4(  4.610054, -0.674313,  4.29,  1.09),   // 6546           \n         vec4(  4.611822,  1.200055,   4.8,  0.43),   // 6596  28Ome Dra\n         vec4(  4.613429, -0.750453,  1.87,   0.4),   // 6553    The Sco\n         vec4(  4.614591, -0.268756,  3.54,  0.26),   // 6561  55Xi  Ser\n         vec4(  4.615720, -0.141701,  4.62,  0.11),   // 6567  57Mu  Oph\n         vec4(  4.622788,  0.802963,   3.8, -0.18),   // 6588  85Iot Her\n         vec4(  4.626838, -0.862464,  4.77,   0.4),   // 6569    Lam Ara\n         vec4(  4.631297, -0.224716,  4.26,  0.08),   // 6581  56Omi Ser\n         vec4(  4.633580,  1.259236,  4.58,  0.42),   // 6636  31Psi1Dra\n         vec4(  4.635980, -0.681202,  2.41, -0.22),   // 6580    Kap Sco\n         vec4(  4.640088, -0.378446,  4.87,  0.47),   // 6595  58    Oph\n         vec4(  4.640279,  0.079713,  2.77,  1.16),   // 6603  60Bet Oph\n         vec4(  4.643209, -0.904677,  5.15,   0.7),   // 6585    Mu  Ara\n         vec4(  4.650138, -1.129645,  3.62,  1.19),   // 6582    Eta Pav\n         vec4(  4.653304,  0.483815,  3.42,  0.75),   // 6623  86Mu  Her\n         vec4(  4.658110, -0.485740,  4.54,   0.8),   // 6616   3    Sgr\n         vec4(  4.658217, -0.700347,  3.03,  0.51),   // 6615    Iot1Sco\n         vec4(  4.659563,  0.047250,  3.75,  0.04),   // 6629  62Gam Oph\n         vec4(  4.663608,  0.447202,  5.12,  1.16),   // 6644  87    Her\n         vec4(  4.664705,  0.886298,  5.02,  0.02),   // 6656  30    Dra\n         vec4(  4.665155, -0.553328,  4.83, -0.04),   // 6628           \n         vec4(  4.666357,  1.343254,  5.04,  0.49),   // 6701  35    Dra\n         vec4(  4.668137, -0.646528,  3.21,  1.17),   // 6630           \n         vec4(  4.669569, -0.699712,  4.81,  0.26),   // 6631    Iot2Sco\n         vec4(  4.683162,  0.698272,  5.16,  1.18),   // 6677  90    Her\n         vec4(  4.684151,  0.992617,  3.75,  1.18),   // 6688  32Xi  Dra\n         vec4(  4.696042,  0.650145,  3.86,  1.35),   // 6695  91The Her\n         vec4(  4.697582,  0.898651,  2.23,  1.52),   // 6705  33Gam Dra\n         vec4(  4.698383, -0.773918,  4.86,  1.21),   // 6675           \n         vec4(  4.702637,  0.510470,   3.7,  0.94),   // 6703  92Xi  Her\n         vec4(  4.702768, -0.728083,  4.88,  1.65),   // 6682           \n         vec4(  4.705860,  0.526905,  4.41,  0.39),   // 6707  94Nu  Her\n         vec4(  4.708143, -0.170582,  3.34,  0.99),   // 6698  64Nu  Oph\n         vec4(  4.708404, -0.528015,  5.16,  1.77),   // 6693           \n         vec4(  4.711488, -0.415670,  4.76, -0.04),   // 6700   4    Sgr\n         vec4(  4.712636,  0.292357,  4.67,  1.26),   // 6713  93    Her\n         vec4(  4.713539,  0.076247,  4.64, -0.03),   // 6712  66    Oph\n         vec4(  4.714499, -0.064408,  4.62,  0.38),   // 6710  57Zet Ser\n         vec4(  4.715203,  0.051167,  3.97,  0.02),   // 6714  67    Oph\n         vec4(  4.718963,  0.376914,  4.96,  0.12),   // 6730  95    Her\n         vec4(  4.720039,  0.022781,  4.45,  0.02),   // 6723  68    Oph\n         vec4(  4.734299, -0.516268,  4.69,  0.78),   // 6742    Gam1Sgr\n         vec4(  4.736192,  0.043623,  4.03,  0.86),   // 6752  70    Oph\n         vec4(  4.737734, -0.531002,  2.99,     1),   // 6746  10Gam2Sgr\n         vec4(  4.738708,  0.387793,  5.06,  1.58),   // 6765  98    Her\n         vec4(  4.741326, -0.874265,  3.66, -0.08),   // 6743    The Ara\n         vec4(  4.743041,  0.533406,  5.04,  0.52),   // 6775  99    Her\n         vec4(  4.744271,  0.152435,  4.64,  0.96),   // 6770  71    Oph\n         vec4(  4.744460,  0.166921,  3.73,  0.12),   // 6771  72    Oph\n         vec4(  4.745028,  0.758549,     5,  0.91),   // 6791           \n         vec4(  4.745302,  0.502000,  3.83, -0.03),   // 6779 103Omi Her\n         vec4(  4.747659, -0.496672,  4.57,  0.94),   // 6766           \n         vec4(  4.749826, -1.111222,  4.35,  0.22),   // 6745    Pi  Pav\n         vec4(  4.750604,  0.363281,  4.36, -0.16),   // 6787 102    Her\n         vec4(  4.751143,  0.349856,   5.1,  0.15),   // 6794 101    Her\n         vec4(  4.761390, -0.802056,  4.53,  1.01),   // 6783    Eps Tel\n         vec4(  4.763542, -0.413662,  4.98,  1.05),   // 6801  11    Sgr\n         vec4(  4.764328,  0.548126,  4.97,  1.65),   // 6815 104    Her\n         vec4(  4.772443, -0.367547,  3.86,  0.23),   // 6812  13Mu  Sgr\n         vec4(  4.773024,  1.123943,  5.03,  0.38),   // 6850  36    Dra\n         vec4(  4.789300, -0.641612,  3.11,  1.56),   // 6832    Eta Sgr\n         vec4(  4.791162, -0.471981,  4.65,  1.66),   // 6842           \n         vec4(  4.799053,  0.629443,  4.33,  1.17),   // 6872   1Kap Lyr\n         vec4(  4.800959,  0.383299,  4.95,  1.59),   // 6868 106    Her\n         vec4(  4.802964,  1.245079,  4.22,  -0.1),   // 6920  43Phi Dra\n         vec4(  4.803446,  0.058944,  4.86,  0.91),   // 6866  74    Oph\n         vec4(  4.803998, -0.520598,   2.7,  1.38),   // 6859  19Del Sgr\n         vec4(  4.804092,  0.503877,  5.12,   0.2),   // 6877 107    Her\n         vec4(  4.804265,  1.269427,  3.57,  0.49),   // 6927  44Chi Dra\n         vec4(  4.805372, -0.050595,  3.26,  0.94),   // 6869  58Eta Ser\n         vec4(  4.806396,  0.857335,  5.05,  1.66),   // 6891           \n         vec4(  4.809734, -0.674691,   5.1,  1.49),   // 6862           \n         vec4(  4.813734, -1.073271,  4.36,  1.48),   // 6855    Xi  Pav\n         vec4(  4.815619, -0.155931,  4.68,  0.95),   // 6884    Zet Sct\n         vec4(  4.815792,  0.379953,  3.84,  1.18),   // 6895 109    Her\n         vec4(  4.816708,  1.026263,  4.98,  0.08),   // 6923  39    Dra\n         vec4(  4.817858, -0.600127,  1.85, -0.03),   // 6879  20Eps Sgr\n         vec4(  4.818111,  0.689531,  5.12,  0.03),   // 6903   2Mu  Lyr\n         vec4(  4.822999, -0.358520,  4.81,  1.31),   // 6896  21    Sgr\n         vec4(  4.825769,  1.144301,  4.82,  1.19),   // 6945  42    Dra\n         vec4(  4.830084, -0.802299,  3.51, -0.17),   // 6897    Alp Tel\n         vec4(  4.834432, -0.443692,  2.81,  1.04),   // 6913  22Lam Sgr\n         vec4(  4.838192, -0.856448,  4.13,  1.02),   // 6905    Zet Tel\n         vec4(  4.839791, -0.254222,   4.7,  0.06),   // 6930    Gam Sct\n         vec4(  4.849281, -1.086962,  4.64, -0.11),   // 6916    Nu  Pav\n         vec4(  4.849564, -0.321189,  5.14,     0),   // 6944           \n         vec4(  4.850955, -0.801368,  4.96, -0.11),   // 6934    Del1Tel\n         vec4(  4.852161, -0.798614,  5.07, -0.14),   // 6938    Del2Tel\n         vec4(  4.853572, -0.692964,  5.16,  0.08),   // 6942           \n         vec4(  4.854525,  0.995633,  4.77,  0.61),   // 6978  45    Dra\n         vec4(  4.858575, -0.738492,  4.64,  1.01),   // 6951    The CrA\n         vec4(  4.865280, -0.191589,  5.14,  0.92),   // 6970           \n         vec4(  4.866008, -0.143888,  3.85,  1.33),   // 6973    Alp Sct\n         vec4(  4.873563,  0.676902,  0.03,     0),   // 7001   3Alp Lyr\n         vec4(  4.896842, -0.157996,  4.72,  0.35),   // 7020    Del Sct\n         vec4(  4.898406,  0.969346,  5.04, -0.09),   // 7049  46    Dra\n         vec4(  4.900165, -1.246655,  4.01,  1.14),   // 6982    Zet Pav\n         vec4(  4.902288, -0.144431,   4.9,  1.12),   // 7032    Eps Sct\n         vec4(  4.903422, -0.668873,  5.13,  0.09),   // 7021    Lam CrA\n         vec4(  4.905786, -0.622069,  4.87, -0.18),   // 7029           \n         vec4(  4.905859,  0.692372,  5.06,  0.16),   // 7051   4Eps1Lyr\n         vec4(  4.906040,  0.691378,  5.14,  0.19),   // 7053   5Eps2Lyr\n         vec4(  4.907749,  0.656331,  4.36,  0.19),   // 7056   6Zet1Lyr\n         vec4(  4.908003,  0.035954,  5.02, -0.06),   // 7040   4    Aql\n         vec4(  4.910694, -1.132219,  4.79,   0.2),   // 7012           \n         vec4(  4.911603, -0.471079,  3.17, -0.11),   // 7039  27Phi Sgr\n         vec4(  4.911626,  0.358602,  4.19,  0.46),   // 7061 110    Her\n         vec4(  4.913430,  0.465344,  4.83,   1.2),   // 7064           \n         vec4(  4.917559,  0.317325,  4.36,  0.13),   // 7069 111    Her\n         vec4(  4.918229, -0.082864,  4.22,   1.1),   // 7063    Bet Sct\n         vec4(  4.930905,  0.582290,  3.45,     0),   // 7106  10Bet Lyr\n         vec4(  4.935798,  1.036522,  4.66,  1.19),   // 7125  47Omi Dra\n         vec4(  4.940228, -1.085377,  4.22, -0.14),   // 7074    Lam Pav\n         vec4(  4.942163, -0.909447,  5.17,  0.94),   // 7087    Kap Tel\n         vec4(  4.944634,  0.885027,  4.92,   0.9),   // 7137           \n         vec4(  4.948750, -0.396975,  4.83,  1.41),   // 7116  32Nu 1Sgr\n         vec4(  4.949747,  1.244371,  4.82,  1.15),   // 7180  52Ups Dra\n         vec4(  4.950205,  0.644007,   4.3,  1.68),   // 7139  12Del2Lyr\n         vec4(  4.951142, -0.272325,   5.1,  0.17),   // 7119           \n         vec4(  4.951273,  0.395230,  4.59,  0.78),   // 7133 113    Her\n         vec4(  4.952888, -0.395690,  4.99,  1.33),   // 7120  35Nu 2Sgr\n         vec4(  4.953527, -0.458964,  2.02, -0.22),   // 7121  34Sig Sgr\n         vec4(  4.953834,  0.767004,  4.04,  1.59),   // 7157  13    Lyr\n         vec4(  4.957695,  0.073367,  4.62,  0.17),   // 7141  63The1Ser\n         vec4(  4.957797,  0.073338,  4.98,   0.2),   // 7142  63The2Ser\n         vec4(  4.960881, -1.173448,  4.44,  0.71),   // 7107    Kap Pav\n         vec4(  4.961368, -0.102034,  4.83,  1.08),   // 7149    Eta Sct\n         vec4(  4.962588, -0.360522,  5.08,  0.13),   // 7145  36Xi 1Sgr\n         vec4(  4.964284, -0.368381,  3.51,  1.18),   // 7150  37Xi 2Sgr\n         vec4(  4.967476, -0.923953,  4.87, -0.05),   // 7134    Lam Tel\n         vec4(  4.968110, -1.050698,  5.14,  1.37),   // 7127    Ome Pav\n         vec4(  4.968617, -0.647648,  4.87,  0.41),   // 7152    Eps CrA\n         vec4(  4.969578,  0.570538,  3.24, -0.05),   // 7178  14Gam Lyr\n         vec4(  4.972544,  0.262992,  4.02,  1.08),   // 7176  13Eps Aql\n         vec4(  4.974254,  0.561046,  4.93,  1.47),   // 7192  15Lam Lyr\n         vec4(  4.980472,  0.819165,  5.01,  0.19),   // 7215  16    Lyr\n         vec4(  4.981519, -0.100163,  4.02,  1.09),   // 7193  12    Aql\n         vec4(  4.985585, -0.521509,   2.6,  0.08),   // 7194  38Zet Sgr\n         vec4(  4.987781, -0.734701,  4.75, -0.02),   // 7188    Zet CrA\n         vec4(  4.994625, -0.379464,  3.77,  1.01),   // 7217  39Omi Sgr\n         vec4(  4.997795,  0.241961,  2.99,  0.01),   // 7235  17Zet Aql\n         vec4(  5.001452, -0.085216,  3.44, -0.09),   // 7236  16Lam Aql\n         vec4(  5.001816, -0.913520,  5.16,  0.53),   // 7213    Rho Tel\n         vec4(  5.002193, -0.646877,  4.93,  0.52),   // 7226    Gam CrA\n         vec4(  5.002193, -0.646877,  4.99,  0.52),   // 7227    Gam CrA\n         vec4(  5.004470, -0.482942,  3.32,  1.19),   // 7234  40Tau Sgr\n         vec4(  5.004631,  0.193232,  5.09, -0.07),   // 7248  18    Aql\n         vec4(  5.010615, -0.706800,  4.59,  1.09),   // 7242    Del CrA\n         vec4(  5.014170,  1.336234,  5.13,  0.31),   // 7312  59    Dra\n         vec4(  5.015516, -0.661557,  4.11,  0.04),   // 7254    Alp CrA\n         vec4(  5.016788, -0.366931,  2.89,  0.35),   // 7264  41Pi  Sgr\n         vec4(  5.017945, -0.686627,  4.11,   1.2),   // 7259    Bet CrA\n         vec4(  5.025129,  0.992380,  5.12,  1.01),   // 7295  53    Dra\n         vec4(  5.028970,  1.180919,  3.07,     1),   // 7310  57Del Dra\n         vec4(  5.034018,  0.040031,  5.15, -0.07),   // 7287  21    Aql\n         vec4(  5.034221,  0.683229,  4.39, -0.15),   // 7298  20Eta Lyr\n         vec4(  5.034926,  1.007142,  4.99,  1.16),   // 7309  54    Dra\n         vec4(  5.041995, -0.440812,  4.85,  0.56),   // 7292  42Psi Sgr\n         vec4(  5.042039,  1.280296,  4.45,  1.25),   // 7352  60Tau Dra\n         vec4(  5.044948,  0.373331,  4.77, -0.05),   // 7306   1    Vul\n         vec4(  5.045610,  0.665557,  4.36,  1.26),   // 7314  21The Lyr\n         vec4(  5.048817,  0.931458,  3.77,  0.96),   // 7328   1Kap Cyg\n         vec4(  5.051136, -0.330793,  4.96,  1.02),   // 7304  43    Sgr\n         vec4(  5.055092,  0.018942,   5.1,  1.15),   // 7319  23    Aql\n         vec4(  5.063847, -0.094524,  5.01,  0.92),   // 7333  26    Aql\n         vec4(  5.064370,  1.146938,  4.59,  0.02),   // 7371  58Pi  Dra\n         vec4(  5.068756, -0.311493,  3.93,  0.22),   // 7340  44Rho1Sgr\n         vec4(  5.068989, -0.278467,  4.61,   0.1),   // 7342  46Ups Sgr\n         vec4(  5.072968, -0.775954,  4.01,  -0.1),   // 7337    Bet1Sgr\n         vec4(  5.073897, -0.949871,  5.05,  0.02),   // 7329    Eta Tel\n         vec4(  5.075505, -0.781903,  4.29,  0.34),   // 7343    Bet2Sgr\n         vec4(  5.078413, -0.708885,  3.97,  -0.1),   // 7348    Alp Sgr\n         vec4(  5.079461,  0.516991,  4.97,  -0.1),   // 7372   2    Cyg\n         vec4(  5.083142,  0.208470,  5.16,  0.77),   // 7373  31    Aql\n         vec4(  5.084471, -0.427756,  5.03,  0.23),   // 7362  47Chi1Sgr\n         vec4(  5.085351,  0.345551,  5.16,  0.98),   // 7385   4    Vul\n         vec4(  5.085445,  0.054362,  3.36,  0.32),   // 7377  30Del Aql\n         vec4(  5.088296,  0.633865,  5.15, -0.12),   // 7395   4    Cyg\n         vec4(  5.089896,  0.005910,  4.66,   0.6),   // 7387  32Nu  Aql\n         vec4(  5.099439,  0.430485,  4.44,   1.5),   // 7405   6Alp Vul\n         vec4(  5.103800,  0.902854,  3.79,  0.14),   // 7420  10Iot2Cyg\n         vec4(  5.107984, -0.048675,  5.03,  1.75),   // 7414  36    Aql\n         vec4(  5.108238,  0.487989,  3.08,  1.13),   // 7417   6Bet1Cyg\n         vec4(  5.108382,  0.488086,  5.11,  -0.1),   // 7418   6Bet2Cyg\n         vec4(  5.112819,  0.601319,  4.74, -0.14),   // 7426   8    Cyg\n         vec4(  5.115385,  1.215816,  4.68,  0.79),   // 7462  61Sig Dra\n         vec4(  5.122935,  0.128786,  4.45,  1.17),   // 7429  38Mu  Aql\n         vec4(  5.125080,  0.345110,     5, -0.09),   // 7437   9    Vul\n         vec4(  5.127435, -0.184312,  5.12,  1.13),   // 7430  37    Aql\n         vec4(  5.127849, -0.839489,   4.9,  1.09),   // 7424    Iot Tel\n         vec4(  5.133195,  0.876524,  4.48,  0.38),   // 7469  13The Cyg\n         vec4(  5.134025,  0.780075,  5.17,  0.93),   // 7468           \n         vec4(  5.134352, -0.434301,   4.6, -0.07),   // 7440  52    Sgr\n         vec4(  5.134418, -0.022452,  4.36, -0.08),   // 7447  41Iot Aql\n         vec4(  5.135159, -0.122653,  4.95,     0),   // 7446  39Kap Aql\n         vec4(  5.145201,  0.094209,  5.17,  0.03),   // 7474  44Sig Aql\n         vec4(  5.146002,  0.526275,  4.69,  0.97),   // 7478  12Phi Cyg\n         vec4(  5.149144,  0.314402,  4.37,  0.78),   // 7479   5Alp Sge\n         vec4(  5.152372,  0.794561,  5.06,   0.4),   // 7495           \n         vec4(  5.153296,  0.305016,  4.37,  1.05),   // 7488   6Bet Sge\n         vec4(  5.159710, -0.281415,  5.06,  0.33),   // 7489  55    Sgr\n         vec4(  5.167381,  0.651958,  4.89,  0.95),   // 7517  15    Cyg\n         vec4(  5.170428,  0.787682,  2.87, -0.03),   // 7528  18Del Cyg\n         vec4(  5.176036,  0.185238,  2.72,  1.52),   // 7525  50Gam Aql\n         vec4(  5.176478, -0.344896,  4.86,  0.93),   // 7515  56    Sgr\n         vec4(  5.176764,  0.588661,  4.99,  0.47),   // 7534  17    Cyg\n         vec4(  5.180960,  0.323482,  3.82,  1.41),   // 7536   7Del Sge\n         vec4(  5.184385,  1.226404,  3.83,  0.89),   // 7582  63Eps Dra\n         vec4(  5.187898,  0.334095,     5,   0.1),   // 7546   8Zet Sge\n         vec4(  5.194820,  0.574461,  4.23,  1.82),   // 7564    Chi Cyg\n         vec4(  5.194828,  0.675835,  5.12,  1.69),   // 7566  19    Cyg\n         vec4(  5.195097,  0.924816,  5.03,  1.28),   // 7576  20    Cyg\n         vec4(  5.195773,  0.154782,  0.77,  0.22),   // 7557  53Alp Aql\n         vec4(  5.196833,  0.181786,  5.11,  0.55),   // 7560  54Omi Aql\n         vec4(  5.197016,  0.394619,  4.95, -0.14),   // 7565  12    Vul\n         vec4(  5.203147,  0.017550,   3.9,  0.89),   // 7570  55Eta Aql\n         vec4(  5.206711,  1.003976,  5.14, -0.13),   // 7608  23    Cyg\n         vec4(  5.207459,  0.420270,  4.58, -0.06),   // 7592  13    Vul\n         vec4(  5.210892,  0.147679,  4.71,  1.05),   // 7595  59Xi  Aql\n         vec4(  5.215313, -0.730740,  4.13,  1.08),   // 7581    Iot Sgr\n         vec4(  5.215539,  0.111817,  3.71,  0.86),   // 7602  60Bet Aql\n         vec4(  5.216921,  0.915231,  4.92,  0.12),   // 7619  24Psi Cyg\n         vec4(  5.217837, -0.459012,   4.7,  0.75),   // 7597  58Ome Sgr\n         vec4(  5.217932,  0.671719,  4.94, -0.08),   // 7613  22    Cyg\n         vec4(  5.218201,  1.027058,  4.96,  1.59),   // 7633           \n         vec4(  5.219872,  0.612320,  3.89,  1.02),   // 7615  21Eta Cyg\n         vec4(  5.222665, -0.474206,  4.52,  1.46),   // 7604  59    Sgr\n         vec4(  5.227042, -0.270376,  5.02,  0.05),   // 7614  61    Sgr\n         vec4(  5.230564,  0.340203,  3.47,  1.57),   // 7635  12Gam Sge\n         vec4(  5.231422, -0.457199,  4.83,   0.9),   // 7618  60    Sgr\n         vec4(  5.234838, -0.615689,  4.37, -0.15),   // 7623    The1Sgr\n         vec4(  5.238569, -1.272529,  3.96, -0.03),   // 7590    Eps Pav\n         vec4(  5.240795,  0.484392,  4.64,  0.18),   // 7653  15    Vul\n         vec4(  5.241923,  0.874492,  5.05,  1.11),   // 7660  26    Cyg\n         vec4(  5.243601, -1.036309,  5.13,  1.53),   // 7625           \n         vec4(  5.247588, -0.483626,  4.58,  1.65),   // 7650  62    Sgr\n         vec4(  5.248285,  1.184618,  4.51,  1.32),   // 7685  67Rho Dra\n         vec4(  5.251515, -0.662192,  4.77,  1.41),   // 7652           \n         vec4(  5.254866, -0.559490,  4.99,  1.21),   // 7659           \n         vec4(  5.258495,  0.348911,   5.1,  1.06),   // 7679  16Eta Sge\n         vec4(  5.266050,  0.412150,  5.07, -0.18),   // 7688  17    Vul\n         vec4(  5.268218, -0.922945,  4.94,  1.62),   // 7673    Xi  Tel\n         vec4(  5.274064, -1.155093,  3.56,  0.76),   // 7665    Del Pav\n         vec4(  5.274771,  1.356320,  4.39, -0.05),   // 7750   1Kap Cep\n         vec4(  5.277119,  0.642974,  4.93, -0.13),   // 7708  28    Cyg\n         vec4(  5.285316, -0.014336,  3.23, -0.07),   // 7710  65The Aql\n         vec4(  5.294021,  0.817090,  4.83,  0.09),   // 7730  30    Cyg\n         vec4(  5.294450,  0.987294,   4.3,  0.11),   // 7740  33    Cyg\n         vec4(  5.295466,  0.815791,  3.79,  1.28),   // 7735  31    Cyg\n         vec4(  5.298129,  0.500817,  5.18,  0.18),   // 7731  21    Vul\n         vec4(  5.298280,  0.265246,  4.95,  0.08),   // 7724  67Rho Aql\n         vec4(  5.299401,  0.642393,  4.97,  0.14),   // 7736  29    Cyg\n         vec4(  5.302595,  0.446664,  4.78, -0.18),   // 7739           \n         vec4(  5.303495,  0.832774,  3.98,  1.52),   // 7751  32    Cyg\n         vec4(  5.303634,  0.410303,  5.15,  1.04),   // 7741  22    Vul\n         vec4(  5.304791,  0.485449,  4.52,  1.26),   // 7744  23    Vul\n         vec4(  5.312994, -0.218312,  4.24,  1.07),   // 7747   5Alp1Cap\n         vec4(  5.313596,  0.663802,  4.81,  0.42),   // 7763  34    Cyg\n         vec4(  5.314769, -0.218947,  3.57,  0.94),   // 7754   6Alp2Cap\n         vec4(  5.317371,  0.610565,  5.17,  0.65),   // 7770  35    Cyg\n         vec4(  5.326149, -0.222690,  4.76, -0.05),   // 7773   8Nu  Cap\n         vec4(  5.327667, -0.257984,  3.08,  0.79),   // 7776   9Bet Cap\n         vec4(  5.332977,  0.702612,   2.2,  0.68),   // 7796  37Gam Cyg\n         vec4(  5.340103,  0.561822,  4.43,  1.33),   // 7806  39    Cyg\n         vec4(  5.347899, -0.990213,  1.94,  -0.2),   // 7790    Alp Pav\n         vec4(  5.361914, -0.310906,  4.78,  0.38),   // 7822  11Rho Cap\n         vec4(  5.364248,  0.530032,  4.01,   0.4),   // 7834  41    Cyg\n         vec4(  5.365063,  1.099456,  4.22,   0.2),   // 7850   2The Cep\n         vec4(  5.365361, -0.050363,  4.91,  1.15),   // 7831  69    Aql\n         vec4(  5.367142,  0.854368,  4.95, -0.09),   // 7844  45Ome1Cyg\n         vec4(  5.380909,  0.197280,  4.03, -0.13),   // 7852   2Eps Del\n         vec4(  5.383920,  0.615243,  4.61,   1.6),   // 7866  47    Cyg\n         vec4(  5.383986, -0.776953,  5.11,  1.01),   // 7846    Nu  Mic\n         vec4(  5.390049,  0.256113,  4.68,  0.11),   // 7871   4Zet Del\n         vec4(  5.391235, -1.057350,  4.76,  0.28),   // 7848    Phi1Pav\n         vec4(  5.396238, -0.044506,  4.89,   1.6),   // 7873  70    Aql\n         vec4(  5.399830,  0.254736,  3.63,  0.44),   // 7882   6Bet Del\n         vec4(  5.399903, -0.825390,  3.11,     1),   // 7869    Alp Ind\n         vec4(  5.399998, -1.073901,  4.88,  0.43),   // 7859    Rho Pav\n         vec4(  5.403269, -0.019291,  4.32,  0.95),   // 7884  71    Aql\n         vec4(  5.404071,  0.370029,  4.82, -0.02),   // 7891  29    Vul\n         vec4(  5.404113,  0.420906,  5.04, -0.14),   // 7894  28    Vul\n         vec4(  5.406725,  0.176036,  5.05,  0.72),   // 7896   7Kap Del\n         vec4(  5.407969,  0.008489,  5.16,  1.06),   // 7897   1    Aqr\n         vec4(  5.408943,  0.277716,  3.77, -0.06),   // 7906   9Alp Del\n         vec4(  5.410711, -1.056777,  5.12,  0.53),   // 7875    Phi2Pav\n         vec4(  5.410738, -0.316578,   5.1,  1.66),   // 7900  15Ups Cap\n         vec4(  5.416769,  0.790290,  1.25,  0.09),   // 7924  50Alp Cyg\n         vec4(  5.419035, -1.165196,  5.15, -0.06),   // 7881    Ups Pav\n         vec4(  5.425611,  0.263099,  4.43,  0.32),   // 7928  11Del Del\n         vec4(  5.428141, -0.906194,  4.51,  0.27),   // 7920    Eta Ind\n         vec4(  5.431793,  0.441054,  4.91,  1.18),   // 7939  30    Vul\n         vec4(  5.432157, -1.155461,  3.42,  0.16),   // 7913    Bet Pav\n         vec4(  5.433602,  1.079292,  3.43,  0.92),   // 7957   3Eta Cep\n         vec4(  5.433872,  1.004956,  4.51,  0.54),   // 7955           \n         vec4(  5.435225,  0.536160,  4.22,  1.05),   // 7942  52    Cyg\n         vec4(  5.437115, -0.441059,  4.14,  0.43),   // 7936  16Psi Cap\n         vec4(  5.437623,  0.592893,  2.46,  1.03),   // 7949  53Eps Cyg\n         vec4(  5.439516,  0.281425,  5.14,  0.49),   // 7947  12Gam1Del\n         vec4(  5.439573,  0.281420,  4.27,  1.04),   // 7948  12Gam2Del\n         vec4(  5.441848,  0.599942,  4.92,  1.32),   // 7956           \n         vec4(  5.442846,  0.636885,  4.53, -0.11),   // 7963  54Lam Cyg\n         vec4(  5.444016, -0.165734,  3.77,     0),   // 7950   2Eps Aqr\n         vec4(  5.444278, -0.087751,  4.42,  1.65),   // 7951   3    Aqr\n         vec4(  5.447550, -0.767746,  5.11,  0.35),   // 7943    Iot Mic\n         vec4(  5.449522,  0.804844,  4.84,  0.41),   // 7977  55    Cyg\n         vec4(  5.451899, -0.806812,  4.89,  1.52),   // 7952    Zet Ind\n         vec4(  5.454017, -0.589567,   4.9,     1),   // 7965    Alp Mic\n         vec4(  5.454509,  0.768982,  5.04,   0.2),   // 7984  56    Cyg\n         vec4(  5.460706, -0.900735,  5.05,  1.13),   // 7968    Iot Ind\n         vec4(  5.462101, -0.469828,  4.11,  1.64),   // 7980  18Ome Cap\n         vec4(  5.463442,  0.472931,  4.59,  0.83),   // 7995  31    Vul\n         vec4(  5.465733, -0.156789,  4.73,  0.32),   // 7990   6Mu  Aqr\n         vec4(  5.468319,  0.774703,  4.78, -0.14),   // 8001  57    Cyg\n         vec4(  5.474050,  0.489696,  5.01,  1.48),   // 8008  32    Vul\n         vec4(  5.475142, -1.020218,  3.65,  1.25),   // 7986    Bet Ind\n         vec4(  5.478640,  0.239483,  5.17,  1.12),   // 8011  17    Del\n         vec4(  5.485454,  0.718504,  3.94,  0.02),   // 8028  58Nu  Cyg\n         vec4(  5.497031,  0.829400,  4.74, -0.05),   // 8047  59    Cyg\n         vec4(  5.503424, -0.563004,  4.67,  0.89),   // 8039    Gam Mic\n         vec4(  5.517008, -0.346535,  4.84,  0.17),   // 8060  22Eta Cap\n         vec4(  5.518367, -1.344321,  5.15,  0.49),   // 8021    Alp Oct\n         vec4(  5.519304,  0.766684,  3.72,  1.65),   // 8079  62Xi  Cyg\n         vec4(  5.520638, -0.955170,  5.16,  1.21),   // 8055    Mu  Ind\n         vec4(  5.523735, -0.300769,  4.07, -0.01),   // 8075  23The Cap\n         vec4(  5.526593,  0.831620,  4.55,  1.57),   // 8089  63    Cyg\n         vec4(  5.528892, -0.436434,   4.5,  1.61),   // 8080  24    Cap\n         vec4(  5.539654, -0.198473,  4.51,  0.94),   // 8093  13Nu  Aqr\n         vec4(  5.542911,  0.176831,  4.69,  0.26),   // 8097   5Gam Equ\n         vec4(  5.554234,  0.527560,   3.2,  0.99),   // 8115  64Zet Cyg\n         vec4(  5.556001, -1.223936,  5.02,  1.58),   // 8092    Omi Pav\n         vec4(  5.560976,  0.174654,  4.49,   0.5),   // 8123   7Del Equ\n         vec4(  5.562329,  0.664020,  3.72,  0.39),   // 8130  65Tau Cyg\n         vec4(  5.566829,  0.091591,  3.92,  0.53),   // 8131   8Alp Equ\n         vec4(  5.573782,  0.687568,  4.23,  0.12),   // 8143  67Sig Cyg\n         vec4(  5.575971,  0.609066,  4.43, -0.11),   // 8146  66Ups Cyg\n         vec4(  5.576057, -0.561516,  4.71,  0.06),   // 8135    Eps Mic\n         vec4(  5.578306,  0.766999,     5, -0.01),   // 8154  68    Cyg\n         vec4(  5.578859,  1.092324,  2.44,  0.22),   // 8162   5Alp Cep\n         vec4(  5.584471, -0.932874,  4.39,  0.19),   // 8140    The Ind\n         vec4(  5.588370, -0.712264,  4.82,  0.02),   // 8151    The1Mic\n         vec4(  5.594158,  0.345653,  4.08,  1.11),   // 8173   1    Peg\n         vec4(  5.594858, -0.293816,  4.28,   0.9),   // 8167  32Iot Cap\n         vec4(  5.597679,  0.118876,  5.16,  0.05),   // 8178  10Bet Equ\n         vec4(  5.613167, -1.140854,  4.22,  0.49),   // 8181    Gam Pav\n         vec4(  5.614141, -0.391153,  3.74,     1),   // 8204  34Zet Cap\n         vec4(  5.622841,  1.231519,  3.23, -0.22),   // 8238   8Bet Cep\n         vec4(  5.623116, -0.380608,  4.51,  0.91),   // 8213  36    Cap\n         vec4(  5.628462,  0.412576,  4.57,  1.62),   // 8225   2    Peg\n         vec4(  5.635486, -0.097234,  2.91,  0.83),   // 8232  22Bet Aqr\n         vec4(  5.646060,  0.795730,  4.02,  0.89),   // 8252  73Rho Cyg\n         vec4(  5.649529,  0.672548,   4.9,  1.08),   // 8255  72    Cyg\n         vec4(  5.659011,  0.705351,  5.01,  0.18),   // 8266  74    Cyg\n         vec4(  5.659580, -0.339748,  4.68, -0.17),   // 8260  39Eps Cap\n         vec4(  5.662509, -0.137081,  4.69,  0.17),   // 8264  23Xi  Aqr\n         vec4(  5.663244,  1.083534,  4.73,   0.3),   // 8279   9    Cep\n         vec4(  5.670378,  0.039158,   5.1,  1.04),   // 8277  25    Aqr\n         vec4(  5.672719, -0.290811,  3.68,  0.32),   // 8278  40Gam Cap\n         vec4(  5.673128,  0.755272,  5.11,   1.6),   // 8284  75    Cyg\n         vec4(  5.678756, -1.350710,  3.76,     1),   // 8254    Nu  Oct\n         vec4(  5.679076, -0.245175,  5.18,  0.65),   // 8283  42    Cap\n         vec4(  5.680704,  1.244619,  4.56,   1.1),   // 8317  11    Cep\n         vec4(  5.681461,  0.893429,  4.67, -0.12),   // 8301  80Pi 1Cyg\n         vec4(  5.683918, -0.329281,  4.73,  0.88),   // 8288  43Kap Cap\n         vec4(  5.685701,  1.262227,  5.17,  1.05),   // 8324           \n         vec4(  5.687620,  1.025905,  4.08,  2.35),   // 8316    Mu  Cep\n         vec4(  5.690399,  0.501656,  4.73,  0.48),   // 8309  78Mu 1Cyg\n         vec4(  5.690587,  0.172351,  2.39,  1.53),   // 8308   8Eps Peg\n         vec4(  5.692006,  0.302815,  4.34,  1.17),   // 8313   9    Peg\n         vec4(  5.692587,  0.447590,  4.13,  0.43),   // 8315  10Kap Peg\n         vec4(  5.693903, -0.576409,  4.34, -0.05),   // 8305   9Iot PsA\n         vec4(  5.694158, -0.158520,  5.09,  1.11),   // 8311  46    Cap\n         vec4(  5.696092,  1.066760,  4.29,  0.52),   // 8334  10Nu  Cep\n         vec4(  5.701962,  0.860612,  4.23, -0.12),   // 8335  81Pi 2Cyg\n         vec4(  5.703038, -0.281473,  2.87,  0.29),   // 8322  49Del Cap\n         vec4(  5.706078, -0.539278,  5.01,  0.04),   // 8326  10The PsA\n         vec4(  5.715277,  0.526639,  5.04, -0.03),   // 8343  14    Peg\n         vec4(  5.729320,  0.452477,  5.08, -0.17),   // 8356  16    Peg\n         vec4(  5.730339, -0.236521,  5.08,  0.37),   // 8351  51Mu  Cap\n         vec4(  5.733095, -0.652142,  3.01, -0.12),   // 8353    Gam Gru\n         vec4(  5.744976,  1.110476,  4.91,  1.77),   // 8383           \n         vec4(  5.750505, -0.959800,   4.4,  0.28),   // 8368    Del Ind\n         vec4(  5.756314,  1.277232,  5.03,  0.44),   // 8400  16    Cep\n         vec4(  5.774051, -0.037617,  4.69, -0.06),   // 8402  31Omi Aqr\n         vec4(  5.774248, -0.991105,  4.69,  1.06),   // 8387    Eps Ind\n         vec4(  5.776124,  1.127967,  4.29,  0.34),   // 8417  17Xi  Cep\n         vec4(  5.782052,  1.086991,  5.11,  0.08),   // 8428  19    Cep\n         vec4(  5.784371,  0.088289,  4.84,  1.44),   // 8413  22Nu  Peg\n         vec4(  5.784821, -0.005580,  2.96,  0.98),   // 8414  34Alp Aqr\n         vec4(  5.785913,  0.785650,  5.14,  1.57),   // 8424           \n         vec4(  5.786269, -0.690161,  4.46,  1.37),   // 8411    Lam Gru\n         vec4(  5.787673, -0.242072,  4.27, -0.07),   // 8418  33Iot Aqr\n         vec4(  5.790180,  0.442354,  3.76,  0.44),   // 8430  24Iot Peg\n         vec4(  5.795511, -0.819626,  1.74, -0.13),   // 8425    Alp Gru\n         vec4(  5.796165, -0.575760,   4.5,  0.05),   // 8431  14Mu  PsA\n         vec4(  5.796385, -0.594178,  4.99,  1.48),   // 8433    Ups PsA\n         vec4(  5.802375,  1.262591,  4.79,  0.92),   // 8468  24    Cep\n         vec4(  5.803160,  0.579071,  4.29,  0.46),   // 8454  29Pi 2Peg\n         vec4(  5.803860, -0.568076,  4.92,  0.48),   // 8447  15Tau PsA\n         vec4(  5.804092,  0.108172,  3.53,  0.08),   // 8450  26The Peg\n         vec4(  5.806952,  1.015801,  3.35,  1.57),   // 8465  21Zet Cep\n         vec4(  5.809816,  1.036978,  5.04,  0.25),   // 8469  22Lam Cep\n         vec4(  5.820143,  0.693158,  4.49,  1.39),   // 8485           \n         vec4(  5.825183,  0.995599,  4.19,  0.28),   // 8494  23Eps Cep\n         vec4(  5.827720, -0.721636,  4.79,   0.8),   // 8486    Mu 1Gru\n         vec4(  5.829270,  0.658842,  4.13,  1.46),   // 8498   1    Lac\n         vec4(  5.831335, -0.726537,   5.1,  0.92),   // 8488    Mu 2Gru\n         vec4(  5.833037, -0.135845,  4.16,  0.98),   // 8499  43The Aqr\n         vec4(  5.840315, -1.051731,  2.86,  1.39),   // 8502    Alp Tuc\n         vec4(  5.846962, -1.403938,   5.1,  1.47),   // 8481    Eps Oct\n         vec4(  5.851332,  0.812218,  4.57,  -0.1),   // 8523   2    Lac\n         vec4(  5.852620,  0.494462,  4.81,     0),   // 8522  32    Peg\n         vec4(  5.853479,  0.213022,  5.01, -0.13),   // 8520  31    Peg\n         vec4(  5.853806, -0.376962,  5.13,  1.07),   // 8516  47    Aqr\n         vec4(  5.854081, -0.024212,  3.84, -0.05),   // 8518  48Gam Aqr\n         vec4(  5.862387,  0.911571,  4.43,  1.02),   // 8538   3Bet Lac\n         vec4(  5.866560,  0.863526,  4.57,  0.09),   // 8541   4    Lac\n         vec4(  5.869877,  0.024042,  4.66, -0.03),   // 8539  52Pi  Aqr\n         vec4(  5.878852, -1.133878,  4.48, -0.03),   // 8540    Del Tuc\n         vec4(  5.881143,  0.081953,  4.79,  1.05),   // 8551  35    Peg\n         vec4(  5.885402, -0.000349,  4.42,  0.38),   // 8559  55Zet2Aqr\n         vec4(  5.886871,  1.019539,  3.75,   0.6),   // 8571  27Del Cep\n         vec4(  5.887300, -0.759141,  3.97,  1.03),   // 8556    Del1Gru\n         vec4(  5.888437,  0.832643,  4.36,  1.68),   // 8572   5    Lac\n         vec4(  5.889431, -0.763572,  4.11,  1.57),   // 8560    Del2Gru\n         vec4(  5.892618,  0.752644,  4.51, -0.09),   // 8579   6    Lac\n         vec4(  5.893309, -0.186367,  4.82, -0.06),   // 8573  57Sig Aqr\n         vec4(  5.896123,  0.877595,  3.77,  0.01),   // 8585   7Alp Lac\n         vec4(  5.897052, -0.564546,  4.29,  0.01),   // 8576  17Bet PsA\n         vec4(  5.903584, -1.081794,  4.81,  1.61),   // 8582    Nu  Tuc\n         vec4(  5.913860, -0.002051,  4.02, -0.09),   // 8597  62Eta Aqr\n         vec4(  5.915656,  1.285314,  5.08,  0.39),   // 8615  31    Cep\n         vec4(  5.922659,  0.899635,  4.63,  0.24),   // 8613   9    Lac\n         vec4(  5.924332, -0.073794,  5.03,  1.14),   // 8610  63Kap Aqr\n         vec4(  5.930897,  0.681556,  4.88,  -0.2),   // 8622  10    Lac\n         vec4(  5.936367,  0.772769,  4.46,  1.33),   // 8632  11    Lac\n         vec4(  5.936985, -0.472000,  4.17, -0.11),   // 8628  18Eps PsA\n         vec4(  5.940498,  0.189043,   3.4, -0.09),   // 8634  42Zet Peg\n         vec4(  5.941783,  0.511512,  4.79, -0.01),   // 8641  43Omi Peg\n         vec4(  5.945763, -0.818293,   2.1,   1.6),   // 8636    Bet Gru\n         vec4(  5.947216,  0.527463,  2.94,  0.86),   // 8650  44Eta Peg\n         vec4(  5.949391, -0.722818,  4.85,  1.03),   // 8644    Rho Gru\n         vec4(  5.949776, -0.328650,  4.69,  1.37),   // 8649  66    Aqr\n         vec4(  5.951972,  0.729882,  5.08,  0.96),   // 8656  13    Lac\n         vec4(  5.958693, -0.933756,  4.85,  1.18),   // 8655    Eta Gru\n         vec4(  5.960539, -1.420378,  4.15,   0.2),   // 8630    Bet Oct\n         vec4(  5.962620,  0.411297,  3.95,  1.07),   // 8667  47Lam Peg\n         vec4(  5.963324,  0.212455,  4.19,   0.5),   // 8665  46Xi  Peg\n         vec4(  5.966772,  1.451309,  4.74,  1.26),   // 8702           \n         vec4(  5.971447, -0.895650,  3.49,  0.08),   // 8675    Eps Gru\n         vec4(  5.975972, -0.237234,  4.01,  1.57),   // 8679  71Tau2Aqr\n         vec4(  5.976357,  1.155418,  3.52,  1.05),   // 8694  32Iot Cep\n         vec4(  5.977767,  0.429380,  3.48,  0.93),   // 8684  48Mu  Peg\n         vec4(  5.986624,  0.755946,  4.94,  1.56),   // 8699  15    Lac\n         vec4(  5.988232,  0.171663,  5.16,  0.48),   // 8697  49Sig Peg\n         vec4(  5.988777, -0.573787,  4.46, -0.04),   // 8695  22Gam PsA\n         vec4(  5.989164, -0.132291,  3.74,  1.64),   // 8698  73Lam Aqr\n         vec4(  5.997010,  1.472117,  4.71,  1.43),   // 8748           \n         vec4(  5.998041, -0.276126,  3.27,  0.05),   // 8709  76Del Aqr\n         vec4(  6.000565,  0.153865,   4.9,     0),   // 8717  50Rho Peg\n         vec4(  6.003706, -0.567925,  4.21,  0.97),   // 8720  23Del PsA\n         vec4(  6.005825,  0.868015,  4.95,  1.78),   // 8726           \n         vec4(  6.011139, -0.517005,  1.16,  0.09),   // 8728  24Alp PsA\n         vec4(  6.021758,  0.993883,     5,  1.42),   // 8752           \n         vec4(  6.025227, -0.920734,  4.12,  0.98),   // 8747    Zet Gru\n         vec4(  6.029772,  0.738730,  3.62, -0.09),   // 8762   1Omi And\n         vec4(  6.032753,  0.746264,   5.1,  0.09),   // 8766   2    And\n         vec4(  6.036644, -0.606492,  5.11,  0.29),   // 8767    Pi  PsA\n         vec4(  6.037858,  0.490137,  2.42,  1.67),   // 8775  53Bet Peg\n         vec4(  6.038301,  0.066672,  4.53, -0.12),   // 8773   4Bet Psc\n         vec4(  6.039639,  0.873576,  4.65,  1.06),   // 8780   3    And\n         vec4(  6.042162,  0.265382,  2.49, -0.04),   // 8781  54Alp Peg\n         vec4(  6.050250,  1.037070,  4.85, -0.03),   // 8797   1    Cas\n         vec4(  6.050540, -0.414395,  4.47,   0.9),   // 8789  86    Aqr\n         vec4(  6.051407, -0.759577,  4.28,  0.42),   // 8787    The Gru\n         vec4(  6.051951,  0.164226,  4.52,  1.57),   // 8795  55    Peg\n         vec4(  6.052425,  0.444506,  4.76,  1.34),   // 8796  56    Peg\n         vec4(  6.055849,  1.315760,  4.41,   0.8),   // 8819  33Pi  Cep\n         vec4(  6.062603, -0.369530,  3.66,  1.22),   // 8812  88    Aqr\n         vec4(  6.062947,  0.151446,  5.12,  1.47),   // 8815  57    Peg\n         vec4(  6.064641, -0.391957,  4.69,  0.65),   // 8817  89    Aqr\n         vec4(  6.066591, -0.789703,   3.9,  1.02),   // 8820    Iot Gru\n         vec4(  6.072597,  0.152193,  5.16,  0.13),   // 8826  59    Peg\n         vec4(  6.076147,  0.862304,  4.52,  0.29),   // 8830   7    And\n         vec4(  6.083883, -0.105573,  4.22,  1.56),   // 8834  90Phi Aqr\n         vec4(  6.090726, -0.158612,  4.21,  1.11),   // 8841  91Psi1Aqr\n         vec4(  6.094902, -0.134856,  5.06,   1.6),   // 8850  92Chi Aqr\n         vec4(  6.096282,  0.057286,  3.69,  0.92),   // 8852   6Gam Psc\n         vec4(  6.097439, -1.016407,  3.99,   0.4),   // 8848    Gam Tuc\n         vec4(  6.098814,  0.855478,  4.85,  1.67),   // 8860   8    And\n         vec4(  6.099504, -0.160265,  4.39, -0.15),   // 8858  93Psi2Aqr\n         vec4(  6.102654,  1.188773,  4.75,  0.84),   // 8872  34Omi Cep\n         vec4(  6.103518, -0.567789,  4.41,  1.13),   // 8863    Gam Scl\n         vec4(  6.104123, -0.167741,  4.98, -0.02),   // 8865  95Psi3Aqr\n         vec4(  6.104777, -0.234902,  5.08,   0.8),   // 8866  94    Aqr\n         vec4(  6.110152,  0.093923,  5.05,   1.2),   // 8878   7    Psc\n         vec4(  6.111430,  0.414346,   4.6,  0.17),   // 8880  62Tau Peg\n         vec4(  6.121611, -0.350821,  3.97,   1.1),   // 8892  98    Aqr\n         vec4(  6.122077,  0.214918,  5.08,  1.31),   // 8893  66    Peg\n         vec4(  6.129763,  1.087040,  4.98,  1.68),   // 8904   4    Cas\n         vec4(  6.132127,  0.408480,   4.4,  0.61),   // 8905  68Ups Peg\n         vec4(  6.135036, -0.360270,  4.39,  1.47),   // 8906  99    Aqr\n         vec4(  6.138905,  0.021914,  4.94,  0.03),   // 8911   8Kap Psc\n         vec4(  6.143421,  0.111333,  4.28,  1.07),   // 8916  10The Psc\n         vec4(  6.148600,  0.222714,  4.55,  0.94),   // 8923  70    Peg\n         vec4(  6.152433,  1.021871,  4.91, -0.12),   // 8926           \n         vec4(  6.165253, -0.660054,  4.37, -0.09),   // 8937    Bet Scl\n         vec4(  6.166583, -0.365026,  4.71,  0.02),   // 8939 101    Aqr\n         vec4(  6.169535,  0.546729,  4.98,  1.38),   // 8943  72    Peg\n         vec4(  6.174437, -0.743772,  4.71,  0.08),   // 8949    Iot Phe\n         vec4(  6.185293,  0.810846,  3.82,  1.01),   // 8961  16Lam And\n         vec4(  6.186537, -0.793994,  4.74,  0.08),   // 8959           \n         vec4(  6.187788,  0.755170,  4.29,  -0.1),   // 8965  17Iot And\n         vec4(  6.193069,  1.354943,  3.21,  1.03),   // 8974  35Gam Cep\n         vec4(  6.194980, -0.248215,     5,  0.24),   // 8968 102Ome1Aqr\n         vec4(  6.195700,  0.098199,  4.13,  0.51),   // 8969  17Iot Psc\n         vec4(  6.197700,  0.773772,  4.14, -0.08),   // 8976  19Kap And\n         vec4(  6.203614, -0.310955,  4.82,  0.82),   // 8982 104    Aqr\n         vec4(  6.204850,  0.031067,   4.5,   0.2),   // 8984  18Lam Psc\n         vec4(  6.207796, -0.253858,  4.49, -0.04),   // 8988 105Ome2Aqr\n         vec4(  6.210639,  0.180317,  5.06,  1.68),   // 8991  77    Peg\n         vec4(  6.213335,  0.512458,  4.93,  0.95),   // 8997  78    Peg\n         vec4(  6.222252,  0.810187,  4.95,  1.11),   // 9003  20Psi And\n         vec4(  6.223806,  0.060854,  5.04,   2.6),   // 9004  19    Psc\n         vec4(  6.226717,  1.023669,  4.87,  1.11),   // 9008   5Tau Cas\n         vec4(  6.230448,  1.183454,  5.04, -0.01),   // 9013           \n         vec4(  6.234868, -0.490966,  4.57,  0.01),   // 9016    Del Scl\n         vec4(  6.248743, -1.431500,  5.11,  0.92),   // 9032    Gam1Oct\n         vec4(  6.250411,  0.333712,  5.08,   1.6),   // 9036  81Phi Peg\n         vec4(  6.258678,  1.003555,  4.54,  1.22),   // 9045   7Rho Cas\n         vec4(  6.272656, -1.122218,     5,  0.06),   // 9062    Eta Tuc\n         vec4(  6.273405,  0.438800,  4.66,  1.59),   // 9064  84Psi Peg\n         vec4(  6.276264,  0.896901,   4.8,  1.83),   // 9066           \n         vec4(  6.277397, -0.062066,  4.86,  0.93),   // 9067  27    Psc\n         vec4(  6.278517, -0.920588,  5.13,  1.13),   // 9069    Pi  Phe\n         vec4(  6.278858,  0.973108,  4.88, -0.07),   // 9071   8Sig Cas\n         vec4(  6.280182,  0.119788,  4.01,  0.42),   // 9072  28Ome Psc\n         vec4(  6.282822, -1.144538,   4.5, -0.08)    // 9076    Eps Tuc\n);\n\nconst int nstars = stars.length();", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlSWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 313, 391, 609], [611, 611, 666, 666, 1912]], "test": "untested"}
{"id": "msfSW8", "name": "japao", "author": "GabrielKepecs", "description": "wiggle", "tags": ["japaoflamulando"], "likes": 0, "viewed": 122, "published": 3, "date": "1668781051", "time_retrieved": "2024-07-30T16:18:54.377717", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float wiggle = sin(iTime*2.0+uv.x)*0.08;\n    // Time varying pixel color\n    float x = length(vec2(uv.x*1.73,uv.y) - vec2(0.85, 0.5+wiggle));\n\n    // Output to screen\n    if(x<0.25)\n    fragColor = vec4(1.0,0,0.1,0);\n    else\n    fragColor = vec4(1,1,1,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 410]], "test": "untested"}
{"id": "dsfSW8", "name": "franca", "author": "GabrielKepecs", "description": "franca", "tags": ["wiggle"], "likes": 0, "viewed": 104, "published": 3, "date": "1668780638", "time_retrieved": "2024-07-30T16:18:55.285290", "image_code": "float shadow(float time, vec2 uv)\n{\n    float velx=1.0;\n    float freqx=1.0;\n    float vely=1.0;\n    float freqy=0.5;\n    float timeshiftx = cos(iTime*velx) + (uv.x*freqx);\n    float timeshifty = sin(iTime*vely) + (uv.y*freqy);\n    float shadow = 0.5+(timeshiftx)*(timeshifty)*0.5;\n    return shadow;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float wiggle = sin(iTime*2.0+uv.y)*0.06;\n\n    // Output to screen\n    if(uv.x>0.7+wiggle)\n    {\n      fragColor = vec4(1.0,0,0.1,0)*shadow(iTime,uv);\n    }\n    else\n    {\n      fragColor = vec4(1,1,1,1)*shadow(iTime,uv);\n    }\n    if(uv.x<0.3+wiggle)\n    {\n      fragColor = vec4(0,0,0.9,0)*shadow(iTime,uv);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 302], [303, 303, 360, 410, 772]], "test": "untested"}
{"id": "DsfXDH", "name": "perlin and worley", "author": "Lincac", "description": "perlin and worley", "tags": ["2dnoise"], "likes": 0, "viewed": 59, "published": 3, "date": "1668778900", "time_retrieved": "2024-07-30T16:18:56.240736", "image_code": "#define scale 8.\n\nfloat perlin(vec2 p){\n    vec2 i = floor(p); // 返回一个值等于或小于参数的最接近的整数 获取网格索引\n    vec2 f = fract(p); // 返回一个值等于参数的小数部分  获取网格内位置\n\n    float p0 = random( i );\n    p0 = 0.5 + 0.5*sin( iTime + 6.2831*p0 );\n    float p1 = random( i + vec2( 1.0, 0.0 ));\n    p1 = 0.5 + 0.5*sin( iTime + 6.2831*p1 );\n    float p2 = random( i + vec2( 0.0, 1.0 ));\n    p2 = 0.5 + 0.5*sin( iTime + 6.2831*p2 );\n    float p3 = random( i + vec2( 1.0, 1.0 ));\n    p3 = 0.5 + 0.5*sin( iTime + 6.2831*p3 );\n\n    vec2 u = f*f*(3.0-2.0*f); // 差值系数\n\n    return mix(mix(p0,p1,u.x),mix(p2,p3,u.x),u.y); \n}\n\nfloat worley(vec2 p){\n    vec2 i = floor(p); // 返回一个值等于或小于参数的最接近的整数 获取网格索引\n    vec2 f = fract(p); // 返回一个值等于参数的小数部分  获取网格内位置\n\n    float feature = 1.0;\n    for(int m=-1;m<=1;m++){\n        for(int n=-1;n<=1;n++){\n            vec2 offset = vec2(float(m),float(n));\n            vec2 point = random22(i + offset); // 特征点位置\n            point = 0.5 + 0.5*sin( iTime + 6.2831*point );\n            float d = length(point + offset - f);\n            feature = min(feature,d);\n        }\n    }\n    return 1.0 - feature;\n}\n\nfloat fbm4_p(vec2 p){\n    float noiseValue = 0.0;\n\n    float a = 0.5;\n    float f = 0.8;\n\n    for (int i = 0; i < 5; i++) { // 四阶\n        noiseValue += a * perlin(p * f);\n\n        a *= 0.5;\n        f *= 2.0;\n    }\n\n    return noiseValue;\n}\n\nfloat fbm4_w(vec2 p){\n    float noiseValue = 0.0;\n\n    float a = 0.5;\n    float f = 0.8;\n\n    for (int i = 0; i < 5; i++) { // 四阶\n        noiseValue += a * worley(p * f);\n\n        a *= 0.5;\n        f *= 2.0;\n    }\n\n    return noiseValue;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= scale;\n    uv -= vec2(.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float p = perlin(uv);\n    float w = worley(uv);\n    \n    float _p_fbm4 = fbm4_p(uv);\n    float _w_fbm4 = fbm4_w(uv);\n    float pw = clamp(remap(_p_fbm4,_w_fbm4,1.0,0.0,1.0),0.,1.);\n    \n\tfragColor =  vec4(pw,pw,pw,1.);\n\t//fragColor =  vec4(p,p,p,1.);\n\t//fragColor =  vec4(w,w,w,1.);\n}", "image_inputs": [], "common_code": "float random(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec2 random2(vec2 p){\n    return fract(\n                sin(\n                    vec2(\n                        dot(p,vec2(127.9898,311.233)),\n                        dot(p,vec2(269.3265,124.7643))\n                    )\n                ) * 43758.5453123\n            ) * 2. - 1.;\n}\n\nvec2 random22(vec2 p)\n{\n    return fract(\n                sin(\n                    vec2(\n                        dot(p,vec2(127.9898,311.233)),\n                        dot(p,vec2(269.3265,183.7643))\n                    )\n                ) * 43758.5453123\n            );\n}\n\nfloat remap(float originalValue, float originalMin, float originalMax, float newMin, float newMax)\n{\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 39, 39, 683], [685, 685, 706, 706, 1295], [1297, 1297, 1318, 1318, 1540], [1542, 1542, 1563, 1563, 1785], [1787, 1787, 1842, 1842, 2256]], "test": "untested"}
{"id": "cdfSD8", "name": "Void And Cluster Bluenoise", "author": "krax", "description": "Port of a void and cluster implementation I did:\n[url]https://alister-chowdhury.github.io/posts/20221230-bluenoise-generator/[/url]\n\nSettings can be configured in Common (width, height, sigma)\n\nDoes one iteration per frame, so takes longer to converge.", "tags": ["noise", "bluenoise"], "likes": 7, "viewed": 402, "published": 3, "date": "1668763020", "time_retrieved": "2024-07-30T16:18:57.115398", "image_code": "#define TILE_SAMPLE 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if TILE_SAMPLE\n    ivec2 coord = ivec2(fract(gl_FragCoord.xy * textureSizeAndInvSize.zw) * textureSizeAndInvSize.xy);\n#else // TILE_SAMPLE\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    ivec2 coord = ivec2(uv * textureSizeAndInvSize.xy);\n#endif // TILE_SAMPLE\n\n    vec3 value = texelFetch(iChannel0, coord, 0).xxx;\n    fragColor = vec4(value, 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define bluenoiseWidth  64\n#define bluenoiseHeight 64\n#define sigma           1.9\n\n\n#define log2e           1.4426950408889634073599246810018\n\nconst int maxIterations = bluenoiseWidth * bluenoiseHeight - 1;\nconst float valueMultiplier = 1.0 / float(maxIterations);\nconst float expMultiplier = 1.0 / (sigma * sigma) * log2e;\nconst vec4 textureSizeAndInvSize = vec4(float(bluenoiseWidth),\n                                        float(bluenoiseHeight),\n                                        1.0 / float(bluenoiseWidth),\n                                        1.0 / float(bluenoiseHeight));\n\n\nuint simpleHash32(uvec3 Seed)\n{\n    uint hx = (0xb543c3a6u ^ Seed.x);\n    uint hy = (0x526f94e2u ^ Seed.y);\n    uint hxy = hx * hy;\n    uint hz0 = 0x53c5ca59u ^ (hxy >> 5u);\n    uint hz1 = (0x74743c1bu ^ Seed.z);\n    uint h = hz0 * hz1;\n    return h;\n}\n\n\n", "buffer_a_code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background\n// energy.\n\n\n// Uses the last 23bits to construct a (non-linear) range\n// [0, 1.17549421069e-38]\nfloat backgroundEnergyBounded(uint seed)\n{\n    return uintBitsToFloat(seed & 0x007fffffu);\n}\n\nfloat getBackgroundEnergy()\n{\n    uint backgroundEnergySeed = simpleHash32(floatBitsToUint(iDate.yzw)) ^ floatBitsToUint(iTime);\n    uint S = simpleHash32(uvec3(uvec2(gl_FragCoord.xy), uint(backgroundEnergySeed)));\n    return backgroundEnergyBounded(S);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(any(greaterThanEqual(gl_FragCoord.xy, textureSizeAndInvSize.xy)))\n    {\n        return;\n    }\n\n    if(iFrame == 0)\n    {\n        fragColor = vec2(0., getBackgroundEnergy()).xyxx;\n        return;\n    }\n    \n    vec2 prevValue = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0).xy;\n    if(iFrame > maxIterations)\n    {\n        fragColor = prevValue.xyxx;\n        return;\n    }\n    \n    // Get the result from downscaling and finding the smallest void\n    float value = 1.0 - (valueMultiplier * float(iFrame - 1));\n    vec2 target = texelFetch(iChannel1, ivec2(0, 0), 0).yz;\n    vec2 coord = vec2(floor(gl_FragCoord.xy));\n    float noise = all(equal(target, coord)) ? value : 0.;\n\n    // Wrap around logic\n    vec2 delta = fract(abs(coord - target) * textureSizeAndInvSize.zw);\n    delta = 0.5 - abs(delta - 0.5);\n    delta *= textureSizeAndInvSize.xy;\n    float energy = exp2(-dot(delta, delta) * expMultiplier) * value;\n\n    noise += prevValue.x;\n    energy += prevValue.y;\n\n    fragColor = vec2(noise, energy).xyxx;\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Void and cluster reduce init\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 maxSize = uvec2(bluenoiseWidth, bluenoiseHeight);\n    uint seed = simpleHash32(floatBitsToUint(iDate.yzw)) ^ uint(iFrame);\n\n    uvec2 voidCoord = uvec2(0, 0);\n    float voidValue = 1e+35;\n\n    uvec2 start = min(uvec2(gl_FragCoord.xy) << 3u, maxSize - 1u);\n    uvec2 end = min(start + uvec2(8u, 8u), maxSize);\n\n    // Reduce 8x8 at a time, but mix up the order of comparison\n    // to prevent biasing in any one location\n    uint yh = simpleHash32(uvec3(start + 1u, seed)) >> 20u;\n    uint xh = simpleHash32(uvec3(start + uvec2(13u, 11u), yh)) >> 19u;\n   \n    for(uint yit=0u; yit < 8u; ++yit)\n    {\n        uint y = start.y + ((yh ^ yit) & 7u);\n        if(y >= end.y) { continue; }\n\n        for(uint xit=0u; xit < 8u; ++xit)\n        {\n            uint x = start.x + ((xh ^ xit) & 7u);\n            if(x >= end.x) { continue; }\n            \n            uvec2 coord = uvec2(x, y);\n            vec2 noiseEnergy = texelFetch(iChannel0, ivec2(coord), 0).xy;\n            if((noiseEnergy.x == 0.) && (noiseEnergy.y < voidValue))\n            {\n                voidValue = noiseEnergy.y;\n                voidCoord = coord;\n            }\n        }\n    }\n\n    vec2 outVoidData = vec2(voidValue,\n                            uintBitsToFloat(voidCoord.x | (voidCoord.y << 16)));\n\n    fragColor = outVoidData.xyxx;\n    fragColor = vec3(voidValue, vec2(voidCoord)).xyzx;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Void and cluster reduce iteration\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 maxSize = uvec2(bluenoiseWidth, bluenoiseHeight);\n    maxSize.x = (maxSize.x + 7u) / 8u;\n    maxSize.y = (maxSize.y + 7u) / 8u;\n    \n    uint seed = simpleHash32(floatBitsToUint(iDate.yzw * iTime)) ^ uint(iFrame);\n\n    vec2 packedVoidCoord = vec2(0.);\n    float voidValue = 1e+35;\n\n    uvec2 start = min(uvec2(gl_FragCoord.xy) << 3u, maxSize - 1u);\n    uvec2 end = min(start + uvec2(8u, 8u), maxSize);\n\n    // Reduce 8x8 at a time, but mix up the order of comparison\n    // to prevent biasing in any one location\n    uint yh = simpleHash32(uvec3(start + 1u, seed)) >> 20u;\n    uint xh = simpleHash32(uvec3(start + uvec2(13u, 11u), yh)) >> 19u;\n   \n    for(uint yit=0u; yit < 8u; ++yit)\n    {\n        uint y = start.y + ((yh ^ yit) & 7u);\n        if(y >= end.y) { continue; }\n\n        for(uint xit=0u; xit < 8u; ++xit)\n        {\n            uint x = start.x + ((xh ^ xit) & 7u);\n            if(x >= end.x) { continue; }\n            \n            uvec2 coord = uvec2(x, y);\n            vec3 packedData = texelFetch(iChannel0, ivec2(coord), 0).xyz;\n            if(packedData.x < voidValue)\n            {\n                voidValue = packedData.x;\n                packedVoidCoord = packedData.yz;\n            }\n        }\n    }\n\n    vec3 outVoidData = vec3(voidValue, packedVoidCoord);\n\n    fragColor = outVoidData.xyzx;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Final reduction, no 8x8 tiling, since we have no more buffers\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 maxSize = uvec2(bluenoiseWidth, bluenoiseHeight);\n    maxSize.x = (maxSize.x + 7u) / 8u;\n    maxSize.y = (maxSize.y + 7u) / 8u;\n    maxSize.x = (maxSize.x + 7u) / 8u;\n    maxSize.y = (maxSize.y + 7u) / 8u;\n\n    vec2 packedVoidCoord = vec2(0.);\n    float voidValue = 1e+35;\n    \n    uvec2 start = min(uvec2(gl_FragCoord.xy) << 3u, maxSize - 1u);\n    uvec2 end = min(start + uvec2(8u, 8u), maxSize);\n    \n    for(uint y=start.y; y<end.y; ++y)\n    for(uint x=start.x; x<end.x; ++x)\n    {\n        uvec2 coord = uvec2(x, y);\n        vec3 packedData = texelFetch(iChannel0, ivec2(coord), 0).xyz;\n        if(packedData.x < voidValue)\n        {\n            voidValue = packedData.x;\n            packedVoidCoord = packedData.yz;\n        }\n    }\n\n    vec3 outVoidData = vec3(voidValue, packedVoidCoord);\n    fragColor = outVoidData.xyzx;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 436]], "test": "untested"}
{"id": "DsfXW8", "name": "psychedelic fractal interactive", "author": "timmaffett", "description": "added mouse interactivity to https://www.shadertoy.com/view/NldSDl (which was forked from \nhttps://www.shadertoy.com/view/Msf3WS )\nall credits to @sleeplessmonk and @ndxbxrme", "tags": ["2d", "fractal", "julia", "fragmentarium"], "likes": 6, "viewed": 274, "published": 3, "date": "1668761790", "time_retrieved": "2024-07-30T16:18:57.874368", "image_code": "// Fork of \"Fork Grinning F sleeplessm 792\" by sleeplessmonk. https://shadertoy.com/view/NldSDl\n// 2022-11-18 08:50:10\n\n//based on code from fragmentarium\n//http://syntopia.github.io/Fragmentarium/\n\nvec3 fractal(vec2 c, vec2 c2) {\t\n\tvec2 z = c;\n\tfloat ci = 0.0;\n\tfloat mean = 0.0;\n\tfor(int i = 0;i < 64; i++) {\n\t\tvec2 a = vec2(z.x,abs(z.y));\n\t\tfloat b = atan(a.y, a.x);\n\t\tif(b > 0.0) b -= 6.283185307179586;\n\t\tz = vec2(log(length(a)),b) + c2;\n\t\tif (i>5) mean+=length(z);\n\t}\n\tmean/=float(62);\n\tci =  1.0 - log2(.05*log2(mean/1.));\n\treturn vec3( .5+.5*cos(6.*ci+0.0),.4+.5*cos(66.*ci + 0.4),.5+.5*cos(6.*ci +1.7) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    \n\tvec2 uv = fragCoord.xy - iResolution.xy*.5;\n\tuv /= iResolution.x;\n\tvec2 tuv = uv;\n\tfloat rot=sin(iTime*0.025*mouse.y)*4.7;\t\t\n\tuv.x = tuv.x*cos(rot)-tuv.y*sin(rot);\n\tuv.y = tuv.x*sin(rot)+tuv.y*cos(rot);\n\tfloat juliax = mouse.x * sin(iTime) * 0.021 + 0.12;\n\tfloat juliay = mouse.y * cos(iTime * 0.23) * 0.2 + 5.7;\n\tfragColor = vec4( fractal(uv, vec2(juliax, juliay)) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 230, 230, 615], [618, 618, 675, 675, 1134]], "test": "untested"}
{"id": "mdsSDn", "name": "jigglers", "author": "nickbrick", "description": "randomizing color with three oscillators (horizontal vertical and radial) and cutting off at a vibrating threshold", "tags": ["wave"], "likes": 3, "viewed": 190, "published": 3, "date": "1668737633", "time_retrieved": "2024-07-30T16:18:58.716117", "image_code": "float wave(float v, float freq, float scale){\n    return 0.5 + 0.5 * sin(scale * v) * sin(freq * iTime);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define SMALLDIM min(iResolution.x, iResolution.y)\n    #define C (iResolution.xy / SMALLDIM / 2.0)\n    #define LOW 1.2\n    #define HIGH 1.5\n    #define JIGGLEFREQ 20.0\n    #define JIGGLEAMP 0.0051 \n    #define BLUR (1.0 / SMALLDIM)\n    vec2 uv = fragCoord / SMALLDIM;\n\n    vec4 col = vec4(wave(uv.x, 0.5, 8.0),\n                    wave(uv.y, 0.6, 12.0),\n                    wave(pow(uv.x - C.x, 2.0) + pow(uv.y - C.y, 2.0), 0.7, 16.0),\n                    1.0);\n    float j = JIGGLEAMP * sin(iTime * JIGGLEFREQ);\n    float f = smoothstep(LOW  + j, LOW  + j + BLUR, length(col))\n             -smoothstep(HIGH + j, HIGH + j + BLUR, length(col));\n    fragColor = vec4(vec3(f), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 106], [107, 107, 164, 164, 850]], "test": "untested"}
{"id": "mslXRM", "name": "Dessin Pour Textile (353 chars)", "author": "fenix", "description": "A tribute to Russian Constructivist designer Varvara Stepanova's Dessin Pour Textile, 1924, gouache, paper mounted on cardboard, 46 x 55 cm, Musée Pouchkine, © ADAGP, Paris\n\nhttps://awarewomenartists.com/en/artiste/varvara-stepanova/", "tags": ["codegolf", "reproduction", "constructivist"], "likes": 10, "viewed": 219, "published": 3, "date": "1668736404", "time_retrieved": "2024-07-30T16:18:59.520965", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// From: https://awarewomenartists.com/en/artiste/varvara-stepanova/\n\n// Varvara Stepanova was one of the founding members of Russian Constructivism, a movement\n// that rejected art for the sake of art in favour of a functional and practical art. In\n// 1924, she became involved in the creation of new fabrics for the first Soviet printed\n// cotton factory, designing structures and patterns to fit the function of the piece of\n// clothing they were intended for. With a view towards standardisation – a principle valued\n// by Constructivists – she hoped to create ideal clothes for each trade.\n\n// I'm no expert in graphic design history, but isn't it wild that this design is almost\n// 100 years old? FWIW I saw this pattern while watching this video, which I highly recommend\n// but it only has a very little bit about Varvara Stepanova in it @10:40.\n\n//     https://youtu.be/WVfRxFwVHQc\n\n// I've already golfed this somewhat, but I bet someone could do better.\n\n//*\n#define S(v) smoothstep(3./R.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;   \n    O = vec4(.97,.92,.83,1);\n    O = mix(\n            .5 < fract(7.5 * abs( fract( ( u = 1.6*(u - .5*R) / R.y).x / .39 ) \n                                  - .5) + .25 )\n              ? O : vec4(1,.36,.3,1)\n            ,\n            mix( O, vec4(.2,.1,.1,1), \n                 S(\n                    abs(  mod(\n                            ( u.y = mod(u.y - sign( fract(u.x / .78) - .5) * iTime * .01, .53)\n                              + sin(u.x*8.)/ 16.\n                            ) + .09\n                            , .048)\n                          - .026\n                       ) -.01 ) \n                ),\n                S( abs(.4 - u.y*2.) -.2\n          )   );\n}\n/**/\n\n\n// My attempt to re-apply FabriceNeyret2's optimizations and avoid cross-hatching in the black parts: 353 chars\n/*\n#define S(v) smoothstep(3./O.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O.xyz = iResolution;\n    \n    vec4 W = vec4(.97,.92,.83,1);\n\n    O = mix(.5 < fract(7.5 * abs(fract((\n                u = 1.6*(u - .5*O.xy) / O.y).x / .39) - .5) + .25) ? W : vec4(1,.36,.3,1),\n            mix(W, vec4(.2,.1,.1,1), S(abs(mod((\n                u.y = mod(u.y - sign(fract(u.x / .78) - .5) * iTime * .01, .53)\n                + sin(u.x*8.)/ 16.) + .1, .048) - .036) - .009)),\n            S(abs(2.8 - u.y*14.) - 1.4));\n}\n/**/\n\n// From FabriceNeyret2: 343 chars! but doesn't look right for me\n/*\n#define S(v) smoothstep(3./R.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;   \n\n    O = mix(\n            .5 < fract(7.5 * abs( fract( ( u = 1.6*(u - .5*R) / R.y).x / .39 ) \n                                  - .5) + .25 )\n              ? O = vec4(.97,.92,.83,1) : vec4(1,.36,.3,1)\n            ,\n            mix( O, vec4(.2,.1,.1,1), ≈≈≈\n                 S(\n                    abs(  mod(\n                            ( u.y = mod(u.y - sign( fract(u.x / .78) - .5) * iTime * .01, .53)\n                              + sin(u.x*8.)/ 16.\n                            ) + .09\n                            , .048)\n                          - .026\n                       ) -.01 ) \n                ),\n                S( abs(.4 - u.y*2.) -.2\n          )   );\n}\n/**/\n\n// Original: 379 chars\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O.xyz = iResolution;\n    \n    vec4 W = vec4(.97,.92,.83,1);\n\n    O = mix(mix(vec4(1,.36,.3,1), W, float(0. < mod(7.5 * abs(fract((\n                u = 1.6*(u - .5*O.xy) / O.y).x / .39) - .5) + .25, 1.) - .5)),\n            mix(W, vec4(.2,.1,.1,1), 1. - smoothstep(.01, .01 + 3./O.y, abs((mod((\n                u.y = mod(u.y - sign(fract(u.x / .78) - .5) * iTime * .01, .53)\n                + sin(u.x*8.)/ 16.) + .1, .048) - .018) - .018))),\n            1. - smoothstep(1.4, 1.41, abs(2.8 - u.y*14.)));\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslXRM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1222, 1222, 1260, 1260, 1963]], "test": "untested"}
{"id": "cdlXWr", "name": "1D Fuzzy SDF Visualization 2", "author": "Hatchling", "description": "Please read the comments on the Image tab for explanation.\nThis lets you view each SDF w/ diff. thresholds.", "tags": ["sdf", "visualizer", "1d", "graph", "fuzzy"], "likes": 5, "viewed": 225, "published": 3, "date": "1668733009", "time_retrieved": "2024-07-30T16:19:00.574150", "image_code": "// NOTICE:\n// _________________________\n//\n// - The shader is intended to be used mostly while paused.\n//   Each frame the shader plays, the test function will evolve.\n//   (1-D perlin noise).\n//\n// - This isn't optimized, the search function is brute force,\n//   but it is 1D so this should be fine.\n\n// How to use:\n// _________________________\n//\n// 1. Pause the shader.\n// 2. Click and drag your mouse to view the SDF produced at different boundary\n//    thresholds. Top = 1, Bottom = 0.\n\n// Legend:\n// _________________________\n//\n//    Orange curve : Arbitrary function to turn into an SDF.\n//      Blue curve : The resulting SDF.\n//  Red background : The SDF has a positive gradient at this X coordinate.\n// Blue background : The SDF has a negative gradient at this X coordinate.\n//   Light/dark bg : The SDF is poitive/negative at this X coordinate.\n// Horizontal Line : The boundary threshold delininating inside from outside.\n\n// Controls:\n// _________________________\n//\n//              Pause : Prevent the orange function from changing.\n//               Play : Generate new orange functions.\n// Mouse Click + Drag : Change the SDF's boundary level from 0 to 1:\n//                      Top = 1, Bottom = 0.\n\n\n// Explanation:\n// _________________________\n\n// --- \"Problem\" with SDFs ---\n\n// An SDF generated from an occupancy field of varying value, like a heightmap,\n// requires that a boundary be defined that determines whether\n// a given point in the field should be considered \"inside\" the surface\n// or \"outside\" the surface. (This is called an isocontour.)\n\n// However, this definition has a \"problem\":\n// Most of the cells in the occupancy field are simply \"thrown out\",\n// and only the very few cells that have neighbors which cross\n// the isocontour have any influcence on the resulting SDF.\n\n// Many things in nature have \"fuzzy\" edges, and ideally we'd like to\n// model these kinds of things with SDFs as well.\n// For training Neural Implicit Fields for example,\n// most of the latent space has no influence on the resulting shape, \n// even if a region is extremely close but is still just shy of an iso crossing.\n// These points in the latent space thus have no gradients for training\n// and thus training progress is only produced by the tiny regions with crossings.\n// If useful gradients could come from anywhere, new solid structures\n// could emerge without needing to extend them from existing surfaces.\n\n// --- Reinterpreting SDFs as Probabilistic ---\n\n// When you generate an SDF, you can start with a field\n// of values (could be a texture, a function, etc.), then you \n// interpret the field as occupancy; either \"solid stuff\" exists at\n// this point or it does not.\n\n// This poses a problem; even if a point in the field has 0.1% occupancy,\n// there is still stuff at that point, and it could be the closest\n// bit of stuff.\n// Thus, unless your field contains a lot of 0% occupied (empty) space, \n// most of your field will be considered completely solid \n// and inside the occupied surface.\n\n// Instead, suppose we were to think of it like this:\n// When we generate an SDF, we want to find \n// the distance to the closest point in the field \n// where the probability that it is occupied is at least X%.\n\n// Then, integrate the SDF over X from 0% to 100%.\n//\n//     In other words, create N SDFs,\n//     with X linearly increasing from 0% to 100% \n//     (X for SDF[n] is n / (N-1))\n//     then average all of the SDFs together.\n//     Ideally N would be infinity, but we can't compute this,\n//     so instead we can try to caclulate the\n//     the limit, or what the result trends towards,\n//     as N approaches infinity.\n//\n// From this we'll have a \"fuzzy\" signed distance field (FSDF),\n// where its value at position P is the distance in which\n// there is exactly a 50% chance that an isocontour crossing\n// will occur.\n\n// --- Application to terrain ---\n\n// Signed distance fields (SDFs) in 2-D can be used to generate \n// fairly natural erosion patterns in heightmaps very quickly.\n\n// However, a normal single SDF doesn't alone produce nice looking terrain,\n// but you'll see erosion-like patterns of branching\n// peaks and valleys where the gradient direction,\n// or in other words, the direction to the nearest isocontour,\n// changes suddenly.\n\n// Using an FSDF, however, somehow, does produce fairly convincing results.\n// I'm guessing this is just due to the fact that each individual SDF[n]\n// has erosion-like qualities, and averaging out multiple of them\n// both creates natural variations and lets erosion-like features \n// that are more consistent across all of the SDFs \n// have a stronger influence on the result.\n\n// --- Purpose for THIS shader ---\n\n// This shader lets you visualize individual slices that compose the\n// final FSDF.\n\n// You'll see that FSDFs are composed of, basically, many\n// connected diagonal lines with constant absolute slope.\n\n// Visualizing the concept this way should hopefully\n// build an intuition for the parts that sum together to\n// make an FSDF.\n\n// --- How to Interpret the Visualization ---\n \n// Orange line:\n//     - The probability of occupancy at a given X coordinate.\n//     - Any points of the orange line that are above the white line\n//       have a greater probabilty than the probability threshold.\n//     - Where the orange line crosses the white line,\n//       we have an isocontour.\n\n// Blue line:\n//     - The signed distance from X coordiante\n//       to the closest point on the orange line\n//       that crosses the probability threshold.\n//     - Where the blue line crosses the white line,\n//       the signed distance is 0.\n\n// Horizontal white line:\n//     - Shows the probability threshold for the orange line.\n//     - Can be controlled with the mouse.\n//     - Top: 100%, Bottom: 0%\n//     - Also represents the X axis for the blue line graph,\n//       in which all blue points along the line are 0.\n\n// Red/Cyan tinted regions:\n//     - Shows the gradient of the SDF.\n//     - Notice that the gradient changes in the center\n//       between two points where the orange line\n//       and the horizontal white line intersect.\n\n#define decl_getGraphOpacity(type) \\\ntype getGraphOpacity(type graphHeight, type graphGradient, type fragHeight) \\\n{\\\n    type range = (type(1.0) + abs(graphGradient)) * type(2.0);\\\n    type upper = graphHeight + range;\\\n    type lower = graphHeight - range;\\\n    type value = (fragHeight - lower) / (upper - lower);\\\n    value = type(1.0) - (abs(value - type(0.5)) * type(2.0));\\\n    return smoothstep(type(0.0), type(1.0), value);\\\n}    \n    \ndecl_getGraphOpacity(float)\ndecl_getGraphOpacity(vec4)\n\nfloat sampleGraph( in float graphHeight, in vec2 fragCoord )\n{\n    return getGraphOpacity(graphHeight, dFdx(graphHeight), fragCoord.y);\n}\n\nvec4 sampleGraphEx(in float graphHeight, in float zeroLineHeight, in vec2 fragCoord  )\n{\n    vec4 result;\n    // x = line opacity;\n    // y = height relative to zero line;\n    // z = gradient\n\n    float graphGradient = dFdx(graphHeight);\n    result.x = getGraphOpacity(graphHeight, graphGradient, fragCoord.y);\n    result.y = graphHeight - zeroLineHeight;\n    result.z = graphGradient;\n    result.w = 1.0;\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = vec4(0,0,0,1);\n    \n    float mouseY = iMouse.y < 0.5 ? iResolution.y * 0.5 : iMouse.y; \n    \n    float horizontalLine = sampleGraph(mouseY, fragCoord);\n\n    float orangeLine;\n    {\n        orangeLine = texelFetch(iChannel1, ivec2(fragCoord.x, 0), 0).r; \n        orangeLine *= iResolution.y;\n        orangeLine = sampleGraph(orangeLine, fragCoord);\n    }\n    \n    vec4 data;\n    {\n        \n        float blueLineHeight = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0)).x;\n        blueLineHeight -= 0.5;\n        blueLineHeight *= iResolution.y;\n        blueLineHeight += mouseY;\n        data = sampleGraphEx(blueLineHeight, mouseY, fragCoord); \n    }\n\n    fragColor.rgb = mix\n    (\n        fragColor.rgb, \n        data.y > 0. ? vec3(1) : vec3(0), \n        0.05\n    );\n    fragColor.rgb = mix\n    (\n        fragColor.rgb, \n        data.z > 0. ? vec3(1, 0, 0) : vec3(0, 1, 1), \n        0.2\n    );\n    \n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 1.0), horizontalLine);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.7, 0.3), orangeLine);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.3, 0.7, 1.0), data.x);\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Contains the function to display.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    // Only process the first row of pixels.\n    if(fragCoord.y > 0.5)\n    {\n        return;\n    }\n    \n    // 1-D perlin noise.\n    const int maxLayer = 5;\n    for(int i = 2; i < maxLayer; i++)\n    {\n        vec2 uv = fragCoord  / iChannelResolution[1].xy;\n\n        // Randomize offset per layer.\n        float uvOffset = float(i) * 1.618;\n        uvOffset -= floor(uvOffset);\n\n        // Get weighted sample with varying scale.\n        float weightScale = float(1 << i);\n        float uvScale = 1.0 / weightScale;\n        uv.y += iTime * 0.05;\n        uv *= uvScale;\n        uv += vec2(uvOffset);\n        vec4 t = texture(iChannel1, uv * uvScale);\n        t.a = 1.0;\n        t *= weightScale;\n\n        fragColor += t;\n    }\n\n    fragColor.rgb /= fragColor.a;\n\n    // Add contrast.\n    fragColor -= vec4(0.5);\n    fragColor *= fragColor.a / float(1 << (maxLayer-1));\n    //fragColor = tanh(fragColor);\n    //fragColor *= 0.5;\n    fragColor += 0.5;\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Contains the function to display.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 intFragCoord = ivec2(fragCoord);\n    \n    if(fragCoord.y > 0.5)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    float mouseY = iMouse.y < 0.5 ? iResolution.y * 0.5 : iMouse.y; \n    \n    // The X center of \"my\" pixel (the current one being drawn).\n    float myCenter = float(intFragCoord.x) + 0.5;\n    float myHeight = texelFetch(iChannel0, ivec2(fragCoord.x, 0), 0).r;\n    \n    float dither = mouseY / iResolution.y;\n    vec4 thresh = (vec4(dither));\n    float maxDist = iResolution.x;\n    vec4 dist = vec4(maxDist);\n    bvec4 mySign = greaterThan(vec4(myHeight), thresh);\n\n    ivec2 intResolution = ivec2(iResolution.xy);\n    for(int iNeighbor = 0; iNeighbor < intResolution.x; iNeighbor++)\n    {\n        // This doesn't work for some reasosn.\n        /*int neighborX = (iNeighbor / 2) + 1;\n        if((iNeighbor % 2) == 0)\n            neighborX = -neighborX;\n            \n        neighborX += intFragCoord.x;\n        \n        if(neighborX > intResolution.x-1) neighborX = intResolution.x-1;\n        if(neighborX < 0) neighborX = 0;*/\n        \n        // Can't break early, I guess. Brute force it is. -shrug-\n        int neighborX = iNeighbor;\n            \n        // The X center of the neighbor pixel.\n        float neighborCenter = float(neighborX) + 0.5;\n        float neighborNearestEdge = neighborCenter + sign(myCenter - neighborCenter) * 0.5;\n\n        float distMeToNeighbor = abs(myCenter - neighborNearestEdge);\n\n        float neighborHeight = texelFetch(iChannel0, ivec2(neighborX, 0), 0).r;\n\n\n        bvec4 neighborSign = greaterThan(vec4(neighborHeight), thresh);\n\n        bvec4 signEquals = equal(mySign, neighborSign);\n        bvec4 neighborFurther = greaterThanEqual(vec4(distMeToNeighbor), dist);\n        \n        dist.x = signEquals.x || neighborFurther.x ? dist.x : distMeToNeighbor;\n        dist.y = signEquals.y || neighborFurther.y ? dist.y : distMeToNeighbor;\n        dist.z = signEquals.z || neighborFurther.z ? dist.z : distMeToNeighbor;\n        dist.w = signEquals.w || neighborFurther.w ? dist.w : distMeToNeighbor;\n    }\n\n    dist *= vec4(mySign) * 2.0 - vec4(1.0);\n    dist /= vec4(maxDist);\n    dist = dist * 0.5 + 0.5;\n    \n    fragColor = vec4(dist);\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlXWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6777, 6777, 6865, 6865, 7208], [7210, 7210, 7267, 7267, 8423]], "test": "untested"}
{"id": "cslSDr", "name": "random but not random #2", "author": "jonasfrey", "description": "random use mouse", "tags": ["random"], "likes": 0, "viewed": 143, "published": 3, "date": "1668727761", "time_retrieved": "2024-07-30T16:19:01.483718", "image_code": "float f_n_random(vec2 o){\n    float n = (pow(257.89, o.x) + pow(83.367, o.y))*1217.;\n    return fract(n+o.x*23.23 + o.y/o.x*0.3123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5) /iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy - iResolution.xy*0.5) /iResolution.y;\n    float n_pix_size_max = floor(2. * iMouse.x);\n    vec2 o_pix_coo_big = floor(o_pix_coo_nor*n_pix_size_max)/n_pix_size_max;\n    fragColor = vec4(f_n_random(o_pix_coo_big));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 134], [135, 135, 192, 192, 525]], "test": "untested"}
{"id": "cdlSDr", "name": "random but not random #1", "author": "jonasfrey", "description": "random", "tags": ["cells"], "likes": 2, "viewed": 164, "published": 3, "date": "1668726223", "time_retrieved": "2024-07-30T16:19:02.304523", "image_code": "float f_n_random(vec2 o){\n    float n = fract(o.x*0.369+o.y*0.369)*0.369;\n    n = fract(o.x*n*936.+o.y*n*9369.+o.x*n+o.y*33399.);\n    n = fract(pow(n, 39.369));\n    return n;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5) /iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy - iResolution.xy*0.5) /iResolution.y;\n    fragColor = vec4(f_n_random(o_pix_coo_nor+iTime*0.000001));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 176], [177, 177, 234, 234, 451]], "test": "untested"}
{"id": "DdlSDr", "name": "Dirty Edge Outliner", "author": "eo", "description": "Adds a stylized outline to video/images\n\nClick and drag the mouse to modify the effect\nX: controls the darkening effect\nY: controls the sampling spread\n", "tags": ["mouse", "outline", "edges"], "likes": 4, "viewed": 278, "published": 3, "date": "1668726135", "time_retrieved": "2024-07-30T16:19:03.175195", "image_code": "\n/*\nCalculates a 'dirty' edge image by subtracting the original image\nfrom a 'blurred' copy of itself, except the blurred copy is coming\nfrom a simple 'monto carlo' blur. The result is combined back into\nthe original image. A bit like unsharp masking:\nhttps://en.wikipedia.org/wiki/Unsharp_masking\n\nInspired by the very pretty stippling effect from starea:\nhttps://www.shadertoy.com/view/ldSyzV\n\nI really like the term 'monte carlo blur', it comes from Justaway:\nhttps://www.shadertoy.com/view/MdXXWr\n*/\n\n\n//#define EDGES_ONLY\n#define TWO_PI 6.283185307\n#define ANIMATED_NOISE 0.25\n\n\n// Settings applied when mouse isn't active\nfloat default_offset = 0.015;\nfloat default_darken = 0.92;\n\n\n// From Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nvec2 get_random_sampling_offset(vec2 xy) {\n\n    vec2 random_2d = hash22(xy);\n    float random_radius = random_2d.x;\n    float random_angle = random_2d.y * TWO_PI;\n    \n    #ifdef ANIMATED_NOISE\n        random_angle += (iTime * ANIMATED_NOISE);\n    #endif\n    \n    return random_radius * vec2(cos(random_angle), sin(random_angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // For convenience\n    vec2 xy_norm = fragCoord/iResolution.xy;\n    vec2 mouse_xy_norm = iMouse.xy / iResolution.xy;\n    float is_mouse_down = clamp(iMouse.z, 0., 1.);\n    \n    // Get offset sampling scale (can be altered by mouse Y)\n    float mouse_scale = mix(0.001, 0.5, mouse_xy_norm.y);\n    float offset_scale = mix(default_offset, mouse_scale, is_mouse_down);\n    vec2 sampling_offset = offset_scale * get_random_sampling_offset(fragCoord);\n\n    // Get edges by subtracting a 'blurry' copy of the image from itself\n    vec4 orig_img = texture(iChannel0, xy_norm);\n    vec4 offset_img = texture(iChannel0, xy_norm + sampling_offset);\n    vec4 diff_img = orig_img - offset_img;\n    float gray = 1.0 - length(diff_img.xyz);\n    \n    // Contrast bump before output (can be altered by mouse X)\n    float mouse_darken = mix(0.0, 1.0, mouse_xy_norm.x);\n    float darken = mix(default_darken, mouse_darken, is_mouse_down);\n    gray = smoothstep(darken, 1.0, gray) * 0.8 + 0.2;\n    vec3 gray_3d = vec3(gray);\n    \n    // Choose coloring style\n    vec3 col;\n    #ifdef EDGES_ONLY\n        col = gray_3d;\n    #else\n        vec3 dulled_offset = offset_img.rgb * 0.6 + 0.2;\n        col = mix(gray_3d, dulled_offset, gray);\n    #endif\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[689, 749, 770, 770, 904], [907, 907, 949, 949, 1239], [1242, 1242, 1299, 1322, 2568]], "test": "untested"}
{"id": "DdlXDn", "name": "Mixing Tank", "author": "wyatt", "description": "Fluid", "tags": ["fluid"], "likes": 21, "viewed": 421, "published": 3, "date": "1668718814", "time_retrieved": "2024-07-30T16:19:03.981041", "image_code": "Main {\n    vec4 b = B(U);\n    Q = .5+.5*sin(b.w+b.z*vec4(1,2,3,4));\n    //Q = b.zzzz;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define G(x,s) 0.3989422804/(s)*exp(-.5*(x)*(x)/(s)/(s))", "buffer_a_code": "Main {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q.xy -= 0.25*vec2(e.z-w.z,n.z-s.z);\n    Q.y -= .1*(b.z)/R.y;\n    Q.w = 0.;\n    \n    if (iFrame < 1) Q = vec4(0,0,0,0);\n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.) \n    Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q.z -= 0.25*(e.x-w.x+n.y-s.y);\n    Q.w = 0.;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    if (iFrame % 20 == 0) {\n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n        \n        U -= .5*A(U).xy;\n        U -= .5*A(U).xy;\n    }\n    Q = A(U);\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = B(U);\n    for (float x = -1.; x <= 1.; x++)\n    for (float y = -1.; y <= 1.; y++)\n    {\n        vec4 b = B(U+vec2(x,y));\n        if (length(U-b.xy)<length(U-Q.xy))\n            Q = b;\n    }\n    Q.xy += A(U).xy;\n    Q.zw = mix(Q.zw,B(Q.xy-A(U).xy).zw,.01);\n    if (iFrame < 1) {\n        Q = vec4(U,\n        sign(U.y-.5*R.y+10.*sin(.1*U.x)),\n        U.x/R.x*2.-1.);\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<50.)\n        Q.zw += .01;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DsXSDr", "name": "Mandelbrot.", "author": "cp1", "description": "Mandelbrot.", "tags": ["mandelbrot"], "likes": 0, "viewed": 156, "published": 3, "date": "1668718152", "time_retrieved": "2024-07-30T16:19:04.870662", "image_code": "\n\nvec2 add(vec2 comp1, vec2 comp2) {\n    return vec2(\n        (comp1[0] + comp2[0]),\n        (comp1[1] + comp2[1])\n    );\n}\n\nvec2 mul(vec2 comp1, vec2 comp2) {\n    return vec2(\n        (comp1[0] * comp2[0] - comp1[1] * comp2[1]),\n        (comp1[0] * comp2[1] + comp1[1] * comp2[0])\n    );\n}\n\nfloat norm(vec2 number) {\n    return dot(number, number);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\n    int ITERATIONS;\n   \n    \n    float zm = float(1.5 / pow(-2.0, iTime));\n    ITERATIONS = 1000 + int(pow(iTime, 3.0));\n\n    \n    //float zm = 0.5;\n    \n    // X:[-2.0, 1.0]\n    // Y:[-1.0, 1.0]\n    vec2 uv = vec2(\n        (fragCoord.x / iResolution.x * (3.5 * zm) - (2.0 * zm) + 0.3007953),\n        (fragCoord.y / iResolution.y * (2.0 * zm) - (1.0 * zm) - 0.0201099));\n\n\n\n    vec2 z = vec2(0);\n    vec2 c = uv;\n    \n    int i = 0;\n    \n    while (i < ITERATIONS && norm(z) <= 5.0) {\n        z = add(mul(z, z), c);\n        \n        i++;\n    }\n\n    float v = float(i) / float(ITERATIONS);\n    \n    float mixingFactor = sqrt(float(i) / float(ITERATIONS) * (zm + 10.0));\n    \n    if (v == 1.0) {\n        vec4 col = vec4(1);\n        fragColor = col;\n    } else if (v != 0.0) {\n        vec4 col = vec4((mixingFactor + 0.1), mixingFactor, (mixingFactor + 0.2), 0.0);\n        fragColor = col;\n    } else {\n        fragColor = vec4(0);\n    }\n\n  \n    \n    \n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 36, 36, 123], [125, 125, 159, 159, 290], [292, 292, 317, 317, 351], [355, 355, 412, 412, 1367]], "test": "untested"}
{"id": "dsfXDn", "name": "ModTag Background", "author": "shraiwi", "description": "This is my modtag on a scrolling background, with anti-aliased rendering. I'm using this on my github pages as a background for the e-portfolio!", "tags": ["pixelart"], "likes": 3, "viewed": 165, "published": 3, "date": "1668704355", "time_retrieved": "2024-07-30T16:19:05.705430", "image_code": "// special thanks to FabriceNeyret2 for helping optimize and clean up the shader!\n\nconst float pixelSize = 10.;\nconst float iPxS = 1.0 / pixelSize;\n\nconst vec4 bgColor = vec4(239.0, 245.0, 241.0, 255.0) * (1.0 / 255.0);\nconst vec4 fgColor = vec4(223.0, 236.0, 227.0, 255.0) * (1.0 / 255.0);\n\nconst float t = -0.10; // rotate pattern in rad. due to the aa method, it works best near 90-degree multiples.\n\n//#define DISABLE_AA // uncomment to disable anti-aliasing entirely\n\n//#define DEMO_AA // comment to disable switch between no anti-aliasing and anti-aliasing every 2s\n//#define DEBUG_SCALE (4.0) // comment to disable scaling screen pixels by 4x, making it easier to see the anti-aliasing\n\n#define ROT(theta) mat2(cos(theta), sin(theta), -sin(theta), cos(theta))\n\nfloat modTag(ivec2 px) {\n    px = abs(px);\n    int x = px.x, y = px.y;\n    return sign(float(\n        (x ^ y) % 5 // your expression here!\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 U = fragCoord;\n\n#ifdef DEBUG_SCALE\n    vec2 c = round(U / DEBUG_SCALE);\n#else\n    vec2 c = U;\n#endif\n\n    c = (c + vec2(iTime * pixelSize * 0.25, 0.0)) * ROT(t);\n    \n    ivec2 ibl = ivec2((c - 0.25) * iPxS);\n    \n#ifdef DISABLE_AA\n    float m = modTag(ibl + ivec2(1, 1));\n#else\n\n    \n    // sample 4 modtag values\n    vec4 values = vec4(\n        modTag(ibl + ivec2(0, 0)),\n        modTag(ibl + ivec2(1, 0)),\n        modTag(ibl + ivec2(0, 1)), \n        modTag(ibl + ivec2(1, 1))\n    );\n\n    // nearest modtag grid intersection in normalized coords, clamped to 0-1\n    vec2 x = clamp(c - vec2(ibl) * pixelSize, 0.0, 1.0);\n    \n#ifdef DEMO_AA\n    if (mod(iTime, 2.0) < 1.0) x = vec2(1.0);\n#endif\n    \n    // modtag pixel weights\n    vec4 w = vec4(1.0 - x, x);\n    w = w.xzxz * w.yyww;\n    \n    // find mixing factor\n    float m = dot(values, w);\n\n#endif\n    \n    fragColor = mix(fgColor, bgColor, m);\n        \n    //fragColor = vec4(x, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[768, 768, 792, 792, 916], [918, 918, 975, 975, 1932]], "test": "untested"}
{"id": "csfXDn", "name": "GMTK Elden Ring Cards Inspired", "author": "Rutvik_Tak", "description": "Recently GMTK which is a YouTube channel around game dev showcased some of the custom Elden ring cards. I loved those and thought of creating an image filter inspired by those cards design.\nhttps://twitter.com/gamemakerstk/status/1590778079118782464\n", "tags": ["imagefilter", "dithering"], "likes": 4, "viewed": 345, "published": 3, "date": "1668687900", "time_retrieved": "2024-07-30T16:19:06.544187", "image_code": "\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    // Output to screen\n    \n    vec4 mycolor=vec4(uv.xyx,1.);\n    \n    //vec4 color = texture( iChannel0, uv.xy );\n    \n    vec4 bitRateColor=vec4(sin(mycolor.x*700.)*.3,cos(mycolor.y*700.)*.3,1.,1.);\n    vec2 res=iResolution.xy/3.;\n    vec2 pos=floor(uv*res)/res;\n    if(max(abs(pos.x-.5),abs(pos.y-.5))>.5){\n        fragColor=vec4(0.);\n    }\n    \n    vec4 imagePixel=texture(iChannel0,pos.xy);\n    \n    vec4 imagetopixelcolor=vec4(bitRateColor.xy,imagePixel.x,imagePixel.x);\n    \n    float grayScaleValue=(imagetopixelcolor.x+imagetopixelcolor.y+imagetopixelcolor.z)/3.;\n   // vec2 pixelColor = step(grayScaleValue+0.5,imagePixel.xy);\n    vec2 pixelColor = smoothstep(0.,grayScaleValue+1.,imagePixel.xy);\n\n    fragColor=vec4(pixelColor,imagePixel.b,0.);\n    \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 55, 105, 912]], "test": "untested"}
{"id": "dsBGzW", "name": "rectangle where mouse", "author": "jonasfrey", "description": "click and drag mouse, draws a rectangle where there is the mouse", "tags": ["rectangle"], "likes": 3, "viewed": 191, "published": 3, "date": "1668684769", "time_retrieved": "2024-07-30T16:19:07.362998", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iTime < 0.1){ // reset time to clear the screen\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    vec2 a_n_mouse_normalized = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    vec2 a_n_pixel_coordinate_normalized = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    \n    float n_scale_x = 33.0;\n    float n_scale_y = 33.0;\n    float n_scale_x_normalized = n_scale_x / iResolution.x;\n    float n_scale_y_normalized = n_scale_y / iResolution.y;\n    if(\n        a_n_pixel_coordinate_normalized.x >= a_n_mouse_normalized.x\n        &&\n        a_n_pixel_coordinate_normalized.x < a_n_mouse_normalized.x + n_scale_x_normalized\n        &&\n        a_n_pixel_coordinate_normalized.y >= a_n_mouse_normalized.y\n        &&\n        a_n_pixel_coordinate_normalized.y < a_n_mouse_normalized.y + n_scale_y_normalized\n     ){\n        float n_center_x = (a_n_mouse_normalized.x + (n_scale_x_normalized / 2.0));\n        float n_center_y = (a_n_mouse_normalized.y + (n_scale_y_normalized / 2.0));\n       float n_distance = sqrt(\n           pow(a_n_pixel_coordinate_normalized.x - n_center_x,2.0) + \n           pow(a_n_pixel_coordinate_normalized.y - n_center_y,2.0)\n          );\n          float n_distance_normalized = n_distance/n_scale_y_normalized;\n          float n_distance_normalized_inverted = 1.0 - n_distance_normalized;\n\n       fragColor = vec4(\n       n_distance_normalized_inverted,\n       n_distance_normalized_inverted,\n       n_distance_normalized_inverted,\n       1.0\n       );\n    }else{\n    \n        discard;\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1637]], "test": "untested"}
{"id": "Dss3WH", "name": "Dots.", "author": "OzoneOnYou", "description": "I mean the name is pretty self explanatory...", "tags": ["dots"], "likes": 1, "viewed": 148, "published": 3, "date": "1668684398", "time_retrieved": "2024-07-30T16:19:08.225692", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color1 = vec3(34./255., 166./255., 179./255.);\n    vec3 color2 = vec3(126./255., 214./255., 223./255.);\n    \n    float circles = sin(uv.x * 80.0) + sin(uv.y * 45.0);\n\n    // Time varying pixel color\n    vec3 col = (step(circles, sin(iTime + uv.x)*1.8) * -1. + 1.) * mix(color1, color2, (uv.x + uv.y)/2.);\n\n    // Output to screen\n    fragColor = vec4(col,circles/10. + 0.9); //alpha optimized for cineshader\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dss3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 571]], "test": "untested"}
{"id": "mdlSz7", "name": "Magic Trick ... wait for it", "author": "GregRostami", "description": "If you make a white shader, a GHOST will HAUNT your Shader!!!\nThis is a fork of Fabrice's shader:\nhttps://www.shadertoy.com/view/ddlSRn", "tags": ["2d", "magic", "trick", "short"], "likes": 6, "viewed": 271, "published": 3, "date": "1668674845", "time_retrieved": "2024-07-30T16:19:09.018572", "image_code": "void mainImage( out vec4 o, in vec2 u )\n{                                                                                                                                                                                                                                             o=cos(iTime*.17)+max(u=fract(u/dot(u=u/1e3+cos(iTime*.2),u)+iTime),u.x-u).yxyy;  vec4 _\\\no = vec4(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "msS3zd", "name": "Shiny Boxes", "author": "FifthStateOfMatter", "description": "3d", "tags": ["3d"], "likes": 4, "viewed": 335, "published": 3, "date": "1668661163", "time_retrieved": "2024-07-30T16:19:09.777543", "image_code": "const vec3 lPos = vec3(0, 3, 0);\nconst float PI = 3.1415926535;\nconst float degreesToRadians = PI/180.0;\nconst float FOV = 70.0*degreesToRadians;\nconst float fogDensity = 3.0;\nconst vec3 fogColor = vec3(0.4, 0.7, 0.9);\n\nconst float f = 1.0/tan(FOV/2.0);\nconst float aperture = 0.015;\nconst float focalLength = 11.1;\n\nstruct material{\n    vec3 col;\n    float type;\n    float intensity;\n};\n\nstruct box{\n    vec3 pos;\n    vec3 size;\n    material mat;\n};\n\nstruct camera{\n    vec3 o;\n    vec3 d;\n};\n\nbox[] scene = box[](\n    box(vec3(0, 0, 0), vec3(500, 1, 500), material(vec3(1), 3.0, 0.8)),\n    box(vec3(-2, 1, 2), vec3(2, 1, 1), material(vec3(1, 1, 0), 3.0, 0.6)),\n    box(vec3(2, 1.5, 6), vec3(1, 2, 1), material(vec3(1, 0, 1), 3.0, 0.4)),\n    box(vec3(-3, 1.5, 0), vec3(2), material(vec3(0, 1, 0), 3.0, 0.9)),\n    box(vec3(4, 1.25, 1), vec3(1.5), material(vec3(0, 0, 1), 3.0, 0.7)),\n    box(vec3(0, 1, 2), vec3(1), material(vec3(1, 0, 0), 3.0, 0.5)),\n    box(vec3(-2.5, 3, 0), vec3(1), material(vec3(1, 0.5, 0), 3.0, 0.2)),\n    box(lPos, vec3(1, 1, 1), material(vec3(1), 0.0, 0.5))\n);\n\nbool raytraceBox(vec3 o, vec3 d, out float t, box b, out material mat){\n    vec3 tMin;\n    vec3 tMax;\n\n    vec3 halfSize = b.size/2.0;\n\n    vec3 lbf = b.pos - halfSize;\n    vec3 rtb = b.pos + halfSize;\n\n    tMin = (lbf - o)/d;\n    tMax = (rtb - o)/d;\n\n    if(tMin.x > tMax.x){\n        float tempT = tMin.x;\n        tMin.x = tMax.x;\n        tMax.x = tempT;\n    }\n\n    if(tMin.y > tMax.y){\n        float tempT = tMin.y;\n        tMin.y = tMax.y;\n        tMax.y = tempT;\n    }\n\n    if(tMin.z > tMax.z){\n        float tempT = tMin.z;\n        tMin.z = tMax.z;\n        tMax.z = tempT;\n    }\n\n    if((tMin.x > tMax.y) || (tMin.y > tMax.x)){\n        return false;\n    }\n\n    if(tMin.y > tMin.x){\n        tMin.x = tMin.y;\n    }\n\n    if(tMax.y < tMax.x){\n        tMax.x = tMax.y;\n    }\n\n    if((tMin.x > tMax.z) || (tMin.z > tMax.x)){\n        return false;\n    }\n\n    if(tMin.z > tMin.x){\n        tMin.x = tMin.z;\n    }\n\n    if(tMax.z < tMax.x){\n        tMax.x = tMax.z;\n    }\n\n    mat = b.mat;\n    t = tMin.x;\n\n    return true;\n}\n\nbool raytraceScene(vec3 o, vec3 d, out float t, out material mat, out int Index){\n    float initT = 1000000000.0;\n    bool r;\n    int index;\n    for(int i = 0; i < scene.length(); i++){\n        float testT;\n        bool rt = raytraceBox(o, d, testT, scene[i], mat);\n        if(rt && testT < initT && testT >= 0.0){\n            r = true;\n            initT = testT;\n            index = i;\n        }\n    }\n    t = initT;\n    Index = index;\n    mat = scene[Index].mat;\n    return r;\n}\n\nvec3 getBoxNormals(vec3 h, box b){\n    vec3 n;\n\n    vec3 p = h;\n\n    vec3 halfSize = (b.size*0.99999)/2.0;\n\n    vec3 lbf = (b.pos - halfSize);\n    vec3 rtb = (b.pos + halfSize);\n\n    if(p.x >= rtb.x){\n        n = vec3(1, 0, 0);\n    }\n    if(p.x <= lbf.x){\n        n = vec3(-1, 0, 0);\n    }\n    if(p.y >= rtb.y){\n        n = vec3(0, 1, 0);\n    }\n    if(p.y <= lbf.y){\n        n = vec3(0, -1, 0);\n    }\n    if(p.z >= rtb.z){\n        n = vec3(0, 0, 1);\n    }\n    if(p.z <= lbf.z){\n        n = vec3(0, 0, -1);\n    }\n\n    return normalize(n);\n}\n\nfloat getLighting(vec3 h, vec3 lpos, material inMat, int index){\n    float brightness = 1.0;\n\n    float lt;\n    material lmat;\n    int i;\n    vec3 lray = lpos - h;\n\n    bool rl;\n\n    if(inMat.type != 0.0){\n        rl = raytraceScene(h, lray, lt, lmat, i);\n    }else{\n        rl = false;\n    }\n\n    vec3 n = getBoxNormals(h, scene[index]);\n    //if(lmat.type != 0.0){\n        brightness = max(dot(normalize(lray), n), 0.1);\n    //}else{\n        //brightness = 1.0;\n    //}\n    \n    float spec = pow(max(dot(normalize(lray), n), 0.1), 15.0);\n    \n        if(rl && scene[index] != scene[i]){\n            if(lmat.type != 0.0){\n                spec = 0.0;\n                brightness *= 0.4;\n            }else if(lmat.type == 0.0){\n                brightness = max(dot(normalize(lray), n), 0.1);\n            }\n        }else{\n            if(lmat.type != 0.0){\n                spec = pow(max(dot(normalize(lray), n), 0.1), 15.0);\n                brightness = max(dot(normalize(lray), n), 0.1);\n            }else if(lmat.type == 0.0){\n                brightness = 1.0;\n            }\n        }\n\n    if(inMat.type == 2.0){\n        brightness += spec;\n    }\n\n    return brightness;\n}\n\nvec3 reflectRay(vec3 h, vec3 d, int index){\n    vec3 n = getBoxNormals(h, scene[index]);\n    return d - 2.0*n*dot(d, n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 initCol = vec3(0);\n    vec3 col = fogColor;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //scene[1].pos.x += sin(iTime*0.5)*3.0 + 4.0;\n    //scene[1].pos.z += sin(iTime*0.5)*3.0 - 2.0;\n    mat3 projection;\n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n\n    camera cam = camera(vec3(5, 5, -10), vec3(20, 20, 0));\n\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(cam.d.x*degreesToRadians), -sin(cam.d.x*degreesToRadians));\n    xRotation[2] = vec3(0, sin(cam.d.x*degreesToRadians), cos(cam.d.x*degreesToRadians));\n\n    mat3 yRotation;\n    yRotation[0] = vec3(cos(cam.d.y*degreesToRadians), 0, -sin(cam.d.y*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(cam.d.y*degreesToRadians), 0, cos(cam.d.y*degreesToRadians));\n\n    vec3 camd = normalize(vec3(uv, 1.0)*projection*xRotation*yRotation);\n    vec3 o = cam.o;\n\n    float focusRes = 0.15;\n    \n    float iteration = 1.0;\n    \n    for(float originMoveX = -1.0; originMoveX < 1.0; originMoveX += focusRes){\n        for(float originMoveY = -1.0; originMoveY < 1.0; originMoveY += focusRes){\n            o.x += (originMoveX*aperture)/(0.5/focusRes);\n            o.y += originMoveY*aperture;\n            //if(length(o.xy - cam.o.xy) < aperture/1.0){\n            float t;\n            material mat;\n            int i;\n            vec3 focalPoint = cam.o + camd*focalLength;\n            vec3 d = normalize(focalPoint - o);\n            \n            bool r = raytraceScene(o, d, t, mat, i);\n            \n            vec3 n = getBoxNormals(o + d*t, scene[i]);\n\n            float c = getLighting(o + d*t, lPos, mat, i);\n\n            if(r){\n                if(mat.type != 3.0){\n                    col = mix(mat.col*c, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                }else{\n                    float rt;\n                    int ri;\n                    material rmat;\n                    vec3 rd = normalize(reflectRay(o + d*t, d, i));\n\n                    bool reflectTrace = raytraceScene(o + d*t, rd, rt, rmat, ri);\n\n                    if(reflectTrace){\n                        float rc = getLighting((o + d*t) + rd*rt, lPos, rmat, ri);\n                        col = mix(mix(rmat.col*rc, mat.col, mat.intensity)*c, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                    }else{\n                        col = mix(mix(fogColor, mat.col, mat.intensity)*c, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                    }\n                }\n            }\n            iteration++;\n            initCol = mix(initCol, col, 1.0/(iteration));\n        }\n    }\n    \n    fragColor = vec4(pow(initCol, vec3(1.0/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msS3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1086, 1086, 1157, 1157, 2105], [2107, 2107, 2188, 2188, 2587], [2589, 2589, 2623, 2623, 3128], [3130, 3130, 3194, 3194, 4301], [4303, 4303, 4346, 4346, 4425], [4427, 4427, 4481, 4481, 7223]], "test": "untested"}
{"id": "DslSz7", "name": "Bendy Glass Cube", "author": "SnoopethDuckDuck", "description": "just playing about, very messy code. buffer + noise hides overstepping/artifacts quite well, looks cool i think", "tags": ["f"], "likes": 16, "viewed": 317, "published": 3, "date": "1668656696", "time_retrieved": "2024-07-30T16:19:10.777868", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n\tvec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "buffer_a_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 rayOri() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 3, -3);\n    ro.xz *= rot(-pi/2.);\n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat dist(vec3 p) {\n    float o = 2. * pi / 3.;\n    float t = exp(-2. * length(p)) + 0.25 * iTime;\n    p.xy *= rot(pi * thc(4., t + o));\n    p.yz *= rot(pi * thc(4., t));\n    p.zx *= rot(pi * thc(4., t -o));\n    float sd = length(p) - 1.6;\n    p = erot(p, normalize(vec3(1,2,3)), iTime);\n    //p.xz *= rot(-21.4 * iTime);\n    //p.xy *= rot(-11.4 * iTime);\n    float bd = sdBox(p, vec3(0.75)) - 0.;\n    //p.xz *= rot(10.4 * iTime);\n    p = erot(p, normalize(vec3(3,2,1)), -1. * iTime);\n    float c = 0.5 + 0.5 * cc(1.5, 0. * log(length(p)) + iTime);\n    c = pow(4. * c * (1.-c), 2.);\n    float bd2 = sdBox(p, vec3(0.3 + 0.15 * c)) - 0.1 * c;//(0.5 - 0.5 * c);\n    bd = -min(-bd, bd2);\n    return -min(-sd, bd);\n}\n\nfloat march(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = dist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        //dS *= .5 + .5 * h21(vec2(h21(p.xz + iTime),p.y + iTime));\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = dist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy),\n        dist(p-e.yxy),\n        dist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 tx = texelFetch(iChannel0, ivec2(fragCoord - 0. * vec2(2,3)), 0).rgb;//texture(iChannel0, uv).rgb;\n    vec3 ro = rayOri();\n    \n    vec3 rd = rayDir(uv, ro, vec3(0), 1.25);\n    vec3 col = vec3(0);\n   \n    float d = march(ro, rd, 1.);\n    \n    vec3 p = ro + rd * d;\n    float IOR = 1.2;\n    if(d<MAX_DIST) {        \n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 q = p - 4. * SURF_DIST * n;\n        vec3 rd2 = refract(rd, n, 1./IOR);\n        float d2 = march(q, rd2, -1.);       \n        vec3 p2 = q + d2 * rd2;\n        vec3 n2 = -normal(p2); \n        \n        vec3 q2 = p2 - 4. * SURF_DIST * n2;\n        vec3 rd3 = refract(rd2, n2, 1./IOR);\n        float d3 = march(q2, rd3, 1.);       \n        vec3 p3 = q2 + d3 * rd3;\n        vec3 n3 = normal(p3);\n\n        vec3 lightDir = normalize(vec3(1,2,3));//normalize(vec3(cos(iTime),0.5 * sqrt(2.),sin(iTime)));\n        float dif  = dot(n,  lightDir)*.5+.5;\n        float dif2 = dot(n2, lightDir)*.5+.5;\n        float dif3 = dot(n3, lightDir)*.5+.5;       \n       \n        float fres  = pow(1. + dot(rd, n),  5.);\n        float fres2 = pow(1. + dot(rd, n2), 5.);\n        float fres3 = pow(1. + dot(rd, n3), 5.); // hmm\n\n        //dif2 = pow(4. * dif2 * (1.-dif2), 8.);\n        //dif3 = pow(4. * dif3 * (1.-dif3), 8.);\n\n        float spec  = pow(dif,  32.);\n        float spec2 = pow(dif2, 32.);\n        float spec3 = pow(dif3, 32.);\n        \n        float t = iTime;\n        float th = pi * h21(t + vec2(h21(t + p.xy), p.z));\n        float th2 = 2. * pi * h21(t + vec2(h21(t - p.xy), -11. + p.z));\n        float m = 1.;\n        vec3 w = length(p3) * vec3(cos(th) * sin(th2), sin(th) * sin(th2), cos(th2));\n        col = 0.5 + 0.5 * normalize(p3 - w);\n        col += 0.5 * dif3;\n        float test = abs(dot(n3,n2));\n        // dividing by zero is fun\n        col /= 0.5 + 0.5 * thc(8., 4. * cross(p2,p3).y);\n        col *= clamp((dif3 + spec3) * vec3(test), 0., 1.);\n        \n        \n        //col *= 0.5 + 0.5 * thc(4., 2. * iTime);\n        col = clamp(col, 0., 1.);\n        col *= step(length(p3), MAX_DIST);\n        col = 4. * col * (1.-col);\n        col = pow(col, vec3(0.5));\n        col *= 0.8 + 0.4 * h21(uv + mod(iTime, 301.));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    //col = mix(tx, col, exp(-0.5 * iTime));\n    //col = normalize(col);\n    col = mix(tx, col,0.25);//exp(-0.5 * iTime));\n   \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 172]], "test": "untested"}
{"id": "DslXR7", "name": "Psychedelic Dodec interactive", "author": "timmaffett", "description": "License: CC0\nResults after some random coding while listening to online concert\n\njust added some mouse interaction-tmm", "tags": ["2d", "dodec"], "likes": 20, "viewed": 384, "published": 3, "date": "1668650924", "time_retrieved": "2024-07-30T16:19:11.687436", "image_code": "// Fork of \"Psychedelic Dodec experiment\" by None. https://shadertoy.com/view/-1\n// 2022-11-17 02:05:59\n\n// Fork of \"Psychedelic Dodec experiment\" by mrange. https://shadertoy.com/view/tdScD1\n// 2022-11-17 02:05:30\n\n// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\nconst float size  = 0.75 ;\nconst float offc  = 1.05;\nconst float width = 0.0125;\nconst int   rep   = 15 ;\n\n#define PHI   (.5*(1.+sqrt(5.)))\n#define PI    3.141592654\n#define TAU   (2.0*PI)\n#define TTIME (TAU*iTime)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width*7.5*(0.55 + 0.45*sin(10.0*length(p) - 0.5*p.y + TTIME/9.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100000.0;\n  float off = 0.30  + 0.25*(0.5 + 0.5*sin(TTIME/11.0));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(offc*size, 0.0);\n    vec2 cp = ip;\n    rot(ip, TTIME/73.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2(0.25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, 0.025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - 0.25*exp(-200.0*d*d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.5) : iMouse.xy/iResolution.xy;\n    \n\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = 2.0*(q - 0.5) * (mouse.x*2.0);\n  p.x *= iResolution.x/iResolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += (mouse.y*2.0)*0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(8.0, 9.0, 7.0)); \n  col *= 1.0 - tanh(0.05+length(8.0*d));\n\n  float phase = TAU/4.0*(-length(p) - 0.5*p.y) + TTIME/11.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 0.75);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(0.25, 0.5, 0.75));\n  col = postProcess(col, q, p);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslXR7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[768, 768, 807, 807, 896], [898, 898, 922, 922, 1332], [1334, 1334, 1367, 1367, 1452], [1454, 1454, 1472, 1472, 1933], [1935, 1935, 1979, 1979, 2261], [2263, 2263, 2318, 2318, 3200]], "test": "error"}
{"id": "DdSGR3", "name": "line thickness with functions", "author": "jonasfrey", "description": "from left to right\n---\nstep \nsmoothstep\ndistance normalized 0-1\ndistance normalized 0-1 then (modulo 0.2) / 0.2\nsqrt(n_dist)\npow(n_dist, 1.0/3.0) : (third root )\n\n", "tags": ["function"], "likes": 1, "viewed": 153, "published": 3, "date": "1668644307", "time_retrieved": "2024-07-30T16:19:12.688759", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 a_n_pix_cor_nor = fragCoord/iResolution.xy;\n    \n    float n_dist = abs(a_n_pix_cor_nor.y - 0.5);\n    //float n_dist = 0.5 - a_n_pix_cor_nor.y;\n    \n    float a_n_dist_modified[] = float[](\n        step(0.2, n_dist), \n        smoothstep(0.2, 0.25, n_dist), \n        n_dist, \n        mod(n_dist, 0.2)/0.2,\n        sqrt(n_dist),\n        pow(n_dist,1.0/3.0), \n        n_dist*n_dist*0.5\n    );\n    \n    for(\n        float n_index_norm_a_n_dist_modified = 0.0;\n        n_index_norm_a_n_dist_modified < 1.0; \n        n_index_norm_a_n_dist_modified+= (1.0/float(a_n_dist_modified.length()))\n    ){\n        float n = a_n_dist_modified[\n            int(n_index_norm_a_n_dist_modified*float(a_n_dist_modified.length()))\n        ];\n        if(a_n_pix_cor_nor.x > n_index_norm_a_n_dist_modified){\n            fragColor = vec4(n);\n        }\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cssXRM", "name": "wav form visualized", "author": "jonasfrey", "description": "wav", "tags": ["wave", "wav"], "likes": 0, "viewed": 168, "published": 3, "date": "1668644053", "time_retrieved": "2024-07-30T16:19:13.615281", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_pix_coo_nor_strech = (fragCoord.xy ) / iResolution.xy;\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n    \n    vec4 o_sound_data = texture(\n        iChannel0, \n        vec2(o_pix_coo_nor_strech.x, floor(o_pix_coo_nor_strech.y*10.0)/10.0)\n    );\n    float n_sample = o_sound_data.x;\n    \n    fragColor = vec4((n_sample));\n    \n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssXRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 482]], "test": "untested"}
{"id": "ddfXz7", "name": "1D Fuzzy SDF Visualizer", "author": "Hatchling", "description": "Fuzzy signed distance fields in 1D visualization.\nAverages multiple signed distance fields over time where the inside-outside boundary varies from 0 to 1.\nClick and drag to draw the source curve.\nThis process produces erosion heightmaps in 2D.", "tags": ["sdf", "visualizer", "1d", "graph", "fuzzy"], "likes": 5, "viewed": 221, "published": 3, "date": "1668642313", "time_retrieved": "2024-07-30T16:19:14.468999", "image_code": "// 1D visualization of a fuzzy signed distance field.\n// A fuzzy signed distance field is one that averages\n// multiple regular signed distance fields, but where for each sample,\n// the threshold that separates inside from outside is different.\n\n// The threshold is is uniformly distributed between 0-1.\n// It's basically integrating \"signedDist(x, threshold)\" as \"threshold\" changes from 0 to 1.\n// Where \"signedDist(x, threshold)\" is the minimum distance along the x-axis \n// from \"x\" to any point (within the range 0-1 along the x axis)\n// in a function \"F()\" that is greater than or equal to \"threshold\".\n\n// Legend: ----------------------------------\n// Orange curve : The function F() described above.\n//   Blue curve : The resulting fuzzy SDF.\n\n// Controls: ----------------------------------\n// Mouse Click + Drag: Change the value of the orange graph \n//                     at and around the given point.\n\n// Notice: ----------------------------------\n//\n// - It takes a while for the fuzzy SDF to resolve, but starts out\n//   low-resolution and gradually gets sharper. \n//   It takes a couple seconds to get a good result.\n//\n// - It resets if you draw a different orange curve,\n//   but once you stop drawing, it will converge again.\n//   Until then, you'll see a rough preview.\n//\n// - This isn't optimized, the search function is brute force,\n//   but it is 1D so this should be fine.\n\n// I'm not sure there is a simpler way to interpret what this process does,\n// but perhaps one can get an intuition for it by playing with it in 1-D.\n\nfloat sampleGraph( in float graphHeight, in vec2 fragCoord )\n{\n\n    //fragColor.rgb *= scale;\n    \n    float pixelHeight = fragCoord.y;   \n    \n    float range = (1.0 + abs(dFdx(graphHeight))) * 2.0;\n    \n    float upper = graphHeight + range;\n    float lower = graphHeight - range;\n    \n    float value = (pixelHeight - lower) / (upper - lower);\n    \n    // Convert to a line instead of a solid graph.\n    // Increase the range's multiplier from 1.0 to 2.0 to use this.\n    value = abs(value - 0.5) * 2.0;\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float graphHeight1;\n    {\n        // Determine mip level to try and have uniform samples per texel.\n        float densityPerFrag = texelFetch(iChannel0, ivec2(fragCoord.x, 0), 0).a; \n        float tgtDensityPerFrag = float(1 << 13);\n        float mipLevel = log(tgtDensityPerFrag/densityPerFrag)/log(2.0);\n        mipLevel = clamp(mipLevel, 0.0, 7.0);\n        \n        float scale = pow(2.0, mipLevel);\n        vec4 f = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0), mipLevel);\n        f /= f.a;\n        graphHeight1 = f.x * iResolution.y;\n    }\n\n    float graph1 = sampleGraph(graphHeight1, fragCoord);\n    \n    float graphHeight2;\n    {\n        // Determine mip level to try and have uniform samples per texel.\n        float f = texelFetch(iChannel1, ivec2(fragCoord.x, 0), 0).a; \n        graphHeight2 = f * iResolution.y;\n    }\n\n    float graph2 = sampleGraph(graphHeight2, fragCoord);\n    \n    fragColor = vec4(0,0,0,1);\n    \n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.7, 0.3), graph2);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.3, 0.7, 1.0), graph1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Contains the function to display.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y > 0.5)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    if(iFrame == 0)\n    {\n        fragColor = texture(iChannel1, fragCoord * 0.125 / iChannelResolution[1].xy).rrrr;\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    \n    \n    if(iMouse.z > 0.0)\n    {\n        float distanceToMouse = abs(iMouse.x - fragCoord.x) / iResolution.x;\n        \n        float weight = exp2(-distanceToMouse * 100.0);\n        weight = smoothstep(0., 1., weight);\n    \n        fragColor = mix(fragColor, vec4(iMouse.y / iResolution.y), weight);\n    }\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Contains the function to display.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 intFragCoord = ivec2(fragCoord);\n    \n    if(fragCoord.y > 0.5)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec4 prev = iMouse.z > 0.5 ? vec4(0) : texelFetch(iChannel1, intFragCoord, 0);\n    fragColor = prev;\n    \n    // The X center of \"my\" pixel (the current one being drawn).\n    float myCenter = float(intFragCoord.x) + 0.5;\n    float myHeight = texelFetch(iChannel0, ivec2(fragCoord.x, 0), 0).y;\n    \n    float distSum = 0.0;\n    \n    ivec2 intResolution = ivec2(iResolution.xy);\n    //float dither = fragColor.a * 0.56984029 + fragCoord.x * 0.7548776662;\n    float dither = fragColor.a * 0.7548776662 + fragCoord.x * 1.61803398875;\n    dither -= floor(dither);\n    \n\n    vec4 thresh = (vec4(0, 1, 2, 3) + vec4(dither)) / 4.0;\n    float maxDist = iResolution.x;\n    vec4 dist = vec4(maxDist);\n    bvec4 mySign = greaterThan(vec4(myHeight), thresh);\n\n    for(int iNeighbor = 0; iNeighbor < intResolution.x; iNeighbor++)\n    {\n        // This doesn't work for some reasosn.\n        /*int neighborX = (iNeighbor / 2) + 1;\n        if((iNeighbor % 2) == 0)\n            neighborX = -neighborX;\n            \n        neighborX += intFragCoord.x;\n        \n        if(neighborX > intResolution.x-1) neighborX = intResolution.x-1;\n        if(neighborX < 0) neighborX = 0;*/\n        \n        // Can't break early, I guess. Brute force it is. -shrug-\n        int neighborX = iNeighbor;\n            \n        // The X center of the neighbor pixel.\n        float neighborCenter = float(neighborX) + 0.5;\n        float neighborNearestEdge = neighborCenter + sign(myCenter - neighborCenter) * 0.5;\n\n        float distMeToNeighbor = abs(myCenter - neighborNearestEdge);\n\n        float neighborHeight = texelFetch(iChannel0, ivec2(neighborX, 0), 0).y;\n\n\n        bvec4 neighborSign = greaterThan(vec4(neighborHeight), thresh);\n\n        bvec4 signEquals = equal(mySign, neighborSign);\n        bvec4 neighborFurther = greaterThanEqual(vec4(distMeToNeighbor), dist);\n        \n        dist.x = signEquals.x || neighborFurther.x ? dist.x : distMeToNeighbor;\n        dist.y = signEquals.y || neighborFurther.y ? dist.y : distMeToNeighbor;\n        dist.z = signEquals.z || neighborFurther.z ? dist.z : distMeToNeighbor;\n        dist.w = signEquals.w || neighborFurther.w ? dist.w : distMeToNeighbor;\n    }\n\n    dist *= vec4(mySign) * 2.0 - vec4(1.0);\n\n    distSum += dist.x + dist.y + dist.z + dist.w;\n    \n    distSum /= (4.0 * maxDist);\n    distSum = distSum * 0.5 + 0.5;\n    \n    fragColor += vec4(distSum, distSum, distSum, 1) * 4.0;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfXz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1551, 1551, 1613, 1644, 2108], [2110, 2110, 2167, 2167, 3252]], "test": "untested"}
{"id": "msXXzM", "name": "Shadertoy Geographic", "author": "iapafoto", "description": "There is a cruel lack of wildlife documentary on \"shadertoy\" !\n/!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\\n/!\\    restart to get a good sound synchro!!!  /!\\\n/!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\ /!\\", "tags": ["penguin", "documentary"], "likes": 78, "viewed": 997, "published": 3, "date": "1668640426", "time_retrieved": "2024-07-30T16:19:15.495255", "image_code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n\n#define WITH_DOF\n\n#ifdef WITH_DOF\n\n// fade in out arround t during dt\n#define fade(t,dt) smoothstep(0.,dt,abs(iTime-t))\n//#define iTime (iTime + 120.)\n\nint[] txt = int[] (83,72,65,68,69,82,84,79,89,0,71,69,79,71,82,65,80,72,73,67,0); \n\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sample_dist_gaussian(vec2 uv) {\n    const int nstep = 3;\n    const float w[3] = float[3](1., 2., 1.);\n    float d, wij, dsum = 0., wsum = 0.;    \n    for (int i=0; i<nstep; ++i) {\n        for (int j=0; j<nstep; ++j) {\n            vec2 delta = vec2(float(i-1), float(j-1))/1024.;\n            d = textureLod(iChannel1, uv-delta, 0.).w - 127./255.;\n            wij = w[i]*w[j];\n            dsum += wij * d;\n            wsum += wij;\n        }\n    }\n    return dsum / wsum;\n}\n\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), sample_dist_gaussian(uv));\n}\n\nfloat sdMessage(vec2 p, int[21] text, int start, float scale, float bold) {\n    p /= scale;\n    float d = 9999.;\n    vec2 pp;\n\n    for (int i=min(iFrame,0)+start; i<text.length(); i++) {  \n        if (text[i] == 0) break;\n        d = min(d, sdFont(p, text[i]));\n        p.x-=.5;\n\n    }\n    return d*scale - bold;\n}\n\n//-----------------------------------------------\n// Based on Iq Dof\n//-----------------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    \n    if (iTime > 1. && iTime < 158.) {\n\n        float focus = 1.5;\n\n        float gTime = iTime - 40.;\n            \n        if (gTime < 110.) focus = 1.5;\n        if (gTime < 85.) focus = (1.25+.05*gTime); \n        if (gTime < 70.) focus = mix(6.,1.5,smoothstep(50.,60.,gTime));\n        if (gTime < 44.) focus = 10.;\n        if (gTime < 25.) focus = 7.;\n        if (gTime < 20.) focus = 2.;\n        if (gTime < 0.) focus = 5.;\n        if (gTime < -20.) focus = mix(2.,.25,smoothstep(.5,3.,iTime));\n\n        float a = 1.;\n\n        vec4 acc = vec4(0.0);\n        const int N = 12;\n        for( int j=-N; j<=N; j++ )\n        for( int i=-N; i<=N; i++ )\n        {\n            vec2 off = vec2(float(i),float(j));\n            vec4 tmp = texture( iChannel0, q + off/iResolution.xy ); \n            float depth = tmp.w;\n            vec3  color = tmp.xyz;\n            float coc = .001 + 3.*abs(depth-focus)/depth;\n            if( dot(off,off) < (coc*coc) ) {\n                float w = 1.0/(coc*coc); \n                acc += vec4(color*w,w);\n            }\n        }\n\n        vec3 col = acc.xyz / acc.w;\n\n\n        //-----------------------------------------------------\n        // postprocessing\n        //-----------------------------------------------------\n        // gamma\n        col = pow( abs(clamp(col,0.0,1.0)), vec3(0.5) );\n\n        // contrast, desat, tint and vignetting\t\n        col = col*0.8 + 0.2*col*col*(3.0-2.0*col);\n        col = mix( col, vec3(col.x+col.y+col.z)*0.333, 0.25 );\n        col *= vec3(1.0,1.02,0.96);\n        col *= pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.25);\n        col += .05*(vec3(hash22(q*100.),hash12(111.*q)) - .5);\n        fragColor = vec4(col,1.0);\n    \n        fragColor *= fade(20.,1.5); // fondu noir entre scene\n        fragColor *= fade(60.,1.); \n        fragColor *= fade(110.,1.5); \n        fragColor *= fade(125.,2.);\n  //      fragColor *= fade(140.,1.5);\n  //      fragColor *= fade(145.,1.5);\n  //      fragColor *= fade(165.,1.5);\n    } else {\n        vec2 uv = q-vec2(0.5);\n        uv.y /= iResolution.x/iResolution.y;\n        uv.x += .1;\n        float d = max(sdBox(uv-vec2(-.18,0), .6*vec2(.14,.2)), -sdBox(uv-vec2(-.18,0), .6*vec2(.1,.16)));\n        float dTxt = sdMessage(uv-vec2(-.05,.05), txt, 0,.11,0.);\n        dTxt = min(dTxt, sdMessage(uv-vec2(-.05,-.05), txt, 10,.11,0.));\n        vec3 col = mix(vec3(0), vec3(1,1,0),step(d,0.));\n        col = mix(vec3(1.),col, smoothstep(0.,1./iResolution.y,dTxt));\n        fragColor = vec4(col,1.0);\n    }\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor= texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n\n\n#endif", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n\n#define ZERO min(0,iFrame)\n\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\n\n//----------------------------------------------------------------------------------------\n// Dave Hoskins Hash functions\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in ...\nfloat hash11(float p) {\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * MOD3);\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\nfloat hash12( vec2 p ) {\n    p  = 50.*fract( p*.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n// utilise pour le texture3D\nvec3 noised(in vec2 x) {\n    vec2 p = floor(x),\n         w = fract(x),\n         u = w*w*(3.-2.*w);  \n    float a = hash12(p),\n          b = hash12(p+vec2(1,0)),\n          c = hash12(p+vec2(0,1)),\n          k1 = b - a,\n          k2 = c - a,\n          k4 = a - b - c + hash12(p+vec2(1));\n    return vec3( -1.+2.*(a + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 12.*w*(1.-w) * vec2(k1 + k4*u.y, k2 + k4*u.x) );\n}\n\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    float n = mix(h.x, h.y, p.z);\n    return n;\n}\n", "sound_code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n\nvec2 add = vec2(1,0);\n\n\n\nfloat tri(in float x) { \n    return abs(fract(x)-.5)*2.;\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nfloat Noise11(float x) {\n    float p = floor(x), f = fract(x);\n    f = f*f*(3.-2.*f);\n    return mix( hash11(p), hash11(p + 1.), f)-.5;\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 Noise21(float x) {\n    float p = floor(x), f = fract(x);\n    f = f*f*(3.-2.*f);\n    return  mix( hash21(p), hash21(p + 1.), f)-.5;\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 2 in...\nvec2 Noise22(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.-2.*f);\n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                   mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res-.5;\n}\n\n//----------------------------------------------------------------------------------------\n// Fractal Brownian Motion...\nvec2 FBM22(vec2 x) {\n    vec2 r = vec2(0);\n    float a = .6;\n    for (int i = 0; i<8; i++) {\n        r += Noise22(x * a) / a;\n        a += a;\n    }\n    return r;\n}\n\n\n\nvec2 mainSound( in int samp, float time) {\n    float gTime = time - 40.;\n\n    int sceneId = 6;\n         if (gTime <-20.) sceneId = -2;\n    else if (gTime <  1.) sceneId = -1;\n    else if (gTime < 20.) sceneId = 0;\n    else if (gTime < 25.) sceneId = 1;\n    else if (gTime < 44.) sceneId = 2;\n    else if (gTime < 70.) sceneId = 3;\n    else if (gTime < 85.) sceneId = 4;\n    else if (gTime < 105.) sceneId = 5;\n    else sceneId = 6;\n\n\n    vec2 audio = vec2(.0);\n    \n    // le vent    \n    for (float t = 0.0; t < 1.0; t+=.5)\n    {\n        time = time+t;\n        vec2 n1 = FBM22( time*(Noise21(time*3.25)*40.0+Noise21(time*.03)*5500.0+9500.0)) * (abs(Noise21(time)))*1.5;\n        vec2 n2 = FBM22( time*(Noise21(time*.4)+1900.0))*abs(Noise21(time*1.5))*1.5;\n        vec2 n3 = FBM22( time*(Noise21(time*1.3)+Noise21(-time*.03)*200.0+1940.0))*(.5+abs(Noise21(time-99.)))*1.5;\n        vec2 s1 = sin(time*3300.+(Noise21(time*.23))*(Noise21(-time*.12)*3000.0+4000.0))*abs(Noise21(time*32.3+199.))*abs(Noise21(-time*.04+9.)+.5)*3.;\n\n        audio += (n1+n2+n3+s1)/8.0;\n    }\n    \n    if (sceneId == -1) {\n        audio *= .1;\n    } else if (sceneId == 5) {\n        audio *= 2.; // bcp de event\n    }\n    // Les pas\n    if (sceneId > -2 && sceneId < 3 || sceneId == 5) { \n        float foot = tri(time*(sceneId == 1 ? 3.7 : 1.85));\n        audio += 6. * Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot));\n\n        if (sceneId > -1) { // + de pas\n            foot = tri(time*1.85+.8);\n            audio += 6. * Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot));\n        }\n        if (sceneId == 5) { // + de pas\n            foot = tri(time*1.85+1.2);\n            audio += 6. * Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot));\n        }\n    }\n    if (sceneId == -2) audio *= .25 +.15*cos(time*1.5);  // ocean\n    if (sceneId == 1) audio *= .05; // glissades\n  \n    return .15*clamp(audio, -1.0, 1.0); \n    \n    \n}\n", "sound_inputs": [], "buffer_a_code": "// Created by Sebastien Durand - 11/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//-----------------------------------------------------\n// Sounds based with minor changed on\n//     Dave Hoskins [Frozen wasteland] https://www.shadertoy.com/view/Xls3D2\n// ------------------------------------------------------------\n// Many part of shading based on \n//     iq [Bridge] https://www.shadertoy.com/view/Mds3z2\n// ------------------------------------------------------------\n// Penguin feets and texture bedes on\n//     kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\n// ------------------------------------------------------------\n//#define iTime (iTime + 120.)\n\n\n#define FAR 30.\n\n#define  GROUND 0.\n#define  BODY 1.\n#define  BROW 2.\n#define  BEAK 3.\n#define  EGG 4.\n#define  HEAD 5.\n#define  FEET 6.\n#define  AILE 7.\n#define  COU 8.\n\n#define PI 3.141592653592\n\n#define WITH_SHADOW\n\nfloat gTime;\n\nint sceneId = 0;\nbool withBBox = true;\nbool isStanding = true;\nbool isWalking = false;\n\n\nfloat fogmap(in vec3 p, in float d) {\n    float time = 5.*iTime;\n    p.xz -= time*7.+(sin(p.z)+1.2+cos(p.x))*3.;\n    p.y -= time*.5;\n    return (max(noise3D(p*.008+.1),.0)*noise3D(p*.1))*.3;\n}\n\n\n// b(t) = (1-t)^2*A + 2(1-t)t*B + t^2*C\nvec3 bezier( vec3 A, vec3 B, vec3 C, float t ) {\n    return (1.-t)*(1.-t)*A + 2.*(1.-t)*t*B + t*t*C;\n}\n// b'(t) = 2(t-1)*A + 2(1-2t)*B + 2t*C\nvec3 bezier_dx( vec3 A, vec3 B, vec3 C, float t ) {\n    return 2.*((t-1.)*A + (1.-2.*t)*B + t*C);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 opSunFlowerRep(in vec2 p, inout vec2 id, bool norot, vec2 k) {\n    float a = atan(p.x, p.y);\n    vec2 b = vec2(0, length(p))/k.y + a/(2.*PI);\n    b.x = ceil(b.y) - b.x;\n    b.x *= b.x * 2.*1.618/k.x;\n    id = vec2(floor(b)); // x: pos from center, y: id of circle\n    b = k.y*(fract(b)-.5); // [-1:1] o n y and y\n    b.x *= k.x;\n    if (norot) b *= rot(a);\n    return b;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*.5,\n\t      c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) {\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c < start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n//////////////\n// distance functions from from https://iquilezles.org/articles/distfunctions\n/////////////\n\nfloat smin(float a, float b , float s){\n    float h = clamp(.5 + .5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.-h)*s;\n}\n\nfloat smax(float a, float b, float s){\n    float h = clamp(.5 + .5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.-h)*s;\n}\n\n// iq - https://www.shadertoy.com/view/Wdjfz3\nfloat sdEgg(vec3 q, float sz) {\n    const float k = sqrt(3.);\n    float r = sz*(.6 - .3);\n    vec2 p = vec2(length(q.xz), .9*q.y);    \n    return (p.y<0. ? length(p) - r : k*(p.x+r)<p.y ? length(vec2(p.x,  p.y-k*r)) : length(vec2(p.x+r,p.y)) - 2.*r) - sz*.3;\n}\n\n// iq - https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec3 p, vec3 b0, vec3 b1, vec3 b2) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    float t = clamp((a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)/dot(g,g))/m, 0., 1.);\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n}\n\nvec3 sdBezierUV(vec3 p, vec3 a, vec3 b, vec3 c, vec2 h) {\n    vec3 bb = normalize(cross(b-a,c-a)),\n         qq = bezier(a,b,c,h.y),\n         tq = normalize(bezier_dx(a,b,c,h.y));  \n    return vec3(dot(p-qq, normalize(cross(bb,tq))), h.y, dot(p-qq,bb));\n}   \n\nfloat sdSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba*clamp(dot(pa,ba)/dot(ba,ba), 0., 1. ));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    float k0 = length(p/r), k1 = length(p/(r*r));\n    return k0*(k0-1.)/k1;\n}\n\nvec3 bend(vec3 p, float angle){\n\tfloat c = cos(angle*p.z), s = sin(angle*p.z);\n    return vec3(mat2(c,-s,s,c)*p.yz,p.x);\n}\n\nfloat hGround(vec3 p) {\n    p.zx = p.xz;\n    p.y *= 1.5;\n    float tx = .1*(cos(p.x*.03))*(textureLod(iChannel1, p.xz/16. + p.xy/80., 0.0).x);\n    vec3 q = p*.25;\n    float h = tx + .5*(dot(sin(q)*cos(q.yzx), vec3(.222))) + dot(sin(q*1.3)*cos(q.yzx*1.4), vec3(.111));\n    return (sceneId == -1 ? -2.7 : sceneId == 3 ? -.5 : -1.) * smin(0.,smoothstep(.2,3., abs(p.z))*h*5.,.2);\n}\n\n\n///////////////////////////\n///////////////////////////\n///////////////////////////\n\n\n// kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\nfloat sdToes( vec3 p, vec2 h) {\n  p.x += sin(p.x * 40.) * .007 + cos(p.y * 600.) * .001;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\n// kuvkar [AngryBird] https://www.shadertoy.com/view/ldKXRz\nfloat sdFeet(vec3 rp, inout float body, float dfeet, float side) {\n    vec3 legpos = vec3(side*.055, -.16, 0.),\n     nFeet = vec3(0., .12, .01);\n    float a = -.5*dfeet;\n    nFeet.yz *= rot(a);\n    vec3 footpos = legpos - nFeet;\n    float leg = sdSegment(rp, -legpos, mix(legpos, footpos,.45)) - .03;\n    body = smin(body, leg,.02);\n    vec3 pFeet = rp - footpos;\n    pFeet.yz *= rot(-a);\n    float d = sdToes( (pFeet + vec3(0, -.03, -.01)), vec2(.012, .01)) - .008;\n    pFeet.x = abs(pFeet.x); \n    d = smin(d, sdToes( bend (pFeet + vec3(0, -.02, .01) , 4.), vec2(.01, .045)), .01);\n    pFeet = bend(pFeet + vec3(-0.015, -.02, .02), 12.);\n    pFeet.zy *= rot(-.4);\n    return smin(d, sdToes(pFeet, vec2(.009, .03)), .01);\n}\n\n\nfloat sdPenguin(in vec3 rp, in vec3 p0, float hG, float id, inout vec4 r) {\n    rp.y -= hG + .27;\n  \n    float Time = (sceneId ==-2 || sceneId == 3 ? .3*iTime : iTime) + .2*id,\n         t = 1.85*Time,\n         k = cos(PI*t);\n\n    if (!isStanding) {\n        rp.z = -rp.z;\n    }\n    if (isWalking) {   \n        rp.z += .02*cos(1.57+PI*t*2.);  // avance de la marche\n        rp.x += .1*hash11(10.*id); // position decalle suivant id\n    }\n    rp.x *= .9+.2*hash22(vec2(id,id)).x; // +/- gros et grands suivant id\n\n    if (!isStanding) {\n        rp.xyz = rp.xzy + vec3(0,0,.22);\n    }\n    \n    // Fastest thanks to this bounding box\n    if (withBBox) {\n        float dBox = sdEllipsoid(rp-vec3(0,.025,0), isStanding?vec3(.3,.35,.2):vec3(.5,.4,.3));\n        if (dBox > 0.) return dBox + .005+.01*hash12(p0.xz+p0.y);\n    }\n    \n    vec3 headPos = vec3(0, .26, -.05), \n         peak = - .14 * vec3(0.,0.,1.),\n         legpos1 = vec3(.055, -0.16, -.02),\n         legpos2 = vec3(-.055, -0.16, -.02),\n         nFeet1 = vec3(0., .12, .01),\n         nFeet2 = vec3(0., .12, .01);\n    float up = 0., dfeet = 0., dfeet1 = 0., dfeet2 = 0.,\n          k0 = cos(PI*t), k1 = cos(PI*t+.25), k2 = cos(PI*t-.25);\n    \n    if (isWalking) {    \n         dfeet = .5*sign(k)*pow(abs(k),1.5);\n         dfeet1 = .5*sign(k1)*pow(abs(k1),1.5);\n         dfeet2 = .5*sign(k1)*pow(abs(k2),1.5);\n         up = rp.x>0. ? .2 - .2*dfeet : .2 + .2*dfeet; \n         nFeet1.yz *= rot(.5*(.6+dfeet1));\n         nFeet2.yz *= rot(-.5*(.6-dfeet2));\n    }\n    \n    float body = 999.; \n        \n    if (isWalking) {    \n        vec3 rotPos = mix(legpos1 - nFeet1, legpos2 - nFeet2, .5+.5*k);\n        rp -= rotPos; \n        rp.yz *= rot(-.1);  // penche en avant pendant la marche\n        rp.xy *= rot(.25*.25*dfeet); // penche sur le coté\n        rp.xz *= rot(-.5*dfeet); // tourne autour du pied\n        rp += rotPos;\n    }\n    \n    vec3 rpHead = rp - headPos;\n    if (!isStanding) {\n        headPos.z += .15;\n        rpHead.yz *= rot(4.84);\n        rpHead.y -= .15;\n    }    \n    if (sceneId == 4) {\n        rpHead.yz *= rot(1.+.05*cos(.3*iTime)); // rotation haut bas\n        rpHead += vec3(0,-.025,.035);\n        \n    } else if (sceneId == 5) {\n        rpHead.xz *= rot(-.5*cos(2.*Time)); // droite gauche\n        rpHead.yz *= rot(.5+.2*cos(Time)); // rotation haut bas\n        rpHead += vec3(0,-.01,.02);\n    } else {        \n        rpHead.yz *= rot(-.06*cos(5.*Time+cos(Time))); // rotation haut bas\n        rpHead.xz *= rot(-.5*cos(2.*Time)); // droite gauche\n    }\n   // rpHead.zy += .02*headup;\n    \n    vec3 rp_real = rp;\n\trp.x = -abs(rp.x); // most of the stuff is just mirrored\n\n    // body\n    body = min(body, sdEllipsoid(rp, vec3(.12,.22,.1)));\n    // pectoraux\n    body = smin(body, sdEllipsoid(rp-vec3(-0.0,.105,-.03), vec3(0.1-.005*up,.08,.055-.005*up)), .02);\n    // queu\n    body = smin(body, sdSegment(rp, vec3(0,-.18,.05), vec3(0,-.28,.12)) + .3*(rp.z -.12)-.01, .05);\n\n    float body0 = body;\n    \n    // aile\n    vec3 pa = rp - vec3(-.1,.125,.02);\n    pa.xz *= rot(.2); // rotation axe \n    \n    if (sceneId == 4) {\n        pa.zy *= rot(.3+.3*cos(.5*iTime+id));\n        pa.xy *= rot(.5-.03*cos(.41*iTime+2.*id)); // Leves\n    } else {\n        pa.zy *= rot((isStanding ? -1.5*up : 0.) +.3);//+.1*cos(8.*Time)); // Avant arriere\n        pa.xy *= rot(isStanding ? .3 : .5-.3*k1); // Leves\n    }\n    pa += vec3(-.01+.02*up,.16,.0);  \n     \n    float aile = sdEllipsoid(pa, vec3(.025,.15,.06));\n    aile = smin(aile, -sdEllipsoid(pa-vec3(.04,-.037,.03), vec3(.054,.17,.08)), -.03);\n    body = smin(body, aile, .03*smoothstep(.07,.15,pa.y));\n    \n    // head\n    float head = sdEllipsoid(rpHead, vec3(.04,.04,.06));\n    body = min(body, head);\n    // bec\n    vec2 bez = sdBezier(rpHead, .4*peak, peak, peak + vec3(0,-.02,-.001));\n    body = smin(body, (bez.x - .002-.01*smoothstep(1.,.3, bez.y)), .03);\n   \n    // oeil\n    rpHead.x = abs(rpHead.x);\n    vec3 eyePos = vec3(.019, .01, -.04);\n   \n    float dEye = length(rpHead - eyePos-vec3(-.007,0,0)) - .012;\n     \n    vec3 uvEye = rpHead - eyePos;\n    float dEyeHole = max(length(rpHead - eyePos-vec3(0,.007,0)), \n                         length(rpHead - eyePos+vec3(0,.007,0)))- .015;  \n    \n    // cou\n    vec2 cou = sdBezier(rp_real, headPos, vec3(0, .2,.02), vec3(.0, .15,.03));\n   \n    body = smin(body, cou.x-.04,.01);\n    body = max(body, -dEyeHole);\n    body = min(body, dEye);\n     // legs\n    float feet = min(sdFeet(rp_real, body, .6+dfeet1, 1.), sdFeet(rp_real, body, .6-dfeet2, -1.)); \n    \n    float d = body0;\n    r = vec4(BODY, rp);\n\n    if (head < d) {\n        d = head; r = vec4(HEAD, rpHead);\n    }\n    if (aile < d) {\n        d = aile; r = vec4(AILE, pa);\n    }\n    if (feet < d) {\n        d = feet; r = vec4(FEET, rp);\n    } \n    if (cou.x-.04<d) {\n        vec3 uvCou = sdBezierUV(rp_real, headPos, vec3(0, .2,.02), vec3(.0, .15,.03), cou);\n        d = cou.x-.04; \n        r = vec4(COU, isStanding ? uvCou : vec3(-uvCou.x, uvCou.y, uvCou.z));\n    } \n\n    return min(feet, body);\n}\n\n\nvec4 rColor;\n\n\nfloat mapGround(in vec3 p0) {\n    return p0.y - hGround(p0);\n}\n\nfloat map(in vec3 p0) {\n    float hG = hGround(p0),\n          dGround = p0.y - hG;\n\n    vec3 p = p0;\n    float id = 0.;\n    if (sceneId == 4) {\n        p.z +=.1;\n        id = sign(p.z);\n        p.z = abs(p.z);\n        p.z -=.16;\n        p.x += .01*id;\n        \n    } else if (sceneId == 3) {\n        vec2 id3 = vec2(0);\n        vec3 p1 = p0;\n        p1.xz += 20.;\n        p.xz = opSunFlowerRep(p1.xz, id3, false, vec2(2.5,1.1));\n        // Couples\n        if (mod(id3.y,2.) <.5) p.z = -p.z;\n        p.z += .35*smoothstep(25.,35., gTime);\n        id = id3.x;\n        \n    } else if (sceneId == 5) {\n        vec2 id3 = vec2(0);\n        vec3 p1 = p0;\n     //   p1.xz -= vec2(3.,9.);\n        if (length(p1.xz)>5.2) return 999.;\n        p.xz = opSunFlowerRep(p1.xz, id3, false, vec2(.7,.4));\n        p.xz = p.zx;\n        //p.x += .05;\n        id = id3.x;\n        if (id < 5. /*|| id>700.*/) return 1.;\n        \n    } else if (sceneId != -2) {\n         float dz = sceneId == -1 || sceneId == 6 ? .29*gTime-2. : .14*gTime;\n         if (sceneId == 1) {\n             p = p0;\n             p.x -= 5.;\n             dz *= 6.;  // 6 fois plus rapide en glissades\n         }\n        \n         if (sceneId == 6) {\n             p.z = -p.z + dz;\n         } else {\n             p.z += dz;\n         }\n         float id2 = 0.;\n         if (sceneId == 2) {\n             p.x += .8*cos(.5*p.z+cos(.1*p.z));\n             id2 = pModInterval1(p.x, .45, -1.,1.);\n             p.z += .6*hash11(id2+1.2);\n         }\n\n//p.z = mod(p.z +.45, .9) - .45;\n         id = id2*100.+ pModInterval1(p.z, sceneId == -1 ? 16. : sceneId == 6 ? 3.8 : .9, -58.,58.);\n         if (sceneId == 6) p.xz += vec2(3,2)*(.5-hash22(vec2(id, id2)));\n         if (sceneId == 1 || id>2. && id<4.) isStanding = false;\n     }\n          \n     float d = sdPenguin(p, p0, hG, id, rColor);\n     isStanding = true;\n     if (sceneId == 4) {\n        float d0 = sdEgg(p0-vec3(-.04,.085,-.04),.075);\n        if (d0<d) {\n            d = d0;\n            rColor = vec4(EGG,p0);\n        }\n     }\n     return d * (sceneId == 3 ? .45 : .7);\n\n}\n\n//-------------------------------------------------------------\n//     Textures 3D (Shane)\n//-------------------------------------------------------------\n\nvec3 tex3D(in vec3 p, in vec3 n){\n    p += 10.;\n    p *= 100.;\n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n\treturn noised(p.yz)*n.x + noised(p.zx)*n.y + noised(p.xy)*n.z;\n}\n\n// Grey scale.\nfloat grey(vec3 p) { return dot(p, vec3(.299, .587, .114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap(vec3 p, vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3(grey(tex3D(vec3(p.x-ep, p.y, p.z), n)),\n                     grey(tex3D(vec3(p.x, p.y-ep, p.z), n)),\n                     grey(tex3D(vec3(p.x, p.y, p.z-ep), n)));\n    grad = (grad - grey(tex3D(p, n)))/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n//---------------------------------------------------------------------\n//   Calculate normal\n// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n//---------------------------------------------------------------------\nvec3 normal(in vec3 pos, vec3 rd, float t, float k) {\n    withBBox = false;\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(pos+k*e);\n    }\n\treturn normalize(n - max(0., dot(n,rd))*rd);\n}\n\nvec3 normalGround(in vec3 pos, vec3 rd, float t, float k) {\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*mapGround(pos+k*e);\n    }\n\treturn normalize(n - max(0., dot(n,rd))*rd);\n}\n\n#ifdef WITH_SHADOW\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k ) {\n    withBBox = false;\n    float res=1., t=.05+.1*hash22(rd.xy).x, h=1.;\n    for(int i=ZERO; i<48; i++ ) {\n        h = min(map(ro + rd*t), mapGround(ro + rd*t));\n        res = min( res, k*h/t );\n\t\tt += clamp( h, .01, .1);\n\t\tif (h<.005) break;\n    }    \n    return clamp(res,0.,1.);\n}\n\n#endif\n\nvec3 skyColor(vec3 col, vec3 ro, vec3 rd, float sun) {\n    vec2 cuv = ro.xz + rd.xz*(100.-ro.y)/rd.y;\n    float cc = texture( iChannel1, .0003*cuv + .1+ .0023*iTime ).x;\n    cc = .65*cc + .35*texture( iChannel1, .0006*cuv + .00115*iTime ).x;\n    cc = smoothstep( .3, 1., cc );        \n    return mix( col, vec3(.95+.20*(1.-cc)*sun), .7*cc );\n}\n\n\nfloat trace(vec3 ro, vec3 rd, inout vec3 col) {\n   // vec3 ro = rp;\n\n\tfloat d, precis = .006, t = 0., tg = 0., m = -1., fog = 0.;\n\n    for (int i=ZERO; i<200; i++) {\n        t += d;\n\t    d = map(ro+rd*t);     \n        if (sceneId>4) fog += fogmap(ro+rd*t, t);\n        if (abs(d) < 1e-2*t*precis || t>FAR) \n            break;\n    }\n\n    for( int i=ZERO; i<300; i++) {\n\t    d = mapGround(ro+rd*tg);\n        tg += d;\n        if (abs(d) < 1e-2*tg*precis || tg>t) \n            break;        \n    }\n    fog = min(1., .05*fog);\n    \n    vec3 pos, nor;\n    \n    if (tg < t) {\n        pos = ro+rd*tg;\n        rColor = vec4(GROUND, pos);\n        t = tg;\n        nor = normalGround(pos, rd, t, .05);\n    } else {\n        pos = ro+rd*t;\n        withBBox = false;\n        map(pos); // To get Color in rColor\n        nor = normal(pos, rd, t, .007);\n    }\n \n    vec3 lig = normalize(vec3(-.5,.25,-.3));\n    col = .9*(2.5*vec3(.18,.33,.45) - rd.y*1.5);\n    \n    float sun = clamp( dot(rd,lig), 0., 1.);\n\tcol += vec3(2,1.5,0)*.8*pow( sun, 32.);\n    \n    vec3 bgcol = col, color = bgcol, mate2 = vec3(0);\n    bool isSea = false;\n\n    if (t<FAR) {\n        vec3 ch = vec3(.04), cb = vec3(.1), cw = vec3(1),\n             uvw = rColor.yzw;\n       \n        float kspe = .1; // coeff specularity\n        if (rColor.x == BEAK) {\n            kspe = 1.;\n        }\n        if (rColor.x != BEAK && rColor.x != EGG && rColor.x != GROUND) {\n            nor = doBumpMap(rColor.yzw*3.1*vec3(1,.2,1)+2., nor, .0005); \n            cb += .05*tex3D(5.*rColor.yzw*vec3(1.,.25,1.), nor).x;\n        }\n       \n        color = vec3(.7);\n        \n        if (rColor.x == EGG) {\n            color = vec3(.9,1.,.8);\n            \n        } else if (rColor.x == HEAD) {\n            color = mix(ch, .5*vec3(1,.55,.5), smoothstep(.03,.025, length(vec2(9.,1.)*(rColor.zw-vec2(-.008,-.107)))));\n            \n            vec2 eyePos = rColor.zw - vec2(.014,-.038);\n            float dEye = max(length(eyePos-vec2(.003,0)), length(eyePos+vec2(.003,0)))- .007;  \n            kspe = dEye < 0. ? 2. : .1; \n            vec3 colEye = mix(vec3(0), .1*vec3(1,.7,.5), .6+.4*smoothstep(.0,.001, length(eyePos+vec2(0,.006))-.004));\n            color = mix(colEye, color, smoothstep(.0,.001, dEye));\n            \n        } else if (rColor.x == AILE) {\n            color = mix(cb, cw, smoothstep(.001,.02,rColor.y+.1*(rColor.w-rColor.z)));\n           \n        } else if (rColor.x == BODY) {\n            \n            color = vec3(1);\n          \n            color = mix(color, vec3(1,.5,0), smoothstep(.14,.2, rColor.z));\n            color = mix(color, vec3(1,1.,0), smoothstep(.17,.2, rColor.z));\n            \n            color = mix(cb, color, smoothstep(.03,.04,-rColor.w+.03 -.024*sin(.7+12.*uvw.y)));\n            \n            color = mix(mix(vec3(1,1,0),vec3(1,1,1), smoothstep(.0,.01, length(rColor.z)-.199)),\n            color, smoothstep(.039,.042, length(rColor.zw-vec2(.235,0))+.003));\n            // le petit trait noir des epaules\n            color = mix(ch, color, smoothstep(.0,.005, sdSegment(vec3(0,rColor.z,rColor.w), vec3(0,.1,-.024), vec3(0,.195,-.01))-.05*(rColor.z-.1)));\n            \n        } else if (rColor.x == COU) {\n        \n            color = .5+.5*cos(vec3(200,20,200)*rColor.yzw);\n            vec3 uv = vec3(200,20,200)*rColor.yzw - vec3(0,8,0);\n\n            color = mix(cw, vec3(1,1,.001), smoothstep(-2.,2., -uv.y));\n            color = mix(color, vec3(1,.5,.001), smoothstep(-1.,5., -uv.y));\n            color = mix(color, mix(ch,cb, smoothstep(-4.,8.,uv.y)), smoothstep(.4,.0, 4.+uv.y+1.8*cos(.6*uv.z)-20.*smoothstep(.1,8.,-uv.x)));\n       \n       } else if (rColor.x == FEET) {\n            color = vec3(.3);\n            kspe = .2;\n            \n        } else if (rColor.x == GROUND) {\n            color = vec3(.97);\n            float dSea = pos.y - (.02 + .005+.005*cos(1.5*iTime+length(pos.xz)));\n            isSea = (sceneId == -2 && pos.z>-3. && dSea<.007);\n\n            if (isSea) {\n               color = mix(color,.2*vec3(.5,.7,.9), smoothstep(.012, .0, dSea));\n           //  color = mix(color+.1*vec3(0,1,1), color, smoothstep(.0, .01, dSea+.02+.001*cos(iTime)));\n            }\n           \n            kspe = .5;\n            nor = doBumpMap(rColor.yzw*.7, nor, .0003); \n\n            float iss = smoothstep( .5, .9, nor.y );\n            iss = 2.*mix( iss, .9, .75*smoothstep( .1, 1., noise3D(.25*pos)));\n            vec3 cnor = normalize( -1. + 2.*texture( iChannel2, .25*pos.xz).xyz );\n            cnor.y = abs(cnor.y);\n            float spe2 = max(0., pow( clamp( dot(lig,reflect(rd,cnor)), 0., 1.), 16.));\n            mate2.y = spe2*iss*(.5+.5*cos(20.*iTime+6.28*hash12(pos.xz)));\n        }\n\n\t\t// lighting\n        float sky = .6 + .4*nor.y,\n             bou = clamp(-nor.y,0.,1.),\n             dif = max(dot(nor,lig),0.),\n             bac = max(.2 + .8*dot(nor,normalize(vec3(-lig.x,0,-lig.z))),0.);\n\t\t\n#ifdef WITH_SHADOW\n        float sha = 0.;\n        if (dif > 0.) {\n            sha = softshadow( pos+.075*nor*hash12(10.*pos.xy+1.234*pos.z), lig, 4.);\n        }\n#else         \n        float sha = 1.;\n#endif\n        float fre = pow(clamp(1.+ dot(nor,rd), .01, 1. ), 3. ),\n              spe = pow(max( dot( reflect(-lig, nor), -rd ), 0.), 16.); // Specular term.\n\t\t// lights\n\t\tvec3 lin = dif*vec3(1.7,1.15,.7)*pow(vec3(abs(sha)),vec3(1.,1.2,2.));\n\t\tlin += 1.2*bou*vec3(.15,.2,.2);\n        lin += fre*vec3(1,1.25,1.3)*.5*(.5+.5*dif*sha)\n                    +sky*vec3(.05,.20,.45)\n\t\t\t\t\t+bac*vec3(.2,.25,.25);\n \n        lin += mate2.y*vec3(1,.6,.5)*4.*dif*(.1+.9*sha);\n        col = color*lin + (.5+.5*color)*spe*kspe;//*sha;\n    \n        if (rColor.x == GROUND) {\n            vec3 ref = reflect(rd, nor);\n            col += .2*col*skyColor(bgcol, pos, ref, clamp(dot(ref,lig), 0.0, 1.0 )); \n        }\n        col = mix( col, bgcol, smoothstep(15.,FAR,t) );\n\n        if (isSea) {\n           col += skyColor(col, pos, reflect(rd, nor), sun);\n        }\n    } else {\n        col = skyColor(col, ro, rd, sun);\n    }\n\n\t// sun glow\n    col += vec3(1,.6,.2)*.4*pow( abs(sun), 4.);\n  \n    if (sceneId >= 5) {\n       col = mix(.7*col, vec3(0.6, .65, .7), sqrt(fog));\n       col = length(col)*.2 + .8*col;\n    }\n    \n    return t;\n}\n\nmat3 lookat(vec3 from, vec3 to) {\n    vec3 f = normalize(to - from),\n         u = normalize(cross(normalize(cross(f, vec3(0,1,0))), f));\n    return mat3(normalize(cross(u, f)),u,f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    rColor = vec4(0);\n\n\tvec2 q = fragCoord.xy / iResolution.xy,\n         uv = q-.5;\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1)),\n         rp = vec3(0, 1, -2.2);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    \n    gTime = iTime - 40.;\n    \n    sceneId = 6; \n   \n    if (gTime < -20.) sceneId = -2;\n    else if (gTime < 1.)  sceneId = -1;\n    else if (gTime < 20.) sceneId = 0;\n    else if (gTime < 25.) sceneId = 1;\n    else if (gTime < 44.) sceneId = 2;\n    else if (gTime < 70.) sceneId = 3;\n    else if (gTime < 85.) sceneId = 4;\n    else if (gTime < 105.) sceneId = 5;\n    else sceneId = 6;\n    \n    isWalking = true;\n\n    if (sceneId == 5) {\n        float dd = smoothstep(135.,145., iTime);\n        if (uv.x<mix(.7,-.7,dd)-uv.y*.25) { \n            uv *= mix(1.,2.,dd);\n        } else {\n            uv.x -= mix(.5,0.,dd);\n            sceneId = 6;         \n        }\n    }\n    \n    if (sceneId == -2) { \n        gTime = iTime;\n        isWalking = false;\n        gTime = iTime;\n        withBBox = false;\n        rp = vec3(.0,.57,-.15) + mix(.2,.7,gTime/20.)* vec3(-cos(.1*gTime), -.05, sin(.1*gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(.0,.57,-.15)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == -1) { \n        gTime = iTime-20.;\n        rp = mix(vec3(2.7,.5,-4.), vec3(20,7.,33), smoothstep(7.,27.,gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,1.,-2)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == 0) {\n        // Marche petit groupe\n        if (sceneId == 6) gTime = iTime - 145.;\n        rp = vec3(2.7-.05*gTime,-1.+.035*gTime,1.7);\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,0.5,0)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == 6) {\n        // Marche petit groupe retour\n        gTime = iTime - 145.;\n        rp = vec3(.7,.7+.035*gTime,-36.+.39*gTime);\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,0.5,-38.+.39*gTime)) * normalize(vec3(uv, 1.));\n\n    } else if (sceneId == 1) {\n        // Glissades\n        rp = vec3(3.7,1.,-18.7);\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(5,0.5,-15.)) * normalize(vec3(uv, 1.));\n        \n    } else if (sceneId == 2) {\n        // Marche en grand groupes\n        rp = vec3(12.7,3.5+.035*gTime,.7-.5*gTime); \n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(-2.,.5,10.-1.*gTime)) * normalize(vec3(uv, 1.));\n        \n    }  else if (sceneId == 3) {\n        // Rassemblement + rencontre\n        gTime = iTime - 58.;\n        rp = vec3(27.7+.3*gTime+5.*sin(.2*gTime), 8.+cos(.31*gTime),1.7-.5*gTime+5.*cos(.2*gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        \n        vec3 ta = vec3(-16.-.5*gTime,.05, -23.+.3*gTime),\n        rp2, ta2 = vec3(1.3,.45,17.1);\n        rp2 = ta2 + vec3(cos(.6*gTime+1.7),-.05+.05*cos(iTime), sin(.6*gTime+1.7)); \n        rp = mix(rp,rp2,smoothstep(20.,40.,gTime));\n        ta = mix(ta,ta2,smoothstep(20.,40.,gTime));\n        rd = lookat(rp, ta) * normalize(vec3(-uv.x, uv.y, 1.1));\n        \n     } else if (sceneId == 4) {\n        gTime = iTime-70.;\n        isWalking = false;\n        withBBox = false;\n        rp = vec3(0,.5,-.15) + (1.25+.05*gTime)*vec3(-cos(-.1*gTime), .01, sin(-.1*gTime));\n        rp.y = max(rp.y, hGround(rp) + .1);\n        rd = lookat(rp, vec3(0,.5,-.15)) * normalize(vec3(uv, 1.));\n        \n     } else if (sceneId == 5) {\n        // froid\n        gTime -= 70.;\n        isWalking = true;\n        rp = vec3(4.*sin(-.02*gTime), 1.2, 5.*cos(-.02*gTime));\n        rp.y = hGround(rp) + 1.1+.1+.2*cos(.2*iTime);\n        vec3 ta = vec3(2.5*sin(-.02*gTime-1.)-1.6+.1*gTime, .5, 2.5*cos(-.02*gTime-1.));\n        rd = lookat(rp, ta) * normalize(vec3(-uv.x, uv.y, 1.1));\n     } \n    \n    vec3 col; \n    float dist = trace(rp, rd, col);\n    fragColor = vec4(col, dist);\n}\n\n// undersea\n// https://www.shadertoy.com/view/llcSz8", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXXzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "ddfSz7", "name": "untitled #0", "author": "fishy", "description": "Idk what I made but it's cool", "tags": ["blob", "glowing"], "likes": 9, "viewed": 167, "published": 3, "date": "1668636513", "time_retrieved": "2024-07-30T16:19:16.691059", "image_code": "#define STEPS 100. // set higher for coolness\n#define BLUR_OUTWARDS\n//#define ADD_ORIGINAL\n\nfloat hash21(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat dither(float c, float b, vec2 p)\n{\n    float s = floor(c*b)/b;\n    float r = fract(c*b);\n    return s + float(hash21(p) < r)*r/b;\n}\n\nvec4 dither(in vec4 c, float b, vec2 p)\n{\n    for(int s = 0; s < 4; s++)\n    {\n        c[s] = dither(c[s], b, p);\n    }\n    return c;\n}\n\nvec4 ghostBlur(sampler2D tex, vec2 p, float it)\n{\n    vec4 res = vec4(0);\n    vec2 np;\n    float st = 2./it;\n    for(float i = 1.; i > -1.-st; i -= st)\n    {\n        #ifdef BLUR_OUTWARDS\n        np = (p-0.5) * i + 0.5;\n        #else\n        np = (p-0.5) / i + 0.5;\n        #endif\n        res += texture(tex, np);\n    }\n    return res / it\n    #ifdef ADD_ORIGINAL \n    + texture(tex, p)\n    #endif\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = ghostBlur(iChannel0, uv, STEPS) + 0.1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ss(a) (smoothstep(-1.0, 1.0, a)*2.0-1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*vec2(iResolution.x/iResolution.y, 1.0);\n    //vec2 m = (iMouse.xy/iResolution.xy-0.5)*vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 m = vec2(sin(iTime),cos(iTime))*0.1*(sin(iTime)+1.5);\n    \n\n    fragColor = vec4(vec3(smoothstep(0.1 + 1.5/iResolution.y, 0.1,length(uv-m))),1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 118, 118, 235], [237, 237, 277, 277, 374], [376, 376, 417, 417, 511], [919, 919, 976, 1026, 1237]], "test": "untested"}
{"id": "mdXSz7", "name": "F# logo distance field", "author": "mrange", "description": "CC0: F# logo distance field\nApart from shader coding I enjoy tinkering in F#\nRecreating the F# logo as a shader seemed like a good idea.\n", "tags": ["2d"], "likes": 9, "viewed": 270, "published": 3, "date": "1668635821", "time_retrieved": "2024-07-30T16:19:17.567714", "image_code": "// CC0: F# logo distance field\n//  Apart from shader coding I enjoy tinkering in F#\n//  Recreating the F# logo as a shader seemed like a good idea.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat triangleIsosceles(vec2 p, vec2 q ) {\n  p.x = abs(p.x);\n  vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n  float s = -sign( q.y );\n  vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                vec2( dot(b,b), s*(p.y-q.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n// \"Better\"\nvec2 dfsharp0(vec2 p) {\n  const float sm = 0.005;\n  const mat2 rot45 = ROT(PI/4.0);\n  vec2 p0 = p;\n  p0.x = -abs(p0.x);\n  p0.x += 0.7;\n  p0 = p0.yx;\n  vec2 p1 = p;\n  p1 *= rot45; \n  vec2 p2 = p;\n  p2.x += 0.26;\n  p2 = p2.yx;\n  float d0 = triangleIsosceles(p0, 1.35*vec2(0.5, 0.5)-sm);\n  float d1 = box(p1, vec2(0.26)+sm);\n  float d2 = triangleIsosceles(p2, 0.47*vec2(0.5, 0.5)-sm);\n  float d = d0;\n  d = pmax(d, -d1, sm);\n  d = pmin(d, d2, sm);\n  return vec2(d-sm, p.x > 0.0 ? 1.0 : 0.0);\n}\n\n// \"Cheaper\"\nvec2 dfsharp1(vec2 p) {\n  const mat2 rot45 = ROT(PI/4.0);\n  vec2 p0 = p;\n  p0 *= rot45;\n  vec2 p2 = p;\n  float d0 = box(p0, vec2(0.5));\n  float d1 = d0+0.275;\n  float d2 = abs(d1)-0.035;\n  float d3 = -p2.x-0.025;\n  d2 = min(d2, max(d1, d3));\n  float d4 = abs(p2.x)-0.025;\n  float d = d0;\n  d = max(d, -d2);\n  d = max(d, -d4);\n  return vec2(d, p.x > 0.0 ? 1.0 : 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  vec2 d = dfsharp1(p);\n  vec3 col = vec3(0.00);\n  vec3 bcol0 = vec3(1.0, 0.0, 0.5).yzx;\n  vec3 bcol1 = bcol0.yzx;;\n  col = mix(col, mix(bcol0, sqrt(bcol0), d.y), smoothstep(aa, -aa, d.x));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 427, 466, 466, 551], [553, 641, 680, 680, 709], [711, 711, 738, 738, 814], [816, 816, 858, 858, 1152], [1154, 1166, 1189, 1189, 1656], [1658, 1671, 1694, 1694, 2039], [2041, 2041, 2098, 2098, 2468]], "test": "untested"}
{"id": "ddfXzM", "name": "Antialiased Graph", "author": "Hatchling", "description": "Uses dFdx to draw an anti-aliased filled line graph.\nIt isn't perfect but it is stupidly simple.", "tags": ["graph", "aa"], "likes": 4, "viewed": 177, "published": 3, "date": "1668629324", "time_retrieved": "2024-07-30T16:19:18.430407", "image_code": "// Controls:\n// Mouse Click + Drag: Change the value of the graph \n//                     at and around the given point.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float pixelHeight = fragCoord.y;\n    float graphHeight = fragColor.x * iResolution.y;\n    \n    float range = (1.0 + abs(dFdx(graphHeight))) * 1.0;\n    \n    float upper = graphHeight + range;\n    float lower = graphHeight - range;\n    \n    float value = (pixelHeight - lower) / (upper - lower);\n    \n    // Convert to a line instead of a solid graph.\n    // Increase the range's multiplier from 1.0 to 2.0 to use this.\n    //value = abs(value - 0.5) * 2.0;\n    \n    fragColor = vec4(smoothstep(0., 1., value));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Contains the function to display.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec4 mouseProxy = iMouse;\n    \n    if(iMouse.xy == vec2(0))\n    {\n        vec2 halfRes = iResolution.xy * 0.5;\n        mouseProxy.xy = vec2(sin(iTime), cos(iTime)) * halfRes + halfRes;\n        mouseProxy.z = 1.0;\n    }\n    \n    if(mouseProxy.z > 0.0)\n    {\n        float distanceToMouse = abs(mouseProxy.x - fragCoord.x) / iResolution.x;\n        \n        float weight = exp2(-distanceToMouse * 100.0);\n        weight = smoothstep(0., 1., weight);\n    \n        fragColor = mix(fragColor, vec4(mouseProxy.y / iResolution.y), weight);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 760]], "test": "untested"}
{"id": "dssXzN", "name": "Sliced Gyroid Fly Though", "author": "byt3_m3chanic", "description": "Gyroid Slices \nmusic for mood only - Greenhouse Gasses | by Cevin Key\n\n@smjtyazdi https://twitter.com/smjtyazdi/status/1484828390104485896 (sliced SDFs)", "tags": ["raymarching", "gyroid"], "likes": 66, "viewed": 944, "published": 3, "date": "1668624298", "time_retrieved": "2024-07-30T16:19:19.397821", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Sliced Gyroid Fly Though\n    11/16/22 | @byt3_m3chanic\n\n    music for mood only - Greenhouse Gasses | by Cevin Key\n\n    Original post here about sliced SDF's. Kind of updated\n    version (extra loops to help backside of sdf's)\n    \n    @smjtyazdi https://twitter.com/smjtyazdi/status/1484828390104485896\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n\n#define PI  3.1415926\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.34,35.34)))*483434.);}\n\n//globals\nmat2 trot;\nfloat glow=0.,tglow=0.;\n\nconst float ofx = 1.25;\n\nfloat sdGry(vec3 p, float s, float t, float b) {\n    p *= s;\n    return abs(dot(sin(p*ofx),cos(p.zxy))-b)/(s*ofx)-t;\n}\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,1.);\n    \n    vec3 q = p;\n    float tt = .5+.5*sin(T*.2);\n    \n    float k = 8./dot(p,p);\n    float mul = 1./k;\n    p*=k;\n    \n    p.xy*= trot;\n    p.yz += vec2(-1.25, T);\n    \n    float d = .365, mf = 1e5;\n    float mm = .25+.25*sin(T*.75);\n    \n    for(float j=-2.;j<2.;j++){\n        vec3 nf =p;\n        nf.z=round(nf.z/d+j)*d;\n        float ids = mod(nf.z,2.);\n        \n        float fd= sdGry(nf, .725, .05, .65);\n        \n        nf.z=clamp(p.z,nf.z-d/4.,nf.z+d/4.);\n        fd=length(vec2(max(.0,fd), nf.z-p.z));\n\n        float idx = mod(nf.z,5.);\n        \n        if(idx<mm+.025&&idx>mm) tglow+=.002/(.015+fd*fd);\n        if(ids<mm+.075&&ids>mm) glow+=.002/(.015+fd*fd);\n   \n        mf=min(mf,fd);\n    }\n    if(mf<res.x) res=vec2(mf,3.);\n\n    res.x*= mul/1.35;\n    return res;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    trot=rot(T*.072);\n    \n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,.5);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    float x = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n\n    mat2 rx = rot(x),ry = rot(y);\n    \n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 p = ro;\n\n    float d=0.,m=0.;\n    for(int i=0;i<164;i++){\n        vec2 t = map(p);\n        d += i<64? t.x*.35:t.x*.75;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(t.x<d*1e-4||d>45.) break;\n    } \n    \n    float sp = .2+.2*sin(uv.x*4.1+T);\n    vec3 fog = mix(vec3(0.043,0.153,0.255),vec3(0.235,0.302,0.000),clamp((uv.y+.5-sp),0.,1.));\n\n    C = mix(C,vec3(glow,glow*.65,glow*.15),clamp(glow,.0,.6));\n    C = mix(C,vec3(tglow*.15,tglow*.465,tglow),clamp(tglow,.0,.8));\n    \n    C = mix(C,fog, 1.-exp(-20.*d*d*d));\n    \n    C = clamp(C,vec3(0),vec3(1));\n    O = vec4(pow(C, vec3(.4545)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXzN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[496, 496, 516, 516, 561], [562, 562, 583, 583, 637], [710, 710, 758, 758, 828], [830, 830, 848, 848, 1657], [1659, 1659, 1700, 1700, 2732]], "test": "untested"}
{"id": "dsfSRM", "name": "Reuleaux's ngon", "author": "Peace", "description": "Reuleaux's triangle and other polygons", "tags": ["ngon", "reuleaux"], "likes": 0, "viewed": 123, "published": 3, "date": "1668622994", "time_retrieved": "2024-07-30T16:19:20.159783", "image_code": "const float PI = 3.1415926;\n\nfloat reuleaux(vec2 p, int n) {\n    float a = atan(p.y, p.x);\n    float ang = PI/float(n);\n    float cc = cos(a - 2.0 * ang * floor(0.5 * (a - PI) / ang + 0.5));\n    return length(p) - (cc + sqrt(1.0 + 2.0 * cos(ang) + cc * cc));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {   \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float rlp = reuleaux(uv, int(iTime * 2.0) % 4 + 3);\n    float rl = smoothstep(0.0, -length(fwidth(uv)) * 2.0, rlp);\n    fragColor = vec4(vec3(rl), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 60, 60, 260], [262, 262, 314, 314, 562]], "test": "untested"}
{"id": "ddfSRM", "name": "Noise Maps Generator", "author": "rge15", "description": "Code for generating a lot of types of noise maps.", "tags": ["noise", "fbm", "gradient", "value", "polar"], "likes": 1, "viewed": 220, "published": 3, "date": "1668622258", "time_retrieved": "2024-07-30T16:19:20.984578", "image_code": "#define PI 3.14159265359\n#define selec 12\n\nfloat N21(in vec2 p)\n{\n    p = 50.*fract( p * PI);\n    p = 50.*fract((p+vec2(0.24342,709.23))/PI);\n\n    return -1. + 2.*fract((p.x*p.y) );\n}\n\nvec2 N22(in vec2 p)\n{\n    p = 50.*fract((p+vec2(0.24342,709.23))/PI);\n    return 1. - 2.*fract(p * vec2(p.x+p.y, p.y*p.x) + vec2(0.29137,0.9348));\n}\n\nvec2 modulo(in vec2 divident, in vec2 divisor)\n{\n   return mod(divident,divisor) * (divisor / abs(divisor));\n}\n\nfloat valueNoise(in vec2 pos)\n{\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    vec2 inter = f * f * (3. -2.*f);\n    \n    float vA = N21(i + vec2(0.,0.));\n    float vB = N21(i + vec2(1.,0.)); \n    float vC = N21(i + vec2(0.,1.)); \n    float vD = N21(i + vec2(1.,1.)); \n    \n    return vA + (vB - vA)*inter.x + (vC - vA)*inter.y + (vD - vC - vB + vA) * inter.x * inter.y;\n}\n\nfloat tiledValueNoise(in vec2 pos, in vec2 frec)\n{\n    vec2 f = fract(pos);\n \n    vec2 imin = floor(pos);\n    vec2 imax = ceil(pos);\n \n    imin = modulo( imin, frec );\n    imax = modulo( imax, frec );\n     \n \n    vec2 inter = f * f * (3. -2.*f);\n    \n    float vA = N21( imin );\n    float vB = N21( vec2( imax.x, imin.y)); \n    float vC = N21( vec2( imin.x, imax.y)); \n    float vD = N21( imax ); \n    \n    return vA + (vB - vA)*inter.x + (vC - vA)*inter.y + (vD - vC - vB + vA) * inter.x * inter.y;\n}\n\nfloat gradientNoise(in vec2 pos)\n{\n    vec2 f = fract(pos);\n    vec2 i = floor(pos);\n\n    vec2 inter = f * f * ( 3. - 2. * f);\n\n    vec2 vecA = N22( i );\n    vec2 vecB = N22( i + vec2( 1. , 0. ) );\n    vec2 vecC = N22( i + vec2( 0. , 1. ) );\n    vec2 vecD = N22( i + vec2( 1. ));\n    \n    float valA = dot( f , vecA );\n    float valB = dot( f - vec2(1.,0.) , vecB );\n    float valC = dot( f - vec2(0.,1.) , vecC );\n    float valD = dot( f - vec2(1.,1.) , vecD );\n\n    return valA + ( valB - valA ) * inter.x + ( valC - valA ) * inter.y + ( valD - valB - valC + valA ) * inter.x * inter.y;\n\n}\n\nfloat tiledGradientNoise(in vec2 pos, in vec2 frec)\n{\n    vec2 f = fract(pos);\n    vec2 imin = floor(pos);\n    vec2 imax = ceil(pos);\n    \n    imin = modulo(imin, frec);\n    imax = modulo(imax, frec);\n\n    vec2 inter = f * f * ( 3. - 2. * f);\n\n    vec2 vecA = N22( imin );\n    vec2 vecB = N22( vec2( imax.x, imin.y) );\n    vec2 vecC = N22( vec2( imin.x, imax.y) );\n    vec2 vecD = N22( imax );\n    \n    float valA = dot( f , vecA );\n    float valB = dot( f - vec2(1.,0.) , vecB );\n    float valC = dot( f - vec2(0.,1.) , vecC );\n    float valD = dot( f - vec2(1.,1.) , vecD );\n\n    return valA + ( valB - valA ) * inter.x + ( valC - valA ) * inter.y + ( valD - valB - valC + valA ) * inter.x * inter.y;\n\n}\n\nfloat valueFBM(in vec2 p, in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * valueNoise( f*p );\n    }\n\n    return value;\n}\n\nfloat tiledValueFBM(in vec2 p, in vec2 frec ,in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * tiledValueNoise( f*p , frec);\n    }\n\n    return value;\n}\n\nfloat gradientFBM(in vec2 p, in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * gradientNoise( f*p );\n    }\n\n    return value;\n}\n\nfloat tiledGradientFBM(in vec2 p, in vec2 frec ,in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * tiledGradientNoise( f*p , frec);\n    }\n\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    // Polar Coordinates\n    vec2 p_uv = vec2( atan(uv.x,uv.y), length(uv));\n    // Normalized Polar Coordinates\n    vec2 np_uv = vec2( p_uv.x/(2.*PI)+0.5 , p_uv.y );\n    \n    float noise = 0.;\n#if selec == 0\n    noise = valueNoise(uv*10.+vec2(iTime));\n#elif selec == 1\n    noise = tiledValueNoise(uv*10.+vec2(iTime), vec2(15.));\n#elif selec == 2\n    noise = tiledValueNoise(np_uv*vec2(20.,5.)+vec2(iTime), vec2(10.));\n#elif selec == 3\n    noise = clamp(tiledValueNoise(np_uv*vec2(5.,5.)+vec2(iTime), vec2(5.)),0.,1.);\n    noise *= tiledValueNoise(np_uv*vec2(40.,0.)+vec2(iTime,0.), vec2(20.));\n#elif selec == 4\n    noise = gradientNoise(uv*10.+vec2(iTime));\n#elif selec == 5\n    noise = tiledGradientNoise(uv*3.+vec2(iTime), vec2(10.,5.) );\n#elif selec == 6\n    noise = clamp(tiledGradientNoise(np_uv*vec2(5.,5.)+vec2(iTime*0.5,iTime), vec2(5.)),0.,1.);\n#elif selec == 7\n    noise = 0.7 * valueFBM(uv*10.+vec2(iTime),0.49,4);\n#elif selec == 8\n    noise = 0.7 * tiledValueFBM(uv*10., vec2(10.) ,0.49,4);\n#elif selec == 9\n    noise = 0.7 * tiledValueFBM(np_uv*vec2(10.,2.)+vec2(iTime*0.5), vec2(10.) ,0.49,7);\n    noise *= np_uv.y;\n#elif selec == 10\n    noise = 0.7 * gradientFBM(uv*10.+vec2(iTime),0.49,5);\n#elif selec == 11\n    noise = 0.7 * tiledGradientFBM(uv*10., vec2(10.) ,0.49,4);\n#elif selec == 12\n    noise = 0.7 * tiledGradientFBM(np_uv*vec2(10.,2.)+vec2(iTime*0.5), vec2(10.) ,0.49,2);\n    noise *= np_uv.y;\n#endif\n\n\n    // Time varying pixel color\n    vec3 col = vec3(noise);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 65, 65, 183], [185, 185, 206, 206, 333], [335, 335, 383, 383, 445], [447, 447, 478, 478, 830], [832, 832, 882, 882, 1333], [1335, 1335, 1369, 1369, 1926], [1928, 1928, 1981, 1981, 2633], [2635, 2635, 2690, 2690, 2899], [2901, 2901, 2975, 2975, 3195], [3197, 3197, 3255, 3255, 3467], [3469, 3469, 3546, 3546, 3769], [3771, 3771, 3828, 3878, 5482]], "test": "untested"}
{"id": "cdXSR7", "name": "My_Ray_Tracing", "author": "Lincac", "description": "光线追踪", "tags": ["raytracing"], "likes": 3, "viewed": 257, "published": 3, "date": "1668612862", "time_retrieved": "2024-07-30T16:19:21.874200", "image_code": "const int TRACTING_NUM = 100;\nconst int SEARCH_DEPTH = 28;\nconst float nearPlane = .001;\nconst float farPlane = 1000.0;\n\nconst vec3 lightPos = vec3(2,2,4);\nconst vec3 cameraPos = vec3(0,.5,3);\n\n#define PI 3.1415926535\n\n#define MAT_LAMBERTIAN 0\n#define MAT_METALLIC 1\n#define MAT_DIELECTRIC 2\n\nuint m_u = uint(521288629);\nuint m_v = uint(362436069);\nuint GetUintCore(inout uint u, inout uint v){\n\tv = uint(36969) * (v & uint(65535)) + (v >> 16);\n\tu = uint(18000) * (u & uint(65535)) + (u >> 16);\n\treturn (v << 16) + u;\n}\nfloat GetUniformCore(inout uint u, inout uint v){\n\tuint z = GetUintCore(u, v);\n\t\n\treturn float(z) / float(uint(4294967295));\n}\nfloat GetUniform(){\n\treturn GetUniformCore(m_u, m_v);\n}\nfloat rand(){\n\treturn GetUniform();\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 random_in_unit_sphere(){\n\tvec3 p;\n\t\n\tfloat theta = rand() * 2.0 * PI;\n\tfloat phi   = rand() * PI;\n\tp.y = cos(phi);\n\tp.x = sin(phi) * cos(theta);\n\tp.z = sin(phi) * sin(theta);\n\t\n\treturn p;\n}\n\nbool irefract(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted){\n\tvec3 uv = normalize(v);\n\tfloat dt = dot(uv, n);\n\tfloat discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt * dt);\n\tif (discriminant > 0.0){\n\t\trefracted = ni_over_nt * (uv - n * dt) - n * sqrt(discriminant);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfloat schlick(float cosine, float ior){\n\tfloat r0 = (1.- ior) / (1.+ ior);\n\tr0 = r0 * r0;\n\treturn r0 + (1.- r0) * pow((1.- cosine), 5.);\n}\n\nvec3 getbackground(vec3 pos){\n    return texture(iChannel0,pos).rgb;\n}\n\nstruct Lambertian{\n\tvec3 albedo;\n};\n\nLambertian lambertians[4];\n\nLambertian createLambertian(vec3 color){\n    Lambertian lambertian;\n    \n    lambertian.albedo = color;\n    \n    return lambertian;\n}\n\nstruct Metallic{\n    vec3 albedo;\n    float roughness;\n};\n\nMetallic metallics[4];\n\nMetallic createMetallic(vec3 color,float rough){\n    Metallic metallic;\n    \n    metallic.albedo = color;\n    metallic.roughness = rough;\n    \n    return metallic;\n}\n\nstruct Dielectric{\n    vec3 albedo;\n    float rate;\n};\n\nDielectric dielectrics[4];\n\nDielectric createDielectric(vec3 color,float rate){\n    Dielectric dielectric;\n    \n    dielectric.albedo = color;\n    dielectric.rate = rate;\n    \n    return dielectric;\n}\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere{\n    float radius;\n    vec3 position;\n    \n    int materialPtr;\n    int materialType;\n};\n\nstruct World{\n    int objnum;\n    Sphere sps[10];\n};\n\nstruct HitRecord{\n    float t;\n    vec3 position;\n    vec3 normal;\n    \n    int materialPtr;  \n    int materialType;\n};\n\nSphere createSphere(vec3 pos,float r,int ptr,int type){\n    Sphere sphere;\n    sphere.position = pos;\n    sphere.radius = r;\n    \n    sphere.materialPtr = ptr;\n    sphere.materialType = type;\n    return sphere;\n}\n\nvoid hitlambertian(Ray ray,HitRecord hit,Lambertian lambertian,out Ray scatray,out vec3 color){\n    color = lambertian.albedo;\n    \n    scatray.origin = hit.position;\n    scatray.direction = hit.normal + random_in_unit_sphere();\n}\n\nvoid hitmetallic(Ray ray,HitRecord hit,Metallic metallic,out Ray scatray,out vec3 color){\n    color = metallic.albedo;\n    \n    scatray.origin = hit.position;\n    scatray.direction = reflect(ray.direction,hit.normal) + metallic.roughness * random_in_unit_sphere();\n}\n\nvoid hitdielectric(Ray ray,HitRecord hit,Dielectric dielectric,out Ray scatray,out vec3 color){\n    color = dielectric.albedo;\n    \n    vec3 outward_normal;\n\tfloat ni_over_nt;\n\tfloat cosine;\n\tif(dot(ray.direction, hit.normal) > 0.0){\n\t\toutward_normal = -hit.normal;\n\t\tni_over_nt = dielectric.rate;\n\t\tcosine = dot(ray.direction, hit.normal) / length(ray.direction);\n\t}\n\telse{\n\t\toutward_normal = hit.normal;\n\t\tni_over_nt = 1.0 / dielectric.rate;\n\t\tcosine = -dot(ray.direction, hit.normal) / length(ray.direction);\n\t}\n    \n    float reflect_prob;\n\tvec3 refracted;\n\tif(irefract(ray.direction, outward_normal, ni_over_nt, refracted)){\n\t\treflect_prob = schlick(cosine, dielectric.rate);\n\t}\n\telse{\n\t\treflect_prob = 1.0;\n\t}\n\n\tif(rand() < reflect_prob){\n\t\tscatray = Ray(hit.position,refracted);\n\t}\n\telse{\n\t\tscatray = Ray(hit.position,refracted);\n\t}\n}\n\nbool HitSphere(Ray ray,float near,float far,Sphere sp,inout HitRecord hit){\n    vec3 oc = ray.origin - sp.position;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = 2.0 * dot(oc, ray.direction);\n\tfloat c = dot(oc, oc) - sp.radius * sp.radius;\n\n\tfloat delta = b * b - 4. * a * c;\n\n    if(delta > 0.){\n        float temp = (-b - sqrt(delta)) / (2.0 * a);  // 最近的点\n        if(near < temp && temp < far){\n            hit.t = temp;\n            hit.position = ray.origin + temp * ray.direction;\n            hit.normal = normalize((hit.position - sp.position) / sp.radius);\n            \n            hit.materialPtr = sp.materialPtr;\n            hit.materialType = sp.materialType;\n            \n            return true;\n        }\n        \n        temp = (-b + sqrt(delta)) / (2.0 * a);  // 最远的点\n        if(near < temp && temp < far){\n            hit.t = temp;\n            hit.position = ray.origin + temp * ray.direction;\n            hit.normal = normalize((hit.position - sp.position) / sp.radius);\n            \n            hit.materialPtr = sp.materialPtr;\n            hit.materialType = sp.materialType;\n            \n            return true;\n        }\n    }\n    \n    return false;\n}\n\nWorld getScene(){\n    World world;\n    world.objnum = 4;\n    \n    lambertians[0] = createLambertian(vec3(0.1, 0.7, 0.7));\n    lambertians[1] = createLambertian(vec3(0.5, 0.5, 0.5));\n    \n    metallics[0] = createMetallic(vec3(0.8, 0.8, 0.8), 0.3);\n    \n    dielectrics[0] = createDielectric(vec3(1.0, 1.0, 1.0), 1.5);\n    \n    world.sps[0] = createSphere(vec3(0.0, 0.0, -1.0), 0.5,0,MAT_LAMBERTIAN);\n    world.sps[1] = createSphere(vec3(0.0, -100.5, -1.0), 100.0,1,MAT_LAMBERTIAN);\n    world.sps[2] = createSphere(vec3(1.0, 0.0, -1.0), 0.5,0,MAT_METALLIC);\n    world.sps[3] = createSphere(vec3(-1.0, 0.0, -1.0), 0.5,0,MAT_DIELECTRIC);\n\n    return world;\n}\n\n\nbool HitWorld(World world,Ray ray,float near,float far,inout HitRecord hit){\n    HitRecord temphit;\n    bool hit_anything = false;\n    float hit_t_max = far;\n    \n    for(int i=0;i<world.objnum;i++){\n        if(HitSphere(ray,near,hit_t_max,world.sps[i],temphit)){\n            hit = temphit;\n            hit_anything = true;\n            hit_t_max = hit.t;\n        }\n    }\n    \n    return hit_anything;\n}\n\nvec3 raymarch(Ray ray,float near,float far,World world,int iter){\n    HitRecord record;\n    \n    vec3 bgcolor = vec3(1);\n    vec3 sumcolor = vec3(1);\n\n    while(iter > 0){\n        iter--;\n        if(HitWorld(world,ray,near,far,record)){\n            Ray scatterray;\n            vec3 attenuation;\n            if(record.materialType == MAT_LAMBERTIAN){\n                hitlambertian(ray,record,lambertians[record.materialPtr],scatterray,attenuation);\n            }else if(record.materialType == MAT_METALLIC){\n                hitmetallic(ray,record,metallics[record.materialPtr],scatterray,attenuation);\n            }else if(record.materialType == MAT_DIELECTRIC){\n                hitdielectric(ray,record,dielectrics[record.materialPtr],scatterray,attenuation);\n            }\n            \n            ray = scatterray;\n            sumcolor *= attenuation;\n        }else{\n            bgcolor = getbackground(ray.direction);\n            break;\n        }\n    }\n    \n    return sumcolor * bgcolor;\n}\n\nvec3 GammaCorrection(vec3 c){\n\treturn pow(c, vec3(1.0 / 2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    World world = getScene();\n    \n    // Time varying pixel color\n    mat3 rotaY = rotateY(iTime);\n    \n    vec3 col = vec3(0.);\n    for(int i=0;i<TRACTING_NUM;i++){\n        vec2 uv = ((fragCoord + vec2(rand(),rand())) - .5 * iResolution.xy) / iResolution.y;\n        \n        Ray ray;\n        ray.origin = cameraPos * rotaY;\n        ray.direction = vec3(uv,-1) * rotaY;\n\n        col+=raymarch(ray,nearPlane,farPlane,world,SEARCH_DEPTH);\n    }\n    col /= float(TRACTING_NUM);\n    \n    col = GammaCorrection(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 394, 394, 519], [520, 520, 569, 569, 646], [647, 647, 666, 666, 702], [703, 703, 716, 716, 740], [742, 742, 769, 769, 916], [918, 918, 947, 947, 1112], [1114, 1114, 1182, 1182, 1430], [1432, 1432, 1471, 1471, 1570], [1572, 1572, 1601, 1601, 1642], [1709, 1709, 1749, 1749, 1842], [1927, 1927, 1975, 1975, 2092], [2178, 2178, 2229, 2229, 2350], [2684, 2684, 2739, 2739, 2896], [2898, 2898, 2993, 2993, 3128], [3130, 3130, 3219, 3219, 3396], [3398, 3398, 3493, 3493, 4239], [4241, 4241, 4316, 4316, 5444], [5446, 5446, 5463, 5463, 6101], [6104, 6104, 6180, 6180, 6506], [6508, 6508, 6573, 6573, 7501], [7503, 7503, 7532, 7532, 7567], [7569, 7569, 7626, 7626, 8201]], "test": "untested"}
{"id": "cslSzn", "name": "diagonal image switch distortion", "author": "kyohe1", "description": "switch images working on fragment shadar.\ninspired by taotajima.jp", "tags": ["fragmentshadar"], "likes": 3, "viewed": 230, "published": 3, "date": "1668608436", "time_retrieved": "2024-07-30T16:19:22.743874", "image_code": "const float PI = 3.1415926535;\n\nvec2 moveUv(vec2 _uv){\n    float tension = abs(pow(sin(iTime), 2.));\n    return vec2(\n        _uv.x / 1.5 - (cos(iTime) * .125 - .125),\n        (_uv.y + tension * sin(_uv.x * PI * 10.) / 50. ) / 1.5 + (cos(iTime) * .125 + .125)\n    );\n}\n\nvec2 distort(vec2 _uv){\n    return vec2(_uv.x / 1.5 + sin(_uv.y) * cos(_uv.x), _uv.y / 1.5 - cos(_uv.y) * sin(_uv.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float _t = abs(sin(iTime) * .05);\n    float threshold = -1. * cos(iTime);\n    vec2 movedUv = moveUv(uv);\n    vec4 tex_a = texture(iChannel0, mix(distort(uv), movedUv, smoothstep(threshold, threshold + _t, uv.x - uv.y))),\n         tex_b = texture(iChannel1, mix(movedUv, distort(uv), smoothstep(threshold - _t,threshold,uv.x - uv.y)));\n\n\n    // Output to screen\n    fragColor = mix(tex_a, tex_b, step(uv.x - uv.y, threshold));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 54, 54, 268], [270, 270, 293, 293, 390], [392, 392, 449, 499, 971]], "test": "untested"}
{"id": "mssSRH", "name": "大龙猫 - Wire Mountain", "author": "totetmatt", "description": "Wire Mountain", "tags": ["wire"], "likes": 14, "viewed": 237, "published": 3, "date": "1668601968", "time_retrieved": "2024-07-30T16:19:23.588616", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy -.5 *iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    float aa=0.,rnd;\n    for(aa=0.;aa++<4.;){\n        vec3 p,d=normalize(vec3(uv,1.));\n        for(float i=0.,e,g=0.;i++<99.;){\n            vec3 p = d*g,op=p;\n            p.xy+=rnd=sqrt(i)*fract(tan(445.887*sin(dot(vec2(p.xy)*aa,vec2(2425.223,984.401)))))*.03*length(uv);\n            p.xz*=rot(iTime*.1+asin(sin(iTime+cos(iTime*2.)))*.5);\n          \n            p.zx +=iTime;\n            p.y -= -2.5+clamp(abs(mod(p.z+p.x,6.)-3.)*.5,0.5,1.5);\n            \n            p.xz = fract(p.xz)-.5;\n            float h =min(length(p.yz),length(p.xy))-.01;\n            g+=e=max(.0001,abs(h)*.7);\n            col += sqrt(vec3(.7+sin(iTime+op.z)*.5,.5,.5+cos(iTime-op.z*4.)*.2)*.025/exp(i*i*e));\n        }\n    }\n    fragColor = vec4(sqrt(col/aa),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 66, 123, 123, 961]], "test": "untested"}
{"id": "dslSR4", "name": "Gabor and Phasor Noise", "author": "rubioh", "description": "My implementation of gabor and phasor noise.\nGabor : https://hal.archives-ouvertes.fr/hal-00695670/document\nPhasor : https://hal.archives-ouvertes.fr/hal-02118508/document\n\nL: Gabor, UR: Amplitude, DR: Phase", "tags": ["noise", "gabor"], "likes": 16, "viewed": 599, "published": 3, "date": "1668592502", "time_retrieved": "2024-07-30T16:19:24.344595", "image_code": "#define PI 3.14159\n\nfloat GaborNoise(vec2 uv, vec2 omega, float freq, vec2 orig, float bandwidth){\n    float f = 2.*PI*freq; // frequency\n    float a = exp(-length(orig-uv)*bandwidth*PI);\n    return a*cos(f* dot(uv, omega));\n}\n\nvec2 GaborAmplitude(vec2 uv, vec2 omega, float freq, vec2 orig, float bandwidth){\n    float f = 2.*PI*freq; // frequency\n    float a = exp(-length(orig-uv)*bandwidth*PI);\n    return a*vec2(cos(f* dot(uv, omega)),\n                sin(f* dot(uv, omega))); // redundancy with GaborNoise for clarity\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.x /= 1.;\n    // Time varying pixel color\n    float gn;\n    int N = 100;\n    vec2 L = vec2(0.);\n    \n    float my = iMouse.y/iResolution.y;\n    if (my == 0.){\n        my = .5;\n    }\n    \n    float mx = iMouse.x/iResolution.x;\n    if (mx == 0.){\n        mx = .5;\n    }\n    \n    float phase_velocity = 2.*mx;\n    float freq = 5.;\n    float bandwidth = .01;\n    for (int i=0; i<N; i++){\n        vec2 pos = vec2(noise(vec2(float(i), 0.)), noise(vec2(float(i), 1.)));\n        float omega_ = atan(noise(vec2(float(i), 1.)), noise(vec2(float(i), 2.)))*phase_velocity + iTime/20.;\n        vec2 omega = vec2(cos(omega_), sin(omega_));\n        \n        \n        freq = 40.*my; // *hash11(float(i)); //   one can take varying frequencies and bandwidth; \n        bandwidth = .01; //  * hash11(float(i)+.3);    //\n        \n        L += GaborAmplitude((uv-pos), omega, freq, uv, bandwidth);\n        gn += GaborNoise((uv-pos), omega, freq, uv, bandwidth);\n    }\n    float amplitude = length(L);\n    float pn = gn/amplitude;\n    gn /= sqrt(float(N)); // for high bandwidth i need to tune the normalizing factor\n    // Output to screen \n    float an = amplitude/sqrt(float(N));\n    pn = mix(pn, an*.5, step(0., uv.y));\n    vec3 col = vec3(\n                mix(gn, pn, step(0., uv.x))) + 100.*vec3(1.,0.,0.)*smoothstep(0., .005, .005-abs(uv.x))\n                + 100.*vec3(1.,0.,0.)*smoothstep(0., .005, .005-abs(uv.y))*step(0., uv.x);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "float hash11( float x){\n    return fract( sin( float(x)*11.45067)*41.234);\n}\n\n\nvec2 hash22(vec2 p){\n    vec2 a = vec2(110.487,9.4567);\n    vec2 b = vec2(4506.775, 50.2467);\n    return fract( sin(vec2(dot(a,p), dot(b,p)))*41.234);\n}\n\nfloat hash21(vec2 p){\n    vec2 a = vec2(110.487,9.4567);\n    return fract( sin(dot(a,p))*41.234);\n}\n\nvec2 hash12(float x){\n    vec3 p = vec3(x,x,x);\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    return fract( sin(vec2(dot(a,p), dot(b,p)))*41.234);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 98, 98, 226], [228, 228, 309, 309, 527], [529, 529, 586, 636, 2158]], "test": "untested"}
{"id": "DssXRN", "name": "Heart exercise 2", "author": "yli110", "description": "always use mathematical method by Inigo Quilez and Multiple sampling.", "tags": ["heart"], "likes": 3, "viewed": 138, "published": 3, "date": "1668585339", "time_retrieved": "2024-07-30T16:19:25.424706", "image_code": "//https://www.youtube.com/watch?v=BFld4EBO2RE&list=RDCMUCdmAhiG8HQDlz8uyekw4ENw&in\n//https://www.bilibili.com/video/BV1Ka411r7yK/?spm_id_from=333.788\n\n#define PI 3.1415926\n#define AA 4\n#define num 5\nvec2 fixUV(in vec2 uv)\n{\n    return (2.*uv.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n}\n\nvec3 BGColor(in vec2 uv)\n{\n    vec3 color = vec3(0.);\n    vec2 grid = floor(mod(uv,2.));\n    if(grid.x != grid.y) color = vec3(0.45);\n    else color = vec3(0.55);\n    color = mix(color,vec3(0.),smoothstep(1.5*fwidth(uv).x,0.,abs(uv.x)));\n    color = mix(color,vec3(0.),smoothstep(1.5*fwidth(uv).y,0.,abs(uv.y)));\n    return color;\n}\n\nfloat function(in vec2 uv, in float R)\n{\n    float x = 3.*uv.x;\n    float y = uv.y;\n    float r = R+0.5*pow(0.5+0.5*sin(2.*PI*iTime+y/1.),4.);\n    float f = r-x*x;\n    return f;\n}\nfloat functionY(in vec2 uv)\n{\n    float y = 1.2*uv.y-abs(uv.x)*sqrt((20.*abs(uv.x)/15.));\n    y *= 9.*y;\n    return y;\n}\n\nfloat plot(vec2 uv){\n    float fY = functionY(uv);\n    float fuc = function(uv,1.);\n    float plotline = 0.;\n    for(int i=0;i<num;i++)\n    {\n        float fuc = function(uv,1.-1.0/float(num)*float(i));\n        float line = smoothstep( fuc-0.01, fuc, fY);\n        float mark = (-step(sign(mod(float(i),2.)),0.)+step(1.,sign(mod(float(i),2.))));\n        plotline = line-plotline*pow(mark,2.);\n    }\n  return  plotline;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fixUV(fragCoord);\n    uv *=3.;\n    vec3 colorbg = BGColor(uv);\n    //Multiple sampling\n    float count = 0.;\n    for(int i = 0;i<AA;i++)\n    {\n        for(int j = 0;j<AA;j++)\n        {\n            vec2 offset = (vec2(float(i),float(j))-0.5*float(AA))/float(AA) *2.;\n            count += plot(fixUV(fragCoord+offset));\n        }\n    }\n    if(count > float(AA*AA)/2.) count = float(AA*AA) - count;\n    count = count *2.0 / float(AA*AA);\n    vec3 colorfinal = mix(colorbg,vec3(1.0, 1.0, 1.0),count);\n    fragColor = vec4(colorfinal,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 223, 223, 296], [298, 298, 324, 324, 630], [632, 632, 672, 672, 811], [812, 812, 841, 841, 932], [934, 934, 954, 954, 1353], [1355, 1355, 1411, 1411, 1961]], "test": "untested"}
{"id": "mdfXRN", "name": "Unsharp Filter", "author": "cwfitzgerald", "description": "Kinda crap two pass unsharp filter.", "tags": ["blur", "filter", "unsharp"], "likes": 0, "viewed": 280, "published": 3, "date": "1668561004", "time_retrieved": "2024-07-30T16:19:26.248504", "image_code": "float luminance(vec3 v)\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\nvec3 change_luminance(vec3 c_in, float l_out)\n{\n    float l_in = luminance(c_in);\n    return c_in * (l_out / l_in);\n}\n\nvec3 reinhard_extended_luminance(vec3 v, float max_white_l)\n{\n    float l_old = luminance(v);\n    float numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\n    float l_new = numerator / (1.0f + l_old);\n    return change_luminance(v, l_new);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 self = texture(iChannel1, uv).xyz;\n\n    // Output to screen\n    if (fragCoord.x <= iMouse.x) {\n        vec2 nudge = 1.0/iResolution.xy;\n        vec3 blur = vec3(0.0);\n\n        for (int y = -COUNT; y <= COUNT; ++y) {\n            blur += texture(iChannel0, uv + nudge * vec2(ivec2(0, y))).xyz;\n        }\n\n        blur /= float(COUNT * 2 + 1);\n    \n        float greyscale = pow(dot(self, vec3(0.4, 0.5, 0.1)), 2.2);\n        vec3 adj = (self - blur) * SCALE * greyscale + self;\n        \n        fragColor = vec4(reinhard_extended_luminance(adj, 0.9),1.0);\n    } else {\n        fragColor = vec4(self,1.0);\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int COUNT = 50;\nconst float SCALE = 1.;\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 nudge = 1.0/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 blur = vec3(0.0);\n    \n    for (int x = -COUNT; x <= COUNT; ++x) {\n        blur += texture(iChannel0, uv + nudge * vec2(ivec2(x, 0))).xyz;\n    }\n    \n    blur /= float(COUNT * 2 + 1);\n\n    // Output to screen\n    fragColor = vec4(blur,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 79], [81, 81, 128, 128, 198], [200, 200, 261, 261, 458], [460, 460, 517, 567, 1231]], "test": "untested"}
{"id": "cssXRH", "name": "circle with segments", "author": "jonasfrey", "description": "i have no clue what is going on ", "tags": ["polygon"], "likes": 3, "viewed": 131, "published": 3, "date": "1668557876", "time_retrieved": "2024-07-30T16:19:27.002488", "image_code": "const float n_tau = 6.283185;\nfloat f_n_dist_circle_segment(\n    //vec2 o_p_origin, \n    float n_radians_nor, \n    float n_radians_offset_nor, \n    float n_radius_nor, \n    vec2 o_pix_cor_nor\n){\n    float n_rad = n_radians_offset_nor * n_tau;\n    o_pix_cor_nor = vec2(\n            cos(n_rad)*o_pix_cor_nor.x + sin(n_rad)*o_pix_cor_nor.y,\n            -sin(n_rad)*o_pix_cor_nor.x + cos(n_rad)*o_pix_cor_nor.y\n    );\n        \n    vec2 o_p_origin = vec2(0.0); // was once used as a param, but translation can be applied by passing f(...,o_pix_cor_nor+translation)\n    float n_dist_origin = length(o_p_origin - o_pix_cor_nor);\n    vec2 o_delta = o_p_origin - o_pix_cor_nor;\n    float n_angle_origin = atan(o_delta.x , o_delta.y)+(n_tau/2.0);\n    float n_angle_origin_nor = n_angle_origin / n_tau;\n  \n    float n_dist_shortest = 1.0;\n    \n    vec2 o_p_center = o_p_origin;\n    float n_dist_origin_max = min(n_radius_nor, n_dist_origin);\n    vec2 o_p1 = vec2(\n            sin(n_tau)*n_dist_origin_max,\n            cos(n_tau)*n_dist_origin_max\n    ) + o_p_origin;\n    vec2 o_p2 = vec2(\n            sin(n_tau+ n_tau * n_radians_nor)*n_dist_origin_max,\n            cos(n_tau+ n_tau * n_radians_nor)*n_dist_origin_max\n    ) + o_p_origin;\n    float n_freq = min(n_angle_origin_nor*n_tau, n_radians_nor*n_tau);\n    \n    vec2 o_p_on_circumfence = vec2(\n            sin(n_tau+n_freq)*n_radius_nor,\n            cos(n_tau+n_freq)*n_radius_nor\n    ) + o_p_origin;\n    \n    float n_dist1 = length(o_p1-o_pix_cor_nor);\n    float n_dist2 = length(o_p2-o_pix_cor_nor);\n    float n_dist_on_circumfence = length(o_p_on_circumfence-o_pix_cor_nor);\n    \n    float n_dist = min(n_dist1, n_dist2);\n    n_dist = min(n_dist, n_dist_on_circumfence);\n\n    // o_p1 = vec2(\n    //         sin(n_tau * n_side_nor)*n_radius,\n    //         cos(n_tau * n_side_nor)*n_radius\n    // );\n    // o_p2 = vec2(\n    //         sin(n_tau * (n_side_nor+(1.0/n_sides)))*n_radius,\n    //         cos(n_tau * (n_side_nor+(1.0/n_sides)))*n_radius\n    // );\n    // vec2 o_delta2 = o_p2-o_p1;\n    // float n_m = o_delta2.y / o_delta2.x;\n    // float n_q = -(n_m*o_p1.x) + o_p1.y;\n    // float n_x = o_pix_cor_nor.x;\n    // float n_y = n_m * n_x + n_q; \n    // float n_dist4 = abs(o_pix_cor_nor.y-n_y);\n    // n_dist = min(n_dist, n_dist4);\n    \n    return n_dist;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_cor_nor = (fragCoord.xy - iResolution.xy* 0.5) / iResolution.y;\n    vec2 o_mou_cor_nor = (iMouse.xy - iResolution.xy* 0.5) / iResolution.y;\n    \n    float n_sides = 54.0*o_mou_cor_nor.x;\n    vec2 o_delta = o_pix_cor_nor - 0.0;\n    \n    \n    float n_angle_norm = atan(o_delta.x , o_delta.y)+(n_tau/2.0);\n    float n_angle_origin_nor = n_angle_norm / n_tau;\n    \n    float n_side = floor(n_angle_origin_nor / (1.0/n_sides));\n    \n       \n    float n_d2 = f_n_dist_circle_segment(\n        0.2, //float n_radians_nor, \n        0.0, //float n_radians_offset_nor, \n        0.4, \n        o_pix_cor_nor\n    );\n    float n_d3 = f_n_dist_circle_segment(\n        0.2, //float n_radians_nor, \n        0.2, //float n_radians_offset_nor, \n        0.4, \n        o_pix_cor_nor\n    );\n    float n_d4 = f_n_dist_circle_segment(\n        0.2, //float n_radians_nor, \n        0.4, //float n_radians_offset_nor, \n        0.4, \n        o_pix_cor_nor\n    );\n    float n_d5 = f_n_dist_circle_segment(\n        0.2, //float n_radians_nor, \n        0.6, //float n_radians_offset_nor, \n        0.4, \n        o_pix_cor_nor\n    );\n    float n_d6 = f_n_dist_circle_segment(\n        0.2, //float n_radians_nor, \n        0.8, //float n_radians_offset_nor, \n        0.4, \n        o_pix_cor_nor\n    );\n    float n_dist = min(n_d2,n_d3);\n    n_dist = min(n_dist,n_d4);\n    n_dist = min(n_dist,n_d5);\n    n_dist = min(n_dist,n_d6);\n    fragColor = vec4(sqrt((n_dist)));\n    //fragColor *= vec4(n_side/n_sides);\n    float n_d = f_n_dist_circle_segment(\n        (1./n_sides), //float n_radians_nor, \n        (1./n_sides)*(n_sides-n_side)+(0.5), //float n_radians_offset_nor, \n        0.4, \n        o_pix_cor_nor\n    );\n    fragColor = vec4(sqrt(n_d));\n    \n    //fragColor = vec4(sqrt((n_d)));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 194, 194, 2313], [2315, 2315, 2372, 2372, 4148]], "test": "untested"}
{"id": "csfXzN", "name": "Sea and moon", "author": "mrange", "description": "License CC0: Sea and moon\nTinkering with the colors of an old shaders to make it a better fit for windows terminal\n", "tags": ["waves"], "likes": 35, "viewed": 959, "published": 3, "date": "1668551305", "time_retrieved": "2024-07-30T16:19:27.769437", "image_code": "// License CC0: Sea and moon\n//  Tinkering with the colors of an old shaders to make it a better fit for windows terminal\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nconst float gravity = 1.0;\nconst float waterTension = 0.01;\n\nconst vec3 skyCol1 = vec3(0.6, 0.35, 0.3).zyx*0.5;\nconst vec3 skyCol2 = vec3(1.0, 0.3, 0.3).zyx*0.5 ;\nconst vec3 sunCol1 = vec3(1.0,0.5,0.4).zyx;\nconst vec3 sunCol2 = vec3(1.0,0.8,0.8).zyx;\nconst vec3 seaCol1 = vec3(0.1,0.2,0.2)*0.2;\nconst vec3 seaCol2 = vec3(0.2,0.9,0.6)*0.5;\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh_approx(k*h));\n  return wave(t, a ,k, w*TIME);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh_approx(k*h));\n  return wave(t, a, k, w*TIME);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh_approx(k*h));\n  return dwave(t, a, k, w*TIME);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh_approx(k*h));\n  return dwave(t, a, k, w*TIME);\n}\n\nvoid mrot(inout vec2 p, in float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  const int maxIter = 8;\n  const int midIter = 4;\n\n  float kk = 1.0/1.3;\n  float aa = 1.0/(kk*kk);\n  float k = 1.0*pow(kk, -float(maxIter) + 1.0);\n  float a = ia*0.25*pow(aa, -float(maxIter) + 1.0);\n\n  float h = 25.0;\n  p *= 0.5;\n  \n  vec2 waveDir = vec2(0.0, 1.0);\n\n  for (int i = midIter; i < maxIter; ++i) {\n    float t = dot(-waveDir, p) + float(i);\n    y += capillaryWave(t, a, k, h).y;\n    vec2 dw = capillaryWaveD(-t, a, k, h);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, PI/3.0);\n\n    k *= kk;\n    a *= aa;\n  }\n  \n  waveDir = vec2(0.0, 1.0);\n\n  for (int i = 0; i < midIter; ++i) {\n    float t = dot(waveDir, p) + float(i);\n    y += gravityWave(t, a, k, h).y;\n    vec2 dw = gravityWaveD(t, a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, -step(2.0, float(i)));\n\n    k *= kk;\n    a *= aa;\n  }\n\n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}\n\nvec3 sunDirection() {\n  vec3 dir = normalize(vec3(0, 0.06, 1));\n  return dir;\n}\n\nvec3 skyColor(in vec3 rd) {\n  vec3 sunDir = sunDirection();\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  vec3 final = vec3(0.0);\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol1*pow(sunDot, 90.0);\n  final += 4.0*sunCol2*pow(sunDot, 900.0);\n  return final;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  float dsea = (0.0 - ro.y)/rd.y;\n  \n  vec3 sunDir = sunDirection();\n  \n  vec3 sky = skyColor(rd);\n  \n  if (dsea > 0.0) {\n    vec3 p = ro + dsea*rd;\n    vec4 s = sea(p.xz, 1.0);\n    float h = s.x;    \n    vec3 nor = s.yzw;\n    nor = mix(nor, vec3(0.0, 1.0, 0.0), smoothstep(0.0, 200.0, dsea));\n\n    float fre = clamp(1.0 - dot(-nor,rd), 0.0, 1.0);\n    fre = fre*fre*fre;\n    float dif = mix(0.25, 1.0, max(dot(nor,sunDir), 0.0));\n    \n    vec3 refl = skyColor(reflect(rd, nor));\n    vec3 refr = seaCol1 + dif*sunCol1*seaCol2*0.1; \n    \n    col = mix(refr, 0.9*refl, fre);\n    \n    float atten = max(1.0 - dot(dsea,dsea) * 0.001, 0.0);\n    col += seaCol2*(p.y - h) * 2.0 * atten;\n    \n    col = mix(col, sky, 1.0 - exp(-0.01*dsea));\n    \n  } else {\n    col = sky;\n  }\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.1, 1.0));\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfXzN.jpg", "access": "api", "license": "cc0-1.0", "functions": [[583, 643, 671, 737, 813], [815, 815, 874, 874, 940], [942, 942, 1002, 1002, 1076], [1078, 1078, 1144, 1144, 1224], [1226, 1226, 1294, 1294, 1397], [1399, 1399, 1466, 1466, 1547], [1549, 1549, 1618, 1618, 1722], [1724, 1724, 1761, 1761, 1846], [1848, 1848, 1882, 1882, 2935], [2937, 2937, 2958, 2958, 3016], [3018, 3018, 3045, 3045, 3290], [3292, 3292, 3329, 3329, 4140], [4142, 4142, 4199, 4199, 4578]], "test": "error"}
{"id": "DdXXzN", "name": "Test Erosion Algo", "author": "Hatchling", "description": "Modified spalmer's algorithm to start with large scale and gradually reduce to small scale so it converges. Unfortunately near the end you get banding.", "tags": ["procedural", "terrain", "distance", "erosion"], "likes": 13, "viewed": 279, "published": 3, "date": "1668550706", "time_retrieved": "2024-07-30T16:19:28.534392", "image_code": "// fork of Hatchling's excellent http://shadertoy.com/view/ddS3WR\n// swapped distance field extrapolation and ray marcher\n// Golfed from 11934 ch down to 4611 so far.\n// With some more effort I could probably improve the noise\n// and fine tune the shape of the mountains more.\n// But I'm pretty happy with it at this point.\n\n#define quat vec4\n\nquat FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis),\n       halfAngle = mag * .5,\n       scalar = sin(halfAngle) / max(mag, .00001);\n    return vec4(angleAxis * scalar, cos(halfAngle));\n}\n\nvec3 qmul(quat q, vec3 v)\n{\n    vec3 t = 2. * cross(q.xyz, v);\n    return v + vec3(q.w * t) + cross(q.xyz, t);\n}\n\nquat qmul(quat a, quat b)\n{\n    quat q;\n    q = vec4(\n        a.wwww * b \n      + (a.xyzx * b.wwwx + a.yzxy * b.zxyy) * vec4(1, 1, 1,-1) \n      - a.zxyz * b.yzxz\n        );\n    return q;\n}\n\n#define CH iChannel0\n#define CHR iChannelResolution[0]\n\nfloat maxHeight()\n{\n    return .3; //200. / CHR.x;        \n}\n\nfloat precis()\n{\n    return 1.5 / CHR.x;        \n}\n\nfloat terrain(vec2 p)\n{\n    p.x /= CHR.x / CHR.y;    \n    p += .5;        \n    if (clamp(p, 0., 1.) != p) return .5;    \n    vec4 t = texture(CH, p);\n    return t.r * maxHeight();\n}\n\nvec3 terrainGrad(vec3 p, out vec2 curv)\n{    \n    float prec = precis();\n    float hC = terrain(p.xz);    \n    vec3 pC = vec3(p.x, hC, p.z),\n      pR = p + vec3(prec, 0,  0),\n      pL = p - vec3(prec, 0,  0),\n      pT = p + vec3( 0, 0, prec),\n      pB = p - vec3( 0, 0, prec);    \n    pR.y = terrain(pR.xz);\n    pL.y = terrain(pL.xz);\n    pT.y = terrain(pT.xz);\n    pB.y = terrain(pB.xz);    \n    vec3 n = normalize(cross(pT - pB, pR - pL));    \n    float cx = dot(pC + pC - pR - pL, n),\n          cy = dot(pC + pC - pT - pB, n);\n    curv = vec2(cx, cy) / prec;\n    return n;\n}\n\n// recombined\nvec3 skybox(vec3 dir, bool blurry)\n{\n    float g = dir.y * .5 + .5;\n    if (!blurry) {\n        g *= g;\n        g *= g;\n    }\n    g = 1.-g;\n    g *= g * g;\n    if (!blurry) {\n        g *= g;\n        g *= g;\n    }\n    g = 1.-g;\n    if (!blurry) {\n        g = smoothstep(0., 1., g);\n        g = smoothstep(0., 1., g);\n        g = smoothstep(0., 1., g);\n        g = smoothstep(0., 1., g);\n    }    \n    vec3 h = pow(vec3(g), vec3(8, 1, 1));\n    h = vec3(1.)-h;\n    h = pow(h, vec3(.4, .5, 4));\n    h = vec3(1.)-h;    \n    return mix(vec3(.99,.99,.99), vec3(.01,.02,.2), h) * 2.;\n}\n\nvec3 render(vec3 camPos, vec3 camDir)\n{\n    vec3 sky = skybox(camDir, false); // we'll need it regardless\n    if (camPos.y >= 0. && camDir.y >= 0.) \n        return sky; // early out\n\n    const float range = .7;\n    vec3 p = camPos, near = p, far = p + camDir * range;\n    float maxD = 1.;\n    bool hit = false;\n    // prone to undermarching b/c distance scaling is so wack, plus it's noisy\n    // perhaps should run another eikonal smoothing pass to compute actual SDF\n    // or simply use the gamma trick for mip maximum\n    float t = 0.;\n    for (int iter = 384; --iter > 0 && t < range; ) {\n        p = t * camDir + camPos;\n        float h = (p.y - terrain(p.xz)) / maxHeight() / 18.;\n        if (abs(h) < .002 * t) {\n            hit = true; \n            break;\n        }\n        t += .7 * h; // / range;\n    }\n    if (!hit) return sky;\n    maxD = t/range;\n    \n    vec2 curve2;\n    vec3 normal = terrainGrad(p, curve2);\n    \n    vec2 posCurve2 =  max(vec2(0), curve2);\n    vec2 negCurve2 = -min(vec2(0), curve2);\n    \n    float posCurve = posCurve2.x + posCurve2.y;\n    posCurve = posCurve / (.2 + posCurve);\n    float negCurve = negCurve2.x + negCurve2.y;\n    negCurve = negCurve / (.2 + negCurve);\n    float curve = (curve2.x + curve2.y);\n    curve = curve / (.2 + abs(curve));\n    \n    p = vec3(p.x, terrain(p.xz), p.z);\n\n    vec3 albedo  = vec3(1);\n    \n    float slopeFactor;\n    float heightFactor;\n    {\n        heightFactor = p.y / maxHeight();\n        \n        heightFactor = smoothstep(0., 1., heightFactor);        \n        heightFactor = smoothstep(0., 1., heightFactor);\n        \n        slopeFactor = abs(normal.y);\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        \n        const vec3\n            flatLow = vec3(.1, .4, .1),\n            flatHigh = vec3(.7, .7, .5),        \n            slopeLow = vec3(.4, .7, .2),\n            slopeHigh = vec3(.3, .2, .1);\n        \n        vec3 flatColor = mix(flatLow, flatHigh, heightFactor);\n        vec3 slopeColor = mix(slopeLow, slopeHigh, heightFactor);\n        \n        albedo = mix(slopeColor, flatColor, slopeFactor);\n    }\n    \n    albedo = mix(albedo, (albedo+vec3(.7))*vec3(.7,.6,.3), posCurve); \n    \n    float rivers;\n    {\n        rivers = max(0.,negCurve - posCurve);\n        \n        rivers = pow(rivers, pow(2., mix(.5, -.7, slopeFactor) + mix(-.7, .7, heightFactor)));   \n\n        rivers = smoothstep(0., 1., rivers);\n        rivers = smoothstep(0., 1., rivers);\n        \n        albedo = mix(albedo, vec3(.1,.2,.5), rivers); \n    }\n    float snow = pow(heightFactor, 8.);\n    albedo = min(mix(albedo, vec3(8), snow), 1.);\n\n    albedo *= albedo; // guess all those colors were specified in sRGB gamma?\n\n    const vec3 lightDir = normalize(vec3(0, 3, 5)),\n      lightColor = 2. * vec3(1., .75, .5);    \n    float nl = max(0., dot(normal, lightDir));\n    \n    float specm = 0.;\n    specm = mix(specm, .5, posCurve);\n    specm = mix(specm, 3., rivers);\n    specm = mix(specm, 2., snow);\n\n    float spec = max(0., dot(camDir, reflect(lightDir, normal))); // phong specular\n    spec = pow(spec, 128.);\n\n    float ambient = normal.y * .5 + .5; // hemisphere ambient\n    ambient *= .2*exp2(-4. * negCurve);\n    vec3 ambientColor = ambient * skybox(normal, true);\n\n    vec3 color = nl*lightColor*(albedo + spec*specm) + ambientColor * albedo;\n\n    float d2 = t*t; //dot(p - camPos, p - camPos);  \n    color = mix(sky, color, exp2(-3.*d2)); // fog  \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 d = normalize(vec3(fragCoord - .5*iResolution.xy, iResolution.y)), // ray dir\n       e = vec3(0, maxHeight() * 1., -.5); // eye pos    \n    quat pan = FromAngleAxis(vec3(0, iTime * .1, 0)),\n       tilt = normalize(quat(1,0,0,4));\n    e = qmul(pan, e);\n    d = qmul(qmul(pan, tilt), d);    \n    vec3 c = render(e, d);\n    fragColor = vec4(c / (c + .3), 1);\n}  \n    // just show the heightmap\n    //fragColor = textureLod(iChannel0, fragCoord/iResolution.xy, 0.);\n    //fragColor /= fragColor.a;\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// from Eikonal FIM at http://shadertoy.com/view/7dGSz3\n// RNG\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0) - textureLod(tex, fragCoord, 20.0);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n    \n    //o = vec4(sampleRandom(iChannel3, p, rngState).g);\n    //return;\n\n #define decode(x) (((x) - bias) * e)\n #define T(x) decode(textureLod(iChannel2, (x)/r, 0.).r - textureLod(iChannel2, (x)/r, 20.).r + 0.5)\n    vec2 r = iResolution.xy;\n    const float bias = .5, // meh\n        e = exp2(8.5); // controls steepness\n    o = texelFetch(iChannel2, ivec2(0), 0);\n    \n    float time = iTime * 4.0 + 1.5;\n    float temperature = time*time*10.1+1.0;\n    float scaleTemperature = sqrt(time);\n    \n    float d = T(p);\n    // handle resolution change, for full screen support\n    if (iFrame < 1 || !(length(o.yz-r) < .5) || iChannelResolution[3].x < 1.) {\n        d = sampleRandom(iChannel3, p * scaleTemperature, rngState).g;\n    } else {\n        float od = d/e + bias; // undoes some stuff in T FIXME\n        // compute local gradient\n        vec2 g = vec2(T(p + vec2(1,0))\n                    - T(p - vec2(1,0))\n                    , T(p + vec2(0,1))\n                    - T(p - vec2(0,1))) * .5;\n        float dsgn = sign(d);\n        dsgn *= 50.0 / (temperature); // slow melt rate\n        const float stretch = 1.001;\n        vec2 q = p - dsgn * inversesqrt(dot(g, g)) * g;\n        d = T(q)\n            + dsgn * stretch;\n        d /= e;\n        d += bias;\n        d = mix(od, d, .8);\n        float noise = sampleRandom(iChannel3, p*sqrt(time), rngState).g;\n              \n        d += noise*2.0 / (temperature);\n       d = clamp(d, 0., 1.);\n    }\n    //d = sampleRandom(iChannel3, p * (iTime*iTime+1.0), rngState).g/ (iTime*iTime+1.0);\n    o = vec4(d,d,d,1);\n    if (ivec2(p) == ivec2(0))\n        o.yz = r;\n}\n", "buffer_b_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 380, 380, 550], [552, 552, 579, 579, 664], [666, 666, 693, 693, 854], [912, 912, 931, 931, 972], [974, 974, 990, 990, 1024], [1026, 1026, 1049, 1049, 1207], [1209, 1209, 1250, 1250, 1786], [1788, 1802, 1838, 1838, 2378], [2380, 2380, 2419, 2419, 6274], [6276, 6276, 6328, 6328, 6695]], "test": "untested"}
{"id": "DsfSzN", "name": "Silk 3.0", "author": "uratowel12", "description": "Swag", "tags": ["swag"], "likes": 13, "viewed": 307, "published": 3, "date": "1668548652", "time_retrieved": "2024-07-30T16:19:29.375144", "image_code": "#define NUM_LAYER 8.\n\n\nmat2 Rot(float angle){\n    float s=sin(angle), c=cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//random number between 0 and 1\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34, 456.21));\n    p +=dot(p, p+45.32);\n    return  fract(p.x*p.y);\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);//center of screen is origin of uv -- length give us distance from every pixel to te center\n    float m = .05/d;\n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m +=rays*flare;\n    \n    uv *=Rot(3.1415/4.);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m +=rays*.3*flare;\n    m *=smoothstep(1., .2, d);\n    return m;\n}\n\nvec3 StarLayer(vec2 uv){\n   \n   vec3 col = vec3(0.);\n   \n    vec2 gv= fract(uv)-.5; //gv is grid view\n    vec2 id= floor(uv);\n    \n    for(int y=-1; y<=1; y++){\n        for(int x=-1; x<=1; x++){\n            \n            vec2 offset= vec2(x, y);\n            float n = Hash21(id+offset);\n            float size = fract(n*345.32);\n                float star= Star(gv-offset-(vec2(n, fract(n*34.))-.5), smoothstep(.9, 1., size)*.6);\n            vec3 color = sin(vec3(.2, .3, .9)*fract(n*2345.2)*123.2)*.5+.5;\n            color = color*vec3(1., .25, 1.+size);\n            \n            star *=sin(iTime*3.+n*6.2831)*.5+1.;\n            col +=star*size*color; \n            \n         }\n     }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t=  iTime*.02;\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    uv *=Rot(t);\n    uv +=M*4.;\n    \n    vec3 col = vec3(0.);\n    \n    for(float i =0.; i<1.; i += 1./NUM_LAYER){\n        float depth = fract(i+t);\n        float scale= mix(10.,.5, depth);\n        float fade = depth*smoothstep(1., .9, depth);\n        col += StarLayer(uv*scale+i*453.32-M)*fade;\n    }\n    fragColor = vec4(col,1.0);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 45, 45, 115], [117, 149, 170, 170, 264], [266, 266, 299, 299, 653], [655, 655, 679, 679, 1356], [1357, 1357, 1414, 1414, 1894]], "test": "untested"}
{"id": "csfSzN", "name": "Silk 2.0", "author": "uratowel12", "description": "Swag", "tags": ["swag"], "likes": 6, "viewed": 284, "published": 3, "date": "1668548398", "time_retrieved": "2024-07-30T16:19:30.131123", "image_code": "#define NUM_LAYER 8.\n\n\nmat2 Rot(float angle){\n    float s=sin(angle), c=cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//random number between 0 and 1\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(13.34, 46.21));\n    p +=dot(p, p+5.32);\n    return  fract(p.x*p.y);\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);//center of screen is origin of uv -- length give us distance from every pixel to te center\n    float m = .03/d;\n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m +=rays*flare;\n    \n    uv *=Rot(3.1415/4.);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m +=rays*.3*flare;\n    m *=smoothstep(1., .2, d);\n    return m;\n}\n\nvec3 StarLayer(vec2 uv){\n   \n   vec3 col = vec3(0.);\n   \n    vec2 gv= fract(uv)-.1; //gv is grid view\n    vec2 id= floor(uv);\n    \n    for(int y=-1; y<=1; y++){\n        for(int x=-1; x<=1; x++){\n            \n            vec2 offset= vec2(x, y);\n            float n = Hash21(id+offset);\n            float size = fract(n*345.32);\n                float star= Star(gv-offset-(vec2(n, fract(n*800.))-.8), smoothstep(.2, 1., size)*.6);\n            vec3 color = sin(vec3(.4, .9, .2)*fract(n*2345.2)*123.2)*.5+.5;\n            color = color*vec3(1., 1.0, 1.+size);\n            \n            star *=sin(iTime*3.+n*6.2831)*.5+1.;\n            col +=star*size*color; \n            \n         }\n     }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t=  iTime*.02;\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    uv *=Rot(t);\n    uv +=M*4.;\n    \n    vec3 col = vec3(0.);\n    \n    for(float i =0.; i<1.; i += 1./NUM_LAYER){\n        float depth = fract(i+t);\n        float scale= mix(5.,.5, depth);\n        float fade = depth*smoothstep(1.4, .1, depth);\n        col += StarLayer(uv*scale+i*453.32-M)*fade;\n    }\n    fragColor = vec4(col,1.6);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 45, 45, 115], [117, 149, 170, 170, 261], [263, 263, 296, 296, 650], [652, 652, 676, 676, 1354], [1355, 1355, 1412, 1412, 1892]], "test": "untested"}
{"id": "csfSRN", "name": "Psychedelic Pills", "author": "kishimisu", "description": "This is a still image. If you see it animated you're probably tripping", "tags": ["raymarching", "domain", "colorful", "space", "repetition", "rgb", "chromatic", "aberration", "trippy"], "likes": 37, "viewed": 684, "published": 3, "date": "1668537943", "time_retrieved": "2024-07-30T16:19:30.887102", "image_code": "/* \"Psychedelic Pills\" by @kishimisu (2022) - https://www.shadertoy.com/view/csfSRN\n\n   Playing around with raymarching, space repetition, \n   psychedelic colors and code golfing.\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n*/\n\nvoid mainImage(out vec4 O, vec2 F) {\n_AA_START\n    float p, s, y, c, h = 3., \n                      e = iTime*.4+.8;\n    \n    vec2 r = iResolution.xy,\n         v = (F*2.-r-f)/r.y;\n         \n    for (s = 0.; s < 2e2 && abs(h) > .001 && p < 40.; s++) {\n        vec3 o = p * normalize(vec3(1., v));\n        c      = sin(e + p*.5)*.25;\n        y      = c + .25;\n        o.x   += e; \n        o.y    = abs(o.y);\n        o      = fract(o) - .5;\n        o.xy  *= mat2(cos(e + vec4(0,33,11,0)));\n        o.y   += y/2.; \n        o.y   -= clamp(o.y, 0., y);     \n        p += h = (length(o) - .1*(.75 + p*.1 + c))*.8;\n    }\n        \n    tot.rgb += exp(-p*.15 - .5*length(v)) * (cos(p*(8.4 + 0.16*vec3(0,1,2)))*1.2+1.2);\n_AA_END\n}", "image_inputs": [], "common_code": "/* Anti-aliasing code */\n\n#define AA 2\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 f = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END        \\\n} tot /= float(AA*AA); \\\nO = vec4(tot, 1.);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfSRN.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [], "test": "untested"}
{"id": "csXSz4", "name": "Random tiles", "author": "thespudguy", "description": "Just a random little experiment", "tags": ["random"], "likes": 0, "viewed": 166, "published": 3, "date": "1668533168", "time_retrieved": "2024-07-30T16:19:31.651060", "image_code": "vec2 getCell(vec2 pos, float offset)\n{\n    pos = (pos);\n    vec2 unit = vec2(0.,1.);\n    float theta = sin(pos.x)-cos(pos.y)+offset;\n    float rand1 = unit.x*cos(theta) + unit.y*sin(theta);\n    float rand2 = unit.y*cos(theta) - unit.x*sin(theta);\n    return vec2(rand1, rand2);\n}\n\nvec3 dVal(vec2 pos, float mixer, float offset)\n{\n    vec2 pos1 = (pos+offset/2.);\n    vec2 cell1 = getCell(pos,offset);\n    vec2 cell2 = getCell(vec2(pos.x+offset, pos.y),offset);\n    vec2 cell3 = getCell(pos+offset,offset);\n    vec2 cell4 = getCell(vec2(pos.x, pos.y+offset),offset);\n    float dist1 = length(vec2(cell1.y,-cell2.x));\n    float dist2 = length(vec2(cell1.y,-cell3.x));\n    float dist3 = length(vec2(cell3.y,-cell4.x));\n    if (iMouse.x==iMouse.z)\n    {\n        return vec3(dist1*0.,dist3*0.,dist3/dist2);\n    }\n    return vec3(dist1,dist3,dist3/dist2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/15.;\n    vec3 amount = dVal(uv, .5, iTime)/4.;\n    // Time varying pixel color\n    vec3 col = amount;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXSz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 279], [281, 281, 329, 329, 851], [853, 853, 910, 960, 1144]], "test": "untested"}
{"id": "DsXXR4", "name": "Invert color ", "author": "axiomgraph", "description": "simple color invert", "tags": ["invert", "color"], "likes": 0, "viewed": 237, "published": 3, "date": "1668531947", "time_retrieved": "2024-07-30T16:19:32.635427", "image_code": "\n\nint invert = 1; // 0 means no original color 1 means invert\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    if(invert == 0) {\n        fragColor = color;\n    } else {\n    fragColor = vec4(1.0-color.rgb,1.0);\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 119, 119, 296]], "test": "untested"}
{"id": "mslXz8", "name": "random wave ", "author": "jonasfrey", "description": "random sine", "tags": ["random"], "likes": 12, "viewed": 227, "published": 3, "date": "1668523165", "time_retrieved": "2024-07-30T16:19:33.621790", "image_code": "float f_n_rand(vec2 o){\n    return fract(cos(o.x*3123.123+o.y*4321.234)*123.123);\n}\nfloat f_n_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat f_n_noise_smooth(vec2 o_pix_coo_nor){\n    //vec2 o_cells = vec2(10.,10.);\n    \n    //vec2 o_coo_big_mod = fract(o_pix_coo_nor*o_cells);\n    //vec2 o_coo_big_mod = smoothstep(0.,1.,fract(o_pix_coo_nor*o_cells));\n    vec2 o_coo_big_mod = smoothstep(0.,1.,fract(o_pix_coo_nor));\n    \n    vec2 o_coo_big_flo = floor(o_pix_coo_nor);\n    //float n_index = o_coo_big_flo.x + o_coo_big_flo.y * o_cells.x;\n    \n    float o_col = f_n_hash12(o_coo_big_flo);\n    float o_col_xp1 = f_n_hash12(o_coo_big_flo + vec2(1,0));\n    float o_col_mix_xp1 = mix(o_col, o_col_xp1, o_coo_big_mod.x);\n    \n    float o_col_yp1 = f_n_hash12(o_coo_big_flo+ vec2(0, 1));\n    float o_col_xp1_yp1 = f_n_hash12(o_coo_big_flo + vec2(1,1));\n    float o_col_mix_yp1_xp1_yp1 = mix(o_col_yp1, o_col_xp1_yp1, o_coo_big_mod.x);\n    \n    float o_col_mix = mix(o_col_mix_xp1, o_col_mix_yp1_xp1_yp1, o_coo_big_mod.y);\n    return o_col_mix;\n}\n\nfloat f_n_noise_smooth_layered(\n    vec2 o_pix_coo_nor,\n    float n_freq_start, \n    float n_layers\n){\n    float n_freq = n_freq_start;\n    float n_noise_smooth = f_n_noise_smooth(o_pix_coo_nor*n_freq);\n\n    float n_amp = 0.5; \n    float n_amp_sum = 0.0;\n    for(\n        float n_layer_nor = 0.0;\n        n_layer_nor < 1.0;\n        n_layer_nor += (1.0/n_layers)\n    ){\n        n_freq *= 2.0;\n        n_noise_smooth += f_n_noise_smooth(o_pix_coo_nor*n_freq)*n_amp;\n        n_amp_sum += n_amp;\n        n_amp*=0.5;\n    }\n    \n    n_noise_smooth /= 1.0+n_amp_sum;\n    \n    return n_noise_smooth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n    float n_noise_smooth_layered = f_n_noise_smooth_layered(\n        //o_pix_coo_nor+vec2(0.0, iTime*2.0),\n        vec2(o_pix_coo_nor.x+iTime, 0.0),\n        2.0,\n        3.0\n    );\n    if(o_pix_coo_nor.x>0.0){\n    n_noise_smooth_layered = f_n_noise_smooth_layered(\n        o_pix_coo_nor+vec2(0.0, iTime*2.0),\n        //vec2(o_pix_coo_nor.x+iTime, 0.0),\n        2.0,\n        3.0\n    );\n    }\n    \n    float n_tau = 6.2831;\n    float n_rand = 1.0-n_noise_smooth_layered;\n    float n_freq = n_rand*2.0;\n    float n_amp = 0.5+n_rand;\n    float n_y = sin(n_freq)*(n_amp/2.0)*(n_amp/2.0);\n    \n    float n_dist = abs(o_pix_coo_nor.y - n_y+n_amp*0.1); \n    \n    float n_dist2 = abs(o_pix_coo_nor.y - n_y+n_amp*0.1); \n    fragColor = vec4(1.-sqrt(n_dist));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslXz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 83], [84, 84, 110, 110, 227], [230, 230, 273, 446, 1133], [1135, 1135, 1237, 1237, 1728], [1730, 1730, 1787, 1787, 2621]], "test": "untested"}
{"id": "cdjGWy", "name": "Extruded Hexagon Fractal Curve", "author": "Shane", "description": "An extruded non-intersecting hexagon fractal curve.", "tags": ["fractal", "hexagon", "truchet", "curve", "polar", "extrude", "gosper"], "likes": 71, "viewed": 663, "published": 3, "date": "1668517432", "time_retrieved": "2024-07-30T16:19:34.869454", "image_code": "/*\n\n    Extruded Hexagon Fractal Curve\n    ------------------------------\n    \n    This is an extruded hexagon fractal curve -- to match the 2D version that \n    I posted earlier. The original was constructed in a tri-level blob form, \n    but I've rendered this in a curved configuration to better display the \n    non-intersecting space-filling curve properties. As you can see, it has \n    a hexagon Truchet look about it.\n    \n    Although not the same, it has a similar feel to Fabrice Neyret and MLA's \n    Gosper curve examples, which are well worth the look if you haven't seen \n    them. Gosper curves are one those interesting and important topics that \n    very little code exists for.\n    \n    Technically, there's not much to this. I've rendered the curve in 2D to a\n    backbuffer, then extruded the 2D field inside the raymarching distance \n    function, which is a lot faster than constructing things on the fly. As a \n    small aside, it would be much more practical to render from a fixed size \n    buffer for many reasons. Even though cube map faces have fixed sizes, \n    they are not fun to work with in that capacity.\n    \n    I kept the lighting and coloring very basic, which is just another way to \n    say, I was feeling lazy. :D There are a few defines at the top of the \n    \"Common\" tab for anyone interested in changing the color, curve shape, etc.\n \n\n\n    \n    Related examples:\n    \n    // The Gosper curves are different, but have a very similar feel.\n    Gosper Closed Curves - mla\n    https://www.shadertoy.com/view/mdXGWl\n    \n    // The original Gosper curve example on here.\n    Gosper curve - FabriceNeyret2\n    https://www.shadertoy.com/view/cdsGRj\n    \n    // A 2D hexagon fractal version.\n    Hexagon Fractal Object - Shane\n    https://www.shadertoy.com/view/cdfGzs\n    \n*/\n\n\n// Global tile scale.\nvec2 scale = vec2(1./8.);\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID.\nfloat objID;\n\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    // Reading into \"Buffer A\".\n    // Stretching to account for the varying buffer size.\n    p *= vec2(iResolution.y/iResolution.x, 1);\n    return texture(iChannel0, p + .5).x;\n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n \n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = p.y;\n\n    // The 2D hexagon fractal object.\n    float d2 = hm(p.xz);\n    \n    // Extruding the 2D field.\n    float d = opExtrusion(d2, p.y, .05);\n    \n    //d += d2*.25; // Raised tops.\n  \n    // Overall object ID.\n    objID = fl<d? 1. : 0.;\n    \n    // Combining the floor with the extruded object.\n    return  min(fl, d);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .005, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    \n\t// Camera Setup.\n    vec3 ro = vec3(cos(iTime/8.)*1.1, 1.25, sin(iTime/8.)*1.1); // Camera position, doubling as the ray origin.\n\tvec3 lk = vec3(0, -.06, 0);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = lk + vec3(-.25, .5, .4);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .5; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    //if(dot(fwd, vec3(fwd.z, 0, -fwd.x))==0.) fwd = normalize(fwd - vec3(0, 0, .00001));\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd));// Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n    \n    // Camera.\n    //mat3 mCam = mat3(rgt, up, fwd);\n    // rd - Ray direction.\n    //vec3 rd = mCam*normalize(vec3(uv, 1./FOV));//\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the object ID.\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6); \n        \n        vec2 txP = sp.xz;        \n        txP *= vec2(iResolution.y/iResolution.x, 1);\n        vec4 tx = texture(iChannel0, txP + .5);\n        float dst = tx.w;\n        float sf = 1./iResolution.y;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            //float h = hm(sp.xz);\n            \n\n            \n            dst = max(dst, sp.y - .05 - .02);\n\n            \n            // The fractal curve object color.\n            #if COLOR == 0\n            vec3 fg = vec3(1, .2, .4);\n            fg = mix(fg, vec3(1, .4, .2), uv.y*.5 + .25);\n            #elif COLOR == 1\n            vec3 fg = vec3(.8, 1, .15);\n            fg = mix(fg, vec3(1, .8, .2), uv.y*.5 + .25);\n            #elif COLOR == 2\n            vec3 fg = vec3(.2, .5, 1);\n            fg = mix(fg, vec3(.1, .9, 1), uv.y*.5 + .25);\n            #else\n            vec3 fg = vec3(.85);\n            fg = mix(fg, vec3(.88, .9, .95), uv.y*.5 + .25);\n            #endif\n\n            // Object color.\n            \n            float th = .005*float(2 - cInd);\n            vec3 oCol = vec3(0);\n            oCol = mix(oCol, pow(fg, vec3(1)), 1. - smoothstep(0., sf,  dst + .005));\n            // Surface detail.\n            //oCol = mix(oCol, oCol*.5, 1. - smoothstep(0., sf,  abs(dst + .013) - .001));\n\n            texCol = mix(oCol, pow(fg, vec3(1.4)), 1. - smoothstep(0., sf, sp.y - .05 + .002));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, sp.y - .005));\n \n        }\n        else {\n            \n            // The floor pattern.\n            \n            \n            // Background.\n            texCol = vec3(.1); //vec3(.4, .35, .3); //vec3(.9, .95, 1)\n      \n            // The hexagon Truchet background.\n            float hSc = .2/.8660254*sqrt(7.)/scale.x*2.; // Scale based on the main pattern level.\n            vec2 hUV = rot2(-atan(sqrt(3.)/9.))*sp.xz; // Rotating the coordinates.\n            float bgP = bgPat(hUV*hSc)/hSc;\n            vec3 svBg = texCol;\n\n            // Rendering the hexagon background pattern.\n            texCol = mix(texCol, svBg*.8, (1. - smoothstep(0., sf*8., bgP)));  \n            texCol = mix(texCol, svBg*.5, 1. - smoothstep(0., sf, bgP));   \n            texCol = mix(texCol, svBg*1.1, 1. - smoothstep(0., sf, bgP + .0035));  \n            // Surface detail.\n            //texCol = mix(texCol, svBg*.6, 1. - smoothstep(0., sf,  abs(bgP + .011) - .001));\n \n            // Rendering some dark edges to match the extruded pattern.\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf,  dst - .0005));\n        \n        }\n       \n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n        \n        // It's sometimes helpful to check things like shadows and AO by themselves.\n        //col = vec3(ao);\n          \n\t\n\t}\n    \n    // Horizon fog. Not visible here, but provided for completeness.\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The 2D hexagon fractal object.\n\n\n// Dividing line passing through \"a\" and \"b\".\nfloat divLine(vec2 p, vec2 a, vec2 b){\n\n   // I've had to put a hack on the end to get rid of fine lines\n   // at the zero point. That, of course, invalidates the distance portion.\n   // However, in this case, I only need it for a border check, not distances.\n   // I'm not sure why the hack is needed... Some kind of float inaccuracy... \n   // I'll look into it later. :)\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b))*1e8;\n}\n\n// Standard polar partitioning.\nvec2 polRot(vec2 p, inout float na, int m){\n\n    const float aN = 6.;\n    float a = atan(p.y, p.x);\n    na = mod(floor(a/6.2831*aN) + float(m - 1), aN);\n    float ia = (na + .5)/aN;\n    p *= rot2(-ia*6.2831);\n    // Flip alternate cells about the center.\n    if(mod(na, 2.)<.001) p.y = -p.y;\n\n    return p;\n}\n\n// Partition lines.\nvec3 prtnLines(vec2 p, mat3x2 ctr){\n\n                \n    // Cell partition lines.\n    float div1 = divLine(p, ctr[1], ctr[0]);\n    float div2 = divLine(p, ctr[2], ctr[1]);  \n     // Cell border.\n    float bR = divLine(p, vec2(0), ctr[2]);\n    //bL = divLine(p, vec2(0), ctr[0]);\n\n    return vec3(div1, -max(div1, div2), max(div2, bR));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc*1.5/iResolution.y;\n    \n    // Automatically rotate through all levels.\n    //cInd = int(mod(floor(iTime/4.), 2.));\n    \n    \n    // Scaling and translation.\n    vec2 p = sc*uv;//rot2(3.14159/6. - iTime/24.)*sc*uv;\n    \n    // Scene field calculations.\n\n    vec2 op = p;\n    \n    // The distance field for each level.\n    vec3 gDst = vec3(1e5);\n \n    // Polar cell numbers.\n    vec3 na;    \n  \n    \n    // Bounds for each level.\n    float gBound = 1e5;\n\n    \n    // I poached this from one of my hexagonal six petal geometry examples. I remember\n    // working it out on paper and liking the fact that it was so weird but concise. \n    // Unfortunately, I didn't mention how I got there. :)\n    const float shF = sqrt(1./7.);\n    // The original radius of the circle that the curve is constucted around.\n    const float r0 = .2;\n    const float hr0 = r0/.8660254; // Hexagon radius.\n    float r20 = hr0/3.; // Small circle radius.\n    #if SHAPE != 0\n    r20 *= .8660254; // Readjusting the radius for hexagonal shapes.\n    #endif\n    // Each polar cell has an S-shaped curve running through it, which is\n    // constructed with three vertex points. There are two on the cell boundaries, \n    // and one in the center -- Check the figure with one iteration for a visual. \n    // The vertex scale changes for greater iteration depth, but not the direction, \n    // so we're going to precalculate the original scale and direction here.\n    mat3x2 ctr0 = mat3x2(rot2(3.14159/6.)*vec2(hr0*2./3., 0), vec2(r0*4./3., 0), \n                         rot2(-3.14159/6.)*vec2(hr0*4./3., 0));\n    \n    // Precalculating the rotation matrices, which get used a few times.\n    // The angle is a hexagonal rotation related number involving ratios...\n    // The tangential angle between thrice the apothem and half the side\n    // length... I worked it out long ago, and no longer care why it works. :D\n    //\n    // Angle between the vertical line and the line running through the \n    // left hexagon vertex to the right vertex on the hexagon above.\n    float rotAng = atan(sqrt(3.)/9.); // Approx: 0.19012.\n    mat2 mRot = rot2(rotAng);\n    mat2 mRotP3 = rot2(rotAng + 3.14159/3.); // Inner curve needs extra rotation.\n\n    for(int aI = 0; aI<3; aI++){\n\n        // The radius of the circle that the curve is constucted around.\n        float r2 = r20; // Small circle radius.\n        p = op; // Original global coordinates.\n       \n        // Split this space into polar cells, and return the local coordinates\n        // and the cell number, which is used later.\n        p = polRot(p, na.x, aI);\n\n\n        mat3x2 ctr = ctr0; // Curve center -- There are three in each segment.\n\n\n        // Partition lines for each of the three vertices in the cell.\n        vec3 oDiv = prtnLines(p, ctr);\n        // Hexagon bounds for this scale. It's used to reverse coloring at the end.\n        gBound = min(gBound, max(-oDiv.y, oDiv.z)); // Previous hexagonal boundary lines.\n\n    \n        // Left, middle, right central point distances.\n        vec3 c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n        \n        \n        c = max(c*vec3(-1, 1, -1), oDiv);\n\n        float crv = min(max(c.x, c.z), c.y);\n        \n        if(crv<gDst.x){ gDst.x = crv; }\n        \n        \n\n        ////////////////////////  \n\n        // Move to the new frame of reference, readjust r to the new scale\n        // (the smaller circle, r2), then recalculate the curve.\n        \n        // Move to the new points.\n        mat3x2 p3 = mat3x2(p, p, p) - ctr;\n        //\n        if(mod(na.x, 2.)<.001){\n            // Flip the X-value in every second polar cell.\n            p3[0].x = -p3[0].x; p3[1].x = -p3[1].x; p3[2].x = -p3[2].x;\n        }\n        // Rotate each point to the new orientation. The second point\n        // needs to be rotated an extra 60 degrees.\n        p3[0] *= mRot; p3[1] *= mRotP3; p3[2] *= mRot;\n \n\n        for(int i = 0; i<3; i++){\n\n            ctr = ctr0*shF; \n            r2 = r20*shF;\n            \n            p = p3[i];\n            \n            // Split this space into polar cells, and return the local coordinates\n            // and the cell number, which is used later.\n            p = polRot(p, na.y, 1); // bI - 1\n\n\n            // Partition lines for each of the three vertices in the cell.\n            vec3 oDiv2 = prtnLines(p, ctr);\n            \n       \n            // Applying the previous clipping region to this one.\n            oDiv2 = max(oDiv2, oDiv[i]);\n     \n            // Left, middle, right central point distances.\n            c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n            ////\n            \n            c = max(c*vec3(-1, 1, -1), oDiv2);\n           \n            crv = min(max(c.x, c.z), c.y);\n        \n            if(crv<gDst.y){ gDst.y = crv; }\n\n           \n       \n\n        } // End \"i\".\n        \n\n    } // End \"aI\".   \n\n\n    \n    // Clamp the level index between zero and one, since they're the only\n    // one's that work.\n    cInd = cInd<0? 0 : cInd>1? 1 : cInd;\n    \n    // Flipping patterns outside the bounds of previous levels... Yeah, it's confusing. :)\n    // With Truchet patterns, there's usually some cell pattern flipping involved, but with \n    // this example, there's level flipping also. \n    if(gBound<0.){ gDst.y = -gDst.y; gDst.z = -gDst.z; }\n     \n    // Giving the pattern some extra thickness.\n    gDst -= .004*float(3 - cInd);\n    \n    #ifdef CURVE\n    gDst = abs(gDst + .004*float(3 - cInd)) - .009*float(3 - cInd);\n    #endif\n \n    \n\n    // Edge, or stroke.\n    float dst = gDst[cInd];\n\n\n    // Output to screen\n    fragColor = vec4(dst);\n}", "buffer_a_inputs": [], "common_code": "\n// Fractal iteration depth. I'm only prividing 2 here, so the\n// numbers are 0 for the base object or 1.\nint cInd = 1;\n\n// Display the closed curve... Technically, the dark edges are the closed\n// curve, but this presents it more fully.\n#define CURVE\n\n// Arc shape. Circular: 0, Hexagon: 1.\n#define SHAPE 0\n\n// Color: Terracotta: 0, Lime: 1, Blue: 2, White: 3.\n#define COLOR 0\n\n\n//////////////\n// Background pattern code.\n// vec2 to float hash.\nfloat hash21( vec2 p ){ \n\n    return fract(sin(dot(p, vec2(1, 113)))*45758.5453); \n    // Animation, if preferred.\n    //p.x = fract(sin(dot(p, vec2(1, 113)))*45758.5453);\n    //return sin(p.x*6.2831853 + iTime)*.5 + .5; \n}\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Arc or blob shape.\nfloat dist(vec2 p){\n  \n    #if SHAPE == 0\n    return length(p); // Circle.\n    #else\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x); // Hexagon.\n    #endif\n\n}\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers.\n\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. \n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n// A pretty simple hexagon Truchet pattern.\n//\n// I'm using the standard arc pattern for the fractal hexagon curve option, \n// and the blob equivalent for the non-curve (or blob) option.\nfloat bgPat(vec2 p){\n\n    // The hexagon grid.\n    vec4 h = getHex(p + vec2(0, s.y/3.));\n    \n     // Unique random number.\n    float rnd = hash21(h.zw + .11);\n    #ifdef CURVE\n    h.xy *= rot2(3.14159/3.*floor(rnd*72.));\n    #else\n    if(rnd<.5) h.y = -h.y;\n    #endif\n    \n    // Distances from three equispapced hexagon vertices.\n    vec2 v = vec2(0, s.y/3.);\n    \n    // Three circles at the vertices.\n    vec3 cDist = vec3(dist(h.xy - v), \n                      dist(h.xy - rot2(6.2831/3.)*v), \n                      dist(h.xy - rot2(2.*6.2831/3.)*v)); \n    \n    \n    // Random circle size.\n    vec3 r = vec3(s.y/6.);\n    #if SHAPE != 0\n    r *= .8660254; // Readjusting the radius for hexagonal shapes.\n    #endif\n    \n    #ifdef CURVE\n    // Randomly replace some of the arcs with end point dots.\n    for(int i = 0; i<3; i++){\n       \n        if(hash21(h.zw + float(i + 1)/6.)<.2){\n\n            r.x = 0., \n            cDist.x = dist(h.xy - rot2(-6.2831/12. + float(i)*6.2831/3.)*v*.8660254);\n            cDist.x = min(cDist.x, dist(h.xy - rot2(6.2831/12. + float(i)*6.2831/3.)*v*.8660254));\n        }\n        \n        r = r.yzx;\n        cDist = cDist.yzx;\n    }\n    #endif\n   \n    cDist -= r;\n    \n    float d = min(min(cDist.x, cDist.y), cDist.z);\n    #ifdef CURVE\n    d = abs(d) - .15; // Circles to arcs.\n    #else\n    if(rnd<.5) d = -d; // Flip the pattern for the blob version.\n    #endif\n    \n    \n    return d;\n\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1942, 1963, 1983, 2075, 2170], [2173, 2200, 2257, 2257, 2563], [2568, 2591, 2609, 2628, 2971], [2975, 2996, 3032, 3081, 3519], [3522, 3622, 3658, 4037, 4309], [4312, 4503, 4555, 4636, 5902], [5905, 6057, 6092, 6092, 6337], [6340, 6340, 6396, 6429, 12470]], "test": "untested"}
{"id": "cslSzH", "name": "3D Perlin Noise Contours", "author": "mla", "description": "Playing around with [url]https://www.shadertoy.com/view/dsXSzH[/url] by @hzh98", "tags": ["noise", "perlin", "contours"], "likes": 13, "viewed": 340, "published": 3, "date": "1668509374", "time_retrieved": "2024-07-30T16:19:35.824900", "image_code": "// Just playing around with https://www.shadertoy.com/view/dsXSzH by @hzh9\nfloat linewidth = 1.0; // Line width in pixels\n\n// Code by @hzh98\n#define HASH_LUT_SIZE 256\n#define inc(x) (x+1)%HASH_LUT_SIZE\n\n// Hash lookup table as defined by Ken Perlin.\n// This is a randomly arranged array of all numbers from 0-255 inclusive.\nconst int p[2*HASH_LUT_SIZE] = int[2*HASH_LUT_SIZE](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180); \n\n#define clamp(x,y,z) (min(max(x,y),z)) // As per spec\n//#define clamp(x,y,z) (max(min(x,z),y)) // Consistent with Nvidia\n\nfloat FadeSmooth(float x) {\n    float t = clamp(0.0, 1.0, x); // Wrong order of params!\n    float t_2 = t * t;\n    float res = t_2 * t * (6.0*t_2 - 15.0*t + 10.0);\n    return res;\n}\n#if defined clamp\n#undef clamp\n#endif\n\n// pick a random vector\nfloat Grad(int hash, float x, float y, float z) {\n    int h = hash & 15;                                    \n    float u = h < 8 /* 0b1000 */ ? x : y;                \n    \n    float v;                                             \n    \n    if(h < 4 /* 0b0100 */)                               \n        v = y;\n    else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/) \n        v = x;\n    else                                                 \n        v = z;\n    \n    return ((h&1) == 0 ? u : -u)+((h&2) == 0 ? v : -v); \n}\n\nfloat PerliNoise3D(float x, float y, float z) {\n    int xi = int(floor(x)) & 255;                           \n    int yi = int(floor(y)) & 255;                              \n    int zi = int(floor(z)) & 255;                           \n    float xf = fract(x);\n    float yf = fract(y);\n    float zf = fract(z);\n    \n    float u = FadeSmooth(xf);\n    float v = FadeSmooth(yf);\n    float w = FadeSmooth(zf);\n    \n    int aaa, aba, aab, abb, baa, bba, bab, bbb;\n    aaa = p[p[p[    xi ]+    yi ]+    zi ];\n    aba = p[p[p[    xi ]+inc(yi)]+    zi ];\n    aab = p[p[p[    xi ]+    yi ]+inc(zi)];\n    abb = p[p[p[    xi ]+inc(yi)]+inc(zi)];\n    baa = p[p[p[inc(xi)]+    yi ]+    zi ];\n    bba = p[p[p[inc(xi)]+inc(yi)]+    zi ];\n    bab = p[p[p[inc(xi)]+    yi ]+inc(zi)];\n    bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];\n   \n    float x1, x2, y1, y2;\n    x1 = mix(Grad(aaa, xf, yf, zf), Grad(baa, xf-1.0, yf, zf), u);                                     \n    x2 = mix(Grad(aba, xf, yf-1.0, zf), Grad(bba, xf-1.0, yf-1.0, zf), u);\n    y1 = mix(x1, x2, v);\n\n    x1 = mix(Grad(aab, xf, yf, zf-1.0), Grad(bab, xf-1.0, yf, zf-1.0), u);\n    x2 = mix(Grad(abb, xf, yf-1.0, zf-1.0), Grad(bbb, xf-1.0, yf-1.0, zf-1.0), u);\n    y2 = mix (x1, x2, v);\n    \n    return (mix(y1, y2, w)+1.0)/2.0; \n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mostly @mla code\n    vec3 aacol = vec3(0);\n    int N = 1; // set N=2 for MSAA, though it's not really needed here.\n    for (int i = 0; i < N*N; i++) {\n      vec2 uv = 5.0*(2.0*fragCoord + vec2(i/N,i%N) -iResolution.xy) / iResolution.y;\n      vec2 noise_uv = uv + 0.5*vec2(iTime,0.0);\n    \n      float res = PerliNoise3D(noise_uv.x,noise_uv.y, 0.1*iTime);\n      float px = length(vec2(dFdx(res),dFdy(res)));\n      if (iMouse.z > 0.0) px = 0.8*fwidth(length(res)); // fwidth not so nice here.\n      float ncontours = round(12.0/linewidth);\n      if (iResolution.x > 800.0) ncontours *= 2.0;\n      float res0 = round(ncontours*res)/ncontours;\n      vec3 col = h2rgb(res-1.0/6.0);     \n      col *= smoothstep(0.0,px,abs(res-res0)-0.5*(linewidth-1.0)*px);\n      aacol += col;\n    }\n    aacol /= float(N*N);\n    aacol = pow(aacol,vec3(0.4545));\n    fragColor = vec4(aacol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2360, 2360, 2387, 2387, 2541], [2581, 2605, 2654, 2654, 3122], [3124, 3124, 3171, 3171, 4396], [4398, 4398, 4419, 4419, 4552], [4554, 4554, 4611, 4635, 5491]], "test": "untested"}
{"id": "cssSR8", "name": "bigger pixels", "author": "jonasfrey", "description": "bigger pixels", "tags": ["pixels"], "likes": 1, "viewed": 148, "published": 3, "date": "1668500275", "time_retrieved": "2024-07-30T16:19:36.721502", "image_code": "\nfloat f_n_rand(\n    vec2 o\n){\n\n    return fract(sin(o.x*33134.5543+o.y*3121.32112)*12.23*3232.33);\n    \n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_pix_coo_nor = (fragCoord.xy - iResolution.xy*0.5) /iResolution.y;\n    \n    \n    vec2 o_cells = vec2(\n        10.0, 10.0\n    );\n    \n    \n    vec2 o_cell_coo = vec2(\n        floor(o_pix_coo_nor.x * o_cells.x), \n        floor(o_pix_coo_nor.y * o_cells.y)\n    );\n    \n    float n_index = o_cell_coo.x + (o_cell_coo.y * o_cells.x);\n    \n    fragColor = vec4(sqrt(f_n_rand(o_cell_coo+floor(iTime))));\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 111], [112, 112, 169, 169, 583]], "test": "untested"}
{"id": "DdXGDX", "name": "Progressive Dragon Curve", "author": "mla", "description": "Four Dragon Curves link up nicely to form a continuous path. Curve drawn progressively. No buffer is used, the entire curve so far is drawn every frame.\n\n<mouse>: show recursion for mouse point\n'a': show shortcut lines\n'x': show entire curve\n", "tags": ["lsystem", "stack", "dragon", "curve"], "likes": 16, "viewed": 255, "published": 3, "date": "1668498427", "time_retrieved": "2024-07-30T16:19:37.881401", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Progressive Dragon Curve. mla, 2022.\n//\n// Uses an explicit stack to keep track of the recursion.\n// This one keeps track of intermediate segments and avoids recursing far from\n// the point being plotted.\n//\n// <mouse>: show recursion for mouse point\n// 'a': show shortcut lines\n// 'x': show entire curve\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int maxdepth = 10; // How deeply to recurse\n\n// Dragon Curve L-system\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff)) // Encoding\nconst int A = 0, B = 3, END = -1, L = -1, R = 1;\nconst int program[6] = int[] (C(0,A),C(R,B),C(0,END),C(0,A),C(L,B),C(0,END));\nconst float factor = 2.0; // (Area) scale factor\n\n// Global state\nvec2 point = vec2(0);         // The drawing point\nvec2 movingpoint = vec2(0); // The moving point\nbool foundmovingpoint = false;\nfloat pathlen = 0.0;          // Cumulative path length\n\n// Calculate and draw segment in final level\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  assert(t > pathlen);\n  vec2 seg = vec2(cos(theta),sin(theta));\n  if (t >= pathlen && t < pathlen+seglen) {\n    foundmovingpoint = true;\n    movingpoint = point + (t-pathlen)*seg;\n    seglen = t-pathlen;\n  }\n  vec2 newpoint = point + seglen*seg;\n  float d = 1e8;\n  d = segment(pos,point,newpoint);\n  //polywind(pos,point,newpoint);\n  pathlen += seglen;\n  point = newpoint;\n  return d;\n}\n\nvec2 map(vec2 pos) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos *= 1.666;\n  pos = -pos;\n  pos -= vec2(-0.8,0.71);\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = map(fragCoord);\n  vec2 pos2 = pos;\n  if (iMouse.z > 0.0) pos2 = map(iMouse.xy);\n  int stack[maxdepth];\n  float totalpath = 4.0*pow(factor,0.5*float(maxdepth+1));\n  float t = mod(2.0*iTime,totalpath+10.0); // Moving point position\n  t = min(t,totalpath);\n  if (key(CHAR_X)) t = totalpath;\n  float angledelta = 0.0;\n  if (!key(CHAR_Z)) angledelta = 0.015;\n  float angle = PI/2.0+angledelta;\n  float magic = 0.5*angle; // Segment rotation at each recursion level\n  float d = 1e8, d1 = 1e8; // Line distances\n  float theta = -4.0*angledelta;//0.0;       // Cumulative angle\n  float tt = 0.0;\n  // Draw four curves, which just happen to join up continuously.\n  for (int i = 0; i < 4; i++,theta+=angledelta){\n    int depth = 0;\n    stack[depth++] = B;\n    float seglen = 1.0;\n    while (depth > 0 && pathlen < t) {\n      int instr = program[stack[depth-1]++];\n      // Decode instruction\n      int turns = instr>>16;\n      int code = instr<<16>>16;\n      theta += float(turns)*angle; // Apply turn\n      if (code == END) {\n        depth--;    // Terminate level & unwind\n        seglen *= sqrt(factor);\n      } else if (depth == maxdepth) {\n        float d1 = drawsegment(pos,seglen,theta,t); // Segment\n        if (d1 < d) { d = d1; tt = pathlen; }\n      } else {\n        // Compute the end point of the segment at the current level\n        float depthdelta = float(maxdepth-depth);\n        float theta1 = theta + magic*(depthdelta-1.0);\n        // Adjust for segment type\n        if (code == A) theta1 += magic;\n        else theta1 -= magic;\n        float seglenfactor = pow(sqrt(1.0+cos(angle)),depthdelta);\n        vec2 newpoint = point+seglenfactor*seglen*vec2(cos(theta1),sin(theta1));\n        d1 = min(d1,segment(pos,point,newpoint));\n        if (distance(pos2,0.5*(point+newpoint)) > seglen) {\n          // Modify state as if we had done the full recursion\n          //polywind(pos,point,newpoint);\n          point = newpoint;\n          pathlen += seglen*pow(factor,0.5*depthdelta);\n          // Each non-final segment changes theta by angle.\n          if (code == A) theta += angle;\n          else theta -= angle;\n        } else {\n          // Actually recurse\n          stack[depth++] = code;\n          seglen /= sqrt(factor);\n        }\n      }\n    }\n  }\n  //polywind(pos,point,vec2(0)); // Just in case rounding error prevents exact closure...\n  float px = fwidth(pos.x);\n  vec3 col = texture(iChannel0,0.2*pos).xyz; //vec3(0);//vec3(1,1,0.8);\n  col = 0.1*pow(col,vec3(2.2));\n  vec3 pcol = h2rgb(tt/totalpath);\n  //if (!key(CHAR_F) && (windnum&1) != 0) col = vec3(0,0,0.05);\n  if (key(CHAR_A) || iMouse.z > 0.0) col = mix(vec3(0.5), col,smoothstep(0.0,px,d1));\n  col = mix(pcol, col,smoothstep(0.0,px,d));\n  if (foundmovingpoint) {\n    col = mix(vec3(1), col,smoothstep(0.0,px,distance(pos,movingpoint)-0.01));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.1415927;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1009, 1054, 1119, 1119, 1507], [1509, 1509, 1529, 1529, 1651], [1653, 1653, 1708, 1708, 4627]], "test": "untested"}
{"id": "Dd23z3", "name": "Slime Mold Terrain", "author": "fenix", "description": "Further experiments with slime molds. I wanted to know what they would look like rendered as a height map, and I think this shader answers the question: they look cool!\n*mouse to tilt camera*\n*space to reset*\n*left and right arrow keys to switch demos*", "tags": ["terrain", "antialiasing", "slime", "mold", "slimemold"], "likes": 24, "viewed": 462, "published": 3, "date": "1668497929", "time_retrieved": "2024-07-30T16:19:39.110116", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This is essentially a mash-up of two of my previous shaders. The rendering method is\n// based on the terrain renderer in:\n//\n//   Dynamic Editable Terrain   https://www.shadertoy.com/view/NlyBWm\n//\n// Whereas the particle sim and demo framework come from:\n//\n//   Slime Mode Variations      https://www.shadertoy.com/view/Ddj3RG\n// \n// There are two expensive rendering options at the top of the Common tab, ADAPTIVE_AA\n// and SHADOW. Turn those on for higher quality at the expense of FPS. My graphics card\n// can't really do either at \"normal\" resolutions...I'd love to hear if anyone is able\n// to get 30+ FPS with either of those turned on. The shadows are definitely worth\n// trying out, but on my card the AA is way too costly.\n//\n// One interesting thing about the adaptive AA...it interacts badly with the analytic\n// AA for the checkerboard floor pattern, so I had to turn it off. I had hoped it would\n// just skip over those pixels but I guess there is too much contrast. To see the effect,\n// hack the code in pixelInternal with the comment \"Don't use analytic AA and adaptive AA\n// at the same time...\" and then use the arrow keys to switch to one of the checkered demos.\n//\n// The slime mold sim is roughly the same as previous, with the addition of a few more per-\n// demo, sometimes per-color tunable parameters. The particle sim now runs within a circle,\n// instead of over the entire frame buffer, to try to at least allow for the possibility\n// of rotational symmetry.\n//\n// All the rest of the changes have been to the rendering. The mixing of the colors was\n// more difficult than I expected, because I wanted the colors to come through brightly,\n// but to also blend smoothly at their edges.\n//\n// Buffer A runs the slime mode simulation\n// Buffer B performs voronoi neighbor computation\n// Buffer C renders the particles into the terrain texture\n// Buffer D renders the final image once for adaptive AA, if enabled\n//\n// --------------------------------------------------------------------------------------------\n\nvec4 render(vec2 u)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse.xy / iResolution.xy, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 hitPos, normal;\n    return pixel(cameraPos, cameraFwd, rayDir, hitPos, normal);\n}\n\n// From FabriceNeyret2's easy adaptive sampling series\n// https://www.shadertoy.com/view/WlSBDt\n// https://www.shadertoy.com/view/Wt2fzV\n\n// --- my adaptive antialiasing: oversample only if neighborhood disagree\n\n#define hash12(p)  fract(sin( 99.*pass + float(p) * vec2(12.9898, 78.233) ) * 43758.5453)\nconst float pass = 1.;\n#define N 5\nconst float n = float(N);\n\nvec4 AArender( vec2 u )\n{ \n    vec2 un = u / iResolution.xy;\n    vec4  O =  textureLod(iChannel2, un, 0.), C;                // result of previous pass\n    \n    if ( length( textureLod(iChannel2, un, 3.).rgb - textureLod(iChannel2, un, 0.).rgb ) > 0.05 ) // neighborhood does not agree\n    { // neighborhood does not agree\n        C = vec4(0);\n        float w = 1., wt = 0.;           // weigth\n        for (int k=0; k<N*N; k++) // --- oversampling\n        {      \n          //vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n;     // subpixel : grid\n          //vec2 D = hash12(k) - .5;                            // subpixel : rand\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. + hash12(k)-.5 ) / n; // stratified\n            D *= 1.5; w = exp(-4.*dot(D,D)); wt += w;           // gaussian kernel filter\n            C += render(  u +  D ) * w;\n        }\n        C *= n*n / wt;                   // normalize by pass weigth (for kernel filter )\n        O *= n*n*(pass-1.);              // restore weigth\n        O += C;                          // add new contribs\n        O /= n*n *pass;                  // normalize by multipass weigth\n        O.a = pass;                      // 1: mark filtered aread\n    }\n    //else                                 // LOD#0 is ok\n    \n    return O;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n#if ADAPTIVE_AA\n    fragColor = AArender(fragCoord);\n#else\n    fragColor = render(fragCoord);\n#endif\n\n#if 0 // Debug terrain texture\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * 10.;\n#endif\n\n    fragColor.a = 1.;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes particle positions and velocities\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;    \n\n    fxParticle data = fxGetParticle(id);\n    \n    if (iFrame == 0 || state.x < 0. || id >= g_MaxParticles)\n    {\n        data.pos = data.vel = vec2(0);\n    }\n    else\n    {\n        // probe the density texture ahead of us, to the left and to the right\n        vec2 p = data.pos * .5 * vec2(iResolution.y / iResolution.x, 1) + .5;\n        vec4 fwdC = texture(iChannel2, p + data.vel * 2.);\n        int type = id % g_Demo.colors;\n        vec2 leftV = data.vel * rot2(g_Demo.turn[type]);\n        vec4 leftC = texture(iChannel2, p + leftV * 3.);\n        vec2 rightV = data.vel * rot2(-g_Demo.turn[type]);\n        vec4 rightC = texture(iChannel2, p + rightV * 2.);\n        \n        vec4 color = colorFromId(id);\n        color = color * 2. - 1.;\n        \n        data.vel *= rot2(g_Demo.spin[type]);\n                \n        float fwd = dot(color, fwdC);\n        float left = dot(color, leftC);\n        float right = dot(color, rightC);\n\n        // turn towards our color and away from other colors\n        if (fwd < left || fwd < right)\n        {\n            if (left < right)\n            {\n                data.vel = mix(data.vel, rightV, 0.3*right / (fwd + right));\n            }\n            else\n            {\n                data.vel = mix(data.vel, leftV, 0.3*left / (fwd + left));\n            }\n        }\n\n        // always move at g_ParticleSpeed\n        if (length(data.vel) > 1e-10)\n        {\n            data.vel = normalize(data.vel) * g_Demo.speed;\n        }\n        else\n        {\n            vec3 h = hash3(uvec3(iFragCoord.x*iFragCoord.y, iFragCoord.y, iFrame*iFragCoord.x));\n            data.vel = g_Demo.speed*normalize((vec2(h.x, h.y) - .5));\n        }\n\n        // integrate position\n        data.pos = data.pos + data.vel;\n\n        // boundary\n        float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n        vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n        if (distToScene < 0.001)\n        {\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n            float dp = dot(data.vel, distNormal);\n            if (dp < 0.)\n            {\n                data.vel = reflect(data.vel, distNormal);\n            }\n        }\n\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Turn these on only if you have a beefy graphics card\n#define ADAPTIVE_AA 0\n#define SHADOW 1\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nconst float PI = 3.141592653589793;\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nvoid fxCalcCamera(in float time, in vec2 mouse, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0,-.02,0);\n    vec3 delta = vec3(.2,sin(time*.1)*0.02 + 0.06 + mouse.y * 0.1,.2) * (.8 - mouse.y * .4);\n    delta.xz *= rot2(time * .05 + mouse.x * 4.);\n    cameraPos = cameraLookAt + delta;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2(p - b * h); // squared dist to segment\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n#if 1\n    return 1. - length(point);\n#else\n    float minDist = 1e30;\n    minDist = min(minDist, point.x + resolution.x / resolution.y);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n#endif\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS_VEL 0\n#define NUM_PARTICLE_DATA_TYPES 1\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xy;\n    particle.vel = particleData0.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nstruct Demo\n{\n    float used;      // what pct of the total particle buffer should be used\n    float size;      // how big should the particle be\n    float speed;     // how fast should the particles travel\n    vec4 turn;       // how fast can the particles turn to follow a trail\n    vec4 spin;       // how fast do the particles turn on average (signed)\n    int colors;      // how many colors does this demo use\n    vec4 colorR;     // color for red particles (specular in alpha)\n    vec4 colorG;     // color for green particles\n    vec4 colorB;     // color for blue particles\n    vec4 colorA;     // color for alpha particles \n    vec4 background; // background color\n    float checker;   // should the floor be checkered\n};\n\nconst int NUM_DEMOS = 12;\nconst Demo DEMOS[NUM_DEMOS] = Demo[](\n\n    Demo(.9,   .001,  .006, vec4(.6),          vec4(.09),             2, vec4(.6,.05,.1,.2), vec4(.8,.1,.1,.2),   vec4(0),             vec4(0),            vec4(.8,.6,.4,0),    0.), // sand dunes\n    Demo(.05,  .0005, .001, vec4(.9),          vec4(0.),              4, vec4(0,0,0,1),      vec4(.1),            vec4(.2),            vec4(.3),           vec4(1,.3,.1,0),     0.), // lava\n    Demo(.05,  .0002, .001, vec4(.3,.3,.3,.0), vec4(-.01,.01,.02,1.), 4, vec4(1),            vec4(.9),            vec4(.8),            vec4(.8,.4,.2,0),   vec4(.4,.4,1,1),     0.), // islands\n    Demo(.9,   .0003, .001, vec4(.7),          vec4(0.),              1, vec4(1,0,1,1),      vec4(1,0,1,0),       vec4(1,0,1,0),       vec4(1,0,1,0),      vec4(.4,1,.4,1),     1.), // toxic snakes\n    Demo(.2,   .0004, .003, vec4(.3),          vec4(0.),              1, vec4(.2,.2,.2,1),   vec4(.2),            vec4(.2),            vec4(.2),           vec4(.9,.9,.8,0),    0.), // ink\n    Demo(.01,  .001,  .002, vec4(.3,.1,0,0),   vec4(0.),              2, vec4(.5,.2,.2,0),   vec4(.1,.5,.3,0),    vec4(.8),            vec4(.7),           vec4(.6,.9,.6,0),    0.), // redwood\n    Demo(.05,  .0002, .002, vec4(.3),          vec4(.05),             1, vec4(0,0,1,1),      vec4(0,0,1,0),       vec4(0,0,1,0),       vec4(0,0,1,0),      vec4(1,0,0,0),       0.), // red blue\n    Demo(.05,  .002,  .002, vec4(1,.7,.5,1),   vec4(.1,-.1,0,0),      4, vec4(1,1,0,0),      vec4(1, .7, 0,0),    vec4(1,.5,0,0),      vec4(.2,.4,.2,0),   vec4(.2),            0.), // red yellow\n    Demo(.5,   .0004, .004, vec4(1.5),         vec4(-.03),            2, vec4(0,0,1,1),      vec4(1,0,0,1),       vec4(1,0,0,0),       vec4(0,0,1,0),      vec4(1),             1.), // red blue\n    Demo(.1,   .0002, .002, vec4(1),           vec4(0,0,1,0),         3, vec4(.1,.5,.1,.3),  vec4(.2,.6,.7,1),    vec4(.4),            vec4(.4),           vec4(.5,.4,.1,0),    0.), // rock garden\n    Demo(.6,   .0001, .002, vec4(1),           vec4(0),               4, vec4(.22,.4,.4,0),  vec4(.58,.48,.32,0), vec4(.85,.85,.82,0), vec4(.2,.22,.24,0), vec4(.85,.77,.67,0), 0.), // pollock\n    Demo(.01,  .001,  .001, vec4(.3),          vec4(0),               1, vec4(.5,1.4,0,1),   vec4(0),             vec4(0),             vec4(0),            vec4(0),             0.)  // glow 'n the dark worms\n);\n\nDemo g_Demo;\nint g_MaxParticles = 10000; \n\nvoid initGlobals(vec3 res, vec4 state)\n{\n    Demo demo = DEMOS[int(state.w) % NUM_DEMOS];\n    Demo nextDemo = DEMOS[int(state.w + 1.) % NUM_DEMOS];\n    \n    float used = fract(state.w) > .9 ? min(demo.used, nextDemo.used) : demo.used;\n    g_MaxParticles = int(res.x * res.y * used) / NUM_PARTICLE_DATA_TYPES;\n    \n    float transition = smoothstep(.9, 1., fract(state.w));\n    g_Demo.colors = demo.colors;\n    g_Demo.size = mix(demo.size, nextDemo.size, transition)*.02;\n    g_Demo.speed = mix(demo.speed, nextDemo.speed, transition);\n    g_Demo.turn = mix(demo.turn, nextDemo.turn, transition);\n    g_Demo.spin = mix(demo.spin, nextDemo.spin, transition);\n    g_Demo.colorR = mix(demo.colorR, nextDemo.colorR, transition);\n    g_Demo.colorG = mix(demo.colorG, nextDemo.colorG, transition);\n    g_Demo.colorB = mix(demo.colorB, nextDemo.colorB, transition);\n    g_Demo.colorA = mix(demo.colorA, nextDemo.colorA, transition);\n    g_Demo.background = mix(demo.background, nextDemo.background, transition);\n    g_Demo.checker = mix(demo.checker, nextDemo.checker, transition);\n}\n\nvec4 colorFromId(int id)\n{\n    int index = id % g_Demo.colors;\n    \n    vec4 result = vec4(0);\n    result[index] = 1.;\n    \n    return result;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\nconst float MAX_Y = 0.003;\n\nfloat scene(sampler2D sampler, vec3 res, vec3 p)\n{\n    vec4 colors = min(texture(sampler, p.xz * vec2(1, res.x / res.y) + .5) * .012, vec4(MAX_Y));\n    float h = max(max(max(colors.x, colors.y), colors.z), colors.a);\n    float height = p.y - h;\n  \n    float b = sdCylinder(p, vec3(0,0,.25));\n    return max(b, height);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 grad( sampler2D sampler, vec3 res, in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*scene(sampler, res, pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*scene(sampler, res, pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*scene(sampler, res, pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*scene(sampler, res, pos + e.xxx*eps ) );\n}\n\nfloat g_MaxT = 0.4;\nconst float SDF_EPSILON = 0.00005;\nvec3 rayMarch(sampler2D sampler, vec3 res, vec3 pos, vec3 dir, out float t)\n{\n    t = 0.;\n    \n    if (pos.y > MAX_Y) // skip immediately down to the max Y so we don't do unnecessary texture fetches\n    {\n        if (dir.y > 0.) { t = g_MaxT; return vec3(1e6); }\n        t = (MAX_Y - pos.y) / dir.y;\n        pos += dir * t;\n    }\n    \n    float g = 1., s = .5;\n    for (int i = 0; i < 100; ++i)\n    {\n        float d = scene(sampler, res, pos);\n        \n        if (abs(d) < SDF_EPSILON || t > g_MaxT)\n        {\n            break;\n        }\n        \n        if (g != sign(d))\n        {\n            g = -g;\n            //s *= .5;\n        }\n        \n        t += d * s;\n        pos += dir * d * s;\n    }\n \n    return pos;\n}\n\n// From iq's  Filtered checker (triangle, 3D)\n// https://www.shadertoy.com/view/llffWs\n\n// --- analytically triangle-filtered checkerboard ---\nvec3 pri( in vec3 x )\n{\n    // see https://www.shadertoy.com/view/MtffWs\n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri( in vec3 p, in vec3 ddx, in vec3 ddy )\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvec4 pixelInternal(sampler2D sampler, vec3 res, vec3 cameraPos, vec3 cameraFwd, vec3 rayDir, out vec3 hitPos, out vec3 normal)\n{\n    g_MaxT = .10 + length(cameraPos.xz);\n    \n    float t;\n    hitPos = rayMarch(sampler, res, cameraPos, rayDir, t);\n\n    normal = grad(sampler, res, hitPos);\n\n    // Compute color\n    vec4 background = g_Demo.background;\n    float checker = 0.;\n    if (g_Demo.checker > 0.)\n    {\n#if ADAPTIVE_AA // Don't use analytic AA and adaptive AA at the same time...they don't get along\n        vec2 m = mod(hitPos.xz, .02);\n\t\tchecker = float((m.x < .01) ^^ (m.y < .01));\n#else\n\t\tvec3 uvw = hitPos.xzy * 100.;\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3 ddx_uvw = dFdx( uvw ); \n        vec3 ddy_uvw = dFdy( uvw ); \n        \n\t\t// shading\t\t\n        checker = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n#endif\n    }\n\n    background = 1.5*mix(g_Demo.background, g_Demo.background * checker, g_Demo.checker);\n    vec4 colors = textureLod(sampler, (hitPos.xz * vec2(1, res.x / res.y) + .5), 3.);\n\n    // Pretty much want the max, but we want to blend if the next-biggest color(s) are close\n    float cMax = max(max(max(colors.r, colors.g), colors.b), colors.a);\n    vec4 rdcd = max(vec4(0), colors - cMax + .01); // reduce all weights by the max with small offset\n    vec4 color = (rdcd.r * g_Demo.colorR + // weighted sum of reduced weights\n                  rdcd.g * g_Demo.colorG +\n                  rdcd.b * g_Demo.colorB +\n                  rdcd.a * g_Demo.colorA)\n        / (rdcd.r + rdcd.g + rdcd.b + rdcd.a);\n    \n    color = mix(background, color, smoothstep(0., .02, cMax));\n                         \n    // Apply light and shadow\n    const vec3 LIGHT_DIR = normalize(vec3(1, .2, 1));\n    const float AMBIENT = 0.3;\n\n#if SHADOW\n    float shadowT = g_MaxT;    \n    vec3 offsetPos = hitPos + normal * SDF_EPSILON * 2.;\n    rayMarch(sampler, res, offsetPos, LIGHT_DIR, shadowT);\n    \n    if (shadowT < g_MaxT)\n    {\n        color = color * AMBIENT;\n    }\n    else\n#endif // SHADOW\n    {\n        float dp = max(0., dot(normal, LIGHT_DIR));\n        color = color * (dp * (1. - AMBIENT) + AMBIENT);\n        \n        vec3 reflection = reflect(LIGHT_DIR, normal);\n        dp = dot(cameraFwd, reflection);\n        \n        color.rgb += color.a * pow(abs(dp), 15.0) * vec3(0.5);\n    }\n    \n    // Fade at distance\n    if (t >= g_MaxT*.75)\n    {\n        vec4 sky = g_Demo.background * (.5 - 2. * rayDir.y);\n        color = mix(color, sky, smoothstep(g_MaxT*.75, g_MaxT, t));\n    }\n    \n    return vec4(color.xyz, t);\n}\n\n#define pixel(A, B, C, D, E) pixelInternal(iChannel0, iResolution, A, B, C, D, E)", "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Computes the nearest particles to each texel for buffer C\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord)\n{\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nconst float FRAMES_PER_DEMO = 500.;\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iResolution.x * iResolution.y != abs(state.x) || iFrame == 0 || keyDown(KEY_SPACE))\n        {\n            state = vec4(-iResolution.x * iResolution.y, .5, .5, 0);\n        }\n        else\n        {\n            state.x = abs(state.x);\n\n            state.w += 1. / FRAMES_PER_DEMO;\n            \n            if (keyClick(KEY_LEFT))\n            {\n                state.w = trunc(state.w - 1.);\n            }\n            if (keyClick(KEY_RIGHT))\n            {\n                state.w = trunc(state.w + 1.);\n            }\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    if (length((fragCoord - .5*iResolution.xy) / iResolution.y) > 1.)\n    {\n        fragColor = vec4(-1);\n        return;\n    }\n    \n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    \n    if (iFrame > 0)\n    {\n        //in this vector the distance to these particles will be stored \n        vec4 dis = vec4(1e6);\n\n        for(int x=-2; x<=2; x++){\n            for(int y=-2; y<=2; y++){\n                ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n                for(int j=0; j<4; j++){\n                    int id = old[j];\n                    float dis2 = distance2Particle(id, screen2world(fragCoord));\n                    insertion_sort( new, dis, id, dis2 );\n                }\n            }\n        }\n\n        int searchIterations = 3;\n        if (iFrame < 5)\n        {\n            searchIterations = 10;\n        }\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n\n            int p = int(h*float(g_MaxParticles));\n            insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n        }\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// This is the texture that the particles are rendered into, and that becomes the height\n// map for raymarching.\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(in fxParticle p, int id, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = fxLinePointDist2(p.pos, p.pos - 1.5 * p.vel, fragCoord);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, g_MaxParticles);\n\n    vec4 color = colorFromId(id) *.003;\n    fragColor += color * max(0.0, g_Demo.size - dist) / g_Demo.size;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n    \n    fragColor = vec4(0);\n  \tvec2 p = (2.*fragCoord - iResolution.xy) / iResolution.xy;\n        \n    // diffuse colors\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        vec4 n = texelFetch(iChannel2, ivec2(fragCoord) + ivec2(x, y), 0);\n        fragColor += n / (1.09 + 100.*dot(vec2(x, y), vec2(x, y))); // fall off with distance but also fade\n    }\n\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    // draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        int id = ids[i];\n        if (id < 0 || id >= g_MaxParticles) continue;\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, id, p, fragColor);\n    }\n    \n    fragColor = min(fragColor, max(vec4(MAX_Y * .8 / .012), vec4(MAX_Y * .8 / .012) + (fragColor - vec4(MAX_Y * .8 / .012)) * .7));\n\n    // reset\n    if (iFrame == 0 || state.x < 0.)\n    {\n        fragColor = vec4(0);\n    }\n}", "buffer_c_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Pre-render pass for adaptive AA, needed to compute the color gradient of each pixel.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n#if ADAPTIVE_AA\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse.xy / iResolution.xy, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 hitPos, normal;\n    fragColor = pixel(cameraPos, cameraFwd, rayDir, hitPos, normal);\n#endif // ADAPTIVE_AA\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd23z3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2249, 2249, 2270, 2270, 2616], [2983, 2983, 3008, 3008, 4278], [4280, 4280, 4334, 4334, 4660]], "test": "untested"}
{"id": "msXXzH", "name": "Heart Exercise", "author": "yli110", "description": "Reference mathematical method by Inigo Quilez.\nHello everyone! this is my first fragment shader, I am still learning, please give me more advice.", "tags": ["heart"], "likes": 0, "viewed": 88, "published": 3, "date": "1668497396", "time_retrieved": "2024-07-30T16:19:40.021679", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st -= 0.5;\n    st.x *= iResolution.x/iResolution.y;\n    st *= 1.2;\n    //st += 0.1*vec2(cos(u_time),sin(u_time));\n    /*\n    mat3 rotate = mat3(cos(iTime),0.,sin(iTime),\n                        0.,1.,0.,\n                       -sin(iTime),0.,cos(iTime));\n    \n    */\n    \n    //https://www.youtube.com/watch?v=BFld4EBO2RE&list=RDCMUCdmAhiG8HQDlz8uyekw4ENw&in\n    float r = 1.+0.15*pow(.5+.5*sin(6.28*iTime+st.y/25.0),4.);\n    vec3 xyz = vec3(st.x,st.y,sqrt(r*r-st.x*st.x-st.y*st.y));\n    xyz.z = xyz.z*(2.-xyz.y/15.);\n    xyz.y = 1.2*xyz.y-abs(xyz.x)*sqrt((20.*abs(xyz.x)/15.));\n\n    \n    vec3 color = vec3(0.);\n    \n    //Ray light\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(xyz.x,xyz.y,xyz.z));\n\n    //Sphere\n    vec3 SpCenter = vec3(0.,0.,8.);\n    \n\n    float map = dot(SpCenter-ro,rd);\n    vec3 p = ro + map*rd;\n\n    float d = length(SpCenter-ro-p);\n    if(d < r)\n    {\n        //intersection\n        float line = sqrt(r*r-d*d);\n        //float t1 = line + map;\n        //float t2 = line - map;\n        color = vec3(line/r*0.8,0.,0.);\n    } \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1194]], "test": "untested"}
{"id": "dsXXzH", "name": "WobblyTeeth", "author": "Del", "description": "just a wobble pattern", "tags": ["wobble", "sin"], "likes": 2, "viewed": 153, "published": 3, "date": "1668497000", "time_retrieved": "2024-07-30T16:19:40.940223", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime*0.1)*6.28;\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    p.y *= 4.0;\n  \tp.y *= 2.0 * sin(p.x * 15.0 + t)+ 0.5 * sin(p.x * 25.0 + t*4.0 );\n    p.y = pow(abs(p.y),12.0);\n    float v = clamp(p.y , 0.0, 1.0);\n    fragColor = vec4(v*0.37,v*0.75,v*0.4,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 364]], "test": "untested"}
{"id": "dsXXRH", "name": "Birthday of the Dead", "author": "xenn", "description": "flaming skull face", "tags": ["fluid", "cfd", "fluiddynamics"], "likes": 8, "viewed": 647, "published": 3, "date": "1668494505", "time_retrieved": "2024-07-30T16:19:42.042277", "image_code": "// just jamming the way I do. All credit to the actual coders, all credit is due\n\n#define HEIGHT 10.50+(10.*sin(iTime/3.))\n#define BRIGHTNESS 3.\n\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n   \n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n    \n     vec4 frogColor = texture(iChannel3, uv);\n\n    vec3 normal = bump2Normal(uv, iChannel2, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3(abs(sin(iTime/20.)), -abs(cos(iTime/40.)), abs(sin(iTime/40.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 01.99) {\n        frogColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        frogColor*=texture(iChannel3, uv);\n    } else {\n        frogColor = vec4(normalRGB, 1.0);\n    }  \n    \n/*    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n    \tfrogColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n    }\n    \n  */  \n    \n    vec4 final = frogColor;\n    \n    vec4 ace = vec4(ACESFilm(vec3(0)), 1.0);;\n\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n//    vec2 uv = fragCoord.xy/iResolution.xy;\n\n\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n      vec3 color = vec3(texture(iChannel0, uv - 0.50 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv + 01.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.50  * d).r,\n                      texture(iChannel1, uv - .0 * d).g,\n                      texture(iChannel1, uv - 01.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv -0.50  * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - 01.0  * d).b);\n                      \n                       vec3 col3 = vec3(texture(iChannel3, uv - 0.50 * d).r,\n                      texture(iChannel3, uv - 0.0 * d).g,\n                      texture(iChannel3, uv - 1.0 * d).b);\n                      \n                      vec3 blend = (max(color,col));\n                      vec3 bland = (max(col,color));\n               //       blend *= bland;\n               //       col2 = min(col,col3)*col2;\n               //       col = mix(col,col3,color);\n              //       col3 = min(col,color)*col3;\n                 color *= mix(col,color,col)*color;\n\n  //    color = ((max(color,col),col3)*(color));\n //     color = (mix(color,col2,col2)*(color));\n    float noise = .9 + randomFloat()*.15;\n  \t//fragColor = vec4(ACESFilm(frogColor));\n    fragColor = mix(vec4(ACESFilm((col+(mix(bland,blend,0.5)))*noise), 1.0),frogColor,(col,1.0))/2.;\n//    fragColor = vec4(ace(final))*noise );\n //   fragColor = frogColor;\n //fragColor =(vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0));\n fragColor += mix((vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0)),frogColor,(color,.50))/2.;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  col = clamp(col, 0., 1.);\n  col2 = clamp(col2, 0., 1.);\n  col3 = clamp(col3, 0., 1.);\n  vec4 blend = min((mix(col,col2,0.075)),col );\n // fragColor=min(blend,col3);\n  blend = clamp(blend, 0., 1.);\n  \n  fragColor=mix(col,col2, col3);\n//fragColor = col2;\n//fragColor=blend;\n//  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .0001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 15.95;\nconst float iBlobEdgeSmoothing        = .1;\nconst float iBlob1Radius              = 1.5;\nconst float iBlob1PowFactor           = 69.;\nconst float iBlob1ColorPulseSpeed     = .25242;\nconst float iBlob2Radius              = 1.5;\nconst float iBlob2PowFactor           =69.;\nconst float iBlob2ColorPulseSpeed     = -.01834;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       =  0.5;\nconst float iFeedbackMouseShiftFactor = .01;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * (iBlob1ColorPulseSpeed / 1.5), 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * (iBlob2ColorPulseSpeed / -1.5) + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n    vec3 prevColor3 = repeatedTexture(iChannel1, uv - stShift).rgb;\n    prevColor3 *= iFeedbackFadeRate;\n    \n    prevColor = mix(prevColor,prevColor2,prevColor3);\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n         (1. * abs(cos(iTime / 3.2)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          (iBlob1PowFactor)) * iBlob1Color;\n        radius =\n         (1. * abs(sin(iTime / 3.3)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n         (iBlob2PowFactor)) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.003;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel0, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_c_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_d_code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*6.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb2(hsv), 0.1), hsv.y*0.075);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 185, 185, 264], [266, 266, 289, 289, 429], [431, 499, 556, 665, 3661]], "test": "untested"}
{"id": "DdsXzr", "name": "Procedural Eroded Mountains 2.0", "author": "Hatchling", "description": "Using a long-range Texture SDF algorithm, you have much more control over the result (such as neighbor search distance) without impacting performance.\nThe exact distance to pixel algorithm also seems to help a lot with noise and aliasing.", "tags": ["2d", "sdf", "distance", "field", "signed"], "likes": 13, "viewed": 557, "published": 3, "date": "1668485978", "time_retrieved": "2024-07-30T16:19:43.170260", "image_code": "// Controls:\n// ______________________________\n//\n// Mouse Drag - Move Camera\n\n// May take 5-20 seconds to compile.\n// This is mainly due to recursion,\n// but this lets the shader run fast!\n// Too bad these compilations cannot be cached.\n\n// Changes:\n// - Added \"fuzzing\" to raycast algorithm so that\n//   undersampled edges are blurred instead of stepped,\n//   creating a pseudo-DoF effect instead.\n// - Added detail albedo map.\n\n// Known issues:\n// - Artifacts may be visible on mobile devices.\n//   I tried it with my phone and saw excessive\n//   dithering, this could happen to you.\n//   To fix, uncomment this line.\n// #define NO_DITHER\n\nbounds worldBounds() \n{\n    bounds b;\n    b.mini = vec3\n    (\n        0,\n        0,\n        0\n    );\n    \n    b.maxi = vec3\n    (\n        iChannelResolution[0].x,\n        600,\n        iChannelResolution[0].y\n    );\n    return b;\n}\n\nvec3 boundsToWorld(vec3 boundsPoint)\n{\n    bounds b = worldBounds();\n    return mix\n    (\n        b.mini,\n        b.maxi,\n        boundsPoint\n    );\n}\n\nvec3 worldToBounds(vec3 worldPoint)\n{\n    bounds b = worldBounds();\n    return invMix\n    (\n        b.mini,\n        b.maxi,\n        worldPoint\n    );\n}\n\nvec3 projectBoundsPoint(vec3 p, bool zeroEdge)\n{\n    if(zeroEdge && clamp(p,0.0,1.0) != p) \n    {\n        p.y = 0.0;\n        return p;\n    }\n    \n    vec4 t = texture(iChannel0, p.xz);\n    p.y = t.b / t.a;\n    return p;\n}\n\nvec3 projectWorldPoint(vec3 p, bool zeroEdge)\n{\n    p = worldToBounds(p);\n    p = projectBoundsPoint(p, zeroEdge);\n    p = boundsToWorld(p);\n    return p;\n}\n\nbool isWorldPointUnderTerrain(vec3 p)\n{\n    vec3 proj = projectWorldPoint(p, true);\n    return proj.y > p.y;\n}\n\nvoid worldPointToNormalCurvature(vec3 p, out vec3 n, out vec2 c)\n{    \n    p = worldToBounds(p);\n    vec4 t = texture(iChannel1, p.xz);\n    \n    n.xz = t.xy;\n    c = t.zw;\n    n.y = sqrt(1.0 - lengthSqr(n.xz));\n\n    /*const float offset = 16.0;\n    \n    vec3 posC = p;\n    vec3 posR = p + vec3(offset, 0.0,    0.0);\n    vec3 posL = p - vec3(offset, 0.0,    0.0);\n    vec3 posT = p + vec3(   0.0, 0.0, offset);\n    vec3 posB = p - vec3(   0.0, 0.0, offset);\n    \n    posR = projectWorldPoint(posR, false);\n    posL = projectWorldPoint(posL, false);\n    posT = projectWorldPoint(posT, false);\n    posB = projectWorldPoint(posB, false);\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    n = -normalize(cross(dx, dy));\n    \n    float curveX = dot(posC + posC - posR - posL, n);\n    float curveY = dot(posC + posC - posT - posB, n);\n    \n    c = vec2(curveX, curveY) / vec2(distance(posR, posL), distance(posT, posB));\n    \n    /*n = normalize(vec3(posL.y - posR.y, 1.0, posB.y - posT.y));\n    c = vec2\n    (\n        posL.y + posR.y - 2.0 * posC.y, \n        posB.y + posT.y - 2.0 * posC.y \n    ) * 0.5;*/\n}\n\nbool raycast(vec3 camPos, vec3 camDir, uint rngState, vec2 fragCoord, out vec3 pos)\n{\n    bounds b = worldBounds();   \n    pos = vec3(0);\n    \n    vec3 near, far;\n    if(!rayIntersectBounds(b, camPos, camDir, near, far))\n    {\n        return false;\n    }\n    \n    pos = near;\n    float minD = 0.0, maxD = 1.0;\n    bool hit = false;\n    const float increment = 0.005;\n    \n    #ifdef NO_DITHER\n    const float start = 0.0;\n    #else\n    // Randomize ray starting point to fuzz undersampled edges.\n    float noise = sampleBlueNoise(iChannel2, fragCoord, rngState).x;\n    float start = increment * noise;\n    #endif\n    \n    for(float i = start;; i += increment)\n    {\n        float j = i;\n        if(j > 1.0) j = 1.0;\n        j = i*i;\n        \n    \tpos = mix(near, far, j);\n        \n        maxD = j;\n        \n        if(isWorldPointUnderTerrain(pos))\n        {\n            hit = true;\n            break;\n        }\n        \n        minD = j;\n        \n        if(i > 1.0) \n        {\n            break;\n        }\n    }\n    \n    if(!hit) return false;\n\n    maxD = (minD + maxD) * 0.5;\n    float stepSize = (maxD - minD) * 0.5;\n\n    for(int i = 0; i < 5; i++, stepSize *= 0.5)\n    {\n    \tpos = mix(near, far, maxD);\n        if(!isWorldPointUnderTerrain(pos))\n        {\n            minD = maxD;\n            maxD += stepSize;\n        }\n        else\n        {\n            maxD -= stepSize;\n        }\n    }\n    \n    return true;\n}\n\nvec4 skybox(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    gradient *= gradient;\n    gradient *= gradient;\n   \n    gradient = 1.-gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient = 1.-gradient;\n    \n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    return vec4(sqrt(color), 1.0);\n}\n\nvec3 envLighting(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    gradient = 1.-gradient;\n    gradient *= gradient * gradient;\n    gradient = 1.-gradient;\n    \n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 5.0;\n    \n    return sqrt(color);\n}\n\nvec4 shade(bool hit, vec3 hitPoint, vec3 camPos, vec3 camRay)\n{\n    if(!hit) return vec4(0);\n    \n    vec3 normal;\n    vec2 curvature;\n    worldPointToNormalCurvature(hitPoint, normal, curvature);\n    \n    \n    vec2 posCurve2 = max(vec2(0), curvature);\n    vec2 negCurve2 = -min(vec2(0), curvature);\n    \n    float posCurve = posCurve2.x + posCurve2.y;\n    posCurve = posCurve / (0.025 + posCurve);\n    float negCurve = negCurve2.x + negCurve2.y;\n    negCurve = negCurve / (0.075 + negCurve);\n    float curve = (curvature.x + curvature.y);\n    curve = curve / (0.075 + abs(curve));\n    \n    //posCurve = negCurve = curve = 0.;\n    \n    //hitPoint /= 10.;\n    //hitPoint -= floor(hitPoint);\n    \n    vec3 reflDir = reflect(camRay, normal); \n    \n    Indirect ind;\n    {\n        ind.diffuse = envLighting(normal);\n        ind.specular = skybox(reflDir).rgb;\n        \n        vec3 ambientDir = vec3(0, 1, 0);\n        {\n            float ambient = dot(normal, ambientDir) * 0.5 + 0.5;\n            ambient *= ambient;\n            ambient *= ambient;\n            //ambient *= ambient;\n            ambient *= curve * 0.5 + 0.5;\n            ind.diffuse *= ambient; \n        }\n        //return vec4(ind.diffuse, 1.0);\n        {\n            float ambient = dot(normal, ambientDir) * 0.5 + 0.5;\n            ambient *= ambient;\n            ambient *= ambient;\n            //ambient *= ambient;\n            ambient *= curve * 0.5 + 0.5;\n            ind.specular *= ambient; \n        }\n        //return vec4(ind.specular, 1.0);\n    }\n    \n    \n    Light light;\n    light.dir = normalize(vec3(0, 3, 5));\n    light.color = vec3(2.0, 1.5, 1.0);\n    \n    MaterialMetallic mat;\n    {\n        mat.albedo  = vec3(1.);\n\n        float slopeFactor;\n        float heightFactor;\n        {\n            heightFactor = hitPoint.y / worldBounds().maxi.y;\n\n            heightFactor = smoothstep(0., 1., heightFactor);        \n            heightFactor = smoothstep(0., 1., heightFactor);\n\n            slopeFactor = abs(normal.y);\n            slopeFactor *= slopeFactor;\n            slopeFactor *= slopeFactor;\n            slopeFactor *= slopeFactor;\n            //slopeFactor *= slopeFactor;\n            slopeFactor = 1.-slopeFactor;\n            slopeFactor *= slopeFactor;\n            slopeFactor *= slopeFactor;\n            //slopeFactor *= slopeFactor;\n            slopeFactor = 1.-slopeFactor;\n            //slopeFactor = smoothstep(0., 1., slopeFactor);\n            //slopeFactor = smoothstep(0., 1., slopeFactor);\n            //slopeFactor = smoothstep(0., 1., slopeFactor);\n\n            vec3 flatLow = vec3(0.1, 0.4, 0.05);\n            vec3 flatHigh = vec3(0.7, 0.7, 0.5);\n\n            vec3 slopeLow = vec3(0.4, 0.7, 0.2);\n            vec3 slopeHigh = vec3(0.3, 0.2, 0.05);\n\n            vec3 flatColor = mix(flatLow, flatHigh, heightFactor);\n            vec3 slopeColor = mix(slopeLow, slopeHigh, heightFactor);\n\n            mat.albedo = mix(slopeColor, flatColor, slopeFactor);\n        }\n        \n        // Add texture.\n        {\n            vec2 texUV = (hitPoint.xz * 8.0) / iChannelResolution[3].xy;\n            \n            mat.albedo *= texture(iChannel3, texUV).rgb;\n            mat.albedo /= texture(iChannel3, texUV, 16.).rgb;\n        }\n\n        float crestFactor = slopeFactor;\n        // Highlight cracks.\n        {\n            crestFactor *= crestFactor;\n            crestFactor *= crestFactor;\n            crestFactor = 1.-crestFactor;\n            crestFactor = crestFactor * 0.6 + 0.4;\n            float crests = posCurve;\n            crests = 1.-crests;\n            crests = lerp(crests, crests*crests, 0.5);\n            crests = 1.-crests;\n            crestFactor *= crests;\n            mat.albedo = mix(mat.albedo, (mat.albedo*1.0+vec3(0.75))*vec3(0.7,0.65,0.3), crestFactor); \n        }\n\n        // Add rivers.\n        float rivers;\n        {\n            rivers = max(0.,negCurve - posCurve);\n\n            rivers = pow(rivers, pow(2., mix(0.5, -0.7, slopeFactor) + mix(-0.7, 0.7, heightFactor)));   \n\n            //rivers = pow(rivers, heightFactor + 1.0);   \n            //rivers = pow(rivers, heightFactor*3.+0.5);         \n\n            rivers = smoothstep(0., 1., rivers);\n            rivers = smoothstep(0., 1., rivers);\n\n            //rivers = 1.-rivers;\n            //rivers *= rivers;\n            //rivers = 1.-rivers;\n\n            mat.albedo = mix(mat.albedo, vec3(0.1,0.2,0.5), rivers); \n        }\n        \n        \n\n        //mat.albedo *= mat.albedo * 2.0;\n        //mat.albedo = vec3(1.);\n        \n        mat.smoothness = 0.0;\n        mat.smoothness = mix(mat.smoothness, 1., 0.75 * crestFactor);//length(color)*length(color)*0.2;\n        mat.smoothness = mix(mat.smoothness, 1., 1.0 * rivers);\n        \n        mat.metallic = crestFactor;\n        mat.metallic *= mat.metallic;\n    }\n    \n    //MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect\n    vec3 color = lighting(mat, normal, -camRay, light, ind);\n    \n    float fogScale = 1.0 / 1200.0;\n    float fogDist = lengthSqr((hitPoint - camPos) * fogScale);\n    \n    color.rgb = mix(skybox(camRay).rgb, color.rgb, pow(vec3(0.5), fogDist * vec3(0.1,0.4,2.))); \n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n\n    vec3 pivotPos   = boundsToWorld(vec3(0.5, 0.25, 0.5));\n    vec3 camPos     = boundsToWorld(vec3(0.5, 1, 0.0));\n    vec3 camOffset  = camPos - pivotPos;\n    \n    quaternion pan  = FromAngleAxis(vec3(0, iTime * 0.125, 0));\n    camOffset       = mul(pan, camOffset);\n    camPos          = pivotPos + camOffset;\n    if(iMouse.xy != vec2(0)) camPos = boundsToWorld(vec3(iMouse.xyy / iResolution.xyy));\n    camPos          = projectWorldPoint(camPos, false) + vec3(0.0, 50.0, 0.0);\n    \n    //vec3 lookDir    = -camOffset;    \n    //quaternion pan  = FromAngleAxis(vec3(0, iTime * 0.125, 0));\n    //quaternion tilt = FromToRotation(vec3(0,0,1), lookDir);\n    \n    //vec3 camRay     = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.yy, 1));\n    //camOffset       = mul(pan, camOffset);\n    //camRay          = mul(mul(pan, tilt), camRay);\n    \n    vec3 normal; vec2 curvature;\n    worldPointToNormalCurvature(camPos, normal, curvature);\n    vec3 lookFwd;\n    vec3 lookUp;\n    vec3 lookRight;\n    \n    vec3 lookAtPoint = camPos + normalize(pivotPos - camPos) * 250.0;\n    lookAtPoint          = projectWorldPoint(lookAtPoint, false) + vec3(0.0, 10.0, 0.0);\n    \n    lookFwd = normalize(lookAtPoint - camPos);\n    lookUp = vec3(0,1,0);\n    /*lookRight = safeNormalize(cross(lookUp, lookFwd));\n    lookUp = normal;\n    lookFwd = safeNormalize(cross(lookRight, lookUp)) + lookFwd * 5.0;\n    lookUp = vec3(0,1,0);*/\n    \n    \n    quaternion look = LookRotation(lookFwd, lookUp);\n    vec3 camRay     = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.yy, 1));\n    \n    camRay          = mul(look, camRay);\n    \n    fragColor = skybox(camRay);\n    \n    vec3 hitPoint;\n    bool hit = raycast(camPos, camRay, rngState, fragCoord, hitPoint);\n    vec4 foreground = shade(hit, hitPoint, camPos, camRay);\n    \n    blend(foreground, fragColor);\n    \n    // Vignette\n    {\n        half2 diff = abs(fragCoord / iResolution.xy - vec2(0.5));\n        half2 maxDiff = vec2(0.5);\n        vec4 _Vignette = vec4(1.0, 0.8, 2.0, 1.0); \n        \n        half maxDistanceToCenter = pow( pow(maxDiff.x, _Vignette.z) + pow(maxDiff.y, _Vignette.z), 1.0/_Vignette.z);\n        \n        half distanceToCenter = pow( pow(diff.x, _Vignette.z) + pow(diff.y, _Vignette.z), 1.0/_Vignette.z) / maxDistanceToCenter;\n        half vignette = saturate(distanceToCenter);\n        vignette = pow(vignette, _Vignette.x);\n        vignette = 1.0 - vignette;\n        vignette *= _Vignette.w;\n        vignette /= 1.0 + vignette;\n        vignette /= _Vignette.w / (1.0 + _Vignette.w);\n        vignette = smoothstep(1.0,0.0,vignette);\n        vignette = lerp(0.0, vignette, _Vignette.y);\n        fragColor.rgb = lerp(fragColor.rgb * vec3(2.0, 1.0, 0.5), vec3(0), pow(vec3(vignette), vec3(0.75, 2.0, 5.0)));\n        \n    }\n    \n    fragColor.rgb = fragColor.rgb / sqrt(1.0+fragColor.rgb*fragColor.rgb);\n    fragColor.rgb = linearToGamma(fragColor.rgb);\n    fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\n// Constants ----------------------------------\n\nconst float Pi = 3.14159265358979;\nconst float InvPi = 1.0 / 3.14159265358979;\n\n// HLSL support -------------------------------\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define half  float\n#define half2 vec2\n#define half3 vec3\n#define half4 vec4\n\n#define fixed  float\n#define fixed2 vec2\n#define fixed3 vec3\n#define fixed4 vec4\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n#define lerp mix\n\n#define decl_saturate(type)            \\\ntype saturate(type x)                  \\\n{                                      \\\n    return clamp(x, type(0), type(1)); \\\n} \n\ndecl_saturate(float)\ndecl_saturate(vec2)\ndecl_saturate(vec3)\ndecl_saturate(vec4)\n\n// Boolean -------------------------------\n\nbool  isinf2(float v) { return isinf(v); } \nbvec2 isinf2(vec2 v)\n{\n    return bvec2\n    (\n        isinf(v.x),\n        isinf(v.y)\n    );\n}\nbvec3 isinf2(vec3 v)\n{\n    return bvec3\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z)\n    );\n}\nbvec4 isinf2(vec4 v)\n{\n    return bvec4\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z),\n        isinf(v.w)\n    );\n}\n\nbool  isnan2(float v) { return isnan(v); } \nbvec2 isnan2(vec2 v)\n{\n    return bvec2\n    (\n        isnan(v.x),\n        isnan(v.y)\n    );\n}\nbvec3 isnan2(vec3 v)\n{\n    return bvec3\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z)\n    );\n}\nbvec4 isnan2(vec4 v)\n{\n    return bvec4\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z),\n        isnan(v.w)\n    );\n}\n\nbool bnot(bool b) { return !b; }\nbvec2 bnot(bvec2 b) \n{ \n    return bvec2(!b.x, !b.y); \n}\nbvec3 bnot(bvec3 b) \n{ \n    return bvec3(!b.x, !b.y, !b.z); \n}\nbvec4 bnot(bvec4 b) \n{ \n    return bvec4(!b.x, !b.y, !b.z, !b.w); \n}\n\nbool band(bool a, bool b) { return a && b; }\nbvec2 band(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x && b.x,\n        a.y && b.y\n    ); \n}\nbvec3 band(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z\n    ); \n}\nbvec4 band(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z,\n        a.w && b.w\n    ); \n}\n\nbool bor(bool a, bool b) { return a || b; }\nbvec2 bor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x || b.x,\n        a.y || b.y\n    ); \n}\nbvec3 bor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z\n    ); \n}\nbvec4 bor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z,\n        a.w || b.w\n    ); \n}\n\nbool bxor(bool a, bool b) { return a != b; }\nbvec2 bxor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x != b.x,\n        a.y != b.y\n    ); \n}\nbvec3 bxor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z\n    ); \n}\nbvec4 bxor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z,\n        a.w != b.w\n    ); \n}\n\n#define decl_isfinite(retType, type) \\\nretType isfinite(type v)             \\\n{                                    \\\n    return band                      \\\n    (                                \\\n        bnot(isinf2(v)),             \\\n        bnot(isnan2(v))              \\\n    );                               \\\n} \ndecl_isfinite(bool, float)\ndecl_isfinite(bvec2, vec2)\ndecl_isfinite(bvec3, vec3)\ndecl_isfinite(bvec4, vec4)\n\nfloat select(bool s, float a, float b)\n{\n    return s ? a : b;\n}\n\nvec2 select(bvec2 s, vec2 a, vec2 b)\n{\n    return vec2\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y\n    );  \n}\n\nvec3 select(bvec3 s, vec3 a, vec3 b)\n{\n    return vec3\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z\n    );  \n}\n\nvec4 select(bvec4 s, vec4 a, vec4 b)\n{\n    return vec4\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z,\n        s.w ? a.w : b.w\n    );  \n}\n\n// Vector math -------------------\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) \\\nretType lengthSqr(type a)             \\\n{                                     \\\n    return dot2(a,a);                 \\\n}                                     \n\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) \\\nretType distSqr(type a, type b)     \\\n{                                   \\\n    type diff = a-b;                \\\n    return lengthSqr(diff);         \\\n}                                   \n\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// Borrowed from UnityEngine\n#define decl_safeNormalize(type)                 \\\ntype safeNormalize(type inVec)                   \\\n{                                                \\\n    float dp3 = max(0.001f, dot2(inVec, inVec)); \\\n    return inVec / sqrt(dp3);                    \\\n}\ndecl_safeNormalize(vec2)\ndecl_safeNormalize(vec3)\ndecl_safeNormalize(vec4)\n\n// Misc. math --------------------\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type)              \\\nretType floorToInt(type a)                          \\\n{                                                   \\\n    return retType(floor(a) + sign(a) * type(0.5)); \\\n}                                                   \n\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n\n#define decl_invMix(type) \\\ntype invMix(type a, type b, type t) \\\n{                                   \\\n    type result = (t-a)/(b-a);      \\\n    return select(isfinite(result), result, type(0.5)); \\\n}\n\ndecl_invMix(float)\ndecl_invMix(vec2)\ndecl_invMix(vec3)\ndecl_invMix(vec4)\n\n#define invLerp invMix\n\nhalf Pow5 (half x)\n{\n    return x*x * x*x * x;\n}\n\nhalf2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}\n\n// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\n// Color -------------------------------\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\nstruct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nquaternion LookRotation(float3 forward, float3 up)\n{\n    quaternion q;\n    forward = safeNormalize(forward);\n    q = FromToRotation(vec3(0,0,1), forward);\n    up = up - dot(forward, up) * forward;\n    vec3 upFrom = mul(q, vec3(0,1,0));\n    q = mul(FromToRotation(upFrom, up), q);\n    return q;\n}\n\n\n\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n// PBR Lighting ------------------------------\n// Borrowed from UnityEngine\nstruct MaterialMetallic\n{\n    fixed3 albedo;      // base (diffuse or specular) color\n    half metallic;      // 0=non-metal, 1=metal\n    half smoothness;    // 0=rough, 1=smooth\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specColor;\n    float oneMinusReflectivity;\n    float smoothness;\n};\n\nstruct Light\n{\n    half3 color;\n    half3 dir;\n};\n\nstruct Indirect\n{\n    half3 diffuse;\n    half3 specular;\n};\n\nconst float4 dielectricSpec = float4(0.04, 0.04, 0.04, 1.0 - 0.04);\n\nhalf OneMinusReflectivityFromMetallic(half metallic)\n{\n    half oneMinusDielectricSpec = dielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nhalf3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (dielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}\n\nMaterial toMaterial(MaterialMetallic i)\n{\n    Material o;\n    \n    o.albedo = i.albedo;\n    o.smoothness = i.smoothness;\n    \n    half oneMinusReflectivity;\n    half3 specColor;\n    o.albedo = DiffuseAndSpecularFromMetallic (o.albedo, i.metallic, o.specColor, o.oneMinusReflectivity);\n    \n    return o;\n}\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1.0 - smoothness);\n}\n\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\nhalf DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    half viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return InvPi * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nhalf3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\n\nhalf3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}\n\n\nhalf3 brdf (half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = safeNormalize(float3(light.dir) + viewDir);\n\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl / 3.1415927;\n\n    // Specular term\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    \n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n\n    float specularTerm = V*D; // Torrance-Sparrow model, Fresnel is applied later\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0.0, specularTerm * nl);\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n    surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    //specularTerm *= (specColor != vec3(0)) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1.0-oneMinusReflectivity));\n    half3 color =   albedo * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, vec3(grazingTerm), nv)\n                    ;\n\n    return half3(color);\n}\n\n/*half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi*/\nvec3 lighting(MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect)\n{\n    Material m = toMaterial(mat);\n    \n    return brdf(m.albedo, m.specColor, m.oneMinusReflectivity, m.smoothness,\n    normal, viewDir, light, indirect);\n    \n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Linq;\n\t\t\t\t\t\npublic class Program\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tstatic Vector2 GetTestCoord(int index)\n\t{\n\t\tVector2 v = default(Vector2);\n\t\t\n\t\t// abs(x) > abs(y)?\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tv.X = 0.25f;\n\t\t\tv.Y = 0.125f;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tv.X = 0.125f;\n\t\t\tv.Y = 0.25f;\n\t\t}\n\t\t\n\t\t// x < 0?\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tv.X = -v.X;\n\t\t}\n\t\t\n\t\t// y < 0?\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tv.Y = -v.Y;\n\t\t}\n\t\t\n\t\treturn -v;\n\t}\n\t\n\tstatic string AsString(Vector2 v)\n\t{\n\t\treturn string.Format\n\t\t(\n\t\t\t\"ivec2({0}{1}, {2}{3})\", \n\t\t\t v.X < 0 ? '-' : (v.X > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.X), \n\t\t\t v.Y < 0 ? '-' : (v.Y > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.Y)\n\t     );\n\t}\n\t\n\tstatic string AsString(Vector2[] v)\n\t{\n\t\tstring s = \"\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t\t\n\t\t\t\tif(i % 4 == 0)\n\t\t\t\t\ts = s + '\\n';\n\t\t\t}\n\t\t\ts = s + AsString(v[i]);//.ToString();\n\t\t}\n\t\t\n\t\ts += \",\";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"________________\");\n\t\tConsole.WriteLine(\"                \");\n\t\t\n\t\tconst int radius = 4;\n\t\tconst int diameter = radius+radius+1;\n\t\tconst int capacity = diameter * diameter - 1;\n\t\tList<Vector2> pixelCoords = new List<Vector2>(capacity);\n\t\t\n\t\tconst float maxDistanceSqr = (radius + 0.5f) * (radius + 0.5f);\n\n\t\tfor(int x = -radius; x <= radius; x++)\n\t\t{\n\t\t\tfor(int y = -radius; y <= radius; y++)\n\t\t\t{\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tpixelCoords.Add(new Vector2(x,y));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tVector2 testCoord = GetTestCoord(i);\n\t\t\t\n\t\t\tvar pixelsSorted = pixelCoords.Where(p => Vector2.DistanceSquared(p, testCoord) <= maxDistanceSqr).OrderBy(p => Vector2.DistanceSquared(p, testCoord)).ToArray();\n\t\t\t\n\t\t\t//Console.WriteLine(pixelsSorted.Length);\n\t\t\tConsole.WriteLine(AsString(pixelsSorted));\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n*/", "cube_a_code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nfloat perlin(vec2 uv, inout uint rngState)\n{\n    uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    vec2 occ = vec2(0);\n\n    const float startScale = 1.0;\n    const float endScale = 0.005;\n    const int layerCount = 10;\n    float uvScale = pow(endScale / startScale, 1. / float(layerCount));\n    float alphaScale = 1. / uvScale;\n    uv *= startScale;\n    float a = 1.0 / startScale;\n    \n    for(int i = 0; i <layerCount; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= uvScale;\n        a *= alphaScale * 0.975;\n        uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    }\n    float v = occ.x / occ.y;\n    \n    return v;\n       \n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    \n    vec2 uvTile = uv * 2.0;\n    \n    if(uvTile.x > 1.0)\n        uvTile.x = 2.0-uvTile.x;\n    if(uvTile.y > 1.0)\n        uvTile.y = 2.0-uvTile.y;\n        \n    \n    uvTile = smoothstep(0., 1., uvTile);\n        \n    uint rngState = 3114u;\n    \n    vec2 uv00 = uv + vec2(0.5, 0.5);\n    uv00 -= floor(uv00);\n    vec2 uv01 = uv + vec2(0.0, 0.5);\n    uv01 -= floor(uv01);\n    vec2 uv10 = uv + vec2(0.5, 0.0);\n    uv10 -= floor(uv10);\n    vec2 uv11 = uv + vec2(0.0, 0.0);\n    uv11 -= floor(uv11);\n    \n    float height00 = perlin(uv00, rngState);\n    float height01 = perlin(uv01, rngState);\n    float height10 = perlin(uv10, rngState);\n    float height11 = perlin(uv11, rngState);\n    \n     //height00 = 0.;\n     //height01 = 0.;\n     //height10 = 0.;\n     //height11 = 0.;\n    \n    float height0X = mix(height00, height01, uvTile.x);\n    float height1X = mix(height10, height11, uvTile.x);\n    float v = mix(height0X, height1X, uvTile.y);\n    \n    //v = height01;\n    /*float height1 = perlin(uv, rngState);\n    \n    vec2 offsetUv = uv;\n    offsetUv += vec2(0.5, 0.5);\n    offsetUv -= floor(offsetUv);\n    \n    float height2 = perlin(offsetUv, rngState);\n    \n    vec2 weightXY = abs(uv - vec2(0.5)) * 2.0;\n    float weight2 = weightXY.x * weightXY.y  + 0.001;\n    float weight1 = (1.0-weightXY.x) * (1.0-weightXY.y) + 0.001;\n    \n    float weight = weight2 / (weight1 + weight2);\n    weight = smoothstep(0., 1., weight);\n    \n    float v = mix(height1, height2, weight);*/\n        \n\n    \n    // Increase contrast\n    // (though this will flatten the tops and bottoms).\n    v = v * 2.0 - 1.0;\n    v = min(1.0, max(-1.0, v * 2.25));\n    //v = tanh(v * 2.0);\n    v = v * 0.5 + 0.5;\n    \n    // Make peaks pointer and valleys flatter.\n    v *= v;\n    \n    v = 1. - v;\n    \n    \n    fragColor = vec4(v, v, v, 1.0); \n    \n    vec3 noise = getNoise(iFrame);\n    fragColor.x = v > noise.z ? 1. : 0.;\n}", "cube_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// HOLY ---- I DID IT\n// Broad crawl outward, then a recursive mipmap quadtree search.\n// FAST runtime, FAST compilation (comparitavely).\n// Should compile in about 7.2 seconds, 144+ FPS @ 900x506\n\n// Controls =================================\n// Frag + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Circle:           (Color) Gradient (Radius) Final distance.\n\nconst int mipCount = 8;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst int SampleCoordCount = 64*8;\nconst ivec2 SampleCoords[64*8] = ivec2[64*8]\n(\n    ivec2( 0, -1), ivec2(-1,  0), ivec2(-1, -1), ivec2(+1,  0), \n    ivec2( 0, +1), ivec2(+1, -1), ivec2(-1, +1), ivec2(+1, +1), \n    ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+1, -2), ivec2(+2,  0), ivec2(-2, +1), ivec2( 0, +2), \n    ivec2(+2, -1), ivec2(-1, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(-2, -2), ivec2( 0, -3), ivec2(+2, -2), ivec2(-3,  0), \n    ivec2(-1, -3), ivec2(-2, +2), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+2, +2), ivec2(-3, +1), ivec2(+3,  0), ivec2(+3, -1), \n    ivec2( 0, +3), ivec2(-2, -3), ivec2(-3, -2), ivec2(-1, +3), \n    ivec2(+3, +1), ivec2(+1, +3), ivec2(+2, -3), ivec2(+3, -2), \n    ivec2(-3, +2), ivec2(-2, +3), ivec2( 0, -4), ivec2(-1, -4), \n    ivec2(+3, +2), ivec2(-4,  0), ivec2(+2, +3), ivec2(+1, -4), \n    ivec2(-4, -1), ivec2(-3, -3), ivec2(-4, +1), ivec2(+4,  0), \n    ivec2(+3, -3), ivec2(-2, -4), ivec2(+4, -1), ivec2(-4, -2), \n    ivec2( 0, +4), ivec2(+2, -4), ivec2(+4, +1), ivec2(-3, +3), \n    ivec2(-1, +4), ivec2(+1, +4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2( 0, -1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, -1), \n    ivec2( 0, +1), ivec2(-1, -1), ivec2(+1, +1), ivec2(-1, +1), \n    ivec2( 0, -2), ivec2(+2,  0), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-1, -2), ivec2(-2,  0), ivec2(-2, -1), ivec2( 0, +2), \n    ivec2(+2, +1), ivec2(+1, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(+2, -2), ivec2(-2, -2), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(+3,  0), ivec2(+2, +2), ivec2(-1, -3), ivec2(+3, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(+3, +1), ivec2(-3, -1), \n    ivec2( 0, +3), ivec2(+2, -3), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+3, -2), ivec2(-1, +3), ivec2(-2, -3), ivec2(-3, -2), \n    ivec2(+3, +2), ivec2( 0, -4), ivec2(+2, +3), ivec2(-3, +2), \n    ivec2(+1, -4), ivec2(-2, +3), ivec2(+4,  0), ivec2(-1, -4), \n    ivec2(+4, -1), ivec2(+3, -3), ivec2(+4, +1), ivec2(-4,  0), \n    ivec2(-3, -3), ivec2(-4, -1), ivec2(+2, -4), ivec2( 0, +4), \n    ivec2(+4, -2), ivec2(-4, +1), ivec2(-2, -4), ivec2(+1, +4), \n    ivec2(+3, +3), ivec2(-1, +4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(-1,  0), ivec2(-1, +1), ivec2(+1,  0), \n    ivec2( 0, -1), ivec2(+1, +1), ivec2(-1, -1), ivec2(+1, -1), \n    ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+1, +2), ivec2(+2,  0), ivec2(-2, -1), ivec2( 0, -2), \n    ivec2(+2, +1), ivec2(-1, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(-2, +2), ivec2( 0, +3), ivec2(+2, +2), ivec2(-3,  0), \n    ivec2(-1, +3), ivec2(-2, -2), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+2, -2), ivec2(-3, -1), ivec2(+3,  0), ivec2(+3, +1), \n    ivec2( 0, -3), ivec2(-2, +3), ivec2(-3, +2), ivec2(-1, -3), \n    ivec2(+3, -1), ivec2(+1, -3), ivec2(+2, +3), ivec2(+3, +2), \n    ivec2(-3, -2), ivec2(-2, -3), ivec2( 0, +4), ivec2(-1, +4), \n    ivec2(+3, -2), ivec2(-4,  0), ivec2(+2, -3), ivec2(+1, +4), \n    ivec2(-4, +1), ivec2(-3, +3), ivec2(-4, -1), ivec2(+4,  0), \n    ivec2(+3, +3), ivec2(-2, +4), ivec2(+4, +1), ivec2(-4, +2), \n    ivec2( 0, -4), ivec2(+2, +4), ivec2(+4, -1), ivec2(-3, -3), \n    ivec2(-1, -4), ivec2(+1, -4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, +1), \n    ivec2( 0, -1), ivec2(-1, +1), ivec2(+1, -1), ivec2(-1, -1), \n    ivec2( 0, +2), ivec2(+2,  0), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-1, +2), ivec2(-2,  0), ivec2(-2, +1), ivec2( 0, -2), \n    ivec2(+2, -1), ivec2(+1, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(+2, +2), ivec2(-2, +2), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(+3,  0), ivec2(+2, -2), ivec2(-1, +3), ivec2(+3, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(+3, -1), ivec2(-3, +1), \n    ivec2( 0, -3), ivec2(+2, +3), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+3, +2), ivec2(-1, -3), ivec2(-2, +3), ivec2(-3, +2), \n    ivec2(+3, -2), ivec2( 0, +4), ivec2(+2, -3), ivec2(-3, -2), \n    ivec2(+1, +4), ivec2(-2, -3), ivec2(+4,  0), ivec2(-1, +4), \n    ivec2(+4, +1), ivec2(+3, +3), ivec2(+4, -1), ivec2(-4,  0), \n    ivec2(-3, +3), ivec2(-4, +1), ivec2(+2, +4), ivec2( 0, -4), \n    ivec2(+4, +2), ivec2(-4, -1), ivec2(-2, +4), ivec2(+1, -4), \n    ivec2(+3, -3), ivec2(-1, -4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2(-1,  0), ivec2( 0, -1), ivec2(-1, -1), ivec2( 0, +1), \n    ivec2(+1,  0), ivec2(-1, +1), ivec2(+1, -1), ivec2(+1, +1), \n    ivec2(-2,  0), ivec2( 0, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(-2, +1), ivec2( 0, +2), ivec2(-1, +2), ivec2(+1, -2), \n    ivec2(+2,  0), ivec2(+2, -1), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(-2, +2), ivec2(-3, -1), \n    ivec2( 0, -3), ivec2(+2, -2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +2), ivec2( 0, +3), ivec2(+1, -3), ivec2(-1, +3), \n    ivec2(+3,  0), ivec2(-3, -2), ivec2(-2, -3), ivec2(+1, +3), \n    ivec2(+3, -1), ivec2(+3, +1), ivec2(-3, +2), ivec2(-2, +3), \n    ivec2(+2, -3), ivec2(-4,  0), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(+2, +3), ivec2( 0, -4), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(-1, -4), ivec2(-3, -3), ivec2(+1, -4), ivec2( 0, +4), \n    ivec2(-3, +3), ivec2(-4, -2), ivec2(-1, +4), ivec2(-2, -4), \n    ivec2(+4,  0), ivec2(-4, +2), ivec2(+1, +4), ivec2(+3, -3), \n    ivec2(+4, -1), ivec2(+4, +1), ivec2(-2, +4), ivec2(+2, -4),\n\n    ivec2(+1,  0), ivec2( 0, -1), ivec2( 0, +1), ivec2(+1, -1), \n    ivec2(-1,  0), ivec2(+1, +1), ivec2(-1, -1), ivec2(-1, +1), \n    ivec2(+2,  0), ivec2( 0, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(+2, +1), ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, -2), \n    ivec2(+1, +2), ivec2(-2, -1), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+2, -2), ivec2(+2, +2), ivec2(+3,  0), ivec2( 0, -3), \n    ivec2(+3, -1), ivec2(-2, -2), ivec2(+1, -3), ivec2(+3, +1), \n    ivec2(-2, +2), ivec2(-1, -3), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(-3,  0), ivec2(+3, -2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -3), ivec2(-3, +1), ivec2(+3, +2), ivec2(+2, +3), \n    ivec2(-2, -3), ivec2(-3, -2), ivec2(+4,  0), ivec2(-2, +3), \n    ivec2(+4, -1), ivec2(-3, +2), ivec2( 0, -4), ivec2(+4, +1), \n    ivec2(+1, -4), ivec2(+3, -3), ivec2(-1, -4), ivec2( 0, +4), \n    ivec2(+3, +3), ivec2(+1, +4), ivec2(+4, -2), ivec2(-4,  0), \n    ivec2(+2, -4), ivec2(-1, +4), ivec2(+4, +2), ivec2(-4, -1), \n    ivec2(-3, -3), ivec2(-4, +1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(-1,  0), ivec2( 0, +1), ivec2(-1, +1), ivec2( 0, -1), \n    ivec2(+1,  0), ivec2(-1, -1), ivec2(+1, +1), ivec2(+1, -1), \n    ivec2(-2,  0), ivec2( 0, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(-2, -1), ivec2( 0, -2), ivec2(-1, -2), ivec2(+1, +2), \n    ivec2(+2,  0), ivec2(+2, +1), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(-2, -2), ivec2(-3, +1), \n    ivec2( 0, +3), ivec2(+2, +2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -2), ivec2( 0, -3), ivec2(+1, +3), ivec2(-1, -3), \n    ivec2(+3,  0), ivec2(-3, +2), ivec2(-2, +3), ivec2(+1, -3), \n    ivec2(+3, +1), ivec2(+3, -1), ivec2(-3, -2), ivec2(-2, -3), \n    ivec2(+2, +3), ivec2(-4,  0), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(+2, -3), ivec2( 0, +4), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(-1, +4), ivec2(-3, +3), ivec2(+1, +4), ivec2( 0, -4), \n    ivec2(-3, -3), ivec2(-4, +2), ivec2(-1, -4), ivec2(-2, +4), \n    ivec2(+4,  0), ivec2(-4, -2), ivec2(+1, -4), ivec2(+3, +3), \n    ivec2(+4, +1), ivec2(+4, -1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(+1,  0), ivec2( 0, +1), ivec2( 0, -1), ivec2(+1, +1), \n    ivec2(-1,  0), ivec2(+1, -1), ivec2(-1, +1), ivec2(-1, -1), \n    ivec2(+2,  0), ivec2( 0, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(+2, -1), ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, +2), \n    ivec2(+1, -2), ivec2(-2, +1), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+2, +2), ivec2(+2, -2), ivec2(+3,  0), ivec2( 0, +3), \n    ivec2(+3, +1), ivec2(-2, +2), ivec2(+1, +3), ivec2(+3, -1), \n    ivec2(-2, -2), ivec2(-1, +3), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(-3,  0), ivec2(+3, +2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +3), ivec2(-3, -1), ivec2(+3, -2), ivec2(+2, -3), \n    ivec2(-2, +3), ivec2(-3, +2), ivec2(+4,  0), ivec2(-2, -3), \n    ivec2(+4, +1), ivec2(-3, -2), ivec2( 0, +4), ivec2(+4, -1), \n    ivec2(+1, +4), ivec2(+3, +3), ivec2(-1, +4), ivec2( 0, -4), \n    ivec2(+3, -3), ivec2(+1, -4), ivec2(+4, +2), ivec2(-4,  0), \n    ivec2(+2, +4), ivec2(-1, -4), ivec2(+4, -2), ivec2(-4, +1), \n    ivec2(-3, +3), ivec2(-4, -1), ivec2(-2, +4), ivec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*64) : 0;\n    index |= testToSample.y < 0. ? (2*64) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*64) : 0;\n    return index;\n}\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec3 get_diff_minDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 pointToCenter = squareCenter - point;\n    vec2 minOffset = clamp(pointToCenter, vec2(-0.5), vec2(0.5));\n    vec2 pointToMin = pointToCenter - minOffset;\n    return vec3(pointToMin, lengthSqr(pointToMin));\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 diff_distSqr;\n    vec2 testCoord;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD testCoord\n#define DIFFDISTSQR diff_distSqr\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) vec3 name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03 )\n#define SSA04 {    \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA05     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);   \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA06    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA07    {\n#define SSA08        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA09        vec3 subsampleDiffDistSqr = get_diff_minDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA10        if(!(subsampleDiffDistSqr.z < a.DIFFDISTSQR.z))\n#define SSA11            continue;\n    \n#define SSA12        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA13            continue;\n\n                     // Recursive   \n#define SSR(name)    subsampleDiffDistSqr = name                     \n#define SSB00        (\n#define SSB01            GetNextArgs(a, subsamplingCoord),\n#define SSB02            testOccupied\n#define SSB03        );\n\n#define SSC00        if(a.DIFFDISTSQR.z > subsampleDiffDistSqr.z) a.DIFFDISTSQR = subsampleDiffDistSqr;\n#define SSC01     }\n    \n#define SSC02     return a.DIFFDISTSQR * vec3(0.5, 0.5, 0.25);\n#define SSC03 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 \n\n#define SSB_0 SSB00 SSB01 SSB02 SSB03\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSB_0\n#define SS_END              SSC_0\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 noise = getNoise(iFrame);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    // Set up fragment coordinates.\n    vec2 fragUV = fragCoord / iChannelResolution[0].xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize) \n                       + noise.xy * (1.0 / float(1 << RECURSION_DEPTH));\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    bool fragIsOccupied = isOccupied(fragUV); \n    \n    const float maxDist = 2.0;\n    vec3 diff_distSqr = vec3(maxDist, 0.0, maxDist*maxDist);\n\n    int iCoordOffset = GetSampleIndexOffset((vec2(fragTestIntCoord) + vec2(0.5) - fragTestCoord));\n    for(int iCoord = -1; iCoord < 64; iCoord++)\n    {\n        ivec2 samplingCoord = fragTestIntCoord;\n        if(iCoord >= 0)\n        {\n            samplingCoord += SampleCoords[iCoord + iCoordOffset];\n        }\n        \n        vec3 sampleDiffDistSqr = get_diff_minDistSqr(fragTestCoord, samplingCoord);\n        \n        // Need to add a bias for some reason.\n        if(sampleDiffDistSqr.z >= diff_distSqr.z + 1.5)\n            break;\n            \n        if(sampleDiffDistSqr.z >= diff_distSqr.z)\n            continue; \n            \n        if(!containsEdge(fragIsOccupied, samplingCoord, maxMip))\n            continue;\n            \n        SubSampleArgs a;\n        a.DIFFDISTSQR = diff_distSqr;\n        a.SAMPLECOORD = samplingCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = fragTestCoord;\n        IncreaseDepth(a);\n        diff_distSqr = SubSample\n        (\n            a,\n            fragIsOccupied\n        ); \n    }\n         \n    vec3 diff_dist = vec3(diff_distSqr.xy, sqrt(diff_distSqr.z)) / (fragIsOccupied ? -maxDist : maxDist);     \n         \n    diff_dist.xy = normalize(diff_dist.xy);\n    \n    diff_dist.z = diff_dist.z * 0.5 + 0.5;\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    //diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    //diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    \n         \n    fragColor = vec4(diff_dist, 1.0);\n    if(isnan(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    if(isinf(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    \n    // Check if the image size increased:\n    bool increased;\n    {\n        increased = texture(iChannel1, vec2(1)).a <= 0.0;\n    }\n    \n    // Accumulate samples over time.\n    if(iFrame > 1 && !increased)\n    {\n        vec2 uv = (fragCoord.xy) / iChannelResolution[1].xy;\n        vec4 oldColor = texture(iChannel1, uv);\n        fragColor += oldColor;\n    }\n}\n", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "bounds worldBounds() \n{\n    bounds b;\n    b.mini = vec3\n    (\n        0,\n        0,\n        0\n    );\n    \n    b.maxi = vec3\n    (\n        iChannelResolution[0].x,\n        600,\n        iChannelResolution[0].y\n    );\n    return b;\n}\n\nvec3 boundsToWorld(vec3 boundsPoint)\n{\n    bounds b = worldBounds();\n    return mix\n    (\n        b.mini,\n        b.maxi,\n        boundsPoint\n    );\n}\n\nvec3 worldToBounds(vec3 worldPoint)\n{\n    bounds b = worldBounds();\n    return invMix\n    (\n        b.mini,\n        b.maxi,\n        worldPoint\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvC = fragCoord.xy / iResolution.xy;\n\tvec2 uvR = (fragCoord.xy + vec2(1.25,0)) / iResolution.xy;\n\tvec2 uvT = (fragCoord.xy + vec2(0,1.25)) / iResolution.xy;\n\tvec2 uvL = (fragCoord.xy - vec2(1.25,0)) / iResolution.xy;\n\tvec2 uvB = (fragCoord.xy - vec2(0,1.25)) / iResolution.xy;\n    vec2 colC = texture(iChannel0, uvC).ba;\n    vec2 colR = texture(iChannel0, uvR).ba;\n    vec2 colT = texture(iChannel0, uvT).ba;\n    vec2 colL = texture(iChannel0, uvL).ba;\n    vec2 colB = texture(iChannel0, uvB).ba;\n    \n    colC.r *= 1. / colC.g;\n    colR.r *= 1. / colR.g;\n    colT.r *= 1. / colT.g;\n    colL.r *= 1. / colR.g;\n    colB.r *= 1. / colT.g;\n    \n\n    vec3 posC = vec3(uvC.x, colC.r, uvC.y);\n    vec3 posR = vec3(uvR.x, colR.r, uvR.y);\n    vec3 posL = vec3(uvL.x, colL.r, uvL.y);\n    vec3 posT = vec3(uvT.x, colT.r, uvT.y);\n    vec3 posB = vec3(uvT.x, colB.r, uvB.y);\n    \n    posC = boundsToWorld(posC);\n    posR = boundsToWorld(posR);\n    posL = boundsToWorld(posL);\n    posT = boundsToWorld(posT);\n    posB = boundsToWorld(posB);\n\n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    vec3 n = -normalize(cross(dx, dy));\n    \n    float curveX = dot(posC + posC - posR - posL, n);\n    float curveY = dot(posC + posC - posT - posB, n);\n    \n    vec2 c = vec2(curveX, curveY) / vec2(distance(posR, posL), distance(posT, posB));\n    \n    fragColor = vec4(n.xz, c);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdsXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[643, 643, 666, 666, 873], [875, 875, 913, 913, 1025], [1027, 1027, 1064, 1064, 1178], [1180, 1180, 1228, 1228, 1401], [1403, 1403, 1450, 1450, 1559], [1561, 1561, 1600, 1600, 1671], [1673, 1673, 1739, 1739, 2792], [2794, 2794, 2879, 2879, 4214], [4216, 4216, 4239, 4239, 5007], [5009, 5009, 5037, 5037, 5491], [5493, 5493, 5556, 5556, 10676], [10678, 10678, 10735, 10735, 13815]], "test": "untested"}
{"id": "ddsXRn", "name": "waterfall thing", "author": "janpitokiala", "description": "waterfall using scrolling displacement maps", "tags": ["idk"], "likes": 1, "viewed": 134, "published": 3, "date": "1668465010", "time_retrieved": "2024-07-30T16:19:44.032954", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(texture(iChannel0, uv+texture(iChannel1, uv).r).b,texture(iChannel0, uv+texture(iChannel1, uv).r).b,1.);\n    if(abs(uv.x-0.5)>0.2) {\n        col = texture(iChannel2, uv*5. + .2).rgb;\n    } else {\n        col = (col + texture(iChannel2, uv*5.+texture(iChannel1, uv).r).rgb)/2.;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float scrollLeft = .2*texture(iChannel0, .05*(uv+.209*iTime)).r;\n    uv.x = 1.-uv.x;\n    float scrollRight = .2*texture(iChannel0, .05*(uv+.2*iTime)).r;\n    fragColor = vec4(scrollLeft+scrollRight,.0,.0,.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 512]], "test": "untested"}
{"id": "cdXSR8", "name": "rainbow mandelbrot", "author": "janpitokiala", "description": "rainbow mandelbrot set", "tags": ["mandelbrot", "rainbow"], "likes": 0, "viewed": 125, "published": 3, "date": "1668464990", "time_retrieved": "2024-07-30T16:19:44.865727", "image_code": "vec2 square(vec2 num) {\n    num = vec2(num.x*num.x-num.y*num.y,2.*num.x*num.y);\n    return num;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = 5.*uv.x - 2.5;\n    uv.y = 3.*uv.y - 1.5;\n    vec2 z = vec2(0.,0.);\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = 0;i < 255; i = i + 1) {\n        z = square(z) + uv;\n        if (length(z) > 2.) {\n            float tint = float(i)/8.0;\n            col = tint*sin(iTime+vec3(0.,2.,4.));\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 97], [98, 98, 155, 205, 634]], "test": "untested"}
{"id": "DsfXRr", "name": "matrix transformation 3Blue1Brow", "author": "jonasfrey", "description": "i dont know why it is not working \nhttps://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/2D_affine_transformation_matrix.svg/250px-2D_affine_transformation_matrix.svg.png\nhttps://www.youtube.com/watch?v=kYB8IZa5AuE&ab_channel=3Blue1Brown\n", "tags": ["warp"], "likes": 1, "viewed": 287, "published": 3, "date": "1668463231", "time_retrieved": "2024-07-30T16:19:45.650628", "image_code": "\n//https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/2D_affine_transformation_matrix.svg/250px-2D_affine_transformation_matrix.svg.png\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_coo_nor = (fragCoord.xy-iResolution.xy*0.5) / iResolution.y;\n    vec2 o_mou_coo_nor = (iMouse.xy-iResolution.xy*0.5) / iResolution.y;\n    o_pix_coo_nor*= 6.0;\n    o_mou_coo_nor*= 6.0;\n    float n_tau = 6.2831;\n    float n_amp = 10.;\n    float n_th = 1.0;\n\n    vec2 o_linewidth = vec2(0.01, 0.02);\n    vec2 o_circle_width = vec2(0.1, 0.12);\n\n    //o_pix_coo_nor.x = sin(n_tau+o_pix_coo_nor.x)*n_amp*o_mou_coo_nor.x+n_amp*o_mou_coo_nor.x;\n    //o_pix_coo_nor.y = cos(n_tau+o_pix_coo_nor.y)*n_amp*o_mou_coo_nor.x+n_amp*o_mou_coo_nor.x;\n    \n   \n    vec2 o_ihat = vec2(1.0, 0.0);\n    vec2 o_jhat = vec2(0.0, 1.0);\n    \n    float n_dist_mouse_ihat = length(o_ihat-o_mou_coo_nor);\n    float n_dist_mouse_jhat = length(o_jhat-o_mou_coo_nor);\n    \n\n    vec2 o_ihat_target = vec2(1.0, -2.0);\n    vec2 o_ihat_target_delta = vec2(o_ihat_target.x-o_ihat.x, o_ihat_target.y-o_ihat.y);\n    o_ihat = vec2(\n       o_ihat.x + sin(iTime)*(o_ihat_target_delta.x/2.0)+(o_ihat_target_delta.x/2.0),\n       o_ihat.y + sin(iTime)*(o_ihat_target_delta.y/2.0)+(o_ihat_target_delta.y/2.0)\n    );\n    vec2 o_jhat_target = vec2(3.0, 0.0);\n    vec2 o_jhat_target_delta = vec2(o_jhat_target.x-o_jhat.x, o_jhat_target.y-o_jhat.y);\n    o_jhat = vec2(\n       o_jhat.x + sin(iTime)*(o_jhat_target_delta.x/2.0)+(o_jhat_target_delta.x/2.0),\n       o_jhat.y + sin(iTime)*(o_jhat_target_delta.y/2.0)+(o_jhat_target_delta.y/2.0)\n    );\n\n    \n    vec2 o_p = vec2(-1.0, 2.0);\n    float n_dist_o_p = length(o_pix_coo_nor-o_p);\n    \n    float n_dist_origin = length(o_pix_coo_nor);\n    float n_dist_ihat = length(o_ihat-o_pix_coo_nor);\n    float n_dist_jhat = length(o_jhat-o_pix_coo_nor);\n    \n    vec4 o_col_text = texture(iChannel0, o_pix_coo_nor*-1.);\n\n\n    \n    fragColor = o_col_text;\n    vec2 o_dist_nor = vec2(\n        mod(o_pix_coo_nor.x, n_th),\n        mod(o_pix_coo_nor.y, n_th)\n    )/n_th;\n    fragColor += smoothstep(o_linewidth.y,o_linewidth.x,o_dist_nor.x);\n    fragColor += smoothstep(o_linewidth.y,o_linewidth.x,o_dist_nor.y);\n    \n\n    \n    fragColor = mix(fragColor, vec4(1.0,0.0,0.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_origin));\n    fragColor = mix(fragColor, vec4(0.0,1.0,0.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_ihat));\n    fragColor = mix(fragColor, vec4(0.0,0.0,1.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_jhat));\n    fragColor = mix(fragColor, vec4(0.0,1.0,1.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_o_p));\n\n    //fragColor += vec4(0.0,0.0,smoothstep(0.1,0.12,n_dist_jhat), 1.0);\n    \n    \n    \n\n    o_pix_coo_nor = vec2(\n        o_ihat.x * o_pix_coo_nor.x + o_jhat.x * o_pix_coo_nor.y,\n        o_ihat.y * o_pix_coo_nor.x + o_jhat.y * o_pix_coo_nor.y\n    );\n    o_col_text = texture(iChannel0, o_pix_coo_nor*-1.);\n\n    fragColor = mix(fragColor, o_col_text, 0.5);\n\n    //fragColor += vec4(0.0,0.0,smoothstep(0.1,0.12,n_dist_jhat), 1.0);\n    n_dist_o_p = length(o_pix_coo_nor-o_p);\n    \n    n_dist_origin = length(o_pix_coo_nor);\n    n_dist_ihat = length(o_ihat-o_pix_coo_nor);\n    n_dist_jhat = length(o_jhat-o_pix_coo_nor);\n    \n\n\n    o_dist_nor = vec2(\n        mod(o_pix_coo_nor.x, n_th),\n        mod(o_pix_coo_nor.y, n_th)\n    )/n_th;\n    fragColor += smoothstep(o_linewidth.y,o_linewidth.x,o_dist_nor.x);\n    fragColor += smoothstep(o_linewidth.y,o_linewidth.x,o_dist_nor.y);\n    \n    n_dist_o_p = length(o_pix_coo_nor-o_p);\n\n    \n    fragColor = mix(fragColor, vec4(1.0,0.0,0.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_origin));\n    fragColor = mix(fragColor, vec4(0.0,1.0,0.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_ihat));\n    fragColor = mix(fragColor, vec4(0.0,0.0,1.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_jhat));\n    fragColor = mix(fragColor, vec4(0.0,1.0,1.0,1.0), smoothstep(o_circle_width.y,o_circle_width.x,n_dist_o_p));\n    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 143, 200, 200, 4075]], "test": "untested"}
{"id": "mdlXzn", "name": "Tie Dye Explosion Hypnosis", "author": "timmaffett", "description": "St Elmo's Fire pulsing and mouse responsive.\nThe explosion changes as it is dragged around (mouse down)...\nan automatic figure 8 path in lieu of mouse might be a great addition\n", "tags": ["mouse", "interactive", "iterated"], "likes": 4, "viewed": 182, "published": 3, "date": "1668457096", "time_retrieved": "2024-07-30T16:19:46.409107", "image_code": "const float PI = 3.14;\n\nfloat steps = 12.0;\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\n\nvec2 applyTransformation(vec2 pos,float iteration){\n\n    float angle = atan(pos.y,pos.x);\n    float initialDist = length(vec3(pos,1)) * (iteration+1.0);\n    float currentStep = mod(floor(initialDist * steps),steps);\n    vec2 outVec = vec2(1);\n    float sinDist = (sin(angle*(3.0 * currentStep) + iTime * sin(currentStep))*0.05 + 1.0);\n    \n    outVec.xy = pos.xy * sinDist;\n    \n    return outVec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec2 center = vec2(0.5,0.5) + ((iMouse.xy==vec2(0.)) ? vec2(.5,.5) : iMouse.xy/iResolution.xy)-vec2(0.5);\n   \n    vec2 offset = (uv - center) * 1.8;\n    offset.y *= iResolution.y/iResolution.x;\n\n    offset *= 4.5;\n    \n   //clamp keeps 1 & 2 'large' pattern explosions out   for(float i = 0.0; i < clamp((mod(fract(iTime)*abs(iMouse.x+1.)*1000.0,37.0)),3.0,37.0); i++){\n    for(float i = 0.0; i < (mod(fract(iTime)*abs(iMouse.x+1.)*1000.0,37.0)); i++){\n       offset = applyTransformation(offset,i/0.1);\n    }\n    \n    \n    float initialDist = length(offset);\n    float currentStep = mod(floor(initialDist * steps*fract(iTime)*10.),steps);\n    \n    \n    float clampedDist = step(fract(length(offset)*steps),0.5);\n    \n    \n    vec3 col = HSVtoRGB(vec3(currentStep/steps,1,1));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 73, 154, 268], [269, 269, 297, 346, 426], [429, 429, 480, 480, 828], [831, 831, 888, 938, 1826]], "test": "untested"}
{"id": "ddlSRn", "name": "malicious code in shadertoy", "author": "FabriceNeyret2", "description": "here it is pretty obvious.\nBut there exist competitions where the goal is to make a code apparently doing task A, and secretly doing task B.\nBoth tasks are annouced publically, but still it can be very tough to detect in codes ;-)", "tags": ["hack", "code", "malicious"], "likes": 18, "viewed": 484, "published": 3, "date": "1668448721", "time_retrieved": "2024-07-30T16:19:47.168078", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{                                                                                                                                                                   vec2 uv = mod(floor(fragCoord/10.),2.); fragColor = uv.xyxy;                                                                                                                                                                                                                 vec4 _\\\nfragColor = vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cslSRr", "name": "Audio-reactive scene 1st attempt", "author": "kishimisu", "description": "First attempt at raymarching scenes that react to audio input !", "tags": ["raymarching", "music", "beat", "light", "random", "visualizer", "song", "responsive", "reaction", "intensity"], "likes": 32, "viewed": 1145, "published": 3, "date": "1668442626", "time_retrieved": "2024-07-30T16:19:47.951982", "image_code": "/* @kishimisu - 2022\n   \n   First attempt at raymarching scenes\n   that react to audio input !\n   \n   I realized that it's really hard\n   to isolate the notes in order to \n   have different parts of the scene \n   react to different sounds without\n   manual fine-tuning. I'll try to \n   improve on it, any reference on \n   this subject is welcome !\n*/\n\n// Set to 1 if you have a really good PC\n#define HIGH_PERF 0  \n\n#if HIGH_PERF\n    #define iterations           50.\n    #define max_dist            500.\n// numbers of neighbor lights to check, very expensive so default to 0.\n    #define light_neighbors_check 1. \n#else\n    #define iterations           30.\n    #define max_dist            100.\n    #define light_neighbors_check 0.\n#endif\n\nfloat lightRep = 12.;    // lights spacing\nfloat attenuation = 20.; // light attenuation\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define rep(p,r) (mod(p+r/2.,r)-r/2.)\n#define rid(p,r) floor((p+r/2.)/r)\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 getLight(float d, vec3 color) {\n    return max(vec3(0.), color / (1. + pow(abs(d * attenuation), 1.3)) - .001*0.);\n}\n\nfloat getLevel(float x) {\n    return texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r;\n}\n\n// The next functions are borrowed from https://www.shadertoy.com/view/7lVBRw\n// because they seem to better retrieve the musical aspects from the FFT\nfloat getPitch(float freq, int octave){\n   return getLevel(pow(2.0, float(octave)) * freq / 12000.0);\n}\nfloat logX(float x, float a, float c){\n   return 1.0 / (exp(-a*(x-c)) + 1.0);\n}\nfloat logisticAmp(float amp){\n   float c = 1.0 - (0.25);\n   float a = 20.0 * (1.0 - iMouse.y / iResolution.y);  \n   a = 20.;   \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getAudioIntensityAt(float x) {\n    x = abs(fract(x));\n    float freq = pow(2., x*3.) * 261.;\n    return iChannelTime[0] <= 0. ? hash11(x) : logisticAmp(getPitch(freq, 1));\n}\n\nfloat map(vec3 p, inout vec3 col) {    \n    //p.z = abs(p.z);\n    p.y = abs(p.y) - 13. - getAudioIntensityAt(0.)*1.2;\n   \n    vec2 id = rid(p.xz, 2.);\n    p.y += sin( length(sin(id/5.23 - iTime) * cos(id/10.45 + iTime))  ) * 8.;\n    \n    vec3 fp = rep(p, lightRep);\n    fp.y = p.y;\n\n    const float r = light_neighbors_check;\n    for (float j = -r; j <= r; j++)\n    for (float i = -r; i <= r; i++) {\n        vec3 off = vec3(i, 0., j) * lightRep;        \n        vec3 nid = rid(p - off, lightRep);\n        float d = length( fp + off )-1.;\n        \n        // assign more red to lower frequencies, more green to middle and more blue to upper frequencies\n        vec3 c = hash33(nid);\n        vec3 light = vec3(getAudioIntensityAt(c.r*.33), getAudioIntensityAt(c.g*.33+.33), 4.*getAudioIntensityAt(c.b*.33+.67));\n        // make the intensity vary depending on a random frequency (always the same for each light)\n        light *= getAudioIntensityAt(c.r+c.b+c.g)+(c.r+c.b+c.g);\n        col += getLight(d, light);\n    }\n  \n    p.xz = rep(p.xz, 2.);\n    return length(p) - 1.;\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.; \n    ro = vec3(iTime*8. -6., 0., 0.);\n        \n    float t = -iTime*.15*0.;\n    vec3 f = normalize(vec3(cos(t),0,sin(t)));\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    \n    initRayOriginAndDirection(uv, ro, rd);\n    \n    float t = 0.;\n    \n    for (float i = 0.; i < iterations; i++) {\n        p = ro + t*rd;\n        //p.yz *= rot(-t*mix(-.01, .01, sin(iTime*.1)*.5+.5));\n        t += map(p, col);\n        if (t > max_dist) break;\n    }\n \n    col = pow(col, vec3(.45));\n    O = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30306, "src": "https://soundcloud.com/ghostcalledmisery/prisoners-dilemma", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1073, 1073, 1096, 1096, 1170], [1172, 1172, 1208, 1208, 1293], [1295, 1295, 1320, 1320, 1384], [1386, 1537, 1576, 1576, 1640], [1641, 1641, 1679, 1679, 1720], [1721, 1721, 1750, 1750, 1935], [1936, 1936, 1972, 1972, 2115], [2117, 2117, 2152, 2178, 3190], [3192, 3192, 3263, 3263, 3531], [3533, 3533, 3572, 3572, 3982]], "test": "untested"}
{"id": "ddXSRr", "name": "Procedural Erosion 2.0", "author": "Hatchling", "description": "Using a long-range Texture SDF algorithm, you have much more control over the result (such as neighbor search distance) without impacting performance.", "tags": ["2d", "sdf", "distance", "field", "signed"], "likes": 34, "viewed": 873, "published": 3, "date": "1668429075", "time_retrieved": "2024-07-30T16:19:48.918398", "image_code": "// Controls:\n// Mouse click - Clear and restart. (Useful for when you go fullscreen.)\n\n\nvec2 compress(vec2 vec)\n{\n    float mag = sqrt(dot(vec, vec));\n\n    float newMag = mag;\n\n    // Softly compress the range \n    // from 0 to +Inf\n    // to 0 to +1 \n    // instead of clipping values\n    // when contrast is used for visualization.\n    newMag = newMag / (0.5 + newMag);\n\n    vec *= newMag / (mag + 0.00001);\n    return vec;\n}\nfloat compress(float vec)\n{\n    float mag = abs(vec);\n\n    float newMag = mag;\n\n    // Softly compress the range \n    // from 0 to +Inf\n    // to 0 to +1 \n    // instead of clipping values\n    // when contrast is used for visualization.\n    newMag = newMag / (0.5 + newMag);\n\n    vec *= newMag / (mag + 0.00001);\n    return vec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvC = fragCoord.xy / iChannelResolution[0].xy;\n\tvec2 uvR = (fragCoord.xy + vec2(1,0)) / iChannelResolution[0].xy;\n\tvec2 uvT = (fragCoord.xy + vec2(0,1)) / iChannelResolution[0].xy;\n\tvec2 uvL = (fragCoord.xy - vec2(1,0)) / iChannelResolution[0].xy;\n\tvec2 uvB = (fragCoord.xy - vec2(0,1)) / iChannelResolution[0].xy;\n    vec2 colC = texture(iChannel0, uvC).zw;\n    vec2 colR = texture(iChannel0, uvR).zw;\n    vec2 colT = texture(iChannel0, uvT).zw;\n    vec2 colL = texture(iChannel0, uvL).zw;\n    vec2 colB = texture(iChannel0, uvB).zw;\n    \n    colC.r /= colC.g;\n    colR.r /= colR.g;\n    colT.r /= colT.g;\n    colL.r /= colR.g;\n    colB.r /= colT.g;\n    \n    \n    vec2 gradient = vec2(colL.r - colR.r, colB.r - colT.r);\n    vec2 curvature = vec2\n    (\n        colL.r + colR.r - 2.0 * colC.r, \n        colB.r + colT.r - 2.0 * colC.r \n    ) * 0.5;\n    \n    \n    // Enhance gradient+curvature contrast.\n    vec2 both = compress(gradient * 100.0 - curvature * 8000.0);\n    \n    \n    // Unmodified gradients:\n    // vec2 gradient = vec2(colC.r - colR.r, colC.r - colT.r);\n    \n    fragColor = vec4(both * 0.5 + 0.5, compress(colC.r), 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n   \n   // RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Linq;\n\t\t\t\t\t\npublic class Program\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tstatic Vector2 GetTestCoord(int index)\n\t{\n\t\tVector2 v = default(Vector2);\n\t\t\n\t\t// abs(x) > abs(y)?\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tv.X = 0.25f;\n\t\t\tv.Y = 0.125f;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tv.X = 0.125f;\n\t\t\tv.Y = 0.25f;\n\t\t}\n\t\t\n\t\t// x < 0?\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tv.X = -v.X;\n\t\t}\n\t\t\n\t\t// y < 0?\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tv.Y = -v.Y;\n\t\t}\n\t\t\n\t\treturn -v;\n\t}\n\t\n\tstatic string AsString(Vector2 v)\n\t{\n\t\treturn string.Format\n\t\t(\n\t\t\t\"ivec2({0}{1}, {2}{3})\", \n\t\t\t v.X < 0 ? '-' : (v.X > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.X), \n\t\t\t v.Y < 0 ? '-' : (v.Y > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.Y)\n\t     );\n\t}\n\t\n\tstatic string AsString(Vector2[] v)\n\t{\n\t\tstring s = \"\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t\t\n\t\t\t\tif(i % 4 == 0)\n\t\t\t\t\ts = s + '\\n';\n\t\t\t}\n\t\t\ts = s + AsString(v[i]);//.ToString();\n\t\t}\n\t\t\n\t\ts += \",\";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"________________\");\n\t\tConsole.WriteLine(\"                \");\n\t\t\n\t\tconst int radius = 4;\n\t\tconst int diameter = radius+radius+1;\n\t\tconst int capacity = diameter * diameter - 1;\n\t\tList<Vector2> pixelCoords = new List<Vector2>(capacity);\n\t\t\n\t\tconst float maxDistanceSqr = (radius + 0.5f) * (radius + 0.5f);\n\n\t\tfor(int x = -radius; x <= radius; x++)\n\t\t{\n\t\t\tfor(int y = -radius; y <= radius; y++)\n\t\t\t{\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tpixelCoords.Add(new Vector2(x,y));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tVector2 testCoord = GetTestCoord(i);\n\t\t\t\n\t\t\tvar pixelsSorted = pixelCoords.Where(p => Vector2.DistanceSquared(p, testCoord) <= maxDistanceSqr).OrderBy(p => Vector2.DistanceSquared(p, testCoord)).ToArray();\n\t\t\t\n\t\t\t//Console.WriteLine(pixelsSorted.Length);\n\t\t\tConsole.WriteLine(AsString(pixelsSorted));\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n*/", "cube_a_code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nfloat perlin(vec2 uv, inout uint rngState)\n{\n    uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    uv /= 1.0;\n    vec2 occ = vec2(0);\n    float a = 1.0;\n    for(int i = 0; i <8; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= 0.5;\n        a *= 1.7;\n        uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    }\n    float v = occ.x / occ.y;\n    \n    return v;\n       \n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    \n    vec2 uvTile = uv * 2.0;\n    \n    if(uvTile.x > 1.0)\n        uvTile.x = 2.0-uvTile.x;\n    if(uvTile.y > 1.0)\n        uvTile.y = 2.0-uvTile.y;\n        \n    \n    uvTile = smoothstep(0., 1., uvTile);\n        \n    uint rngState = 14114u;\n    \n    vec2 uv00 = uv + vec2(0.5, 0.5);\n    uv00 -= floor(uv00);\n    vec2 uv01 = uv + vec2(0.0, 0.5);\n    uv01 -= floor(uv01);\n    vec2 uv10 = uv + vec2(0.5, 0.0);\n    uv10 -= floor(uv10);\n    vec2 uv11 = uv + vec2(0.0, 0.0);\n    uv11 -= floor(uv11);\n    \n    float height00 = perlin(uv00, rngState);\n    float height01 = perlin(uv01, rngState);\n    float height10 = perlin(uv10, rngState);\n    float height11 = perlin(uv11, rngState);\n    \n     //height00 = 0.;\n     //height01 = 0.;\n     //height10 = 0.;\n     //height11 = 0.;\n    \n    float height0X = mix(height00, height01, uvTile.x);\n    float height1X = mix(height10, height11, uvTile.x);\n    float v = mix(height0X, height1X, uvTile.y);\n    \n    //v = height01;\n    /*float height1 = perlin(uv, rngState);\n    \n    vec2 offsetUv = uv;\n    offsetUv += vec2(0.5, 0.5);\n    offsetUv -= floor(offsetUv);\n    \n    float height2 = perlin(offsetUv, rngState);\n    \n    vec2 weightXY = abs(uv - vec2(0.5)) * 2.0;\n    float weight2 = weightXY.x * weightXY.y  + 0.001;\n    float weight1 = (1.0-weightXY.x) * (1.0-weightXY.y) + 0.001;\n    \n    float weight = weight2 / (weight1 + weight2);\n    weight = smoothstep(0., 1., weight);\n    \n    float v = mix(height1, height2, weight);*/\n        \n\n    \n    // Increase contrast\n    // (though this will flatten the tops and bottoms).\n    v = v * 2.0 - 1.0;\n    v = min(1.0, max(-1.0, v * 2.25));\n    v = v * 0.5 + 0.5;\n    \n    // Make peaks pointer and valleys flatter.\n    v *= v * v * v;\n    \n    v = 1. - v;\n    \n    \n    fragColor = vec4(v, v, v, 1.0); \n    \n    vec3 noise = getNoise(iFrame);\n    fragColor = v > noise.z ? vec4(1) : vec4(0);\n}", "cube_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// HOLY ---- I DID IT\n// Broad crawl outward, then a recursive mipmap quadtree search.\n// FAST runtime, FAST compilation (comparitavely).\n// Should compile in about 7.2 seconds, 144+ FPS @ 900x506\n\n// Controls =================================\n// Frag + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Circle:           (Color) Gradient (Radius) Final distance.\n\nconst int mipCount = 8;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst int SampleCoordCount = 64*8;\nconst ivec2 SampleCoords[64*8] = ivec2[64*8]\n(\n    ivec2( 0, -1), ivec2(-1,  0), ivec2(-1, -1), ivec2(+1,  0), \n    ivec2( 0, +1), ivec2(+1, -1), ivec2(-1, +1), ivec2(+1, +1), \n    ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+1, -2), ivec2(+2,  0), ivec2(-2, +1), ivec2( 0, +2), \n    ivec2(+2, -1), ivec2(-1, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(-2, -2), ivec2( 0, -3), ivec2(+2, -2), ivec2(-3,  0), \n    ivec2(-1, -3), ivec2(-2, +2), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+2, +2), ivec2(-3, +1), ivec2(+3,  0), ivec2(+3, -1), \n    ivec2( 0, +3), ivec2(-2, -3), ivec2(-3, -2), ivec2(-1, +3), \n    ivec2(+3, +1), ivec2(+1, +3), ivec2(+2, -3), ivec2(+3, -2), \n    ivec2(-3, +2), ivec2(-2, +3), ivec2( 0, -4), ivec2(-1, -4), \n    ivec2(+3, +2), ivec2(-4,  0), ivec2(+2, +3), ivec2(+1, -4), \n    ivec2(-4, -1), ivec2(-3, -3), ivec2(-4, +1), ivec2(+4,  0), \n    ivec2(+3, -3), ivec2(-2, -4), ivec2(+4, -1), ivec2(-4, -2), \n    ivec2( 0, +4), ivec2(+2, -4), ivec2(+4, +1), ivec2(-3, +3), \n    ivec2(-1, +4), ivec2(+1, +4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2( 0, -1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, -1), \n    ivec2( 0, +1), ivec2(-1, -1), ivec2(+1, +1), ivec2(-1, +1), \n    ivec2( 0, -2), ivec2(+2,  0), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-1, -2), ivec2(-2,  0), ivec2(-2, -1), ivec2( 0, +2), \n    ivec2(+2, +1), ivec2(+1, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(+2, -2), ivec2(-2, -2), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(+3,  0), ivec2(+2, +2), ivec2(-1, -3), ivec2(+3, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(+3, +1), ivec2(-3, -1), \n    ivec2( 0, +3), ivec2(+2, -3), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+3, -2), ivec2(-1, +3), ivec2(-2, -3), ivec2(-3, -2), \n    ivec2(+3, +2), ivec2( 0, -4), ivec2(+2, +3), ivec2(-3, +2), \n    ivec2(+1, -4), ivec2(-2, +3), ivec2(+4,  0), ivec2(-1, -4), \n    ivec2(+4, -1), ivec2(+3, -3), ivec2(+4, +1), ivec2(-4,  0), \n    ivec2(-3, -3), ivec2(-4, -1), ivec2(+2, -4), ivec2( 0, +4), \n    ivec2(+4, -2), ivec2(-4, +1), ivec2(-2, -4), ivec2(+1, +4), \n    ivec2(+3, +3), ivec2(-1, +4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(-1,  0), ivec2(-1, +1), ivec2(+1,  0), \n    ivec2( 0, -1), ivec2(+1, +1), ivec2(-1, -1), ivec2(+1, -1), \n    ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+1, +2), ivec2(+2,  0), ivec2(-2, -1), ivec2( 0, -2), \n    ivec2(+2, +1), ivec2(-1, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(-2, +2), ivec2( 0, +3), ivec2(+2, +2), ivec2(-3,  0), \n    ivec2(-1, +3), ivec2(-2, -2), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+2, -2), ivec2(-3, -1), ivec2(+3,  0), ivec2(+3, +1), \n    ivec2( 0, -3), ivec2(-2, +3), ivec2(-3, +2), ivec2(-1, -3), \n    ivec2(+3, -1), ivec2(+1, -3), ivec2(+2, +3), ivec2(+3, +2), \n    ivec2(-3, -2), ivec2(-2, -3), ivec2( 0, +4), ivec2(-1, +4), \n    ivec2(+3, -2), ivec2(-4,  0), ivec2(+2, -3), ivec2(+1, +4), \n    ivec2(-4, +1), ivec2(-3, +3), ivec2(-4, -1), ivec2(+4,  0), \n    ivec2(+3, +3), ivec2(-2, +4), ivec2(+4, +1), ivec2(-4, +2), \n    ivec2( 0, -4), ivec2(+2, +4), ivec2(+4, -1), ivec2(-3, -3), \n    ivec2(-1, -4), ivec2(+1, -4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, +1), \n    ivec2( 0, -1), ivec2(-1, +1), ivec2(+1, -1), ivec2(-1, -1), \n    ivec2( 0, +2), ivec2(+2,  0), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-1, +2), ivec2(-2,  0), ivec2(-2, +1), ivec2( 0, -2), \n    ivec2(+2, -1), ivec2(+1, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(+2, +2), ivec2(-2, +2), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(+3,  0), ivec2(+2, -2), ivec2(-1, +3), ivec2(+3, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(+3, -1), ivec2(-3, +1), \n    ivec2( 0, -3), ivec2(+2, +3), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+3, +2), ivec2(-1, -3), ivec2(-2, +3), ivec2(-3, +2), \n    ivec2(+3, -2), ivec2( 0, +4), ivec2(+2, -3), ivec2(-3, -2), \n    ivec2(+1, +4), ivec2(-2, -3), ivec2(+4,  0), ivec2(-1, +4), \n    ivec2(+4, +1), ivec2(+3, +3), ivec2(+4, -1), ivec2(-4,  0), \n    ivec2(-3, +3), ivec2(-4, +1), ivec2(+2, +4), ivec2( 0, -4), \n    ivec2(+4, +2), ivec2(-4, -1), ivec2(-2, +4), ivec2(+1, -4), \n    ivec2(+3, -3), ivec2(-1, -4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2(-1,  0), ivec2( 0, -1), ivec2(-1, -1), ivec2( 0, +1), \n    ivec2(+1,  0), ivec2(-1, +1), ivec2(+1, -1), ivec2(+1, +1), \n    ivec2(-2,  0), ivec2( 0, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(-2, +1), ivec2( 0, +2), ivec2(-1, +2), ivec2(+1, -2), \n    ivec2(+2,  0), ivec2(+2, -1), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(-2, +2), ivec2(-3, -1), \n    ivec2( 0, -3), ivec2(+2, -2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +2), ivec2( 0, +3), ivec2(+1, -3), ivec2(-1, +3), \n    ivec2(+3,  0), ivec2(-3, -2), ivec2(-2, -3), ivec2(+1, +3), \n    ivec2(+3, -1), ivec2(+3, +1), ivec2(-3, +2), ivec2(-2, +3), \n    ivec2(+2, -3), ivec2(-4,  0), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(+2, +3), ivec2( 0, -4), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(-1, -4), ivec2(-3, -3), ivec2(+1, -4), ivec2( 0, +4), \n    ivec2(-3, +3), ivec2(-4, -2), ivec2(-1, +4), ivec2(-2, -4), \n    ivec2(+4,  0), ivec2(-4, +2), ivec2(+1, +4), ivec2(+3, -3), \n    ivec2(+4, -1), ivec2(+4, +1), ivec2(-2, +4), ivec2(+2, -4),\n\n    ivec2(+1,  0), ivec2( 0, -1), ivec2( 0, +1), ivec2(+1, -1), \n    ivec2(-1,  0), ivec2(+1, +1), ivec2(-1, -1), ivec2(-1, +1), \n    ivec2(+2,  0), ivec2( 0, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(+2, +1), ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, -2), \n    ivec2(+1, +2), ivec2(-2, -1), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+2, -2), ivec2(+2, +2), ivec2(+3,  0), ivec2( 0, -3), \n    ivec2(+3, -1), ivec2(-2, -2), ivec2(+1, -3), ivec2(+3, +1), \n    ivec2(-2, +2), ivec2(-1, -3), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(-3,  0), ivec2(+3, -2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -3), ivec2(-3, +1), ivec2(+3, +2), ivec2(+2, +3), \n    ivec2(-2, -3), ivec2(-3, -2), ivec2(+4,  0), ivec2(-2, +3), \n    ivec2(+4, -1), ivec2(-3, +2), ivec2( 0, -4), ivec2(+4, +1), \n    ivec2(+1, -4), ivec2(+3, -3), ivec2(-1, -4), ivec2( 0, +4), \n    ivec2(+3, +3), ivec2(+1, +4), ivec2(+4, -2), ivec2(-4,  0), \n    ivec2(+2, -4), ivec2(-1, +4), ivec2(+4, +2), ivec2(-4, -1), \n    ivec2(-3, -3), ivec2(-4, +1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(-1,  0), ivec2( 0, +1), ivec2(-1, +1), ivec2( 0, -1), \n    ivec2(+1,  0), ivec2(-1, -1), ivec2(+1, +1), ivec2(+1, -1), \n    ivec2(-2,  0), ivec2( 0, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(-2, -1), ivec2( 0, -2), ivec2(-1, -2), ivec2(+1, +2), \n    ivec2(+2,  0), ivec2(+2, +1), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(-2, -2), ivec2(-3, +1), \n    ivec2( 0, +3), ivec2(+2, +2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -2), ivec2( 0, -3), ivec2(+1, +3), ivec2(-1, -3), \n    ivec2(+3,  0), ivec2(-3, +2), ivec2(-2, +3), ivec2(+1, -3), \n    ivec2(+3, +1), ivec2(+3, -1), ivec2(-3, -2), ivec2(-2, -3), \n    ivec2(+2, +3), ivec2(-4,  0), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(+2, -3), ivec2( 0, +4), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(-1, +4), ivec2(-3, +3), ivec2(+1, +4), ivec2( 0, -4), \n    ivec2(-3, -3), ivec2(-4, +2), ivec2(-1, -4), ivec2(-2, +4), \n    ivec2(+4,  0), ivec2(-4, -2), ivec2(+1, -4), ivec2(+3, +3), \n    ivec2(+4, +1), ivec2(+4, -1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(+1,  0), ivec2( 0, +1), ivec2( 0, -1), ivec2(+1, +1), \n    ivec2(-1,  0), ivec2(+1, -1), ivec2(-1, +1), ivec2(-1, -1), \n    ivec2(+2,  0), ivec2( 0, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(+2, -1), ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, +2), \n    ivec2(+1, -2), ivec2(-2, +1), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+2, +2), ivec2(+2, -2), ivec2(+3,  0), ivec2( 0, +3), \n    ivec2(+3, +1), ivec2(-2, +2), ivec2(+1, +3), ivec2(+3, -1), \n    ivec2(-2, -2), ivec2(-1, +3), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(-3,  0), ivec2(+3, +2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +3), ivec2(-3, -1), ivec2(+3, -2), ivec2(+2, -3), \n    ivec2(-2, +3), ivec2(-3, +2), ivec2(+4,  0), ivec2(-2, -3), \n    ivec2(+4, +1), ivec2(-3, -2), ivec2( 0, +4), ivec2(+4, -1), \n    ivec2(+1, +4), ivec2(+3, +3), ivec2(-1, +4), ivec2( 0, -4), \n    ivec2(+3, -3), ivec2(+1, -4), ivec2(+4, +2), ivec2(-4,  0), \n    ivec2(+2, +4), ivec2(-1, -4), ivec2(+4, -2), ivec2(-4, +1), \n    ivec2(-3, +3), ivec2(-4, -1), ivec2(-2, +4), ivec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*64) : 0;\n    index |= testToSample.y < 0. ? (2*64) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*64) : 0;\n    return index;\n}\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec3 get_diff_minDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 pointToCenter = squareCenter - point;\n    vec2 minOffset = clamp(pointToCenter, vec2(-0.5), vec2(0.5));\n    vec2 pointToMin = pointToCenter - minOffset;\n    return vec3(pointToMin, lengthSqr(pointToMin));\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 diff_distSqr;\n    vec2 testCoord;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD testCoord\n#define DIFFDISTSQR diff_distSqr\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) vec3 name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03 )\n#define SSA04 {    \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA05     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);   \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA06    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA07    {\n#define SSA08        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA09        vec3 subsampleDiffDistSqr = get_diff_minDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA10        if(!(subsampleDiffDistSqr.z < a.DIFFDISTSQR.z))\n#define SSA11            continue;\n    \n#define SSA12        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA13            continue;\n\n                     // Recursive   \n#define SSR(name)    subsampleDiffDistSqr = name                     \n#define SSB00        (\n#define SSB01            GetNextArgs(a, subsamplingCoord),\n#define SSB02            testOccupied\n#define SSB03        );\n\n#define SSC00        if(a.DIFFDISTSQR.z > subsampleDiffDistSqr.z) a.DIFFDISTSQR = subsampleDiffDistSqr;\n#define SSC01     }\n    \n#define SSC02     return a.DIFFDISTSQR * vec3(0.5, 0.5, 0.25);\n#define SSC03 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 \n\n#define SSB_0 SSB00 SSB01 SSB02 SSB03\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSB_0\n#define SS_END              SSC_0\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 noise = getNoise(iFrame);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    // Set up fragment coordinates.\n    vec2 fragUV = fragCoord / iChannelResolution[0].xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize) \n                       + noise.xy * (1.0 / float(1 << RECURSION_DEPTH));\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    bool fragIsOccupied = isOccupied(fragUV); \n    \n    const float maxDist = 2.0;\n    vec3 diff_distSqr = vec3(maxDist, 0.0, maxDist*maxDist);\n\n    int iCoordOffset = GetSampleIndexOffset((vec2(fragTestIntCoord) + vec2(0.5) - fragTestCoord));\n    for(int iCoord = -1; iCoord < 64; iCoord++)\n    {\n        ivec2 samplingCoord = fragTestIntCoord;\n        if(iCoord >= 0)\n        {\n            samplingCoord += SampleCoords[iCoord + iCoordOffset];\n        }\n        \n        vec3 sampleDiffDistSqr = get_diff_minDistSqr(fragTestCoord, samplingCoord);\n        \n        // Need to add a bias for some reason.\n        if(sampleDiffDistSqr.z >= diff_distSqr.z + 1.5)\n            break;\n            \n        if(sampleDiffDistSqr.z >= diff_distSqr.z)\n            continue; \n            \n        if(!containsEdge(fragIsOccupied, samplingCoord, maxMip))\n            continue;\n            \n        SubSampleArgs a;\n        a.DIFFDISTSQR = diff_distSqr;\n        a.SAMPLECOORD = samplingCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = fragTestCoord;\n        IncreaseDepth(a);\n        diff_distSqr = SubSample\n        (\n            a,\n            fragIsOccupied\n        ); \n    }\n         \n    vec3 diff_dist = vec3(diff_distSqr.xy, sqrt(diff_distSqr.z)) / (fragIsOccupied ? -maxDist : maxDist);     \n         \n    diff_dist.xy = normalize(diff_dist.xy);\n    \n    diff_dist.z = diff_dist.z * 0.5 + 0.5;\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    //diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    \n         \n    fragColor = vec4(diff_dist, 1.0);\n    if(isnan(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    if(isinf(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    \n    // Accumulate samples over time.\n    if(iFrame > 1 && iMouse.z <= 0.)\n    {\n        vec2 uv = (fragCoord.xy) / iChannelResolution[1].xy;\n        vec4 oldColor = texture(iChannel1, uv);\n        fragColor += oldColor;\n    }\n    \n}\n", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 113, 113, 427], [428, 428, 455, 455, 758], [760, 760, 817, 817, 1958]], "test": "untested"}
{"id": "mdjGWt", "name": "Dripping Red Wax", "author": "Peace", "description": "Dripping and dripping, where is it coming from...", "tags": ["dripping"], "likes": 20, "viewed": 381, "published": 3, "date": "1668428155", "time_retrieved": "2024-07-30T16:19:49.731225", "image_code": "#define BACKGROUND vec3(1, 1, 1)\n\nconst float PI = 3.14159265359;\n\nfloat seed = 0.25;\n\nfloat dripDistance = 0.1;\nfloat density = 0.75;\n\nfloat bCurve = 1.5;\nfloat bFreq = 3.5;\nfloat bRange = 0.35;\n\nfloat fallSpeed = 6.0;\n\nfloat sdfWidth = 0.14;\n\nfloat scale = 0.5;\n\n\nfloat rand(float x, float y) { return fract(1e4 * sin(17.0 * x + y * 0.1) * (0.1 + abs(sin(y * 13.0 + x)))); }\n\nfloat dripSDF( vec2 uv )\n{   \n    uv.y *= -1.;\n    uv.y += 1.0;\n    float s = sdfWidth * abs((1.0-uv.y)-0.75) + 0.05;\n    float o = 1.0;\n    float drip = 9999.0;\n    \n    float x = uv.x * scale - sdfWidth;\n    x += dripDistance - mod(x, dripDistance);\n    \n    x -= dripDistance;\n    for( int i=0; i<3; i++ )\n    {\n        if( x > uv.x * scale + sdfWidth ) break;\n        \n        x += dripDistance;\n        float isLine = floor(rand(x, seed) + density);\n        if( isLine == 0.0 ) continue;\n        \n        float y = rand(seed,x) * 0.8 + 0.1;\n        float animTime = iTime+(y*10.0);\n        float bounce = 0.0 - (bCurve * mod(animTime, bFreq)) * exp(1.0-bCurve*mod(animTime, bFreq));\n        y += bounce * bRange;\n        y = min(y,uv.y);\n        \n        float t = mod(animTime, bFreq) * fallSpeed * bRange;\n        float f = y + t;\n        \n        float d = distance(vec2(x,y), uv * vec2(scale, 1));\n        \n        o *= clamp(d/s, 0.0, 1.0);\n        drip = min(drip, distance(vec2(x / scale,f), uv) * (0.5 + t * 0.45));\n    }\n    \n    o = min( o, clamp(drip/s,0.0,1.0) );\n    \n    s = sin(uv.x * 20.0 + iTime * 0.5) * 0.1 + sin(0.5 * (uv.x * 20.0 + iTime * 0.5)) * 0.2 + 0.4;\n    float sdf = o * clamp(uv.y/s,0.0,1.0);\n    return sdf;\n}\n\nvec3 getNormal(vec2 p)\n{\n    vec3 e = vec3(vec2(1.0) / iResolution.xy * 32.0 /*multiply for smooth normals*/, 0);\n    float nx = (dripSDF(p - e.xz) - dripSDF(p + e.xz)) / (2.0 * e.x);\n    float ny = (dripSDF(p - e.zy) - dripSDF(p + e.zy)) / (2.0 * e.y);\n    vec3 n = normalize(vec3(nx, ny, 1.));\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n\tvec3 col = vec3(0.0);   \n    \n    float c = 1.0 / sdfWidth * 0.025;\n    float w = 0.03;\n    \n    float d = dripSDF(uv);\n    float m = 1.0 - smoothstep( c - w, c + w, d );\n    \n \n    col.r = m;\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0, 0, 0);\n    vec3 p = ro + rd * d;\n    vec3 l[4] = vec3[](vec3(700, -500, 50.0), vec3(-700, -500, 50.0), vec3(0, -500, 200.0), vec3(100, 500, 100.0));\n    float light = 0.0;\n    for(int i = 0; i < l.length(); ++i)\n    {\n    vec3 to_l = normalize(l[i] - p);\n    vec3 to_ro = normalize(ro - p);\n    vec3 n = getNormal(uv);\n    float spec = pow(max(dot(reflect(-to_l, n), to_ro), 0.0), 8.0) * 0.75;\n    float occl = pow(max(dot(reflect(to_l, n), to_ro), 0.0), 2.0);\n    float diff = max(0.0, dot(to_l, n)) * 0.5;\n    light += max(spec + diff - occl, 0.0);\n    }\n    col.rgb *= light + 0.5;\n    col.gb += max(col.r - 1.0, 0.0);\n    col.rgb = pow(col.rgb, 1.0 / vec3(2.2));\n    col.rgb = mix(BACKGROUND, col.rgb, m);\n    //col.rgb = vec3(d);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 296, 296, 376], [378, 378, 404, 404, 1623], [1625, 1625, 1649, 1649, 1936]], "test": "untested"}
{"id": "ddfSRr", "name": "lines-cone", "author": "Kolya142", "description": "lines\nurl: https://cineshader.com/view/ddfSRr", "tags": ["cineshader"], "likes": 1, "viewed": 2077, "published": 3, "date": "1668422355", "time_retrieved": "2024-07-30T16:19:50.823305", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = atan((uv.x - 0.5) / (uv.y - .5)) / 6.28 * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"lines-cone\",\n\t\"description\": \"lines\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 679]], "test": "untested"}
{"id": "msXSzn", "name": " Particles 2D version", "author": "rubioh", "description": "Same as: https://www.shadertoy.com/view/ddSGDd\n2D version.", "tags": ["2d", "particles", "bloom"], "likes": 8, "viewed": 251, "published": 3, "date": "1668419034", "time_retrieved": "2024-07-30T16:19:53.762446", "image_code": "const int MAX_MARCHING_STEPS = 30;\nconst float MIN_DIST = 6.;\nconst float MAX_DIST = 3.;\nconst float PRECISION = 0.002;\n#define AA 0\n#define PI 3.14159\n\n\nconst float K = 120.;\n\n// iq's palette\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.4, 0.2, 1.);\n    vec3 b = vec3(0.75, 0.7, 0.7);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.6, 0.35, 0.05);\n    \n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 analytic_sphere(vec2 p, float r) {\n    //return sphere_coord;\n    float l = length(p);\n    float h = r*cos(l*PI/2./(r*1.5));\n    p = normalize(p/r)*asin(length(p/r)) / PI;\n    //p *= smoothstep(0., 0.001, sign(p));\n    return vec3(p, h*16.);\n}\n\nvec3 Ring(vec2 uv, inout vec3 col, inout vec3 col_bloom){\n    \n    float dmin=1e10, d;\n    \n    vec3 pos, posf;\n    for (int i=0; i<int(get_NPARTICLES()); i++){\n        vec3 tmp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n        \n        pos.xy = decode(tmp.x);\n        pos.z = tmp.y;\n                \n        d = 1.-smoothstep(0., .001, length(uv-pos.xy)-(1.+pos.z)/K);\n        \n        float d2 = abs(length(uv-pos.xy));\n        \n        if (d2<dmin){ \n            dmin = d2;\n            posf = pos*d;\n        }\n        \n        col += d*palette(float(i)/get_NPARTICLES()+iTime/8.);\n        \n        d2 = d2-(1.+pos.z)/K;\n        if (iFrame >= 1) col_bloom += palette(float(i)/get_NPARTICLES()+iTime/8.)*exp(-abs(d2*d2)/.0003)*.4; \n           \n    }\n    return posf;\n}\n\nvec3 calcNormal(vec2 uv){\n    vec2 e = vec2(1.0, -1.0) * 0.0001*1.45674;\n    vec3 pos;\n    float d;\n    float dtot = 0.;\n    vec3 S = vec3(0.);\n    vec3 tmpS;\n    for (int i=0; i<int(get_NPARTICLES()); i++){\n        vec3 tmp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n        pos.xy = decode(tmp.x);\n        pos.z = tmp.y;\n        d = 1.-smoothstep(0., .1, length(uv-pos.xy)-(1.+pos.z)/K);\n        tmpS =\n            normalize(\n                e.xyx*analytic_sphere(uv +  e.xy -pos.xy, (1.+pos.z)/K) + \n                e.yxx*analytic_sphere(uv +  e.yx -pos.xy, (1.+pos.z)/K) + \n                e.xxx*analytic_sphere(uv +  e.xx -pos.xy, (1.+pos.z)/K))*d              \n                ;\n        S = max(S, tmpS);\n\n    }\n    return S;\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col) {\n  // ambient\n  float N = 2.;\n  vec3 ambient = (col*(.5) *N )/N;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = (col * dotLN*N)/N;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = ((col) * pow(dotRV, 5.)*N)/N;\n\n  return  ambient + diffuse + specular*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1)*4.;\n  \n  vec3 col_ball = vec3(0.);\n  vec3 col_bloom = vec3(0.);\n  \n  vec3 p = Ring(uv*1.4, col_ball, col_bloom);\n\n  vec3 normal = calcNormal(uv*1.4);\n  \n  \n  vec3 lightPosition = vec3(2, 2, 3);\n  vec3 ld = normalize(lightPosition - p);\n\n  vec3 rd = normalize(vec3(uv, 2)); \n  vec3 col = phong(ld, normal, rd, col_ball);\n      \n  // Output to screen\n  vec3 col_tot = col_bloom+max(col*.4, vec3(0.));\n  \n  fragColor = vec4(col_tot, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NPARTICLES 150\n#define PI 3.14159\n\nfloat get_NPARTICLES(){\n    return float(NPARTICLES);\n}\n\nfloat hash11( float x){\n    return fract( sin( float(x)*101.4567)*41.234);\n}\n\n\nvec2 hash22(vec2 p){\n    vec2 a = vec2(10.487,9.4567);\n    vec2 b = vec2(456.775, 150.2467);\n    return fract( sin(vec2(dot(a,p), dot(b,p)))*41.234);\n}\n\nvec3 hash33(vec3 p){\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\nvec3 hash13(float x){\n    vec3 p = vec3(x,x,x);\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\n// PACK UNPACK METHODS FROM https://www.shadertoy.com/view/WtfyDj\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\n// iq's sdf\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n", "buffer_a_code": "vec3 init_position(vec3 seed){\n    vec3 pos = vec3(seed);\n    return vec3(pos);\n}\n\nvec3 init_velocity(vec3 seed){\n    vec3 vel = vec3(seed.yxz);\n    return vec3(vel);\n}\n\n// found this on: https://www.vertexshaderart.com/art/aqgyqr6ASpcsZTeEu\nvec2 sphere_point(float i) {\n  // golden ratio\n  float phi = (sqrt(5.) + 1.) / 2. - 1.;\n  // golden angle\n  float ga = phi * 2. * PI;\n  \n  vec2 p = vec2(0.);  \n  p.x = ga * i;\n  p.x /= 2. * PI;\n  p.x = fract(p.x);\n  p.x *= 2. * PI;\n    \n  p.y = asin(-1. + 2. * i / get_NPARTICLES());\n  return p;\n}\nvec3 lla2xyz(vec2 latlon, float rad) {\n  float rxz = rad * cos(latlon.y);\n  \n  return vec3(\n    rxz * cos(latlon.x),\n    rad * sin(latlon.y),\n    rxz * sin(latlon.x)\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    \n    if (uv.x>int(get_NPARTICLES())){\n        fragColor = vec4(0.);\n        return;\n    }\n    if (uv.y>1){\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 center_obj = vec3(0.);\n    \n    vec3 pos;\n    vec3 vel;\n    \n    if (iFrame <= 1){\n        float seedx = hash11( float(uv.x)+.1);\n        float seedy = hash11( float(uv.x)+5.);\n        float seedz = hash11(  float(uv.x)+1.);\n        pos = init_position(vec3(seedx, seedy, seedz));\n        vel = init_velocity(vec3(seedx, seedy, seedz));\n        }\n        \n    else{\n        vec4 state = texelFetch(iChannel0, uv, 0);\n        \n        pos.xy = decode(state.x);\n        pos.z = state.y;\n        \n        vec2 tmp = sphere_point(mod(float(uv.x)-40.*floor(iTime/2.), get_NPARTICLES()));\n        vec3 id = lla2xyz(tmp, .5) + .05*(hash13(float(uv.x)+floor(iTime*2.*PI)) -.5)*(.5+.5*cos(iTime));\n               \n        vel.xy = decode(state.z);\n        vel.z = state.w;\n        \n        pos += vel*.2;\n        vel = (.96 * vel + .04 * -(pos-id));\n\n    }\n    \n    vec4 state;\n    \n    state.x = encode(pos.xy);\n    state.y = pos.z;\n    \n    state.z = encode(vel.xy);\n    state.w = vel.z;\n\n    \n    fragColor = state;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 193, 220, 220, 404], [406, 406, 445, 472, 654], [656, 656, 713, 713, 1429], [1431, 1431, 1456, 1456, 2167], [2169, 2169, 2228, 2241, 2573], [2575, 2575, 2632, 2632, 3161]], "test": "untested"}
{"id": "dsfSzn", "name": "Line Continuations + Britney", "author": "mla", "description": "Line continuations, plus randomized Britney.\n\nMouse sets size and aspect ratio of pixelization (if it's not obvious from the code).", "tags": ["line", "continuation"], "likes": 2, "viewed": 165, "published": 3, "date": "1668418764", "time_retrieved": "2024-07-30T16:19:54.981188", "image_code": "u\\\ni\\\nn\\\nt\\\n \\\ni\\\nh\\\na\\\ns\\\nh\\\n(\\\nu\\\ni\\\nn\\\nt\\\n \\\nx\\\n)\\\n \\\n{\\\n\n\\\n \\\n \\\n \\\n \\\n/\\\n/\\\n \\\nF\\\nr\\\no\\\nm\\\n \\\nC\\\nh\\\nr\\\ni\\\ns\\\n \\\nW\\\ne\\\nl\\\nl\\\no\\\nn\\\ns\\\n:\\\n \\\nh\\\nt\\\nt\\\np\\\ns\\\n:\\\n/\\\n/\\\nn\\\nu\\\nl\\\nl\\\np\\\nr\\\no\\\ng\\\nr\\\na\\\nm\\\n.\\\nc\\\no\\\nm\\\n/\\\nb\\\nl\\\no\\\ng\\\n/\\\n2\\\n0\\\n1\\\n8\\\n/\\\n0\\\n7\\\n/\\\n3\\\n1\\\n/\\\n\n\\\n \\\n \\\n \\\n \\\nx\\\n \\\n^\\\n=\\\n \\\nx\\\n \\\n>\\\n>\\\n \\\n1\\\n6\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nx\\\n \\\n*\\\n=\\\n \\\n0\\\nx\\\n7\\\nf\\\ne\\\nb\\\n3\\\n5\\\n2\\\nd\\\nU\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nx\\\n \\\n^\\\n=\\\n \\\nx\\\n \\\n>\\\n>\\\n \\\n1\\\n5\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nx\\\n \\\n*\\\n=\\\n \\\n0\\\nx\\\n8\\\n4\\\n6\\\nc\\\na\\\n6\\\n8\\\nb\\\nU\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nx\\\n \\\n^\\\n=\\\n \\\nx\\\n \\\n>\\\n>\\\n \\\n1\\\n6\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nr\\\ne\\\nt\\\nu\\\nr\\\nn\\\n \\\nx\\\n;\\\n\n\\\n}\\\n\n\\\nu\\\ni\\\nn\\\nt\\\n \\\nx\\\no\\\nr\\\ns\\\nh\\\ni\\\nf\\\nt\\\n(\\\nu\\\ni\\\nn\\\nt\\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n)\\\n \\\n{\\\n\n\\\n \\\n \\\n/\\\n/\\\n \\\nX\\\no\\\nr\\\ns\\\nh\\\ni\\\nf\\\nt\\\n*\\\n3\\\n2\\\n\n\\\n \\\n \\\n/\\\n/\\\n \\\nB\\\ny\\\n \\\nG\\\ne\\\no\\\nr\\\ng\\\ne\\\n \\\nM\\\na\\\nr\\\ns\\\na\\\ng\\\nl\\\ni\\\na\\\n:\\\n \\\nh\\\nt\\\nt\\\np\\\n:\\\n/\\\n/\\\nw\\\nw\\\nw\\\n.\\\nj\\\ns\\\nt\\\na\\\nt\\\ns\\\no\\\nf\\\nt\\\n.\\\no\\\nr\\\ng\\\n/\\\nv\\\n0\\\n8\\\n/\\\ni\\\n1\\\n4\\\n/\\\np\\\na\\\np\\\ne\\\nr\\\n\n\\\n \\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n \\\n^\\\n=\\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n \\\n<\\\n<\\\n \\\n1\\\n3\\\n;\\\n\n\\\n \\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n \\\n^\\\n=\\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n \\\n>\\\n>\\\n \\\n1\\\n7\\\n;\\\n\n\\\n \\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n \\\n^\\\n=\\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n \\\n<\\\n<\\\n \\\n5\\\n;\\\n\n\\\n \\\n \\\nr\\\ne\\\nt\\\nu\\\nr\\\nn\\\n \\\nv\\\na\\\nl\\\nu\\\ne\\\n;\\\n\n\\\n}\\\n\n\\\n\n\\\nv\\\no\\\ni\\\nd\\\n \\\nm\\\na\\\ni\\\nn\\\nI\\\nm\\\na\\\ng\\\ne\\\n(\\\no\\\nu\\\nt\\\n \\\nv\\\ne\\\nc\\\n4\\\n \\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\nl\\\no\\\nr\\\n,\\\n \\\nv\\\ne\\\nc\\\n2\\\n \\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\no\\\nr\\\nd\\\n)\\\n{\\\n\n\\\n \\\n \\\n \\\n \\\nv\\\ne\\\nc\\\n2\\\n \\\nN\\\n \\\n=\\\n \\\nv\\\ne\\\nc\\\n2\\\n(\\\n1\\\n)\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\ni\\\nf\\\n \\\n(\\\ni\\\nM\\\no\\\nu\\\ns\\\ne\\\n.\\\nz\\\n \\\n>\\\n \\\n0\\\n.\\\n0\\\n)\\\n \\\nN\\\n \\\n=\\\n \\\n1\\\n.\\\n0\\\n+\\\nf\\\nl\\\no\\\no\\\nr\\\n(\\\n6\\\n.\\\n0\\\n*\\\ni\\\nM\\\no\\\nu\\\ns\\\ne\\\n.\\\nx\\\ny\\\n/\\\ni\\\nR\\\ne\\\ns\\\no\\\nl\\\nu\\\nt\\\ni\\\no\\\nn\\\n.\\\nx\\\ny\\\n)\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\no\\\nr\\\nd\\\n \\\n=\\\n \\\nN\\\n*\\\nf\\\nl\\\no\\\no\\\nr\\\n(\\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\no\\\nr\\\nd\\\n/\\\nN\\\n)\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nv\\\ne\\\nc\\\n2\\\n \\\nu\\\nv\\\n \\\n=\\\n \\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\no\\\nr\\\nd\\\n/\\\ni\\\nR\\\ne\\\ns\\\no\\\nl\\\nu\\\nt\\\ni\\\no\\\nn\\\n.\\\nx\\\ny\\\n;\\\n \\\n \\\n \\\n\n\\\n \\\n \\\n \\\n \\\nv\\\ne\\\nc\\\n3\\\n \\\nc\\\no\\\nl\\\n \\\n=\\\n \\\nt\\\ne\\\nx\\\nt\\\nu\\\nr\\\ne\\\n(\\\ni\\\nC\\\nh\\\na\\\nn\\\nn\\\ne\\\nl\\\n0\\\n,\\\nu\\\nv\\\n)\\\n.\\\nx\\\ny\\\nz\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nu\\\ni\\\nn\\\nt\\\n \\\nh\\\n \\\n=\\\n \\\ni\\\nh\\\na\\\ns\\\nh\\\n(\\\nu\\\ni\\\nn\\\nt\\\n(\\\n4\\\n0\\\n9\\\n6\\\n.\\\n0\\\n*\\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\no\\\nr\\\nd\\\n.\\\nx\\\n+\\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\no\\\nr\\\nd\\\n.\\\ny\\\n)\\\n)\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\nf\\\no\\\nr\\\n \\\n(\\\ni\\\nn\\\nt\\\n \\\ni\\\n \\\n=\\\n \\\n0\\\n;\\\n \\\ni\\\n \\\n<\\\n \\\n3\\\n;\\\n \\\ni\\\n+\\\n+\\\n)\\\n \\\n{\\\n\n\\\n \\\n \\\n \\\n \\\n \\\n \\\nh\\\n \\\n=\\\n \\\nx\\\no\\\nr\\\ns\\\nh\\\ni\\\nf\\\nt\\\n(\\\nh\\\n)\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\n \\\n \\\nf\\\nl\\\no\\\na\\\nt\\\n \\\nr\\\na\\\nn\\\nd\\\n \\\n=\\\n \\\nf\\\nl\\\no\\\na\\\nt\\\n(\\\nh\\\n)\\\n/\\\np\\\no\\\nw\\\n(\\\n2\\\n.\\\n0\\\n,\\\n3\\\n2\\\n.\\\n0\\\n)\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\n \\\n \\\nf\\\nl\\\no\\\na\\\nt\\\n \\\nl\\\ne\\\nv\\\ne\\\nl\\\n \\\n=\\\n \\\nc\\\no\\\nl\\\n[\\\ni\\\n]\\\n;\\\n\n\\\n \\\n \\\n \\\n \\\n \\\n \\\nc\\\no\\\nl\\\n[\\\ni\\\n]\\\n \\\n=\\\n \\\nf\\\nl\\\no\\\na\\\nt\\\n(\\\nr\\\na\\\nn\\\nd\\\n \\\n<\\\n \\\nl\\\ne\\\nv\\\ne\\\nl\\\n)\\\n;\\\n \\\n\n\\\n \\\n \\\n \\\n \\\n}\\\n\n\\\n \\\n \\\n \\\n \\\nf\\\nr\\\na\\\ng\\\nC\\\no\\\nl\\\no\\\nr\\\n \\\n=\\\n \\\nv\\\ne\\\nc\\\n4\\\n(\\\nc\\\no\\\nl\\\n,\\\n1\\\n.\\\n0\\\n)\\\n;\\\n\n\\\n}\\\n\n\\", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ddSGDd", "name": "Particles RayMarching experiment", "author": "rubioh", "description": "Question: \n- Is there any way to optimize the raymarching in order to plot a maximum of particles?", "tags": ["raymarching", "particles", "bloom"], "likes": 9, "viewed": 404, "published": 3, "date": "1668416226", "time_retrieved": "2024-07-30T16:19:55.744148", "image_code": "const int MAX_MARCHING_STEPS = 30;\nconst float MIN_DIST = 6.;\nconst float MAX_DIST = 3.;\nconst float PRECISION = 0.002;\n#define AA 0\n#define PI 3.14159\n\n// iq's palette\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.2, 0.2, 1.);\n    vec3 b = vec3(0.7, 0.7, 0.7);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.3, 0.1, 0.8);\n    \n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat Ring(vec3 p, inout vec3 col, inout vec3 col_bloom){\n    float d = 1e10;\n        \n    vec3 p_s = p;\n    \n    float d2;\n    vec3 pos;\n    for (int i=0; i<int(get_NPARTICLES()); i++){\n        vec3 tmp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n        \n        pos.xy = decode(tmp.x);\n        pos.z = tmp.y;\n        \n        vec3 res = p_s + pos;\n       \n         d2 = sdSphere(res, .01);\n        \n        if (d2<d){\n           col = palette(float(i)/get_NPARTICLES()+iTime/8.);\n           d = d2;\n        }\n        if (iFrame >= 1) col_bloom += palette(float(i)/get_NPARTICLES()+iTime/8.)*.1*exp(-abs(d2*d2)/.005); \n;\n          \n    }\n    return d;\n}\n\n\nfloat map(vec3 p, inout vec3 col, inout vec3 col_bloom){\n    float d = 1e10;    \n    p += vec3(1., 0., 1.);\n    d = Ring(p, col, col_bloom);    \n        \n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, out vec3 col, inout float min_dist, inout vec3 col_bloom) {\n  float depth = start, min_d = 1e10;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = map(p, col, col_bloom);\n    depth += d;\n    if (d < PRECISION){\n        break;\n        }\n    if (d>MAX_DIST){\n        break;\n    }\n    if (d<min_d){\n        min_dist = d;\n        min_d = d;\n    }\n    }\n    return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.001;\n    vec3 c, c2;\n    return normalize(\n      e.xyy * map(p + e.xyy,c,c2) +\n      e.yyx * map(p + e.yyx,c,c2) +\n      e.yxy * map(p + e.yxy,c,c2) +\n      e.xxx * map(p + e.xxx,c,c2));\n}\n\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col, float spec) {\n  // ambient\n  float N = 2.;\n  vec3 ambient = (col*N)/N;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = (col * dotLN*N)/N;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal)/1.4, -rd), 0., 1.);\n  vec3 specular = 50.*spec*((.5*col+vec3(.5)) * pow(dotRV, 15.)*N)/N;\n\n  return ambient + diffuse; + specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1)*4.;\n  \n  vec3 col;\n  vec3 col_tot = vec3(0.);\n\n  \n    vec3 ro = vec3(-1., 0., 1.); \n    vec3 rd = normalize(vec3(uv, -1)); \n  \n\n  vec3 normal;\n  float d;\n  float L=0.;\n  float depth2 = 1e10;\n  float min_depth = 1e10;\n  vec3 col_bloom;\n                    \n  vec3 rd2 = rd;\n  d = rayMarch(ro, rd2, d+1., col, min_depth, col_bloom); \n  if (d > MAX_DIST) {\n    col_tot = vec3(0.); \n  } else {\n    vec3 p = ro + rd * d;\n    normal = calcNormal(p);\n    vec3 lightPosition = vec3(1, 1, 2);\n    vec3 lightDirection = normalize(lightPosition - p);\n    float lint = 5.;\n    col_tot += lint*phong(lightDirection, normal, rd, col/4., 3.);\n   }\n           \n    \n  col_tot += col_bloom;\n  \n  col_tot = vec3(col_tot)/float(AA+1)/float(AA+1);\n  // Output to screen\n  fragColor = vec4(col_tot*.4, d);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NPARTICLES 150\n#define PI 3.14159\n\nfloat get_NPARTICLES(){\n    return float(NPARTICLES);\n}\n\nfloat hash11( float x){\n    return fract( sin( float(x)*101.4567)*41.234);\n}\n\n\nvec2 hash22(vec2 p){\n    vec2 a = vec2(10.487,9.4567);\n    vec2 b = vec2(456.775, 150.2467);\n    return fract( sin(vec2(dot(a,p), dot(b,p)))*41.234);\n}\n\nvec3 hash33(vec3 p){\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\nvec3 hash13(float x){\n    vec3 p = vec3(x,x,x);\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\n// PACK UNPACK METHODS FROM https://www.shadertoy.com/view/WtfyDj\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\n// iq's sdf\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n", "buffer_a_code": "vec3 init_position(vec3 seed){\n    vec3 pos = vec3(seed);\n    return vec3(pos);\n}\n\nvec3 init_velocity(vec3 seed){\n    vec3 vel = vec3(seed.yxz);\n    return vec3(vel);\n}\n\n// found this on: https://www.vertexshaderart.com/art/aqgyqr6ASpcsZTeEu\nvec2 sphere_point(float i) {\n  // golden ratio\n  float phi = (sqrt(5.) + 1.) / 2. - 1.;\n  // golden angle\n  float ga = phi * 2. * PI;\n  \n  vec2 p = vec2(0.);  \n  p.x = ga * i;\n  p.x /= 2. * PI;\n  p.x = fract(p.x);\n  p.x *= 2. * PI;\n    \n  p.y = asin(-1. + 2. * i / get_NPARTICLES());\n  return p;\n}\nvec3 lla2xyz(vec2 latlon, float rad) {\n  float rxz = rad * cos(latlon.y);\n  \n  return vec3(\n    rxz * cos(latlon.x),\n    rad * sin(latlon.y),\n    rxz * sin(latlon.x)\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    \n    if (uv.x>int(get_NPARTICLES())){\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    \n    vec3 center_obj = vec3(0.);\n    \n    vec3 pos;\n    vec3 vel;\n    \n    if (iFrame <= 1){\n        float seedx = hash11( float(uv.x)+.1);\n        float seedy = hash11( float(uv.x)+5.);\n        float seedz = hash11(  float(uv.x)+1.);\n        pos = init_position(vec3(seedx, seedy, seedz));\n        vel = init_velocity(vec3(seedx, seedy, seedz));\n        }\n        \n    else{\n        vec4 state = texelFetch(iChannel0, uv, 0);\n        \n        pos.xy = decode(state.x);\n        pos.z = state.y;\n        \n        vec2 tmp = sphere_point(mod(float(uv.x)-10.*floor(iTime), get_NPARTICLES()));\n        vec3 id = lla2xyz(tmp, .5) + .05*(hash13(float(uv.x)+floor(iTime*2.*PI)) -.5)*(.5+.5*cos(iTime));\n               \n        vel.xy = decode(state.z);\n        vel.z = state.w;\n        \n        pos += vel*.2;\n        vel = (.96 * vel + .04 * -(pos-id));\n        \n        /*\n        vec3 pos2;\n        for (int i=-2; i<=2; i++){\n            if (i == 0) continue;\n            vec4 state2 = texelFetch(iChannel0, ivec2(uv.x + i, 0.), 0);\n\n            pos2.xy = decode(state2.x);\n            pos2.z = state2.y;\n            \n            vel += .01*pow((pos-pos2), vec3(1.));\n            \n        }\n        */\n        \n        \n        \n               \n    }\n    \n    vec4 state;\n    \n    state.x = encode(pos.xy);\n    state.y = pos.z;\n    \n    state.z = encode(vel.xy);\n    state.w = vel.z;\n\n    \n    fragColor = state;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 169, 196, 196, 377], [379, 379, 436, 436, 1036], [1039, 1039, 1095, 1095, 1208], [1210, 1210, 1315, 1315, 1667], [1669, 1669, 1694, 1694, 1916], [1919, 1919, 1938, 1938, 2014], [2017, 2017, 2088, 2101, 2449], [2452, 2452, 2509, 2509, 3388]], "test": "untested"}
{"id": "DsfSRr", "name": "Simple Polygon Drawing II", "author": "mla", "description": "Another simple way of drawing a polygon. No atan this time, it's all done with mirrors. ", "tags": ["simple", "polygon"], "likes": 7, "viewed": 179, "published": 3, "date": "1668416192", "time_retrieved": "2024-07-30T16:19:56.594873", "image_code": "// Simple Polygon Drawing, mla, 2022\n// Just a little exercise in drawing polygons, trying\n// to keep everything as simple and obvious as possible.\n// This one uses a fold rather than polar coordinates.\n\nconst float PI = 3.141592654;\n\nbool exact = true;\n\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  if (exact) k = clamp(k,0.0,1.0);\n  return distance(p,k*r);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 1.1*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float K = 8.0*4.0+2.0;\n    float N = mod(iTime,K);\n    N = min(N,K-N);\n    float step = 2.0;\n    float k = mod(N,step);\n    k = smoothstep(1.0,2.0,k);\n    N = floor(N/step) + k + 3.0;\n    float s = cos(PI/N), t = sin(PI/N);\n    float px = fwidth(p.x);\n    p = p.yx*vec2(-1,1); // Set orientation\n    vec2 n = vec2(t,-s);\n    for (int i = 0; i < int(ceil(N)+1.0)/2; i++) {\n      p.y = abs(p.y);\n      float k = dot(p,n);\n      if (k > 0.0) break;\n      p -= 2.0*k*n;\n    }\n    float d = segment(p,vec2(0.5*s,0),vec2(s,t));\n    vec3 col = vec3(0.75+0.25*cos(20.0*PI*d));\n    col = mix(vec3(1,0,0),col,vec3(smoothstep(0.0,px,d-0.01)));\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 294, 294, 406], [408, 408, 460, 460, 1226]], "test": "untested"}
{"id": "csXSzr", "name": "Texture SDF", "author": "Hatchling", "description": "Using mipmaps as a quadtree, I wrote a FAST traversal algorithm to find the signed distance within a pixel field.\nPrior to that I use a broad phase search.\nThis allows me to recursively search very deep down.\n\nF--K YES", "tags": ["2d", "sdf", "distance", "field", "signed"], "likes": 13, "viewed": 363, "published": 3, "date": "1668414816", "time_retrieved": "2024-07-30T16:19:57.675983", "image_code": "// HOLY ---- I DID IT\n// Broad crawl outward, then a recursive mipmap quadtree search.\n// FAST runtime, FAST compilation (comparitavely).\n// Should compile in about ~7 seconds, ~70 FPS @ 1000x563\n\nconst int mipCount = 8;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst int SampleCoordCount = 64*8;\nconst ivec2 SampleCoords[64*8] = ivec2[64*8]\n(\n    ivec2( 0, -1), ivec2(-1,  0), ivec2(-1, -1), ivec2(+1,  0), \n    ivec2( 0, +1), ivec2(+1, -1), ivec2(-1, +1), ivec2(+1, +1), \n    ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+1, -2), ivec2(+2,  0), ivec2(-2, +1), ivec2( 0, +2), \n    ivec2(+2, -1), ivec2(-1, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(-2, -2), ivec2( 0, -3), ivec2(+2, -2), ivec2(-3,  0), \n    ivec2(-1, -3), ivec2(-2, +2), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+2, +2), ivec2(-3, +1), ivec2(+3,  0), ivec2(+3, -1), \n    ivec2( 0, +3), ivec2(-2, -3), ivec2(-3, -2), ivec2(-1, +3), \n    ivec2(+3, +1), ivec2(+1, +3), ivec2(+2, -3), ivec2(+3, -2), \n    ivec2(-3, +2), ivec2(-2, +3), ivec2( 0, -4), ivec2(-1, -4), \n    ivec2(+3, +2), ivec2(-4,  0), ivec2(+2, +3), ivec2(+1, -4), \n    ivec2(-4, -1), ivec2(-3, -3), ivec2(-4, +1), ivec2(+4,  0), \n    ivec2(+3, -3), ivec2(-2, -4), ivec2(+4, -1), ivec2(-4, -2), \n    ivec2( 0, +4), ivec2(+2, -4), ivec2(+4, +1), ivec2(-3, +3), \n    ivec2(-1, +4), ivec2(+1, +4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2( 0, -1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, -1), \n    ivec2( 0, +1), ivec2(-1, -1), ivec2(+1, +1), ivec2(-1, +1), \n    ivec2( 0, -2), ivec2(+2,  0), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-1, -2), ivec2(-2,  0), ivec2(-2, -1), ivec2( 0, +2), \n    ivec2(+2, +1), ivec2(+1, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(+2, -2), ivec2(-2, -2), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(+3,  0), ivec2(+2, +2), ivec2(-1, -3), ivec2(+3, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(+3, +1), ivec2(-3, -1), \n    ivec2( 0, +3), ivec2(+2, -3), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+3, -2), ivec2(-1, +3), ivec2(-2, -3), ivec2(-3, -2), \n    ivec2(+3, +2), ivec2( 0, -4), ivec2(+2, +3), ivec2(-3, +2), \n    ivec2(+1, -4), ivec2(-2, +3), ivec2(+4,  0), ivec2(-1, -4), \n    ivec2(+4, -1), ivec2(+3, -3), ivec2(+4, +1), ivec2(-4,  0), \n    ivec2(-3, -3), ivec2(-4, -1), ivec2(+2, -4), ivec2( 0, +4), \n    ivec2(+4, -2), ivec2(-4, +1), ivec2(-2, -4), ivec2(+1, +4), \n    ivec2(+3, +3), ivec2(-1, +4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(-1,  0), ivec2(-1, +1), ivec2(+1,  0), \n    ivec2( 0, -1), ivec2(+1, +1), ivec2(-1, -1), ivec2(+1, -1), \n    ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+1, +2), ivec2(+2,  0), ivec2(-2, -1), ivec2( 0, -2), \n    ivec2(+2, +1), ivec2(-1, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(-2, +2), ivec2( 0, +3), ivec2(+2, +2), ivec2(-3,  0), \n    ivec2(-1, +3), ivec2(-2, -2), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+2, -2), ivec2(-3, -1), ivec2(+3,  0), ivec2(+3, +1), \n    ivec2( 0, -3), ivec2(-2, +3), ivec2(-3, +2), ivec2(-1, -3), \n    ivec2(+3, -1), ivec2(+1, -3), ivec2(+2, +3), ivec2(+3, +2), \n    ivec2(-3, -2), ivec2(-2, -3), ivec2( 0, +4), ivec2(-1, +4), \n    ivec2(+3, -2), ivec2(-4,  0), ivec2(+2, -3), ivec2(+1, +4), \n    ivec2(-4, +1), ivec2(-3, +3), ivec2(-4, -1), ivec2(+4,  0), \n    ivec2(+3, +3), ivec2(-2, +4), ivec2(+4, +1), ivec2(-4, +2), \n    ivec2( 0, -4), ivec2(+2, +4), ivec2(+4, -1), ivec2(-3, -3), \n    ivec2(-1, -4), ivec2(+1, -4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, +1), \n    ivec2( 0, -1), ivec2(-1, +1), ivec2(+1, -1), ivec2(-1, -1), \n    ivec2( 0, +2), ivec2(+2,  0), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-1, +2), ivec2(-2,  0), ivec2(-2, +1), ivec2( 0, -2), \n    ivec2(+2, -1), ivec2(+1, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(+2, +2), ivec2(-2, +2), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(+3,  0), ivec2(+2, -2), ivec2(-1, +3), ivec2(+3, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(+3, -1), ivec2(-3, +1), \n    ivec2( 0, -3), ivec2(+2, +3), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+3, +2), ivec2(-1, -3), ivec2(-2, +3), ivec2(-3, +2), \n    ivec2(+3, -2), ivec2( 0, +4), ivec2(+2, -3), ivec2(-3, -2), \n    ivec2(+1, +4), ivec2(-2, -3), ivec2(+4,  0), ivec2(-1, +4), \n    ivec2(+4, +1), ivec2(+3, +3), ivec2(+4, -1), ivec2(-4,  0), \n    ivec2(-3, +3), ivec2(-4, +1), ivec2(+2, +4), ivec2( 0, -4), \n    ivec2(+4, +2), ivec2(-4, -1), ivec2(-2, +4), ivec2(+1, -4), \n    ivec2(+3, -3), ivec2(-1, -4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2(-1,  0), ivec2( 0, -1), ivec2(-1, -1), ivec2( 0, +1), \n    ivec2(+1,  0), ivec2(-1, +1), ivec2(+1, -1), ivec2(+1, +1), \n    ivec2(-2,  0), ivec2( 0, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(-2, +1), ivec2( 0, +2), ivec2(-1, +2), ivec2(+1, -2), \n    ivec2(+2,  0), ivec2(+2, -1), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(-2, +2), ivec2(-3, -1), \n    ivec2( 0, -3), ivec2(+2, -2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +2), ivec2( 0, +3), ivec2(+1, -3), ivec2(-1, +3), \n    ivec2(+3,  0), ivec2(-3, -2), ivec2(-2, -3), ivec2(+1, +3), \n    ivec2(+3, -1), ivec2(+3, +1), ivec2(-3, +2), ivec2(-2, +3), \n    ivec2(+2, -3), ivec2(-4,  0), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(+2, +3), ivec2( 0, -4), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(-1, -4), ivec2(-3, -3), ivec2(+1, -4), ivec2( 0, +4), \n    ivec2(-3, +3), ivec2(-4, -2), ivec2(-1, +4), ivec2(-2, -4), \n    ivec2(+4,  0), ivec2(-4, +2), ivec2(+1, +4), ivec2(+3, -3), \n    ivec2(+4, -1), ivec2(+4, +1), ivec2(-2, +4), ivec2(+2, -4),\n\n    ivec2(+1,  0), ivec2( 0, -1), ivec2( 0, +1), ivec2(+1, -1), \n    ivec2(-1,  0), ivec2(+1, +1), ivec2(-1, -1), ivec2(-1, +1), \n    ivec2(+2,  0), ivec2( 0, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(+2, +1), ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, -2), \n    ivec2(+1, +2), ivec2(-2, -1), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+2, -2), ivec2(+2, +2), ivec2(+3,  0), ivec2( 0, -3), \n    ivec2(+3, -1), ivec2(-2, -2), ivec2(+1, -3), ivec2(+3, +1), \n    ivec2(-2, +2), ivec2(-1, -3), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(-3,  0), ivec2(+3, -2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -3), ivec2(-3, +1), ivec2(+3, +2), ivec2(+2, +3), \n    ivec2(-2, -3), ivec2(-3, -2), ivec2(+4,  0), ivec2(-2, +3), \n    ivec2(+4, -1), ivec2(-3, +2), ivec2( 0, -4), ivec2(+4, +1), \n    ivec2(+1, -4), ivec2(+3, -3), ivec2(-1, -4), ivec2( 0, +4), \n    ivec2(+3, +3), ivec2(+1, +4), ivec2(+4, -2), ivec2(-4,  0), \n    ivec2(+2, -4), ivec2(-1, +4), ivec2(+4, +2), ivec2(-4, -1), \n    ivec2(-3, -3), ivec2(-4, +1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(-1,  0), ivec2( 0, +1), ivec2(-1, +1), ivec2( 0, -1), \n    ivec2(+1,  0), ivec2(-1, -1), ivec2(+1, +1), ivec2(+1, -1), \n    ivec2(-2,  0), ivec2( 0, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(-2, -1), ivec2( 0, -2), ivec2(-1, -2), ivec2(+1, +2), \n    ivec2(+2,  0), ivec2(+2, +1), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(-2, -2), ivec2(-3, +1), \n    ivec2( 0, +3), ivec2(+2, +2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -2), ivec2( 0, -3), ivec2(+1, +3), ivec2(-1, -3), \n    ivec2(+3,  0), ivec2(-3, +2), ivec2(-2, +3), ivec2(+1, -3), \n    ivec2(+3, +1), ivec2(+3, -1), ivec2(-3, -2), ivec2(-2, -3), \n    ivec2(+2, +3), ivec2(-4,  0), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(+2, -3), ivec2( 0, +4), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(-1, +4), ivec2(-3, +3), ivec2(+1, +4), ivec2( 0, -4), \n    ivec2(-3, -3), ivec2(-4, +2), ivec2(-1, -4), ivec2(-2, +4), \n    ivec2(+4,  0), ivec2(-4, -2), ivec2(+1, -4), ivec2(+3, +3), \n    ivec2(+4, +1), ivec2(+4, -1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(+1,  0), ivec2( 0, +1), ivec2( 0, -1), ivec2(+1, +1), \n    ivec2(-1,  0), ivec2(+1, -1), ivec2(-1, +1), ivec2(-1, -1), \n    ivec2(+2,  0), ivec2( 0, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(+2, -1), ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, +2), \n    ivec2(+1, -2), ivec2(-2, +1), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+2, +2), ivec2(+2, -2), ivec2(+3,  0), ivec2( 0, +3), \n    ivec2(+3, +1), ivec2(-2, +2), ivec2(+1, +3), ivec2(+3, -1), \n    ivec2(-2, -2), ivec2(-1, +3), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(-3,  0), ivec2(+3, +2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +3), ivec2(-3, -1), ivec2(+3, -2), ivec2(+2, -3), \n    ivec2(-2, +3), ivec2(-3, +2), ivec2(+4,  0), ivec2(-2, -3), \n    ivec2(+4, +1), ivec2(-3, -2), ivec2( 0, +4), ivec2(+4, -1), \n    ivec2(+1, +4), ivec2(+3, +3), ivec2(-1, +4), ivec2( 0, -4), \n    ivec2(+3, -3), ivec2(+1, -4), ivec2(+4, +2), ivec2(-4,  0), \n    ivec2(+2, +4), ivec2(-1, -4), ivec2(+4, -2), ivec2(-4, +1), \n    ivec2(-3, +3), ivec2(-4, -1), ivec2(-2, +4), ivec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*64) : 0;\n    index |= testToSample.y < 0. ? (2*64) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*64) : 0;\n    return index;\n}\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec3 get_diff_minDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 pointToCenter = squareCenter - point;\n    vec2 minOffset = clamp(pointToCenter, vec2(-0.5), vec2(0.5));\n    vec2 pointToMin = pointToCenter - minOffset;\n    return vec3(pointToMin, lengthSqr(pointToMin));\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 diff_distSqr;\n    vec2 testCoord;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD testCoord\n#define DIFFDISTSQR diff_distSqr\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) vec3 name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03 )\n#define SSA04 {    \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA05     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);   \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA06    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA07    {\n#define SSA08        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA09        vec3 subsampleDiffDistSqr = get_diff_minDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA10        if(!(subsampleDiffDistSqr.z < a.DIFFDISTSQR.z))\n#define SSA11            continue;\n    \n#define SSA12        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA13            continue;\n\n                     // Recursive   \n#define SSR(name)    subsampleDiffDistSqr = name                     \n#define SSB00        (\n#define SSB01            GetNextArgs(a, subsamplingCoord),\n#define SSB02            testOccupied\n#define SSB03        );\n\n#define SSC00        if(a.DIFFDISTSQR.z > subsampleDiffDistSqr.z) a.DIFFDISTSQR = subsampleDiffDistSqr;\n#define SSC01     }\n    \n#define SSC02     return a.DIFFDISTSQR * vec3(0.5, 0.5, 0.25);\n#define SSC03 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 \n\n#define SSB_0 SSB00 SSB01 SSB02 SSB03\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSB_0\n#define SS_END              SSC_0\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    // Set up mouse coordinates.\n    vec2 mouseUV = fragCoord / iResolution.xx * 2.0;\n    vec2 mouseTestCoord = mouseUV * vec2(maxMipSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    bool mouseIsOccupied = isOccupied(mouseUV); \n    \n    // Set up fragment coordinates.\n    vec2 fragUV = fragCoord / iResolution.xx * 2.0;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    \n    // Color the fragment.\n    {\n        float density = 0.;\n        int count = 0;\n        for(int i = maxMip-RECURSION_DEPTH; i <= maxMip; i++)\n        {\n            ivec2 mipSize = textureSize(iChannel0, i);\n            bool fragIsOccupied = containsEdge(false, ivec2(fragUV * vec2(mipSize)), i);   \n            bool fragIsOccupied2 = containsEdge(true, ivec2(fragUV * vec2(mipSize)), i);   \n\n            density += fragIsOccupied ? 1. : 0.;\n            density += !fragIsOccupied2 ? 1. : 0.;\n            count+=2;\n            \n            // Remove this to show all mip levels explored.\n            break;\n        }\n            \n        // Compress the range to 0-1\n        density /= 10. + density;\n        \n        density /= float(count) / (float(10 + count)); \n        //density = smoothstep(0., 1., density);\n        //density *= density;\n        \n        fragColor.rgb = hsv2rgb(vec3(density*density*density*density*2.0 + 0.5, 1.-density * 0.5, density* 0.5));\n    }\n    \n    vec3 diff_distSqr = vec3(4.0, 0.0, 16.0);\n\n    int iCoordOffset = GetSampleIndexOffset((vec2(mouseTestIntCoord) + vec2(0.5) - mouseTestCoord));\n    for(int iCoord = -1; iCoord < 64; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord;// + iCoord == -1 ? SampleCoords[iCoord + iCoordOffset];\n        if(iCoord >= 0)\n        {\n            samplingCoord += SampleCoords[iCoord + iCoordOffset];\n        }\n        \n        vec3 sampleDiffDistSqr = get_diff_minDistSqr(mouseTestCoord, samplingCoord);\n        \n        // Need to add a bias for some reason.\n        if(sampleDiffDistSqr.z >= diff_distSqr.z + 1.5)\n            break;\n            \n        if(sampleDiffDistSqr.z >= diff_distSqr.z)\n            continue; \n            \n        if(samplingCoord == fragTestIntCoord)\n            fragColor += vec4(0.1, 0, 0, 0);\n            \n        if(!containsEdge(mouseIsOccupied, samplingCoord, maxMip))\n            continue;\n            \n        /*if(sampleDistSqr < distSqrToSignChange)\n        {\n            distSqrToSignChange = sampleDistSqr;\n        }*/\n            \n        SubSampleArgs a;\n        a.DIFFDISTSQR = diff_distSqr;\n        a.SAMPLECOORD = samplingCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = mouseTestCoord;\n        IncreaseDepth(a);\n        diff_distSqr = SubSample\n        (\n            a,\n            mouseIsOccupied\n        ); \n    }\n         \n    vec3 diff_dist = vec3(diff_distSqr.xy, sqrt(diff_distSqr.z) * (mouseIsOccupied ? -1.0 : 1.0));     \n         \n    drawSDF\n    (\n        diff_dist,\n        fragColor\n    );\n    \n    // Compress the range to 0-1\n    //fragColor /= vec4(0.25) + fragColor;\n    //fragColor = smoothstep(vec4(0), vec4(1), fragColor);\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\n\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Linq;\n\t\t\t\t\t\npublic class Program\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tstatic Vector2 GetTestCoord(int index)\n\t{\n\t\tVector2 v = default(Vector2);\n\t\t\n\t\t// abs(x) > abs(y)?\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tv.X = 0.25f;\n\t\t\tv.Y = 0.125f;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tv.X = 0.125f;\n\t\t\tv.Y = 0.25f;\n\t\t}\n\t\t\n\t\t// x < 0?\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tv.X = -v.X;\n\t\t}\n\t\t\n\t\t// y < 0?\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tv.Y = -v.Y;\n\t\t}\n\t\t\n\t\treturn -v;\n\t}\n\t\n\tstatic string AsString(Vector2 v)\n\t{\n\t\treturn string.Format\n\t\t(\n\t\t\t\"ivec2({0}{1}, {2}{3})\", \n\t\t\t v.X < 0 ? '-' : (v.X > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.X), \n\t\t\t v.Y < 0 ? '-' : (v.Y > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.Y)\n\t     );\n\t}\n\t\n\tstatic string AsString(Vector2[] v)\n\t{\n\t\tstring s = \"\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t\t\n\t\t\t\tif(i % 4 == 0)\n\t\t\t\t\ts = s + '\\n';\n\t\t\t}\n\t\t\ts = s + AsString(v[i]);//.ToString();\n\t\t}\n\t\t\n\t\ts += \",\";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"________________\");\n\t\tConsole.WriteLine(\"                \");\n\t\t\n\t\tconst int radius = 4;\n\t\tconst int diameter = radius+radius+1;\n\t\tconst int capacity = diameter * diameter - 1;\n\t\tList<Vector2> pixelCoords = new List<Vector2>(capacity);\n\t\t\n\t\tconst float maxDistanceSqr = (radius + 0.5f) * (radius + 0.5f);\n\n\t\tfor(int x = -radius; x <= radius; x++)\n\t\t{\n\t\t\tfor(int y = -radius; y <= radius; y++)\n\t\t\t{\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tpixelCoords.Add(new Vector2(x,y));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tVector2 testCoord = GetTestCoord(i);\n\t\t\t\n\t\t\tvar pixelsSorted = pixelCoords.Where(p => Vector2.DistanceSquared(p, testCoord) <= maxDistanceSqr).OrderBy(p => Vector2.DistanceSquared(p, testCoord)).ToArray();\n\t\t\t\n\t\t\t//Console.WriteLine(pixelsSorted.Length);\n\t\t\tConsole.WriteLine(AsString(pixelsSorted));\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n*/", "cube_a_code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy; \n    \n    float thresh = sin(iTime) * 0.25 + 0.5;\n    fragColor = texture(iChannel0, uv).r > thresh ? vec4(1) : vec4(0);\n}", "cube_a_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 314, 314, 490], [492, 492, 518, 518, 600], [9506, 9506, 9551, 9551, 9749], [9751, 9751, 9799, 9799, 9994], [9996, 10128, 10179, 10179, 10444], [10659, 10659, 10702, 10702, 10833], [10835, 10835, 10895, 10895, 11065]], "test": "untested"}
{"id": "cdfXzr", "name": "ray marching with rtx", "author": "Kolya142", "description": "version 2.4;\nadded pixelation shader;\nfix mirror", "tags": ["raytracing", "raymarching"], "likes": 1, "viewed": 167, "published": 3, "date": "1668414556", "time_retrieved": "2024-07-30T16:19:58.439940", "image_code": "#define PIXELATION false\n#define BLOCKSIZE  5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    if (PIXELATION) {\n        uv /= float(BLOCKSIZE);\n        uv.x = float(int(uv.x)*BLOCKSIZE);\n        uv.y = float(int(uv.y)*BLOCKSIZE);\n    }\n    fragColor = texture(iChannel0, uv/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sphere(vec3 p, vec3 c, float r) {\n    return length(p-c)-r;\n}\nfloat sdBox( vec3 p, vec3 c, vec3 b )\n{\n  vec3 q = abs(p-c) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 light_pos() {\n    return vec3(vec2(1.6, 7.), .0);\n}\nvec2 rot(vec2 p, float a) {\n    return vec2(p.x * cos(a) - p.y * sin(a), \n                p.x * sin(a) + p.y * cos(a));\n}\nvec2 map_the_world(in vec3 p) {\n    vec3 pbi = p;\n    pbi.xy = rot(pbi.xy, sin(iTime));\n    pbi.xz = rot(pbi.xz, cos(iTime));\n    float s = sphere(vec3(p.x, p.y, p.z), vec3(-3., sin(iTime)+3., -3.), 1.);\n    float b1 = sdBox(p, vec3(sin(2.68), cos(2.68), -3.), vec3(100., 2., 100.));\n    float bi = sdBox(pbi, vec3(3., 1., 2.), vec3(1.) );\n    float l = sphere(p, light_pos(), .3);\n    float glass = sphere(vec3(p.x, p.y, p.z), vec3(+3., 3., -3.), .3);\n    float index = 0.;\n    float m = min(s, min(b1, min(bi, min(l, glass))));\n    if (s == m) {\n        index = 1.;\n    }\n    if (b1 == m) {\n        index = 2.;\n    }\n    if (bi == m) {\n        index = 3.;\n    }\n    if (l == m) {\n        index = 4.;\n    }\n    if (glass == m) {\n        index = 5.;\n    }\n    return vec2(m, index);\n}\nvec3 Norm(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy).x - map_the_world(p - small_step.xyy).x;\n    float gradient_y = map_the_world(p + small_step.yxy).x - map_the_world(p - small_step.yxy).x;\n    float gradient_z = map_the_world(p + small_step.yyx).x - map_the_world(p - small_step.yyx).x;\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\nfloat shadow(vec3 ro, vec3 rd) {\n    float step_size;\n    vec3 pos;\n    float dist;\n    float d;\n    for (int i = 0; i < 20;i++) {\n        pos = ro + dist * rd;\n        vec2 map = map_the_world(pos);\n        d = map.x;\n        if (d < .0001 && dist > .015) {\n            if (map.y == 4.) return -10.;\n            return .5;\n        }\n        dist += d;\n    }\n    return 0.;    \n}\nvec4 render(vec3 ro, vec3 rd) {\n    float step_size;\n    vec3 pos;\n    float dist;\n    float d;\n    vec3 color = vec3(1.);\n    for (int iter = 0; iter < 2; iter++) {\n        for (int i = 0; i < 100;i++) {\n            pos = ro + dist * rd;\n            vec2 map = map_the_world(pos);\n            d = map.x;\n            float id = map.y;\n            vec3 norm = Norm(pos);\n            float light = max(.1, dot(norm, normalize(light_pos())));\n            light -= shadow(pos, normalize(light_pos()));\n            if (d < .001) {\n                bool end = true;\n                if (id == 3.) {\n                    color *= vec3(.2, 1., .2);\n                }\n                if (id == 2.) {\n                    color *= vec3(.5, .6, .4);\n                }\n                if (id == 1.) {\n                    rd = reflect(rd, norm);ro = pos;color = vec3(1., .6, 1.);\n                    end = false;\n                }\n                if (id == 4.) {\n                    color *= vec3(10.);\n                }\n                if (id == 5.) {\n                    rd = -norm;pos += rd;end = false;ro = pos;\n                }\n                if (end) {\n                    return vec4(color * light, dist);\n                }\n            }\n            dist += d;\n        }\n    }\n    return vec4(vec3(.4, .5, .8)*color, 0.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vuv = fragCoord/iResolution.xy;\n    vuv.x *= iResolution.x / iResolution.y;\n    vuv.x -= .5;\n    vec2 uv = vuv * 2. - 1.;\n    vec3 ro = vec3(0., 0., -6.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec2 mouse = (iMouse.xy/iResolution.xy - .5) * 3.;\n    rd.yz = rot(rd.yz, mouse.y);rd.xz = rot(rd.xz, mouse.x);\n    ro.yz = rot(ro.yz, mouse.y);ro.xz = rot(ro.xz, mouse.x);\n\n    // Time varying pixel color\n    vec4 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = col;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 331]], "test": "untested"}
{"id": "DdfSRr", "name": "Signed Distance to Texture FULL", "author": "Hatchling", "description": "Using mipmaps as a quadtree, I wrote a FAST traversal algorithm to find the signed distance within a pixel field.\nPrior to that I use a broad phase search.\nThis allows me to recursively search very deep down.\n\nF--K YES", "tags": ["2d", "sdf", "distance", "field", "signed"], "likes": 3, "viewed": 251, "published": 3, "date": "1668408889", "time_retrieved": "2024-07-30T16:19:59.626767", "image_code": "// HOLY ---- I DID IT\n// Broad crawl outward, then a recursive mipmap quadtree search.\n// FAST runtime, FAST compilation (comparitavely).\n// Should compile in about 7.2 seconds, 144+ FPS @ 900x506\n\n// Controls =================================\n// Mouse + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Circle:           (Color) Gradient (Radius) Final distance.\n\nconst int mipCount = 8;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst int SampleCoordCount = 64*8;\nconst ivec2 SampleCoords[64*8] = ivec2[64*8]\n(\n    ivec2( 0, -1), ivec2(-1,  0), ivec2(-1, -1), ivec2(+1,  0), \n    ivec2( 0, +1), ivec2(+1, -1), ivec2(-1, +1), ivec2(+1, +1), \n    ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+1, -2), ivec2(+2,  0), ivec2(-2, +1), ivec2( 0, +2), \n    ivec2(+2, -1), ivec2(-1, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(-2, -2), ivec2( 0, -3), ivec2(+2, -2), ivec2(-3,  0), \n    ivec2(-1, -3), ivec2(-2, +2), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+2, +2), ivec2(-3, +1), ivec2(+3,  0), ivec2(+3, -1), \n    ivec2( 0, +3), ivec2(-2, -3), ivec2(-3, -2), ivec2(-1, +3), \n    ivec2(+3, +1), ivec2(+1, +3), ivec2(+2, -3), ivec2(+3, -2), \n    ivec2(-3, +2), ivec2(-2, +3), ivec2( 0, -4), ivec2(-1, -4), \n    ivec2(+3, +2), ivec2(-4,  0), ivec2(+2, +3), ivec2(+1, -4), \n    ivec2(-4, -1), ivec2(-3, -3), ivec2(-4, +1), ivec2(+4,  0), \n    ivec2(+3, -3), ivec2(-2, -4), ivec2(+4, -1), ivec2(-4, -2), \n    ivec2( 0, +4), ivec2(+2, -4), ivec2(+4, +1), ivec2(-3, +3), \n    ivec2(-1, +4), ivec2(+1, +4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2( 0, -1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, -1), \n    ivec2( 0, +1), ivec2(-1, -1), ivec2(+1, +1), ivec2(-1, +1), \n    ivec2( 0, -2), ivec2(+2,  0), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-1, -2), ivec2(-2,  0), ivec2(-2, -1), ivec2( 0, +2), \n    ivec2(+2, +1), ivec2(+1, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(+2, -2), ivec2(-2, -2), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(+3,  0), ivec2(+2, +2), ivec2(-1, -3), ivec2(+3, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(+3, +1), ivec2(-3, -1), \n    ivec2( 0, +3), ivec2(+2, -3), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+3, -2), ivec2(-1, +3), ivec2(-2, -3), ivec2(-3, -2), \n    ivec2(+3, +2), ivec2( 0, -4), ivec2(+2, +3), ivec2(-3, +2), \n    ivec2(+1, -4), ivec2(-2, +3), ivec2(+4,  0), ivec2(-1, -4), \n    ivec2(+4, -1), ivec2(+3, -3), ivec2(+4, +1), ivec2(-4,  0), \n    ivec2(-3, -3), ivec2(-4, -1), ivec2(+2, -4), ivec2( 0, +4), \n    ivec2(+4, -2), ivec2(-4, +1), ivec2(-2, -4), ivec2(+1, +4), \n    ivec2(+3, +3), ivec2(-1, +4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(-1,  0), ivec2(-1, +1), ivec2(+1,  0), \n    ivec2( 0, -1), ivec2(+1, +1), ivec2(-1, -1), ivec2(+1, -1), \n    ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+1, +2), ivec2(+2,  0), ivec2(-2, -1), ivec2( 0, -2), \n    ivec2(+2, +1), ivec2(-1, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(-2, +2), ivec2( 0, +3), ivec2(+2, +2), ivec2(-3,  0), \n    ivec2(-1, +3), ivec2(-2, -2), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+2, -2), ivec2(-3, -1), ivec2(+3,  0), ivec2(+3, +1), \n    ivec2( 0, -3), ivec2(-2, +3), ivec2(-3, +2), ivec2(-1, -3), \n    ivec2(+3, -1), ivec2(+1, -3), ivec2(+2, +3), ivec2(+3, +2), \n    ivec2(-3, -2), ivec2(-2, -3), ivec2( 0, +4), ivec2(-1, +4), \n    ivec2(+3, -2), ivec2(-4,  0), ivec2(+2, -3), ivec2(+1, +4), \n    ivec2(-4, +1), ivec2(-3, +3), ivec2(-4, -1), ivec2(+4,  0), \n    ivec2(+3, +3), ivec2(-2, +4), ivec2(+4, +1), ivec2(-4, +2), \n    ivec2( 0, -4), ivec2(+2, +4), ivec2(+4, -1), ivec2(-3, -3), \n    ivec2(-1, -4), ivec2(+1, -4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, +1), \n    ivec2( 0, -1), ivec2(-1, +1), ivec2(+1, -1), ivec2(-1, -1), \n    ivec2( 0, +2), ivec2(+2,  0), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-1, +2), ivec2(-2,  0), ivec2(-2, +1), ivec2( 0, -2), \n    ivec2(+2, -1), ivec2(+1, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(+2, +2), ivec2(-2, +2), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(+3,  0), ivec2(+2, -2), ivec2(-1, +3), ivec2(+3, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(+3, -1), ivec2(-3, +1), \n    ivec2( 0, -3), ivec2(+2, +3), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+3, +2), ivec2(-1, -3), ivec2(-2, +3), ivec2(-3, +2), \n    ivec2(+3, -2), ivec2( 0, +4), ivec2(+2, -3), ivec2(-3, -2), \n    ivec2(+1, +4), ivec2(-2, -3), ivec2(+4,  0), ivec2(-1, +4), \n    ivec2(+4, +1), ivec2(+3, +3), ivec2(+4, -1), ivec2(-4,  0), \n    ivec2(-3, +3), ivec2(-4, +1), ivec2(+2, +4), ivec2( 0, -4), \n    ivec2(+4, +2), ivec2(-4, -1), ivec2(-2, +4), ivec2(+1, -4), \n    ivec2(+3, -3), ivec2(-1, -4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2(-1,  0), ivec2( 0, -1), ivec2(-1, -1), ivec2( 0, +1), \n    ivec2(+1,  0), ivec2(-1, +1), ivec2(+1, -1), ivec2(+1, +1), \n    ivec2(-2,  0), ivec2( 0, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(-2, +1), ivec2( 0, +2), ivec2(-1, +2), ivec2(+1, -2), \n    ivec2(+2,  0), ivec2(+2, -1), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(-2, +2), ivec2(-3, -1), \n    ivec2( 0, -3), ivec2(+2, -2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +2), ivec2( 0, +3), ivec2(+1, -3), ivec2(-1, +3), \n    ivec2(+3,  0), ivec2(-3, -2), ivec2(-2, -3), ivec2(+1, +3), \n    ivec2(+3, -1), ivec2(+3, +1), ivec2(-3, +2), ivec2(-2, +3), \n    ivec2(+2, -3), ivec2(-4,  0), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(+2, +3), ivec2( 0, -4), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(-1, -4), ivec2(-3, -3), ivec2(+1, -4), ivec2( 0, +4), \n    ivec2(-3, +3), ivec2(-4, -2), ivec2(-1, +4), ivec2(-2, -4), \n    ivec2(+4,  0), ivec2(-4, +2), ivec2(+1, +4), ivec2(+3, -3), \n    ivec2(+4, -1), ivec2(+4, +1), ivec2(-2, +4), ivec2(+2, -4),\n\n    ivec2(+1,  0), ivec2( 0, -1), ivec2( 0, +1), ivec2(+1, -1), \n    ivec2(-1,  0), ivec2(+1, +1), ivec2(-1, -1), ivec2(-1, +1), \n    ivec2(+2,  0), ivec2( 0, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(+2, +1), ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, -2), \n    ivec2(+1, +2), ivec2(-2, -1), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+2, -2), ivec2(+2, +2), ivec2(+3,  0), ivec2( 0, -3), \n    ivec2(+3, -1), ivec2(-2, -2), ivec2(+1, -3), ivec2(+3, +1), \n    ivec2(-2, +2), ivec2(-1, -3), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(-3,  0), ivec2(+3, -2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -3), ivec2(-3, +1), ivec2(+3, +2), ivec2(+2, +3), \n    ivec2(-2, -3), ivec2(-3, -2), ivec2(+4,  0), ivec2(-2, +3), \n    ivec2(+4, -1), ivec2(-3, +2), ivec2( 0, -4), ivec2(+4, +1), \n    ivec2(+1, -4), ivec2(+3, -3), ivec2(-1, -4), ivec2( 0, +4), \n    ivec2(+3, +3), ivec2(+1, +4), ivec2(+4, -2), ivec2(-4,  0), \n    ivec2(+2, -4), ivec2(-1, +4), ivec2(+4, +2), ivec2(-4, -1), \n    ivec2(-3, -3), ivec2(-4, +1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(-1,  0), ivec2( 0, +1), ivec2(-1, +1), ivec2( 0, -1), \n    ivec2(+1,  0), ivec2(-1, -1), ivec2(+1, +1), ivec2(+1, -1), \n    ivec2(-2,  0), ivec2( 0, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(-2, -1), ivec2( 0, -2), ivec2(-1, -2), ivec2(+1, +2), \n    ivec2(+2,  0), ivec2(+2, +1), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(-2, -2), ivec2(-3, +1), \n    ivec2( 0, +3), ivec2(+2, +2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -2), ivec2( 0, -3), ivec2(+1, +3), ivec2(-1, -3), \n    ivec2(+3,  0), ivec2(-3, +2), ivec2(-2, +3), ivec2(+1, -3), \n    ivec2(+3, +1), ivec2(+3, -1), ivec2(-3, -2), ivec2(-2, -3), \n    ivec2(+2, +3), ivec2(-4,  0), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(+2, -3), ivec2( 0, +4), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(-1, +4), ivec2(-3, +3), ivec2(+1, +4), ivec2( 0, -4), \n    ivec2(-3, -3), ivec2(-4, +2), ivec2(-1, -4), ivec2(-2, +4), \n    ivec2(+4,  0), ivec2(-4, -2), ivec2(+1, -4), ivec2(+3, +3), \n    ivec2(+4, +1), ivec2(+4, -1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(+1,  0), ivec2( 0, +1), ivec2( 0, -1), ivec2(+1, +1), \n    ivec2(-1,  0), ivec2(+1, -1), ivec2(-1, +1), ivec2(-1, -1), \n    ivec2(+2,  0), ivec2( 0, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(+2, -1), ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, +2), \n    ivec2(+1, -2), ivec2(-2, +1), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+2, +2), ivec2(+2, -2), ivec2(+3,  0), ivec2( 0, +3), \n    ivec2(+3, +1), ivec2(-2, +2), ivec2(+1, +3), ivec2(+3, -1), \n    ivec2(-2, -2), ivec2(-1, +3), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(-3,  0), ivec2(+3, +2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +3), ivec2(-3, -1), ivec2(+3, -2), ivec2(+2, -3), \n    ivec2(-2, +3), ivec2(-3, +2), ivec2(+4,  0), ivec2(-2, -3), \n    ivec2(+4, +1), ivec2(-3, -2), ivec2( 0, +4), ivec2(+4, -1), \n    ivec2(+1, +4), ivec2(+3, +3), ivec2(-1, +4), ivec2( 0, -4), \n    ivec2(+3, -3), ivec2(+1, -4), ivec2(+4, +2), ivec2(-4,  0), \n    ivec2(+2, +4), ivec2(-1, -4), ivec2(+4, -2), ivec2(-4, +1), \n    ivec2(-3, +3), ivec2(-4, -1), ivec2(-2, +4), ivec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*64) : 0;\n    index |= testToSample.y < 0. ? (2*64) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*64) : 0;\n    return index;\n}\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec3 get_diff_minDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 pointToCenter = squareCenter - point;\n    vec2 minOffset = clamp(pointToCenter, vec2(-0.5), vec2(0.5));\n    return vec3(pointToCenter, lengthSqr(pointToCenter - minOffset));\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 diff_distSqr;\n    vec2 testCoord;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD testCoord\n#define DIFFDISTSQR diff_distSqr\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) vec3 name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03 )\n#define SSA04 {    \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA05     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);   \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA06    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA07    {\n#define SSA08        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA09        vec3 subsampleDiffDistSqr = get_diff_minDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA10        if(!(subsampleDiffDistSqr.z < a.DIFFDISTSQR.z))\n#define SSA11            continue;\n    \n#define SSA12        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA13            continue;\n\n                     // Recursive   \n#define SSR(name)    subsampleDiffDistSqr = name                     \n#define SSB00        (\n#define SSB01            GetNextArgs(a, subsamplingCoord),\n#define SSB02            testOccupied\n#define SSB03        );\n\n#define SSC00        if(a.DIFFDISTSQR.z > subsampleDiffDistSqr.z) a.DIFFDISTSQR = subsampleDiffDistSqr;\n#define SSC01     }\n    \n#define SSC02     return a.DIFFDISTSQR * vec3(0.5, 0.5, 0.25);\n#define SSC03 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 \n\n#define SSB_0 SSB00 SSB01 SSB02 SSB03\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSB_0\n#define SS_END              SSC_0\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    // Set up mouse coordinates.\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    if(mouseUV == vec2(0) || mouseUV != clamp(mouseUV, vec2(0), vec2(1)))\n    {\n        mouseUV.x = sin(iTime) * 0.5 + 0.5;\n        mouseUV.y = cos(iTime * 1.618) * 0.5 + 0.5;\n    }\n    vec2 mouseTestCoord = mouseUV * vec2(maxMipSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    bool mouseIsOccupied = isOccupied(mouseUV); \n    \n    // Set up fragment coordinates.\n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    \n    // Color the fragment.\n    {\n        float density = 0.;\n        int count = 0;\n        for(int i = maxMip-RECURSION_DEPTH; i <= maxMip; i++)\n        {\n            ivec2 mipSize = textureSize(iChannel0, i);\n            bool fragIsOccupied = containsEdge(false, ivec2(fragUV * vec2(mipSize)), i);   \n            bool fragIsOccupied2 = containsEdge(true, ivec2(fragUV * vec2(mipSize)), i);   \n\n            density += fragIsOccupied ? 1. : 0.;\n            density += !fragIsOccupied2 ? 1. : 0.;\n            count+=2;\n            \n            // Remove this to show all mip levels explored.\n            break;\n        }\n            \n        // Compress the range to 0-1\n        density /= 10. + density;\n        \n        density /= float(count) / (float(10 + count)); \n        //density = smoothstep(0., 1., density);\n        //density *= density;\n        \n        fragColor.rgb = hsv2rgb(vec3(density*density*density*density*2.0 + 0.5, 1.-density * 0.5, density* 0.5));\n    }\n    \n    vec3 diff_distSqr = vec3(4.0, 0.0, 16.0);\n\n    int iCoordOffset = GetSampleIndexOffset((vec2(mouseTestIntCoord) + vec2(0.5) - mouseTestCoord));\n    for(int iCoord = -1; iCoord < 64; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord;// + iCoord == -1 ? SampleCoords[iCoord + iCoordOffset];\n        if(iCoord >= 0)\n        {\n            samplingCoord += SampleCoords[iCoord + iCoordOffset];\n        }\n        \n        vec3 sampleDiffDistSqr = get_diff_minDistSqr(mouseTestCoord, samplingCoord);\n        \n        // Need to add a bias for some reason.\n        if(sampleDiffDistSqr.z >= diff_distSqr.z + 1.5)\n            break;\n            \n        if(sampleDiffDistSqr.z >= diff_distSqr.z)\n            continue; \n            \n        if(samplingCoord == fragTestIntCoord)\n            fragColor += vec4(0.1, 0, 0, 0);\n            \n        if(!containsEdge(mouseIsOccupied, samplingCoord, maxMip))\n            continue;\n            \n        /*if(sampleDistSqr < distSqrToSignChange)\n        {\n            distSqrToSignChange = sampleDistSqr;\n        }*/\n            \n        SubSampleArgs a;\n        a.DIFFDISTSQR = diff_distSqr;\n        a.SAMPLECOORD = samplingCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = mouseTestCoord;\n        IncreaseDepth(a);\n        diff_distSqr = SubSample\n        (\n            a,\n            mouseIsOccupied\n        ); \n    }\n         \n    drawCircle\n    (\n        mouseTestCoord,\n        fragTestCoord,\n        sqrt(diff_distSqr.z),\n        0.02,\n        vec4(normalize(diff_distSqr.xy) * 0.5 + 0.5, 0, 1.0),\n        fragColor\n    );\n    \n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\n\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Linq;\n\t\t\t\t\t\npublic class Program\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tstatic Vector2 GetTestCoord(int index)\n\t{\n\t\tVector2 v = default(Vector2);\n\t\t\n\t\t// abs(x) > abs(y)?\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tv.X = 0.25f;\n\t\t\tv.Y = 0.125f;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tv.X = 0.125f;\n\t\t\tv.Y = 0.25f;\n\t\t}\n\t\t\n\t\t// x < 0?\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tv.X = -v.X;\n\t\t}\n\t\t\n\t\t// y < 0?\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tv.Y = -v.Y;\n\t\t}\n\t\t\n\t\treturn -v;\n\t}\n\t\n\tstatic string AsString(Vector2 v)\n\t{\n\t\treturn string.Format\n\t\t(\n\t\t\t\"ivec2({0}{1}, {2}{3})\", \n\t\t\t v.X < 0 ? '-' : (v.X > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.X), \n\t\t\t v.Y < 0 ? '-' : (v.Y > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.Y)\n\t     );\n\t}\n\t\n\tstatic string AsString(Vector2[] v)\n\t{\n\t\tstring s = \"\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t\t\n\t\t\t\tif(i % 4 == 0)\n\t\t\t\t\ts = s + '\\n';\n\t\t\t}\n\t\t\ts = s + AsString(v[i]);//.ToString();\n\t\t}\n\t\t\n\t\ts += \",\";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"________________\");\n\t\tConsole.WriteLine(\"                \");\n\t\t\n\t\tconst int radius = 4;\n\t\tconst int diameter = radius+radius+1;\n\t\tconst int capacity = diameter * diameter - 1;\n\t\tList<Vector2> pixelCoords = new List<Vector2>(capacity);\n\t\t\n\t\tconst float maxDistanceSqr = (radius + 0.5f) * (radius + 0.5f);\n\n\t\tfor(int x = -radius; x <= radius; x++)\n\t\t{\n\t\t\tfor(int y = -radius; y <= radius; y++)\n\t\t\t{\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tpixelCoords.Add(new Vector2(x,y));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tVector2 testCoord = GetTestCoord(i);\n\t\t\t\n\t\t\tvar pixelsSorted = pixelCoords.Where(p => Vector2.DistanceSquared(p, testCoord) <= maxDistanceSqr).OrderBy(p => Vector2.DistanceSquared(p, testCoord)).ToArray();\n\t\t\t\n\t\t\t//Console.WriteLine(pixelsSorted.Length);\n\t\t\tConsole.WriteLine(AsString(pixelsSorted));\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n*/", "cube_a_code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    \n    fragColor = texture(iChannel0, uv).r > 0.5 ? vec4(1) : vec4(0);\n}", "cube_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[665, 665, 724, 724, 900], [902, 902, 928, 928, 1010], [9916, 9916, 9961, 9961, 10159], [10161, 10161, 10209, 10209, 10404], [10406, 10538, 10589, 10589, 10823], [11038, 11038, 11081, 11081, 11212], [11214, 11214, 11274, 11274, 11444]], "test": "untested"}
{"id": "cdfSRr", "name": "comma assignment ternary bug", "author": "abje", "description": "this is the same bug as from\n[url]https://www.shadertoy.com/view/DsS3D3[/url]\nset the bug macro to anything other than 1 or 2 to see the expected result.", "tags": ["bug"], "likes": 0, "viewed": 153, "published": 3, "date": "1668404471", "time_retrieved": "2024-07-30T16:20:00.473503", "image_code": "//#define FORCE_BUG\n#define BUG 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float a = 0.0, b = 0.0;\n    \n#ifndef FORCE_BUG\n    \n#if BUG == 1\n    a = uv.x > 0.5 ? b = uv.y > 0.5 ? 1.0 : 0.0, 1.0 : 0.0;\n#elif BUG == 2\n    b = uv.x > 0.5 ? a = 1.0, uv.y > 0.5 ? 1.0 : 0.0 : 0.0;\n#else\n    a = uv.x > 0.5 ? 1.0 : 0.0;\n    b = uv.y > 0.5 && uv.x > 0.5 ? 1.0 : 0.0;\n#endif\n\n#else\n\n#if BUG == 1\n    float temp = (b = uv.y > 0.5 ? 1.0 : 0.0, 1.0);\n    a = uv.x > 0.5 ? temp : 0.0;\n#elif BUG == 2\n    float temp = (a = 1.0, uv.y > 0.5 ? 1.0 : 0.0);\n    b = uv.x > 0.5 ? temp : 0.0;\n#endif\n\n#endif\n    \n    fragColor = vec4(a, b, 0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 697]], "test": "untested"}
{"id": "csfSRn", "name": "Signed Dist to Tex (OBSOLETE)", "author": "Hatchling", "description": "OBSOLETE, SEE: https://www.shadertoy.com/view/DdfSRr\n\nUsing mipmaps as a quadtree, I wrote a FAST traversal algorithm to find the signed distance within a pixel field.\n\nF--K YES", "tags": ["2d", "sdf", "distance", "field", "signed"], "likes": 6, "viewed": 220, "published": 3, "date": "1668397876", "time_retrieved": "2024-07-30T16:20:01.545637", "image_code": "// HOLY ---- I DID IT\n// Recursive mipmap quadtree search, FAST runtime, FAST compilation (comparitavely).\n\n// Recursion Depth | Compilation Time:\n// ________________|__________________\n//                 |\n//               7 | 3.5 seconds \n//               8 | 7.5 seconds \n//               9 | 15  seconds\n//              10 | 30  seconds\n\n// Controls =================================\n// Mouse + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Orange Circle:    Distance of found cell.\n// Whtie Circle:     Final distance.\n\nconst int mipCount = 11;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst vec2 SampleCoords[64*8] = vec2[64*8]\n(\n    vec2( 0, -1), vec2(-1,  0), vec2(-1, -1), vec2(+1,  0), \n    vec2( 0, +1), vec2(+1, -1), vec2(-1, +1), vec2(+1, +1), \n    vec2( 0, -2), vec2(-2,  0), vec2(-1, -2), vec2(-2, -1), \n    vec2(+1, -2), vec2(+2,  0), vec2(-2, +1), vec2( 0, +2), \n    vec2(+2, -1), vec2(-1, +2), vec2(+2, +1), vec2(+1, +2), \n    vec2(-2, -2), vec2( 0, -3), vec2(+2, -2), vec2(-3,  0), \n    vec2(-1, -3), vec2(-2, +2), vec2(-3, -1), vec2(+1, -3), \n    vec2(+2, +2), vec2(-3, +1), vec2(+3,  0), vec2(+3, -1), \n    vec2( 0, +3), vec2(-2, -3), vec2(-3, -2), vec2(-1, +3), \n    vec2(+3, +1), vec2(+1, +3), vec2(+2, -3), vec2(+3, -2), \n    vec2(-3, +2), vec2(-2, +3), vec2( 0, -4), vec2(-1, -4), \n    vec2(+3, +2), vec2(-4,  0), vec2(+2, +3), vec2(+1, -4), \n    vec2(-4, -1), vec2(-3, -3), vec2(-4, +1), vec2(+4,  0), \n    vec2(+3, -3), vec2(-2, -4), vec2(+4, -1), vec2(-4, -2), \n    vec2( 0, +4), vec2(+2, -4), vec2(+4, +1), vec2(-3, +3), \n    vec2(-1, +4), vec2(+1, +4), vec2(-4, +2), vec2(+4, -2),\n\n    vec2( 0, -1), vec2(+1,  0), vec2(-1,  0), vec2(+1, -1), \n    vec2( 0, +1), vec2(-1, -1), vec2(+1, +1), vec2(-1, +1), \n    vec2( 0, -2), vec2(+2,  0), vec2(+1, -2), vec2(+2, -1), \n    vec2(-1, -2), vec2(-2,  0), vec2(-2, -1), vec2( 0, +2), \n    vec2(+2, +1), vec2(+1, +2), vec2(-2, +1), vec2(-1, +2), \n    vec2(+2, -2), vec2(-2, -2), vec2( 0, -3), vec2(+1, -3), \n    vec2(+3,  0), vec2(+2, +2), vec2(-1, -3), vec2(+3, -1), \n    vec2(-2, +2), vec2(-3,  0), vec2(+3, +1), vec2(-3, -1), \n    vec2( 0, +3), vec2(+2, -3), vec2(-3, +1), vec2(+1, +3), \n    vec2(+3, -2), vec2(-1, +3), vec2(-2, -3), vec2(-3, -2), \n    vec2(+3, +2), vec2( 0, -4), vec2(+2, +3), vec2(-3, +2), \n    vec2(+1, -4), vec2(-2, +3), vec2(+4,  0), vec2(-1, -4), \n    vec2(+4, -1), vec2(+3, -3), vec2(+4, +1), vec2(-4,  0), \n    vec2(-3, -3), vec2(-4, -1), vec2(+2, -4), vec2( 0, +4), \n    vec2(+4, -2), vec2(-4, +1), vec2(-2, -4), vec2(+1, +4), \n    vec2(+3, +3), vec2(-1, +4), vec2(-4, -2), vec2(+4, +2),\n\n    vec2( 0, +1), vec2(-1,  0), vec2(-1, +1), vec2(+1,  0), \n    vec2( 0, -1), vec2(+1, +1), vec2(-1, -1), vec2(+1, -1), \n    vec2( 0, +2), vec2(-2,  0), vec2(-1, +2), vec2(-2, +1), \n    vec2(+1, +2), vec2(+2,  0), vec2(-2, -1), vec2( 0, -2), \n    vec2(+2, +1), vec2(-1, -2), vec2(+2, -1), vec2(+1, -2), \n    vec2(-2, +2), vec2( 0, +3), vec2(+2, +2), vec2(-3,  0), \n    vec2(-1, +3), vec2(-2, -2), vec2(-3, +1), vec2(+1, +3), \n    vec2(+2, -2), vec2(-3, -1), vec2(+3,  0), vec2(+3, +1), \n    vec2( 0, -3), vec2(-2, +3), vec2(-3, +2), vec2(-1, -3), \n    vec2(+3, -1), vec2(+1, -3), vec2(+2, +3), vec2(+3, +2), \n    vec2(-3, -2), vec2(-2, -3), vec2( 0, +4), vec2(-1, +4), \n    vec2(+3, -2), vec2(-4,  0), vec2(+2, -3), vec2(+1, +4), \n    vec2(-4, +1), vec2(-3, +3), vec2(-4, -1), vec2(+4,  0), \n    vec2(+3, +3), vec2(-2, +4), vec2(+4, +1), vec2(-4, +2), \n    vec2( 0, -4), vec2(+2, +4), vec2(+4, -1), vec2(-3, -3), \n    vec2(-1, -4), vec2(+1, -4), vec2(-4, -2), vec2(+4, +2),\n\n    vec2( 0, +1), vec2(+1,  0), vec2(-1,  0), vec2(+1, +1), \n    vec2( 0, -1), vec2(-1, +1), vec2(+1, -1), vec2(-1, -1), \n    vec2( 0, +2), vec2(+2,  0), vec2(+1, +2), vec2(+2, +1), \n    vec2(-1, +2), vec2(-2,  0), vec2(-2, +1), vec2( 0, -2), \n    vec2(+2, -1), vec2(+1, -2), vec2(-2, -1), vec2(-1, -2), \n    vec2(+2, +2), vec2(-2, +2), vec2( 0, +3), vec2(+1, +3), \n    vec2(+3,  0), vec2(+2, -2), vec2(-1, +3), vec2(+3, +1), \n    vec2(-2, -2), vec2(-3,  0), vec2(+3, -1), vec2(-3, +1), \n    vec2( 0, -3), vec2(+2, +3), vec2(-3, -1), vec2(+1, -3), \n    vec2(+3, +2), vec2(-1, -3), vec2(-2, +3), vec2(-3, +2), \n    vec2(+3, -2), vec2( 0, +4), vec2(+2, -3), vec2(-3, -2), \n    vec2(+1, +4), vec2(-2, -3), vec2(+4,  0), vec2(-1, +4), \n    vec2(+4, +1), vec2(+3, +3), vec2(+4, -1), vec2(-4,  0), \n    vec2(-3, +3), vec2(-4, +1), vec2(+2, +4), vec2( 0, -4), \n    vec2(+4, +2), vec2(-4, -1), vec2(-2, +4), vec2(+1, -4), \n    vec2(+3, -3), vec2(-1, -4), vec2(-4, +2), vec2(+4, -2),\n\n    vec2(-1,  0), vec2( 0, -1), vec2(-1, -1), vec2( 0, +1), \n    vec2(+1,  0), vec2(-1, +1), vec2(+1, -1), vec2(+1, +1), \n    vec2(-2,  0), vec2( 0, -2), vec2(-2, -1), vec2(-1, -2), \n    vec2(-2, +1), vec2( 0, +2), vec2(-1, +2), vec2(+1, -2), \n    vec2(+2,  0), vec2(+2, -1), vec2(+1, +2), vec2(+2, +1), \n    vec2(-2, -2), vec2(-3,  0), vec2(-2, +2), vec2(-3, -1), \n    vec2( 0, -3), vec2(+2, -2), vec2(-3, +1), vec2(-1, -3), \n    vec2(+2, +2), vec2( 0, +3), vec2(+1, -3), vec2(-1, +3), \n    vec2(+3,  0), vec2(-3, -2), vec2(-2, -3), vec2(+1, +3), \n    vec2(+3, -1), vec2(+3, +1), vec2(-3, +2), vec2(-2, +3), \n    vec2(+2, -3), vec2(-4,  0), vec2(+3, -2), vec2(-4, -1), \n    vec2(+2, +3), vec2( 0, -4), vec2(+3, +2), vec2(-4, +1), \n    vec2(-1, -4), vec2(-3, -3), vec2(+1, -4), vec2( 0, +4), \n    vec2(-3, +3), vec2(-4, -2), vec2(-1, +4), vec2(-2, -4), \n    vec2(+4,  0), vec2(-4, +2), vec2(+1, +4), vec2(+3, -3), \n    vec2(+4, -1), vec2(+4, +1), vec2(-2, +4), vec2(+2, -4),\n\n    vec2(+1,  0), vec2( 0, -1), vec2( 0, +1), vec2(+1, -1), \n    vec2(-1,  0), vec2(+1, +1), vec2(-1, -1), vec2(-1, +1), \n    vec2(+2,  0), vec2( 0, -2), vec2(+2, -1), vec2(+1, -2), \n    vec2(+2, +1), vec2( 0, +2), vec2(-2,  0), vec2(-1, -2), \n    vec2(+1, +2), vec2(-2, -1), vec2(-1, +2), vec2(-2, +1), \n    vec2(+2, -2), vec2(+2, +2), vec2(+3,  0), vec2( 0, -3), \n    vec2(+3, -1), vec2(-2, -2), vec2(+1, -3), vec2(+3, +1), \n    vec2(-2, +2), vec2(-1, -3), vec2( 0, +3), vec2(+1, +3), \n    vec2(-3,  0), vec2(+3, -2), vec2(-3, -1), vec2(-1, +3), \n    vec2(+2, -3), vec2(-3, +1), vec2(+3, +2), vec2(+2, +3), \n    vec2(-2, -3), vec2(-3, -2), vec2(+4,  0), vec2(-2, +3), \n    vec2(+4, -1), vec2(-3, +2), vec2( 0, -4), vec2(+4, +1), \n    vec2(+1, -4), vec2(+3, -3), vec2(-1, -4), vec2( 0, +4), \n    vec2(+3, +3), vec2(+1, +4), vec2(+4, -2), vec2(-4,  0), \n    vec2(+2, -4), vec2(-1, +4), vec2(+4, +2), vec2(-4, -1), \n    vec2(-3, -3), vec2(-4, +1), vec2(-2, -4), vec2(+2, +4),\n\n    vec2(-1,  0), vec2( 0, +1), vec2(-1, +1), vec2( 0, -1), \n    vec2(+1,  0), vec2(-1, -1), vec2(+1, +1), vec2(+1, -1), \n    vec2(-2,  0), vec2( 0, +2), vec2(-2, +1), vec2(-1, +2), \n    vec2(-2, -1), vec2( 0, -2), vec2(-1, -2), vec2(+1, +2), \n    vec2(+2,  0), vec2(+2, +1), vec2(+1, -2), vec2(+2, -1), \n    vec2(-2, +2), vec2(-3,  0), vec2(-2, -2), vec2(-3, +1), \n    vec2( 0, +3), vec2(+2, +2), vec2(-3, -1), vec2(-1, +3), \n    vec2(+2, -2), vec2( 0, -3), vec2(+1, +3), vec2(-1, -3), \n    vec2(+3,  0), vec2(-3, +2), vec2(-2, +3), vec2(+1, -3), \n    vec2(+3, +1), vec2(+3, -1), vec2(-3, -2), vec2(-2, -3), \n    vec2(+2, +3), vec2(-4,  0), vec2(+3, +2), vec2(-4, +1), \n    vec2(+2, -3), vec2( 0, +4), vec2(+3, -2), vec2(-4, -1), \n    vec2(-1, +4), vec2(-3, +3), vec2(+1, +4), vec2( 0, -4), \n    vec2(-3, -3), vec2(-4, +2), vec2(-1, -4), vec2(-2, +4), \n    vec2(+4,  0), vec2(-4, -2), vec2(+1, -4), vec2(+3, +3), \n    vec2(+4, +1), vec2(+4, -1), vec2(-2, -4), vec2(+2, +4),\n\n    vec2(+1,  0), vec2( 0, +1), vec2( 0, -1), vec2(+1, +1), \n    vec2(-1,  0), vec2(+1, -1), vec2(-1, +1), vec2(-1, -1), \n    vec2(+2,  0), vec2( 0, +2), vec2(+2, +1), vec2(+1, +2), \n    vec2(+2, -1), vec2( 0, -2), vec2(-2,  0), vec2(-1, +2), \n    vec2(+1, -2), vec2(-2, +1), vec2(-1, -2), vec2(-2, -1), \n    vec2(+2, +2), vec2(+2, -2), vec2(+3,  0), vec2( 0, +3), \n    vec2(+3, +1), vec2(-2, +2), vec2(+1, +3), vec2(+3, -1), \n    vec2(-2, -2), vec2(-1, +3), vec2( 0, -3), vec2(+1, -3), \n    vec2(-3,  0), vec2(+3, +2), vec2(-3, +1), vec2(-1, -3), \n    vec2(+2, +3), vec2(-3, -1), vec2(+3, -2), vec2(+2, -3), \n    vec2(-2, +3), vec2(-3, +2), vec2(+4,  0), vec2(-2, -3), \n    vec2(+4, +1), vec2(-3, -2), vec2( 0, +4), vec2(+4, -1), \n    vec2(+1, +4), vec2(+3, +3), vec2(-1, +4), vec2( 0, -4), \n    vec2(+3, -3), vec2(+1, -4), vec2(+4, +2), vec2(-4,  0), \n    vec2(+2, +4), vec2(-1, -4), vec2(+4, -2), vec2(-4, +1), \n    vec2(-3, +3), vec2(-4, -1), vec2(-2, +4), vec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nfloat getMinDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 centerToPoint = point - squareCenter;\n    vec2 minOffset = clamp(centerToPoint, vec2(-0.5), vec2(0.5));\n    return lengthSqr(centerToPoint - minOffset);\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 tstCrd_distSqr;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD tstCrd_distSqr.xy\n#define DISTSQR tstCrd_distSqr.z\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.tstCrd_distSqr *= vec3(2.0,2.0,4.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.tstCrd_distSqr *= vec3(2.0,2.0,4.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) float name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03     \n#define SSA04     \n#define SSA05     \n#define SSA06     \n#define SSA07     \n#define SSA08     \n#define SSA09 )\n#define SSA10 {\n#define SSA11     \n#define SSA12     \n#define SSA13     \n#define SSA14     \n#define SSA15     \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA16     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);\n#define SSA17     \n#define SSA18      \n#define SSA19         \n#define SSA20         \n#define SSA21        \n#define SSA22        \n#define SSA23        \n#define SSA24        \n#define SSA25        \n#define SSA26        \n#define SSA27        \n#define SSA28    \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA29    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA30    {\n#define SSA31        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA32        float subsampleDistSqr = getMinDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA33        if(!(subsampleDistSqr < a.DISTSQR))\n#define SSA34            continue;\n    \n#define SSA35        \n#define SSA36        \n\n#define SSA37        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA38            continue;\n            \n#define SSA39        \n\n                     // Non recursive\n#define SSB00        \n\n                     // Recursive   \n#define SSR(name)    subsampleDistSqr = name                     \n#define SSC00        (\n#define SSC01            GetNextArgs(a, subsamplingCoord),\n#define SSC02           \n#define SSC03            \n#define SSC04            \n#define SSC05            testOccupied\n#define SSC06            \n#define SSC07            \n#define SSC08            \n#define SSC09        );\n\n#define SSD00        a.DISTSQR = min(a.DISTSQR, subsampleDistSqr);\n\n#define SSD01         \n#define SSD02         \n#define SSD03         \n#define SSD04         \n#define SSD05         \n#define SSD06         \n#define SSD07         \n#define SSD08         \n#define SSD09         \n#define SSD10     }\n    \n#define SSD11     return a.DISTSQR * 0.25;\n#define SSD12 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 SSA14 SSA15 SSA16 SSA17 SSA18 SSA19\n#define SSA_2 SSA20 SSA21 SSA22 SSA23 SSA24 SSA25 SSA26 SSA27 SSA28 SSA29\n#define SSA_3 SSA30 SSA31 SSA32 SSA33 SSA34 SSA35 SSA36 SSA37 SSA38 SSA39\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03 SSC04 SSC05 SSC06 SSC07 SSC08 SSC09\n\n#define SSD_0 SSD00 SSD01 SSD02 SSD03 SSD04 SSD05 SSD06 SSD07 SSD08 SSD09\n#define SSD_1 SSD10 SSD11 SSD12\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1 SSA_2 SSA_3\n#define SS_TERMINATING      SSB00\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSC_0\n#define SS_END              SSD_0 SSD_1\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_TERMINATING SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    vec2 centerUV = vec2(0.5);\n    vec2 centerTestCoord = centerUV * vec2(maxMipSize);\n    ivec2 centerTestIntCoord = floorToInt(centerTestCoord);\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    if(mouseUV == vec2(0) || mouseUV != clamp(mouseUV, vec2(0), vec2(1)))\n    {\n        mouseUV.x = sin(iTime) * 0.5 + 0.5;\n        mouseUV.y = cos(iTime * 1.618) * 0.5 + 0.5;\n    }\n    \n    vec2 mouseTestCoord = mouseUV * vec2(maxMipSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    bool mouseIsOccupied = isOccupied(mouseUV); \n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    \n    if(fragTestIntCoord == centerTestIntCoord)\n    {\n        float density = 0.;\n        int count = 0;\n        for(int i = maxMip-RECURSION_DEPTH; i <= maxMip; i++)\n        {\n            ivec2 mipSize = textureSize(iChannel0, i);\n            bool fragIsOccupied = containsEdge(false, ivec2(fragUV * vec2(mipSize)), i);   \n            bool fragIsOccupied2 = containsEdge(true, ivec2(fragUV * vec2(mipSize)), i);   \n\n            density += fragIsOccupied ? 1. : 0.;\n            density += !fragIsOccupied2 ? 1. : 0.;\n            count+=2;\n            \n            // Remove this to show all mip levels explored.\n            break;\n        }\n            \n        // Compress the range to 0-1\n        density /= 10. + density;\n        \n        density /= float(count) / (float(10 + count)); \n        //density = smoothstep(0., 1., density);\n        //density *= density;\n        \n        fragColor.rgb = hsv2rgb(vec3(density*density*density*density*2.0 + 0.5, 1.-density * 0.5, density* 0.5));\n    }\n    \n    float distSqrToSignChange = 100000.0;\n\n    if(containsEdge(mouseIsOccupied, centerTestIntCoord, maxMip))\n    {\n        SubSampleArgs a;\n        a.DISTSQR = distSqrToSignChange;\n        a.SAMPLECOORD = centerTestIntCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = mouseTestCoord;\n        IncreaseDepth(a);\n        distSqrToSignChange = SubSample\n        (\n            a,\n            mouseIsOccupied\n        );   \n    }\n         \n    drawCircle\n    (\n        mouseTestCoord,\n        fragTestCoord,\n        sqrt(distSqrToSignChange),\n        0.0035,\n        vec4(1, 1, 1, 1.0),\n        fragColor\n    );\n    \n    // Compress the range to 0-1\n    fragColor /= vec4(0.25) + fragColor;\n    fragColor = smoothstep(vec4(0), vec4(1), fragColor);\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\n\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\n\t\t\t\t\t\npublic class ComputeSubsampleCoordinates\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t}\n}\n*/", "cube_a_code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    \n    fragColor = texture(iChannel0, uv).r > 0.5 ? vec4(1) : vec4(0);\n}", "cube_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[829, 829, 888, 888, 1064], [1066, 1066, 1092, 1092, 1174], [9531, 9531, 9579, 9579, 9774], [9776, 9908, 9954, 9954, 10167], [10372, 10372, 10415, 10415, 10514], [10516, 10516, 10576, 10576, 10714]], "test": "untested"}
{"id": "dd23Wt", "name": "Rocket Simulation II", "author": "oneshade", "description": "Read the instructions in the Image tab.", "tags": ["2d", "physics", "flying", "rockets"], "likes": 28, "viewed": 371, "published": 3, "date": "1668394523", "time_retrieved": "2024-07-30T16:20:02.524021", "image_code": "/*\nq - fire upper left thruster\na - fire lower left thruster\ns - fire main (bottom) thruster\nd - fire lower right thruster\ne - fire upper right thruster\nspace - increase main thrust\n\nOr instead of q/a/s/d/e you can use the arrow keys.\nIf the arrow controls feel inverted to you,\nuncomment CONTROLS_INVERTED in the Common tab.\n\nTry and hit platforms!\n\nPro tip: to right the rocket after a crash landing,\ntry jostling the rocket with small pulses from the\nmain thruster and then catch it before it over\ncorrects with the auxiliary thrusters.\n\nOr just hit r to engage the emergency break :)\n*/\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Setup\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Load rocket state\n    vec4 stateBlock1 = load(iChannel0, ivec2(0, 0));\n    vec4 stateBlock2 = load(iChannel0, ivec2(1, 0));\n\n    vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n    float angle = stateBlock2.x, angVel = stateBlock2.y;\n    float score = stateBlock2.z, flag = stateBlock2.w;\n\n    // Camera zoom\n    float zoom = clamp(length(pos - INITIAL_POSITION) / 0.6, 1.0, 5.0);\n\n    // Reference frame\n    vec2 refUv = uv - aspectCorrect(REF_FRAME_POS, aspect);\n    if (abs(refUv.x) < 0.2 && abs(refUv.y) < 0.2) {\n        uv = refUv;\n    }\n\n    // Zoom out on the scene\n    else {\n        uv *= zoom;\n        unit *= zoom;\n    }\n\n    // Draw environment\n    vec2 envUv = uv + pos;\n\n    // Reference grid\n    drawSDF(abs(mod(envUv.x, 0.25) - 0.125), vec3(0.25));\n    drawSDF(abs(mod(envUv.y, 0.25) - 0.125), vec3(0.25));\n\n    vec3 envMaterial = TERRAIN_COLOR;\n    if (envUv.y > PLATFORM_OFFSET - PLATFORM_THICKNESS - 2.0 * unit) { // In the area populated with platforms\n        envMaterial = PLATFORM_COLOR; // Default platform color\n        float cell = round(envUv.x / PLATFORM_SPACING) * PLATFORM_SPACING;\n        for (int platform=0; platform < int(score); platform++) {\n            if (load(iChannel0, ivec2(platform, 1)).x == cell) { // Has been collided with\n                envMaterial = PLATFORM_HIT_COLOR; // Platform color after collision\n                break;\n            }\n        }\n    }\n\n    drawSDF(mapEnv(envUv), envMaterial);\n\n    // Thruster animation\n    vec2 rocketUv = Rotate2D(-angle) * uv;\n\n    // Draw upper left thruster flame\n    if (keypress(iChannel1, KEY_q)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[0].xy, thrusters[0].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower left thruster flame\n    if (keypress(iChannel1, KEY_a) || keypress(iChannel1, LEFT_CONTROL)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[1].xy, thrusters[1].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw main thruster flame\n    if (keypress(iChannel1, KEY_s) || keypress(iChannel1, MAIN_CONTROL)) {\n        float mainFlameSize = MAIN_FLAME_SIZE;\n        if (keypress(iChannel1, KEY_SPACE)) {\n            mainFlameSize = MAX_FLAME_SIZE;\n        }\n\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[2].xy, thrusters[2].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, mainFlameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, mainFlameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower right thruster flame\n    if (keypress(iChannel1, KEY_d) || keypress(iChannel1, RIGHT_CONTROL)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[3].xy, thrusters[3].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw upper right thruster flame\n    if (keypress(iChannel1, KEY_e)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[4].xy, thrusters[4].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw rocket\n    rocketUv = vec2(abs(rocketUv.x), rocketUv.y - 0.0243594417401);\n    drawSDF(sdIsosceles(rocketUv + vec2(0.0, 0.09), vec2(0.03, 0.08)), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-0.7) * (rocketUv - vec2(0.08, -0.06)), vec2(0.03, 0.08)), vec3(0.0, 1.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-1.8) * (rocketUv - vec2(0.07, 0.03)), vec2(0.03, 0.08)), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdIsosceles(rocketUv, vec2(0.08, 0.2)), vec3(1.0));\n\n    if (abs(refUv.x) > 0.2 || abs(refUv.y) > 0.2) {\n        // Reset zoom\n        uv /= zoom;\n        unit /= zoom;\n\n        // Draw velocity vector\n        vec2 vectorBase = normalize(vel) * 0.2;\n        drawSDF(sdVectorArrow(uv - vectorBase, 0.05 * vel), vec3(1.0));\n\n        // Show score\n        color = digitIn(color, vec3(1.0), uv - aspectCorrect(SCORE_POS, aspect), 100.0, score);\n    }\n\n    // Outline the reference frame\n    float frame = sdBox(refUv, vec2(0.2));\n    drawSDF(abs(frame) - 0.001, vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.1415926536\n#define EPS 0.001\n\n#define GRAVITY 0.6\n#define FRICTION 0.5\n\n#define KEY_q     81\n#define KEY_a     65\n#define KEY_s     83\n#define KEY_d     68\n#define KEY_e     69\n#define KEY_r     82\n#define KEY_SPACE 32\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n// Uncomment if the arrow controls feel inverted to you\n//#define CONTROLS_INVERTED\n\n// Alternate controls\n#ifdef CONTROLS_INVERTED\n#define LEFT_CONTROL KEY_RIGHT\n#define MAIN_CONTROL KEY_UP\n#define RIGHT_CONTROL KEY_LEFT\n#else\n#define LEFT_CONTROL KEY_LEFT\n#define MAIN_CONTROL KEY_DOWN\n#define RIGHT_CONTROL KEY_RIGHT\n#endif\n\n// GUI settings\n#define SCORE_POS vec2(-0.52, -0.442)\n#define REF_FRAME_POS vec2(0.359, -0.25)\n\n// Rocket settings\n#define MAIN_THRUST 15.0\n#define MAX_THRUST 25.0 // For main thruster\n#define AUXILIARY_THRUST 0.04 // Mainly for small angle corrections\n\n#define FLAME_SIZE 0.04 // Thruster flame length\n#define FLAME_RATIO 0.4 // Changes inner flame size\n#define MAIN_FLAME_SIZE 0.06\n#define MAX_FLAME_SIZE 0.09 // For main thruster\n\n#define MASS 5.0\n#define MOI 0.000144426534534\n\n#define INITIAL_POSITION vec2(0.0, 2.75)\n\n// Environment settings\n#define PLATFORM_WIDTH 0.65\n#define PLATFORM_THICKNESS 0.075\n#define PLATFORM_OFFSET 2.5\n#define PLATFORM_SPACING 1.5\n#define PLATFORM_VARIATION 20.0\n#define PLATFORM_COLOR vec3(0.6)\n#define PLATFORM_HIT_COLOR vec3(1.0, 0.8, 0.0)\n\n#define TERRAIN_HEIGHT 2.0\n#define TERRAIN_EXAGGERATION 4.0\n#define TERRAIN_ROUGHNESS 2\n#define TERRAIN_COLOR vec3(0.8, 0.5, 0.0)\n\n// Utilities\n#define load(buf, addr) texelFetch(buf, addr, 0)\n#define keypress(buf, key) (texelFetch(buf, ivec2(key, 0), 0).x > 0.5)\n#define aspectCorrect(p, aspect) vec2(p.x * aspect, p.y)\n\nvec2 perp(in vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    return p * mat2(up.y, -up.x, up);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat noise(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat snoise(in float p) {\n    return mix(noise(floor(p)), noise(ceil(p)), smoothstep(0.0, 1.0, fract(p)));\n}\n\nfloat fbm(in float p) {\n    float val = 0.0;\n    float noiseScale = 1.0;\n    float totalScale = 0.0;\n    for (int oct=0; oct < TERRAIN_ROUGHNESS; oct++) {\n        val += snoise(p) * noiseScale;\n        totalScale += noiseScale;\n        noiseScale *= 0.5;\n        p *= 2.0;\n    }\n\n    return val / totalScale;\n}\n\n// SDFs\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), 2.0 * q.y / 3.0 - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// Uncentered isosceles triangle\nfloat sdIsosceles2(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), q.y - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float mag = length(v);\n    p = axisAlign(p, v / mag);\n    return min(sdVerticalLine(p, mag), sdIsosceles(p - vec2(0.0, mag), vec2(0.02, 0.03)));\n}\n\n// Rocket geometry\nconst vec2[11] convexHull = vec2[11](\n    vec2( 0.0000000000,  0.1576927751),\n    vec2(-0.0891532073,  0.0896335932),\n    vec2(-0.1027853330,  0.0312027353),\n    vec2(-0.1201244039, -0.0367098193),\n    vec2(-0.0742338727, -0.0753628805),\n    vec2(-0.0300000000, -0.0923072249),\n    vec2( 0.0300000000, -0.0923072249),\n    vec2( 0.0742338727, -0.0753628805),\n    vec2( 0.1201244039, -0.0367098193),\n    vec2( 0.1027853330,  0.0312027353),\n    vec2( 0.0891532073,  0.0896335932)\n);\n\n// vec4(position, direction)\n// Listed in counterclockwise order from the upper left\nconst vec4[5] thrusters = vec4[5](\n    vec4(-0.0959692702,  0.0604181643, -0.9738476309,  0.2272020947),\n    vec4(-0.0971791383, -0.0560363499, -0.6442176872, -0.7648421873),\n    vec4( 0.0000000000, -0.0923072249,  0.0000000000, -1.0000000000),\n    vec4( 0.0971791383, -0.0560363500,  0.6442176872, -0.7648421873),\n    vec4( 0.0959692702,  0.0604181643,  0.9738476309,  0.2272020947)\n);\n\n// Environment distance\nfloat mapEnv(in vec2 p) {\n    float ground = p.y - TERRAIN_HEIGHT * pow(fbm(p.x), TERRAIN_EXAGGERATION);\n\n    // Randomly positioned platforms\n    float cell = round(p.x / PLATFORM_SPACING) * PLATFORM_SPACING;\n    p -= vec2(cell, PLATFORM_VARIATION * noise(cell) + PLATFORM_OFFSET);\n    float platforms = max(abs(p.x) - PLATFORM_WIDTH, abs(p.y) - PLATFORM_THICKNESS);\n\n    return min(ground, platforms);\n}\n\n// Rocket distance\nfloat mapRocket(in vec2 p) {\n    p = vec2(abs(p.x), p.y - 0.0243594417401);\n    float dist = sdIsosceles(p + vec2(0.0, 0.09), vec2(0.03, 0.08));\n    dist = min(dist, sdIsosceles(Rotate2D(-0.7) * (p - vec2(0.08, -0.06)), vec2(0.03, 0.08)));\n    dist = min(dist, sdIsosceles(Rotate2D(-1.8) * (p - vec2(0.07, 0.03)), vec2(0.03, 0.08)));\n    dist = min(dist, sdIsosceles(p, vec2(0.08, 0.2)));\n    return dist;\n}\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 3; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iAddr = ivec2(fragCoord);\n\n    // Initialize\n    if (iFrame == 0) {\n        if (iAddr == ivec2(0, 0)) fragColor.xy = INITIAL_POSITION;\n    }\n\n    // Update\n    if (iFrame > 0) {\n        if (iAddr.y < 2) { // Save calculations for the relevant pixels\n            // Load previous state\n            fragColor = texelFetch(iChannel0, iAddr, 0);\n            vec4 stateBlock1 = load(iChannel0, ivec2(0, 0));\n            vec4 stateBlock2 = load(iChannel0, ivec2(1, 0));\n\n            vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n            float angle = stateBlock2.x, angVel = stateBlock2.y;\n            float score = stateBlock2.z, flag = stateBlock2.w;\n            mat2 basis = Rotate2D(angle);\n\n            // Get the closest rocket vertex to the environment\n            // Note that even checking the full list of vertices is not enough\n            // but since we're being cheap, the convex hull is fine\n            vec2 contact = basis * convexHull[0] + pos;\n            float contactDist = mapEnv(contact);\n            for (int i=1; i < 11; i++) {\n                vec2 newContact = basis * convexHull[i] + pos;\n                float newContactDist = mapEnv(newContact);\n                if (newContactDist < contactDist) {\n                    contact = newContact;\n                    contactDist = newContactDist;\n                }\n\n                // In the rare case of a parallel edge/edge collision\n                // Really only occurs when everything is first initialized\n                if (abs(newContactDist - contactDist) < 1e-6) {\n                    contact = (contact + newContact) / 2.0;\n                }\n            }\n\n            // Align thrust vectors to the rocket's new orientation\n            vec4[5] orientedThrusters;\n            for (int i=0; i < 5; i++) {\n                orientedThrusters[i].xy = basis * thrusters[i].xy;\n                orientedThrusters[i].zw = basis * thrusters[i].zw;\n            }\n\n            // Linear and angular forces\n            vec2 force = vec2(0.0);\n            float torque = 0.0;\n\n            // Apply forces\n            force.y -= GRAVITY * MASS;\n\n            // Upper left thruster\n            if (keypress(iChannel1, KEY_q)) {\n                vec2 newForce = -orientedThrusters[0].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[0].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower left thruster\n            if (keypress(iChannel1, KEY_a) || keypress(iChannel1, LEFT_CONTROL)) {\n                vec2 newForce = -orientedThrusters[1].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[1].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Main thruster\n            if (keypress(iChannel1, KEY_s) || keypress(iChannel1, MAIN_CONTROL)) {\n                float mainThrust = MAIN_THRUST;\n                if (keypress(iChannel1, KEY_SPACE)) {\n                    mainThrust = MAX_THRUST;\n                }\n\n                vec2 newForce = -orientedThrusters[2].zw * mainThrust;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[2].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower right thruster\n            if (keypress(iChannel1, KEY_d) || keypress(iChannel1, RIGHT_CONTROL)) {\n                vec2 newForce = -orientedThrusters[3].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[3].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Upper right thruster\n            if (keypress(iChannel1, KEY_e)) {\n                vec2 newForce = -orientedThrusters[4].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[4].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Collision handling\n            if (contactDist < 0.0) {\n                float d0 = mapEnv(contact);\n                vec2 contactNormal = normalize(vec2(mapEnv(contact + vec2(EPS, 0.0)), mapEnv(contact + vec2(0.0, EPS))) - d0);\n                pos -= contactNormal * d0;\n                contact -= pos;\n\n                // Calculate force required to reflect contact point's velocity\n                // I'm not sure if this is correct, but it gives reasonable behavior\n                vec2 contactVel = vel + vec2(-contact.y, contact.x) * angVel;\n                mat2 sys = mat2(\n                    MOI / MASS + contact.y * contact.y, -contact.x * contact.y,\n                    -contact.x * contact.y, MOI / MASS + contact.x * contact.x\n                );\n\n                vec2 deltaV = FRICTION * reflect(contactVel, contactNormal) - contactVel;\n                vec2 collisionForce = inverse(sys) * (deltaV * MOI / iTimeDelta);\n\n                // Apply force\n                force += collisionForce;\n                torque += cross(vec3(contact, 0.0), vec3(collisionForce, 0.0)).z;\n\n                // Check for a platform collision\n                contact += pos;\n                float cell = round(contact.x / PLATFORM_SPACING) * PLATFORM_SPACING;\n                vec2 toPlatform = contact - vec2(cell, PLATFORM_VARIATION * noise(cell) + PLATFORM_OFFSET);\n                bool newPlatformCollision = abs(toPlatform.x) <= PLATFORM_WIDTH && abs(toPlatform.y) <= PLATFORM_THICKNESS;\n                if (newPlatformCollision) {\n                    // Check if this platform has already been collided with\n                    for (int platform=0; platform < int(score); platform++) {\n                        if (load(iChannel0, ivec2(platform, 1)).x == cell) {\n                            newPlatformCollision = false;\n                            break;\n                        }\n                    }\n                }\n\n                // New high score!\n                if (newPlatformCollision) {\n                    if (iAddr == ivec2(score, 1)) fragColor.x = cell; // Remember this platform\n                    score++;\n                }\n            }\n\n            // Emergency brake!\n            if (keypress(iChannel1, KEY_r)) {\n                force = vec2(0.0);\n                vel = vec2(0.0);\n                angle = 0.0;\n                angVel = 0.0;\n            }\n\n            // Simulation step\n            vel += force / MASS * iTimeDelta;\n            pos += vel * iTimeDelta;\n\n            angVel += torque / MOI * iTimeDelta;\n            angle += angVel * iTimeDelta;\n\n            // Store rocket state\n            if (iAddr == ivec2(0, 0)) fragColor = vec4(pos, vel);\n            if (iAddr == ivec2(1, 0)) fragColor = vec4(angle, angVel, score, flag);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd23Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[672, 672, 727, 740, 5513]], "test": "untested"}
{"id": "ms23Dd", "name": "Pixel Dist (OBSOLETE)", "author": "Hatchling", "description": "OBSOLETE, SEE: https://www.shadertoy.com/view/DdfSRr\nUsed multiple declarations to avoid the recursion limit.\n\n10 seconds to compile with 3 recursion steps.\nTakes 300+ seconds to compile with more than 4+ recursion depth levels, but runs FAST.", "tags": ["2d", "sdf", "distance", "field", "signed"], "likes": 3, "viewed": 153, "published": 3, "date": "1668385552", "time_retrieved": "2024-07-30T16:20:03.678933", "image_code": "// WARNING: Compilation times are slow with more than 3 levels of recursion.\n//          Currently with 3 levels it takes 10 seconds.\n//          4 levels of recursion takes 300+ seconds to compile!!\n//          But after compilation it is very fast!\n//          Increase recursion level at your own risk!\n\n// TODO: Perhaps if I make the recursive function smaller\n//       by moving most of the logic into other functions that it calls,\n//       it'll be easier for the compiler to parse.\n\n// Controls =================================\n// Mouse + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Orange Circle:    Distance of found cell.\n// Whtie Circle:     Final distance.\n\n\nconst int mipCount = 11;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\n\nvoid GetSubsampleCoords(bool xNeg, bool yNeg, bool absXGtAbsY, out ivec4 c01, out ivec4 c23)\n{\n    int r = 0x1B; // 00 10 01 11;\n    \n    if(xNeg)\n    {\n        const int xor = 0xAA; // 10 10 10 10\n        r = r ^ xor;\n    }\n    \n    if(yNeg)\n    {\n        const int xor = 0x55; // 01 01 01 01\n        r = r ^ xor;\n    }\n    \n    if(!absXGtAbsY)\n    {\n        const int xor = 0x3C; // 00 11 11 00\n        r = r ^ xor;\n    }\n    \n    const ivec4 c01_m = ivec4\n    (\n        0x80, // 10 00 00 00\n        0x40, // 01 00 00 00\n        0x20, // 00 10 00 00\n        0x10  // 00 01 00 00\n    );\n    \n    const ivec4 c01_s = ivec4\n    (\n        7,\n        6,\n        5, \n        4 \n    );\n    \n    const ivec4 c23_m = ivec4\n    (\n        0x08, // 00 00 10 00\n        0x04, // 00 00 01 00\n        0x02, // 00 00 00 10\n        0x01  // 00 00 00 01\n    );\n    \n    const ivec4 c23_s = ivec4\n    (\n        3, \n        2, \n        1,\n        0\n    );\n    \n    c01 = (ivec4(r) & c01_m) >> c01_s;\n    c23 = (ivec4(r) & c23_m) >> c23_s;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nfloat getMinDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 centerToPoint = point - squareCenter;\n    vec2 minOffset = clamp(centerToPoint, vec2(-0.5), vec2(0.5));\n    return lengthSqr(centerToPoint - minOffset);\n}\n\nconst vec4 DebugBoundsCheckColor    = vec4(0.0, 0.0, 1.0, 0.25);\nconst vec4 DebugEdgeCheckColor      = vec4(1.0, 0.0, 0.0, 0.25);\nconst vec4 DebugStackIncrementColor = vec4(0.0, 1.0, 1.0, 0.25);\nconst vec4 DebugStackLimitColor     = vec4(0.0, 1.0, 0.0, 0.5);\nconst vec4 DebugSubDistCloserColor  = vec4(1.0, 0.5, 0.0, 1.0);\nconst vec4 DebugSubDistFurtherColor = vec4(0.5, 1.0, 0.0, 1.0);\n\nconst int ErrorStackUnderflow = 0;\nconst int ErrorStackOverflow = 1;\nconst int ErrorInvalidState = 2;\n\nvoid drawCharacter(vec4 fontColor, in ivec2 fontElement, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(fontElement.x >= 16 || fontElement.y >= 16 || fontElement.x < 0 || fontElement.y < 0)\n        fontElement = ivec2(0);\n    \n    vec4 text = sampleFontElementColor(iChannel2, fragCoord, fontElement, fontColor);\n    \n    blend(text, fragColor);\n}\n\nvoid drawError(in int errorID, in int data, in vec2 fragCoord, inout vec4 fragColor)\n{\n    const vec4 ErrorStackUnderflowColor = vec4(1.0, 0.2, 0.0, 1.0);\n    const vec4 ErrorStackOverflowColor = vec4(1.0, 0.2, 0.2, 1.0);\n    const vec4 ErrorInvalidStateColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    ivec2 fontElement;\n    vec4 fontColor;\n    \n    switch(errorID)\n    {\n        case ErrorStackUnderflow:\n            fontElement = ivec2(1 + data, 9);\n            fontColor = ErrorStackUnderflowColor;\n            break;\n        case ErrorStackOverflow:\n            fontElement = ivec2(1 + data, 11);\n            fontColor = ErrorStackOverflowColor;\n            break;\n        case ErrorInvalidState:\n            fontElement = ivec2(1 + data, 11);\n            fontColor = ErrorInvalidStateColor;\n            break;\n    }\n    \n    if(fontElement.x >= 16 || fontElement.y >= 16 || fontElement.x < 0 || fontElement.y < 0)\n        fontElement = ivec2(0);\n    \n    vec4 text = sampleFontElementColor(iChannel2, fragCoord, fontElement, fontColor);\n    \n    blend(text, fragColor);\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) float name\n#define SSA00 (\n#define SSA01     float      distSqrToSignChange,\n#define SSA02     ivec2      samplingCoord, \n#define SSA03     int        mip, \n#define SSA04     vec2       testCoord,\n#define SSA05     in bool    testOccupied,\n#define SSA06     vec2       fragTestCoord,\n#define SSA07     vec2       originalFragCoord,\n#define SSA08     inout vec4 fragColor\n#define SSA09 )\n#define SSA10 {\n#define SSA11     mip -= 1;\n#define SSA12     distSqrToSignChange *= 4.0;\n#define SSA13     samplingCoord *= 2;\n#define SSA14     testCoord *= 2.0;\n#define SSA15     fragTestCoord *= 2.0;\n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA16     ivec2 subsampleCoords[4];\n#define SSA17     {\n#define SSA18         vec2 testToSample = vec2(samplingCoord + ivec2(1)) - testCoord;\n#define SSA19         bool xNeg = testToSample.x < 0.;\n#define SSA20         bool yNeg = testToSample.y < 0.;\n#define SSA21        bool absXGtAbsY = abs(testToSample.x) > abs(testToSample.y);\n#define SSA22        ivec4 c01, c23;\n#define SSA23        GetSubsampleCoords(xNeg, yNeg, absXGtAbsY, c01, c23);\n#define SSA24        subsampleCoords[0] = c01.xy;\n#define SSA25        subsampleCoords[1] = c01.zw;\n#define SSA26        subsampleCoords[2] = c23.xy;\n#define SSA27        subsampleCoords[3] = c23.zw;\n#define SSA28    }\n    \n                 // Go through subsamples from closest to furthest.\n#define SSA29    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA30    {\n#define SSA31        ivec2 subsamplingCoord = samplingCoord + subsampleCoords[iSub];\n#define SSA32        float subsampleDistSqr = getMinDistSqr(testCoord, subsamplingCoord);\n        \n#define SSA33        if(!(subsampleDistSqr < distSqrToSignChange))\n#define SSA34            continue;\n    \n#define SSA35        if(floorToInt(fragTestCoord) == subsamplingCoord)\n#define SSA36            fragColor += vec4(0.1,0,0,0);\n\n#define SSA37        if(!containsEdge(testOccupied, subsamplingCoord, mip))\n#define SSA38            continue;\n            \n#define SSA39        float temp =\n\n                     // Non recursive\n#define SSB00        subsampleDistSqr;\n\n                     // Recursive   \n#define SSR(name)    name                     \n#define SSC00        (\n#define SSC01            distSqrToSignChange, \n#define SSC02            subsamplingCoord,\n#define SSC03            mip,\n#define SSC04            testCoord,\n#define SSC05            testOccupied,\n#define SSC06            fragTestCoord,\n#define SSC07            originalFragCoord,\n#define SSC08            fragColor\n#define SSC09        );\n\n#define SSD00        distSqrToSignChange = min(distSqrToSignChange, temp);\n\n#define SSD01         drawCircle\n#define SSD02         (\n#define SSD03             testCoord,\n#define SSD04             fragTestCoord,\n#define SSD05             sqrt(temp),\n#define SSD06             0.01,\n#define SSD07             vec4(1.0, 0.5, 0.1, 1.0),\n#define SSD08             fragColor\n#define SSD09         );\n#define SSD10     }\n    \n#define SSD11     return distSqrToSignChange * 0.25;\n#define SSD12 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 SSA14 SSA15 SSA16 SSA17 SSA18 SSA19\n#define SSA_2 SSA20 SSA21 SSA22 SSA23 SSA24 SSA25 SSA26 SSA27 SSA28 SSA29\n#define SSA_3 SSA30 SSA31 SSA32 SSA33 SSA34 SSA35 SSA36 SSA37 SSA38 SSA39\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03 SSC04 SSC05 SSC06 SSC07 SSC08 SSC09\n\n#define SSD_0 SSD00 SSD01 SSD02 SSD03 SSD04 SSD05 SSD06 SSD07 SSD08 SSD09\n#define SSD_1 SSD10 SSD11 SSD12\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1 SSA_2 SSA_3\n#define SS_TERMINATING      SSB00\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSC_0\n#define SS_END              SSD_0 SSD_1\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_TERMINATING SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 3\nSS_DECLARE_TERMINATING(SubSample3)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    vec2 centerUV = vec2(0.5);\n    vec2 centerTestCoord = centerUV * vec2(maxMipSize);\n    ivec2 centerTestIntCoord = floorToInt(centerTestCoord);\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(maxMipSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    bool mouseIsOccupied = isOccupied(mouseUV); \n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    \n    if(fragTestIntCoord == centerTestIntCoord)\n    {\n        for(int i = maxMip-RECURSION_DEPTH; i <= maxMip; i++)\n        {\n            ivec2 mipSize = textureSize(iChannel0, i);\n            bool fragIsOccupied = containsEdge(false, ivec2(fragUV * vec2(mipSize)), i);   \n            bool fragIsOccupied2 = containsEdge(true, ivec2(fragUV * vec2(mipSize)), i);   \n\n            fragColor += fragIsOccupied ? vec4(0.1, 0.2, 0.5, 1) : vec4(0);\n            fragColor += !fragIsOccupied2 ? vec4(0.1, 0.2, 0.5, 1) : vec4(0);\n\n            \n            // Remove this to show all mip levels explored.\n            // (You'll have to change the colors a bit though.)\n            break;\n        }\n            \n        // Compress the range to 0-1\n        //fragColor /= vec4(1.0, 0.5, 0.25, 0.001) + fragColor;\n    }\n    \n    float distSqrToSignChange = 100000.0;\n\n    if(containsEdge(mouseIsOccupied, centerTestIntCoord, maxMip))\n    {\n        distSqrToSignChange = SubSample\n        (\n            distSqrToSignChange,\n            centerTestIntCoord, \n            maxMip, \n            mouseTestCoord,\n            mouseIsOccupied,\n            fragTestCoord,\n            fragCoord,\n            fragColor\n        );   \n    }\n         \n    drawCircle\n    (\n        mouseTestCoord,\n        fragTestCoord,\n        sqrt(distSqrToSignChange),\n        0.01,\n        vec4(1, 1, 1, 1.0),\n        fragColor\n    );\n    \n    // Compress the range to 0-1\n    fragColor /= vec4(0.25) + fragColor;\n    fragColor = smoothstep(vec4(0), vec4(1), fragColor);\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\n\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}", "cube_a_code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy; \n    \n    uv += vec2(0.1);\n    \n    fragColor = texture(iChannel0, uv).r > 0.7 ? vec4(1) : vec4(0);\n}", "cube_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[979, 979, 1038, 1038, 1214], [1216, 1216, 1242, 1242, 1324], [1327, 1327, 1421, 1421, 2349], [2351, 2483, 2529, 2529, 2742], [3235, 3235, 3334, 3334, 3585], [3587, 3587, 3673, 3673, 4654]], "test": "untested"}
{"id": "dsj3Dd", "name": "polygon by shortest distance", "author": "jonasfrey", "description": "finalllyyy!!!! yeey ", "tags": ["polygon"], "likes": 4, "viewed": 213, "published": 3, "date": "1668382749", "time_retrieved": "2024-07-30T16:20:04.449871", "image_code": "const float n_tau = 6.283185;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_cor_nor = (fragCoord.xy - iResolution.xy* 0.5) / iResolution.y;\n    vec2 o_mou_cor_nor = (iMouse.xy - iResolution.xy* 0.5) / iResolution.y;\n    \n    if(iMouse.w == 0.0){\n        o_mou_cor_nor = vec2(0.3);\n    }\n    float n_sides = 10.0*o_mou_cor_nor.x;\n    float n_dist_origin = length(vec2(0.0) - o_pix_cor_nor);\n    vec2 o_delta = vec2(0.0) - o_pix_cor_nor;\n    float n_angle_origin = atan(o_delta.x , o_delta.y)+(n_tau/2.0);\n    float n_angle_origin_nor = n_angle_origin / n_tau;\n    float n_radius = 0.4;\n    float n_dist_shortest = 1.0;\n    \n    float n_side_nor = floor(n_angle_origin_nor / (1.0/n_sides))*(1.0/n_sides);\n\n    float n_dist_origin_max = min(n_dist_origin,n_radius);\n    vec2 o_p1 = vec2(\n            sin(n_tau * n_side_nor)*n_dist_origin,\n            cos(n_tau * n_side_nor)*n_dist_origin\n    );\n    float n_dist1 = length(o_pix_cor_nor - o_p1);\n    vec2 o_p2 = vec2(\n            sin(n_tau * (n_side_nor+(1.0/n_sides)))*n_dist_origin,\n            cos(n_tau * (n_side_nor+(1.0/n_sides)))*n_dist_origin\n    );\n    float n_dist2 = length(o_pix_cor_nor - o_p2);\n    vec2 o_p3 = vec2(\n            sin(n_angle_origin)*n_radius,\n            cos(n_angle_origin)*n_radius\n    );\n    float n_dist3 = length(o_p3-o_pix_cor_nor);\n    float n_dist = min(n_dist1, n_dist2);\n\n    n_dist = min(n_dist, n_dist3);\n\n    \n    o_p1 = vec2(\n            sin(n_tau * n_side_nor)*n_radius,\n            cos(n_tau * n_side_nor)*n_radius\n    );\n    o_p2 = vec2(\n            sin(n_tau * (n_side_nor+(1.0/n_sides)))*n_radius,\n            cos(n_tau * (n_side_nor+(1.0/n_sides)))*n_radius\n    );\n    vec2 o_delta2 = o_p2-o_p1;\n    float n_m = o_delta2.y / o_delta2.x;\n    float n_q = -(n_m*o_p1.x) + o_p1.y;\n    \n    float n_x = o_pix_cor_nor.x;\n    float n_y = n_m * n_x + n_q; \n    float n_dist4 = abs(o_pix_cor_nor.y-n_y);\n    n_dist = min(n_dist, n_dist4);\n    \n    \n    \n    fragColor = vec4(sqrt(n_dist));\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsj3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 2015]], "test": "untested"}
{"id": "cdXSRn", "name": "Torusphere Accelerator (+ blog)", "author": "dracusa", "description": "Have you ever felt that time is elapsing faster and faster? Also, here's an excessively detailed post on how this thing works and on motion blur in general:\n\nhttps://www.osar.fr/notes/motionblur/", "tags": ["blur", "motionblur", "motion", "analytic", "tone", "shepard", "acceleration"], "likes": 66, "viewed": 1089, "published": 3, "date": "1668380373", "time_retrieved": "2024-07-30T16:20:05.582842", "image_code": "/*\nInfinite speed motion blur using volume ray casting.\n\nBlog post to go with it: https://www.osar.fr/notes/motionblur\n*/\n\n#define PI 3.14159265359\n\n// basic material, light and camera settings\n#define DIFFUSE .9\n#define SPEC .9\n#define REFLECT .05\nconst vec3 lightDir = normalize(vec3(-5, -6, -1));\n#define CAM_D 2.4\n#define CAM_H .75\n\n// marching iterations\n#define ITER 40\n#define SHADOW_ITER 20\n// marching step, which depends on the size of the bounding sphere\nfloat stepSz;\n// torus shape ratio = minor radius / major radius\n#define TOR_RATIO .38\n// speed for: time remapping; ball transition into orbit; object rotation\n#define TIMESCALE .015\n#define RAD_SPEED 100.\nconst float RT_RAD_SPEED = sqrt(RAD_SPEED);\nconst float MAX_SPEED = floor(30./(TIMESCALE*PI*2.)+.5)*PI*2.;\n// remapped time for large scale events\nfloat T;\n// cycle duration in remapped time\n// it depends on the torus ratio because the radiuses zoom into each other\nconst float C = log((1. + TOR_RATIO) / TOR_RATIO);\nconst float D = C * .5;\n// ball and torus speed, rotation and transformation matrix\nfloat balSpeed, balRot, torSpeed, torRot;\nmat2 balMat, torMat;\n// ball and torus size and cycle progression\nfloat balSz, torSz, balCycle, torCycle;\n// ball and torus motion blur amplification\nfloat balAmp, torAmp;\n// torus minor and major radius, with squared version\nvec2 tor, tor2;\n// constants for torus angle and ball normals\nfloat torCst, balCst;\n// density and normity x-fades, ball orbit radius, cosmetic adjustments\nfloat densXf, normXf, balOrbit, torNormSz, strobe;\n\n// by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy+33.33);\n\treturn fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n// by iq: https://iquilezles.org/articles/filterableprocedurals/\nfloat filteredGrid(vec2 p, float scale, vec2 dpdx, vec2 dpdy) {\n\tfloat iscale = 1./scale;\n\tfloat N = 60.0*scale;\n\tp *= iscale;\n\tvec2 w = max(abs(dpdx), abs(dpdy))*iscale;\n\tvec2 a = p + 0.5*w;\n\tvec2 b = p - 0.5*w;\n\tvec2 i = (floor(a)+min(fract(a)*N,1.0)-\n\t\tfloor(b)-min(fract(b)*N,1.0))/(N*w);\n\treturn (1.0-i.x*.6)*(1.0-i.y*.6);\n}\n\n// by iq: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n\tfloat h = max(k-abs(a-b), 0.0)/k;\n\treturn min(a, b) - h*h*k*(1.0/4.0);\n}\n\nmat2 rot2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\n// 2-point sphere intersection\nvec2 sphIntersect2(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif(h<0.0) return vec2(-1.0, -1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h);\n}\n\n// antiderivative of the cosine shutter function which is:\n// (1-cos((x-t1) 2 PI / (t2-t1)))/(t2-t1) if t1<x<t2\n// 0 otherwise\nfloat iCosShutter(float x, float t1, float t2) {\n\tif (x < t1) return 0.;\n\tif (x > t2) return 1.;\n\tfloat d = 1./(t2 - t1);\n\tx -= t1;\n\treturn x*d - sin(2.*PI*x*d)/(2.*PI);\n}\n\n// motion blurred density = integral of { object presence * window function }\nfloat cosMotionBlur(float obj1, float obj2) {\n\t// Shutter time interval. Should include the frameStart, but it's\n\t// moved to the pixel coordinates for easier wrap management.\n\tfloat shut1 = -1./60.;\n\tfloat shut2 = 1./60.;\n\t// integral of the shutter function from obj1 to obj2\n\treturn iCosShutter(obj2, shut1, shut2) - iCosShutter(obj1, shut1, shut2);\n}\n\n// Take a slice at depth y. In polar coordinates, at radius r,\n// find the polar angle of the ball surface.\n// Returns 0 if r is entirely outside the ball.\n// Returns -1 if r is entirely inside the ball.\nfloat ballPolarSurface(float r, float y) {\n\tfloat rad = balSz*balSz - y*y;\n\tif (rad <= 0.) return 0.;\n\trad = sqrt(rad);\n\tif (r <= rad-balOrbit) return -1.;\n\tfloat div = (balOrbit*balOrbit+r*r-rad*rad)/(2.*r*balOrbit);\n\tif (abs(div) > 1.) return 0.;\n\treturn acos(div);\n}\n\n// motion-blurred ball density\nfloat ballDensity(vec3 p, float speed) {\n    p.xz *= balMat;\n\tp.z = abs(p.z);\n\tvec2 pol = vec2(length(p.xz), atan(p.z, p.x));\n\tfloat bA = ballPolarSurface(pol.x, p.y);\n\tif (bA == -1.) return 1.;\n\t// Time interval for the object presence at this pixel.\n\tfloat obj1 = (pol.y-bA)/speed;\n\tfloat obj2 = (pol.y+bA)/speed;\n\treturn cosMotionBlur(obj1, obj2);\n}\n\n// ball \"normity\", pseudo distance field to calculate normals\nfloat ballNormity(vec3 p) {\n    p.xz *= balMat;\n\tp.z = abs(p.z);\n\tvec2 pol = vec2(length(p.xz), atan(p.z, p.x));\n\tpol.y = max(0., pol.y-balCst);\n\tp.x = pol.x*cos(pol.y);\n\tp.z = pol.x*sin(pol.y);\n\treturn length(p-vec3(balOrbit, 0., 0.))-balSz;\n}\n\n// Take a slice at depth z. In polar coordinates, at radius r,\n// find the polar angle of the torus surface.\n// Returns 0 if r is entirely outside the torus.\n// Returns -1 if r is entirely inside the torus.\nfloat spiricPolarSurface(float r, float z) {\n\tfloat r2 = r*r;\n\tfloat z2 = z*z;\n\tfloat sum = torCst-2.*tor2.x*z2-2.*tor2.x*r2-2.*tor2.y*z2+2.*tor2.y*r2+z2*z2+2.*z2*r2+r2*r2;\n\tif (sum < 0.) return -1.;\n\tfloat sq = sqrt(sum)/(2.*tor.y*r);\n\tif (abs(sq) > 1.) return 0.;\n\treturn acos(sq);\n}\n\n// motion-blurred density of a half torus (a macaroni)\nfloat halfTorusDensity(vec2 pol, float z, float speed) {\n\tfloat da = spiricPolarSurface(pol.x, z);\n\tif (da == 0.) return 0.;\n\tif (da == -1.) return 1.;\n\t// Time interval for the object presence at this pixel.\n\tfloat obj1 = (pol.y-da)/speed;\n\tfloat obj2 = (pol.y+da)/speed;\n\treturn cosMotionBlur(obj1, obj2);\n}\n\n// motion-blurred torus density\nfloat torusDensity(vec3 p3d, float speed) {\n    p3d.xy *= torMat;\n\tvec2 pol = vec2(length(p3d.xy), atan(p3d.y, p3d.x));\n\tpol.y = mod(pol.y, PI*2.)-PI;\n\tfloat da = halfTorusDensity(pol, p3d.z, speed);\n\tpol.y = mod(pol.y + PI*2., PI*2.)-PI;\n\tfloat da2 = halfTorusDensity(pol, p3d.z, speed);\n\tif (da == 0. && da2 == 0.) return 0.;\n\tif (da == -1. || da2 == -1.) return 1.;\n\treturn min(1., da+da2);\n}\n\n// torus \"normity\", pseudo distance field to calculate normals\nfloat torusNormity(vec3 p, float speed) {\n    p.xy *= torMat;\n\tfloat shell = abs(length(p)-tor.y)-tor.x*.3;\n\tvec2 q = vec2(length(p.xz)-tor.y,p.y);\n\tfloat torus = length(q)-tor.x;\n\treturn -smin(speed*.002-torus, .1-shell, 0.1);\n}\n\n// combined density and normity\nfloat density(vec3 p) {\n\tfloat ball = ballDensity(p, balSpeed)*balAmp;\n\tfloat torus = torusDensity(p, torSpeed)*torAmp;\n    return mix(ball, torus, densXf);\n}\nfloat normity(vec3 p) {\n    return mix(\n\t\tballNormity(p),\n    \ttorusNormity(p*torNormSz, torSpeed*.5),\n\t\tnormXf);\n}\nvec3 getNormal(vec3 p) {\n\tfloat d = normity(p);\n\tvec2 e = vec2(.001, 0);\n\tvec3 n = d - vec3(\n\t\tnormity(p-e.xyy),\n\t\tnormity(p-e.yxy),\n\t\tnormity(p-e.yyx));\n\treturn normalize(n);\n}\n\n// Because we're raycasting translucent stuff, this is called up to 28x per px\n// so let's keep it short\nvec3 material(vec3 normal, vec3 rayDir) {\n\tfloat diff = max(dot(normal, -lightDir), .05);\n\tvec3 reflectDir = -lightDir - 2.*normal * dot(-lightDir, normal);\n\tfloat spec = max(dot(rayDir, reflectDir), 0.);\n\treturn vec3(.8,.9,1.) * (diff * DIFFUSE + spec * REFLECT);\n}\n\n// render torusphere by volume raycasting\nvec4 march(vec3 ro, vec3 rd, float marchPos, float marchBack) {\n\tfloat totMul = strobe*stepSz/0.05;\n\tvec4 col = vec4(0.);\n\tmarchPos -= stepSz * hash14(vec4(rd*4000., iTime*100.));\n\tint nMats = 0;\n\tfor(int i=0; i<ITER; i++) {\n\t\tvec3 pos = ro + rd * marchPos;\n\t\tfloat d = clamp(density(pos)*totMul, 0., 1.);\n\t\tif(d > .002) {\n\t\t\td = d*d*.5;\n\t\t\tfloat a2 = (1.-col.a)*d;\n\t\t\tvec3 n = getNormal(pos);\n\t\t\tcol += vec4(material(n, rd)*a2, a2);\n\t\t\tif (col.a > 0.95) break;\n\t\t\tif (nMats++ > 28) break;\n\t\t}\n\t\tmarchPos += stepSz;\n\t\tif (marchPos > marchBack) break;\n\t}\n\tif (col.a > 0.) col.rgb /= col.a;\n\treturn col;\n}\n\n// render ground shadow by volume raycasting without material\nfloat shadowMarch(vec3 ro, vec3 rd, float marchPos, float marchBack) {\n\tfloat ret = 0.;\n\tfloat shadowStep = stepSz*2.;\n\tfloat totMul = .47*strobe*shadowStep/0.05;\n\tmarchPos -= shadowStep * hash14(vec4(ro*4000., iTime*100.));\n\tfor(int i=0; i<SHADOW_ITER; i++) {\n\t\tvec3 pos = ro + rd * marchPos;\n\t\tfloat d = clamp(density(pos)*totMul, 0., 1.);\n\t\tif(d > .002) {\n\t\t\td = d*d*.9;\n\t\t\tret += (1.-ret)*d;\n\t\t\tif (ret > 0.95) break;\n\t\t}\n\t\tmarchPos += shadowStep;\n\t\tif (marchPos > marchBack) break;\n\t}\n\treturn min(1., ret);\n}\n\n// very inefficiently speed up the boring parts\nfloat retime(float t) {\n\tt *= TIMESCALE;\n\tfloat s = .5+1.7*t*PI*2./D;\n\ts = sin(s+sin(s+sin(s+sin(s)*0.3)*0.5)*0.75);\n\treturn s*.06+t*1.7;\n}\n\n// ball<->torus crossfade used separately by density and normity\nfloat getXf(float x) {\n\tx = (abs(mod(x-(D/4.), C)-D)/D-.5)*2.+.5;\n\t// return smoothstep(0, 1, x)\n\tx = 2.*clamp(x, 0., 1.)-1.;\n\treturn .5+x/(x*x+1.);\n}\n\n// The entire scene is necessarily zooming out. The ground texture deals with\n// that by crossfading different scales.\nconst float GRID_CYCLE = log(64.);\nvec3 grid(vec2 pt, vec2 dx, vec2 dy, float phase, float t) {\n\tfloat freq = exp(-mod(t+GRID_CYCLE*phase, GRID_CYCLE))*7.;\n\tfloat amp = cos(PI*2.*phase+t*PI*2./GRID_CYCLE)*-.5+.5;\n\tfloat g = filteredGrid(pt, freq, dx, dy)*amp;\n\treturn vec3(g,g,g);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// set all the globals...\n\tT = retime(iTime+25.); // consider a modulo here\n\tbalCycle = mod(T, C);\n\ttorCycle = mod(T+D, C);\n\n\t// size of the bounding sphere for marching and step size\n\tfloat boundSz = exp(-min(torCycle, 5.*(C-mod(T-D, C))));\n\tstepSz = boundSz/20.;\n\n\t// the ball/torus appear constant size and the camera appears to zoom out\n\t// in the code the camera distance is fixed and the objects are shrinking\n\tbalSz = exp(-balCycle-D);\n\ttorSz = exp(-torCycle);\n\n\t// the rotation is (theoretically) the integral of the speed, we need both\n\tbalSpeed = .04*MAX_SPEED*(cos(T*PI*2./C)+1.);\n\ttorSpeed = .04*MAX_SPEED*(cos((T+D)*PI*2./C)+1.);\n\tbalRot = MAX_SPEED*(sin(T*PI*2./C)/(PI*2./C)+T)/C;\n\ttorRot = MAX_SPEED*(sin((T+D)*PI*2./C)/(PI*2./C)+T)/C;\n\tif (balCycle<D) {\n\t\tbalRot = MAX_SPEED*(floor(T/C+.5)*C+D)/C;\n\t\tbalSpeed = 0.;\n\t}\n\tif (torCycle<D) {\n\t\ttorRot = MAX_SPEED*(floor((T+D)/C+.5)*C)/C;\n\t\ttorSpeed = 0.;\n\t}\n\tbalMat = rot2d(balRot);\n\ttorMat = rot2d(torRot);\n\n\t// torus minor and major radius and their squares\n\ttor = vec2(torSz/(1.+1./TOR_RATIO), torSz/(1.+TOR_RATIO));\n\ttor2 = tor*tor;\n\n\t// precalculate constants for the spiric angle and ball normals\n\ttorCst = tor2.x*tor2.x + tor2.y*tor2.y - 2.*tor2.x*tor2.y;\n\tbalCst = 2.*balSpeed*smoothstep(30., 40., balSpeed);\n\tfloat bx = balCst*.037;\n\tbalCst = (balCst+bx*bx*bx)*.004;\n\n\t// ball's orbital radius\n\tbalOrbit = clamp(balCycle-D, 0., 2.*RT_RAD_SPEED/RAD_SPEED)-RT_RAD_SPEED/RAD_SPEED;\n\tbalOrbit = .5+RT_RAD_SPEED*balOrbit/(balOrbit*balOrbit*RAD_SPEED+1.);\n\tbalOrbit *= tor.y;\n\n\t// ball<->torus crossfade: the normity precedes the density slightly\n\t// this smoothens the max speed -> zero speed illusion\n\tdensXf = getXf(T);\n\tnormXf = getXf(T+0.06);\n\n\t// motion blur amplification is what makes this work\n\tbalAmp = 1.+balSpeed*balSpeed*.00013;\n\ttorAmp = 1.5+torSpeed*torSpeed*.00015;\n\ttorNormSz = max(1., 8.*(torCycle-.76));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t// the strobe effect simulates overlap between fast spin and slow spin\n\tstrobe = 1.-.1*(sin(iTime*83.+PI*smoothstep(.4, .6, uv.x))+1.)*(sin(2.2+T*PI*2./D)+1.)*.5;\n\n\t// camera\n\tfloat side = cos(CAM_H)*CAM_D;\n\tfloat camT = iTime*0.05+PI*.75;\n\tvec3 ro = vec3(sin(camT)*side, sin(CAM_H)*CAM_D, cos(camT)*side); // camera position (ray origin)\n\tvec3 ta = vec3(0., 0., 0.); // camera target\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 2.*ww);\n\n\t// this starting color taints the entire scene (unintentional but why not)\n\tvec3 col = vec3(0.33, 0.18, 0.1);\n\n\t// the ground plane\n\tif (rd.y < 0.) {\n\t\tvec3 groundPt = ro + rd*(-(ro.y+.8) / rd.y);\n\t\tvec2 g2d = groundPt.xz;\n\t\tvec2 dx = dFdx(g2d);\n\t\tvec2 dy = dFdy(g2d);\n\t\t// the ground texture zooms out by crossfading different scales\n\t\tcol += grid(g2d, dx, dy, 0., T)/3.;\n\t\tcol += grid(g2d, dx, dy, 1./3., T)/3.;\n\t\tcol += grid(g2d, dx, dy, 2./3., T)/3.;\n\t\tfloat sqDist = dot(g2d, g2d);\n\t\tcol *= 2./(sqDist*.5*1.5+1.)-1.2/(sqDist*1.5*1.5+1.);\n\t\t// are we in the shadow of the bounding sphere?\n\t\tvec2 sphInter = sphIntersect2(groundPt, -lightDir, vec4(0.,0.,0.,boundSz));\n\t\tif (sphInter != vec2(-1., -1.)) {\n\t\t\t// march the torusphere to draw the shadow\n\t\t\tfloat shad = shadowMarch(groundPt, -lightDir, sphInter.x, sphInter.y);\n\t\t\tcol *= 1.-shad*.7;\n\t\t}\n\t}\n\n\t// the sky (only visible in interactive version)\n\tfloat up = dot(rd, vec3(0.,1.,0.));\n\tcol = mix(col, vec3(0.33, 0.18, 0.1)*.7, 1.-smoothstep(0., .02, abs(up)+.003));\n\tcol = mix(col, vec3(0.,0.,.1), smoothstep(0., .5, up));\n\n\t// finally render the torusphere\n\tvec2 sphInter = sphIntersect2(ro, rd, vec4(0.,0.,0.,boundSz));\n\tif (sphInter != vec2(-1., -1.)) {\n\t\tvec4 ts = march(ro, rd, sphInter.x, sphInter.y);\n\t\tcol = mix(col, ts.rgb, ts.a);\n\t}\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1550, 1608, 1631, 1631, 1763], [1765, 1830, 1893, 1893, 2159], [2161, 2209, 2248, 2248, 2322], [2324, 2324, 2345, 2345, 2412], [2414, 2445, 2493, 2493, 2678], [2680, 2807, 2855, 2855, 2978], [2980, 3058, 3103, 3233, 3412], [3414, 3618, 3660, 3660, 3887], [3889, 3920, 3960, 3960, 4272], [4274, 4336, 4363, 4363, 4580], [4582, 4789, 4833, 4833, 5074], [5076, 5131, 5187, 5187, 5440], [5442, 5474, 5517, 5517, 5869], [5871, 5934, 5975, 5975, 6163], [6165, 6197, 6220, 6220, 6355], [6356, 6356, 6379, 6379, 6471], [6472, 6472, 6496, 6496, 6649], [6651, 6756, 6797, 6797, 7022], [7024, 7066, 7129, 7129, 7669], [7671, 7733, 7803, 7803, 8246], [8248, 8296, 8319, 8319, 8435], [8437, 8502, 8524, 8524, 8652], [8808, 8808, 8868, 8868, 9055], [9057, 9057, 9112, 9139, 13039]], "test": "untested"}
{"id": "Ds23Wd", "name": "a pie chart", "author": "jonasfrey", "description": "pie\nthe smallest distance to 3 points is calculated that way the pieces of pie look like circle segments", "tags": ["chart"], "likes": 2, "viewed": 216, "published": 3, "date": "1668378007", "time_retrieved": "2024-07-30T16:20:06.343808", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n       \n       vec2 o_pix_coo_nor = (fragCoord.xy-(iResolution.xy/2.0)) / iResolution.y; \n       vec2 o_mou_coo_nor = (iMouse.xy-(iResolution.xy/2.0)) / iResolution.y; \n\n\n       \n       float[] a_n_value =  float[](\n        300.0,\n        200.0,\n        150.0,\n        400.0,\n        200.0,\n        350.0,\n        150.0,\n        250.0,\n        50.0\n        );\n        \n        float n_val_sum = 0.0;\n        for(float n_i = 0.0; n_i < float(a_n_value.length()); n_i+=1.){\n            n_val_sum+=a_n_value[int(n_i)];\n        }\n\n        float n_tau = 6.283185;\n        float n_val_nor_start = 0.0;\n        float n_val_nor_end = 0.0;\n        vec2 o_delta = vec2(0.0,0.0)-o_pix_coo_nor;\n        for(float n_i = 0.0; n_i < float(a_n_value.length()); n_i+=1.){\n            float n_val_nor = a_n_value[int(n_i)] / n_val_sum;\n            n_val_nor_end += n_val_nor; \n            float n_tau = 6.2831;\n            float n_angle = atan(o_delta.y , o_delta.x)+(n_tau/2.0);\n            float n_angle_norm = n_angle / n_tau;\n\n            if(\n                n_angle_norm > n_val_nor_start\n                &&\n                n_angle_norm < n_val_nor_end\n            ){\n            \n                float n_radius = length(vec2(0.0,0.0)-o_pix_coo_nor);\n                float n_radius_max = 0.5;\n                \n                vec2 o_p1 = vec2(\n                    cos((n_val_nor_start)*n_tau)*n_radius, \n                    sin((n_val_nor_start)*n_tau)*n_radius\n                );\n                float n_dist1 = length(o_p1 - o_pix_coo_nor);\n                \n                vec2 o_p2 = vec2(\n                    cos((n_val_nor_end)*n_tau)*n_radius, \n                    sin((n_val_nor_end)*n_tau)*n_radius\n                );\n                float n_dist2 = length(o_p2 - o_pix_coo_nor);\n                \n                vec2 o_p3 = vec2(\n                    cos((n_angle_norm)*n_tau)*n_radius_max, \n                    sin((n_angle_norm)*n_tau)*n_radius_max\n                );\n                float n_dist3 = length(o_p3 - o_pix_coo_nor);\n                float n_dist_min = min(n_dist1, n_dist2);\n                n_dist_min = min(n_dist_min, n_dist3);\n                \n                fragColor = vec4((mod(n_dist_min+iTime*0.1,0.1)/0.1));\n            }\n            n_val_nor_start = n_val_nor_end;\n\n        }\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds23Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "md2GWd", "name": "Dihedral Symmetry SDF", "author": "mla", "description": "Drawing a polygon, or anything else with dihedral symmetry.", "tags": ["simple", "sdf", "polygon", "dihedral"], "likes": 11, "viewed": 214, "published": 3, "date": "1668373184", "time_retrieved": "2024-07-30T16:20:07.100784", "image_code": "// Dihedral Symmetry, mla, 2022\n// Started as a little exercise in drawing polygons, trying to\n// keep everything as simple as possible, but I couldn't resist\n// adding some bells & whistles.\n\nconst float PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Signed distance from p segment qr. Positive distance for\n// points on the left of the line looking from q to r.\nfloat ssegment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  k = clamp(k,0.0,1.0);\n  vec2 closestpoint = k*r;\n  float dist = distance(p,closestpoint);\n  vec2 normal = vec2(-r.y,r.x);\n  float s = dot(p,normal) >= 0.0 ? 1.0 : -1.0;\n  return s*dist;\n}\n\n\nfloat polydist(float N, vec2 p, inout float t) {\n    float phi = PI/N; // angle of half sector\n    float theta = atan(p.x,-p.y);// negative y-axis is theta = 0\n    theta = mod(theta+phi,2.0*phi)-phi;\n    //theta /= 2.0*phi; theta -= round(theta); theta *= 2.0*phi; // Equivalent\n    theta = abs(theta); // Mirror symmetry\n    // With dihedral symmetry, the closest point is always in the\n    // fundamental region, so can limit attention just to there\n    // for finding the SDF.\n    vec2 p1 = length(p)*vec2(cos(theta),sin(theta));\n    float k = 0.618; // Just a constant for drawing\n    //k = abs(tan(0.125*PI*iTime)); k *= k; t = 1.0; // Alternative animation\n    vec2 q0 = 1.0/k*vec2(cos(phi),sin(phi)), q1 = k*vec2(cos(phi),0);\n    return ssegment(p1,q0,mix(q0,q1,t));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 2.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //float N = iMouse.x <= 0.0 ? 7.0 : floor(10.0*iMouse.x/iResolution.x) + 3.0;\n    //float N = floor(mod(0.25*iTime,10.0)) + 3.0;\n    float t = fract(0.25*iTime);\n    t = 6.0*t;\n    float N = 0.25*iTime;\n    float N1 = N+1.0;\n    N = floor(mod(N,10.0))+3.0;\n    N1 = floor(mod(N1,10.0))+3.0;\n    if (t > 5.0) N = mix(N,N1,smoothstep(0.0,1.0,t-5.0));\n    t = min(t,6.0-t);\n    t = clamp(t-1.0,0.0,1.0);\n    t = smoothstep(0.0,1.0,t);\n    float d = polydist(N,p,t);\n    float px = fwidth(p.x);\n    vec3 col = vec3(0.75+0.25*cos(20.0*PI*abs(d)));\n    if (t == 1.0 && d < 0.0) col.b = 0.25;\n    col = mix(vec3(1,0,0),col,vec3(smoothstep(0.0,px,abs(d)-0.01)));\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2GWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 265, 265, 291], [293, 408, 448, 448, 687], [690, 690, 738, 738, 1465], [1467, 1467, 1519, 1519, 2335]], "test": "untested"}
{"id": "md23Dt", "name": "Mandala flowers interactive", "author": "timmaffett", "description": "CCO: Mandala flowers\nSmoooth kaleidoscope + abstract shape + colors\nI just added mouse interactivity - all credit to @mrange for creating this great shader.\nadd iMouse terms to allow pattern movement and scrub colors cycle (and removed hexagon lines) -tmm", "tags": ["2s", "mandala"], "likes": 40, "viewed": 624, "published": 3, "date": "1668372258", "time_retrieved": "2024-07-30T16:20:07.859754", "image_code": "// CCO: Mandala flowers\n//  Smoooth kaleidoscope + abstract shape + colors\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define NO_HEXAGON_LINES\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract (sin(a)*43758.5453123);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r) {\n#ifndef NO_HEXAGON_LINES\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n#else\n  return 1.0;\n#endif\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0-exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float aa = iz*2.0/RESOLUTION.y;\n  float  n = modPolar(p, 3.0);\n\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  s1.z += -PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  vec3 hsv = vec3(fract(s.z/PI+TIME*0.5), 0.9, 1.0);\n  return vec4(hsv2rgb(hsv)*s.x, s.y);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n\n  float d;\n  float a = TAU*TIME*((iMouse.x!=0. && iMouse.z>=0.) ? iMouse.x/iResolution.x/10.0 : 1.0)/300.0;\n  float aY = TAU*TIME*((iMouse.y!=0. && iMouse.z>=0.) ? iMouse.y/iResolution.x/10.0 : 1.0)/300.0;\n  p.x += 10.0*vec2(sin(a), sin(sqrt(0.5)*a)).x;\n  p.y += 10.0*vec2(sin(aY), sin(sqrt(0.5)*aY)).y;\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  float hd = hex(hp.yx, 0.5);\n  hd = abs(hd) - 2.0*aa;\n  vec2 cp = hp;\n  float h = hash(np);\n  float hh = fract(137.0*h);\n  float sm = mix(mix(0.025, 0.25, hh), 0.025, h);\n  float rep = 2.0*floor(mix(8.0, 30.0, h));\n  float cn = smoothKaleidoscope(cp, sm, rep);\n  cp *= ROT(TIME*((iMouse.x!=0. && iMouse.z>=0.) ? max(iMouse.x,iMouse.y)/iResolution.x/50.0 : 1.0)*0.2+TAU*h);\n  \n  vec4 ccol = clogo(cp, 0.6, d);\n  vec3 gcol = hsv2rgb(vec3(h, 0.8, 4.0));\n  vec3 col  = vec3(0.0);\n  col += gcol*exp(-50.0*max(d, 0.0));\n  col = mix(col, vec3(0.2), smoothstep(aa, -aa, hd));\n  col = mix(col, ccol.xyz, ccol.w);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md23Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 378, 398, 398, 481], [635, 635, 657, 657, 803], [1231, 1231, 1251, 1251, 1271], [1273, 1371, 1407, 1407, 1517], [1519, 1519, 1550, 1550, 1576], [1578, 1672, 1700, 1700, 1936], [1938, 2039, 2067, 2166, 2493], [2495, 2581, 2630, 2630, 3032], [3034, 3117, 3153, 3197, 3468], [3470, 3553, 3592, 3592, 3677], [3679, 3767, 3806, 3806, 3835], [3837, 3925, 3955, 3955, 3982], [3984, 4070, 4115, 4115, 4269], [4271, 4359, 4381, 4381, 4425], [4427, 4515, 4536, 4536, 4581], [4583, 4671, 4732, 4732, 4945], [4947, 4947, 4971, 4971, 5070], [5072, 5072, 5102, 5102, 5338], [5340, 5340, 5373, 5373, 5911], [5913, 5913, 5951, 5951, 6223], [6225, 6225, 6245, 6245, 6273], [6275, 6275, 6317, 6317, 6728], [6730, 6730, 6759, 6759, 7756], [7758, 7758, 7813, 7813, 8002]], "test": "untested"}
{"id": "ddj3Wt", "name": "Mipmap Overlap Tracking Test", "author": "oneshade", "description": "Mipmap experiment.", "tags": ["test", "tracking", "gpmipmap"], "likes": 3, "viewed": 151, "published": 3, "date": "1668363746", "time_retrieved": "2024-07-30T16:20:08.669589", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float a = length(uv - 0.25 * vec2(cos(iTime), sin(iTime))) - 0.1 * (cos(10.0 * uv.x) + sin(10.0 * uv.y)) - 0.25;\n    float b = length(uv - 0.25 * vec2(2.0 * cos(3.0 * iTime), 0.5 * sin(iTime))) - 0.25;\n    if (a < 0.0) fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    if (b < 0.0) fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n\n    uv = fragCoord / iResolution.xy;\n    fragColor += texture(iChannel1, uv);\n\n    vec4 bufA = texture(iChannel0, uv, 100.0);\n    vec2 pos = bufA.xy / bufA.w;\n    if (length(uv - pos) < 0.01) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float weight = length(texture(iChannel0, uv).rgb);\n    fragColor = vec4(uv * weight, 0.0, weight);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float a = length(uv - 0.25 * vec2(cos(iTime), sin(iTime))) - 0.1 * (cos(10.0 * uv.x) + sin(10.0 * uv.y)) - 0.25;\n    float b = length(uv - 0.25 * vec2(2.0 * cos(3.0 * iTime), 0.5 * sin(iTime))) - 0.25;\n    fragColor = vec4(step(max(a, b), 0.0));\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddj3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 698]], "test": "untested"}
{"id": "csjGDd", "name": "Forest Train Ride", "author": "dr2", "description": "Ride through forest and lakes in summer and winter; train  track based on generalized hexagonal Truchet tiles (mouseable, multiple views).", "tags": ["landscape", "tree", "truchet", "snow", "train"], "likes": 26, "viewed": 342, "published": 3, "date": "1668356934", "time_retrieved": "2024-07-30T16:20:09.673904", "image_code": "// \"Forest Train Ride\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/* See \"Truchet's Train\" for more info. */\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN 17\n#define N_CAR 4\n\nvec4 cPath[PLEN], carPos[N_CAR], snowCol;\nvec3 qHit, sunDir, tOff;\nvec2 cIdB, cIdS, cMidB, cMidS, wlBase;\nfloat dstFar, tCur, angRFac, hgSizeB, hgSizeS, tEnd[PLEN + 1], tLen, trVel, cDir, cType,\n   trSzFac, viaWid, viaHt, watHt, csOcc;\nint idObj;\nbool trees, snow;\nconst int idGrnd = 1, idWat = 2, idVia = 3, idRail = 4, idFenc = 5, idTrnk = 6, idLvs = 7,\n   idPost = 8, idCar = 9, idCon = 10, idWhl = 11, idFLamp = 12, idBLamp = 13;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{ // (from \"Truchet's Train\", with signed distance)\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = sign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. || \n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nfloat CarDf (vec3 p, float dMin, float dir)\n{  // (from \"Alpine Express\")\n  vec3 q, qq;\n  float d, s, ds;\n  q = p;\n  qq = q;\n  s = 0.25;\n  if (q.z * dir > 0.5) {\n    ds = -0.25 * (q.z * dir - 0.5);\n    s += ds;\n    qq.y -= ds;\n  }\n  d = 0.9 * PrRoundBoxDf (qq, vec3 (0.3, s, 1.55), 0.4);\n  DMINQ (idCar);\n  q = p;\n  q.xz = abs (q.xz);\n  q.z = abs (q.z - wlBase.y);\n  q -= vec3 (wlBase.x, -0.6, 0.2);\n  d = PrCylDf (q.yzx, 0.15, 0.08);\n  DMINQ (idWhl);\n  q = p;\n  q.z = (dir == 0.) ? abs (q.z) - 1.8 : q.z + 1.8 * dir;\n  d = PrCylDf (q.xzy, 0.3, 0.5);\n  DMINQ (idCon);\n  if (dir > 0.) {\n    q = p;\n    q.yz -= vec2 (-0.25, 1.9);\n    d = PrCylDf (q, 0.1, 0.1);\n    DMINQ (idFLamp);\n  } else if (dir < 0.) {\n    q = p;\n    q.x = abs (q.x) - 0.2;\n    q.yz -= vec2 (-0.25, -1.9);\n    d = PrCylDf (q, 0.08, 0.1);\n    DMINQ (idBLamp);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar / trSzFac;\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2Cs (q.xz, sin (carPos[k].w + vec2 (0.5 * pi, 0.)));\n    dMin = CarDf (q, dMin, (k > 0) ? ((k < N_CAR - 1) ? 0. : -1.) : 1.);\n  }\n  return dMin * trSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd, float dstCut)\n{\n  float dHit, d, eps;\n  eps = 0.001;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < eps * max (1., angRFac * dHit) || dHit > dstCut) break;\n    dHit += d;\n  }\n  if (d >= eps * max (1., angRFac * dHit)) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nfloat GrndHt (vec2 p)\n{\n  float f, a, aSum;\n  p *= 0.25;\n  f = 0.;\n  a = 1.;\n  aSum = 0.;\n  for (int j = 0; j < 3; j ++) {\n    f += a * Noisefv2 (p);\n    aSum += a;\n    a *= 0.4;\n    p *= 2.5;\n  }\n  return 2.2 * f / aSum;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  float dMin, d, dt, rc, ac, gHt, dh;\n  bool onTrk;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidB) / hgSizeB;\n    dh = hgSizeB * HexEdgeDist (q.xz);\n    cm3 = TruchSDist (q.xz);\n    dt = hgSizeB * abs (cm3.x);\n    rc = abs (cm3.y);\n    ac = 18. * cm3.z;\n    onTrk = (cType <= 2. && rc != 0. && OnTrk (q.xz));\n    d = q.y - watHt;\n    DMIN (idWat);\n    gHt = GrndHt (p.xz);\n    d = q.y - gHt;\n    if (onTrk && gHt > viaHt - 0.1) d = min (SmoothMax (d, -0.2 - dot (vec2 (dt - viaWid,\n       0.2 * gHt - q.y), sin (0.1 * pi + vec2 (0.5 * pi, 0.))), 0.1), q.y - (viaHt - 0.1));\n    DMIN (idGrnd);\n    if (onTrk) {\n      d = max (max (abs (dt) - viaWid, q.y - viaHt), - (length (vec2 (abs (fract (9. *\n         rc * ac + 0.5) - 0.5) / 3., q.y) - vec2 (0., min (q.y, viaHt - 0.3))) - 0.12));\n      DMIN (idVia);\n      d = PrRoundBox2Df (vec2 (dt - wlBase.x * trSzFac, q.y - viaHt - 0.01),\n         vec2 (0.005, 0.01), 0.003);\n      DMIN (idRail);\n      d = min (length (vec2 (dt - viaWid + 0.03, q.y - viaHt - 0.12)) - 0.008,\n         max (PrRoundBox2Df (vec2 (dt - viaWid + 0.03, (fract (9. * rc * ac + 0.5) -\n         0.5) / 3.), vec2 (0.007, 0.001), 0.001), abs (q.y - viaHt - 0.06) - 0.06));\n      DMIN (idFenc);\n      if (cm3.y < 0.) {\n        q = vec3 (dt - 0.23, q.y - viaHt - 0.4, dh);\n        d = min (max (length (q.xz) - 0.012, q.y), PrSphDf (q, 0.03));\n        DMIN (idPost);\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd, float dstCut)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeB;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeB));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      BConf ();\n    }\n    d = BObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps * max (1., angRFac * dHit) || dHit > dstCut) break;\n  }\n  if (d >= eps * max (1., angRFac * dHit)) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      BConf ();\n    }\n    h = BObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > hgSizeB) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid SConf ()\n{\n  vec2 r;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  r = Hashv2v2 (73. * cIdS + 1.1);\n  tOff.xz = 0.2 * sqrt3 * hgSizeS * (0.5 + 0.5 * r.x) * sin (2. * pi * r.y + vec2 (0.5 * pi, 0.));\n  tOff.y = r.x + r.y;\n}\n\nvoid SBConf ()\n{\n  vec2 s, u;\n  u = cMidS + tOff.xz;\n  cIdB = PixToHex (u / hgSizeB);\n  BConf ();\n  s = (u - cMidB) / hgSizeB;\n  csOcc = (hgSizeB * abs (TruchSDist (s).x) < 0.9 || GrndHt (cMidS) < watHt + 0.1) ? 0. :\n     0.01 + 0.99 * Hashfv2 (17.11 * cIdS);\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  if (csOcc > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidS) / hgSizeS;\n    q.xz -= tOff.xz;\n    h = 0.15 + 0.15 * tOff.y;\n    q.y -= h + GrndHt (cMidS);\n    d = max (length (q.xz) - 0.05, q.y - h);\n    DMIN (idTrnk);\n    q.y -= h + 0.55;\n    d = PrConCapsDf (q.xzy, sin (0.09 * pi + vec2 (0.5 * pi, 0.)), 0.18, 0.35);\n    DMIN (idLvs);\n  }\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd, float dstCut)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeS;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeS));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    SBConf ();\n    d = SObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps * max (1., angRFac * dHit) || dHit > dstCut) break;\n  }\n  if (d >= eps * max (1., angRFac * dHit)) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    SBConf ();\n    if (csOcc > 0.) {\n      h = SObjDf (p);\n      sh = min (sh, smoothstep (0., 0.1 * d, h));\n      d += h;\n    } else d += 0.1 * hgSizeS;\n    if (sh < 0.05 || d > 2. * hgSizeS) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 CarCol ()\n{\n  vec4 col4;\n  col4 = vec4 (0.7, 0., 0., 0.3);\n  if (idObj == idCar) {\n    col4 = (abs (qHit.y - 0.22) < 0.26) ? vec4 (0.3, 0.3, 0.5, 0.3) :\n       ((abs (abs (qHit.y - 0.22) - 0.28) < 0.02) ? vec4 (0.4, 0.4, 0.8, 0.3) : col4);\n  } else if (idObj == idCon) {\n    col4 *= 0.8;\n  } else if (idObj == idWhl) {\n     col4 = (length (qHit.yz) < 0.07) ? vec4 (0.2, 0.2, 0.2, 0.1) :\n        vec4 (0.6, 0.6, 0.6, 0.2);\n  } else if (idObj == idFLamp) {\n    if (qHit.z > 0.08) col4 = vec4 (1., 1., 0., -1.);\n  } else if (idObj == idBLamp) {\n    if (qHit.z < -0.08) col4 = vec4 (1., 0., 0., -1.);\n  }\n  return col4;\n}\n\nvec4 GrndViaCol (vec3 p, vec3 vn, inout vec2 vf)\n{\n  vec4 col4;\n  vec3 cm3;\n  vec2 w;\n  float dt, rc, ac;\n  bool onTrk;\n  w = (p.xz - cMidB) / hgSizeB;\n  cm3 = TruchSDist (w);\n  dt = hgSizeB * abs (cm3.x);\n  rc = abs (cm3.y);\n  ac = 18. * abs (cm3.z);\n  if (idObj == idGrnd) {\n    col4 = snow ? snowCol : vec4 (0., 0.7, 0., 0.) * (0.6 + 0.4 * Fbm2 (4. * p.xz));\n    onTrk = (cType <= 2. && rc != 0. && OnTrk (w));\n    if (onTrk) {\n      if (dt < 2.) col4 = mix ((snow ? snowCol : vec4 (0.5, 0.55, 0.5, 0.) * (0.97 +\n         0.03 * sin (64. * pi * p.y))), col4, smoothstep (0.6, 0.9, vn.y));\n      if (dt < viaWid + 0.05 && abs (p.y - viaHt + 0.1) < 0.01) col4 = snow ?\n         snowCol : vec4 (0.5, 0.55, 0.5, 0.);\n    }\n    if (trees && csOcc > 0. && length ((p.xz - cMidS) / hgSizeS - tOff.xz) < 0.06) col4 *= 0.8;\n    vf = vec2 (16., 1.);\n  } else if (idObj == idVia) {\n    col4 = (snow && p.y > viaHt - 0.01 && dt < viaWid - 0.01) ? snowCol :\n       vec4 (0.6, 0.4, 0.1, 0.1);\n    if (p.y > viaHt - 0.01 && dt < 0.2) {\n      if (! snow) col4 = mix (col4, vec4 (0.6, 0.6, 0.5, 0.), smoothstep (0., 0.01, 0.22 - dt));\n      if (dt < 0.15 && step (0.4, abs (fract (20. * rc * ac + 0.5) - 0.5)) > 0.)\n         col4 = vec4 (0.5, 0.4, 0.3, 0.);\n    } else col4 *= 0.8 + 0.2 * step (0.05, abs (fract (32. * p.y + 0.5) - 0.5));\n    vf = vec2 (64., 1.);\n  }\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn, inout vec2 vf)\n{\n  vec4 col4;\n  if (idObj == idGrnd || idObj == idVia) {\n    col4 = GrndViaCol (ro, vn, vf);\n  } else if (idObj == idWat) {\n    col4 = vec4 (0.6, 0.6, 0.7, 0.);\n  } else if (idObj == idTrnk) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n    vf = vec2 (32., 1.);\n  } else if (idObj == idLvs) {\n    col4 = vec4 (0.4, 0.7, 0.1, 0.) * (1.1 - 0.3 * csOcc);\n    if (snow) col4 = mix (col4, snowCol, smoothstep (-0.8, -0.4, vn.y));\n    else col4 = mix (col4, vec4 (0.9, 0.9, 0., 0.1), step (0.7, Fbm3 (64. * ro.xzy)));\n    vf = vec2 (16., 2.);\n  } else if (idObj == idFenc) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n  } else if (idObj == idPost) {\n    col4 = (ro.y < viaHt + 0.37) ? vec4 (0.8, 0.8, 0.9, 0.2) : vec4 (1., 1., 0.4, -1.);\n  } else if (idObj == idRail) {\n    col4 = vec4 (0.7, 0.7, 0.75, 0.1);\n  } else if (idObj >= idCar && idObj <= idBLamp) {\n    col4 = CarCol ();\n  }\n  return col4;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (4. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rs, rdd;\n  vec2 vf;\n  float dstObj, dstObjB, dstObjS, dstObjNR, dstCut, sh, reflFac;\n  int idObjB, idObjS;\n  bool isLit;\n  reflFac = 0.;\n  dstObjNR = 0.;\n  snowCol = vec4 (0.9, 0.9, 0.95, 0.1);\n  vf = vec2 (0.);\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstCut = dstFar;\n    if (trees) {\n      dstObjS = SObjRay (ro, rd, dstCut);\n      dstCut = min (dstCut, dstObjS);\n      idObjS = idObj;\n    } else dstObjS = dstFar;\n    dstObjB = BObjRay (ro, rd, dstCut);\n    dstCut = min (dstCut, dstObjB);\n    idObjB = idObj;\n    dstObj = ObjRay (ro, rd, dstCut);\n    if (min (dstObjB, dstObjS) < min (dstObj, dstFar)) {\n      if (dstObjB < dstObjS) {\n        dstObj = dstObjB;\n        idObj = idObjB;\n      } else {\n        dstObj = dstObjS;\n        idObj = idObjS;\n      }\n    }\n    if (k == 0 && dstObj < dstFar && idObj == idWat) {\n      ro += dstObj * rd;\n      rd = reflect (rd, VaryNf (4. * ro, vec3 (0., 1., 0.), 0.1));\n      ro += 0.01 * rd;\n      dstObjNR = dstObj;\n      reflFac = 0.2;\n    } else break;\n  }     \n  isLit = false;\n  if (min (dstObjB, dstObjS) < dstObj) {\n    if (dstObjB < dstObjS) {\n      dstObj = dstObjB;\n      idObj = idObjB;\n    } else {\n      dstObj = dstObjS;\n      idObj = idObjS;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjB) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      BConf ();\n      vn = BObjNf (ro);\n    } else if (dstObj == dstObjS) {\n      cIdS = PixToHex (ro.xz / hgSizeS);\n      SConf ();\n      SBConf ();\n      vn = SObjNf (ro);\n    } else {\n      vn = ObjNf (ro);\n    }\n    col4 = ObjCol (ro, vn, vf);\n    if (idObj == idCar) {\n      rdd = reflect (rd, vn);\n      reflFac = (abs (qHit.y - 0.22) < 0.26) ? 0.6 : 0.2;\n    }\n    if (col4.a >= 0.) {\n      rs = ro + 0.01 * vn;\n      sh = min (ObjSShadow (rs, sunDir), BObjSShadow (rs, sunDir));\n      if (trees) sh = min (sh, SObjSShadow (rs, sunDir));\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      isLit = true;\n    } else {\n      col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    vn = vec3 (0., 1., 0.);\n    col4 = 0.8 * vec4 (0., 0.8, 0., 0.);\n    sh = 1.;\n    isLit = true;\n  } else {\n    col = SkyCol (rd);\n  }\n  if (isLit) {\n    col = col4.rgb * (0.3 + 0.1 * max (- dot (sunDir, vn), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    col = mix (col, SkyCol (rd), 1. - exp (min (0., 1. - 5. * (dstObjNR + dstObj) / dstFar)));\n  }\n  if (reflFac > 0.) col = mix (0.9 * col, SkyCol (rdd), reflFac);\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  3\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd, pAv;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, pc[3];\n  float el, az, zmFac, asp, sr, cGap, t, nc;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  hgSizeB = 16.;\n  hgSizeS = 1.;\n  watHt = 0.7;\n  viaWid = 0.3;\n  viaHt = 1.1;\n  trSzFac = 0.2;\n  SetPath ();\n  trees = true;\n  snow = (uv.x / asp > -1.+ 2. * SmoothBump (0.25, 0.75, 0.01, fract (0.02 * (tCur - 10.))));\n  cGap = 0.74 * trSzFac;\n  wlBase = vec2 (0.5, 0.9);\n  trVel = 0.2;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  pAv = vec3 (0.);\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    t = (tCur + 30.) * trVel - float (k) * cGap;\n    for (int j = VAR_ZERO; j < 3; j ++)\n       pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * wlBase.y * trSzFac : 0.));\n    carPos[k].xz = pc[0];\n    carPos[k].y = viaHt + 0.9 * trSzFac;\n    pAv += carPos[k].xyz;\n    vd.xy = pc[2] - pc[1];\n    carPos[k].w = 0.5 * pi - atan (vd.y, vd.x);\n  }\n  nc = float (N_CAR);\n  pAv /= nc;\n  t = (tCur + 30.) * trVel;\n  angRFac = 1.;\n  if (vuId == 0 || vuId == 3) {\n    ro.xz = EvalPPos (t - ((vuId == 0) ? nc + 2. :  -3.) * cGap);\n    ro.x += 0.01;\n    ro.y = viaHt + 1.;\n    vd = normalize (((vuId == 0) ? carPos[N_CAR - 2].xyz : carPos[1].xyz) - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += asin (vd.y);\n    el = clamp (el, -0.2 * pi, 0.15 * pi);\n    zmFac = 3.;\n    dstFar = 12. * hgSizeB;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 40., (-3. * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x += 1.6 * hgSizeB;\n    az += pi / 3.;\n    el -= 0.15 * pi;\n    el = clamp (el, -0.4 * pi, -0.1 * pi);\n    zmFac = 5.;\n    dstFar = 30. * hgSizeB;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 20., (-1.5 * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x -= 1.5 * hgSizeB;\n    vd = normalize (pAv - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 40.;\n    angRFac = 0.1;\n    dstFar = 30. * hgSizeB;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 1.5, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjGDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1704, 1704, 1725, 1725, 1748], [1750, 1750, 1776, 1826, 2810], [2812, 2812, 2833, 2833, 3480], [3482, 3482, 3499, 3499, 4344], [4346, 4346, 4371, 4371, 5023], [5025, 5025, 5070, 5098, 5873], [5875, 5875, 5897, 5897, 6202], [6204, 6204, 6251, 6251, 6537], [6539, 6539, 6560, 6560, 6815], [6817, 6817, 6854, 6854, 7109], [7111, 7111, 7126, 7126, 7835], [7837, 7837, 7860, 7860, 8060], [8062, 8062, 8085, 8085, 9544], [9546, 9546, 9594, 9594, 10893], [10895, 10895, 10917, 10917, 11173], [11175, 11175, 11213, 11213, 11630], [11632, 11632, 11647, 11647, 11852], [11854, 11854, 11870, 11870, 12115], [12117, 12117, 12140, 12140, 12541], [12543, 12543, 12591, 12591, 13905], [13907, 13907, 13929, 13929, 14185], [14187, 14187, 14225, 14225, 14708], [14710, 14710, 14726, 14726, 15332], [15334, 15334, 15384, 15384, 16704], [16706, 16706, 16753, 16753, 17638], [17640, 17640, 17663, 17663, 17826], [17828, 17828, 17863, 17863, 20534], [20554, 20554, 20610, 20610, 24473], [24475, 24475, 24521, 24521, 24568], [24570, 24570, 24617, 24617, 24664], [24666, 24666, 24699, 24699, 24726], [24728, 24728, 24770, 24770, 24821], [24823, 24823, 24878, 24878, 25144], [25146, 25146, 25170, 25170, 25400], [25402, 25402, 25426, 25426, 25486], [25488, 25488, 25516, 25516, 25596], [25598, 25598, 25620, 25620, 25647], [25649, 25649, 25671, 25671, 25698], [25700, 25700, 25722, 25722, 25760], [25762, 25762, 25784, 25784, 25822], [25824, 25824, 25869, 25869, 25961], [25963, 25963, 26008, 26008, 26046], [26048, 26048, 26105, 26105, 26188], [26190, 26190, 26226, 26226, 26432], [26434, 26434, 26464, 26464, 26577], [26579, 26579, 26610, 26610, 26674], [26708, 26708, 26732, 26732, 26792], [26794, 26794, 26818, 26818, 26930], [26932, 26932, 26956, 26956, 27099], [27101, 27101, 27126, 27126, 27312], [27314, 27314, 27339, 27339, 27564], [27566, 27566, 27587, 27587, 27742], [27744, 27744, 27765, 27765, 27920], [27922, 27922, 27951, 27951, 28163], [28165, 28165, 28204, 28204, 28456]], "test": "untested"}
{"id": "Dd2GWd", "name": "colorize fields", "author": "jonasfrey", "description": "colorize", "tags": ["colorize"], "likes": 3, "viewed": 158, "published": 3, "date": "1668352836", "time_retrieved": "2024-07-30T16:20:10.478752", "image_code": "\nvec3 f_o_color_colorized_distance_modsin(\n    float n_dist_norm, \n    float n_repetitions \n){\n    float n_tau = 6.2831;\n    return vec3(sin(n_tau*n_dist_norm*n_repetitions)*0.5+0.5);\n}\n\nvec3 f_o_color_colorized_distance_modlin(\n    float n_dist_norm, \n    float n_repetitions \n){\n    float n_mod = 1.0/n_repetitions;\n    float n_dist_mod = (mod(n_dist_norm, n_mod)/n_mod);\n    \n    return vec3(n_dist_mod);\n}\n\nvec3 f_o_rgb_converted_from_hsl( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 f_o_color_colorized_distance_colorspectrum(\n    float n_dist_norm\n){\n\n    return f_o_rgb_converted_from_hsl(\n        vec3(n_dist_norm, 0.5, 0.5)\n    );\n}\nvec3 f_o_color_colorized_distance_colorsaturation(\n    float n_dist_norm\n){\n    return f_o_rgb_converted_from_hsl(vec3(0,n_dist_norm, 0.5));\n}\n\nvec3 f_o_color_smoothstep(\n    float n_dist_norm, \n    float n_min, \n    float n_max\n){\n    float n_range = n_max - n_min; \n    if(n_dist_norm > n_min && n_dist_norm < n_max){\n        float n_dist_in_range_norm = (n_dist_norm - n_min) / n_range;\n        \n        return f_o_rgb_converted_from_hsl(vec3(n_dist_in_range_norm, 0.5 ,0.5));\n    }\n    \n    return vec3(n_dist_norm);\n}\n\nvec3 f_o_color_switch(\n    float n_dist_norm, \n    float n_switch\n){\n    if(n_dist_norm > n_switch){\n        return vec3(1.0, 0.0,0.0);\n    }\n    return vec3(0.0,1.0,0.0);\n}\nvec3 f_o_color_smoothswitch(\n    float n_dist_norm, \n    float n_switch\n){\n    float n_range = 1.0 - n_switch;\n    float n_d_norm = n_dist_norm / n_range;\n    if(n_dist_norm > n_switch){\n        n_range = 1.0 - n_range;\n        n_d_norm = (n_dist_norm-n_switch) / n_range;\n    }\n    return f_o_rgb_converted_from_hsl(vec3(1./3.,n_d_norm, n_d_norm));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_pix_coo_nor = fragCoord.xy/iResolution.y;\n    vec2 o_mou_coo_nor = iMouse.xy/iResolution.xy;\n    \n    vec2 o_p_res = vec2(3.0, 3.0);\n    vec2 o_p_bigger = o_pix_coo_nor * o_p_res;\n    vec2 o_p_floor = floor(o_p_bigger);\n    vec2 o_p_fract = fract(o_p_bigger);\n    float n_index_center = o_p_floor.y * o_p_res.x + o_p_floor.x;\n\n\n    float n_dist = length(o_p_fract-0.5);\n    float n_dist_norm = n_dist / (1.0/o_p_res.x);\n    n_dist_norm = sin(n_dist_norm*6.2831+iTime)*0.5+0.5;\n    fragColor = vec4(n_dist_norm);\n\n\n    vec3[] a_o_color = vec3[](\n        vec3(sqrt(n_dist_norm)),\n        vec3(n_dist_norm),\n        vec3(f_o_color_colorized_distance_colorspectrum(n_dist_norm)),\n        vec3(f_o_color_colorized_distance_modlin(n_dist_norm, 10.0)),\n        vec3(f_o_color_colorized_distance_modsin(n_dist_norm, 10.0)),\n        vec3(f_o_color_colorized_distance_colorsaturation(n_dist_norm)),\n        vec3(f_o_color_smoothstep(n_dist_norm, 0.3, 0.35)),\n        vec3(f_o_color_switch(n_dist_norm,0.5)),\n        vec3(f_o_color_smoothswitch(n_dist_norm, 0.5))\n    );\n    fragColor = vec4( a_o_color[int(n_index_center)],1.0);\n\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2GWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 94, 94, 185], [187, 187, 280, 280, 409], [411, 411, 457, 457, 600], [602, 602, 675, 675, 760], [761, 761, 836, 836, 903], [905, 905, 992, 992, 1283], [1285, 1285, 1353, 1353, 1458], [1459, 1459, 1533, 1533, 1811]], "test": "untested"}
{"id": "DdjGWd", "name": "2D vector field visualizer", "author": "lomateron", "description": "write your function to graph in tab [Common]", "tags": ["animation", "graph", "plot", "realtime", "visual"], "likes": 9, "viewed": 240, "published": 3, "date": "1668349196", "time_retrieved": "2024-07-30T16:20:11.312523", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rd = 1./iResolution.xy;\n    vec2 u = vR*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m =    (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float d = 0.; \n    for(float i=.5; i<bM; ++i){\n    for(float j=.5; j<bT; ++j){\n        vec4 t = texture(iChannel0, vec2(i,j*6.)*rd);\n        vec2 a = t.xy-u;\n        d += float(dot(a,a)<.0003*vR*t.w*bZ);\n    }}\n    fragColor = vec4(d); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2  u2 = vec2(0,u.y!=.5);\n    vec4  t = texture(iChannel0, (u-u2)/iResolution.xy);\n    vec2  a = vectorField2D(t.xy);\n    vec2  b = t.xy-a;\n    float z = t.w;\n    if(dot(b,b)<.000001||dot(a,a)>vR*vR){z-= iTimeDelta*2.;}\n    else                                {z+= iTimeDelta*2.;}\n                                         z = min(z,1.);\n    if(iFrame==0 || z<0.)\n    {\n         a = fract(cos(dot(u,vec2(1.111,9.999))+iTime+7.777)\n                   *vec2(4567.1234, 8765.2345));\n         a = (a*2.-1.)*vR;\n         z = .0;\n    }\n                fragColor = vec4(a,0,z);\n    if(u.y!=.5){fragColor = t;}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define bM 300. //max balls in screen\n#define bT 3.   //balls tail length\n#define bZ 1.   //size of balls\n#define vR 1.   //visual range from -vR to vR\nvec2 vectorField2D(vec2 p)\n{\n    vec2 v = p.yx*vec2(-1,1);  //calculate vector\n    return p + v*.01;          //update position\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjGWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 456]], "test": "untested"}
{"id": "csjGWt", "name": "generation", "author": "Kolya142", "description": "noise generation\n3d: https://cineshader.com/view/csjGWt", "tags": ["generation"], "likes": 0, "viewed": 2396, "published": 3, "date": "1668336662", "time_retrieved": "2024-07-30T16:20:12.140309", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv+(iDate.w/3.);\n    float n = noise(p*3.);\n    vec3 col;\n    \n    if (n < .1) {\n        col = vec3(.2, .2, .8);\n    }\n    else {\n        if (n < .3) {\n            col = vec3(.8, .7, .2);\n        }\n        else {\n            if (n < .7) {\n                col = vec3(.2, .8, .2);\n            }\n            else {\n                col = vec3(.8, .7, .86);\n            }\n        }\n    }\n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = vec4(col,n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [89, 89, 109, 109, 318], [319, 319, 376, 426, 950]], "test": "untested"}
{"id": "dsS3Wd", "name": "Graphic Design Experiment 3", "author": "yasuo", "description": "Graphic Design Experiment 3", "tags": ["graphicdesign", "cineshader"], "likes": 31, "viewed": 2539, "published": 3, "date": "1668330389", "time_retrieved": "2024-07-30T16:20:12.985051", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Skew(a,b) mat2(1.0,tan(a),tan(b),1.0)\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define SymdirX(p) mod(floor(p).x,2.)*2.-1.\n#define SymdirY(p) mod(floor(p).y,2.)*2.-1.\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat thunderIcon(vec2 p){\n    float dir = SymdirY(p);\n    p.x = abs(p.x)-0.17;\n    vec2 prevP2 = p;\n    p.y+=iTime*0.15*dir;\n    p.y = mod(p.y,0.1)-0.05;\n    vec2 prevP = p;\n    \n    vec2 size = vec2(0.01,0.04);\n    float a = radians(-25.);\n    \n    p.x+=0.008;\n    p.y-=0.035;\n    float d = B(p,size);\n    p.x-=0.01;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p.x-=0.008;\n    p.y+=0.035;\n    a = radians(-25.);\n    float d2 = B(p,size);\n    p.x+=0.01;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n    return abs(d)-0.0005;\n}\n\nfloat arrow(vec2 p){\n    float dir = SymdirY(p);\n    p.x = abs(p.x)-0.05;\n    vec2 prevP = p;\n    \n    p.y+=(0.1*iTime)*dir;\n    \n    p.y=mod(p.y,0.07)-0.035;\n    p.y+=0.025;\n    if(dir == 1.){\n        p.y-=0.05;\n    }\n    p.y*=dir*-1.;\n    float a = radians(60.);\n    p.x = abs(p.x)-0.1;\n    float d = dot(p,vec2(cos(a),sin(a)));\n    p.y+=0.03;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    d = max(-d2,d);\n    p = prevP;\n    \n    d = max(abs(p.x)-0.04,d);\n    \n    return abs(d)-0.0005;\n}\n\nfloat arrowItem (vec2 p){\n    vec2 prevP = p;\n    float dist = 0.16;\n    p.x = abs(p.x)-dist;\n    p*=SkewX(radians(45.));\n    float d = B(p,vec2(0.04,0.01));\n    \n    p = prevP;\n    p.x = abs(p.x)-dist;\n    p-=vec2(-0.04,0.07);\n    p*=SkewY(radians(45.));\n    float d2 = B(p,vec2(0.01,0.07));\n    d = abs(min(d,d2))-0.0005;\n    \n    p =  prevP;\n    p.y-=iTime*0.23;\n    p.y = mod(p.y,0.3)-0.15;\n\n    p.x = abs(p.x)-dist;\n    p-=vec2(-0.04,0.0);\n    p*=SkewY(radians(45.));\n    d2 = B(p,vec2(0.01,0.1));\n    p = prevP;\n    d2 = max(-p.y+0.16,d2);\n    \n    p.x = abs(p.x);\n    float a = radians(45.);\n    \n    p.y-=0.3;\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = abs(min(d,d2))-0.0005;\n    \n    return d;\n}\n\nfloat arrows(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(45.));\n    float d = arrow(p);\n    \n    p = prevP;\n    p*=Rot(radians(-45.));\n    float d2 = arrow(p);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    \n    d2 = B(p,vec2(0.32));    \n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p*=Rot(radians(45.));\n    p.y=abs(p.y)-0.34;\n    \n    d2 = arrowItem(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p*=Rot(radians(-45.));\n    p.y=abs(p.y)-0.34;\n    \n    d2 = arrowItem(p);\n    d = min(d,d2);    \n    \n\n    p = prevP;\n    p*=Rot(radians(-45.));\n    d2 = thunderIcon(p);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    float d3 = thunderIcon(p); \n    d2 = min(d2,d3);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    \n    float mask = B(p,vec2(0.38));    \n    d2 = max(-mask,d2);\n    \n    \n    d = min(d,d2);   \n    \n    return d;\n}\n\nfloat arrow2(vec2 p){\n    vec2 prevP = p;\n\n    float dir = SymdirY(p);\n    p.y-=0.03;\n    p.y+=(0.1*iTime)*dir;\n    p.y=mod(p.y,0.08)-0.04;\n    p.x = abs(p.x)-0.04;\n    p*=SkewY(radians(45.*dir*-1.));\n    float d = abs(B(p,vec2(0.025,0.015)))-0.0005;\n\n    return d;\n}\n\nfloat arrowItem2 (vec2 p, float dist){\n    vec2 prevP = p;\n    p.x = abs(p.x)-dist;\n    float d = B(p,vec2(0.0119,0.057));\n    \n    p = prevP;\n    p.x = abs(p.x)-dist;\n    p-=vec2(0.025,0.075);\n    p*=Rot(radians(-45.));\n    float d2 = B(p,vec2(0.04,0.0125));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-dist;\n    p-=vec2(0.0487,0.225);\n    d2 = B(p,vec2(0.0127,0.13));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    float a = radians(45.);\n    \n    p.y-=0.49;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n        \n    \n    return abs(d)-0.0005;\n}\n\n\nfloat arrows2(vec2 p){\n    vec2 prevP = p;\n    float d = arrow2(p);\n    \n    p*=Rot(radians(90.));\n    float d2 = arrow2(p);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    \n    d2 = B(p,vec2(0.32));    \n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x = abs(p.x)-0.47;\n    p*=Rot(radians(90.));\n    d2 = arrowItem2(p,0.095);\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p.y = abs(p.y)-0.47;\n    d2 = arrowItem2(p,0.095);\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.x = abs(p.x)-0.6;\n    p.x -= 0.05;\n    p.y = abs(p.y)-0.1;\n    p.x = mod(p.x,0.08)-0.04;\n    d2 = abs(length(p)-0.01)-0.001;\n    p = prevP;\n    d2 = max(-(abs(p.x)-0.58),d2);\n    d = min(d,d2); \n    \n    p = prevP;\n    p.x = abs(p.x)-0.46;\n    p.y = abs(p.y)-0.17;\n    d2 = abs(Tri(p,vec2(0.035),radians(45.)))-0.001;\n    d = min(d,d2); \n    \n    p = prevP;\n    p.x = abs(p.x)-0.17;\n    p.y = abs(p.y)-0.46;\n    p*=Rot(radians(90.));\n    d2 = abs(Tri(p,vec2(0.035),radians(45.)))-0.001;\n    d = min(d,d2);     \n    \n    p = prevP;\n    p.x = abs(p.x)-0.505;\n    p.y = abs(p.y)-0.18;\n    p*=Rot(radians(45.));\n    d2 = abs(B(p,vec2(0.03,0.01)))-0.001;\n    d = min(d,d2); \n        \n    p = prevP;\n    p.x = abs(p.x)-0.18;\n    p.y = abs(p.y)-0.505;\n    p*=Rot(radians(45.));\n    d2 = abs(B(p,vec2(0.03,0.01)))-0.001;\n    d = min(d,d2); \n    \n    return d;\n}\n\nfloat shapeBase(vec2 p, float s, int mode){\n    vec2 prevP = p;\n    p*=10.;\n\n    if(mode ==1){\n        p = abs(p);\n        p-=iTime*0.5;\n    } else {\n        p*=2.;\n        p.x-=0.2;\n        p.y+=iTime*1.;\n    }\n    \n    vec2 id = floor(p);\n    vec2 gv = fract(p)-0.5;\n    \n    float n = Hash21(id);\n    \n    float w = 0.1;\n    if(n<0.5 || n>=0.8){\n        float dir = (n>=0.8)?1.0:-1.0;\n        gv*=Rot(radians(dir*45.0));\n        if(mode ==1){\n            gv.x = abs(gv.x);\n        }\n        gv.x-=0.355;\n    } else {\n        w = 0.135;\n    }\n    \n    w*=s;\n    float d = B(gv,vec2(w,1.));\n    return d;\n}\n\nfloat centerItem(vec2 p){\n    vec2 prevP = p;\n\n    float d = shapeBase(p,1.,1);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.2));\n    d = max(d2,d);\n    \n    d2 = abs(B(p,vec2(0.22)))-0.005;\n    p = prevP;\n    d2 = max(abs(p.x)-0.1,d2);\n    d = min(d,d2);\n    \n    p*=Rot(radians(45.));\n    d2 = abs(B(p,vec2(0.22)))-0.005;\n    p = prevP;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);\n    \n    p*=Rot(radians(45.));\n    d2 = abs(B(p,vec2(0.24)))-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.2;\n    p.y-=0.2;\n    p*=Rot(radians(-225.));\n    d2 = shapeBase(p,1.,0);\n    \n    d2 = max(abs(p.x)-0.02,d2);\n    d2 = max(abs(p.y)-0.3,d2);\n    p = prevP;\n    d2 = max(-p.y,d2);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.2;\n    p.y+=0.2;\n    p*=Rot(radians(225.));\n    d2 = shapeBase(p,1.,0);\n    \n    d2 = max(abs(p.x)-0.02,d2);\n    d2 = max(abs(p.y)-0.3,d2);\n    p = prevP;\n    d2 = max(p.y,d2);\n    d = min(d,d2);    \n    \n    \n    return d;\n}\n\nfloat circleItem(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(iTime*-30.));\n    p = DF(p,2.);\n    p -= vec2(0.06);\n    p*=Rot( radians(-45.+sin(iTime*2.)*-10.));\n    \n    p.x*=2.;\n    float d = abs(Tri(p,vec2(0.025),radians(45.)))-0.002;\n    p = prevP;\n    float d2 = abs(length(p)-0.05)-0.002;\n    d = min(d,d2);\n    d2 = length(p)-0.02;\n    d = min(d,d2);\n    return d;\n}\n\nfloat circleItems(vec2 p){\n    vec2 prevP = p;\n    \n    p.x = abs(p.x)-0.77;\n    p.y = abs(p.y)-0.32;\n    float d = circleItem(p);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.61;\n    p.y = abs(p.y)-0.21;\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.07,0.04));\n    float a = radians(-45.);\n    p.y+=0.03;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,abs(abs(d2)-0.01)-0.001);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.815;\n    p.y = abs(p.y)-0.19;\n    p*=Rot(radians(-90.));\n    d2 = abs(Tri(p,vec2(0.04),radians(45.)))-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.63;\n    p.y = abs(p.y)-0.32;    \n    d2 = abs(length(p)-0.015)-0.001;\n    d = min(d,d2);\n        \n    p = prevP;\n    p.x = abs(p.x)-0.84;\n    p.y = abs(p.y)-0.46;    \n    d2 = abs(length(p)-0.025)-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.77;\n    p.y = abs(p.y)-0.46;    \n    d2 = abs(length(p)-0.013)-0.001;\n    d = min(d,d2);    \n        \n    p = prevP;\n    p.x = abs(p.x)-0.7585;\n    p.y = abs(p.y)-0.186;\n    d2 = abs(B(p,vec2(0.04,0.006)))-0.001;\n    d = min(d,d2);  \n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor,  in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    vec3 col = vec3(0.);\n\n    float d = centerItem(p);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    d = arrows2(p);\n    \n    float d2 = arrows(p);\n    d = min(d,d2);\n    d2 = circleItems(p);\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.5),S(d,0.0));\n    \n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsS3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 661, 683, 683, 773], [775, 775, 801, 801, 1355], [1357, 1357, 1377, 1377, 1848], [1850, 1850, 1875, 1875, 2570], [2572, 2572, 2593, 2593, 3445], [3447, 3447, 3468, 3468, 3714], [3716, 3716, 3754, 3754, 4291], [4294, 4294, 4316, 4316, 5651], [5653, 5653, 5696, 5696, 6260], [6262, 6262, 6287, 6287, 7275], [7277, 7277, 7302, 7302, 7653], [7655, 7655, 7681, 7681, 8781], [8783, 8783, 8841, 8841, 9225]], "test": "untested"}
{"id": "mdSGD3", "name": "[phreax] geometric dissolution", "author": "phreax", "description": "Making the impossible possible!\n\nObject from another realm..\n\nInspired by the awesome trick of Luna (https://www.shadertoy.com/view/WslyzX)\nand using jarble's amazing fractal texture https://www.shadertoy.com/view/csl3zl\n\n", "tags": ["raymarching", "escher", "moebius", "impossiblegeometry"], "likes": 29, "viewed": 350, "published": 3, "date": "1668312994", "time_retrieved": "2024-07-30T16:20:13.777931", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define PHI 1.618033988749895\n\n\nfloat tt, g_mat, flip;\nfloat g_gl = 0.;\n\nmat2 rot2(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nfloat fadeInOut(float t1, float t2, float fadeTime) {\n    return smoothstep(t1, t1+fadeTime, iTime)-smoothstep(t2-fadeTime, t2, iTime);\n}\n\n\n// Amazing fractal texture from jarble https://www.shadertoy.com/view/csl3zl\nvec2 triangle_wave(vec2 a){\n    \n    vec2 a2 = vec2(1.,0.5),\n    \n    a1 = a-a2;\n    \n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n\nvec3 fractex(vec2 uv) {\n    \n    vec3 col = vec3(0.);\n    \n    uv *= rot2(-tt*.5);\n    \n    float t1 = 2.;    \n    vec2 t2 = vec2(0.);\n        \n    for(int k = 0; k < 6; k++){\n        \n        uv = abs(.5*sign(uv.y-uv.x)+uv+t2);\n                \n        t2 = -triangle_wave(uv-.5*sign(uv.y-uv.x)) ;\n        \n        uv = t2-triangle_wave(uv.yx);\n\n        float c1 = abs(uv.x-uv.y);\n        \n        col = col.yzx;\n                \n        if(uv.y < uv.x) col = vec3(col.yz,c1);\n        \n    }\n    \n    col = min(col*2.,vec3(1.));\n    return col;\n}\n\n\n// from https://mercury.sexy/hg_sdf/\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\n\nfloat icosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n// fold space for toroid\nvec3 transform(vec3 p) {\n    float time = tt*flip;\n\n    p.x *= 1.3;\n    p.yz *= rot2(PI*.25*flip);\n\n    vec3 a = vec3(\n\t\tlength(p.xz),\n        p.y,\n        atan(p.x,p.z)\n\t);\n\n    a.z = fract((a.z/TAU)*10.+time*.5)-.5;\n    a.x -= mix(1.2, 1.9, SIN(tt));\n    \n    float deformF = fadeInOut(20., 30., 2.);\n  \n    a.xy *= rot2(abs(p.x)*deformF*.2+time*.5);\n\n    a.xy = abs(a.xy)-.5*SIN(tt);\n    \n    float rotateF = fadeInOut(10., 53., .0001); \n    float deform2F = fadeInOut(15., 50., 2.);\n    a.xy *= rot2(p.x*p.y*.3*deform2F+.33*(iTime-10.)*flip*rotateF);\n    \n    a.xy = abs(a.xy) -0.3*SIN(.25*tt);\n    return a;\n}\n\n\nfloat map(vec3 p) {   \n\n    vec3 a = transform(p);\n    float r = .01;\n    float b = mix(.3, .15, SIN(tt));\n    \n    float fizzleF = fadeInOut(20., 50., 3.); \n    b -= .13*sin(p.x+tt*.33)*fizzleF;\n\n    float w = mix(.2, .6, SIN(.6*tt- PI));\n    \n    float db = box(a, vec3(b, b, w)) - r;\n   \n    float dr = rect(a.xy, vec2(b*.8), r);\n    \n    g_mat = db < dr ? 1. : 0.;\n    float d = min(dr, db);;\n    return .7*d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\n\nvec2 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        if(d < 0.0001 || t > 50.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    return vec2(t, mat);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    flip = step(gl_FragCoord.x,iResolution.x*.5)*2.-1.;\n    //flip = 1.;\n    tt = iTime + 17.;\n    vec3 ro = vec3(uv*mix(5., 5., SIN(.1*tt)),-4.),\n          rd = vec3(0,0,1.),\n          lp = vec3(0., 0., -15);\n\n    vec3 col;\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    vec3 c1 = vec3(0.365,0.796,0.722);\n    vec3 c2 = vec3(0.961,0.667,0.161);\n    \n    for(float i = 0.; i < 2.; i++) {\n        float steps = i > 0. ? 50. : 100.;\n        vec2 rm = raymarch(ro, rd, steps);\n        mat = rm.y;\n        \n        vec3 p = ro + rm.x*rd;\n\n        if(rm.x < 50.) {\n        \n            vec3 rcol = vec3(0);\n                    \n            vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n            \n            vec3 l = normalize(lp-p);\n            float dif = max(dot(n, l), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n            float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n\n            vec3 tex = fractex(p.xy*.1);\n            vec3 al = mix(c2,  c1 + .4*tex, mat)*.5 + .5*(.5+.5*n);\n\n            rcol += al*mix(1., dif, .8) + .0*spe +  + .4*al*sss;\n           \n            ro = p + n*0.001; \n            if(mat == 0.) {\n                rd = reflect(rd, n);\n            } \n\n\t\t\tif(i == 0.)\n                col = rcol;\n            else  \n                col *= mix(rcol, vec3(1), 1.0 - exp(-.8*i));  // from https://www.shadertoy.com/view/7dsfDl\n\n        } else {\n            \n            if(i == 0.) {\n               col =  mix(c1, c2-.9, (.9-pow(dot(uv, uv), .3)))*.3+.8; // background\n               break;\n            } else {\n                col = texture(iChannel0, rd).rgb*c2;\n            }\n        }   \n    }\n\n\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5)));\n    col = pow(col, vec3(.6));\n   \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSGD3.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[228, 228, 248, 248, 296], [298, 298, 351, 351, 435], [438, 515, 542, 542, 646], [649, 649, 672, 672, 1196], [2364, 2376, 2407, 2407, 2492], [2494, 2494, 2521, 2521, 2612], [2614, 2614, 2653, 2653, 2746], [2748, 2773, 2797, 2797, 3387], [3390, 3390, 3409, 3409, 3805], [3808, 3808, 3832, 3832, 4107], [4110, 4110, 4156, 4156, 4473], [4476, 4476, 4533, 4533, 6550]], "test": "untested"}
{"id": "mdS3DV", "name": "4D Riemmanian star cluster", "author": "A_Toaster", "description": "An expanding star cluster in the 4-D spacetime described by Greg Egan in his Orthogonal series. Different wavelengths have a different angle relative to the observer's time, leading to the spectral star trails.", "tags": ["raymarching", "4d", "orthogonal"], "likes": 10, "viewed": 346, "published": 3, "date": "1668295313", "time_retrieved": "2024-07-30T16:20:14.532913", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture( iChannel0, uv ).xyz * 2.5;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Uncomment the line below for a camera accelerating constantly, which makes a traces a circular arc through spacetime\n// #define ZOOM_CAM\n\n// Uncomment the line below to enable camera orbiting\n#define ORBIT_CAM\n\n// Uncomment for a cluster of stars orthogonal to the camera's time dimension\n// #define ORTHOGONAL_STAR_DIR\n// Uncomment for a cluster of stars with random 4D directions\n// #define RANDOM_STAR_DIR\n// (By default, star directions are all near (0, 0, 0, 1) )\n\n\n// For a more complete explaination of the physics/geometry of Riemmanian spacetime,\n// see http://gregegan.net/ORTHOGONAL/ORTHOGONAL.html\n//\n// The universe rendered here is mostly accurate to the one described by Greg Egan, with one exception:\n// Every star in this scene emits light in every direction, including the direction\n// opposite its own arrow of time.\n//\n// This scene shows a universe with 4 dimensions, much like our own, except that there is no special\n// \"time\" dimension. Objects are free to move in any direction (Always with a velocity of 1).\n// For any given observer, their direction of motion dictates their own arrow of time.\n//\n// Stars are modelled as infinitely long spherical prisms. Because these prisms aren't parallel,\n// I couldn't use the standard tricks like domain repetition to speed up rendering.\n// \n// One consequence of this universe is that the speed of light depends on its wavelength (which\n// depends on its orientation relative to you). This creates the streaks seen behind the stars.\n// For the sake of accuracy, rendering is done by sampling light is sampled at a few different \n// wavelength ranges. This also contributes to slow rendering.\n//\n// Another consequence is that a constantly accelerating object will eventually have a direction\n// orthogonal to its original direction, which would appear to a stationary observer like moving at an\n// infinite velocity. To see what a field of infinite-velocity (orthogonal) stars would look like,\n// uncomment the line \"#define ORTHOGONAL_STAR_DIR\".\n//\n// An object that keeps accelerating beyond this point will eventually loop around to the same 4D\n// coordinates that it started at. Uncomment \"#define ZOOM_CAM\" to see the perspective of such an object.\n//\n// One aspect which is not modelled is that this universe must be a finite, compact manifold thanks to\n// the properties of light waves. This could likely be modelled by domain repitition, but care would\n// have to be taken to ensure that every star loops back to its original position after exactly one lap.\n//\n// I will likely revisit this rendering scheme with different 4D geometry in the future.\n\n// Turn up if your system can handle it\n#define N_STARS 16\n\nconst float FIELD_OF_VIEW = 1.2;\n\n// camera directions\nconst vec4 FWD_4 = vec4(1., 0., 0., 0.);\nconst vec4 UP_4 = vec4(0., 0., 1., 0.);\n\n// raymarching questions\nconst float MAX_DIST = 200.;\nconst float EPS = 0.01;\nconst float GLOW_DIST = 1.;\n#define MAX_ITERATIONS 20\n\n// cluster settings\nconst float CLUSTER_SIZE = 20.;\nconst float CLUSTER_RAND_VEL = 0.4;\n#ifdef ORTHOGONAL_STAR_DIR\nconst vec4 CLUSTER_FUTURE = vec4(1., 0., 0., 0.);\n#else\nconst vec4 CLUSTER_FUTURE = vec4(0., 0., 0., 1.);\n#endif\nconst float STAR_SIZE = 0.01;\n\n\n// projection operator\nvec4 proj(vec4 u, vec4 v) {\n    return (u * dot(u,v)) / dot(u, u);\n}\n\n// Calculate a vector orthogonal (but not orthonormal) to three other 4-vectors\nvec4 cross4(vec4 u, vec4 v, vec4 t){\n    return vec4(\n        ( u.w * v.z - u.z * v.w) * t.y + (-u.w * v.y + u.y * v.w) * t.z + (-u.y * v.z + u.z * v.y) * t.w,\n        (-u.w * v.z + u.z * v.w) * t.x + ( u.w * v.x - u.x * v.w) * t.z + ( u.x * v.z - u.z * v.x) * t.w,\n        ( u.w * v.y - u.y * v.w) * t.x + (-u.w * v.x + u.x * v.w) * t.y + (-u.x * v.y + u.y * v.x) * t.w,\n        ( u.y * v.z - u.z * v.y) * t.x + (-u.x * v.z + u.z * v.x) * t.y + ( u.x * v.y - u.y * v.x) * t.z\n    \n    );\n}\n\n// Returns a 4-d ray direction orthogonal to the time vector given a set of camera parameters.\nvec4 camera_spacelike_dir(vec2 uv, vec4 cameraDirection, vec4 cameraUp, vec4 cameraFuture) {\n    \n\tuv = uv * FIELD_OF_VIEW;\n    \n    // Up/fwd vec orthogonal to future\n    vec4 fut = cameraFuture;\n    vec4 up_vec = normalize(cameraUp - proj(fut, cameraUp));\n    vec4 fwd_vec = normalize(cameraDirection - proj(fut, cameraDirection));\n    // Right vec orthogonal to all other directions\n    vec4 right_vec = normalize(cross4(up_vec, fwd_vec, fut));\n    \n    vec4 spacelike_dir = normalize(fwd_vec + uv.y * up_vec + uv.x * right_vec);\n    \n    return spacelike_dir;\n}\n\n// Returns 4-d ray direction given a spacelike direction and a velocity in the timelike direction.\nvec4 camera(vec4 spacelike_dir, vec4 cameraFuture, float futureVel) {\n    vec4 timelike_dir = cameraFuture * futureVel;\n    \n    return normalize(spacelike_dir + timelike_dir);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 rand(int i) {\n    return vec4(\n        rand(vec2(float(i), 2.)),\n        rand(vec2(float(i), 12.)),\n        rand(vec2(float(i), 112.)),\n        rand(vec2(float(i), 1112.))\n    );\n}\n\n// 4D star cluster SDF\n// SDF between a cluster and a dispersing line of light of different wavelengths.\n// 'elongation' is a vector from the point at one end of the spectrum to the other.\nfloat sdCluster (vec4 p, vec4 elongation) {\n    float dist = MAX_DIST;\n    for(int i=0; i < N_STARS; i++) {\n        #ifdef RANDOM_STAR_DIR\n        vec4 star_future = normalize(rand(i + 9874) - vec4(0.5));\n        #else\n        vec4 star_future = normalize(CLUSTER_FUTURE + (rand(i + 9874) - vec4(0.5)) * CLUSTER_RAND_VEL);\n        #endif\n\n        vec4 star_pos = (rand(i) - vec4(0.5)) * CLUSTER_SIZE;\n        \n        vec4 pa = p - star_pos;\n        \n        // Elongate along elongation vector\n        vec4 orth_elongation = elongation - proj(star_future, elongation);\n        float t2 = dot(pa, orth_elongation)/dot(orth_elongation, orth_elongation);\n        pa = pa - clamp(t2, -1., 0.) * orth_elongation;\n        \n        // Elongate (infinitely) along star future\n        float t1 = dot(pa, star_future)/dot(star_future, star_future);\n        pa = pa - t1 * star_future;\n        \n        \n        \n        \n        // Calculate distance to star\n        dist = min(dist, length(pa) - STAR_SIZE);\n        \n    }\n    return dist;\n}\n\nfloat raymarch4d(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        d = sdCluster(ray_pos + l * lower_ray_dir, l * elongation_vec);\n        min_dist = min(min_dist, d);\n        if (d < EPS) {\n            // Hit star\n            min_dist = 0.;\n            break;\n        }\n        l += d;\n        if (l > MAX_DIST) {\n            break;\n        }\n    }\n    \n    // 1.0 for direct hit, 0.0 for complete miss\n    float a = clamp((GLOW_DIST - min_dist) / GLOW_DIST, 0., 1.);\n    // (poor) simulation of exponential decay\n    return pow(a, 10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cam_uv = ((fragCoord/iResolution.xy) - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.);\n    \n    // Calculate camera position & direction. The requires 3 orthogonal vectors to define in 4d.\n    \n    \n    #ifdef ZOOM_CAM\n    \n    float radius = 4.;\n    float center = 0.;\n    \n    vec4 future = vec4(0., -sin(iTime/radius), 0., cos(iTime/radius));\n    vec4 ray_pos = vec4(0., center + radius * cos(iTime/radius), 0., radius * sin(iTime/radius));\n    \n    vec4 fwd = vec4(0., -cos(iTime/radius), 0., -sin(iTime/radius));\n    vec4 camera_d = camera_spacelike_dir(cam_uv, fwd, UP_4, future);\n    #else\n    #ifdef ORBIT_CAM\n    float orbit_rate = 0.05; // radians/sec\n    #else\n    float orbit_rate = 0.; // radians/sec\n    #endif\n    \n    float orbit_radius = CLUSTER_SIZE * 1.5;\n    \n    vec4 fwd = vec4(sin(iTime * orbit_rate), cos(iTime * orbit_rate), 0., 0.);\n    vec4 future = normalize(vec4(0., 0.0, 0., 1.));\n    vec4 camera_d = camera_spacelike_dir(cam_uv, fwd, UP_4, future);\n    vec4 ray_pos = fwd * orbit_radius * -1. - future * iTime;\n    #endif\n    \n    \n    // Raymarch 4 different wavelength/velocity ranges\n    float r = raymarch4d(camera_d, ray_pos, future, 0.58, 0.65); // Red light is slowest (Pointed most towards the camera's future)\n    float g = raymarch4d(camera_d, ray_pos, future, 0.51, 0.59);\n    float b = raymarch4d(camera_d, ray_pos, future, 0.46, 0.54);\n    float v = raymarch4d(camera_d, ray_pos, future, 0.44, 0.48); // Violet light is fastest\n    \n    // Wavelength range colors\n    vec3 r_col = vec3(0.8, 0., 0.);\n    vec3 g_col = vec3(0., 0.5, 0.);\n    vec3 b_col = vec3(0., 0., 0.6);\n    vec3 v_col = vec3(0.25, 0., 0.7);\n    // Additively mix final color\n    vec3 col = r * r_col + g * g_col + b * b_col + v * v_col;\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 184]], "test": "untested"}
{"id": "csB3Dt", "name": "chrysalis redux", "author": "haptix", "description": "chrysalis redux", "tags": ["psychedelic", "trippy"], "likes": 4, "viewed": 235, "published": 3, "date": "1668292190", "time_retrieved": "2024-07-30T16:20:15.295872", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot (float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 rBox(vec3 p, vec3 b, float r, float matId)\n{\n\tvec3 q = abs(p) - b;\n\treturn vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r, matId);\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = -iTime - iDate.y;\n    \n    for(float i = 0.; i < 11.; i++)\n    {   \n        p = abs(p) - vec3(((cos(.03*t) + .5) * .011*sin(t*.19)) + ((sin(.015*t) + .5) * .011*cos(t*.19)) + .05,\n                          ((sin(.05*t) + .5) * .011*cos(t*.29)) + ((cos(.017*t) + .5) * .011*sin(t*.29)) + .09,\n                          ((sin(.02*t) + .5) * .011*cos(t*.09)) + ((cos(.013*t) + .5) * .011*sin(t*.09)) + .07);\n    \n        p.xy *= rot(.031*t);\n        \n        p = abs(p.zxy) - vec3(((sin(.02*t) + .5) * .011*cos(t*.07)) + ((cos(.013*t) + .5) * .011*sin(t*.07)) + .09,\n                          ((cos(.03*t) + .5) * .011*sin(t*.17)) + ((sin(.015*t) + .5) * .011*cos(t*.17)) + .05,\n                          ((cos(.05*t) + .5) * .011*sin(t*.27)) + ((sin(.017*t) + .5) * .011*cos(t*.27)) + .07);\n                          \n        p.zx *= rot(-.029*t);\n\n        //p = abs(p.yzx) - vec3(((cos(.05*t) + .5) * .011*sin(t*.011)) + ((cos(.02*t) + .5) * .011*sin(t*.03)) + .09,\n        //                  ((sin(.03*t) + .5) * .011*cos(t*.07)) + ((cos(.07*t) + .5) * .011*sin(t*.011)) + .05,\n        //                  ((cos(.07*t) + .5) * .011*sin(t*.05)) + ((sin(.011*t) + .5) * .011*cos(t*.09)) + .07);\n                          \n        //p.yz *= rot(.017*t);\n    }\n    \n    return p;\n}\n\nvec2 add(vec2 m1, vec2 m2)\n{\n    return m1.x < m2.x ? m1 : m2;\n}\n\nvec2 map(vec3 p)\n{   \n    float rCorner = .001;\n    \n    p.x = abs(p.x);\n    p = (60. + 4.*cos(.07*iTime)) * sin(p/dot(p,p));\n    p = kif(p);\n    \n    vec2 m1 = rBox(p, vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m2 = rBox(vec3(p.x - .05, p.yz), vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m3 = rBox(vec3(p.x - .02, p.yz), vec3(.04, .8, 1.), rCorner, 2.);\n    vec2 m4 = rBox(vec3(p.x - .2, p.yz), vec3(.03, .45, .55), .005, 1.);\n    vec2 m5 = rBox(vec3(p.x - .025, p.y + .5, p.z), vec3(.05, .01, 1.05), rCorner, 2.);\n    vec2 m6 = rBox(vec3(p.x - .025, p.y - .5, p.z), vec3(.05, .01, 1.05), rCorner, 2.);\n    vec2 m7 = rBox(vec3(p.x - .025, p.yz), vec3(.05, .01, 1.05), rCorner, 2.);\n    vec2 m8 = rBox(vec3(p.x - .3, p.yz), vec3(.005, .15, .1), rCorner, 3.);\n\n    vec2 m = add(add(add(add(add(add(add(m1, m2), m3), m4), m5), m6), m7), m8);\n    glo += .15 / (1.2 + m2.x*m2.x*m2.x);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 25.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 128; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .01 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x * .9;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nfloat sss(vec3 p, vec3 l, float d)\n{\n\treturn smoothstep(0., 1., map(p + l*d).x/d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(.75*cos(-.1*iTime),\n                   .75*sin(-.1*iTime),\n                   -4.2);\n    float targDist = 8.;\n\tvec3 camTarget = vec3(ro.x + targDist*sin(.1*iTime),\n                          ro.y,\n                          ro.z + targDist*cos(.1*iTime));\n\tvec3 up = vec3(sin(iTime/10.), cos(iTime/10.), 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(2.5, 2.5, -5.);\n    vec3 lightPos2 = vec3(-2.5, -2.5, -5.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .05);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(.35*sin(.317*(iTime)),\n                       cos(.151*(iTime)),\n                       .35*cos(.227*(iTime))) + 1.2;\n\n    vec3 hit = ro + rd*t.x;\n    vec3 lightDir = normalize(lightPos - hit);\n    vec3 lightDir2 = normalize(lightPos2 - hit);\n\n    vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                                            map(hit - eps.xyx).x,\n                                            map(hit - eps.xxy).x));\n\n\n    float diff = max(0., dot(lightDir, norm));\n    float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 50.);\n    float spec2 = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 50.);\n    float ao = clamp(map(t.x + norm*.01).x / .5, 0., 1.);\n\n    vec3 col = vec3(.1);\n    col *= .1 * ao;\n\n    if(t.y == 1.)\n        colRot = vec3(.18);\n    else if(t.y == 3.)\n        col += glo*.035*colRot;\n    else\n    {\n        colRot = colRot.yzx;\n        col += glo*.035*colRot;\n    }    \n\n    col += .3 * diff * colRot;\n    col += 1. * spec * vec3(0., .7, 1.);\n    col += 1. * spec2 * vec3(0., .7, 1.);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 61, 61, 121], [123, 123, 172, 172, 276], [278, 278, 296, 296, 1593], [1595, 1595, 1623, 1623, 1659], [1661, 1661, 1679, 1679, 2562], [2564, 2564, 2591, 2591, 2822], [2824, 2824, 2860, 2860, 2908], [2910, 2910, 2967, 2967, 4848]], "test": "untested"}
{"id": "csBGWt", "name": "built-in basics 'sign'", "author": "jonasfrey", "description": "sign, does return \ny = -1 if x < 0\ny = 1 if x > 0\n\ngreen a sin wave with freq 6 tau and amp 0.3\nred the built-in function 'sign' \nblue the self replicated function f_n_sign", "tags": ["basics"], "likes": 4, "viewed": 226, "published": 3, "date": "1668287064", "time_retrieved": "2024-07-30T16:20:16.050854", "image_code": "// this is an example of how builtin functions work\n// i will try to programm the function manually \n// to get an understanding of how it works\nfloat f_n_sign(\n    float n\n){\n    // to bad that booleans cannot be used as a multiplier :(\n    // return (n > 0. * 1.) + (n < 0. * -1.) \n    \n    if(n > 0.){ return +1.; }\n    if(n < 0.){ return -1.; }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 o_pixel_coord_normalized = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.y;\n    \n\n    float n_y = sin(o_pixel_coord_normalized.x*9.0*6.2831) * 0.3;\n    float n_dist = abs(o_pixel_coord_normalized.y - n_y);\n    if(o_pixel_coord_normalized.x<0.0){\n        fragColor = vec4(sqrt(n_dist));\n        fragColor += vec4(0.0, 0.2,0.0,0.0);\n    }\n    if(o_pixel_coord_normalized.x>0.0){\n       n_y = sign(n_y)*0.5;\n       n_dist = abs(o_pixel_coord_normalized.y - n_y);\n       \n       fragColor = vec4(sqrt((n_dist))); \n       fragColor += vec4(0.2, 0.0,0.0,0.0);\n    }\n    if(o_pixel_coord_normalized.x>0.5){\n       n_y = f_n_sign(n_y)*0.5;\n       n_dist = abs(o_pixel_coord_normalized.y - n_y);\n       \n       fragColor = vec4(sqrt((n_dist))); \n       fragColor += vec4(0.0, 0.0,0.2,0.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 144, 174, 282, 350], [352, 352, 409, 409, 1222]], "test": "untested"}
{"id": "mdjGDc", "name": "Mystic Flower interactive", "author": "timmaffett", "description": "@rigel's https://www.shadertoy.com/view/XsjBRt  with mouseX added as a multiplier to iTime to allow mouse interactivity (lines 53, 56)\n\nall credit goes to https://www.shadertoy.com/user/rigel", "tags": ["2d", "noise", "color", "palette"], "likes": 11, "viewed": 371, "published": 3, "date": "1668276251", "time_retrieved": "2024-07-30T16:20:16.811819", "image_code": "// Author: Rigel\n// Shader: Mystic Flower\n// licence: https://creativecommons.org/licenses/by/4.0/\n\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n\n// radom number in 2d\nfloat hash(vec2 p) {\n  return fract(sin(dot(p,vec2(12.9898,78.2333)))*43758.5453123);\n}\n\n// noise in 2d\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// fractal noise in 2d\nfloat fbm ( vec2 p ) {\n    const mat2 m = mat2(0.8,0.6,-0.6,0.8);\n    float f = 0.0;\n    f += 0.5000*noise ( p ); p*=m*2.02;\n    f += 0.2500*noise ( p ); p*=m*2.04;\n    f += 0.1250*noise ( p ); p*=m*2.03;\n    f += 0.0650*noise ( p ); p*=m*2.01;\n\n    // normalize f;\n    f /= 0.9375;\n    return f;\n}\n\n// generates a palette with a cosine\n// from https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float domain, vec3 frequency, vec3 phase) {\n  return vec3(0.5) + vec3(0.5) * cos(TWO_PI*(frequency*domain+phase));\n}\n\nvoid mainImage(out vec4 light, in vec2 space)\t{\n  // cordinate system from -2 to 2\n  vec2 p = (-0.5 + (space.xy / iResolution.xy)) * vec2(4.0);\n  // aspect ratio\n  p.x *= iResolution.x / iResolution.y;\n\n  // angle and radius to center 0,0\n  float a = atan( p.y, abs(p.x) );\n  float r = length(p);\n\n  float mouseX = (iMouse.x>0.) ? (iMouse.x-iResolution.x)/iResolution.x : 1.;  // add mouseX in as 0.5 - +0.5 term to allow interactivity\n  //float mouseX = (iMouse.x>0.) ? iMouse.x/iResolution.x : 1.;  // add mouseX in as 0.0 - 1.0 term to allow interactivity\n\n  // space distortion\n  p += vec2(fbm(vec2(a*2.+mouseX*iTime*.1,r*.4-iTime*.3)))*5.0;\n  // divide the space into cells and get cell index to seed the palette\n  float cidx = (floor(p.x+2.0) + (floor(p.y+2.0)*4.0)) / 16.0;\n  // color is from palette with cell index\n  vec3 color = pal(fbm(p*.5), vec3(1.0), vec3(0.4+cidx,0.2+cidx,0.0));\n\n  // draw a grid for the cells\n  color *= smoothstep(0.49,0.44, abs(fract(p.x)-0.5));\n  color *= smoothstep(0.49,0.44, abs(fract(p.y)-0.5));\n\n  // angular distortion\n  a += fbm(p*0.05);\n  // flower white petals\n  float f = abs(cos(a*9.)*sin(a*6.))*.7+.1;\n  float ff = smoothstep(f,f+0.05,r);\n  color = ff * color + (1.0-ff) * vec3(0.9,0.9,0.7) * (1.8-r);\n\n  // flower center\n  color = mix(color,vec3(1.,1.-r*3.,0.0),smoothstep(0.26,0.1+fbm(vec2(r+iTime,a-iTime))*0.06 ,r));\n\n  light = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjGDc.jpg", "access": "api", "license": "cc-by-sa-3.0", "functions": [[163, 185, 205, 205, 272], [274, 289, 310, 310, 556], [558, 581, 603, 603, 879], [881, 964, 1016, 1016, 1089], [1091, 1091, 1138, 1173, 2490]], "test": "untested"}
{"id": "ds23D3", "name": "i really need this formula", "author": "jonasfrey", "description": "i want to create a equilateral triangle by modifying the radius on a circle", "tags": ["triangle"], "likes": 2, "viewed": 238, "published": 3, "date": "1668273130", "time_retrieved": "2024-07-30T16:20:17.567798", "image_code": "vec4 f_o_dist_flower(\n    vec2 o_pix_cor_nor,\n    vec2 o_target, \n    float n_leaves\n){\n    vec2 o_delta = o_pix_cor_nor - o_target;\n    float n_tau = 6.2831;\n    float n_angle = atan(o_delta.x , o_delta.y);\n    float n_leave = n_angle / (n_tau/n_leaves); \n    float n_angle_mod_norm = fract(n_leave);\n    float n_dist_squared = o_delta.x * o_delta.x + o_delta.y * o_delta.y;\n    float n_dist_sqrt_root = sqrt(n_dist_squared);\n    float n_radius_outcircle = n_dist_sqrt_root;\n    float n_dist_sqrt_root_modded = 0.0;\n    \n    float n_incircle_radius_regular_polygon = n_radius_outcircle * cos((n_tau/2.0)/n_leaves);\n    //https://www.desmos.com/calculator/xeiqmbj1ee?lang=de\n    float n_angle_mod_norm_linear_inout = abs(n_angle_mod_norm - 0.5) * -2.0 + 1.0;\n    float n_angle_mod_norm_exp_inout = \n        pow((n_angle_mod_norm - 0.5), 2.0) * -4.0 + 1.0;\n        \n    float n_angle_mod_norm_special_inout = \n        pow(mod(n_angle_mod_norm+0.5, 1.0)-0.5, 2.0)*4.0;\n        \n   float n_angle_mod_norm_sin_inout = \n        sin(n_tau * n_angle_mod_norm * 0.5);\n   \n   float n_angle_mod_norm_sin_mirrored_inout = \n        sin(n_tau * mod(n_angle_mod_norm+0.5, 1.0) * 0.5) *-1.0 + 1.0;     \n    \n    return \n        vec4(\n            //n_radius_outcircle-((n_radius_outcircle-n_incircle_radius_regular_polygon)*n_angle_mod_norm_exp_inout), \n            //n_radius_outcircle-((n_radius_outcircle-n_incircle_radius_regular_polygon)*n_angle_mod_norm_special_inout), \n            //n_radius_outcircle-((n_radius_outcircle-n_incircle_radius_regular_polygon)*n_angle_mod_norm_linear_inout), \n            //n_radius_outcircle-((n_radius_outcircle-n_incircle_radius_regular_polygon)*n_angle_mod_norm_sin_inout),\n            n_radius_outcircle-((n_radius_outcircle-n_incircle_radius_regular_polygon)*n_angle_mod_norm_sin_mirrored_inout), // allmost it!\n            1.,1.,1.\n        );\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_cor_nor = (fragCoord-0.5*iResolution.xy)/iResolution.y; \n    vec4 o_dist = vec4(1.0,1.0,1.0,1.0);\n\n    float n_sides_max = 9.0;\n    float n_sides_min = 3.0; \n    float n_sides_range = n_sides_max - n_sides_min;\n    float n_dist_lwst = 1.0;\n    for(\n        float n_side_norm = (1.0/n_sides_max)*n_sides_min;\n        n_side_norm < 1.0;\n        n_side_norm += 1.0/n_sides_max\n    ){\n        float n_side = n_side_norm*n_sides_max;\n        \n        float n_x = (1.0 / n_sides_range)*(n_sides_max - n_side)-0.5;\n        if(o_pix_cor_nor.x > n_x){\n            o_dist = f_o_dist_flower(o_pix_cor_nor, vec2(n_x+( (1.0 / n_sides_range)/2.0),0.0), n_side);\n        }\n        if(o_dist.x<n_dist_lwst){n_dist_lwst=o_dist.x;}\n\n    }\n\n    fragColor = vec4(\n        sin(n_dist_lwst*333.0)\n    ); \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds23D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 87, 87, 1879], [1880, 1880, 1937, 1937, 2738]], "test": "untested"}
{"id": "ms23D3", "name": "textile patterns w/iTime in seed", "author": "timmaffett", "description": "This is simply [url]https://www.shadertoy.com/view/tl2XRG[/url] with uvec seeding changed to floats and then iTime thrown in to animate the tiles.\nKind of fun. mouse x further animates\n-All credit goes to @TekF", "tags": ["kaleidoscope"], "likes": 12, "viewed": 252, "published": 3, "date": "1668272695", "time_retrieved": "2024-07-30T16:20:18.325772", "image_code": "float seed = 0.; // initial seed, set to 0 to get a seed based on the current time & date\n\nconst float tau = 6.2831853;\n\nvec3 GeneratePattern( float seed, vec2 uv, vec2 duvdx, vec2 duvdy )\n{\n    float r = 1.0;\n    float a = seed*.1;\n    float c = cos(a)*r;\n    float s = sin(a)*r;\n    float q = fract((seed*.2/tau)/3.)*3.;\n    for ( int i=0; i<30; i++ )\n    {\n    \t//uv = abs(uv);\n        \n        // higher period symmetry\n        float t = atan(uv.x,uv.y);\n\t\tt *= q;\n        t = abs(fract(t*.5+.5)*2.0-1.0);\n        t /= q;\n        //q = q+.001;\n        uv = length(uv)*vec2(sin(t),cos(t));\n        \n        uv -= .7;\n        uv = uv*c + s*uv.yx*vec2(1,-1);\n    }\n\n\t// pixellate to make it look like tiles\n//    uv = floor(uv*27.)/27.;\n//    vec3 tap = textureLod( iChannel0, uv*vec2(1,-1)+.5, 0.0 ).rgb;\n    \n    vec3 tap = textureGrad( iChannel0, uv*vec2(1,-1)+.5, duvdx, duvdy ).rgb;\n\n    // quantize the colour to get polygonal shapes\n//    tap = floor(tap*6.999)/6.;\n    \n    vec3 col = .5+.5*sin(seed+vec3(13,17,23)*tap);\n    \n    // quantize the colour to get polygonal shapes\n    float shades = 4.;\n    col = floor(col*(shades+.999))/shades;\n    \n    return col;\n}\n\n    \nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\nif ( seed == 0. )\n    {\n        float mouseX = (iMouse.x>0.) ? iMouse.x: iResolution.x ;\n        // randomize based on timestamp\n        vec4 date = vec4(floor(iDate));\n        date.w /= 3600.; // randomize once per hour\n        // can't do a dot product!?\n        date *= vec4(372.*24.,31.*24.,24.,1.);\n        seed = float( (date.x+date.y+date.z+date.w) * mod(float(iTime*(mouseX/iResolution.x)),26543.) )/exp2(32.);\n        seed = -50.*seed;\n    }\n    \n    vec3 ray = vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, 1. );\n    ray = normalize(ray);\n    \n    vec3 camK = normalize(vec3(3.*sin(iTime*.1),3.*cos(iTime*.0618),5));\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    \n    float t = 5./ray.z;\n    \n    vec2 uv = ray.xy*t;\n    \n    uv /= 3.;\n    uv += vec2(.2,.1)*iTime;\n    float _seed = seed + floor(uv.x) + 5.*floor(uv.y); // floor(iTime*.3+10.0);\n    \n    float size = 5.;\n    vec2 wrapuv = (fract(uv)-.5)*size;\n    uv *= size;\n    \n    fragColour.rgb = GeneratePattern( _seed, wrapuv, dFdx(uv), dFdy(uv) );\n}\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 190, 190, 1174], [1181, 1181, 1239, 1239, 2354]], "test": "untested"}
{"id": "msj3D3", "name": "Inside the System", "author": "kishimisu", "description": "Playing with neon attenuation, space repetition, randomness and camera movement", "tags": ["raymarching", "illumination", "random", "space", "repetition", "glow", "infinite", "neon"], "likes": 95, "viewed": 3111, "published": 3, "date": "1668270895", "time_retrieved": "2024-07-30T16:20:19.086737", "image_code": "/* \"Inside the System\" by @kishimisu (2022) - https://www.shadertoy.com/view/msj3D3\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n   3 torus, 3 lights, infinite domain repetition.\n   Mouse interactive.\n   \n   I got inspired to create this after seeing\n   https://www.shadertoy.com/view/3dlcWl which \n   plays with similar neon colors. The key equation that\n   allow this intensity fallout is 1./(1. + pow(abs(d), n))\n*/\n\n#define LOW_PERF      0   // set to 1 for better performances\n\n// spacing controls\n#define spacing       7.  // columns repetition spacing\n#define light_spacing 2.  // light   repetition spacing (try 1. for a psychedelic effect!)\n\n#define attenuation  22.  // light   attenuation\n\n// speed controls\n#define GLOBAL_SPEED  .7\n#define camera_speed  1.\n#define lights_speed 30.\n#define columns_speed 4.\n\n#if LOW_PERF\n    #define iterations 30.\n    #define max_dist   30.\n#else\n    #define iterations 50.\n    #define max_dist   80.\n#endif\n\n#define epsilon 0.005\n#define iTime (iTime*GLOBAL_SPEED)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define rep(p, r) (mod(p+r/2., r)-r/2.)\n#define torus(p) (length( vec2(length(p.xz)-.6,p.y) ) - .06)\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 getLight(vec3 p, vec3 color) {\n    return max(vec3(0.), color / (1. + pow(abs(torus(p) * attenuation), 1.3)) - .001);\n}\n\nvec3 geo(vec3 po, inout float d, inout vec2 f) {\n    // shape repetition\n    float r = hash12(floor(po.yz/spacing+vec2(.5)))-.5;\n    vec3  p = rep(po + vec3(iTime*r*columns_speed, 0., 0.), vec3(.5, spacing, spacing));\n    p.xy   *= rot(1.57);\n    d       = min(d, torus(p));\n    \n    // light repetition\n    f       = floor(po.yz/(spacing*light_spacing)-vec2(.5));\n    r       = hash12(f)-.5;\n    if (r > -.45) p = rep(po + vec3(iTime*lights_speed*r, 0., 0.), spacing*light_spacing*vec3(r+.54, 1., 1.));\n    else p  = rep(po + vec3(iTime*lights_speed*.5*(1.+r*0.003*hash12(floor(po.yz*spacing))), 0., 0.), spacing*light_spacing);\n    p.xy   *= rot(1.57);\n    f       = (cos(f.xy)*.5+.5)*.4;\n    \n    return p;\n}\n\nvec4 map(vec3 p) {\n    float d = 1e6;\n    vec3 po, col = vec3(0.);\n    vec2 f;\n    \n    po = geo(p, d, f);\n    col  += getLight(po, vec3(1., f));        // x\n    \n    p.z  += spacing/2.;\n    p.xy *= rot(1.57);\n    po    = geo(p, d, f);\n    col  += getLight(po, vec3(f.x, .5, f.y)); // y\n    \n    p.xy += spacing/2.;\n    p.xz *= rot(1.57);\n    po    = geo(p, d, f);\n    col  += getLight(po, vec3(f, 1.));        // z\n     \n    return vec4(col, d);\n}\n\nvec3 getOrigin(float t) {\n    t = (t+35.)*-.05*camera_speed;\n    float rad = mix(50., 80., cos(t*1.24)*.5+.5);\n    return vec3(rad*sin(t*.97), rad*cos(t*1.11), rad*sin(t*1.27));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.; \n    \n    ro = getOrigin(iTime+m.x*10.);\n    \n    vec3 f = normalize(getOrigin(iTime+m.x*10.+.5) - ro);    \n    vec3 r = normalize(cross(normalize(ro), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    \n    initRayOriginAndDirection(uv, ro, rd);\n    \n    float t = 2.;\n    for (float i = 0.; i < iterations; i++) {\n        p = ro + t*rd;\n        \n        vec4 res = map(p);\n        col += res.rgb;\n        t += abs(res.w);\n\n        if (abs(res.w) < epsilon) t += epsilon;\n        \n        if (col.r >= 1. && col.g >= 1. && col.b >= 1.) break;\n        if (t > max_dist) break;\n    }\n            \n    col = pow(col, vec3(.45));\n    O = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msj3D3.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[1301, 1301, 1323, 1323, 1440], [1442, 1442, 1477, 1477, 1566], [1568, 1568, 1616, 1640, 2279], [2281, 2281, 2299, 2299, 2729], [2731, 2731, 2756, 2756, 2910], [2912, 2912, 2983, 2983, 3238], [3240, 3240, 3279, 3279, 3811]], "test": "untested"}
{"id": "dsjGD3", "name": "is this sRGB conversion ?", "author": "jonasfrey", "description": "left side: no sRGB conversion, \nright side: sRGB conversion", "tags": ["srgb"], "likes": 2, "viewed": 179, "published": 3, "date": "1668270350", "time_retrieved": "2024-07-30T16:20:19.842715", "image_code": "float f_n_dist(\n    vec2 o_pix_cor_nor,\n    vec2 o_target\n){\n    float n_one = 1.0;// to keep it simple do not change this\n    vec2 o_delta = o_pix_cor_nor - o_target;\n    float n_tau = 6.2831;\n    float n_angle = atan(o_delta.y , o_delta.x)+(n_tau/2.0);\n    float n_angle_norm = n_angle / n_tau;\n  \n    float n_dist_squared = o_delta.x * o_delta.x + o_delta.y * o_delta.y;\n    float n_dist_squared_root = sqrt(n_dist_squared);\n    float n_dist_squared_root_modded = n_angle_norm;\n\n    \n    return n_dist_squared_root_modded;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_cor_nor = (fragCoord-0.5*iResolution.xy)/iResolution.y; \n    float n_dist = f_n_dist(o_pix_cor_nor, vec2(-0.5,0.0));\n\n    fragColor = vec4(n_dist); \n    \n    if(o_pix_cor_nor.x > 0.0){\n        o_pix_cor_nor = (fragCoord-0.5*iResolution.xy)/iResolution.y; \n        n_dist = f_n_dist(o_pix_cor_nor, vec2(0.5,0.0));\n        float n_dist_srgb_converted = pow(n_dist,1.0/2.6);\n        fragColor = vec4(n_dist_srgb_converted); \n    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 532], [533, 533, 590, 590, 1040]], "test": "untested"}
{"id": "ds23W3", "name": "Underwater Mushroom forest", "author": "rcargou", "description": "I love fantasy underwater universe, so I gave it a try\nI wanted to raymarch the mushroom cap to make them emit some light, but it may be too costly", "tags": ["3d", "sdf", "water", "underwater", "mushroom"], "likes": 19, "viewed": 418, "published": 3, "date": "1668268071", "time_retrieved": "2024-07-30T16:20:20.878945", "image_code": "\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat mapWorm(vec3 p, out vec2 id, float h) {\n    return 1E10;\n    vec2 inset = -(p.yz) * .3 * cos( +iTime + 5.*p.x) * .051*cos( +iTime + 5.*p.x);\n    p.yz -= inset;\n    id.x = p.x + iTime/2.;\n    float s = .2;// + .02*cos( +iTime *10.+ 5.*p.x);\n    p.z -= 5.;\n    p.y += h - s;\n    p.z += cos(p.x + iTime) * sin(iTime);\n    float d = length(p.yz) - s;\n\n    return d;\n}\n\nfloat mapstarfish(in vec3 pos, out vec2 id, float h) {\n    pos.xz*=2.;\n    float rep = 3.;\n    vec3 mp = mod(pos.xxz, rep) - rep / 2.;\n    mp.xz = rotate2d(.3) * mp.xz;\n    vec2 l_id = hash22(floor(pos.xz/rep));\n    id.x = l_id.x;\n    if(id.x < .6)\n    return 3.;\n    return opExtrusionT(vec3(mp.x, mp.z, pos.y - 0.0 + h), .03); \n}\n\nfloat mapMushroom(in vec3 pos, out vec2 id, out vec3 ep) {\n    float rep = 3.9;\n    pos.x+=1.;\n    pos.z+=.1;\n    pos.xz = rotate2d(-.2) * pos.xz;\n    \n    vec3 u = pos;\n    vec2 m_id = hash2( 12.387*floor(pos.xz / rep));\n   \n    pos.xz = mod(pos.xz, rep) - rep / 2.;\n    pos.xz = rotate2d(m_id.y*33.14) * pos.xz;\n     pos *= 1.6;\n \n//    pos.x -= m_id.x * 1.;\n    \n    vec3 pcap = pos;\n    \n    pcap.xy = rotate2d(-.5 ) * pcap.xy;\n    pcap.x+=2.;\n    \n    float h= 1.9 + .6*cos(3.14*m_id.y+iTime/1.515) + m_id.x * 4.;\n    id.x = pos.y / h;\n    pos.y += 1.;\n    float bcap = smoothstep(13.0, 2.01, pos.y);\n    pos.x += cos(pos.y/1.5 - sin(iTime)  ) /2.;\n    vec2 r = normalize(vec2(pos.z, pos.x) );\n    float a = atan(r.x, r.y);\n    if(m_id.x < .4 ||noise(floor(u / rep ) *vec3(1, .0, .1)) <.2)\n     return 1.1;\n    vec2 inset = -pos.xz * cos( a * 40. + iTime *0.)  * .5;\n    pcap.xz+= inset / 8.;\n    pos.xz+= inset/64.;\n    float s = .95 - m_id.x * .8 + sin(m_id.y + iTime / 3.) / 10.;\n    float scap = -.1;//-1.05  + sin(m_id.y+iTime / 3.);// + m_id.y/5.*sin(11.*length(pos.xz));\n    id.x = 1. + sin(iTime / 3.);\n    float j = 5.5;\n    float j2 = 5.;\n    float h2 = h  - .0 ;\n    id.y = m_id.y;\n     pcap.y -= h;\n     \n     \n     float prep = 4.;\n //   pcap.y = mod(pcap.y, prep) - prep / 2.;\n\n    float dcap = length(pcap * vec3(1., j, 1.) - vec3(0., j*h*0., 0.)) - scap;\n    ep = pos - vec3(0., j*h, 0.);\n    float dt = max( length(pos.xz) - s, abs(pos.y) - h * 1.2) ;\n    \n//     dcap = opST(indcap, dcap);\n    return smin(dcap, dt, 10.5);\n\n}\n\n\nfloat mapJellyfish(in vec3 pos) {\n\n    float s = 5.;\n    pos.z += 2.;\n    float mrep = 3.5;\n    if (pos.z > 11. || pos.y < -1.5 || pos.y > 4.)\n         return 1e10; \n     ;//pos *= 2.;\n     pos.xy = rotate2d(.2) * pos.xy;\n     \n    vec3 id = floor(pos / vec3(mrep));\n    vec2 r = hash2(id.xz);\n    float t = .5 * (iTime * (1.5 +  r.y / 2.));\n    pos.y -= t / 1. - 0.1*((r.x+ cos(t * 6.)));\n\n    pos.y += r.x * 10.;\n //   pos.x += r.y * 5.;\n    pos = mod(pos, vec3(mrep)) - vec3(mrep/2.);\n    pos.xz = rotate2d(iTime) * pos.xz;\n\n    //pos.xz=rotate2d(5.) * pos.xz;\n//       pos.z += 2.;\n    float h = 2.5 / s;\n    float st = .015 / s;\n    float sc = 1.6 / s;\n    float j = 1.5;\n    \n    float dc = length(pos * vec3(1., j, 1.) - vec3(0., h*j, 0)) - sc;\n \n     float mtrep = .2;\n    float l = 4. /  s;\n    vec2 o = vec2(0.);//floor(pos.xz / mtrep);\n    vec2 ct = pos.xz;\n    ct.x += cos(pos.y * 2./h + iTime * 3. + o.x) / (s * 3.);\n    ct.y += sin(pos.y * 2. / h + iTime * 3. + o.y) / ( s * 3.);\n \n    vec2 mt = ct.xy;//-mtrep*clamp(round(pos.xz/mtrep),-l,l);\n    mt = ct.xy-mtrep*clamp(round(ct.xy/mtrep),-l,l);\n   \n    float dt = max( length(mt) - st, abs(pos.y) - h);\n    return smin(dt, dc, .4 / s);\n}\n\nvec2 map( in vec3 pos, out vec2 id, bool b, out vec3 ep )\n{\n    vec2 res = vec2( 1e10, 0.0f );\n    float d = 1e10;\n    id.y = 1.;\n    float dg=1e10;\n    float y = 1.0;\n    float dm;\n    vec2 tmp_id;\n    \n    if ((dm = mapMushroom(pos, id, ep)) < res.x) {    \n        res.y = 7.0f;\n        res.x = dm;// smin(d, dg+.9, 1.5);\n    }\n    y += noise(pos / 5.) / .5;\n    if ((dg = abs(pos.y + .5 + y ) ) < res.x) {\n        res.y = 3.0f;\n        res.x = dg;//smin(dg, dm, .5);\n    }\n    res.x = smin(dg, dm, .2);       \n    if ((d = abs(pos.y - 10.5 + 1.*getwaves(pos.xz / 5., iTime) ))  < res.x) {\n        res.y = 2.0f;\n        res.x = d;\n    }\n    if ((d = mapJellyfish(pos)) < res.x) {\n        res.y = 5.0f;\n        res.x = d;\n    }\n    if ((d = mapstarfish(pos, tmp_id, y + .5)) < res.x) {    \n        res.y = 8.0f;\n        res.x = d;\n        id = tmp_id;\n    }\n    if ((d = mapWorm(pos, tmp_id, y + .5)) < res.x) {    \n        res.y = 9.0f;\n        res.x = d;\n        id = tmp_id;\n    }    \n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n\n    vec3 acc = vec3(0.);\n    float t = 1.;\n    float far = 40.;\n    float num_step = 164.;\n    float stepSize = (far - 1.) / num_step;\n\n    for(int i = 0; float(i) < num_step; i++) {\n        vec3 pos = ro + rd * t;\n        \n        vec3 pc = pos + vec3(-.2, 0.0, .0) * (abs(pos.y + 20.));\n        float v = (texture(iChannel0, pc.xz / 190. + .5).x);\n       // v = pow(v / 5., .5);\n        v = smoothstep(.4, .1, v);\n        acc += vec3(v) / num_step / max(5.0, pow( (pos.y * 1.), 1.) );\n        t+= stepSize;\n    }\n    return acc;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec2 id, out vec3 ep )\n{\n    vec2 res = vec2(-1.0,-1.0);\n    \n    bool b = false;\n    \n    float tmin = 1.0;\n    float tmax = 35.0;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<250 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t,id, b, ep );\n            if( abs(h.x)<(0.001*t) )\n            { \n                     res = vec2(t,h.y);\n                     break;\n            }\n            t += h.x * .5;\n        }\n    }\n    return res;\n}\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 normal (in vec3 p)\n{\n    vec2 e = vec2(.001, .0);\n    vec2 id;\n    vec3 ep;\n    bool b = false;\n    float d = map (p,id,b, ep).x;\n    vec3 n = vec3 (map (p + e.xyy,id,b, ep).x - d,\n                   map (p + e.yxy,id,b, ep).x - d,\n                   map (p + e.yyx,id,b, ep).x - d);\n    return normalize(n);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    vec2 id;\n    bool d = false;\n    float res = 1.0;\n    float t = mint;\n    vec3 ep;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t,id, d,ep ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    \n    vec3 ep;\n    vec2 id;\n    vec2 res = castRay(ro,rd, id, ep);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 k_water = 2.5*vec3(0.01, .1, .35);\n    vec3 k_sun = 2.*vec3(.5, .2, .1 ) + k_water / 2.;\n    vec3 k_backlit = vec3(2., 3.4, .5) * 2.;\n    vec3 lbackdir = normalize( -vec3(0., 1, 0.) );\n    vec3 ldir = normalize( -vec3(-30., -100, 10.) );\n    vec3 col = vec3(0.);//k_water;\n    vec3 p = ro + rd * t;\n    vec3 nor = normal(p);\n    vec3 albedo = vec3(.2);\n    float ndotl = max(0.2, dot(nor, ldir) );\n    float ndotlback = max(.0, dot(nor, lbackdir) );\n    float d = length(ro - p);\n\n  if (res.x > .0f) {\n    \tvec3 c = vec3((texture(iChannel0, p.xz / 25. + .5).x)) * vec3(0.1, 0.25, 0.55);\n         col += smoothstep(0.05, 0.9, pow(c / 2., vec3(2.2)) / .02) / 2.;\n         col += k_water / 3.;\n    }else {\n        d = 100.;\n    }\n    \n    if (res.y == 5.) {    \n        albedo = vec3(0.,.2,.2)/15.;\n        col+=.4;\n    }\n\n    if (res.y == 3.) {\n        vec3 k_sand = vec3(.5, .5, .1);\n        float shadow = calcSoftshadow( p, -ldir, .5, 10. );\n        vec3 t = k_sand * texture(iChannel1, p.xz * 1.).xxx * 15.;\n        col += t / 8.;\n        //col+=vec3(.2);\n        col = col*.3*shadow + col *.7; \n    }\n\n    if (res.y == 7.) {\n        albedo = vec3(.15);\n        vec3 c1 = vec3(.2, .1, .1);\n        vec3 c4 = pal(id.y/1. + .1,vec3(.00,0.0,.28),vec3(.2,.3,-.16),vec3(0.33,0.36,0.73),vec3(0.74,1.00,0.79));\n        col = .0+ c1/200.;\n        albedo = c4 / 5.;\n        float up = smoothstep(.3, .4, nor.y);\n        //albedo *= vec3( pow( 18./length(ep), 6.5) );\n        col += texture(iChannel2,  p.xz).rrr * up;\n        \n    }\n    if (res.y == 8.) {\n    \n        col += .7 * pal(id.x,vec3(0.95,0.65,0.00),vec3(0.26,0.47,0.00),vec3(0.64,0.57,0.00),vec3(0.00,0.00,0.00));\n        albedo = col;\n    }\n    if(id.y == 4.) {\n    //    col = vec3(.0);\n        albedo += vec3(.2);\n    }\n    if (res.y != 2.) {\n        col += albedo * ndotl * k_sun;\n     } else {\n         col += max(0., smoothstep(.9, 1., -nor.y) ) * vec3(.3, .5, .25) / 2.;\n         col /= 1.3;\n        \n     //    col += vec3(.1,.1,.15) * 2.;\n     }\n     if (res.y == 9.) {\n         albedo = vec3(.3 + .05 * sin(10.* id.x))  * vec3(.44, .4, .1) * 3.;\n     //    albedo *= texture(iChannel1, p.xy * 2.).xxx * 2.;\n         col = albedo ;\n     }\n    //if (res.y == 6.0f) \n      \n    //col+= .1;\n        if(res.y!=2. && res.y != 9.) {\n        col += albedo * ndotlback * k_backlit * 2.;\n    }\n\n    col = mix(col, k_water * 1.8, clamp(pow(d / 33., 2.), 0., 1.  ) );\n         \n   \n    col += mix( vec3(0.), vec3(1.) ,max(0., rd.y / 1.5));\n\n    vec3 r= raymarch(ro, rd) * 8.;\n    col += r;\n    float turfu = 0.;//pow(sin(iTime*8.), 2.);\n    r *= mix(vec3(1.), vec3(1., .3, .3), turfu);\n    col = mix( col, col * ((r) * 1.), turfu * .8); \n   \treturn vec3(col);\n}\n\nfloat ghash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat bubble(vec2 uv) {\n    uv.x -= iTime;\n    // uv.y -= iTime;\n    uv *= 40.;\n    \n    float acc = 0.;\n    for (int i = 0; i < 3; ++i) {\n        float rep = 2.;\n        vec2 f= floor(uv / rep);\n        vec2 ouv = uv;\n        \n        //ouv.x += mod(f.y, 2.);\n         float r = ghash(f / float(21.*float(1+i)));\n        \n        vec2 p = mod(ouv, rep) - rep/2.;\n   // p.y += sin(4.*iTime) * r/2.;\n        float c = smoothstep(.9, .8, length(p) );\n        c *= smoothstep(.3, .75, length(p));\n        if(r < .97)\n            c = 0.;\n        acc+= c;\n        uv *= 2.;\n    }\n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    vec3 ro = vec3( sin(0. / 2.), -.3f ,  -6.0f+ cos(0. / 2.));\n    vec3 ta = vec3( 1., 1.9, 0. );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    vec3 tot = vec3(0.0);\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = normalize( ca * vec3(p.xy,1.4) );\n    ro.x += 2.;// + iTime;\n   // ro.z += iTime*5.;\n    ro.y -=1.;\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col*1. * (.95 + .05*bubble(p.yx + vec2(0., 0.))), vec3(2.5 ));\n\n    tot += col;\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p/1.3 ); p = m*p*2.02;\n    f += 0.2500*noise( p  ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n }\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, float time){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    int iterations = 2;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, time);\n        position += p * res.y * weight * 0.048;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opST( in float d1, in float d2 )\n{\n    d1 *= -1.0;\n    return (d1 > d2) ? d1 : d2;\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nfloat starfish(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    vec2 l = uv;\n \n     float it = 5.;\n    for(int i = 0; i < int(it); ++i) {\n        uv.xy = rotate2d(6.28/it + cos(length(uv) * 2.) / 80. ) * uv;\n        float h = 1.;\n\n        float u = smoothstep(.2, .1, uv.y);\n        float d = min(10.,  max(0., h - ((uv.y) / h) ));\n        d = .5 * (d + pow(d, .3));\n        float l = abs(uv.x + sin(0.)/3.) / d + u;\n        float c = smoothstep(.4, .32, l);\n        col += vec3(c);\n    }\n    col += smoothstep(.3, .2, length(uv) );\n   // col = normalize(col);\n    col.x = smoothstep(.0, .1, col.x);\n   // col.x = 1.;\n    //col /= 1.+length(l)*2.;\n    return 1.-col.x;\n}\nfloat opExtrusionT( in vec3 p, in float h )\n{\n    float d = starfish(p.xy);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}", "buffer_a_code": "float phase1() {\nreturn 0.;\n    return .5* sin(iTime / 6.) + .5;\n} \n// The parameter w controls the smoothness\nvec4 voronoi( in vec2 x, float w )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec4 m = vec4( 8.0, 0.0, 0.0, 0.0 );\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash2( n + g );\n\t\t\n\t\t// animate\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n\n        // distance to cell\t\t\n\t\tfloat d = length(g - f + o);\n\t\t\n        // cell color\n\t\tvec3 col = 0.5 + 0.5*sin( hash1(dot(n+g,vec2(7.0,113.0)))*2.5 + 3.5 + vec3(2.0,3.0,0.0));\n        // in linear space\n        col = col*col;\n        \n        // do the smooth min for colors and distances\t\t\n\t\tfloat h = smoothstep( -1.0, 1.0, (m.x-d)/w );\n\t    m.x   = mix( m.x,     d, h ) - h*(1.0-h)*w/(1.0+3.0*w); // distance\n\t\tm.yzw = mix( m.yzw, col, h ) - h*(1.0-h)*w/(1.0+3.0*w); // color\n    }\n  //     return vec4(length(x) - .5);\n\treturn m;\n}\n\nvec3 eart( vec2 p )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    p *= 10.;\n    float rep = 2.;\n    \n    p = mod(p, rep) - rep/2.;\n    p.y -= 0.25;\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n    \t// color\n\tfloat s = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.4*r;\n\ts = 0.3 + 0.7*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.4*r,0.3)*s;\n\t\n    vec3 col = mix( vec3(0.), hcol, smoothstep( -0.01, 0.01, d-r) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    p-=iTime / 20.;\n    p.x += iTime / 8.;\n    vec3 v = voronoi(p * 20., .5).xyz;\n    vec3 e =vec3(1.) -eart(p);\n    vec3 c = mix(v, e, phase1());\n    fragColor = vec4(c,1.);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds23W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 217, 217, 541], [543, 543, 597, 597, 874], [876, 876, 934, 934, 2424], [2427, 2427, 2460, 2460, 3630], [3632, 3632, 3691, 3691, 4638], [4667, 4667, 4700, 4700, 5234], [5236, 5236, 5302, 5302, 5771], [5775, 5775, 5827, 5827, 6004], [6006, 6006, 6031, 6031, 6321], [6322, 6322, 6400, 6423, 6746], [6748, 6748, 6787, 6787, 9621], [9623, 9623, 9646, 9646, 9726], [9728, 9728, 9751, 9751, 10320], [10322, 10322, 10379, 10379, 11009]], "test": "untested"}
{"id": "ms2GW3", "name": "Failed flow field 🙈", "author": "larserik", "description": "Failing to make particles using pixel scanning.", "tags": ["particles", "flowfield"], "likes": 4, "viewed": 285, "published": 3, "date": "1668267014", "time_retrieved": "2024-07-30T16:20:21.647889", "image_code": "\nbool onEdge(vec2 fragCoord) {\n    return fragCoord.x > iResolution.x - 1.\n         || fragCoord.x < 1.\n         || fragCoord.y > iResolution.y - 1.\n         || fragCoord.y < 1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec4 col = texture(iChannel1, fragCoord/iResolution.xy);\n    if (onEdge(fragCoord)) {\n        col = vec4(1.);\n    }\n    // Output to screen\n    fragColor = 1. - col;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm (in vec3 st, int octaves) {\n    float value = 0.0;\n    float amplitude = 1.;\n    float total = 0.;\n\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude;\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= 0.5;\n    }\n\n    return value / total;\n}", "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 5.;\n    float n = fbm(vec3(uv, 0.), 2)*.5+.5;\n    fragColor = vec4(vec3(n),1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define TAU 6.28318\n#define SCALE 1.\n#define OCTAVES 6\n#define SPEED .5\n#define GROWTH 1.005\n\nconst float threshold = .998;\n\nfloat rnd21(vec2 p) {\n    return fract(sin(dot(p, vec2(137.37, 387.531)))*57843.761);\n    //return snoise(vec3(p,iTime));\n    //fract(sin(p.x*754.43+p.y*645.32)*5430.32);\n}\n\nbool onEdge(vec2 fragCoord) {\n    return fragCoord.x > iResolution.x - 1.\n         || fragCoord.x < 1.\n         || fragCoord.y > iResolution.y - 1.\n         || fragCoord.y < 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 starCoord = fragCoord / 500.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= SCALE;\n    float n = fbm(vec3(uv, iTime*SPEED), OCTAVES)+.5;\n    float a = TAU * n;\n    vec2 d = vec2((cos(a)), (sin(a)));\n\n    if (iTime < .05) {\n        if (rnd21(starCoord+iTime)>.99) {\n            fragColor = vec4(1.0,1.0,1.0,1.0);\n        } else {\n            fragColor = vec4(0.00001);\n        }\n    } else {\n\n        if (onEdge(fragCoord) && rnd21(starCoord+iTime)>.9) {\n            fragColor = vec4(1.0,1.0,1.0,1.0);\n        } else if (!onEdge(fragCoord+d)) {\n            fragColor = texture(iChannel0, ((fragCoord+d)/iResolution.xy))*GROWTH;\n        } else {\n            fragColor = vec4(0.00001);\n        }\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2GW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 180], [183, 183, 240, 240, 477]], "test": "untested"}
{"id": "dsj3W3", "name": "Amber windows terminal shader", "author": "mrange", "description": "CC0: Amber windows terminal shader\nI did a hercules green shader for Windows Terminal\nI wanted an amber one as well to \"relive\" the good old days\n Distance field based on an older shader but now with a glowing amber\n\n", "tags": ["windowsterminal"], "likes": 12, "viewed": 429, "published": 3, "date": "1668266886", "time_retrieved": "2024-07-30T16:20:22.406860", "image_code": "// CC0: Amber windows terminal shader\n//  I did a hercules green shader for Windows Terminal\n//  I wanted an amber one as well to \"relive\" the good old days\n//  Distance field based on an older shader but now with a glowing amber\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// -------------------------------------------------\n// Mandelbox - https://www.shadertoy.com/view/XdlSD4\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst float folding_limit = 1.0;\nconst float scale         = -2.8;\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\nvec3 pmin(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  const float k = 0.05;\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*pmin(abs(z), vec3(folding_limit), vec3(k));\n  // Hard clamp\n  // z = clamp(z, -folding_limit, folding_limit);\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));\n        r2 = abs(r2) - 0.25;\n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return (fd);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat df(vec2 p) {\n  const float s = 0.45;\n  p /= s;\n  float rep = 20.0;\n  float ss = 0.05*6.0/rep;\n  vec3 p3 = vec3(p.x, p.y, smoothstep(-0.9, 0.9, sin(TIME*0.21)));\n  p3.yz *= ROT(TIME*0.05);\n  p3.xy *= ROT(TIME*0.11);\n  float n = smoothKaleidoscope(p3.xy, ss, rep);\n  float d = mb(p3)*s;\n  return abs(d);\n}\n\n\n// -------------------------------------------------\n\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  \n  float d = df(p);\n  const float hoff = 0.685;\n  const float inte = 0.85;\n  const vec3 bcol0 = HSV2RGB(vec3(0.50+hoff, 0.85, inte*0.85));\n  const vec3 bcol1 = HSV2RGB(vec3(0.33+hoff, 0.85, inte*0.025));\n  const vec3 bcol2 = HSV2RGB(vec3(0.45+hoff, 0.85, inte*0.85));\n  vec3 col = 0.1*bcol2;\n  col += bcol1/sqrt(abs(d));\n  col += bcol0*smoothstep(aa, -aa, (d-0.001));\n  \n  col *= smoothstep(1.5, 0.5, length(pp));\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  col = aces_approx(col);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsj3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[561, 561, 583, 583, 729], [1024, 1124, 1143, 1143, 1230], [1232, 1339, 1365, 1365, 1549], [1790, 1890, 1929, 1929, 2014], [2016, 2104, 2143, 2143, 2172], [2174, 2262, 2292, 2292, 2319], [2320, 2320, 2355, 2355, 2443], [2444, 2444, 2492, 2492, 2762], [2764, 2764, 2809, 2809, 3029], [3031, 3031, 3062, 3062, 3086], [3088, 3088, 3117, 3117, 3182], [3185, 3185, 3203, 3203, 3694], [3696, 3696, 3718, 3718, 3762], [3764, 3764, 3785, 3785, 3830], [3832, 3832, 3877, 3877, 4031], [4032, 4120, 4181, 4181, 4394], [4396, 4396, 4414, 4414, 4705], [4763, 4763, 4793, 4793, 5259], [5261, 5261, 5316, 5316, 5533]], "test": "untested"}
{"id": "dd2GW3", "name": "Scrolling stars", "author": "larserik", "description": "First step towards something nice (tm)", "tags": ["particles", "stars"], "likes": 0, "viewed": 207, "published": 3, "date": "1668263564", "time_retrieved": "2024-07-30T16:20:23.169820", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec4 col = texture(iChannel1, fragCoord/iResolution.xy);\n\n    // Output to screen\n    fragColor = col;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm (in vec3 st, int octaves) {\n    float value = 0.0;\n    float amplitude = 1.;\n    float total = 0.;\n\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude;\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= 0.5;\n    }\n\n    return value / total;\n}", "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 5.;\n    float n = fbm(vec3(uv, 0.), 2)*.5+.5;\n    fragColor = vec4(vec3(n),1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "const float threshold = .999;\n\nfloat rnd21(vec2 p) {\n    return fract(sin(dot(p, vec2(137.37, 387.531)))*57843.761);\n    //return snoise(vec3(p,iTime));\n    //fract(sin(p.x*754.43+p.y*645.32)*5430.32);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 starCoord = fragCoord / 500.;\n\n    if (iTime < 5.) {\n        if (rnd21(starCoord)>threshold)\n            fragColor = vec4(1.0,1.0,1.0,1.0);\n        else\n            fragColor = vec4(0);\n    } else {\n        if (fragCoord.x >= iResolution.x - 1.) {\n            if (rnd21(starCoord+iTime)>threshold) {\n                fragColor = vec4(1.0,1.0,1.0,1.0);\n            }\n            else {\n                fragColor = vec4(0);\n            }\n        } else {\n            fragColor = texture(iChannel0, (fragCoord+vec2(1,0))/iResolution.xy);\n        }\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2GW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 231]], "test": "untested"}
{"id": "DsjGWc", "name": "Racetrack Path", "author": "Zyphery", "description": "It's a racetrack shape path or capsule idk what to call it", "tags": ["mask", "path", "shape", "capsule", "racetrack"], "likes": 8, "viewed": 134, "published": 3, "date": "1668249723", "time_retrieved": "2024-07-30T16:20:23.925799", "image_code": "#define PI 3.14159265\n#define TAU (2.0 * PI)\n#define EDGE 0.003\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length(pa - h * ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float d = udSegment(uv, vec2(0.3), vec2(0.3, 0.7));\n        \n    float midSegment = step(0.3, uv.y) * step(uv.y, 0.7);\n    \n    float topMask = step(0.7, uv.y);\n    float bottomMask = step(uv.y, 0.3);\n    float leftMask = midSegment * step(uv.x, 0.3);\n    float rightMask = midSegment * step(0.3, uv.x);\n  \n    \n    float top = (2.0 * mod(atan(uv.y - 0.7, uv.x - 0.3) / TAU, 1.0)) * topMask;\n    float bottom = (2.0 * mod((PI + atan(uv.y - 0.3, uv.x - 0.3)) / TAU, 1.0)) * bottomMask;\n    float left = (uv.y * -2.5 + 1.75) * leftMask;\n    float right = (uv.y * 2.5 - 0.75) * rightMask;\n    \n    float route = right * 0.25 + top * 0.25 + topMask * 0.25 + left * 0.25 + leftMask * 0.5 + bottom * 0.25 + bottomMask * 0.75;\n\n    col = vec3(mod(route - iTime, 1.0));\n    \n    col = mix(vec3(0.0), col, smoothstep(0.2, 0.2 + EDGE, d));\n    col = mix(vec3(0.0), col, smoothstep(0.3, 0.3 - EDGE, d));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 116, 116, 247], [249, 249, 306, 306, 1312]], "test": "untested"}
{"id": "cdjGWc", "name": "12 Draw an image of the function", "author": "ccc9527", "description": "Draw an image of the function", "tags": ["function", "draw"], "likes": 1, "viewed": 167, "published": 3, "date": "1668249114", "time_retrieved": "2024-07-30T16:20:24.748599", "image_code": "#define PI 3.1415926\n\nvec3 Grid(in vec2 uv) //绘制坐标系及网格\n{\n    vec2 cell = floor(mod(uv,2.)); //取余\n    vec3 res = vec3(0.4);\n    \n    if(cell.x == cell.y) res = vec3(0.6);\n    \n    //fwidth(uv.x)表示水平方向一个像素的宽度\n    res = mix(res,vec3(0),smoothstep(1.1*fwidth(uv.x),fwidth(uv.x),abs(uv.x)));//y轴，黑色\n    res = mix(res,vec3(0),smoothstep(1.1*fwidth(uv.y),fwidth(uv.y),abs(uv.y)));//x轴，黑色\n\n    return res;\n}\n\nvec2 fixUV(vec2 fragCoord)\n{\n    return 3.*(2.*fragCoord - iResolution.xy) / min(iResolution.x,iResolution.y);\n}\n\nfloat Function(float x)  //需要绘制的图形的函数\n{\n    vec2 m = fixUV(iMouse.xy);\n    float T = 4.+2.*cos(iTime);\n    if(iMouse.z>0.1)\n        T += m.x;\n    \n    //return smoothstep(1.,0.,x);\n    //return mod(x,2.);\n    return sin(2.*PI/T*x+iTime);\n}\n\nfloat Draw(vec2 uv)\n{\n    float fx = uv.x;//当前uv点的x值\n    float fy = Function(fx);//用当前uv点的x值带入要绘制的函数种得到对应的y值\n\n    return smoothstep(fy-0.01,fy+0.01,uv.y);\n}\n\n#define AA 4\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = fixUV(fragCoord);\n    \n    vec3 col = Grid(uv);\n    \n    float count = 0.;\n    for(int m=0;m<AA;m++)\n    {\n        for(int n=0;n<AA;n++)\n        {\n            vec2 offset = (vec2(float(m),float(n))-0.5*float(AA))/float(AA)*2.;\n            count += Draw(fixUV(fragCoord+offset));\n        }\n    }\n    \n    if(count>float(AA*AA)/2.)\n        count = float(AA*AA)-count;\n    count = 2.*count/float(AA*AA);\n    \n    col = mix(col,vec3(1.,1.,0.),count);\n  \n    //col = vec3(Draw(uv));\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 72, 72, 461], [463, 463, 491, 491, 575], [577, 577, 636, 636, 836], [838, 838, 859, 859, 1046], [1061, 1061, 1115, 1115, 1644]], "test": "untested"}
{"id": "ssjSRw", "name": "SDF to Mesh II", "author": "oneshade", "description": "Interpolation within tetrahedral cells, ensuring planar facets.\nLook around with the mouse.", "tags": ["3d", "raymarching", "sdf", "effect", "barycentric", "interpolation", "mesh", "sdftomesh", "tetrahedral"], "likes": 28, "viewed": 438, "published": 3, "date": "1668240388", "time_retrieved": "2024-07-30T16:20:25.581372", "image_code": "// Mesh resolution\n#define RES vec3(0.5)\n\n// Inigo Quilez's polynomial smooth minimum from https://iquilezles.org/articles/smin:\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat mapScene(in vec3 p) {\n    float dist = length(p - vec3(-1.0, -1.0 + sin(iTime), 1.0)) - 1.5;\n    dist = smin(dist, length(p - vec3(1.0, 1.0 + 0.5 * cos(iTime), -1.0)) - 2.0, 1.5);\n    dist = smin(dist, length(p - vec3(-4.0, 1.0, 0.5)) - 2.0, 1.0);\n    dist = smin(dist, length(p - vec3(-2.0, 1.0, -3.0)) - 1.0, 2.25);\n    dist = smin(dist, length(p - vec3(3.0 + cos(iTime), -1.0, -1.0)) - 1.0, 1.0);\n    return dist;\n}\n\n// Meshify!\nfloat mapMesh(in vec3 p, out vec3 nor) {\n    vec3 pos = floor(p / RES) * RES;\n    vec3 uvw = (p - pos) / RES;\n\n    // Determine the vertices of the tetrahedron we're in\n    vec3 v0 = dot(uvw, vec3( 1,  1,  1)) > 2.0 ? vec3(1, 1, 1) : vec3(0, 0, 0);\n    vec3 v1 = dot(uvw, vec3(-1, -1,  1)) > 0.0 ? vec3(0, 0, 1) : vec3(1, 1, 0);\n    vec3 v2 = dot(uvw, vec3(-1,  1, -1)) > 0.0 ? vec3(0, 1, 0) : vec3(1, 0, 1);\n    vec3 v3 = dot(uvw, vec3( 1, -1, -1)) > 0.0 ? vec3(1, 0, 0) : vec3(0, 1, 1);\n\n    // Solve for barycentric coordinates\n    mat4 map = inverse(transpose(mat4(v0, 1, v1, 1, v2, 1, v3, 1)));\n    vec4 bary = vec4(uvw, 1) * map;\n\n    // Calculate isovalues at the tetrahedron vertices\n    vec4 isovals = vec4(\n        mapScene(pos + v0 * RES),\n        mapScene(pos + v1 * RES),\n        mapScene(pos + v2 * RES),\n        mapScene(pos + v3 * RES)\n    );\n\n    nor = normalize((map * isovals).xyz / RES); // Normalized gradient\n    return dot(isovals, bary); // Interpolate isovalues\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.24375, 0.16125, 0.07875, 1.0);\n\n    // Default before interaction\n    if (ivec2(iMouse) == ivec2(0)) mouse = vec2(-0.25, -0.5);\n\n    // Calculate ray\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Raymarch\n    float t = 0.0;\n    vec3 nor;\n    for (int i=0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float dist = mapMesh(p, nor);\n        if (dist < 0.001) {\n            fragColor.rgb = 0.5 + 0.5 * nor;\n            break;\n        }\n\n        if (t > 25.0) {\n            break;\n        }\n\n        t += dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 129, 177, 177, 280], [282, 282, 309, 309, 706], [708, 720, 760, 760, 1708], [1710, 1710, 1765, 1765, 2772]], "test": "untested"}
{"id": "csjGW3", "name": "Fractal arcade", "author": "jarble", "description": "A fractal structure with many glowing neon lights.", "tags": ["3d", "fractal"], "likes": 2, "viewed": 250, "published": 3, "date": "1668228899", "time_retrieved": "2024-07-30T16:20:26.338348", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 stars(vec3 uv)\n{\n    //uv = uv.yzx;\n    vec3 col = vec3(0.);\n    \n    for(int k = 0; k < 6; k++){ \n        uv =\n            //min(uv*vec3(uv.y+uv.x+.5,uv.z+uv.y+.5,uv.x+uv.z)*3.,abs(fract(vec3(uv.y+uv.x+.5,uv.z+uv.y+.5,uv.x+uv.z))-.5))\n            min(uv*vec3(uv.y+uv.x,uv.z+uv.y,uv.x+uv.z)*2.,abs(fract(vec3(uv.y+uv.x+1.,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n            //min(uv/2.*vec3(sqrt(uv.x*uv.y),sqrt(uv.z*uv.y),uv.x+uv.z)*4.,abs(fract(vec3(uv.y+uv.x,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n            //min(uv*vec3(uv.y+uv.x+.125,uv.z+uv.y+.75,uv.x+uv.z)*4.,abs(fract(vec3(uv.y+uv.x+1.,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n            //min(uv*vec3(uv.y*4.,uv.z,uv.x+uv.z)*4.,abs(fract(vec3(uv.y+uv.x+1.,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n        ;\n        col =\n            vec3(col.yz,uv.x-uv.y).yzx\n            //vec3(col.yz,uv.x).yzx\n            //vec3(col.yz,sqrt(uv.x*uv.y)).yzx\n        ;\n        if(uv.y>uv.x || uv.z>uv.y) uv = uv.yzx;\n    }\n    \n    return\n        col.yzx\n        //col - uv;\n    ;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(-2.,0.,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = stars(p/16.);\n        float sd1 = col.z-.1;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "sound_code": "#define fract1(a) (1.-fract(a)*fract(a))\n\n#define fmod(x,y) mod(floor(x),y)\nvec2 mainSound(int samp, float t){\n  float s1 =\n      8.,\n  m1 =\n      //fmod(t*s1,s1),\n      fmod(floor(t*s1)+floor(t*s1/2.)+floor(t*s1/4.),s1),\n      //fmod(t*s1-floor(t),s1),\n  z1 =\n      (1.+fmod(t,2.))\n  ;\n  t /=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n  ;\n  float m3 =\n      fmod((t)/(m1+.5),s1)\n  ;\n  t *=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n  ;\n\n  float a=\n      //sqrt((1.-sqrt(fract(t*s1))))*.2\n      -log(1./16.+fract1(-t*s1)/1.5)*.2\n  ,\n\n  nb = pow(2.,(m3+z1)/5.+7.);\n\n  return abs(.5-vec2(fract1(t*nb*.998)*a\n   ,fract1(t*nb)*a));\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 275, 294, 1248], [1250, 1250, 1291, 1291, 1830]], "test": "untested"}
{"id": "mdS3Wc", "name": "i dont know but this hurts eyes", "author": "jonasfrey", "description": "this hurts my eyes somehow", "tags": ["hexagon"], "likes": 3, "viewed": 164, "published": 3, "date": "1668214748", "time_retrieved": "2024-07-30T16:20:27.181095", "image_code": "vec4 f_o_dist_flower(\n    vec2 o_pix_cor_nor,\n    vec2 o_target, \n    float n_leaves\n){\n    vec2 o_delta = o_pix_cor_nor - o_target;\n    float n_tau = 6.2831;\n    float n_angle = atan(o_pix_cor_nor.x , o_pix_cor_nor.y);\n    float n_leave = n_angle / (n_tau/n_leaves); \n    float n_angle_mod = mod(n_angle, n_tau/n_leaves);\n    float n_angle_mod_norm = n_angle_mod / (n_tau/n_leaves);\n    float n_angle_mod_norm_modhalf = mod(n_angle_mod_norm, 0.5);\n    float n_angle_mod_norm_linear_in_out;\n    if(n_angle_mod_norm > 0.5){\n        n_angle_mod_norm_linear_in_out = 1.0 - (n_angle_mod_norm_modhalf*2.0);\n    }else{\n        n_angle_mod_norm_linear_in_out = (n_angle_mod_norm_modhalf*2.0);\n    }\n  \n    float n_dist_squared = o_delta.x * o_delta.x + o_delta.y * o_delta.y;\n    float n_dist_squared_modified = n_dist_squared *\n        (1.0 - (n_angle_mod_norm_linear_in_out*-1.0));\n\n    \n    return \n        vec4(\n            sqrt(n_dist_squared_modified),\n            n_leave/n_leaves, \n            n_angle, \n            n_angle_mod_norm\n        );\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pix_cor_nor = (fragCoord-0.5*iResolution.xy)/iResolution.y; \n    vec4 o_dist = f_o_dist_flower(o_pix_cor_nor, vec2(0.0,0.0), 3.0);\n    \n    \n    fragColor = vec4(\n        (sin(o_dist.x*444.0))\n        ); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdS3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 87, 87, 1051], [1052, 1052, 1109, 1109, 1327]], "test": "untested"}
{"id": "DsjGR3", "name": "Raymarched Shifting Hallway", "author": "Aurcereal", "description": "Maybe WIP - rly unorganized unoptimized code so probably don't look.  Has artifacts on some computers (can't find its cause)", "tags": ["raymarching"], "likes": 2, "viewed": 132, "published": 3, "date": "1668210642", "time_retrieved": "2024-07-30T16:20:27.943058", "image_code": "\n\n\nvec4 image(vec2 fragCoord)\n{\n    //set time\n    time = iTime;\n    //bendTheta = sin(time) * (PI/12.0) * .5;\n    \n    //do bending\n    float z = time*24.0; //12.0\n    vec3 pnt = vec3(sampleBendCurve(z), z); ////0.0 oc\n    z -= 23.0;\n    //time -= 2.0;\n    vec3 dir = normalize(vec3(sampleBendCurve(z+NORMALEPS), z+NORMALEPS) - vec3(sampleBendCurve(z), z));\n    //time += 2.0;\n    \n    //get camera ray and sample\n    Camera cam = createCamera(pnt, dir, vec3(0.0, 1.0, 0.0));\n    \n    vec2 cRaySS = (fragCoord/iResolution.xy)*2.0-1.0;\n    vec3 cRayWS = CS2WS(SS2CS(cRaySS, cam), cam);\n    \n    int steps;\n    float dist = trace(cam.position, cRayWS, steps);\n    \n    vec3 col = vec3(0.0);\n    if(dist < MAXDIST + time*4.0*1.0)\n    {\n        vec3 norm = getNormal(cam.position + cRayWS * dist);\n        col = norm * 0.5 + 0.5;\n    }\n    else\n    {\n        float angFrac = acos(cRayWS.y)/PI;\n        col = angFrac * vec3(0.3, 0.1, 0.8);\n    }\n    \n    // Output\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 col = vec4(0.0);\n    \n    int iterSize = 1; //!! THE SAMPLE RATE PER PIXEL IS THIS NUMBER SQUARED - SO YOU CAN INCREMENT IT FOR ANTI-ALIASING !!\n    float iIter = 1.0 / float(iterSize);\n    for(int x=0; x<iterSize; x++)\n    {\n        for(int y=0; y<iterSize; y++)\n        {\n            col += image(fragCoord + vec2(float(x) * iIter, float(y) * iIter));\n        }\n    }\n\n    fragColor = col * iIter * iIter;\n}", "image_inputs": [], "common_code": "///CONSTANTS\n#define MAXSTEPS 100\n#define MAXDIST 50.0\n#define SDEPS 0.01\n#define NORMALEPS 0.05 //.05\n#define D2R 0.0174533\n#define R2D 57.296\n#define PI 3.14159265\n#define IPI .318309886\n\n///CAMERA STUFF START\nstruct Camera\n{\n    vec3 position;\n    \n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    \n    float fovX;\n    float fovY;\n    \n};\n\nCamera createCamera(vec3 pos, vec3 forward, vec3 up)\n{\n    return Camera(pos, cross(up, forward), up, forward, 90.0*D2R, 60.0*D2R);\n}\nCamera createForwardCamera(vec3 pos, float theta)\n{\n    return Camera(pos, vec3(cos(theta),0.0,sin(theta)), vec3(0.0,1.0,0.0), vec3(cos(theta+PI*0.5),0.0,sin(theta+PI*0.5)), 90.0*D2R, 60.0*D2R);\n}\n\nvec3 SS2CS(vec2 raySS, float fovX, float fovY)\n{\n    float z = 1.0;\n    return normalize(vec3(z*tan(fovX/2.0)*raySS.x, z*tan(fovY/2.0)*raySS.y, z));\n}\nvec3 SS2CS(vec2 raySS, Camera cam) {return SS2CS(raySS, cam.fovX, cam.fovY);}\n\nvec3 CS2WS(vec3 rayCS, vec3 right, vec3 forward, vec3 up)\n{\n    return vec3(dot(rayCS, right), dot(rayCS, up), dot(rayCS, forward));\n}\nvec3 CS2WS(vec3 rayCS, Camera cam) { return CS2WS(rayCS, cam.right, cam.forward, cam.up); }\n\n///SDF functions\nfloat sdSphere(vec3 p, vec4 sphere)\n{\n    return MAXDIST;\n    return length(p - sphere.xyz) - sphere.w;\n}\nfloat sampleFunc(float x)\n{\n    x = sqrt(PI*0.5*200.0 + pow(mod(x, sqrt(26.0*PI*200.0)),2.0));\n    return sin(x*x*0.005);\n}\n\n//Hallway Stuff\nfloat time;\nfloat bendTheta;\n\nvec2 sampleBendCurve(float z)\n{\n    z *= 0.1;\n\n    float y = 1.*15.*(sin(z*PI*.5/15.)*0.5+0.5)*sin(time+z*0.2)*1.5+cos(z)*2.0*(sin(0.8*time)*0.5+0.5)*2.0+3.0;          \n    float x = sin(z)*(sin(0.8*time)*0.5+0.5)*2.0+3.0;\n    \n    return .7*vec2(x, y);\n}\n\nfloat sdHallway(vec3 p, vec2 dimensions, vec3 right, float time)\n{\n    //p.z += time*24.0;\n    \n    vec3 origin = vec3(sampleBendCurve(p.z), p.z);\n    vec3 forward = normalize(vec3(sampleBendCurve(p.z+NORMALEPS), p.z+NORMALEPS) - origin);\n    \n    float len = p.z;//*.5;//p.z*(.7-abs(sin(time))*.4); //use arc length later\n    //float scaleFrom = p.z - 10.0;//p.z - mod(p.z, 100.0);\n    //len = (p.z - scaleFrom) * (.7-(sin(time*0.4))*.4) + scaleFrom;\n\n    vec3 up = cross(right, forward);\n    right = cross(forward, up);\n\n    p = p - origin;\n    p = vec3(dot(p, right), dot(p, up), dot(p, forward));\n    \n    dimensions += sampleFunc(len); //mod(len, 100.0) for some reason looks cool and not broken?\n    \n    return min(min(dimensions.x - p.x, dimensions.x + p.x), min(dimensions.y - p.y, dimensions.y + p.y));\n} \nfloat sdHallwayWorst(vec3 p, vec2 dimensions, vec3 right, float time)\n{\n \n    //used to just return here\n    float dist1 = sdHallway(p, dimensions, right, time);\n    \n    //worst case dist\n\n    float distReg = min(min(dimensions.x - p.x, dimensions.x + p.x), min(dimensions.y - p.y, dimensions.y + p.y));\n    dimensions += min(distReg, 1.0);\n    \n    float y = 0.0;\n    float xEps = mix(.2, 4., clamp((time - 0.0)/(40.0 - 0.0), 0.0, 1.0));//3.;\n    float distWorst = sqrt(xEps*xEps);\n    \n    return min(distWorst, dist1);\n} \n\nvec3 twistScene(vec3 p)\n{\n    //p.z += time*24.0;\n    \n    //rotation amount\n    float len = p.z; //use arc length later\n    float twistTheta = (len+time*4.0) * 0.05;\n    \n    //origin and rot axis\n    //vec3 origin = vec3(0.0);\n    //vec3 forward = vec3(0.0, 0.0, 1.0);\n    vec3 origin = vec3(sampleBendCurve(p.z), p.z);\n    vec3 forward = normalize(vec3(sampleBendCurve(p.z+NORMALEPS), p.z+NORMALEPS) - origin);\n    \n    //get axis' (don't matter as long as perp)\n    vec3 arb1 = vec3(0.0, 1.0, 0.0); //arbitrary vec -> right and up\n    vec3 arb2 = vec3(1.0, 0.0, 0.0);\n    \n    vec3 right = normalize(2.0 * normalize(cross(arb1, forward)) + 1.0 * normalize(cross(arb2, forward)));\n    vec3 up = cross(forward, right);\n\n    //convert to axis space\n    p = vec3(dot(p - origin, right), dot(p - origin, up), dot(p - origin, forward));\n    \n    //rotate about z in axis space\n    p = p.x * vec3(cos(twistTheta), sin(twistTheta), 0.0) + p.y * vec3(cos(twistTheta+PI*.5), sin(twistTheta+PI*.5), 0.0) + p.z * vec3(0.0, 0.0, 1.0);\n    \n    //convert back to world space\n    p = p.x * right + p.y * up + p.z * forward + origin;\n    \n    //p.z -= time*24.0;\n    \n    return p;\n}\n\n\n///RAYMARCHING and SDF sampling\n\n\nfloat sampleSDF(vec3 p)\n{\n    p = twistScene(p);\n    return sdHallway(p, vec2(5.0, 8.0), vec3(1.0, 0.0, 0.0), time);\n}\nfloat sampleSDFWorst(vec3 p)\n{\n    p = twistScene(p);\n    return sdHallwayWorst(p, vec2(5.0, 8.0), vec3(1.0, 0.0, 0.0), time);\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(NORMALEPS*(1.0+4.0*smoothstep(80.0, 450.0, time)), 0.0);\n    \n    //this creates some other artifacts so if your computer doesn't have the ridging artifacts, turn this to 0\n    float scaleBandaid = 0.0;\n    vec3 scale = vec3(1.0) + scaleBandaid*normalize(vec3(sampleBendCurve(p.z+NORMALEPS), p.z+NORMALEPS) - vec3(sampleBendCurve(p.z), p.z));\n\n    return normalize(vec3(\n    (sampleSDF(p + e.xyy*scale.x) - sampleSDF(p - e.xyy*scale.x))/scale.x,\n    (sampleSDF(p + e.yxy*scale.y) - sampleSDF(p - e.yxy*scale.y))/scale.y,\n    (sampleSDF(p + e.yyx*scale.z) - sampleSDF(p - e.yyx*scale.z))/scale.z\n    ));\n}\n\nfloat trace(vec3 ro, vec3 rd, out int steps) //all WS and rd is normalized\n{\n    float dist = 0.0;\n    float sd;\n    \n    float startSign = sign(sampleSDF(ro));\n    \n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        steps++;\n        sd = sampleSDF(ro + rd*dist);\n        dist += sd;\n        \n        if(abs(sd) <= SDEPS || dist >= MAXDIST + time*4.0*1.0 ) { return dist; }\n    }\n    \n    return dist;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 31, 46, 989], [991, 991, 1049, 1049, 1468]], "test": "untested"}
{"id": "dsSGD3", "name": "Monte Carlo Gaussian Blur", "author": "Hatchling", "description": "Gaussian blur implemented by randomly sampling from a gaussian distribution, instead of using a fixed width kernel.", "tags": ["blur", "gaussian", "monte", "carlo"], "likes": 6, "viewed": 310, "published": 3, "date": "1668210387", "time_retrieved": "2024-07-30T16:20:28.788796", "image_code": "const int Quality = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurPower = blurMask(fragCoord, iTime) * 5.0;\n    \n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973)\n    ) | uint(1);\n    \n    fragColor = vec4(0);\n    \n    for(int i = 0; i < Quality; i++)\n    {\n        fragColor += gaussianBlurSample\n        (\n            iChannel0,\n            iChannel1,\n            fragCoord,\n            blurPower-2.0,\n            max(0.0, pow(2., blurPower)-1.0),\n            rngState\n        );\n    }\n    \n    fragColor *= 1.0 / float(Quality);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\nvec4 gaussianBlurSample\n(\n    sampler2D texture,\n    sampler2D blueNoise,\n    vec2 fragCoord, \n    float lod, \n    float blurSize, \n    inout uint rngState\n)\n{\n    fragCoord += uniform01ToGauss\n    (\n        sampleBlueNoise(blueNoise, fragCoord, rngState).xy\n    ) * blurSize;\n\n    vec2 uv = fragCoord/vec2(textureSize(texture, 0));\n    \n    return textureLod(texture, uv, lod);    \n}\n\nfloat blurMask(vec2 fragCoord, float iTime)\n{\n    return cos(iTime + fragCoord.x / 100.) *\n    sin(iTime + fragCoord.y / 100.) * 0.5 + 0.5;    \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 579]], "test": "untested"}
{"id": "DsS3D3", "name": "rolling snake", "author": "FabriceNeyret2", "description": "I wanted to capture the motion of alternate crawling direction of this snake's rings:\nreference: [url]  https://twitter.com/Rainmaker1973/status/1590784802684571648  [/url]\n\nWindowsians: for now, see gelami's version: https://www.shadertoy.com/view/csjGWd", "tags": ["snake", "parameterization", "reproduction"], "likes": 34, "viewed": 518, "published": 3, "date": "1668196258", "time_retrieved": "2024-07-30T16:20:29.543778", "image_code": "// different way to turnaround the nested ()?: Windows Angle bug \n// original() ?: 967        ( switch comments below. currently using gelami solution. )\n//         vec2 1007          https://www.shadertoy.com/view/cs23Dd\n// gelami: if    971  ( and explains the bug ) https://www.shadertoy.com/view/csjGWd\n// abje:   step ~975 (1005)   https://www.shadertoy.com/view/cd23Dd\n//         func 1005 (2 ways) https://www.shadertoy.com/view/ddfXRn\n\n#define rot(a) mat2(cos( (a) + vec4(0,-1.57,1.57,0)))\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2  R = iResolution.xy,\n          U = 4.*( 2.*u - R ) / R.y, V, U0=U;\n    float S = sign(U0.x+.5), y, t = 0.,        // S: mirror side  t: parameterization\n          l = length(U)-.5, a = atan(-U.x,U.y),\n         \n    v =  l < 0. ? 0.                                                  // empty center\n       : l < 1. ?   a > 0. ?   a < 2.1 ? t = 2.1-a, l                 // left neck\n                  :(t=2.1-a, min(1.,length(U-vec2(-.87,-.5))+.5))     // head \n                  : a > -2.1 ? t = 2.1-a, l : 0.                      // right neck\n       : l < 2. ? a < 2.1 && a > -1.57 ? t = 19.35+2.*(a-2.1), l : 0. // second ring\n       : l < 3. ? a < 1.57 && a > -1.  ? t = 26.7+3.*(1.57-a), l : 0. // third ring\n       : 0.;   \n    U.x = -.5-abs(U.x+.5);                            // loops\n    U = U - vec2(-2,-2.5); \n    l = -U.x-.5;                                      // vertical straight part \n // v = l >  0. && l < 1.&& U.y>0. && U.y < 2.6 ? t = U.y+(S<0.?24.2:9.5), l : v; // bug on Windows\n    if( l >  0. && l < 1.&& U.y>0. && U.y < 2.6 ) t = U.y+(S<0.?24.2:9.5), v = l;\n    V = U * rot( S < 0. ?.54 : .455 );                // diagonal straight part \n    l = V.x-.5;   \n // v = l >  0. && l < 1.&& V.y>0. && V.y< (S<0.?1.2:1.77) ? t =(S<0.?20.5:5.93)-V.y, l : v; // bug on Windows\n    if( l >  0. && l < 1.&& V.y>0. && V.y< (S<0.?1.2:1.77) ) t =(S<0.?20.5:5.93)-V.y, v = l;\n    \n    l = length(U)-.5, a = atan(-U.x,U.y);             // loop turn\n // v = l > 0. && l < 1. && ( a < -1. || a > 1.57 ) ? t = (S<0.?14.65:0.)+(a<0.?4.8:9.5+1.57)-a, l : v; // bug on Windows\n    if( l > 0. && l < 1. && ( a < -1. || a > 1.57 ) ) t = (S<0.?14.65:0.)+(a<0.?4.8:9.5+1.57)-a, v = l;\n    \n    U = U0 - vec2(3.37,2.17);\n    l = length(U)-.5, a = atan(-U.x,U.y);             // tail // using step(a,0.)*(40.7-34.4)+34.4 would also fix the bug\n // v = l > 0. && l < 1. && ( a > 2.14 || a < -1. ) ? t = (a<0.?40.7:34.4) +a - 2.14, l : v; // bug on Windows\n    if( l > 0. && l < 1. && ( a > 2.14 || a < -1. ) ) t = (a<0.?40.7:34.4) +a - 2.14, v = l;\n    V = U *rot(.52);                                  // diagonal straight part \n    l = V.x-.5;   \n    v = l >  0. && l < 1.&& V.y>0. ? t = 37.5+V.y, l : v;\n    \n    O = vec4( sqrt(abs( y = fract(v-.5)*2.-1. )) );   // cylinder shading\n    v = sin((t+iTime)*8.) * cos(6.28*y); \n    O.gb *= .5+ min(1., v / fwidth(v) );              // animated parameterization\n // if (iMouse.z>0.) O = vec4(iMouse.y/R.y*(t-40.*iMouse.x/R.x));     // debug\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsS3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 537, 537, 3034]], "test": "untested"}
{"id": "DsB3Wc", "name": "Newton Fractal (z^5+z^2-z+1)", "author": "kanayuki", "description": "Newton Fractal (z^5+z^2-z+1)", "tags": ["2d", "fractal"], "likes": 0, "viewed": 168, "published": 3, "date": "1668192466", "time_retrieved": "2024-07-30T16:20:30.308732", "image_code": "#define P(z) power(z,5.0)+power(z,2.0)-z+1.0\n#define P1(z) 5.0*power(z,4.0)+2.0*z-1.0\n#define x1 vec2(-1.32472,0.0)\n#define x2 vec2(0.0,-1.0)\n#define x3 vec2(0.0,1.0)\n//#define x4 vec2(0.662359, -0.56228)\n#define x5 vec2(0.662359, +0.56228)\n \n\nvec2 times(vec2 a, vec2 b)\n{\n    float re = a.x*b.x-a.y*b.y;\n    float im = a.x*b.y+a.y*b.x;\n    return vec2(re, im);\n}\n\nvec2 division(vec2 a,vec2 b)\n{\n    float len2 = pow(b.x,2.0)+pow(b.y,2.0);\n    return times(a, vec2(b.x,-b.y))/len2;\n}\n\nvec2 power(vec2 a, float n)\n{\n    float p = length(a);\n    float theta = acos(a.x/p)*sign(a.y);\n    return pow(p,n)*vec2(cos(n*theta),sin(n*theta));    \n}\n\nmat2 rm(float t)\n{\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 color(vec2 z)\n{    \n    vec2 x4=iMouse.xy;\n    float d1 = distance(z,x1);\n    float d2 = distance(z,x2);\n    float d3 = distance(z,x3);\n    float d4 = distance(z,x4);\n    float d5 = distance(z,x5);\n    float m = min(min(d1,d2),d3);\n    m = min(min(m,d4),d5);\n    if (d1==m) return vec3(1,0,0);\n    if (d2==m) return vec3(0,1,0);\n    if (d3==m) return vec3(0,0,1);\n    if (d4==m) return vec3(1,0,1);\n    if (d5==m) return vec3(1,1,0);\n    return vec3(1,0.8,1);\n    \n}\n\nfloat sdCircle(vec2 p)\n{\n    return length(p)-1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //vec2 pos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    // uv *=rm(iTime);\n    uv *= 1.50;\n    vec2 z = uv;\n    \n    // vec2 C = length(pos)<2.0 ? pos:vec2(0.6,0.5);\n    // vec2 C = vec2(0.6,0.5);\n     \n    //float theta = iTime/3.0;\n    //float A = cos(theta*5.0)*0.75;\n    //vec2 C = vec2(cos(theta),sin(theta))*A;\n    //float n = (sin(iTime/5.0)*0.5+1.0)*10.0;\n    \n    for(int i=0; i<50; i++) z = z-division(P(z),P1(z));\n    \n    vec3 col = color(z);\n    \n    if (abs(sdCircle(uv))<0.0015) col =vec3(1);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // float a = mod(log(length(z)),0.5);\n    // col *= a+ 0.25*z.x/length(z)+0.75;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsB3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 272, 272, 363], [365, 365, 395, 395, 483], [485, 485, 514, 514, 639], [641, 641, 659, 659, 708], [710, 710, 730, 730, 1181], [1183, 1183, 1207, 1207, 1235], [1237, 1237, 1294, 1344, 2169]], "test": "untested"}
{"id": "csB3W3", "name": "fractal C-z^n (temp)", "author": "kanayuki", "description": "fractal C-z^n (temp)", "tags": ["2d", "fractal"], "likes": 0, "viewed": 154, "published": 3, "date": "1668182115", "time_retrieved": "2024-07-30T16:20:31.071692", "image_code": "vec2 times(vec2 a, vec2 b)\n{\n    float re = a.x*b.x-a.y*b.y;\n    float im = a.x*b.y+a.y*b.x;\n    return vec2(re, im);\n}\n\nvec2 power(vec2 a, float n)\n{\n    float p = length(a);\n    float theta = acos(a.x/p);\n    return pow(p,n)*vec2(cos(n*theta),sin(n*theta));    \n}\n\nmat2 rm(float t)\n{\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 color(vec2 z)\n{\n    vec2 x1 = vec2(0);\n    vec2 x2 = vec2(-1.0/2.0, sqrt(3.0)/2.0);\n    vec2 x3 = vec2(-1.0/2.0, -sqrt(3.0)/2.0);\n    float d1 = distance(z,x1);\n    float d2 = distance(z,x2);\n    float d3 = distance(z,x3);\n    float m = min(min(d1,d2),d3);\n    if (d1==m) return vec3(1,0,0);\n    if (d2==m) return vec3(0,1,0);\n    if (d3==m) return vec3(0,0,1);\n    return vec3(1,0.8,1);\n    \n}\n\nfloat sdCircle(vec2 p)\n{\n    return length(p)-1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 pos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    // uv *=rm(iTime);\n    vec2 z = uv;\n    \n    // vec2 C = length(pos)<2.0 ? pos:vec2(0.6,0.5);\n    // vec2 C = vec2(0.6,0.5);\n     \n    float theta = iTime/3.0;\n    float A = cos(theta*5.0)*0.75;\n    vec2 C = vec2(cos(theta),sin(theta))*A;\n    float n = (sin(iTime/5.0)*0.5+1.0)*10.0;\n    for(int i=0; i<int(100); i++) z = C-power(z,n);\n    \n    vec3 col = color(z);\n    \n    if (abs(sdCircle(uv))<0.0015) col =vec3(0.5);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // float a = mod(log(length(z)),0.5);\n    // col *= a+ 0.25*z.x/length(z)+0.75;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 119], [121, 121, 150, 150, 265], [267, 267, 285, 285, 334], [336, 336, 356, 356, 735], [737, 737, 761, 761, 789], [791, 791, 848, 898, 1690]], "test": "untested"}
{"id": "DdBGW3", "name": "polygons like 11235 #2", "author": "jonasfrey", "description": "polygon", "tags": ["polygon"], "likes": 13, "viewed": 290, "published": 3, "date": "1668180936", "time_retrieved": "2024-07-30T16:20:31.829667", "image_code": "// function from \nfloat f_n_dist_line(vec2 p, vec2 a,vec2 b) { // --- distance to segment with caps\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length(p - b * h);                      // dist to segment\n    // We might directly return smoothstep( 3./R.y, 0., dist),\n    //     but its more efficient to factor all lines.\n    // We can even return dot(,) and take sqrt at the end of polyline:\n    // p -= b*h; return dot(p,p);\n}\n\nfloat f_n_dist_polygon_slower(\n    float n_sides,\n    float n_radius,\n    float n_radians_offset,\n    vec2 o_pix_cor_nor\n){\n\n    float n_tau = 6.283185;\n    float n_dist_line_lowest = 1.0; \n    for(\n        float n_side_norm = 0.0;\n        n_side_norm < 1.0;\n        n_side_norm +=1.0/n_sides\n       ){\n           float n_side_norm_next = n_side_norm+(1.0/n_sides);\n       \n           vec2 p1 = vec2(\n               sin(n_radians_offset+n_tau*n_side_norm)*n_radius,\n               cos(n_radians_offset+n_tau*n_side_norm)*n_radius\n           );\n           vec2 p2 = vec2(\n               sin(n_radians_offset+n_tau*n_side_norm_next)*n_radius,\n               cos(n_radians_offset+n_tau*n_side_norm_next)*n_radius\n           );\n\n           \n           float n_dist = f_n_dist_line(o_pix_cor_nor, p1,p2);\n           \n           if(n_dist < n_dist_line_lowest){\n               n_dist_line_lowest = n_dist;\n           }\n       }\n       \n    \n    return n_dist_line_lowest;\n}\n\nfloat f_n_dist_polygon(\n    float n_sides,\n    float n_radius, \n    vec2 o_pix_cor_nor\n){\n\n    float n_tau = 6.283185;\n    float n_dist_line_lowest = 1.0;\n    \n    float n_center_xy = 0.0;\n    float delta_x = o_pix_cor_nor.x - n_center_xy;\n    float delta_y = o_pix_cor_nor.y - n_center_xy;\n    \n\n    float n_rad_current = atan(delta_x,delta_y);\n    float n_nth_line = floor(n_rad_current/(n_tau / n_sides));\n    float n_radians = (n_tau / n_sides) * (n_nth_line);\n    float n_radians_next = (n_tau / n_sides) * ((n_nth_line)+1.0);\n\n    //float n_radians_next = n_radians+ (n_tau / n_sides);\n\n   vec2 p1 = vec2(\n       sin((n_nth_line)*(n_tau / n_sides))*n_radius,\n       cos((n_nth_line)*(n_tau / n_sides))*n_radius\n   );\n   vec2 p2 = vec2(\n       sin(n_radians_next)*n_radius,\n       cos(n_radians_next)*n_radius\n   );\n\n   float n_dist = f_n_dist_line(o_pix_cor_nor,p2,p1);\n    \n    return n_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_pixel_coord_norm = fragCoord.xy / iResolution.xy;\n    \n    o_pixel_coord_norm -= 0.5;\n    \n    o_pixel_coord_norm.x *= iResolution.x/iResolution.y;\n    \n    //line\n    float n_ires_min =  min(iResolution.x,iResolution.y);\n    float n_ires_max =  max(iResolution.x,iResolution.y);\n    vec2 o_pix_cor_nor = fragCoord.xy / iResolution.xy; \n    vec2 o_mou_cor_nor = iMouse.xy / iResolution.xy; \n    o_pix_cor_nor-=0.5;\n    o_pix_cor_nor*= vec2(\n        n_ires_max / n_ires_min,\n        n_ires_min / n_ires_min\n    );\n    o_pix_cor_nor*=2.0; // zoom out\n    \n    \n    float n_poly_norm_lowest = 0.;\n    float n_polys = min(iResolution.x, iResolution.y)/20.0+430.*o_mou_cor_nor.x; \n    float n_dist_lowest = 1.0;\n    float n_radius_norm = 0.0;\n    for(float n_poly_norm = 0.0; n_poly_norm<1.0;n_poly_norm+=1.0/n_polys){\n        float n_sides = 5.0;\n        n_radius_norm += 1.0/n_polys;\n        float n_dist_polygon = f_n_dist_polygon_slower(\n            n_sides, \n            n_radius_norm,\n            sin(n_poly_norm*2.0+iTime*2.0),\n            o_pix_cor_nor\n        );\n        \n        if(n_dist_polygon < n_dist_lowest){\n            n_dist_lowest = n_dist_polygon;\n            n_poly_norm_lowest = n_poly_norm;\n        }\n    }\n    \n    \n    fragColor = vec4(pow(n_dist_lowest,sin(n_poly_norm_lowest*5.+iTime)*0.5+0.5));\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 62, 99, 487], [489, 489, 612, 612, 1456], [1458, 1458, 1547, 1547, 2359], [2361, 2361, 2418, 2418, 3784]], "test": "untested"}
{"id": "ms2GDV", "name": "4 worlds", "author": "lomateron", "description": "just to let you know these exists", "tags": ["automata"], "likes": 8, "viewed": 211, "published": 3, "date": "1668178795", "time_retrieved": "2024-07-30T16:20:32.636509", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float o = +A(u+vec2(-2,-1)).x\n              +A(u+vec2(-1,-1)).x\n              +A(u+vec2( 0,-1)).x\n              +A(u+vec2( 1,-1)).x\n              +A(u+vec2( 2,-1)).x\n              +A(u+vec2( 0,-2)).x;\n              \n    float s = floor(u.x/iResolution.x*4.);\n         uint id = 0U;         //world ID\n    if(s==0.){id = 16U*2U+4U;}\n    if(s==1.){id = 16U*3U+2U;}\n    if(s==2.){id = 16U*3U+3U;}\n    if(s==3.){id = 16U*3U+4U;}\n    \n    o = float((id>>int(o+.1))&1U);\n    \n    if(iFrame==0||iMouse.z>.5)\n    {\n        o = floor(fract(cos(dot(u,vec2(234.76543,iTime+11.23513)))*3467.5678)+.5);\n    }\n    if(iFrame!=0&&int(u.y)!=(iFrame%int(iResolution.y))){o=A(u).x;}\n    fragColor = vec4(o);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2GDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 120]], "test": "untested"}
{"id": "ms2GWV", "name": "3D vector field visualizer", "author": "lomateron", "description": "write your function to visualize in tab [Common] \nprevious shader is horrible for [title]\nthis is the way\nI need to train brain on [title] to do next thing", "tags": ["animation", "graph", "plot", "realtime", "visual"], "likes": 20, "viewed": 433, "published": 3, "date": "1668172132", "time_retrieved": "2024-07-30T16:20:33.396477", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rd = 1./iResolution.xy;\n\n    vec2 u =     (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 1.5*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec3 camPos = vec3(cos(m.x),m.y,sin(m.x))*2.*cD;\n    vec3 camDir = -normalize(camPos);\n    \n    mat3 mtx;\n    mtx[0] = normalize(vec3(camDir.z,0.,-camDir.x));\n    mtx[1] = cross(camDir,mtx[0]);\n    mtx[2] = camDir;\n    vec3 ray = mtx*normalize(vec3(u,2.));//direction of ray from camera\n    \n    float d = 9999.; \n    for(float i=.5; i<bM; ++i){\n    for(float j=.5; j<bT; ++j){\n        vec4  t = texture(iChannel0, vec2(i,j*6.)*rd);\n        vec3  a = t.xyz;\n        float e = dot(a-camPos,ray);\n              a = a - (camPos+ray*e);\n        if(e>=0. && dot(a,a)<.0002*t.w*cD*bZ)\n        {\n            d = min(d,e);\n        }\n    }}\n    fragColor = (cos(d*2./cD+vec4(1,2,3,4))*.5+.5)\n                *step(d,9998.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2  u2 = vec2(0,u.y!=.5);\n    vec4  t = texture(iChannel0, (u-u2)/iResolution.xy);\n    vec3  a = vectorField3D(t.xyz);\n    vec3  b = t.xyz-a;\n    float z = t.w;\n    if(dot(b,b)<.000001||dot(a,a)>cD*cD){z-= iTimeDelta*2.;}\n    else                                {z+= iTimeDelta*2.;}\n                                         z = min(z,1.);\n    if(iFrame==0 || z<0.)\n    {\n         a = fract(cos(dot(u,vec2(1.111,9.999))+iTime+7.777)\n                   *vec3(5567.1234, 8765.2345, 7654.3456));\n         a = (a*2.-1.)*cD;\n         z = .0;\n    }\n                fragColor = vec4(a,z);\n    if(u.y!=.5){fragColor = t;}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define bM 300.  //max balls on screen\n#define bT 3.    //ball tail length\n#define bZ 1.    //ball size\n#define cD 1.    //camera distance from center of world\n                 //balls die if position outside -cD to cD\n                 //balls born  position   inside -cD to cD\n\nfloat sdTorus(vec3 p)//distance field of torus\n{\n    return length(vec2(length(p.xz)-.5,p.y));\n}\nvec3 vectorField3D(vec3 p)\n{\n    float s = 1./512.;\n    vec3  n = normalize(vec3(sdTorus(p+s*vec3(1,0,0)) - sdTorus(p-s*vec3(1,0,0)),\n                             sdTorus(p+s*vec3(0,1,0)) - sdTorus(p-s*vec3(0,1,0)),\n                             sdTorus(p+s*vec3(0,0,1)) - sdTorus(p-s*vec3(0,0,1))));\n          n = cross(n,normalize(p.zyx*vec3(-1,0,1)));\n    return p-n*sdTorus(p)*.02;\n    //return p+vec3(0,.005,0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2GWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 936]], "test": "untested"}
{"id": "md23DK", "name": "incompressible field div(V) = 0", "author": "FabriceNeyret2", "description": "local frame ( per tile ) in an incompressible field  ( made with curl of flownoise ).\nintensity ~ speed.\nBest seen in fullscreen.", "tags": ["fluid", "curlnoise", "flownoise", "incompressible"], "likes": 19, "viewed": 404, "published": 3, "date": "1668169528", "time_retrieved": "2024-07-30T16:20:34.157442", "image_code": "// --- noise ---------------------------------------------------------\n//#define T(u) texture(iChannel0,.01*u/iChannelResolution[0].xy).x // interp text noise\n  #define T(u) ( .5 + 1.5* noise (.005*u) )  // base gradient noise\n//#define T(u) ( .5 + 1.5* perlin(.005*u) )  // perlin noise\n\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n// ---------------------------------------------------------------\n\n#define cross(a,b) ( (a).x*(b).y - (a).y*(b).x )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/32., I = floor(U), V, A;\n    float psi = T(u);\n    V = 5e3 * vec2( -dFdy(psi), dFdx(psi) ); // div(V) = 0\n    U = fract(U)-.5;\n    A = vec2( dot(U,V) , cross(U,V) );       // draw local frame ( orthoV, V )\n    A = sin(A); // A = 1./abs(A); \n    O = .5 + .5 * vec4( A , 0,0);            // colored frame\n    O = vec4( A.x + A.y );                   // dots\n    O = vec4(  max( A.x, A.y ) );            // frame\n    O *= .4 + .6* length(V)/40.;             // intensity = speed \n // O.r = min(O.r, length(V)/40. );\n // U = .5+.5*cos(3.14*U); O *= U.x*U.y;     // tile vignetting\n    \n// ......................................... // debug\n // O = vec4 ( psi );                \n // O = vec4 ( .5+.02*V, 0,1);      \n // O = vec4( length(V)/40. );   \n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md23DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 507, 530, 530, 823], [825, 825, 849, 904, 1063], [1182, 1182, 1220, 1220, 2011]], "test": "untested"}
{"id": "mdjGDK", "name": "derivative of textures 2", "author": "FabriceNeyret2", "description": "buffA texture is just a  0 / 1 checker.\nImage tab:   zoom & interpolate.\ntop: hardware derivative.    why ??? \nbottom: manual derivative. not continuous either, but at least x/y symmetrical.", "tags": ["dfdx", "dfdy", "precision", "interpolation", "fwidth"], "likes": 3, "viewed": 255, "published": 3, "date": "1668164362", "time_retrieved": "2024-07-30T16:20:34.914418", "image_code": "// variant of https://shadertoy.com/view/ddj3WK\n\n#define T(U) texture(iChannel0,(U)/128.).xxxx\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  U = u / R; \n // vec2 R = vec2(512), U = ( u-.5 ) / 512.; // avoids float approx. not better.\n    \n    O = T(U); \n    O = U.y > .5\n      ? dFdx( O )                     // top: hardware derivative\n      : O - T( U + vec2(1./R.x,0) );  // bottom: manual derivative\n          // analytical: should be a const vertical gradient B to W or W to B\n   O =  .5 + 50. * O;\n   \n   if ( int(u.y)*2 == int(iResolution.y) ) O = vec4(1,0,0,1); // red separator\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n     O.x = mod(u.x+u.y,2.);     //  pure checker\n  // O.x = mod( u.x-.5, 2.);    //  alternate bars\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 134, 134, 612]], "test": "untested"}
{"id": "ddj3WK", "name": "derivative of textures", "author": "FabriceNeyret2", "description": "...or is it the precision of the texture unit interpolation ?\n\ntop: derivative of the 8bit texture\nbottom: derivative of the float (same) texture ( note also the behavior on borders - see fullscreen ).\n\ntry alternate patterns in buffA. \n", "tags": ["dfdx", "dfdy", "precision", "fwidth"], "likes": 1, "viewed": 274, "published": 3, "date": "1668162036", "time_retrieved": "2024-07-30T16:20:35.712285", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / iResolution.xy;\n    float scale = 1024.;\n    O =  U.y>.5 ? texture(iChannel0,u/scale   )   // top: 8bits texture\n                : texture(iChannel1,U/scale*8.);  // bottom: float (same) texture\n    O =.5+100.*dFdx( O.xxxx ); // scale/8\n    \n    if ( int(u.y)*2 == int(iResolution.y) ) O = vec4(1,0,0,1); // red separator\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = texelFetch( iChannel0, ivec2(u), 0 );\n // O = vec4( .5* mod(u.x+u.y,2.));  // variant: pure checker\n // O = vec4( .5*mod(u.x-.5,2.));    // variant: alternate bars\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddj3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 379]], "test": "untested"}
{"id": "md2GWy", "name": "3D particles without particles", "author": "lomateron", "description": "key W to restart\n3D form of https://www.shadertoy.com/view/7ldGzl\nbut this does not damps the divergence of velocity field", "tags": ["graph", "function", "plot", "helper"], "likes": 22, "viewed": 499, "published": 3, "date": "1668152104", "time_retrieved": "2024-07-30T16:20:36.465272", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec3 camPos = step(iMouse.z,.5)*vec3(cos(sin(iTime*.11)*3.),cos(iTime*.7)*.3,sin(sin(iTime*.15)*3.))*3.;\n         camPos+= step(.5,iMouse.z)*vec3(cos(m.x),m.y,sin(m.x))*3.;\n    vec3 camDir = -normalize(camPos);\n    \n    mat3 mtx;\n    mtx[0] = normalize(vec3(camDir.z,0.,-camDir.x));\n    mtx[1] = cross(camDir,mtx[0]);\n    mtx[2] = camDir;\n    vec3 ray = mtx*normalize(vec3(u,2.));//direction of ray from camera\n    vec3 ray2= 1./ray;\n    vec3 ray3= step(vec3(0),ray)*2.-1.;\n    \n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3);\n    float x3d= 2./x3;\n    float x4 = x3*2.;//max voxels the ray will transverse inside simulationCube\n    \n        vec3  inc  = step(camPos,vec3( 1))*  //inside cube\n                     step(vec3(-1),camPos);\n        vec3  tMin = (vec3(-1)-camPos)*ray2;\n        vec3  tMax = (vec3( 1)-camPos)*ray2;    ray2 = abs(ray2);\n        vec3  t1 = min(tMin, tMax);\n        vec3  t2 = max(tMin, tMax);\n        float tN = max(max(t1.x, t1.y), t1.z);//length of ray between camera and simulationCube\n        float tF = min(min(t2.x, t2.y), t2.z);\n              tF = float(tF>tN);\n              \n    vec3 p = camPos+ray*tN*(1.-inc.x*inc.y*inc.z)*1.001;//collision position of ray on simulationCube \n         p = (p*.5+.5)*x3;      //transform to voxels coordinates, range 0 to x3\n    fragColor = vec4(0);\n    for(float i=0.; i<x4; ++i)\n    {\n        vec3  g = (1.-fract(p*ray3))*ray2;\n        float l = min(min(g.x,g.y),g.z);\n        fragColor += texelFetch(iChannel0, ivec2(c32(floor(p),x2,x3)), 0)*l;\n        p+= ray*l;\n        \n        vec3 o = abs(p*x3d-1.);\n        if(o.x>=1.||o.y>=1.||o.z>=1.){break;}\n    }\n    fragColor = fragColor*vec4(.02,.02,.02,1)+fragColor.wwww*.3;\n    //fragColor = fragColor.wwww*.7;\n    fragColor*= tF;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3);\n    vec3  u3 = c23(floor(u), x2, x3);\n    \n    vec3  r = vec3(0);\n    vec4  a = texelFetch(iChannel0, ivec2(u), 0);\n    float z = 4.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n    for(float k=-z; k<=z; ++k){\n        vec3 ijk = vec3(i,j,k);\n        float l = length(ijk);\n        if((i==0.&&j==0.&&k==0.) || l>z+.1){continue;}\n      //vec3  c  = normalize(ijk);\n        vec3  um = mod(u3+ijk,vec3(x3));\n              um = floor(um);\n        vec4  a2 = texelFetch(iChannel0, ivec2(c32(um,x2,x3)), 0);\n        vec4  b  = a2-a;\n        r += ijk*b.w*cos(l*2.1)*exp(-l*l*.25);\n    }}}\n    fragColor = vec4(r,0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 vectorField(vec3 p)\n{\n    return +p.yxz*vec3(-1,1,0)*exp(-dot(p,p)*9.)*.0;\n}\nvoid mainImage(out vec4 fragColor, in vec2 u)\n{\n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3);\n    vec3  u3 = c23(floor(u), x2, x3);\n\n    vec3 m = +vectorField(floor(u3)*2./x3-1.)\n             +texelFetch(iChannel0, ivec2(u), 0).xyz*1. //mass momentum\n             +texelFetch(iChannel1, ivec2(u), 0).xyz;   //mass force on mass\n    float s = 0.;\n    float z = 2.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n    for(float k=-z; k<=z; ++k){\n        vec3 ijk = vec3(i,j,k);\n        if(dot(ijk,ijk)>z*z+.1){continue;}\n        vec3 c = m+ijk;\n        s += exp(-dot(c,c));\n    }}}\n    if(s!=0.){s = 1./s;}\n    fragColor = vec4(m,s);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3);\n    vec3  u3 = c23(floor(u), x2, x3);\n\n    vec3  v = vec3(0);\n    float s = 0.;\n    float z = 2.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n    for(float k=-z; k<=z; ++k){\n        vec3 ijk = vec3(i,j,k);\n        if(dot(ijk,ijk)>z*z+.1){continue;}\n        vec3  um = mod(u3+ijk,vec3(x3));\n              um = floor(um);\n        ivec2 u2 = ivec2(c32(um,x2,x3));\n        vec4  t = texelFetch(iChannel0, u2, 0);\n        vec4  m = texelFetch(iChannel1, u2, 0);\n        vec3  c = m.xyz-ijk;\n        float w = t.w*m.w*exp(-dot(c,c));\n        v += w*m.xyz;\n        s += w;\n    }}}\n    float dv = 1./s; if(s==0.){dv = 0.;}//avoid division by zero\n    fragColor = vec4(v*dv,s);\n    float keyW = texture(iChannel2, vec2(87.5/256.,.25)).x;\n    if(iFrame==0||keyW>0.)\n    {\n        vec3 uv = (floor(u3)/x3-.5)*3.;\n        fragColor = vec4(0,0,0,.1)*exp(-dot(uv,uv));\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 c23(vec2 u, float x2, float x3)//transform 2D to 3D coordinates\n{\n    float i = dot(u,vec2(1,x2))+.5;\n    return vec3(mod(i,x3), mod(i/x3,x3), i/(x3*x3));\n}\nvec2 c32(vec3 u, float x2, float x3)//transform 3D to 2D coordinates\n{\n    float i = dot(u,vec3(1, x3, x3*x3))+.5;\n    return vec2(mod(i,x2), i/x2);\n}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2GWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2018]], "test": "untested"}
{"id": "cdjGWK", "name": "My First Burning Ship", "author": "cr1901", "description": "My first fractal, apropos of absolutely nothing going on on a certain Blue Bird website :).", "tags": ["fractal", "mandelbrot", "burningship"], "likes": 3, "viewed": 227, "published": 3, "date": "1668146099", "time_retrieved": "2024-07-30T16:20:37.203298", "image_code": "\nvoid burning_ship(in vec2 uv, out vec3 color)\n{\n    vec2 iter = vec2(0.0, 0.0);\n    float abs_iter = 0.0;\n    int i = 0;\n\n    for(i = 0; i < 100; i++)\n    {\n    \n        vec2 tmp = vec2(abs(iter.x), abs(iter.y));\n        float real = (tmp.x * tmp.x) - (tmp.y * tmp.y);\n        float imag = 2.0*tmp.x*tmp.y;\n\n        // Uncomment for Mandelbrot\n        /* float real = (iter.x * iter.x) - (iter.y * iter.y);\n        float imag = 2.0*iter.x*iter.y; */\n    \n        iter = vec2(real, imag) + uv;\n        \n        if(length(iter) > 100.0)\n        {\n            abs_iter = 200.0;\n            break;\n        }\n    }\n    \n    if(abs_iter == 0.0)\n    {\n        abs_iter = length(iter);  \n    }\n    \n    \n    if(abs_iter > 100.0)\n    {\n        color = vec3(float(i)/10.0, float(i)/50.0, 0.0);\n    } else {\n        color = vec3(0.25, 0.0, 0.0);\n    }\n}\n    \nconst float PI = 3.1415;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 xy_norm = fragCoord/iResolution.xy;\n\n    float x_scale = 3.0;\n    float y_scale = -4.0 * float(iResolution.y) / float(iResolution.x);\n    \n    float shift_speed = 0.30*2.0*PI*iTime;\n    float shift_freq = 1.6*2.0*PI*xy_norm.y;\n    float shift_mag = 0.005;\n    float x_shift = 0.6 + shift_mag*cos(shift_freq + shift_speed);\n    float y_shift = 0.22;\n\n    vec2 uv = vec2(x_scale, y_scale) * (xy_norm - vec2(x_shift, y_shift));\n\n    vec3 color;\n    burning_ship(uv, color);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 48, 843], [875, 875, 930, 930, 1446]], "test": "untested"}
{"id": "DsSGDV", "name": "polygon lines", "author": "jonasfrey", "description": "polygon", "tags": ["polygon"], "likes": 0, "viewed": 234, "published": 3, "date": "1668123542", "time_retrieved": "2024-07-30T16:20:37.943320", "image_code": "// function from \nfloat f_n_dist_line(vec2 p, vec2 a,vec2 b) { // --- distance to segment with caps\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length(p - b * h);                      // dist to segment\n    // We might directly return smoothstep( 3./R.y, 0., dist),\n    //     but its more efficient to factor all lines.\n    // We can even return dot(,) and take sqrt at the end of polyline:\n    // p -= b*h; return dot(p,p);\n}\n\nfloat f_n_dist_polygon_slower(\n    float n_sides,\n    float n_radius, \n    vec2 o_pix_cor_nor\n){\n\n    float n_tau = 6.283185;\n    float n_dist_line_lowest = 1.0; \n    for(\n        float n_side_norm = 0.0;\n        n_side_norm < 1.0;\n        n_side_norm +=1.0/n_sides\n       ){\n           float n_side_norm_next = n_side_norm+(1.0/n_sides);\n       \n           vec2 p1 = vec2(\n               sin(n_tau*n_side_norm)*n_radius,\n               cos(n_tau*n_side_norm)*n_radius\n           );\n           vec2 p2 = vec2(\n               sin(n_tau*n_side_norm_next)*n_radius,\n               cos(n_tau*n_side_norm_next)*n_radius\n           );\n\n           \n           float n_dist = f_n_dist_line(o_pix_cor_nor, p1,p2);\n           \n           if(n_dist < n_dist_line_lowest){\n               n_dist_line_lowest = n_dist;\n           }\n       }\n       \n    \n    return n_dist_line_lowest;\n}\n\nfloat f_n_dist_polygon(\n    float n_sides,\n    float n_radius, \n    vec2 o_pix_cor_nor\n){\n\n    float n_tau = 6.283185;\n    float n_dist_line_lowest = 1.0;\n    \n    float n_center_xy = 0.0;\n    float delta_x = o_pix_cor_nor.x - n_center_xy;\n    float delta_y = o_pix_cor_nor.y - n_center_xy;\n    \n    float n_rad_current = atan(0.0, 0.0) - atan(o_pix_cor_nor.x, o_pix_cor_nor.y);\n    n_rad_current = atan(delta_x,delta_y);\n    float n_nth_line = floor(n_rad_current/(n_tau / n_sides));\n    float n_radians = (n_tau / n_sides) * (n_nth_line);\n    float n_radians_next = (n_tau / n_sides) * ((n_nth_line)+1.0);\n\n    //float n_radians_next = n_radians+ (n_tau / n_sides);\n\n   vec2 p1 = vec2(\n       sin((n_nth_line)*(n_tau / n_sides))*n_radius,\n       cos((n_nth_line)*(n_tau / n_sides))*n_radius\n   );\n   vec2 p2 = vec2(\n       sin(n_radians_next)*n_radius,\n       cos(n_radians_next)*n_radius\n   );\n\n   float n_dist = f_n_dist_line(o_pix_cor_nor,p2,p1);\n    \n    return n_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_pixel_coord_norm = fragCoord.xy / iResolution.xy;\n    \n    o_pixel_coord_norm -= 0.5;\n    \n    o_pixel_coord_norm.x *= iResolution.x/iResolution.y;\n    \n    //line\n    float n_ires_min =  min(iResolution.x,iResolution.y);\n    float n_ires_max =  max(iResolution.x,iResolution.y);\n    vec2 o_pix_cor_nor = fragCoord.xy / iResolution.xy; \n    o_pix_cor_nor-=0.5;\n    o_pix_cor_nor*= vec2(\n        n_ires_max / n_ires_min,\n        n_ires_min / n_ires_min\n    );\n    o_pix_cor_nor*=2.0; // zoom out\n    \n    \n    float n_sides = 5.0;\n    float n_radius_norm = 0.5;\n    float n_dist_polygon = f_n_dist_polygon(\n        n_sides, \n        n_radius_norm, \n        o_pix_cor_nor\n    );\n    \n    fragColor = vec4(n_dist_polygon);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 62, 99, 487], [489, 489, 585, 585, 1361], [1363, 1363, 1452, 1452, 2340], [2342, 2342, 2399, 2399, 3133]], "test": "untested"}
{"id": "msB3WK", "name": "Ghosts on fire", "author": "larserik", "description": "Yet another noise experiment gone off in a random direction. 🙈", "tags": ["noise", "fbm", "simplex"], "likes": 11, "viewed": 338, "published": 3, "date": "1668121489", "time_retrieved": "2024-07-30T16:20:38.690323", "image_code": "float speed = 1.7;\nfloat scale = 8.7;\nint octaves = 6;\nint repeats = 2;\nbool turbulence = true;\n\nfloat fbm (in vec3 st) {\n    float value = 0.0;\n    float amplitude = 1.;\n    float total = 0.;\n\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude;\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= 0.5;\n    }\n\n    return value / total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float time = iTime * speed;\n    float dist = sqrt(uv.x*uv.x+uv.y*uv.y);\n\n    uv *= scale;\n\n    float mag = .2;\n\n    float n = fbm(vec3(uv, time*.2));\n    \n    for (int i = 0; i<repeats; i++) {\n      float ang = n * 3.141592;\n      n = fbm(vec3(uv + vec2(cos(ang), sin(ang)) * n, time*.2));\n    }\n\n    if (turbulence) {\n        n = abs(n);\n    } else {\n        n = n*.5 + .5;\n    }\n\n    vec3 color = vec3(n*.58, n*.65, n*.997);\n    \n    if (dist < (snoise(vec3(uv * vec2(1., 2.5), time*.2))+1.) * .35 && color.b > .3) {\n      color.r *= 1. + (.9 - dist);\n      color.b *= dist;\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "// Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msB3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 121, 121, 381], [383, 383, 440, 440, 1126]], "test": "untested"}
{"id": "dsS3WK", "name": "Sunset on sandy seabottom", "author": "larserik", "description": "Just another noise experiment gone off in a random direction. 🙈\nTurns into something entirely different yet fun with turbulence = true.", "tags": ["noise", "fbm", "simplex"], "likes": 2, "viewed": 223, "published": 3, "date": "1668120615", "time_retrieved": "2024-07-30T16:20:39.431341", "image_code": "float speed = .3;\nfloat scale = 7.2;\nint octaves = 4;\nint repeats = 1;\nbool turbulence = false;\n\nfloat fbm (in vec3 st) {\n    float value = 0.0;\n    float amplitude = 1.;\n    float total = 0.;\n\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude;\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= 0.5;\n    }\n\n    return value / total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float time = iTime * speed;\n    float dist = sqrt(uv.x*uv.x+uv.y*uv.y);\n\n    uv *= scale;\n\n    float mag = .2;\n\n    float n = fbm(vec3(uv, time*.2));\n    \n    for (int i = 0; i<repeats; i++) {\n      float ang = n * 3.141592;\n      n = fbm(vec3(uv + vec2(cos(ang), sin(ang)) * n, time*.2));\n    }\n\n    if (turbulence) {\n        n = abs(n);\n    } else {\n        n = n*.5 + .5;\n    }\n\n    vec3 color = vec3(n*.58, n*.65, n*.997);\n    \n    if (dist < (snoise(vec3(uv * vec2(1., 2.5), time*.2))+1.) * .35 && color.b > .3) {\n      color.r *= 1. + (.9 - dist);\n      color.b *= dist;\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "// Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsS3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 121, 121, 381], [383, 383, 440, 440, 1126]], "test": "untested"}
{"id": "DsS3DV", "name": "Golden Polar Flower", "author": "SnoopethDuckDuck", "description": "i was passing out when i made this so the code makes no sense", "tags": ["spiral"], "likes": 14, "viewed": 294, "published": 3, "date": "1668115470", "time_retrieved": "2024-07-30T16:20:40.245165", "image_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float a = atan(uv.y, uv.x);\n    vec2 p = 0.5 * cos(a - 0.49 * iTime) * vec2(cos(0.5 * iTime), sin(0.3 * iTime));\n    vec2 q = 0.5 * (cos(2. * a - 0.51 * iTime)) * vec2(cos(iTime), sin(iTime));\n    \n    float d1 = length(uv-q) / length(uv - p) + 1.;\n    float d2 = length(uv - q) / length(uv) + 1.;\n    \n    vec2 uv2 = vec2(d1,d2) / (d1 + d2);\n    uv2 = log(uv2 + 0.495);\n    a = atan(uv2.y, uv2.x) + 4. * log(length(uv2)) + iTime;\n    uv2 *= vec2(sin(a), cos(a));\n    vec3 col = vec3(uv2.x, uv2.y, abs(uv2.x-uv2.y));\n    col = exp(-24. * 0.5 * col);\n    col *= 0.5 +0.5 * thc(4., a -10. * log(length(uv)));\n    col += exp(-3.5 * length(uv))-exp(-8. * length(uv2));\n    col = 0.5 * col + 0.5 * clamp(col,0.,1.);\n    //col = clamp(col,0.,1.);\n    col += vec3(0.9,0.6,0.45) * thc(4., exp(-10. * length(uv-uv2))) * abs(d1/d2-d2/d1);\n    col -= 0.7 / cosh(4. * length(uv)) * vec3(0.4,0.58,1);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 98, 1099]], "test": "untested"}
{"id": "DdS3DV", "name": "line function  @FabriceNeyret2", "author": "jonasfrey", "description": "line from here https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/", "tags": ["line"], "likes": 4, "viewed": 261, "published": 3, "date": "1668115114", "time_retrieved": "2024-07-30T16:20:40.986184", "image_code": "float line(vec2 p, vec2 a,vec2 b) { // --- distance to segment with caps\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length(p - b * h);                      // dist to segment\n    // We might directly return smoothstep( 3./R.y, 0., dist),\n    //     but its more efficient to factor all lines.\n    // We can even return dot(,) and take sqrt at the end of polyline:\n    // p -= b*h; return dot(p,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float n_resolution_min = min(iResolution.x, iResolution.y);\n    float n_resolution_max = max(iResolution.x, iResolution.y);\n    vec2 o_pix_cor_nor = fragCoord/n_resolution_min;\n    vec2 o_mouse_norm = iMouse.xy/n_resolution_min;\n\n\n    float n_dist = line(o_pix_cor_nor,  vec2(0.0,0.0), o_mouse_norm);\n    \n    float n_dist_modified = sqrt(n_dist);\n    fragColor = vec4(n_dist_modified);\n    \n    fragColor = sqrt(fragColor);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 72, 460], [462, 462, 519, 569, 1005]], "test": "untested"}
{"id": "dsS3zc", "name": "checker board simple", "author": "jonasfrey", "description": "use it as a template ", "tags": ["checkerboard"], "likes": 1, "viewed": 182, "published": 3, "date": "1668100521", "time_retrieved": "2024-07-30T16:20:41.731192", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 a_n_pixel_coor_norm = fragCoord.xy / iResolution.xy; \n    vec2 a_n_pixel_coor_norm = fragCoord.xy / min(iResolution.y,iResolution.x);//1:1 aspect \n    \n    vec2 a_n_scale = vec2(10.0, 10.0);\n    vec2 a_n_pixel_coor_norm_scaled = a_n_pixel_coor_norm * a_n_scale;\n\n    float n_index = (fragCoord.x /10.0) + (fragCoord.y /10.0)* (iResolution.x/10.0);\n    float n_col =  step(1.0,mod(a_n_pixel_coor_norm_scaled.x+step(1.0,mod(a_n_pixel_coor_norm_scaled.y, 2.0)), 2.0));\n    fragColor = vec4(n_col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsS3zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 123, 566]], "test": "untested"}
{"id": "md23Dy", "name": "distance to line 2 ", "author": "jonasfrey", "description": "distance", "tags": ["distance"], "likes": 1, "viewed": 189, "published": 3, "date": "1668096712", "time_retrieved": "2024-07-30T16:20:42.478195", "image_code": "float f_n_dist_to_line(\n    vec2 o_p1, \n    vec2 o_p2,\n    vec2 o_pixel_coord_norm\n){\n\n    //y = m*x + b\n    // y = m*(x-x1) + y1;\n    if(o_p1.x > o_p2.x){\n        vec2 o_p_tmp = o_p1; \n        o_p1 = o_p2;\n        o_p2 = o_p_tmp;\n    }\n    vec2 o_delta = o_p2-o_p1; \n    \n    float n_m = o_delta.y/o_delta.x;\n    \n    float n_y = n_m * (o_pixel_coord_norm.x - o_p1.x) + o_p1.y;\n\n    float n_dist_line = length(o_pixel_coord_norm-vec2(o_pixel_coord_norm.x, n_y));\n    \n    if(\n        o_pixel_coord_norm.x < min(o_p1.x, o_p2.x)\n    ){\n        n_dist_line = length(o_pixel_coord_norm-o_p1);\n        n_dist_line = 1.0;\n    }\n    if(\n        o_pixel_coord_norm.x > max(o_p1.x, o_p2.x)\n    ){\n        n_dist_line = length(o_pixel_coord_norm-o_p2);\n        n_dist_line = 1.0;\n    }\n    \n    return n_dist_line;\n    \n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pixel_coord_norm = fragCoord.xy / iResolution.xy;\n    vec2 o_mouse_coord_norm = iMouse.xy / iResolution.xy;\n    if(iMouse.w==0.0){o_mouse_coord_norm =vec2(0.5,0.5);}\n    o_pixel_coord_norm -= 0.5;\n    float n_tau = 6.283185;\n    o_pixel_coord_norm.x *= iResolution.x/iResolution.y;\n\n    o_pixel_coord_norm *=10.0*o_mouse_coord_norm.x;\n    float n_amp = 0.5; \n    float n_lines = 99.0;\n    \n    float delta_x = o_pixel_coord_norm.x - 0.0;\n    float delta_y = o_pixel_coord_norm.y - 0.0;\n    float theta_radians = atan(delta_y, delta_x);\n    float n_nth_line = theta_radians/(n_tau / n_lines);\n    float n_radians = n_tau * n_nth_line; \n\n    float n_x = sin(n_radians)*n_amp;\n    float n_y = cos(n_radians)*n_amp;\n\n    float n_dist_to_line = f_n_dist_to_line(\n        vec2(0.0, 0.0),\n        vec2(n_x, n_y), \n        o_pixel_coord_norm\n    );\n            \n    fragColor = vec4(n_dist_to_line);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md23Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 130, 813], [814, 814, 871, 871, 1776]], "test": "untested"}
{"id": "cdSGRd", "name": "Sea blobs", "author": "z0rg", "description": "BlobsBlobs", "tags": ["raymarching", "blobs", "sea", "light"], "likes": 49, "viewed": 733, "published": 3, "date": "1668094063", "time_retrieved": "2024-07-30T16:20:43.231181", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30184, "src": "https://soundcloud.com/arney-aquatic-acoustics/underwater-stridulations?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW 1.\n#define GLOW_OPACITY 1.86\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 3.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    vec2 acc = vec2(10000.,-1.);\n    vec2 rep = vec2(.25);\n    vec2 id = floor((p.xz+rep*.5)/rep);\n\n    p.xz = mod(p.xz+rep*.5,rep)-rep*.5;\n    float sz = .1;\n    float h = .5*texture(iChannel0, id*.01+iTime*.0008).x*length(id*.15);\n    vec3 op = p;\n    p.y = abs(p.y);\n    p.y-= h;\n    float bar = length(p)-sz;\n    bar = min(bar, max(length(p.xz)-sz, abs(op.y)-h));\n    bar = max(bar, op.y);\n    acc = _min(acc, vec2(bar, 0.));\n    \n    vec3 rep2 = vec3(1.);\n    p2.y += iTime;\n    p2.xz *= r2d(sin(p2.y*3.-iTime)*.05);\n    vec3 id2 = floor((p2+rep2*.5)/rep2);\n    p2 = mod(p2+rep2*.5,rep2)-rep2*.5;\n    float bubble = length(p2)+abs(sin(id2.y+id2.x+id2.z*10.));\n    acc = _min(acc, vec2(bubble, 3.));\n    \n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 10.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.35;\n        vec3 rgb = mix(vec3(.1,.3,.5),vec3(0.078,0.522,0.471), sat(sin(2.*distance(p, ro))));\n        accCol += rgb*0.01*sat(.3+sat(sin(p.x*2.)+sin(p.z)+sin(length(p.xz)+iTime)));//*(1.-sat(res.x/0.5))*.01;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float d = 2.;\n    float a = iTime*.1;\n    uv *= r2d(sin(iTime*.2)*.2);\n    vec2 offr = (vec2(rand(), rand())-.5)*.05;\n    vec3 ro = vec3(sin(a)*d+offr.x,-.8+offr.y+.2*sin(iTime*.1),cos(a)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    float depth = 100.;\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec2 rep = vec2(.25);\n        vec2 id = floor((p.xz+rep*.5)/rep);\n        float h = texture(iChannel0, id*.01+iTime*.0008).x;\n        vec3 rgb = mix(vec3(0.102,1.000,0.698), vec3(0.486,0.435,0.094), pow(h,3.));\n        col = rgb*(1.-pow(sat(-dot(rd, n)), .25));\n        col += rgb * pow(sat(-p.y*1.5),2.);\n        col *= pow(h*1.5,2.);\n        col = mix(col*.35, 1.5*col.yxz, sat(sin(length(id)*.7-iTime*2.)));\n    }\n    col = mix(col, accCol, 1.-sat(exp(-depth*0.4)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 1.9/(col+1.);\n    col = sat(col);\n\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGRd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1004]], "test": "untested"}
{"id": "ddjGDy", "name": "julia fractal C-z^3(mouse)", "author": "kanayuki", "description": "julia fractal C-z^3(mouse)", "tags": ["2d", "fractal"], "likes": 6, "viewed": 206, "published": 3, "date": "1668093003", "time_retrieved": "2024-07-30T16:20:43.986163", "image_code": "vec2 times(vec2 a, vec2 b)\n{\n    float re = a.x*b.x-a.y*b.y;\n    float im = a.x*b.y+a.y*b.x;\n    return vec2(re, im);\n}\n\nvec2 power(vec2 a, int n)\n{\n    vec2 res = a;\n    for(int i=0; i<n-1; i++) res=times(res,a);\n    return res;    \n}\n\nmat2 rm(float t)\n{\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 color(vec2 z)\n{\n    vec2 x1 = vec2(0);\n    vec2 x2 = vec2(-1.0/2.0, sqrt(3.0)/2.0);\n    vec2 x3 = vec2(-1.0/2.0, -sqrt(3.0)/2.0);\n    float d1 = distance(z,x1);\n    float d2 = distance(z,x2);\n    float d3 = distance(z,x3);\n    float m = min(min(d1,d2),d3);\n    if (d1==m) return vec3(1,0,0);\n    if (d2==m) return vec3(0,1,0);\n    if (d3==m) return vec3(0,0,1);\n    return vec3(1,0.8,1);\n    \n}\n\nfloat sdCircle(vec2 p)\n{\n    return length(p)-1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // uv *=rm(iTime);\n    \n    vec2 z = uv;\n    \n    float iter = (sin(iTime/2.0)*0.5+0.5)*30.0;\n    vec2 pos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n     \n    vec2 C = length(pos)<2.0 ? pos:vec2(0.6,0.5);\n    for(int i=0; i<int(100); i++) z = C-power(z,5);\n    \n    vec3 col = color(z);\n    \n    if (abs(sdCircle(uv))<0.0015) col =vec3(0.5);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // float a = mod(log(length(z)),0.5);\n    // col *= a+ 0.25*z.x/length(z)+0.75;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 119], [121, 121, 148, 148, 235], [237, 237, 255, 255, 304], [306, 306, 326, 326, 705], [707, 707, 731, 731, 759], [761, 761, 818, 868, 1521]], "test": "untested"}
{"id": "ds23Wy", "name": "GLSL bug #64 ( Windows )", "author": "FabriceNeyret2", "description": "disk should be ~centered, not in the bottom-left corner as Windows does.\nThe bug disappear if you  either :\n- end line #8 with \";\"  \n-  or switch comment to activate line #9 instead of #11.  ", "tags": ["glsl", "bug"], "likes": 10, "viewed": 268, "published": 3, "date": "1668092983", "time_retrieved": "2024-07-30T16:20:44.736158", "image_code": "\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U = U/iResolution.y;\n\n    float w,a;\n    U -= .5,\n    w = length(U),                  // on Window, triggers the bug if \",\" instead of \";\"\n//  a = .001 / (w*w*w) ;            // no bug\n//  a = .001 / pow(w,3.) ;          // bugged on Windows, but differently !!!\n    a = .001 / pow(length(U),3.) ;  // bugged on Windows !!!\n    \n    O = vec4(a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds23Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 392]], "test": "untested"}
{"id": "ddj3Wy", "name": "julia fractal z0-z^3", "author": "kanayuki", "description": "julia fractal z0-z^3", "tags": ["2d", "fractal"], "likes": 0, "viewed": 146, "published": 3, "date": "1668091760", "time_retrieved": "2024-07-30T16:20:45.478174", "image_code": "vec2 times(vec2 a, vec2 b)\n{\n    float re = a.x*b.x-a.y*b.y;\n    float im = a.x*b.y+a.y*b.x;\n    return vec2(re, im);\n}\n\nvec2 power(vec2 a, int n)\n{\n    vec2 res = a;\n    for(int i=0; i<n-1; i++) res=times(res,a);\n    return res;    \n}\n\nmat2 rm(float t)\n{\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 color(vec2 z)\n{\n    vec2 x1 = vec2(0);\n    vec2 x2 = vec2(-1.0/2.0, sqrt(3.0)/2.0);\n    vec2 x3 = vec2(-1.0/2.0, -sqrt(3.0)/2.0);\n    float d1 = distance(z,x1);\n    float d2 = distance(z,x2);\n    float d3 = distance(z,x3);\n    float m = min(min(d1,d2),d3);\n    if (d1==m) return vec3(1,0,0);\n    if (d2==m) return vec3(0,1,0);\n    if (d3==m) return vec3(0,0,1);\n    return vec3(1,0.8,1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // uv *=rm(iTime);\n    \n    vec2 z = uv;\n    \n    float iter = (sin(iTime/2.0)*0.5+0.5)*100.0;\n    for(int i=0; i<int(iter); i++) z = vec2(0.6,0.5)-power(z,3);\n    \n    vec3 col = color(z);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // float a = mod(log(length(z)),0.5);\n    // col *= a+ 0.25*z.x/length(z)+0.75;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddj3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 119], [121, 121, 148, 148, 235], [237, 237, 255, 255, 304], [306, 306, 326, 326, 705], [707, 707, 764, 814, 1309]], "test": "untested"}
{"id": "cd23DG", "name": "fractal z0-z^3", "author": "kanayuki", "description": "newton fractal 1-z^3", "tags": ["2dfractal"], "likes": 2, "viewed": 166, "published": 3, "date": "1668081764", "time_retrieved": "2024-07-30T16:20:46.255097", "image_code": "vec2 times(vec2 a, vec2 b)\n{\n    float re = a.x*b.x-a.y*b.y;\n    float im = a.x*b.y+a.y*b.x;\n    return vec2(re, im);\n}\n\nvec2 power(vec2 a, int n)\n{\n    vec2 res = a;\n    for(int i=0; i<n-1; i++) res=times(res,a);\n    return res;    \n}\n\nmat2 rm(float t)\n{\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 color(vec2 z)\n{\n    vec2 x1 = vec2(0);\n    vec2 x2 = vec2(-1.0/2.0, sqrt(3.0)/2.0);\n    vec2 x3 = vec2(-1.0/2.0, -sqrt(3.0)/2.0);\n    float d1 = distance(z,x1);\n    float d2 = distance(z,x2);\n    float d3 = distance(z,x3);\n    float m = min(min(d1,d2),d3);\n    if (d1==m) return vec3(1,0,0);\n    if (d2==m) return vec3(0,1,0);\n    if (d3==m) return vec3(0,0,1);\n    return vec3(1,0.8,1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // uv *=rm(iTime);\n    \n    vec2 z = vec2(0);\n    \n    float iter = (sin(iTime/2.0)*0.5+0.5)*30.0;\n    for(int i=0; i<int(iter); i++) z = uv-power(z,3);\n    \n    vec3 col = color(z);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // float a = mod(log(length(z)),0.5);\n    // col *= a+ 0.25*z.x/length(z)+0.75;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd23DG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 119], [121, 121, 148, 148, 235], [237, 237, 255, 255, 304], [306, 306, 326, 326, 705], [707, 707, 764, 814, 1302]], "test": "untested"}
{"id": "cd23WG", "name": "complex plot 1-z^n - log(abs(f))", "author": "kanayuki", "description": "complex plot 1-z^n - log(abs(f))", "tags": ["2d", "complex"], "likes": 2, "viewed": 191, "published": 3, "date": "1668079260", "time_retrieved": "2024-07-30T16:20:46.997113", "image_code": "vec2 times(vec2 a, vec2 b)\n{\n    float re = a.x*b.x-a.y*b.y;\n    float im = a.x*b.y+a.y*b.x;\n    return vec2(re, im);\n}\n\nvec2 power(vec2 a, int n)\n{\n    vec2 res = a;\n    for(int i=0; i<n-1; i++) res=times(res,a);\n    return res;    \n}\n\nmat2 rm(float t)\n{\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y*1.5;\n    uv *=rm(iTime);\n\n    vec2 z = vec2(1,0)-power(uv,5);\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float a = mod(log(length(z)),0.5);\n    col *= a+ 0.25*z.x/length(z)+0.75;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd23WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 119], [121, 121, 148, 148, 235], [237, 237, 255, 255, 304], [306, 306, 363, 413, 762]], "test": "untested"}
{"id": "csj3WG", "name": "complex plot 1-z^n", "author": "kanayuki", "description": "complex plot 1-z^n", "tags": ["2d", "complex"], "likes": 2, "viewed": 140, "published": 3, "date": "1668078633", "time_retrieved": "2024-07-30T16:20:47.737134", "image_code": "vec2 times(vec2 a, vec2 b)\n{\n    float re = a.x*b.x-a.y*b.y;\n    float im = a.x*b.y+a.y*b.x;\n    return vec2(re, im);\n}\n\nvec2 power(vec2 a, int n)\n{\n    vec2 res = a;\n    for(int i=0; i<n-1; i++) res=times(res,a);\n    return res;    \n}\n\nmat2 rm(float t)\n{\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y*1.5;\n    uv *= rm(sin(iTime/2.0));\n    uv *= 0.5*cos(iTime/1.0)+1.0;\n    vec2 z = vec2(1,0)-power(uv,28);\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col *= 0.25*z.x/length(z)+0.75;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csj3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 119], [121, 121, 148, 148, 235], [237, 237, 255, 255, 304], [306, 306, 363, 413, 764]], "test": "untested"}
{"id": "md2GRt", "name": "Rational quad bezier", "author": "NinjaKoala", "description": "Quick test showing off a rational quadratic bezier curve, with the two weights on the endpoints set to 1 and the weight at the control\npoint can be altered by going up and down with mouse after clicking.\n\nClicking in the bottom left starts animation again", "tags": ["2d", "bezier", "implicit", "quadratic", "parametric", "rational"], "likes": 9, "viewed": 373, "published": 3, "date": "1668076011", "time_retrieved": "2024-07-30T16:20:48.658670", "image_code": "/*\n\nThe idea of rational bezier curves is basically that you\ndefine the points in homogenic coordinates, different\nrepresentatives of the same affine points correspond to different\nweighted points. The curve is then also computed in homogenic coordinates\nand then you divide by the third coordinate to get an affine point.\n\nSo instead of a parametric polynomial function,\nyou get a parametric rational function.\n\nEvery three points have a weight associated a priori.\n\nBut scaling all three weights by the same factor doesn't change the curve.\nSo you can set one of the weights to 1.\n\nI decided to set two weights to 1 and only change the weight at the\ncontrol point, but i'm loosing a degree of freedom with that.\n\nI compute the approximated signed distance to the curve by using the implicitization\nand gradient distance estimation.\n\nFor more information about all sorts of stuff\nregarding bezier curves i always recommend Sederbergs script:\nhttp://hdl.lib.byu.edu/1877/2822\n\nThere is probably room for improvement at different parts of this shader.\n*/\n\n//#define SHOW_DISTANCE_FIELD\n\nconst bool fill_outer=false;\n\nconst float dot_size=.003;\n\nconst vec3 bg_col=vec3(1);\nconst vec3 dot_col=vec3(0,1,0);\nconst vec3 fill_col=vec3(0);\n\nconst float pi=3.1415925;\n\nconst int num_iterations=3;\nconst int num_start_params=16;\n\nfloat rational_quadratic_bezier_gradient_dis_approx(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n\tvec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n\tvec2 b2=a2.xy-uv*a2.z;\n\tvec2 b1=a1.xy-uv*a1.z;\n\tvec2 b0=a0.xy-uv*a0.z;\n    \n    float dm21=determinant(mat2(b2,b1));\n    float dm20=determinant(mat2(b2,b0));\n    float dm10=determinant(mat2(b1,b0));\n\n\tmat2 bezout_matrix=mat2(dm21,dm20,dm20,dm10);\n    float val=determinant(bezout_matrix);\n\n\tfloat grad_x=2.*dm20*(a2.z*b0.y - a0.z*b2.y)\n\t             - dm10*(a2.z*b1.y - a1.z*b2.y)\n\t\t\t\t - dm21*(a1.z*b0.y - a0.z*b1.y);\n\n\tfloat grad_y=dm10*(a2.z*b1.x - a1.z*b2.x)\n\t\t\t\t + dm21*(a1.z*b0.x - a0.z*b1.x)\n\t\t\t\t - 2.*dm20*(a2.z*b0.x - a0.z*b2.x);\n\n\treturn val/length(vec2(grad_x,grad_y));\n}\n\n// quartic equation solver by oneshade (see https://www.shadertoy.com/view/fsB3Wt)\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\nvec2 parametric_rational_quadratic_bezier(float t, vec3 p0, vec3 p1, vec3 p2){\n    vec3 p = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n    return p.xy/p.z;\n}\n\n/* Exact variant, has precision issues */\nfloat rational_quadratic_bezier_dis_exact(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n\tvec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n\tfloat q4 = (a2.x*a2.x + a2.y*a2.y)*a1.z\n             - (a1.x*a2.x + a1.y*a2.y)*a2.z\n             - (a2.x*a1.z*a2.z - a1.x*a2.z*a2.z)*uv.x\n             - (a2.y*a1.z*a2.z - a1.y*a2.z*a2.z)*uv.y;\n             \n    float q3 = 2.*(a2.x*a2.x + a2.y*a2.y)*a0.z\n             + (a1.x*a2.x + a1.y*a2.y)*a1.z\n             - (a1.x*a1.x + 2.*a0.x*a2.x\n             + a1.y*a1.y + 2.*a0.y*a2.y)*a2.z\n             - (a2.x*a1.z*a1.z - 2.*a0.x*a2.z*a2.z\n             + (2.*a2.x*a0.z - a1.x*a1.z)*a2.z)*uv.x\n             - (a2.y*a1.z*a1.z - 2.*a0.y*a2.z*a2.z\n             + (2.*a2.y*a0.z - a1.y*a1.z)*a2.z)*uv.y;\n\n    float q2 = 3.*((a1.x*a2.x + a1.y*a2.y)*a0.z\n             - (a0.x*a1.x + a0.y*a1.y)*a2.z\n             - (a2.x*a0.z*a1.z - a0.x*a1.z*a2.z)*uv.x\n             - (a2.y*a0.z*a1.z - a0.y*a1.z*a2.z)*uv.y);\n             \n    float q1 = (a1.x*a1.x + 2.*a0.x*a2.x + a1.y*a1.y + 2.*a0.y*a2.y)*a0.z\n             - (a0.x*a1.x + a0.y*a1.y)*a1.z\n             - 2.*(a0.x*a0.x + a0.y*a0.y)*a2.z\n             - (2.*a2.x*a0.z*a0.z + a1.x*a0.z*a1.z\n             - a0.x*a1.z*a1.z - 2.*a0.x*a0.z*a2.z)*uv.x\n             - (2.*a2.y*a0.z*a0.z + a1.y*a0.z*a1.z\n             - a0.y*a1.z*a1.z - 2.*a0.y*a0.z*a2.z)*uv.y;\n\n    float q0 = (a0.x*a1.x + a0.y*a1.y)*a0.z\n             - (a0.x*a0.x + a0.y*a0.y)*a1.z\n             - (a1.x*a0.z*a0.z - a0.x*a0.z*a1.z)*uv.x\n             - (a1.y*a0.z*a0.z - a0.y*a0.z*a1.z)*uv.y;\n\n    vec4 roots;\n    int n_roots = solveQuartic(q4,q3,q2,q1,q0,roots);\n    \n    float dis = 1e38;\n    \n    for(int i=0;i<n_roots;i++){\n        dis = min(dis, distance(uv,parametric_rational_quadratic_bezier(roots[i],p0,p1,p2)));\n    }\n    \n    return dis;\n}\n\nfloat rational_quadratic_bezier_val_grad(vec2 uv,vec3 p0,vec3 p1,vec3 p2, out vec2 grad){\n    vec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n    vec2 b2=a2.xy-uv*a2.z;\n    vec2 b1=a1.xy-uv*a1.z;\n    vec2 b0=a0.xy-uv*a0.z;\n\n    float dm21=determinant(mat2(b2,b1));\n    float dm20=determinant(mat2(b2,b0));\n    float dm10=determinant(mat2(b1,b0));\n\n    mat2 bezout_matrix=mat2(dm21,dm20,dm20,dm10);\n    float val=determinant(bezout_matrix);\n\n    float grad_x=2.*dm20*(a2.z*b0.y - a0.z*b2.y)\n                 - dm10*(a2.z*b1.y - a1.z*b2.y)\n                 - dm21*(a1.z*b0.y - a0.z*b1.y);\n\n    float grad_y=dm10*(a2.z*b1.x - a1.z*b2.x)\n                 + dm21*(a1.z*b0.x - a0.z*b1.x)\n                 - 2.*dm20*(a2.z*b0.x - a0.z*b2.x);\n                         \n    grad = vec2(grad_x,grad_y);\n    \n    return val;\n}\n\nfloat rational_quadratic_bezier_dis_approx2d(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n    const int num_start_points = 2;\n    const int num_iterations = 10;\n    \n    float dis = 1e38;\n\n    for(int i=0;i<num_start_points;i++){\n        float t = float(i) / float(num_start_points-1);\n        vec2 p = parametric_rational_quadratic_bezier(t,p0,p1,p2);\n        \n        for(int j=0;j<num_iterations;j++){\n            vec2 grad;\n            float val = rational_quadratic_bezier_val_grad(p,p0,p1,p2,grad);\n            vec2 tang = normalize(vec2(grad.y,-grad.x));\n            p += dot(tang,uv-p) * tang;\n            \n            val = rational_quadratic_bezier_val_grad(p,p0,p1,p2,grad);\n            p -= val * grad / dot(grad,grad);\n        }\n        dis = min(dis,distance(uv,p)); \n    }\n\n    return dis;\n}\n\n// Netwon method\nfloat rational_quadratic_bezier_dis_newton(vec2 uv, vec3 p0, vec3 p1, vec3 p2){\n    const float eps = .001;\n    const int num_start_vals = 16;\n    const int num_iterations = 5;\n    \n    float dis = 1e38;\n    \n    for(int i=0;i<num_start_vals;i++){\n        float t = float(i) / float(num_start_vals-1);\n\n        for(int j=0;j<num_iterations;j++){\n            vec3 fp1 = mix(mix(p0,p1,t-eps),mix(p1,p2,t-eps),t-eps);\n            float f1 = dot(uv-fp1.xy/fp1.z,uv-fp1.xy/fp1.z);\n            \n            vec3 fp2 = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n            float f2 = dot(uv-fp2.xy/fp2.z,uv-fp2.xy/fp2.z);\n            \n            vec3 fp3 = mix(mix(p0,p1,t+eps),mix(p1,p2,t+eps),t+eps);\n            float f3 = dot(uv-fp3.xy/fp3.z,uv-fp3.xy/fp3.z);\n            \n            t -= eps * ((-.5 * f1 + .5 * f3) / (f1 - 2.*f2 + f3));\n        }\n        t = clamp(t,0.,1.);\n        vec3 p = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n        float f = dot(uv-p.xy/p.z,uv-p.xy/p.z);\n        \n        dis = min(dis,f);\n    }\n    return sqrt(dis);\n}\n\n//by iq (see https://www.shadertoy.com/view/XsXSz4)\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat rational_quadratic_bezier_normal_iteration(float t, vec2 uv, vec3 a0, vec3 a1, vec3 a2){\n\tvec3 eval=(a2*t+a1)*t+a0;\n\n\tvec2 diff_num=((a2.xy*a1.z - a1.xy*a2.z)*t + 2.*(a2.xy*a0.z - a0.xy*a2.z))*t + a1.xy*a0.z - a0.xy*a1.z;\n\n\tvec2 uv_to_p=eval.xy / eval.z - uv;\n\tvec2 tang=diff_num / (eval.z * eval.z);\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat rational_quadratic_bezier_dis_approx(vec2 uv, vec3 p0, vec3 p1, vec3 p2){\n\tvec3 a2 = p0 - 2. * p1 + p2;\n\tvec3 a1 = -2. * p0 + 2. * p1;\n\tvec3 a0 = p0;\n\n\tfloat d0 = 1e38;\n\n\tfloat t0=.0;\n\tfloat t;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tt=t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\tt=rational_quadratic_bezier_normal_iteration(t,uv,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec3 cur_p=(a2*t+a1)*t+a0;\n\t\tcur_p/=cur_p.z;\n\t\tvec2 uv_to_p = cur_p.xy - uv;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\n\t\tt0+=1./float(num_start_params-1);\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat rational_quadratic_bezier_sign(vec2 uv,vec3 p0,vec3 p1,vec3 p2){\n\tvec3 a2=p0-2.*p1+p2;\n\tvec3 a1=-2.*p0+2.*p1;\n\tvec3 a0=p0;\n\n\tvec2 b2=a2.xy-uv*a2.z;\n\tvec2 b1=a1.xy-uv*a1.z;\n\tvec2 b0=a0.xy-uv*a0.z;\n\n\tmat2 bezout_matrix=mat2(determinant(mat2(b2,b1)),determinant(mat2(b2,b0)),determinant(mat2(b2,b0)),determinant(mat2(b1,b0)));\n\n\treturn sign(determinant(bezout_matrix));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse2=abs(iMouse.zw)/iResolution.xy;\n\tmouse2-=.5;\n    mouse2.y*=iResolution.y/iResolution.x;\n\n\tfloat weight = exp(5.*(mouse2.y-mouse.y));\n\n\tvec3 p0=vec3(-.3,-.2,1.);\n\tvec3 p1=vec3(mouse2,1.)*weight;\n\tvec3 p2=vec3(.3,-.2,1.);\n\n\tif(max(iMouse.x, iMouse.y) < 20.){\n\t\tweight=1.+.3*sin(2.*iTime);\n        p1=vec3(.3*sin(iTime),.1+.1*cos(iTime),1.)*weight;\n    }\n\n\tfloat tri_dis=sdTriangle(uv,p0.xy/p0.z,p1.xy/p1.z,p2.xy/p2.z);\n\n    float curve_dis=(fill_outer?1.0:-1.0) * rational_quadratic_bezier_gradient_dis_approx(uv,p0,p1,p2);\n    \n    // The distance approximation using the parametric form doesn't work well here\n    /*\n    float sgn=rational_quadratic_bezier_sign(uv,p0,p1,p2);\n    float curve_dis=(fill_outer?1.0:-1.0) * sgn * rational_quadratic_bezier_dis_approx(uv,p0,p1,p2);\n    */\n    \n    // Exact variant (with numerical precision issues)\n    /*\n    float sgn=rational_quadratic_bezier_sign(uv,p0,p1,p2);\n    float curve_dis=(fill_outer?1.0:-1.0) * sgn * rational_quadratic_bezier_dis_exact(uv,p0,p1,p2);\n    */\n    \n    // Newton method variant\n    /*\n    float sgn=rational_quadratic_bezier_sign(uv,p0,p1,p2);\n    float curve_dis=(fill_outer?1.0:-1.0) * sgn * rational_quadratic_bezier_dis_newton(uv,p0,p1,p2);\n    */\n    \n    #ifdef SHOW_DISTANCE_FIELD\n    float dis = curve_dis;\n    #else\n\tfloat dis=max(tri_dis,curve_dis);\n    #endif\n\n\tvec3 color = bg_col;\n\tcolor=mix(fill_col,color,smoothstep(-border/2.,border/2.,dis));\n    \n    #ifdef SHOW_DISTANCE_FIELD\n    dis*=3.;\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(120.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(dis)) );\n    color = col;\n    #endif\n\n\tdis=1e38;\n\n\tdis=min(dis,distance(p0.xy/p0.z,uv)-dot_size);\n\tdis=min(dis,distance(p1.xy/p1.z,uv)-dot_size*weight);\n\tdis=min(dis,distance(p2.xy/p2.z,uv)-dot_size);\n    \n    vec2 p3=parametric_rational_quadratic_bezier(fract(.1*iTime),p0,p1,p2);\n    dis=min(dis,distance(p3,uv)-dot_size);\n\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2GRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1320, 1320, 1405, 1405, 2047], [2049, 2132, 2156, 2156, 2199], [2200, 2200, 2296, 2296, 4745], [4747, 4747, 4825, 4825, 4895], [4897, 4939, 5014, 5014, 6721], [6723, 6723, 6812, 6812, 7547], [7549, 7549, 7627, 7627, 8344], [8346, 8363, 8442, 8442, 9394], [9396, 9448, 9501, 9501, 10102], [10104, 10104, 10198, 10198, 10479], [10481, 10481, 10560, 10560, 11027], [11029, 11029, 11099, 11099, 11403], [11405, 11405, 11459, 11459, 13764]], "test": "untested"}
{"id": "msBGWG", "name": "Chutes and Ladders Probability", "author": "oneshade", "description": "Using matrices to calculate the probability of landing on a particular square in a game of Chutes and Ladders.", "tags": ["matrices", "probability", "markovchains", "chutesandladders"], "likes": 6, "viewed": 208, "published": 3, "date": "1668069907", "time_retrieved": "2024-07-30T16:20:49.412654", "image_code": "// Reference: https://www.datagenetics.com/blog/november12011/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 10.0;\n\n    // Visualize transition matrix\n    //vec3 color = texelFetch(iChannel0, ivec2(uv * 10.0), 0).rgb;\n    //color += 0.2 * smoothstep(200.0 / iResolution.x, 0.0, abs(fract(uv.x * 10.0 + 0.5) - 0.5));\n    //color += 0.2 * smoothstep(200.0 / iResolution.y, 0.0, abs(fract(uv.y * 10.0 + 0.5) - 0.5));\n    //fragColor = vec4(color, 1.0);\n\n    ivec2 ij = ivec2(uv);\n    if (ij.y % 2 == 1) ij.x = 9 - ij.x; // Rows wind back and forth\n    vec3 color = texelFetch(iChannel1, ivec2(10 * ij.y + ij.x, 0), 0).rgb;\n\n    // Normalize to improve visibility\n    float maxVal = 0.0;\n    for (int n=0; n < 100; n++) {\n        maxVal = max(maxVal, texelFetch(iChannel1, ivec2(n, 0), 0).x);\n    }\n\n    // Grid\n    color.r += smoothstep(20.0 / iResolution.x, 0.0, abs(fract(uv.x + 0.5) - 0.5));\n    color.r += smoothstep(20.0 / iResolution.y, 0.0, abs(fract(uv.y + 0.5) - 0.5));\n\n    fragColor = vec4(color / maxVal, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int i = int(fragCoord.x);\n    int j = int(fragCoord.y);\n    fragColor = vec4(0.0);\n    if (i < 100 && j < 100) {\n        if (iFrame == 0) {\n            bool isSlide = false;\n            int dest;\n            for (int idx=0; idx < 19; idx++) {\n                if (slides[idx].x == i) {\n                    isSlide = true;\n                    dest = slides[idx].y;\n                    break;\n                }\n            }\n\n            if (isSlide) {\n                if (j == dest) {\n                    fragColor = vec4(1.0); // Instantly jump to a different square\n                }\n            }\n\n            else {\n                if (j >= i + 1 && j < i + 7) {\n                    fragColor = vec4(1.0); // Advance forward amount rolled on the die\n                }\n\n                if (i > 93 && j == i) {\n                    fragColor = vec4(i - 93); // Must get exact amount to finish\n                }\n\n                fragColor /= 6.0;\n            }\n        }\n\n        if (iFrame > 0) {\n            fragColor = texelFetch(iChannel0, ivec2(i, j), 0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const ivec2[19] slides = ivec2[19](\n    ivec2( 0, 37),\n    ivec2( 3, 13),\n    ivec2( 8, 30),\n    ivec2(15,  5),\n    ivec2(20, 41),\n    ivec2(27, 83),\n    ivec2(35, 43),\n    ivec2(47, 25),\n    ivec2(48, 10),\n    ivec2(50, 66),\n    ivec2(55, 52),\n    ivec2(61, 18),\n    ivec2(63, 59),\n    ivec2(70, 90),\n    ivec2(79, 99),\n    ivec2(86, 23),\n    ivec2(92, 72),\n    ivec2(94, 74),\n    ivec2(97, 77)\n);", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int i = int(fragCoord.x);\n    fragColor = vec4(0.0);\n    if (int(fragCoord.y) == 0 && i < 100) {\n        if (iFrame == 0) {\n            // Initial probability distribution\n            if (i < 6) {\n                fragColor = vec4(1.0 / 6.0);\n            }\n        }\n\n        if (iFrame > 0) {\n            if (iFrame % 60 == 0) {\n                // Multiply by transition matrix\n                for (int n=0; n < 100; n++) {\n                    fragColor += texelFetch(iChannel0, ivec2(n, i), 0) * texelFetch(iChannel1, ivec2(n, 0), 0);\n                }\n            }\n\n            else {\n                fragColor = texelFetch(iChannel1, ivec2(i, 0), 0);\n            }\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 118, 118, 1074]], "test": "untested"}
{"id": "ds23zd", "name": "TestMoney", "author": "uratowel12", "description": "123", "tags": ["123"], "likes": 8, "viewed": 269, "published": 3, "date": "1668051787", "time_retrieved": "2024-07-30T16:20:50.153673", "image_code": "//CBS\n//Parallax scrolling fractal galaxy.\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n\t\n\t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\t\n\tfragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\n}", "image_inputs": [{"id": 30325, "src": "https://soundcloud.com/clammyclams/im-god-lil-b", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds23zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 223, 255, 255, 642], [644, 680, 714, 714, 1101], [1103, 1103, 1127, 1127, 1310], [1313, 1313, 1370, 1370, 2789]], "test": "untested"}
{"id": "dsjGRt", "name": "smiley tutorial 2", "author": "jonasfrey", "description": "followed this tuorial https://www.youtube.com/watch?v=ZlNnrpM0TRg&t=8s&ab_channel=TheArtofCode", "tags": ["smiley"], "likes": 2, "viewed": 172, "published": 3, "date": "1668043605", "time_retrieved": "2024-07-30T16:20:50.895689", "image_code": "// macro for smoothstep\n#define f_smstp(a,b,t) smoothstep(a,b,t)\nfloat f_n_remap1(\n    float a,\n    float b,\n    float t\n){\n    return clamp((t-a)/(b-a), 0.0, 1.0);\n}\nfloat f_n_remap2(\n    float a,\n    float b,\n    float c,\n    float d,\n    float t\n){\n    return (f_n_remap1(a,b,t)) * (d-c) + c;\n}\nvec2 f_o_within(\n    vec2 o_pixel_coord_norm, \n    vec4 o_rect\n){\n    return (o_pixel_coord_norm-o_rect.xy)/(o_rect.zw-o_rect.xy);\n}\nvec4 f_o_col_eye(\n    vec2 o_pixel_coord_norm\n){\n    // re normalize \n    o_pixel_coord_norm -= 0.5;\n    float n_dist = length(o_pixel_coord_norm);\n\n    vec4 o_col_iris = vec4(0.3, 0.5, 1., 1.0);\n    vec4 o_col = mix(vec4(1.0), o_col_iris, f_smstp(0.1, 0.5, n_dist)*0.5);\n    \n    o_col.rgb *= 1. - f_smstp(0.45, 0.5 , n_dist)*0.5*clamp(-o_pixel_coord_norm.y-o_pixel_coord_norm.x, 0.0, 1.0);\n    \n    o_col.rgb = mix(o_col.rgb, vec3(0.0), f_smstp(0.3, 0.25, n_dist));\n    o_col_iris.rgb *= 1. + f_smstp(0.3, 0.05, n_dist);\n    \n    \n    o_col.rgb = mix(o_col.rgb, o_col_iris.rgb, f_smstp(0.28, 0.25, n_dist));\n    \n    o_col.rgb = mix(o_col.rgb, vec3(0.0), f_smstp(0.16, 0.14, n_dist));\n\n    \n    float n_highlight = f_smstp(\n        0.1,\n        0.09,\n        length(\n            o_pixel_coord_norm\n            - vec2(-.15, .15)\n        )\n    );\n    n_highlight += f_smstp(\n        0.07,\n        0.05,\n        length(\n            o_pixel_coord_norm\n            + vec2(-.08, .08)\n        )\n    );\n    o_col.rgb = mix(o_col.rgb, vec3(1.0), n_highlight);\n    o_col.a = f_smstp(0.5, 0.48, n_dist);\n    \n    \n    return o_col;\n}\n\nvec4 f_o_col_mouth(\n    vec2 o_pixel_coord_norm\n){\n    o_pixel_coord_norm -= 0.5;\n    o_pixel_coord_norm.y *= 1.5;\n\n    o_pixel_coord_norm.y -= o_pixel_coord_norm.x * o_pixel_coord_norm.x*2.0;\n    vec4 o_col = vec4(0.5, 0.18, 0.05 , 1.0);\n    float n_dist = length(o_pixel_coord_norm);\n    o_col.a = f_smstp(0.5, 0.48, n_dist);\n    \n    vec3 o_col_tooth = vec3(1.0)*f_smstp(0.6, 0.35, n_dist);\n    float n_dist_teeth  = length(o_pixel_coord_norm-vec2(0., 0.55)); \n    o_col.rgb = mix(o_col.rgb, o_col_tooth, f_smstp(0.4, 0.37, n_dist_teeth));\n    \n    float n_dist_tounge = length(o_pixel_coord_norm+vec2(0., 0.5));\n    o_col.rgb = mix(o_col.rgb, vec3(1.0, 0.5, 0.5), f_smstp(0.5, 0.2, n_dist_tounge));\n\n    return o_col;\n}\n\nvec4 f_o_col_head(\n    vec2 o_pixel_coord_norm\n){\n    vec4 o_col = vec4(0.9, 0.66, 0.3, 1.0);\n    float n_dist = length(\n        vec2(0.0,0.0) - o_pixel_coord_norm\n    );\n    o_col.a = f_smstp(0.5, 0.49, n_dist);\n    float n_edge_shade = f_n_remap1(.35, .5, n_dist);\n    n_edge_shade = n_edge_shade*n_edge_shade;\n    o_col.rgb *= 1.-n_edge_shade * 0.3;\n    o_col.rgb = mix(o_col.rgb, vec3(0.7, 0.3, 0.1), f_smstp(0.47, 0.48, n_dist));\n    \n    float n_highlight = f_smstp(0.41, 0.405, n_dist)*0.5;\n    n_highlight *= f_n_remap2(0.41, 0.0, 0.76, 0., o_pixel_coord_norm.y);\n    o_col.rgb = mix(o_col.rgb, vec3(1.0), n_highlight);\n    \n    n_dist = length(o_pixel_coord_norm - vec2(0.25, -0.2));\n    float n_cheeck = f_smstp(0.2, 0.01, n_dist)*0.4;\n    n_cheeck *= f_smstp(.17, 0.15, n_dist);\n    o_col.rgb = mix(o_col.rgb, vec3(1.0, 0.1, 0.1), n_cheeck);\n    return o_col;\n}\n\nvec4 f_o_col_smiley(\n    vec2 o_pixel_coord_norm\n){\n    vec4 o_col = vec4(0.0);\n    //mirror x coordinate \n    o_pixel_coord_norm.x = abs(o_pixel_coord_norm.x);\n    \n    vec4 o_col_head = f_o_col_head(o_pixel_coord_norm);\n    \n    vec4 o_col_eye = f_o_col_eye(\n        f_o_within(\n            o_pixel_coord_norm, \n            vec4(0.03, -.1, 0.37, 0.25)\n        )\n    );\n\n    vec4 o_col_mouth = f_o_col_mouth(\n        f_o_within(\n            o_pixel_coord_norm, \n            vec4(-.3, -.4, 0.3, -0.1)\n        )\n    );\n    \n    o_col = mix(o_col, o_col_head, o_col_head.a);\n    o_col = mix(o_col, o_col_eye, o_col_eye.a);\n    o_col = mix(o_col, o_col_mouth, o_col_mouth.a);\n\n\n    \n    return o_col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pixel_coord_norm = fragCoord.xy / iResolution.xy;\n    \n    o_pixel_coord_norm -= 0.5;\n    \n    o_pixel_coord_norm.x *= iResolution.x/iResolution.y;\n    \n    fragColor = f_o_col_smiley(o_pixel_coord_norm);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjGRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 123, 123, 166], [167, 167, 251, 251, 297], [298, 298, 363, 363, 430], [431, 431, 479, 500, 1555], [1557, 1557, 1607, 1607, 2280], [2282, 2282, 2331, 2331, 3154], [3156, 3156, 3207, 3207, 3855], [3857, 3857, 3914, 3914, 4132]], "test": "untested"}
{"id": "dsfGzj", "name": "Squirmle Truchet", "author": "byt3_m3chanic", "description": "Squirmles - It's the Magical Pet.\n\nalso Truchets and Bayer textures are so hot right now.. ", "tags": ["hextruchetplay"], "likes": 35, "viewed": 315, "published": 3, "date": "1668039000", "time_retrieved": "2024-07-30T16:20:51.643689", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Reminds me of Squirmles - using bayer again to make some dithered animation\n    on the truchet tiles.. \n    \n    11/09/22 @byt3_m3chanic \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n\n#define PI         3.14159265359\n#define PI2        6.28318530718\n#define SQ3        1.732\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n//@Shane\nvec4 hexGrid(vec2 uv, float scale){\n    uv*=scale;\n    const vec2 s = vec2(SQ3, 1.);\n    vec4 hC = floor(vec4(uv, uv - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h4 = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n    return dot(h4.xy, h4.xy) < dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nconst float scale = 11.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec3 C = vec3(0);\n    \n    vec2 uv = F.xy/max(R.x,R.y);\n    uv-=vec2(T*.01,T*.05);\n    vec2 vuv=uv;\n    \n    float px = scale/R.x;\n    vec4 hex = hexGrid(uv,scale);\n\n    vec2 id = hex.zw;\n    vec2 p  = hex.xy;\n    \n    float check = mod(id.y + id.x,2.) * 2. - 1.;\n    float rnd = hash21(id);\n    float dir =  -1.;\n    \n    if(rnd>.5) {\n        p *= rot(1.0471975512);\n        p.y=-p.y;\n    } \n    \n    float rdx = .2885;\n    \n    // set vectors\n    vec2 p0 = p - vec2(-.5/SQ3, .5);\n    vec2 p1 = p - vec2(.8660254*2./3., 0);\n    vec2 p2 = p - vec2(-.5/SQ3, -.5);\n    \n    // find closest point\n    vec3 d3 = vec3(length(p0), length(p1), length(p2));\n    vec2 pp = vec2(0);\n\n    if(d3.x>d3.y) pp = p1;\n    if(d3.y>d3.z) pp = p2;\n    if(d3.z>d3.x && d3.y>d3.x) pp = p0;\n\n    float wrp = sin(T+(vuv.x+vuv.y)*10.);\n    // draw truchet path\n    float circle = length(pp)-rdx;\n    circle=abs(circle)-(.14+.080*wrp);//.15;\n    \n    float cntr = circle;\n    float cntrsdo = circle;\n    cntrsdo = smoothstep(.1-px,px,cntrsdo);\n    cntr = smoothstep(px,-px,cntr);\n    \n    circle=abs(circle)-.0075;\n    circle=smoothstep(px,-px,circle);\n    float amt = 12.;\n\n    // hex background\n    float tileform = max(abs(hex.x)*.8660254 + abs(hex.y)*.5, abs(hex.y)) - .5;\n    float edges = abs(abs(tileform)-.025)-.015;\n    edges=smoothstep(px,-px, edges);\n    float cells=smoothstep(px,-px, tileform);\n\n    //animation\n    d3 = abs(d3 - SQ3/6.) - .125;\n    vec3 a3=vec3(atan(p0.x, p0.y),atan(p1.x, p1.y),atan(p2.x, p2.y));\n    \n    vec2 da = vec2(0);\n    if(d3.x>d3.y) da = vec2(d3.y, a3.y);\n    if(d3.y>d3.z) da = vec2(d3.z, a3.z);\n    if(d3.z>d3.x && d3.y>d3.x) da = vec2(d3.x, a3.x);\n    \n    //speed\n    float speed = texture(iChannel1,(F/8.)).r - (T*2.);\n    \n    float d = length(pp);\n    float pathMotion = 200.+da.y/ PI2* (amt) + speed;\n    \n    float x =fract(pathMotion) - .5;\n    float y = d-rdx;\n\n    vec2 cid = vec2(floor(x),floor(pathMotion)-.5);\n    cid=mod(cid,4.);\n\n    //vector and compress coords\n    vec2 tu = vec2(x,y)*vec2(3,10.);\n\n    float path = box(tu,vec2(1.5,1.1+.75*wrp));\n    path=smoothstep(px,-px,path);\n\n    //mixdowns and stuff\n    vec3 topHue = hsv2rgb(vec3(cid.y*PI2,1.,.6)).xxx;\n    float cut = min(cells,1.-cntr);\n    \n\n    C = rnd>.7? vec3(.5):vec3(.05);\n    C = mix(C, vec3(.9), cntr);\n    C = mix(C, vec3(.05),cntrsdo);\n\n    C = mix(C, topHue,path);\n    C = mix(C, vec3(.0),min(cut,edges));\n    C = mix(C, vec3(.85),circle); \n       \n    //output\n    O = vec4(pow(C,vec3(.4545)),1.0);\n}\n\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfGzj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[419, 419, 437, 437, 480], [481, 481, 502, 502, 562], [564, 578, 605, 605, 731], [732, 741, 776, 776, 1040], [1042, 1042, 1076, 1076, 1156], [1183, 1183, 1224, 1224, 3736]], "test": "untested"}
{"id": "mdSGzd", "name": "Bubble voronoi", "author": "rubioh", "description": "Bubble voronoi, u can grab the center bubble.\nOnly analytic computation for the 3D effect.", "tags": ["2d", "voronoi", "refraction"], "likes": 10, "viewed": 253, "published": 3, "date": "1668029965", "time_retrieved": "2024-07-30T16:20:52.392686", "image_code": "#define PI 3.14159\n\nvec2 hash22(vec2 p){\n    vec2 a = vec2(94.86, 43.46);\n    vec2 b = vec2(72.67, 13.48);\n    p = vec2(dot(p, a), dot(p, b));\n    return fract(sin(p*10.29)*48.47);\n}\n\nvec3 hash23(vec2 p){\n    vec2 a = vec2(92.8, 438.7);\n    vec2 b = vec2(73.6, 12.8);\n    vec2 c = vec2(34.7, 73.18);\n\n    vec3 r = vec3(dot(p, a), dot(p, b), dot(p, c));\n    return fract(sin(r*10.29)*48.47);\n}\nvec3 analytic_sphere(vec2 p, float r) {\n    //return sphere_coord;\n    float l = length(p);\n    float h = r*cos(l*PI/2./(r*1.5));\n    p = normalize(p/r)*asin(length(p/r)) / PI;\n    //p *= smoothstep(0., 0.001, sign(p));\n    return vec3(p, h);\n}\n\nvec3 calcNormal(vec2 p, float r){\n    vec2 e = vec2(1.0, -1.0) * 0.001;    \n    return normalize(\n      e.xyx*analytic_sphere(p + e.xy, r) +\n      e.yxx*analytic_sphere(p + e.yx, r) +\n      e.xxx*analytic_sphere(p + e.xx, r));\n}\n\nvec2 voro(vec2 uv, float ntiles, out vec3 normal, out vec3 col_boule)\n{\n    vec2 uv_id = floor (uv*ntiles);\n    vec2 uv_st = fract(uv*ntiles);\n\n    vec2 m_neighbor, m_diff, m_neighbor_id;\n    float m_dist_s, m_dist = 10.;\n    vec2 idx = vec2(0.,0.);\n    int K = 1;\n    vec2 point;\n    for (int j = -K; j<=K; j++)\n    {\n        for (int i = -K; i<=K; i++)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            if (uv_id + neighbor == vec2(0.,0.)){\n                point = (iMouse.xy-.5*iResolution.xy)/iResolution.y*ntiles;\n            }\n            else{\n                point = hash22(uv_id + neighbor);\n                point = float(K)/2.+float(K)/2.*sin(2.*PI*point+iTime/1.);\n            }\n            vec2 diff = neighbor + point - uv_st;\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_dist_s = dist;\n                m_diff = diff;\n                m_neighbor = neighbor+point;\n                m_neighbor_id = neighbor;\n            }\n        }\n    }\n    \n    // mla suggestion\n    vec2 neighbor_id = m_neighbor_id + uv_id;\n    vec2 neighbor_coord = m_neighbor + uv_id - neighbor_id;\n    \n    m_dist=100.;\n   \n    for (int j = -K-1; j<=K+1; j++)\n    {\n        for (int i = -K-1; i<=K+1; i++)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            if (neighbor_id + neighbor == vec2(0.,0.)){\n                point = (iMouse.xy-.5*iResolution.xy)/iResolution.y*ntiles;\n            }\n            else{\n                point = hash22(neighbor_id + neighbor);\n                point = float(K)/2.+float(K)/2.*sin(2.*PI*point+iTime/1.);\n            }\n            vec2 new_neighbor = point+neighbor;\n            vec2 diff = new_neighbor - neighbor_coord;\n            float dist = length(diff);\n            if (dist < m_dist && length(neighbor_coord-new_neighbor)>.0001)\n                    m_dist = dist;\n        }\n    }\n    float neighbor_radius = m_dist/2.;\n    \n    \n    float d = 1.-smoothstep(-.02, -0., length(m_neighbor-uv_st)-neighbor_radius);\n    \n    float r = neighbor_radius;\n    vec2 p = m_neighbor-uv_st;\n    float l = length(p);\n    vec3 sphere = analytic_sphere(p, r);\n    float h = r*cos(l*PI/2./r);\n    col_boule = hash23(neighbor_id);\n    normal = calcNormal(p, r);\n        \n    return vec2(d, h);\n}\n\nfloat smooth_damier(vec2 uv){\n    float a = (.32035*atan(sin(PI*uv.x)/0.01)+.5);\n    float b = (.32035*atan(sin(PI*uv.y)/0.01)+.5);\n    return a*(1.-b)+b*(1.-a);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col) {\n  // ambient\n  vec3 ambient = col*(.5+.5*normal.z);\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = col * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal*.8), -rd), 0., 1.);\n  vec3 specular = 2.*col* pow(dotRV, 12.);\n\n  return ambient*.4 + diffuse + specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n        \n    vec3 normal;\n    vec3 col_boule;\n    vec2 v = voro(uv, 4., normal, col_boule);\n    \n    vec3 rd = vec3(uv, 2.);\n    vec3 ld = vec3(-.4,-.4, 2.);//lightdir\n    \n    \n    vec3 rr = refract(rd, normal, .1);\n    vec3 ro = vec3(uv, v.y);\n    float depth = -ro.z/rr.z;\n    vec2 st = (v.x > 0.06) ? (ro+rr*depth).xy : uv;\n\n    \n    vec3 col = v.y*1.*max(vec3(0.), v.x*phong(ld, normal, rd, col_boule+.3));\n    \n    float damier = smooth_damier(st*4.);\n    \n    col += v.y*1.*max(vec3(0.), v.x*phong(ld, normal, rd, vec3(damier*.4)*v.x));\n    \n    \n    float dotLN_damier = clamp(dot(ld, vec3(0.,0.,1.)), 0., 1.)*(1.-v.x);\n    float dotRV_damier = clamp(dot(reflect(ld, vec3(0.,0.,1.)*.8), -rd), 0., 1.)*(1.-v.x);\n    col += .5*damier* pow(dotRV_damier*.99, 10.) + .4*damier * dotLN_damier;\n\n    // Output to screen\n    fragColor = vec4(col*.8, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 182], [184, 184, 204, 204, 392], [393, 393, 432, 459, 637], [639, 639, 672, 672, 867], [869, 869, 940, 940, 3211], [3213, 3213, 3242, 3242, 3376], [3378, 3378, 3437, 3450, 3761], [3764, 3764, 3821, 3871, 4820]], "test": "untested"}
{"id": "csj3zt", "name": "Golden Electric Spiral", "author": "SnoopethDuckDuck", "description": "wanted to use vec2(d1,d2)/(d1+d2) as co-ords then played around with things", "tags": ["spiral"], "likes": 27, "viewed": 347, "published": 3, "date": "1668027464", "time_retrieved": "2024-07-30T16:20:53.190553", "image_code": "float seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float a = atan(uv.y, uv.x);\n    vec2 p = cos(a + iTime) * vec2(cos(0.5 * iTime), sin(0.3 * iTime));\n    vec2 q = (cos(iTime)) * vec2(cos(iTime), sin(iTime));\n    \n    float d1 = length(uv - p);\n    float d2 = length(uv - 0.);\n    \n    vec2 uv2 = 2. * cos(log(length(uv))*0.25 - 0.5 * iTime + log(vec2(d1,d2)/(d1+d2)));///(d1+d2);\n    //uv = mix(uv, uv2, exp(-12. * length(uv)));\n    //uv = uv2;\n    \n    vec2 fpos = fract(4. *  uv2) - 0.5;\n    float d = max(abs(fpos.x), abs(fpos.y));\n    float k = 5. / iResolution.y;\n    float s = smoothstep(-k, k, 0.25 - d);\n    vec3 col = vec3(s, 0.5 * s, 0.1-0.1 * s);\n    col += 1./cosh(-2.5 * (length(uv - p) + length(uv))) * vec3(1,0.5,0.1);\n    \n    float c = cos(10. * length(uv2) + 4. * iTime);\n    col += (0.5 + 0.5 * c) * vec3(0.5,1,1) *\n           exp(-9. * abs(cos(9. * a + iTime) * uv.x\n                       + sin(9. * a + iTime) * uv.y \n                       + 0.1 * c));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csj3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 163], [165, 165, 222, 222, 1256]], "test": "untested"}
{"id": "ddS3z3", "name": "Twisted Trip", "author": "kishimisu", "description": "An infinite psychedelic loop", "tags": ["raymarching", "spiral", "colorful", "psychedelic", "rgb", "rainbow", "code", "golfing"], "likes": 36, "viewed": 544, "published": 3, "date": "1668027150", "time_retrieved": "2024-07-30T16:20:54.025321", "image_code": "/* \n   @kishimisu - 2022 \n   https://www.shadertoy.com/view/ddS3z3 \n*/\n\n#define c(a) (sin(a)*.5+.5)\n#define g    (iTime*.5)\n\nfloat b(vec3 p, vec3 s) { // box sdf\n  vec3 q = abs(p) - s; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    float a, r, t = 3.;\n    \n    vec2 n = iResolution.xy; \n    for (a = 0.; a < 150. && t > .002*r && r < 50.; a++) {\n        vec3 p = normalize(vec3((F-n*.5)/n.y*1.4, 1.))*r; p.z += g; \n        p.xy  *= mat2(cos(mix(c(g), -c(g), c((g-3.14)/2.))*r*.75 + vec4(0,33,11,0)));    \n        r += t = max(b(fract(p+.5)-.5, vec3(mix(.2,.45,c(g)))),-b(p, vec2(1.1,1e9).xxy))*.85;         \n    }\n    O.rgb = cos(vec3(mix(2.05,1.85,c(g)),2.1,2.15)*r-g) * exp(-r*.06);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddS3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 150, 161, 245], [247, 247, 286, 286, 745]], "test": "untested"}
{"id": "DsjGzt", "name": "Chessboard_dm", "author": "DmLvkvch", "description": "Chessboard ", "tags": ["chessboard"], "likes": 0, "viewed": 186, "published": 3, "date": "1668024794", "time_retrieved": "2024-07-30T16:20:54.847124", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(mod(dot(vec2(1.0), floor(uv*15.0)),2.0));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 166]], "test": "untested"}
{"id": "msBGzd", "name": "wave distortion", "author": "import_shader_steve", "description": "Experiments of sin and cos waves, with coordinate distortions.", "tags": ["wave", "distortion", "sin", "cos"], "likes": 1, "viewed": 159, "published": 3, "date": "1668016644", "time_retrieved": "2024-07-30T16:20:55.738741", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5 * iResolution.xy) / iResolution.y;\n    uv *= 2.;\n    uv.x /= sin(uv.y * iTime) * 100. * sin(iTime);\n    uv.y /= cos(uv.x * iTime) * 100. * cos(iTime);\n    vec3 col = vec3(uv.x / uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 379]], "test": "untested"}
{"id": "dsSGzt", "name": "Inverse Trig Accuracy II", "author": "mla", "description": "Implementing atan as a 9 coefficient Chebyshev approximation, and using that to define acos and asin. The results are more accurate than the built in functions.\n\nHorizontal scale [0,π/2], vertical scale ±1e-6, ie. 1/100th the scale of previous shader.", "tags": ["atan", "acos", "precision", "trigonometry", "asin"], "likes": 10, "viewed": 233, "published": 3, "date": "1668011363", "time_retrieved": "2024-07-30T16:20:56.672245", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Inverse Trig Accuracy II, mla 2022.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// Inverse trig function errors.\n\n// Red channel:   absolute error in acos(cos(x))\n// Green channel: absolute error in asin(sin(x))\n// Blue channel:  absolute error in atan(tan(x))\n//\n// This time, the inverse functions are computed by accurate functions,\n// using a Chebyshev approximation for atan.\n//\n// sin and cos also calculated by accurate functions, press 'x' to use the\n// native functions - be warned, the result on Intel isn't pretty.\n//\n// Horizontal scale is 0..π/2. Vertical scale is ±1e-6 on all platforms.\n//\n// Numeric display shows the main trig functions evaluated at the mouse position\n// and compared with the more accurate myxxx functions. We also compute the inverse\n// functions for comparison with the original theta.\n//\n//         mycos(theta)         mysin(theta)         mytan(theta)\n//         cos(theta)           sin(theta)           tan(theta)\n// theta   myacos(mycos(theta)) myasin(mysin(theta)) myatan(mytan(theta))\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// atan, asin, acos using Chebshev approximation\nfloat a = 0.0, b = 1.0;\n#if 1\nint N = 0;\nfloat myatan(float x, int n) {\n  // Chebyshev approximation for atan((1+x)/(1-x))\n  x = (x-1.0)/(x+1.0);\n  assert(x >= -1.0000000 && x <= 1.0000000);\n  float x2 = x*x;\n  float t = -0.0039602572;\n  t = x2*t + 0.021509254;\n  t = x2*t + -0.055381698;\n  t = x2*t + 0.096016564;\n  t = x2*t + -0.13892041;\n  t = x2*t + 0.19943081;\n  t = x2*t + -0.33329538;\n  t = x2*t + 0.99999925;\n  t = x*t + 0.78539816;\n  return t;\n}\n\n#elif 1\nfloat c[] = float[](\n  0.8284271247,-0.04737854124,0.004877323528,-0.0005977260152,\n  7.976388858e-05,-1.119707976e-05,1.625558989e-06, -2.417149193e-07 \n);\nconst int N = c.length();\n\n// Code from Numerical Recipes, adapted to use only odd coefficients.\n// I don't understand Clenshaw's Recurrence (yet) so I've just made\n// two copies of the loop body. Simplifications are possible.\nfloat eval(float x, int m) {\n  float d = 0.0, dd = 0.0;\n  assert(m <= N);\n  assert((x-a)*(x-b) <= 0.0);\n  float y = (2.0*x-a-b)/(b-a);\n  for (int j = m-1; j >= 0; j--) {\n    float sv = d;\n    d = 2.0*y*d-dd;\n    dd = sv;\n    sv = d;\n    d = 2.0*y*d-dd+c[j];\n    dd = sv;\n  }\n  return y*d-dd;\n}\n\n// Chebyshev series is for atan(1/(1-x)) - π/4 to make domain [0,1] rather than [0,∞)\n// and to make it an odd function in interval [0,1].\nfloat myatan(float x, int m) {\n  if (key(CHAR_Y)) return atan(x);\n  return eval(x/(1.0+x),m) + 0.25*PI;\n}\n#else\n// Simpler version using symmetry of atan about x=1, but less accurate for\n// same number of coefficients, for some reason.\nfloat c[] = float[](\n  0.8541571728, 0.3947364539, -0.03545533837, -0.001940941448,\n  0.001095092532, -0.0001026183744, -1.896686898e-05, 6.367123996e-06\n);\nconst int N = c.length();\n\n// Code from Numerical Recipes using 'Clenshaw's Recurrence'.\nfloat eval(float x, int m) {\n  float d = 0.0, dd = 0.0;\n  assert(m <= N);\n  assert((x-a)*(x-b) <= 0.0);\n  float y = (2.0*x-a-b)/(b-a);\n  for (int j = m-1; j > 0; j--) {\n    float sv = d;\n    d = 2.0*y*d-dd+c[j];\n    dd = sv;\n  }\n  return y*d-dd+0.5*c[0];\n}\n\n// Since atan(PI/2-x) = 1/atan(x) we can just use the Chebyshev \n// approximation on [0,1] and flip the result where necessary.\nfloat myatan(float x, int m) {\n  if (key(CHAR_Y)) return atan(x);\n  bool flip = x > 1.0;\n  if (flip) x = 1.0/x;\n  x = eval(x,m);\n  if (flip) x = 0.5*PI-x;\n  return x;\n}\n#endif\n// acos and asin seem to be hard to do directly as a Chebshev approximation\n// but fortunately they have nice definitions in terms of atan.\nfloat myacos(float x, int m) {\n  if (x == 0.0) return 0.5*PI; // Hum!\n  return myatan(1.0/(x*inversesqrt(1.0-x*x)),m);\n}\nfloat myasin(float x, int m) {\n  if (x == 1.0) return 0.5*PI;\n  return myatan(x*inversesqrt(1.0-x*x),m);\n}\n\n// mycos and mysin have been checked on CPU & agree to a few ulps with\n// builtin functions in range [0..pi/2] (ulp error is larger when result is\n// closer to zero, but absolute error is fine). It's possibly worth using\n// sin(pi/2-x) for cos(x) in upper half of range, but there isn't a lot in it.\n\nfloat mycos(float x) {\n  if (key(CHAR_X)) return cos(x);\n  int N = 12;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\n\nfloat mysin(float x) {\n  if (key(CHAR_X)) return sin(x);\n  int N = 10;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\nfloat hud(vec2 fragCoord, float theta) {\n  const int digits = 7;\n  const int nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int column = cellindex.x;\n  int row = cellindex.y;\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  // Get coords for mipmap scaling - p and uv have discontinuities\n  vec2 uvscale = 0.5*fragCoord/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = dFdx(uvscale), dy = dFdy(uvscale); // Calculate early\n  float x;\n  float cost = cos(theta);\n  float mycost = mycos(theta);\n  float sint = sin(theta);\n  float mysint = mysin(theta);\n  float mytant = mysint/mycost;\n  if (column == 0) {\n    if (row == 0) x = theta;\n    else return 0.0;\n  } else if (column == 1) {\n    if (row == 1) x = cost;\n    else if (row == 2) x = mycost;\n    else if (row == 0) x = myacos(mycost,N);\n    else return 0.0;\n  } else if (column == 2) {\n    if (row == 1) x = sint;\n    else if (row == 2) x = mysint;\n    else if (row == 0) x = myasin(mysint,N);\n    else return 0.0;\n  } else if (column == 3) {\n    if (row == 1) x = tan(theta);\n    else if (row == 2) x = mytant;\n    else if (row == 0) x = myatan(mytant,N);\n    else return 0.0;\n  } else {\n    return 0.0;\n  }\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = floatchar(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c < 0) return 0.0;\n  float charstart = charwidth*float(charpos); // character start\n  uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  return t.x;  \n}\n\nbool comp(float y, float r) { return (0.0 < y) == (y < r); }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float xmouse = 0.1*iTime;\n  float scale = 1e-6;\n  if (iMouse.x > 10.0) {\n    xmouse = iMouse.x/iResolution.x;\n    //scale = exp(-10.0*iMouse.y/iResolution.y);\n  }\n  xmouse = 0.5*PI*fract(xmouse);\n  //float check = max(0.1,-iTime);\n  //if (abs(cos(check)-mycos(check)) < 1e-6) scale = 1e-6;\n  float x = 0.5*PI*fragCoord.x/iResolution.x;\n  float y = scale * (2.0*fragCoord.y-iResolution.y)/iResolution.y;\n  float cosx = mycos(x), sinx = mysin(x), tanx = sinx/cosx;\n  if (key(CHAR_B)) {\n    for (int i = 0; i < 1000; i++) {\n      x = myatan(mysin(x)/mycos(x),N);\n    }\n  }\n  float t0 = x-myacos(cosx,N);\n  float t1 = x-myasin(sinx,N);\n  float t2 = x-myatan(tanx,N);\n  vec3 col = vec3(comp(y,t0),comp(y,t1),comp(y,t2));\n\n  col = mix(col,vec3(1),hud(fragCoord,xmouse)); \n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// A couple of Chebyshev approximations\n// Defined on domain [-1,1] so do PI/2-f(1/x) outside.\nfloat f0(float x) {\n  assert(x >= -1.0000000 && x <= 1.0000000);\n  float x2 = x*x;\n  float t = -0.038254465;\n  t = x2*t + 0.14498249;\n  t = x2*t + -0.32053329;\n  t = x2*t + 0.99913345;\n  t = x*t;\n  return t;\n}\n\nfloat f(float x) {\n  assert(x >= -1.0000000 && x <= 1.0000000);\n  float x2 = x*x;\n  float t = 0.020419555;\n  t = x2*t + -0.084198465;\n  t = x2*t + 0.17944049;\n  t = x2*t + -0.33010496;\n  t = x2*t + 0.99985132;\n  t = x*t;\n  return t;\n}\n\nfloat myatan0(float x) {\n  bool flip = abs(x) > 1.0;\n  if (flip) x = 1.0/x;\n  x = f(x);\n  if (flip) return 0.5*PI-x;\n  return x;\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\nconst int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n#define SIGN(x) { if ((x) < 0.0) CHAR(MINUS) else CHAR(SPACE) } \n\n// Format x to digits precision and return the character at cindex,\n// or -1 if cindex is out of range.\nint floatchar(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return -1;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int SPACE = 0x20, ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    SIGN(x);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    // Maybe show the bits\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    SIGN(x);\n    CHAR(ZERO);\n  } else {\n    SIGN(x);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // This is a delicate business if we aren't to\n    // lose too much precision\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have a correctly rounded integer representation together\n    // with the correct exponent. The rest is just formatting.\n\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return -1;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3625, 3765, 3795, 3795, 3885], [3886, 3886, 3916, 3916, 3992], [4295, 4295, 4317, 4317, 4476], [4479, 4479, 4501, 4501, 4662], [4664, 4705, 4731, 4813, 4852], [4854, 4854, 4894, 4894, 6707], [6709, 6709, 6738, 6738, 6769], [6771, 6771, 6824, 6824, 7647]], "test": "untested"}
{"id": "cdSGzd", "name": "my shader of the day #2", "author": "jonasfrey", "description": "shader\ndesmos https://www.desmos.com/calculator/b3ovcsjlq4", "tags": ["day"], "likes": 1, "viewed": 122, "published": 3, "date": "1668008597", "time_retrieved": "2024-07-30T16:20:57.422239", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_pixel_cord_norm = fragCoord.xy / iResolution.xy; \n    vec2 o_mouse_cord_norm = iMouse.xy / iResolution.xy; \n    if(iMouse.z == 0.0){\n        o_mouse_cord_norm = vec2(0.5,0.5);\n    }\n    float n_dist_pix_mouse = length(\n        o_pixel_cord_norm - o_mouse_cord_norm\n    );\n    float n_stretch_factor = 1.5;\n    vec2 n_deviation_mouse = (o_mouse_cord_norm-vec2(0.5))*-vec2(n_dist_pix_mouse)*n_stretch_factor;\n    \n    float n_dist_pix_mouse_with_deviation = length(\n        o_pixel_cord_norm - (o_mouse_cord_norm+(n_deviation_mouse))\n    );\n    float n_dist_pix_mouse_modified = pow(n_dist_pix_mouse_with_deviation, 1.0/2.0);\n    float n_dist_pix_mouse_modified_mod_norm = \n        mod(\n            n_dist_pix_mouse_modified\n            ,0.2\n            )/0.2;\n\n    float n_tau = 6.2831;\n    float n = mod(n_dist_pix_mouse_modified_mod_norm+0.5, 1.0);\n    \n    float l = 2.0;\n    float a = pow(n-(1.0/2.0), l) * pow(2.0,l);\n    \n\n    fragColor = vec4(a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1023]], "test": "untested"}
{"id": "dsSGRV", "name": "Pathtracing Global illumination", "author": "kishimisu", "description": "Attempt at making a global illumination scene with pathtracing and indirect light only.\nMove the camera with the mouse!", "tags": ["ray", "gi", "lighting", "marching", "tracing", "indirect", "path", "emission", "emissive"], "likes": 16, "viewed": 764, "published": 3, "date": "1668004723", "time_retrieved": "2024-07-30T16:20:58.254015", "image_code": "/* Second attempt at pathtracing, this time there is \n   no direct light at all, instead I set an emissive \n   property to specific objects that will allow to \n   light up the scene with indirect bounces only.\n   \n   This makes the raymarch faster as there's is no need\n   to march any light to calculate its shadow, but it\n   converges way slower. (this scene is still ok as \n   there are a lot of emissive objects)\n   \n   Setting the number of BOUNCES to 1 show that there is\n   no lighting except for the emissive objects surface.\n   \n   You can reset the samples by moving the camera around\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    float t = texelFetch(iChannel0, ivec2(0.5), 0).r;\n    \n    col /= 1. + float(iFrame) - t;\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BOUNCES 3\n\n#define MAX_ITER 250\n#define EPS 0.001\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define hash(p) fract(sin(p)*43758.5453)\n\nfloat sdBox(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.0;\n}\n\nvec3 cosineDirection(float seed, vec3 nor) {\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nvec4 map(vec3 p, inout float em) {\n    vec3 p0 = p;\n\n    p.z = abs(p.z) - 5.;\n    float ground = p.y + 1.;\n    ground = min(ground, abs(p0.z + 5.7));\n   \n    vec3 pp = p + vec3(2.,0.,0.);\n    pp.x = mod(pp.x+2., 4.)-2.;\n    ground = min(ground, sdBox(pp, vec3(1.,1e5,1.)));\n    \n    vec3 ppp = p;\n    ppp.x = mod(ppp.x-2., 4.)-2.;\n    float box = sdBox(ppp - vec3(0., 9.*step(mod(p0.x/4.-.5, 6.), 3.),0.), vec3(1.));\n    \n    float spheres = length(p + vec3(-4.,0.,3.)) - 1.;\n    box = min(box, spheres);\n    \n    if (box < ground) {\n        em = 1.;\n        vec3 col = (sin(vec3(.02,.04,.06)*p*10.)+1.);\n        return vec4(col,box);\n    } \n    \n    em = 0.;\n    return vec4(1.,1.,1.,ground);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, inout vec3 col, inout float em) {\n    float t = 0.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + t*rd;\n        vec4 d = map(p, em);\n        \n        t += d.a;\n        if (d.a < EPS*t) {\n            col = d.rgb;\n            return p;\n        }\n        if (t > 250.) break;\n    }\n    col = vec3(-1.);\n    return vec3(0.);\n}\n\nvec3 normal(vec3 p) {\n    float em;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0001;\n    return normalize(e.xyy*map(p + e.xyy, em).a + e.yyx*map(p + e.yyx, em).a + \n\t\t\t\t\t e.yxy*map(p + e.yxy, em).a + e.xxx*map(p + e.xxx, em).a);\n}\n\nvec3 render(vec3 ro, vec3 rd, float seed) {\n    vec3 colMask = vec3(1.0);\n    vec3 col     = vec3(0.0);\n    \n    for (int i = 0; i < BOUNCES; i++) {\n        vec3 hitCol;\n        float em = 0.;\n        vec3 p = raymarch(ro, rd, hitCol, em) - rd * .01;\n        \n        if (hitCol == vec3(-1.)) {\n            if (i == 0) return vec3(rd.y+.2)*.0;\n            break;\n        }\n        \n        vec3 n = normal(p);\n        float cseed = seed + 76.2 + 73.1*float(i) + 17.7*iTime;\n        \n        ro = p;\n        rd = cosineDirection(cseed, n);\n        \n        colMask *= hitCol;\n        col     += colMask * em;// * exp(-length(p*.01));\n    }\n    \n    return col;\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.z == 0. ? vec2(0.1, 0.5) : iMouse.xy/iResolution.xy*2.-1.;  \n    ro = vec3(0., 6.5, 5.+abs(m.x)*15.); \n    ro.yz *= rot(m.y*.7);\n    ro.zx *= rot(m.x*2.-1.57);\n        \n    vec3 f = normalize(vec3(0.,1.,0.)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro, rd, color = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    if (iMouse.z > 0. || iFrame == 0) color *= 0.;\n    \n    float seed = hash(dot(fragCoord, vec2(12.9898, 78.233)) + 1113.1*iTime); \n    vec2 of = vec2(hash(seed+13.271), hash(seed+63.216))-0.5;\n    vec2 uv = (2.*(fragCoord+of) - iResolution.xy)/iResolution.y;\n    \n    initRayOriginAndDirection(uv, ro, rd);\n    \n    color += render(ro, rd, seed);\n    \n    if (fragCoord == vec2(0.5, 0.5) && (iMouse.z > 0. || iFrame == 0)) color = vec3(float(iFrame));\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 599, 656, 656, 886]], "test": "untested"}
{"id": "cdfGzs", "name": "Hexagon Fractal Object", "author": "Shane", "description": "A curved hexagon fractal object.", "tags": ["fractal", "hexagon", "curve", "polar"], "likes": 49, "viewed": 471, "published": 3, "date": "1668004265", "time_retrieved": "2024-07-30T16:20:59.188516", "image_code": "/*\n\n    Hexagon Fractal Object\n    ----------------------\n    \n    Fabrice Neyret and MLA (aka Matthew Arcus) have posted a few Gosper\n    curve examples lately, which were much appreciated because it's one\n    of those interesting and important topics that very little code \n    exists for.\n    \n    Anyway, the results very much reminded me a fractal curve example that \n    I'd left unfinished a while back. I'm not sure what the object is \n    technically called, but it's a hexagon fractal curve, so that'll do.\n    It's not a common object, but I've seen it around.\n    \n    I took a polar cell partitioning approach, which was almost trivial\n    for one level, reasonable for the second level, and downright\n    annoying to code for the third due to cell overlap issues. I won't\n    bore you with the details, since a lot of it is in the code, but \n    here's quick explanation:\n    \n    Divide space into six polar cells (sextants, I think), then render \n    S-curves in even cells and reverse S-curves in the remaining cells to \n    produce a flowing hexagonal boundary curve -- Set \"cInd\" to zero and \n    uncomment the define CNSTR_LINES for a visual reference. The S-curves \n    consist of circular arcs around three vertex points contained in each\n    cell. For the next iteration, move to each of those three vertex points, \n    then render the same hexagonal curves around them, then do it again... \n    There are details I'm omitting, but that and the code should give \n    anyone interested in this sort of thing a start.\n    \n    Aesthetically speaking, I like the way the object looks with just two \n    levels. However, that seems a little too easy to construct, so I've \n    opted for the tri-level version. By the way, I'm going to make a more \n    interesting two level example later.\n    \n    \n    \n    Related examples:\n    \n    // The Gosper curves are different, but have a very similar feel.\n    Gosper Closed Curves - mla\n    https://www.shadertoy.com/view/mdXGWl\n    \n    // The original Gosper curve example on here.\n    Gosper curve - FabriceNeyret2\n    https://www.shadertoy.com/view/cdsGRj\n    \n*/\n\n//////////////////\n\n// Fractal iteration depth. I'm only prividing 3 here, due to the \n// iteration count getting out of hand for values like 4, so the\n// numbers are 0, 1, or 2.\nint cInd = 2;\n\n// Display the closed curve... Technically, the dark edges are the closed\n// curve, but this presents it more fully.\n//#define CURVE\n\n// Arc shape. Circular: 0, Hexagon: 1.\n#define SHAPE 0\n\n// Show the construction lines: These make more sense when the variable \n// \"cInd\" (above) is set to zero. The long lines represent the six individual\n// cell borders, and the remaining disecting lines are hexagon boundaries. \n// The object in each cell consists of three curves surround three points.\n//#define CNSTR_LINES\n\n//////////////////\n\n// Arc shape.\nfloat dist(vec2 p){\n  \n    #if SHAPE == 0\n    return length(p);\n    #else\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x);\n    #endif\n\n}\n\n// The construction lines for this cell.\nfloat cnstLines(vec2 p, mat3x2 ctr, vec2 s){\n\n    float ln = 1e5;\n    // Borders.\n    ln = min(ln, distLine(p, vec2(0), ctr[0]*s.x));\n    ln = min(ln, distLine(p, vec2(0), ctr[2]*s.y));\n    // Dividing lines.   \n    ln = min(ln, distLine(p, ctr[1], ctr[0]));\n    ln = min(ln, distLine(p, ctr[2], ctr[1]));\n    \n    return ln;\n}\n\n// Standard polar partitioning.\nvec2 polRot(vec2 p, inout float na, int m){\n\n    const float aN = 6.;\n    float a = atan(p.y, p.x);\n    na = mod(floor(a/6.2831*aN) + float(m - 1), aN);\n    float ia = (na + .5)/aN;\n    p *= rot2(-ia*6.2831);\n    // Flip alternate cells about the center.\n    if(mod(na, 2.)<.001) p.y = -p.y;\n\n    return p;\n}\n\n// Partition lines.\nvec3 prtnLines(vec2 p, mat3x2 ctr){\n\n                \n    // Cell partition lines.\n    float div1 = divLine(p, ctr[1], ctr[0]);\n    float div2 = divLine(p, ctr[2], ctr[1]);  \n     // Cell border.\n    float bR = divLine(p, vec2(0), ctr[2]);\n    //bL = divLine(p, vec2(0), ctr[0]);\n\n    return vec3(div1, -max(div1, div2), max(div2, bR));\n}\n\n/*\nint colID(vec3 c, vec3 oDiv, int index, inout float gCol){\n    c = max(c, oDiv);\n    int colID = c.x<c.y && c.x<c.z? 0 : c.y<c.z? 1 : 2;\n    if(c[colID]<gCol){ gCol = c[colID]; index = colID; }\n    return index;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc*1.5/iResolution.y;\n    \n    // Automatically rotate through all levels.\n    //cInd = int(mod(floor(iTime/4.), 3.));\n    \n    \n    // Scaling and translation.\n    vec2 p = rot2(3.14159/6. - iTime/24.)*sc*uv;\n    \n    // Scene field calculations.\n\n    vec2 op = p;\n    \n    // The distance field for each level.\n    vec3 gDst = vec3(1e5);\n \n    // Polar cell numbers.\n    vec3 na, gNa = vec3(1);    \n  \n    /*\n    // Index and global color value.\n    ivec3 index = ivec3(0);\n    vec3 gCol = vec3(1e5);\n    */\n    \n    // Construction lines and maximum bounds for each level.\n    vec3 ln = vec3(1e5);\n    vec3 gBound = vec3(1e5);\n\n    \n    // I poached this from one of my hexagonal six petal geometry examples. I remember\n    // working it out on paper and liking the fact that it was so weird but concise. \n    // Unfortunately, I didn't mention how I got there. :)\n    const float shF = sqrt(1./7.);\n    // The original radius of the circle that the curve is constucted around.\n    const float r0 = .27;\n    const float hr0 = r0/.8660254; // Hexagon radius.\n    float r20 = hr0/3.; // Small circle radius.\n    #if SHAPE != 0\n    r20 *= .8660254; // Readjusting the radius for hexagonal shapes.\n    #endif\n    // Each polar cell has an S-shaped curve running through it, which is\n    // constructed with three vertex points. There are two on the cell boundaries, \n    // and one in the center -- Check the figure with one iteration for a visual. \n    // The vertex scale changes for greater iteration depth, but not the direction, \n    // so we're going to precalculate the original scale and direction here.\n    mat3x2 ctr0 = mat3x2(rot2(3.14159/6.)*vec2(hr0*2./3., 0), vec2(r0*4./3., 0), \n                         rot2(-3.14159/6.)*vec2(hr0*4./3., 0));\n    \n    // Precalculating the rotation matrices, which get used a few times.\n    // The angle is a hexagonal rotation related number involving ratios...\n    // The tangential angle between thrice the apothem and half the side\n    // length... I worked it out long ago, and no longer care why it works. :D\n    //\n    // Angle between the vertical line and the line running through the \n    // left hexagon vertex to the right vertex on the hexagon above.\n    float rotAng = atan(sqrt(3.)/9.); // Approx: 0.19012.\n    mat2 mRot = rot2(rotAng);\n    mat2 mRotP3 = rot2(rotAng + 3.14159/3.); // Inner curve needs extra rotation.\n\n    for(int aI = 0; aI<3; aI++){\n\n        // The radius of the circle that the curve is constucted around.\n        float r2 = r20; // Small circle radius.\n        p = op; // Original global coordinates.\n       \n        // Split this space into polar cells, and return the local coordinates\n        // and the cell number, which is used later.\n        p = polRot(p, na.x, aI);\n\n\n        mat3x2 ctr = ctr0; // Curve center -- There are three in each segment.\n\n\n        // Partition lines for each of the three vertices in the cell.\n        vec3 oDiv = prtnLines(p, ctr);\n        // Hexagon bounds for this scale. It's used to reverse coloring at the end.\n        float bR = divLine(p, vec2(0), ctr[2]);\n        gBound.x = min(gBound.x, max(-oDiv.y, oDiv.z)); // Previous hexagonal boundary lines.\n\n    \n        // Left, middle, right central point distances.\n        vec3 c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n        \n        /*\n        //////////\n        // Color ID.\n        index.x = colID(c, oDiv, index.x, gCol.x);\n        /////////\n        */\n        \n        c = max(c*vec3(-1, 1, -1), oDiv);\n\n        float crv = min(max(c.x, c.z), c.y);\n        \n        if(crv<gDst.x){ gDst.x = crv; gNa.x = na.x; }\n        \n        // Get the construction lines for this iteration.\n        ln.x = min(ln.x, cnstLines(p, ctr, vec2(2.5, 1.25)));//vec2(3, 1.5)\n        \n\n        ////////////////////////  \n\n        // Move to the new frame of reference, readjust r to the new scale\n        // (the smaller circle, r2), then recalculate the curve.\n        \n        // Move to the new points.\n        mat3x2 p3 = mat3x2(p, p, p) - ctr;\n        //\n        if(mod(na.x, 2.)<.001){\n            // Flip the X-value in every second polar cell.\n            p3[0].x = -p3[0].x; p3[1].x = -p3[1].x; p3[2].x = -p3[2].x;\n        }\n        // Rotate each point to the new orientation. The second point\n        // needs to be rotated an extra 60 degrees.\n        p3[0] *= mRot; p3[1] *= mRotP3; p3[2] *= mRot;\n \n\n        for(int bI = 0; bI<3; bI++){\n        for(int i = 0; i<3; i++){\n\n            ctr = ctr0*shF; \n            r2 = r20*shF;\n            \n            p = p3[i];\n            \n            // Split this space into polar cells, and return the local coordinates\n            // and the cell number, which is used later.\n            p = polRot(p, na.y, bI); // bI - 1\n\n\n            // Partition lines for each of the three vertices in the cell.\n            vec3 oDiv2 = prtnLines(p, ctr);\n            \n       \n            // Applying the previous clipping region to this one.\n            oDiv2 = max(oDiv2, oDiv[i]);\n            // Hexagon bound.\n            gBound.y = min(gBound.y, max(max(-oDiv2.y, oDiv2.z), oDiv[i]));\n\n            // Left, middle, right central point distances.\n            c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n            ////\n            \n            /*\n            //////////\n            // Color ID.\n            index.y = colID(c, oDiv2, index.y, gCol.y);\n            /////////\n            */\n            \n            c = max(c*vec3(-1, 1, -1), oDiv2);\n\n           \n            crv = min(max(c.x, c.z), c.y);\n        \n            if(crv<gDst.y){ gDst.y = crv; gNa.y = na.y; }\n\n           \n            // Get the construction lines for this iteration.\n            ln.y = min(ln.y, cnstLines(p, ctr, vec2(1.25, 1.25))); //vec2(2.5, 1.5)\n            \n          \n            // Move to the new points.\n            mat3x2 q3 = mat3x2(p, p, p) - ctr;\n            //\n            if(mod(na.y, 2.)<.001){\n                // Flip the X-value in every second polar cell.\n                q3[0].x = -q3[0].x; q3[1].x = -q3[1].x; q3[2].x = -q3[2].x;\n            }\n            // Rotate each point to the new orientation. The second point\n            // needs to be rotated an extra 60 degrees.\n            q3[0] *= mRot; q3[1] *= mRotP3; q3[2] *= mRot;\n\n\n            mat3x2 ctr2 = ctr*shF;\n            r2 = r20*shF*shF;\n        \n            // Technically, we should allow for polar cells on either side, but that\n            // would mean three times the total iterations, so since there are no \n            // cell border encroachments here, we'll save a heap of cycles.\n            //for(int cI = 0; cI<3; cI++){\n            for(int j = 0; j<3; j++){\n\n                p = q3[j]; \n                \n                // Split this space into polar cells, and return the local coordinates\n                // and the cell number. Normally, you'd pass in a cell number variable\n                // to the last position, but we only need the middle one.\n                p = polRot(p, na.z, 1); // cI\n                \n                // Partition lines for each of the three vertices in the cell.\n                vec3 oDiv3 = prtnLines(p, ctr2);\n\n                // Applying the previous clipping region to this one.\n                oDiv3 = max(oDiv3, oDiv2[j]);\n\n                // Left, middle, right central point distances.\n                c = vec3(dist(p - ctr2[0]), dist(p - ctr2[1]), dist(p - ctr2[2])) - r2;\n                \n                /*\n                //////////\n                // Color ID.\n                index.z = colID(c, oDiv3, index.z, gCol.z); \n                /////////\n                */\n               \n                c = max(c*vec3(-1, 1, -1), oDiv3);\n                crv = min(max(c.x, c.z), c.y);\n                \n\n                if(crv<gDst.z){ gDst.z = crv; gNa.z = na.z; }\n                ////\n\n                if(oDiv[i]<0.){\n                    // Get the construction lines for this iteration.\n                    ln.z = min(ln.z, cnstLines(p, ctr2, vec2(1.1, 1.1)));\n                }\n\n            } // End \"j\".\n            //} // End \"cI\".\n\n        } // End \"i\".\n        } // End \"bI\". \n\n    } // End \"aI\".   \n\n\n    // RENDERING.\n \n \n    // Background.\n    vec3 bg = vec3(.08);//vec3(1, .15, .3);////vec3(.9, .95, 1)\n    vec3 fg = vec3(.8, 1, .15);//.yyz; //vec3(1, .6, .4); vec3(.8, .9, 1);//\n    fg = mix(fg, fg*vec3(1, .95, .2), uv.y*2. + .5);\n    \n    // The hexagon dot background.\n    float hSc = 4.*float(cInd + 1)*2.; // Scale based on the main pattern level.\n    vec2 hUV = rot2(3.14159/12. + iTime/24.)*uv; // Rotating the coordinates.\n    float bgP = bgPat(hUV*hSc)/hSc;\n    vec3 svBg = bg;\n    \n    bg = mix(bg, svBg*.8, (1. - smoothstep(0., sf*5., bgP)));  \n    bg = mix(bg, svBg*.5, 1. - smoothstep(0., sf, bgP));   \n    bg = mix(bg, svBg*1.1, 1. - smoothstep(0., sf, bgP + .0035));   \n\n    /*\n    // Adding subtle lines to the background.\n    const float lnSc = 60.;\n    vec2 pUV = rot2(3.14159/6. + iTime/24.)*uv; \n    float pat = (abs(fract(pUV.x*lnSc) - .5) - .15)/lnSc;\n    bg = mix(bg, bg*1.2, (1. - smoothstep(0., sf, max(pat, bgP + .003))));    \n    */\n       \n    // Scene color -- Set to the background.\n    vec3 col = bg;\n    \n    // Debug cell indicators.\n    //if(mod(gNa.x, 2.)==0.) col *= vec3(.8);\n    //if(mod(gNa.y, 2.)==0.) col *= vec3(.8);\n    //if(mod(gNa.z, 2.)==0.) col *= vec3(.8);\n    //col *= mod(dot(gNa, vec3(1)), 18.)/17.;\n    //col *= (gNa.x*36. + gNa.y*6. + gNa.z)/215.;\n    \n    // Clamp the level index between zero and two, since they're the only\n    // one's that work.\n    cInd = cInd<0? 0 : cInd>2? 2 : cInd;\n    \n    // Flipping patterns outside the bounds of previous levels... Yeah, it's confusing. :)\n    // With Truchet patterns, there's usually some cell pattern flipping involved, but with \n    // this example, there's level flipping also. \n    if(gBound.x<0.){ gDst.y = -gDst.y; gDst.z = -gDst.z; /* index.y += 1; index.z += 1; */ }\n    if(gBound.y<0.){ gDst.z = -gDst.z; /* index.z += 1; */ }\n     \n    // Giving the pattern some extra thickness.\n    gDst -= .006*float(3 - cInd);\n    \n    #ifdef CURVE\n    gDst = abs(gDst + .006*float(3 - cInd)) - .018*float(3 - cInd);\n    #endif\n\n    /*\n    // Debug indicators.\n    vec3 tCol =  mix(fg, vec3(1), .75);\n    if((index[cInd]&1)==0) tCol = mix(fg, bg, .85);\n    col = mix(col, tCol, 1. - smoothstep(0., sf, gCol[cInd]));\n    fg = mix(fg, tCol, 1. - smoothstep(0., sf, gCol[cInd]));\n    */\n    \n\n    // Edge, or stroke.\n    float dst = gDst[cInd];\n     \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., dst))*.35);\n    col = mix(col, fg*fg*.65, 1. - smoothstep(0., sf,  dst));\n    col = mix(col, fg, 1. - smoothstep(0., sf,  dst + .01*float(3 - cInd) + .002)); \n    \n   \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(dst) - .001)); \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(dst + .01*float(3 - cInd)) - .001)); \n     \n/*\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(gDst[2]) - .0045))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gDst[2]) - .0045)); \n    col = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, abs(gDst[2]) - .001));\n    if(cInd>1){\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gDst[1]) - .0045)); \n        col = mix(col, vec3(1, .85, .7), 1. - smoothstep(0., sf, abs(gDst[1]) - .001));\n    }\n    if(cInd>0){\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gDst[0]) - .0045)); \n        col = mix(col, vec3(1, .9, .8), 1. - smoothstep(0., sf, abs(gDst[0]) - .001)); \n    }\n*/\n    //if(cInd>0) col = mix(col, vec3(0), (1. - smoothstep(0., sf, gBound[cInd - 1]))*.35);\n    \n    #ifdef CNSTR_LINES\n    // Display the cellular construction lines.\n    //ln = max(ln, gDst + .01);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln[cInd] - .006)); \n    col = mix(col, min(fg.zyx + .7, 1.1), 1. - smoothstep(0., sf, ln[cInd] - .0002));\n    #endif\n\n    //col = mix(col, col.xzy, uv.y + .5);\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Dividing line passing through \"a\" and \"b\".\nfloat divLine(vec2 p, vec2 a, vec2 b){\n\n   // I've had to put a hack on the end to get rid of fine lines\n   // at the zero point. That, of course, invalidates the distance portion.\n   // However, in this case, I only need it for a border check, not distances.\n   // I'm not sure why the hack is needed... Some kind of float inaccuracy... \n   // I'll look into it later. :)\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b))*1e8;\n}\n\n//////////////\n// Background pattern code.\n// vec2 to float hash.\nfloat hash21( vec2 p ){ \n\n    return fract(sin(dot(p, vec2(1, 113)))*45758.5453); \n    // Animation, if preferred.\n    //p.x = fract(sin(dot(p, vec2(1, 113)))*45758.5453);\n    //return sin(p.x*6.2831853 + iTime)*.5 + .5; \n}\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers.\n\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. \n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n// A very unimaginative background pattern. :)\nfloat bgPat(vec2 p){\n\n    vec4 h = getHex(p);// + s.yx*iTime/6.\n    \n    float cDist = length(h.xy); // Distance from the center.\n    \n    // Unique random number.\n    float rnd = hash21(h.zw + .1)*.5 + .5;\n    \n    // Random circle size.\n    float d = cDist - min(.5*rnd, .47);\n    //d = abs(d + .2*rnd) - .2*rnd;\n    \n    return d;\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2862, 2876, 2895, 2895, 3023], [3025, 3066, 3110, 3110, 3393], [3395, 3427, 3470, 3470, 3735], [3737, 3757, 3792, 3839, 4095], [4318, 4318, 4374, 4409, 16596]], "test": "untested"}
{"id": "ms23Rc", "name": "flow streamlines - interactive", "author": "FabriceNeyret2", "description": "Mouse drag vortices.\nplay with comments:21-24 for variants.\ninteractive variant of https://shadertoy.com/view/cdfGz7\nanimated version: see https://www.shadertoy.com/view/cdX3z7", "tags": ["flow", "irrotational", "vorticity", "reproduction"], "likes": 36, "viewed": 646, "published": 3, "date": "1667987144", "time_retrieved": "2024-07-30T16:20:59.939509", "image_code": "// interactive variant of https://shadertoy.com/view/cdfGz7\n\nvoid mainImage( out vec4 O, vec2 u )  { \n    O = sqrt(T(u));\n // O = sqrt(1.-exp(-T(u)*vec4(4,2,1,1)));                    // color\n \n // O = vec4( .5+.5*field(u/iResolution.y,iChannel1), 0,1);   // debug\n // field(u/iResolution.y,iChannel1); O=C;                    // debug\n // O*=0.; for (float i=0.; i<Nvort;i++) O += .01/length(u/iResolution.y-texelFetch(iChannel1,ivec2(i,1),0).xy); // debug\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---- compute BBoxs of next curves / manage interactive vortices\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    R = iResolution.xy;\n    vec2 M = iMouse.xy/R.y;\n    if (u-.5==vec2(2)) {     // T(2,2).a = vortex closest to mouse ( if clicked )\n        float l, m = R.x, v;\n        for (float i=0.; i<Nvort; i++ ) {\n            l = length( M - T(vec2(i,1)).xy );\n            if (l < m ) m = l, v = i;\n           // l < m ? m = l, v = i : v;\n            }\n        O.a = iMouse.z>0. ? v : -1.;\n    } \n    \n    if (u.y==1.5) {                                // --- manage vortices\n        O.xy = iFrame<1 ?        H(u.x-.5)         // init vortex\n             : u.x-.5==T(2).a ?  M                 // closest follow mouse ( if clicked )\n         //  :                   T(u).xy;          // startionary\n             :       mod( T(u).xy + (H(u.x)-.5)/1e3, R/R.y); // evolving\n    }\n    if (u.y==.5) {                                 // --- compute BBoxs of next curves\n        float l = 9., p = 1./R.y;\n        vec2  P = H(u.x-iTime), _P=P, m=P; M=P;    // random start point\n\n        for( int t=0; t <len; t++, _P = P )        // follow trajectory\n            P += field(P,iChannel0),\n            m = min(m,P), M = max(M,P);        \n\n        O = vec4(m-p,M+p);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int     len = 20;  // curve length ( i.e. number of samples )\nfloat Nvort = 30., // number of vortices \n      Nline = 80.;\n\nvec2 R; // can't #define because used in field (via H) but Common is stupidely not an include\n\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n#define H(p) ( fract(sin(mod(float(p)*vec2(269.5,183.3),6.283)) *1e4)*R/R.y )\n#define hue(v)( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat L(vec2 p, vec2 a,vec2 b) { // --- draw line  ( squared distance )\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b), \n          c = clamp(h, 0., 1.);     \n    return h==c ? dot(p -= b*h ,p) : 1e5; \n}\n\nvec4 C = vec4(0);  // returns color field\n\nvec2 field(vec2 U, sampler2D ch) {  // --- velocity field induced by vortices ( Biot & Savart )\n    vec2 V = vec2(0), P;\n    float w;\n    for( float i=0.; i < Nvort; i++ ) { // N random vortices ( same strength )\n        P = texelFetch(ch,ivec2(i,1),0).xy - U; // don't use ',' or bug on Windows !\n        w = min( 1., .001 / pow(length(P),3.) ), \n        C += hue(i/Nvort)    * w ,        // colored influence\n        V += vec2(-P.y,P.x)  * w          // velocity influence\n                 // * sign(H(i+.3).y-.5)  // random sign\n                 // * (2.*H(i+.3).y-1.)   // random sign & strength\n                 // * H(i+.3).y*2.        // random strength\n                          // * min(100.,.2/dot(P,P) )\n                ;}\n    return V*.1;\n}", "buffer_b_code": "// --- draw only curves which BBox covers the pixel\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    R = iResolution.xy;\n    vec2 U = u / R.y, P, _P, b;\n    O =  .98*T(u);                         // cumulates previous draw\n   \n    for( float i=0.,l; i < Nline; i++ ) {  // draw N streamlines per frame\n        vec4 B = texelFetch(iChannel1,ivec2(i,0),0); // curve bbox\n        b = step(B.xy,U)*step(U,B.zw);\n     // if (b.x*b.y == 0.) continue;       // ← this form crashes Firefox !\n        if (b.x*b.y == 1.)\n        {               // pixel not in BBox: skip draw\n            _P = P = H(i+.5-iTime);             // random start point\n            l = 9.;\n            for( int t=0; t <len; t++, _P = P ) // follow trajectory\n                P += field(P,iChannel1),\n                l = min( l, L(U,_P,P) );\n        O += .2*max(0., 1.-R.y*sqrt(l))         // draw the curve\n             * ( .4 + C*.02 );                  // color field\n       }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 100, 100, 460]], "test": "untested"}
{"id": "md2Gzc", "name": "Simple Night Sky", "author": "Yahor10", "description": "Simple circle particles ", "tags": ["noise", "random", "sky"], "likes": 1, "viewed": 242, "published": 3, "date": "1667985865", "time_retrieved": "2024-07-30T16:21:00.860048", "image_code": "float Noise2d( in vec2 x )// https://www.shadertoy.com/view/Md2SR3 cop \n{\n    float xhash = cos( x.x * 21.0 );\n    float yhash = cos( x.y * 3.0 );\n    return fract( 245.92653 * ( xhash + yhash ) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 iViewportSize = vec2(iResolution.xy);\n    vec2 viewCoords = vec2(gl_FragCoord.x, iViewportSize.y - gl_FragCoord.y);\n    float iRadius = 1.5;\n    \n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 iCenter = (vec2(734.0))  ;      \n    float r = Noise2d(iCenter - viewCoords);\n    float d = length(r * iViewportSize) - iRadius * abs(cos(iTime)*.750) + 2.0 * abs(sin(iTime)*0.005);\n    float t = smoothstep(.0,iRadius,d) ;\n    vec4 color = vec4(.5,1.0,.4,1.0);\n    fragColor = vec4(color.rgb * 1.0-(t),color.a * 1.0-(t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2Gzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 73, 73, 199], [200, 200, 257, 307, 843]], "test": "untested"}
{"id": "ds2Gz3", "name": "WCOM AB", "author": "mrange", "description": "WCOM AB logo\nThe logo is a trademark of WCOM AB.", "tags": ["wcom"], "likes": 3, "viewed": 181, "published": 3, "date": "1667977393", "time_retrieved": "2024-07-30T16:21:01.634975", "image_code": "// CC0: WCOM AB Logo\n//  The logo is a trademark of WCOM AB.\n\n// #define LOGO_TO_RIGHT\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat shape(vec2 p) {\n  return hexagon(p.yx, 0.4)-0.075;\n}\n\nfloat cellHeight(float h) {\n  return 0.05*2.0*(-h);\n}\n\nvec3 cell(vec2 p, float h) {\n  float hd = shape(p);\n\n  const float he = 0.0075*2.0;\n  float aa = he;\n  float hh = -he*smoothstep(aa, -aa, hd);\n  \n  return vec3(hd, hh, cellHeight(h));\n}\n\nfloat height(vec2 p, float h) {\n  return cell(p, h).y;\n}\n\nvec3 normal(vec2 p, float h) {\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy, h) - height(p - e.xy, h);\n  n.y = height(p + e.yx, h) - height(p - e.yx, h);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec3 planeColor(vec3 ro, vec3 rd, vec3 lp, vec3 pp, vec3 pnor, vec3 bcol, vec3 pcol) {\n  vec3  ld = normalize(lp-pp);\n  float dif  = pow(max(dot(ld, pnor), 0.0), 1.0);\n  vec3 col = pcol;\n  col = mix(bcol, col, dif);\n  return col;\n}\n\nconst mat2 rots[6] = mat2[](\n    ROT(0.0*TAU/6.0)\n  , ROT(1.0*TAU/6.0)\n  , ROT(2.0*TAU/6.0)\n  , ROT(3.0*TAU/6.0)\n  , ROT(4.0*TAU/6.0)\n  , ROT(5.0*TAU/6.0)\n); \n\nconst vec2 off = vec2(1.0, 0.0);\n\nconst vec2 offs[6] = vec2[](\n    off*rots[0]\n  , off*rots[1]\n  , off*rots[2]\n  , off*rots[3]\n  , off*rots[4]\n  , off*rots[5]\n  );\n  \nfloat cutSlice(vec2 p, vec2 off) {\n  // A bit like this but unbounded\n  // https://www.shadertoy.com/view/MlycD3\n  p.x = abs(p.x);\n  off.x *= 0.5; \n\n  vec2 nn = normalize(vec2(off));\n  vec2 n  = vec2(nn.y, -nn.x);\n\n  float d0 = length(p-off);\n  float d1 = -(p.y-off.y);\n  float d2 = dot(n, p);\n  \n  bool b = p.x > off.x && (dot(nn, p)-dot(nn, off)) < 0.0;\n  \n  return b ? d0 : max(d1, d2);\n}\n\nfloat hexSlice(vec2 p, int n) {\n  n = 6-n;\n  n = n%6;\n  p *= rots[n];\n  p = p.yx;\n  const vec2 dim  = vec2((0.5)*2.0/sqrt(3.0), (0.5));\n  return cutSlice(p, dim);\n}\n\nvec3 backdrop(vec2 p) {\n  const float z = 0.327;\n  float aa = 2.0/(z*RESOLUTION.y);\n  \n  p.yx = p;\n  \n  vec3 lp = vec3(3.0, 0.0, 1.0);\n  \n  p -= vec2(0.195, 0.);\n  p /= z;\n\n  float toff = 0.2*TIME;\n  p.x += toff;\n  lp.x += toff;\n\n  vec2 hp  = p;\n  vec2 hn  = hextile(hp);\n  float hh = hash(hn);\n  vec3 c   = cell(hp, hh);\n  float cd = c.x;\n  float ch = c.z;  \n\n  vec3 fpp = vec3(p, ch);\n  vec3 bpp = vec3(p, 0.0);\n\n  vec3 ro = vec3(0.0, 0.0, 1.0);\n  vec3 rd = normalize(fpp-ro);\n\n  vec3  bnor = vec3(0.0, 0.0, 1.0);\n  vec3  bdif = lp-bpp;\n  float bl2  = dot(bdif, bdif);\n\n  vec3  fnor = normal(hp, hh);\n  vec3  fld  = normalize(lp-fpp); \n\n  float sf = 0.0;\n\n  for (int i = 0; i < 6; ++i) {\n    vec2  ioff= offs[i];\n    vec2  ip  = p+ioff;\n    vec2  ihn = hextile(ip);\n    float ihh = hash(ihn);\n    float ich = cellHeight(ihh);\n    float iii = (ich-ch)/fld.z;\n    vec3  ipp = vec3(hp, ch)+iii*fld;\n    \n    float hsd = hexSlice(ipp.xy, i);\n    if (ich > ch) {\n      sf += exp(-20.0*tanh_approx(1.0/(10.0*iii))*max(hsd+0., 0.0));\n    }\n  }\n\n  const float sat = 0.23;\n  vec3 bpcol = planeColor(ro, rd, lp, bpp, bnor, vec3(0.0), HSV2RGB(vec3(240.0/36.0, sat, 0.14)));\n  vec3 fpcol = planeColor(ro, rd, lp, fpp, fnor, bpcol, HSV2RGB(vec3(240.0/36.0, sat, 0.19)));\n\n  vec3 col = bpcol;\n  col = mix(col, fpcol, smoothstep(aa, -aa, cd));\n  col *= 1.0-tanh_approx(sf);\n\n  float fo = exp(-0.025*max(bl2-0., 0.0));\n  col *= fo;\n  col = mix(bpcol, col, fo);\n\n  return col;\n}\n\nvec3 wcom(vec3 col, vec2 p) {\n  const float sc = 0.25;\n#if defined(LOGO_TO_RIGHT)  \n  p.x -= (RESOLUTION.x/RESOLUTION.y - 2.0*sc);\n#endif\n  vec2 op = p;\n  float aa = 2.0/RESOLUTION.y;\n  p -= 0.5*1.5*sc;\n\n  vec2 n = mod2(p, vec2(1.5*sc));\n  const float bw = 0.1;\n  float dh = box(p, vec2((0.5-bw)*sc))-bw*sc;\n  if (abs(n.x+0.5) > 1.0||abs(n.y+0.5) > 2.0) {\n    dh = box(op, sc*vec2(1.25, 2.75));\n  }\n\n  vec3 gcol0 = hsv2rgb(vec3(0.6, 0.85, 0.0025)); \n\n  float v = mod(n.x+n.y, 2.0) == 0.0 ? 0.0 : 1.0;\n  vec3 bcol = hsv2rgb(vec3(0.62, 0.925, v));\n  col = mix(col, bcol, smoothstep(aa, -aa, dh));\n\n  col += gcol0/(max(abs(dh)-0.001, 0.0)+0.0001);\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 col = backdrop(p);\n\n  col = wcom(col, p);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2Gz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 366, 385, 385, 472], [474, 581, 607, 607, 791], [793, 879, 915, 915, 1009], [1011, 1071, 1099, 1165, 1241], [1395, 1395, 1417, 1417, 1563], [1859, 1919, 1940, 1940, 2010], [2012, 2113, 2141, 2240, 2567], [2569, 2687, 2719, 2719, 2899], [2901, 3019, 3046, 3046, 3122], [3124, 3124, 3145, 3145, 3182], [3184, 3184, 3211, 3211, 3237], [3239, 3239, 3267, 3267, 3424], [3426, 3426, 3457, 3457, 3482], [3484, 3484, 3514, 3514, 3712], [3714, 3714, 3800, 3800, 3945], [4274, 4274, 4308, 4386, 4665], [4667, 4667, 4698, 4698, 4831], [4833, 4833, 4856, 4856, 6296], [6298, 6298, 6327, 6327, 6958], [6960, 6960, 6981, 6981, 7047], [7049, 7049, 7106, 7106, 7304]], "test": "untested"}
{"id": "ddj3R3", "name": "dirty wigglers", "author": "lomateron", "description": "click to paint\nin bufferA change line19 to 7U for clean wigglers", "tags": ["automata"], "likes": 6, "viewed": 201, "published": 3, "date": "1667972081", "time_retrieved": "2024-07-30T16:21:02.413893", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int m = tz+1;\n    int i = iFrame%m;\n    //if(i!=0){discard;}  //comment out to see more frames but more flicker too\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0);\n    uint n = (1U<<m)-1U;\n    uint b = floatBitsToUint(a.x)&n;\n    uint c = ((b>>i)|(b<<(m-i)))&n;\n    //fragColor = cos(float(c)*88.8888+vec4(3,1,2,4))*.5+.5;\n    if(tz==1){fragColor = vec4(float(c)/float(n));}\n    if(tz==2){fragColor = vec4((c>>0)&1U,(c>>1)&1U,(c>>2)&1U,0);}\n    if(tz> 2){fragColor = cos(float(c)/float(n)*4.4+vec4(2,3,4,5)+.8);}\n    //fragColor = vec4(b&1U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rz 120.  //size of each world in pixels\n#define sz  3.   //size of kernel across space\n#define tz  2    //size of kernel across time          must be <= 32\n#define nz  .05  //size of mouse click noise ball\n\n//exploration works when texture is 1920*1080\n//if you dont have 1920*1080 texture\n//then you must change rz to textureWidth/16\n\n//1920*1080 and rz=120 will show 16*9 worlds simulations\n//becos 1920/rz*1080/rz = 16*9\n//mouse click on each world will show the next 16*8 worlds\n//go to BufferA line24, change 0U to 1U to keep exploring next 16*8*16*8 worlds\n//there are 2^(sz*sz*tz+1) different worlds to explore\n//arktually 2^(sz*sz*tz  ) becous half are worlds inverted in color\n\n//next will be 1D worlds explorer", "buffer_a_code": "uint read(vec2 u, vec2 m)\n{\n    vec2 o = mod(u+m,iResolution.xy);\n         u = floor(u/iResolution.xy)*iResolution.xy+o;\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(u),0).x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float ck = -floor((sz-1.)*.5);    //center the kernel\n    float ev = float(mod(sz,2.)==0.); //move and resize kernel when sz = even\n    uint o = 0U;                      //sum of all bits\n                          float n = (float(iFrame&1)-1.)*ev;\n    for(int   t=0 ; t<tz; ++t){ float m = n*(1.-float(t&1)); float s2 = sz-float(t&1)*ev; \n    for(float i=0.; i<s2; ++i){\n    for(float j=0.; j<s2; ++j){ uint r = read(u,vec2(i,j)+ck+m);\n                                o += (r>>t)&1U;\n    }}}                         o += (read(u,vec2(0))>>2)&1U;\n    \n    uint a = +6U          //change to 7U for clean wiglers\n             +16U*8U*8U;\n    o = (read(u,vec2(0,0))<<1U) | ((a>>(o&31U))&1U);\n    \n    vec2 v = (u        *2.-iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y-v;\n    if(iFrame==0)\n    {\n        float r = fract(cos(dot(u,vec2(1.76543,iTime+9.)))*5467.5678)*float(1<<tz);\n              r*= step(dot(v,v),nz);\n        o = uint(r+1.);\n    }\n    if(iMouse.z>.5 && dot(m,m)<.005)\n    {\n        float r = fract(cos(dot(u,vec2(1.76543,iTime+9.)))*5467.5678)*float(1<<tz);\n        o = uint(r);\n    }\n    fragColor = vec4(uintBitsToFloat(o));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddj3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 613]], "test": "untested"}
{"id": "msj3R3", "name": "Glowing fractal tunnel", "author": "jarble", "description": "Another bizarre fractal structure.\nUse the mouse to look around.", "tags": ["3d", "fractal"], "likes": 5, "viewed": 286, "published": 3, "date": "1667972063", "time_retrieved": "2024-07-30T16:21:03.254645", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 stars(vec3 uv)\n{\n    uv = -uv.yzx;\n    vec3 col = vec3(0.);\n    \n    for(int k = 0; k < 6; k++){ \n        uv =\n            //min(uv*vec3(uv.y+uv.x+.5,uv.z+uv.y+.5,uv.x+uv.z)*3.,abs(fract(vec3(uv.y+uv.x+.5,uv.z+uv.y+.5,uv.x+uv.z))-.5))\n            min(uv*vec3(uv.y+uv.x,uv.z+uv.y+1.,uv.x+uv.z)*2.,abs(fract(vec3(uv.y+uv.x+1.,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n            //min(uv/2.*vec3(sqrt(uv.x*uv.y),sqrt(uv.z*uv.y),uv.x+uv.z)*4.,abs(fract(vec3(uv.y+uv.x,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n            //min(uv*vec3(uv.y+uv.x+.125,uv.z+uv.y+.75,uv.x+uv.z)*4.,abs(fract(vec3(uv.y+uv.x+1.,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n            //min(uv*vec3(uv.y*4.,uv.z,uv.x+uv.z)*4.,abs(fract(vec3(uv.y+uv.x+1.,uv.z+uv.y,uv.x+uv.z)+uv)-.5))\n        ;\n        col =\n            vec3(col.yz,uv.x-uv.y).yzx\n            //vec3(col.yz,uv.x).yzx\n            //vec3(col.yz,sqrt(uv.x*uv.y)).yzx\n        ;\n    }\n    \n    return\n        col.yzx\n        //col - uv;\n    ;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(t,9.,7.),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = stars(p/16.);\n        float sd1 = col.z-.12;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "sound_code": "#define fmod0(x,y) mod(floor(x),y)\n#define fmod1(x,y) mod(floor((x)/s1+floor(t*s1)/s1),y)\n#define fmod(x,y) mod(floor(x+floor(t/s1)/s1),y)\nvec2 mainSound(int samp, float t){\n  float s1 =\n      8.,\n  m1 =\n      fmod(t*s1,s1),\n      //fmod(mod(t*s1,floor(t*s1/4.)),s1),\n      //fmod(floor(t*s1)+floor(t*s1/2.)+floor(t*s1/4.),s1),\n      //fmod(t*s1-floor(t),s1),\n  z1 =\n      (1.+fmod(t,2.))\n      //(1.+fmod(floor(t/4.)*4.+floor(t/3.)*3.,2.))\n  ;\n  t /=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n  ;\n  float m3 =\n      fmod((t)/(m1+.5),s1)\n  ;\n  t *=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n  ;\n\n  float a= ((1.-sqrt(fract(t*s1))))*.2,\n\n  nb = pow(2.,(m3+z1)/5.+7.);\n\n  return vec2(fract(t*nb*.998)\n   ,fract(t*nb))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msj3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 275, 275, 1202], [1204, 1204, 1245, 1245, 1784]], "test": "untested"}
{"id": "XsBGDt", "name": "Machine Elf", "author": "jimbo00000", "description": "Suzanne the Blender monkey on salvia. They're making gifts for you!", "tags": ["2d", "fractal", "julia", "pareidolia", "suzanne"], "likes": 15, "viewed": 275, "published": 3, "date": "1667962414", "time_retrieved": "2024-07-30T16:21:04.090410", "image_code": "// Adapted from\n// https://www.shadertoy.com/view/XdsGDr\n\n#define ITER 120\n\nvec2 mir( vec2 pix, float zoom)\n{\n\tvec2 z = zoom * pix;    \n    z.x = -abs(z.x) + .3;\n    return z;\n}\n\n#define S smoothstep\nvec3 colMap( float x )\n{\n\tvec3 col = vec3(0.);\n\tcol.x = S(.0, .3, x) - .75*S(.2,.9,x);\n\tcol.y = S(.0, .4, x) - .75*S(.3,.8,x);\n\tcol.z = S(.7, .8, x) - .85*S(.8,.9,x);\n\n\treturn col * vec3(1.6, .8, .8) * vec3(1., 1.15, 1.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n        tc = ( fragCoord - .5*R ) / R.y;\n        \n\t//vec2 m = iMouse.xy / R.xy;\n\tfloat t = iTime * .5;\n    \n    float zoom = 1.5 + 1.*(.5*cos(.15*t)+.5);\n    float freq = 4.;\n\n    // Animate Julia params\n    vec2 c = vec2(-0.35, 0.7);\n    c += vec2(\n        .1 + .016*cos(t*freq),\n        -.005+-(.0123*sin(t*freq)*sin(t*freq*1.1))\n        );\n\n\tvec2 z = mir(tc, zoom);\n    vec2 z0 = z;\n    vec2 eye = vec2(-.31, .41);\n\n    float m = clamp(0.,1., length(z-eye)*3.);\n    c = mix(c, c*.94, 1.-m*m*m);\n\n    // Julia\n\tint i = 0;\n\tfor(; i<ITER; i++)\n    {\n\t\tfloat x = (z.x * z.x - z.y * z.y) + c.x;\n\t\tfloat y = (z.y * z.x + z.x * z.y) + c.y;\n\n\t\tif((x * x + y * y) > 4.0)\n        {\n\t\t\tbreak;\n\t\t}\n\t\tz.x = x;\n\t\tz.y = y;\n\t}\n\t\n    float q = 40. + 10.*sin(.1*t);\n    float x = fract(float(i) / q);\n\tif(i == ITER)\n    {\n        //iris\n        x = sin(100.*length(z0-eye) - 20.*t);\n\t}\n\tvec3 col = colMap(x);\n\n\tfragColor.xyz = col;\n}\n", "image_inputs": [], "sound_code": "#define PI 3.1415927\n\n// https://kaegi.nl/werner/userfiles/downloads/vosim-system.pdf\nfloat vosim(in float time, in float freq, in float n)\n{\n    float m = 3.;\n    float ph = mod(freq*time, 1.);\n    float fund = sin(n*PI*ph);\n    fund *= 1.-ph;\n\n    return fund * fund;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float vol = 1.;\n        \n    float n = 6.;\n    // modulate n\n    float n1 = n + 1.*sin(time);\n    float n2 = n + 1.*sin(1.1*time);\n    \n    // Chant\n    float m = 3.;\n    float chant = 0.;\n    float low = 55.;\n    chant += vosim(time, low, n1);\n    chant -= vosim(time, low*3.0/2., n2);\n    chant -= vosim(time, low*1.006, n2);\n    chant += vosim(time, low*3.0055/2., n1);\n    chant *= .06125;\n    \n    float sig = 0.;\n    sig += .5*chant;\n    \n    // Elf says \"ohhh woooowwwww\"\n    float ooo = 0.;\n    float n3 = n + 4.*cos(4.*time+5.);\n\n    // modulate freq\n    float x = 4.*time + 95.;\n    float pmod = sin(x) + sin(1.3*x) + sin(1.7*x);\n    time += .2*.13*pmod;\n    float freq = 180.;\n\n    ooo += vosim(time, freq, n3);\n    \n    x = .5*time;\n    float vmod = sin(1.23*x) + sin(1.61*x) + sin(2.1*x);\n    //vmod = sin(1.23*x);\n    vmod = pow(clamp(abs(sin(x))-.4, 0.,1.),.12);\n    \n    float t = time * .5;\n    float near = .125*(.5*cos(.15*t)+.5);\n    sig += (.25-near)*vmod*vmod * ooo;\n    \n    return vol * vec2(sig);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 109, 109, 177], [200, 200, 224, 224, 424], [426, 426, 483, 483, 1431]], "test": "untested"}
{"id": "cdj3RG", "name": "Permanganate Absorption", "author": "oneshade", "description": "Attempting to recreate the beautiful color of permanganate (MnO4-) in solution using questionable data I got from a quick google search.", "tags": ["rendering", "chemistry", "beerlambert", "permanganate"], "likes": 17, "viewed": 261, "published": 3, "date": "1667961191", "time_retrieved": "2024-07-30T16:21:04.926176", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Screen UVs and mouse\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.6, -0.1);\n\n    // Background\n    float[33] specRx = float[33](0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.09375, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\n    // Camera ray\n    Ray ray = Ray(vec3(0.0, 0.0, 14.0), normalize(vec3(uv, -1.0)));\n\n    mat2 vert = Rotate2D(mouse.y);\n    ray.pos.yz *= vert;\n    ray.dir.yz *= vert;\n\n    mat2 hori = Rotate2D(mouse.x);\n    ray.pos.xz *= hori;\n    ray.dir.xz *= hori;\n\n    // Light\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    float[33] lightColor = float[33](1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n    // Render\n    float[33] planeColor = float[33](0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125);\n    float tPlane = (-3.71 - ray.pos.y) / ray.dir.y;\n    if (tPlane > 0.0) {\n        for (int i=0; i < 33; i++) {\n            specRx[i] = planeColor[i] * lightColor[i] * lightDir.y;\n        }\n    }\n\n    vec2 tCube = cubeIsect(ray, vec3(2.65, 3.7, 2.65));\n    if (tCube.x > 0.0 && (tPlane < 0.0 ? true : tPlane > tCube.x)) {\n        float b = tCube.y - tCube.x; // Light path length (cm)\n        float C = 0.005;//0.0003164; // Concentration (M)\n        for (int i=0; i < 33; i++) {\n            float lambda = 380.0 + 10.0 * float(i);\n            // 4835.43 ~ 2.625 * ln(10) / (1.25cm * 0.001M)\n            float A = gaussian(lambda, 4835.43, 0.000255, 525.0) * b * C; // Very rough approximation of the absorbance spectrum\n            specRx[i] *= exp(-A);\n        }\n    }\n\n    fragColor = vec4(pow(spectrum2rgb(specRx), vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "// Discrete spectrum from 380nm to 700nm in 10nm increments\nconst vec3[33] specBasis = vec3[33](\n    vec3(0.0000548384, 0.0000008374, 0.0061998149),\n    vec3(0.0006127200, 0.0000042329, 0.0226023738),\n    vec3(0.0042446966, 0.0000192909, 0.0673963214),\n    vec3(0.0182321761, 0.0000792635, 0.1643709785),\n    vec3(0.0485554067, 0.0002936307, 0.3278845083),\n    vec3(0.0801759147, 0.0009807018, 0.5349626533),\n    vec3(0.0820838093, 0.0029531092, 0.7138925334),\n    vec3(0.0521048970, 0.0080173185, 0.7792001443),\n    vec3(0.0205074548, 0.0196239245, 0.6956199327),\n    vec3(0.0050061561, 0.0433061604, 0.5079276101),\n    vec3(0.0007690801, 0.0861629558, 0.3033461120),\n    vec3(0.0001369679, 0.1545605267, 0.1481773604),\n    vec3(0.0003212008, 0.2499675772, 0.0592014146),\n    vec3(0.0013261318, 0.3644818144, 0.0193459083),\n    vec3(0.0048227433, 0.4791540236, 0.0051707432),\n    vec3(0.0152553543, 0.5679126026, 0.0011303778),\n    vec3(0.0419684800, 0.6068690157, 0.0002021162),\n    vec3(0.1004145564, 0.5846763336, 0.0000295587),\n    vec3(0.2089501070, 0.5078590041, 0.0000035357),\n    vec3(0.3781473071, 0.3977204208, 0.0000003459),\n    vec3(0.5951849164, 0.2808146205, 0.0000000277),\n    vec3(0.8147330072, 0.1787592946, 0.0000000018),\n    vec3(0.9699541294, 0.1025946327, 0.0000000001),\n    vec3(1.0042910022, 0.0530869459, 0.0000000000),\n    vec3(0.9043581098, 0.0247661177, 0.0000000000),\n    vec3(0.7082617587, 0.0104168214, 0.0000000000),\n    vec3(0.4824137079, 0.0039502046, 0.0000000000),\n    vec3(0.2857708829, 0.0013505512, 0.0000000000),\n    vec3(0.1472274546, 0.0004163031, 0.0000000000),\n    vec3(0.0659678183, 0.0001156952, 0.0000000000),\n    vec3(0.0257067947, 0.0000289887, 0.0000000000),\n    vec3(0.0087123683, 0.0000065486, 0.0000000000),\n    vec3(0.0025680118, 0.0000013338, 0.0000000000)\n);\n\n// Structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\n// Utilities\nfloat gaussian(in float x, in float a, in float b, in float c) {\n    x -= c;\n    return a * exp(-b * x * x);\n}\n\nvec3 wavelength2rgb(in float lambda) {\n    float r = gaussian(lambda, 0.086169, 0.002390, 435.492) + gaussian(lambda, 1.00871, 0.000698, 607.492);\n    float g = gaussian(lambda, 0.607489, 0.000518, 541.404);\n    float b = gaussian(lambda, 0.779526, 0.001005, 449.355);\n    return vec3(r, g, b);\n}\n\nvec3 spectrum2rgb(in float[33] spectrum) {\n    vec3 rgb = vec3(0.0);\n    for (int i=0; i < 33; i++) {\n        rgb += spectrum[i] * specBasis[i];\n    }\n\n    return rgb;\n}\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, -si, si, co);\n}\n\nvec2 cubeIsect(in Ray ray, in vec3 size)  {\n    vec3 n = ray.pos / ray.dir, k = size / abs(ray.dir);\n    vec3 t1 = -k - n, t2 =  k - n;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\t\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n\n    return vec2(tN, tF);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdj3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cd23z3", "name": "smoke on the Jean-Claude", "author": "sympou", "description": "Jean-Claude is too hot for this world !!\n", "tags": ["smoke"], "likes": 29, "viewed": 413, "published": 3, "date": "1667957811", "time_retrieved": "2024-07-30T16:21:05.701104", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    fragColor = texture( iChannel1, fragCoord/iResolution.xy );\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define smokeDiffusion  2.5\n#define smokeDecay      0.975\n\n// \"lum\" gives the visible intensity of light per given color\n#define lum(pix) dot( pix, vec3(0.2126,0.7152,0.0722) )\n\nfloat texLum (in vec2 uv) {\n    return lum(texture( iChannel1, uv ).rgb);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixSize = 1./iResolution.xy;\n    \n    // Matte compositing :\n    // https://www.shadertoy.com/view/XsfGzn\n    vec4 fg = texture( iChannel0, uv);\n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n\n    float ll = length( fg );\n    fg.g = min( fg.g, maxrb*0.8 );\n    fg = ll*normalize(fg);\n        \n    //the smoke goes up (a little bit)\n    uv.y -= 0.001;\n    \n    // \"bg\" is the image of the smoke behind jean-claude.\n    // we expand the smoke with a kind of hacky solution (not a fluid simulation !)\n\n    float p1 = texLum( uv - vec2(pixSize.x,0.) );\n    float p2 = texLum( uv + vec2(pixSize.x,0.) );\n    float p3 = texLum( uv - vec2(0.,pixSize.y) );\n    float p4 = texLum( uv + vec2(0.,pixSize.y) );\n\n    vec2 gradient = vec2(p1-p2,p3-p4); \n    float len = length(gradient);\n    gradient = ( len > 0.0 ) ? gradient/len*smokeDiffusion : vec2(0.);\n\n    vec4 bg = texture( iChannel1, uv - pixSize*gradient )*smokeDecay;\n    \n    //a greyscale filter for the smoke\n    bg = vec4( vec3(lum(bg.rgb)), 1. );\n\n    fragColor = fg*(1.-k) + bg*k;\n\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd23z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]], "test": "untested"}
{"id": "Ds23z3", "name": "another perspective", "author": "lomateron", "description": "looks like this perspective has lots of potential\nlike the previously posted binary simulations\nbut now smooth simulations of many dimensions\nsimulations that depend on the shape of the X dimension vector field", "tags": ["wave"], "likes": 6, "viewed": 193, "published": 3, "date": "1667956581", "time_retrieved": "2024-07-30T16:21:06.526896", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u    = fragCoord/iResolution.xy;\n         u.x *= 128./iResolution.x;\n    vec4 C = texture(iChannel0, u);\n    vec4 b = u.y*vec4(8.)-vec4(1.,3.,5.,7.);\n\n    fragColor = vec4(+float(b.x<C.x && b.x>0.)\n                     +float(b.x>C.x && b.x<0.)\n                     +float(b.y<C.y && b.y>0.)\n                     +float(b.y>C.y && b.y<0.)\n                     +float(b.z<C.z && b.z>0.)\n                     +float(b.z>C.z && b.z<0.)\n                     +float(b.w<C.w && b.w>0.)\n                     +float(b.w>C.w && b.w<0.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float pi = 3.14159265359;\nvec2 vField(vec2 p, float x)\n{\n    //vector field moves input p\n    //vector field in 2D space with 2D vectors\n    //vector field rotates around center\n    //vector field rotation center moves depending on x\n    p.x -= x;\n    vec2 v = p.yx*vec2(-1,1);//calculate vector field\n    p += v*.25;\n    p.x += x;\n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 m = vec2(128.,iResolution.y);\n    vec4 C = texture(iChannel0, mod(u+vec2(0,0),m)/iResolution.xy);//center pixel\n    vec4 R = texture(iChannel0, mod(u+vec2(1,0),m)/iResolution.xy);//right  pixel\n    vec4 L = texture(iChannel0, mod(u-vec2(1,0),m)/iResolution.xy);//left   pixel\n  //C.xy = vField(C.xy                        , L.x*.5+R.x*.5);    //high frequencies get big fast\n    C.xy = vField(C.xy*.97+L.xy*.015+R.xy*.015, L.x*.5+R.x*.5);    //blur damps high frequencies\n    if(iFrame==0) C = exp(-pow((u.x-64.)*.2,2.))*vec4(1,0,0,0);\n    fragColor = C;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds23z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 597]], "test": "untested"}
{"id": "dsB3RK", "name": "Cube Field / DOF experiment", "author": "byt3_m3chanic", "description": "An assortment of tricks picked up from @Nusan via twitter/shadertoy - mult-tap map @Shane\n\nleft = bayer | right = blue noise\nfilter = linear", "tags": ["raymarching", "time", "cubes", "states"], "likes": 20, "viewed": 389, "published": 3, "date": "1667955849", "time_retrieved": "2024-07-30T16:21:07.337728", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    Cube Field / DOF experiment\n    11/08/22 | byt3_m3chanic\n\n    Trying to use a bayer texture and some tricks picked up from @Nusan to\n    do this DOF thing..more experiment than accuracy\n\n    left = bayer | right = blue noise\n    @Xor suggestion for blue noise..\n*/\n\n\n#define R     iResolution\n#define T     iTime\n#define M     iMouse\n#define PI    3.14159265358\n#define PI2   6.28318530718\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.34,35.34)))*483434.);}\nvec2 hash22(vec2 uv) {return fract(sin(uv*425.215+uv.yx*714.388)*vec2(522.877));}\n\nfloat box(vec3 p, vec3 a){\n    vec3 q = abs(p)-a;\n    return length(max(q,0.))-min(max(q.x,max(q.z,q.y)),0.);\n}\n\nconst float scale = 2.;\nconst vec2 s = vec2(scale*2.);\n\nfloat pf=0.,spf=0.,gpf=0.,hsh=0.,gsh=0.,glow=0.,sglow=0.;\nvec3 hit=vec3(0),hp=vec3(0);\n\nvec2 map(vec3 q3) {\n    vec2 res=vec2(1e5,0.);\n\n    float yd=floor((q3.y+3.)/6.);\n    q3.y=mod(q3.y+3.,6.)-3.;\n    q3.z+=T*1.5;\n    \n    // Multi Tap loop @Shane https://www.shadertoy.com/view/WtffDS\n    vec2 p,ip,ct = vec2(0);\n    const vec2[4] ps4 = vec2[4](vec2(-.5,.5),vec2(.5),vec2(.5,-.5),vec2(-.5));\n    float d1=1e5;\n    \n    for(int i = 0; i<4; i++) {\n    \n        ct = ps4[i]/2. -  ps4[0]/2.;\n        p = q3.xz - ct*s;\n        ip = floor(p/s) + .5;\n        p -= (ip)*s;\t   \n        vec2 idi = (ip + ct)*s;\n\n        vec3 q = vec3(p.x,q3.y,p.y);\n    \n        float hs=hash21(idi+yd);\n        float gs=hash21(idi+yd+floor(T*2.));\n        \n        //@Nusan - mixing states from twitter..\n        pf = mix(hash21(vec2(floor(T)+hs)), hash21(vec2(floor(T)+1.+hs)), pow(smoothstep(0.,1.,fract(T)), 8.));\n        pf = clamp(pf*.45,.15,1.);\n\n        float d = box(q,vec3(scale*pf))-.075;\n        d=max(d,-(box(q,vec3(scale*pf*.8))-.075));\n        \n        float thk = (scale*.7*pf),thx = (scale*.03);\n        float pipe = min(min(length(q.xz)-thk,length(q.yz)-thk),length(q.yx)-thk);\n        float xipe = min(length(q.yx)-thx,length(q.yz)-thx);\n\n        if(xipe<res.x) {\n            res=vec2(xipe,2.);\n            gsh=hs;\n            hit=q;\n            gpf=pf;\n        }\n        \n        if(hs<.9) d=max(d,-pipe);\n        \n        if(d<res.x) {\n            res=vec2(d,1.);\n            hit=q;\n            gsh=hs;\n            gpf=pf;\n        }\n        \n        float d4 = length(q)-(scale*.35*pf);\n        if(gs>.68&&hs<.9) glow+=.004/(.0025+d4*d4);\n        if(d4<res.x&&gs>.68) {\n            res=vec2(d4,2.);\n            gsh=hs;\n        }\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t){\n    vec2 e=vec2(t*1e-3,0.);\n    float d = map(p).x;\n    vec3 n = d-vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\n// Tri-Planar blending function. Ryan Geiss: \n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    p*=.175;\n    p+=hsh*5.;\n    p.xz*=rot(hsh*PI2+.38);\n    n = max(abs(n), 1e-3);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec3 hue(float a){return .33+.66*sin(PI2*a*vec3(.95,.48,.08)*vec3(1,.98,.95));}\n\nvoid mainImage( out vec4 fragColor, in vec2 F )\n{\n\tvec2 uv = (2.*F.xy - R.xy)/max(R.x,R.y);\n    vec2 vv=uv;\n    uv*=rot(-.38*sin(T*.1));\n\tvec3 C = vec3(0);\n    \n    vec3 ro = vec3(0,0,6), rd=normalize(vec3(uv,-1.));\n\n    float dof = 0.001;\n    float dofdist = 1.0/6.;\n    vec2 off=vec2(.05);\n\n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * 2. - 1.) * PI;     \n    mat2 rx = rot(-.72),ry = rot(T*.05+y);\n    ro.zy*=rx;ro.xz*=ry;\n    rd.zy*=rx;rd.xz*=ry;\n   \n    float fa=0.;\n    for(int k=0;k<2;k++){\n    \n        vec3 p = ro;\n        float d = 0., m = 0.;\n\n\n        vec3 RC = vec3(0);\n        for(int i=0;i<86;i++){\n\n            //modified jitter/dof \n            //inspiration @Nusan https://www.shadertoy.com/view/3sXyRN\n            if(mod(float(i),2.)<1.){\n                off= vv.x>.0? texture(iChannel1,F.xy/1024.).rg*2.-1.: texture(iChannel2,F.xy/8.).rg*2.-1.;\n                vec2 fp = off*dof;\n                ro.xz+= vv.x>.0? fp*(d)*.002: fp*(d)*.02;\n                rd.xy+= vv.x>.0? fp*(d*d)*dofdist*.02: fp*(d*d)*dofdist*.04;\n            }\n            \n            p=ro+d*rd;\n\n            vec2 ray = map(p);\n            m=ray.y;\n            d+=i<20?ray.x*.5:ray.x*.9;\n            if(ray.x<d*1e-4||d>30.)break;\n        }\n\n        hsh=gsh;\n        spf=gpf;\n        hp=hit;\n        \n        if(k==0) {fa=d;sglow=glow;}\n        \n        if(d<30.) {\n            vec3 n = normal(p,d);\n            vec3 l = normalize(vec3(1,14,-5));\n            float diff = clamp(dot(n,l),0.1,1.);\n       \n            vec3 h = hue(73.+hsh);\n            h=mix(tex3D(iChannel0,hp/spf,n).rgb,h,.05);\n            if(m==2.) h = vec3(.1);\n            RC=diff*h;\n\n            ro = p+n*.001;\n            rd = reflect(rd,n);\n\n        }\n\n        if(k>0) RC *=.125;\n\n        C = clamp(C+RC,vec3(0),vec3(1));\n\n    }\n    \n    C=mix(C,vec3(sglow,sglow*.5,sglow*.15),clamp(sglow,0.,.2));\n    C=mix(C,mix(vec3(.12,.08,.06),vec3(.9,.69,.39),clamp((uv.y+.5)*.5,0.,1.)),1.-exp(-.0003*fa*fa*fa));\n    if(vv.x>-.002&&vv.x<.002)C=vec3(1);\n    C=pow(C,vec3(.4545));\n\tfragColor = vec4(C,1.);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsB3RK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[492, 492, 511, 511, 554], [555, 555, 576, 576, 630], [631, 631, 653, 653, 712], [714, 714, 740, 740, 825], [2634, 2634, 2663, 2663, 2841], [2843, 2957, 3004, 3004, 3260], [3262, 3262, 3280, 3280, 3341], [3343, 3343, 3392, 3392, 5401]], "test": "untested"}
{"id": "msSGRc", "name": "Inverse Trig Accuracy I", "author": "mla", "description": "Testing inverse trigonometry functions, compare x and acos(cos(x)) etc. Text shows function values at mouse. 'x' for native sin, cos, tan.", "tags": ["atan", "acos", "precision", "trigonometry", "asin"], "likes": 7, "viewed": 231, "published": 3, "date": "1667947055", "time_retrieved": "2024-07-30T16:21:08.144571", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Inverse Trig Function Accuracy, mla 2022.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// Inverse trig function errors.\n\n// Red channel:   absolute error in acos(cos(x))\n// Green channel: absolute error in asin(sin(x))\n// Blue channel:  absolute error in atan(tan(x))\n//\n// sin and cos calculated by accurate functions, press 'x' to use the\n// native functions - be warned, the result on Intel isn't pretty.\n//\n// Note that acos and asin are significantly less accurate than atan\n// (on Nvidia, Pixel 4a and Intel anyway, very much so on Intel).\n//\n// Horizontal scale is 0..π/2. Vertical scale is ±1e-4 on all platforms.\n//\n// Numeric display shows the main trig functions evaluated at the mouse position\n// and compared with the more accurate myxxx functions. We also compute the inverse\n// functions for comparison with the original theta.\n//\n//         mycos(theta)       mysin(theta)       mytan(theta)\n//         cos(theta)         sin(theta)         tan(theta)\n// theta   acos(mycos(theta)) asin(mysin(theta)) atan(mytan(theta))\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// mycos and mysin have been checked on CPU & agree to a few ulps with\n// builtin functions in range [0..pi/2] (ulp error is larger when result is\n// closer to zero, but absolute error is fine). It's possibly worth using\n// sin(pi/2-x) for cos(x) in upper half of range, but there isn't a lot in it.\n\nfloat mycos(float x) {\n  int N = 12;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\n\nfloat mysin(float x) {\n  int N = 10;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\nfloat hud(vec2 fragCoord, float theta) {\n  const int digits = 7;\n  const int nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int column = cellindex.x;\n  int row = cellindex.y;\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  // Get coords for mipmap scaling - p and uv have discontinuities\n  vec2 uvscale = 0.5*fragCoord/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = dFdx(uvscale), dy = dFdy(uvscale); // Calculate early\n  float x;\n  float cost = cos(theta);\n  float mycost = mycos(theta);\n  float sint = sin(theta);\n  float mysint = mysin(theta);\n  float mytant = mysint/mycost;\n  if (column == 0) {\n    if (row == 0) x = theta;\n    else return 0.0;\n  } else if (column == 1) {\n    if (row == 1) x = cost;\n    else if (row == 2) x = mycost;\n    else if (row == 0) x = acos(mycost);\n    else return 0.0;\n  } else if (column == 2) {\n    if (row == 1) x = sint;\n    else if (row == 2) x = mysint;\n    else if (row == 0) x = asin(mysint);\n    else return 0.0;\n  } else if (column == 3) {\n    if (row == 1) x = tan(theta);\n    else if (row == 2) x = mytant;\n    else if (row == 0) x = atan(mytant);\n    else return 0.0;\n  } else {\n    return 0.0;\n  }\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = floatchar(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c < 0) return 0.0;\n  float charstart = charwidth*float(charpos); // character start\n  uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  return t.x;  \n}\n\nbool comp(float y, float r) { return (0.0 < y) == (y < r); }\n\n// Possibly better implementations of acos and asin.\nfloat acos2(float x) { return atan(1.0/(x*inversesqrt(1.0-x*x))); }\nfloat asin2(float x) { return atan(x*inversesqrt(1.0-x*x)); }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float xmouse = 0.1*iTime;\n  float scale = 1e-4;\n  if (iMouse.x > 10.0) {\n    xmouse = iMouse.x/iResolution.x;\n    //scale = exp(-10.0*iMouse.y/iResolution.y);\n  }\n  xmouse = 0.5*PI*fract(xmouse);\n  //float check = max(0.1,-iTime);\n  //if (abs(cos(check)-mycos(check)) < 1e-6) scale = 1e-6;\n  float x = 0.5*PI*fragCoord.x/iResolution.x;\n  float y = scale * (2.0*fragCoord.y-iResolution.y)/iResolution.y;\n  float cosx = mycos(x), sinx = mysin(x), tanx = sinx/cosx;\n  if (key(CHAR_X)) {\n    cosx = cos(x), sinx = sin(x), tanx = tan(x);\n  }\n  float t0 = x-acos(cosx);\n  float t1 = x-asin(sinx);\n  float t2 = x-atan(tanx);\n  vec3 col = vec3(comp(y,t0),comp(y,t1),comp(y,t2));\n\n  col = mix(col,vec3(1),hud(fragCoord,xmouse)); \n  \n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n#define SIGN(x) { if ((x) < 0.0) CHAR(MINUS) else CHAR(SPACE) } \n\n// Format x to digits precision and return the character at cindex,\n// or -1 if cindex is out of range.\nint floatchar(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return -1;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int SPACE = 0x20, ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    SIGN(x);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    // Maybe show the bits\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    SIGN(x);\n    CHAR(ZERO);\n  } else {\n    SIGN(x);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // This is a delicate business if we aren't to\n    // lose too much precision\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have a correctly rounded integer representation together\n    // with the correct exponent. The rest is just formatting.\n\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return -1;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1553, 1553, 1575, 1575, 1700], [1703, 1703, 1725, 1725, 1852], [1854, 1895, 1921, 2003, 2042], [2044, 2044, 2084, 2084, 3885], [3887, 3887, 3916, 3916, 3947], [3949, 4002, 4024, 4024, 4069], [4070, 4070, 4092, 4092, 4131], [4133, 4133, 4186, 4186, 4941]], "test": "untested"}
{"id": "cdSGzV", "name": "Raymarching 2.3", "author": "FifthStateOfMatter", "description": "3d", "tags": ["3d"], "likes": 5, "viewed": 246, "published": 3, "date": "1667918254", "time_retrieved": "2024-07-30T16:21:08.974352", "image_code": "//Thanks to @dean_the_coder for some performance improvements\n#define epsilon 0.01\n#define maxSteps 300\n#define lPos vec3(6, 10, -20)\n#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define FOV 90.0*degreesToRadians\n#define fogDensity 10.0\n#define fogColor vec3(0.8)\n\nstruct material{\n    vec3 col;\n    float type;\n    float intensity;\n    float brightness;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n    int index;\n};\n\nstruct camera{\n    vec3 o;\n    vec3 d;\n};\nfloat random(vec3 p){\n    return fract((sin(p.x*203.24 + 20398.243)*sin(p.y*834.29 + 2382.2033)*sin(p.z*405.09))*20384.043);\n}\n\nfloat noise2(vec2 p){\n    vec2 luv = fract(p);\n    vec2 id = floor(p);\n    luv = luv*luv*(3.0 - 2.0*luv);\n    float bl = random(vec3(id, 1));\n    float br = random(vec3(id + vec2(1, 0), 1));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = random(vec3(id + vec2(0, 1), 1));\n    float tr = random(vec3(id + vec2(1, 1), 1));\n    float t = mix(tl, tr, luv.x);\n    return mix(b, t, luv.y);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = smoothstep(0.0, 1.0, frc);\n    \n    float tlf = random(fc + vec3(0, 1, 0));\n    float trf = random(fc + vec3(1, 1, 0));\n    float blf = random(fc + vec3(0, 0, 0));\n    float brf = random(fc + vec3(1, 0, 0));\n    float tlb = random(fc + vec3(0, 1, 1));\n    float trb = random(fc + vec3(1, 1, 1));\n    float blb = random(fc + vec3(0, 0, 1));\n    float brb = random(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\n\nSDF sphere(vec3 p, float rad, material mat, int index){\n    return SDF(length(p) - rad, mat, index);\n}\n\nSDF boxSDF(vec3 p, vec3 s, material mat, int index){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat, index);\n}\n\nSDF yPlane(vec3 p, float y, material mat, int index){\n    return SDF(p.y - y, mat, index);\n}\n\nSDF boxFrameSDF(vec3 p, vec3 s, float sw, float ro, material mat, int index){\n  p = abs(p) - s;\n  vec3 q = abs(p + sw) - sw;\n  return SDF(min(\n      min(\n          length(max(vec3(p.x, q.y, q.z),0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n          length(max(vec3(q.x, p.y, q.z),0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)\n      ),\n      length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0)) - ro, mat, index);\n}\n\nSDF sceneSDF(vec3 p, float type){\n    \n    /*SDF[] scene = SDF[](\n        sphere(p - vec3(2, 1, 5), 1.0, material(vec3(1, 0, 0), 1.0, 0.0, 0.0), 0),\n        sphere(p - vec3(-1, -2, 5), 0.6, material(vec3(1, 1, 0), 1.0, 0.0, 0.0), 1),\n        sphere(p - vec3(0, 0, 5), 1.0, material(vec3(0, 1, 0), 1.0, 0.0, 0.0), 2),\n        sphere(p - vec3(-4, 0, 8), 1.0, material(vec3(0, 1, 1), 1.0, 0.0, 0.0), 2)\n    );\n    \n    //float outputDist = 100000.0;\n    for(int i = scene.length() - 1; i >= 0; i--){\n        float outputDist = min(scene[0].dist, scene[i].dist);\n        //if(type == 0.0){\n            if(outputDist == scene[i].dist){\n                return scene[i];\n            }\n        //}\n    }*/\n    \n    \n    float gf = 0.5;\n    float gh = 1.5;\n    float gv = 0.03;\n    int gd = 4;\n    \n    float gn = noise3((p + vec3(5, sin(iTime*10.0)*0.03, 2))*gf)*gh;\n    for(int i = 0; i < gd; i++){\n        gh /= 2.0;\n        gf *= 2.0;\n        gv *= 2.0;\n        gn += noise3((p + vec3(5.0 + float(i), sin(iTime*10.0)*0.03 + float(i), 2.0 + float(i)))*gf)*gh;\n    }\n    \n    gn /= 2.0;\n    \n    float wf = 10.0;\n    float wh = 0.005;\n    float wv = 0.01;\n    int wd = 2;\n    \n    float wn = noise3((p + vec3(5, iTime*wv, 2))*wf)*wh;\n    for(int i = 0; i < wd; i++){\n        wh /= 2.0;\n        wf *= 2.0;\n        wv *= 2.0;\n        wn += noise3((p + vec3(5.0 + float(i), iTime*wv + float(i), 2.0 + float(i)))*wf)*wh;\n    }\n    \n    wn /= 2.0;\n    \n    //SDF s1 = sphere(p - lPos, 1.0, material(vec3(1), 0.0, 0.9, 0.0), 0);\n    //SDF s2 = sphere(p - vec3(-1, 1.0, 3), 0.6, material(vec3(0, 1, 1), 3.0, 0.6, 0.0), 1);\n    SDF s3 = sphere(p - vec3(0, sin(-iTime*10.0)*0.03, 0), 0.25, material(vec3(0.6, 0.4, 0.2), 1.0, 0.7, 0.0), 1);\n    SDF s4 = yPlane(p, 0.3 - mix(sin(length(p - vec3(0, 0.4, 0))*10.0 - iTime*10.0)*0.01, 0.0, min(length(p - vec3(0, 0.4, 0))/3.0, 1.0)), material(vec3(0, 0.05, 0.1), 3.0, 0.8, 0.0), 2);\n   \n    s3.dist -= gn;\n    \n    //s4.dist -= wn;\n    \n    float closest;\n    \n    if(type == 0.0){\n        closest = min(s3.dist, s4.dist);\n    }else if(type == 1.0){\n        closest = min(s3.dist, s4.dist);\n    }\n    \n    //if(closest == s1.dist){\n        //return s1;\n    //}else if(closest == s2.dist){\n        //return s2;\n    /*}else*/ if(closest == s3.dist){\n        return s3;\n    }else if(closest == s4.dist){\n        return s4;\n    }\n}\n\nbool raymarch(float type, vec3 o, vec3 d, out float t, float eps, out material mat, out int index){\n    t = 0.0;\n    for(int i = 0; i < maxSteps && t <= 30.0; i++){\n        SDF s = sceneSDF(o + d*t, type);\n        t += s.dist;\n        mat = s.mat;\n        index = s.index;\n        if(s.dist < eps*t*0.1 && t > 0.0){\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 getNormals(vec3 h){\n    return normalize(\n        vec3(\n            sceneSDF(vec3(h.x + epsilon, h.yz), 0.0).dist - sceneSDF(vec3(h.x - epsilon, h.yz), 0.0).dist,\n            sceneSDF(vec3(h.x, h.y + epsilon, h.z), 0.0).dist - sceneSDF(vec3(h.x, h.y - epsilon, h.z), 0.0).dist,\n            sceneSDF(vec3(h.xy, h.z + epsilon), 0.0).dist - sceneSDF(vec3(h.xy, h.z - epsilon), 0.0).dist\n        )\n    );\n}\n\nfloat getLighting(vec3 h, vec3 lpos, material hitMat, int ii){\n    float brightness = 1.0;\n    \n    vec3 n = getNormals(h);\n    vec3 lRay = normalize(lpos - h);\n    \n    if(hitMat.type != 0.0){\n        float lt;\n        material lMat;\n        int i;\n        \n        bool rl = raymarch(1.0, h + n*0.007, lRay, lt, 0.001, lMat, i);\n        brightness = max(dot(n, lRay), 0.01);\n        \n        if(rl && i != ii){\n            brightness -= 0.6;\n        }\n    }else{\n        brightness = 1.0;\n    }\n    return brightness;\n}\n\nvec3 reflectRay(vec3 h, vec3 d){\n    vec3 n = getNormals(h);\n    return d - 2.0*n*dot(n, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float f = 1.0/tan(FOV/2.0);\n    \n    mat3 projection;\n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    vec3 col = fogColor;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    camera cam = camera(vec3(2.5, 3, -6), vec3(20, 20, 0));\n    \n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(cam.d.x*degreesToRadians), -sin(cam.d.x*degreesToRadians));\n    xRotation[2] = vec3(0, sin(cam.d.x*degreesToRadians), cos(cam.d.x*degreesToRadians));\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cos(cam.d.y*degreesToRadians), 0, -sin(cam.d.y*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(cam.d.y*degreesToRadians), 0, cos(cam.d.y*degreesToRadians));\n    \n    vec3 d = normalize(vec3(uv, 1.0)*projection*xRotation*yRotation);\n    vec3 o = cam.o;\n    \n    float t;\n    material mat;\n    int si;\n    \n    bool rs = raymarch(0.0, o, d, t, epsilon, mat, si);\n    \n    if(rs){\n        mat.brightness = getLighting(o + d*t, lPos, mat, si);\n        \n        if(mat.type == 1.0){\n            col = mix(mat.col*mat.brightness, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n        }else if(mat.type == 0.0){\n            col = mat.col;\n        }else if(mat.type == 3.0){\n            float rt;\n            material rmat;\n            int ri;\n            vec3 rd = reflectRay(o + d*t, d);\n            \n            vec3 n = getNormals(o + d*t);\n            \n            bool rr = raymarch(0.0, (o + d*t) + n*0.02, normalize(rd), rt, epsilon, rmat, ri);\n            \n            if(rr){\n                //mat.brightness = getLighting(o + d*t, lPos, mat, si);\n                float reflectLighting = getLighting((o + d*t) + normalize(rd)*rt, lPos, rmat, ri);\n                col = mix(mix(rmat.col*reflectLighting, mat.col*mat.brightness, mat.intensity), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n            }else{\n                col = mix(mix(fogColor, mat.col, mat.intensity)*mat.brightness, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n            }\n        }\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 500, 500, 605], [607, 607, 628, 628, 999], [1001, 1001, 1022, 1022, 1850], [1853, 1853, 1908, 1908, 1955], [1957, 1957, 2009, 2009, 2121], [2123, 2123, 2176, 2176, 2215], [2217, 2217, 2294, 2294, 2648], [2650, 2650, 2683, 3347, 5006], [5008, 5008, 5107, 5107, 5384], [5386, 5386, 5410, 5410, 5793], [5795, 5795, 5857, 5857, 6316], [6318, 6318, 6350, 6350, 6412], [6414, 6414, 6468, 6468, 8648]], "test": "untested"}
{"id": "csSGR3", "name": "my shader of the day 1#", "author": "jonasfrey", "description": "1#", "tags": ["day"], "likes": 3, "viewed": 169, "published": 3, "date": "1667911729", "time_retrieved": "2024-07-30T16:21:09.778203", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    // a sine wave but not horizontal\n    vec2 a_n_pix_cor_nor = fragCoord.xy / iResolution.xy; \n    vec2 a_n_mou_cor_nor = iMouse.xy / iResolution.xy; \n    float n_tau = 6.283185;\n    float n_mount = 0.0;\n    float n_amp = 0.2;\n    vec2 a_n_trans = vec2(0.0, 0.5);\n    float n_y = \n        sin(a_n_pix_cor_nor.x * n_tau + a_n_trans.x)\n        * n_amp\n        + a_n_trans.y;\n        \n    float n_dist = abs(a_n_pix_cor_nor.y - n_y);\n    \n    // https://www.desmos.com/calculator/r9j8egdlvx\n    float n_dist_modified = pow(n_dist, 0.3);\n    //fragColor *= vec4(n_dist_modified);\n    \n    \n    float n_curves = 24.0;\n    float n_dist_shortest = 1.0;\n    float n_curve_col = 0.0;\n    for(\n        float n_curve_norm = 0.0;\n        n_curve_norm <= 1.0; \n        n_curve_norm += 1.0/n_curves\n        ){\n            \n            n_y = \n                sin(a_n_pix_cor_nor.x * n_tau + a_n_trans.x + n_curve_norm*5.0 + iTime)\n                * n_amp \n                + a_n_pix_cor_nor.x*n_curve_norm*2.0;\n\n            n_dist = abs(a_n_pix_cor_nor.y - n_y);\n\n            // https://www.desmos.com/calculator/r9j8egdlvx\n            n_dist_modified = pow(n_dist, 0.3);\n            \n            if(n_dist_modified < n_dist_shortest){\n                n_dist_shortest = n_dist_modified;\n                n_curve_col = fract(sin(1234.1234*n_curve_norm)*1234.1234);\n            }\n            \n            n_y = \n                sin(a_n_pix_cor_nor.x * n_tau + a_n_trans.x + n_curve_norm*5.0 + iTime)\n                * n_amp \n                + 1.0-a_n_pix_cor_nor.x*n_curve_norm*2.0;\n\n            n_dist = abs(a_n_pix_cor_nor.y - n_y);\n\n            // https://www.desmos.com/calculator/r9j8egdlvx\n            n_dist_modified = pow(n_dist, 0.3);\n            \n            if(n_dist_modified < n_dist_shortest){\n                n_dist_shortest = n_dist_modified;\n                n_curve_col = fract(sin(1234.1234*n_curve_norm)*1234.1234);\n            }\n        }\n    \n    if(1.0-a_n_pix_cor_nor.y > a_n_pix_cor_nor.x){\n    \n        fragColor *= vec4(\n            n_dist_shortest, \n            n_curve_col, \n            1.-n_curve_col, \n            0.\n        );\n    }else{\n        fragColor = vec4(n_dist_shortest);\n    }\n\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2298]], "test": "untested"}
{"id": "csB3zV", "name": "cool cells", "author": "jonasfrey", "description": "disstance", "tags": ["cell"], "likes": 5, "viewed": 184, "published": 3, "date": "1667899923", "time_retrieved": "2024-07-30T16:21:10.598011", "image_code": "float f_n_random_norm(float n){\n    return fract(sin(n*11235.1234)*1234.1324);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_pix_cor_nor = fragCoord.xy / iResolution.xy;\n\n    vec2 a_n_mou_cor_nor = iMouse.xy / iResolution.xy;\n    if(iMouse.xy==vec2(0)){\n        a_n_mou_cor_nor = vec2(0.5,0.5);\n    }\n    float n_points = 500.0 * a_n_mou_cor_nor.x;\n    float n_dist_min = 1.0; \n    float n_max_dist_hardcoded = 0.2;\n    fragColor = vec4(1.0);\n    float n_freq_max_factor = 2.0;\n    float n_rand_last = f_n_random_norm(1234.1234);\n    for(float n_i_norm = 0.0; n_i_norm < 1.0; n_i_norm+=1.0/n_points){\n        float n_rand1 = f_n_random_norm(n_rand_last);\n        float n_rand2 = f_n_random_norm(n_rand1);\n        float n_rand3 = f_n_random_norm(n_rand2);\n        float n_rand4 = f_n_random_norm(n_rand3);\n        n_rand_last = n_rand1;\n        float n_dist = length(\n            vec2(\n                n_rand1+sin(iTime*n_freq_max_factor*n_rand3+n_i_norm*n_rand3)*n_rand3*0.2, \n                n_rand2+cos(iTime*n_freq_max_factor*n_rand3+n_i_norm*n_rand4)*n_rand4*0.2\n            )\n            -\n            a_n_pix_cor_nor\n        );\n        if(n_dist < n_dist_min){\n            n_dist_min = n_dist;\n        }\n    }\n    \n    fragColor = vec4(n_dist_min/n_max_dist_hardcoded);\n\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 80], [82, 82, 139, 139, 1312]], "test": "untested"}
{"id": "dsSGzK", "name": "aphex twin visualized", "author": "jonasfrey", "description": "sound, \n", "tags": ["test", "sound", "equalizer"], "likes": 4, "viewed": 237, "published": 3, "date": "1667899875", "time_retrieved": "2024-07-30T16:21:11.429787", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n const float N_TAU = 6.283185307179586476;\n \n     vec2 a_n_frag_coords_normalized = fragCoord.xy / iResolution.xy; \n     float n_amp_base = 100.0; \n     float n_angle = 0.0;\n     float n_channels = 2.0;\n\n     float n_brightness = 0.0;\n     float n_distance_min = 1.0;\n     \n     float n_len_a_n_freq = iChannelResolution[0].x;\n     float n_amp_max_norm = 1.0 / iChannelResolution[0].x;\n     float n_freqs_to_display = 99.0;\n     int n_count = 0;\n     float n_sound_amplitude_saved = 0.0;\n     for(float n_index_freq_norm = 0.0; n_index_freq_norm < 1.0; n_index_freq_norm+=(1.0/n_freqs_to_display)){\n            n_count+=1;\n             \n            //float n_sound_amplitude = texelFetch(iChannel0, ivec2(float(n_index),  0), 0).r; \n             //float n_index = 0.0;\n             float n_index_freq = n_index_freq_norm * n_len_a_n_freq;\n             float n_sound_amplitude = texelFetch(iChannel0, ivec2(n_index_freq,  0), 0).x;     \n             float n_phase_factor = 1.0;\n             if(mod(float(n_count), 2.0) == 0.0){\n                 n_phase_factor = -1.0;\n             } \n             float n_y = sin(\n                 N_TAU \n                 * a_n_frag_coords_normalized.x \n                 * n_index_freq_norm * n_freqs_to_display\n                 + sin(iTime*(n_sound_amplitude/255.0)*n_index_freq_norm) \n                 // + (iTime*0.1*n_index_freq + n_index_freq)* n_phase_factor // overkill\n                 ) \n                 * n_sound_amplitude \n                 * (1.0 / n_freqs_to_display)\n                 //* (1.0-n_index_freq_norm)*2.0 //overkill\n                 + n_index_freq_norm + (n_amp_max_norm);\n\n                 \n             float n_dist_to_n_y = abs(a_n_frag_coords_normalized.y - n_y);\n             float n_dist_to_n_y_norm = n_dist_to_n_y / (1.0 / n_freqs_to_display);\n             //float n_dist_to_n_y_norm_smoothstep = smoothstep(0.0, (1.0-n_index_freq_norm), n_dist_to_n_y_norm);\n             //fragColor *= vec4(n_dist_to_n_y_step);\n             if(n_dist_to_n_y_norm < n_distance_min){\n                 //n_distance_min = n_dist_to_n_y_norm_smoothstep;\n                 n_distance_min = n_dist_to_n_y_norm;\n                 n_sound_amplitude_saved = n_sound_amplitude;\n             }\n         \n         \n     \n     }\n     fragColor = vec4(1.0-(n_distance_min/(n_sound_amplitude_saved*1.0)));\n\n     \n\n\n     \n\n}", "image_inputs": [{"id": 30154, "src": "https://soundcloud.com/user-832040388/aphex-twin-soundlab20", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 2415]], "test": "untested"}
{"id": "Ds23WW", "name": "a line and a colorized field", "author": "jonasfrey", "description": "Thanks to @Envy24 for showing me the colorize field functions!", "tags": ["basic", "line"], "likes": 1, "viewed": 148, "published": 3, "date": "1667899872", "time_retrieved": "2024-07-30T16:21:12.250592", "image_code": "#define R (iResolution)\n//const float n_tau = 6.28318530717958647;\nfloat f_n_difference_to_line_function(\n    vec2 a_n_start, \n    vec2 a_n_end, \n    vec2 a_n_pixel_coord_normalized\n){\n    //remember that math lesson ?\n    // y = m*x+q\n    float n_delta_y = a_n_end.y - a_n_start.y; \n    float n_delta_x = a_n_end.x - a_n_start.x; \n    float n_m = n_delta_y / n_delta_x;\n    float n_q = -(n_m*a_n_start.x) - a_n_start.y;\n    \n    float n_x = a_n_pixel_coord_normalized.x;\n    \n    float n_y = n_m * n_x + n_q; \n   \n    float n_difference = a_n_pixel_coord_normalized.y - n_y;\n    return n_difference;\n\n    \n}\n\n//Or iq's scheme:\n// https://www.shadertoy.com/view/3tdSDj\nvec3 f_colorize_field_iq(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n    \n    // Add interleaved waves.\n\tcolor *= 0.7 + 0.2 * cos(30.0 * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 6./R.y, abs(dist)));\n}\n\n\n// https://www.shadertoy.com/view/ddfGz2\nvec3 f_colorize_field_Envy24(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./R.y, 0., abs(dist)) );\n}\n\n/*\nbool f_b_inside_polygon(\n    vec2 a_n_translation, \n    float n_radius, \n    float n_corners\n){todo}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_pixel_pos_normalized = fragCoord.xy / iResolution.xy;\n    \n    vec2 a_n_start = vec2(0.001,0.0);\n    vec2 a_n_end = vec2(0.99, 0.99); \n    \n    float n_brightness = 0.0;\n    float n_difference_to_line_function = f_n_difference_to_line_function(\n        a_n_start, \n        a_n_end, \n        a_n_pixel_pos_normalized\n    );\n  \n  \n\n    \n    fragColor = vec4(abs(n_difference_to_line_function*20.00));\n    vec3 o_col = vec3(0.1, 0.5, 0.9);\n    if(a_n_pixel_pos_normalized.x > (1.0/3.0)*1.0){\n        fragColor = vec4(f_colorize_field_Envy24(n_difference_to_line_function, o_col), 1.);        \n    }\n\n    if(a_n_pixel_pos_normalized.x > (1.0/3.0)*2.0){\n        fragColor = vec4(f_colorize_field_iq(abs(n_difference_to_line_function) - 0.1, o_col), 1.);\n    }\n    \n    if(a_n_pixel_pos_normalized.y > (0.5)){\n        // gamma correction\n        fragColor = pow(max(fragColor,0.),vec4(1./2.2));\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds23WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 67, 184, 235, 608], [610, 669, 719, 760, 1061], [1064, 1105, 1159, 1159, 1654], [1656, 1763, 1820, 1820, 2731]], "test": "untested"}
{"id": "Dsj3DW", "name": "moire mouse x ", "author": "jonasfrey", "description": "slowly drag the mouse on x axis to experience it!", "tags": ["moire"], "likes": 1, "viewed": 168, "published": 3, "date": "1667899780", "time_retrieved": "2024-07-30T16:21:13.069404", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_mouse_coords_normalized = iMouse.xy / iResolution.xy;\n    vec2 a_n_frag_coords_normalized = fragCoord.xy / iResolution.xy;\n\n    \n    float n_lines_glob = 500.0; \n    float n_lines = n_lines_glob; \n    float n_mod = iResolution.x / n_lines;\n    float n_brightness = 1.0;\n    \n    if(\n        a_n_frag_coords_normalized.y > 0.0\n        &&\n        a_n_frag_coords_normalized.y < 0.75\n    ){\n    \n        if(mod(fragCoord.x, n_mod) > (n_mod /2.0)){\n            n_brightness = 1.0;\n        }else{\n            n_brightness = 0.0;\n        }\n    }\n    if(\n        a_n_frag_coords_normalized.y > 0.25 \n    ){\n        float n_lines2 = n_lines+1.0;\n        float n_mod2 = iResolution.x / n_lines2;\n        float n_trans = n_mod * (a_n_mouse_coords_normalized.x*(n_lines2/20.0));\n        if(\n            mod(fragCoord.x + n_trans, n_mod2) \n            > (n_mod /2.0)\n          ){\n                n_brightness = 0.0;\n           }\n    }\n    \n    \n    fragColor = vec4(n_brightness);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsj3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1047]], "test": "untested"}
{"id": "Ddj3RG", "name": "Slime Mold Variations", "author": "fenix", "description": "I saw this YouTube video and I was inspired to experiment with slime mold simulation.\nhttps://youtu.be/X-iSQQgOd1A\n*mouse to clear trails*\n*space to reset*\n*left and right arrow keys to switch demos*", "tags": ["2d", "voronoi", "simulation", "particles", "slime", "mold", "slimemold"], "likes": 19, "viewed": 499, "published": 3, "date": "1667896008", "time_retrieved": "2024-07-30T16:21:14.006896", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I saw this YouTube video and I was inspired to experiment with slime mold simulation.\n//\n//      https://youtu.be/X-iSQQgOd1A\n//\n//  The idea is that particles are attracted to their own trails, and repelled by\n//  trails of different colors. Up to four colors are supported (one per channel).\n//\n//  I tried to find some settings and color combinations that looked cool together,\n//  and I'm cycling between 14 demos defined at the bottom of the common tab. You can\n//  change demos with the left and right arrow keys, clear trails with the mouse, and\n//  reset everything with space.\n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    \n    initGlobals(iResolution, state);\n    \n    vec4 colors = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.xyz = sqrt(max(max(max(colors.r * g_ColorR,\n                         colors.g * g_ColorG),\n                         colors.b * g_ColorB),\n                         colors.a * g_ColorA));\n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//global variables, initialized per demo\nint g_MaxParticles = 100000; \nfloat g_ParticleSize = .03;\nfloat g_ParticleSpeed = .005;\nfloat g_ParticleTurn = .8;\nvec3 g_ColorR, g_ColorG, g_ColorB, g_ColorA;\nint g_NumColors = 2;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x + resolution.x / resolution.y);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS_VEL 0\n#define NUM_PARTICLE_DATA_TYPES 1\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xy;\n    particle.vel = particleData0.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvec4 colorFromId(int id)\n{\n    int index = id % g_NumColors;\n    \n    switch (index)\n    {\n    case 0: return vec4(1,0,0,0);\n    case 1: return vec4(0,1,0,0);\n    case 2: return vec4(0,0,1,0);\n    case 3: return vec4(0,0,0,1);\n    }\n}\n\nstruct Demo\n{\n    float used;\n    float size;\n    float speed;\n    float turn;\n    int colors;\n    vec3 colorR;\n    vec3 colorG;\n    vec3 colorB;\n    vec3 colorA;\n};\n\nconst int NUM_DEMOS = 14;\nDemo DEMOS[NUM_DEMOS] = Demo[](\n    Demo( .5,   .003, .002, 1.2, 4, vec3(.8,.3,0),   vec3(.7,.6,.3),  vec3(0,.2,.7),  vec3(.9,.3,.6)), // intro\n    Demo( .01,  .01,  .01,   .5, 1, vec3(0,.4,.1),   vec3(0),         vec3(0),        vec3(0)),        // oscilloscope\n    Demo( .003, .01,  .003,  .3, 2, vec3(0,1,1),     vec3(1,0,0),     vec3(0),        vec3(0)),        // branching\n    Demo( .003, .01,  .003,  .9, 3, vec3(0,1,1),     vec3(1,0,0),     vec3(1, .7, 0), vec3(0)),        // looping\n    Demo(1.,    .004, .005,  .5, 3, vec3(0,.2,.6),   vec3(.6,0,.3),   vec3(.2,.6,.6), vec3(0)),        // blizzard\n    Demo(1.,    .004, .001, 1. , 4, vec3(.8,.7,.6),  vec3(.9,.8,.1),  vec3(.9,.5,.0), vec3(.5,0,0)),   // solar flare\n    Demo( .8,   .005, .005, 1.5, 1, vec3(1,.2,.1),   vec3(0),         vec3(0),        vec3(0)),        // fire\n    Demo( .4,   .01,  .001,  .5, 2, vec3(.6,.1,.05), vec3(.2,.3,.1),  vec3(0),        vec3(0)),        // sprouting\n    Demo( .4,   .007, .001,  .5, 4, vec3(.5,0,0),    vec3(.1,.2,.0),  vec3(.3,.5,.4), vec3(.5,.2,1)),  // celestial\n    Demo( .01,  .01,  .002,  .5, 3, vec3(.3,.2,.1),  vec3(.2,.3,.1),  vec3(.2,.5,.3), vec3(0)),        // arboreal\n    Demo(1.,    .005, .001,  .9, 4, vec3(.2,.2,.5),  vec3(.3,.3,.5),  vec3(.4,.4,.5), vec3(.5)),       // climactic\n    Demo( .2,   .01,  .005, 1.5, 2, vec3(.05,.1,.2), vec3(.1,.2,.05), vec3(0),        vec3(0)),        // two-color slow\n    Demo( .05,  .007, .01,  1.5, 2, vec3(0,.4,0),    vec3(.4,0,.2),   vec3(0),        vec3(0)),        // two-color fast\n    Demo( .05,  .007, .003,  .3, 1, vec3(.6,.8,1),   vec3(0),         vec3(0),        vec3(0))         // ice\n);\n\nvoid initGlobals(vec3 res, vec4 state)\n{\n    Demo demo = DEMOS[int(state.w) % NUM_DEMOS];\n    Demo nextDemo = DEMOS[int(state.w + 1.) % NUM_DEMOS];\n    \n    float used = fract(state.w) > .9 ? min(demo.used, nextDemo.used) : demo.used;\n    g_MaxParticles = int(res.x * res.y * used) / NUM_PARTICLE_DATA_TYPES;\n    \n    float transition = smoothstep(.9, 1., fract(state.w));\n    g_NumColors = demo.colors;\n    g_ParticleSize = mix(demo.size, nextDemo.size, transition);\n    g_ParticleSpeed = mix(demo.speed, nextDemo.speed, transition);\n    g_ParticleTurn = mix(demo.turn, nextDemo.turn, transition);\n    g_ColorR = mix(demo.colorR, nextDemo.colorR, transition);\n    g_ColorG = mix(demo.colorG, nextDemo.colorG, transition);\n    g_ColorB = mix(demo.colorB, nextDemo.colorB, transition);\n    g_ColorA = mix(demo.colorA, nextDemo.colorA, transition);\n}\n\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes particle positions and velocities\n// ---------------------------------------------------------------------------------------\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;    \n\n    fxParticle data = fxGetParticle(id);\n    \n    if (iFrame == 0 || state.x < 0. || id >= g_MaxParticles)\n    {\n        vec3 h = hash3(uvec3(iFragCoord.x*iFragCoord.y, iFragCoord.y, iFrame*iFragCoord.x));\n        vec3 h2 = hash3(uvec3(iFragCoord.y, iFrame + int(iDate.w), iFragCoord.x));\n        data.pos = vec2(iResolution.x / iResolution.y, 1) * (h2.xy * 2. - 1.);\n        data.vel = g_ParticleSpeed*normalize((vec2(h.x, h.y) - .5));\n    }\n    else\n    {\n        // probe the density texture ahead of us, to the left and to the right\n        vec2 p = data.pos * .5 * vec2(iResolution.y / iResolution.x, 1) + .5;\n        vec4 fwdC = texture(iChannel2, p + data.vel * 2.);\n        vec2 leftV = data.vel * rot2(g_ParticleTurn);\n        vec4 leftC = texture(iChannel2, p + leftV * 3.);\n        vec2 rightV = data.vel * rot2(-g_ParticleTurn);\n        vec4 rightC = texture(iChannel2, p + rightV * 2.);\n        \n        vec4 color = colorFromId(id);\n        color = color * 2. - 1.;\n        \n        float fwd = dot(color, fwdC);\n        float left = dot(color, leftC);\n        float right = dot(color, rightC);\n\n        // turn towards our color and away from other colors\n        if (fwd < left || fwd < right)\n        {\n            if (left < right)\n            {\n                data.vel = mix(data.vel, rightV, 0.3*right / (fwd + right));\n            }\n            else\n            {\n                data.vel = mix(data.vel, leftV, 0.3*left / (fwd + left));\n            }\n        }\n\n        // always move at g_ParticleSpeed\n        if (length(data.vel) > 1e-10)\n        {\n            data.vel = normalize(data.vel) * g_ParticleSpeed;\n        }\n        else\n        {\n                    \n            vec3 h = hash3(uvec3(iFragCoord.x*iFragCoord.y, iFragCoord.y, iFrame*iFragCoord.x));\n            data.vel = g_ParticleSpeed*normalize((vec2(h.x, h.y) - .5));\n        }\n\n        // integrate position\n        data.pos = data.pos + data.vel;\n\n        // boundary\n        float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n        float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n        vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n        if (distToScene < 0.001)\n        {\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n            float dp = dot(data.vel, distNormal);\n            if (dp < 0.)\n            {\n                data.vel = reflect(data.vel, distNormal);\n            }\n        }\n\n    }\n\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Computes the nearest particles to each screen pixel\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nconst float FRAMES_PER_DEMO = 1000.;\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iResolution.x * iResolution.y != abs(state.x) || iFrame == 0 || keyDown(KEY_SPACE))\n        {\n            state = vec4(-iResolution.x * iResolution.y, .5, .5, 0);\n        }\n        else\n        {\n            state.x = abs(state.x);\n\n\n            state.w += 1. / FRAMES_PER_DEMO;\n            \n            if (keyClick(KEY_LEFT))\n            {\n                state.w = trunc(state.w - 1.);\n            }\n            if (keyClick(KEY_RIGHT))\n            {\n                state.w = trunc(state.w + 1.);\n            }\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    \n    if (iFrame > 0)\n    {\n        //in this vector the distance to these particles will be stored \n        vec4 dis = vec4(1e6);\n\n        int RANGE = 2;\n        for(int x=-RANGE; x<=RANGE; x++){\n            for(int y=-RANGE; y<=RANGE; y++){\n                ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n                for(int j=0; j<4; j++){\n                    int id = old[j];\n                    float dis2 = distance2Particle(id, screen2world(fragCoord));\n                    insertion_sort( new, dis, id, dis2 );\n                }\n            }\n        }\n\n        int searchIterations = 3;\n        if (iFrame < 5)\n        {\n            searchIterations = 10;\n        }\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n\n            int p = int(h*float(g_MaxParticles));\n            insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n        }\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Particle render\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(in fxParticle p, int id, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = linePointDist2(p.pos, p.pos - 1.5 * p.vel, fragCoord, iResolution, closest);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, g_MaxParticles);\n\n    vec4 color = colorFromId(id) *.03;\n    fragColor += color * max(0.0, g_ParticleSize - sqrt(dist)) / g_ParticleSize;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n        \n    // diffuse colors\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        vec4 n = texelFetch(iChannel2, ivec2(fragCoord) + ivec2(x, y), 0);\n        fragColor += n / (1.08 + 100.*dot(vec2(x, y), vec2(x, y)));\n    }\n\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    // draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        int id = ids[i];\n        if (id < 0 || id >= g_MaxParticles) continue;\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, id, p, fragColor);\n    }\n    \n    // reset\n    if (iFrame == 0 || state.x < 0. ||\n        (iMouse.z > 0. && distance(fragCoord, iMouse.xy) < 0.1*iResolution.y))\n    {\n        fragColor = vec4(0);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddj3RG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1074, 1074, 1127, 1127, 1518]], "test": "untested"}
{"id": "cd23zV", "name": "Tri Cylinder - sdf - practice", "author": "kanayuki", "description": "Tri Cylinder - sdf - practice", "tags": ["phong", "raymarch", "sdf", "blinn"], "likes": 4, "viewed": 196, "published": 3, "date": "1667894649", "time_retrieved": "2024-07-30T16:21:14.758886", "image_code": "# define pi 3.141592653589793238462643383279502\n\nmat2 rotateMatrix(float theta)\n{\n    return mat2(cos(theta),-sin(theta),\n                sin(theta),cos(theta));\n}\n\nfloat sdTorus(vec3 p, float r1, float r2)\n{\n    float d = length(p.xy)-r1;\n    return length(vec2(d,p.z))-r2;\n}\n\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    float d = length(p.xy)-r;\n    vec2 w = vec2(d, abs(p.z)-h);\n    return min(max(w.x,w.y), 0.0) + length(max(w,0.0));\n}\n\nfloat sdf(vec3 p) \n{\n    p.xz *= rotateMatrix(iTime);\n    p.xy *= rotateMatrix(iTime);\n    \n    // Symmetries\n    p = abs(p);\n    if(p.x>p.y) p.xy=p.yx;\n    if(p.y>p.z) p.yz=p.zy;\n    if(p.x>p.y) p.xy=p.yx;\n    \n    float cy = sdCylinder(p,0.3,3.0);\n    float t = sdTorus(p.zyx,3.0,0.5);\n     \n    return min(cy,t);\n }\n\nfloat rayMarching(vec3 raySource, vec3 direction)\n{\n    float d = 0.0;\n    for (int i=0; i<100; i++)\n    {\n        float len = sdf(raySource+direction*d);\n        if (len<0.001 || d>30.0) break;\n        d += len;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0);\n    float d = sdf(p);\n    float pdx=sdf(p+e.xyy)-d;\n    float pdy=sdf(p+e.yxy)-d;\n    float pdz=sdf(p+e.yyx)-d;\n    return normalize(vec3(pdx,pdy,pdz));\n \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y * 4.0;\n\n    vec3 col = vec3(0.75);\n    vec3 raySource = vec3(0,0,20);\n        \n    vec3 screen = vec3(uv,1.0);\n    \n    vec3 direction = normalize(screen-raySource);\n    \n    float d = rayMarching(raySource, direction );\n    if(d<30.0)\n    {\n        vec3 p = raySource+direction*d;\n        vec3 N = getNormal(p);\n        vec3 light = vec3(5,0,5);\n        // light.xz *= rotateMatrix(iTime);\n        \n        vec3 L = normalize(light-p);\n        \n        float diffuse = dot(N,L);\n        // Lambert\n        // diffuse = max(0,diffuse);\n        // Half Lambert\n        diffuse = diffuse * 0.5 + 0.5;\n         \n        \n        // Phong\n        vec3 R = normalize(2.0*N*dot(N,L)-L);\n        vec3 V = -direction;\n        // vec3 specular = 0.1*vec3(1)*pow(dot(R,V),8.0);\n        \n        // Blinn\n        vec3 H = normalize(V+L);\n        vec3 specular = 0.9*vec3(1)*pow(dot(H,N),5.0);\n        \n        \n        vec3 ambient = vec3(0.1,0.1,0.3)*1.5;\n        \n        col = vec3(1,0,1);\n        col = ambient + 0.5*col*diffuse + specular;\n    }\n    \n    // Time varying pixel color\n    // col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd23zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 81, 81, 163], [165, 165, 208, 208, 276], [278, 278, 322, 322, 444], [446, 446, 466, 466, 764], [766, 766, 817, 817, 1000], [1002, 1002, 1026, 1026, 1212], [1216, 1216, 1273, 1323, 2571]], "test": "untested"}
{"id": "mdsGDX", "name": "Parabolic Graph Drawing", "author": "mla", "description": "Drawing graphs by locally fitting a parabola & solving a cubic for the distance to the parabola.", "tags": ["line", "curve", "cubic", "parabola", "parabolic"], "likes": 10, "viewed": 251, "published": 3, "date": "1667893331", "time_retrieved": "2024-07-30T16:21:15.508881", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Parabolic Graph Drawing, mla, 2022\n//\n// Drawing a y = f(x) graph by finding the distance from (a,b) to the tangent\n// at (a,f(a)) is simple and effective for graphs that don't bend too sharply,\n// but if they do we get ugly artefacts at the bends. Using a quadratic\n// approximation to the curve at (a,f(a) works better, though it involves\n// solving a cubic to find the distance to the approximating parabola.\n//\n// The cubic solver is analytic and uses ideas from other solvers, particularly\n// by @iq and @spalmer (as well as papers by Jim Blinn & others). The solver\n// works pretty well, though it is improved, particularly on devices with \n// low-quality trig functions, by one round of Newton-Raphson (this does have\n// the potential for making the root accuracy worse, but most of the time\n// it's an improvement).\n//\n// I haven't tried to deal with discontinuous or linear functions and there is\n// a point at which the parabolic approximation has artefacts (this graph is\n// about at the limit in fact).\n//\n// <mouse>: set the position of the fitting parabola (and interpolation\n//          points) that is shown.\n// 'x': use linear fitting\n// 'a': SSAA\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nint curve = 1;\nfloat F(float x, float t) {\n  switch (curve) {\n  case 0: return 1.0/sin(x+t);\n  case 1: return 4.0*cos(0.3*(x+t))*sin(10.0*cos(x+0.382*t)+t); // The curve\n  case 2: return 8.0*abs(fract(0.43*(x+t))-0.5)-2.0; // Triangle wave from @spalmer\n  return 0.0;\n  }\n}\n\nfloat scale = 6.0;\nfloat linewidth = 0.02;\n\n// Plots a function of x based on three consecutive values.\n// This is basically (y-f(x))/|(f'(x),1)|, using an approximate derivative.\nfloat graphdist(vec2 p,float eps, float f0, float f1, float f2){\n  assert(f1 == 0.0);\n  vec2 base = vec2(0), dir = vec2(2.0*eps,f2-f0);\n  return line(p,base,dir);\n}\n\n// Match a circle - nice, except there are serious artefacts where p is close\n// to the other side of the circle.\nfloat graphdist0(vec2 p,float eps, float f0, float f1, float f2){\n  vec2 c0 = vec2(-eps,f0), c2 = vec2(eps,f2);\n  vec3 circle = cross(vec3(c0,dot(c0,c0)), vec3(c2,dot(c2,c2)));\n  circle /= length(circle.xy);\n  return abs(dot(circle.xy,p)+circle.z*dot(p,p));\n}\n\n// sgn is not sign\nfloat sgn(float p) { return p < 0.0 ? -1.0 : 1.0; }\nfloat cuberoot(float x) { return sgn(x)*pow(abs(x),1.0/3.0); }\n\n// Solve the reduced cubic x³+px+q = 0 and return the largest real root.\nfloat solvecubic(float p, float q) {\n  p /= 3.0, q /= -2.0;    // Simplifies the algebra\n  float h = q*q + p*p*p;  // Discriminant\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = q+sgn(q)*r; // Largest magnitude root\n    float t = cuberoot(u);\n    return t - p/t;\n  } else {\n    // Find real part of 'principal' cube root of -q+ir\n    float theta = atan(r,q);               // 0 <= theta < PI since r >= 0 - could use -r\n    float k = 2.0*sqrt(abs(p));\n    //return k*cos((theta+vec3(0,2,4)*PI)/3.0); // All roots\n    return k*cos(theta/3.0); // Largest root wanted here\n  }\n}\n\n// sdParabola based on a function by @iq\nfloat sdParabola(vec2 pos, in float k ) {\n  pos.x = abs(pos.x); // Ensure largest root is nearest\n  float ik = 1.0/k;\n  float p = -ik*(pos.y - 0.5*ik);\n  float q = -0.5*ik*ik*pos.x;\n  float x = solvecubic(p,q);\n  for (int i = 0; i < 1; i++) {\n    // A quick polishing for the root. This makes hardly any difference in\n    // this shader, except very slightly when the graph is nearly linear.\n    float fx = q+x*(p+x*x);\n    float dx = p+3.0*x*x;\n    x -= fx/dx;\n  } \n  return length(pos-vec2(x,k*x*x));\n}\n\nfloat graphdist2(vec2 p, float eps, float y0, float y1, float y2) { \n  assert(y1 == 0.0);\n  if (key(CHAR_X) || abs(y0+y2)<1e-4) return graphdist(p,eps,y0,y1,y2);\n  // Parabolic approximation: y = Ax²+ Bx\n  // so y0 = A.eps²-B.eps, y2 = A.eps²+B.eps\n  float A = 0.5*(y2+y0)/(eps*eps);\n  float B = 0.5*(y2-y0)/eps; // For reference\n  // Change of variable\n  float k = 0.5*(y2-y0)/(y2+y0);\n  float d = abs(sdParabola(p+vec2(eps*k,0.25*(y2-y0)*k),A));\n  return d;\n}\n\nvec2 map(vec2 coords) {\n  vec2 uv = (2.0*coords - iResolution.xy)/iResolution.y;\n  uv *= scale;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float t = iTime;\n  vec2 uv = map(fragCoord);\n  vec2 mouse = vec2(0);\n  bool domouse = true; //iMouse.x > 10.0;\n  if (iMouse.x > 0.0) mouse = map(iMouse.xy);\n  float x = uv.x, y = uv.y;\n  float px = fwidth(x);\n  assert(px >0.);\n  float a = mouse.x;\n\n  //col = mix(vec3(0.1),col,smoothstep(0.0,px,abs(y)-0.25*lwidth)); // Axes\n  float eps = 4.0*scale/iResolution.y; // Power of 2 may be better\n  vec3 aacol = vec3(0);\n  int N = 2; // SSAA\n  if (key(CHAR_A)) N = 1;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      vec3 col = vec3(0.5);\n      vec2 uv = map(fragCoord+vec2(i,j)/float(N)); // Remap fragCoord\n      float x = uv.x, y = uv.y;\n      float y0 = F(x-eps,t), y1 = F(x,t), y2 = F(x+eps,t);\n      float d = graphdist2(vec2(0,y-y1),eps,y0-y1,0.0,y2-y1);\n      //col *= 0.5+0.5*cos(4.0*PI*d);\n      col = mix(vec3(0),col,smoothstep(0.0,px,d-1.5*linewidth));\n      col = mix(vec3(1,0,0),col,smoothstep(0.0,px,d-1.5*linewidth));\n      col = mix(vec3(1),col,smoothstep(0.0,px,d));\n      if (domouse) {\n        float y0 = F(a-eps,t), y1 = F(a,t), y2 = F(a+eps,t);\n        vec2 p = vec2(x-a,y-y1);\n        float d = graphdist2(p,eps,y0-y1,y1-y1,y2-y1);\n        col = mix(vec3(0.0),col,smoothstep(0.0,px,d-0.5*linewidth));\n        d = 1e8;\n        d = min(d,distance(p,vec2(-eps,y0-y1)));\n        d = min(d,distance(p,vec2(0)));\n        d = min(d,distance(p,vec2(eps,y2-y1)));\n        col = mix(vec3(1),col,smoothstep(0.0,px,d-1.5*linewidth));\n      }\n      aacol += col;\n    }\n  }\n  aacol /= float(N*N);\n  aacol = pow(aacol,vec3(0.4545));\n  if (alert) aacol.g = 1.0;\n  fragColor = vec4(aacol,1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.1415927;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  //h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\nconst int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1353, 1353, 1380, 1380, 1611], [1657, 1793, 1857, 1857, 1957], [1959, 2073, 2138, 2138, 2332], [2334, 2353, 2373, 2373, 2404], [2405, 2405, 2430, 2430, 2467], [2469, 2543, 2579, 2579, 3129], [3131, 3172, 3213, 3213, 3676], [3678, 3678, 3745, 3745, 4142], [4144, 4144, 4167, 4167, 4254], [4256, 4256, 4313, 4313, 5935]], "test": "untested"}
{"id": "cd2GzK", "name": "Precise Sampling Order", "author": "Hatchling", "description": "Creating an algorithm to get the nearest neighbor to an occupied pixel.\nPart of this algorithm involves a creating a fast way to calculate the nearest N integer coordinates from a given central coordinate.\nUse the mouse to test this part of the algorithm.", "tags": ["2d", "sdf", "distance", "field"], "likes": 3, "viewed": 202, "published": 3, "date": "1667886046", "time_retrieved": "2024-07-30T16:21:16.436401", "image_code": "const ivec2 TestImageSize = ivec2(16,9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//debugAllData(DATA, fragColor, fragCoord / vec2(1, 100));\n    //return;\n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    \n    for(int iCoord = 0; iCoord < SamplingOrderCount; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord + GetSamplingOrderCoord(iCoord, DATA).xy;\n        \n        if(fragTestIntCoord != samplingCoord)\n            continue;\n            \n        float hue = float(iCoord) / float(SamplingOrderCount);\n        \n        fragColor.rgb = hsv2rgb(vec3(hue, 1.0, 1.0));\n        return;\n    }\n    \n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}", "buffer_d_code": "// Cached data buffer.\n// Things that only need to be calculated once will be stored here.\n\nvoid getSamplingCoords(out ivec3 coords[SamplingOrderCount], int maxIndex)\n{\n    // coordinate:\n    // x, y: position\n    // z:    layer\n    \n    // NOTE: SamplingOrderCount and maxIndex are evaluated\n    // separately in hopes that the compiler\n    // will unroll the for loops\n    // and break early given one of the\n    // arguments is a constant.\n    // If we combine the two limits,\n    // it might be dumb and assume that\n    // the breaking condition is non-constant\n    // and therefore,\n    // there is no definite upper bound\n    // to the number of iterations,\n    // thus preventing the loop from being unrolled.\n    \n    int iCoord = 0;\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    coords[iCoord++] = ivec3(0);\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    for(int iLayer = 1; ; iLayer++)\n    {\n        // Add primaries (left, right, down, up).\n        {\n            ivec3 swizzler = ivec3(-iLayer, iLayer, 0);\n            \n            coords[iCoord++] = ivec3(swizzler.xzy); // left\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzy); // right\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zxy); // bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyy); // top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add coordinates between corners and primaries.\n        for(int iMinor = 1; iMinor < iLayer; iMinor++)\n        {\n            // iLayer = length of longer (major) arm.\n            // iMinor = length of shorter (minor) arm.\n            \n            ivec4 swizzler = ivec4(iLayer, iMinor, -iLayer, -iMinor);\n            \n            coords[iCoord++] = ivec3(swizzler.xyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            \n            coords[iCoord++] = ivec3(swizzler.yxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add corners.\n        {\n            ivec2 swizzler = ivec2(-iLayer, iLayer);\n            \n            coords[iCoord++] = ivec3(swizzler.xxy); // left bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xyy); // left top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yxy); // right bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yyy); // right top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n    }\n}\n\n\nvoid UpdateSamplingOrderData( out vec4 fragColor, in ivec2 iCoord )\n{\n    switch(iFrame)\n    {\n        case SamplingOrderFrameImprecise:\n        {\n            ivec3 coords[SamplingOrderCount];\n            int coordComputeCount = min(SamplingOrderCount, iCoord.x+1);\n            getSamplingCoords(coords, coordComputeCount);\n            fragColor.xyz = vec3(coords[coordComputeCount-1]);\n            fragColor.w = 1.0;\n            return;\n        }\n        case SamplingOrderFramePrecise:\n        {\n        \nint n = min(SamplingOrderCount, iCoord.x+1);\nint maxN = min(SamplingOrderCount, int(float(n)*1.5));\nivec3 closestNCoords[SamplingOrderCount];\nfloat closestNDistances[SamplingOrderCount];\nint closestNIndices[SamplingOrderCount];\nint closestNCount = 0;\n\n// TODO: Skip more comparisons by better exploiting\n//       the fact the list is already\n//       semi-sorted.\n\nfor(int thisIndex = 0; thisIndex < maxN; thisIndex++)\n{\n    ivec3 thisCoord = GetSamplingOrderCoord(thisIndex, DATA);\n    float thisDist = GetSamplingDistance(thisIndex, DATA);\n    if(closestNCount < n)\n    {\n        // Add it to the list.\n        closestNCoords[closestNCount] = thisCoord;\n        closestNDistances[closestNCount] = thisDist;\n        closestNIndices[closestNCount] = thisIndex;\n        closestNCount++;\n    }\n    else\n    {\n        // Replace the furthest one in the list if it is better.\n        \n        int elementToReplace = 0;\n        int furthestIndex = closestNIndices[0];\n        float furthestDistance = closestNDistances[0];\n        {\n            for(int j = 1; j < n; j++)\n            {\n                if(furthestDistance < closestNDistances[j])\n                {\n                    elementToReplace = j;\n                    furthestIndex = closestNIndices[j];\n                    furthestDistance = closestNDistances[j];\n                }\n                else if(furthestDistance == closestNDistances[j])\n                {\n                    // In the case where distances are identical,\n                    // use their position in the original list instead.\n                    // This ensures that all elements have\n                    // a unique rank and thus are kept.\n                    if(furthestIndex < closestNIndices[j])\n                    {\n                        elementToReplace = j;\n                        furthestIndex = closestNIndices[j];\n                        furthestDistance = closestNDistances[j];\n                    }\n                }\n            }\n        }\n        \n        if(thisDist < furthestDistance)\n        {   \n            closestNCoords[elementToReplace] = thisCoord;\n            closestNDistances[elementToReplace] = thisDist;\n            closestNIndices[elementToReplace] = thisIndex;\n        }\n        else if(thisDist == furthestDistance)\n        {\n            // In the case where distances are identical,\n            // use their position in the original list instead.\n            // This ensures that all elements have\n            // a unique rank and thus are kept.\n            if(thisIndex < furthestIndex)\n            {\n                closestNCoords[elementToReplace] = thisCoord;\n                closestNDistances[elementToReplace] = thisDist;\n                closestNIndices[elementToReplace] = thisIndex;\n            }\n        }\n    }\n}\n\n// Our list contains the N closest coordinates.\n// The furthest in this list is the Nth closest element.\n// This will be the coordinate for this fragment.\nint resultElement = 0;\n{\n    int furthestIndex = closestNIndices[0];\n    float furthestDistance = closestNDistances[0];\n    {\n        for(int j = 1; j < n; j++)\n        {\n            if(furthestDistance < closestNDistances[j])\n            {\n                resultElement = j;\n                furthestIndex = closestNIndices[j];\n                furthestDistance = closestNDistances[j];\n            }\n            else if(furthestDistance == closestNDistances[j])\n            {\n                // In the case where distances are identical,\n                // use their position in the original list instead.\n                // This ensures that all elements have\n                // a unique rank and thus are kept.\n                if(furthestIndex < closestNIndices[j])\n                {\n                    resultElement = j;\n                    furthestIndex = closestNIndices[j];\n                    furthestDistance = closestNDistances[j];\n                }\n            }\n        }\n    }\n}\n\n\n            fragColor.xyz = vec3(closestNCoords[resultElement]);\n            fragColor.w = 1.0;\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\nfloat MinimumDistanceBetweenSquares(in ivec2 p1, in ivec2 p2)\n{\n    vec2 p1Center = vec2(p1) + vec2(0.5);\n    vec2 p2Center = vec2(p2) + vec2(0.5);\n    vec2 p1ToP2 = p2Center - p1Center;\n    vec2 offset = clamp(p1ToP2, vec2(-1.0), vec2(1.0));\n    return lengthSqr(p1ToP2 - offset);\n}\n\nvoid UpdateSamplingDistanceData( out vec4 fragColor, in ivec2 iCoord )\n{\n    switch(iFrame)\n    {\n        case SamplingDistanceFrameImprecise:\n        case SamplingDistanceFramePrecise:\n        {\n            ivec2 neighbor = GetSamplingOrderCoord(iCoord.x, DATA).xy;\n            ivec2 me = ivec2(0);\n            fragColor = vec4(0);\n            fragColor.x = MinimumDistanceBetweenSquares(me, neighbor);\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: UpdateSamplingOrderData(fragColor, iCoord); return;\n        case SamplingDistanceRow: UpdateSamplingDistanceData(fragColor, iCoord); return;\n    }\n    \n    fragColor = texelFetch(DATA, iCoord, 0);\n}\n\n\n\n", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2GzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 99, 173, 945]], "test": "untested"}
{"id": "cdj3RK", "name": "Sampling Order (Cached)", "author": "Hatchling", "description": "Creating an algorithm to get the nearest neighbor to an occupied pixel.\nPart of this algorithm involves a creating a fast way to calculate the nearest N integer coordinates from a given central coordinate.\nUse the mouse to test this part of the algorithm.", "tags": ["2d", "sdf", "distance", "field"], "likes": 1, "viewed": 149, "published": 3, "date": "1667877640", "time_retrieved": "2024-07-30T16:21:17.271170", "image_code": "const ivec2 TestImageSize = ivec2(16,9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//debugAllData(DATA, fragColor, fragCoord);\n    //return;\n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    \n    for(int iCoord = 0; iCoord < SamplingOrderCount; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord + GetSamplingOrderCoord(iCoord, DATA).xy;\n        \n        if(fragTestIntCoord != samplingCoord)\n            continue;\n            \n        float hue = float(iCoord) / float(SamplingOrderCount);\n        \n        fragColor.rgb = hsv2rgb(vec3(hue, 1.0, 1.0));\n        return;\n    }\n    \n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}\n\n// Sampling Order -------------------------------\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n", "buffer_d_code": "// Cached data buffer.\n// Things that only need to be calculated once will be stored here.\n\nvoid getSamplingCoords(out ivec3 coords[SamplingOrderCount], int maxIndex)\n{\n    // coordinate:\n    // x, y: position\n    // z:    layer\n    \n    // NOTE: SamplingOrderCount and maxIndex are evaluated\n    // separately in hopes that the compiler\n    // will unroll the for loops\n    // and break early given one of the\n    // arguments is a constant.\n    // If we combine the two limits,\n    // it might be dumb and assume that\n    // the breaking condition is non-constant\n    // and therefore,\n    // there is no definite upper bound\n    // to the number of iterations,\n    // thus preventing the loop from being unrolled.\n    \n    int iCoord = 0;\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    coords[iCoord++] = ivec3(0);\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    for(int iLayer = 1; ; iLayer++)\n    {\n        // Add primaries (left, right, down, up).\n        {\n            ivec3 swizzler = ivec3(-iLayer, iLayer, 0);\n            \n            coords[iCoord++] = ivec3(swizzler.xzy); // left\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzy); // right\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zxy); // bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyy); // top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add coordinates between corners and primaries.\n        for(int iMinor = 1; iMinor < iLayer; iMinor++)\n        {\n            // iLayer = length of longer (major) arm.\n            // iMinor = length of shorter (minor) arm.\n            \n            ivec4 swizzler = ivec4(iLayer, iMinor, -iLayer, -iMinor);\n            \n            coords[iCoord++] = ivec3(swizzler.xyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            \n            coords[iCoord++] = ivec3(swizzler.yxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add corners.\n        {\n            ivec2 swizzler = ivec2(-iLayer, iLayer);\n            \n            coords[iCoord++] = ivec3(swizzler.xxy); // left bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xyy); // left top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yxy); // right bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yyy); // right top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n    }\n}\n\nvoid UpdateSamplingOrderData( out vec4 fragColor, in ivec2 iCoord )\n{\n    if(iFrame != 0)\n    {\n        fragColor = texelFetch(iChannel0, iCoord, 0);\n        return;\n    }\n\n    ivec3 coords[SamplingOrderCount];\n    int coordComputeCount = min(SamplingOrderCount, iCoord.x+1);\n    getSamplingCoords(coords, coordComputeCount);\n    fragColor.xyz = vec3(coords[coordComputeCount-1]);\n    fragColor.w = 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow:\n        {\n            UpdateSamplingOrderData(fragColor, iCoord);\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(iChannel0, iCoord, 0);\n}\n\n\n\n", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdj3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 99, 158, 930]], "test": "untested"}
{"id": "msB3zV", "name": "Sampling Order", "author": "Hatchling", "description": "Creating an algorithm to get the nearest neighbor to an occupied pixel.\nPart of this algorithm involves a creating a fast way to calculate the nearest N integer coordinates from a given central coordinate.\nUse the mouse to test this part of the algorithm.", "tags": ["2d", "sdf", "distance", "field"], "likes": 1, "viewed": 155, "published": 3, "date": "1667875558", "time_retrieved": "2024-07-30T16:21:18.013185", "image_code": "\nconst int coordCount = 100;\n\nvoid getSamplingCoords(out ivec3 coords[coordCount])\n{\n    // coordinate:\n    // x, y: position\n    // z:    layer\n    \n    int iCoord = 0;\n    \n    coords[iCoord++] = ivec3(0);\n    if(iCoord>=coordCount) return;\n    \n    for(int iLayer = 1; ; iLayer++)\n    {\n        // Add primaries (left, right, down, up).\n        {\n            ivec3 swizzler = ivec3(-iLayer, iLayer, 0);\n            \n            coords[iCoord++] = ivec3(swizzler.xzy); // left\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yzy); // right\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zxy); // bottom\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zyy); // top\n            if(iCoord>=coordCount) return;\n        }\n        \n        // Add coordinates between corners and primaries.\n        for(int iMinor = 1; iMinor < iLayer; iMinor++)\n        {\n            // iLayer = length of longer (major) arm.\n            // iMinor = length of shorter (minor) arm.\n            \n            ivec4 swizzler = ivec4(iLayer, iMinor, -iLayer, -iMinor);\n            \n            coords[iCoord++] = ivec3(swizzler.xyx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.xwx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zyx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zwx);\n            if(iCoord>=coordCount) return;\n            \n            coords[iCoord++] = ivec3(swizzler.yxx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.wxx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yzx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.wzx);\n            if(iCoord>=coordCount) return;\n        }\n        \n        // Add corners.\n        {\n            ivec2 swizzler = ivec2(-iLayer, iLayer);\n            \n            coords[iCoord++] = ivec3(swizzler.xxy); // left bottom\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.xyy); // left top\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yxy); // right bottom\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yyy); // right top\n            if(iCoord>=coordCount) return;\n        }\n        \n    }\n}\n\nconst ivec2 TestImageSize = ivec2(16,9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    \n\tivec3 coords[coordCount];\n    getSamplingCoords(coords);\n    \n    for(int iCoord = 0; iCoord < coordCount; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord + coords[iCoord].xy;\n        \n        if(fragTestIntCoord != samplingCoord)\n            continue;\n            \n        float hue = float(iCoord) / float(coordCount);\n        \n        fragColor.rgb = hsv2rgb(vec3(hue, 1.0, 1.0));\n        return;\n    }\n    \n\t\n}\n", "image_inputs": [], "common_code": "float dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msB3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 84, 144, 2534], [2578, 2578, 2635, 2635, 3430]], "test": "untested"}
{"id": "mdB3zV", "name": "Reaction Diffusion Fluid", "author": "wyatt", "description": "Fluid reaction diffusion ", "tags": ["fluid"], "likes": 27, "viewed": 305, "published": 3, "date": "1667873102", "time_retrieved": "2024-07-30T16:21:18.854934", "image_code": "\nMain {\n    Q = 2.*A(U).wwww;\n    Q.xy *= A(U).z;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n            #define r 1.5\n#define N 25.\n#define S vec4(3.)\n#define G(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n", "buffer_a_code": "Main {\nQ = vec4(0);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n        Q.xyz += m*a.w*a.xyz;\n        Q.w += m*a.w;\n    }\n    if (Q.w>0.)\n        Q.xyz/=Q.w;\n        Q.z = mix(Q.z,sign(Q.z),.01);\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,sign(U.y/R.y*2.-1.),0);\n        Q.w = .2+.1*sin(.1*U.x)*sin(.1*U.y);\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = vec4(0);\n    for (float i = -N; i <= N; i++) {\n        Q += G(i)*A(U+vec2(0,i)).w;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = vec4(0);\n    for (float i = -N; i <= N; i++) {\n        Q += G(i)*A(U+vec2(i,0));\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u);\n        Q.xy -= q.w*0.125*(.5*b.x+a.w*(a.w-1.))*u;\n    }\n    Q.y -= .1*Q.z/R.y;\n    Q.xy *= .999;\n    \n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdB3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "msS3zV", "name": "Min/Max Distance to Pixel", "author": "Hatchling", "description": "Creating an algorithm to get the nearest neighbor to an occupied pixel.\nPart of that involves getting the range of distances a given block of pixels occupies to see if they can be skipped.\nUse the mouse to test this part of the algorithm.", "tags": ["2d", "sdf", "distance", "field"], "likes": 1, "viewed": 169, "published": 3, "date": "1667872840", "time_retrieved": "2024-07-30T16:21:19.598945", "image_code": "// Returns the minimum and maximum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec2 getMinMaxDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    \n    vec2 dirToCenter = squareCenter - point;\n    \n    vec2 minOffset = clamp(dirToCenter, vec2(-0.5), vec2(0.5)) * -1.0;\n    \n    vec2 maxOffset = vec2\n    (\n        dirToCenter.x < 0. ? -0.5 : 0.5,\n        dirToCenter.y < 0. ? -0.5 : 0.5\n    );\n    \n    vec2 distances = vec2\n    (\n        lengthSqr(dirToCenter + minOffset),\n        lengthSqr(dirToCenter + maxOffset)\n    );\n    \n    return distances;\n}\n\n\nconst ivec2 TestImageSize = ivec2(16,9);\nconst ivec2 TestImagePixel = ivec2(8, 5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    bool fragInTestPixel = floorToInt(fragTestCoord) == TestImagePixel;\n    \n    fragColor = fragInTestPixel ? vec4(1) : vec4(0);\n    \n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    \n    vec2 distancesToPixelSqr = getMinMaxDistSqr(mouseTestCoord, TestImagePixel);\n    \n    float distanceToMouseSqr = distSqr(fragTestCoord, mouseTestCoord);\n    \n    vec2 circles = clamp\n    (\n        vec2(1.0) - abs(sqrt(distancesToPixelSqr) - sqrt(vec2(distanceToMouseSqr))) * 25.0, \n        vec2(0.0), \n        vec2(1.0)\n    );\n    \n    fragColor.xy = circles;\n\t\n}\n", "image_inputs": [], "common_code": "float dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msS3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 144, 192, 192, 652], [739, 739, 796, 796, 1514]], "test": "untested"}
{"id": "ddB3zV", "name": "LDN001", "author": "antoinefortin", "description": "whatever, made it on the plane", "tags": ["whatever"], "likes": 5, "viewed": 173, "published": 3, "date": "1667872244", "time_retrieved": "2024-07-30T16:21:20.349937", "image_code": "float drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\nvec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(0.0f);\n    vec3 col2 = vec3(0.0f);\n    float radius = .5f;\n    float tt = iTime;\n       uv.y += .15;\n       \n    vec3 l1 = vec3(0.0f);\n        vec3 l2 = vec3(0.0f);\n    for(int i = 0; i < 25; i++)\n    {\n        l1 += vec3(\n        drawLine(\n        vec2(0.0, 0.0), \n        vec2( radius * sin(tt + float(i)), \n        (cos(uv.y * 2.7) - radius * cos(tt + float(i)))) - .15, \n        uv - vec2(0.0,0.0f), \n        1.0));\n        \n        \n        l2 += vec3(\n        drawLine(\n        vec2(0.0, 0.0), \n        vec2( radius * sin(tt - float(i)), \n        (sin(uv.x * 1.7) - radius * sin(tt - float(i)))) - .15, \n        uv - vec2(0.0,0.0f), \n        1.0));\n        \n    }\n    \n    \n    //col += vec3(drawLine(vec2(0.0, 0.0), vec2( radius * sin(tt + 2.0f),radius * cos(tt + 2.0f)), uv, 2.5));\n    l1 = clamp(l1, 0.0f, 1.0f);\n    l2 = clamp(l2, 0.0f, 1.0f);\n    \n    vec3 cc = l1 * vec3(abs(uv.x) * 22. + abs(uv.y), uv.y, 0.0f);\n    cc += l2;\n\n    // Output to screen\n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddB3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 465], [468, 468, 525, 575, 1683]], "test": "untested"}
{"id": "ddSGzV", "name": "Vines and thorns (3D)", "author": "jarble", "description": "A plant-like fractal structure.", "tags": ["3d", "fractal"], "likes": 7, "viewed": 237, "published": 3, "date": "1667867626", "time_retrieved": "2024-07-30T16:21:21.115889", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 stars(vec3 uv)\n{\n    vec3 col = vec3(0.);\n    for(int k = 0; k < 6; k++){ \n        vec3 offset =\n            (vec3(uv.y+uv.x+.5,uv.z+uv.y+.5,uv.x+uv.z))\n            //vec3(uv.y-uv.x+.5,uv.z-uv.y+.5,uv.x+uv.z)\n        ;\n        uv =\n            min(offset.yzx+uv.yzx,abs(fract(offset)-.5))\n        ;\n        \n        //uv += abs(fract(uv*4.+iTime)-.5)/64.;\n\n        \n        col = vec3(col.yz,uv.x-uv.y).yzx;\n    }\n    \n    return\n        col.yzx\n        //col - uv;\n    ;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(4.,2.5,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = stars(p/16.);\n        float sd1 = col.z-.12;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 mainSound(int samp, float t){\n  \n  float s1 =\n      8.,\n  m1 =\n      //fmod(t*s1,s1),\n      fmod(floor(t*s1)+floor(t*s1/2.)+floor(t*s1/4.),s1),\n  z1 =\n      //(1.+fmod(t/s1,2.))\n      (1.+fmod(floor(t/s1)+floor(t/s1*2.)+floor(t/s1*4.),2.))\n  ;\n  t /= z1;\n  t /=\n      1.+fmod(floor(t)*floor(t/s1+z1),2.)\n  ;\n  \n  float m3 =\n      fmod((t)/(m1+.5),s1)\n  ;\n  \n  t *=\n      1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n  ;\n  t /= z1;\n\n  float a=sqrt((1.-sqrt(fract(t*s1))))*.2,\n\n  nb = pow(2.,(m3+z1)/5.+7.5);\n\n  return abs(.5-vec2(fract(t*nb*.998)\n   ,fract(t*nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 275, 275, 732], [734, 734, 775, 775, 1315]], "test": "untested"}
{"id": "mdSGzK", "name": "Quite nice smoke", "author": "larserik", "description": "First time I achieved semi-realistic smoke. 👼", "tags": ["noise", "fbm", "simplex", "smoke"], "likes": 13, "viewed": 569, "published": 3, "date": "1667857781", "time_retrieved": "2024-07-30T16:21:21.918743", "image_code": "float speed = .3;\nfloat scale = 2.2;\nint octaves = 4;\nbool turbulence = false;\nfloat shift = .3;\nfloat startAmp = .8;\n\nfloat fbm (in vec3 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = startAmp;\n    float frequency = 0.;\n\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float time = iTime * speed;\n    float plainY = uv.y + .5;\n\n    uv *= scale;\n\n    float mag = .2;\n\n    float n = fbm(vec3(uv, time*.2));\n    n = fbm(vec3(uv - time*.2, n * mag + time*.1));\n    n = fbm(vec3(uv - time*.4, n * mag + time*.2));\n\n    if (turbulence) {\n        n = abs(n);\n    } else {\n        n = n*.5 + .5;\n    }\n\n    n = pow(n, shift + plainY * (1.-shift));\n    n *= 1. - plainY;\n\n    vec3 color = vec3(n*.98, n*.95, n*.997);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "// Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 143, 165, 420], [422, 422, 479, 479, 1021]], "test": "untested"}
{"id": "DsS3zV", "name": "Blue and yellow stars (3D)", "author": "jarble", "description": "An endless series of blue and yellow fractal stars.", "tags": ["3d", "fractal"], "likes": 7, "viewed": 240, "published": 3, "date": "1667848800", "time_retrieved": "2024-07-30T16:21:22.812353", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 stars(vec3 uv)\n{\n    vec3 col = vec3(0.);\n    for(int k = 0; k < 6; k++){ \n        vec3 offset =\n            //(vec3(uv.x-.45,uv.y+.45,uv.z-uv.x))\n            vec3(uv.y+uv.x+.5,uv.z+uv.y+.5,uv.x+uv.z)\n            //vec3(uv.y-uv.x+1.5,uv.z-uv.y+1.5,uv.x+uv.z)\n\n            //vec3(uv.y-uv.x+.5,uv.z-uv.y+.5,uv.x+uv.z)\n            //vec3(uv.y+uv.x-.25,uv.z+uv.y+.25,uv.x+uv.z)\n        ;\n        uv =\n            min(offset+uv,abs(fract(offset)-.5))\n        ;\n        \n        //uv += abs(fract(uv*4.+iTime)-.5)/64.;\n\n        col = vec3(col.yz,uv.x-uv.y);\n    }\n    \n    return\n        col\n        //col - uv;\n    ;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,6,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = stars(p/16.);\n        float sd1 = col.z-.14;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 mainSound(int samp, float t){\n  t += 1.;\n  float s1 =\n      8.,\n  m2 = floor(t/s1)+floor(t),\n  m4 = floor(t*s1)+floor(t),\n  m3 =\n      fmod(mod(m4,m2),s1)\n  ;\n  t /=\n      1.+fmod(m2,2.)\n  ;\n      \n      \n  float a=sqrt((1.-sqrt(fract(t))))*.2,\n\n  nb = pow(2.,(m3)/5.+7.5);\n\n  return abs(.5-vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a));\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsS3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 275, 275, 872], [874, 874, 915, 915, 1452]], "test": "untested"}
{"id": "ddS3zG", "name": "My first pathtracing scene", "author": "kishimisu", "description": "Move the camera with the mouse", "tags": ["lighting", "bounce", "occlusion", "indirect", "sample", "ambient", "tracer", "path", "monte", "carlo"], "likes": 18, "viewed": 491, "published": 3, "date": "1667848237", "time_retrieved": "2024-07-30T16:21:23.605233", "image_code": "/* I'm currently learning to implement path-tracing by following this article:\n   https://iquilezles.org/articles/simplepathtracing/\n   \n   * Left image has nice anti-aliasing and indirect lighting \n     thanks to path-tracing with 4 bounces.\n   \n   * Right image is regular raymarching with direct lighting only.\n   \n   * Move the camera to reset the accumulated samples.\n   \n   There is only one point light source, no sky or sun light.\n   I'm not sure if the randomness of ray directions is working correctly\n   as we can see patterns in the noise when moving the camera.\n   \n   I might need to work a bit more on this before learning about\n   importance sampling!\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    float t = texelFetch(iChannel0, ivec2(0.5, 0.5), 0).r;\n    \n    col /= 1. + float(iFrame) - t;\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BOUNCES 4\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define hash(p) fract(sin(p)*43758.5453)\n#define hash33(p) fract(sin((p) * mat3(127.1,311.7,74.7, 269.5,183.3,246.1, 113.5,271.9,124.6))*43758.5453123)\n\nvec3 lightPos = vec3(0., 1.4, 0.);\nvec3 groundColor = vec3(.9, .8, .7);\n\nfloat sdBox(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.0;\n}\n\nvec2 scene(vec3 p) {\n    float ground = p.y + .2;\n    \n    vec3 p0 = p;\n    p.xz = fract(p.xz+.5)-.5;\n    float boxes = sdBox(p, vec3(.2, .2 + length(sin(floor(p0+.5)*8.))*.1, .35))/2.;\n  \n    if (boxes < ground) return vec2(boxes, 1.);\n    return vec2(ground, 0.);\n}\n\nvec3 cosineDirection(float seed, vec3 nor) {\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nvec2 worldIntersect(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t*rd;\n        vec2 d = scene(p);\n        t += d.x;\n        \n        if (d.x < 0.01) return vec2(t, d.y);\n        if (t > maxt) break;\n    }\n    return vec2(-1.);\n}\n\nfloat worldShadow(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t*rd;\n        \n        float d = scene(p).x;\n        t += d;\n        \n        if (d < 0.01) return 0.;\n        if (t > maxt) break;\n    }\n    return 1.;\n}\n\nvec3 worldGetNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ).x + k.yyx*scene( p + k.yyx*h ).x + \n                      k.yxy*scene( p + k.yxy*h ).x + k.xxx*scene( p + k.xxx*h ).x );\n}\n\nvec3 worldApplyLighting(vec3 p, vec3 nor) {\n    vec3 lightDir = normalize(lightPos - p);\n    float lightDist = length(lightPos - p);\n    float diffuse = clamp(dot(nor, lightDir), 0., 1.);\n    float shadow = worldShadow(p, lightDir, lightDist);\n    float att = clamp(1./pow(lightDist*.4, 2.), 0., 1.);\n    \n    return vec3(diffuse * shadow * att);\n}\n\nvec3 worldGetColor(vec3 p, float objectID) {\n    if (objectID == 0.) return groundColor;\n    else {\n        vec3 fp = floor(p-vec3(.5,0.,.5));\n        if (fp.xz == vec2(-1.)) return vec3(1.);\n        return sin(vec3(.02,.04,.06)*fp*1000.)*.5+.5;\n    }\n}\n\nvec3 worldGetBackground(vec3 rd) {\n    return rd.y * vec3(.4, .4, .5);\n}\n\n#define isLightCube(p) floor(p-.5).xz == vec2(-1.)\nvec3 renderPixel(vec3 ro, vec3 rd, float sa, bool renderRaymarching) {\n    vec3 tcol = vec3(0.0);\n    vec3 fcol = vec3(1.0);\n  \n    for (int i = 0; i < BOUNCES; i++) {\n        vec2 res = worldIntersect(ro, rd, 30.);\n    \n        if (res.y < 0.) {\n            if (i == 0) return worldGetBackground(rd);\n            break;\n        }\n        \n        vec3 p = ro + (res.x-.02)*rd;\n        vec3 n = worldGetNormal(p);\n\n        vec3 scol = worldGetColor(p, res.y);\n        vec3 dcol = (res.y == 1. && isLightCube(p)) ? vec3(1.) : worldApplyLighting(p, n);\n\n        ro = p;\n        rd = cosineDirection(76.2 + 73.1*float(i) + sa + 17.7*float(iFrame), n);\n\n        fcol *= scol;\n        tcol += fcol * dcol; \n\n        if (renderRaymarching) break;\n    }\n    \n    return tcol;\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.;\n    \n    float z = iMouse.z > 0. ? 1. : smoothstep(0., 6., iTime);\n    ro = vec3(0., 0., iMouse.z == 0. ? 4. : 4. - 1.+(m.y*.5+.5)); \n    ro.yz *= rot(iMouse.z == 0. ? -0.3 : (m.y-.9)*.5);\n    ro.zx *= rot(iMouse.z == 0. ? -5.6 : m.x*2.);\n        \n    vec3 f = normalize(-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    if (iMouse.z > 0. || iFrame == 0) color *= 0.;\n    \n    bool renderRaymarching = fragCoord.x/iResolution.x > .5;\n    float sa = renderRaymarching ? 0. : hash(dot(fragCoord, vec2(12.9898, 78.233)) + 1113.1*iTime);\n    \n    vec2 of = (vec2( hash(sa+13.271), hash(sa+63.216) )-0.5);\n    vec2 uv = (fragCoord+of - .5*iResolution.xy)/iResolution.y;\n\n    vec3 ro, rd;\n    initRayOriginAndDirection(uv, ro, rd);\n    \n    color += renderPixel(ro, rd, sa, renderRaymarching);\n    color *= smoothstep(0.003, .004, abs(fragCoord.x/iResolution.x - .5));\n\n    if (fragCoord == vec2(0.5, 0.5) && iMouse.z > 0.) color.r = float(iFrame);\n    \n    fragColor.rgb = color;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddS3zG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[672, 672, 729, 729, 964]], "test": "untested"}
{"id": "Dd23zy", "name": "Clouds with walking and flying", "author": "ilia87", "description": "Use the mouse to look around. WASD to move. Shift to run. Press Space to detach from ground while moving", "tags": ["clouds"], "likes": 1, "viewed": 224, "published": 3, "date": "1667844086", "time_retrieved": "2024-07-30T16:21:24.643458", "image_code": "#define FBM_ORDER 6\nvec3 camPos;\nvec3 L;\nconst mat2 m2 = mat2(.6,.8,-.8,.6);\nconst mat3 m3 = mat3(0.7213075,  0.0909291,  0.6866202,\n   0.0448847,  0.9831243, -0.1773473,\n  -0.6911591,  0.1587406,  0.7050536);\nconst mat4 m4 = mat4(\n     0.56205435, -0.81788519, -0.05012413,  0.11245573,\n 0.05973262,  0.12274471,  0.53602604,  0.83309173,\n-0.67219756, -0.37512639, -0.48469787,  0.41532951,\n 0.47820222,  0.41866184, -0.68937046,  0.34758203);\n\nconst float cloudStartHeight = 6.;\nconst float cloudEndHeight = 22.;\nconst float morphSpeed = 1.5;\n\nfloat noise(float i)\n{\n    float x = fract(i*3.453462472+.45623426)*50.;\n    return 2.*fract(x*x)-1.;\n}\n\n\nfloat noise(vec2 ij)\n{\n    vec2 xy = fract(ij*vec2(3.453462472,6.76235421)+vec2(.45623426,.57422783))*50.;\n    return 2.*fract(xy.x*xy.y*(xy.x+xy.y))-1.;\n}\n\nfloat noise(vec3 ijk)\n{\n    vec3 xyz = fract(ijk*vec3(3.453462472,6.76235421,1.2452341)+vec3(.45623426,.57422783,.7552213513))*50.;\n    return 2.*fract((xyz.x*xyz.y + xyz.y*xyz.z + xyz.z*xyz.x)*(xyz.x+xyz.y+xyz.z))-1.;\n}\n\nfloat noise(vec4 ijk)\n{\n    vec4 xyz = fract(ijk*vec4(3.453462472,6.76235421,1.2452341,2.86987991)+vec4(.45623426,.57422783,.7552213513,.91231514))*50.;\n    return 2.*fract((xyz.x*xyz.y + xyz.y*xyz.z + xyz.z*xyz.x + xyz.w*(xyz.z + xyz.y + xyz.x))*(xyz.x+xyz.y+xyz.z+xyz.w))-1.;\n}\n\n\nvec2 SmoothStep_d(float edge0, float edge1, float x)\n{\n    float scale = 1. / (edge1 - edge0);\n    float t = clamp((x - edge0) * scale, 0.0, 1.0);\n    float v = t * t * (3.0 - 2.0 * t);\n    float dv = scale * 6. * t * (1. - t);\n    return vec2(v,dv);\n}\n\nfloat CloudFBM_d(vec4 p, out vec4 dk)\n{\n    float k = 0.;\n    dk = vec4(0.);\n    float factor=1.;\n    float uvFactor = 1.;\n    mat4 mTotal = mat4(\n        1,0,0,0,\n        0,1,0,0,\n        0,0,1,0,\n        0,0,0,1);\n    for ( int i=0;i<FBM_ORDER;++i)\n    {\n        p+=vec4(7.436525461,8.32524631,3.2465756,2.254107789);\n        vec4 q = floor(p);\n        \n        vec2 SX = SmoothStep_d(0.,1.,fract(p.x));\n        vec2 SY = SmoothStep_d(0.,1.,fract(p.y));\n        vec2 SZ = SmoothStep_d(0.,1.,fract(p.z));\n        vec2 SW = SmoothStep_d(0.,1.,fract(p.w));\n        vec4 s = vec4(SX.x,SY.x,SZ.x,SW.x);\n        vec4 ds = vec4(SX.y,SY.y,SZ.y,SW.y);\n        \n        float h[4];\n        vec2 dh[4];\n        for ( int jz = 0;jz<2;++jz)\n        {\n            for ( int kw = 0;kw<2;++kw)\n            {\n                float a1 = noise(q+vec4(0.,0.,float(jz),float(kw)));\n                float b1 = noise(q+vec4(1.,0.,float(jz),float(kw)));\n                float c1 = noise(q+vec4(0.,1.,float(jz),float(kw)));\n                float d1 = noise(q+vec4(1.,1.,float(jz),float(kw)));\n                h[jz*2+kw] = (\n                    a1\n                    + (b1-a1)*s.x\n                    + (c1-a1)*s.y\n                    + (a1-b1-c1+d1)*s.x*s.y);\n                dh[jz*2+kw] = vec2(\n                    ds.x*((b1-a1) + (a1-b1-c1+d1)*s.y),\n                    ds.y*((c1-a1) + (a1-b1-c1+d1)*s.x)\n                );\n            }\n        }\n        float g = h[0]\n                    + (h[2]-h[0])*s.z\n                    + (h[1]-h[0])*s.w\n                    + (h[0]-h[1]-h[2]+h[3])*s.z*s.w;\n        vec4 dg;\n        dg.xy = dh[0]\n            + (dh[2] - dh[0]) * s.z\n            + (dh[1] - dh[0]) * s.w\n            + (dh[0] - dh[1] - dh[2] + dh[3])*s.z*s.w;\n        \n        dg.zw = vec2((h[2]-h[0] + (h[0]-h[1]-h[2]+h[3])*s.w) *ds.z\n                    ,(h[1]-h[0] + (h[0]-h[1]-h[2]+h[3])*s.z) *ds.w);\n        \n        k += factor * g;\n        dk += (factor * uvFactor)*(mTotal * dg);\n        \n        factor *=.4;\n        uvFactor *= 1.5;\n        p *= 2.5;\n        p *= m4;\n        mTotal = mTotal * m4;\n    }\n    return k;\n}\n\nfloat CloudFBM(vec4 p,int n)\n{\n    float k = 0.;\n    float factor=1.;\n    for ( int i=0;i<n;++i)\n    {\n        p+=vec4(7.436525461,8.32524631,3.2465756,2.254107789);\n        vec4 q = floor(p);\n        \n        vec4 s = smoothstep(0.,1.,fract(p));\n        \n        float h[4];\n        for ( int jz = 0;jz<2;++jz)\n        {\n            for ( int kw = 0;kw<2;++kw)\n            {\n                float a1 = noise(q+vec4(0.,0.,float(jz),float(kw)));\n                float b1 = noise(q+vec4(1.,0.,float(jz),float(kw)));\n                float c1 = noise(q+vec4(0.,1.,float(jz),float(kw)));\n                float d1 = noise(q+vec4(1.,1.,float(jz),float(kw)));\n                h[jz*2+kw] = (\n                    a1\n                    + (b1-a1)*s.x\n                    + (c1-a1)*s.y\n                    + (a1-b1-c1+d1)*s.x*s.y);\n            }\n        }\n        float g = h[0]\n                    + (h[2]-h[0])*s.z\n                    + (h[1]-h[0])*s.w\n                    + (h[0]-h[1]-h[2]+h[3])*s.z*s.w;\n                    \n        k += factor * g;\n        \n        factor *=.55;\n        p *= 2.5;\n        p *= m4;\n    }\n    return k;\n}\n\nfloat CloudFBM(vec3 p, int n)\n{\n    float k = 0.;\n    float factor=1.;\n    for ( int i=0;i<n;++i)\n    {\n        p += vec3(5.434573,7.5436727,1.3453572);\n        vec3 q = floor(p);\n        \n        float a0 = noise(q);\n        float b0 = noise(q+vec3(1.,0.,0.));\n        float c0 = noise(q+vec3(0.,1.,0.));\n        float d0 = noise(q+vec3(1.,1.,0.));\n        \n        float a1 = noise(q+vec3(0.,0.,1.));\n        float b1 = noise(q+vec3(1.,0.,1.));\n        float c1 = noise(q+vec3(0.,1.,1.));\n        float d1 = noise(q+vec3(1.,1.,1.));\n        \n        vec3 s = smoothstep(0.,1.,fract(p));\n        \n        float k0 = (\n            a0\n            + (b0-a0)*s.x\n            + (c0-a0)*s.y\n            + (a0-b0-c0+d0)*s.x*s.y);\n        float k1 = (\n            a1\n            + (b1-a1)*s.x\n            + (c1-a1)*s.y\n            + (a1-b1-c1+d1)*s.x*s.y);\n        k+=factor*((k1-k0)*s.z+k0);\n        factor *=.55;\n        p *= 2.5;\n        p *= m3;\n    }\n    return k;\n}\n\nfloat CloudFBM_ld(vec4 p)\n{\n    float k = 0.;\n    float factor=1.;\n    for ( int i=0;i<5;++i)\n    {\n        p+=vec4(7.436525461,8.32524631,3.2465756,2.254107789);\n        vec4 q = floor(p);\n        \n        vec4 s = smoothstep(0.,1.,fract(p));\n        \n        float h[4];\n        for ( int jz = 0;jz<2;++jz)\n        {\n            for ( int kw = 0;kw<2;++kw)\n            {\n                float a1 = noise(q+vec4(0.,0.,float(jz),float(kw)));\n                float b1 = noise(q+vec4(1.,0.,float(jz),float(kw)));\n                float c1 = noise(q+vec4(0.,1.,float(jz),float(kw)));\n                float d1 = noise(q+vec4(1.,1.,float(jz),float(kw)));\n                h[jz*2+kw] = (\n                    a1\n                    + (b1-a1)*s.x\n                    + (c1-a1)*s.y\n                    + (a1-b1-c1+d1)*s.x*s.y);\n            }\n        }\n        float g = h[0]\n                    + (h[2]-h[0])*s.z\n                    + (h[1]-h[0])*s.w\n                    + (h[0]-h[1]-h[2]+h[3])*s.z*s.w;\n                    \n        k += factor * g;\n        \n        factor *=.6;\n        p *= 2.;\n        p *= m4;\n    }\n    return k;\n}\n\nfloat CloudFBM_ld(vec3 p)\n{\n    float k = 0.;\n    vec3 dk = vec3(0.);\n    float factor=1.;\n    float uvFactor = 1.;\n    mat3 mTotal = mat3(1,0,0,0,1,0,0,0,1);\n    for ( int i=0;i<3;++i)\n    {\n        p+=vec3(1.56437612,6.415345893,8.62512677);\n        vec3 q = floor(p);\n        \n        float a0 = noise(q);\n        float b0 = noise(q+vec3(1.,0.,0.));\n        float c0 = noise(q+vec3(0.,1.,0.));\n        float d0 = noise(q+vec3(1.,1.,0.));\n        \n        float a1 = noise(q+vec3(0.,0.,1.));\n        float b1 = noise(q+vec3(1.,0.,1.));\n        float c1 = noise(q+vec3(0.,1.,1.));\n        float d1 = noise(q+vec3(1.,1.,1.));\n        \n        vec3 s = smoothstep(0.,1.,fract(p));\n        \n        float k0 = (\n            a0\n            + (b0-a0)*s.x\n            + (c0-a0)*s.y\n            + (a0-b0-c0+d0)*s.x*s.y);\n        float k1 = (\n            a1\n            + (b1-a1)*s.x\n            + (c1-a1)*s.y\n            + (a1-b1-c1+d1)*s.x*s.y);\n        k+=factor*((k1-k0)*s.z+k0);\n        factor *=.6;\n        p *= 2.;\n        //p.y*=2.5;\n        p *= m3;\n    }\n    return k;\n}\n\nfloat CloudDensity_ld(vec3 p)\n{\n    float v = clamp(CloudFBM_ld(vec4(p*vec3(.1,.1,.1)*.04,morphSpeed*iTime*.005)),-1.,1.)*.5 + .5;\n    float d = (p.y-cloudStartHeight) / (cloudEndHeight - cloudStartHeight);\n    v *= smoothstep(0.,0.4,d);\n    v *= 1. - smoothstep(0.6,1.,d);\n    return v;\n}\n\nfloat CloudDensity_hd(vec3 p, int detail)\n{\n    float v = clamp(CloudFBM(vec4(p*vec3(.1,.1,.1),morphSpeed*iTime*.02),detail),-1.,1.)*.5 + .5;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mouse = iMouse;\n    resolution = iResolution;\n    camPos = texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    //fragColor.xyz = camPos;\n    //return;\n    mat3 viewRot;\n    if(iMouse.x==0. && iMouse.y==0. || texelFetch(iChannel3,ivec2(76,0),0).x != 0.)\n        viewRot = Rotation(radians(220.),radians(40.));\n    else\n        viewRot = MouseToRot();\n    \n    if(iMouse.x==0. && iMouse.y==0. || texelFetch(iChannel3,ivec2(76,0),0).x == 0.)\n        L = normalize(vec3(0,-.5,1));\n    else\n        L = MouseToRot() * vec3(0,0,-1);\n    \n    vec3 rd = vec3((2.*fragCoord-iResolution.x) / iResolution.x,1.);\n    rd = viewRot * rd;\n    \n    //vec3 ro = camPos + rd + vec3(0.,0.,1.)*iTime;\n    vec3 ro = camPos + vec3(0.,0.,1.)*iTime + vec3(-40.,0.,-170.);\n    rd = normalize(rd);\n    \n    const int N = 100;\n    \n    float dr_min = .45;\n    float dr_max = 1.5;\n    \n    const vec3 lightColor = vec3(.85);\n    const vec3 darkColor = vec3(.5,.5,.7);\n    const vec3 horizonColor = vec3(.5,.5,.55)*1.5;\n    const float ldThreshold = .3;\n    const float hdThreshold = .4;\n    //float dr = dr0;\n    vec4 colSum=vec4(0.);\n    float currDist;\n    if ( rd.y > 0. )\n    {\n        currDist = (cloudStartHeight-camPos.y)/rd.y;\n    }\n    else\n    {\n        currDist = (cloudEndHeight-camPos.y)/rd.y;\n    }\n    currDist = max(currDist,0.);\n    int i=0;\n    for ( ;i<N;++i)\n    {\n        vec3 p = ro + rd * currDist;\n        float ld = CloudDensity_ld(p);\n        //float dr = dr_min;\n        float dr = mix(dr_max,dr_min,smoothstep(0.,ldThreshold*2.5,ld));\n        //float dr = mix(dr_max,dr_min,smoothstep(0.,1.,v*4.));\n        float drAddition = max((currDist-100.)/50.,0.);\n        dr += drAddition;//*drAddition*.1;\n        dr *= .95 + .1*fract(439.526363543*(p.x+p.y+p.z));\n        \n\n        //float dr = mix(dr_max,dr_min,smoothstep(-.0,1.,ld));\n        //float dr = dr_max;\n        currDist += dr;\n        if ( ld < ldThreshold)\n            continue;\n\n        float hd = CloudDensity_hd(p,6);//int(6./(currDist*.01+1.)));\n        float v = smoothstep(ldThreshold,1.,ld) * smoothstep(hdThreshold,1.,hd);\n\n        float alpha = min(1.,2.0*v*dr);\n        //float alpha = min(1.,1.0*v);\n        \n        \n        float dlDist = .05;\n        float dL = (smoothstep(0.,1.,CloudDensity_ld(p+L*dlDist)) - smoothstep(0.,1.,ld)) /dlDist;\n        vec3 col = mix(darkColor,lightColor*2.9*exp(-currDist*.003),smoothstep(-1.0,1.,dL*6.0));\n        col = mix(col,horizonColor*1.7,1.-exp(-currDist*.003));\n        alpha *= exp(-currDist*.003);\n\n        colSum.xyz += col.xyz * alpha * (1.-colSum.w);\n        //colSum.xyz += col.xyz * (1.-colSum.w);\n        //colSum.xyz = mix(colSum.xyz,col.xyz,1.-colSum.w);\n        //colSum.xyz += col.xyz * alpha;\n        colSum.w += alpha;\n        if (colSum.w >= 1.0)\n            break;\n        if (   (p.y > cloudEndHeight && rd.y > 0.) \n            || (p.y < cloudStartHeight && rd.y < 0.) )\n            break;\n        if ( currDist > 800.)\n            break;\n    }\n    colSum.w = min(colSum.w,1.);\n    colSum.w = smoothstep(0.,2.,colSum.w)*2.;\n    vec3 envColor = vec3(0.);\n    if (rd.y<0.)\n    {\n        //fragColor.xyz=vec3(0.);\n        //return;\n        vec3 p = camPos + (-2.-camPos.y)/rd.y*rd;\n        envColor = texture(iChannel0, p.xz*.01).xyz * vec3(1.,1.,.7);\n    }\n    else\n    {\n        float theta = atan(rd.y,length(rd.xz))+fract(942348796.23523424*(rd.y+rd.z+rd.x+254235.6572974893487))*.2;\n        envColor = mix(horizonColor,vec3(.3,.3,.5)*1.5,smoothstep(radians(0.),radians(15.),theta));\n        envColor = mix(envColor,vec3(.2,.2,.4)*1.5,smoothstep(radians(10.),radians(60.),theta+fract(4234232.23523424*(rd.y+rd.z+rd.x))*.1));\n        //const vec3 skyColor = vec3(.5,.5,.7);\n        //envColor = skyColor;\n    }\n    //envColor =  vec3(.6,.6,1);\n    colSum.xyz = mix(envColor,colSum.xyz,colSum.w);\n    fragColor = vec4(colSum.xyz,1.);\n    //fragColor.x = float(i)/float(N);\n    //fragColor.yz = vec2(0.);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    if ( iFrame<5 || int(fragCoord.x) != 0 || int(fragCoord.y)!=0 )\n    {\n        return;\n    }\n    mouse = iMouse;\n    resolution = iResolution;\n    mat3 viewRot;\n    if(iMouse.x==0. && iMouse.y==0. || texelFetch(iChannel3,ivec2(76,0),0).x != 0.)\n        viewRot = Rotation(radians(220.),radians(40.));\n    else\n        viewRot = MouseToRot();\n    \n    vec3 currPos = texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    vec3 move = vec3(0.);\n    if ( texelFetch(iChannel3,ivec2(87,0),0).x != 0. )\n        move.z += 1.;\n    if ( texelFetch(iChannel3,ivec2(83,0),0).x != 0. )\n        move.z -= 1.;\n    if ( texelFetch(iChannel3,ivec2(65,0),0).x != 0. )\n        move.x -= 1.;\n    if ( texelFetch(iChannel3,ivec2(68,0),0).x != 0. )\n        move.x += 1.;\n    move = viewRot*move;\n    if ( texelFetch(iChannel3,ivec2(32,0),0).x == 0. )\n        move.y=0.;\n    float lm = length(move);\n    if (lm != 0.)\n    {\n        move /= lm;\n    }\n    float speed = .1;\n    if ( texelFetch(iChannel3,ivec2(16,0),0).x != 0.)\n        speed *= 5.;\n    fragColor.xyz = currPos + move*speed;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415927\n\nmat3 Rotation(float phi, float theta)\n{\n    float cp = cos(phi);\n    float sp = sin(phi);\n    float ct = cos(theta);\n    float st = sin(theta);\n    mat3 Mp = mat3(\n        cp,0.,-sp,\n        0.,1.,0.,\n        sp,0.,cp);\n    mat3 Mt = mat3(\n        1.,0.,0.,\n        0.,ct,-st,\n        0.,st,ct);\n    return Mp*Mt;\n}\n\nvec4 mouse;\nvec3 resolution;\n\nmat3 MouseToRot()\n{\n    vec2 mouse = (2.*mouse.xy-resolution.xy) / resolution.xy;\n    float phi = mouse.x*PI;\n    float theta = (mouse.y)*PI*.5;\n    return Rotation(phi,theta);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd23zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[546, 546, 568, 568, 649], [652, 652, 674, 674, 807], [809, 809, 832, 832, 1029], [1031, 1031, 1054, 1054, 1310], [1313, 1313, 1367, 1367, 1565], [1567, 1567, 1606, 1606, 3682], [3684, 3684, 3714, 3714, 4813], [4815, 4815, 4846, 4846, 5779], [5781, 5781, 5808, 5808, 6905], [6907, 6907, 6934, 6934, 7980], [7982, 7982, 8013, 8013, 8271], [8273, 8273, 8316, 8316, 8430], [8432, 8432, 8489, 8489, 12419]], "test": "untested"}
{"id": "DsjGWw", "name": "Transparent worms", "author": "rubioh", "description": "First experiment on 1-step refraction rendering", "tags": ["raymarching", "refraction", "worms", "lightningmodel"], "likes": 6, "viewed": 232, "published": 3, "date": "1667842707", "time_retrieved": "2024-07-30T16:21:25.845244", "image_code": "const int MAX_MARCHING_STEPS = 250;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 20.0;\nconst float PRECISION = 0.005;\n#define AA 1\n#define PI 3.14159\n\nstruct worm{\n    float depth;\n    vec3 col;\n    float id;\n    float cnt;\n    float eta;\n};\n\n\nfloat Worm(vec3 p, out worm W){\n    float d = 1e10;\n        \n    vec3 q = p;\n    q.y += .3*sin(p.x*1.3+2.);\n    q.x -= .3*cos(p.y*1.);\n    q.z += .3*cos(p.x*1.7+1.);\n    q.z += .42*cos(q.x*2.+iTime);    vec3 a = vec3(0.), b = -vec3(2.,0.,0.);\n    float r = .1;\n    float d2 = sdCapsule(q/2., a, b, r);\n    if (d2<d){\n        W.col = vec3(.3,0.,0.);\n        d = d2;\n        W.id = 1.;\n        W.eta = .9;\n     }\n     \n    vec2 t = vec2(.5, .65);\n    q = rotateZ(PI/2.)*q;\n    q.y = q.y - .3*clamp(round(q.y/.3), 0., 12.);\n    q.y *= 2.;\n    d2 = sdTorus(q/2., t/10.);\n    if (d2<d){\n        W.col = vec3(2.,0.,0.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 2.;\n        d = d2;\n        W.eta = 1.;\n     }    \n     \n    q = p;\n    q.x -= .3*cos(p.y*1.);    \n    q.y += .3*sin(p.x*1.3+2.);\n    q.z += .3*cos(p.x*1.7+1.);\n\n    q.y += .42*sin(q.x*2.+iTime);     a = vec3(0.), b = -vec3(2.,0.,0.);\n     r = .1;\n     d2 = sdCapsule(q/2., a, b, r);\n    if (d2<d){\n        W.col = vec3(0.,.3,0.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 1.5;\n        d = d2;\n        W.eta = .9;\n\n\n     }\n     \n     \n    q = rotateZ(PI/2.)*q;\n    q.y = q.y - .3*clamp(round(q.y/.3), 0., 12.);\n    q.y *= 2.;\n    d2 = sdTorus(q/2., t/10.);\n    if (d2<d){\n        W.col = vec3(0.,2.,0.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 2.5;\n        d = d2;\n        W.eta = 1.;\n   }\n   \n   \n    q = p;\n    q.x -= .3*cos(p.y*1.);    \n    q.y += .3*sin(p.x*1.3+2.);\n    q.z += .3*cos(p.x*1.7+1.);\n    \n    q.z += .55*sin(q.x*2.+iTime);   \n    q.y += .55*cos(q.x*2.+iTime);\n     r = .1;\n     d2 = sdCapsule(q/2., a, b, r);\n    if (d2<d){\n        W.col = vec3(0.,0.,.3);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 1.5;\n        d = d2;\n        W.eta = .9;\n\n\n     }\n     \n     \n    q = rotateZ(PI/2.)*q;\n    q.y = q.y - .3*clamp(round(q.y/.3), 0., 12.);\n    q.y *= 2.;\n    d2 = sdTorus(q/2., t/10.);\n    if (d2<d){\n        W.col = vec3(0.,0.,2.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 2.5;\n        d = d2;\n        W.eta = 1.;\n   }    \n    return d;\n}\n\n\nfloat map(vec3 p, out worm W){\n    float d = 1e10;    \n    p += vec3(1., 0., 1.);\n    d = Worm(p, W);\n    return d;\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, float start, out worm W1) {\n  float depth = start;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = map(p, W1);\n    depth += d*.5;\n    if (d < PRECISION){\n        W1.depth = depth;\n        break;\n        }\n    else W1.id = 0.;\n    if (d>MAX_DIST){\n        W1.depth = 1e10;\n        break;\n    }\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.001;\n    vec3 c;\n    worm obj;\n    return normalize(\n      e.xyy * map(p + e.xyy, obj) +\n      e.yyx * map(p + e.yyx, obj) +\n      e.yxy * map(p + e.yxy, obj) +\n      e.xxx * map(p + e.xxx, obj));\n}\n\nvec4 rayTransp(vec3 ro, vec3 rd, float depth, out worm W2, out float density, vec3 normal, float eta) {\n  vec3 p = ro + depth*rd;\n  ro = p;\n  depth = 0.;\n  float d=1.;\n  int iter = 0;\n  float dit = (fract(sin(dot(p, vec3(10.4886, 14.214654, 21.4567)))))*0.0002;\n  while (d>0.){\n      p = ro+depth*rd;\n      d = map(p, W2);\n      depth += .01;\n      iter += 1;\n      if (iter>10) break;\n  }\n  rd = refract(rd, normal, eta);\n  \n  for (int i = 0; i < 400; i++) {\n    p = ro + depth * rd;\n    d = map(p, W2);\n    depth += 0.002;\n    if (d<0.) density += 0.00025;\n        else break;\n     }\n   \n   return vec4(depth*rd, depth);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col, float spec) {\n  // ambient\n  float N = 2.;\n  vec3 ambient = (col*N)/N;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = (col * dotLN*N)/N;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal)/1.4, -rd), 0., 1.);\n  vec3 specular = 50.*spec*((.5*col+vec3(.5)) * pow(dotRV, 15.)*N)/N;\n\n  return ambient + diffuse + specular;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1)*4.;\n  \n  vec3 col = vec3(0);\n  float density = 0.;\n  vec3 col_tot = vec3(0.);\n  vec3 col_tot2 = vec3(0.);\n\n  vec3 ro = vec3(1., 1., 3.);\n  vec2 m = iMouse.xy/iResolution.xy;\n  if (m.xy == vec2(0.)){\n      m.x = .35;\n      m.y = .8;\n  }\n    vec3 tmp = vec3(-2., 0.,0. );\n  vec3 lookat = tmp;\n  ro.yz = ro.yz * 1. * rot(mix(PI/2., 0., m.y));\n  ro.xz = ro.xz * rot(mix(-PI, PI, m.x)) + vec2(lookat.x, lookat.z); \n  vec3 rd = camera(ro, lookat)*normalize(vec3(uv, -1));\n  worm W1 = worm(1e10, vec3(0.,0.,0.), 0., 0., 1.);\n  worm W2 = W1;\n  vec3 normal, normal2;\n  float d, d2;\n  for (int i = 0; i<AA+1; i++){\n      for (int j = 0; j<AA+1; j++){\n                    \n          vec3 rd2 = rd + vec3(float(i), float(j), 0.)*(.0005);\n          rayMarch(ro, rd2, MIN_DIST, W1); \n          float d = W1.depth;\n          if (d > MAX_DIST) {\n            col_tot = vec3(0.); \n          } else {\n            d = W1.depth;\n            vec3 p = ro + rd * d;\n            normal = calcNormal(p);\n            vec3 lightPosition = vec3(1, 1, 2);\n            vec3 lightDirection = normalize(lightPosition - p);\n            float lint = 5.;\n            \n            float eta = W1.eta;\n            vec4 rt = rayTransp(ro, rd2, d, W2, density, normal, eta);\n            \n            col_tot += 2.*density*lint*phong(lightDirection, normal, rd, W1.col/5., 3.);\n            \n            vec3 odir = refract(rd, normal, eta);\n            rayMarch(rt.xyz+ro, rd, d+dot(normalize(rd), normalize(odir))*rt.w+.1, W2);\n            \n            d2 = W2.depth;\n            if (d2 > MAX_DIST) {\n             col_tot += vec3(0.); \n            } else {\n                vec3 p = ro + rd * d2;\n                normal = calcNormal(p);\n                vec3 lightPosition = vec3(1, 1, 2);\n                vec3 lightDirection = normalize(lightPosition - p);\n                float lint = 5.;\n                col_tot2 += .1*(1.-density)*6.*phong(lightDirection, normal, rd, W2.col/5., 3.);\n            }\n\n       }\n    }\n    \n  }  \n  // Output to screen\n  fragColor = vec4(vec3(col_tot+col_tot2)/float(AA+1)/float(AA+1), 1.0);\n}\n", "image_inputs": [], "common_code": "\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 280, 280, 2396], [2399, 2399, 2429, 2429, 2516], [2518, 2518, 2577, 2577, 2895], [2897, 2897, 2922, 2922, 3154], [3156, 3156, 3259, 3259, 3780], [3782, 3782, 3801, 3801, 3877], [3880, 3880, 3951, 3964, 4311], [4313, 4313, 4360, 4360, 4573], [4575, 4575, 4632, 4632, 6808]], "test": "untested"}
{"id": "dd2GRy", "name": "Truchet's Train", "author": "dr2", "description": "Antique train with track based on generalized hexagonal Truchet tiles (mouseable, multiple views)", "tags": ["grid", "truchet", "path", "train"], "likes": 38, "viewed": 446, "published": 3, "date": "1667825718", "time_retrieved": "2024-07-30T16:21:27.047031", "image_code": "// \"Truchet's Train\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Three separate raymarching loops: a regular loop for the train, and\n separate hexagonal-grid loops (B) for the Truchet-tiled train tracks\n and (S) for the trees. Tree placement requires both grids to keep\n trees off tracks.\n\n  No. 19 in \"Train\" series\n    \"Train Ride\"                  (4s2Sz3)\n    \"Toy Train\"                   (4tfGzr)\n    \"Gotthard Tunnel\"             (MlSXRR)\n    \"Sneak Preview\"               (XsK3R3)\n    \"Ride the Loop\"               (lsK3Rc)\n    \"Lost Egg\"                    (ls3XDn)\n    \"Thomas X3\"                   (ldtXD8)\n    \"Complex Tunnels\"             (4dtXW4)\n    \"Express Train\"               (MsdSDM)\n    \"Train Builder\"               (4tlcz7)\n    \"Alpine Express\"              (4t2fW1)\n    \"White Pass Route\"            (ltSBzG)\n    \"Time Released\"               (MdVBDK)\n    \"Train Ride 2\"                (XlVczW)\n    \"Roller-Coaster\"              (Wtl3Rl)\n    \"Riding the Textured Tunnel\"  (WdVXzD)\n    \"Live Assembly Instructions\"  (WlcSD2)\n    \"Underground Trains\"          (tsKyzw)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define P_LONG  1  // (= 0/1) for longer path\n\n#if P_LONG\n#define PLEN 17\n#else\n#define PLEN 13\n#endif\n\n#define N_CAR 4\n\nvec4 cPath[PLEN], carPos[N_CAR];\nvec3 qHit, sunDir, tOff;\nvec2 cIdB, cIdS, cMidB, cMidS, wlBase;\nfloat dstFar, tCur, hgSizeB, hgSizeS, tEnd[PLEN + 1], tLen, trVel, cDir, cType, gHt,\n   csOcc, trSzFac;\nint idObj;\nbool trees;\nconst int idGrnd = 1, idFenc = 2, idBrdg = 3, idBrdgP = 4, idRail = 5, idTree = 6, idLeaf = 7, \n  idEng = 8, idCar = 9, idRf = 10, idWhl = 11, idAxle = 12, idCrod = 13, idFun = 14, idCpl = 15,\n  idLamp = 16;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchDist (vec2 p)\n{ // (from \"Generalized Truchet Path\" with longer default path)\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  ac = 0.5 - atan (dp.y, - dp.x) / (2. * pi);\n  cxy = cIdB.x - cIdB.y;\n#if P_LONG  \n  if (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ac *= -1.;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n#else\n  if (ct && cxy < 0.) ac *= -1.;\n#endif\n  return vec3 (d, rc, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n#if P_LONG  \n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. || \n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n#else\n  offTrk = (cxy == -2. && wm.y > 0. || ! cyo && (abs (cxy) == 2. || cxy == -3. && w.y > -0.3 ||\n     cxy == -1. && wm.y > 0. || cxy == 1. && wm.y < 0.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || cxy == 1. && wm.x < 0. ||\n     cxy == 2. && wm.y < 0.));\n#endif\n     return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n#if P_LONG\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n#else\n  cPath[ 8] = vec4 (2., 1., -1./6., tl);\n  cPath[ 9] = vec4 (3., 1., 1./3., - ts);\n  cPath[10] = vec4 (2., 2., 5./6., tl);\n#endif\n  cPath[PLEN - 2] = vec4 (1., 2., -1./3., ts);\n  cPath[PLEN - 1] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = Rot2D (vec2 (0., 1.), pi * cp.z);\n  return (HexToPix (tp) + dc * vd - r * Rot2D (vd, tt * a)) * hgSizeB;\n}\n\nfloat EngDf (vec3 p, float dMin)\n{  // (from \"White Pass Route\")\n  vec3 q;\n  float wRad, d, aw, sx, tw;\n  tw = wlBase.x;\n  wRad = 0.8;\n  q = p;\n  d = max (max (PrBoxDf (vec3 (q.xy, q.z + 1.75), vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (vec3 (q.xy, q.z + 1.95), vec3 (0.95, 1.3, 0.65))),\n     - PrBox2Df (q.yz - vec2 (0.7, -1.75), vec2 (0.5, 0.4)));\n  d = min (d, max (PrCapsDf (q - vec3 (0., -0.2, 0.5), 1., 2.), - (q.z + 1.2)));\n  d = min (min (min (min (d, PrBoxDf (q - vec3 (0., -0.5, -3.15), vec3 (1., 0.7, 0.3))),\n     PrBoxDf (q - vec3 (0., -1.3, -0.25), vec3 (1., 0.1, 3.2))),\n     PrBoxDf (q - vec3 (0., -1.4, 3.), vec3 (1.1, 0.2, 0.07))),\n     PrCylDf (vec3 (abs (q.x) - 0.6, q.y + 1.4, q.z - 3.1), 0.2, 0.1));\n  DMINQ (idEng);\n  d = max (PrCylDf (q - vec3 (0., -2.35, -1.77), 4., 0.7), max (1.4 - q.y, abs (q.x) - 1.35));\n  DMINQ (idRf);\n  d = PrCylDf ((q - vec3 (0., -1.4, -3.5)).xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  d = min (PrCylDf ((q - vec3 (0., 1.1, 2.)).xzy, 0.3, 0.5),\n     PrCylDf ((q - vec3 (0., 1.5, 2.)).xzy, 0.4, 0.15));\n  d = min (d, PrCapsDf ((q - vec3 (0., 0.8, 0.5)).xzy, 0.3, 0.2));\n  DMINQ (idFun);\n  q = p;\n  q.yz -= vec2 (-0.2, 3.5);\n  d = PrCylDf (q, 0.2, 0.2);\n  DMINQ (idLamp);\n  q = p; \n  q.xz = abs (q.xz);\n  q -= vec3 (tw - 0.12, -1.4, wlBase.y);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1), PrCylDf (q.zyx - vec3 (0.,0., -0.07),\n     wRad + 0.05, 0.03)), - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (tw - 0.17, -1.4, sign (q.z * wlBase.y));\n  aw = - trVel * tCur / (wRad * trSzFac);\n  q.yz = Rot2D (q.yz, aw);  \n  q.yz = Rot2D (q.yz, 2. * pi * floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.);\n  q.z -= -0.5 * wRad;\n  d = min (d, PrCylDf (q, 0.05, 0.5 * wRad));\n  DMINQ (idWhl);\n  q = p;\n  sx = sign (q.x);\n  q.x = abs (q.x);\n  q.xy -= vec2 (tw + 0.08, -1.4);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);\n  q.xz -= vec2 (-0.1, wlBase.y);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  DMINQ (idCrod);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0., -1.4, wlBase.y);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, tw;\n  wRad = 0.35;\n  tw = wlBase.x;\n  q = p;\n  d = PrBoxDf (q, vec3 (1.3, 1.4, 2.8));\n  DMINQ (idCar);\n  d = max (PrCylDf (vec3 (q.x, q.y + 2.35, q.z), 4., 2.85), max (1.4 - q.y, abs (q.x) - 1.35));\n  DMINQ (idRf);\n  q = p;\n  q.z = abs (q.z);\n  q.yz -= vec2 (-1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (tw - 0.1, -1.85, wlBase.y);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1), PrCylDf (q.zyx - vec3 (0.,0., -0.07),\n     wRad + 0.05, 0.03)), PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - PrCylDf (q.zyx, 0.2, 0.05));\n  DMINQ (idWhl);\n  q = p;\n  q.z = abs (q.z);\n  q.yz -= vec2 (-1.85, wlBase.y);\n  d = PrCylDf (q.zyx, 0.05, tw);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar / trSzFac;\n  q = (p - carPos[0].xyz) / trSzFac;\n  q.xz = Rot2D (q.xz, carPos[0].w);\n  dMin = EngDf (q, dMin);\n  for (int k = VAR_ZERO + 1; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    dMin = CarDf (q, dMin);\n  }\n  return dMin * trSzFac;\n}\n\nvec4 TrnCol ()\n{\n  vec4 col4, carCol, carCol2;\n  carCol = vec4 (0.1, 0.1, 1., 0.2);\n  carCol2 = vec4 (0.7, 1., 0.7, 0.2);\n  if (idObj == idEng || idObj == idCar) {\n    col4 = mix (carCol2, carCol, smoothstep (0., 0.05, abs (abs (qHit.y + 0.25) - 0.1) - 0.02)) *\n       (0.5 + 0.5 * step (-1.15, qHit.y));\n  }\n  if (idObj == idEng) {\n    if (min (max (abs (abs (qHit.x) - 0.5) - 0.4, abs (qHit.y - 1.1) - 0.2),\n       max (abs (abs (qHit.z - 1.) - 1.5) - 0.1,  - qHit.y - 1.1)) < 0.)\n       col4 = vec4 (0.4, 0.4, 0.1, -1.);\n    if (qHit.z > 3.1 && qHit.y < -1.) col4 = carCol;\n    if (qHit.z < -2.8 && qHit.y > 0.1) col4 = vec4 (vec3 (0.01), 0.);\n  } else if (idObj == idCar) {\n    if (min (max (abs (abs (qHit.z) - 1.25) - 1., abs (qHit.y - 0.6) - 0.5),\n       length (vec2 (qHit.xy - vec2 (0., 0.6))) - 0.4) < 0.) col4 = vec4 (0.4, 0.4, 0.1, -1.);\n  } else if (idObj == idRf) {\n    col4 = carCol2;\n    if (length (qHit.xy - vec2 (0., -2.35)) > 3.97)\n       col4 *= (0.8 + 0.2 * smoothstep (0., 0.05, abs (fract (4. * qHit.x + 0.5) - 0.5)));\n  } else if (idObj == idFun) {\n    col4 = ((qHit.y > 1.35) ? carCol : carCol2) * (0.5 + 0.5 * step (0.25,\n       length (vec2 (qHit.xz - vec2 (0., 2.)))));\n  } else if (idObj == idAxle) {\n    col4 = vec4 (0.3, 0.3, 0.35, 0.);\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.6, 0.6, 0.7, 0.1);\n  } else if (idObj == idCpl) {\n    col4 = vec4 (0.3, 0.3, 0.3, 0.);\n  } else if (idObj == idCrod) {\n    col4 = vec4 (0.7, 0.7, 0.1, 0.1);\n  } else if (idObj == idLamp) {\n    col4 = (length (qHit.xy) < 0.16) ? ((mod (tCur, 2.) < 1.) ? vec4 (1., 1., 0.8, -1.) :\n       vec4 (0.8, 0.8, 0.4, 0.)) : carCol2;\n  }\n  return col4;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n#if P_LONG\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n#else\n  else if (abs (cxy) == 2. || cxy == -3.) cType = 2.;\n  if (cType <= 2.) cDir = 2. * mod (cIdB.x, 2.) - 1.;\n#endif\n}\n\nfloat GrndHt (vec2 p)\n{\n  float f, a, aSum;\n  p *= 2.;\n  f = 0.;\n  a = 1.;\n  aSum = 0.;\n  for (int j = 0; j < 3; j ++) {\n    f += a * Noisefv2 (p);\n    aSum += a;\n    a *= 0.4;\n    p *= 2.5;\n  }\n  return 0.05 * f / aSum;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 ws;\n  float dMin, d, dt, dWid, eWid, rc, ac, dh, r, h;\n  dWid = 0.5;\n  eWid = 0.2;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidB) / hgSizeB;\n    cm3 = TruchDist (q.xz);\n    dt = hgSizeB * cm3.x;\n    rc = cm3.y;\n    ac = 18. * cm3.z;\n    dh = hgSizeB * HexEdgeDist (q.xz);\n    ws = vec2 (0.005, 0.01);\n    if (cType <= 2. && rc != 0. && OnTrk (q.xz)) {\n      d = PrRoundBox2Df (vec2 (dt - wlBase.x * trSzFac + ws.x, q.y - ws.y), ws, 0.003);\n      DMIN (idRail);\n    }\n    h = gHt + GrndHt (p.xz) - 0.05;\n    d = dot (vec2 (dt - dWid, h - q.y), sin (0.13 * pi + vec2 (0.5 * pi, 0.)));\n    d = SmoothMin (q.y, SmoothMax (q.y - h, - d, 0.1), 0.1);\n    d = SmoothMax (d, - max (PrBox2Df (vec2 (dh, q.y - gHt - 0.05),\n       vec2 (eWid, 0.1)), 1.25 - dt), 0.05);\n    DMIN (idGrnd);\n    r = length (vec2 (dt, q.y + 1.)) - 1.8;\n    d = max (abs (abs (r) - 0.1) - 0.025, abs (dh - 0.23) - 0.01);\n    DMIN (idBrdg);\n    d = max (abs (r + 0.1) - 0.01, abs (dh) - 0.23);\n    DMIN (idBrdgP);\n    if (rc != 0.) {\n      d = min (length (vec2 (dt - dWid + 0.2, q.y - 0.2)) - 0.011,\n         max (PrRoundBox2Df (vec2 (dt - dWid + 0.2, (fract (10. * rc * ac + 0.5) - 0.5) / 10.),\n         vec2 (0.01, 0.003), 0.001), q.y - 0.2));\n      DMIN (idFenc);\n    }\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeB;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeB));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      BConf ();\n    }\n    d = BObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      BConf ();\n    }\n    h = BObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > hgSizeB) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid SConf ()\n{\n  vec2 r;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  r = Hashv2v2 (73. * cIdS + 1.1);\n  tOff.xz = 0.2 * sqrt3 * hgSizeS * (0.5 + 0.5 * r.x) * sin (2. * pi * r.y + vec2 (0.5 * pi, 0.));\n  tOff.y = r.x + r.y;\n}\n\nvoid SBConf ()\n{\n  vec2 s, u;\n  u = cMidS + tOff.xz;\n  cIdB = PixToHex (u / hgSizeB);\n  BConf ();\n  s = (u - cMidB) / hgSizeB;\n  csOcc = (hgSizeB * min (TruchDist (s).x, HexEdgeDist (s)) < 1.1) ? 0. : 1.;\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  if (csOcc > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidS) / hgSizeS;\n    q.xz -= tOff.xz;\n    h = 0.15 + 0.15 * tOff.y;\n    q.y -= h;\n    d = PrCylDf (q.xzy, 0.05, h);\n    DMIN (idTree);\n    q.y -= h + 0.5;\n    d = PrConCapsDf (q.xzy, sin (0.08 * pi + vec2 (0.5 * pi, 0.)), 0.17, 0.3);\n    DMIN (idLeaf);\n  }\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeS;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeS));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    SBConf ();\n    d = SObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    SBConf ();\n    if (csOcc > 0.) {\n      h = SObjDf (p);\n      sh = min (sh, smoothstep (0., 0.1 * d, h));\n      d += h;\n    } else d += 0.1 * hgSizeS;\n    if (sh < 0.05 || d > 2. * hgSizeS) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec4 GroundCol (vec3 p, inout vec2 vf)\n{\n  vec4 col4, gCol;\n  vec3 cm3;\n  vec2 w;\n  float dt, rc, ac;\n  gCol = vec4 (0.6, 0.6, 0.5, 0.);\n  col4 = vec4 (0., 0.7, 0., 0.) * (0.6 + 0.4 * Fbm2 (p.xz));\n  vf = vec2 (32., 1.);\n  w = (p.xz - cMidB) / hgSizeB;\n  cm3 = TruchDist (w);\n  dt = hgSizeB * cm3.x;\n  if (dt > 1.22) col4 = mix (gCol, col4, smoothstep (0., 0.01, hgSizeB * HexEdgeDist (w) - 0.2));\n  else if (dt < 0.19) {\n    col4 = mix (col4, gCol, smoothstep (0., 0.03, 0.19 - dt));\n    rc = cm3.y;\n    ac = cm3.z;\n    if (cType <= 2. && rc != 0. && OnTrk (w) && dt < 0.16 && step (0.35,\n         abs (fract (36. * 6. * rc * ac + 0.5) - 0.5)) > 0.) col4 = vec4 (0.5, 0.4, 0.3, 0.);\n  }\n  if (trees) {\n    cIdB = PixToHex (p.xz / hgSizeB);\n    BConf ();\n    cIdS = PixToHex (p.xz / hgSizeS);\n    SConf ();\n    SBConf ();\n    if (csOcc > 0. && length ((p.xz - cMidS) / hgSizeS - tOff.xz) < 0.07) col4 *= 0.8;\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rs;\n  vec2 w, vf;\n  float dstObj, dstObjB, dstObjS, sh, shGrnd;\n  int idObjB, idObjS;\n  vf = vec2 (0.);\n  if (trees) {\n    dstObjS = SObjRay (ro, rd);\n    idObjS = idObj;\n  } else dstObjS = dstFar;\n  dstObjB = BObjRay (ro, rd);\n  idObjB = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObjB, dstObjS) < dstObj) {\n    if (dstObjB < dstObjS) {\n      dstObj = dstObjB;\n      idObj = idObjB;\n    } else {\n      dstObj = dstObjS;\n      idObj = idObjS;\n    }\n  }\n  shGrnd = 1.;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjS) {\n      cIdS = PixToHex (ro.xz / hgSizeS);\n      SConf ();\n      SBConf ();\n      vn = SObjNf (ro);\n    } else if (dstObj == dstObjB) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      BConf ();\n      vn = BObjNf (ro);\n    } else {\n      vn = ObjNf (ro);\n    }\n    if (idObj == idFenc) {\n      col4 = vec4 (0.9, 0.2, 0.3, 0.2);\n    } else if (idObj == idBrdg) {\n      col4 = vec4 (0.8, 0.3, 0.3, 0.2);\n    } else if (idObj == idBrdgP) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.);\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.1);\n    } else if (idObj == idTree) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n    } else if (idObj == idLeaf) {\n      col4 = mix (vec4 (0.4, 0.7, 0.1, 0.), vec4 (0.9, 0.9, 0., 0.1), step (0.7,\n         Fbm3 (64. * ro.xzy)));\n      vf = vec2 (16., 2.);\n    } else if (idObj == idGrnd) {\n      col4 = GroundCol (ro, vf);\n      for (int k = VAR_ZERO; k < N_CAR; k ++) shGrnd = min (shGrnd, 0.5 +\n         0.5 * smoothstep (-0.02, 0.02, PrBox2Df (Rot2D ((ro.xz - carPos[k].xz), carPos[k].w),\n         vec2 (1.3, ((k == 0) ? 3.15 : 2.8) - 0.1) * trSzFac)));\n    } else if (idObj >= idEng && idObj <= idLamp) {\n      col4 = TrnCol ();\n    }\n    if (col4.a >= 0.) {\n      rs = ro + 0.01 * vn;\n      sh = min (ObjSShadow (rs, sunDir), BObjSShadow (rs, sunDir));\n      sh = min (sh, shGrnd);\n      if (trees) sh = min (sh, SObjSShadow (rs, sunDir));\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = col4.rgb * (0.3 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.7 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n      col = mix (col, SkyCol (rd), smoothstep (0.8, 1., dstObj / dstFar));\n    } else {\n      col = col4.rgb * (0.2 + 0.8 * max (- dot (rd, vn), 0.));\n    }\n  } else {\n    col = SkyCol (rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  3\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, pc[3];\n  float el, az, zmFac, asp, sr, cGap, t;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  hgSizeB = 8.;\n  hgSizeS = 1.;\n  gHt = 0.2;\n  trSzFac = 0.1;\n  SetPath ();\n  trees = true;\n  cGap = 2.3 * trSzFac;\n  wlBase = vec2 (1.3, 1.1);\n  trVel = 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    t = tCur * trVel - (float (k) + ((k > 0) ? 0.05 : 0.)) * cGap;\n    for (int j = VAR_ZERO; j < 3; j ++)\n       pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * wlBase.y * trSzFac : 0.));\n    carPos[k].xz = pc[0];\n    carPos[k].y = 2.4 * trSzFac;\n    vd.xy = pc[2] - pc[1];\n    carPos[k].w = 0.5 * pi - atan (vd.y, vd.x);\n  }\n  t = tCur * trVel;\n  if (vuId == 0 || vuId == 3) {\n    ro.xz = EvalPPos (t - float ((vuId == 3) ? -3 : N_CAR + 2) * cGap);\n    ro.y = 0.8;\n    vd.xy = normalize (EvalPPos (t - float (N_CAR - ((vuId == 3) ? 5 : 0)) * cGap) - ro.xz);\n    az += atan (vd.y, - vd.x) - 0.5 * pi;\n    el -= 0.06 * pi;\n    el = clamp (el, -0.2 * pi, 0.15 * pi);\n    zmFac = 3.;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 40., (-3. * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n#if P_LONG\n    ro.x += 1.6 * hgSizeB;\n#else\n    ro.x -= 1.6 * hgSizeB;\n#endif\n    az += pi / 3.;\n    el -= 0.3 * pi;\n    el = clamp (el, -0.4 * pi, -0.2 * pi);\n    zmFac = 3.;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 20., (-1.5 * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x -= 1.5 * hgSizeB;\n    vd = normalize (carPos[1].xyz - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 30.;\n  }\n  vuMat = StdVuMat (el, az);\n  dstFar = 16. * hgSizeB;\n  sunDir = normalize (vec3 (0., 1.5, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.7, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2GRy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[2750, 2750, 2771, 2771, 2794], [2796, 2796, 2821, 2883, 3865], [3867, 3867, 3888, 3888, 4826], [4828, 4828, 4845, 4845, 5849], [5851, 5851, 5876, 5876, 6477], [6479, 6479, 6513, 6543, 8698], [8700, 8700, 8734, 8734, 9498], [9500, 9500, 9522, 9522, 9856], [9858, 9858, 9874, 9874, 11520], [11522, 11522, 11555, 11555, 11738], [11740, 11740, 11761, 11761, 12016], [12018, 12018, 12055, 12055, 12298], [13158, 13158, 13181, 13181, 13380], [13382, 13382, 13405, 13405, 14714], [14716, 14716, 14750, 14750, 15995], [15997, 15997, 16019, 16019, 16275], [16277, 16277, 16315, 16315, 16732], [16734, 16734, 16749, 16749, 16954], [16956, 16956, 16972, 16972, 17162], [17164, 17164, 17187, 17187, 17559], [17561, 17561, 17595, 17595, 18855], [18857, 18857, 18879, 18879, 19135], [19137, 19137, 19175, 19175, 19658], [19660, 19660, 19683, 19683, 19846], [19848, 19848, 19888, 19888, 20777], [20779, 20779, 20814, 20814, 23314], [26997, 26997, 27029, 27029, 27129], [27131, 27131, 27164, 27164, 27253], [27255, 27255, 27302, 27302, 27349], [27351, 27351, 27393, 27393, 27444], [27446, 27446, 27489, 27489, 27553], [27555, 27555, 27610, 27610, 27876], [27878, 27878, 27902, 27902, 28132], [28134, 28134, 28158, 28158, 28218], [28220, 28220, 28248, 28248, 28328], [28330, 28330, 28352, 28352, 28379], [28381, 28381, 28403, 28403, 28430], [28432, 28432, 28454, 28454, 28492], [28494, 28494, 28516, 28516, 28554], [28556, 28556, 28601, 28601, 28693], [28695, 28695, 28740, 28740, 28778], [28780, 28780, 28816, 28816, 29022], [29024, 29024, 29054, 29054, 29167], [29169, 29169, 29200, 29200, 29264], [29298, 29298, 29322, 29322, 29382], [29384, 29384, 29408, 29408, 29520], [29522, 29522, 29546, 29546, 29689], [29691, 29691, 29716, 29716, 29902], [29904, 29904, 29929, 29929, 30154], [30156, 30156, 30177, 30177, 30332], [30334, 30334, 30355, 30355, 30510], [30512, 30512, 30541, 30541, 30753], [30755, 30755, 30794, 30794, 31046]], "test": "untested"}
{"id": "dsBGRm", "name": "SAT Box Blur", "author": "fad", "description": "Calculating a summed area table to use for performing a box blur in constant time w.r.t. blur radius. Drag mouse around to change blur radius.", "tags": ["blur", "filter", "box", "area", "table", "summed"], "likes": 9, "viewed": 420, "published": 3, "date": "1667821897", "time_retrieved": "2024-07-30T16:21:27.914711", "image_code": "#define CLAMP_TO_EDGE\n\nvec4 sumToPoint(ivec2 p) {\n    if (p.x <= 0 || p.y <= 0) {\n        return vec4(0.0);\n    }\n    \n    return texelFetch(iChannel0, min(p, ivec2(iResolution.xy)) - 1, 0);\n}\n\nvec4 sumOverRect(ivec2 a, ivec2 b) {\n#ifdef CLAMP_TO_EDGE\n    ivec2 z = ivec2(0);\n    ivec2 r = ivec2(iResolution.xy);\n    return \n        + (a.x < 0 ? (sumToPoint(ivec2(1, b.y)) - sumToPoint(ivec2(1, a.y))) * float(min(b.x, 0) - a.x) : vec4(0.0))\n        + (b.x > r.x ? (sumToPoint(ivec2(r.x, b.y)) - sumToPoint(ivec2(r.x - 1, b.y)) - sumToPoint(ivec2(r.x, a.y)) + sumToPoint(ivec2(r.x - 1, a.y))) * float(b.x - max(a.x, r.x)) : vec4(0.0))\n        + (a.y < 0 ? (sumToPoint(ivec2(b.x, 1)) - sumToPoint(ivec2(a.x, 1))) * float(min(b.y, 0) - a.y) : vec4(0.0))\n        + (b.y > r.y ? (sumToPoint(ivec2(b.x, r.y)) - sumToPoint(ivec2(b.x, r.y - 1)) - sumToPoint(ivec2(a.x, r.y)) + sumToPoint(ivec2(a.x, r.y - 1))) * float(b.y - max(a.y, r.y)) : vec4(0.0))\n        + (a.x < 0 && a.y < 0 ? sumToPoint(ivec2(1)) * float((min(b.x, 0) - a.x) * (min(b.y, 0) - a.y)) : vec4(0.0))\n        + (a.x < 0 && b.y > r.y ? (sumToPoint(ivec2(1, r.y)) - sumToPoint(ivec2(1, r.y - 1))) * float((min(b.x, 0) - a.x) * (b.y - max(a.y, r.y))) : vec4(0.0))\n        + (b.x > r.x && a.y < 0 ? (sumToPoint(ivec2(r.x, 1)) - sumToPoint(ivec2(r.x - 1, 1))) * float((b.x - max(a.x, r.x)) * (min(b.y, 0) - a.y)) : vec4(0.0))\n        + (b.x > r.x && b.y > r.y ? (sumToPoint(r) - sumToPoint(ivec2(r.x - 1, r.y)) - sumToPoint(ivec2(r.x, r.y - 1)) + sumToPoint(r - 1)) * float((b.x - max(a.x, r.x)) * (b.y - max(a.y, r.y))) : vec4(0.0))\n        + sumToPoint(clamp(b, z, r))\n        - sumToPoint(clamp(ivec2(a.x, b.y), z, r))\n        - sumToPoint(clamp(ivec2(b.x, a.y), z, r))\n        + sumToPoint(clamp(a, z, r));\n#else\n    return sumToPoint(b) - sumToPoint(ivec2(a.x, b.y)) - sumToPoint(ivec2(b.x, a.y)) + sumToPoint(a);\n#endif\n}\n\nvec4 avgOverRect(ivec2 a, ivec2 b) {\n    return sumOverRect(a, b) / float((b.x - a.x) * (b.y - a.y));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int s;\n    \n    if (iMouse == vec4(0.0)) {\n        s = int((0.5 - 0.5 * cos(iTime)) * 100.0) + 1;\n    } else {\n        s = int(abs(iMouse.x) / 5.0 + 1.0);\n    }\n    \n    fragColor = pow(avgOverRect(ivec2(fragCoord) - s, ivec2(fragCoord) + s + 1), vec4(1.0 / 2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    ivec2 p = ivec2(fragCoord);\n    \n    if (iFrame == 0) {\n        fragColor = pow(texelFetch(iChannel0, p % textureSize(iChannel0, 0), 0), vec4(2.2));\n        return;\n    }\n    \n    int numXSteps = int(ceil(log2(iResolution.x)));\n    int numYSteps = int(ceil(log2(iResolution.y)));\n    fragColor = texelFetch(iChannel1, p, 0);\n    \n    if (iFrame > numXSteps + numYSteps) {\n        return;\n    }\n    \n    ivec2 s = p;\n    \n    if (iFrame <= numXSteps) {\n        s.x -= 1 << iFrame - 1;\n    } else {\n        s.y -= 1 << iFrame - numXSteps - 1;\n    }\n    \n    if (s.x >= 0 && s.y >= 0) {\n        fragColor += texelFetch(iChannel1, s, 0);\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBGRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 49, 49, 192], [194, 194, 230, 230, 1883], [1885, 1885, 1921, 1921, 1988], [1990, 1990, 2042, 2042, 2313]], "test": "untested"}
{"id": "csj3Ry", "name": "brushlsw", "author": "lsw", "description": "brush", "tags": ["image"], "likes": 0, "viewed": 93, "published": 3, "date": "1667809808", "time_retrieved": "2024-07-30T16:21:28.668695", "image_code": "const float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\n\nconst float KEY_Q = 81.5/256.0;\nconst float KEY_W = 87.5/256.0;\nconst float KEY_E = 69.5/256.0;\nconst float KEY_R = 82.5/256.0;\n\nvec3 HSVtoRGB(vec3 hsv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pointer = iMouse.xy / iResolution.xy;\n //   fragColor =vec4(0);\n    \n    \n    float Q = texture( iChannel3, vec2( KEY_Q, 0.75 )).r;\n    float W = texture( iChannel3, vec2( KEY_W, 0.75 )).r;\n    \n    vec2 brush = vec2(2.) * iResolution.xy / iResolution.xx;\n    if( Q > .5 )\n        brush.x *= 8.;\n    if( W > .5 )\n        brush.y *= 8.;\n    \n    if( (length( (uv - pointer) * brush ) > 0.1 || iMouse.z < 0.) && (uv.x < 0.95 && uv.y < 0.95) )\n        discard;\n    pointer.x = dFdx( fragColor.x ) *1000.;\n    float pallette = mod( iTime, 8. );\n    vec2 localuv = uv - pointer + .1;\n    \n    float tex1 = texture( iChannel3, vec2( KEY_1, 0.75 )).r;\n    float tex2 = texture( iChannel3, vec2( KEY_2, 0.75 )).r;\n    float tex3 = texture( iChannel3, vec2( KEY_3, 0.75 )).r;\n    float tex4 = texture( iChannel3, vec2( KEY_4, 0.75 )).r;\n    \n    if( tex2 > .5 )\n        fragColor.rgb += texture( iChannel0, localuv ).rgb;\n    if( tex3 > .5 )\n        fragColor.rgb += texture( iChannel1, localuv ).rgb;\n    if( tex4 > .5 )\n        fragColor.rgb += texture( iChannel2, localuv ).rgb;\n    \n    if( !(tex1 > .5) )\n    {\n        vec3 hsv = vec3(mod(iTime, 10.) / 10., 0.5, 0.5 );\n        fragColor.rgb += HSVtoRGB( hsv ) / 255.;\n    }\n    fragColor.rgb *= abs(2.0 - mod( iTime, 4. ));\n\tfragColor.a = 1.;\n}\n\n\n\nvec3 HSVtoRGB(vec3 hsv)\n{\n\tfloat R, G, B;\n\tfloat H = hsv.x;\n\tfloat S = hsv.y;\n\tfloat V = hsv.z;\n\tif( S == 0.0 )\n    {\n        R = G = B = floor(V * 255.0);\n    }\n    else\n    {\n        float vH = H * 6.0;\n        float vI = floor( vH );\n        float   v = floor(V * 255.0);\n        float  v1 = floor(V * (1.0 - S) * 255.0);\n        float  v2 = floor(V * (1.0 - S * (vH - vI)) * 255.0);\n        float  v3 = floor(V * (1.0 - S * (1.0 - (vH - vI))) * 255.0);\n\n        if     ( vI == 0.0 ) { R =  v; G = v3; B = v1; }\n        else if( vI == 1.0 ) { R = v2; G =  v; B = v1; }\n        else if( vI == 2.0 ) { R = v1; G =  v; B = v3; }\n        else if( vI == 3.0 ) { R = v1; G = v2; B =  v; }\n        else if( vI == 4.0 ) { R = v3; G = v1; B =  v; }\n        else               { R =  v; G = v1; B = v2; }\n    }\n\treturn vec3(R,G,B);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csj3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 341, 341, 1684], [1688, 1688, 1713, 1713, 2514]], "test": "untested"}
{"id": "cd2GRG", "name": "nth harmonic from phasor", "author": "ttg", "description": "given a unit phasor z = e^ix\ncalculate v = e^inx = z^n\nin log(N) steps given n<N", "tags": ["math", "complex"], "likes": 1, "viewed": 213, "published": 3, "date": "1667796999", "time_retrieved": "2024-07-30T16:21:29.501469", "image_code": "/*\n\nnth harmonic from phasor\ngiven a unit phasor z = e^ix\ncalculate v = e^inx = z^n\nin log(N) steps given n<N\n\n*/\n\nconst float pi = 3.1415927;\n\nvec2 conj (vec2 a) { return vec2(a.x,-a.y); }\nvec2 cmul (vec2 a, vec2 b) { return a.x*b+a.y*conj(b).yx; }\n\nvec2 nthharmonic(vec2 z, int n){\n  vec2 v=vec2(1,0);\n  for (int k=0;k<10;k++){ // for n<1024\n    if(0<(n&1)) v=cmul(v,z);\n    z=cmul(z,z);\n    n>>=1;\n  }\n  return v;\n}\n\nvec2 csin (float a) { return vec2(cos(a),sin(a)); }\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(1.);\n    \n    float xmin = -8.,\n          xmax =  8.,\n          ymin = -2.,\n          ymax =  2. ;\n\n    mat2 domain = mat2(xmin,ymin,xmax,ymax);\n    \n    mat2 window = mat2(0,0,1,1);\n    \n    int n=iMouse.y<.1?10:int(floor(iMouse.x/iResolution.x*20.));\n\n    //                     window,domain,color,side,blend,linewidth, expression...\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(1,0,0), 0, 0, 0.02, nthharmonic(csin(x),n).x );\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(0,.5,0), 0, 0, 0.02, -.1+csin(x*float(n)).x );\n    \n\n    fragData = vec4(pow(col,vec3(1./2.2)),0);\n}\n", "image_inputs": [], "common_code": "\n/* \n\nExpression Plotter\n\nUsage: PLOT_CONTINUOUS( fragColor, uv, window, domain,\n                        linecolor, side, blend, linewidth, expression );\n\n  fragColor - output (linear RGB)\n  uv - coordinate system for window\n  window - mat2, first col: window corner, second col: window size\n  domain - mat2, first col: min x,y, second col: max x,y\n  linecolor - RGB\n  side - 0 = line, 1 = below, -1 = above (see demo)\n  blend - 0=paint, 1=light-trace, 2=ink (see demo)\n  linewidth - measured in units of uv.x; only for side=0\n  expression - uses x as the independent variable\n\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/3t3XWf\", is displayed within the source.\n\n*/\n\n\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\n\n\n/*\nCopyright 2020 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2GRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 164, 164, 189], [190, 190, 218, 218, 249], [251, 251, 283, 283, 418], [420, 420, 441, 441, 471], [473, 473, 529, 529, 1168]], "test": "untested"}
{"id": "dsB3RG", "name": " ϕ-based palette generator", "author": "sh1boot", "description": "Something sort of like that example I saw once which tries to pick an arbitrary number of distinct colours with stable first choices.", "tags": ["palette", "phi", "goldenratio"], "likes": 15, "viewed": 359, "published": 3, "date": "1667788407", "time_retrieved": "2024-07-30T16:21:30.467885", "image_code": "const int num_lines = 15;\n\nvec3 hsv2rgb(float h, float s, float v) {\n    vec3 h3 = mod(6.0 * h + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return v - v * s * h3;\n}\n\nvec3 palette(int i) {\n    float f = float(i);\n    float h = mod(1.618033988749894848204586834 * f, 1.0);\n    float s = fract(-f / 4.0) * 0.5 + 0.45;\n    float v = 1.0;\n    return hsv2rgb(h, s, v);\n}\n\n\n// borrowed hash from https://www.shadertoy.com/view/llGSzw\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixel = 1.5 / iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = vec4(0);\n    float y = 0.0;\n    for (int i = num_lines + 8; i >= 0; --i) {\n        vec3 r = hash3(uint(i + 101));\n        float f = 12.0 * r.x + 4.0;\n        float a = (r.y * 0.25 + 0.05) * 16.0 / (f + 8.0);\n        float t = 0.5 * (r.z + 0.1) * (iTime + 2.0);\n        float w = sin(uv.x * f + t) * a;\n        y = w - y * 0.5;\n        if (i < num_lines) {\n            float cutoff = float(i) + uv.x * 0.8;\n            if (iTime < cutoff * 2.0) continue;\n            float thickness = 0.008 * length(vec2(dFdx(y / pixel), 1.0));\n            float alpha = 1.0 - smoothstep(thickness, thickness + pixel, abs(uv.y - 0.5 - y));\n            vec4 over = vec4(palette(i), alpha);\n            col += (over - col) * over.a;\n        }\n    }\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsB3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 68, 68, 210], [212, 212, 233, 233, 410], [413, 473, 496, 539, 722], [725, 725, 782, 782, 1708]], "test": "untested"}
{"id": "csB3zy", "name": "Sea Creature", "author": "iq", "description": "A procedural sea creature. It's a recursive/fractal SDF, rendered with raymarching. Info: [url]https://iquilezles.org/articles/raymarchingdf/[/url]", "tags": ["procedural", "3d", "raymarching", "distancefield", "sea", "sdf", "ocean", "creature"], "likes": 206, "viewed": 9024, "published": 3, "date": "1667783498", "time_retrieved": "2024-07-30T16:21:31.340552", "image_code": "// Copyright Inigo Quilez, 2022 - https://iquilezles.org/\n// I am the sole copyright owner of this Work. You cannot host, display, distribute\n// or share this Work neither as it is or altered, on Shadertoy or anywhere else,\n// in any form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot sell this\n// Work, mint an NFTs of it or train a neural network with it without my permission.\n// I share this Work for educational purposes, and you can link to it through an URL\n// with proper attribution and unmodified art. If these conditions are too\n// restrictive contact me and we'll definitely work it out.\n\n\n// I made this after I saw leon's shader for the Inercia Shader Royale 2022\n// (https://www.shadertoy.com/view/md2GDD), not because of any particular reason\n// (KIFS fractals are very popular and I've done my share\n// https://www.shadertoy.com/view/lssGRM and https://www.shadertoy.com/view/4sX3R2)\n// but because sometimes you just see something pretty and that inspires to\n// attempt doing something on your own too.\n//\n// I'm using smooth-minimum and smooth-abs to blend all spheres together into a\n// single organic shape. The rest is color tweaking.\n//\n// The shader runs slow because I'm doing volumetric rendering so I get some sweet\n// transparencies. With regular raymarching this runs at 60 fps in a full screen,\n// but as usual I'm okey with doing something 4x slower if that makes it look\n// 10% better!\n\n\n// https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect( in vec3 ro, in vec3 rd, float ra )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - ra*ra;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n// https://iquilezles.org/articles/smin/\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = max( k-abs(a.x-b.x), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*0.5;\n    vec2 r = (a.x<b.x) ? vec2(a.x,m) : vec2(b.x,1.0-m);\n    return vec4(r.x-s, mix( a.yzw, b.yzw, r.y ) );\n}\n\n// https://iquilezles.org/articles/functions/\nfloat sabs( float x, float k )\n{\n    return sqrt(x*x+k);\n}\n\nvec2 rot( vec2 p, float a )\n{\n    float co = cos(a);\n    float si = sin(a);\n    return mat2(co,-si,si,co) * p;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//======================================================================\n// creature\n//======================================================================\n\n// euclidean distance to creature, and color at closest point\nvec4 map( in vec3 p, float time )\n{\n    float d1 = 0.10*sin(-time*6.283185/8.0 +  3.0*p.y); // animate body\n    float d2 = 0.05*sin( time*10.0         + 60.0*p.y); // animate flagellum\n\n    vec4 dcol = vec4(1e20,0.0,0.0,0.0);\n    float sc = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        // rotate coords\n        p.xz = rot(p.xz, 17.0*sc + d1*smoothstep( 5.0, 1.0,float(i))); // body\n        p.yz = rot(p.yz, -1.0*sc + d2*smoothstep(10.0,12.0,float(i))); // flagellum\n        \n        // smooth mirror and translate coords\n        p.x = sabs(p.x,0.0001*sc) - 0.22*sc;\n\n        // distance\n        float d = (i==19) ? length(p*vec3(1.0,1.0,0.1)) - 0.1*sc :\n                            length(p) - (0.1*sc + 0.001*sc*sin(2000.0*p.y*sc));\n        // color\n        vec3 c = (i==9) ? vec3(0.75) :\n                          vec3(0.4,0.2,0.2) + vec3(0.1,0.5,0.6)*float(i)/20.0 + 0.1*cos(vec3(0,1,2)-p*10.0);\n\n        // blend in distance and color\n        dcol = smin(dcol, vec4(d,c), 0.12*sc);\n    \n        // scale coords for next iteration\n        sc /= 1.2;\n    }\n    \n    return dcol;\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.01 + 0.4*float(i)/7.0;\n        vec3  w = normalize( nor + normalize(sin(float(i)+vec3(0,2,4))));\n        float d = map( pos + h*w, time ).x;\n        occ += h-d;\n    }\n    return clamp( 1.0 - 0.71*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float dis, in float time )\n{\n    const vec2 e = vec2(0.001,0.0);\n    return normalize( vec3( map( pos + e.xyy, time ).x,\n                            map( pos + e.yxy, time ).x,\n                            map( pos + e.yyx, time ).x)-dis );\n}\n\n//======================================================================\n// CITA - Crap In The Air\n//======================================================================\n\n// a 3D dithered grid of spheres\nvec4 mapCITA( in vec3 pos, in float time )\n{\n    pos.y += time*0.02;\n\n    const float rep = 1.5;\n    vec3 ip = floor(pos/rep);\n    vec3 fp = fract(pos/rep);\n    vec3 op = vec3( (fp.x<0.0)?-1.0:0.0, (fp.y<0.0)?-1.0:0.0, (fp.z<0.0)?-1.0:0.0 );\n    \n    // note we only need to check 8 cells, not 27\n    vec4 dr = vec4(1e20);\n    for( int i=0; i<2; i++ )\n    for( int j=0; j<2; j++ )\n    for( int k=0; k<2; k++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 id = ip + b + op;\n        \n        // random location per sphere\n        vec3 ra = fract(sin(dot(id,vec3(1,123,1231))+vec3(0,1,2))*vec3(338.5453123,278.1459123,191.1234));\n        vec3 o = 0.3*sin(6.283185*time/48.0 + 50.0*ra);\n        vec3 r = b - fp + o;\n        \n        float d = dot(r,r);\n        if( d<dr.x ) dr = vec4(d,r);\n    }\n    return vec4(sqrt(dr.x)*rep-0.02,dr.yzw);\n}\n\n// https://iquilezles.org/articles/raymarchingdf/\nvec4 raycastCITA( in vec3 ro, in vec3 rd, in float px, in float tmax, in float time )\n{\n    float t = 0.0;\n    vec3 res = vec3(0.0);\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        vec4 h = mapCITA( pos, time );\n        res = h.yzw;\n        if( h.x<0.0005*px*t || t>tmax ) break;\n\t\tt += h.x;\n\t}\n\treturn (t<tmax) ? vec4(t,res) : vec4(-1.0);\n}\n\n//======================================================================\n// rendering\n//======================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = mod( iTime, 48.0 );\n    \n    // camera location and lense\n    vec3  ta = 0.08*sin( 6.283185*time/24.0+vec3(0,2,4) );\n    vec3  ro = ta + 1.85*vec3( cos(7.0*mo.x), 0.25, sin(7.0*mo.x) );\n    float fl = 2.5;\n\n    if( time>9.0 && time<16.0) { ta.z += 0.1; fl = 5.0; }    \n    \n    // camera-to-world transformation and ray direction\n    mat3 ca = setCamera( ro, ta, 0.05 );\n    vec3 rd = normalize( ca*vec3(p,fl) );\n    \n    // background\n    vec3 back = vec3(0.0003,0.013,0.04)*(1.0-clamp(-1.25*rd.y,0.0,1.0));\n    \n    // render creature\n    float ft = -1.0;\n    vec3 col = back;\n    \n    // bounding sphere\n    vec2 b = sphIntersect( ro, rd, 1.2 );\n    if( b.y>0.0 )\n    {\n        // raymarch creature from bounding sphere's entry to exit point\n        vec4  sum = vec4(0.0);\n        float tmax = b.y;\n        float t = max(0.0,b.x);\n        for( int i=0; i<256 && t<tmax; i++ )\n        {\n            vec4  res = map( ro + t*rd, time );\n            float dis = res.x;\n            \n            // raymarching step size (outter vs inner)\n            float dt = (dis>0.0) ? dis*0.8+0.001 : (-dis+0.002);\n            \n            // inside creature\n            if( dis<0.0 )\n            {\n                // record depth-buffer\n                if( ft<0.0 ) ft=t; \n                \n                // local geometry (position, normal, convexity)\n                vec3  pos = ro + t*rd;\n                vec3  nor = calcNormal( pos, res.x, time );\n                float occ = calcAO( pos, nor, time );\n\n                // color and opacity\n                vec4 tmp = vec4(res.yzw*res.yzw,min(20.0*dt,1.0));\n\n                // main light\n                float ll = 15.0*exp2(-2.0*t);\n                tmp.rgb *= (0.5+0.5*dot(nor,-rd))*ll*3.0/(1.0+ll);\n                \n                // subsurface scattering\n                float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n                tmp.rgb += fre*fre*(0.5+0.5*tmp.rgb)*0.8;\n                \n                // occlusion\n                tmp.rgb *= 1.6*mix(tmp.rgb*0.1+vec3(0.2,0.0,0.0),vec3(1.0),occ*1.4);\n      \n                // fog\n                //tmp.rgb = mix( back, tmp.rgb, exp2(-0.1*t*vec3(4.0,3.5,3.0)/fl) );\n\n                // composite front to back, and exit if opaque\n                tmp.rgb *= tmp.a;\n                sum += tmp*(1.0-sum.a);\n                if( sum.a>0.995 ) break;\n            }\n            t += dt;\n        }\n\n        // composite with background\n        sum = clamp(sum,0.0,1.0);\n        col = col*(1.0-sum.w) + sum.xyz;\n    }\n    \n    // render cita\n    vec4  cita = raycastCITA( ro, rd, 2.0/fl, (ft>0.0) ? ft : 15.0, time );\n    if( cita.x>0.0 )\n    {\n        // color\n        vec3 citacol = vec3(0.9,1.0,1.0);\n        // fog\n        citacol = mix( back, citacol, exp2(-0.1*cita.x*vec3(4.0,3.5,3.0)/fl) );\n        // blend in\n        float fre = clamp(dot(normalize(cita.yzw),rd),0.0,1.0);\n        col = mix( col, citacol, fre*0.3 );\n    }\n\n    // gain\n    //col = col*3.0/(3.0+col);\n    \n    // gamma and color tweak\n    col = pow( col, vec3(0.45,0.5,0.5) );\n    \n    // vignette\n    col *= 1.2 - 0.35*length(p);\n    \n    // dither to remove banding in the background\n    col += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n \n    // return color\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3zy.jpg", "access": "api", "license": "proprietary-license", "functions": [[1510, 1559, 1614, 1614, 1770], [1772, 1813, 1851, 1851, 2050], [2052, 2098, 2130, 2130, 2156], [2158, 2158, 2187, 2187, 2270], [2272, 2272, 2324, 2324, 2501], [2662, 2724, 2759, 2759, 3810], [3812, 3869, 3926, 3926, 4214], [4216, 4262, 4320, 4320, 4533], [4708, 4741, 4785, 4785, 5608], [5610, 5660, 5747, 5747, 6022], [6184, 6184, 6241, 6260, 9678]], "test": "untested"}
{"id": "msBGzG", "name": "Eyes by hugolnx", "author": "hugolnx", "description": "Eyes", "tags": ["eyes", "art", "hugolnx"], "likes": 1, "viewed": 49, "published": 3, "date": "1667780687", "time_retrieved": "2024-07-30T16:21:32.326914", "image_code": "#define SHADERTOY 1\n//#define VERTICAL 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float minV, float maxV, float v) {\n    return step(minV, v) * step(v, maxV);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\nvec3 togrey(vec3 c) {\n  return vec3((c.r+c.g+c.b)/3.);\n}\nfloat normrange(float v, float minV, float maxV) { return sat((v-minV)/(maxV-minV)); }\nfloat xnormrange(float v, float minV, float maxV) { return normrange(v, minV, maxV) * xstep(minV, maxV, v); }\nvec3 mix3(vec3 cMin, vec3 cMid, vec3 cMax, float t) {\n  float t1 = normrange(t, -1., 0.);\n  float t2 = normrange(t, 0., 1.);\n  vec3 c = mix(cMin, cMid, t1);\n  c = mix(c, cMax, t2);\n  return c;\n}\n\n// -------------------\n// BEGIN https://github.com/stegu/webgl-noise\n// -------------------\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod7(vec3 x) {return x - floor(x * (1.0 / 7.0)) * 7.0;}\nvec3 permute(vec3 x) {return mod289((34.0 * x + 10.0) * x);}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Cellular\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nvec2 ncellular(vec2 p, float seed) {\n  p *= 15.;\n  seed *= 0.3;\n  return cellular(vec3(p, seed));\n}\n\n// Classic Perlin noise\nfloat perlin(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat nperlin(vec2 p, float seed) {\n  p *= 20.;\n  seed *= 0.5;\n  return norm(perlin(vec3(p, seed)));\n}\n\n// Simplex Noise\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat nsimplex(vec2 x, float seed) {\n  x *= 10.;\n  seed *= 0.3;\n  return norm(simplex(vec3(x, seed)));\n}\n\n\n// -------------------\n// END noise3D\n// -------------------\n\n// -------------------\n// BEGIN https://www.shadertoy.com/view/4dS3Wd\n// -------------------\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat morgan(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat morgan(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat morgan(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat nmorgan(float x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x, float seed) {\n  x *= 20.;\n  seed *= 0.5;\n  return morgan(vec3(x, seed));\n}\n// -------------------\n// END Morgan Noises\n// -------------------\n\n\n// -------------------\n// BEGIN http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// -------------------\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 P = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, P.wz) : vec4(c.gb, P.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    // vec4 p = mix(vec4(c.bg, P.wz), vec4(c.gb, P.xy), step(c.b, c.g));\n    // vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 P = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + P.xyz) * 6.0 - P.www);\n    return c.z * mix(P.xxx, clamp(p - P.xxx, 0.0, 1.0), c.y);\n}\n// -------------------\n// END HSV Conversion \n// -------------------\n\nvec3 hsv(float h, float s, float v) {return hsv2rgb(vec3(h, s, v));}\n\n\n// Noise Aux Functions\nfloat random(vec2 uv, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(uv, vec2(a, b)) + seed) * c);\n}\n\n#define OCTAVES 6\n#define OCTAVES_F 6.0\n\n// Simplex Variations\n#define SIMPLEX_VARS_SCALE 1.0\nfloat turbSimplex( vec3 p ) {\n  p *= SIMPLEX_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(100.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( simplex( power * p + shift ) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbSimplex(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.08;\n  return 1.-sat(-1.2*turbSimplex(vec3(p, seed)));\n}\n\nfloat nturb2Simplex(vec2 st2, float seed) {\n  seed *= 0.04;\n  vec3 st = vec3(st2, seed);\n  st *= SIMPLEX_VARS_SCALE * 3.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(200.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(simplex(st));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, .0, 1.);\n}\n\nfloat fbmSimplex(vec3 x) {\n  x *= SIMPLEX_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(300.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * simplex(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmSimplex(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmSimplex(vec3(x, seed)));\n}\n\n\n// Morgan Variations\n#define MORGAN_VARS_SCALE 2.5\nfloat turbMorgan( vec3 p ) {\n  p *= MORGAN_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(0.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(morgan( power * p + shift )) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbMorgan(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.05;\n  return 1.-sat(-2.0*turbMorgan(vec3(p, seed)));\n}\n\nfloat nturb2Morgan(vec2 st2, float seed) {\n  seed *= 0.03;\n  vec3 st = vec3(st2, seed);\n  st *= MORGAN_VARS_SCALE * 6.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(0.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(morgan(st)));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmMorgan(vec3 x) {\n  x *= MORGAN_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = .9;\n\tvec3 shift = vec3(0.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * (denorm(morgan(x))+0.05);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmMorgan(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmMorgan(vec3(x, seed)));\n}\n\n\n\n// Cellular Variations\n#define CELLULAR_VARS_SCALE 1.5\nfloat turbCellular( vec3 p ) {\n  p *= CELLULAR_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(700.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(cellular( power * p + shift ).x) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbCellular(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.07;\n  return sat(0.85+2.*turbCellular(vec3(p, seed)));\n}\n\nfloat nturb2Cellular(vec2 st2, float seed) {\n  seed *= 0.02;\n  vec3 st = vec3(st2, seed);\n  st *= CELLULAR_VARS_SCALE * 5.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(800.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(cellular(st).x));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmCellular(vec3 x) {\n  x *= CELLULAR_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(900.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * denorm(cellular(x).x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmCellular(vec2 x, float seed) {\n  seed *= 0.1;\n  x *= 5.;\n  return norm(fbmCellular(vec3(x, seed)));\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n#define WRED vec3(1., .8, .8)\n#define WGRE vec3(.8, 1., .8)\n#define WBLU vec3(.8, .8, 1.)\n#define BLU2 vec3(0.35, 0.5, 1.)\n#define PUR vec3(1., 0., 1.)\n#define YEL vec3(1., 1., 0.)\n#define CYA vec3(0., 1., 1.)\n#define WHI vec3(1.)\n#define BLA vec3(0.)\n#define BLANK vec3(0.35, 0., 0.35)\n\n// RGB(0,255,170)\n#define C1 vec3(0.,255.,170.)/255.\n\n// RGB(255,195,0)\n#define C2 vec3(255.,195.,0.)/255.\n\nstruct noiseSpecs {\n  float n1;\n  vec3 n1Color;\n  float n2;\n  vec3 n2Color;\n  float n3;\n  vec3 n3Color;\n  float nFinal;\n  vec3 nFinalColor;\n};\n\nnoiseSpecs getNoise(vec2 uv, float t) {\n  noiseSpecs o;\n  float tseed = t; //sin(t*.5) ; //floor(t*0.1);\n  float seed  = tseed;\n  float seed2 = tseed + 373.297;\n  float seed3 = tseed + 793.713;\n  float seed4 = tseed + 127.139;\n  float seed5 = tseed + 929.197;\n#ifdef VERTICAL\n  uv = vec2(uv.y, uv.x);\n#endif\n  vec2 roll = -0.05*t*vec2(1.);\n  // uv += roll;\n\n  float v = 0.;\n  float v1 = 0.;\n  float v2 = 0.;\n  float v3 = 0.;\n\n  vec2 ouv = uv;\n  vec2 nUV = ouv * .9;\n\n  float tmpZoom = 1.;//7.;\n  float bv1_turb = ncos(nsimplex(nUV*9., seed) * 50.);\n  bv1_turb = bv1_turb*.2 + .8/2.;\n\n  //float bv2_a = nturb2Simplex(uv*4./tmpZoom, seed2);\n  float bv2_a_fbm = nfbmCellular(nUV*4./tmpZoom, seed3);\n  float bv2_a = ncos(bv2_a_fbm*4.);\n\n  //float bv2_b = nturb2Simplex(uv*.5/tmpZoom, seed3);\n  float bv2_b_fbm = nfbmCellular(nUV/tmpZoom, seed2);\n  float bv2_b = ncos(bv2_b_fbm*10.);\n\n  float bv2 = sat(bv2_a*.6 + bv2_b*.6);\n  bv2 = mix(.15, .45, bv2);\n\n  float bv3_fbm = nfbmCellular(nUV*15./tmpZoom, seed);\n  float bv3 = smoothstep(.0, .8, bv3_fbm);\n\n  float final = bv1_turb*0.2 + bv2*0.8;\n  final = mix(final*.3, final, bv3);\n  final = smoothstep(.0, .5, final);\n  final = mix(.15, .45, final);\n\n  float eyeballrad = .17;\n  float blackrad = .09;\n  vec2 pt1 = vec2(-.12, .0);\n  float pt1dist = length(uv - pt1);\n  vec2 pt2 = vec2(.12, .0);\n  float pt2dist = length(uv - pt2);\n\n  float dist = min(pt1dist, pt2dist);\n  final *= (1.-step(eyeballrad, dist)) * (1.-smoothstep(eyeballrad-.1, eyeballrad, dist));\n\n  float turb = nturbSimplex(uv*20., seed*10.);\n  final *= mix(step(blackrad, dist+denorm(turb)*.04), 1., smoothstep(blackrad-.07, blackrad, dist));\n\n  o.n1 = bv1_turb;\n  o.n2 = bv2;\n  o.n3 = bv3;\n  o.nFinal = final;\n  \n  uv = ouv;\n  float c1_fbm = nfbmCellular(uv*4., seed4*20.);\n  c1_fbm = smoothstep(.0, 1., c1_fbm);\n  vec3 c1 = mix(C1, WHI, .8);\n\n  float c2_fbm = nfbmCellular(uv*2., seed5);\n  c2_fbm = smoothstep(.45, .55, c2_fbm);\n\n  \n  //float c2_fbm = nfbmCellular(uv*15., seed4);\n  //c2_fbm = smoothstep(.0, .7, c1_fbm);\n  vec3 c2 = mix(C2, WHI, .4);\n  vec3 c2strong = mix(C2, WHI, .15)*.9;\n  vec3 c2weak = mix(C2, WHI, .7)*.9;\n\n  float sideMix = 1.-smoothstep(-.05, .05, uv.x);\n  vec3 ca = mix(c2, c2weak, sideMix);\n  vec3 cb = mix(c1, c2strong, sideMix);\n\n  o.n1Color = WHI;\n  o.n2Color = WHI;\n  o.n3Color = WHI;\n  o.nFinalColor = mix(ca, cb, c1_fbm);\n\n  return o;\n}\n\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from -0.5 to 0.5)\n  //float mx = max(iResolution.x, iResolution.y);\n#ifdef VERTICAL\n  float mx = iResolution.y;\n#else\n  float mx = iResolution.x;\n#endif\n  vec2 ct = iResolution.xy / mx / 2.0;\n  vec2 uv = fragCoord/mx - ct;\n  vec2 uv2 = fragCoord / iResolution.xy - .5;\n\n  float t = iTime;\n  float loopDuration = 30.;\n  float modloop = mod(t, loopDuration);\n  float modhalf = mod(t, loopDuration*.5);\n  float pt2 = step(loopDuration*.5, modloop);\n  float pt1 = 1.-pt2;\n  t = pt1*modhalf + pt2*(loopDuration*.5-modhalf);\n  t *= .15;\n\n\n  float allZoom = 1.;\n  vec2 uvZoom1 = uv / allZoom;\n  vec2 uvZoom2 = uvZoom1 / 2.;\n\n  noiseSpecs noises2 = getNoise(uvZoom2, t);\n\n  noiseSpecs n = noises2;\n  fragColor = vec4(n.nFinalColor * n.nFinal, 1.);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 130, 130, 150], [151, 151, 174, 174, 194], [195, 195, 241, 241, 285], [286, 286, 332, 332, 379], [380, 380, 418, 418, 460], [461, 461, 482, 482, 512], [513, 513, 534, 534, 564], [565, 565, 586, 586, 616], [617, 617, 637, 637, 662], [663, 663, 684, 684, 711], [712, 712, 759, 759, 815], [816, 816, 867, 867, 924], [925, 925, 946, 946, 981], [982, 982, 1032, 1032, 1068], [1069, 1069, 1120, 1120, 1178], [1179, 1179, 1232, 1232, 1373], [1468, 1468, 1489, 1489, 1534], [1535, 1535, 1556, 1556, 1601], [1602, 1602, 1621, 1621, 1662], [1663, 1663, 1685, 1685, 1723], [1724, 1724, 1746, 1746, 1780], [1781, 1781, 1808, 1808, 1856], [1857, 1857, 1876, 1876, 1912], [1914, 1926, 1949, 1949, 6756], [6758, 6758, 6794, 6794, 6857], [6859, 6883, 6905, 6905, 9200], [9202, 9202, 9237, 9237, 9304], [9306, 9323, 9348, 9348, 11487], [11489, 11489, 11525, 11525, 11593], [11658, 11825, 11846, 11846, 11913], [11914, 11914, 11934, 11934, 12039], [12041, 12041, 12064, 12064, 12196], [12198, 12198, 12220, 12220, 12854], [12857, 12857, 12879, 12879, 13640], [13642, 13642, 13666, 13666, 13700], [13701, 13701, 13724, 13724, 13758], [13759, 13759, 13794, 13794, 13855], [13925, 14036, 14058, 14058, 14519], [14521, 14521, 14543, 14543, 14712], [14783, 14783, 14820, 14820, 14851], [14854, 14877, 14912, 14912, 15060], [15156, 15156, 15185, 15185, 15419], [15421, 15421, 15461, 15461, 15540], [15542, 15542, 15585, 15585, 15907], [15909, 15909, 15935, 15935, 16146], [16148, 16148, 16187, 16187, 16257], [16311, 16311, 16339, 16339, 16577], [16579, 16579, 16618, 16618, 16696], [16698, 16698, 16740, 16740, 17067], [17069, 17069, 17094, 17094, 17316], [17318, 17318, 17356, 17356, 17425], [17484, 17484, 17514, 17514, 17760], [17762, 17762, 17803, 17803, 17883], [17885, 17885, 17929, 17929, 18264], [18266, 18266, 18293, 18293, 18516], [18518, 18518, 18558, 18558, 18629], [18632, 18632, 18666, 18666, 18748], [19377, 19377, 19416, 19416, 21758], [21932, 21932, 21989, 22092, 22766]], "test": "untested"}
{"id": "msjGWD", "name": "using modulo to repeat a pattern", "author": "jonasfrey", "description": "modulo is so neat", "tags": ["modulo"], "likes": 1, "viewed": 348, "published": 3, "date": "1667778116", "time_retrieved": "2024-07-30T16:21:33.500776", "image_code": "const float n_tau = 6.2831;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_mouse_coords_normalized = iMouse.xy / iResolution.xy; \n    vec2 a_n_pixel_coords_normalized = fragCoord.xy / iResolution.xy; \n    float n_amp = 0.3;\n    float n_y = sin(a_n_pixel_coords_normalized.x * n_tau) * n_amp + 0.5;\n    \n    float n_distance_to_sine = length(\n        a_n_pixel_coords_normalized\n        -\n        vec2(\n            a_n_pixel_coords_normalized.x,\n            n_y\n        )\n    );\n    \n    float n_brightness = n_distance_to_sine; \n    // now we can do modulo\n    float n_mod_max = 0.1;\n    n_brightness = mod(n_brightness, n_mod_max);\n    // now we can also normalize it\n    n_brightness = n_brightness / n_mod_max;\n    \n    fragColor = vec4(n_brightness);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 786]], "test": "untested"}
{"id": "ms2GWR", "name": "builtin-basics length", "author": "jonasfrey", "description": "this is the start of a series where i try to manually implement every built-in function to get a better understanding of it", "tags": ["basics"], "likes": 2, "viewed": 215, "published": 3, "date": "1667778089", "time_retrieved": "2024-07-30T16:21:37.571891", "image_code": "// this is an example of how builtin functions work\n// i will try to programm the function manually \n// to get an understanding of how it works\n\nfloat f_n_distance(\n    vec2 a_n_start, \n    vec2 a_n_end\n){\n    vec2 a_n_delta = vec2(\n        a_n_start.x - a_n_end.x, \n        a_n_start.y - a_n_end.y\n    );\n    float n_distance_square = \n        pow(a_n_delta.x,2.0) + \n        pow(a_n_delta.y,2.0);\n        \n    float n_distance_sqrt = sqrt(n_distance_square);\n    \n    return n_distance_sqrt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_pixel_coords_normalized = fragCoord.xy / iResolution.xy;\n    float n = 0.0;\n    if(a_n_pixel_coords_normalized.x < 0.5){\n        vec2 a_n_center1 = vec2(0.25,0.5);\n        n = f_n_distance(\n            a_n_pixel_coords_normalized, \n            a_n_center1\n        );    \n    }\n    if(a_n_pixel_coords_normalized.x > 0.5){\n        vec2 a_n_center2 = vec2(0.75,0.5);\n        n = length(\n            a_n_pixel_coords_normalized\n            -\n            a_n_center2\n        );\n    }\n    fragColor = vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2GWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 205, 205, 495], [497, 497, 554, 554, 1074]], "test": "untested"}
{"id": "DdjGzw", "name": "blur with a kernal size by mouse", "author": "jonasfrey", "description": "click and drag mouse along x-axis for more or less blur, \nif you want to challange your GPU, change the variable `n_max_kernel_size` to 1000.0, and enjoy the frame freeze ;)\n", "tags": ["mouse", "blur", "kernel"], "likes": 1, "viewed": 155, "published": 3, "date": "1667778069", "time_retrieved": "2024-07-30T16:21:38.515368", "image_code": "float f_n_distance(\n    float n_x, \n    float n_y, \n    float n_x2, \n    float n_y2\n){\n\n    float n_delta_x = n_x - n_x2;\n    float n_delta_y = n_y - n_y2;\n    \n    float n_distance_pow = pow(n_delta_x,2.0) + pow(n_delta_y,2.0);\n    float n_distance_sqrt = sqrt(n_distance_pow); \n    return n_distance_sqrt;\n}\n\nvec4 f_a_n_blurred(\n    float n_scale_x_kernel, \n    float n_scale_y_kernel, \n    float n_x_kernel, \n    float n_y_kernel\n){\n    \n    vec4 a_n_rgba_sum = vec4(0.0,0.0,0.0,0.0);\n    int n_x = 0; \n    int n_y = 0; \n    for(int n_y; n_y < int(n_scale_y_kernel); n_y+=1){\n        for(int n_x; n_x < int(n_scale_x_kernel); n_x+=1){\n            //int n_x_current = n_x - int(float(n_scale_x_kernel)/2.0);\n            //int n_x_current = n_y - int(float(n_scale_y_kernel)/2.0);\n            vec2 n_coords_normalized_kernel = vec2(\n                float(n_x) + n_x_kernel - float(n_scale_x_kernel)/2.0, \n                float(n_y) + n_y_kernel - float(n_scale_y_kernel)/2.0\n            )/iResolution.xy;\n            a_n_rgba_sum+=texture(\n                iChannel0,\n                n_coords_normalized_kernel \n                \n            );\n        }\n    }\n    return a_n_rgba_sum / (n_scale_x_kernel * n_scale_y_kernel);\n}\nvec4 f_a_n_blurred_ignore_out_of_bounds(\n    float n_scale_x_kernel, \n    float n_scale_y_kernel, \n    float n_x_kernel, \n    float n_y_kernel\n){\n    \n    vec4 a_n_rgba_sum = vec4(0.0,0.0,0.0,0.0);\n    int n_x = 0; \n    int n_y = 0; \n    int n_count =0;\n    for(int n_y; n_y < int(n_scale_y_kernel); n_y+=1){\n        for(int n_x; n_x < int(n_scale_x_kernel); n_x+=1){\n            float n_x_target = float(n_x) + n_x_kernel - float(n_scale_x_kernel)/2.0;\n            float n_y_target = float(n_y) + n_y_kernel - float(n_scale_y_kernel)/2.0;\n            if(\n                n_x_target >= 0.0  && n_x_target <= float(iResolution.x\n)                &&\n                n_y_target >= 0.0  && n_y_target <= float(iResolution.y)\n                \n            ){\n                //int n_x_current = n_x - int(float(n_scale_x_kernel)/2.0);\n                //int n_x_current = n_y - int(float(n_scale_y_kernel)/2.0);\n                vec2 n_coords_normalized_kernel = vec2(n_x_target, n_y_target)/iResolution.xy;\n                a_n_rgba_sum+=texture(\n                    iChannel0,\n                    n_coords_normalized_kernel \n\n                );\n                n_count +=1;\n            }\n\n        }\n    }\n    return a_n_rgba_sum / float(n_count);\n}\nvec4 f_a_n_blurred_ignore_out_of_bounds_gaussian(\n    float n_scale_x_kernel, \n    float n_scale_y_kernel, \n    float n_x_kernel, \n    float n_y_kernel\n){\n    float n_distance_to_kernel_max = f_n_distance(\n        0.0, \n        0.0, \n        n_scale_x_kernel, \n        n_scale_y_kernel\n    );\n    \n    vec2 n_coords_kernel_normalized = vec2(n_x_kernel, n_y_kernel) / iResolution.xy;\n    vec4 a_n_rgba_sum = vec4(0.0,0.0,0.0,0.0);\n    int n_x = 0; \n    int n_y = 0; \n    int n_count =0;\n    for(int n_y; n_y < int(n_scale_y_kernel); n_y+=1){\n        for(int n_x; n_x < int(n_scale_x_kernel); n_x+=1){\n            float n_x_target = float(n_x) + n_x_kernel - float(n_scale_x_kernel)/2.0;\n            float n_y_target = float(n_y) + n_y_kernel - float(n_scale_y_kernel)/2.0;\n            if(\n                n_x_target >= 0.0  && n_x_target <= float(iResolution.x\n)                &&\n                n_y_target >= 0.0  && n_y_target <= float(iResolution.y)\n                \n            ){\n                vec2 n_coords_target_normalized = vec2(n_x_target, n_y_target) / iResolution.xy;\n                float n_distance_to_center = f_n_distance(\n                    n_coords_target_normalized.x, \n                    n_coords_target_normalized.y, \n                    n_coords_kernel_normalized.x, \n                    n_coords_kernel_normalized.y\n                );\n                \n                vec2 n_coords_normalized_kernel = vec2(n_x_target, n_y_target)/iResolution.xy;\n                a_n_rgba_sum+=(texture(\n                    iChannel0,\n                    n_coords_normalized_kernel \n                ))*(1.0-(n_distance_to_center/n_distance_to_kernel_max));\n                n_count +=1;\n            }\n\n        }\n    }\n    return a_n_rgba_sum / float(n_count);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 a_n_coords_normalized_mouse = iMouse.xy / iResolution.xy;\n    vec2 a_n_coords_normalized_pixel = fragCoord.xy / iResolution.xy; \n    \n\n    float n_max_kernel_size = 100.0;\n    float n_kernel = n_max_kernel_size * a_n_coords_normalized_mouse.x;\n    vec4 a_n_rgba_blurred = vec4(0.0,0.0,0.0,0.0);\n    if(a_n_coords_normalized_pixel.x < 1.0/3.0){\n      fragColor = f_a_n_blurred(\n            n_kernel,\n            n_kernel,\n            fragCoord.x,\n            fragCoord.y\n       );\n       return;\n     }\n    if(a_n_coords_normalized_pixel.x < 2.0/3.0){\n        fragColor = f_a_n_blurred_ignore_out_of_bounds(\n            n_kernel,\n            n_kernel,\n            fragCoord.x,\n            fragCoord.y\n       );\n       return;\n    }\n    if(a_n_coords_normalized_pixel.x < 3.0/3.0){\n        fragColor = f_a_n_blurred_ignore_out_of_bounds_gaussian(\n            n_kernel,\n            n_kernel,\n            fragCoord.x,\n            fragCoord.y\n       );\n       return;\n    }\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 309], [311, 311, 435, 435, 1226], [1227, 1227, 1372, 1372, 2468], [2469, 2469, 2623, 2623, 4239], [4240, 4240, 4297, 4347, 5328]], "test": "untested"}
{"id": "ddBGzG", "name": "distance to multiple points ", "author": "jonasfrey", "description": "distance to multiple points with an offset in the animation", "tags": ["distance", "points", "offset"], "likes": 1, "viewed": 143, "published": 3, "date": "1667778040", "time_retrieved": "2024-07-30T16:21:39.268355", "image_code": "const float n_tau = 6.2831;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float n_amp = sin(iTime*0.5);\n    float n_max_points = 5.0;\n    vec2 o_pix_cor_nor = fragCoord.xy / iResolution.xy; \n    vec2 o_pix_cor_nor_trans = o_pix_cor_nor-vec2(0.0, 0.0); \n    fragColor = vec4(1.0);\n    float n_dist_lowest = 1.0;\n    float n_rot_glob = iTime;\n    \n    float n_x_max = 10.0;\n    float n_y_max = 10.0; \n\n    float n_col_fact = 1.0;\n    float n_index_norm = 0.0;\n\n    for(float n_x_norm = 0.0; n_x_norm<1.0; n_x_norm+=(1.0/n_x_max)){\n        for(float n_y_norm = 0.0; n_y_norm<1.0; n_y_norm+=(1.0/n_y_max)){\n        \n            n_index_norm += 1.0/(n_x_max*n_y_max);\n        \n        \n            vec2 o_p = vec2(\n                n_x_norm,\n                n_y_norm\n            );\n\n            float n_dist = length(o_p - o_pix_cor_nor_trans);\n            if(n_dist < n_dist_lowest){\n                n_dist_lowest = n_dist;\n                n_col_fact = n_index_norm;\n                \n            }\n        \n        }\n        \n    }\n    \n    float n_dist_max = length(vec2(0.0,0.0) - vec2(1.0/n_x_max, 1.0/n_y_max));\n    float n_dist_lowest_norm = n_dist_lowest / n_dist_max; \n    fragColor *= vec4(n_dist_lowest_norm*sin(iTime+(n_col_fact*10.0)));\n    //fragColor *= vec4(n_dist_lowest);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 1307]], "test": "untested"}
{"id": "msSGzG", "name": "n_dist_lowest", "author": "jonasfrey", "description": "per pixel calculate multiple distances to a multiple points and then take the lowest", "tags": ["distance"], "likes": 1, "viewed": 148, "published": 3, "date": "1667777024", "time_retrieved": "2024-07-30T16:21:40.118083", "image_code": "const float n_tau = 6.2831;\nfloat  f_ease_in_out_sine(float n){\n    return -(cos((n_tau/2.0) * n) - 1.0) / 2.0;\n}\n\nvec4 f_o_color_by_dist(float n_dist, vec3 o_c){\n    float n = 10.0;\n    float n_mod = 1.0/n;\n    float n_dist_mod = mod(n_dist,n_mod);\n    float n_dist_mod_norm = n_dist_mod/n_mod;\n    float n_mod_index = floor(n_dist / n_mod);\n    float n_dist_mod_norm_eased = sin(n_dist_mod_norm*(n_tau/2.0*n_mod_index*0.5));\n    return vec4(\n        mod(o_c.r * n_dist_mod_norm+n_dist, 1.0),\n        o_c.g * n_dist_mod_norm,\n        o_c.b * n_dist_mod_norm,\n        1.0\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float n_amp = sin(iTime*0.5);\n    float n_max_points = 5.0;\n    vec2 o_pix_cor_nor = fragCoord.xy / iResolution.xy; \n    vec2 o_pix_cor_nor_trans = o_pix_cor_nor-vec2(0.5, 0.5); \n    fragColor = vec4(1.0);\n    float n_dist_lowest = 1.0;\n    float n_rot_glob = iTime;\n\n\n    for(float n_i_point_norm = 0.0; n_i_point_norm<1.0; n_i_point_norm+=(1.0/n_max_points)){\n        \n        vec2 o_p = vec2(\n            sin(n_i_point_norm*n_tau+n_rot_glob)*n_amp,\n            cos(n_i_point_norm*n_tau+n_rot_glob)*n_amp\n        );\n        \n        float n_dist = length(o_p - o_pix_cor_nor_trans);\n        if(n_dist < n_dist_lowest){\n            n_dist_lowest = n_dist;\n        }\n        //fragColor = vec4(mix(fragColor.r, n_dist, 0.5));\n        \n    }\n    \n    vec3 a_o_col[] = vec3[](\n      vec3(0.1, 0.9, 0.2),\n      vec3(mod(sin(iTime),1.0), n_dist_lowest, 1.0-n_dist_lowest),\n      vec3(0.9, 0.1, 0.4)\n    );\n    float n_index_a_o_col = 0.0;\n    if(n_amp < 0.0){\n        n_index_a_o_col = mod(n_index_a_o_col+1.0, float(a_o_col.length()));\n    }\n    \n    fragColor *= vec4(f_o_color_by_dist(n_dist_lowest, \n       a_o_col[int(n_index_a_o_col)]\n    ));\n    //fragColor *= vec4(n_dist_lowest);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 63, 63, 113], [115, 115, 162, 162, 580]], "test": "untested"}
{"id": "DsSGRy", "name": "Reflected infinity", "author": "kishimisu", "description": "Move the camera with the mouse", "tags": ["reflection", "refraction", "domain", "glass", "art", "geometric", "crystal"], "likes": 43, "viewed": 941, "published": 3, "date": "1667771906", "time_retrieved": "2024-07-30T16:21:40.953848", "image_code": "/* @kishimisu - 2022 \n\n   Playing with reflection and refraction */\n\n#define AA 2\n\n#define PI 3.141592\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define impulse(freq, off) pow(smoothstep(0., .5, sin(off+(iTime-4.5)*freq)*.5+.5), 10.)\n\nfloat sdBox(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.0;\n}\n\n// x: distance to box\n// y: distance to shape\n// z: min absolute distance to scene\nvec3 map(vec3 p) {\n    float box = sdBox(p, vec3(.9, 1.5, .9)) - .05;\n     \n    // animations\n    p.xy *= rot(impulse(.3,PI)*3.14); // xy rotation\n    p.xz *= rot(impulse(.2,0.)*1.57); // xz rotation\n    p = abs(abs(p) - impulse(1.,PI)*.4); // first domain rep\n    p = mix(p, abs(p*2. - .3), impulse(.5,0.)); // second domain rep\n    float shape = mix(length(p) - .25, sdBox(p, vec3(.25)), impulse(2., 0.))*.5; // box/sphere\n    \n    shape = max(box, shape);\n    return vec3(box, shape, min(abs(box), shape));\n}\n\nvec3 normal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + k.xxx*map( p + k.xxx*h ).x );\n}\n\n// refract, or reflect if total internal refraction\nvec3 rrefract(vec3 rd, vec3 n, float ior) {\n    vec3   r = refract(rd, n, ior);\n    return r == vec3(0.) ? reflect(rd, n) : r;\n}\n\nvoid initRayOriginAndDirection(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.;\n    \n    float z = iMouse.z > 0. ? 1. : smoothstep(0., 6., iTime);\n    ro = vec3(0., 0., 4.2); \n    ro.yz *= rot(iMouse.z > 0. ? m.y*1.5 : -1.5 + mix(0.5, 1.85, z));\n    ro.zx *= rot(m.x*2.+iTime*.2);\n        \n    vec3 f = normalize(vec3(0.,.2,0.)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f,r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {                  \n    vec3 tot; for (int j = 0; j < AA; j++) for (int k = 0; k < AA; k++) { // antialiasing code \n    vec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n    \n    vec3 ro, rd;\n    initRayOriginAndDirection(fragCoord+o/2., ro, rd);\n    \n    vec3 bgColor = mix(vec3(.17,.0,.16), vec3(0.,0.,.12), rd.y-.3)*.8;\n    vec3 tintColor = vec3(1.,.5,.5) + .07*sin(vec3(1.4,.54,1.23)*iTime*.3);\n    \n    vec3 p = ro, color = bgColor;\n    float i, t, inside, entry, fresnel;\n    const float ior = 1.7;\n    \n    for (i = 0.; i < 150.; i++) {\n        vec3 d = map(p);\n\n        if (d.y < .001) {\n            // sphere hit\n            color = tintColor;\n            break;\n        }\n        \n        p += d.z*rd;\n        t += d.z;\n        \n        if (inside < .5) {\n            if (d.x < .001) { \n                // first box hit\n                vec3 n = normal(p);\n                fresnel = pow(1. - clamp(-dot(rd, n), 0., 1.), 4.);\n                rd = rrefract(rd, n, 1./ior);\n                p += rd*.04;\n                entry = t;\n                inside++;\n            }\n        } else {\n            if (d.x > -.001) {\n                // inside box bounces\n                vec3 n = normal(p);\n                rd = reflect(rd, n);\n                p += rd*.1;\n                inside++;\n            }       \n\n        }\n        if (inside > 6. || t > 15.) break;\n    }\n    \n    if (inside > 0.) {\n        float att = exp(-(t-entry)*.3);\n        color = mix(bgColor*.7, color - vec3(.5,.5,2.)*fresnel, exp(-i*.005) * att);\n    }\n    tot += color;\n\n} tot /= float(AA*AA); // antialiasing code\n  fragColor.rgb = tot;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 275, 275, 365], [367, 450, 468, 468, 961], [963, 963, 984, 984, 1207], [1209, 1261, 1304, 1304, 1389], [1391, 1391, 1469, 1469, 1918], [1920, 1920, 1977, 1977, 3595]], "test": "untested"}
{"id": "DsBGzy", "name": "colour picker using hsv and phi.", "author": "sh1boot", "description": "Something sort of like that example I saw once which tries to pick an arbitrary number of distinct colours with stable first choices.", "tags": ["palette"], "likes": 5, "viewed": 184, "published": 3, "date": "1667768753", "time_retrieved": "2024-07-30T16:21:41.846462", "image_code": "vec3 hsv2rgb(float h, float s, float v) {\n    vec3 h3 = mod(6.0 * h + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return pow(v - v * s * h3, vec3(1.0/2.4));\n}\n\nvec3 palette(int i) {\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(h, s, v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r = floor(uv.x * 6.0) / 7.1;\n    float t = 3.0 + 12.0 * (0.5 + 0.5 * cos(iTime * r));\n    float u = sin(iTime * r) * 8.0;\n\n    int i = int(floor(uv.y * t + u));\n\n    vec3 col = palette(i);\n    //col = hsv2rgb(uv.y, uv.x, 1.0);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 203], [205, 205, 226, 226, 407], [410, 410, 467, 517, 854]], "test": "untested"}
{"id": "Ddj3Wh", "name": "Textured Cloth", "author": "fenix", "description": "New cloth rendering method (for me) that is able to add texture.\nTexture borrowed from the beautiful Fractal mosaic 30 (music) by jarble: https://www.shadertoy.com/view/csl3zl\n\n*mouse to move camera* \n*space to reset*", "tags": ["3d", "simulation", "texture", "particles", "shadows", "physics", "integration", "cloth", "fabric"], "likes": 24, "viewed": 505, "published": 3, "date": "1667767805", "time_retrieved": "2024-07-30T16:21:42.913609", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  The third in my series of attempts at cloth shaders, see also: \n//\n//      Tearable 3D Fishnet       https://www.shadertoy.com/view/NlKBW3\n//      Cloth Draping + Shadows   https://www.shadertoy.com/view/cdjGRR\n//\n//  Texture borrowed from jarble's beautiful:\n//\n//      Fractal mosaic 30 (music) https://www.shadertoy.com/view/csl3zl\n//\n//  I got this new rendering method to work, but it has some major limitations. I\n//  just barely managed to cobble together (what I hope is) an interesting-looking\n//  shader despite them.\n//\n//  I have not seen a cloth renderer like this before...this is my own idea. The\n//  concept is to take the voronoi closest particles as \"guesses\" to the correct\n//  quad to render for a particular pixel. Then we refine that guess by searching\n//  over the cloth mesh. This way the voronoi doesn't even need to be very good\n//  because as long as the cloth is flat towards the screen, we can find the\n//  correct quad with just a few iterations.\n//\n//  The huge problem is that findQuad fails to find a good quad whenever there\n//  are a lot of verties bunched up on one pixel. This happens all the time as the\n//  cloth drapes over objects, so I had to greatly limit the amount the balls push\n//  into the cloth, and the angle of both the camera and the light. To see the problems,\n//  makes the balls bigger with BALL_SIZE or move them deeper into the cloth by\n//  hacking the opRepSphere call in the scene function.\n//\n//  I don't know if there is a way to rescue this rendering approach with a smarter\n//  search strategy, or if I should be going in another direction. I know about\n//  archee's quadtree method\n//\n//      curtain and ball          https://www.shadertoy.com/view/MldXWX\n//\n//  and I like how it doesn't need a voronoi buffer. I suppose I could just copy\n//  his approach but I would like to think there is more than one good way to render\n//  cloth.\n//\n//  For fun you can put whatever texture you want (e.g. a video) onto the cloth by\n//  modifying the colorMap function.\n//\n//  Buffer A computes the positions of cloth vertices\n//  Buffer B computes nearest particles to each screen pixel from the camera's POV\n//  Buffer C computes nearest particles to each screen pixel from the light's POV\n//  Buffer D computes the depth of the cloth from the light's perspective, for shadows\n//\n// ---------------------------------------------------------------------------------------\n\nvec3 light(vec3 n, vec3 pointLightDir, bool shadow)\n{\n    return vec3(abs(dot(n, FILL_LIGHT_DIR)) *.25) + float(!shadow) * max(0., dot(n, pointLightDir)) * .75;\n}\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd, vec4 state)\n{\n\tfloat d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * d;\n        float dS = scene(p, state);\n        d += dS;\n        if(d > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return d;\n}\n\nbool shadowScene(vec3 p, vec3 lightDir, mat4 w2l, vec4 state)\n{\n    float sd = rayMarch(POINT_LIGHT_POS, -lightDir, state);\n    vec3 sp = POINT_LIGHT_POS - lightDir * sd;\n    return dot(p - sp, lightDir) < -0.1;\n}\n\nbool shadowCloth(vec3 p, vec3 lightDir, mat4 w2l, vec4 state)\n{\n    vec3 s = screen(p, w2l);\n    float sz = texture(iChannel2, s.xy * .5 * vec2(iResolution.y / iResolution.x, 1) + .5).w;\n\n    return sz < s.z;\n}\n\n// Featuring: Fractal mosaic 30 (music) by jarble\n// https://www.shadertoy.com/view/csl3zl\nvec2 triangle_wave(vec2 a)\n{\n    vec2 a2 = vec2(1.,0.5),\n    a1 = a-a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvec3 fractalMosaic( in vec2 uv )\n{\n    uv = uv - .5;\n    uv = abs(uv);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 t2 = vec2(0.);\n        \n    for(int k = 0; k < 5; k++)\n    {    \n        uv = abs(.5*sign(uv.y-uv.x)+uv+t2);\n        t2 = -triangle_wave(uv-.5*sign(uv.y-uv.x)) ;\n        uv = t2-triangle_wave(uv.yx);\n        float c1 = abs(uv.x-uv.y);\n        col = col.yzx;\n        if(uv.y < uv.x) col = vec3(col.yz,c1);\n    }\n    \n    return min(col,vec3(1.));\n}\n\nvec3 colorMap(vec2 uv)\n{\n    //return uv.xyy; // check uv\n    //return texture(iChannel3, vec2(0, 1) + uv * vec2(1, -1)).xyz; // video\n    return fractalMosaic(uv)*1.4 + 0.1;\n}\n\nbool drawQuad(int id, vec2 bc, fxParticle ul, fxParticle ur, fxParticle ll, fxParticle lr, mat4 w2c, mat4 w2l, vec4 state, vec2 p, vec3 cameraPos, vec3 cameraFwd, inout vec4 fragColor)\n{\n    vec2 uv = vec2(float(id % g_ClothSideLen) + bc.y, float(id / g_ClothSideLen) - bc.x) / float(g_ClothSideLen);\n    fxParticle a, b, c;\n    if (bc.x + bc.y > 1.)\n    {\n        a = ll; b = ul; c = lr;\n    }\n    else\n    {\n        a = ur; b = lr; c = ul; bc = 1. - bc;\n    }\n    \n    vec3 pp = a.pos + bc.x * (b.pos - a.pos) + bc.y * (c.pos - a.pos);\n    vec3 ps = screen(pp, w2c);\n    \n    if (all(lessThanEqual(bc, vec2(1))) && all(greaterThanEqual(bc, vec2(0)))\n        && ps.z < fragColor.w + 0.03)\n    {\n        vec3 norm = normalize(a.norm * (1. - bc.x - bc.y) + b.norm * bc.x + c.norm * bc.y);\n        vec3 color = colorMap(uv);\n        //vec3 color = vec3(((id % g_ClothSideLen) % 2) ^ ((id / g_ClothSideLen) % 2)); // checkered\n        \n        if (dot(norm, cameraFwd) < 0.) color = color.bgr;\n        vec3 lightDir = normalize(POINT_LIGHT_POS - pp);\n        bool sh = shadowScene(pp, lightDir, w2l, state);\n        fragColor = vec4(color * light(norm, normalize(pp - POINT_LIGHT_POS - vec3(10, 0, 0)), sh), ps.z);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initClothExtents(iResolution);\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // set up ray for marching\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    vec3 cameraPos = fxCalcCameraPos(state), cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    mat4 w2c = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n   \n    fragColor = vec4(0, 0, 0, MAX_DIST);\n\n    // march\n    float d = rayMarch(cameraPos, rayDir, state);\n\n    // process march results\n    vec3 hit = cameraPos + rayDir * d;\n    vec3 n = getNormal(hit, state);\n    vec3 lightDir = normalize(POINT_LIGHT_POS - hit);\n    \n    // set up light matrix\n    vec3 lightFwd, lightLeft, lightUp;\n    fxCalcCamera(LOOK_AT, POINT_LIGHT_POS, lightFwd, lightLeft, lightUp);\n    mat4 w2l = fxCalcCameraMat(iResolution, lightLeft, lightUp, lightFwd, POINT_LIGHT_POS);\n   \n    // compute shadows\n    bool s = shadowScene(hit, lightDir, w2l, state) || shadowCloth(hit, lightDir, w2l, state);\n\n    // render background color\n    fragColor = vec4(light(n, lightDir, s), d);\n    \n    // render cloth\n    ivec4 old = fxGetClosest(iChannel1, ivec2(fragCoord));      \n\n#define RENDER_ONLY_CLOSEST_NEIGHBOR 1 // more artifacts, but faster\n\n    // find closest of the nearby vertices\n    int closest = -1;\n    float dist = 1e6;\n    for(int i = 0; i < 4; ++i)\n    {\n        int id = old[i];\n        if (id < 0 || id >= g_MaxParticles) continue;\n#if RENDER_ONLY_CLOSEST_NEIGHBOR\n        fxParticle data = fxGetParticle(id);\n        vec3 s = screen(data.pos, w2c);\n        if (s.z < dist)\n        {\n            closest = id;\n            dist = s.z;\n        }\n#else\n        fxParticle ul, ur, ll, lr; vec2 bc;\n        findQuad(id, bc, ul, ur, ll, lr, w2c, p, cameraPos, cameraFwd, fragColor);\n        if (drawQuad(id, bc, ul, ur, ll, lr, w2c, w2l, state, p, cameraPos, cameraFwd, fragColor)) break;\n#endif\n    }\n    \n#if RENDER_ONLY_CLOSEST_NEIGHBOR\n    fxParticle ul, ur, ll, lr; vec2 bc;\n    findQuad(closest, bc, ul, ur, ll, lr, w2c, p, cameraPos, cameraFwd, fragColor);\n    drawQuad(closest, bc, ul, ur, ll, lr, w2c, w2l, state, p, cameraPos, cameraFwd, fragColor);    \n#endif\n    \n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.w = 1.;\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0); //render shadow buffer\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec3 POINT_LIGHT_POS = vec3(3, 4, 10);\nconst vec3 FILL_LIGHT_DIR = normalize(vec3(-1, .5, 1));\nconst vec3 LOOK_AT = vec3(0, .5, 0);\nconst float FLOOR_Z = -2.;\nconst float BALL_SIZE = .4;\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 fxCalcCameraPos(vec4 state)\n{\n    return vec3(state.y, 1, state.z + 6.);\n}\n\nvoid fxCalcCamera(in vec3 cameraLookAt, in vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return inverse(mat4(vec4(-0.25 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0)));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.y) * vec2(0.5, 1.) - vec2(0.25 * iResolution.x / iResolution.y, .5);\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat fxLinePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosest(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define POS 0\n#define PREV 1\n#define NORM 2\n#define NUM_PARTICLE_DATA_TYPES 3\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 prev;\n    vec3 norm;\n    bool pinned;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, PREV), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, NORM), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xyz;\n    particle.pinned = particleData0.w != 0.;\n    particle.prev = particleData1.xyz;\n    particle.norm = particleData2.xyz;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:  \n        return vec4(p.pos, p.pinned ? 1. : 0.);\n    case PREV:  \n        return vec4(p.prev, 0);\n    case NORM:  \n        return vec4(p.norm, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float SIDE_LEN = 4.;\n\n// global variables, initialized via computeClothSide\nint g_ClothSideLen = 0; // how many particles along each side of the square\nint g_MaxParticles = 0; // how many particles, total\n\n// computes the size of the cloth grid relative to the current resolution\nvoid initClothExtents(vec3 res)\n{\n    float particleUse = 0.5 * (3. - 0.6 * smoothstep(1000., 1200., res.y));\n    g_ClothSideLen = int(sqrt(res.x * res.y / float(NUM_PARTICLE_DATA_TYPES)) * particleUse);\n    g_ClothSideLen = min(80, g_ClothSideLen);\n    g_MaxParticles = g_ClothSideLen * g_ClothSideLen;\n}\n\n// These functions compute the neighbors from each particle, and -1 if there is\n// no neighbor in that direction. Crucially, they must continue to return -1 if\n// -1 is passed in, since we do not terminate the loop right away.\n\nint above(int i)\n{\n    return i >= 0 && i >= g_ClothSideLen ? i - g_ClothSideLen : -1;\n}\n\nint below(int i)\n{\n    return i >= 0 && i < (g_ClothSideLen * (g_ClothSideLen - 1)) ? i + g_ClothSideLen : -1;\n}\n\nint left(int i)\n{\n    return i >= 0 && (i % g_ClothSideLen) != 0 ? i - 1 : -1;\n}\n\nint right(int i)\n{\n    return i >= 0 && (i % g_ClothSideLen) != g_ClothSideLen - 1 ? i + 1 : -1;\n}\n\nvec3 screen(vec3 p, mat4 w2c)\n{\n    vec3 s = (w2c * vec4(p,1.0)).xyz;\n    s.xy = s.xy / s.z;\n    return s;\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat distance2Particle(sampler2D sampler, int resolutionWidth, int id, float zBias, vec2 fragCoord, mat4 w2cNew)\n{\n    if (id==-1) return 1e20;\n    vec4 worldPos = fxGetParticleDataInternal(sampler, resolutionWidth, id, POS);\n    if (worldPos.w != 0.) return 1e20;\n    vec3 screenPos = (w2cNew * vec4(worldPos.xyz,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    vec2 delta = (screenPos.xy)-fragCoord;\n    return dot(delta, delta) + zBias*screenPos.z;\n}\n\nvoid consider(sampler2D sampler, int resolutionWidth, int nid, float zBias, vec2 p, mat4 w2c, inout ivec4 new, inout vec4 dis)\n{\n    if (nid >= 0 && nid < g_MaxParticles)\n    {\n        float dis2 = distance2Particle(sampler, resolutionWidth, nid, zBias, p, w2c);\n        insertion_sort( new, dis, nid, dis2 );\n    }\n}\n\nvoid voronoiInternal(sampler2D particles, vec3 res, int frame, out vec4 fragColor, vec2 fragCoord, vec3 cameraPos, sampler2D self, float zBias, uint searchRange, uint searchCount)\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    initClothExtents(res);\n\n\tvec2 p = (2.*fragCoord - res.xy) / res.y;\n\n    vec3 cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    mat4 w2c = fxCalcCameraMat(res, cameraLeft, cameraUp, cameraFwd, cameraPos);\n\n    ivec4 new = ivec4(-1);\n    vec4 dis = vec4(1e6);\n\n    ivec4 old = fxGetClosest(self, iFragCoord);      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        consider(particles, int(res.x), id, zBias, p, w2c, new, dis);\n\n        // randomly check one of the neighbors of the particle, it's likely to be of interest\n        int nid;\n        switch((frame + int(j)) % 4)\n        {\n            case 0: nid = above(id); break;\n            case 1: nid = below(id); break;\n            case 2: nid = left(id); break;\n            case 3: nid = right(id); break;\n        }\n        \n        consider(particles, int(res.x), nid, zBias, p, w2c, new, dis);\n    }\n\n    for (uint i = 0u; i < searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, frame, res.x) * i);\n\n        ivec4 old = fxGetClosest(self, iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u));      \n        consider(particles, int(res.x), old[0], zBias, p, w2c, new, dis);\n    }\n\n    int searchIterations = 1;\n    if (frame < 5)\n    {\n        searchIterations = 10;\n    }\n    for (int k = 0; k < searchIterations; k++)\n    {\n        float h = hash3(uvec3(fragCoord, k)).x;\n\n        int id = int(h*float(g_MaxParticles));\n        consider(particles, int(res.x), id, zBias, p, w2c, new, dis);\n    }\n    \n    fragColor = vec4(new);\n}\n\n#define voronoi(A, B, C, D, E, F, G) voronoiInternal(iChannel0, iResolution, iFrame, A, B, C, D, E, F, G)\n\nvec2 bary(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    return vec2((d11 * d20 - d01 * d21) / denom,\n                (d00 * d21 - d01 * d20) / denom);\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvec2 baryQuad(vec2 p, vec2 ul, vec2 ur, vec2 ll, vec2 lr)\n{\n    vec2 bc = bary(p, ll, ul, lr);\n    if (bc.x + bc.y > 1.) bc = 1. - bary(p, ur, lr, ul);\n    return bc;\n}\n\nvoid findQuadInternal(sampler2D sampler, vec3 res, inout int id, out vec2 bc, out fxParticle ul, out fxParticle ur, out fxParticle ll, out fxParticle lr, mat4 w2c, vec2 p, vec3 cameraPos, vec3 cameraFwd, inout vec4 fragColor)\n{\n    if (id < 0) return;\n    // move away from edge\n    if (id < g_ClothSideLen) id += g_ClothSideLen;\n    if ((id % g_ClothSideLen) == g_ClothSideLen - 1) id -= 1;\n\n    ll = fxGetParticleInternal(sampler, int(res.x), id);\n    ul = fxGetParticleInternal(sampler, int(res.x), above(id));\n    lr = fxGetParticleInternal(sampler, int(res.x), right(id));\n    ur = fxGetParticleInternal(sampler, int(res.x), above(right(id)));\n\n    for (int i = 0; i < 10; ++i)\n    {\n        vec3 lls = screen(ll.pos, w2c);\n        vec3 uls = screen(ul.pos, w2c);\n        vec3 lrs = screen(lr.pos, w2c);\n        vec3 urs = screen(ur.pos, w2c);\n        \n        bc = baryQuad(p, uls.xy, urs.xy, lls.xy, lrs.xy);\n\n        vec2 uv = vec2(float(id % g_ClothSideLen) + bc.y, float(id / g_ClothSideLen) - bc.x) / float(g_ClothSideLen);\n        if (any(lessThan(uv, vec2(0))) || any(greaterThan(uv, vec2(1))))\n        {\n            id = -1; // off the edge of the cloth\n            return;\n        }\n \n        if (all(lessThan(bc, vec2(1))) && all(greaterThanEqual(bc, vec2(0))))\n        {\n            break; // found the correct quad that surrounds our pixel\n        }\n        \n        if (bc.x < 0.)\n        {\n            id = below(id);\n            ur = lr;\n            ul = ll;\n            ll = fxGetParticleInternal(sampler, int(res.x), id);\n            lr = fxGetParticleInternal(sampler, int(res.x), right(id));\n        }\n        else if (bc.x >= 1.)\n        {\n            id = above(id);\n            lr = ur;\n            ll = ul;\n            ul = fxGetParticleInternal(sampler, int(res.x), above(id));\n            ur = fxGetParticleInternal(sampler, int(res.x), above(right(id)));            \n        }\n\n        if (bc.y < 0.)\n        {\n            id = left(id);\n            ur = ul;\n            lr = ll;\n            ll = fxGetParticleInternal(sampler, int(res.x), id);            \n            ul = fxGetParticleInternal(sampler, int(res.x), above(id));\n        }\n        else if (bc.y >= 1.)\n        {\n            id = right(id);\n            ul = ur;\n            ll = lr;\n            lr = fxGetParticleInternal(sampler, int(res.x), right(id));\n            ur = fxGetParticleInternal(sampler, int(res.x), above(right(id)));\n        }\n    }\n}\n\n#define findQuad(A, B, C, D, E, F, G, H, I, J, K) findQuadInternal(iChannel0, iResolution, A, B, C, D, E, F, G, H, I, J, K)\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat opRepSphere( in vec3 p, in vec3 c, float s )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdSphere( q, s );\n}\n\nfloat scene(vec3 p, vec4 state)\n{\n    float d = opRepSphere(p + vec3(abs(state.w) * 0.01 + .5, 0, -.15), vec3(1.5, 0, 0), BALL_SIZE); // balls\n    \n    d = min(d, sdBox(p + vec3(0,0,6), vec3(100.,100.,1.))); // wall\n    d = min(d, sdBox(p + vec3(0,1.-FLOOR_Z,0), vec3(100.,1.,100.))); // floor\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p, vec4 state)\n{\n    vec2 e = vec2(.001, 0);\n    vec3 n = scene(p, state) - \n        vec3(scene(p - e.xyy, state), scene(p - e.yxy, state),scene(p - e.yyx, state));\n    \n    return normalize(n);\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position of each cloth vertex.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-0.1,0);\nconst float COMPRESSION_RESIST = .00003; // stiffness\nconst float OVERRELAX = .75;\n\nvoid constraint(inout int nid, inout fxParticle p, float edgeLen)\n{\n    if (nid < 0) return;\n    \n    fxParticle n = fxGetParticle(nid);\n    \n    vec3 deltaPos = n.pos - p.pos;\n    float len = length(deltaPos);\n    vec3 dir = deltaPos / len;\n    \n    float error = len - edgeLen * OVERRELAX;\n    \n    error *= error < 0. ? COMPRESSION_RESIST : 1.;\n    \n    float f = .99;\n    p.pos += dir * error * f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initClothExtents(iResolution);\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=g_MaxParticles) return;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType == NORM)\n    {\n        // compute cloth normals\n        ivec4 ids;\n\n        ids.x = above(id);\n        ids.y = right(id);\n        ids.z = below(id);\n        ids.w = left(id);\n\n        fxParticle ps[4];\n        for (int i = 0; i < 4; ++i) ps[i] = fxGetParticle(ids[i]);\n\n        float count = 0.;\n        vec3 norm = vec3(0);\n        for (int i = 0; i < 4; ++i)\n        {\n            if (ids[i] >= 0 && ids[(i + 1) % 4] >= 0)\n            {\n                norm += normalize(cross(ps[i].pos - p.pos, ps[(i + 1) % 4].pos - p.pos));\n                count += 1.;\n            }\n        }\n\n        fragColor = vec4(normalize(norm / count), 0);\n        return;\n    }\n    \n    if (!p.pinned)\n    {\n        p.prev = p.pos;\n        p.pos += p.pos - p.prev + GRAVITY; // verlet\n\n        // edge constraints\n        int a, b, l, r;\n        a = b = l = r = id;\n\n        float EDGE_LEN = SIDE_LEN / float(g_ClothSideLen);\n        float CARDINAL_ITERATIONS = 45.;\n        for (float i = 1.; i < CARDINAL_ITERATIONS; ++i)\n        {\n            a = above(a);\n            b = below(b);\n            r = right(r);\n            l = left(l);\n\n            float sLen = EDGE_LEN * i;\n            constraint(a, p, sLen);\n            constraint(b, p, sLen);\n            constraint(r, p, sLen);\n            constraint(l, p, sLen);\n        }\n\n    #define DIAGONAL_CONSTRAINTS 1\n\n    #if DIAGONAL_CONSTRAINTS\n        int al, ar, bl, br;\n        al = ar = bl = br = id;\n\n        float DIAGONAL_ITERATIONS = 35.;\n        for (float i = 1.; i < DIAGONAL_ITERATIONS; ++i)\n        {\n            ar = above(right(ar));\n            al = above(left(al));\n            br = below(right(br));\n            bl = below(left(bl));\n\n            float dLen = EDGE_LEN * i * sqrt(2.);\n            constraint(al, p, dLen);\n            constraint(ar, p, dLen);\n            constraint(bl, p, dLen);\n            constraint(br, p, dLen);\n        }\n    #endif // DIAGONAL_CONSTRAINTS\n\n        // collision with scene\n        p.pos -= min(0., scene(p.pos, state)) * getNormal(p.pos, state);\n    }\n    \n    // reset\n    if (iFrame == 0 || state.x < 0.)\n    {   \n        float x = float(id % g_ClothSideLen) / float(g_ClothSideLen) - 0.5;\n        float y = .7 - float(id) / float(g_ClothSideLen * g_ClothSideLen);\n        p.pos = vec3(x, y, 0.0) * SIDE_LEN / sqrt(2.);\n        p.prev = p.pos;\n        p.pinned = id < g_ClothSideLen;\n    }\n\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Manages state, computes voronoi for particle rendering.\n// ---------------------------------------------------------------------------------------\n\nvec4 updateState()\n{\n    // Reset if resolution changes\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    ivec4 topMiddleClosest = fxGetClosest(iChannel1, ivec2(iResolution.x * .5, iResolution.y - 10.));\n    if (topMiddleClosest[0] >= 0)\n    {\n        // Reset if cloth falls on the floor\n        fxParticle test = fxGetParticle(topMiddleClosest[0]);\n        if (test.pos.y <= FLOOR_Z) state.x = 0.;\n    }\n\n    if (iFrame == 0 ||\n        iResolution.x * iResolution.y != abs(state.x) ||\n        keyDown(KEY_SPACE))\n    {\n        state = vec4(-iResolution.x * iResolution.y, 0.0, 0.0, 0.0);\n    }\n    else\n    {\n        state.x = abs(state.x);\n    }\n\n    if (iMouse.z > 0.)\n    {\n        state.yz = vec2(3, 0) + (vec2(-3, 7) * iMouse.xy - iResolution.xy ) / iResolution.y;\n        state.w = -abs(state.w);\n    }\n\n    if (state.w >= 0.)\n    {\n        state.w++;\n        state.z = 1.5 * sin(.005 * state.w);\n        state.y = 3.2 * cos(.0025 * state.w);\n    }\n    else\n    {\n        state.w--;\n    }\n    \n    return state;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        fragColor = updateState();\n        return;\n    }\n    \n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    voronoi(fragColor, fragCoord, fxCalcCameraPos(state), iChannel1, 0.01, 15u, 4u);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Computes voronoi for shadow buffer.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    voronoi(fragColor, fragCoord, POINT_LIGHT_POS, iChannel2, 0.00003, 15u, 20u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Renders depth into w component from the light source for shadow computation.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initClothExtents(iResolution);\n    \n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraPos = POINT_LIGHT_POS, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 w2c = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n   \n    fragColor = vec4(0, 0, 0, 1e6);\n    \n    ivec4 old = fxGetClosest(iChannel2, ivec2(fragCoord));      \n\n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0 || id >= g_MaxParticles) continue;\n        fxParticle ul, ur, ll, lr; vec2 bc;\n        findQuad(id, bc, ul, ur, ll, lr, w2c, p, POINT_LIGHT_POS, cameraFwd, fragColor);\n        \n        fxParticle a, b, c;\n        if (bc.x + bc.y > 1.)\n        {\n            a = ll; b = ul; c = lr;\n        }\n        else\n        {\n            a = ur; b = lr; c = ul;\n        }\n\n        vec3 pp = a.pos + bc.x * (b.pos - a.pos) + bc.y * (c.pos - a.pos);\n        vec3 ps = screen(pp, w2c);\n\n        vec2 uv = vec2(float(id % g_ClothSideLen) + bc.y, float(id / g_ClothSideLen) - bc.x) / float(g_ClothSideLen);\n        if (any(lessThan(uv, vec2(0))) || any(greaterThan(uv, vec2(1))))\n        {\n            continue;// off the edge of the cloth\n        }\n \n        if (all(lessThanEqual(bc, vec2(1))) && all(greaterThanEqual(bc, vec2(0)))\n            && ps.z < fragColor.w + .01)\n        {\n            fragColor = vec4(1, 1, 1, ps.z);\n            return;\n        }\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddj3Wh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2641, 2641, 2694, 2694, 2803], [2873, 2873, 2919, 2919, 3146], [3148, 3148, 3211, 3211, 3361], [3363, 3363, 3426, 3426, 3573], [3575, 3666, 3694, 3694, 3783], [3785, 3785, 3819, 3819, 4256], [4258, 4258, 4282, 4392, 4434], [4436, 4436, 4622, 4622, 5699], [5701, 5701, 5758, 5758, 8223]], "test": "untested"}
{"id": "DdSGzy", "name": "Another windows terminal shader", "author": "mrange", "description": "CC0: Another windows terminal shader\nCreated this based on an old shader as a background in windows terminal\n", "tags": ["terminal"], "likes": 46, "viewed": 2211, "published": 3, "date": "1667765958", "time_retrieved": "2024-07-30T16:21:43.916926", "image_code": "// CC0: Another windows terminal shader\n//  Created this based on an old shader as a background in windows terminal\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst mat2 rot0 = ROT(0.0);\nmat2 g_rot0 = rot0;\nmat2 g_rot1 = rot0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat apolloian(vec3 p, float s) {\n  float scale = 1.0;\n  for(int i=0; i < 5; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n    float r2 = dot(p,p);\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  vec3 ap = abs(p/scale);  \n  float d = length(ap.xy);\n  d = min(d, ap.z);\n\n  return d;\n}\n\n\nfloat df(vec2 p) {\n  float fz = mix(0.75, 1., smoothstep(-0.9, 0.9, cos(TAU*TIME/300.0)));\n  float z = 1.55*fz;\n  p /= z;\n  vec3 p3 = vec3(p,0.1);\n  p3.xz*=g_rot0;\n  p3.yz*=g_rot1;\n  float d = apolloian(p3, 1.0/fz);\n  d *= z;\n  return d;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  g_rot0 = ROT(0.1*TIME); \n  g_rot1 = ROT(0.123*TIME);\n\n  float aa = 2.0/RESOLUTION.y;\n  \n  float d = df(p);\n  const vec3 bcol0 = HSV2RGB(vec3(0.55, 0.85, 0.85));\n  const vec3 bcol1 = HSV2RGB(vec3(0.33, 0.85, 0.025));\n  vec3 col = 0.1*bcol0;\n  col += bcol1/sqrt(abs(d));\n  col += bcol0*smoothstep(aa, -aa, (d-0.001));\n  \n  col *= smoothstep(1.5, 0.5, length(pp));\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  col = aces_approx(col);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 447, 469, 469, 615], [979, 1079, 1098, 1098, 1185], [1187, 1294, 1320, 1320, 1504], [1506, 1506, 1540, 1540, 1806], [1809, 1809, 1827, 1827, 2048], [2050, 2050, 2080, 2080, 2463], [2465, 2465, 2520, 2520, 2737]], "test": "untested"}
{"id": "cdSGzy", "name": "StarCollectionHUD", "author": "Del", "description": "A simple UI HUD shader - - https://www.twitch.tv/videos/1642855178", "tags": ["star", "polar", "hud"], "likes": 5, "viewed": 208, "published": 3, "date": "1667764723", "time_retrieved": "2024-07-30T16:21:44.865390", "image_code": "// StarHUD - https://www.twitch.tv/videos/1642855178\n\n#define PI 3.141519\n#define TAU 6.283185\n\nvec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c)*v;\n}\n\n// mercury sdf\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle = (2.0*PI/repetitions);\n\tfloat a = atan(p.x, p.y) + angle/2.; // Y,X\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\nfloat sdfStar5( in vec2 p )\n{\n    // repeat domain 5x\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    \n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n\nfloat SDstar5(in vec2 p, in float r)\n{\n    //return sdfStar5(p/r)*r;\n\n\n    // these 4 lines can be precomputed for a given shape\n    const float an = 3.141593/5.0; // 5sides\n    const float en = 3.141593/3.0; // angle\n    const vec2  acs = vec2(cos(an),sin(an));\n    const vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    p.y = -p.y;\n\n    //float starcount = 38.0;               // example stars collected (pass this in...)\n    \n    float t = iTime*0.75;\n    \n    float starcount = hash11(floor((27.0+t)/3.0));\n    starcount = floor(starcount*50.0);      // randomized stars collected\n    \n    \n    // fill amount (0.0 to 1.0)\n    float fill = mod(t,3.0)-1.0;  // example fill value\n    //float fill = 0.5+sin(t)*0.5;\n\n    vec3 col1 = vec3(0.6,0.3,1.0)*0.7;    // purple\n    vec3 col2 = vec3(0.2,0.2,0.2);        // grey\n    vec3 col3 = vec3(1.0,1.0,1.0);        // white\n\n    float totalstars = 50.0;\n    float c = pModPolar(p,totalstars)+(totalstars*0.5);\n    float fade = 0.0;\n    float rad = 0.015;\n    float ang = -(PI*0.5);\n    //float ang = (c*(-TAU/totalstars))-(PI*0.5);\n\n    if (c>(totalstars-starcount))\n    {\n        fade = -1.0 + (c*(1.0/totalstars));\n        fade+=(fill*2.0);\n        fade = clamp(fade,0.0,1.0);\n        float fade2 = smoothstep(0.0,0.25,fade); // 0.125\n        rad = mix(rad,0.022,fade2);\n        ang = mix(ang,ang-(TAU/5.0),fade2);\n        float fade3 = smoothstep(0.0,0.25,fade-0.1);\n        col2 = mix(col2,col3,fade3);\n    }\n    \n    // render star\n    p = rot(p+vec2(-0.4,0.0),ang);\n    float cc = 1.0-smoothstep(0.0,0.005,SDstar5(p,rad)); // starradius=0.02\n    vec3 col = mix(col2*cc,col1*cc,fade);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 127, 127, 213], [215, 343, 393, 393, 794], [796, 796, 825, 849, 1187], [1189, 1189, 1227, 1317, 1793], [1796, 1796, 1819, 1819, 1904], [1906, 1906, 1963, 1963, 3385]], "test": "untested"}
{"id": "cdBGRy", "name": "torus - practice", "author": "kanayuki", "description": "torus raymarch", "tags": ["3d", "phong", "sdf", "torus", "blinn", "raymrch"], "likes": 1, "viewed": 167, "published": 3, "date": "1667761769", "time_retrieved": "2024-07-30T16:21:45.898628", "image_code": "float sdTorus(vec3 p, float r1, float r2)\n{\n    float l = length(p.xy)-r1;\n    return length(vec2(l,p.z))-r2;\n}\n\nfloat sdf(vec3 p) {return sdTorus(p,3.0,1.0);}\n\nfloat rayMarching(vec3 raySource, vec3 direction)\n{\n    float d;\n    for (int i=0; i<100; i++)\n    {\n        float len = sdf(raySource+direction*d);\n        if (len<0.001 || d>30.0) break;\n        d += len;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0);\n    float d = sdf(p);\n    float pdx=sdf(p+e.xyy)-d;\n    float pdy=sdf(p+e.yxy)-d;\n    float pdz=sdf(p+e.yyx)-d;\n    return normalize(vec3(pdx,pdy,pdz));\n \n}\n\nmat2 rotateMatrix(float theta)\n{\n    return mat2(cos(theta),-sin(theta),\n                sin(theta),cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y * 4.0;\n\n    vec3 col = vec3(0.75);\n    vec3 raySource = vec3(0,0,20);\n    raySource.xz *= rotateMatrix(iTime);\n    \n    vec3 screen = vec3(uv,1.0);\n    screen.xz *= rotateMatrix(iTime);\n    \n    vec3 direction = normalize(screen-raySource);\n    \n    float d = rayMarching(raySource, direction );\n    if(d<30.0)\n    {\n        vec3 p = vec3(raySource+direction*d);\n        vec3 N = getNormal(p);\n        vec3 light =vec3(5,0,5);\n         light.xz *= rotateMatrix(iTime);\n        \n        vec3 L = normalize(light-p);\n        \n        float diffuse = dot(N,L);\n        // Lambert\n        // diffuse = max(0,diffuse);\n        // Half Lambert\n        diffuse = diffuse * 0.5 + 0.5;\n         \n        \n        // Phong\n        vec3 R = normalize(2.0*N*dot(N,L)-L);\n        vec3 V = -direction;\n        // vec3 specular = 0.1*vec3(1)*pow(dot(R,V),8.0);\n        \n        // Blinn\n        vec3 H = normalize(V+L);\n        vec3 specular = 0.9*vec3(1)*pow(dot(H,N),5.0);\n        \n        \n        vec3 ambient = vec3(0.1,0.1,0.3)*1.5;\n        \n        col = vec3(1,0,1);\n        col = ambient + 0.5*col*diffuse + specular;\n    }\n    \n    // Time varying pixel color\n    // col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 111], [113, 113, 132, 132, 159], [161, 161, 212, 212, 389], [391, 391, 415, 415, 601], [603, 603, 635, 635, 717], [719, 719, 776, 826, 2152]], "test": "untested"}
{"id": "cdj3Dw", "name": "Whats Up Jitter?", "author": "byt3_m3chanic", "description": "Trying to figure out how people do that jitter effect that gives a kind of a DOF . Picking apart @leon's shader from the Inercia Shader Royal", "tags": ["raymarching", "domain", "jitter"], "likes": 16, "viewed": 331, "published": 3, "date": "1667755785", "time_retrieved": "2024-07-30T16:21:46.722425", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Whats Up Jitter?\n    Trying to figure out how people do that jitter effect that gives a kind of \n    a DOF effect. Picking apart @leon's shader from the Inercia Shader Royal \n    https://www.shadertoy.com/view/md2GDD\n    \n    11/6/22 | byt3_m3chanic\n\n*/\n\n\n#define R     iResolution\n#define T     iTime\n#define M     iMouse\n#define PI    3.14159265358\n#define PI2   6.28318530718\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.34,35.34)))*483434.);}\n\n//@iq\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nfloat glow=0.,t12=0.;\n\nconst float size = 5.25;\nconst float hlf =size/2.;\n\nvoid sep(inout vec3 p){\n\tif (p.x + p.y<0.) p.xy = -p.yx;\n\tif (p.x + p.z<0.) p.xz = -p.zx;\n\tif (p.y + p.z<0.) p.zy = -p.yz;\n}\n\nvec2 map(vec3 p, float sq) {\n    vec2 res = vec2(1e5,0.);\n    p.y+=3.;\n    p.z-=t12;\n    vec3 o=p;\n    o.y+= .5*sin(T*.21+o.z*.15)+.7*cos(T*.12+o.x*.3);\n    \n    vec2 id = floor((p.xz+hlf)/size);\n    p.xz=mod(p.xz+hlf,size)-hlf;\n\n    float hs = 2.50*sin(id.x+id.y*2.+T*.3);\n    float ht = 2.25*sin(id.x*2.+id.y*1.3+T*1.3);\n    \n    float ss = hash21(id);\n    p.y+= ht;\n    vec3 q=p;\n    \n    float pis=hs*PI2;\n    p.zy*=rot(pis+(T*.04));\n    p.xy*=rot(pis-(T*.05));\n    \n    if(ss>.25) sep(p);\n    \n    float fs = hash21(id+vec2(22.));\n    if(fs>.5) { p=abs(p.zyx); } else if(fs>.75) p=abs(p.yzx);\n    \n    float r = length(p.xy)-1.45;\n    float d = opx(abs(r)-.1,abs(p.z)-.25,.05)/1.25;\n    \n    if(d<res.x) res=vec2(d,1.);\n\n    float d2 = length(q)-(1.15-ss);  \n    \n    if(d2<res.x) res=vec2(d2,2.);\n    \n    float ms=hash21(id+floor(T*1.5));\n    if(sq==1.&&ms>.825) glow+=.002/(.0025+d2*d2);\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t){\n    vec2 e=vec2(t*1e-3,0.);\n    float d = map(p,0.).x;\n    vec3 n = d-vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n    );\n    return normalize(n);\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 ro, float m) {\n    vec3 l = normalize(vec3(-2,15,-10)-p);\n    float diff = clamp(dot(n,l),.1,1.);\n\n    float shdw = 1.;\n    for( float t=.01;t<18.; ) {\n        float h = map(p + l*t,0.).x;\n        if( h<1e-4 ) { shdw = 0.; break; }\n        shdw = min(shdw, 18.*h/t);\n        t += h;\n        if( shdw<1e-4 || t>18. ) break;\n    }\n    diff = mix(diff,diff*shdw,.85);\n\n    float spec = .15 * pow(max(dot(normalize(p-ro),reflect(l,n)),0.),24.);\n        \n    vec3 h = vec3(0);\n    if(m==1.) h = vec3(.05);\n    if(m==2.) h = vec3(.75);\n        \n    return h * diff+spec;   \n}\nvoid mainImage( out vec4 fragColor, in vec2 F )\n{\n\n    t12=(T*14.);\n\tvec2 uv = (2.*F.xy - R.xy)/max(R.x,R.y);\n    vec2 vv=uv;\n\n\tvec3 C = vec3(0);\n\n    vec3 ro = vec3(0,-1.,12),rd = normalize(vec3(uv, -1.0));\n\n    const float dof = 0.001;\n    const float dofdist = 1.0/10.;\n    \n    vec2 off=vec2(-.05,.05);\n    ro.xy+=off*dof*smoothstep(0.,1.,length(uv))*.01;\n    \n    mat2 rx =rot(-.60-.46*sin(T*.4));\n    mat2 ry =rot(-.178*sin(T*.2)+pow(1.95,cos(T*.2)*PI));\n    \n    ro.zy*=rx;ro.xz*=ry;\n    rd.zy*=rx;rd.xz*=ry;\n   \n    float fa=0.,sglow=0.;\n    for(int k=0;k<2;k++){\n    \n        vec3 p = ro;\n        float d = 0., m = 0.;\n        vec3 RC = vec3(0);\n        \n        for(int i=0;i<80;i++){\n            \n            //modified jitter/dof \n            //inspiration @Nusan https://www.shadertoy.com/view/3sXyRN\n            if(mod(float(i),2.)<1.){\n                off= texture(iChannel1,F.xy/1024.).rg*2.-1.;\n                vec2 focus = off*dof;\n                ro.xy+= focus*(d)*.01;\n                rd.xy+= focus*(d*d)*dofdist*.012;\n            }\n            \n            p=ro+d*rd;\n\n            vec2 ray = map(p,1.);\n            m=ray.y;\n            d+= ray.x*.55;\n            if(ray.x<d*1e-4||d>50.)break;\n        }\n\n        if(k==0) {fa=d;sglow=glow;}\n        \n        if(d<40.) {\n            vec3 n = normal(p,d);\n            RC += shade(p, n, ro, m);\n            ro = p+n*.001;\n            rd = reflect(rd,n);\n        }\n\n        if(k>0) RC *=.3;\n        C += RC;\n\n    }\n    \n    C=mix(C,vec3(.1),1.-exp(-.00003*fa*fa*fa));\n    C=mix(C,vec3(sglow,sglow*.5,sglow*.1),clamp(sglow,0.,.9));\n    C=clamp(C,vec3(0),vec3(1));\n\tfragColor = vec4(pow(C,vec3(.4545)),1.);\n}\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdj3Dw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[485, 485, 504, 504, 547], [548, 548, 569, 569, 623], [625, 631, 677, 677, 770], [847, 847, 870, 870, 971], [973, 973, 1001, 1001, 1887], [1889, 1889, 1918, 1918, 2108], [2110, 2110, 2156, 2156, 2711], [2712, 2712, 2761, 2761, 4384]], "test": "untested"}
{"id": "ms23Wm", "name": "RayMarching - SDF - Learn", "author": "kanayuki", "description": "learn RayMarching SDF practice", "tags": ["raymarching", "sdf", "spheresdf"], "likes": 2, "viewed": 162, "published": 3, "date": "1667744324", "time_retrieved": "2024-07-30T16:21:47.629001", "image_code": "float sphereSDF(in vec3 p)\n{\n    return length(p)-1.0;\n}\n\nfloat sdf(vec3 p){return sphereSDF(p);}\n\nfloat RayMarching(in vec3 source, in vec3 direction)\n{\n    float distance=0.0;\n    for (int i=0; i<100; i++)\n    {\n        vec3 end = source+direction*distance;\n        float len = sdf(end);\n        if (len<0.001 || distance>10.0) break;\n        distance += len;     \n    }\n    return distance;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = sdf(p);\n    vec2 e = vec2(0.001,0.0);\n    float pdx = sdf(p+e.xyy)-d;\n    float pdy = sdf(p+e.yxy)-d;\n    float pdz = sdf(p+e.yyx)-d;\n    return normalize(vec3(pdx,pdy,pdz));\n}\n\nmat2 RotateMatrix(float theta)\n{\n    return mat2(cos(theta),-sin(theta),\n                sin(theta),cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.75);\n    \n    vec3 source = vec3(0,0,3);\n    vec3 direction = normalize(vec3(uv,0.5)-source);\n       \n    float d = RayMarching(source, direction);\n    \n    col = vec3(d/15.0);\n    if (d < 10.0)\n    {\n        vec3 p = source + direction*d;\n        vec3 n = GetNormal(p);\n        vec3 light = vec3(3,1,3);\n        light.xz *= RotateMatrix(iTime*5.0);\n        float diffuse = dot(n, normalize(light-p));\n        \n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        col = col * (diffuse*0.5+0.5);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 56], [58, 58, 76, 76, 97], [99, 99, 153, 153, 395], [397, 397, 421, 421, 612], [614, 614, 646, 646, 728], [730, 730, 787, 837, 1529]], "test": "untested"}
{"id": "cdSGRD", "name": "DICE", "author": "samuelotherion", "description": "a paradox transparent dice.", "tags": ["raytracing", "transparency", "dice"], "likes": 0, "viewed": 55, "published": 3, "date": "1667737272", "time_retrieved": "2024-07-30T16:21:48.394953", "image_code": "// global integer input\nI2\nI;\n\n// read vec4 from ram wia ivec2 address\nF4\nrd(I2 a) {\n\n    RE texelFetch(iChannel0, a, 0);\n}\n\n// read vec4 from ram via integer address\nF4\nrd(I1 a) {\n    \n    RE rd(I1toI2(a));\n}\n\n// some useful structurs\nstruct Cuboid {F3 pos, ext; M3 dir;};\nstruct Hit {I1 id; F1 dist; F2 uv; F3 norm;};\nstruct Camera {F3 pos, ray; M3 dir;};\n\nF3\ncol = F3(.41,.43,.41);\n\nB1\nhitCuboid(Camera cam, Cuboid cub, inout Hit f, inout Hit b) {\n    \n    \n    F3\n    ray = normalize(cam.dir * cam.ray),\n    dst = cam.pos - cub.pos;\n    \n    // check whether ray hits bounding spheroid\n    F1\n    rd = dot(ray, dst);\n\n    if(dot(cub.ext, cub.ext) - dot(dst, dst) + rd * rd < 0.) RF\n\n    Hit[2]\n    hit = Hit[2](\n        Hit(-1, 1e7, _.yy, _.yyy),\n        Hit(-1, 1e7, _.yy, _.yyy));\n\n    I1\n    i = -1;\n    \n    M3\n    xyz = M3(cub.dir[X] * cub.ext.x, cub.dir[Y] * cub.ext.y, cub.dir[Z] * cub.ext.z),\n    xyz_,\n    _zyx;\n\n    F3\n    sol;\n    \n    F2\n    sol_uv;\n    \n    for(I1 dim = 0; dim < 3; ++ dim) {\n    \n        for(F1 sol_f = -1.; sol_f < 2.; sol_f += 2.) { \n    \n            xyz_      = xyz;\n            xyz_[dim] = -ray;\n            _zyx      = inverse(xyz_);\n    \n            sol       = _zyx * (dst + sol_f * xyz[dim]);\n            sol_uv    = F2(sol[(dim + 1) % 3], sol[(dim + 2) % 3]);\n            \n            if(i < 1 && 0. < sol[dim] && all(lessThanEqual(abs(sol_uv), _.ww))) {\n\n                ++ i;\n                hit[i].id   = 2 * dim + I1(.5 + .5 * sol_f);\n                hit[i].dist = sol[dim];\n                hit[i].uv   = sol_uv;\n                hit[i].norm = -sol_f * cub.dir[dim];\n            }\n        }\n    }\n    \n    if(hit[0].dist < hit[1].dist) {\n        \n        f = hit[0];\n        b  = hit[1];\n    } else {\n        \n        f = hit[1];\n        b  = hit[0];\n    }\n    \n    RE 1 == i;\n}\n\nVO\nmainImage(out F4 o, F2 xy) {\n\n    F2\n    R  = 1. / iResolution.xy,\n    uv = 2. * (xy * R - .5) * F2(iResolution.x * R.y, 1.);\n    \n    Camera\n    //           position         ray                    coord system\n    cam = Camera(F3(0., 0., 50.), normalize(F3(uv, -3)), ID);\n    \n    // Cuboid local coordinate system rotating around a rotating vector red from Buffer A at Address DIR\n    M3\n    cs = M3(\n        rd(DIR + 0).xyz,\n        rd(DIR + 1).xyz,\n        rd(DIR + 2).xyz);\n    \n    Cuboid\n    //          position      extents             coord system    \n    c0 = Cuboid(F3(0, 0, 5), F3( +9., +9., +9.), cs);\n    \n    // background color\n    o = F4(.02, .03, .05, 1);\n    \n    Hit\n    f,\n    b;\n    \n    if(hitCuboid(cam, c0, f, b)) {\n    \n        F1\n        fac = .2;\n\n        if((\n            (f.id == 0 && \n             (.05 < dot(F2(.00) - f.uv, F2(.00) - f.uv))) ||\n            (f.id == 2 && \n             (.05 < dot(F2(.50) - f.uv, F2(.50) - f.uv) &&\n              .05 < dot(F2(-.50) - f.uv, F2(-.50) - f.uv))) ||\n            (f.id == 4 && \n             (.05 < dot(F2(-.50) - f.uv, F2(-.50) - f.uv)) &&\n              .05 < dot(F2(0.00) - f.uv, F2(0.00) - f.uv) &&\n              .05 < dot(F2(+.50) - f.uv, F2(+.50) - f.uv)) ||\n            (f.id == 5 && \n             (.05 < dot(F2(-.5,-.5) - f.uv, F2(-.5,-.5) - f.uv)) &&\n              .05 < dot(F2(-.5,+.5) - f.uv, F2(-.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,+.5) - f.uv, F2(+.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,-.5) - f.uv, F2(+.5,-.5) - f.uv)) ||\n            (f.id == 3 && \n             (.05 < dot(F2(-.5,-.5) - f.uv, F2(-.5,-.5) - f.uv)) &&\n              .05 < dot(F2(-.5,+.5) - f.uv, F2(-.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,+.5) - f.uv, F2(+.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,-.5) - f.uv, F2(+.5,-.5) - f.uv) &&\n              .05 < dot(F2(+.0,+.0) - f.uv, F2(+.0,+.0) - f.uv)) ||\n            (f.id == 1 && \n             (.05 < dot(F2(-.5,-.5) - f.uv, F2(-.5,-.5) - f.uv)) &&\n              .05 < dot(F2(-.5,+.5) - f.uv, F2(-.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,+.5) - f.uv, F2(+.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,-.5) - f.uv, F2(+.5,-.5) - f.uv) &&\n              .05 < dot(F2(-.5,+.0) - f.uv, F2(-.5,+.0) - f.uv) &&\n              .05 < dot(F2(+.5,+.0) - f.uv, F2(+.5,+.0) - f.uv))\n        ))\n        \n            if(!(\n                (f.id == 0 && \n                 (.05 < dot(F2(.00) - b.uv, F2(.00) - b.uv))) ||\n                (f.id == 2 && \n                 (.05 < dot(F2(.50) - b.uv, F2(.50) - b.uv) &&\n                  .05 < dot(F2(-.50) - b.uv, F2(-.50) - b.uv))) ||\n                (f.id == 4 && \n                 (.05 < dot(F2(-.50) - b.uv, F2(-.50) - b.uv)) &&\n                  .05 < dot(F2(0.00) - b.uv, F2(0.00) - b.uv) &&\n                  .05 < dot(F2(+.50) - b.uv, F2(+.50) - b.uv)) ||\n                (f.id == 5 && \n                 (.05 < dot(F2(-.5,-.5) - b.uv, F2(-.5,-.5) - b.uv)) &&\n                  .05 < dot(F2(-.5,+.5) - b.uv, F2(-.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,+.5) - b.uv, F2(+.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,-.5) - b.uv, F2(+.5,-.5) - b.uv)) ||\n                (f.id == 3 && \n                 (.05 < dot(F2(-.5,-.5) - b.uv, F2(-.5,-.5) - b.uv)) &&\n                  .05 < dot(F2(-.5,+.5) - b.uv, F2(-.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,+.5) - b.uv, F2(+.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,-.5) - b.uv, F2(+.5,-.5) - b.uv) &&\n                  .05 < dot(F2(+.0,+.0) - b.uv, F2(+.0,+.0) - b.uv)) ||\n                (f.id == 1 && \n                 (.05 < dot(F2(-.5,-.5) - b.uv, F2(-.5,-.5) - b.uv)) &&\n                  .05 < dot(F2(-.5,+.5) - b.uv, F2(-.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,+.5) - b.uv, F2(+.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,-.5) - b.uv, F2(+.5,-.5) - b.uv) &&\n                  .05 < dot(F2(-.5,+.0) - b.uv, F2(-.5,+.0) - b.uv) &&\n                  .05 < dot(F2(+.5,+.0) - b.uv, F2(+.5,+.0) - b.uv))\n            ))\n\n            o = \n                  .75 * F4(col * (fac        * clamp(dot(f.norm, F3(0, 0, +1)), 0., 1.)), 1.) + \n                  .75 * F4(col * ((1. - fac) * clamp(dot(b.norm, F3(0, 0, -1)), 0., 1.)), 1.);\n\n            else o = \n                  .75 * F4(col * (fac        * clamp(dot(f.norm, F3(0, 0, +1)), 0., 1.)), 1.) + \n                  .35 * F4(col * ((1. - fac) * clamp(dot(b.norm,  F3(0, 0, -1)), 0., 1.)), 1.);\n\n        else o = F4(col,1.)*((1. - fac) * clamp(dot(f.norm, F3(0, 0, +1)), 0., 1.)); \n    } \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VO void\n#define B1 bool\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n#define I1 int\n#define I2 ivec2\n\n#define M3 mat3x3\n\n#define X  0\n#define Y  1\n#define Z  2\n\n#define RE return\n#define RF RE false;\n#define RT RE true;\n\n#define I1toI2(S) I2(S & 0xf, (S >> 4) & 0xf)\n#define I2toI1(V) (V.x + (V.y << 4))\n\n// addresses in Buffer A accessable via rd(DIR + {0,1,2}) \n#define MOUSE 0 \n#define DIR   1 \n#define END   4 \n\nconst F4\n_ = F4(-1., 0., .5, 1.);\n\nconst M3\nID = M3(_.wyy, _.ywy, _.yyw);\n\n// rotate vector u around vector axe by angle alpha\nF3\nrot(F3 u, F1 alpha, F3 axe) {\n\n    axe = normalize(axe);\n    \n    F3\n    z = dot(u, axe) * axe,\n    x = u - z,\n    y = cross(axe, x);\n    \n    RE cos(alpha) * x + sin(alpha) * y + z;\n}\n\n// rotate coordinate system xyz around vector axe by angle alpha\nM3\nrot(M3 xyz, F1 alpha, F3 axe) {\n\n    axe = normalize(axe);\n    \n    xyz[X] = rot(xyz[X], alpha, axe);\n    xyz[Y] = rot(xyz[Y], alpha, axe);\n    xyz[Z] = rot(xyz[Z], alpha, axe);\n    \n    RE xyz;\n}\n", "buffer_a_code": "// global Output \nF4\nO;\n\n//global Integer Input\nI2\nI;\n\n// read from ivec2 address a\nF4\nrd(I2 a) {\n\n    RE texelFetch(iChannel0, a, 0);\n}\n\n\n// read from int address a\nF4\nrd(I1 a) {\n    \n    RE rd(I1toI2(a));\n}\n\n// write to ivec2 address a the vec4 value v\nB1\nwt(I2 a, F4 v) {\n    \n    if(a.x == I.x && a.y == I.y) {\n    \n        O = v;\n        \n        RT\n    }\n    \n    RF\n}\n\n// write to int address a the vec4 value v\nB1\nwt(I1 a, F4 v) {\n    \n    RE wt(I1toI2(a), v);\n}\n\n\nVO\nmainImage(out F4 o, F2 f) {\n\n    // set globel input I\n    I = I2(f);\n    \n    // read color from Buffer A and store to globel output O\n    O = rd(I);\n    \n    // use first 16 pixel of the first row of Buffer A as RAM\n    // that means if where not inside the RAM coords, we are done here and return fragmentColor o = O.\n    if(15 < I.x || 0 < I.y) {\n    \n        o = O;\n    \n        RE;\n    }\n    \n    // if the first frame is rendered\n    // Buffer A is undefined - RAM is not set\n    // init RAM\n    if(iFrame < 1) {\n        \n        // init RAM and return o = O\n        wt(MOUSE,   F4(-1));\n        wt(DIR + 0, F4(ID[X], 0));\n        wt(DIR + 1, F4(ID[Y], 0));\n        wt(DIR + 2, F4(ID[Z], 0));\n        \n        o = O;\n        \n        RE;\n    }\n\n    // if mouse button is not pressed\n    // write -1,-1,-1,-1 to RAM at address MOUSE and return o = O\n    if(iMouse.z <= 0.) {\n    \n        wt(MOUSE, F4(-1));\n        \n        o = O;\n        \n        RE;\n    }\n    \n    // read iMouse from Buffer A at address MOUSE and store it in m\n    F4\n    m = rd(MOUSE);\n    \n    // if mouse button is pressed and one of the coords has changed\n    if(m.z == iMouse.z && (iMouse.y != m.y || iMouse.x != m.x)) {\n\n        // create from mouse coord difference a rotation axis\n        F4\n        axis = F4(normalize(F3(m.y - iMouse.y, iMouse.x - m.x, 0)),  .01 * length(iMouse.yx - m.yx));\n\n        // read the coords system of the cube\n        M3\n        dir = M3(\n            rd(DIR + X).xyz,\n            rd(DIR + Y).xyz,\n            rd(DIR + Z).xyz\n        );\n\n        // rotate the cubes coords system by angle axis.w around axis.xyz\n        dir = rot(dir, axis.w, axis.xyz);\n\n        // write new cubes 3d coords to RAM as 3 x vec4\n        wt(DIR + X, F4(dir[X], 0));\n        wt(DIR + Y, F4(dir[Y], 0));\n        wt(DIR + Z, F4(dir[Z], 0));\n    }\n    \n    // write current mouse state to RAM at address MOUSE\n    wt(MOUSE, iMouse);\n\n    // return o = O\n    o = O;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 167, 180, 180, 209], [1827, 1827, 1858, 1858, 6379]], "test": "untested"}
{"id": "ms23Dw", "name": "Fractal of sin(z)", "author": "darkeclipz", "description": "A render of the fractal c * sin(z). \n\nYou can use the mouse to explore the Julia set. Blogpost about it: https://rotgers.io/posts/sinz_fractal/", "tags": ["fractal", "sinz"], "likes": 9, "viewed": 571, "published": 3, "date": "1667736955", "time_retrieved": "2024-07-30T16:21:49.265625", "image_code": "#define N 256.\n#define R iResolution.xy\n#define T iTime\n#define M iMouse\n#define MOUSE_DOWN (M.z > 0.1)\n#define MOUSE_POS ((2.0*M.xy-R.y)/R.y)\n\nvec3 magma(float t) { // from Mattz\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    t *= 2.; if(t >= 1.) { t = 2. - t; }\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nfloat F(vec2 z) {\n    float i;\n    vec2 c = MOUSE_DOWN ? MOUSE_POS\n           : vec2(1.0, 0.3) - 0.01*vec2(3.0*sin(T), 5.0*cos(T)) + 0.02;\n    mat2 C = mat2(c, -c.y, c.x);\n    for(i=0.; i < N && abs(z.y) < 50.0; i++) \n        z = C*vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y));\n    return i/N;\n}\n\nvoid mainImage(out vec4 C, in vec2 P) {\n    float t = F(2.0*(2.*P-R)/R.y+vec2(T*0.2,0));\n    C = vec4(t + 0.00001 > 1.0 \n        ? vec3(0) \n        : magma(fract(5.*t + 0.08*T)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 179, 879], [881, 881, 898, 898, 1176], [1178, 1178, 1217, 1217, 1364]], "test": "untested"}
{"id": "csjGDm", "name": "Relaxing Tank", "author": "wyatt", "description": "Fluid", "tags": ["fluid"], "likes": 23, "viewed": 342, "published": 3, "date": "1667712594", "time_retrieved": "2024-07-30T16:21:50.255977", "image_code": "Main {\n    vec4 b = B(U);\n    Q = .5+.5*sin(b.w+b.z*vec4(1,2,3,4));\n    Q = b.zzzz;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define G(x,s) 0.3989422804/(s)*exp(-.5*(x)*(x)/(s)/(s))", "buffer_a_code": "Main {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q.xy -= 0.25*vec2(e.z-w.z,n.z-s.z);\n    Q.xy += .25*0.25*b.z*vec2(e.w-w.w,n.w-s.w);\n    Q.y -= (b.z)/R.y;\n    Q.w = 0.;\n    for (float x = -5.; x<=5.; x++)\n        Q.w += G(x,4.)*B(U+vec2(x,0)).z;\n    \n    if (iFrame < 1) Q = vec4(0,0,0,0);\n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.) \n    Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q.z -= 0.25*(e.x-w.x+n.y-s.y);\n    Q.w = 0.;\n    for (float x = -5.; x<=5.; x++)\n        Q.w += G(x,4.)*A(U+vec2(0,x)).w;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    Q = A(U);\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = B(U);\n    for (float x = -1.; x <= 1.; x++)\n    for (float y = -1.; y <= 1.; y++)\n    {\n        vec4 b = B(U+vec2(x,y));\n        if (length(U-b.xy)<length(U-Q.xy))\n            Q = b;\n    }\n    Q.xy += A(U).xy;\n    Q.z = sign(Q.z);\n    if (iFrame < 1) {\n        Q = vec4(U,\n        sign(U.y-.5*R.y+10.*sin(.1*U.x)),\n        U.x/R.x*2.-1.);\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<50.)\n        Q.z *= -1.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdB3Dm", "name": "voroboid swarm", "author": "ufffd", "description": "playing with Gijs scene\nsee previous work by FabriceNeyret\nhttps://shadertoyunofficial.wordpress.com/#splatting-thousands-of-particles-voronoi-particle-tracking\nand rory618 https://www.shadertoy.com/view/lsKBzt", "tags": ["voronoi", "simulation", "particles", "art", "boids"], "likes": 9, "viewed": 233, "published": 3, "date": "1667704317", "time_retrieved": "2024-07-30T16:21:51.135625", "image_code": "// #define DEBUG\n#define returnCol3(col) {fragColor=vec4(col,1.); return;}\n#define returnCol4(col) {fragColor=vec4(col); return;}\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    vec2 uv = fragCoord/R.xy;\n    #ifdef DEBUG\n      vec2 muv = iMouse.xy/R.xy;\n      if (muv.x>uv.x && muv.y>uv.y) \n          returnCol3(vec3(1.))\n      if (muv.x>uv.x) returnCol4(texture(ch0,uv))\n      if (muv.y>uv.y) returnCol4(texture(ch1,uv))       \n    #endif\n    \n    fragColor = texture(iChannel2,uv);\n\n    ivec4 ids = getClosest(ivec2(fragCoord));\n\n    vec2  p1 = getParticle(ids.x).xy;\n    vec2  p2 = getParticle(ids.y).xy;\n    float r = dot(fragCoord-(p1+p2)/2.,normalize(p2-p1));\n    \n    fragColor.rgb = vec3(smoothstep(0.,.7,fragColor.r));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// boid settings\nconst int PARTICLES = 10000; // 50000\nfloat seperation_min = 0.01;   // 0.1\nfloat seperation_max = 1.0;\nfloat alignment_min = 0.001; // 0.1\nfloat alignment_max = .5;\nfloat cohesion_min = 0.0001;  // 0.001\nfloat cohesion_max = 0.001;\nfloat speed_min = 0.3;       // 0.5\nfloat speed_max = 0.8;\n\n#define ANIM_SPEED .025\n#define TIMER ANIM_SPEED*iTime\n\n// shorthands\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define R iResolution\n\n// particle data interface\n//   rewritten to defines \n#define getClosest(xy) ivec4(texelFetch(ch1, xy, 0))\n#define locFromID(id) ivec2(id%(int(R.x)),id/(int(R.x)))\n#define getParticle(id) texelFetch(ch0, locFromID(id), 0)\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n#define key(k,mode) ( texelFetch( iChannel3, ivec2(k,mode), 0 ).x > .5 )\n#define keyDown(k) key(k,0)\n#define KEY_SPACEBAR 32\n\n#define PI 3.14159", "buffer_a_code": "// simulation\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    int id = iFragCoord.x + iFragCoord.y*int(R.x);\n    if(id>=PARTICLES) return; \n    \n    vec4 prev = texelFetch( ch0, ivec2(fragCoord), 0 );\n    vec2 pos = prev.xy;\n    vec2 vel = prev.zw;\n     \n    // reset pattern\n    if(iFrame==0 || keyDown(KEY_SPACEBAR)){\n        float h1 = hash(id);\n        float h2 = hash(int(h1*41343.));\n        pos = vec2(h1,h2)*R.xy;\n    }\n    \n    float timer = fract(TIMER);\n    int cycle = int(TIMER);\n\n    vec2 force = vec2(0);\n    \n    if(iMouse.z > 0.){\n        vec2 delta = pos-iMouse.xy;\n        float dis = length(delta);\n        force -= delta/(dis*dis*dis) * 100.;\n    } else {\n        vec2 delta = pos-R.xy/2.;\n        float dis = length(delta);\n        vec2 p1 = delta-vec2(R.x/4.,0.);\n        vec2 p2 = delta+vec2(R.x/4.,0.);\n        float d1 = length(p1);\n        float d2 = length(p2);\n        \n        if(timer<0.007||timer>.66) {\n            // force -= delta/(dis*dis*dis) * 100.;\n            force -= p1/(d1*d1*d1) * 100.;\n            force -= p2/(d2*d2*d2) * 100.;\n        }\n    }\n    \n    // set boid values for the current cycle\n    //   min-max set in COMMON\n    float seperation = mix(\n        seperation_min,\n        seperation_max,\n        hash(cycle    ));\n    float cohesion = mix(\n        cohesion_min,\n        cohesion_max,\n        hash(cycle+100));\n    float alignment = mix(\n        alignment_min,\n        alignment_max,\n        hash(cycle+200));\n    float speed = mix(\n        speed_min,\n        speed_max,\n        hash(cycle+100));\n\n    ivec4 closest = getClosest(ivec2(pos));\n    for(int i = 0; i < 4; i++){\n        int cid = closest[i];\n        if(cid==id) continue;\n\n        vec4 part = getParticle(cid);\n        vec2 delta = part.xy-pos;\n        float dis = length(delta);\n        force += -delta /(dis*dis*dis) * seperation;\n\n        force += delta * cohesion;\n\n        force += (part.zw-vel)/(dis+1.) * alignment;\n    }\n\n    vec2 dis = max(R.xy-pos, vec2(1));\n    force -= 1./(dis*dis)*20.;\n         dis = max(pos, vec2(1));\n    force += 1./(dis*dis)*20.;\n\n    vel += force;\n\n    vel = normalize(vel)* speed; \n    \n    pos += vel;\n    \n    fragColor = vec4(pos,vel);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// particle storage?\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = getParticle(id).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    ivec4 new = ivec4(-1);\n    vec4 dis = vec4(1e20);\n\n    ivec4 old   = getClosest( iFragCoord + ivec2( 0, 0) );            \n    ivec4 east  = getClosest( iFragCoord + ivec2( 1, 0) );\n\tivec4 north = getClosest( iFragCoord + ivec2( 0, 1) );\n    ivec4 west  = getClosest( iFragCoord + ivec2(-1, 0) );\n    ivec4 south = getClosest( iFragCoord + ivec2( 0,-1) );\n    ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n    \n    for(int i=0; i<5; i++){\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, fragCoord);\n            insertion_sort( new, dis, id, dis2 );\n        }\n    }\n    \n    for(int k = 0; k < 1; k++){\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(R.x) + \n            iFrame*int(R.x*R.y) +\n            k\n        );\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, fragCoord) );\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 ratioZoom(in vec2 uv, in vec2 R, in float k) {\n    uv -= 0.5;\n    uv *= vec2(1.,R.x/R.y);\n    uv *= 1.-k;\n    uv /= vec2(1.,R.x/R.y);\n    uv += 0.5;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    fragColor = vec4(0);\n    \n    float timer = fract(TIMER);\n    int cycle = int(TIMER);\n\n    ivec4 ids = getClosest(ivec2(fragCoord));\n\n    const int glow = 6;\n    float dots = 0.;\n    for(int i = 0; i < glow; i++){\n        int id = ids[i];\n        vec2 pos = getParticle(id).xy;\n        float d = distance(fragCoord,pos);\n        dots += 1./(pow(d+.5,2.)); // draw dots\n    }\n    // feedback uvs\n    float zoomer = pow(sin(timer*PI+PI/2.),5.);\n    zoomer *= 0.002;\n    vec2 luv = fragCoord/R.xy;\n    luv = ratioZoom(luv,R.xy,zoomer);\n    vec4 last = texture(iChannel2,luv);\n    float b = mix(dots,last.r,.99);\n    b = clamp(b,0.,1.);\n    b = mix(b,dots,dots*dots*dots);\n    fragColor = vec4(vec3(b),1.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdB3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "msS3Wm", "name": "vector swizzling ", "author": "jonasfrey", "description": "this is vector swizzling\nthe order of vector channels can be changed by simply changing the order of the letters \"rgba\"  ", "tags": ["swizzling"], "likes": 0, "viewed": 137, "published": 3, "date": "1667682844", "time_retrieved": "2024-07-30T16:21:52.100047", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_pixel_coord_norm = fragCoord.xy / iResolution.xy; \n    \n    float n_screens = 3.0;\n    fragColor = vec4(\n        1.0\n    );\n    for(float n_screen = 0.0; n_screen < n_screens; n_screen+=1.0){\n        float n_x_norm_screen = mod(a_n_pixel_coord_norm.x,1.0/n_screens) / (1.0/n_screens);\n        \n        if(a_n_pixel_coord_norm.x > 0.0*(1.0/n_screens)){\n       \n            fragColor = vec4(\n                1.0,  // red is 1.0\n                0.0, \n                0.0, \n                1.0\n            );\n        }\n        \n        if(a_n_pixel_coord_norm.x > 1.0*(1.0/n_screens)){\n            fragColor.rgba = fragColor.bgra;\n            //          ^ blue is from   ^ red (1.0)\n            //\n            // now blue holds 1.0\n        }\n        if(a_n_pixel_coord_norm.x > 2.0*(1.0/n_screens)){\n            fragColor.rgba = fragColor.rbra;\n            //         ^ green is from  ^ blue (1.0)\n            // \n            // now green holds 1.0\n\n        }\n        \n\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msS3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1045]], "test": "untested"}
{"id": "msBGWm", "name": "moire circle ", "author": "jonasfrey", "description": "mouse y: line width\n\nmouse x: translation\n\nhttps://de.wikipedia.org/wiki/Moir%C3%A9-Effekt", "tags": ["circle"], "likes": 3, "viewed": 136, "published": 3, "date": "1667682561", "time_retrieved": "2024-07-30T16:21:52.903897", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     float n_y_scale_resolution_min = min(iResolution.x, iResolution.y);\n     float n_y_scale_resolution_max = max(iResolution.x, iResolution.y);\n     float n_scale_res_xy_delta = n_y_scale_resolution_max - n_y_scale_resolution_min;\n     vec2 a_n_pixel_coords_norm_square_aspect_ratio = \n        (fragCoord.xy - vec2(n_scale_res_xy_delta/2.0,0)) \n        / \n        vec2(n_y_scale_resolution_min, n_y_scale_resolution_min);\n     \n     vec2 a_n_mouse_coords_norm_square_aspect_ratio = \n        (iMouse.xy - vec2(n_scale_res_xy_delta/2.0,0)) \n        / \n        vec2(n_y_scale_resolution_min, n_y_scale_resolution_min);\n     \n     if(iMouse.xy == vec2(0.0)){\n     \n         a_n_mouse_coords_norm_square_aspect_ratio = \n         vec2(\n             sin(iTime*0.2)*0.1+0.5,\n             0.5\n         );\n     }\n\n\n\n    vec2 delta = vec2(\n        a_n_pixel_coords_norm_square_aspect_ratio - vec2(0.5,0.5)\n    ); \n    float n_circles = 60.0;\n    float n_circle_width = 0.9*a_n_mouse_coords_norm_square_aspect_ratio.y;\n    float dist = length(delta);\n    float distmod = mod(dist, 1.0/n_circles)/(1.0/n_circles);\n    float distmodstep = step(n_circle_width,distmod);\n    fragColor = vec4(distmodstep);\n    \n    float n_circles2 = n_circles - 5.0;\n    vec2 delta2 = vec2(\n        a_n_pixel_coords_norm_square_aspect_ratio - vec2(a_n_mouse_coords_norm_square_aspect_ratio.x,0.5)\n    ); \n    float dist2 = length(delta2);\n    float distmod2 = mod(dist2, 1.0/n_circles2)/(1.0/n_circles2);\n    float distmodstep2 = step(n_circle_width,distmod2);\n    fragColor = vec4(mix(fragColor.r, distmodstep2, 0.5));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1655]], "test": "untested"}
{"id": "msSGDm", "name": "Hall of Claude", "author": "MysteryPancake", "description": "Modified from my \"Hall of Mirrors\" shader (shadertoy.com/view/dsSGWm). Click to drag offset position :)", "tags": ["mirror", "redgiant", "aftereffects", "hallofmirrors", "plugin", "obsolete"], "likes": 11, "viewed": 301, "published": 3, "date": "1667680571", "time_retrieved": "2024-07-30T16:21:53.663865", "image_code": "// Modification of https://www.shadertoy.com/view/dsSGWm\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Number of images to display\n\tint images = 96;\n\t// Scale factor per image\n\tfloat scale = 0.9 + cos(iTime) * 0.05;\n\t// Rotation per image in degrees\n\tfloat rotation = sin(iTime) * 90.0;\n\t// Position offset per image in normalized coordinates (0-1)\n\tvec2 offset = iMouse.z > 0.0 ? vec2(iMouse.xy / iResolution.xy) : 0.5 + vec2(cos(iTime), sin(iTime)) * 0.5;\n\n\tfloat rad = radians(-rotation);\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(0.0);\n\n\tfor (int i = 0; i < images; ++i) {\n\t\t// SCALING: Offset, apply scale, reset offset\n\t\tvec2 pos = uv - offset;\n\t\tpos /= pow(scale, float(i));\n\t\tpos += offset;\n\n\t\t// ROTATION\n\t\tfloat theta = rad * float(i);\n\t\tfloat cs = cos(theta);\n\t\tfloat sn = sin(theta);\n\t\t// Offset to center, fix aspect ratio\n\t\tpos -= vec2(0.5);\n\t\tpos *= iResolution.xy;\n\t\t// Rotate coordinate space\n\t\tpos = vec2(pos.x * cs - pos.y * sn, pos.x * sn + pos.y * cs);\n\t\t// Reset aspect ratio, reset offset\n\t\tpos /= iResolution.xy;\n\t\tpos += vec2(0.5);\n\n\t\t// Prevent out of bounds bugs, could also be done with clamp\n\t\tif (pos.x >= 0.0 && pos.x <= 1.0 && pos.y >= 0.0 && pos.y <= 1.0) {\n            // Color key\n            vec4 color = texture(iChannel0, pos);\n            color.a = smoothstep(0.5, 0.8, distance(color.rgb, vec3(0.0, 1.0, 0.0)));\n            // Tint towards red/yellow\n            color.rgb += vec3(float(i * 4) / float(images), float(i) / float(images), 0.0);\n            // Premultiply color\n            color.rgb *= color.a;\n            // Composite behind\n            fragColor += (1.0 - fragColor.a) * color;\n            // Early exit\n            if (fragColor.a >= 1.0) return;\n\t\t}\n\t}\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 113, 146, 1745]], "test": "untested"}
{"id": "dsSGWm", "name": "Hall of Mirrors", "author": "MysteryPancake", "description": "My recreation of the deleted \"Hall of Mirrors\" effect by Red Giant, one of my favourite effects. Click to drag offset position.", "tags": ["mirror", "redgiant", "aftereffects", "hallofmirrors", "plugin", "obsolete"], "likes": 10, "viewed": 642, "published": 3, "date": "1667676923", "time_retrieved": "2024-07-30T16:21:54.425828", "image_code": "// Faithful remake of the deleted \"Hall of Mirrors\" effect by Red Giant\n// Recreated by MysteryPancake\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Number of images to display\n\tint images = 33;\n\t// Scale factor per image\n\tfloat scale = 0.9 + cos(iTime * 2.0) * 0.1;\n\t// Rotation per image in degrees\n\tfloat rotation = sin(iTime * 0.5) * 45.0;\n\t// Position offset per image in normalized coordinates (0-1)\n\tvec2 offset = iMouse.z > 0.0 ? vec2(iMouse.xy / iResolution.xy) : 0.5 + vec2(cos(iTime), sin(iTime)) * 0.5;\n\t// Composite behind or in front\n\tbool behind = false;\n\n\tfloat rad = radians(-rotation);\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(0.0);\n\n\tfor (int i = 0; i < images; ++i) {\n\t\t// SCALING: Offset, apply scale, reset offset\n\t\tvec2 pos = uv - offset;\n\t\tpos /= pow(scale, float(i));\n\t\tpos += offset;\n\n\t\t// ROTATION\n\t\tfloat theta = rad * float(i);\n\t\tfloat cs = cos(theta);\n\t\tfloat sn = sin(theta);\n\t\t// Offset to center, fix aspect ratio\n\t\tpos -= vec2(0.5);\n\t\tpos *= iResolution.xy;\n\t\t// Rotate coordinate space\n\t\tpos = vec2(pos.x * cs - pos.y * sn, pos.x * sn + pos.y * cs);\n\t\t// Reset aspect ratio, reset offset\n\t\tpos /= iResolution.xy;\n\t\tpos += vec2(0.5);\n\n\t\t// Prevent out of bounds bugs, could also be done with clamp\n\t\tif (pos.x >= 0.0 && pos.x <= 1.0 && pos.y >= 0.0 && pos.y <= 1.0) {\n\t\t\tvec4 color = texture(iChannel0, pos);\n            // Alpha blending, see shadertoy.com/view/msSGDm for working example\n\t\t\tif (behind) {\n\t\t\t\tfragColor += (1.0 - fragColor.a) * color;\n\t\t\t} else {\n\t\t\t\tfragColor = color + (1.0 - color.a) * fragColor;\n\t\t\t}\n\t\t}\n\t}\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 159, 192, 1597]], "test": "untested"}
{"id": "Dsj3WW", "name": "Digital Abyss", "author": "kishimisu", "description": "What will you find at the bottom?...\n\nInteractive with the mouse!", "tags": ["interactive", "spiral", "colorful", "psychedelic", "rgb", "vortex"], "likes": 34, "viewed": 801, "published": 3, "date": "1667676267", "time_retrieved": "2024-07-30T16:21:55.208735", "image_code": "/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid mainImage(out vec4 O, in vec2 F) { \n_AA_START     \n    float a, r, t = 3.;\n    vec2  n       = iResolution.xy,\n          i       = (F+(o-n)*.5)/n.y,\n          m       = iMouse.xy/n*2.-1.;\n          \n    for (a = 0.; a < 2e2 && t > .001; a++) {\n        vec3 p = r*vec3(i*.35 - m*.05, 1.);\n        p.xy  *= mat2(cos(r*m.x*.07 + vec4(0,33,11,0)));\n        p.z   += iTime*.6; p = abs(fract(p)-.5);            \n        r += t = (p.x + p.y + p.z - .12)*.6;        \n    }\n    tot += mix(.7 - vec3(r*r*2e-4), \n        1.5*cos(r*(vec3(5.7, 5.76, 5.82) + length(i))), \n        exp(-r*.07) * (1.2-length(i))); \n_AA_END \n} ", "image_inputs": [], "common_code": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\nO = vec4(tot, 1.);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsj3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdS3Dw", "name": "大龙猫- Inercia 2022 Shader Royale", "author": "totetmatt", "description": "Prod from Inercia 2022 Shader Royale. ", "tags": ["inercia"], "likes": 9, "viewed": 286, "published": 3, "date": "1667674303", "time_retrieved": "2024-07-30T16:21:56.039514", "image_code": "vec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\nfloat rnd = 0.;\nfloat bpm = 0.;\nfloat box3(vec3 p,vec3 b){\n    p = abs(p)-b;\n    return length(max(vec3(0.),p))+min(0.,max(p.x,max(p.y,p.z)));\n}\nfloat box2(vec2 p,vec2 b){\n    p = abs(p)-b;\n    return length(max(vec2(0.),p))+min(0.,max(p.x,p.y));\n}\nvec2 sdf(vec3 p){\n  vec3 op = p;\n  vec2 h;\n   p.x +=iTime;\n \n  vec3 hp = p;\n  hp.y -=2.;\n   float d = 0.;\n  for(float i=0.2;i<25.;hp=erot(hp,vec3(0.,1.,0.),i+=i)){\n      \n       d += abs(dot(asin(sin(hp*i)),vec3(.4)/i));\n       hp=erot(hp,normalize(vec3(.1,.2,.3)),i);\n  }    float txt = texture(iChannel0,fract(vec2(.05+floor(hp.x*10.)/100.))).r*.1;\n     h.x = abs(p.y+2.)-d*.3-txt;\n   \n     h.x = max(abs(p.z-7.)-7.5,h.x);\n     h.y = 1.;\n  \n     vec2 t;\n    vec3 tp=p;\n  \n  tp.y +=1.+sin(p.z*.5+bpm+iTime)*.1;\n   float q = sign(p.y);\n   tp.xz = fract(tp.xz)-.5;\n   tp =erot(tp,vec3(0.,1.,0.),sign(q)*.785);\n   tp.y = abs(tp.y)-.05;\n  t.x =max(abs(p.z)-5.5, min(length(tp.zy),length(tp.xy))-.01);\n  t.y = 2.;\n  h= t.x < h.x ? t:h;\n  \n    tp = p;\n   \n   tp.y = abs(tp.y)-1.75;\n     tp = erot(tp,vec3(1.,0.,0.),bpm+p.x);\n    tp = abs(tp)-.2;\n \n     t.x = box2(tp.yz,vec2(.05));\n     \n     t.y = 3.;\n  \n    h= t.x < h.x ? t:h;\n    \n    \n    \n    tp = op;\n    for(float j=0.;j<=8.;j++){\n      vec3 ttp= tp;\n      ttp.y +=sin(iTime+j+rnd*.01);\n    ttp.x += tan(bpm+iTime+j+rnd*.01);\n    ttp=erot(ttp,normalize(vec3(.0,.1,.2)),bpm);\n     t.x = box3(ttp,vec3(.2));\n     t.y = 1.+mod(j,3.);;\n    h= t.x < h.x ? t:h;\n       }\n    \n       \n       tp=p;\n       tp.y +=1.5;\n       t.x = abs(tp.y)-.1;\n       t.y = 4.;;\n      \n        h= t.x < h.x ? t:h;\n    \n  return h;\n}\n\n#define q(s) s*sdf(p+s).x\n\nvec3 norm(vec3 p, float ee){vec2 e =vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvec3 sun(vec2 p){\n    float up = max(0.,p.y);\n     float d = length(p)-.5;;\n     float t = texture(iChannel0,fract(vec2(abs(floor(p.x*100.)/100.)))).r*.1;\n     float bar = abs(abs(p.y+cos(p.x*5.+iTime)*.1)-.2-t)-.01;\n     d = max(-bar,d);\n\n     float glow = abs(.05/d);\n     d = smoothstep(fwidth(d),0.,d);\n     vec3 col = mix(vec3(.9,.9,.0),vec3(.9,.0,.9),sqrt(up));\n    return col *d * up+glow*up*mix(col,1.-col,sin(atan(p.x,p.y)+iTime));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = sun(uv);\n  float beat = sqrt(texture(iChannel0,vec2(.3)).r);\n     rnd = dot(sin(uv*700.),cos(uv.yx*500.))*.5;\n     bpm=iTime;\n  bpm = floor(bpm)+pow(fract(bpm),2.);\n   vec3 ro = vec3(0.2+sin(bpm),1.,-3.+sin(iTime*.1)*2.),rt = vec3(0.,1.,0.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = cross(z,x);\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.-(.3+floor(sin(bpm+rnd*.05)*5.)*.1)*sqrt(length(uv+rnd*.01))));\n  vec3 rp = ro;\n  vec3 light = vec3(1.,2.,9.);\n  float dd =0.;\n  vec3 acc = vec3(0.);\n  bool ref= false;\n  float dir = 1.;\n  float IOR = 2.4;\n  float i=0.;\n  for(i=0.;i++<108. && dd < 50.;){\n      vec2 d = sdf(rp);\n    d.x  *=dir;\n     if(d.y == 2.){\n         \n          acc += vec3(.9,.0,.9)*exp(-abs(d.x))/(60.-beat*40.+rnd);\n          d.x = max(.002,abs(d.x));       \n      }\n        \n    dd+=d.x;\n      rp+=rd*d.x;\n    \n      if(d.x < .001){\n        \n           \n           vec3 n = norm(rp,.01);\n         vec3 n2 = norm(rp,.03);\n           float dif = max(0.,dot(normalize(light-rp),n));\n           if(d.y == 3.){\n              if(!ref){\n                   rd = refract(rp,n,1./IOR);\n                   rp+=-n+rd*.1;\n                    acc+=dif*.1;\n                ref = true;\n                dir *=-1.;\n              } else {\n                \n                vec3 _rd = refract(rp,n,IOR);\n                if(dot(_rd,rd) ==0.){\n                   rd = reflect(rp,-n);   \n                   rp+=rd*.1;\n                } else {\n                  rd=_rd;\n                  rp+=n+rd*.1;\n                   dir *=-1.;\n                }\n               }\n              continue;\n             \n           } else if(d.y == 4.){\n             \n             rd = reflect(rd,n+rnd*.01);\n              rp+=rd*.1;\n             col =vec3(.1,.0,.2);\n               continue;\n             }\n           float spc = pow(max(0.,dot(rd,reflect(normalize(light-rp),n))),32.);\n           col = dif * vec3(.5)+ mix(vec3(.1),vec3(.3,.0,.9),spc*5.)*dif*step(.15,length(n-n2))*texture(iChannel0,vec2(.3)).r*1.;\n           break;\n        }\n  }\n  if(ref && dd >=50.){\n    col = sun(rd.xy);\n  } \n  col = mix(vec3(.01),col,1.-exp(-i*i));\n\n    // Output to screen\n    fragColor = vec4(col+acc,1.0);\n}", "image_inputs": [{"id": 30091, "src": "https://soundcloud.com/alkama/lowvoltage?in=alkama/sets/remix-and-reworks", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdS3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 88], [121, 121, 147, 147, 233], [234, 234, 260, 260, 337], [338, 338, 355, 355, 1699], [1728, 1728, 1756, 1756, 1832], [1833, 1833, 1850, 1850, 2275], [2276, 2276, 2333, 2383, 4682]], "test": "untested"}
{"id": "mdB3Wz", "name": "Metakoch II", "author": "mla", "description": "Koch curves but with an arbitrary path, set by the mouse (drag the three inner red points). See code for other controls.", "tags": ["lsystem", "stack", "recursion", "koch"], "likes": 23, "viewed": 258, "published": 3, "date": "1667670817", "time_retrieved": "2024-07-30T16:21:56.808458", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Metakoch II, mla, 2022.\n//\n// Koch curves but with an arbitrary path, set by the mouse (drag the three inner\n// red points). There is a counter limiting the number iterations eg. for\n// heavily overlapping curves - place where this happens are coloured a lurid green.\n// Draws two copies of the curve, rotated by 180°, filling the region in between.\n//\n// Code should generalize to more than 4 segments, or using a diffent path at\n// each level of recursion - I've not experimented with this.\n//\n// Controls:\n//\n// <mouse>: set path\n// <up>/<down>: zoom\n// 'c': hide controls\n// 'a': adaptive mode where we iterate down to a minimum segment length\n// 'x': show segments actually drawn around mouse position\n// 'f': fill shape\n// 'm': show moving point\n// 'p': progressive depth\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nconst int MAXDEPTH = 16;       // Maximum stack depth\nconst vec2 initp = vec2(-1,0); // Initial drawing point\n\nvec2 p = initp;                // The drawing point\nvec2 point = vec2(0);          // The moving point\nbool gotpoint = false;\nfloat plen = 0.0;              // Cumulative path length\nint wind = 0; // Compute winding number here\n\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.x <= 0.0) {\n    if (r.x > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.x <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t < plen+seglen && !gotpoint) {\n    gotpoint = true;\n    point = p + (t-plen)/seglen*seg;\n  }\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\n// Map screen coordinates\nvec2 map(vec2 pos) {\n  pos = scale*(2.0*pos - iResolution.xy)/iResolution.y;\n  return pos;\n}\n\n// This should get something from a buffer so we can set all three points\nvec2 getpoint(int i) {\n  vec2 p = getselection(i-1);\n  p *= 0.5;\n  p.x += 0.5;\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int maxdepth = 8;\n  bool adaptive = key(CHAR_A);\n  if (adaptive) maxdepth = MAXDEPTH;\n  else if (key(CHAR_P)) maxdepth = 1+int(iTime)%maxdepth;\n  scale = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec2 pos = map(fragCoord);\n  vec2 pos2 = pos;\n  if (key(CHAR_X)) pos2 = map(iMouse.xy);\n  float pwidth = fwidth(pos.x);\n  vec2 program[5];\n  float radius = 0.0;\n  float pathlen = 0.0;\n  {\n    #define C(a,b) (vec2(a,b))\n    vec2 p[] =\n      vec2[](vec2(0,0),\n             getpoint(1),\n             getpoint(2),\n             getpoint(3),\n             vec2(1,0));\n    float theta = 0.0;\n    float seglen = 1.0;\n    for (int i = 0; i < 4; i++) {\n      radius = max(radius,distance(vec2(0.5,0),p[i]));\n      assert(p[i] != p[i+1]);\n      float theta1 = arg(p[i+1]-p[i]);\n      float seglen1 = length(p[i+1]-p[i]);\n      pathlen += seglen1;\n      program[i] = C(seglen1/seglen,theta1-theta);\n      theta = theta1;\n      seglen = seglen1;\n    }\n    program[4] = C(1.0/seglen,-theta);\n    #undef C\n  }\n  int stack[MAXDEPTH];\n  float d = 1e8;\n  float seglen = 2.0;\n  float theta = 0.0;    // Cumulative angle\n  float t = mod(iTime,2.0*seglen*pow(pathlen,float(maxdepth))); // Moving point\n  for (int i = 0; i < 2; i++,theta += PI) {\n  int depth = 0;\n  stack[depth++] = 0;\n  int check = 1000;\n  while (depth > 0 && check-- > 0) {\n    assert(check > 1);\n    vec2 instr = program[stack[depth-1]++];\n    float lenfact = instr[0];\n    float angle = instr[1];\n    theta += angle; // Apply turn\n    seglen *= lenfact;\n    if (stack[depth-1] == program.length()) {\n      depth--;    // Terminate level & unwind\n    } else if (depth == maxdepth || seglen < 3.0*pwidth) {\n      d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n    } else {\n      vec2 seg = seglen*vec2(cos(theta),sin(theta));\n      vec2 next = p+seg; // Where we end up\n      if (distance(pos2,p+0.5*seg) > seglen) {\n        polywind(pos,p,next);\n        // Show actuall path taken to mouse position.\n        if (key(CHAR_X)) d = min(d,segment(pos,p,next));\n        p = next;\n        plen += seglen*pow(pathlen,float(maxdepth-depth));\n      } else {\n        stack[depth++] = 0;  // Recurse\n      }\n    }\n  }\n  }\n  polywind(pos,p,initp);\n  float px = fwidth(pos.x);\n  vec3 col = vec3(1,1,0.8);\n  if (!key(CHAR_F) && (wind&1) != 0) {\n     col = texture(iChannel0,pos).xyz;\n     if (d > 1.0) col *= 0.75; \n  }\n  col *= vec3(smoothstep(0.0,px,d));\n  if (key(CHAR_M) && gotpoint) col = mix(vec3(1,0,0), col,smoothstep(0.0,px,distance(pos,point)-0.01));\n  if (key(CHAR_R)) col = mix(vec3(1,0,0), col,smoothstep(0.0,px,abs(distance(pos,vec2(0))-2.0*radius)));\n  if (!key(CHAR_C)) {\n    float px = fwidth(pos.x);\n    vec2 points[] = vec2[](vec2(-1,0),\n                           getselection(0),\n                           getselection(1),\n                           getselection(2),\n                           vec2(1,0));\n    float d = 1e8, d1 = 1e8;\n    for (int i = 0; i < 5; i++) {\n      d1 = min(d1,distance(pos,points[i]));\n      if (i < 4) d = min(d,segment(pos,points[i],points[i+1]));\n    }\n    col = mix(vec3(0),col,smoothstep(0.0,px,d-0.008));\n    col = mix(vec3(1,0,0),col,smoothstep(0.0,px,d1-0.025));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.g = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat scale = 1.0;\n\nconst float PI = 3.1415927;\n\nint nselections = 3;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-0.25,0);\n  if (i == 1) return vec2(0.25,0.8);\n  if (i == 2) return vec2(+0.25,0);\n  return vec2(0);\n}\n\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// Complex argument\nfloat arg(vec2 z) {\n  return atan(z.y,z.x);\n}\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\n// const int CHAR_G = 71;\nconst int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\nconst int CHAR_K = 75;\n// const int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "buffer_a_code": "#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nvec2 map(vec2 screen) {\n    return scale*(2.0*screen-iResolution.xy)/iResolution.y;\n}\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  scale = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.xyz = vec3(initselection(i-1),1234); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdB3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1292, 1292, 1331, 1366, 1551], [1553, 1553, 1618, 1618, 1879], [1881, 1907, 1927, 1927, 1999], [2001, 2075, 2097, 2097, 2167]], "test": "untested"}
{"id": "msBGWw", "name": "Inercia 2022 Shader Royale", "author": "mu6k", "description": "Here is my shader royale shader. I got eliminated pretty early on, but I continued throughout the shader royale until the winner was announced.", "tags": ["3d", "sdf", "spheres", "transition"], "likes": 15, "viewed": 329, "published": 3, "date": "1667669313", "time_retrieved": "2024-07-30T16:21:57.657189", "image_code": "#define T (iTime)\n\nfloat sid=0.0;\nvec3 c0=vec3(0);\n\nmat2 rot(float a)\n{\n\tfloat c=cos(a), s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat dfo(vec3 p, float id)\n{\n\tp.xy*=rot(p.z*sin(T/4.0+id)*(.01+id*0.1));\n\tp.z+=T;\n\tfloat s = 1.0/id/id;\n\tvec3 p2 = mod(p, s+s)-s;\n\tp+=sin(p.yzx+T);\n\treturn length(p2)-s*0.5;\n}\n\nfloat df(vec3 p)\n{\n\tfloat d=dfo(p,0.0);\n\tfor (float i=.0; i<4.0; i+=1.)\n\t{\n\t\td=max(d-.2, min(d, dfo(p, i)));\n\t}\n\treturn d;\n}\n\nvec3 nf(vec3 p)\n{\n\tvec2 e=vec2(0,0.5e-4);\n\treturn normalize(vec3(\n\t\tdf(p+e.yxx)-df(p-e.yxx), \n\t\tdf(p+e.xyx)-df(p-e.xyx), \n\t\tdf(p+e.xxy)-df(p-e.xxy)));\n}\n\nvec3 surf(vec3 pos)\n{\n\tvec3 norm = nf(pos);\n\tvec3 emc = c0;\n\tvec3 shr = vec3(0);\n\tfloat pat = 0.0;\n\tfloat q = 0.0;\n\tq += smoothstep(0.9,0.98,sin((pos.z*0.5+T*3.14159)));\n\tpat += smoothstep(0.97-q,0.98,sin(94.0*df(pos*1.0+1.0)));\n\tpat += smoothstep(0.92,0.98,sin(94.0*df(pos*4.0+1.0)))*0.2;\n\tshr=emc * pat * (1.0+q*2.0) * max(.0,sin(pos.z*0.5+T));\n\treturn shr;\n  }\n\nvec3 eval_surface(vec3 pos, vec3 dir)\n{\n\treturn surf(pos);\n}\n\nvec3 frame(in vec2 coord, int id)\n{\n\tvec4 color = vec4(1.0);\n\tvec2 uv = (coord-iResolution.xy/2.0)/iResolution.yy;\n\n\tvec2 quv = uv-mod(uv,vec2(0.1));\n\tfloat q=fract(dot(quv, vec2(2.412,95.313))*31.3513);\n\tsid = T*0.3+q*0.25;\n\tsid -= fract(sid);\n\tsid = sin(sid*4123.0);\n\t\n\tc0 = mix(vec3(0.9,9,1.1), vec3(9,0.9,1.1), abs(sin(sid*4.04+uv.y*0.5)));\n\tc0 = mix(c0, vec3(1.5,.9,6), abs(sin(sid*9.53+uv.y*0.5)));\n\n\tvec3 pos = vec3(sin(sid)*0.35,cos(sid*4.0)*0.35,-4.0);\n\tvec3 dir = normalize(vec3(uv.xy, +1));\n\tfloat dt=0.01;\n\tfloat dist;\n\t\n\tdir.xy*=rot(sid);\n\tdir.xz*=rot(sin(sid*53.0)/4.0);\n\tdir.yz*=rot(sin(sid*9.0)/4.0);\n\t\n\tfor (int i=0; i<150; i+=1){\n\t  dist = df(pos+dir*dt);\n\t  dt += dist;\n\t  if (dist<1e-4) break;\n\t}\n\t\n\tvec3 pos2 = pos+dir*dt;\n  \n\tvec3 col = vec3(0);\n\tif (dist < 1e-3)\n\t{\n\t  col = surf(pos2);\n\t}\n\t\n\tvec3 dir2 = reflect(dir, nf(pos2));\n\tfloat dt2 = 1e-3;\n\tfloat dist2 = 0.0;\n\tfor (int i=0; i<100; i+= 1){\n\t  dist=df(pos2+dir2*dt2);\n\t  dt2+=dist;\n\t  if (dist<1e-4) break;\n   \n\t}\n\tvec3 pos3 = pos2+dir*dt2;\n\tvec3 col2 = c0;\n\tif (dist < 1e-3)\n\t{\n\t  col2 = surf(pos3);\n\t}\n\tcol2 += mix(c0*4.0,col2,1.0/(1.0+dt2*dt2*.5e-3));\n\t\n\tfloat fres = pow(1.0+dot(dir, nf(pos2)),2.0);\n\tfres = clamp(fres,0.0,1.0);\n\t\n\tcol=mix(col, col2, fres);\n\tcol=mix(c0*4.0,col,1.0/(1.0+dt*dt*.5e-3));\n\n\treturn vec3(col);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord){\n\n\tcolor = vec4(0);\n\n\tfor (int i=0; i<1; i+=1)\n\t{\n\t\tcolor.xyz += frame(coord, i);\n\t}\n\n\tfloat vignette = 1.0-pow(length((coord.xy-.5*iResolution.xy)/iResolution.yy),2.0);\n\tcolor.xyz *= clamp(vignette, 0.0, 1.0);\n\tcolor.xyz = 1.2*vec3(1.35,1.3,1.5)*color.xyz/(1.0+color.xyz);\n\tvec3 inv_gamma = vec3(1.0/2.2);\n\tcolor.xyz = pow(color.xyz, inv_gamma);\n\tcolor.xyz = clamp(color.xyz, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 71, 71, 124], [126, 126, 155, 155, 302], [304, 304, 322, 322, 428], [430, 430, 447, 447, 582], [584, 584, 605, 605, 947], [949, 949, 988, 988, 1009], [1011, 1011, 1046, 1046, 2318], [2320, 2320, 2366, 2366, 2755]], "test": "untested"}
{"id": "cdS3Dm", "name": "Multigrain flowmap", "author": "matigekunstintelligentie", "description": "Multigrain flowmap. flow_mix function is incorrect for grains>2. flow_mix does not sum to 1, resulting in a fluctuating saturated image", "tags": ["flowmap"], "likes": 5, "viewed": 480, "published": 3, "date": "1667665464", "time_retrieved": "2024-07-30T16:21:58.598671", "image_code": "float strength = 0.02;\nfloat speed = 0.2;\nint grains = 2;\nfloat fgrains; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Some convenient variables\n    fgrains = float(grains);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Flow from channel 0s RG channels between -1 and 1\n    vec2 flow = (texture(iChannel0,uv).rb-0.5)*2.;\n    \n    // Original phase saw tooth wave\n    float phase = fract(iTime*speed);\n    vec2 uv1 = uv + (flow*phase*strength);\n    \n    // Triangle wave that determines mixture \n    float flow_mix = 1.-abs((fgrains*phase - (0.5*fgrains))/(0.5*fgrains));\n    \n    //Initialise color with first term\n    vec4 color = texture(iChannel1, uv1)*flow_mix;\n    \n    for(int i=1;i<grains;i++){\n        // Calculate next sawtooth wave with offset\n        float phase_tmp = fract(phase + 1./fgrains);\n        vec2 uv2 = uv + (flow*phase_tmp*strength);\n        \n        phase = phase_tmp;\n        flow_mix = 1.-abs(2.*phase - 1.);\n        color += texture(iChannel1, uv2)*flow_mix;\n    }\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdS3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 132, 165, 1069]], "test": "untested"}
{"id": "csBGWm", "name": "Fluttering thing", "author": "aldroid", "description": "Made in the Shader Royale at Inercia 2022, mostly unplanned, no idea how it ended up in this strange state.", "tags": ["shaderroyale"], "likes": 4, "viewed": 170, "published": 3, "date": "1667660006", "time_retrieved": "2024-07-30T16:21:59.419477", "image_code": "\nmat2 rot(float a) {\n  return mat2(cos(a), -sin(a),sin(a), cos(a));\n}\n\nfloat wing2(vec2 uv) {\n  uv.x = abs(uv.x);\n  return length(uv + sin(uv.y)*2.)-1.;\n}\n\nfloat wing(vec3 p) {\n  p.x = abs(p.x);\n  p.xz *= rot(sin(iTime*20.)/5.);\n  return max(abs(p.z)-0.01,wing2(p.xy));\n}\n\n\nfloat flutter(vec3 p) {\n    p.y += sin(iTime);\n  p.x += sin(iTime*2.)*2.;\n  p.yz *= rot (1.2+sin(iTime*2.)*0.2);\n  p.xy *= rot(sin(iTime*2.+0.5));\n  float bod=length(p/vec3(0.3,1.,0.3)+vec3(0.,0.,0.3))-1.;\n  bod /= 3.;\n  float hed = length(p-vec3(0.,1.,0.)) -0.2;\n  float flutter = min(min(wing(p/3.),bod),hed);\n  return flutter;\n}\n\nfloat flh = 3.5;\nfloat twgl = 100.;\n\nfloat twimst(vec3 p) {\n  p.yz *= rot(iTime+p.x/10.);\n  \n  float twgls = max(abs(p.y)-0.4,abs(p.z)-0.4);\n  twgl = min(twgl,twgls);\n  return twgls;\n}\n\nfloat flugl = 100.;\n\nfloat map(vec3 p) {\n\n  float flut = flutter(p);\n  flugl = min(flugl,flut);\n  float flo = p.y+flh;\n  \n  float muun = length(p - vec3(19.,12.,25.))-1.;\n  \n  float twi=twimst(p-vec3(0.,0.,20.));\n  \n  return min(min(min(flut, flo), muun),twi);\n}\n\n\n\nvec3 skydome(vec3 rd) {\n  return vec3(vec2(-rd.y),rd.y);\n}\n\nvec3 gn(vec3 p) {\n  vec2 e=vec2(0.001,0);\n  return normalize(map(p) - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx)));\n}\n\nvec3 wh = vec3(1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro=vec3(0,0,-8), rd=normalize(vec3(uv,1));\n  \n  rd.x += max(0.,sin(uv.y*4.))*0.003;\n  rd.y += max(0.,cos(uv.x*4.))*0.003;\n  \n  float d,t=0.;\n  \n  for(int i=0; i < 1000; ++i ) {\n    d = map(ro+rd*t);\n    t+=d;\n    if (d < 0.01) {\n      vec3 p = ro + rd * t;\n        \n      if (p.y > 0.3-flh)\n        break;\n      else {\n        wh = vec3(0.5,0.5,1);\n        vec3 n = gn(p);\n        n.x += sin(iTime*4.+30.*p.z)/50.;\n        n.y += cos(iTime*4.+30.*p.z)/50.;\n        rd = reflect(rd,n);\n        ro = p;\n        t = 0.2;\n      }\n    }\n  }\n  \n  \n  vec3 col = skydome(rd);\n  \n  vec3 ld = normalize(vec3(3,4,-10));\n  \n  vec3 p = ro + rd * t;\n  \n  if (d < 0.01) {\n    vec3 n = gn(ro+rd*t);\n    if (p.y > 3.) {\n      col = vec3(1.);\n    } else {\n      if (p.z > 3.) {\n        col = vec3(0,0.4,0);\n      } else {\n        col = vec3(0.3,0,0);\n      }\n      col += pow(max(dot(reflect(-ld,n),rd),0.),30.);\n      col += dot(n,ld);\n    }\n  } else {\n    \n    col += vec3(0.3,0.3,0.)* 0.1/pow(twgl,2.);\n    col += vec3(0.6,0.,0.4)* 0.1/flugl;\n }\n  \n  col *= wh;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 69], [71, 71, 93, 93, 154], [156, 156, 176, 176, 271], [274, 274, 297, 297, 605], [644, 644, 666, 666, 791], [814, 814, 833, 833, 1055], [1059, 1059, 1082, 1082, 1117], [1119, 1119, 1136, 1136, 1239], [1261, 1261, 1318, 1369, 2577]], "test": "untested"}
{"id": "csB3Dw", "name": "Inercia 2022 - Shader royal", "author": "z0rg", "description": "My participation to the inercia shader royale =D", "tags": ["specular", "glossy", "demoparty", "dnb", "inercia", "royale"], "likes": 14, "viewed": 363, "published": 3, "date": "1667657228", "time_retrieved": "2024-07-30T16:22:00.212357", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\nfloat rand()\n{\n  return hash11(_seed++);\n}\n#define sat(a) clamp(a, 0., 1.)\n#define FFT(a) (texture(iChannel3, vec2(a, 0.)).x*4.)\nvec3 getCam(vec2 uv, vec3 rd)\n{\n  vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+(r*uv.x+u*uv.y)*1.);\n}\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\nmat2 r2d(float a)\n{\n  float c=cos(a),s=sin(a);\n  return mat2(c,-s,s,c);\n}\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(100000., -1.);\n  \n  vec3 op = p;\n  vec3 rep = vec3(15.);\n  //p = mod(p+rep*.5,rep)-rep*.5;\n  acc = _min(acc, vec2(length(p)-1., 0.));\n  for (int i = 0; i < 8; i++)\n  {\n    vec3 p2 = p;\n    \n    p2 = abs(p2)-vec3(1.2,0.,0.);\n    p2.xy *= r2d(-iTime*.5+float(i));\n    p2+= (float(i)-8.)*1.5;\n    p2 = abs(p2);\n    p2.xy *= r2d(iTime+float(i));\n    p2.yz *= r2d(iTime*.8+float(i));\n    float sz = mix(.2,1., float(i)/8.);\n    float cube = _cube(p2, vec3(sz, sz, 2.));\n    //cube = mix(cube, length(p2)-sz, sin(float(i)+fGlobalTime));\n    acc = _min(acc, vec2(cube, 0.));\n  }\n  \n  float box = -_cube(op, vec3(19.));\n  acc = _min(acc, vec2(box, 2.));\n  \n  acc = _min(acc, vec2(-p.y+1., 1.));\n  \n\n  return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01, 0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accCol = vec3(0.);\n    vec3 p = ro;\n  for (int i = 0; i < steps && distance(p, ro) < 50.;++i)\n  {\n    vec2 res = map(p);\n      if (res.x < 0.01)\n        return vec3(res.x, distance(p, ro), res.y);\n      p+=rd*res.x*.5;\n      vec3 rgb = vec3(.2,.4,.8);\n      rgb = mix(rgb, rgb.zxy, sin(length(p)-iTime));\n      if (res.y < 1.)\n        accCol += rgb*(1.-sat(res.x/.5))*.2*sat(sin(p.y*20.))*.85;\n    }\n    return vec3(-1.);\n}\nvec3 getmat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n  vec3 col = vec3(0.);//n*.5+.5;\n  if (res.z == 1.)\n    col = vec3(0.);\n  if (res.z == 0.)\n    col = vec3(.0);\n  \n  if (res.z == 0.)\n  {\n    col += vec3(1.,0.4,0.2)*sat(sin(p.z*10.)*sin(p.y*10.)*100.);\n  }\n  if (p.y < -8.)\n  {\n    float beat = 1./8.;\n    float flicker = mod(iTime, beat)/beat;\n    float flick = mix(1.,flicker, sat(sin(iTime*.5)));\n    col = vec3(1.)*sat((sin(p.z*2.)-.5)*100.)*3.*flick;\n  }\n  return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  float stpt = 1.;\n  float stptime = floor(iTime/stpt)*stpt;\n  uv *= r2d(sin(hash11(stptime)));\n    float t = iTime;\n  float d = 18.;\n  float zbeat = 1./2.;\n  float zz = mod(iTime, zbeat)/zbeat;\n  vec2 off = (vec2(rand(), rand())-.5)*.1;\n  vec3 ro = vec3(sin(t*.3)*d+off.x,-3.+off.y,-5.+zz);\n  vec3 ta = vec3(0.);\n  vec3 rd = normalize(ta-ro);\n  rd = getCam(uv, rd);\n  \n  vec3 res = trace(ro, rd, 64);\n  float depth = 100.;\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = vec3(.2,.4,.9);\n    col = getmat(p,n,rd,res);\n    \n    vec3 refl = reflect(rd, n);\n    float spec = texture(iChannel2, p.xz).x;\n    refl = normalize(refl+(vec3(rand(), rand(), rand())-.5)*.1*spec);\n    vec3 resrefl = trace(p+n*0.01,refl, 32);\n    if (resrefl.y > 0.)\n    {\n      vec3 prefl = p+refl*resrefl.y;\n      vec3 nrefl = getNorm(prefl, resrefl.x);\n      col += getmat(prefl, nrefl, refl, resrefl);\n    }\n  }\n  col += accCol;\n  col = mix(col, vec3(.2,.4,.8)*.5, 1.-exp(-depth*0.02));  \n  \n  \n  vec2 rep = vec2(.5);\n  uv = mod(uv+rep*.5, rep)-rep*.5;\n    float shape = length(uv)-.02*FFT(uv.x*.1);\n  col += vec3(.89,.2,.3)*(1.-sat(shape*400.));\n\n  \n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 ouv = fragCoord.xy/iResolution.xy;\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  _seed = iTime+texture(iChannel1, uv*10.).x;\n  if (sin(iTime*.5) < 0.)\n  {\n  uv *= r2d(iTime*.5);\n    uv = abs(uv);\n  }\n    vec3 col = rdr(uv);\n  col += rdr(uv+col.xy*.1+(vec2(rand(), rand())-.5)*.05)*.5;\n  col = mix(col, texture(iChannel0, ouv).xyz,.15);\n  //col = mix(col, col.yxz, sat(length(uv)));\n  col = sat(col);\n  col = pow(col, vec3(1.));\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30085, "src": "https://soundcloud.com/marius-smaidris/styles-of-beyond-subculture-upbeats-remix?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3Dw.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 576]], "test": "untested"}
{"id": "DdB3Dw", "name": "Glowing gnarly apollonian II", "author": "mrange", "description": "Glowing gnarly apollonian II\nThe glow coloring of Fractal doodling: https://www.shadertoy.com/view/ds2GRW\ninspired me to revisit an old shader of mine and spice it up", "tags": ["glow"], "likes": 27, "viewed": 468, "published": 3, "date": "1667657141", "time_retrieved": "2024-07-30T16:22:01.208693", "image_code": "// CC0: Glowing gnarly apollonian II\n// The glow coloring of Fractal doodling: https://www.shadertoy.com/view/ds2GRW\n//  inspired me to revisit an old shader of mine and spice it up\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define NORM_OFF    0.001\n#define MIN_DIST    0.00025\n#define MAX_DIST    10.0\n#define MAX_ITER    90\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2))*2.0 - vec2(1.0);\n  return c;\n}\n\nfloat apollonian(vec3 p, out float ss) {\n  float s = mix(1.4, 1.45, smoothstep(0.9, 1.0, sin(-length(p.xz)+TAU*TIME/10.0))); \n  float scale = 1.5;\n\n  float d = 10000.0;\n    \n  const int rep = 5;\n  mat2 rr = ROT(PI/5.5);\n\n  for(int i=0; i<rep; ++i) {\n    mod1(p.y, 2.0);\n    modMirror2(p.xz, vec2(2.0));\n    p.xz *= rr;\n\n    float r2 = dot(p,p);\n    float k = s/r2;\n    p *= k;\n    scale *= k;\n  }\n  \n  d = -sphere(p-0.025, 1.8);\n  ss = scale;\n  return 0.25*d/scale;\n}\n\nfloat df(vec3 p, out float ss) {\n  float d0 = apollonian(p, ss);\n  float d1 = -((abs(p.y)-2.0));\n  float d = d0;\n  d = pmin(d, d1, 0.2);\n  \n  return d; \n} \n\nvec3 glow(vec3 ro, vec3 rd, out float tt) {\n  float res;\n  float t = 0.+0.8;\n\n  vec3 col = vec3(0.0);    \n  for(int i = 0; i < MAX_ITER; ++i) {\n    vec3 p = ro + rd * t;\n    float ss;\n    res = df(p, ss);\n    float lss = log(ss);\n    float dp = -((abs(p.y)-2.0)); \n    vec3 gcol = mix(0.2, 0.6, dp)*((0.5+0.5*cos(3.0+vec3(1.0, 2.0, 3.0)+0.8*lss))*exp(-0.75*t-20.0*res));\n    col += gcol*gcol;\n    if(res < MIN_DIST * t || res > MAX_DIST) {\n      break;\n    }\n    t += res;\n  }\n  \n  tt = t;\n    \n  return col;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  float ss;\n  nor.x = df(pos+eps.xyy, ss) - df(pos-eps.xyy, ss);\n  nor.y = df(pos+eps.yxy, ss) - df(pos-eps.yxy, ss);\n  nor.z = df(pos+eps.yyx, ss) - df(pos-eps.yyx, ss);\n  return normalize(nor);\n}\n\nvec3 render(vec2 p) {\n  vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\n  mat2 rot= ROT(TIME/10.0); \n  vec3 ro = 1.2*vec3(-1.0, -0.05, -0.0);\n  lightDir.xz *= rot;\n  ro.xz  *= rot;\n  vec3 la = vec3(0.0, 1.6, 0.0); \n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  float tt = 0.0;\n  vec3 col = vec3(0.0);\n  vec3 gcol = glow(ro, rd, tt);\n  vec3 pos = ro+rd*tt;\n  vec3 nor = normal(pos);\n  vec3 ref = reflect(rd, nor);\n \n  float spe   = pow(max(dot(lightDir, ref), 0.0), 40.0);\n \n  float sfog = exp(-2.0*0.5*tt);\n  const vec3 scol = vec3(4.0, 3.5, 3.0);\n  col += gcol;\n  col += spe*sfog*scol;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q; \n  p.x*=RESOLUTION.x/RESOLUTION.y;\n \n  vec3 col = render(p);\n  col -= 0.0125*vec3(2.0, 3.0, 1.0);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdB3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 564, 603, 603, 688], [690, 690, 721, 721, 747], [749, 835, 874, 874, 999], [1001, 1087, 1129, 1129, 1291], [1293, 1293, 1333, 1333, 1760], [1762, 1762, 1794, 1794, 1916], [1919, 1919, 1962, 1962, 2429], [2431, 2431, 2454, 2454, 2698], [2700, 2700, 2721, 2721, 3457], [3459, 3459, 3516, 3516, 3770]], "test": "untested"}
{"id": "ms23DD", "name": "TestAndiMouse", "author": "CodeJUN", "description": "交互性的shader", "tags": [], "likes": 1, "viewed": 263, "published": 3, "date": "1667643969", "time_retrieved": "2024-07-30T16:22:02.308753", "image_code": "#define r .5+.2*sin(iTime)//运动\n\nvec2 fixUV(in vec2 c)//重置UV\n{\n    return (2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n}\n\n\n\n\nfloat sdfCircle(in vec2 p)\n{\n    return length(p)-r;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fixUV(fragCoord);\n    float d=sdfCircle(uv);\n\n    vec3 color=abs(1.-sign(d)*vec3(.2,.33,.46));\n    color *=1.-exp(-3.*abs(d)); \n    color*=.8+.2*sin(100.*abs(d));\n    color =mix(color,vec3(1.), smoothstep(.005,.004,abs(d)));\n    \n    if(iMouse.z>0.)//鼠标控制\n    {\n    vec2 m=fixUV(iMouse.xy);\n    // float currentDistance=sdfCircle(m,.7);\n    float currentDistance=abs(sdfCircle(m));\n    // color=mix(color,vec3(1.,1.,0.),  length(uv-m));\n    //color=mix(color,vec3(1.,1.,0.), smoothstep(currentDistance,currentDistance-0.01, abs( length(uv-m)-currentDistance)));\n    color=mix(color,vec3(1.,1.,0.), smoothstep(0.01,0., abs( length(uv-m)-currentDistance)));\n\n    color=mix(color,vec3(0.),smoothstep(0.02,.0,length(uv-m)));\n    }\n\n\n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 69, 69, 138], [143, 143, 171, 171, 197], [200, 200, 254, 254, 1035]], "test": "untested"}
{"id": "md2GDD", "name": "Inercia Royaliptic", "author": "leon", "description": "Bouncing for the Inercia Shader Royale 2022", "tags": ["inercia"], "likes": 103, "viewed": 2196, "published": 3, "date": "1667643719", "time_retrieved": "2024-07-30T16:22:03.069717", "image_code": "\n// Some bouncing made for Inercia Shader Royale 2022\n// https://2022.inercia.pt/\n// music by Diffty https://soundcloud.com/diffty\n\n// globals\nfloat fft, material, rnd;\n\n// toolbox\n#define time iTime\n#define ss(a,b,t) smoothstep(a,b,t)\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat gyroid (vec3 p) { return dot(sin(p), cos(p.yzx)); }\nfloat random (vec2 p) { return fract(sin(dot(p,vec2(10.1324,5.654)))*46501.654); } \nfloat fbm (vec3 p) {\n  float result = 0., a = .5;\n  for (float i = 0.; i < 3.; ++i) {\n    result += abs(gyroid(p/a)*a);\n    a /= 2.;\n  }\n  return result;\n}\nfloat box (vec3 p, vec3 s) {\n  vec3 b = abs(p)-s;\n  return max(b.x,max(b.y,b.z));\n}\n\nfloat map(vec3 p)\n{\n  float dist = 100.;\n  \n  // rotation angle\n  float t = time*1.+p.z*.5;\n  t = pow(fract(t), 10.) + floor(t);\n  t += rnd;\n  \n  // translate offset\n  float tt = time + p.z;\n  tt = pow(fract(tt), 10.) + floor(tt);\n  float r = .0*fft+.2+.1*sin(length(p)*3.-tt+p.z*5.);\n  \n  // kaleido\n  float a = 1.;\n  const float count = 12.;\n  for (float i = 0.; i < count; ++i) {\n    p.xz *= rot(t/a);\n    p.yz *= rot(sin(t)/a);\n    p.x = abs(p.x)-r*a;\n    float shape = length(p)-.1*a;\n    //if (mod(i, 2.) < .5) shape = box(p,vec3(1,1,.01)*.15*a);\n    material = shape < dist ? i : material;\n    dist = min(dist, shape);\n    a /= 1.2;\n  }\n  \n  // extra details surface\n  float noise = fbm(p*60.);\n  dist -= noise*.002;\n  \n  return dist*.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 pos = vec3(0,0,2);\n    vec3 ray = normalize(vec3(uv, -3));\n    \n    // noise\n    float rng = random(uv);\n    vec2 jitter = vec2(random(uv+.196),random(uv+4.1));\n    \n    // audio\n    fft = texture(iChannel0, vec2(0.)).r;\n    fft = pow(fft, .8);\n    float aa = abs(atan(uv.y, uv.x))/10.+fft*3.;\n    float lod = 100.;\n    aa = floor(aa*lod)/lod;\n    float fft2 = texture(iChannel0, vec2(fract(aa),0)).r;\n    \n    // timeline random (used in map to add extra rotation)\n    float t = time*2.;\n    float index = floor(t);\n    float anim = fract(t);\n    rnd = mix(random(vec2(index)), random(vec2(index+1.)), anim);\n    \n    // blur edge\n    float luv = length(uv);\n    ray.xy += jitter * smoothstep(.5, 2., luv)*.1;\n    \n    // glitch blur\n    vec2 llod = 10.*vec2(random(vec2(floor(time*4.+.5))), random(vec2(floor(time*2.))));\n    float blur = random(floor(uv*llod)+floor(time*4.));\n    ray.xy += jitter*step(.95, blur)*.1;\n    \n    // raymarch\n    const float count = 100.;\n    float shade = 0.;\n    float total = 0.;\n    for (float index = count; index > 0.; --index) {\n        float dist = map(pos);\n        if (dist < .0001 * total || total > 10.) {\n            shade = index/count;\n            break;\n        }\n        // blur in distance\n        ray.xy += jitter*total*.0005;\n        dist *= .9+.1*rng;\n        total += dist;\n        pos += ray * dist;\n    }\n    \n    // background\n    vec3 color = vec3(0);\n    color += ss(4.,.5, luv)*.5;\n    \n    // circle fft\n    luv = length(uv);\n    color += ss(.01,.0,abs(abs(luv-fft))-fft2*.2);\n    \n    // shading\n    if (total < 10. && shade > .0) {\n        color = vec3(0.2);\n        vec2 unit = vec2(.001,0);\n        vec3 normal = normalize(vec3(map(pos+unit.xyy)-map(pos-unit.xyy), map(pos+unit.yxy)-map(pos-unit.yxy), map(pos+unit.yyx)-map(pos-unit.yyx)));\n        vec3 rf = reflect(ray, normal);\n        color += .5+.5*cos(vec3(1,2,3)*5.+pos.z+blur);\n        color *= mod(material, 2.);\n        color += pow(dot(ray, normal)*.5+.5, 1.) * 2.;\n        color += pow(dot(rf, vec3(0,1,0))*.5+.5, 10.);\n        color *= shade;\n    }\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 30082, "src": "https://soundcloud.com/diffty/dj-set-dnb-footwork-eclipse-sur-la-canopee-2017-06-03", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2GDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 255, 255, 305], [306, 306, 329, 329, 363], [364, 364, 387, 387, 446], [448, 448, 468, 468, 603], [604, 604, 632, 632, 687], [689, 689, 708, 708, 1435], [1437, 1437, 1494, 1513, 3701]], "test": "untested"}
{"id": "dd23WD", "name": "Mandelbrot set & iteration path", "author": "quantum_rose", "description": "Use the mouse to change the iteration path.", "tags": ["mandelbrotset"], "likes": 2, "viewed": 149, "published": 3, "date": "1667638741", "time_retrieved": "2024-07-30T16:22:03.827690", "image_code": "#define ITERATIONS 256\n\nvec2 f(vec2 z, vec2 c) {\n    return mat2(z, -z.y, z.x) * z + c;\n}\n\nfloat getScale() {\n    return (0.25 * min(iResolution.x, iResolution.y)) / iResolution.x;\n\n}\n\nfloat line(vec2 st, vec2 start, vec2 end, float strokeWidth, float pixelSize) {\n    vec2 a = end - start;\n    vec2 b = st - start;\n    float t = clamp(dot(a, b) / dot(a, a), 0.0, 1.0);\n    float d = length(st - start - a * t);\n    return smoothstep(d - pixelSize, d + pixelSize, strokeWidth * 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = getScale();\n    float pixelSize = 1.0 / iResolution.x / scale;\n    vec2 st = fragCoord.xy / iResolution.x;\n    vec2 center = vec2(0.5, iResolution.y / iResolution.x * 0.5);\n    vec2 p = (st - center) / scale;\n    vec3 color = vec3(0.0);\n    vec2 c, z;\n\n    c = p;\n    z = vec2(0.0);\n    bool escaped = false;\n    int j;\n    for (int i = 0; i < ITERATIONS; i++) {\n        z = f(z, c);\n        if (length(z) > 2.0) {\n            escaped = true;\n            j = i;\n            break;\n        }\n    }\n    float depth = float(j) / float(ITERATIONS);\n    color = escaped ? vec3(pow(depth, 0.5)) : vec3(1.0);\n\n    vec3 strokeColor = vec3(1.0, 0.0, 0.0);\n    if (iMouse.x == 0.0 && iMouse.y == 0.0) {\n        c = vec2(0.035, 0.068) / scale;\n    } else {\n        c = ((iMouse.xy / iResolution.x) - center) / scale;\n    }\n    z = vec2(0.0);\n    for (int i = 0; i < ITERATIONS; i++) {\n        vec2 newZ = f(z, c);\n        color = mix(color, strokeColor, line(p, z, newZ, pixelSize, pixelSize));\n        z = newZ;\n        if (length(z) > 2.0) {\n            break;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd23WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 48, 48, 89], [91, 91, 109, 109, 183], [185, 185, 264, 264, 485], [487, 487, 542, 542, 1665]], "test": "untested"}
{"id": "mdj3DW", "name": "Inercia Shader Royale 2022", "author": "kostik1337", "description": "My result at the end. This version differs from the original, had to remove some parts (apparently I did too much backbuffer fuckery)", "tags": ["glitch", "livecoding"], "likes": 21, "viewed": 347, "published": 3, "date": "1667634714", "time_retrieved": "2024-07-30T16:22:04.718309", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define time iTime\nconst float BPM = 120.;\n#define beat (time*BPM/60.)\n\nvec3 ct(vec3 p) {\n  if(p.x<p.y) p.xy=p.yx;\n  if(p.y<p.z) p.yz=p.zy;\n  if(p.x<p.y) p.xy=p.yx;\n  return p;\n}\n\n#define mr(t) (mat2(cos(t), sin(t), -sin(t), cos(t)))\n#define quant(p,x) (floor(p/x)*x)\n#define rep(p,s) (mod(p,(s))-(s)/2.)\n#define rep2(p,s) (abs(rep(p,(2.*s)))-(s)/2.)\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define INF (1e10)\n\nfloat hash(float x) {return fract(sin(x*325.88913));}\n\nvec4 back(vec2 uv) {return texture(iChannel0, uv);}\nfloat ffti(float t) {return iTime * (1./(t+1.));}\n\nvec3 glow = vec3(0.);\n\nfloat box(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return max(p.x, max(p.y, p.z));\n}\n\nvec3 calcglow(float m) {\n  return .003*vec3(1.,1.2,1.4) / abs(m-.05*vec3(1.3, 1.2, .9));\n}\n\nfloat mycube(vec3 p) {\n  vec3 p2 = p;\n  float m = INF;\n  vec3 s = vec3(.2 + .02*smoothstep(.6, 1., fract(beat)));\n  float gi = floor(4.*fract(beat));\n  for(float i=0.;i<4.;++i) {\n    s.xz *= mr(2.31*floor(beat));\n    s.yz *= mr(1.19*floor(beat));\n    s = abs(s)/1.5;\n    if(i==2.) p.xz *= mr(PI/4.);\n    p = abs(p)-s;\n    p=ct(p);\n    vec3 p1 = p;\n    float qf = fract(beat + hash(dot(vec3(.12,.34,.32),quant(p2, .1))));\n    p1 = quant(p1, mix(.001, .05, qf));\n    float mm = length(p1.xy)-s.x/64.;\n    m = min(m, mm);\n    if (i==gi) glow += calcglow(mm);\n  }\n  return m;\n}\n\nfloat map(vec3 op) {\n  vec3 p=op;\n  p.xy *= mr(time);\n  p.xz *= mr(floor(beat) + smoothstep(0., .5, fract(beat)));\n  p.yz *= mr(1.12* (floor(beat) + smoothstep(0., .5, fract(beat))));\n  p.xz *= mr(ffti(.13)*4.);\n  float m;\n  float h = hash(floor(beat));\n  if(h < .1) {\n    p = abs(p);\n    m = dot(p, normalize(vec3(1.)))-.3;\n    glow += calcglow(m);\n  } else if(h < .2) {\n    m = box(p, vec3(.3));\n    glow += calcglow(m);\n  } else if(h < .3) {\n    p = abs(p)-.2;\n    p = abs(p)-.1;\n    m = length(p)-.05;\n    glow += calcglow(m);\n  } else if(h < .4) {\n    p = ct(abs(p));\n    m = box(p, vec3(.01, .01, .5).zxy);\n    glow += calcglow(m);\n  } else {\n    m = mycube(p);\n  }\n  vec3 s;\n  \n  p = op;\n  p.z += 8.*ffti(.2);\n  s = vec3(12.2);\n  float maxx = -box(op, vec3(2.,1., INF));\n  for(float i = 0.;i<4.;++i) {\n    float t = i==1.? .01*(floor(beat) + smoothstep(0., .3, beat)) : 0.;\n    s.xy *= mr(.12+t);\n    s.yz *= mr(.23+t);\n    s = abs(s)/2.;\n    p = rep2(p, s);\n    p = ct(p);\n    vec3 pp = p;\n    pp = quant(pp, mix(.001, .05, fract(beat+.5)));\n    float mm = length(pp.yz)-s.x/128.;\n    mm = max(mm, maxx);\n    m = min(m, mm/1.3);\n    glow += .0005 * (sin(4.*op.z-1.3*time)*.5+.5) / abs(mm-.01*vec3(1.,1.4,1.2));\n  }\n  \n  return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 c = vec3(0.);\n  vec3 O = vec3(0., 0., -2.), D = vec3(uv, 1.);\n  \n  mat2 m = mr(.1*sin(time) + .07*sin(1.1*time));\n  O.xz *= m;\n  D.xz *= m;\n  m = mr(.08*sin(1.2*time) + .06*sin(1.3*time));\n  O.xz *= m;\n  D.xz *= m;\n  O.z -= .5+.5*sin(PI/16.*beat);\n  \n  D.xy *= mr(PI/4.*smoothstep(.0, .1, fract(beat/4.)));\n  \n  float d = 0.;\n  float hit = 0.;\n  for(float i=0.;i<64.;++i) {\n    vec3 p=O+D*d;\n    float m = map(p);\n    d += m;\n    if(m < .01*d) {\n      c += (1.-i/64.)*.1 * exp(-d*.5);\n      float thresh = mix(10., 64., fract(beat/4.));\n      hit = i > thresh ? 1. : 0.;\n      break;\n    }\n  }\n  glow *= exp(-d*.2);\n  c += glow;\n  \n  uv = fragCoord/iResolution.xy;\n  float gg = 1.;\n  if (fract(beat) < .05) {\n    uv = quant(uv, .05);\n    gg = 1.2;\n  }\n  vec4 prev = back(uv);\n  vec2 e = vec2(.01, .0);\n  e *= 8. * smoothstep(.9, 1., fract(beat/4.));\n  e *= mr(floor(beat));\n  e *= hash(quant(uv.y, .05))-.5;\n  prev = vec4(\n    back(uv-e).r,\n    back(uv).g,\n    back(uv+e).b,\n    prev.a\n  )*gg;\n  prev = clamp(vec4(0.),vec4(1.), prev);\n  float mf = mix(.6, .8, prev.a);\n  \n  c = mix(c, prev.rgb, mf);\n  c *= 1.-hit;\n\n\tfragColor = vec4(c, glow);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdj3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "ms23WW", "name": "Find Edges Directionally 2", "author": "MysteryPancake", "description": "Same as the original but without the additional weight.", "tags": ["edge", "cellular", "cell", "kernel", "findedges", "direction"], "likes": 1, "viewed": 155, "published": 3, "date": "1667629892", "time_retrieved": "2024-07-30T16:22:05.610923", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 texSize = vec2(textureSize(iChannel1, 0));\n\tfragColor = texelFetch(iChannel0, ivec2(fragCoord / iResolution.xy * texSize), 0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n\t// Brightest neighbour and direction toward it\n\tvec4 brightest = vec4(0.0);\n\tvec2 direction = vec2(0.0);\n\n\t// Sample in a 3 x 3 kernel\n\tfor (int x = -1; x <= 1; ++x) {\n\t\tfor (int y = -1; y <= 1; ++y) {\n\n\t\t\t// Ignore self\n\t\t\tif (x == 0 && y == 0) continue;\n\t\t\t\n\t\t\t// Sample neighbour\n\t\t\tvec2 pos = vec2(x, y);\n\t\t\tvec4 neighbour = texelFetch(iChannel0, ivec2(fragCoord + pos), 0);\n\t\t\t\n\t\t\t// Store neighbour with maximum brightness\n\t\t\tif (length(neighbour) > length(brightest)) {\n\t\t\t\tbrightest = neighbour;\n\t\t\t\tdirection = pos;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Colorize (direction range is -1 to 1)\n\tfragColor = vec4(direction.xy, -direction.xy);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 190]], "test": "untested"}
{"id": "mdj3WW", "name": "JackOLantern", "author": "wyatt", "description": "Sound shader", "tags": ["sound"], "likes": 17, "viewed": 260, "published": 3, "date": "1667625602", "time_retrieved": "2024-07-30T16:22:06.578336", "image_code": "Main {\n    float w = A(U).w;\n    Q = w*sin(-.5+2.*w+vec4(1,2,3,4));\n    if (SDF ((U-.5*R)/R.y)<0.) {\n        Q *= 0.;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi2 6.28318530718\n#define e(t,a,b) exp((t)*(a))*vec2(sin(pi2*(b)*(t)),sin(pi2*(b)*(t))) \nvec2 mainSound( int samp, float time )\n{\n    #define MEASURE (3. + sin(.1*time))\n    time += 10.*MEASURE;\n    vec2 o = vec2(0);\n    for (float i = 0.; i < 4.; i++) {\n        vec4 h1 = hash41(floor(time/MEASURE));\n        float t = mod(time,MEASURE);\n        o += .25*e(t+e(t,-1.,100.*h1.x).x/(100.*h1.x),-1.,440.*h1.y)*exp(-2.*h1.y);\n        time += MEASURE/4.;\n    }\n    return o;\n}", "sound_inputs": [], "common_code": "vec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat tri ( vec2 p, float h ) {\n  vec2 q = abs(p);\n  return max(q.x*0.866025+p.y*0.5,-p.y)-h*0.5;\n}\nfloat SDF (vec2 p) {\n    float d = tri(p,.1);\n    \n    d = min(d,tri((p-vec2(-.25,.25))*vec2(1,-1),.1));\n    d = min(d,tri((p-vec2(+.25,.25))*vec2(1,-1),.1));\n    \n    d = min(d,\n        max(\n            max(\n                max(\n                    length(p-vec2(0,0.))-.4,\n                    .2+p.y\n                ),\n                -tri((p-vec2(.15,-.2))*vec2(1,-1),.1)\n            ),\n            -tri((p-vec2(-.15,-.2))*vec2(1,-1),.1)\n        )\n    );\n    \n    return d;\n}", "buffer_a_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q.xy -= 0.25*vec2(e.z-w.z,n.z-s.z);\n    Q.y += 1./R.y*Q.w;\n    \n    if (SDF ((U-.5*R)/R.y)<0.) {\n        Q.w = 1.;\n        Q.xy *= 0.;\n    }\n    if (iFrame < 1) Q = vec4(0,.5,0,0);\n    if (U.y<1.) Q.y *= 0.;\n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.) Q.w *= 0.;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q.z -= 0.25*(e.x-w.x+n.y-s.y);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    Q = A(U);\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdj3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dd2GWW", "name": "moment_2", "author": "danzabarr", "description": "number 2", "tags": ["trippy", "hyperbolic"], "likes": 7, "viewed": 192, "published": 3, "date": "1667621098", "time_retrieved": "2024-07-30T16:22:07.386177", "image_code": "\nvec4 checkerboard(vec2 coord, vec2 scale)\n{\n\n    coord *= scale;\n    \n    vec2 floored = round(coord);\n    \n    float d = distance(coord, floored);\n    \n    vec4 color = vec4(.5, 1, .4, 1);\n    \n    if (mod(floored.x, 2.0) == mod(floored.y, 2.0))\n        color = vec4(.4, .6, .1, 1);\n    \n    \n    if (d > 0.5)\n        return vec4(1, 1, 1, 1) / (d * 10.0);\n    else\n        return (1.0 - color * d * d * 4.0);\n\n}\n\nvec2 convert(vec2 coord)\n{\n\n    float d = length(coord);\n    float a = atan(coord.y, coord.x);\n    //a += pow(d, 1.0 + iTime * sin(iTime / 100.0));\n\n    float cosa = cos(a);\n    float sina = sin(a);\n\n\n    vec2 converted = vec2(cosa + (sina * cos(iTime)), sina + (cosa * sin(iTime))) / (d / iTime);\n    converted = coord * d + converted * (1.0 - d);\n    \n    vec2 other = coord / (d * iTime);\n\n\n    return converted * d + other * (1.0 - d);\n    \n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    fragColor = checkerboard(convert(uv), vec2(1, 1) / (1.0 + sin(iTime / 100.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2GWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 44, 44, 413], [415, 415, 441, 441, 862], [867, 867, 924, 924, 1124]], "test": "untested"}
{"id": "mdBGDD", "name": "life moves pretty fast.", "author": "numbers__", "description": "if you don't stop and look around once in a while, you could miss it.", "tags": ["raymarch", "metaballs", "bleh", "smoothunion"], "likes": 2, "viewed": 165, "published": 3, "date": "1667612163", "time_retrieved": "2024-07-30T16:22:08.486236", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.01\n#define BLEND_UNITS 1.6667\n\n//smooth union function (thank you, inigo!)\nfloat opSmoothUnion (float d1, float d2, float k ) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0., 1.);\n    return mix( d2, d1, h ) - k*h*(1.-h);\n}\n\n//sdfs\nfloat GetDist(vec3 p) {\n    vec4 s1 = vec4(0, 1, 5, 1);\n    vec4 s2 = vec4(.25 * tan(iTime), 2, 5, 1);\n    vec4 s3 = vec4(0, 2, cos(iTime) + 5., 1);\n    \n    float sphereDist1 = length(p-s1.xyz)-s1.w;\n    float sphereDist2 = length(p-s2.xyz)-s2.w;\n    float sphereDist3 = length(p-s3.xyz)-s3.w;\n    float sphereDist = opSmoothUnion(\n        sphereDist1, sphereDist2, BLEND_UNITS\n    );\n    sphereDist = opSmoothUnion(\n        sphereDist, sphereDist3, BLEND_UNITS\n    );\n    \n    float planeDist = opSmoothUnion(sphereDist, p.y, BLEND_UNITS);\n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\n//raymarcher\nfloat RayMarch (vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i=0; i<MAX_STEPS; ++i) {\n        vec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\n//normals\nvec3 Normalfy (vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    //calculates normals by swizzling\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\n//phong\nfloat Phongify(vec3 p) {\n    vec3 lightPos = vec3(3, 5, -1);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = Normalfy(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zero uvs are in the middle\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(.25 * tan(iTime), 1.2, -2.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    vec3 bl = vec3(sin(iTime) * 255., cos(iTime) * 255., 0);\n    \n    float dif = Phongify(p);\n    col = vec3(dif);\n    col = mix(col, bl.yzx, 0.001);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdBGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 143, 195, 195, 289], [291, 298, 321, 321, 897], [899, 912, 947, 947, 1161], [1163, 1173, 1197, 1197, 1427], [1429, 1437, 1461, 1461, 1717], [1719, 1719, 1776, 1810, 2260]], "test": "untested"}
{"id": "csj3WD", "name": "moment_1", "author": "danzabarr", "description": "number 1", "tags": ["trippy", "hyperbolic"], "likes": 1, "viewed": 139, "published": 3, "date": "1667611884", "time_retrieved": "2024-07-30T16:22:09.357904", "image_code": "\nvec4 lerp(vec4 colorone, vec4 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\nvec4 power(vec4 color, float exponent)\n{\n    return vec4(pow(color.x, exponent), pow(color.y, exponent), pow(color.z, exponent), pow(color.w, exponent));\n}\n\nvec4 checkerboard(vec2 coord)\n{\n\n    float l = length(coord);\n\n    coord *= iTime;\n    \n    coord = floor(coord);\n\n    vec2 wrap = mod((mod(coord, 255.0) + 255.0), 255.0) / 255.0;\n\n    vec4 color = vec4(wrap.y, (wrap.x + wrap.y) / 2.0, wrap.x*.9, 1);\n    \n    if (mod(coord.x, 2.0) == mod(coord.y, 2.0))\n        color = lerp(color * color, 1.0 - color, cos(iTime / 10.0));\n\n\n    return color;//smoothstep(0.0, 1.0, lerp(color, power(color, iTime / 10.0), l / 10.0));\n}\n\nfloat PI = 3.1415926;\n\nvec2 src(vec2 dst)\n{\n    float d = length(dst);\n    float angle = atan(dst.y, dst.x);\n    //angle += d;\n    //angle += pow(d, 1.0 + iTime / 1000.0);\n    //angle += d * iTime * 0.01;\n    angle += 0.01 * d * sin(iTime / 50.0);\n    angle -= d * d * d * iTime * 0.00005 / (d * sin(iTime / 30.0) + 0.25);\n    float cos = cos(angle);\n    float sin = sin(angle);\n    \n    \n    return vec2(cos, sin) / pow(d, iTime / 100.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor = smoothstep(0.0, 1.0, checkerboard((iTime / -10.0) * src(uv * (iTime / 100.0))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csj3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 55, 55, 105], [107, 107, 147, 147, 262], [264, 264, 295, 295, 732], [757, 757, 777, 777, 1175], [1177, 1177, 1234, 1234, 1446]], "test": "untested"}
{"id": "cdSGWz", "name": "Shader Royale | First Timer", "author": "byt3_m3chanic", "description": "My First time doing a live coding comp, was pretty happy - but way amazed by everyones stuff! ", "tags": ["inercia", "shaderroyale"], "likes": 25, "viewed": 307, "published": 3, "date": "1667610470", "time_retrieved": "2024-07-30T16:22:10.184694", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Inércia Shader Royale \n    30 min - then elimination begins, lasted 3 rounds..#12\n    \n    11/4/22 | byt3_m3chanic\n\n*/\n\n#define R iResolution\n#define T iTime\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){return fract(sin(dot(a,vec2(32.232,21.232)))*2323.23);}\nfloat smp(float a){return texture(iChannel0,vec2(a,.1)).x;}\nvec3 gid,sid;\nfloat glow =0.;\nvec2 map(vec3 p, float a) {\n    vec2 res=vec2(1e5,0.);\n    vec3 o=p,i=p;\n    float k=5./dot(o,o);\n    o*=k;\n    \n    float tt = .5+.5*sin(T*.2);\n    p=mix(p,o,tt);\n    \n    p.z-=T*1.5;\n    \n    vec3 id = floor((p+1.)/2.);\n    float hs=hash21(id.xy+id.z);gid=id;\n    float ss = (smp(mod(id.z*.05,1.))*.25)+.001;\n    p=mod(p+1.,2.)-1.;\n    \n    vec2 q=vec2(length(p.xy)-.5,p.z);\n    float d = length(q)-ss;\n    \n    vec3 w=p;\n    \n    float dt = length(abs(w.xy)-.5)-.075;\n    dt=min(length(abs(w.xz)-.5)-.075,dt);\n    dt=min(length(abs(w.yz)-.5)-.075,dt);\n    \n    float tm = .75+.25*cos(T*.2);\n    dt=mix(1.,dt,tm);\n    if(dt<res.x) res=vec2(dt,1.);\n    if(d<res.x) res=vec2(d,1.);\n\n    bool check=id.x==0.&&id.y==0.;\n    float l = length(p)-.05;\n    if(l<res.x&&hs>.6&&!check) res=vec2(l,1.);\n    if(a==1.&&hs>.6&&!check) glow += .002/(.0165+l*l);\n    \n    float sx = .75+.5*sin(T*.33);\n    float sp =length(i)-(.5+sx);\n    if(sp<res.x) res=vec2(sp,1.);\n    \n    float ml= 1./k;\n    res.x=mix(res.x,res.x*(ml/1.),tt);\n    return res;\n}\n\nvec3 normal(vec3 p, float t){\n    vec2 e=vec2(t*1e-3,0.);\n    float d = map(p,0.).x;\n    vec3 n=d-vec3(\n    map(p-e.xyy,0.).x,\n    map(p-e.yxy,0.).x,\n    map(p-e.yyx,0.).x\n    );\n    return normalize(n);\n}\n\nvec3 hue(float a){return .45+.45*sin(6.*a+vec3(1,.5,.2)*vec3(2.75,1.2,.4));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord-R.xy)/max(R.x,R.y);\n    uv*=rot(T*.4);\n    vec3 C = vec3(0),ro=vec3(0,0,5.),rd=normalize(vec3(uv,-1.));\n\n    float tt = floor(T*.4);\n    float xt= 1.015*sin(uv.x*45.+T*22.);float yt= .015*sin(uv.y*45.+T*22.);\n\n    float hs=hash21(vec2(tt,25.));\n    if(uv.x>yt&&hs>.7&&tt>12.){\n        ro.xz*=rot(30.+T*.2);\n        rd.xz*=rot(30.+T*.2);\n    }\n    \n    hs=hash21(vec2(15,tt));\n    if(uv.y>xt&&hs>.5&&tt>18.){\n        ro.yz*=rot(50.+T*.1);\n        rd.yz*=rot(50.+T*.1);\n    }\n\n    vec3 p = ro;\n    float d=0.,m=0.;\n\n    for(int i=0;i<132;i++){\n        p=ro+d*rd;\n        vec2 ray=map(p,1.);\n        m=ray.y;\n        ray.x=max(abs(ray.x),1e-4);\n        d+=abs(ray.x*.45);\n    }\n    sid=gid;\n    if(d<25.){\n        vec3 n=normal(p,d);\n        vec3 l=normalize(vec3(1,5,-5));\n        float diff=clamp(dot(n,l),0.,1.);\n        vec3 h = hue(n.x+n.y+n.z);\n\n        C+=diff*h;\n\n    }\n    float ff = .5+.5*sin(T*.5);\n    vec3 clr=mix(vec3(.1),hue(2.445+(uv.y+T)*.2),ff);\n    C=mix(C,clr,1.-exp(-.0095*d*d*d));\n    C = mix(C,vec3(glow),clamp(glow,0.,1.));\n\n    C = pow(C,vec3(.4545));\n    fragColor = vec4(C,1.0);\n}", "image_inputs": [{"id": 30077, "src": "https://soundcloud.com/ltj-bukem/twilight-cosmic-db-set-tipper-friends-spirit-of-suwannee-music-park-19th-may-2017", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGWz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[265, 265, 283, 283, 326], [327, 327, 348, 348, 403], [404, 404, 423, 423, 463], [494, 494, 521, 521, 1530], [1532, 1532, 1561, 1561, 1737], [1739, 1739, 1757, 1757, 1815], [1816, 1816, 1873, 1873, 3007]], "test": "untested"}
{"id": "DsjGWD", "name": "Acrid Ball of Fun", "author": "blackle", "description": "inercia 2022 shader royale", "tags": ["livecode", "shaderroyale"], "likes": 35, "viewed": 486, "published": 3, "date": "1667609966", "time_retrieved": "2024-07-30T16:22:10.941670", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat sh1,sh2,sh3;\nfloat time ;\n\nfloat fac(vec3 p) {\n  p = asin(sin(p));\n  return dot(normalize(vec3(1)),p);\n}\n\nfloat noise(vec3 p, float dir) {\n  float f1 = fac(erot(p, normalize(vec3(1,2,3)),1.4+sh1*dir));\n  float f2 = fac(erot(p, normalize(vec3(-1,3,2)),2.4+sh2*dir));\n  float f3 = fac(erot(p, normalize(vec3(1,-2,1)),.4+sh3*dir));\n  \n  return (f1 + f2)/sqrt(2.);\n  return (f1 + f2 + f3)/2.;\n}\n\nfloat ball(vec3 p, float w, float t, float dir) {\n  vec3 p2 = normalize(p);\n  float f = noise(p2*7.*w, dir)/7./w;\n  return length(vec2(f,length(p)-w))-t;\n}\n\nfloat scene(vec3 p) {\n  float b1 = ball(p,1.,.1,-1.);\n  float b2 = ball(p,1.5,.03,1.);\n  float b3 = ball(p,2.,.02,-1.);\n  float b4 = ball(p/2.,2.,.01,1.)*2.;\n  return mix(min(min(b1,b2),min(b4,b3)), mix(noise(p*50., 1.)/50., noise(p*10.,-1.)/10., .5), .2);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n#define FK(x) floatBitsToInt(x*x/7.)^floatBitsToInt(x)\nfloat hash(float a, float b) {\n  int x = FK(a), y = FK(b);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat fakefft(float k) {\nfloat mul = fract(sin(k*564.)*353.);\n    return pow(1.-k,3.) * (.5+.5*sin(iTime*3.*sqrt(k+1.)*(4.4544+mul)))*1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 uv2 = floor(uv*4.)/4.;\n  float hs = hash(uv2.x,uv2.y);\n  time = iTime + (hash(hs,54.)+hash(hs,456.)+hash(hs,234.)+hs)*(.2*(sin(iTime*.5)*.5+.5));\n  \n  float bar = floor(fragCoord.x / iResolution.x*20.)/20.;\n  bar = abs(bar-.5);\n  bool inbar = false;\n  if (fakefft(bar)*(20.+bar*bar*600.)/100. > 1.-abs(fragCoord.y / iResolution.y-.5)*2.) {\n    inbar = true;\n  }\n  \n  float it = iTime*.3;\n  sh1 = sin(it);\n  sh2 = cos(it*1.34235);\n  sh3 = sin(it*2.15335);\n  \n  float off1,off2,off3,off4,off5;\n  \n  float tt = floor(time);\n  float t2 = asin(sin(iTime)) * .2;\n  off1 = sin(tt*45.) + t2;\n  off2 = cos(tt*33.) + t2;\n  off3 = sin(tt*76.) + t2;\n  off4 = sin(tt*17.) + t2;\n  off5 = sin(tt*99.);\n\n  vec3 cam = normalize(vec3(.7+off3*.5,uv));\n  vec3 init = vec3(-3,off1,off2);\n  \n  float zrot = iTime*.3 + off4;\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init = erot(init,vec3(0,0,1),zrot);\n  \n  float glow = 0.;\n  \n  vec3 p = init;\n  bool hit = false;\n  bool trig1 = false;\n  bool refl=false;\n  bool trig2 = false;\n  float atten = 1.;\n  for (int i = 0; i< 100 && !hit; i++) {\n    float dist = scene(p);\n    if(dist*dist<1e-6) {\n      if (sin(erot(p,normalize(vec3(1,1,1)),.96).z*10.) < -0.85) {\n      vec3 n = norm(p);\n      atten*=1.-abs(dot(cam,n))*.9;\n      p += n*.01;\n      cam = reflect(cam,n);\n        refl=true;\n      }else{\n      hit = true;\n      }\n    }\n    float dd = distance(p,init);\n    if (dist < 0.002*dd)trig1=true;\n    if (dist > 0.002*dd && trig1)trig2=true;\n    p += cam*dist;\n    glow += .08/(length(p)+.01) * sqrt(abs(dist));\n    if(distance(p,init)>100.)break;\n  }\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float diff = length(sin(n*2.)*.5+.5)/sqrt(3.);\n  float ref = length(sin(r*2.)*.5+.5)/sqrt(3.);\n  diff = mix(max(diff*2.-1.,0.), diff, .03);\n  vec3 col = vec3(.9,.2,.2)*diff + pow(ref,20.)*(1.-abs(dot(cam,n))*.9)*5.;\n  fragColor.xyz = sqrt(hit ? col : vec3(0));\n  fragColor.xyz += glow*vec3(0.1,.5,.8);\n  fragColor.xyz += glow*glow;\n  fragColor *= atten;\n  \n  if (trig2 && !refl) fragColor *= 0.;\n  fragColor = smoothstep(.05,1.,fragColor);\n  \n  if (inbar) off4 += 2.5;\n  if (inbar) fragColor += .5;\n  fragColor.xyz = erot(fragColor.xyz*2.-1.,normalize(vec3(off1,off2,off3)), off4)*.5+.5;\n  if (off5 < 0.0) fragColor = 1. - fragColor;\n  fragColor *= 1.-dot(uv,uv)*.5;\n  fragColor += noise(uv.xyy*500.,1.)*.02;\n  fragColor = floor(fragColor*8.)/8.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjGWD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 292], [327, 327, 346, 346, 404], [406, 406, 438, 438, 690], [692, 692, 741, 741, 847], [849, 849, 870, 870, 1107], [1109, 1109, 1128, 1128, 1240], [1297, 1297, 1327, 1327, 1399], [1401, 1401, 1425, 1425, 1541], [1543, 1543, 1600, 1650, 4089]], "test": "timeout"}
{"id": "cdjGDW", "name": "Chromatostereopsis Test (201ch)", "author": "fenix", "description": "I see an illusion of depth between the red and blue areas. Supposedly only 1/2 of people see this. Do you?\n\nreference: https://twitter.com/fatlimey/status/1588575802614251520\nmore info: http://gurneyjourney.blogspot.com/2019/04/chromostereopsis.html\n", "tags": ["illusion", "squircle", "golf", "reproduction", "chtomatostereopsis"], "likes": 10, "viewed": 175, "published": 3, "date": "1667609315", "time_retrieved": "2024-07-30T16:22:11.768459", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I see an illusion of depth between the red and blue areas. with the red areas \"higher\"\n// than the blue ones. Supposedly only 1/2 of people see this. If you don't see the\n// illusion, please post in the comments because I'm not sure I believe that there are\n// people who don't see it.\n//\n// Golfing welcome!\n//\n// reference: https://twitter.com/fatlimey/status/1588575802614251520\n// more info: http://gurneyjourney.blogspot.com/2019/04/chromostereopsis.html\n\n#define s(r) smoothstep(1., 1.1, pow(u.x / r, 5.) + pow(u.y / r, 5.)) // squircle\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    O = iResolution.xyyy;\n    u = abs(u - O.xy * .5) / O.y;\n    O = texture(iChannel0, u).r * vec4(1. + s(.43) - s(.17), 0, s(.2) - s(.4), 1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjGDW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[756, 756, 797, 797, 942]], "test": "untested"}
{"id": "cs23DW", "name": "Teach shader", "author": "reatured", "description": "hi", "tags": ["teach"], "likes": 1, "viewed": 116, "published": 3, "date": "1667608774", "time_retrieved": "2024-07-30T16:22:12.817654", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float screenRatio = iResolution.x/iResolution.y;\n    uv.x *= screenRatio;\n    \n    vec2 circlePos = vec2(0.5 + sin(iTime), 0.5);\n    float r = 0.2;\n    \n    float dist = (uv.x-circlePos.x) * (uv.x-circlePos.x) + (uv.y-circlePos.y) * (uv.y-circlePos.y) ;\n    \n    vec3 col = vec3(0.,0.,0.);\n    \n    if(dist > r*r){\n        col = vec3(0.,0.,0.);\n    \n    }else{\n         col = vec3(uv.x,uv.y,1.);\n    }\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs23DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 648]], "test": "untested"}
{"id": "Ddj3DW", "name": "Fork dance dots mds2 313", "author": "mds2", "description": "Music by \"Vantage\" (not by me!).\n\nFork of https://www.shadertoy.com/view/MdcSDB that keeps dots at a constant size", "tags": ["sound", "camera", "dots", "noodling", "soundcloud", "vaporwave", "vantage"], "likes": 5, "viewed": 445, "published": 3, "date": "1667607502", "time_retrieved": "2024-07-30T16:22:17.334577", "image_code": "#define DOTSIZE 8.0\n\nfloat ramp(in float start, in float stop, in float val) {\n  return clamp((val - start)/(stop - start), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dotsize = min(20.0, max(DOTSIZE, 5.0));\n    vec2 mirrorCoord = vec2 (iResolution.x - fragCoord.x, fragCoord.y);\n    vec2 dotcenter = (mirrorCoord - mod(mirrorCoord, 2.0 * dotsize)) + vec2(dotsize);\n    float rad = length(mirrorCoord - dotcenter);\n    \n    vec2 sampleAt = dotcenter / iResolution.xy;\n    \n    vec2 musicSampleAt = vec2(fract(dot(sampleAt + sampleAt * sampleAt, vec2(311.7123, 733.01))), 0.0);\n    \n    float dotRad = texture(iChannel1, musicSampleAt).x * (dotsize - 3.0);\n    \n    float inside = ramp (2.0, 0.25, rad - dotRad) - 0.125 * ramp(dotRad, 0.0, rad);\n    \n    vec3 rgb = texture(iChannel0, sampleAt).xyz;\n    \n    rgb = 0.25 * (step(vec3(0.1), rgb) + step(vec3(0.25), rgb) +\n                  step(vec3(0.4), rgb) + step(vec3(0.55), rgb));\n   //  rgb = vec3(1.0, 0.0, 0.0);\n    \n    vec3 background = vec3(0.0);\n\tfragColor = vec4(mix(background, rgb, inside),1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4217, "src": "https://soundcloud.com/vantagenoise/so-right-80s-aerobics-1k-thank-you-mix?in=vantagenoise/sets/metro-city-deluxe-1", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddj3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 136], [138, 138, 195, 195, 1098]], "test": "untested"}
{"id": "cs23WW", "name": "the Barnsley fern", "author": "kanayuki", "description": "Barnsley fern", "tags": ["2d", "barnsleyfern"], "likes": 5, "viewed": 164, "published": 3, "date": "1667604475", "time_retrieved": "2024-07-30T16:22:18.281046", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv = (uv+vec2(0,1))*5.2;\n    vec3 col = vec3(0.75);\n    float x = 0.0;\n    float y = 0.0;\n    float a,b,c,d,f;\n\n    for(int i = 0; i < 1000; i++){\n\n        float r = fract(sin(uv.x+float(i))*3141.516);\n\n        if( r<0.02 ) { a=0.0; b=0.0; c=0.0; d=0.16; f=0.0; }\n\n        else if( r<0.89 ) { a=0.85; b=0.04; c=-0.04; d=0.85; f=1.6; }\n\n        else if( r<0.96 ) { a=0.2; b=-0.26; c=0.23; d=0.22; f=1.6; }\n\n        else { a=-0.15; b=0.28; c=0.26; d=0.24; f=0.44; }\n\n        float xs = x;\n\n        x = a*x + b*y;\n\n        y = c*xs + d*y + f;\n\n        // plotPointAt( x, y );\n        bool b = length(vec2(x,y)-uv)<0.1;\n        if (b) {\n            fragColor = vec4(1.0,0.0,1.0,1.0);\n            return;\n        }\n\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs23WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 331]], "test": "untested"}
{"id": "dsS3Dh", "name": "Cloudy moonlight", "author": "kishimisu", "description": "Move the mouse to see the perspective better", "tags": ["volume", "clouds", "fbm", "sky", "volumetric", "moon", "night"], "likes": 16, "viewed": 1183, "published": 3, "date": "1667586942", "time_retrieved": "2024-07-30T16:22:19.122797", "image_code": "/* I got the idea to create this shader after observing the moon \n   on a cloudy night a few days ago, and also because I really \n   like to explore volume rendering right now.\n   \n   I started by calculating and marching real light samples \n   but this decreased the performances a lot and I wanted it \n   to be accessible, so I replaced it with a fake light which\n   intensity is mapped to the distance from the camera.\n   \n   You can move the camera with the mouse to better see the perspective.\n   To see the entire \"scene\", set BEHIND_THE_SCENE to 1 =)\n   \n   Also I tried to add stars in the background (line 123) but I got\n   heavy flickering when moving the camera. Does someone know a proper \n   way to add stars without having this visual artefact ?   \n*/\n\n#define CLOUDS_SMOOTHNESS 1.5\n#define LIGHT_INTENSITY   20.\n#define ABSORPTION        5.5\n#define VOLUME_STEPS      40.\n\n#define BEHIND_THE_SCENE  0\n\n#define PI 3.141592\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) * 43758.5453123)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// noise and fbm are from https://www.shadertoy.com/view/XtS3DD\nfloat noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod(iChannel0, (tap+0.5)/256.0, 0.0).yx;\n\treturn mix(rz.x, rz.y, fp.z);\n}\n\nfloat fbm(in vec3 x) {   \n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<4; i++) {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz - .25;\n}\n\nvec2 boxIntersection(in vec3 ro, in vec3 rd) {\n    vec3 rad = vec3(6., 6., 2.);\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection   \n    return vec2( tN, tF );\n}\n\nvoid marchVolume(vec3 ro, vec3 rd, float near, float far, inout vec3 color) {    \n    vec3 vColor = vec3(0.);\n    float visibility = 1.;\n    \n    float inside = far - near + hash33(ro).x*.01;\n    float stepSize = inside / VOLUME_STEPS;\n    float i = 0.;\n    \n    for (float t = near; t <= far; t += stepSize) {\n        vec3 p = ro + t*rd;\n        \n        float s = CLOUDS_SMOOTHNESS*.01;\n        float dens = smoothstep(-s, s, fbm(p + vec3(iTime*.055, iTime*.065, 1.+iTime*.02)))*.1;\n        \n        float prev = visibility;\n        visibility *= exp(-stepSize*dens*ABSORPTION);\n        \n        float absorption = prev - visibility;\n        float light = smoothstep(2.5, 6.5, p.z); // fake light\n        vColor += absorption * dens * light * LIGHT_INTENSITY;\n        \n        if (i++ > VOLUME_STEPS) break;\n    }\n    \n    color = min(vColor, 1.) + color * visibility;\n}\n\nvoid initCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy;\n    \n    ro = vec3(m.x-.5, m.y-.5, .01)*.8;\n\n    #if BEHIND_THE_SCENE\n    ro.x += 8.; ro.z -= 8.;\n    #endif\n    \n    vec3 f = normalize(vec3(0., 0., 1.) - ro*.05),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = ro+f,\n         i = c + uv.x*r + uv.y*u;    \n    rd = normalize(i-ro); // camera direction\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro, rd;   \n    initCamera(fragCoord, ro, rd);\n    \n    // moon\n    float moon = dot(rd, vec3(0., 0., 1.));\n    vec3 color = (.7-fbm(rd*10.)*3.) * vec3(smoothstep(.995, .9955, moon));\n    color += (1.25-color)*pow(moon+.1, 6.)*.25;\n    \n    // stars (removed due to flickering)\n    vec3 h = hash33(vec3(floor(rd.xy*80.), 0.));\n    float stars = length(fract(rd.xy*80. + h.xy*.75)-.5);\n    // color += .006/stars * h.z;\n    \n    // clouds\n    vec2 hit = boxIntersection(ro - vec3(0., 0., 4.), rd);\n    marchVolume(ro, rd, hit.x, hit.y, color);\n        \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsS3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1056, 1056, 1075, 1075, 1127], [1129, 1193, 1217, 1217, 1433], [1435, 1435, 1457, 1457, 1617], [1619, 1619, 1665, 1665, 1996], [1998, 1998, 2075, 2075, 2870], [2872, 2872, 2935, 2935, 3405], [3407, 3407, 3464, 3464, 4059]], "test": "untested"}
{"id": "msSGWW", "name": "Simple voronoi noise", "author": "fishy", "description": "A simple Voronoi noise implementation.  All code in this project *should* be commented and easy to understand. Mouse X controls point jitter, mouse Y controls the split effect. Space toggles showing the second closest point/distance", "tags": ["voronoi"], "likes": 7, "viewed": 180, "published": 3, "date": "1667585466", "time_retrieved": "2024-07-30T16:22:19.914679", "image_code": "vec2 hash22(vec2 p) //hashwithoutsine; hash functions return a random number based on a non-random input, \n// e.g. a range of numbers 0, 1, 2, and 3 each hashed might return a new sequence 0.5, 0.2, 0.7, and 0.9.\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voronoi(vec2 p, float jitter, out vec2 f1, out vec3 f2)\n{\n    float r = 100000.0; // A big number\n    vec2 fp = floor(p); // Round the current position down to the nearest whole number\n    f1 = vec2(0);\n    f2 = vec3(0);\n    for(int x = -1; x <= 1; x++) // Loop over the space near the point\n    for(int y = -1; y <= 1; y++) // Same thing\n    {\n        vec2 cell = fp+vec2(x, y); // Get the current square cell\n        vec2 rp = cell+0.5+(hash22(cell)-0.5)*jitter; // Each square cell the point can be in has a single point, offset by a random value times the jitter\n        float d = distance(p, rp); // Get the distance between the random point and the input position\n        if(d < r) // If the distance is the closer than the current closest distance, it becomes the closest distance (along with the position of the point)\n        {\n            f2.z = r;\n            r = d;\n            f2.xy = f1;\n            f1 = rp;\n        }\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // Convert coordinates to 0.0 to 1.0 range\n    uv.y *= iResolution.y/iResolution.x; // Scale coordinate so that the tiles don't appear squashed\n    \n    vec2 mouse = iMouse.x == 0.0? vec2(smoothstep(-1., 1., sin(iTime)),smoothstep(-1., 1., cos(iTime))) // Animate mouse x and y when no mouse input (thumbnail) according to a square circle\n                 : iMouse.xy/iResolution.xy; // Otherwise use the actual mouse input if there is some\n    mouse.y *= iResolution.y/iResolution.x; // Scale mouse coordinate so that they match the range of the UV coords\n    \n    vec2 f1; // Functions can sort of \"return\" multiple values by using the \"out\" keyword, so this variable will store the position of the closest point\n    vec3 f2; // Read comment for f1. vec3 because this variable stores both the position and the distance, whereas f1 only stores the position\n    float v = voronoi(uv*10.0, mouse.x, f1, f2); // Evaluate voronoi\n    \n    float space = texelFetch(iChannel0, ivec2(32, 2), 0).r;\n    \n    vec3 col = uv.y < mouse.y? vec3(space > 0.5? (f2.z) : v) : vec3((space > 0.5? f2.xy : f1)/10., 0.0); // Split the screen between showing the distance and the position based on mouse position\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 214, 214, 350], [352, 352, 415, 415, 1312], [1314, 1314, 1371, 1371, 2638]], "test": "untested"}
{"id": "cdB3WD", "name": "spiral dots sdf", "author": "sympou", "description": "fork of previous shader !", "tags": ["logpolarsdf"], "likes": 19, "viewed": 266, "published": 3, "date": "1667585229", "time_retrieved": "2024-07-30T16:22:20.678636", "image_code": "//you have to tweak v1 if you want the circles to touch each other.\n//there might be a way to compute the ideal value of v1 !\n\n#define num 11.\n#define Y   fract(iTime*0.25)\n#define v1  1.015\n#define v2  1.\n#define v3  1.25\n#define v4  1.\n\n#define PI   3.1415926535\n#define PI2  6.2831853071\n#define PI05 1.5707963267\n\nfloat sdDots( in vec2 p ) {\n\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    \n    float zone  = mod( ang / PI2 * num + 0.5, num);\n    vec2  zone2 = (floor(zone) + vec2(0., sign( fract(zone) - 0.5 ))) / num;\n    \n    float sa  = sin(PI / num) * v1;\n    float n2  = 2. / (sa + v3) - 1.; \n    \n    float l   = log(len) / log(n2);\n    vec2 Y2   = Y - zone2 * v4;\n    vec2 val2 = pow( vec2(n2), floor( l + Y2 ) - Y2 );\n    vec2 ab   = ang - zone2 * PI2;\n    \n    vec2 p2 = vec2(cos(ab.x), sin(ab.x)) * len;\n    vec2 p3 = vec2(cos(ab.y), sin(ab.y)) * len;\n    vec2 r2 = val2 * sa * v2;\n    \n    float t = length(p2-vec2(val2.x,   0.)) - r2.x;\n    t = min(t,length(p3-vec2(val2.y,   0.)) - r2.y    );\n    t = min(t,length(p2-vec2(val2.x*n2,0.)) - r2.x*n2 );            \n    t = min(t,length(p3-vec2(val2.y*n2,0.)) - r2.y*n2 );\n\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdDots(p);\n    \n\t// coloring (from IQ's shaders)\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 ) {\n        d = sdDots(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdB3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 345, 345, 1169], [1172, 1172, 1229, 1229, 1871]], "test": "untested"}
{"id": "msjGWR", "name": "dsitance to a line", "author": "jonasfrey", "description": "draw a line", "tags": ["basic", "line"], "likes": 1, "viewed": 164, "published": 3, "date": "1667583587", "time_retrieved": "2024-07-30T16:22:21.494455", "image_code": "//const float n_tau = 6.28318530717958647;\nfloat f_n_difference_to_line_function(\n    vec2 a_n_start, \n    vec2 a_n_end, \n    vec2 a_n_pixel_coord_normalized\n){\n    //remember that math lesson ?\n    // y = m*x+q\n    float n_delta_y = a_n_end.y - a_n_start.y; \n    float n_delta_x = a_n_end.x - a_n_start.x; \n    float n_m = n_delta_y / n_delta_x;\n    float n_q = -(n_m*a_n_start.x) + a_n_start.y;\n    \n    float n_x = a_n_pixel_coord_normalized.x;\n    \n    float n_y = n_m * n_x + n_q; \n   \n    float n_difference = abs(a_n_pixel_coord_normalized.y - n_y);\n    return n_difference;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    float n_zoomout = 3.0;\n    vec2 a_n_pixel_pos_normalized = n_zoomout*(fragCoord.xy-iResolution.xy*0.5) / iResolution.y;\n    \n    vec2 o_p1 = vec2(-0.2,0.8);\n    vec2 o_p2 = vec2(-0.5, 0.2); \n    \n    float n_brightness = 0.0;\n    float n_difference_to_line_function = f_n_difference_to_line_function(\n        o_p1, \n        o_p2, \n        a_n_pixel_pos_normalized\n    );\n  \n    fragColor *= vec4(abs(n_difference_to_line_function*20.00));\n    fragColor *= vec4((smoothstep(0.1,0.11,length(a_n_pixel_pos_normalized-o_p1))));\n    fragColor *= vec4((smoothstep(0.1,0.11,length(a_n_pixel_pos_normalized-o_p2))));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 160, 211, 588], [591, 591, 648, 648, 1295]], "test": "untested"}
{"id": "DsBGDD", "name": "pseudo random rgb noise", "author": "jonasfrey", "description": "this is a test of how one can get pseudo random values, foreach each random value to be generated it needs a previous unique value, \nfor the first random value that is the index of the current pixel\nfor the following random values, i take the previous rnd", "tags": ["random"], "likes": 1, "viewed": 164, "published": 3, "date": "1667582415", "time_retrieved": "2024-07-30T16:22:22.265393", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_mouse_coords_norm = iMouse.xy / iResolution.xy;\n    vec2 a_n_frag_coords_norm = fragCoord.xy / iResolution.xy;\n    \n    float n_high_prime = 1471343.0;\n    float n_high_prime_modified = n_high_prime * a_n_mouse_coords_norm.x;\n    \n    float n_tau = 6.2831;\n    int n_index_pixel = \n        int(\n            a_n_frag_coords_norm.x * iResolution.x + \n            (a_n_frag_coords_norm.y * iResolution.y) * iResolution.x\n           ); \n    int n_index_pixel2 = \n        int(fragCoord.x + fragCoord.y * iResolution.x);\n    float n_index_pixel_normalized = float(n_index_pixel2) / iResolution.x * iResolution.y;\n    float n_freq = float(n_index_pixel_normalized); \n\n    \n    float n_y = sin(n_freq*n_tau) * n_high_prime_modified;\n    \n    float n_rand_method1 = abs(mod(n_y,1.0));\n    float n_rand_method2 = n_y - floor(n_y);\n    \n    \n    float n_y2 = sin(n_freq*n_tau*n_rand_method2) * n_high_prime;\n    float n_rand2 = n_y2 - floor(n_y2);\n    \n    float n_y3 = sin(n_freq*n_tau*n_rand2) * n_high_prime;\n    float n_rand3 = n_y3 - floor(n_y3);\n    fragColor = vec4(\n        n_rand_method2, \n        n_rand2, \n        n_rand3, \n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1215]], "test": "untested"}
{"id": "DdSGDD", "name": "CheapFire01", "author": "Del", "description": "Cheap(ish) fire effect - left mouse to see non polar coords", "tags": ["fbm", "fire", "polar"], "likes": 15, "viewed": 302, "published": 3, "date": "1667580273", "time_retrieved": "2024-07-30T16:22:23.037330", "image_code": "// Cheap(ish) tweakable flat / polar burn effect\n\n//#define USE_PROCEDURAL\n\n// noise, IQ - https://www.shadertoy.com/view/4sfGzS\n#ifdef USE_PROCEDURAL\n//float hash(vec3 p)  // replace this by something better\n//{\n//    p  = fract( p*0.3183099+.1 );\n//\tp *= 17.0;\n//    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n//}\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n//#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n//#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+1.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nfloat mNoise( in vec3 pos )\n{\n    vec3 q = pos;\n    const mat3 m = mat3( 0.20,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n                    \n    float amplitude = .65;\n    float f  = amplitude*noise( q );\n    q = m*q*2.11;\n    float scale = 2.02;\n    for (int i = 0; i < 3; ++i)\n    {    \n    \tf += amplitude * noise( q );\n        q = m*q*scale;        \n        amplitude *= 0.5;\n        \n    }\n    return f;\n}\n\n\n\nvec2 polarMap(vec2 uv, float shift, float inner)\n{\n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (sqrt(uv.x * uv.x + uv.y * uv.y) * (1.0 + inner * 2.0) - inner) * 2.0;\n    return vec2(px, py);\n}\n\n// shane?\nvec3 firePalette(float i)\n{\n\n    float T = 1400. + 1400.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tvec2 uv = p;\n    uv.x = abs(uv.x); // mirror\n    \n    // tweak as you like...\n    float inner = 0.0;\n    float shift = 0.0;\n    float hrepeat = 16.0;\n    uv = polarMap(uv*1.4,shift,inner);\n    uv.x *= hrepeat;\n\t\n    if (iMouse.z>0.5)\n        uv = vec2(p.x*4.0,p.y+0.9); // use nonpolar uv\n    \n\tfloat t = iTime * 0.2;\n\tfloat fval = uv.y;\n\tuv = vec2(uv.x, uv.y - t) * 2.55;\n\tfval = fval + 0.67 + (mNoise(vec3(uv, t*1.1)) * 0.33);\n    vec3 color = firePalette(2.4-fval);\n\tfragColor = vec4(color.xyz,1.0);\n}\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1380, 1380, 1409, 1409, 1847], [1851, 1851, 1901, 1901, 2082], [2084, 2094, 2121, 2121, 2445], [2447, 2447, 2504, 2504, 3080]], "test": "untested"}
{"id": "DdSGWD", "name": "some lines click drag mouse", "author": "jonasfrey", "description": "i really do not know what is going on ", "tags": ["line"], "likes": 2, "viewed": 148, "published": 3, "date": "1667579059", "time_retrieved": "2024-07-30T16:22:23.897031", "image_code": "//const float n_tau = 6.28318530717958647;\nfloat f_n_difference_to_line_function(\n    vec2 a_n_start, \n    vec2 a_n_end, \n    vec2 a_n_pixel_coord_normalized\n){\n    //remember that math lesson ?\n    // y = m*x+q\n    float n_delta_y = a_n_end.y - a_n_start.y; \n    float n_delta_x = a_n_end.x - a_n_start.x; \n    float n_m = n_delta_y / n_delta_x;\n    float n_q = -(n_m*a_n_start.x) - a_n_start.y;\n    \n    float n_x = a_n_pixel_coord_normalized.x;\n    \n    float n_y = n_m * n_x + n_q; \n   \n    float n_difference = n_y - a_n_pixel_coord_normalized.y;\n    return n_difference;\n\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_pixel_pos_normalized = fragCoord.xy / iResolution.xy;\n    vec2 a_n_mouse_pos_normalized = iMouse.xy / iResolution.xy;\n        \n    float n_brightness = 1.0;\n    \n    float n_lines = 2000.0 * a_n_mouse_pos_normalized.x;\n    for(float n_i = 1.0; n_i <= n_lines; n_i+=1.0){\n        float n_difference_to_line_function = f_n_difference_to_line_function(\n            vec2(1.0-(1.0/n_lines)*n_i, 0.0), \n            vec2((1.0/n_lines)*n_i,1.0), \n            a_n_pixel_pos_normalized\n        );\n        n_brightness *= (n_difference_to_line_function*1000.0*a_n_mouse_pos_normalized.x);\n    }\n    float n_i = 1.0;\n\n\n    fragColor = vec4(n_brightness);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 160, 211, 584], [586, 586, 643, 643, 1301]], "test": "untested"}
{"id": "dsj3Dh", "name": "Simple Slit Scan", "author": "Trixelized", "description": "A simple and commented out slit scan shader", "tags": ["slitscan", "men"], "likes": 1, "viewed": 348, "published": 3, "date": "1667578783", "time_retrieved": "2024-07-30T16:22:24.653010", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // We don't do anything special here\n    // Simply draw Buffer A\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define extra_frame_delay 120.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // get the screen UV and the vertical 'slit' position\n    vec2 uv = fragCoord/iResolution.xy;\n    float slitpos = mod(float(iFrame), iResolution.y + extra_frame_delay);\n    \n    // sample the previous frame\n    vec3 last = texture(iChannel0, uv).rgb;\n    vec3 col = last;\n    \n    // draw the 1-pixel thin new slit\n    float slit = (step(slitpos - fragCoord.y, 1.0));\n    col = mix(col, texture(iChannel1, uv).rgb, slit);\n    \n    // draw the red bar above the slit\n    float bar = (step(slitpos - fragCoord.y, 0.0) * step(-9.0, slitpos - fragCoord.y));\n    col = mix(col, vec3(1.0, 0.0, 0.0), bar);\n    \n    fragColor = vec4(col, 1.0);\n    \n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsj3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 124, 188]], "test": "untested"}
{"id": "cdSGDW", "name": "SoomthstepAndLength", "author": "CodeJUN", "description": "个人练习", "tags": ["2d"], "likes": 0, "viewed": 140, "published": 3, "date": "1667576378", "time_retrieved": "2024-07-30T16:22:25.608455", "image_code": "#define PI 3.141592653\nvec2 fixUV(in vec2 c)\n{\n    return 3.*(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n}//uv变换\n\nvec3 Grid(in vec2 uv)\n{\n    vec3 color=vec3(0.);\n    vec2 fraction=1.-2.*abs(fract(uv)-0.5);\n\n    /*if(abs(uv.x)<=2.*fwidth(uv.x))\n    {\n        color.g=1.;\n    }\n    else if (abs(uv.y)<=2.*fwidth(uv.y))\n    {\n        color.r=1.;\n    }\n    else if (fraction.x<2.*fwidth(uv.x)||fraction.y<2.*fwidth(uv.y))\n    {\n        color=vec3(1.);\n\n    }*/\n    color=vec3(smoothstep(4.*fwidth(uv.x),3.9*fwidth(uv.x),fraction.x));\n     color+=vec3(smoothstep(4.*fwidth(uv.y),3.9*fwidth(uv.y),fraction.y));\n     color.rb *= smoothstep(1.9*fwidth(uv.x),2.0*fwidth(uv.x),abs(uv.x));\n      color.gb *= smoothstep(1.9*fwidth(uv.y),2.0*fwidth(uv.y),abs(uv.y));\n\n    return color;\n     \n}//横纵坐标和白色格子\n\nfloat segment(in vec2 p,in vec2 a,in vec2 b,in float w)\n{\n    float f=0.;\n    vec2 ba=b-a;\n    vec2 pa=p-a;\n    float proj=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    float d=length(proj*ba-pa);\n    /*if(d<=w)\n    {\n        f=1.; \n    }*/\n    f = smoothstep(w,0.95*w,d);\n    return f;\n}//画一条线段\n\nfloat func(in float x)\n{\n    \n   // return sin(x);\n   //return cos(x);\n\n   /*float T=3.+sin(iTime);\n   return sin(2.*PI/T*x);*/\n   return smoothstep(-1.,1.,x);\n\n}//函数\n\nfloat funcPlot(in vec2 uv )\n{\n    float f=0.;\n    for(float x=0.;x<=iResolution.x;x+=1.)\n    {\n        float fx=fixUV(vec2(x,0.)).x;\n        float nfx=fixUV(vec2(x+1.,0.)).x;\n        f+=segment (uv,vec2(fx,func(fx)),vec2(nfx,func(nfx)),fwidth(uv.x));\n    }\n    return clamp(f,0.,1.);\n}//通过等线距去点连接\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n   // vec3 color = vec3(0.);\n    vec2 uv=fixUV(fragCoord); \n    /*vec3 color = Grid(uv) ;\n   //color =mix(color,vec3(1.,1.,0.),segment(uv,vec2(1.,2.),vec2(2.,0.),fwidth(uv.x)));\n    color =mix(color,vec3(1.,1.,0.),funcPlot(uv));*/\n    vec3 color = vec3(0.);\n    /*if(length(uv)<1.)\n    {\n        color=vec3(1.);\n\n    }*/\n    color = vec3(smoothstep(1.,.99,length(uv)));\n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 118], [130, 130, 153, 153, 797], [828, 828, 885, 885, 1110], [1129, 1129, 1153, 1256, 1291], [1301, 1301, 1330, 1330, 1586], [1617, 1617, 1671, 1700, 2073]], "test": "untested"}
{"id": "msj3D1", "name": "logpolar dots sdf", "author": "sympou", "description": "something that was found while messing around with symmetry and numbers.\nit is inspired by :\nhttps://www.shadertoy.com/view/NlSyD1\nhttps://www.shadertoy.com/view/7tfBW8\nin my case, the sdf is exact ! but it's less flexible than warping the space.", "tags": ["logpolarsdf"], "likes": 11, "viewed": 235, "published": 3, "date": "1667575058", "time_retrieved": "2024-07-30T16:22:26.536973", "image_code": "#define num 11.\n#define Y   iTime*0.25\n#define v1  1.\n#define v2  1.\n#define v3  1.\n\n#define PI 3.1415926535\n\n//function found here : https://www.shadertoy.com/view/ssByDw\nvec2 foldRotate(vec2 p, float s, float offset) {\n    \n    float t = PI / s;\n    float a = PI * 0.5 + t - atan(p.x, p.y) + offset;\n    a = mod(a, t*2.) - t ;\n    //a = abs(a);\n    \n    return vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat sdDots( in vec2 p ) {\n\n    p = foldRotate(p,num,0.);\n\n    float sa = sin(PI / num)*v1;\n    float n2 = 2./(sa + v3) - 1.; \n    \n    float val = pow(n2, floor( log(p.x) / log(n2) + Y) - Y );\n            \n    float t = length(p-vec2(val,   0.)) - val*sa*v2     ;\n    t = min(t,length(p-vec2(val*n2,0.)) - val*sa*n2*v2 );\n    \n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdDots(p);\n    \n\t// coloring (from IQ's shaders)\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 ) {\n        d = sdDots(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msj3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 172, 220, 220, 398], [400, 400, 427, 427, 744], [747, 747, 804, 804, 1446]], "test": "untested"}
{"id": "md2GDh", "name": "BELGIUM", "author": "jojojo12", "description": "Belgian flag", "tags": ["flag", "belgium"], "likes": 1, "viewed": 163, "published": 3, "date": "1667570532", "time_retrieved": "2024-07-30T16:22:27.379719", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(225.0,0.0,0.0);\n    vec2 r = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n    \n    \n    \n    if(fragCoord.x < iResolution.x /3.0){\n      col = vec3(0.0,0.0,0.0);\n\n    }\n    else if (iResolution.x /3.0 < fragCoord.x){\n      if(fragCoord.x < 2.0*iResolution.x /3.0){\n         col = vec3(225.0,225.0,0.0);\n\n      }\n\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2GDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 479]], "test": "untested"}
{"id": "csjGD1", "name": "Find Edges Directionally", "author": "MysteryPancake", "description": "Finds the brightest neighbouring pixel and the direction towards it", "tags": ["edge", "cellular", "cell", "kernel", "findedges", "direction"], "likes": 2, "viewed": 187, "published": 3, "date": "1667557552", "time_retrieved": "2024-07-30T16:22:28.421933", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 texSize = vec2(textureSize(iChannel1, 0));\n\tfragColor = texelFetch(iChannel0, ivec2(fragCoord / iResolution.xy * texSize), 0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n\t// Brightest neighbour and direction toward it\n\tvec4 brightest = vec4(0.0);\n\tvec2 direction = vec2(0.0);\n\n\t// Sample in a 3 x 3 kernel\n\tfor (int x = -1; x <= 1; ++x) {\n\t\tfor (int y = -1; y <= 1; ++y) {\n\n\t\t\t// Ignore self\n\t\t\tif (x == 0 && y == 0) continue;\n\t\t\t\n\t\t\t// Sample neighbour\n\t\t\tvec2 pos = vec2(x, y);\n\t\t\tvec4 neighbour = texelFetch(iChannel0, ivec2(fragCoord + pos), 0);\n\t\t\t\n\t\t\t// Store neighbour with maximum brightness\n\t\t\tif (length(neighbour) > length(brightest)) {\n\t\t\t\tbrightest = neighbour;\n\t\t\t\tdirection = pos;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Colorize (direction range is -1 to 1)\n\tvec4 colorized = vec4(direction.xy, -direction.xy);\n\t\n\t// Emphasise more intense edges\n\tvec4 self = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\tfloat weight = distance(brightest, self);\n\t\n\tfragColor = colorized * weight;\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjGD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 190]], "test": "untested"}
{"id": "DsjGW1", "name": "Stickerlsw", "author": "lsw", "description": "Stickerlsw", "tags": ["image"], "likes": 0, "viewed": 172, "published": 3, "date": "1667551560", "time_retrieved": "2024-07-30T16:22:29.409293", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // 归一化坐标0～1， 作为取纹理用\n    vec3 col = texture(iChannel0, uv).rgb;  // 取图片纹理\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy; // 鼠标点击坐标\n    \n    mouseUV = mouseUV * 2.0;\n    \n    vec2 stickerUV = uv * 2.0;\n   \n    if (mouseUV.x - stickerUV.x < 0.5 &&  mouseUV.y - stickerUV.y < 0.5 && stickerUV.x - mouseUV.x < 0.5 &&  stickerUV.y - mouseUV.y < 0.5) {\n        vec4 me = texture(iChannel1, stickerUV - mouseUV + 0.5);\n\n    \n\n        float c = 1.0;\n        fragColor = vec4(mix(col, me.xyz, c), 1.0);\n    } else {\n        fragColor = vec4(col, 1.0);\n\n    }\n\n    \n    \n   \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 720]], "test": "untested"}
{"id": "csjGW1", "name": "gaussianlsw", "author": "lsw", "description": "gaussianlsw", "tags": ["image"], "likes": 0, "viewed": 157, "published": 3, "date": "1667551449", "time_retrieved": "2024-07-30T16:22:30.431559", "image_code": "#define pow2(x) (x * x)\n\nconst float pi = atan(1.0) * 4.0;\nconst int samples = 35;\nconst float sigma = float(samples) * 0.25;\n\nfloat gaussian(vec2 i) {\n    return 1.0 / (2.0 * pi * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n}\n\nvec3 blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec3 col = vec3(0.0);\n    float accum = 0.0;\n    float weight;\n    vec2 offset;\n    \n    for (int x = -samples / 2; x < samples / 2; ++x) {\n        for (int y = -samples / 2; y < samples / 2; ++y) {\n            offset = vec2(x, y);\n            weight = gaussian(offset);\n            col += texture(sp, uv + scale * offset).rgb * weight;\n            accum += weight;\n        }\n    }\n    \n    return col / accum;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color.rgb = blur(iChannel0, uv, ps);\n    color.a = 1.0;\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 151, 151, 252], [254, 254, 300, 300, 717], [719, 719, 763, 763, 898]], "test": "untested"}
{"id": "Dd23Dh", "name": "Cos Accuracy II", "author": "mla", "description": "Compare built in cos & sine with an accurate Taylor expansion - horizontal scale is ±pi/2, vertical is ±1e-4 or ±1e-6 depending on platform. For cos, errors peak around zero where linear approximation is hardest.", "tags": ["cos", "accuracy"], "likes": 7, "viewed": 224, "published": 3, "date": "1667550507", "time_retrieved": "2024-07-30T16:22:31.917586", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Cos Accuracy II, mla 2022.\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// Trig function errors. This is mainly intended to show what happens on Intel\n// where cos and sin are computed with a simple piecewise linear\n// approximation, though there is a check for GPUs with better trig functions,\n// eg. Nvidia, and zooms in vertically if so (it's just checking a single\n// value so might give false positives though).\n\n// Red channel: absolute error in cos(x)\n// Green channel: absolute error in sin(x)\n// Blue channel: ulps error in cos(x)\n//\n// Numeric display shows the main trig functions evaluated at the mouse position\n// and compared with the more accurate myxxx functions. We also compute the inverse\n// functions for comparison with the original theta.\n//\n//         mycos(theta)       mysin(theta)       mytan(theta)\n//         cos(theta)         sin(theta)         tan(theta)\n// theta   acos(mycos(theta)) asin(mysin(theta)) atan(mytan(theta))\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// mycos and mysin have been checked on CPU & agree to a few ulps with\n// builtin functions in range [0..pi/2] (ulp error is larger when result is\n// closer to zero, but absolute error is fine). It's possibly worth using\n// sin(pi/2-x) for cos(x) in upper half of range, but there isn't a lot in it.\n\n//#define CRENSHAW\n\nfloat mycos0(float x, int N) {\n  N *= 2;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\nfloat mycos(float x) { return mycos0(x,8); }\n\n// This is a pretty good Chebyshev approximaton to cos(x)\nfloat mycos1(float x) {\n  assert(x >= -1.5707963 && x <= 1.5707963);\n  float x2 = x*x;\n  float t = -0.0012711104;\n  t = x2*t + 0.041487381;\n  t = x2*t + -0.4999121;\n  t = x2*t + 0.99999325;\n  return t;\n}\n\nfloat mysin1(float x) {\n  assert(x >= -1.5707963 && x <= 1.5707963);\n  float x2 = x*x;\n  float t = -0.00018362749;\n  t = x2*t + 0.0083062861;\n  t = x2*t + -0.16664824;\n  t = x2*t + 0.9999966;\n  t = x*t;\n  return t;\n}\n\nfloat mysin(float x) {\n  int N = 10;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}\n\n// From https://www.shadertoy.com/view/md3cDM by Envy24\n// Source: \"Math Toolkit For Real-Time Development\", Jack W. Crenshaw\nvec2 sincos(float x)\n{\n    const float sin_30 =      0.5;\n    const float cos_30 =      0.8660254037844386;\n    const float pi_over_six = 0.5235987755982988;    // pi / 6\n    const float inv =         1.9098593171027440292; // 1 / pi_over_six\n    const float tau =         6.2831853071795862;\n    const float inv_tau =     0.1591549430918953;\n    \n    // Increases accuracy for negative angles (see this shader: https://www.shadertoy.com/view/NtVBWG)\n    float X = fract(x*inv_tau);\n          x = X*tau;\n    \n    int n = int(x * inv + 0.5); \n    x -= float(n) * pi_over_six;\n    \n    n = n < 0 ? (n + 12) % 12 : n % 12;\n    //n %= 12; if (n < 0) n += 12;\n\n    float z = x*x, s = 0., c = 0.,\n          s1 = ((z/20.0-1.0)*z/6.0+1.0)*x,\n          c1 = ((z/30.0+1.0)*z/12.0-1.0)*z/2.0+1.0;        \n    \n    switch(n)\n    {\n    case 0:  s =  s1;                        c =  c1;                        break;\n    case 1:  s =  cos_30 * s1 + sin_30 * c1; c = -sin_30 * s1 + cos_30 * c1; break;\n    case 2:  s =  sin_30 * s1 + cos_30 * c1; c = -cos_30 * s1 + sin_30 * c1; break;\n    case 3:  s =  c1;                        c = -s1;                        break;\n    case 4:  s = -sin_30 * s1 + cos_30 * c1; c = -cos_30 * s1 - sin_30 * c1; break;\n    case 5:  s = -cos_30 * s1 + sin_30 * c1; c = -sin_30 * s1 - cos_30 * c1; break;\n    case 6:  s = -s1;                        c = -c1;                        break;\n    case 7:  s = -cos_30 * s1 - sin_30 * c1; c =  sin_30 * s1 - cos_30 * c1; break;\n    case 8:  s = -sin_30 * s1 - cos_30 * c1; c =  cos_30 * s1 - sin_30 * c1; break;\n    case 9:  s = -c1;                        c =  s1;                        break;\n    case 10: s =  sin_30 * s1 - cos_30 * c1; c =  cos_30 * s1 + sin_30 * c1; break;\n    case 11: s =  cos_30 * s1 - sin_30 * c1; c =  sin_30 * s1 + cos_30 * c1; break;\n    }\n    \n    return vec2(s, c);\n}\n\n// Chebyshev approximation tailored for ±45° interval\nfloat mysin2(float x) {\n  assert(x >= -0.78539816 && x <= 0.78539816);\n  float x2 = x*x;\n  float t = 0.0081214934;\n  t = x2*t + -0.16660157;\n  t = x2*t + 0.99999499;\n  t = x*t;\n  return t;\n}\n\nfloat mycos2(float x) {\n  assert(x >= -0.78539816 && x <= 0.78539816);\n  float x2 = x*x;\n  float  t = -0.0013585844;\n  t = x2*t + 0.041655021;\n  t = x2*t + -0.49999857;\n  t = x2*t + 0.99999997;\n  return t;\n}\n\n//#define cos(x) mycos2(x)\n//#define sin(x) mysin2(x)\n#if defined CRENSHAW\n#define cos(x) sincos(x)[1]\n#define sin(x) sincos(x)[0]\n#endif\n\nfloat hud(vec2 fragCoord, float theta) {\n  const int digits = 7;\n  const int nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int column = cellindex.x;\n  int row = cellindex.y;\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  float x;\n  float cost = cos(theta);\n  float mycost = mycos(theta);\n  float sint = sin(theta);\n  float mysint = mysin(theta);\n  float mytant = mysint/mycost;\n  if (column == 0) {\n    if (row == 0) x = theta;\n    else return 0.0;\n  } else if (column == 1) {\n    if (row == 1) x = cost;\n    else if (row == 2) x = mycost;\n    else if (row == 0) x = acos(mycost);\n    else return 0.0;\n  } else if (column == 2) {\n    if (row == 1) x = sint;\n    else if (row == 2) x = mysint;\n    else if (row == 0) x = asin(mysint);\n    else return 0.0;\n  } else if (column == 3) {\n    if (row == 1) x = tan(theta);\n    else if (row == 2) x = mytant;\n    else if (row == 0) x = atan(mytant);\n    else return 0.0;\n  } else {\n    return 0.0;\n  }\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = floatchar(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c < 0) return 0.0;\n  float charstart = charwidth*float(charpos); // character start\n  uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  return t.x;  \n}\n\nbool comp(float y, float r) { return (0.0 < y) == (y < r); }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1e-4;\n  float check = max(0.75,-iTime);\n  if (abs(cos(check)-mycos(check)) < 1e-6) scale = 1e-6;\n  float x = 0.5*PI*(2.0*fragCoord.x-iResolution.x)/iResolution.x;\n  float y = scale * (2.0*fragCoord.y-iResolution.y)/iResolution.y;\n  float r = cos(x) - mycos(x);\n  float s = sin(x) - mysin(x);\n  // The ulps check assumes both values have the same sign.\n  int ulps = floatBitsToInt(cos(x))-floatBitsToInt(mycos(x));\n  vec3 col = vec3(comp(y,r),comp(y,s),comp(y,float(ulps)/float(1<<23)));\n\n  float xmouse = 0.0;\n  if (iMouse.x > 0.0) xmouse = 0.5*PI*(2.0*iMouse.x-iResolution.x)/iResolution.x;\n  col = mix(col,vec3(1),hud(fragCoord,xmouse)); \n  if (alert) col.r = 1.0;  \n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n#define SIGN(x) { if ((x) < 0.0) CHAR(MINUS) else CHAR(SPACE) } \n\n// Format x to digits precision and return the character at cindex,\n// or -1 if cindex is out of range.\nint floatchar(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return -1;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int SPACE = 0x20, ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    SIGN(x);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    // Maybe show the bits\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    SIGN(x);\n    CHAR(ZERO);\n  } else {\n    SIGN(x);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // This is a delicate business if we aren't to\n    // lose too much precision\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have a correctly rounded integer representation together\n    // with the correct exponent. The rest is just formatting.\n\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return -1;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd23Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1489, 1489, 1519, 1519, 1640], [1642, 1642, 1664, 1664, 1686], [1688, 1746, 1769, 1769, 1949], [1951, 1951, 1974, 1974, 2167], [2169, 2169, 2191, 2191, 2318], [2320, 2446, 2468, 2468, 4308], [4310, 4366, 4389, 4389, 4556], [4558, 4558, 4581, 4581, 4765], [4906, 4906, 4946, 4946, 6656], [6658, 6658, 6687, 6687, 6718], [6720, 6720, 6773, 6773, 7487]], "test": "untested"}
{"id": "cs23Dh", "name": "hsvfilterlsw", "author": "lsw", "description": "hsvfilterlsw", "tags": ["image"], "likes": 0, "viewed": 131, "published": 3, "date": "1667550338", "time_retrieved": "2024-07-30T16:22:36.893283", "image_code": "// Color-Space Conversion RGB to HSV written 2015 by Jakob Thomsen\n// https://en.wikipedia.org/wiki/HSL_and_HSV\n\nvec3 RGBtoHSV(vec3 rgb)\n{\n    // Hue: red = 0/6, yellow = 1/6, green = 2/6,\n    //      cyan = 3/6, blue = 4/6, magenta = 5/6\n    vec3 hsv;\n    float cmax = max(rgb.r, max(rgb.g, rgb.b));\n    float cmin = min(rgb.r, min(rgb.g, rgb.b));\n    \n    hsv.z = cmax; // value\n\n    float chroma = cmax - cmin;\n    //if(chroma != 0.0)\n    {\n        hsv.y = chroma / cmax; // saturation\n\n        //if(cmax == rgb.r)\n        if(rgb.r > rgb.g && rgb.r > rgb.b)\n        {\n            hsv.x = (0.0 + (rgb.g - rgb.b) / chroma) / 6.0; // hue\n        }\n        //else if(cmax == rgb.m_Green)\n        else if(rgb.g > rgb.b)\n        {\n            hsv.x = (2.0 + (rgb.b - rgb.r) / chroma) / 6.0; // hue\n        }\n        else\n        {\n            hsv.x = (4.0 + (rgb.r - rgb.g) / chroma) / 6.0; // hue\n        }\n\n        // Make sure hue is in range [0..1]\n        hsv.x = fract(hsv.x);\n    }\n    //else\n    //{\n    //    hsv.x = 0.0; // rnd();\n    //}\n    return hsv;\n}\n\nvec3 HSVtoRGB(in vec3 c) // thanks to iq for this much more compact version!\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 取纹理坐标\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // 取图片纹理像素值\n    vec3 rgb = texture(iChannel0, uv).rgb;\n    // 把纹理像素值转HSV\n    vec3 hsv = RGBtoHSV(rgb);\n\n    // 可修改hsv中的色调、饱和度、明度\n    hsv = vec3(hsv.x, hsv.y, hsv.z);\n    \n    rgb = HSVtoRGB(hsv);\n\tfragColor = vec4(rgb, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs23Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 138, 238, 1063], [1065, 1065, 1143, 1143, 1269], [1271, 1271, 1328, 1351, 1682]], "test": "untested"}
{"id": "csj3Dh", "name": "Graylsw", "author": "lsw", "description": "RGB->Gray", "tags": ["image"], "likes": 0, "viewed": 121, "published": 3, "date": "1667549772", "time_retrieved": "2024-07-30T16:22:37.828782", "image_code": "// 灰度转换函数\nfloat greyScale(in vec3 col) {\n    return dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // 归一化坐标0～1， 作为取纹理用\n    vec3 col = texture(iChannel0, uv).rgb;  // 取图片纹理\n    float grey = greyScale(col);  // 灰度转换\n    col = vec3( grey );  // 一维变三维\n\tfragColor = vec4( col, 1.0 ); // 屏幕颜色输出\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csj3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 52, 52, 105], [107, 107, 164, 164, 464]], "test": "untested"}
{"id": "Dsj3Wh", "name": "3D Medial axis", "author": "scry", "description": "Atempt to extend https://www.shadertoy.com/view/DdX3WH to 3D", "tags": ["3d", "error", "medialaxis"], "likes": 1, "viewed": 174, "published": 3, "date": "1667539648", "time_retrieved": "2024-07-30T16:22:38.702446", "image_code": "//Based off of https://www.shadertoy.com/view/DdX3WH\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n#define pi acos(-1.)\n#define deg pi/180.\n#define time iTime*pi/10.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nvec3 cpos() {\n    vec3 c = vec3(0.,0.,-2.);\n    c.xz *= r2d(deg*40.);\n    c.yz *= r2d(deg*-40.);\n    c.xz *= r2d(sin(time*2.)*0.2-0.1);\n    c.yz *= r2d(cos(time*2.)*0.2-0.1);\n    c.xz *= r2d(time*2.);\n    //c.yz *= r2d(time);\n    return c;\n}\n\nmat4 eye() {\n    vec3 c = cpos();\n    vec3 l = vec3(0.);\n    vec3 f = normalize(l-c);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = cross(f,r);\n    return mat4(r,0.,u,0.,f,0.,vec3(0.),1.);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 q = abs(p)-s;\n    return max(q.z,max(q.x,q.y));\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p = (eye()*vec4(p,1.)).xyz;\n    p += cpos();\n    float d = sdBox(p,vec3(0.5));\n    d = min(d,sdBox(p-vec3(0.4),vec3(0.2)));\n    return vec4(p,d);\n}\n\nvec4 dbmap(vec3 p) {\n    vec3 o = p;\n    p = (eye()*vec4(p,1.)).xyz;\n    p += cpos();\n    float d = map(o).w;\n    \n    \n    //d = min(d,abs(p.z)-0.02);\n    d = abs(p.z)-0.01;\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<30;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 1000. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec2 dbRM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<30;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = dbmap(p).w;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 1000. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\n#define EPS 0.01\nvec3 gradient(vec3 p) {\n    vec2 h = vec2(EPS,0.);\n    return vec3(\n        map(p+h.xyy).w-map(p-h.xyy).w,\n        map(p+h.yxy).w-map(p-h.yxy).w,\n        map(p+h.yyx).w-map(p-h.yyx).w\n    )/EPS/2.;\n}\n\nvec4 vRM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    vec3 col = vec3(0.);\n    for (int i=0;i<420;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += abs(dS*0.004)+EPS/2.;\n        ii += 0.01;\n        vec3 cp = (eye()*vec4(p,1.)).xyz+cpos();\n        vec3 mp = map(p).xyz;\n        float e = map(p+gradient(p)*(-dS)).w;\n        float e_ = map(p+gradient(p)*(dO)).w;\n        float ec = smoothstep(EPS,0.,abs(e));\n        //float ee = smoothstep(0.,0.1,-e_+0.4);\n        //float ee = smoothstep(0.,0.5,-(e_)-e_*dS/dO*0.001);\n        float ee = smoothstep(0.,EPS,0.5-(e_));\n        //col += smoothstep(0.05,0.,abs(fract(mp.x*12.+time)/12.))*ee*0.02-0.003;\n        //col += smoothstep(0.05,0.,abs(mp.x)/abs(dO))*ee*0.02;\n        //col += smoothstep(0.05,0.,abs(dS+(sin(time*10.)*0.25+0.25))-0.01)*ee*0.02;\n        col += ee*clamp(-dS,0.,1.);\n        //col += smoothstep(0.9,0.,abs(fract(mp.x*12.+time)/12.))*ee;\n        if (dO > 1000.) {break;}\n    }\n    //col *= 0.1;\n    //col = col*0.3+sin(vec3(1.9,2.,3.)+col*1.-1.)*0.1+0.5;\n    return vec4(col,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p+h.xyy).w-map(p-h.xyy).w,\n        map(p+h.yxy).w-map(p-h.yxy).w,\n        map(p+h.yyx).w-map(p-h.yyx).w\n    ));\n}\n\n\nvec3 colo(vec3 p, vec3 n, vec2 d, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.);\n    vec2 db = dbRM(ro,rd);\n    vec4 dv = vRM(ro,rd);\n    vec3 pdb = ro+rd*db.x;\n    float dbx = abs(map(pdb).w);\n    //float e = map(pdb+gradient(pdb)*db.x).w;\n    float e = map(p+gradient(p)).w;\n    col += sin(vec3(1.,2.,3.)+d.y*30.-time*2.)*0.1;\n    vec3 vp = ro+rd*dv.w;\n    col *= 0.1;\n    col += dv.xyz;\n    if (d.x > 100.) {\n        col *= 0.05;\n        col += dv.w-4.5;\n    }\n    \n    col += (1.-clamp(d.x*0.1,0.,1.))*0.1;\n\n    //col += 1.-clamp(db.x*0.1,0.,1.);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    col += colo(p,n,d,ro,rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsj3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 298, 298, 347], [350, 350, 363, 363, 591], [593, 593, 605, 605, 799], [801, 801, 830, 830, 889], [891, 891, 909, 909, 1077], [1079, 1079, 1099, 1099, 1277], [1279, 1279, 1306, 1306, 1546], [1548, 1548, 1577, 1577, 1819], [1838, 1838, 1861, 1861, 2037], [2039, 2039, 2067, 2067, 3129], [3131, 3131, 3154, 3154, 3336], [3339, 3339, 3392, 3392, 3905], [3907, 3907, 3962, 3962, 4333]], "test": "untested"}
{"id": "DdS3Wh", "name": "[phreax] lost sentinel", "author": "phreax", "description": "Old creature of mine put in some fractal tunnel (inspired by Nusan)", "tags": ["raymarching", "tunnel", "modeling", "glow", "matrix", "creature"], "likes": 23, "viewed": 321, "published": 3, "date": "1667531523", "time_retrieved": "2024-07-30T16:22:39.642931", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define SIN(x)  (.5+.5*sin(x))\n#define PI 3.141592\n#define PHI 1.618033988749895\n\n\nfloat tt, gl, mat, cid;\nvec3 ro;\n\n\n// from shadertoy user tdhopper\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nvec3 pal(float t) {\n        vec3 cols[] = vec3[](vec3(0.510,0.510,0.510), vec3(0.102,0.675,0.918), vec3(0.427,0.220,1.000), vec3(0.259,1.000,0.443), vec3(1.000,0.220,0.894));\n        return cols[int(t) % cols.length()];\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// iq's impulse function\nfloat impulse2( float x, float k) {\n    \n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat impulse( float x, float k, float e) {\n    \n    float h = k*pow(x, e);\n    return h*exp(1.0-h);\n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse(float x, float k, float e, float period) {\n   \n\treturn impulse(mod(x, period), k, e);\n    \n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse2(float x, float k, float period) {\n   \n\treturn impulse2(mod(x, period), k);\n    \n}\n\n// remap [0,1] -> [a, b])\nfloat remap(float x, float a, float b) {\n    return a*x+b;\n}\n\n\nfloat cyl(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sph(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat cylcap( vec3 p, float r, float h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat ring(vec3 p, float h, float rout, float rin) {\n    return max(cylcap(p, h, rout), -cylcap(p, 2.*h, rin));\n}\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n/*\n\tp = abs(p) - r;\n    return max(p.x, max(p.y, p.z));\n}\n*/\n\nvec2 repeat(vec2 p, vec2 s) {\n   \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat repeat(float p, float s) {\n   \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat sdOctopus(vec3 p) {\n    float s = 0.4;\n    vec3 q = p;\n    \n    \n    q.z = abs(q.z);\n     \n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.25);\n    q.z = abs(q.z);\n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.125);\n    q.z = abs(q.z);\n   \n    q.xz *= rot(-PI*0.25);\n\n    q.xz -= 0.5;\n \n    int maxIter = 20;\n    float d = 1e6;\n    float alpha = remap(continuesPulse((tt), 0.7, 4.0, 5.0), -0.45, 0.15);\n\n    for(int i=1; i < maxIter; i++) { \n        q.xz *= rot(-alpha);\n        q.z-=10./float(maxIter);\n        s -= 0.8/float(maxIter);\n        float b = box(q, vec3(s))-.01;\n        d = min(d, b);              \n    }\n    \n    float head = fIcosahedron(p, .7);\n    \n    d = min(d, head);\n  \n    return d;\n}\n\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0);\n    off.x += sin(p.z*.1)*4.;\n    off.y += sin(p.z*.12)*3.;\n    return off;\n}\n\nvec2 moda(vec2 p, float s) {\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    a = (fract(a/s-.5)-.5)*s;\n    return r*vec2(cos(a), sin(a));\n       \n}\n\nfloat repeat2(inout float p, float size) {\n  float c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvoid cam(inout vec3 p) {\n\tp.z += tt*5.;// + 7.*sin(.1*tt);\n    p -= tunnel(p);\n}\n\nfloat map(vec3 p) {\n\n    vec3 np = p;\n\n    float tunr = 10.;\n    float vrep = 10.;\n    \n    p += tunnel(p);\n   \n    vec3 vvp = p;\n    vvp.z += vrep/2.;\n    cid = 1.+(repeat2(vvp.z, vrep)/vrep)*10.;\n    float octo;\n    \n    {\n    \n        vec3 q = p;\n        float pulse = continuesPulse((tt), 0.7, 3.0, 5.0);\n        float pulse2 = continuesPulse2((tt-1.), 3., 5.0);\n  \n        q.z += 5.;\n        \n        q.z -= remap(pulse, 1.5, 10.0);   \\\n        q.z -= 1.5*tt + tt *remap(pulse2, 0., 3.5);\n                \n       // float oid = repeat2(q.z, 30.);\n        q.xz *= rot(-PI*.5);\n        vec3 o1 = q;\n        vec3 o2 = q;\n\n        o1.xy += vec2(-4.5*sin(tt), 3.3*cos(.4*tt));\n        //o2.x -= 5.0;\n\n        o1.xz *= rot(.4*sin(tt*.4));\n        float s = 1.8;\n        octo = 1./s*sdOctopus(o1/s);\n    }\n\n    vec3 bp = p;\n    vec3 vp = p;\n    vec3 cp = p;\n    vec3 sp = p;\n    \n\t\n    bp.x = atan(p.y, p.x)*30./3.1415;\n    bp.y = length(p.xy)-tunr;\n\n    \n    bp.xz = repeat(bp.xz, vec2(4));\n    bp.xz = abs(bp.xz) - 1.; \n    bp.x -= bp.z*.4;\n     \n    for(float i = 0.; i < 3.; i += 1.) {\n        bp.xz *= rot(tt*.1+cid);\n        //bp.yz *= rot(5.*i);\n      \n        bp.xz = abs(bp.xz) - 1. - .1*SIN(i*tt*.3);\n\n        bp.x += .1;\n \n    }\n      \n    float b = .9*box(bp, vec3(.8));\n\n\n    float dz = abs(ro.z-np.z);\n    float fade = exp(-sqrt(dz)*.4);\n    \n    cp.xy *= rot(.08*p.z);\n    cp.x = abs(cp.x) - 3.;\n    cp.x += sin(0.25*cp.y+sin(tt))*2.;\n    cp.z = repeat(cp.z, 5.);\n    \n    float vid = repeat2(vp.z, vrep);\n    vp.yz *= rot(PI*.5);\n    float veil = ring(vp, max(0., .01), tunr, tunr-.1);\n    \n    float gls = SIN(vid*2.+2.*tt);\n    gl += .018/(.1+pow(abs(veil), 8.));\n    \n    float tun = b;\n    \n   // repeat2(sp.z, vrep);\n    //sp.y -= 9.4;\n    //sp.z -= vrep/2.;\n    //float stone = .3*fIcosahedron(sp, 1.5);\n\n    mat = tun < octo ? 0. : 1.+cid;\n    \n    float d = min(tun, octo);\n    return d;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    tt = 1.5*iTime;\n    \n    vec3 ls = vec3(0, 0, -10.0); // light source\n\tvec3 col = vec3(0);\n    \n    ro = vec3(0, 0, -20);\n    vec3 rd = normalize(vec3(-uv, .7)); \n    \n    vec3 gcol = vec3(0.467,0.706,0.933);\n\n    cam(ro);\n    cam(ls);\n    vec3 p = ro;\n    float d = 0.1;\n    \n    float l_mat = 0.;\n    float l_cid = 0.;\n    \n    float i, t= .1;\n    for(i=0.; i<150.; i++) {\n        d = map(p);\n        \n        if(d < 0.001 || d > 20.) break;\n        \n        p += d*rd;\n        t += d;\n        l_mat = mat;\n        l_cid = cid;     \n    }\n    \n    if(d < 0.001) {\n        vec2 e = vec2(0.0035, -0.0035);\n        \n        vec3 al = pal(l_cid);\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(ls-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4;\n        float ao = calcAO(p, n);\n\n        if(l_mat < 1.) {\n           // gcol = mix(gcol, al, .2);\n            col += pow(i/100., 1.2)*3.*gcol*exp(-t*t*0.001);\n        } else {\n            col +=  .2*spe+.8*al*(.3+.8*dif+1.5*sss) + .2*ao;\n          \n          \n        }\n    }\n    \n    col += 0.08*gl*gcol;\n           \n    col = pow(col, vec3(1.4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdS3Wh.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [], "test": "untested"}
{"id": "ddj3Rm", "name": "Magnification of graph", "author": "Larbagar", "description": "I tried to make a graphing thing then got distracted, and made this cool thing using distortion.", "tags": ["distortion", "zoom", "graphing"], "likes": 3, "viewed": 129, "published": 3, "date": "1667522519", "time_retrieved": "2024-07-30T16:22:40.477699", "image_code": "\n#define PI 3.1415926535897932384626433832795\n#define r1 200\n#define r2 250\n#define zoom 1.5\n#define width 10.\nfloat func(float x){\n    return sin(x/50.)*100.;\n}\nfloat diff(vec2 pos){\n    return abs(pos.y - func(pos.x));\n}\nfloat mouseDown(){\n    return step(0., iMouse.z);\n}\nfloat warpFunc(float len){\n    return float(zoom)+smoothstep(float(r1), float(r2), len/mouseDown())*(1.-float(zoom));//1. + cos(PI*min(len/float(r), 1.)/2.)*(float(zoom) - 1.)*mouseDown();\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 pos = ((fragCoord-0.5*iResolution.xy)/iResolution.y)*2.;\n    //vec2 mousePos = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y)*2.;\n    vec2 pos = fragCoord-iResolution.xy/2.;\n    vec2 mousePos = iMouse.xy - iResolution.xy/2.;\n    float len = length(pos - mousePos);\n    pos = mousePos + (pos - mousePos)/warpFunc(len);//(mousePos - pos)*20.*;\n    \n    vec3 col = vec3(0);\n    \n    //col += texture(iChannel0, pos.xy/500.).rgb;\n    \n    col += smoothstep(width, 0., diff(pos));\n    \n    col.b += smoothstep(0.9, 1., abs(mod(pos.x/100., 1.)*2.-1.))*smoothstep(float(r2), float(r1), len/mouseDown());\n    col.b += smoothstep(0.9, 1., abs(mod(pos.y/100., 1.)*2.-1.))*smoothstep(float(r2), float(r1), len/mouseDown());\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddj3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 131, 131, 161], [162, 162, 183, 183, 222], [223, 223, 241, 241, 274], [275, 275, 301, 301, 465], [466, 466, 523, 664, 1290]], "test": "untested"}
{"id": "mdXGWl", "name": "Gosper Closed Curve", "author": "mla", "description": "The Gosper Curve using a simple stack (jstoring the offset of the \"current instruction\"). Drawing the curve 6 times with extra rotations  in between result in this closed curve. Coloured along path length. Only control is with mouse\nBest full screen..", "tags": ["optimized", "lsystem", "stack", "winding", "gosper"], "likes": 14, "viewed": 225, "published": 3, "date": "1667519924", "time_retrieved": "2024-07-30T16:22:41.404222", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Gosper Closed Curve. mla, 2022.\n//\n// Six Gosper curves joined back to back and coloured.\n\n// Uses an explicit stack to keep track of the recursion.\n// Keeps track of intermediate segments and avoids recursing far from\n// the point being plotted.\n//\n// Mouse down shows segments actually drawn around mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\n// Each instruction is an integer number of turns, followed by\n// either an instruction offset for the recursive call or -1\n// to terminate the current level.\nconst int A = 0, B = 8, END = -1, L = -1, R = 1;\nconst int program[16] =\n  int[] (C(0,A),C(L,B),C(L+L,B),C(R,A), C(R+R,A),C(0,A),C(R,B),C(L,END),\n         C(R,A),C(L,B),C(0,B),C(L+L,B), C(L,A),C(R+R,A),C(R,B),C(0,END));\n\nconst float angle = PI/3.0;\nconst int maxdepth = 4;\n\nvec2 p = vec2(0);       // The drawing point\nvec2 point = vec2(100); // The moving point\nfloat plen = 0.0;       // Cumulative path length\nint wind = 0;           // Winding number here\n\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t >= plen && t < plen+seglen) point = p + (t-plen)/seglen*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\n// Segment rotation at each recursion level - just the net turn the path pattern.\nfloat magic = 0.333473; \n\nvec2 centre = vec2(1.5,0.35);\nvec2 map(vec2 pos) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  //pos = rotate(pos,0.1*iTime);\n  pos *= 4.2;\n  pos -= centre;\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = map(fragCoord);\n  vec2 pos2 = (iMouse.z <= 0.0) ? pos : map(iMouse.xy);\n  int stack[maxdepth];\n  int N = 6;\n  float factor = sqrt(7.0);\n  float totallength = float(N)*factor*pow(factor,float(maxdepth));\n  float t = mod(iTime,totallength); // Moving point\n  float fillhue;\n  float d = 1e8;\n  float theta = 0.0;    // Cumulative angle\n  //N = min(N,int(iTime));\n  for (int i = 0; i < N; i++, theta-=((i&1)==0?0.0:2.0*PI/3.0)){\n    int depth = 0;\n    stack[depth++] = B;//(i&1)==0?A:B;\n    float seglen = 1.0;\n    while (depth > 0) {\n      int instr = program[stack[depth-1]++];\n      int turns = instr>>16;    // Decode instruction\n      int code = instr<<16>>16;\n      theta += float(turns)*angle; // Apply turn\n      if (code == END) {\n        depth--;    // Terminate level & unwind\n        seglen *= factor;\n      } else if (depth == maxdepth) {\n        float d0 = drawsegment(pos,seglen,theta,t); // Segment\n        if (d0 < d) {\n          fillhue = plen/totallength;\n          d = d0;\n        }\n      } else {\n        // The segment is a diagonal of a hexagon off to the left or the right,\n        // so centre is at 30° to the segment, at distance radius of hexagon.\n        float offset = float(maxdepth-depth)*magic; // Segment angle adjustment\n        float sign = code == A ? -1.0 : 1.0;\n        float centreangle = sign*PI/6.0 - offset;\n        float radius = seglen/sqrt(3.0);\n        vec2 centre = p + radius*vec2(cos(theta+centreangle),sin(theta+centreangle));\n        float bound = 1.1*radius; // 1.0 gives some artefacts, 1.05 seems OK. \n        if (distance(pos2,centre) > bound) {\n          // Short circuit this segment\n          vec2 seg = seglen*vec2(cos(theta-offset),sin(theta-offset));\n          polywind(pos,p,p+seg);\n          // Show skipped segments on mouse down.\n          if (iMouse.z > 0.0) d = min(d,segment(pos,p,p+seg));\n          p += seg;\n          plen += seglen*pow(factor,float(maxdepth-depth));\n        } else {\n          stack[depth++] = code;  // Recurse\n          seglen /= sqrt(7.0);\n        }\n      }\n    }\n  }\n  polywind(pos,p,vec2(0));\n  float px = fwidth(pos.x);\n  vec3 col = vec3(0);\n  vec3 fillcol = h2rgb(fillhue+0.00*iTime);\n  if ((wind&1) == 0) col = vec3(1);\n  col = mix(fillcol,col,smoothstep(0.0,px,d-0.01));\n  col = mix(vec3(0), col,smoothstep(0.0,px,distance(pos,point)-0.02));\n  col *= 1.0-smoothstep(0.0,px,distance(pos,vec2(-1.5,-0.35))-4.2);\n  col *= 1.6/(1.0+col);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592654;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb;//\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1173, 1173, 1212, 1247, 1432], [1434, 1434, 1499, 1499, 1729], [1869, 1869, 1889, 1889, 2019], [2021, 2021, 2076, 2076, 4578]], "test": "untested"}
{"id": "msB3Wh", "name": "like a drop falling into water", "author": "jonasfrey", "description": "wavy shit", "tags": ["wave", "water", "drop"], "likes": 2, "viewed": 177, "published": 3, "date": "1667517625", "time_retrieved": "2024-07-30T16:22:42.290851", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 a_n_pixel_coords_norm = fragCoord.xy / iResolution.xy; \n    \n    float n_radius = 1.0;\n    \n    float n_tau = 6.2831;\n    float n_amp = 0.01;\n    vec2 a_n_translation = vec2(0.0,0.0);\n    \n    vec2 a_n_circle = vec2(\n        cos(n_tau*a_n_pixel_coords_norm.x)*n_amp * n_radius + 0.5, \n        sin(n_tau*a_n_pixel_coords_norm.x)*n_amp * n_radius + 0.5\n    ); \n    \n    float n_distance = length((0.5,0.5) - a_n_pixel_coords_norm);\n    n_distance -= mod(iTime*0.1, 1.0);\n    float n_mod_max = 0.2; \n    float n_dist_mod = mod(n_distance, n_mod_max);\n    float n_dist_mod_norm = n_dist_mod / n_mod_max;\n    \n    float n_dist_mod_norm_sin = sin(n_dist_mod_norm*n_tau)*0.5+0.5;\n    \n    fragColor = vec4(1.0-n_dist_mod_norm_sin);\n\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msB3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 809]], "test": "untested"}
{"id": "mdSGWh", "name": "Geometric Vortex", "author": "kishimisu", "description": "Just fiddling around with maths", "tags": ["2d", "sdf", "spiral", "repetition", "rotation", "spin", "layers"], "likes": 22, "viewed": 502, "published": 3, "date": "1667517224", "time_retrieved": "2024-07-30T16:22:43.239315", "image_code": "#define PI       3.141592\n#define S(a,b,d) mix(a, b, sin(d + n*PI*2.)*.5+.5)\n#define rot(a)   mat2(cos( a +vec4(0,33,11,0)))\n#define n        (-iTime*.04+.03)\n\nvoid mainImage(out vec4 O, in vec2 F) {    \n    vec2 u = (F - iResolution.xy*.5)/iResolution.y;\n    for (float s = 0.; s < 3.; s++) { float p = 9.;\n    for (float i = 0.; i < 25.; i++) {\n        vec2  a = fract(rot(i*sin(n*PI*2.)*.25)*u*(i+S(1., 4., PI/2.))+.5)-.5;\n        float r = mix(length(a), abs(a.x) + abs(a.y), S(0., 1.,));\n        float t = abs(r + .1 - s*.02 - i*S(0.005, 0.05,));\n        p = min(p, smoothstep(0., .1 + s*i*S(.0, .015, PI), t*S(s*.1 + .14, .2,)) +\n            smoothstep(0., 20., i*S(.45, 1.,)) + smoothstep(0., 1., length(u)*i*.08));\n    } O[int(s)] = .1/p; \n    } O.a=1.;\n}\n\n// 454 chars by @FabriceNeyret2\n\n// #define S(d) (sin((d+n)*6.28)*.5+.5)\n// #define B smoothstep(0.,\n// void mainImage(out vec4 O, vec2 F) {    \n//     vec2 a=iResolution.xy,u=(F-a*.5)/a.y;   \n//     for(float n=.03-iTime*.04,p,i,t,s=0.;s<3.;O[int(s)]=.1/p,s++)\n//     for(p=9.,i=0.;i<25.;i++)a=abs(fract(mat2(cos(\n//     i*(S()-.5)/2.+vec4(0,33,11,0)))*u*(i+1.+3.*S(.25))+.5)-.5),\n//     p=min(p,B.1+s*i*.015*S(.5),abs(mix(length(a),a.x+a.y,S())\n//     +.1-s*.02-i*.045*(.11+ S()))*(s*.1+.14+.1*(.6-s)*S()))\n//     +B 20.,i*(.45+.55*S()))+B 1.,length(u)*i*.08));\n// }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "csB3D1", "name": "Gnarly colorful apollonian ", "author": "mrange", "description": "CC0: Gnarly colorful apollonian \nThe glow coloring of Fractal doodling: https://www.shadertoy.com/view/ds2GRW\ninspired me to revisit an old shader of mine and spice it up\n", "tags": ["apollonian"], "likes": 68, "viewed": 717, "published": 3, "date": "1667514946", "time_retrieved": "2024-07-30T16:22:44.022222", "image_code": "// CC0: Gnarly colorful apollonian \n// The glow coloring of Fractal doodling: https://www.shadertoy.com/view/ds2GRW\n//  inspired me to revisit an old shader of mine and spice it up\n\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst int   max_iter      = 70;\n \n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2))*2.0 - vec2(1.0);\n  return c;\n}\n\nfloat apollonian(vec3 p, out float ss) {\n  float s = mix(1.4, 1.45, smoothstep(0.9, 1.0, sin(-length(p.xz)+TAU*TIME/10.0))); \n  float scale = 1.5;\n\n  const int rep = 5;\n  mat2 rr = ROT(PI/5.5);\n\n  for(int i=0; i<rep; ++i) {\n    mod1(p.y, 2.0);\n    modMirror2(p.xz, vec2(2.0));\n    p.xz *= rr;\n\n    float r2 = dot(p,p);\n    float k = s/r2;\n    p *= k;\n    scale *= k;\n  }\n  \n  float d = -(box(p - 0.1, vec3(1.0, 2.0, 1.)) - 0.6);\n  ss = scale;\n  return 0.25*d/scale;\n}\n\nvec3 glow(vec3 ro, vec3 rd) {\n  float res;\n  float t = .75;\n  int iter = max_iter;\n\n  vec3 col = vec3(0.0);    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    float ss;\n    res = apollonian(p, ss);\n    col += 0.06*(0.5+0.5*cos(3.0+vec3(1.0, 2.0, 3.0)+0.8*log(ss)))*exp(-0.05*t-.5*res*float(i*i));\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  return col;\n}\n\nvec3 render(vec2 p) {\n  vec3 ro = 1.2*vec3(-1.0, .8, -0.0);\n  ro.xz   *= ROT(TIME/10.0);\n  const vec3 la = vec3(0.0, 1.6, 0.0); \n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return glow(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q; \n  p.x*=RESOLUTION.x/RESOLUTION.y;\n \n  vec3 col = render(p);\n  col -= 0.1*vec3(1.0, 2.0, 0.5);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n\n  fragColor=vec4(col, 1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 514, 541, 541, 628], [630, 716, 755, 755, 880], [882, 968, 1010, 1010, 1172], [1174, 1174, 1214, 1214, 1641], [1643, 1643, 1672, 1672, 2074], [2076, 2076, 2097, 2097, 2427], [2429, 2429, 2484, 2484, 2722]], "test": "untested"}
{"id": "DdS3DR", "name": "Virpropeller No. 1", "author": "virmoesiae", "description": "I just learned about ray marching a few weeks ago and my mind is blow by what can be done with a limited number of lines of code. The best part of it is randomly throwing stuff together, which is exactly what this experimentation is.", "tags": ["raymarching", "reflection", "abstract", "alien", "propeller"], "likes": 22, "viewed": 304, "published": 3, "date": "1667507701", "time_retrieved": "2024-07-30T16:22:44.776206", "image_code": "/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n/*\n    Is this the most optimzed code? Quite the opposite! This is mostly a \n    learning experience.\n*/\n\n// DEFINES -------------------------------------------------------------------//\n\n// Ray marching-related\n#define MAX_STEPS 1000\n#define MAX_DIST 1e3\n#define MIN_DIST 5e-3\n\n// Optical-effect related\n#define N_REFLS 2\n#define SHADW_SHARPN 50\n#define MIN_LIGHT .0125\n\n// Other shader quantities\n#define PERIOD 10.\n#define BCKG_COL vec3(.3+.15*cos(p.x/1000.-iTime/PERIOD))\n\n// Misc\n#define PI 3.141593\n#define TP 2.*PI\n#define OFFSET (10.*MIN_DIST)\n#define VECX vec3(1.,0.,0.)\n#define VECY vec3(0.,1.,0.)\n#define VECZ vec3(0.,0.,1.)\n\n// MISC ----------------------------------------------------------------------//\n\nmat3 rx(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat3(1., 0., 0., 0., ct, -st, 0., st, ct);\n}\nmat3 ry(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat3(ct, 0., st, 0., 1., 0., -st, 0., ct);\n}\nmat3 rz(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat3(ct, -st, 0., st, ct, 0., 0., 0., 1);\n}\nvec3 lattice(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c)-0.5*c;\n}\n\n// PRIMITIVE SIGNED DISTANCE FUNCTIONS (SDFs) AND OPERATIONS -----------------//\n\nfloat SDFSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat SDFBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y,q.z)),0.);\n}\n\nfloat SDFInfColY(vec3 p, vec2 b)\n{\n    vec2 q = abs(p.xz) - b;\n    return length(max(q, 0.)) + min(max(q.x, q.y),0.);\n}\n\nfloat DIntersect(float d0, float d1)\n{\n    return max(d0, d1);\n}\n\nfloat DSmoothIntersect(float d0, float d1, float k)\n{\n    return .5*(d0+d1+sqrt((d0-d1)*(d0-d1)+k));\n}\n\nfloat DUnite(float d0, float d1)\n{\n    return min(d0, d1);\n}\n\nfloat DSmoothUnite(float d0, float d1, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d1-d0)/k, 0.0, 1.0 );\n    return mix(d1, d0, h ) - k*h*(1.0-h);\n}\n\nfloat DSubtract(float d0, float d1)\n{\n    return max(d0, -d1);\n}\n\nfloat DSmoothSubtract(float d0, float d1, float k)\n{\n    return .5*(d0-d1+sqrt((d0+d1)*(d0+d1)+k));\n}\n\n// SURFACE -------------------------------------------------------------------//\n\nstruct Surface\n{\n    float d; // Distance from cast ray origin\n    vec3 c; // Surface color\n    float r; // Surface reflectance\n};\n\nSurface SIntersect(Surface s0, Surface s1)\n{\n    Surface s;\n    if (abs(s0.d) < abs(s1.d))\n        s = s0;\n    else\n        s = s1;\n    s.d = max(s0.d, s1.d);\n    return s;\n}\n\nSurface SSmoothIntersect(Surface s0, Surface s1, float k)\n{\n    float d = DSmoothIntersect(s0.d, s1.d, k);\n    float h = d/s0.d;\n    vec3 c = s1.c*(1.-h) + s0.c*h;\n    float r = mix(s1.r, s0.r, h);\n    return Surface(d, c, r);\n}\n\nSurface SUnite(Surface s0, Surface s1)\n{\n    if (s0.d < s1.d)\n        return s0;\n    return s1;\n}\n\nSurface SSmoothUnite(Surface s0, Surface s1, float k)\n{\n    float h = clamp(.5 + .5*(s1.d-s0.d)/k, 0.0, 1.0 );\n    float d = mix(s1.d, s0.d, h ) - k*h*(1.0-h);\n    vec3 c = s1.c*(1.-h) + s0.c*h;\n    float r = mix(s1.r, s0.r, h);\n    return Surface(d, c, r);\n}\n\nSurface SSubtract(Surface s0, Surface s1)\n{\n    return Surface(max(s0.d, -s1.d), s0.c, s0.r);\n}\n\nSurface SSmoothSubtract(Surface s0, Surface s1, float k)\n{\n    Surface s = s0;\n    s.d = DSmoothSubtract(s0.d, s1.d, k);\n    return s;\n}\n\n// GLOBAL SCENE SDF ----------------------------------------------------------//\n\nSurface sceneSDF(vec3 p)\n{\n    float t = TP*iTime/PERIOD;\n    p = rx(t+.5*p.x)*(p);\n    p.y = abs(p.y)-5.-1.*sin(t);\n    float h = 10.+6.*sin(t/4.);\n    vec3 pb = lattice(p-h*fract(t)*VECX, h*VECX);//*ry(p.y*sin(t));\n    Surface s1 = Surface(SDFInfColY(pb, vec2(.5)), VECX, 0.25);\n    s1.d -= .25;\n    s1.d -= 2.*sin( .5*p.y - t)*(.5+.5*sin(t/4.));\n    Surface s2 = Surface(SDFSphere(p+VECY*(2.), 4.), vec3(1.,.5,0.), .75);\n    s2.d -= .25*sin(5.*p.x+25.*t);\n    Surface pl = Surface(p.y+2., vec3(.6,.3,.15), 0.25);\n    pl.d += .1*sin(p.x*10.+20.*t)+.1*sin(p.z*5.-20.*t);\n    s1 = SSmoothUnite(s1, s2, 4.+2.*sin(2.*t));\n    float x = .5;//1.+.9*sin(t/2.);\n    s1.d -= x;\n    pl = SSmoothSubtract(pl, s1, 0.5);\n    s1.d += x;\n    s1 = SUnite(s1, pl);\n    float m = sin(t)*sin(.5*p.y-5.*t)+cos(t)*sin(0.25*p.x-.5*t);\n    s1.d = DSmoothIntersect(\n        s1.d, \n        SDFBox(p-vec3(0.,0.,0), vec3(MAX_DIST, 6., 3.+2.*m)),\n        0.125\n    );\n    s1.d /= 7.5;\n    return s1;\n}\n\n// RAY MARCHING RELATED ------------------------------------------------------//\n\nstruct Ray \n{\n    vec3 orig; // Ray origin\n    vec3 dir; // Ray direction\n    float af; // Attenuation factor\n    int n; // Number of bounces\n};\n\nRay newRay(vec3 orig, vec3 dir)\n{\n    return Ray(orig, dir, 1., 0);\n}\n\nRay cameraRay(vec2 uv, vec3 cp, vec3 la, float zoom)\n{\n    vec3 f = normalize(la-cp);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f, r));\n    vec3 c = cp + f*zoom;\n    return newRay(cp, normalize(c + uv.x * r + uv.y * u-cp));\n}\n\nSurface rayMarch(Ray ray, out float pn)\n{\n    Surface s;\n    float d, dd, dd0 = MIN_DIST;\n    pn = 1.;\n    for (int iter = 0; iter < MAX_STEPS; iter++)\n    {\n        dd0 = dd; // I am not using dd0 for anything, I know...\n        s = sceneSDF(ray.orig + ray.dir*d);\n        dd = s.d;\n        if (dd > 0. && dd <= MIN_DIST || d >= MAX_DIST)\n            break;\n        pn = min(pn, float(SHADW_SHARPN)*dd/d);\n        d += dd;\n    }\n    s.d = d;\n    return s;\n}\n\nSurface rayMarch(Ray ray) // Overload without penumbra inout\n{\n    float tmp;\n    return rayMarch(ray, tmp);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = sceneSDF(p).d;\n    vec2 e = vec2(OFFSET, 0.);\n    vec3 n = d - vec3\n        (\n            sceneSDF(p-e.xyy).d,\n            sceneSDF(p-e.yxy).d,\n            sceneSDF(p-e.yyx).d\n        );\n    return normalize(n);\n}\n\nfloat getLighting(vec3 p, inout vec3 n)\n{\n    // Light source position\n    vec3 lp = vec3(-.5, 0, -40.);\n    n = getNormal(p);\n    p += n*OFFSET;\n    vec3 dir = normalize(lp-p);\n    float pn;\n    if (rayMarch(newRay(p, dir), pn).d < length(lp-p))\n        return MIN_LIGHT;\n    return max(abs(dot(n, dir)*pn), MIN_LIGHT);\n}\n\nvoid propagate(inout Ray ray, inout vec3 col)\n{\n    // If the ray is fully attenuated, stop propagating\n    if (ray.af == 0.)\n        return;\n    Surface s = rayMarch(ray);\n    vec3 p = ray.orig + ray.dir*s.d;\n    //ray.af *= exp(s.d);\n    vec3 lCol, n;\n    lCol = BCKG_COL;\n    if (s.d < MAX_DIST)\n        lCol = max(getLighting(p, n), 0.)*s.c;\n    // If at the last reflection, set reflectance of hit surface to 0\n    // so it is rendered as fully opaque\n    s.r *= float(ray.n<N_REFLS);\n    // Cumulate col\n    col += lCol*ray.af*(1.0-s.r);\n    // Adjust attenuation by currently hit surface and prepare for next\n    // propagation\n    ray.af *= s.r;\n    if (ray.af != 0.)\n    {\n        ray.orig = p+n*OFFSET;\n        ray.dir = reflect(ray.dir, n);\n    }\n    ray.n++;\n}\n\nvec3 render(Ray r)\n{\n    // Base pass\n    vec3 col = vec3(0.);\n    propagate(r, col);\n    // Reflection passes\n    for (int i = 0; i < N_REFLS; i++)\n    {\n        propagate(r, col);\n    }\n    col = pow(col, vec3(.4545));\n    return col;\n}\n\n// MAIN ----------------------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Camera position, look-at point and resulting ray\n    float t = TP*iTime/PERIOD;\n    vec3 cp = vec3(-25.*sin(t/2.), 1., -25.);\n    vec3 la = vec3(0., 0., 0.);\n    Ray ray = cameraRay(uv, cp, la, 1.);\n    // Render pixel\n    fragColor = vec4(render(ray),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdS3DR.jpg", "access": "api", "license": "libpng", "functions": [[2000, 2000, 2018, 2018, 2120], [2121, 2121, 2139, 2139, 2241], [2242, 2242, 2260, 2260, 2361], [2362, 2362, 2392, 2392, 2428], [2512, 2512, 2546, 2546, 2572], [2574, 2574, 2604, 2604, 2695], [2697, 2697, 2731, 2731, 2816], [2818, 2818, 2856, 2856, 2882], [2884, 2884, 2937, 2937, 2986], [2988, 2988, 3022, 3022, 3048], [3050, 3050, 3099, 3099, 3197], [3199, 3199, 3236, 3236, 3263], [3265, 3265, 3317, 3317, 3366], [3582, 3582, 3626, 3626, 3756], [3758, 3758, 3817, 3817, 3986], [3988, 3988, 4028, 4028, 4085], [4087, 4087, 4142, 4142, 4346], [4348, 4348, 4391, 4391, 4443], [4445, 4445, 4503, 4503, 4581], [4665, 4665, 4691, 4691, 5640], [5870, 5870, 5903, 5903, 5939], [5941, 5941, 5995, 5995, 6202], [6204, 6204, 6245, 6245, 6662], [6664, 6664, 6726, 6726, 6774], [6776, 6776, 6800, 6800, 7028], [7030, 7030, 7071, 7100, 7352], [7354, 7354, 7401, 7457, 8126], [8128, 8128, 8148, 8165, 8366], [8450, 8450, 8507, 8507, 8832]], "test": "ok"}
{"id": "DdBGW1", "name": "sin(x*x)+sin(y*y)", "author": "kanayuki", "description": "sin(x*x)+sin(y*y)", "tags": ["2d", "sinxxsinyy"], "likes": 3, "viewed": 154, "published": 3, "date": "1667506235", "time_retrieved": "2024-07-30T16:22:45.754591", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.x*7.0;\n\n    vec3 col = vec3(0.75);\n    float v = sin(pow(uv.x, 2.0)) + sin(pow(uv.y, 2.0));\n    bool b = abs(v-2.0*sin(iTime/3.0))<0.1;\n    if (b){\n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 472]], "test": "untested"}
{"id": "cdB3Dh", "name": "sine on a sine mouse", "author": "jonasfrey", "description": "sine on a sine\ndrag the mouse", "tags": ["sine"], "likes": 1, "viewed": 165, "published": 3, "date": "1667505569", "time_retrieved": "2024-07-30T16:22:46.850660", "image_code": "const float n_tau = 6.28318530;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_frag_coord_norm = fragCoord.xy / iResolution.xy;\n    vec2 a_n_mouse_coord_norm = iMouse.xy / iResolution.xy;\n    \n    float n = 0.0; \n    float n_amp = 0.4;\n    float n_freq_1 = a_n_frag_coord_norm.x*n_tau; \n    float n_y = \n        sin(n_freq_1)*n_amp\n        +(0.5);\n\n    float n_freq_2 = \n        a_n_frag_coord_norm.x*n_tau*\n        a_n_mouse_coord_norm.x*20.0;\n\n    n_y += sin(n_freq_2)*0.1;\n    float n_distance = length(\n        vec2(\n           a_n_frag_coord_norm.x, \n           n_y\n        )\n        -\n        a_n_frag_coord_norm\n    ); \n    \n    fragColor = vec4(1.0-n_distance*20.0);\n    \n        // mirror it \n    if(a_n_frag_coord_norm.x>0.5){\n        fragColor = vec4(1.0) - fragColor;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdB3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 90, 90, 817]], "test": "untested"}
{"id": "DsB3Dh", "name": "sin(x)+sin(y)", "author": "kanayuki", "description": "sin(x)+sin(y)", "tags": ["2d", "sinxsiny"], "likes": 1, "viewed": 130, "published": 3, "date": "1667505069", "time_retrieved": "2024-07-30T16:22:47.790148", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 20.0*(2.0*fragCoord-iResolution.xy)/iResolution.x;\n\n    vec3 col = vec3(0.75);\n    float v = sin(uv.x)+sin(uv.y);\n    bool b = abs(v-2.0*sin(iTime/3.0))<0.1;\n    if (b){\n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsB3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 451]], "test": "untested"}
{"id": "DdSGWh", "name": "The wall of speakers", "author": "yasuo", "description": "The wall of speakers\n\nsound:\nminutesunlimited\nhttps://soundcloud.com/minutesunlimited\n\n", "tags": ["graphicdesign", "cineshader"], "likes": 89, "viewed": 8630, "published": 3, "date": "1667496681", "time_retrieved": "2024-07-30T16:22:48.694729", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\n// tweaked as the center aligned horizontal capsule. \nfloat sdHorizontalCapsule( vec3 p, float w, float r )\n{\n  p.x-= clamp( p.x, -w*0.5, w*0.5 );\n  return length( p ) - r;\n}\n\nfloat speaker(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p, vec3(0.45,0.95,0.34))-0.03;\n    float d2 = length(p-vec3(0.,-0.2,-0.53))-0.38;\n    \n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.,-0.2,-0.36),vec2(0.36,0.03));\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.,-0.2,-0.32),vec2(0.32,0.025));\n    d = min(d,d2);\n    d2 = length(p-vec3(0.,-0.25,-0.08))-0.12;\n    d = min(d,d2);\n    \n    d2 = sdHorizontalCapsule(p-vec3(0.,-0.75,-0.36),0.6,0.06);\n    d = max(-d2,d);\n    \n    d2 = length(p-vec3(0.,0.55,-0.36))-0.2;\n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.,0.55,-0.36),vec2(0.2,0.03));\n    d = min(d,d2);\n    \n    p.z-=-0.36;\n    p.x = abs(p.x)-0.4;\n    p.y = abs(p.y)-0.9;\n    d2 = length(p)-0.03;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat speaker2(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p, vec3(0.95,0.45,0.34))-0.03;\n    float d2 = sdBox(p-vec3(0.,0.,-0.35), vec3(0.9,0.4,0.01))-0.03;\n    d = max(-d2,d);\n    \n    p.x = abs(p.x);\n    d2 = length(p-vec3(0.4,0.,-0.5))-0.36;\n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.4,0.,-0.3),vec2(0.34,0.03));\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.4,0.,-0.29),vec2(0.3,0.025));\n    d = min(d,d2);\n    d2 = length(p-vec3(0.45,0.,-0.08))-0.1;\n    d = min(d,d2);\n    \n    p.z-=-0.3;\n    p.x = abs(p.x)-0.86;\n    p.y = abs(p.y)-0.36;\n    d2 = length(p)-0.03;\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat speaker3(vec3 p){\n    vec3 prevP = p;\n    float d = sdBox(p, vec3(0.95,0.95,0.34))-0.03;\n    \n    float d2 = length(p-vec3(0.0,0.,-0.68))-0.66;\n    d = max(-d2,d);\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.35),vec2(0.64,0.05));\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.33),vec2(0.6,0.045));\n    d = min(d,d2);\n    \n    d2 = length(p-vec3(0.0,0.,0.1))-0.2;\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.3),vec2(0.56,0.035));\n    d = min(d,d2);    \n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.24),vec2(0.52,0.035));\n    d = min(d,d2);        \n        \n    d2 = sdTorus(p-vec3(0.0,0.,-0.19),vec2(0.47,0.035));\n    d = min(d,d2);  \n    \n    d2 = abs(length(p.xy)-0.73)-0.07;\n    d = min(d,max((abs(p.z)-0.38),d2));\n    \n    p.z-=-0.37;\n    p.x = abs(p.x)-0.86;\n    p.y = abs(p.y)-0.86;\n    d2 = length(p)-0.03;\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.z-=-0.37;\n    p.xy = DF(p.xy,3.0);\n    p.xy -= vec2(0.52);\n    d2 = length(p)-0.03;\n    d = min(d,d2); \n    \n    p = prevP;\n    p.xy*=Rot(radians(sin(iTime)*120.));\n    p.z-=-0.37;\n    p.y=abs(p.y)-0.93;\n    d2 = Tri(p.xy,vec2(0.08),radians(45.));\n    d = min(d,max((abs(p.z)-0.02),d2));    \n    \n    p = prevP;\n    p.xy*=Rot(radians(90.+sin(iTime)*120.));\n    p.z-=-0.37;\n    p.y=abs(p.y)-0.93;\n    d2 = Tri(p.xy,vec2(0.08),radians(45.));\n    d = min(d,max((abs(p.z)-0.02),d2));      \n    \n    return d;\n}\n\nfloat changeSpeakers(vec3 p, float start, float speed){\n    vec3 prevP = p;\n    float endTime = 3.;\n    float t = iTime*speed;\n    float scenes[3] = float[](0.,1.,2.);\n    for(int i = 0; i<scenes.length(); i++){\n        scenes[i] = mod(scenes[i]+start,endTime);\n    }\n    \n    float scene = scenes[int(mod(t,endTime))];\n    \n    float d = 10.;\n    if(scene<1.) {\n        p.x=abs(p.x)-0.5;\n        d = speaker(p);\n    } else if (scene >= 1. && scene<2.){\n        p.y=abs(p.y)-0.5;\n        d = speaker2(p);\n    } else {\n        d = speaker3(p);\n    }\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.y -=iTime*0.5;\n    vec2 id = floor(p.xy*0.5);\n    p.z-=3.;\n    p.xy = mod(p.xy,2.0)-1.0;\n\n    id*=.5;\n    float rand = Hash21(id);\n    \n    float d = 10.;\n    p.z-=rand*0.3;\n    if(rand<0.3) {\n        d = changeSpeakers(p,1.,0.5+rand);\n    } else if(rand>=0.3 && rand<0.7) {\n        d = speaker3(p);\n    } else {\n        p.x=abs(p.x)-0.5;\n        d = speaker(p);\n    }\n    \n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.3));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.5);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float scene = mod(iTime,15.);\n        float rotY = -10.;\n        float rotX = 0.;\n        if(scene>=5. && scene<10.){\n            rotY = 0.;\n            rotX = -30.;\n        } else if(scene>=10.){\n            rotY = 0.;\n            rotX = 30.;\n        }\n        \n        ro.yz *= Rot(radians(rotY));\n        ro.xz *= Rot(radians(rotX));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 30062, "src": "https://soundcloud.com/minutesunlimited/violation-twanz-nola-bounce-flip", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 562, 562, 652], [654, 712, 745, 745, 814], [816, 874, 905, 905, 996], [998, 1110, 1165, 1165, 1230], [1232, 1232, 1254, 1254, 2000], [2002, 2002, 2025, 2025, 2633], [2635, 2635, 2658, 2658, 4024], [4597, 4597, 4619, 4619, 5048], [5050, 5050, 5108, 5108, 5375], [5377, 5377, 5401, 5401, 5602], [5604, 5604, 5646, 5646, 5841], [5843, 5884, 5933, 5933, 6227], [6229, 6229, 6286, 6286, 6907], [6909, 6909, 6968, 6968, 7031], [7033, 7033, 7090, 7090, 8129]], "test": "untested"}
{"id": "ds2GDz", "name": "Logistic Map bifurcation tree", "author": "kanayuki", "description": "Logistic Map bifurcation tree\nMathematica notebook：https://github.com/kanayuki/Mathematica/blob/master/%E5%88%86%E5%BD%A2%E5%92%8C%E6%B7%B7%E6%B2%8C/Logistics%20Equation.nb\n\nhope you like it!", "tags": ["2d", "logisticmapbifurcationtree"], "likes": 1, "viewed": 161, "published": 3, "date": "1667493051", "time_retrieved": "2024-07-30T16:22:49.603300", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = 2.0 * fragCoord/iResolution.x;\n    \n    vec3 col = vec3(0.75);\n    \n    float a = uv.x + 2.0;\n    float y = uv.y;   \n    float x = 0.1;\n\n    for(int j = 0; j < 250; j++) x=a*x*(1.0-x);\n\n    for(int j = 0; j < 100; j++){\n\n        x = a*x*(1.0-x);\n\n        // plotPointAt( a, y );\n        if (abs(y-x) < 0.003){\n        \n            // Time varying pixel color\n            col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n            // vec3 col = vec3(0.1);\n            fragColor = vec4(col,1.0);\n            return;\n        }\n    }\n     \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2GDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 150, 762]], "test": "untested"}
{"id": "msjGzw", "name": "Walk Like an Egyptian", "author": "XT95", "description": "It was kind of funny to make !", "tags": ["cartoon", "parallax", "toon", "pyramid", "desert", "dune"], "likes": 53, "viewed": 687, "published": 3, "date": "1667477799", "time_retrieved": "2024-07-30T16:22:50.563733", "image_code": "#define sunpos vec2(.5,.25)\n\nfloat clouds(vec2 uv) {\n    uv.x += iTime*.001;\n    float d = fbm( vec3(uv*vec2(4.,10.)*1.1+50., iTime*.01) );\n    d += abs(cos(uv.x*70.)*.5 + cos(uv.x*160.)*.25)*0.07;\n    d += uv.y-1.;\n    return d+.2;\n}\n\nvec4 background(vec2 uv, vec2 p) {\n    vec4 col = vec4(0., 0., 0., 1.);\n    \n    // greenish sky\n    col.rgb = pow( vec3(.5), vec3(5., 2.5*uv.y, 2.*(uv.y*-.1+1.)) );\n    \n    // clouds\n    float c = smoothstep(0.3,.32,clouds(uv));\n    float cs = smoothstep(0.3,.32, clouds(uv - normalize(p-sunpos)*.015));\n    col.rgb += vec3(.5,.4,.3) * c * (1.-cs);\n    col.rgb += vec3(.5,.4,.3)*.75 * c * (cs);\n    \n    // stars\n    col.rgb += vec3(1.) * smoothstep(0.8,1., noise(vec3(uv*300., iTime*.1))) * (1.-c);\n    \n    \n    // sun\n    float d = distance(p, sunpos);\n    col.rgb += vec3(1.) * smoothstep(0.16,.15,d);\n    col.rgb += vec3(1.,1.,.5) * pow(1./(1.+d), 8.)*1.;\n    \n    return col;\n}\n\nvec4 pyramids(vec2 p, float freq, float proba) {\n    vec4 col = vec4(0., 0., 0., 0.);\n\n    float seed = floor(p.x*freq-.5);\n    float h = fract(p.x*freq);\n    float d = -p.y + abs(h-.5)/freq * step(proba,hash1(seed));\n    float m = smoothstep(0.,0.01,d) ;\n    \n    float ds = -p.y + saturate(h-.5)/freq * step(proba,hash1(seed));\n    float ms = smoothstep(0.,0.01,ds) ;\n    \n    col.rgb = vec3(1.,.5,.0) * smoothstep(0.6,.5, fbm(p*vec2(10.,100.)*freq));\n    col.rgb = mix(col.rgb, vec3(1.,.5,.0)*.3, ms);\n    \n    col.rgb *= smoothstep(0.,0.015, abs(d-0.005)); // outline\n    \n    col.rgb = saturate(col.rgb);\n    \n    col.a = max(m, ms);\n    \n    return col * col.a;\n}\n\nfloat moutainsHeight(vec2 p, float amp, float power) {\n    float d = - pow(abs(sin(p.x*5.)*.5+ sin(p.x*2.+2.5)*.25 + sin(p.x*4.+2.)*.125), power) * amp;\n    return d;\n}\n\nvec4 mountains(vec2 p, float amp, float power) {\n    vec4 col = vec4(0., 0., 0., 0.);\n    \n    float h = -p.y + moutainsHeight(p,amp,power);\n    float hs = -p.y +moutainsHeight(p + normalize(p-(sunpos*2.-1.))*.05,amp,power);\n    float d = smoothstep(0.,0.01,h);\n    float ds = smoothstep(0.,0.01,hs);\n    \n    col = vec4(1.,1., 1., 1.) * d;\n    col.rgb *= vec3(1.,.4,.2)*(smoothstep(0.,-1.,ds-d)*.75+.25);\n    col.rgb *= smoothstep(0.,0.02,abs(h-.01)); // outline\n    //col.rgb *= (sin(d*50.+fbm(p*vec2(5.,50.)))*.5+.5)*.5+.5;\n    col.rgb = saturate(col.rgb);\n    return col * col.a;\n}\n\nvec4 cactus(vec2 p, float freq) {\n\n    vec4 col = vec4(0., 0., 0., 0.);\n    \n    \n    vec2 ip = floor(p*freq);\n    vec2 fp = fract(p*freq)-.5;\n    float seed = hash1(ip.x);\n    fp.y = p.y*2. + (seed)*.4;\n    \n    if (hash1(ip.x+1000.) > .3) {\n        return vec4(0.);\n    }\n    \n    float d = line(fp, vec2(0.,-.3), vec2(0.,.3));\n        \n    if (hash1(ip.x+100.) > .5) {\n        fp.x = -fp.x;\n    }\n    \n    if (seed > .25) {\n        d = min(d, line(fp, vec2(0.,0.), vec2(0.3,.0))*1.8);\n        d = min(d, line(fp, vec2(0.3,0.015), vec2(0.3,.2))*1.3);\n    }\n    \n    d = min(d, line(fp, vec2(0.,-.15), vec2(-0.3,-.15))*1.8);\n    d = min(d, line(fp, vec2(-0.3,-.14), vec2(-0.3,.05))*1.3);\n    d = d-p.y*.3 - fbm(p*300.+5.)*.005;\n    \n    \n    col = vec4(vec3(0.4,1.,0.)*.5 * (smoothstep(0.5,.6, fbm(p*vec2(300.,5.)+5.)*.5+.5)*.25+.75), smoothstep(0.1,0.09,d));\n    \n    col.rgb *= vec3(1.) * smoothstep(0.007,0.012, abs(d-.098)); // outline\n    \n    return col * col.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 pp = p;\n    \n    \n    // background\n    vec4 col = background(uv, pp);\n    \n    \n    // layers\n    #define LAYER_SPEED 0.05\n    #define LAYER_COUNT 8\n    vec4 layer[LAYER_COUNT];\n    p.x += iTime*LAYER_SPEED;    layer[0] = mountains(p*vec2(.5,3.)-vec2(0.,.3), .75, 1.2) * vec4(vec3(.25),1.);\n    p.x += iTime*LAYER_SPEED;    layer[1] = pyramids(p-vec2(0.,-.4), 1., .6);\n    p.x += iTime*LAYER_SPEED;    layer[2] = pyramids(p-vec2(0.,-.39), .5, .6);\n    p.x += iTime*LAYER_SPEED;    layer[3] = mountains(p*vec2(.25,2.25)-vec2(10.,-0.5), 1., 1.2);\n    p.x += iTime*LAYER_SPEED;    layer[4] = cactus(p*1.5-vec2(0.,-.7),3.)*1.;\n    p.x += iTime*LAYER_SPEED;    layer[5] = mountains(p*vec2(.25,2.)-vec2(0.,-0.6), 1., 1.2);\n    p.x += iTime*LAYER_SPEED;    layer[6] = mountains(p*vec2(.15,2.)-vec2(1000.,-0.7), 1., 1.2);\n    p.x += iTime*LAYER_SPEED;    layer[7] = cactus(p*.2-vec2(0.,-.0),3.);\n    \n    // merge layers with alpha premultiplied\n    for(int i=0; i<LAYER_COUNT; i++) {\n        col.rgb = col.rgb * (1.-layer[i].a) + layer[i].rgb * (2./(pow(float(i),2.5)+1.));\n    }\n    \n    // flare\n    float d = distance(pp, sunpos);\n    col.rgb += vec3(1.,1.,.5) * pow(1./(1.+d), 3.)*.1;\n    \n    \n    // color grading\n    col.rgb = pow(col.rgb, vec3(1.0,1.5,1.3));\n    \n    // vignetting\n    col.rgb *= pow( uv.x*uv.y*(1.-uv.x)*(1.-uv.y)*100., .1);\n\n    // gamma correction\n    col.rgb = pow(col.rgb, vec3(1./2.2));\n    \n    // output to the screen\n    fragColor = vec4(col.rgb * smoothstep(0.,3., iTime),1.0);\n}\n", "image_inputs": [], "common_code": "#define PI 3.14159265\n#define saturate(x) clamp(x,0.,1.)\n\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nfloat fbm(vec2 p) {\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(p);\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n\treturn a;\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n                      \nfloat fbm(vec3 p) {\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(p);\n        a += b*n;\n        b *= s;\n        p = f*m3*p;\n    }\n\treturn a;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 52, 52, 234], [236, 236, 270, 270, 921], [923, 923, 971, 971, 1592], [1594, 1594, 1648, 1648, 1762], [1764, 1764, 1812, 1812, 2349], [2351, 2351, 2384, 2384, 3322], [3325, 3325, 3382, 3382, 5041]], "test": "untested"}
{"id": "cd2GDz", "name": "Large Mountains Erosion Terrain", "author": "Hatchling", "description": "Using \"Fuzzy Signed Distance Fields\" over a perlin noise heightmap, one can easily generate highly detailed and natural looking erosion with branching rivers and cliffs!\nDiscovered by accident!\n\nRaymarch borrowed from https://www.shadertoy.com/view/MlGBD1", "tags": ["procedural", "terrain", "distance", "field", "signed", "erosion"], "likes": 74, "viewed": 1468, "published": 3, "date": "1667474431", "time_retrieved": "2024-07-30T16:22:51.706676", "image_code": "float maxHeight()\n{\n    return 500.0 / iChannelResolution[0].x;        \n}\n\nfloat precis()\n{\n    return 1.5 / iChannelResolution[0].x;        \n}//\n\n\nvec3 worldToTerrain(vec3 p)\n{\n    p.x /= iChannelResolution[0].x / iChannelResolution[0].y;\n    p.xz += 0.5;\n    p.y /= maxHeight();\n    return p;\n}\n\nvec3 terrainToWorld(vec3 p)\n{\n    p.y *= maxHeight();   \n    p.xz -= 0.5;\n    p.x *= iChannelResolution[0].x / iChannelResolution[0].y;\n    return p;\n}\n\nfloat terrain(vec2 p){\n\n    p.x /= iChannelResolution[0].x / iChannelResolution[0].y;\n    \n    p += 0.5;\n    \n\n    \n    if(clamp(p,0.0,1.0) != p) return 0.;\n    \n    vec4 t = texture(iChannel0, p);\n    return t.r / t.a * maxHeight();\n}\n\nvec2 calculate_curvature(vec3 p)\n{    \n    float height_mod = 1.;\n    float prec = precis();\n    float heightC = terrain(p.xz)*height_mod;\n    \n    vec3 posC = vec3(p.x, heightC, p.z);\n    vec3 posR = p + vec3(prec, 0.0,  0.0);\n    vec3 posL = p - vec3(prec, 0.0,  0.0);\n    vec3 posT = p + vec3( 0.0, 0.0, prec);\n    vec3 posB = p - vec3( 0.0, 0.0, prec);\n    \n    posR.y = terrain(posR.xz)*height_mod;\n    posL.y = terrain(posL.xz)*height_mod;\n    posT.y = terrain(posT.xz)*height_mod;\n    posB.y = terrain(posB.xz)*height_mod;\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    vec3 normal = normalize(cross(dx, dy));\n    \n    float curveX = -dot(posC + posC - posR - posL, normal);\n    float curveY = -dot(posC + posC - posT - posB, normal);\n    \n    return vec2(curveX, curveY) / prec;\n}\n\nvec3 calculate_normal(vec3 p)\n{    \n    float height_mod = 1.;\n    float prec = precis();\n    float heightC = terrain(p.xz)*height_mod;\n    \n    vec3 posC = vec3(p.x, heightC, p.z);\n    vec3 posR = p + vec3(prec, 0.0,  0.0);\n    vec3 posL = p - vec3(prec, 0.0,  0.0);\n    vec3 posT = p + vec3( 0.0, 0.0, prec);\n    vec3 posB = p - vec3( 0.0, 0.0, prec);\n    \n    posR.y = terrain(posR.xz)*height_mod;\n    posL.y = terrain(posL.xz)*height_mod;\n    posT.y = terrain(posT.xz)*height_mod;\n    posB.y = terrain(posB.xz)*height_mod;\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    return -normalize(cross(dx, dy));\n}\n\nbool pointTerrain(vec3 p){\n    return terrain(p.xz) >= p.y;\n}\n\nvec3 skybox(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    gradient *= gradient;\n    gradient *= gradient;\n   \n    gradient = 1.-gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient = 1.-gradient;\n    \n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    \n    return color;\n}\n\nvec3 skyboxBlurry(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    \n    \n   \n    //gradient *= gradient;\n   ;\n    gradient = 1.-gradient;\n    gradient *= gradient * gradient;\n    gradient = 1.-gradient;\n    \n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    \n    return color;\n}\n\nvec3 castRayTerrain2(vec3 camPos, vec3 camDir){\n    bounds b;\n    b.mini = terrainToWorld(vec3(0));\n    b.maxi = terrainToWorld(vec3(1));\n    \n    vec3 near, far;\n    if(!rayIntersectBounds(b, camPos, camDir, near, far))\n    {\n        return skybox(camDir);\n    }\n    \n    vec3 p = near;\n    float minD = 0.0, maxD = 1.0;\n    bool hit = false;\n    for(float i=0.; i<=1.; i+=.005)\n    {\n        float j = i*i;\n    \tp = mix(near, far, j);\n        \n        maxD = j;\n        \n        \n        if(pointTerrain(p))\n        {\n            hit = true;\n            break;\n        }\n        \n        minD = j;\n    }\n    \n    if(!hit) return skybox(camDir);\n\n    maxD = (minD + maxD) * 0.5;\n    float stepSize = (maxD - minD) * 0.5;\n\n    for(int i = 0; i < 5; i++, stepSize *= 0.5)\n    {\n    \tp = mix(near, far, maxD);\n        if(!pointTerrain(p))\n        {\n            minD = maxD;\n            maxD += stepSize;\n        }\n        else\n        {\n            maxD -= stepSize;\n        }\n    }\n    \n    \n    vec3 normal = calculate_normal(p);\n    vec2 curve2 = calculate_curvature(p);\n    \n    vec2 posCurve2 = max(vec2(0), curve2);\n    vec2 negCurve2 = -min(vec2(0), curve2);\n    \n    float posCurve = posCurve2.x + posCurve2.y;\n    posCurve = posCurve / (0.2 + posCurve);\n    float negCurve = negCurve2.x + negCurve2.y;\n    negCurve = negCurve / (0.2 + negCurve);\n    float curve = (curve2.x + curve2.y);\n    curve = curve / (0.2 + abs(curve));\n    \n    p = vec3(p.x, terrain(p.xz), p.z);\n\n    vec3 lightDir = normalize(vec3(0, 3, 5));\n    vec3 lightColor = max(0.0,dot(normal, lightDir)) * vec3(1.0, 0.75, 0.5) * 2.0;\n    \n    vec3 ambientDir = vec3(0, 1, 0);\n    float ambient = dot(normal, ambientDir) * 0.5 + 0.5;\n    ambient *= ambient;\n    //ambient *= ambient;\n    //ambient *= ambient;\n    ambient *= curve * 0.5 + 0.5;\n    vec3 ambientColor = ambient * skyboxBlurry(normal);\n    \n    vec3 totalDiffuse = ambientColor + lightColor;\n\n    vec3 eyeDir = normalize(camPos-p);\n    vec3 reflec = reflect(-lightDir, normal);\n    float spec = max(0.0,dot(eyeDir, reflec));\n    spec = pow(spec*1.01, 100.);// * 10.;\n\n    vec3 albedo  = vec3(1.);\n    \n    float slopeFactor;\n    float heightFactor;\n    {\n        heightFactor = p.y / maxHeight();\n        \n        heightFactor = smoothstep(0., 1., heightFactor);        \n        heightFactor = smoothstep(0., 1., heightFactor);\n        \n        slopeFactor = abs(normal.y);\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        \n        vec3 flatLow = vec3(0.1, 0.4, 0.05);\n        vec3 flatHigh = vec3(0.7, 0.7, 0.5);\n        \n        vec3 slopeLow = vec3(0.4, 0.7, 0.2);\n        vec3 slopeHigh = vec3(0.3, 0.2, 0.05);\n        \n        vec3 flatColor = mix(flatLow, flatHigh, heightFactor);\n        vec3 slopeColor = mix(slopeLow, slopeHigh, heightFactor);\n        \n        albedo = mix(slopeColor, flatColor, slopeFactor);\n    }\n    \n    albedo = mix(albedo, (albedo*1.0+vec3(0.75))*vec3(0.7,0.65,0.3), posCurve); \n    \n    // Add rivers.\n    float rivers;\n    {\n        rivers = max(0.,negCurve - posCurve);\n        \n        rivers = pow(rivers, pow(2., mix(0.5, -0.7, slopeFactor) + mix(-0.7, 0.7, heightFactor)));   \n\n        //rivers = pow(rivers, heightFactor + 1.0);   \n        //rivers = pow(rivers, heightFactor*3.+0.5);         \n        \n        rivers = smoothstep(0., 1., rivers);\n        rivers = smoothstep(0., 1., rivers);\n        \n        //rivers = 1.-rivers;\n        //rivers *= rivers;\n        //rivers = 1.-rivers;\n        \n        albedo = mix(albedo, vec3(0.1,0.2,0.5), rivers); \n    }\n\n    albedo *= albedo;\n\n    //albedo = mix(albedo, curve > 0.0 ? vec3(1,0.7,0.3) : vec3(0.3,0.7,1), vec3(abs(curve))); \n\n    float specMult = 0.0;\n    specMult = mix(specMult, 0.5, posCurve);//length(color)*length(color)*0.2;\n    specMult = mix(specMult, 1.5, rivers);//length(color)*length(color)*0.2;\n\n    vec3 color = albedo*totalDiffuse + lightColor*spec*specMult;\n    \n    float fogDist = dot(p - camPos, p - camPos);\n    \n    color = mix(skybox(camDir), color, pow(vec3(0.98), fogDist * vec3(0.1,0.4,2.))); \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camRay = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.yy, 1));\n    vec3 camPos = vec3(0.0, maxHeight() * 1.0, -1.0);\n    \n    vec3 lookDir = vec3(0, maxHeight() * 0.0, 0) - camPos;\n    \n    quaternion pan = FromAngleAxis(vec3(0, iTime * 0.125, 0));\n    quaternion tilt = FromToRotation(vec3(0,0,1), lookDir);\n    \n    camPos = mul(pan, camPos);\n    //camRay = mul(, camRay);\n    camRay = mul(mul(pan, tilt), camRay);\n    \n    vec3 col = castRayTerrain2(camPos, camRay);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    col = col / sqrt(0.5+col*col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float getOccupancy(vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\nbool isIn(vec2 uv, float threshold)\n{\n\treturn getOccupancy(uv) > threshold;\n}\n\nfloat squaredDistanceBetween(vec2 uv1, vec2 uv2)\n{\n    vec2 difference = uv1 - uv2;\n    return dot(difference, difference);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy) / iResolution.xy;\n    vec4 oldColor = texture(iChannel2, uv);\n    \n    // This block of code was to make the terrain\n    // \"grow\" instead of expose the poorly resolved\n    // initial state with few samples.\n    if(oldColor.a == 0. || iMouse.z > 0.)\n    {\n        oldColor.rgb = vec3(25.);\n        oldColor.a = 50.;\n    }\n    \n    // Stop after enough iterations.\n    if(oldColor.a > 512.)\n    {\n        fragColor = oldColor;\n        return;\n    }\n        \n    \n    //fragColor = vec4(vec3(getOccupancy(uv)), 1);\n    //return;\n    \n    // Compute the noise.\n    vec3 noise;\n    {\n        \n        // Cycle the noise.\n        // We do the cycling FIRST to prevent\n        // loss of precision that might\n        // round away the noise values.\n        //   - Use the golden ratio as it should land\n        //     on all fractional values eventually.\n        noise = vec3(iFrame, iFrame+1, iFrame+2);\n        noise *= 1.618033;\n        noise -= floor(noise);\n    \n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n        // (Disable to prevent gradient noise).\n        //vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        //noise += texture(iChannel1, noiseUV).r;\n        //noise -= floor(noise);\n        \n        noise.xy -= 0.5f;\n    }\n    \n    // Compare with and without fuzziness.\n    //if(uv.x > 0.5)\n    //    noise.z = 0.5;\n       \n    vec2 samplingCenter = fragCoord + noise.xy;\n    vec2 samplingCenterUV = samplingCenter / iResolution.xy;\n    \n    const float halfRange = 32.0;\n    const int iRange = int(halfRange);\n    const float maxSqrDist = halfRange*halfRange;\n    vec2 startPosition = samplingCenter;\n    \n    bool fragIsIn = isIn(samplingCenterUV, noise.z);\n    float squaredDistanceToEdge = maxSqrDist*2.;\n    \n    for(int dx=-iRange; dx <= iRange; dx++)\n    {\n        for(int dy=-iRange; dy <= iRange; dy++)\n        {\n            vec2 delta = vec2(dx, dy);\n            vec2 circlizer = abs(delta);\n            circlizer /= max(circlizer.x, circlizer.y);\n            delta /= length(circlizer);\n            vec2 scanPosition = startPosition + vec2(dx, dy);\n            float scanDistance = squaredDistanceBetween(samplingCenter, scanPosition);\n                \n            //if(scanDistance > maxSqrDist)\n            //    continue;\n                \n            bool scanIsIn = isIn(scanPosition / iResolution.xy, noise.z);\n            if (scanIsIn != fragIsIn)\n            {\n                if (scanDistance < squaredDistanceToEdge)\n                    squaredDistanceToEdge = scanDistance;\n            }\n        }\n    }\n    \n    float distanceToEdge = sqrt(squaredDistanceToEdge);\n\n    if (fragIsIn)\n    {\n        // We add 1.0 here since the edge is on the inside\n        // of the boundary.\n        distanceToEdge = 1.0-distanceToEdge;\n    }\n        \n    distanceToEdge /= halfRange * 2.;\n        \n    distanceToEdge = 0.5 - distanceToEdge;\n    \n    distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    //distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    \n    fragColor = vec4(distanceToEdge, distanceToEdge, distanceToEdge, 1.0);\n\n    \n   \n    fragColor += oldColor;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float perlin(vec2 uv)\n{\nuv += vec2(3.1982,4.73234);\n    uv /= 1.0;\n    vec2 occ = vec2(0);\n    float a = 1.0;\n    for(int i = 0; i < 10; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= 0.5;\n        a *= 2.0;\n    }\n\n    float v = occ.x / occ.y;\n    \n    v = v * 2.0 - 1.0;\n    \n    v = tanh(v * 2.0);\n    \n    v = v * 0.5 + 0.5;\n    \n    v *= v;\n    \n    return v;\n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    float height = perlin(uv);\n    \n    fragColor = vec4(height, height, height, 1.);\n    \n    \n\n}", "buffer_b_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 0.5+0.5*(130.0 * dot(m, g));\n}\n\nfloat snoise(float p){\n\treturn snoise(vec2(p,0.));\n}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n#define NUM_OCTAVES 16\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat turbulent(vec2 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn (v+1.)/2.;\n}\n\nfloat turbulent(vec3 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\nfloat pattern( in vec2 p )\n  {\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                   fbm( p + vec2(5.2,1.3) ) );\n\n    return fbm( p + 4.0*q );\n  }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint radius = 1;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2GDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 73], [75, 75, 91, 91, 143], [148, 148, 177, 177, 296], [298, 298, 327, 327, 449], [451, 451, 473, 473, 686], [688, 688, 722, 722, 1497], [1499, 1499, 1530, 1530, 2129], [2131, 2131, 2157, 2157, 2192], [2194, 2194, 2217, 2217, 2973], [2975, 2975, 3004, 3004, 3504], [3506, 3506, 3553, 3553, 8047], [8049, 8049, 8106, 8106, 8717]], "test": "untested"}
{"id": "Ds23WR", "name": "Fork Water elevations 702", "author": "elevations01", "description": "A simple water shader.", "tags": ["2d", "water"], "likes": 7, "viewed": 295, "published": 3, "date": "1667467708", "time_retrieved": "2024-07-30T16:22:52.572362", "image_code": "// A simple water shader. (c) Ajarus, viktor@ajarus.com.\n//\n// Attribution-ShareAlike CC License.\n\nconst float PI = 3.1415926535897932;\n\n// play with these parameters to custimize the effect\n// ==================================================\n\n//speed\nconst float speed = 0.2;\nconst float speed_x = 0.3;\nconst float speed_y = 0.3;\n\n// refraction\nconst float emboss = 0.50;\nconst float intensity = 2.4;\nconst int steps = 8;\nconst float frequency = 6.0;\nconst int angle = 7; // better when a prime\n\n// reflection\nconst float delta = 60.;\nconst float gain = 700.;\nconst float reflectionCutOff = 0.012;\nconst float reflectionIntensity = 200000.;\n\n// ===================================================\n\n\n  float col(vec2 coord,float time)\n  {\n    float delta_theta = 2.0 * PI / float(angle);\n    float col = 0.0;\n    float theta = 0.0;\n    for (int i = 0; i < steps; i++)\n    {\n      vec2 adjc = coord;\n      theta = delta_theta*float(i);\n      adjc.x += cos(theta)*time*speed + time * speed_x;\n      adjc.y -= sin(theta)*time*speed - time * speed_y;\n      col = col + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;\n    }\n\n    return cos(col);\n  }\n\n//---------- main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*1.3;\n\nvec2 p = (fragCoord.xy) / iResolution.xy, c1 = p, c2 = p;\nfloat cc1 = col(c1,time);\n\nc2.x += iResolution.x/delta;\nfloat dx = emboss*(cc1-col(c2,time))/delta;\n\nc2.x = p.x;\nc2.y += iResolution.y/delta;\nfloat dy = emboss*(cc1-col(c2,time))/delta;\n\nc1.x += dx*2.;\nc1.y = -(c1.y+dy*2.);\n\nfloat alpha = 1.+dot(dx,dy)*gain;\n\t\nfloat ddx = dx - reflectionCutOff;\nfloat ddy = dy - reflectionCutOff;\nif (ddx > 0. && ddy > 0.)\n\talpha = pow(alpha, ddx*ddy*reflectionIntensity);\n\t\nvec4 col = texture(iChannel0,c1)*(alpha);\nfragColor = col;\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds23WR.jpg", "access": "api", "license": "other-copyleft", "functions": [[704, 704, 740, 740, 1165], [1186, 1186, 1243, 1243, 1800]], "test": "untested"}
{"id": "cdBGzw", "name": "fractal diving", "author": "ufffd", "description": "playing with XT95's scene, added:\n- overlapped transitions\n- zoom in after each fractal\n- continuous zoom mode\n- variable timer\n- mouse look controls", "tags": ["fractal", "volumetric", "glow"], "likes": 10, "viewed": 274, "published": 3, "date": "1667464187", "time_retrieved": "2024-07-30T16:22:53.637514", "image_code": "// edit of xt95's fractal doodling: https://www.shadertoy.com/view/ds2GRW\n// which was inspired by gaz: https://www.shadertoy.com/user/gaz/\n\n// timer loop length\n#define TIMER 20.\n// constant zoom mode\n// #define CZOOM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/R.xy;\n    vec3 rd = normalize(vec3(uv*2.-1., 2.));\n    \n    if (iMouse.z>0.5) {\n        vec2 muv = iMouse.xy/R.xy-0.5;\n        rd.xz = rot(muv.x*PI*2.) * rd.xz;\n        rd.yz = rot(muv.y*PI*2.) * rd.yz;\n    }\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    \n    for(float cycle=0.;cycle<1.5;cycle++) {\n        vec3 ro = vec3(0.,0.,-.5);\n        float t = 0.;\n        float time = iTime + cycle*TIMER*100.5 + 157.;\n        float ntime = time/TIMER;\n        vec3 seed = hash3( uint(ntime) + 3u );\n        vec3 seed2 = hash3( uint(ntime) );\n        time = mod(time, TIMER);\n        ntime = time/TIMER;\n        ro.z += ntime*.25;\n        // cycle progress bars for debugging\n        /* if (uv.y>0.95 && cycle<0.5) {\n            if (uv.x>ntime) {fragColor = vec4(1.); return;}\n        }\n        if (uv.y<0.95 && uv.y>0.9 && cycle > 0.5) {\n            if (uv.x>ntime) {fragColor = vec4(1.); return;}\n        } */\n        #ifdef CZOOM\n            float fade = sin((ntime*2.-0.5)*PI)*0.5+0.5;\n            fade = smoothstep(0.,1.,fade);\n            float zoom = 2. - ntime*2.;\n        #else\n            float ease_in = smoothstep(.0,.2, ntime);\n            float ease_out = smoothstep(.75,.65, ntime);\n            float fade = ease_in * ease_out;\n            ease_in = smoothstep(.0,.3, ntime);\n            ease_out = smoothstep(.8,.6, ntime);\n            float zoom = .9 - ease_in + ease_out - ntime*0.5;\n        #endif\n\n        vec3 col = vec3(0.);\n        for(int i=0; i<100; i++) {\n            vec3 p = ro + rd * t;\n            p.z -= zoom * 0.6;\n            if (cycle>0.5)\n                p.xz = rot(-iTime*0.02+0.3) * p.xz;\n            else\n                p.xz = rot(iTime*0.02+0.3) * p.xz;\n            p.xy = rot(-iTime*0.03-.2) * p.xy;\n            float s = 2., r2;\n            for(int j=0; j<5+int(cycle*3.); j++) {\n                r2 = (3.2-zoom)/min(dot(p,p),1.9);\n                p = abs(p*r2) - (seed+.1)*5.;\n                s *= r2;\n            }\n\n            float d = length(p.xy)/s;\n            t += d*.5;\n            col += vec3(cos(vec3(1.,2.,3.)-iTime*1.5*(seed2.g*2.-1.) + log(s))*.5+.5) * 0.03 * exp(-.5*d*float(i*i));\n        }\n        col = clamp(col,0.,1.) * fade;\n        fragColor.rgb += col;;\n    }\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\n#define PI 3.14159\n// From Iq https://www.shadertoy.com/view/llGSzw\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,b,-b,a);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 277, 277, 2518]], "test": "untested"}
{"id": "ddS3WR", "name": "Erosion Terrain", "author": "Hatchling", "description": "Using \"Fuzzy Signed Distance Fields\" over a perlin noise heightmap, one can easily generate highly detailed and natural looking erosion with branching rivers and cliffs!\nDiscovered by accident!\n\nRaymarch borrowed from https://www.shadertoy.com/view/MlGBD1", "tags": ["procedural", "terrain", "distance", "field", "signed", "erosion"], "likes": 29, "viewed": 618, "published": 3, "date": "1667462550", "time_retrieved": "2024-07-30T16:22:56.266485", "image_code": "float maxHeight()\n{\n    return 200.0 / iChannelResolution[0].x;        \n}\n\nfloat precis()\n{\n    return 1.5 / iChannelResolution[0].x;        \n}\n\n\nvec3 worldToTerrain(vec3 p)\n{\n    p.x /= iChannelResolution[0].x / iChannelResolution[0].y;\n    p.xz += 0.5;\n    p.y /= maxHeight();\n    return p;\n}\n\nvec3 terrainToWorld(vec3 p)\n{\n    p.y *= maxHeight();   \n    p.xz -= 0.5;\n    p.x *= iChannelResolution[0].x / iChannelResolution[0].y;\n    return p;\n}\n\nfloat terrain(vec2 p){\n\n    p.x /= iChannelResolution[0].x / iChannelResolution[0].y;\n    \n    p += 0.5;\n    \n\n    \n    if(clamp(p,0.0,1.0) != p) return 0.5;\n    \n    vec4 t = texture(iChannel0, p);\n    return t.r / t.a * maxHeight();\n}\n\nvec2 calculate_curvature(vec3 p)\n{    \n    float height_mod = 1.;\n    float prec = precis();\n    float heightC = terrain(p.xz)*height_mod;\n    \n    vec3 posC = vec3(p.x, heightC, p.z);\n    vec3 posR = p + vec3(prec, 0.0,  0.0);\n    vec3 posL = p - vec3(prec, 0.0,  0.0);\n    vec3 posT = p + vec3( 0.0, 0.0, prec);\n    vec3 posB = p - vec3( 0.0, 0.0, prec);\n    \n    posR.y = terrain(posR.xz)*height_mod;\n    posL.y = terrain(posL.xz)*height_mod;\n    posT.y = terrain(posT.xz)*height_mod;\n    posB.y = terrain(posB.xz)*height_mod;\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    vec3 normal = normalize(cross(dx, dy));\n    \n    float curveX = -dot(posC + posC - posR - posL, normal);\n    float curveY = -dot(posC + posC - posT - posB, normal);\n    \n    return vec2(curveX, curveY) / prec;\n}\n\nvec3 calculate_normal(vec3 p)\n{    \n    float height_mod = 1.;\n    float prec = precis();\n    float heightC = terrain(p.xz)*height_mod;\n    \n    vec3 posC = vec3(p.x, heightC, p.z);\n    vec3 posR = p + vec3(prec, 0.0,  0.0);\n    vec3 posL = p - vec3(prec, 0.0,  0.0);\n    vec3 posT = p + vec3( 0.0, 0.0, prec);\n    vec3 posB = p - vec3( 0.0, 0.0, prec);\n    \n    posR.y = terrain(posR.xz)*height_mod;\n    posL.y = terrain(posL.xz)*height_mod;\n    posT.y = terrain(posT.xz)*height_mod;\n    posB.y = terrain(posB.xz)*height_mod;\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    return -normalize(cross(dx, dy));\n}\n\nbool pointTerrain(vec3 p){\n    return terrain(p.xz) >= p.y;\n}\n\nvec3 skybox(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    gradient *= gradient;\n    gradient *= gradient;\n   \n    gradient = 1.-gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient = 1.-gradient;\n    \n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    \n    return color;\n}\n\nvec3 skyboxBlurry(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    \n    \n   \n    //gradient *= gradient;\n   ;\n    gradient = 1.-gradient;\n    gradient *= gradient * gradient;\n    gradient = 1.-gradient;\n    \n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    \n    return color;\n}\n\nvec3 castRayTerrain2(vec3 camPos, vec3 camDir){\n    bounds b;\n    b.mini = terrainToWorld(vec3(0));\n    b.maxi = terrainToWorld(vec3(1));\n    \n    vec3 near, far;\n    if(!rayIntersectBounds(b, camPos, camDir, near, far))\n    {\n        return skybox(camDir);\n    }\n    \n    vec3 p = near;\n    float minD = 0.0, maxD = 1.0;\n    bool hit = false;\n    for(float i=0.; i<=1.; i+=.005)\n    {\n        float j = i*i;\n    \tp = mix(near, far, j);\n        \n        maxD = j;\n        \n        \n        if(pointTerrain(p))\n        {\n            hit = true;\n            break;\n        }\n        \n        minD = j;\n    }\n    \n    if(!hit) return skybox(camDir);\n\n    maxD = (minD + maxD) * 0.5;\n    float stepSize = (maxD - minD) * 0.5;\n\n    for(int i = 0; i < 5; i++, stepSize *= 0.5)\n    {\n    \tp = mix(near, far, maxD);\n        if(!pointTerrain(p))\n        {\n            minD = maxD;\n            maxD += stepSize;\n        }\n        else\n        {\n            maxD -= stepSize;\n        }\n    }\n    \n    \n    vec3 normal = calculate_normal(p);\n    vec2 curve2 = calculate_curvature(p);\n    \n    vec2 posCurve2 = max(vec2(0), curve2);\n    vec2 negCurve2 = -min(vec2(0), curve2);\n    \n    float posCurve = posCurve2.x + posCurve2.y;\n    posCurve = posCurve / (0.2 + posCurve);\n    float negCurve = negCurve2.x + negCurve2.y;\n    negCurve = negCurve / (0.2 + negCurve);\n    float curve = (curve2.x + curve2.y);\n    curve = curve / (0.2 + abs(curve));\n    \n    p = vec3(p.x, terrain(p.xz), p.z);\n\n    vec3 lightDir = normalize(vec3(0, 3, 5));\n    vec3 lightColor = max(0.0,dot(normal, lightDir)) * vec3(1.0, 0.75, 0.5) * 2.0;\n    \n    vec3 ambientDir = vec3(0, 1, 0);\n    float ambient = dot(normal, ambientDir) * 0.5 + 0.5;\n    ambient *= ambient;\n    //ambient *= ambient;\n    //ambient *= ambient;\n    ambient *= curve * 0.5 + 0.5;\n    vec3 ambientColor = ambient * skyboxBlurry(normal);\n    \n    vec3 totalDiffuse = ambientColor + lightColor;\n\n    vec3 eyeDir = normalize(camPos-p);\n    vec3 reflec = reflect(-lightDir, normal);\n    float spec = max(0.0,dot(eyeDir, reflec));\n    spec = pow(spec*1.01, 100.);// * 10.;\n\n    vec3 albedo  = vec3(1.);\n    \n    float slopeFactor;\n    float heightFactor;\n    {\n        heightFactor = p.y / maxHeight();\n        \n        heightFactor = smoothstep(0., 1., heightFactor);        \n        heightFactor = smoothstep(0., 1., heightFactor);\n        \n        slopeFactor = abs(normal.y);\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        \n        vec3 flatLow = vec3(0.1, 0.4, 0.05);\n        vec3 flatHigh = vec3(0.7, 0.7, 0.5);\n        \n        vec3 slopeLow = vec3(0.4, 0.7, 0.2);\n        vec3 slopeHigh = vec3(0.3, 0.2, 0.05);\n        \n        vec3 flatColor = mix(flatLow, flatHigh, heightFactor);\n        vec3 slopeColor = mix(slopeLow, slopeHigh, heightFactor);\n        \n        albedo = mix(slopeColor, flatColor, slopeFactor);\n    }\n    \n    albedo = mix(albedo, (albedo*1.0+vec3(0.75))*vec3(0.7,0.65,0.3), posCurve); \n    \n    // Add rivers.\n    float rivers;\n    {\n        rivers = max(0.,negCurve - posCurve);\n        \n        rivers = pow(rivers, pow(2., mix(0.5, -0.7, slopeFactor) + mix(-0.7, 0.7, heightFactor)));   \n\n        //rivers = pow(rivers, heightFactor + 1.0);   \n        //rivers = pow(rivers, heightFactor*3.+0.5);         \n        \n        rivers = smoothstep(0., 1., rivers);\n        rivers = smoothstep(0., 1., rivers);\n        \n        //rivers = 1.-rivers;\n        //rivers *= rivers;\n        //rivers = 1.-rivers;\n        \n        albedo = mix(albedo, vec3(0.1,0.2,0.5), rivers); \n    }\n\n    albedo *= albedo;\n\n    //albedo = mix(albedo, curve > 0.0 ? vec3(1,0.7,0.3) : vec3(0.3,0.7,1), vec3(abs(curve))); \n\n    float specMult = 0.0;\n    specMult = mix(specMult, 0.5, posCurve);//length(color)*length(color)*0.2;\n    specMult = mix(specMult, 3., rivers);//length(color)*length(color)*0.2;\n\n    vec3 color = albedo*totalDiffuse + lightColor*spec*specMult;\n    \n    float fogDist = dot(p - camPos, p - camPos);\n    \n    color = mix(skybox(camDir), color, pow(vec3(0.9), fogDist * vec3(0.2,0.8,4.))); \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camRay = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.yy, 1));\n    vec3 camPos = vec3(0.0, maxHeight() * 1.0, -0.5);\n    \n    vec3 lookDir = vec3(0, maxHeight() * 0.25, 0) - camPos;\n    \n    quaternion pan = FromAngleAxis(vec3(0, iTime * 0.25, 0));\n    quaternion tilt = FromToRotation(vec3(0,0,1), lookDir);\n    \n    camPos = mul(pan, camPos);\n    //camRay = mul(, camRay);\n    camRay = mul(mul(pan, tilt), camRay);\n    \n    vec3 col = castRayTerrain2(camPos, camRay);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    col = col / sqrt(0.5+col*col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float getOccupancy(vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\nbool isIn(vec2 uv, float threshold)\n{\n\treturn getOccupancy(uv) > threshold;\n}\n\nfloat squaredDistanceBetween(vec2 uv1, vec2 uv2)\n{\n    vec2 difference = uv1 - uv2;\n    return dot(difference, difference);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    //fragColor = vec4(vec3(getOccupancy(uv)), 1);\n    //return;\n    \n    // Compute the noise.\n    vec3 noise;\n    {\n        \n        // Cycle the noise.\n        // We do the cycling FIRST to prevent\n        // loss of precision that might\n        // round away the noise values.\n        //   - Use the golden ratio as it should land\n        //     on all fractional values eventually.\n        noise = vec3(iFrame, iFrame+1, iFrame+2);\n        noise *= 1.618033;\n        noise -= floor(noise);\n    \n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n        // (Disable to prevent gradient noise).\n        //vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        //noise += texture(iChannel1, noiseUV).r;\n        //noise -= floor(noise);\n        \n        noise.xy -= 0.5f;\n    }\n    \n    // Compare with and without fuzziness.\n    //if(uv.x > 0.5)\n    //    noise.z = 0.5;\n       \n    vec2 samplingCenter = fragCoord + noise.xy;\n    vec2 samplingCenterUV = samplingCenter / iResolution.xy;\n    \n    const float halfRange = 16.0;\n    const int iRange = int(halfRange);\n    const float maxSqrDist = halfRange*halfRange;\n    vec2 startPosition = samplingCenter;\n    \n    bool fragIsIn = isIn(samplingCenterUV, noise.z);\n    float squaredDistanceToEdge = maxSqrDist*2.;\n    \n    for(int dx=-iRange; dx <= iRange; dx++)\n    {\n        for(int dy=-iRange; dy <= iRange; dy++)\n        {\n            vec2 delta = vec2(dx, dy);\n            vec2 circlizer = abs(delta);\n            circlizer /= max(circlizer.x, circlizer.y);\n            delta /= length(circlizer);\n            vec2 scanPosition = startPosition + vec2(dx, dy);\n            float scanDistance = squaredDistanceBetween(samplingCenter, scanPosition);\n                \n            //if(scanDistance > maxSqrDist)\n            //    continue;\n                \n            bool scanIsIn = isIn(scanPosition / iResolution.xy, noise.z);\n            if (scanIsIn != fragIsIn)\n            {\n                if (scanDistance < squaredDistanceToEdge)\n                    squaredDistanceToEdge = scanDistance;\n            }\n        }\n    }\n    \n    float distanceToEdge = sqrt(squaredDistanceToEdge);\n\n    if (fragIsIn)\n    {\n        // We add 1.0 here since the edge is on the inside\n        // of the boundary.\n        distanceToEdge = 1.0-distanceToEdge;\n    }\n        \n    distanceToEdge /= halfRange * 2.;\n        \n    distanceToEdge = 0.5 - distanceToEdge;\n    \n    distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    //distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    \n    fragColor = vec4(distanceToEdge, distanceToEdge, distanceToEdge, 1.0);\n\n    vec4 oldColor = texture(iChannel2, uv);\n    \n    // This block of code was to make the terrain\n    // \"grow\" instead of expose the poorly resolved\n    // initial state with few samples.\n    if(oldColor.a == 0.)\n    {\n        oldColor.rgb = vec3(25.);\n        oldColor.a = 50.;\n    }\n    fragColor += oldColor;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float perlin(vec2 uv)\n{\n    uv /= 4.0;\n    vec2 occ = vec2(0);\n    float a = 1.0;\n    for(int i = 0; i < 6; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= 0.5;\n        a *= 2.0;\n    }\n\n    float v = occ.x / occ.y;\n    \n    v = v * 2.0 - 1.0;\n    \n    v = tanh(v * 2.0);\n    \n    v = v * 0.5 + 0.5;\n    \n    //v *= v;\n    \n    return v;\n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    float height = perlin(uv);\n    \n    fragColor = vec4(height, height, height, 1);\n    \n    \n\n}", "buffer_b_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 0.5+0.5*(130.0 * dot(m, g));\n}\n\nfloat snoise(float p){\n\treturn snoise(vec2(p,0.));\n}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n#define NUM_OCTAVES 16\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat turbulent(vec2 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn (v+1.)/2.;\n}\n\nfloat turbulent(vec3 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\nfloat pattern( in vec2 p )\n  {\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                   fbm( p + vec2(5.2,1.3) ) );\n\n    return fbm( p + 4.0*q );\n  }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint radius = 1;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddS3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 73], [75, 75, 91, 91, 143], [146, 146, 175, 175, 294], [296, 296, 325, 325, 447], [449, 449, 471, 471, 685], [687, 687, 721, 721, 1496], [1498, 1498, 1529, 1529, 2128], [2130, 2130, 2156, 2156, 2191], [2193, 2193, 2216, 2216, 2972], [2974, 2974, 3003, 3003, 3503], [3505, 3505, 3552, 3552, 8044], [8046, 8046, 8103, 8103, 8714]], "test": "untested"}
{"id": "cdjGRR", "name": "Cloth Draping + Shadows", "author": "fenix", "description": "Cloth draping over a movable ball. Shadows are computed by rendering depth from light's perspective.\n\n*mouse to move ball* \n*space to reset and resume attract mode*", "tags": ["3d", "simulation", "particles", "physics", "integration", "cloth", "fabric", "tearing", "tear", "fishnet"], "likes": 44, "viewed": 811, "published": 3, "date": "1667461450", "time_retrieved": "2024-07-30T16:22:59.072981", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  The cloth sim is essentially the same as my Tearable 3D Fishnet\n//\n//      https://www.shadertoy.com/view/NlKBW3\n//\n//  I did simplify it slightly, removing the pinning and disabling abilities since\n//  I'm not using them here.\n//\n//  Most of my time on this shader has been spent on the rendering. I originally\n//  tried a more analytic approach, trying to compute a quad from the cloth vertices\n//  to render. I couldn't get that to work, so I ended up with a \"splat\" approach\n//  which looks OK, I think.\n//\n//  The shadows are possible because we compute voronoi for particle vertices from\n//  the light source position, and then render depth into buffer D from the light \n//  source direction. We can then consult this buffer during rendering to determine\n//  when the cloth shadows something.\n//\n//  Buffer A computes the positions of cloth vertices\n//  Buffer B computes nearest particles to each screen pixel from the camera's POV\n//  Buffer C computes nearest particles to each screen pixel from the light's POV\n//  Buffer D computes the depth of the cloth from the light's perspective, for shadows\n//\n// ---------------------------------------------------------------------------------------\n\n\nvec3 light(vec3 n, vec3 pointLightDir, bool shadow)\n{\n    return vec3(abs(dot(n, FILL_LIGHT_DIR)) *.25) + float(!shadow) * max(0., dot(n, pointLightDir)) * .9;\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat scene(vec3 p, vec4 state)\n{\n    float d = sdSphere(p - vec3(state.y, -1, -state.z), 1.); // ball\n    \n    d = min(d, sdBox(p + vec3(0,0,2), vec3(10.,10.,1.))); // wall\n    d = min(d, sdBox(p + vec3(0,1.-FLOOR_Z,0), vec3(10.,1.,10.))); // floor\n    \n    return d;\n}\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd, vec4 state)\n{\n\tfloat d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * d;\n        float dS = scene(p, state);\n        d += dS;\n        if(d > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p, vec4 state)\n{\n    vec2 e = vec2(.001, 0);\n    vec3 n = scene(p, state) - \n        vec3(scene(p - e.xyy, state), scene(p - e.yxy, state),scene(p - e.yyx, state));\n    \n    return normalize(n);\n}\n\nbool shadowScene(vec3 p, vec3 lightDir, mat4 w2l, vec4 state)\n{\n    float sd = rayMarch(POINT_LIGHT_POS, -lightDir, state);\n    vec3 sp = POINT_LIGHT_POS - lightDir * sd;\n    return dot(p - sp, lightDir) < -0.1;\n}\n\nbool shadowCloth(vec3 p, vec3 lightDir, mat4 w2l, vec4 state)\n{\n    vec3 s = screen(p, w2l);\n    float sz = texture(iChannel2, s.xy * .5 * vec2(iResolution.y / iResolution.x, 1) + .5).w;\n\n    return sz < s.z;\n}\n\nbool renderCloth(int id, mat4 w2c, mat4 w2l, vec2 p, vec4 state, inout vec4 fragColor)\n{\n    fxParticle data = fxGetParticle(id);\n    vec3 s = screen(data.pos, w2c);\n    if (distance(s.xy, p) < 15./iResolution.y && s.z <= fragColor.w + 0.01)\n    {\n        vec3 lightDir = normalize(POINT_LIGHT_POS - data.pos);\n        bool sh = shadowScene(data.pos, lightDir, w2l, state);\n        const vec3 CLOTH_COLOR = vec3(1, 0, 0);\n        fragColor = vec4(CLOTH_COLOR * light(data.norm, lightDir, sh), s.z);\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initClothExtents(iResolution);\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // set up ray for marching\n    vec3 cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(LOOK_AT, CAMERA_POS, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    mat4 w2c = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, CAMERA_POS);\n   \n    fragColor = vec4(0, 0, 0, MAX_DIST);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    // march\n    float d = rayMarch(CAMERA_POS, rayDir, state);\n\n    // process march results\n    vec3 hit = CAMERA_POS + rayDir * d;\n    vec3 n = getNormal(hit, state);\n    vec3 lightDir = normalize(POINT_LIGHT_POS - hit);\n    \n    // set up light matrix\n    vec3 lightFwd, lightLeft, lightUp;\n    fxCalcCamera(LOOK_AT, POINT_LIGHT_POS, lightFwd, lightLeft, lightUp);\n    mat4 w2l = fxCalcCameraMat(iResolution, lightLeft, lightUp, lightFwd, POINT_LIGHT_POS);\n   \n    // compute shadows\n    bool s = shadowScene(hit, lightDir, w2l, state) || shadowCloth(hit, lightDir, w2l, state);\n\n    // render background color\n    fragColor = vec4(light(n, lightDir, s), d);\n    \n    // render cloth\n    ivec4 old = fxGetClosest(iChannel1, ivec2(fragCoord));      \n    for (int i = 0; i < 4; i++)\n    {\n        int id = old[i];\n        if (id < 0 || id >= g_MaxParticles) continue;\n        if (renderCloth(id, w2c, w2l, p, state, fragColor)) break;\n    }\n    \n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.w = 1.;\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0); //render shadow buffer\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec3 POINT_LIGHT_POS = vec3(5, 5, 5);\nconst vec3 FILL_LIGHT_DIR = normalize(vec3(-1, 0.75, 1));\nconst vec3 CAMERA_POS = vec3(-1, 3, 5);\nconst vec3 LOOK_AT = vec3(0, -1, 0);\nconst float FLOOR_Z = -2.;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid fxCalcCamera(in vec3 cameraLookAt, in vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return inverse(mat4(vec4(-0.25 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0)));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.y) * vec2(0.5, 1.) - vec2(0.25 * iResolution.x / iResolution.y, .5);\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2(p - b * h); // squared dist to segment\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosest(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define POS 0\n#define PREV 1\n#define NORM 2\n#define NUM_PARTICLE_DATA_TYPES 3\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 prev;\n    vec3 norm;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, PREV), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, NORM), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xyz;\n    particle.prev = particleData1.xyz;\n    particle.norm = particleData2.xyz;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:  \n        return vec4(p.pos, 0);\n    case PREV:  \n        return vec4(p.prev, 0);\n    case NORM:  \n        return vec4(p.norm, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float SIDE_LEN = 4.;\n\n// global variables, initialized via computeClothSide\nint g_ClothSideLen = 0; // how many particles along each side of the square\nint g_MaxParticles = 0; // how many particles, total\n\n// computes the size of the cloth grid relative to the current resolution\nvoid initClothExtents(vec3 res)\n{\n    float particleUse = 0.1 * (3. - 0.6 * smoothstep(1000., 1200., res.y));\n    g_ClothSideLen = int(sqrt(res.x * res.y / float(NUM_PARTICLE_DATA_TYPES)) * particleUse);\n    g_MaxParticles = g_ClothSideLen * g_ClothSideLen;\n}\n\n// These functions compute the neighbors from each particle, and -1 if there is\n// no neighbor in that direction. Crucially, they must continue to return -1 if\n// -1 is passed in, since we do not terminate the loop right away.\n\nint above(int i)\n{\n    return i >= 0 && i >= g_ClothSideLen ? i - g_ClothSideLen : -1;\n}\n\nint below(int i)\n{\n    return i >= 0 && i < (g_ClothSideLen * (g_ClothSideLen - 1)) ? i + g_ClothSideLen : -1;\n}\n\nint left(int i)\n{\n    return i >= 0 && (i % g_ClothSideLen) != 0 ? i - 1 : -1;\n}\n\nint right(int i)\n{\n    return i >= 0 && (i % g_ClothSideLen) != g_ClothSideLen - 1 ? i + 1 : -1;\n}\n\nvec3 screen(vec3 p, mat4 w2c)\n{\n    vec3 s = (w2c * vec4(p,1.0)).xyz;\n    s.xy = s.xy / s.z;\n    return s;\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat distance2Particle(sampler2D sampler, int resolutionWidth, int id, float zBias, vec2 fragCoord, mat4 w2cNew)\n{\n    if (id==-1) return 1e20;\n    vec4 worldPos = fxGetParticleDataInternal(sampler, resolutionWidth, id, POS);\n    if (worldPos.w != 0.) return 1e20;\n    vec3 screenPos = (w2cNew * vec4(worldPos.xyz,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    vec2 delta = (screenPos.xy)-fragCoord;\n    return dot(delta, delta) + zBias*screenPos.z;\n}\n\nvoid consider(sampler2D sampler, int resolutionWidth, int nid, float zBias, vec2 p, mat4 w2c, inout ivec4 new, inout vec4 dis)\n{\n    if (nid >= 0)\n    {\n        float dis2 = distance2Particle(sampler, resolutionWidth, nid, zBias, p, w2c);\n        insertion_sort( new, dis, nid, dis2 );\n    }\n}\n\nvoid voronoiInternal(sampler2D particles, vec3 res, int frame, out vec4 fragColor, vec2 fragCoord, vec3 cameraPos, sampler2D self, float zBias, uint searchRange, uint searchCount)\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    initClothExtents(res);\n\n\tvec2 p = (2.*fragCoord - res.xy) / res.y;\n\n    vec3 cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    mat4 w2c = fxCalcCameraMat(res, cameraLeft, cameraUp, cameraFwd, cameraPos);\n\n    ivec4 new = ivec4(-1);\n    vec4 dis = vec4(1e6);\n\n    ivec4 old = fxGetClosest(self, iFragCoord);      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        consider(particles, int(res.x), id, zBias, p, w2c, new, dis);\n\n        // randomly check one of the neighbors of the particle, it's likely to be of interest\n        int nid;\n        switch((frame + int(j)) % 4)\n        {\n            case 0: nid = above(id); break;\n            case 1: nid = below(id); break;\n            case 2: nid = left(id); break;\n            case 3: nid = right(id); break;\n        }\n        \n        consider(particles, int(res.x), nid, zBias, p, w2c, new, dis);\n    }\n\n    for (uint i = 0u; i < searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, frame, res.x) * i);\n\n        ivec4 old = fxGetClosest(self, iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u));      \n        consider(particles, int(res.x), old[0], zBias, p, w2c, new, dis);\n    }\n\n    int searchIterations = 1;\n    if (frame < 5)\n    {\n        searchIterations = 10;\n    }\n    for (int k = 0; k < searchIterations; k++)\n    {\n        float h = hash3(uvec3(fragCoord, k)).x;\n\n        int id = int(h*float(g_MaxParticles));\n        consider(particles, int(res.x), id, zBias, p, w2c, new, dis);\n    }\n    \n    fragColor = vec4(new);\n}\n\n#define voronoi(A, B, C, D, E, F, G) voronoiInternal(iChannel0, iResolution, iFrame, A, B, C, D, E, F, G)\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position of each cloth vertex.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-1,0);\nconst float COMPRESSION_RESIST = .0003; // stiffness\n\nvoid constraint(inout int nid, inout fxParticle p, float edgeLen)\n{\n    if (nid < 0) return;\n    \n    fxParticle n = fxGetParticle(nid);\n    \n    vec3 deltaPos = n.pos - p.pos;\n    float len = length(deltaPos);\n    vec3 dir = deltaPos / len;\n    \n    float error = len - edgeLen;\n    \n    if (error < 0.) error *= COMPRESSION_RESIST;\n    \n    float f = .99;\n    p.pos += dir * error * f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initClothExtents(iResolution);\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=g_MaxParticles) return;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType == NORM)\n    {\n        // compute cloth normals\n        ivec4 ids;\n\n        ids.x = above(id);\n        ids.y = right(id);\n        ids.z = below(id);\n        ids.w = left(id);\n\n        fxParticle ps[4];\n        for (int i = 0; i < 4; ++i) ps[i] = fxGetParticle(ids[i]);\n\n        float count = 0.;\n        vec3 norm = vec3(0);\n        for (int i = 0; i < 4; ++i)\n        {\n            if (ids[i] >= 0 && ids[(i + 1) % 4] >= 0)\n            {\n                norm += normalize(cross(ps[i].pos - p.pos, ps[(i + 1) % 4].pos - p.pos));\n                count += 1.;\n            }\n        }\n\n        fragColor = vec4(normalize(norm / count), 0);\n        return;\n    }\n    \n    p.prev = p.pos;\n    p.pos += p.pos - p.prev + GRAVITY; // verlet\n\n    // edge constraints\n    int a, b, l, r;\n    a = b = l = r = id;\n\n    float EDGE_LEN = SIDE_LEN / float(g_ClothSideLen);\n    float CARDINAL_ITERATIONS = 45.;\n    for (float i = 1.; i < CARDINAL_ITERATIONS; ++i)\n    {\n        a = above(a);\n        b = below(b);\n        r = right(r);\n        l = left(l);\n\n        float sLen = EDGE_LEN * i;\n        constraint(a, p, sLen);\n        constraint(b, p, sLen);\n        constraint(r, p, sLen);\n        constraint(l, p, sLen);\n    }\n\n#define DIAGONAL_CONSTRAINTS 1\n\n#if DIAGONAL_CONSTRAINTS\n    int al, ar, bl, br;\n    al = ar = bl = br = id;\n\n    float DIAGONAL_ITERATIONS = 35.;\n    for (float i = 1.; i < DIAGONAL_ITERATIONS; ++i)\n    {\n        ar = above(right(ar));\n        al = above(left(al));\n        br = below(right(br));\n        bl = below(left(bl));\n\n        float dLen = EDGE_LEN * i * sqrt(2.);\n        constraint(al, p, dLen);\n        constraint(ar, p, dLen);\n        constraint(bl, p, dLen);\n        constraint(br, p, dLen);\n    }\n#endif // DIAGONAL_CONSTRAINTS\n\n    // collision with ball\n    const float BALL_SIZE  = 1.;\n    vec3 ballPos = vec3(state.y, -1.0, -state.z);\n    vec3 ballDelta = p.pos - ballPos;\n    if (length(ballDelta) < BALL_SIZE)\n    {\n        p.pos = ballPos + normalize(ballDelta) * BALL_SIZE;\n    }\n\n    // collision with floor\n    if (p.pos.y < FLOOR_Z)\n    {\n        p.pos.y = FLOOR_Z;\n    }\n    \n    // reset\n    if (iFrame == 0 || state.x < 0.)\n    {   \n        float x = float(id % g_ClothSideLen) / float(g_ClothSideLen) - 0.5;\n        float y = 0.5 - float(id) / float(g_ClothSideLen * g_ClothSideLen);\n        p.pos = vec3(x, 0.2, y) * SIDE_LEN / sqrt(2.);\n        p.prev = p.pos;\n    }\n\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Manages state, computes voronoi for particle rendering.\n// ---------------------------------------------------------------------------------------\n\nvec4 updateState()\n{\n    // Reset if resolution changes\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    ivec4 topMiddleClosest = fxGetClosest(iChannel1, ivec2(iResolution.x * .5, iResolution.y - 10.));\n    if (topMiddleClosest[0] >= 0)\n    {\n        // Reset if cloth falls on the floor\n        fxParticle test = fxGetParticle(topMiddleClosest[0]);\n        if (test.pos.y <= FLOOR_Z) state.x = 0.;\n    }\n\n    if (iFrame == 0 ||\n        iResolution.x * iResolution.y != abs(state.x) ||\n        keyDown(KEY_SPACE))\n    {\n        state = vec4(-iResolution.x * iResolution.y, 0.0, 0.0, 0.0);\n    }\n    else\n    {\n        state.x = abs(state.x);\n    }\n\n    if (iMouse.z > 0.)\n    {\n        state.yz = (2. * iMouse.xy - iResolution.xy ) / iResolution.y;\n        state.w = -1.;\n    }\n\n    if (state.w >= 0.)\n    {\n        state.w++;\n        state.z = .05 * cos(.06 * state.w);\n        state.y = .3 * sin(.02 * state.w);\n    }\n    \n    return state;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        fragColor = updateState();\n        return;\n    }\n    \n    voronoi(fragColor, fragCoord, CAMERA_POS, iChannel1, 0.0003, 8u, 16u);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Computes voronoi for shadow buffer.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    voronoi(fragColor, fragCoord, POINT_LIGHT_POS, iChannel2, 0.00003, 15u, 8u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Renders depth into w component from the light source for shadow computation.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initClothExtents(iResolution);\n    \n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraPos = POINT_LIGHT_POS, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 w2c = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n   \n    fragColor = vec4(0, 0, 0, 1e6);\n    \n    ivec4 old = fxGetClosest(iChannel2, ivec2(fragCoord));      \n\n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0 || id >= g_MaxParticles) continue;\n        fxParticle data = fxGetParticle(id);\n        vec3 s = screen(data.pos, w2c);\n        if (distance(s.xy, p) < 10./iResolution.y && s.z <= fragColor.w + 0.01)\n        {\n            fragColor = vec4(1, 1, 1, s.z);\n        }\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjGRR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1417, 1417, 1470, 1470, 1578], [1580, 1580, 1609, 1609, 1694], [1696, 1696, 1731, 1731, 1757], [1759, 1759, 1792, 1792, 2029], [2099, 2099, 2145, 2145, 2372], [2374, 2374, 2410, 2410, 2590], [2592, 2592, 2655, 2655, 2805], [2807, 2807, 2870, 2870, 3017], [3019, 3019, 3107, 3107, 3564], [3566, 3566, 3623, 3623, 5239]], "test": "untested"}
{"id": "csB3Dz", "name": "Procedural Erosion Heightmap", "author": "Hatchling", "description": "Using \"Fuzzy Signed Distance Fields\" over a perlin noise heightmap, one can easily generate highly detailed and natural looking erosion with branching rivers and cliffs!\nDiscovered by accident!", "tags": ["procedural", "terrain", "distance", "field", "signed", "erosion"], "likes": 33, "viewed": 753, "published": 3, "date": "1667443845", "time_retrieved": "2024-07-30T16:23:01.310000", "image_code": "vec2 compress(vec2 vec)\n{\n    float mag = sqrt(dot(vec, vec));\n\n    float newMag = mag;\n\n    // Softly compress the range \n    // from 0 to +Inf\n    // to 0 to +1 \n    // instead of clipping values\n    // when contrast is used for visualization.\n    newMag = newMag / (0.5 + newMag);\n\n    vec *= newMag / (mag + 0.00001);\n    return vec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvC = fragCoord.xy / iResolution.xy;\n\tvec2 uvR = (fragCoord.xy + vec2(1,0)) / iResolution.xy;\n\tvec2 uvT = (fragCoord.xy + vec2(0,1)) / iResolution.xy;\n\tvec2 uvL = (fragCoord.xy - vec2(1,0)) / iResolution.xy;\n\tvec2 uvB = (fragCoord.xy - vec2(0,1)) / iResolution.xy;\n    vec2 colC = texture(iChannel0, uvC).ra;\n    vec2 colR = texture(iChannel0, uvR).ra;\n    vec2 colT = texture(iChannel0, uvT).ra;\n    vec2 colL = texture(iChannel0, uvL).ra;\n    vec2 colB = texture(iChannel0, uvB).ra;\n    \n    colC.r /= colC.g;\n    colR.r /= colR.g;\n    colT.r /= colT.g;\n    colL.r /= colR.g;\n    colB.r /= colT.g;\n    \n    \n    vec2 gradient = vec2(colL.r - colR.r, colB.r - colT.r);\n    vec2 curvature = vec2\n    (\n        colL.r + colR.r - 2.0 * colC.r, \n        colB.r + colT.r - 2.0 * colC.r \n    ) * 0.5;\n    \n    \n    // Enhance gradient+curvature contrast.\n    vec2 both = compress(gradient * 50.0 - curvature * 1000.0);\n    \n    \n    // Unmodified gradients:\n    // vec2 gradient = vec2(colC.r - colR.r, colC.r - colT.r);\n    \n    fragColor = vec4(both * 0.5 + 0.5, colC.r, 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float getOccupancy(vec2 uv) { return texture(iChannel0, uv).r; }\n\nbool isIn(vec2 uv, float threshold) { return getOccupancy(uv) > threshold; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This buffer averages out multiple signed distance fields\n    // wherein the threshold that deliniates inside from outside\n    // varies (from 0 to 1) between different signed distance\n    // computations.\n    // This essentially allows a signed distance field\n    // where there is no binary distinction between inside and outside,\n    // where \"low occupancy\" pixels have lower influence\n    // rather than having no influence at all.\n\n    // Compute the \"noise\" which is used to generate\n    // and combine multiple samples.\n    // The noise vector contains:\n    //     x, y: offset to sampling position (antialiasing)\n    //     z:    threshold deliniating inside from outside,\n    //           as the input texture contains a range of values\n    //           from 0 to 1 and must be converted to binary\n    //           at a given threshold.\n    vec3 noise;\n    {\n        noise = vec3(0);\n        \n        // Calculate oising over time.\n        vec3 temporalNoise;\n        {\n            // Use the golden ratio as it should land\n            // on all fractional values eventually.\n            temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n            temporalNoise *= 1.618033;\n            \n            // We floor this one early to prevent\n            // loss of precision when iFrame becomes large.\n            temporalNoise -= floor(noise);\n        }\n        noise += temporalNoise;\n    \n        #ifdef SPATIAL_NOISE\n        // Add noising over space.\n        // (Currently disabled; messes up the\n        // gradient and especially the curvature\n        // of the resulting map.)\n        vec3 spatialNoise;\n        {\n            // Noise is added to vary the threshold\n            // per pixel to speed up apparent convergence,\n            // but the converged result shouldn't change.\n            \n            vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n            spatialNoise = texture(iChannel1, noiseUV).r;\n        }\n        noise += spatialNoise;\n        #endif\n        \n        // Wrap values around from 0 to 1.\n        noise -= floor(noise);\n        \n        // Center the sampling position offset\n        // to a range within -0.5 to +0.5.\n        noise.xy -= 0.5f;\n    }\n    \n    // Compute the signed distance to an edge\n    // (limited to a certain search distance)\n    // from -1 to 1.\n    float distanceToEdge;\n    {\n        // Sample with \"jitter\" for accumulative antialiasing.\n        vec2 samplingCenter = fragCoord + noise.xy;\n        vec2 samplingCenterUV = samplingCenter / iChannelResolution[0].xy;\n\n        const int iRange = 16;\n        const float range = float(iRange);\n        const float maxSqrDist = range*range;\n        vec2 startPosition = samplingCenter;\n\n        // We need to know whether our center pixel,\n        // the one we're currently calculating the signed distance for,\n        // is inside the volume or outside,\n        // as this determines its sign:\n        // Inside -> negative\n        // Outside -> positive\n        bool fragIsIn = isIn(samplingCenterUV, noise.z);\n        \n        float squaredDistanceToEdge = maxSqrDist;\n        for(int dx=-iRange; dx <= iRange; dx++)\n        {\n            for(int dy=-iRange; dy <= iRange; dy++)\n            {\n                vec2 delta = vec2(dx, dy);\n                vec2 scanPosition = startPosition + vec2(dx, dy);\n                float scanDistanceSqr = dot(delta, delta);\n\n                // Ideally we'd use a precomputed sampling pattern\n                // that avoids testing the corners that are out-of-range.\n                // Perhaps the compiler already unrolls the for loop \n                // and culls them?\n                if(scanDistanceSqr >= maxSqrDist)\n                    continue;\n                \n                // Already found one closer? Skip.\n                if(scanDistanceSqr >= squaredDistanceToEdge)\n                    continue;\n\n                bool scanIsIn = isIn(scanPosition / iChannelResolution[0].xy, noise.z);\n                \n                // Sign change?\n                if (scanIsIn != fragIsIn)\n                {\n                    // We found a boundary!\n                    squaredDistanceToEdge = scanDistanceSqr;\n                }\n            }\n        }\n\n        distanceToEdge = sqrt(squaredDistanceToEdge);\n\n        // The minimum distance is always 1,\n        // but the boundary lies between the pixels halfway.\n        // Correct the discontinuity this creates\n        // in the distance field (a flat region at the sign change\n        // boundary) by subtracting the pixel radius\n        // from the distance.\n        distanceToEdge -= 0.5;\n\n        // Make the distance signed:\n        // Inside -> negative\n        // Outside -> positive\n        distanceToEdge = fragIsIn ? -distanceToEdge : distanceToEdge;\n        \n        // Convert distance in pixels \n        // from -range to +range\n        // to 0 to 1 \n        distanceToEdge /= range * 2.;\n        distanceToEdge = 0.5 - distanceToEdge;\n    }\n    \n    // This step will prevent us from generating\n    // a true signed distance field, but is useful\n    // for terrain because it removes discontinuities\n    // in the gradient.\n    distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    \n    // Optionally repeating this step will remove\n    // curvature discontinuities, but\n    // reduces the influence of distant pixels too much.\n    //distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    \n    // NOTE: you can apply other transformations to\n    // \"distanceToEdge\" to change the character of the terrain.\n    // For example, squaring the values makes peaks pointier\n    // and cracks flatter.\n    // distanceToEdge *= distanceToEdge;\n    \n    fragColor = vec4(distanceToEdge, distanceToEdge, distanceToEdge, 1.0);\n\n    // Accumulate samples over time.\n    {\n        vec2 uv = (fragCoord.xy) / iChannelResolution[2].xy;\n        vec4 oldColor = texture(iChannel2, uv);\n\n        // This block of code was to make the terrain\n        // \"grow\" instead of expose the poorly resolved\n        // initial state with few samples.\n        /*if(oldColor.a == 0.)\n        {\n            oldColor.rgb = vec3(25.);\n            oldColor.a = 50.;\n        }*/\n\n        fragColor += oldColor;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float perlin(vec2 uv)\n{\n    uv += vec2(8.2813, 1.42114);\n    uv /= 4.0;\n    vec2 occ = vec2(0);\n    float a = 1.0;\n    for(int i = 0; i < 7; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= 0.5;\n        a *= 2.0;\n    }\n    float v = occ.x / occ.y;\n    \n    // Increase contrast\n    // (though this will flatten the tops and bottoms).\n    v = v * 2.0 - 1.0;\n    v = tanh(v * 2.0);\n    v = v * 0.5 + 0.5;\n    \n    // Make peaks pointer and valleys flatter.\n    v *= v;\n    \n    return v;\n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    float height = perlin(uv);\n    fragColor = vec4(height, height, height, 1);\n}", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3Dz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 339], [341, 341, 398, 398, 1478]], "test": "untested"}
{"id": "DdB3WR", "name": "Fuzzy Signed Distance", "author": "Hatchling", "description": "Allows computation of signed distance fields wherein there is not a binary boundary separating inside from outside. That is, occupancy isn't 0 or 1, it is a range from 0...1. The occupancy could represent probabilities, for example.", "tags": ["2d", "sdf", "text", "distance", "field", "vector", "bruteforce", "signed", "valve", "scaling"], "likes": 8, "viewed": 372, "published": 3, "date": "1667437700", "time_retrieved": "2024-07-30T16:23:02.462917", "image_code": "vec2 compress(vec2 vec)\n{\n    float mag = sqrt(dot(vec, vec));\n\n    float newMag = mag;\n\n    // Softly compress the range \n    // from 0 to +Inf\n    // to 0 to +1 \n    // instead of clipping values\n    // when contrast is used for visualization.\n    newMag = newMag / (0.5 + newMag);\n\n    vec *= newMag / (mag + 0.00001);\n    return vec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvC = fragCoord.xy / iResolution.xy;\n\tvec2 uvR = (fragCoord.xy + vec2(1,0)) / iResolution.xy;\n\tvec2 uvT = (fragCoord.xy + vec2(0,1)) / iResolution.xy;\n\tvec2 uvL = (fragCoord.xy - vec2(1,0)) / iResolution.xy;\n\tvec2 uvB = (fragCoord.xy - vec2(0,1)) / iResolution.xy;\n    vec2 colC = texture(iChannel0, uvC).ra;\n    vec2 colR = texture(iChannel0, uvR).ra;\n    vec2 colT = texture(iChannel0, uvT).ra;\n    vec2 colL = texture(iChannel0, uvL).ra;\n    vec2 colB = texture(iChannel0, uvB).ra;\n    \n    colC.r /= colC.g;\n    colR.r /= colR.g;\n    colT.r /= colT.g;\n    colL.r /= colR.g;\n    colB.r /= colT.g;\n    \n    \n    vec2 gradient = vec2(colL.r - colR.r, colB.r - colT.r);\n    vec2 curvature = vec2\n    (\n        colL.r + colR.r - 2.0 * colC.r, \n        colB.r + colT.r - 2.0 * colC.r \n    ) * 0.5;\n    \n    \n    // Enhance gradient+curvature contrast.\n    vec2 both = compress(gradient * 20.0 - curvature * 200.0);\n    \n    \n    // Unmodified gradients:\n    // vec2 gradient = vec2(colC.r - colR.r, colC.r - colT.r);\n    \n    fragColor = vec4(both * 0.5 + 0.5, colC.r, 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat luminance(vec3 color)\n{\n    color = color * color;\n    return sqrt(dot(vec3(0.299, 0.587, 0.114), color));\n    \n    //(0.2126*R + 0.7152*G + 0.0722*B)\n    //return dot(vec3(0.2126, 0.7152, 0.0722), color);\n}\n\nbool isIn(vec2 uv, float threshold)\n{\n    // Occupancy based on alpha?\n\tfloat occupancy = texture(iChannel0, uv).a;\n    \n    // Occupancy based on luminance?\n    //float occupancy = luminance(texture(iChannel0, uv).rgb); \n    \n    // Add contrast?\n    /*occupancy = occupancy * 2.0 - 1.0;\n    occupancy = tanh(occupancy * 3.0);\n    occupancy = occupancy * 0.5 + 0.5;*/\n    \n\treturn occupancy > threshold;\n}\n\nfloat squaredDistanceBetween(vec2 uv1, vec2 uv2)\n{\n    vec2 difference = uv1 - uv2;\n    return dot(difference, difference);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    // Compute the noise.\n    vec3 noise;\n    {\n        \n        // Cycle the noise.\n        // We do the cycling FIRST to prevent\n        // loss of precision that might\n        // round away the noise values.\n        //   - Use the golden ratio as it should land\n        //     on all fractional values eventually.\n        noise = vec3(iFrame, iFrame+1, iFrame+2);\n        noise *= 1.618033;\n        noise -= floor(noise);\n    \n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n        // (Disable to prevent gradient noise).\n        //vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        //noise += texture(iChannel1, noiseUV).r;\n        //noise -= floor(noise);\n        \n        noise.xy -= 0.5f;\n    }\n    \n    // Compare with and without fuzziness.\n    if(uv.x > 0.5)\n        noise.z = 0.5;\n       \n    vec2 samplingCenter = fragCoord + noise.xy;\n    vec2 samplingCenterUV = samplingCenter / iResolution.xy;\n    \n    const float range = 64.0;\n    const int iRange = int(range);\n    const float halfRange = range / 2.0;\n    const float maxSqrDist = halfRange*halfRange;\n    vec2 startPosition = samplingCenter - halfRange;\n    \n    bool fragIsIn = isIn(samplingCenterUV, noise.z);\n    float squaredDistanceToEdge = maxSqrDist;\n    \n    for(int dx=0; dx < iRange; dx++)\n    {\n        for(int dy=0; dy < iRange; dy++)\n        {\n            vec2 scanPosition = startPosition + vec2(dx, dy);\n            float scanDistance = squaredDistanceBetween(samplingCenter, scanPosition);\n                \n            if(scanDistance > maxSqrDist)\n                continue;\n                \n            bool scanIsIn = isIn(scanPosition / iResolution.xy, noise.z);\n            if (scanIsIn != fragIsIn)\n            {\n                if (scanDistance < squaredDistanceToEdge)\n                    squaredDistanceToEdge = scanDistance;\n            }\n        }\n    }\n    \n    float distanceToEdge = sqrt(squaredDistanceToEdge);\n\n    if (fragIsIn)\n    {\n        // We add 1.0 here since the edge is on the inside\n        // of the boundary.\n        // Otherwise you'll get a weird seam at the sign change\n        // boundary.\n        distanceToEdge = 1.0-distanceToEdge;\n    }\n        \n    distanceToEdge /= range;\n        \n    distanceToEdge = 0.5 - distanceToEdge;\n    \n    // For continuity\n    //distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    //distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    \n    //if (normalised > 0.5)\n    //   fragColor = vec4(1.0);\n    //else\n    \tfragColor = vec4(distanceToEdge, distanceToEdge, distanceToEdge, 1.0);\n\n    fragColor += texture(iChannel2, uv);\n}\n", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdB3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 339], [341, 341, 398, 398, 1477]], "test": "untested"}
{"id": "ms23RW", "name": "reaction diffusion experiment 3", "author": "ufffd", "description": "exploring some more ideas with reaction diffusion\nsome kind of smoke trail that generates stacking slime\na bit hacky and incomplete but I like the look so I'm saving this and iterating onwards", "tags": ["reactiondiffusion"], "likes": 9, "viewed": 301, "published": 3, "date": "1667432233", "time_retrieved": "2024-07-30T16:23:03.583920", "image_code": "const int DEBUG = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    \n    // fetch buffers\n    vec4 buffA = texture(iChannel0,uv);\n    vec4 buffB = texture(iChannel1,uv);\n\n    // fragColor = vec4(vec3(1.-texture(iChannel1,uv,5.5).a),1.); return;\n    \n    // if (iMouse.z>0.5 && muv.x<uv.x) {\n    if (uv.x+uv.y<1.) {\n        // fragColor = vec4(buffB.rrr,1.); return;\n    }\n    \n    // debug\n    if (DEBUG==1)\n        fragColor = 1.-buffA;\n    if (DEBUG==2)\n        fragColor = 1.-buffB;\n    if (DEBUG==3)\n        fragColor = buffB - buffA;\n    if (DEBUG==4)\n        fragColor = vec4(buffB.ab, buffA.ab);\n    if (DEBUG!=0) return;\n\n    // colorize\n    vec3 col = buffB.bbb / buffB.aaa;\n    col = smoothstep(0.2,0.9,col);\n    \n    col *= buffA.a;\n    col.b += buffA.b*0.4;\n    col.r += buffA.b*buffA.b*buffA.b*0.8;\n    col.g *= 1.-buffA.b;\n    col -= smoothstep(0.5,0.9,buffA.b);\n    col.b += smoothstep(0.99,1.,buffA.b)*.7;\n    \n    col.r *= .2;\n    col.g *= uv.y;\n    \n    col = 1. - col;\n    col.r *= col.r;\n    col.b *= col.r;\n    col = 1. - col;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"smoke\"\nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 3.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    px *= 1.;\n    range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.025;\n            if (i>1||j>1) factor = 0.025;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum / 2.;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 0.95;\n    float dB = .3;\n    float feed = 0.06 + sin(iTime*4.)*0.05;\n    float k = 0.06 + 0.01*sin(iTime);\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    vec2 uvc = (fragCoord*2. - R.xy)/R.y;\n    vec2 muvc = (iMouse.xy*2. - R.xy)/R.y;\n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec2 offset = vec2(0.,0.001) + noise(vec3(uvc,iTime*0.5))*0.01;\n    fragColor.ab = setAB(uv-offset,cdist);\n    if (iMouse.z > 0.5 && mdist<0.1) { \n        fragColor.b = 1.; \n        fragColor.a = 0.; \n    }\n    \n    // init animation\n    if (iMouse.z < 0.00001) {\n        vec2 p = vec2(0.,.75);\n        p.x += sin(iTime)*0.666;\n        p.x += sin(iTime*3.3)*0.25;\n        p.x += smoothstep(.1,.9,sin(iTime*.5)*0.5+0.5)*1.4 - 0.7;\n        p.y += sin(iTime*3.7)*0.05;\n        p.y -= smoothstep(.4,.9,sin(iTime*0.2)*.5+.5)*1.5;\n        float pdist = distance(uvc, p);\n        if (pdist < .1+sin(iTime*1.6)*.05) {\n            fragColor.b = 1.;\n            fragColor.a = 0.;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"slime\"\nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 1.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 1.1;\n    float dB = .35;\n    float feed = 0.055;\n    float k = 0.059;\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (R.y-fragCoord.y<1.5) {fragColor = vec4(0.);return;} // skip the top pixel row to avoid artifacts\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    vec2 uvc = (fragCoord*2. - R.xy)/R.y;\n    vec2 muvc = (iMouse.xy*2. - R.xy)/R.y;\n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec2 px = 1./iResolution.xy;\n\n    /* \n       slime stacking:\n       this works by comparing mipmaps at the current location vs \n       a location below to get a \"slime differential\" (?).\n       this was coded by feel, I think this general method could \n       be tuned to be more interesting or \"realistic\"\n   */\n    float drip_speed = 1.;\n    vec2 look_below = vec2(0,.05);\n    look_below.x += noise(vec3(uvc,iTime))*px.x; // fuzz left and right slightly\n    // check how much \"slime\" is below\n    float slime_below = texture(iChannel0, uv-look_below, 4.).a;\n    // wider \"slime\" check\n    slime_below += texture(iChannel0, uv-look_below*2., 8.).a;\n    // negative check within current space - to avoid slime columns\n    slime_below /= .2+.8*texture(iChannel0, uv, 4.).a;\n    slime_below = smoothstep(2.,.5,slime_below);\n    fragColor.r = slime_below/2.; // debug\n    drip_speed *= 1.-slime_below;\n    // slow down at the bottom\n    drip_speed *= 0.1+0.9*smoothstep(0.02,0.2,uv.y);\n    // drip\n    uv.y += drip_speed*px.y;\n    \n    float xoffset = -uvc.x*px.x;\n    uv.x += mix(0.,xoffset,slime_below);\n    // uv.x += sin(slime_below*3.)*px.x;\n    \n    vec2 buffA = texture(iChannel1,uv).ab;\n    \n    fragColor.ab = mix(\n        mix(setAB(uv,cdist),vec2(0.),0.001),\n        buffA,\n        (1.-buffA.x)*0.05\n      );\n    if (iMouse.z > 0.5) {\n        if (mdist<0.05) { fragColor.b = 1.; fragColor.a = 0.; }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat nsin(in float a) {\n    return sin(a)*0.5+0.5;\n}\n\n\n// hashes from Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// 3D noise from IQ\n// returns 3D value noise\nfloat noise( in vec3 x ) {\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash33( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash33( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash33( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash33( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash33( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash33( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash33( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash33( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 129, 1236]], "test": "untested"}
{"id": "mdjGzm", "name": "lissajous curves series", "author": "jonasfrey", "description": "lissajous curves", "tags": ["trace"], "likes": 5, "viewed": 193, "published": 3, "date": "1667427835", "time_retrieved": "2024-07-30T16:23:04.437637", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool f_b_inside_square(\n    float n_x_translation_normalized, \n    float n_y_translation_normalized, \n    float n_x_scale_normalized, \n    float n_y_scale_normalized, \n    vec2 a_n_pixel_coords_normalized\n){\n\n    \n    if(\n        a_n_pixel_coords_normalized.x < n_x_translation_normalized + n_x_scale_normalized \n        &&\n        a_n_pixel_coords_normalized.x > n_x_translation_normalized \n        &&\n        a_n_pixel_coords_normalized.y < n_y_translation_normalized + n_y_scale_normalized \n        &&\n        a_n_pixel_coords_normalized.y > n_y_translation_normalized \n    ){\n        return true;\n    }\n    return false;\n    \n}\nbool f_b_inside_circle(\n    float n_x_translation_normalized, \n    float n_y_translation_normalized, \n    float n_x_scale_normalized, \n    float n_y_scale_normalized, \n    vec2 a_n_pixel_coords_normalized\n){\n\n    vec2 a_n_center = vec2(\n        n_x_translation_normalized - (n_x_scale_normalized/2.0),\n        n_y_translation_normalized - (n_y_scale_normalized/2.0)\n    );\n    float n_radius = (n_x_scale_normalized + n_y_scale_normalized) /2.0;\n    //float n_radius = n_x_scale_normalized;    \n    return \n        pow(a_n_pixel_coords_normalized.x - a_n_center.x,2.0) \n        +\n        pow(a_n_pixel_coords_normalized.y - a_n_center.y,2.0)\n        <\n        pow(n_radius,2.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a_n_pixel_coords_normalized = fragCoord.xy / iResolution.xy; \n    vec2 a_n_mouse_coords_normalized = iMouse.xy / iResolution.xy; \n    //Normalized pixel coordinates (from 0 to 1)\n    float n_max_freq_y = 10.0;\n   float n_max_freq_x = 10.0;\n   float n_amp = 1.0/n_max_freq_x/2.0;//(iResolution.x);\n   float n = 0.0;\n\n   float n_freq_x = float(int(n_max_freq_x * a_n_mouse_coords_normalized.x));\n   float n_freq_y = float(int(n_max_freq_y * a_n_mouse_coords_normalized.y));\n\n    \n    float n_x_scale_normalized = 0.005; \n    float n_y_scale_normalized = 0.005;\n\n\n\n    vec2 a_n_pixel_coord_normalized = fragCoord.xy / iResolution.xy; \n    \n    for(float n_x = 0.0; n_x < n_max_freq_x; n_x+=1.0){\n        for(float n_y = 0.0; n_y < n_max_freq_y; n_y+=1.0){\n\n            vec2 a_n_sincos_trans = vec2(\n                sin(iTime*n_x+n_x*a_n_mouse_coords_normalized.x)*n_amp,\n                cos(iTime*n_y+n_y*a_n_mouse_coords_normalized.y)*n_amp\n            );\n    \n            vec2 a_n_current = vec2(\n                (1.0/n_max_freq_x) * n_x,\n                (1.0/n_max_freq_y) * n_y\n            );\n            vec2 a_n_res = a_n_current.xy + a_n_sincos_trans.xy;\n             bool b_inside_square = f_b_inside_circle(\n                a_n_res.x,\n                a_n_res.y,\n                n_x_scale_normalized,\n                n_y_scale_normalized,\n                a_n_pixel_coords_normalized\n             );\n             if(b_inside_square){\n                 n = 1.0;\n             }  \n        }\n    }\n    vec4 a_n_color_old = texture(iChannel0, a_n_pixel_coord_normalized);\n    n = n+(a_n_color_old.r-0.01);\n    n = clamp(n, 0.0, 1.0);\n    fragColor = vec4(\n        n,\n        n,\n        n,\n        n\n    );\n   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 190]], "test": "untested"}
{"id": "cs2GRm", "name": "random blur", "author": "jonasfrey", "description": "random blur", "tags": ["blur", "random"], "likes": 0, "viewed": 170, "published": 3, "date": "1667427827", "time_retrieved": "2024-07-30T16:23:05.417019", "image_code": "float f_n_random(\n    float n_input\n){\n    float n_mouse_x_normalized = iMouse.x / iResolution.x;\n    float n_mouse_y_normalized = iMouse.y / iResolution.y;\n    float n_amplitude_max = 2097593.0;//large prime number\n    float n_amplitude = n_amplitude_max * n_mouse_y_normalized;\n    float n = 1.0;\n \n    n = sin(n_input)*n_amplitude* n_mouse_x_normalized;\n    \n\n    \n    return mod(n, 1.0);\n}\nvec4 f_a_n_blurred(\n    float n_scale_x_kernel, \n    float n_scale_y_kernel, \n    float n_x_kernel, \n    float n_y_kernel\n){\n    \n    vec4 a_n_rgba_sum = vec4(0.0,0.0,0.0,0.0);\n    int n_x = 0; \n    int n_y = 0; \n    for(int n_y; n_y < int(n_scale_y_kernel); n_y+=1){\n        for(int n_x; n_x < int(n_scale_x_kernel); n_x+=1){\n            //int n_x_current = n_x - int(float(n_scale_x_kernel)/2.0);\n            //int n_x_current = n_y - int(float(n_scale_y_kernel)/2.0);\n            vec2 n_coords_normalized_kernel = vec2(\n                float(n_x) + n_x_kernel - float(n_scale_x_kernel)/2.0, \n                float(n_y) + n_y_kernel - float(n_scale_y_kernel)/2.0\n            )/iResolution.xy;\n            a_n_rgba_sum+=texture(\n                iChannel0,\n                n_coords_normalized_kernel \n                \n            );\n        }\n    }\n    return a_n_rgba_sum / (n_scale_x_kernel * n_scale_y_kernel);\n}\nvoid mainImage( out vec4 a_n_rgba_out, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 a_n_coords_normalized_mouse = iMouse.xy / iResolution.xy;\n    vec2 a_n_coords_normalized_pixel = fragCoord.xy / iResolution.xy; \n    \n\n    float n_max_kernel_size = 66.0;\n    float n_kernel_max_by_mouse = n_max_kernel_size * a_n_coords_normalized_mouse.x;\n    float n_random = f_n_random(a_n_coords_normalized_pixel.x*a_n_coords_normalized_pixel.y);\n\n    float n_kernel = n_kernel_max_by_mouse * n_random;\n    vec4 a_n_rgba_blurred = vec4(0.0,0.0,0.0,0.0);\n    \n        a_n_rgba_out = f_a_n_blurred(\n            n_kernel+1.0,\n            n_kernel+1.0,\n            fragCoord.x,\n            fragCoord.y\n       );\n\n    \n\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2GRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 393], [394, 394, 518, 518, 1309], [1310, 1310, 1370, 1420, 2049]], "test": "untested"}
{"id": "DsjGzW", "name": "ways to get random noise", "author": "jonasfrey", "description": "methods to get random noise", "tags": ["random"], "likes": 0, "viewed": 163, "published": 3, "date": "1667427823", "time_retrieved": "2024-07-30T16:23:06.192944", "image_code": "const int N_FUNCTION_TYPE_SIN =  1;\nconst int N_FUNCTION_TYPE_COS =  2;\nconst int N_FUNCTION_TYPE_TAN =  3;\nconst int N_FUNCTION_TYPE_LOG =  4;\n\nfloat f_n_random(\n    float n_input,\n    int n_function_type\n){\n    float n_mouse_x_normalized = iMouse.x / iResolution.x;\n    float n_mouse_y_normalized = iMouse.y / iResolution.y;\n    float n_amplitude_max = 1111111.0;\n    float n_amplitude = n_amplitude_max * n_mouse_y_normalized;\n    float n = 1.0;\n    if(n_function_type == N_FUNCTION_TYPE_SIN){\n        n = sin(n_input)*n_amplitude* n_mouse_x_normalized;\n    }\n    if(n_function_type == N_FUNCTION_TYPE_COS){\n        n = cos(n_input)*n_amplitude* n_mouse_x_normalized;\n    }\n    if(n_function_type == N_FUNCTION_TYPE_TAN){\n        n = tan(n_input)*n_amplitude* n_mouse_x_normalized;\n    }\n    if(n_function_type == N_FUNCTION_TYPE_LOG){\n        n = log(n_input)*n_amplitude* n_mouse_x_normalized;\n    }\n\n    \n    return mod(n, 1.0);\n}\n\nvoid mainImage( out vec4 a_n_rgba_out, in vec2 fragCoord )\n{\n\n\n    vec2 a_n_normalized_frag = fragCoord.xy/iResolution.xy;\n\n    float a_n_rand[] = float[](\n       f_n_random(\n            fragCoord.x, \n            N_FUNCTION_TYPE_SIN\n       ), \n       f_n_random(\n            fragCoord.x, \n            N_FUNCTION_TYPE_COS\n       ), \n       f_n_random(\n            fragCoord.x, \n            N_FUNCTION_TYPE_TAN\n       ), \n       f_n_random(\n            fragCoord.x, \n            N_FUNCTION_TYPE_LOG\n       )\n    );\n    float n = 0.0;\n    int n_len_a_n_random = a_n_rand.length();\n    for(\n        int n_index_a_n_random = 0;\n        n_index_a_n_random < n_len_a_n_random;\n        n_index_a_n_random++\n      )\n    {\n        if(a_n_normalized_frag.y > (1.0/float(n_len_a_n_random)) * float(n_index_a_n_random)){\n            n = a_n_rand[n_index_a_n_random];\n        }\n    }\n\n\n    \n    a_n_rgba_out = vec4(\n        n, \n        n, \n        n, \n        1.0\n    );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 208, 208, 936]], "test": "untested"}
{"id": "msSGzW", "name": "Mousetest", "author": "jonasfrey", "description": "this is only a test for the mouse, click and drag on the x-axis", "tags": ["mouse"], "likes": 0, "viewed": 170, "published": 3, "date": "1667427767", "time_retrieved": "2024-07-30T16:23:06.948923", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float n_mouse_x_normalized = iMouse.x / iResolution.x; \n    //float n_index_pixel = float(fragCoord.x) + float(fragCoord.y)*float(iResolution.x);\n    float n_index_pixel = fragCoord.y * iResolution.x + fragCoord.x;\n    float n_brightness = mod(iTime + n_index_pixel*0.01*n_mouse_x_normalized, 1.0);\n\n    // Output to screen\n    fragColor = vec4(\n        n_brightness,\n        n_brightness,\n        n_brightness,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 495]], "test": "untested"}
{"id": "msBGzm", "name": "Glowy room", "author": "z0rg", "description": "boom tssst boom tssst boom tssst boom tssst boom tssst titititititititi boom tssst boom tssst boom tssst boom tssst boom tssst !", "tags": ["light", "glow", "techno", "boomboom", "darkroom"], "likes": 31, "viewed": 579, "published": 3, "date": "1667427101", "time_retrieved": "2024-07-30T16:23:07.833558", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += (1.-abs(f))*texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n\n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    //rgb = pow(rgb, vec3(1.));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW 1.1\n#define GLOW_OPACITY 15.\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return fract(sin(seed*123.456789)*123.456);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n#define FFT(a) (texture(iChannel3, vec2(a,0.)).x*.75)\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 4.;\n    if (iTime > 104. && iTime < 174.)\n        fov = 2.+sin(iTime*.3);\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    acc = _min(acc, vec2(length(p+vec3(2.,-3.8,-4.))-2.5, 0.));\n    \n    float cube = -_cube(p, vec3(6.));\n    acc = _min(acc, vec2(cube, 1.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 20.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n    vec3 col = n*.5+.5;\n    vec3 emit = vec3(0.);\n    if (res.z == 1.)\n    {\n        col = vec3(0.);\n        if (sin(iTime+FFT(.1)*13.) > 0.1)\n        {\n        if (p.y < -5.)\n        {\n            emit = vec3(1.)*sat(sin(p.z*5.+iTime));\n            float beat = 1./8.;\n            \n            emit *= mix(1.,.2,(mod(iTime, beat)/beat)*sat(10.*sin(iTime)));\n        }\n        }\n        else\n        {\n            if (p.y > 5.5)\n            {\n                vec2 luv = p.xz;\n                float pix = 1.5;\n                luv = floor(luv/pix)*pix;\n                vec3 rgb = mix(vec3(0.1,.1,1.), vec3(1.000,0.506,0.102)*2., sat(-.5+sin(length(luv)*5.-5.*iTime)));\n                emit = rgb*sat(sin(p.z*3.)*sin(p.x*3.)*10.);\n            }\n        }\n    }\n    if (res.z == 0.)\n    {\n        col = vec3(0.);\n        float freq = 10.;\n        float stpt = 2.;\n        float t = floor(5.*iTime/stpt)*stpt;\n        vec3 rgb = mix(vec3(1.), vec3(1.,.1,.1), abs(sin(p.x*2.)));\n        rgb *= 1.-sat((abs(p.y-4.)-1.)*10.);\n        emit = 2.*sat(sin(p.x*freq+t)*sin(p.y*freq)*sin(p.z*freq-t))*rgb;\n    }\n    col += emit;\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    uv += (vec2(rand(), rand())-.5)*.02*pow(FFT(.8)*2.,2.)*sat(sin(iTime*.33));\n    float stp = 1.9;\n    float t = floor(iTime/stp)*stp;\n    uv *= r2d((hash11(t)-.5)*.5);\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(sat(sin(iTime)*3.)*3.,3.5+mod(iTime, 2.)*sign(sin(iTime*.33)),-4.);\n    vec3 ta = vec3(2.,3.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(p, n, rd, res);\n        if (true)\n        {\n            vec3 refl = rd;\n            for (float i = 0.; i < 8.; ++i)\n            {\n                refl = reflect(refl, n);\n                float gloss = pow(texture(iChannel2, (p.xz+p.y*.5)*.5).x, 2.);\n                refl = normalize(refl+normalize(vec3(rand(),rand(), rand())-.5)*.2*gloss);\n                vec3 resrefl = trace(p+n*.01, refl, 128);\n                if (resrefl.y > 0.)\n                {\n                    p = p+refl*resrefl.y;\n                    n = getNorm(p, resrefl.x);\n                    col += .5*getMat(p, n, refl, resrefl);\n                }\n            }\n\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 1.9/(col+1.);\n\n    col = sat(col);\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .3);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30033, "src": "https://soundcloud.com/i_oofficial/404-anonymous?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += (1.-abs(f))*texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGzm.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1087]], "test": "untested"}
{"id": "cdjGzw", "name": "Dreaming in the Clouds", "author": "kishimisu", "description": "my second test with volumetric raymarching! move the view with the mouse", "tags": ["volume", "fbm", "light", "fog", "smoke"], "likes": 45, "viewed": 1413, "published": 3, "date": "1667415701", "time_retrieved": "2024-07-30T16:23:08.598512", "image_code": "/* Testing my recent volumetric raymarcher on more complex \n   and dynamic scenes.\n   I think the lighting (especially the sky) could be improved.   \n*/\n#define MAX_ITER 300.\n#define MAX_DIST 25.\n#define ABSORPTION 10.\n\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) * 43758.5453123)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// noise and fbm are from https://www.shadertoy.com/view/XtS3DD\nfloat noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod(iChannel0, (tap+0.5)/256.0, 0.0).yx;\n\treturn mix(rz.x, rz.y, fp.z);\n}\n\nfloat fbm(in vec3 x) {\n    x += vec3(iTime*.015, iTime*.035, 0.);\n    \n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<4; i++) {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz - .25;\n}\n\n\n// signed distance to volume\nfloat vol(vec3 p) {\n    p.z += iTime*.8;\n    float r = fbm(p) + max(0., p.y) - .1 - .08*smoothstep(1.,0.,length(p.xy));\n    return p.y - r*((cos(iTime*.146+1.)*.5+.5)*.1+.9) - (sin(iTime*.2)*.5+.5)*abs(p.x)*.1;\n}\n\n// get light visibility at point\nfloat sampleLight(vec3 ro, vec3 lightPos, float att) {  \n    float t = 0., visibility = 1., stepSize = 0.005*2.;\n    vec3 rd = normalize(ro-lightPos);\n    float dstLight = length(ro-lightPos);\n    \n    // directional light if att < 0., else point light\n    float attenuation = att < 0. ? 1. : smoothstep(0., 1., att / pow(dstLight, 2.0));\n    \n    for (int i = 0; i < 9; i++) {\n        vec3 p = ro + t*rd;\n        float d = vol(p);\n        t += max(stepSize, d) + hash33(p).x*.002;\n        if (d < 0.) visibility *= exp(-stepSize*ABSORPTION);\n        if (t > dstLight) break;\n    }\n    \n    return visibility * attenuation;\n}\n\nvoid initCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy;\n    \n    ro = vec3(0., 0.25, 0.);                                   // camera position\n    float mx = (sin(-(iTime-3.)*.2)*.5)*.8 - (m.x*2.-1.)*.5 + 1.54; // camera x rotation\n    float my = (m.y-.5)*.5;                                    // camera y rotation\n    \n    vec3 f = normalize(vec3(cos(mx), my, sin(mx))),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = ro+f,\n         i = c + uv.x*r + uv.y*u;    \n    rd = normalize(i-ro); // camera direction\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro, rd;\n    \n    initCamera(fragCoord, ro, rd);\n    \n    float visibility = 1.;\n    vec3 vColor = vec3(0.), color = vec3(.14,0.08,.12)*.85;\n    \n    float t = 0., eps = 0.0005;\n    float inside = vol(ro) < 0. ? 1. : 0.;\n            \n    for (float i = 0.; i < MAX_ITER; i++) {\n        vec3 p = ro + t*rd;\n        \n        float dvol = vol(p);\n        float d = abs(dvol) + 0.001*t;\n        t += d;\n                \n        bool isInsideVolume = mod(inside, 2.) > .5;\n        \n        if (!isInsideVolume) { \n            if (dvol < eps) { \n                inside++; t += eps*10.; // enter volume\n            }\n        } else {    \n            if (dvol > -eps) {  \n                inside++; t += eps*10.; // exit volume\n            } else {\n                // sample density & light\n                float prev = visibility;\n                visibility *= exp(-d*ABSORPTION);\n                \n                vec3 absorption = vec3(prev - visibility);\n                \n                absorption *= mix(color, vec3(1.), exp(-t*.05));\n                vColor += absorption * sampleLight(p, -vec3(0., 4., 0.), 10.) * vec3(1.2,.6,.3)*.75;\n                vColor += absorption * sampleLight(p, -vec3(0., 1e6, 0.), -1.) * (vec3(1.3, 1.,.8)*.5 + 0.5*fbm(p));\n                        \n                if (visibility <= .01 || dot(vColor, vColor) >= 3.) break;    \n            }\n        }\n        \n        if (t > MAX_DIST) { i = 0.; break; }\n    }\n        \n    color = vColor + color * visibility;\n        \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 358, 358, 410], [412, 476, 500, 500, 716], [718, 718, 740, 740, 945], [948, 977, 996, 996, 1189], [1191, 1224, 1278, 1278, 1849], [1851, 1851, 1914, 1914, 2536], [2538, 2538, 2595, 2595, 4134]], "test": "untested"}
{"id": "Nt2cDz", "name": "Step Grid", "author": "Yahor10", "description": "Grid fract try", "tags": ["firsttrygrid"], "likes": 0, "viewed": 194, "published": 3, "date": "1667412032", "time_retrieved": "2024-07-30T16:23:09.448241", "image_code": "mat2 rotate(float r){\n  \n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c,-s,s,c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x-=.5;\n      uv.x *=iResolution.x/iResolution.y;\n      float x = 0.0;\n      float y =.0;\n      vec2 uvl = rotate(.7) *uv;\n      vec2 uvr = rotate(-.7) *uv;\n      vec2 uvres = fract(uvl+uvl.x *10.0 ); \n      vec2 uvrightres = fract(uvr+uvr.x*10.0);\n      float leftDiagonal = step(uvres.x,.343)-step(uvres.x,.32);\n      float rightDiagonal = step(uvrightres.x,.343)-step(uvrightres.x,.32);\n\n       // Output to screen\n      fragColor =vec4(vec4(rightDiagonal) * vec4(.0,1.0,.0,1.0)  + vec4(leftDiagonal) * vec4(1.0,.0,.0,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2cDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 91], [92, 92, 149, 199, 775]], "test": "untested"}
{"id": "ftlfzn", "name": "First polar coordinates", "author": "Yahor10", "description": "Simple polar coordinates data", "tags": ["atan", "polar"], "likes": 0, "viewed": 156, "published": 3, "date": "1667411998", "time_retrieved": "2024-07-30T16:23:10.204220", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float p2 = length(uv);\n    float p1 = 1.0 + atan(uv.y,uv.x)/6.28   + p2  *sin(iTime)*5.2 ;\n    float fff = fract(p1);\n    \n     vec4 r = mix(vec4(.73888,vec3(1.0,.0,.0)),vec4(.0,.0,.6660,1.0),smoothstep(.22,.3,fff));\n    // Output to screen\n    fragColor = vec4(r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 470]], "test": "untested"}
{"id": "ddBGzm", "name": "Pinguin Sketchy Contour", "author": "rubioh", "description": "Inspire by: https://www.shadertoy.com/view/cs23zR", "tags": ["pinguinsketchycontour"], "likes": 11, "viewed": 235, "published": 3, "date": "1667393145", "time_retrieved": "2024-07-30T16:23:11.009067", "image_code": "const int MAX_MARCHING_STEPS = 250;\nconst float MIN_DIST = 5.;\nconst float MAX_DIST = 30.0;\nconst float PRECISION = 0.01;\n#define AA 0\n#define PI 3.14159\n#define TAU 6.28318\n\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash33( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// Some iq's function\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvec2 hash22(vec2 p)\n{\n    p *= 100.;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract(sin(p3.xy+p3.yz)*p3.zy);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat Tux(vec3 p, out vec3 col, out float obj, vec3 q, vec3 ro){\n    \n    float d = 1e10;\n    \n    // CORE\n    vec3 tmp = vec3(0. ,cos(iTime)*.1, 0.05-.03*cos(iTime));\n    vec3 tmp2 = vec3(cos(iTime)*.1, 0., 0.);\n    p += tmp;\n    vec3 b = vec3(.25,.8,.3);\n    vec3 pt = p;\n    pt.y -= .2;\n    float d2 = min(d, sdRoundBox(pt, b, .4));\n    if (d2<d){\n        d = d2;\n        col = vec3(.2);\n        obj = 1.;\n    }\n        \n    pt = p;\n    pt.y += .1;\n    pt *= 1.1;\n    d2 = sdSphere(pt, 1., vec3(0.));\n    if (d2<d){\n        col = mix(col, vec3(1.), smoothstep(0. ,0.01, abs(d2-d)-.02));\n        obj = smoothstep(0. ,0.01, abs(d2-d)-.03);\n    }\n    d = opSmoothUnion(d, d2, .5);\n    \n\n    pt = p+tmp2;\n    pt.y -= 1.;\n    pt *= 2.;\n    d2 = sdSphere(pt, 1.2, vec3(0.));   \n    if (d2<d){\n        col = vec3(.2);\n\n    }\n    d = opSmoothUnion(d, d2, .5);\n\n    // NOSE\n    pt = p+tmp2;\n    pt += vec3(0.,-.7, -.5);\n    pt *= 2.;\n    d2 = sdOctahedron(pt, 1.);\n    if (d2<d){\n        col = mix(col, vec3(.7, .7, 0.), smoothstep(0. ,0.01, abs(d2-d)-.02));\n        obj = smoothstep(0. ,0.01, abs(d2-d)-.03);\n    }\n    d = opSmoothUnion(d, d2, .05);\n    \n    \n    \n    // EYES\n    pt = p+tmp2;\n    pt.x = abs(pt.x);\n    pt += vec3(-.35, -1., -.55);\n    pt *= 3.5;\n    d2 = sdSphere(pt, 1., vec3(0.));   \n    if (d2<d){\n        col = mix(col, vec3(1.), smoothstep(0. ,0.01, abs(d2-d)-.02));\n        obj = smoothstep(0. ,0.01, abs(d2-d)-.03);\n    }\n    d = opSmoothUnion(d, d2, .05);\n    \n    pt = p+tmp2;\n    pt.x = abs(pt.x);\n    pt += vec3(-.35, -1., -.7);\n    pt *= 5.5;\n    d2 = sdSphere(pt, 1., vec3(0.));   \n    if (d2<d){\n        col = mix(col, vec3(0.), smoothstep(0. ,0.01, abs(d2-d)-.02));\n        obj = smoothstep(0. ,0.01, abs(d2-d)-.03);\n    }\n    d = opSmoothUnion(d, d2, .05);\n  \n  \n    // NAGEOIRE\n    pt = p;\n    pt.x = -abs(pt.x);\n    pt.y -= .3;\n    mat3 rot = rotateX(.25+sign(p.x)*.7*cos(iTime*4.));\n    pt *= rot;\n    pt.y += .3;\n\n    pt += vec3(1., 0., 0.);\n    rot = rotateZ(-.5);\n    pt = rot*pt;\n    vec3 r = vec3(1.,2.,1.)/3.;\n    d2 = sdEllipsoid(pt, r);   \n    if (d2<d){\n        col = mix(col, vec3(.1), smoothstep(0. ,0.01, abs(d2-d)-.02));\n        obj = smoothstep(0. ,0.01, abs(d2-d)-.03);\n    }\n    d = opSmoothUnion(d, d2, .01);\n    \n    \n    // PALME\n    pt = p;\n    pt.x = abs(pt.x);\n    pt += vec3(-.4, 1., -.3);\n    pt *= 3.5;\n    rot = rotateX(.3+sign(p.x)*.5*sin(iTime/2.));\n    pt *= rot;\n    r = vec3(1.3,1.,2.);\n    d2 = sdEllipsoid(pt, r);\n    if (d2<d){\n        col = mix(col, vec3(.7, .7, 0.), smoothstep(0. ,0.01, abs(d2-d)-.02));\n        obj = smoothstep(0. ,0.01, abs(d2-d)-.03);\n\n    }\n    d = opSmoothUnion(d, d2, .05);\n    \n\n    // Queue\n    pt = p;\n    pt += vec3(0., .9, 1.1);\n    pt.z -= .9;\n    rot = rotateY(.3*sin(iTime*4.));\n    pt *= rot;\n    pt.z += .9;    \n    \n    rot = rotateX(-PI/2.+.7);\n    pt *= rot;\n    d2 = sdRoundCone(pt, .2, .5, .7);\n    if (d2<d){\n        col = mix(col, vec3(.1), smoothstep(0. ,0.01, abs(d2-d)-.02));\n        obj = smoothstep(0. ,0.01, abs(d2-d)-.03);\n\n    }\n    d = opSmoothUnion(d, d2, .05);\n\n    return d;\n}\n\n\nfloat map(vec3 p, out vec3 col, out float obj, vec3 ro){\n    \n    float d = 1e10;    \n    vec3 c = vec3(3.)*2.;\n    vec3 q = mod(p+.5*c, c)-.5*c;\n    q = p; // Comment for a multitude of pinguin !!!!\n    d = min(d, Tux(q, col, obj, p, ro));\n    \n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end, out vec3 col, out float L, out float obj) {\n  float depth = start;\n  float id = 0.;\n  float depth2 = 1e10;\n  float dit = fract(sin(dot(rd, vec3(123.4588, 789.457, 0.))))*0.0001;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = map(p, col, obj, ro);\n    depth += d;\n    if (d < PRECISION){\n        depth2 = depth;\n        L = 1.;\n        break;\n        }\n    if(d < PRECISION*10.){\n        if (id != 1.){\n            col *= 0.;\n            depth2 = depth+dit;\n            L *= 0.;\n            \n        }\n      }\n    }\n  return depth2;\n}\n\nvec3 calcNormal(vec3 p, vec3 ro) {\n    vec2 e = vec2(1.0, -1.0) * 0.005; // epsilon\n    float r = 1.; // radius of sphere\n    vec3 c;\n    float obj;\n    \n    return normalize(\n      e.xyy * map(p + e.xyy, c, obj, ro) +\n      e.yyx * map(p + e.yyx, c, obj, ro) +\n      e.yxy * map(p + e.yxy, c, obj, ro) +\n      e.xxx * map(p + e.xxx, c, obj, ro));\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col) {\n  // ambient\n  vec3 ambient = col*(.5);\n\n  // diffuse\n  float dotLN = smoothstep(.45, .5, dot(lightDir, normal))/4.;\n  vec3 diffuse = col * dotLN;\n\n  // specular\n  float dotRV = smoothstep(.85, .9, (dot(reflect(lightDir, normal), -rd)));\n  vec3 specular = 2.*col * pow(dotRV, 5.);\n\n  return ambient + diffuse; + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1, .1, .1)*4.;\n  \n  vec3 col = vec3(0);\n  vec3 col_tot = vec3(0.);\n  vec3 ro = vec3(4., 4., 4.);\n  vec2 m = iMouse.xy/iResolution.xy;\n  if (m.xy == vec2(0.)){\n      m.x = .6;\n      m.y = .5;\n  }\n    vec3 tmp = vec3(0.,cos(iTime)*.1, 0.05-.03*cos(iTime));\n    tmp.z -= .8;\n    tmp.y -= 1.;\n    tmp.x -= .35;\n  vec3 lookat = tmp;// ray origin that represents camera position\n  ro.yz = ro.yz * 1. * rot(mix(PI/2., 0., m.y));\n  ro.xz = ro.xz * rot(mix(-PI, PI, m.x)) + vec2(lookat.x, lookat.z); // remap mouseUV.x to <-pi, pi> range  \n  \n  vec3 rd = camera(ro, lookat)*normalize(vec3(uv, -1)); // ray direction\n  \n  float w;\n  float obj = 1.;\n  for (int i = 0; i<AA+1; i++){\n      for (int j = 0; j<AA+1; j++){\n          \n          vec3 rd2 = rd + vec3(float(i), float(j), 0.)*(cos(iTime)*.0005);\n          float L = 1.;\n          float d = rayMarch(ro, rd2, MIN_DIST, MAX_DIST, col, L, obj); // distance to sphere\n\n          if (d > MAX_DIST) {\n            col_tot += backgroundColor/float(2*(AA+1)); // ray didn't hit anything\n          } else {\n            vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n            vec3 normal = calcNormal(p, ro);\n            vec3 lightPosition = vec3(1, 1, 2);\n            vec3 lightDirection = normalize(lightPosition - p);\n            float lint = 1.2;\n            \n            // Multiply the diffuse reflection value by an orange color and add a bit\n            // of the background color to the sphere to blend it more with the background.\n            if (L != 0.) col_tot += obj*lint*phong(lightDirection, normal, rd, col)/float((AA+1));\n            else col_tot *= 0.;\n          }\n    }\n  }  \n  \n  //vec3 tmp = fwidth(col_tot);\n  \n  // Output to screen\n  fragColor = vec4(col_tot, 1.0);\n}\n", "image_inputs": [], "common_code": "// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 rotate(vec3 theta) {\n    return rotateX(theta.x)*rotateY(theta.y)*rotateZ(theta.z);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 239, 239, 372], [374, 396, 448, 448, 569], [571, 571, 629, 629, 729], [731, 731, 752, 752, 903], [905, 905, 951, 951, 986], [988, 988, 1040, 1040, 1139], [1142, 1142, 1175, 1175, 1240], [1242, 1242, 1286, 1286, 1377], [1379, 1379, 1417, 1417, 1697], [1699, 1699, 1736, 1736, 1819], [1821, 1821, 1879, 1941, 2220], [2222, 2222, 2286, 2286, 5319], [5322, 5322, 5378, 5378, 5583], [5585, 5585, 5685, 5685, 6221], [6223, 6223, 6257, 6257, 6572], [6574, 6574, 6593, 6593, 6669], [6672, 6672, 6719, 6719, 6932], [6934, 6934, 6993, 7006, 7317], [7319, 7319, 7376, 7376, 9222]], "test": "untested"}
{"id": "dsSGzm", "name": "Fork Puddle Rip elevations 054", "author": "elevations02", "description": "trying to emulate reflection/ripples in a shallow body of water", "tags": ["water", "ripple", "puddle"], "likes": 3, "viewed": 222, "published": 3, "date": "1667391059", "time_retrieved": "2024-07-30T16:23:11.950550", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x;\n   \tuv.x += sin(uv.y*mix(1.0, 200.0, uv.y) + iTime) / 250.0;\n    uv.y += cos(uv.x*mix(1.0, 200.0, uv.y) - iTime * 8.0) / 250.0;\n\tfragColor = texture(iChannel0, uv) * vec4(1.0, 1.1, 1.0, 1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 313]], "test": "untested"}
{"id": "ddSGzm", "name": "Fork Water ripp elevations 930", "author": "elevations02", "description": "Inspired by this shader https://www.shadertoy.com/view/MtXSzs", "tags": ["ripple"], "likes": 1, "viewed": 190, "published": 3, "date": "1667389936", "time_retrieved": "2024-07-30T16:23:12.705531", "image_code": "float uvMult = 2.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv*=uvMult;\n    float len = length(uv - vec2(.5 * uvMult)) * 50.;    \n    vec2 s = normalize(uv) * ( sin((len - iTime * 10.))) * .01;      \n    vec4 tex = texture(iChannel0, uv + s);       \n    fragColor = tex;\n    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 76, 335]], "test": "untested"}
{"id": "dsB3Rm", "name": "Fork [SH17A] La elevations 409", "author": "elevations02", "description": "Originally [SH17A] Lake Drops by fizzer.\nGreat job on the shader, fizzer.\n\nThis was originally code golfed to be sent out in a Twitter competition (< 255 characters).\nhttps://www.shadertoy.com/view/MdjBDh", "tags": ["water", "ripple", "pond"], "likes": 5, "viewed": 267, "published": 3, "date": "1667388415", "time_retrieved": "2024-07-30T16:23:13.477468", "image_code": "// Originally [SH17A] Lake Drops by fizzer.\n// Great job on the shader, fizzer.\n//\n// This was originally code golfed to be sent out in a Twitter competition (< 255 characters).\n//\n// https://www.shadertoy.com/view/MdjBDh\n\n#define PI 3.1415936535\n\nvoid mainImage(out vec4 color,vec2 fragCoord) {\n\tvec2 screen_window = fragCoord / iResolution.x * 2.0 - 1.0; // x goes from [-1 to 1].\n    // This is used to accumulate over all ripples at the fragment location.\n    vec2 displacement = vec2(0.0);\n    // Same ripples over and over again, they repeat with this frequency.\n    float loop_time = 3.0;\n    // Lower numbers make wider ripples.\n    float ripple_width_inverse = 20.0;\n    float limits = PI / ripple_width_inverse;\n    // Increase decay to quicken fading of ripples with time.\n    float decay = 2.0;\n    // Controls the concentration of ripples (how far they spawn from the origin).\n    float spread = 4.0;\n    // Increase number of ripples. It can be cheaper to decrease the loop time.\n    int num_ripples = 68;\n    \n    // Change the perspective from top down (straight) to an angular view.\n    screen_window /= (screen_window.y += 1.6) - 2.00;\n    \n    for (float i = 0.0; i < float(num_ripples); ++i) {\n        // Distance from the origin of a ripple.\n        vec2 origin = vec2(919.,154.) * i;\n        // The cos wraps the ripple spawn points to within the local area.\n        vec2 dist = screen_window - spread * (cos(origin) - 0.5);\n        // Increasing this value staggers the creation time of ripples. For zero, they all create at the\n        // same time.\n        float time_offset = i * 0.12;\n        float t = length(dist) - mod(time_offset + iTime, loop_time);\n        // Only show one period of each sine wave.\n        float t_one_period = clamp(t, -limits, limits);\n        // Waves decay with time. I've added a decay parameter to control this more as well as\n        // a small offset to prevent a divide by zero artifact.\n        vec2 amplitude = dist / (pow(dot(dist, dist), decay) + 1e-3);\n        displacement += amplitude * sin(ripple_width_inverse * t_one_period);        \n    }\n    // Original: use the displacement to offset the read from the texture.\n    color = 0.7 * texture(iChannel0, vec3(displacement - screen_window * 6.0, 5.0)) +\n            // Bottom of the pond. No magic here.\n            0.4 * texture(iChannel1, screen_window);\n    // View only the displacement.\n    // color = vec4(vec3(displacement + 0.5,0.5), 1);\n\n\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsB3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 295, 295, 2466]], "test": "untested"}
{"id": "dsSGzw", "name": "Metakoch!", "author": "mla", "description": "Koch curves but where the central triangle has an arbitrary apex, set by the mouse, so including the original curve, the Kochawave & many others. Heavily overlapping curves (with mouse toward top or sides) can get a bit slow.", "tags": ["lsystem", "koch"], "likes": 18, "viewed": 240, "published": 3, "date": "1667383733", "time_retrieved": "2024-07-30T16:23:14.236438", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Metakoch! mla, 2022.\n//\n// Koch curves but where the central triangle has an arbitrary apex, \n// set by the mouse, so including the original curve, the Kochawave & \n// many others. Heavily overlapping curves (with mouse toward top or sides) \n// can get a bit slow.\n//\n// Code should generalize to more than 4 segments, all non-end points being\n// adjustable etc.\n//\n// Inspired by https://www.shadertoy.com/view/Dsj3zD by FabriceNeyret2\n//\n// Uses an explicit stack to keep track of the recursion.\n// This one keeps track of intermediate segments and avoids recursing far from\n// the point being plotted.\n//\n// 'a': adaptive mode where we iterate down to a minimum segment length\n// 'x': show segments actually drawn around mouse position\n// 'w': showing winding number\n// 'f': show moving point\n// 'r': show radius\n// 'c': cycle\n// 'p': progressive depth\n// 'k': Kochawave curve (just to check)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Stack representation\n#if 1\n#define PACK(x) (pack(x))\n#define UNPACK(x) (unpack(x))\n#define STACKTYPE uint\n#else\n#define PACK(x) x\n#define UNPACK(x) x\n#define STACKTYPE vec2\n#endif\n\nconst int MAXDEPTH = 12; //Maximum stack depth\nconst vec2 initp = vec2(-1,0); // Initial drawing point\n\nvec2 p = initp;                // The drawing point\nvec2 point = vec2(0);          // The moving point\nbool gotpoint = false;\nfloat plen = 0.0;              // Cumulative path length\nint wind = 0; // Compute winding number here\n\n// Fixed point packing for floats [0,1)\nuint pack(float s) {\n  s = round(s*65536.0);\n  uint n = uint(s);\n  assert(n < 65536u);\n  return n;\n}\n\n// Divide length multiplier by 16 and angle by 2PI.\nuint pack(vec2 s) {\n return (pack(s.x/8.0)<<16)|pack(mod(s.y/(2.0*PI)+0.5,1.0));\n}\n\nvec2 unpack(uint n) {\n return vec2(float(n>>16)/65536.0*8.0,\n             2.0*PI*(float(n&0xffffu)/65536.0-0.5));\n}\n\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.x <= 0.0) {\n    if (r.x > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.x <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t < plen+seglen && !gotpoint) {\n    gotpoint = true;\n    point = p + (t-plen)/seglen*seg;\n  }\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\n// Map screen coordinates\nvec2 map(vec2 pos) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos.y += 0.65;\n  pos /= 1.5;\n  return pos;\n}\n\n// This should get something from a buffer so we can set all three points\nvec2 getpoint(int i) {\n\n  if (i == 1) return vec2(1.0/3.0,0);\n  if (i == 2) {\n    if (key(CHAR_K)) return vec2(1.0/3.0,0) + vec2(0.5,0.5/sqrt(3.0));\n    else if (length(iMouse.xy) > 10.0) return iMouse.xy/iResolution.xy;\n    else if (!key(CHAR_C)) return vec2(0.5,0.25-0.25*cos(0.5*iTime));\n    else return vec2(0.5);\n  }\n  if (i == 3) return vec2(2.0/3.0,0);\n  assert(false);\n  return vec2(0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int maxdepth = 8;\n  bool adaptive = key(CHAR_A);\n  if (adaptive) maxdepth = MAXDEPTH;\n  else if (key(CHAR_P)) maxdepth = 1+int(iTime)%maxdepth;\n  vec2 pos = map(fragCoord);\n  vec2 pos2 = pos;\n  if (key(CHAR_X)) pos2 = map(iMouse.xy);\n  float pwidth = fwidth(pos.x);\n  STACKTYPE program[5];\n  float radius = 0.0;\n  float pathlen = 0.0;\n  {\n    #define C(a,b) (PACK(vec2(a,b)))\n    vec2 p[] =\n      vec2[](vec2(0,0),\n             getpoint(1),\n             getpoint(2),\n             getpoint(3),\n             vec2(1,0));\n    float theta = 0.0;\n    float seglen = 1.0;\n    for (int i = 0; i < 4; i++) {\n      radius = max(radius,distance(vec2(0.5,0),p[i]));\n      float theta1 = arg(p[i+1]-p[i]);\n      float seglen1 = length(p[i+1]-p[i]);\n      pathlen += seglen1;\n      program[i] = C(seglen1/seglen,theta1-theta);\n      theta = theta1;\n      seglen = seglen1;\n    }\n    program[4] = C(1.0/seglen,-theta);\n    #undef C\n  }\n  int stack[MAXDEPTH];\n  int depth = 0;\n  stack[depth++] = 0;\n  float d = 1e8;\n  float seglen = 2.0;\n  float theta = 0.0;    // Cumulative angle\n  float t = mod(iTime,seglen*pow(pathlen,float(maxdepth))); // Moving point\n  while (depth > 0) {\n    vec2 instr = UNPACK(program[stack[depth-1]++]);\n    float lenfact = instr[0];\n    float angle = instr[1];\n    theta += angle; // Apply turn\n    seglen *= lenfact;\n    if (stack[depth-1] == program.length()) {\n      depth--;    // Terminate level & unwind\n    } else if (depth == maxdepth || seglen < 2.0*pwidth) {\n      d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n    } else {\n      vec2 seg = seglen*vec2(cos(theta),sin(theta));\n      vec2 next = p+seg; // Where we end up\n      if (distance(pos2,p+0.5*seg) > 1.5*radius*length(seg)) {\n        polywind(pos,p,next);\n        // Show skipped segments on mouse down.\n        if (key(CHAR_X)) d = min(d,segment(pos,p,next));\n        p = next;\n        plen += seglen*pow(pathlen,float(maxdepth-depth));\n      } else {\n        stack[depth++] = 0;  // Recurse\n      }\n    }\n  }\n  // A bodge to close off the winding number calculation\n  vec2 offset = vec2(10,0);\n  polywind(pos,initp,initp-offset);\n  d = min(d,segment(pos,initp,initp-offset));\n  polywind(pos,p,p+offset);\n  d = min(d,segment(pos,p,p+offset));\n  float px = fwidth(pos.x);\n  vec3 col = vec3(smoothstep(0.0,px,d));\n  if (!key(CHAR_W) && (wind&1) != 0) col *= mix(0.2,0.8,1.0-fragCoord.y/iResolution.y);;\n  if (key(CHAR_F) && gotpoint) col = mix(vec3(1,0,0), col,smoothstep(0.0,px,distance(pos,point)-0.01));\n  if (key(CHAR_R)) col = mix(vec3(1,0,0), col,smoothstep(0.0,px,abs(distance(pos,vec2(0))-2.0*radius)));\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.1415927;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// Complex argument\nfloat arg(vec2 z) {\n  return atan(z.y,z.x);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\nconst int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1586, 1626, 1646, 1646, 1726], [1728, 1780, 1799, 1799, 1862], [1981, 1981, 2020, 2055, 2240], [2242, 2242, 2307, 2307, 2568], [2570, 2596, 2616, 2616, 2713], [2715, 2789, 2811, 2811, 3185]], "test": "untested"}
{"id": "DdS3zm", "name": "Morphology with JFA", "author": "fad", "description": "Erosion and dilation from mathematical morphology implemented with JFA so that its time complexity is independent of the radius - it could easily run real time in a single pass for small radiuses.", "tags": ["effect", "flood", "jump", "algorithm", "minimum", "maximum", "minimax"], "likes": 5, "viewed": 547, "published": 3, "date": "1667366474", "time_retrieved": "2024-07-30T16:23:15.087164", "image_code": "// The erosion/dilation filter sets the current pixel's colour to the\n// min/maximum value in its neighbourhood of a given radius. Change the settings\n// in Buffer A. If you change the iChannel0 texture here, make sure to change it\n// in Buffer A as well\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(texelFetch(iChannel1, ivec2(fragCoord), 0).xy) % textureSize(iChannel0, 0), 0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The settings you can change are:\n// - whether to erode or dilate\n// - what channel to use as the value for a pixel\n// - what distance metric to use (p-norm)\n// - the radius to search within\n\n// You can experiment with your own channel values or distance metrics by\n// changing the channelValue or distanceFunction functions :)\n\n// If you change the iChannel0 texture here, make sure to change it in the Image\n// buffer as well\n\n#define EROSION   0\n#define DILATION  1\n\n#define RED       0\n#define GREEN     1\n#define BLUE      2\n#define ALPHA     3\n#define LUMINANCE 4\n\n// Settings (have to reset time/change resolution to see effects):\n#define MODE    DILATION\n#define CHANNEL LUMINANCE\n#define P_NORM  1.0\n#define RADIUS  10.0\n\nfloat channelValue(vec4 color) {\n    switch (CHANNEL) {\n        case RED:       return color.r;\n        case GREEN:     return color.g;\n        case BLUE:      return color.b;\n        case ALPHA:     return color.a;\n        case LUMINANCE: return dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n    }\n}\n\nfloat distanceFunction(vec2 a, vec2 b) {\n    return pow(pow(abs(b.x - a.x), P_NORM) + pow(abs(b.y - a.y), P_NORM), 1.0 / P_NORM);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 d = texelFetch(iChannel1, ivec2(0), 0);\n\n    if (iFrame == 0 || d.a != iResolution.x) {\n        fragColor.b = 0.0;\n    } else {\n        fragColor.b = d.b + 1.0;\n    }\n    \n    fragColor.a = iResolution.x;\n    int iFrame = int(fragColor.b);\n    ivec2 p = ivec2(fragCoord);\n    fragColor.rg = vec2(0.0);\n    \n    if (iFrame == 0) {        \n        fragColor.rg = fragCoord;        \n        return;\n    }\n    \n    int numSteps = int(ceil(log2(max(iResolution.x, iResolution.y))));\n    \n    if (iFrame > numSteps) {        \n        fragColor = texelFetch(iChannel1, p, 0);\n        return;\n    }\n    \n    int k = 1 << numSteps - iFrame;    \n    float best = MODE == EROSION ? 1e30 : -1e30;\n    \n    for (int i = -k; i <= k; i += k) {\n        for (int j = -k; j <= k; j += k) {\n            ivec2 s = p + ivec2(i, j);\n            \n            if (any(lessThan(ivec4(s, iResolution.xy - 1.0), ivec4(0, 0, s)))) {\n                continue;\n            }\n\n            vec2 q = texelFetch(iChannel1, s, 0).xy;\n\n            if (q == vec2(0.0)) {\n                continue;\n            }\n\n            float d = distanceFunction(fragCoord, q);\n            float v = channelValue(texelFetch(iChannel0, ivec2(q) % textureSize(iChannel0, 0), 0));\n\n            if (d < RADIUS && (MODE == EROSION ? v < best : v > best)) {\n                best = v;\n                fragColor.rg = q;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdS3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 311, 311, 437]], "test": "untested"}
{"id": "cdBGzm", "name": "Vein", "author": "wyatt", "description": "best sped up", "tags": ["fluid", "automata"], "likes": 13, "viewed": 335, "published": 3, "date": "1667362018", "time_retrieved": "2024-07-30T16:23:15.928913", "image_code": "// Fork of \"Vein\" by wyatt. https://shadertoy.com/view/DsS3Rm\n// 2022-11-02 04:05:42\n\nMain \n{\n    vec4 f = A(U),b=B(U);\n    Q = sin(.5*b.x+vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat std;\nfloat erf(in float x) {\n    x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}", "buffer_a_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.05*(a.w+b.x);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    if (Q.w > 1.) Q.xy *=.99;\n    if (length(U/R-.5)>.49)Q.w = .1,Q.xy*=0.;\n    if (length(U-vec2(.5,0)*R)<.05*R.y) Q.w *= .99;\n    //Q.w += .02/R.y;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(0,0,0.*sin(iTime),1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0,0,0,.1);\n    if (U.x<2.||U.y<2.||R.y-U.y<2.||R.x-U.x<2.) Q*=0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.w += wa+wb;\n      }\n      {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.xyz += Q.xyz*wa+q.xyz*wb;\n      }\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 b = B(U);\n    Q.x -= 10e-3*min(b.w,.1)*length(b.xy);\n    if (iFrame < 100) {\n        Q = vec4(1)*2.*length((U-vec2(.5,0)*R)/R.y);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DsS3Rm", "name": "Erosion Simulation", "author": "wyatt", "description": "best sped up", "tags": ["fluid", "automata"], "likes": 22, "viewed": 400, "published": 3, "date": "1667357366", "time_retrieved": "2024-07-30T16:23:16.728775", "image_code": "Main \n{\n    vec4 f = A(U),b=B(U);\n    Q = .5-.5*sin(4.1+f.w+vec4(1,2,3,4));//sin(b.x)*vec4(1);\n    Q += dFdx(b.x);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat std;\nfloat erf(in float x) {\n    x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}", "buffer_a_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.05*(a.w+b.x);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    if (Q.w > 1.) Q.xy *=.99;\n    Q.w += .1/R.y;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(0,0,0.*sin(iTime),1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0,0,0,.1);\n    if (U.x<2.||U.y<2.||R.y-U.y<2.||R.x-U.x<2.) Q*=0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.w += wa+wb;\n      }\n      {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.xyz += Q.xyz*wa+q.xyz*wb;\n      }\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 b = B(U);\n    Q.x -= 10e-3*min(b.w,.1)*length(b.xy);\n    if (iFrame < 100) {\n        Q = C(U)+10.*U.y/R.y;\n    }\n}", "buffer_c_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsS3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cdXGDn", "name": "Limited Color Dithering", "author": "Mors", "description": "Here's a somewhat customizable dithering shader that takes an image, crushes its colors, and adds some dithering on top. Does not use the dither texture that comes by default.\n\nDrag the mouse to overlay a gradient on top of the video.\n\nLicense: CC BY 4.0", "tags": ["dithering", "bayer"], "likes": 3, "viewed": 296, "published": 3, "date": "1667346750", "time_retrieved": "2024-07-30T16:23:17.532625", "image_code": "// ------------------\n// Epic Dither Shader\n// ------------------\n// by Mors\n// CC BY 4.0\n//\n// Originally written for a secret project, later modified to work in ShaderToy.\n// Should be easy to port to game engines such as GameMaker.\n// Shoutouts to Catonator for providing me with the pattern, and just overall support. :)\n\n\n// Resolution of the base image\nconst vec2 RESOLUTION = vec2(320.0, 180.0);\n\n// Number of colors in each channel\nconst float COLORS_PER_CHANNEL = 8.0;\n\n// Strength of the dithering effect, from 0.0 to 1.0\nconst float DITHER_STRENGTH = 1.0;\n\n// Size of the dither texture\nconst float BAYER_SIZE = 8.0;\n\n// 8x8 bayer ordered dithering pattern. Each input pixel\n// is scaled to the 0..63 range before looking in this table\n// to determine the action\nconst float BAYER_TEXTURE[8 * 8] = float[](\n     0., 32.,  8., 40.,  2., 34., 10., 42.,\n    48., 16., 56., 24., 50., 18., 58., 26.,\n    12., 44.,  4., 36., 14., 46.,  6., 38.,\n    60., 28., 52., 20., 62., 30., 54., 22.,\n     3., 35., 11., 43.,  1., 33.,  9., 41.,\n    51., 19., 59., 27., 49., 17., 57., 25.,\n    15., 47.,  7., 39., 13., 45.,  5., 37.,\n    63., 31., 55., 23., 61., 29., 53., 21.\n    );\n\n\n// Getting the specific pattern from the grid\nfloat getBayer(vec2 uvScreenSpace)\n{\n    vec2 uv = mod(uvScreenSpace.xy / (iResolution.xy / RESOLUTION), BAYER_SIZE);\n    return BAYER_TEXTURE[int(uv.y) * int(BAYER_SIZE) + int(uv.x)] / (BAYER_SIZE * BAYER_SIZE);\n}\n\n// Crushing the colors\nfloat quantize(float channel, float period)\n{\n    return floor((channel + period / 2.0) / period) * period;\n}\n\n// Where the magic happens\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 period = vec3(1.0 / (COLORS_PER_CHANNEL - 1.0));\n    \n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col += (getBayer(fragCoord) - 0.5) * period * DITHER_STRENGTH;\n    col = vec3(quantize(col.r, period.r),\n               quantize(col.g, period.g),\n               quantize(col.b, period.b));\n            \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// -----------\n// DOWNSCALING\n// -----------\n\n// Resolution of the base image\nconst vec2 RESOLUTION = vec2(320.0, 180.0);\n\n\n// Crumch\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // This is where we downscale the channel 0 texture for demonstration purposes\n    // Ideally it's better to just serve a low resolution image instead\n    vec2 uv = floor(fragCoord.xy / iResolution.xy * RESOLUTION) / RESOLUTION;\n    vec4 downscaled = texture(iChannel0, uv);\n    \n    // Let's also add a gradient on top so we can showcase more colors\n    vec4 gradient = vec4(sin((uv.x + vec3(0.0, 0.25, 0.5)) * 3.14159265359 / 0.5 + iTime * 0.25), 1.0);\n    gradient = 0.5 + gradient * 0.5;\n\n    // Combine the results\n    float amount = clamp(iMouse.x / iResolution.x * 2.0 - 0.5, 0.0, 1.0);\n    fragColor = mix(downscaled, gradient, amount);\n}\n\n\n", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXGDn.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1178, 1224, 1260, 1260, 1438], [1440, 1463, 1508, 1508, 1572], [1574, 1601, 1658, 1658, 2029]], "test": "untested"}
{"id": "dsjGzD", "name": "von Kochawave to von Koch - adap", "author": "FabriceNeyret2", "description": "von Koch, relying on  stack + short cuts mla's L-System engine, but giving series of float lengthes and angles.\n\nKochawave  reference:  [url]  https://twitter.com/sfera314/status/1587348448205996032 [/url]\n[url] https://arxiv.org/pdf/2210.17320.pdf [/url]", "tags": ["optimized", "lsystem", "stack", "koch", "gosper"], "likes": 16, "viewed": 300, "published": 3, "date": "1667337436", "time_retrieved": "2024-07-30T16:23:18.297580", "image_code": "// Adaptive variant of https://shadertoy.com/view/Dsj3zD\n// Refactored fork of \"Koch Snowflake Optimized\" by mla. https://shadertoy.com/view/csX3Rs\n// ( Uses an explicit stack to keep track of the recursion + short-cuts to draw only what's necessary )\n// I replace program symbols by true segments lengthes and angles.\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0., 1.);\n  return length(p-b*h);\n}\n\nvec2 p = vec2(0);     // The drawing point\n\nfloat drawsegment(vec2 U, float seglen, float a) {\n  vec2 seg = seglen*vec2(cos(a),sin(a)),\n         q = p + seg;\n  float  d = segment(U,p,q);\n  p = q;\n  return d;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    float END = -1., factor = 3.,    // scaling factor betweel levels\n#if 0                   // von Koch snowflakes: F → F+F--F+F\n    program[] = float[] (0.,1., 1.05,1., -2.1,1., 1.05,1., 0.,END);// (angle, length)\n#elif 0                 // Kochawave\n    program[] = float[] (0.,1., .524,1.732, -2.62,1., 2.1,1., 0.,END);\n#else                   // interpolation\n    X = 1.-.5*cos(iTime), S = .866,             // von Koch to Kochawave\n // X = .5 - cos(iTime) , S = .866,             // left to right Kochawave\n    program[] = float[] ( 0., 1.,               // (angle, length)\n                          atan(S,X), sqrt(S*S+X*X), \n                          atan(X,S)-atan(X-1.,S)-3.14, sqrt(S*S+(X-1.)*(X-1.)), \n                          atan(X-1.,S)+1.57,1., \n                          0., END );\n#endif \n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y + vec2(1.5,.8);\n    const int maxdepth = 10;\n    int stack[maxdepth+1], depth = -1;     // stack: pos in program + seg length\n    float lens[6];\n    stack[++depth] = 0; lens[depth] = 1.;\n    float d = 1e8, seglen = 1., theta = 0.;     // Cumulative angle\n    \n    while (depth >= 0) {\n        float len = program[2*stack[depth] +1]; // len\n        theta +=    program[2*stack[depth]++];  // turns\n        if (len == END)\n            seglen = lens[depth--];             // Terminate level\n        else   \n        if (depth == maxdepth || seglen < 3./R.y )  \n              d = min(d,drawsegment(U,seglen*len,theta)); // Draw segment\n        else {\n          vec2 seg = seglen*len*vec2(cos(theta),sin(theta));\n          if (distance(U,p+.5*seg) > .5*length(seg))\n              p += seg;                         // skip unseen segments\n          else\n              stack[++depth]=0, lens[depth]=seglen, seglen *= len/factor; // Recurse\n        }\n    }\n    O =  vec4(smoothstep(0.,2./R.y,d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 359, 359, 458], [504, 504, 554, 554, 669]], "test": "untested"}
{"id": "ms23RD", "name": "Kochawave 3", "author": "FabriceNeyret2", "description": ".reference: [url] https://arxiv.org/pdf/2210.17320.pdf  [/url]", "tags": ["recursion", "vonkoch", "kochawave", "snowflacks"], "likes": 19, "viewed": 217, "published": 3, "date": "1667336997", "time_retrieved": "2024-07-30T16:23:19.054556", "image_code": "// variant of https://shadertoy.com/view/ds23zW\n\n#define cross(a,b)  ( (a).x*(b).y - (a).y*(b).x )\n#define rot(a)      mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float s = sqrt(3.)/2., i=0., a,b,\n          T = mod(iTime*4.,20.); T = min(T,20.-T);\n    vec2  R = iResolution.xy,\n          U = 1.3*( u - .5*R ) / R.y + vec2(0,.45),\n          S = vec2(.5/s,0), Y = vec2(0,1);\n\n    for ( O=vec4(1); i < T; i++ ) {\n        a = -cross( U-S, vec2(-.5,s) ),           // distance to right border\n        b =  cross( U+S, vec2( .5,s) );           // distance to left border\n        if ( U.y<0. || a < 0. || b < 0. ) return; // out of triangle\n        U = U.y > .67 ? ( U-.67*Y ) *3.           // top triangle\n          :  b  > .67 ? ( U-.67*S ) *3.           // right triangle\n          :  a  > .67 ? ( U+.67*S ) *3.           // left triangle\n          :    (U-.33*Y) *rot(-.524) / (.67*s) + .33*Y; // central triangle\n        O *= vec4(.7,.8,.9,0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms23RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 193, 193, 984]], "test": "untested"}
{"id": "ds2GRW", "name": "Fractal doodling", "author": "XT95", "description": "Wait 10 seconds to see another variation !", "tags": ["fractal", "volumetric", "glow"], "likes": 47, "viewed": 582, "published": 3, "date": "1667336989", "time_retrieved": "2024-07-30T16:23:19.899297", "image_code": "// Heavely inspired by \"fractal xxx gaz\" -> https://www.shadertoy.com/user/gaz/\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,b,-b,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 rd = normalize(vec3(uv*2.-1., 2.));\n    vec3 ro = vec3(0.,0.,-.5);\n    float t = 0.;\n    \n    vec3 seed = hash3( uint(iTime/10.) + 3u );\n    vec3 seed2 = hash3( uint(iTime/10.) );\n    float time = mod(iTime, 10.);\n    float fade = smoothstep(0.,1., time) * smoothstep(10.,9.5, time);\n    \n    \n    vec3 col = vec3(0.);\n    for(int i=0; i<80; i++) {\n        vec3 p = ro + rd * t;\n        p.xz = rot(iTime*0.02+0.3) * p.xz;\n        p.xy = rot(-iTime*0.03-.2) * p.xy;\n        float s = 2., r2;\n        for(int j=0; j<8; j++) {\n            r2 = (fade*1.7)/min(dot(p,p),1.6);\n            p = abs(p*r2) - (seed+.1)*5.;\n            s *= r2;\n        }\n\n        float d = length(p.xy)/s;\n        t += d*.5;\n        col += vec3(cos(vec3(1.,2.,3.)-iTime*1.5*(seed2.g*2.-1.) + log(s))*.5+.5) * 0.03 * exp(-.5*d*float(i*i));\n    }\n    \n    fragColor = vec4(col * fade,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// From Iq https://www.shadertoy.com/view/llGSzw\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2GRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 99, 99, 172], [174, 174, 231, 231, 1144]], "test": "untested"}
{"id": "ds23zW", "name": "Kochawave 2", "author": "FabriceNeyret2", "description": ".reference: [url] https://arxiv.org/pdf/2210.17320.pdf  [/url]", "tags": ["recursion", "vonkoch", "kochawave", "snowflacks"], "likes": 19, "viewed": 249, "published": 3, "date": "1667335004", "time_retrieved": "2024-07-30T16:23:20.810860", "image_code": "#define cross(a,b)  ( (a).x*(b).y - (a).y*(b).x )\n#define rot(a)      mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float s = sqrt(3.)/2., i=0., a,b,\n          T = mod(iTime*4.,16.); T = min(T,16.-T);\n    vec2  R = iResolution.xy,\n          U = 1.3*( u - .5*R ) / R.y + vec2(0,.45),\n          S = vec2(.5/s,0), Y = vec2(0,1);\n\n    for ( O*=0.; i < T; i++ ) {\n        a = -cross( U-S, vec2(-.5,s) ),           // distance to right border\n        b =  cross( U+S, vec2( .5,s) );           // distance to left border\n        if ( U.y<0. || a < 0. || b < 0. ) return; // out of triangle\n        U = U.y > .67 ? ( U-.67*Y ) *3.           // top triangle\n          :  b  > .67 ? ( U-.67*S ) *3.           // right triangle\n          :  a  > .67 ? ( U+.67*S ) *3.           // left triangle\n          :    (U-.33*Y) *rot(-.524) / (.67*s) + .33*Y; // central triangle\n    }\n    O++;\n}\n\n\n\n\n/**  // --- WIP: antialiased version\n\n#define cross(a,b)  ( (a).x*(b).y - (a).y*(b).x )\n#define rot(a)      mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float s = sqrt(3.)/2., i=0., a,b, w=iResolution.y/1.3,\n          T = mod(iTime*4.,16.); T = min(T,16.-T);\n    vec2  R = iResolution.xy,\n          U = 1.3*( u - .5*R ) / R.y + vec2(0,.45),\n          S = vec2(.5/s,0);\n\n    for ( O*=0.; i < T; i++ ) {\n        a = -cross( U-S, vec2(-.5,s) ),\n        b =  cross( U+S, vec2( .5,s) );\n        if ( U.y<0. || a < 0. || b < 0. ) break; // out of triangle\n        U = U.y > .67 ? w/=3., ( U-.67*vec2(0,1) ) *3.   // top triangle\n          :  b  > .67 ? w/=3., ( U-.67*S ) *3.           // right triangle\n          :  a  > .67 ? w/=3., ( U+.67*S ) *3.           // left triangle\n          :   ( w*=.67*s, (U-vec2(0,.33)) *rot(-.524) / (.67*s) + vec2(0,.33) ); // central triangle\n    }\n    a = -cross( U-S, vec2(-.5,s) ),\n    b =  cross( U+S, vec2( .5,s) );\n    O += min(U.y,min(a,b)) *w; // +.5\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds23zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 144, 144, 909]], "test": "untested"}
{"id": "mdj3zW", "name": "My first volumetric clouds", "author": "kishimisu", "description": "interact with mouse", "tags": ["volume", "fbm", "light", "fog", "smoke"], "likes": 27, "viewed": 636, "published": 3, "date": "1667331045", "time_retrieved": "2024-07-30T16:23:21.577810", "image_code": "/* I tried to make my own volumetric raymarcher for arbitrary shapes. \n*  It's a naive implementation consisting of a basic raymarcher extended with an inside/outside \n*  awareness that collects density & light when inside a shape (distance field < 0).\n*  I think it can be optimized by using fixed steps when marching inside a volume.    */\n\n#define MAX_ITER 300.\n#define MAX_DIST 8.\n#define ABSORPTION 17.\n\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) * 43758.5453123)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// noise and fbm are from https://www.shadertoy.com/view/XtS3DD\nfloat noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod(iChannel0, (tap+0.5)/256.0, 0.0).yx;\n\treturn mix(rz.x, rz.y, fp.z);\n}\n\nfloat fbm(in vec3 x) {\n    x += vec3(iTime*.015, iTime*.035, 0.);\n    \n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<4; i++) {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz - .25;\n}\n\n// signed distance to volume\nfloat vol(vec3 p) {\n    p.y -= .2;\n    float r = fbm(p) + p.y*.4 + .08 + .05*max(0., 1.-length(p));\n    float sphere = length(p) - 1.;\n    return max(sphere, r*.9);\n}\n\n// get light visibility at point\nfloat sampleLight(vec3 ro) {\n    vec3 rd = normalize(-ro + vec3(0.,.2,0.));\n    float t = 0., visibility = 1., stepSize = 0.005;\n    \n    for (int i = 0; i < 20; i++) {\n        vec3 p = ro + t*rd;\n        float d = vol(p);\n        t += max(stepSize, d) + hash33(p).x*.002;\n        if (d < 0.) visibility *= exp(-stepSize*ABSORPTION);\n    }\n    \n    return visibility;\n}\n\nvoid initRayOriginAndDirection(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = ( fragCoord - .5*iResolution.xy )/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float d = 1.75;\n    ro = vec3(d*cos(iTime*.1), 1.5, d*sin(iTime*.1));\n    ro.xz *= rot(-m.x*2.);\n    \n    float z = iMouse.z == 0. ? 1.4 : 1.2 + m.y;\n\n    vec3 f = normalize(-ro),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = ro+f*z,\n         i = c + uv.x*r + uv.y*u;\n         \n    rd = normalize(i-ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro, rd;\n    \n    initRayOriginAndDirection(fragCoord, ro, rd);\n    \n    float visibility = 1.;\n    vec3 vColor = vec3(0.), color = vec3(0.,0.,.1);\n    \n    float t = 0., eps = 0.0005;\n    float inside = vol(ro) < 0. ? 1. : 0.;\n            \n    for (float i = 0.; i < MAX_ITER; i++) {\n        vec3 p = ro + t*rd;\n        \n        float d = vol(p);\n        t += abs(d) + 0.001*t;\n        \n        bool isInsideVolume = mod(inside, 2.) > .5;\n        \n        if (!isInsideVolume) { \n            if (d < eps) {  \n                inside++; t += eps*10.; // enter volume\n            }\n        } else {    \n            if (d > -eps) {  \n                inside++; t += eps*10.; // exit volume\n            } else {\n                // sample density & light\n                float prev = visibility;\n                visibility *= exp(-abs(d)*ABSORPTION);\n                \n                float absorption = prev - visibility;\n                vColor += absorption * sampleLight(p) * (vec3(1.3, 1.,.8) + fbm(p)*2.);\n                        \n                if (visibility <= .01 || dot(vColor, vColor) >= 3.) break;         \n            }\n        }\n        \n        if (t > MAX_DIST) break;\n    }\n\n    color = vColor + color * visibility;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdj3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[528, 528, 547, 547, 599], [601, 665, 689, 689, 905], [907, 907, 929, 929, 1134], [1136, 1165, 1184, 1184, 1331], [1333, 1366, 1394, 1394, 1735], [1737, 1737, 1815, 1815, 2271], [2273, 2273, 2330, 2330, 3600]], "test": "untested"}
{"id": "ds23RW", "name": "Fixed Fork of Backscatter", "author": "arabek", "description": "Original info by Ferris:\n\nThis was my sandbox while making the 40kb intro Backscatter by Logicoma (http://www.pouet.net/prod.php?which=65966), which started as an exemusic entry that was too big and ended with winning the intro compo at Solskogen 2015.", "tags": ["procedural", "raymarching", "fractal", "demo", "backscatter", "logicoma", "40k", "64k", "ferris", "hoffman"], "likes": 7, "viewed": 252, "published": 3, "date": "1667327046", "time_retrieved": "2024-07-30T16:23:22.574146", "image_code": "// Thanks to iq for the noise routine, the vignette, and some repetition stuff.\n// Also thanks to mu6k for some repetion/mirroring tricks used in ALLTHECUBES and\n// Daedelus for finding a funny bottleneck in the code structure on some GPU's :D\n\n//#define BAWLS\n//#define TUNNEL\n#define ALLTHECUBES\n//#define SLICES\n//#define TWISTERS\n//#define OUTDOORZ\n\nstruct Material\n{\n    vec3 additiveColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float specularExponent;\n    float backgroundAmount;\n};\n   \nMaterial mixMaterials(Material a, Material b, float x)\n{\n    return Material(\n        mix(a.additiveColor, b.additiveColor, x),\n        mix(a.diffuseColor, b.diffuseColor, x),\n        mix(a.specularColor, b.specularColor, x),\n        mix(a.specularExponent, b.specularExponent, x),\n        mix(a.backgroundAmount, b.backgroundAmount, x));\n}\n\nstruct SceneResult\n{\n    float d;\n    Material material;\n};\n\nvec3 rotateX(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x, x.y * c - x.z * s, x.z * c + x.y * s);\n}\n\nvec3 rotateY(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.z * s, x.y, x.z * c + x.x * s);\n}\n\nvec3 rotateZ(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.y * s, x.y * c + x.x * s, x.z);\n}\n\n// Noise by iq\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 x)\n{\n    float ret = noise(x);\n    ret += noise(x * 2.0) / 2.0;\n    ret += noise(x * 4.0) / 4.0;\n    ret += noise(x * 8.0) / 8.0;\n    ret += noise(x * 16.0) / 16.0;\n    return ret;\n}\n\nfloat fbm2(vec3 x)\n{\n    float ret = noise(x);\n    //ret += noise(x * 2.0) / 2.0;\n    ret += noise(x * 4.0) / 4.0;\n    //ret += noise(x * 8.0) / 8.0;\n    ret += noise(x * 16.0) / 16.0;\n    return ret;\n}\n\nfloat fbm3(vec3 x)\n{\n    float ret = noise(x); x = rotateY(x, .833);\n    //ret += noise(x * 2.0) / 2.0;\n    ret += noise(x * 4.0) / 4.0;\n    //ret += noise(x * 8.0) / 8.0;\n    //ret += noise(x * 16.0) / 16.0;\n    return ret;\n}\n\n#define saturate(x) (clamp((x), 0.0, 1.0))\n\nvec3 nightSky(vec3 eyeDir)\n{\n    float starsBrightness = pow(noise(eyeDir * 200.0), 86.0) * 2.2;\n    vec3 stars = vec3(saturate(starsBrightness));\n    \n    float horizonBrightness = pow(1.0 - abs(eyeDir.y) + .01, 22.0) * .3;\n    vec3 horizon = vec3(0.8, 0.9, 1.0) * horizonBrightness;\n    \n    vec3 moonPos = normalize(vec3(1, 2, 2));\n    float moonBrightness = saturate(pow(max(dot(eyeDir, moonPos), 0.0) + .01, 3000.0));\n    vec3 moonColor = mix(vec3(0.9), vec3(.8, .6, .5), fbm(eyeDir * 24.0));\n    vec3 moon = moonColor * moonBrightness;\n    \n    vec3 clearSky = stars + horizon + moon;\n    \n    return clearSky;\n}\n\nfloat sphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p - pos) - radius;\n}\n\nfloat cube(vec3 p, vec3 pos, vec3 size)\n{\n    vec3 d = abs(p - pos) - size;\n    return max(max(d.x, d.y), d.z);\n}\n\nfloat bawlsNoise(vec3 p)\n{\n    vec3 normalNoisePos = p * 5.0;// + vec3(0.0, iTime, 0.0);\n    return\n        saturate(pow((fbm(normalNoisePos) - .6) * 4.0, 2.0))\n        + pow(fbm(normalNoisePos * 3.0 + 40.0), 6.0) * .08\n        ;\n}\n\n#ifdef BAWLS\nfloat ballsTime = iTime * .3;\nvec3 ball1Pos = vec3(cos(ballsTime * .44), cos(ballsTime * .99), sin(ballsTime * 1.3)) * 1.4;\nvec3 ball2Pos = vec3(cos(ballsTime * 1.3), sin(ballsTime * .78), cos(ballsTime)) * 1.2;\nvec3 ball3Pos = vec3(sin(ballsTime * .77), sin(ballsTime * .12), sin(ballsTime * 2.0)) * 1.2;\nfloat ball1Rad = sin(ballsTime + 1.0) * .4 + .6;\nfloat ball2Rad = cos(ballsTime * 1.6 + 2.0) * .4 + .6;\nfloat ball3Rad = sin(ballsTime * .84 + 3.0) * .4 + .6;\n\nfloat metaballs(vec3 p)\n{\n    float ball1 = sphere(p, ball1Pos, ball1Rad);\n    float ball2 = sphere(p, ball2Pos, ball2Rad);\n    float ball3 = sphere(p, ball3Pos, ball3Rad);\n    \n    float srf =\n        1.0 / (ball1 + ball1Rad) +\n        1.0 / (ball2 + ball2Rad) +\n        1.0 / (ball3 + ball3Rad);\n    \n    return 1.0 / srf - .4;\n}\n\nSceneResult f(vec3 p)\n{\n    float diag = (p.x + p.y + p.z) * 2.0 + iTime * 1.2;\n    float materialMix = saturate(pow(abs(sin(diag) * 1.1), 120.0));\n    \n    Material smoothMaterial = Material(\n        vec3(0.0),\n        vec3(.08),\n        vec3(2.0),\n        36.0,\n        0.52);\n    \n    Material fuzzyMaterial = Material(\n        vec3(0.0),\n        mix(vec3(1.0, .2, .1), vec3(.9, .1, .1), saturate(pow(fbm(p * 7.0) * 1.1 - .1, 8.0))),\n        vec3(.3),\n        6.0,\n        0.4);\n    \n    Material material = mixMaterials(smoothMaterial, fuzzyMaterial, materialMix);\n    float d =\n        metaballs(p)\n        - (fbm3(p * 12.0 + iTime * .4) - .1) * materialMix * .01\n        ;\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult bawlsResult = f(p);\n    \n    float normalNoise = bawlsNoise(p);\n    \n    return SceneResult(bawlsResult.d + normalNoise * .001, bawlsResult.material);\n}\n#endif\n\n#ifdef TUNNEL\nvec2 tunnelUv(vec3 p)\n{\n    vec3 tunnelP = p * .1;\n    return vec2(atan(tunnelP.y, tunnelP.x) * 2.0, tunnelP.z + iTime * .125);\n}\n\nSceneResult tunnel(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.8, .9, 1.0) * .32,\n        vec3(.2),\n        36.0,\n        0.2);\n    \n    vec2 uv = tunnelUv(p);\n    float d = 6.0 - length(p.xy + vec2(sin(p.z * .4 + iTime * .21), cos(p.z * .4 + iTime * .34)) * .7) + fbm3(vec3(uv, iTime * .1)) * 4.0;\n    \n    float cutoutSize = 1.2;\n    float cutout = -(min(abs(p.x) - cutoutSize, abs(p.y) - cutoutSize));\n    \n    return SceneResult(max(d, cutout), material);\n}\n\nSceneResult f(vec3 p)\n{\n    return tunnel(p);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult original = f(p);\n    \n    vec2 uv = tunnelUv(p);\n    return SceneResult(\n        original.d + fbm(vec3(uv * 2.1, iTime * .1) * 3.4) * .4,\n        original.material);\n}\n#endif\n\n#ifdef ALLTHECUBES\n// rep stolen from iq\nfloat repCubes( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return cube(q, vec3(0.0), vec3(0.34));\n}\n\nSceneResult f(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.8),\n        vec3(.02),\n        36.0,\n        0.6);\n    float t = iTime * .4;\n    vec3 q = rotateY(rotateZ(rotateX(p, t * .22), t * .34), t * .44 + sin(p.y * .05 + t * .2));\n    float e = .95;\n    for (int i = 0; i < 4; i++)\n    {\n        q = rotateX(rotateZ(abs(q - e * float(i)), 40.0 + t * .12), t * .116);\n        e = e * .5 + e * e * .3;\n    }\n    float d = max(repCubes(q, vec3(.8)), cube(q, vec3(0.0), vec3(6.0, 6.0, 6.0)));\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    float diag = (p.x + p.y + p.z) * 2.2;\n    float materialMix = saturate(pow((sin(diag) * .5 + .5) * 1.2, 40.0));\n    \n    Material material = Material(\n        vec3(0.0),\n        vec3(.08),//vec3(1.0, .2, .1),\n        vec3(1.01),\n        6.0,\n        0.0);\n    \n    SceneResult original = f(p);\n    return SceneResult(original.d + (fbm(p * 3.0) + 1.4) * materialMix * .03, mixMaterials(original.material, material, materialMix));\n}\n#endif\n\n#ifdef SLICES\nSceneResult f(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.88),\n        vec3(2.0),\n        36.0,\n        0.52);\n    \n    float slashesAmt = .5;\n    \n    //float slashes = abs(fract((p.x + p.y + p.z) * 8.0) / 16.0 - 1.0 / 32.0) - Slashes / 32.0;\n      float slashes = abs(fract((p.x + p.y + p.z) / 2.0) - 1.0 / 2.0) - slashesAmt / 2.0;\n    float d = max(cube(p, vec3(0.0), vec3(4.0)), slashes);\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult original = f(p);\n    return SceneResult(original.d + bawlsNoise(p) * .001, original.material);\n}\n#endif\n\n#ifdef TWISTERS\nSceneResult f(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.08),\n        vec3(2.0),\n        36.0,\n        0.82);\n    \n    vec3 q = rotateY(p, sin(p.y * .03 + iTime * .73) * 6.2);\n    float d = 1000.0;\n    for (int i = 0; i < 3; i++)\n    {\n        float an = float(i) / 3.0 * 2.0 * 3.141592;\n        d = min(d, length(q.xz + vec2(cos(an), sin(an)) * 2.2) - 1.0);\n    }\n    \n    float cutoutPos = sin(iTime * 1.7) * 3.0;\n    float cutoutSize = sin(iTime * 2.1) + 1.5;\n    float cutout = -(abs(p.y - cutoutPos) - cutoutSize);\n    d = max(d, cutout);\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult original = f(p);\n    return SceneResult(original.d + bawlsNoise(p) * .003, original.material);\n}\n#endif\n\n#ifdef OUTDOORZ\n// rep stolen from iq\nfloat repCylinders( vec3 p, vec2 c )\n{\n    vec2 derp = mod(p.xz, c);\n    vec2 q = derp-0.5*c;\n    return length(q) - .34;\n}\n\nSceneResult f(vec3 p)\n{\n    float diag = p.x + p.y + p.z;\n    \n    Material material = Material(\n        vec3(0.0),\n        vec3(.08) * vec3(1., .9, .8),\n        vec3(2.0),\n        36.0,\n        0.42);\n    \n    float s = sphere(p, vec3(0.0), 5.0) + noise(p * .4 + iTime);\n    float cylinders = repCylinders(p + noise(p * .1 + iTime) * .8, vec2(10.0));\n    float ground = p.y + 12.0 + (sin(p.x * .4) + cos(p.z * .4)) * .4;\n    \n    return SceneResult(min(min(s, cylinders), ground), material);\n}\n\nSceneResult tf(vec3 p)\n{\n    float diag = (p.x + p.y + p.z) * 2.2;\n    float materialMix = saturate(pow((sin(diag) * .5 + .5) * 1.2, 40.0));\n    \n    Material material = Material(\n        vec3(0.0),\n        vec3(.08),//vec3(1.0, .2, .1),\n        vec3(1.01),\n        6.0,\n        0.0);\n    \n    SceneResult original = f(p);\n    return SceneResult(original.d + (fbm(p * 3.0) + 1.4) * materialMix * .03, mixMaterials(original.material, material, materialMix));\n}\n#endif\n\nvec3 lightContribution(\n    vec3 eyePos,\n    vec3 eyeDir,\n    vec3 normal,\n    vec3 lightPos,\n    vec3 lightColor,\n    Material material,\n    float occlusionTerm)\n{\n    vec3 l = normalize(lightPos - eyePos);\n    vec3 diffuse = max(material.diffuseColor * (max(dot(normal, l), 0.0)) - occlusionTerm, vec3(0.0));\n    vec3 refVec = reflect(l, normal);\n    vec3 specular = material.specularColor * pow(max(dot(refVec, eyeDir), 0.0), material.specularExponent);\n    return (diffuse + specular) * lightColor;\n}\n\n#if defined TUNNEL || defined OUTDOORZ\nvec3 light1Pos = vec3(sin(iTime * 1.1), cos(iTime), 20.0);// * vec3(2.0, 2.0, 1.0);\nvec3 light2Pos = vec3(cos(iTime * .84), cos(iTime * .45), 20.0);// * vec3(2.0, 2.0, 1.0);\n#endif\nvec3 light1Color = vec3(0.7, .85, 1.0);\nvec3 light2Color = vec3(1.0, .85, .7);\n\nvec3 outdoorBackground(vec3 eyePos, vec3 eyeDir)\n{\nfloat lightTime = iTime * .2;\nvec3 light1Pos = vec3(sin(lightTime * 1.1), cos(lightTime) * .3 + .4, sin(lightTime * .76)) * 20.0;\nvec3 light2Pos = vec3(cos(lightTime * .84), cos(lightTime * .45) * .3 + .4, sin(lightTime * 1.2)) * 20.0;\n\n    vec3 sky =\n        vec3(0.08)\n        + pow(max(dot(eyeDir, normalize(light1Pos - eyePos)), 0.0), 27.0) * light1Color * .4\n        + pow(max(dot(eyeDir, normalize(light2Pos - eyePos)), 0.0), 27.0) * light2Color * .4\n        + mix(vec3(.8, .9, 1.0), vec3(1.0, .9, .8), pow(1.0 - abs(eyeDir.y), 2.1)) * .8\n        ;\n    \n    float cloudsMix =\n        saturate(pow(fbm(vec3(eyeDir.xz * 7.0, iTime * .1)) - .2, 6.0))\n        * pow(max(eyeDir.y, 0.0), 1.4) * .8;\n    \n    vec3 clouds = mix(vec3(.8), vec3(1.0), fbm(eyeDir * 24.0));\n    \n    return mix(sky, clouds, cloudsMix);\n}\n\nvec3 getColor(float x)\n{\n    return\n        mix(\n            vec3(.2, .8, 1.0),\n            mix(\n                vec3(.7, .2, 1.0),\n                mix(\n                    vec3(1.0, .6, .2),\n                    vec3(1.0),\n                    step(.6, x)),\n                step(.4, x)),\n            step(.2, x));\n}\n\nvec3 neonTunnelBackground(vec3 eyePos, vec3 eyeDir)\n{\n    float t = iTime * .2;\n    float an = atan(eyeDir.x, eyeDir.z) / (2.0 * 3.141592) * 26.0;\n    float f = (1.0 - pow(abs(fract(an) * 2.0 - 1.0), 23.0)) * (1.0 - pow(abs(eyeDir.y), 3.0));\n    f *= saturate(pow(fbm(vec3(floor(an), t * 1.4, 0.0)) - .2, 12.0) * 3.0 + .1);\n    f *= (1.0 - pow(saturate(fbm(eyeDir * 33.0) - .8), 3.0)) * .6 + .4;\n    float c = saturate(pow(fbm(vec3(floor(an), 0.0, t * .13)) - .1, 12.0) * 3.0 + .1);\n    return getColor(c) * f * .7 * 2.0;\n}\n\nvec3 background(vec3 eyePos, vec3 eyeDir)\n{\n    return\n#if defined TUNNEL || defined OUTDOORZ\n        outdoorBackground(eyePos, eyeDir);\n#else\n        neonTunnelBackground(eyePos, eyeDir);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float lightTime = iTime * .2;\n    vec3 light1Pos = vec3(sin(lightTime * 1.1), cos(lightTime) * .3 + .4, sin(lightTime * .76)) * 20.0;\n    vec3 light2Pos = vec3(cos(lightTime * .84), cos(lightTime * .45) * .3 + .4, sin(lightTime * 1.2)) * 20.0;\n\n    vec2 pixelPos = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec3 eyeDir = normalize(vec3(pixelPos, 1));\n    \n    vec2 normMouse = vec2(0.0);//iMouse.xy / iResolution.xy - .5;\n    float camRotX = sin(iTime * .1) + normMouse.y * 3.141592;\n    float camRotY = iTime * .5 + normMouse.x * 2.0 * 3.141592;\n    float camRotZ = sin(iTime * .083) * .4;\n    \n    eyeDir = rotateZ(eyeDir, camRotZ);\n    eyeDir = rotateX(eyeDir, camRotX);\n    eyeDir = rotateY(eyeDir, camRotY);\n    \n    vec3 eyePos =\n#ifdef BAWLS\n        vec3(0.0, 0.0, -4.0);\n#elif defined TUNNEL\n        vec3(0.0, -7.0, -4.0);\n#else\n        vec3(0.0, -0.0, -14.0);\n#endif\n    eyePos = rotateX(eyePos, camRotX);\n    eyePos = rotateY(eyePos, camRotY);\n    \n    vec3 color = background(eyePos, eyeDir);\n    \n    const float maxDisTravelled = 40.0;\n    float disTravelled = 0.0;\n    const int maxIterations = 160;\n    for (int i = 0; i < maxIterations; i++)\n    {\n        float d = f(eyePos).d;\n        if (d <= 0.0)\n            break;\n        \n        d = max(d, .025);\n        eyePos += eyeDir * d;\n        disTravelled += d;\n        if (disTravelled >= maxDisTravelled)\n            break;\n    }\n    \n    if (disTravelled < maxDisTravelled)\n    {\n        SceneResult td = tf(eyePos);\n        vec3 normal = normalize(\n            vec3(\n                tf(eyePos + vec3(.003, 0, 0)).d - td.d,\n                tf(eyePos + vec3(0, .003, 0)).d - td.d,\n                tf(eyePos + vec3(0, 0, .003)).d - td.d));\n\n        float occlusionTerm = 0.0;\n        for (float i = 1.0; i < 4.0; i += 1.0)\n            occlusionTerm += max(-f(eyePos + normal * i * .1).d, 0.0) / pow(2.0, i);\n        occlusionTerm *= 2.0;\n\n        vec3 surfaceColor =\n            td.material.additiveColor\n            + lightContribution(eyePos, eyeDir, normal, light1Pos, light1Color, td.material, occlusionTerm)\n            + lightContribution(eyePos, eyeDir, normal, light2Pos, light2Color, td.material, occlusionTerm)\n            + background(eyePos, reflect(eyeDir, normal)) * td.material.backgroundAmount;\n\n        //vec3 iterationGlow = vec3(.9, 1.0, 1.1) * pow(float(i) / float(maxIterations), 2.0);\n\n        color =\n            mix(\n                color,\n                surfaceColor,\n                1.0 - pow(disTravelled / maxDisTravelled, 2.0))\n            //+ iterationGlow\n            ;\n    }\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    color = pow(color * vec3(1.0, .99, 1.06), vec3(1.2));\n    \n    //color = pow(color, vec3(3.0));\n    \n    // Vignette (stolen from iq)\n    color *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    // Cheap \"bloom emulation\" to better match the actual intro :)\n    color += pow(max(color - .2, 0.0), vec3(1.4)) * .5;\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds23RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 562, 562, 846], [909, 909, 941, 941, 1049], [1051, 1051, 1083, 1083, 1191], [1193, 1193, 1225, 1225, 1333], [1335, 1350, 1373, 1373, 1409], [1410, 1410, 1436, 1436, 1808], [1810, 1810, 1829, 1829, 2007], [2009, 2009, 2029, 2029, 2211], [2213, 2213, 2233, 2233, 2439], [2485, 2485, 2513, 2513, 3103], [3105, 3105, 3151, 3151, 3190], [3192, 3192, 3233, 3233, 3305], [3307, 3307, 3333, 3333, 3538], [9914, 9914, 10078, 10078, 10418], [10720, 10720, 10770, 10770, 11585], [11587, 11587, 11611, 11611, 11901], [11903, 11903, 11956, 11956, 12426]], "test": "untested"}
{"id": "csS3zW", "name": "High Voltage Tendencies", "author": "leon", "description": "Another cloud shader", "tags": ["noise", "cloud", "lightning", "storm"], "likes": 75, "viewed": 1230, "published": 3, "date": "1667326462", "time_retrieved": "2024-07-30T16:23:23.370018", "image_code": "\n// High Voltage Tendencies\n// Another cloud shader\n\n// reduces if too slow\nconst float frames = 3.;\n\n// global\nfloat glow;\n\n// snippets\n#define R iResolution.xy\n#define N(a,b,c) normalize(vec3(a,b,c))\n#define ss(a,b,t) smoothstep(a,b,t)\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\n\n// noise\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 8; ++i, a/=2.)\n    {\n        result += abs(gyroid(seed/a))*a;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // cloud\n    vec3 seed = p*.4;\n    seed.z += iTime*.1;\n    float noise = fbm(seed);\n    dist = length(p) - .5 - noise*1.;\n    \n    // lightning\n    const float count = 4.;\n    float a = 1.;\n    float t = iTime*.2 + noise*.5;\n    float r = .1+.2*sin(iTime+p.x);\n    float shape = 100.;\n    for (float i = 0.; i < count; ++i)\n    {\n        p.xz *= rot(t/a);\n        p.xy *= rot(t/a);\n        p = abs(p)-r*a;\n        shape = min(shape, length(p.xz));\n        a /= 1.8;\n    }\n    glow += .002/shape;\n    dist = min(dist, shape);\n    \n    return dist*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(0);\n    \n    // layers\n    for (float f = 0.; f < frames; ++f)\n    {\n        // blue noise scroll by iq https://www.shadertoy.com/view/tlySzR\n        ivec2 p = ivec2(fragCoord);\n        p = (p+(iFrame*196+int(f))*ivec2(113,127)) & 1023;\n        vec3 blu = texelFetch(iChannel0,p,0).xyz;\n\n        // coordinates\n        vec3 pos = vec3(0,0,7);\n        vec3 ray = normalize(vec3(uv,-3));\n        ray.xy += blu.xy * ss(.5,8.,length(uv)); // blur edge\n        pos += ray * blu.z * 4.; // pre start\n\n        vec3 tint = vec3(0);\n        glow = 0.;\n\n        // raymarch\n        const float count = 40.;\n        float maxDist = 10.;\n        float steps = 0.;\n        float total = 0.;\n        for (steps = count; steps > 0.; --steps) {\n            float dist = map(pos);\n            if (dist < .001*total || total > maxDist) break;\n            dist *= 0.9+0.1*blu.z; // dithering\n            ray.xy += blu.xy*total*.001; // depth of field\n            pos += ray * dist;\n            total += dist;\n        }\n\n        // shading\n        float shade = steps/count;\n        if (shade > .1 && total < maxDist) {\n\n            // NuSan https://www.shadertoy.com/view/3sBGzV\n            vec2 noff = vec2(.2*pow(length(uv),2.),0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n\n            // color palette https://iquilezles.org/www/articles/palettes/palettes.htm\n            tint = .8+.5*cos(vec3(1,2,3)*6.1 + pos.y*1. + normal.z*3.);\n\n            // backlight\n            tint *= dot(normal, ray)*.5+.5;\n        }\n\n        // bloom\n        tint += glow*.5;\n        \n        // average\n        color += tint/frames;\n    }\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csS3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 258, 258, 308], [309, 309, 335, 335, 374], [376, 385, 408, 408, 552], [554, 582, 601, 601, 1185], [1187, 1187, 1244, 1244, 3035]], "test": "untested"}
{"id": "md2GRW", "name": "Kochawave!", "author": "mla", "description": "An interesting L-system: [url]https://arxiv.org/pdf/2210.17320.pdf[/url]\n\nNeeds to be full screen for the proper effect.", "tags": ["optimized", "lsystem", "stack", "koch", "gosper"], "likes": 19, "viewed": 268, "published": 3, "date": "1667325029", "time_retrieved": "2024-07-30T16:23:24.197805", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Kochawave! mla, 2022.\n//\n// Thanks to Fabrice for reference: https://arxiv.org/pdf/2210.17320.pdf\n//\n// This one needs to have variable recursion depths (down to a certain\n// segment length - this should be resolution dependent).\n// Inspired by https://www.shadertoy.com/view/cdsGRj by FabriceNeyret2\n//\n// Mouse down shows segments actually drawn around mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\nconst int A = 0, END = -1;\nconst int STAR = 1, SLASH = 2, PLUS = 3;\nconst int program[5] = int[]( C(0,A), C(STAR,A), C(SLASH,A), C(PLUS,A), C(0,END) );\n\nconst int MAXDEPTH = 10;\n\nvec2 p = vec2(0);     // The drawing point\nvec2 point = vec2(100); // The moving point\nfloat plen = 0.0;     // Cumulative path length\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t >= plen && t < plen+seglen) point = p + (t-plen)/seglen*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\nvec2 map(vec2 pos, float factor) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos.y += 0.8;\n  pos *= factor/3.0;\n  pos.x += 0.5*factor;\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float factor = 3.0;// Linear scale factor at each level.\n  int maxdepth = MAXDEPTH;\n  //maxdepth = 1+int(iTime)%MAXDEPTH;\n  vec2 pos = map(fragCoord,factor);\n  vec2 pos2 = pos;\n  if (iMouse.z > 0.0) pos2 = map(iMouse.xy,factor);\n  int stack[MAXDEPTH];\n  int depth = 0;\n  stack[depth++] = 0;\n  float t = mod(iTime,4.0*pow(4.0/factor,float(maxdepth-1))); // Moving point\n  float d = 1e8;\n  float seglen = 1.0;\n  float theta = 0.0;    // Cumulative angle\n  while (depth > 0) {\n    int instr = program[stack[depth-1]++];\n    // Decode instruction\n    int turns = instr>>16;\n    int code = instr<<16>>16;\n    //theta += float(turns)*angle; // Apply turn\n    if (turns == STAR) {\n      theta += PI/6.0;\n      seglen *= sqrt(3.0);\n    } else if (turns == SLASH) {\n      theta -= 5.0*PI/6.0;\n      seglen /= sqrt(3.0);\n    } else if (turns == PLUS) {\n      theta += 2.0*PI/3.0;\n    }\n\n    if (code == END) {\n      depth--;    // Terminate level & unwind\n      seglen *= factor;\n    } else if (depth == maxdepth || seglen < 0.01) {\n      d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n    } else {\n      // Work out where we would end up if we did the full recursion\n      // For Kochawave, segment length and the angle don't change.\n      vec2 seg = seglen*vec2(cos(theta),sin(theta));\n      vec2 newpoint = p+seg; // Where we end up\n      if (distance(pos2,p+0.5*seg) > 0.75*length(seg)) {\n        polywind(pos,p,p+seg);\n        // Show skipped segments on mouse down.\n        if (iMouse.z > 0.0) d = min(d,segment(pos,p,newpoint));\n        p = newpoint;\n        plen += seglen*pow(4.0/factor,float(maxdepth-depth));\n      } else {\n        stack[depth++] = code;  // Recurse\n        seglen /= factor;\n      }\n    }\n  }\n  vec2 offset = vec2(10,0);\n  polywind(pos,vec2(0),-offset);\n  polywind(pos,-offset,-offset-vec2(0,10));\n  d = min(d,segment(pos,vec2(0),-offset));\n  polywind(pos,p,p+offset);\n  polywind(pos,p+offset,p+offset-vec2(0,10));\n  d = min(d,segment(pos,p,p+offset));\n  float px = fwidth(pos.x);\n  vec3 col = vec3(smoothstep(0.0,px,d));\n  if ((wind&1) == 0) col *= 0.8;\n  //col = mix(vec3(1,0,0), col,smoothstep(0.0,px,distance(pos,point)-0.01*factor/3.0));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "const float PI = 3.1415926;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2GRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[936, 967, 1006, 1041, 1226], [1228, 1228, 1293, 1293, 1523], [1525, 1525, 1559, 1559, 1685], [1687, 1687, 1742, 1742, 3943]], "test": "untested"}
{"id": "Dsj3zD", "name": "von Kochawave to von Koch", "author": "FabriceNeyret2", "description": "von Koch, relying on  stack + short cuts mla's L-System engine, but giving series of float lengthes and angles.\n\nKochawave  reference:  [url]  https://twitter.com/sfera314/status/1587348448205996032 [/url]\n[url] https://arxiv.org/pdf/2210.17320.pdf [/url]", "tags": ["optimized", "lsystem", "stack", "koch", "gosper"], "likes": 10, "viewed": 215, "published": 3, "date": "1667322759", "time_retrieved": "2024-07-30T16:23:25.016615", "image_code": "// Refactored fork of \"Koch Snowflake Optimized\" by mla. https://shadertoy.com/view/csX3Rs\n// ( Uses an explicit stack to keep track of the recursion + short-cuts to draw only what's necessary )\n// I replace program symbols by true segments lengthes and angles.\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0., 1.);\n  return length(p-b*h);\n}\n\nvec2 p = vec2(0);     // The drawing point\n\nfloat drawsegment(vec2 U, float seglen, float a) {\n  vec2 seg = seglen*vec2(cos(a),sin(a)),\n         q = p + seg;\n  float  d = segment(U,p,q);\n  p = q;\n  return d;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    float END = -1., factor = 3.,    // scaling factor betweel levels\n#if 0                   // von Koch snowflakes: F → F+F--F+F\n    program[] = float[] (0.,1., 1.05,1., -2.1,1., 1.05,1., 0.,END);// (angle, length)\n#elif 0                 // Kochawave\n    program[] = float[] (0.,1., .524,1.732, -2.62,1., 2.1,1., 0.,END);\n#else                   // interpolation\n    X = 1.-.5*cos(iTime), S = .866,             // von Koch to Kochawave\n // X = .5 - cos(iTime) , S = .866,             // left to right Kochawave\n    program[] = float[] ( 0., 1.,               // (angle, length)\n                          atan(S,X), sqrt(S*S+X*X), \n                          atan(X,S)-atan(X-1.,S)-3.14, sqrt(S*S+(X-1.)*(X-1.)), \n                          atan(X-1.,S)+1.57,1., \n                          0., END );\n#endif \n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y + vec2(1.5,.8);\n    int maxdepth = 4, stack[6], depth = -1;     // stack: pos in program + seg length\n    float lens[6];\n    stack[++depth] = 0; lens[depth] = 1.;\n    float d = 1e8, seglen = 1., theta = 0.;     // Cumulative angle\n    \n    while (depth >= 0) {\n        float len = program[2*stack[depth] +1]; // len\n        theta +=    program[2*stack[depth]++];  // turns\n        if (len == END)\n            seglen = lens[depth--];             // Terminate level\n        else   \n        if (depth == maxdepth)  \n              d = min(d,drawsegment(U,seglen*len,theta)); // Draw segment\n        else {\n          vec2 seg = seglen*len*vec2(cos(theta),sin(theta));\n          if (distance(U,p+.5*seg) > .5*length(seg))\n              p += seg;                         // skip unseen segments\n          else\n              stack[++depth]=0, lens[depth]=seglen, seglen *= len/factor; // Recurse\n        }\n    }\n    O =  vec4(smoothstep(0.,2./R.y,d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsj3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 302, 302, 401], [447, 447, 497, 497, 612]], "test": "untested"}
{"id": "cdjGzD", "name": "Graphic Design Experiment 2", "author": "yasuo", "description": "digital paisely", "tags": ["graphicdesign", "cineshader"], "likes": 52, "viewed": 2799, "published": 3, "date": "1667319000", "time_retrieved": "2024-07-30T16:23:26.064813", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\n// The following data is generated by my tool.\nvec2 svgPolygonData[34] = vec2[](vec2(0.1803,0.3769),vec2(0.09420002,0.354),vec2(0.04120001,0.3294),vec2(-0.01189999,0.3049),vec2(-0.0631,0.2727),vec2(-0.1072,0.237),vec2(-0.1487,0.194),vec2(-0.1832,0.1441),vec2(-0.2047,0.09520001),vec2(-0.2229,0.03929999),vec2(-0.2306,-0.0135),vec2(-0.2304,-0.07270001),vec2(-0.2218,-0.1314),vec2(-0.2062,-0.187),vec2(-0.1823,-0.2386),vec2(-0.1472,-0.2851),vec2(-0.1091,-0.3234),vec2(-0.06389999,-0.3516),vec2(-0.01620001,-0.3702),vec2(0.03920001,-0.3802),vec2(0.09659997,-0.3722),vec2(0.151,-0.347),vec2(0.1941,-0.3118),vec2(0.225,-0.2687),vec2(0.2414,-0.2238),vec2(0.2422,-0.1742),vec2(0.2302,-0.1154),vec2(0.2092,-0.059),vec2(0.1846,-0.006),vec2(0.1576,0.05610001),vec2(0.1374,0.118),vec2(0.1255,0.1803),vec2(0.1322,0.2427),vec2(0.1563,0.3115));\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\nfloat waveCircle(vec2 p, float s, float numW, float amp, float deg, float thickness){\n    float r = s+amp*cos(atan(p.y,p.x)*numW);\n    float d = abs(length(p)-r)-thickness;    \n    p*=Rot(radians(deg));\n    r = s+amp*cos(atan(p.y,p.x)*numW);\n    float d2 = abs(length(p)-r)-thickness;  \n    d = min(d,d2);    \n    return d;\n}\n\nfloat paiselyOutlineItem0(vec2 p, float i){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.024)-0.001;\n    p*=Rot(radians(iTime*30.*i));\n    float d2 = abs(length(p)-0.014)-0.0025;\n    d2 = max(-(abs(p.x)-0.005),d2);\n    d = min(d,d2);\n    return d;\n}\n\nfloat paiselyOutlineItem1(vec2 p, float deg){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.03)-0.0005;\n    p*=Rot(radians(sin(iTime)*deg));\n    float d2 = abs(length(p)-0.03)-0.003;\n    d2 = max(-p.x,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*deg*0.5));\n    d2 = abs(length(p)-0.015)-0.002;\n    d2 = max(-(abs(p.x)-0.005),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat paiselyBase(vec2 p){\n    vec2 prevP = p;\n    \n    float d = 10.;\n    \n    int num = svgPolygonData.length();\n    \n    float t = iTime*2.0;\n    vec2 a = vec2(0.);\n    vec2 b = vec2(0.);\n    \n    for( int i=0; i<num; i++ ){\n        int scene = i+int(mod(t,float(num)));\n        if(scene>=num)  scene -= num;\n        if(scene<num-1){\n            a = svgPolygonData[scene];\n            b = svgPolygonData[scene+1];\n        } else {\n            a = svgPolygonData[scene];\n            b = svgPolygonData[0];\n        }\n        \n        vec2 newPos = mix(a,b,mod(t,1.)); \n        \n        float d2 = paiselyOutlineItem0(p-newPos,float(i)*0.3);\n        \n        d = min(d,d2);\n    }\n    \n    return d;\n}\n\nfloat arrow(vec2 p){\n    float d = B((p-vec2(-0.015,0.0))*Rot(radians(-45.)),vec2(0.01,0.03));\n    float d2 = B((p-vec2(0.025,0.012))*Rot(radians(45.)),vec2(0.01,0.018));\n    d = min(d,d2);\n    return d;\n}\n\nfloat paiselyItem0(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(-radians(iTime*40.));\n    p = DF(p,4.0);\n    p -= vec2(0.08);\n    p*=1.55;\n    p*=Rot( radians(150.));\n    float d = arrow(p);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*30.));\n    p = DF(p,0.75);\n    p -= vec2(0.03);\n    p*=Rot( radians(45.));\n    float d2 = B(p,vec2(0.02, 0.5));\n    \n    p = prevP;\n    d2 = max(-d2, abs(length(p)-0.05)-0.01);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(-radians(iTime*20.));\n    d2 = B(p,vec2(0.015));\n    d = min(d,d2);\n    \n    return abs(d)-0.001;\n}\n\nfloat paiselyItem1(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(iTime*50.));\n    p = DF(p,2.0);\n    p -= vec2(0.055);\n    \n    p*=Rot( radians(45.));\n    float d = abs(SimpleVesicaDistance(p,0.13,0.11))-0.0005;\n    \n    p = prevP;\n    p*=Rot(radians(iTime*50.));\n    p = DF(p,4.0);\n    p -= vec2(0.04);\n    \n    p*=Rot( radians(45.));\n    float d2 = abs(SimpleVesicaDistance(p,0.12,0.115))-0.0005;\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat paiselyItem2(vec2 p){\n    vec2 prevP2 = p;\n    \n    p*=Rot(-radians(iTime*40.));\n    \n    vec2 prevP = p;\n    \n    float d = length(p)-0.1;\n    d = max(-(abs(p.x)-0.03),d);\n    \n    p*=Rot(radians(90.));\n    p.x-=0.02;\n    p.y-=0.03;\n    \n    float d2 = B(p,vec2(0.06,0.02));\n    float a = radians(45.);\n    p.x = abs(p.x)-0.06;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = max(-d2,d);\n    \n    p = prevP;\n    p*=Rot(radians(90.));\n    p.x+=0.02;\n    p.y+=0.03;\n    \n    d2 = B(p,vec2(0.06,0.02));\n    a = radians(-45.);\n    p.x = abs(p.x)-0.06;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    d = max(-d2,d);\n    \n    p = prevP;\n    a = radians(-10.);\n    p.x = abs(p.x)-0.07;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    d = abs(d)-0.001;\n    \n    p = prevP;\n    d2 = abs(length(p)-0.12)-0.001;\n    \n    d = min(d,d2);\n    \n    p.x = abs(p.x)-0.09;\n    d2 = abs(B(p,vec2(0.005,0.03)))-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    d2 = abs(B(p,vec2(0.01,0.08)))-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*50.));\n    p = DF(p,6.0);\n    p -= vec2(0.1);\n    \n    p*=Rot( radians(45.));\n    d2 = abs(B(p,vec2(0.01)))-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p*=Rot( radians(sin(iTime*3.)*45.));\n    d2 = abs(length(p)-0.16)-0.002;\n    d2 = max(-(abs(p.x)-0.15),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = waveCircle(p,0.18,10.,0.01,18.,0.001);\n    d = min(d,d2);\n    return d;\n}\n\nfloat paiselyItem3(vec2 p){\n    vec2 prevP = p;\n    p*=Rot( -radians(iTime*25.));\n    float d = waveCircle(p,0.15,10.,0.03,18.,0.001);\n    p = prevP;\n    p*=Rot( radians(iTime*15.));\n    float d2 = waveCircle(p,0.11,8.,0.02,18.,0.002);\n    d = min(d,d2);\n    p = prevP;\n    p*=Rot( -radians(iTime*20.));\n    d2 = waveCircle(p,0.07,7.,0.02,18.,0.001);\n    d = min(d,d2);\n    p = prevP;\n    p*=Rot( radians(iTime*10.));\n    d2 = waveCircle(p,0.03,6.,0.02,18.,0.002);\n    d = min(d,d2);\n    return d;\n}\n\nfloat paiselyItem4(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(-radians(iTime*30.));\n    p = DF(p,6.0);\n    p -= vec2(0.1);\n    \n    p*=Rot( radians(45.));\n    float d = B(p,vec2(0.001,0.015));\n    \n    p = prevP;\n    p*=Rot(-radians(iTime*30.));\n    p*=Rot( radians(7.));\n    p = DF(p,6.0);\n    p -= vec2(0.095);\n    p*=Rot( radians(45.));\n    float d2 = B(p,vec2(0.001,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot( -radians(45.-sin(iTime)*150.));\n    p.y=abs(p.y)-0.17;\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec2(0.02),radians(45.)))-0.001; \n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*25.));\n    p = DF(p,1.25);\n    p -= vec2(0.06);\n    p*=Rot( radians(45.));\n    d2 = B(p,vec2(0.02, 0.5));\n    \n    p = prevP;\n    d2 = abs(max(-d2, abs(length(p)-0.09)-0.02))-0.001;\n    d = min(d,d2);    \n    \n    p = prevP;\n    p*=Rot( radians(45.+sin(iTime*0.5)*150.));\n    p.y=abs(p.y)-0.05;\n    d2 = abs(Tri(p,vec2(0.02),radians(45.)))-0.001; \n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = length(p)-0.01;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat paiselyItem5(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(iTime*50.));\n    p = DF(p,4.0);\n    p -= vec2(0.09);\n    \n    p*=Rot( radians(45.));\n    float d = abs(SimpleVesicaDistance(p,0.115,0.10))-0.001;\n    \n    p = prevP;\n    p*=Rot(-radians(iTime*40.));\n    p = DF(p,2.0);\n    p -= vec2(0.033);\n    \n    p*=Rot( radians(45.));\n    float d2 = abs(B(p,vec2(0.01)))-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(12.));\n    p*=Rot(radians(iTime*50.));\n    p = DF(p,4.0);\n    p -= vec2(0.115+sin(iTime*3.)*0.005);\n    \n    p*=Rot( radians(225.));\n    d2 = abs(Tri(p,vec2(0.02),radians(45.)))-0.001; \n    d = min(d,d2);    \n    \n    p = prevP;\n    p*=Rot(-radians(iTime*30.));\n    d2 = abs(length(p)-0.21)-0.006;\n    d2 = max(p.x+0.1,d2);\n    d = min(d,d2); \n    \n    p = prevP;\n    d2 = abs(length(p)-0.21)-0.0005;\n    d = min(d,d2); \n    \n    return d;\n}\n\nfloat paiselyItem6(vec2 p){\n    vec2 prevP = p;\n\n    float d = abs(length(p)-0.09)-0.001;\n    p*=Rot(radians(iTime*25.));\n    p = DF(p,1.25);\n    p -= vec2(0.09);\n    p*=Rot( radians(45.));\n    float d2 = B(p,vec2(0.02, 0.5));\n    d = max(d2,d);\n    \n    p = prevP;\n    d2 = abs(max(-d2, abs(length(p)-0.09)-0.012))-0.001;\n    \n    d = min(d,d2);    \n    \n    p = prevP;\n    p*=Rot(-radians(sin(iTime)*135.));\n    p = DF(p,0.5);\n    p -= vec2(0.02);\n    p*=Rot( radians(45.));\n    d2 = B(p,vec2(0.03, 0.5));\n    \n    p = prevP;\n    d2 = max(-d2, abs(length(p)-0.05)-0.005);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(length(p)-0.12)-0.005;\n    p*=Rot(radians(-iTime*60.+50.));\n    float deg = 135.;\n    float a = radians(deg);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);    \n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(length(p)-0.02)-0.001;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat paiselyItem7(vec2 p){\n    p*=Rot(radians(iTime*50.));\n\n    vec2 prevP = p;\n    p = DF(p,0.75);\n    p -= vec2(0.04);\n    \n    p*=Rot( radians(45.));\n    float d = abs(SimpleVesicaDistance(p,0.115,0.10))-0.001;\n    \n    p = prevP;\n    p*=Rot(radians(60.));\n    p = DF(p,0.75);\n    p -= vec2(0.03);\n    \n    p*=Rot( radians(225.));\n    float d2 = abs(Tri(p,vec2(0.03),radians(45.)))-0.002; \n    d = min(d,d2);   \n    \n    p = prevP;\n    p*=Rot(radians(60.));\n    p = DF(p,0.75);\n    p -= vec2(0.07);\n    \n    p*=Rot( radians(45.));\n    d2 = B(p,vec2(0.07,0.001)); \n    \n    p = prevP;\n    p*=Rot(-radians(iTime*35.));\n    d2 = max(-(abs(p.x)-0.035),d2);\n    d2 = max(-(abs(p.y)-0.035),d2);\n    d = min(d,d2);        \n    \n    return d;\n}\n\nfloat paiselyItem8(vec2 p){\n    //p.y = mod(p.y,0.12)-0.06;\n    vec2 prevP = p;\n    p-=vec2(-0.01,0.04);\n    float d =  B(p,vec2(0.02,0.05)); \n    float a = radians(-22.);\n    p.x-=0.01;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    p-=vec2(0.01,-0.04);\n    float d2 = B(p,vec2(0.02,0.05)); \n    a = radians(-22.);\n    p.x+=0.01;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d,d2);\n    \n    return abs(d)-0.0005;\n}\n\nfloat paiselyItem9(vec2 p){\n    vec2 prevP = p;\n    \n    float d = 10.;\n    for(float i = 0.; i<2.; i++){\n        p*= 1.0+i*0.03;\n        p*=Rot(radians(i*30.0+iTime*50.));\n        p = abs(p);\n        p-=0.025+i*0.01;\n        float d2 = arrow(p);\n        d = min(d,d2);\n    }\n    \n    return abs(d)-0.001;\n}\n\nfloat paisely(vec2 p){\n    vec2 prevP = p;\n    float d = paiselyBase(p);\n    float d2 = 10.;\n    \n    p*=0.95;\n    d2 = paiselyItem0(p-vec2(0.04,-0.18));\n    d = min(d,d2);\n\n    p*=1.6;\n    d2 = paiselyItem4(p-vec2(-0.045,0.14));\n    d = min(d,d2);\n\n    p = prevP;\n    p-=vec2(-0.145,-0.075);\n    p*=2.3;\n    d2 = paiselyItem6(p);\n    d = min(d,d2);\n\n    p = prevP;\n    p*=0.95;\n    d2 = paiselyOutlineItem1(p-vec2(0.105,0.0),-160.);\n    d = min(d,d2);\n\n    p = prevP;\n    p-=vec2(0.06,0.25);\n    p*=0.9;\n    d2 = paiselyOutlineItem1(p,-170.);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    vec3 col = vec3(0.);\n    \n    p*=0.9;\n    p.x = abs(p.x)-0.35;\n    p.x*=-1.0;\n    p.y-=-0.04;\n    p*=Rot(radians(-20.));\n    float d = paisely(p);\n    \n    p = prevP;\n    p-= vec2(0.0,0.23);\n    float d2 =  paiselyItem2(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p-= vec2(0.0,-0.42);\n    p*=1.8;\n    d2 =  paiselyItem7(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-= vec2(0.72,0.32);\n    p*=1.2;\n    d2 =  paiselyItem3(p);\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-= vec2(0.735,-0.335);\n    p*=1.1;\n    d2 =  paiselyItem1(p);\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-= vec2(0.78,-0.02);\n    p*=1.3;\n    d2 =  paiselyItem9(p);\n    d = min(d,d2);  \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.035,-0.05);\n    p*=Rot(radians(10.));\n    d2 =  paiselyItem8(p);\n    d = min(d,d2);  \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.53,-0.43);\n    p*=Rot(radians(45.));\n    d2 =  paiselyItem8(p);\n    d = min(d,d2);  \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.53,0.43);\n    p*=Rot(radians(60.));\n    d2 =  paiselyItem8(p);\n    d = min(d,d2);  \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.25,0.38);\n    p*=Rot(radians(10.));\n    d2 =  paiselyItem8(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.25,0.25);\n    d2 =abs( length(p)-0.02)-0.001;\n    d = min(d,d2);\n    p-=vec2(-0.04,-0.12);\n    d2 = abs(length(p)-0.015)-0.0005;\n    d = min(d,d2);\n    p-=vec2(-0.09,-0.1);\n    d2 = length(p)-0.01;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.17,0.4);\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec2(0.04),radians(45.)))-0.001; \n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.12,-0.44);\n    d2 = abs(Tri(p,vec2(0.03),radians(45.)))-0.001; \n    d = min(d,d2);    \n    \n    p = prevP;\n    p.y+=0.02;\n    p = abs(p);\n    p-=vec2(0.83,0.15);\n    d2 = abs( length(p)-0.03)-0.001;\n    d = min(d,d2);\n    \n    p-=vec2(-0.12,-0.03);\n    d2 = length(p)-0.015;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.53,0.36);\n    d2 = abs( length(p)-0.015)-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p-=vec2(0.6,-0.46);\n    d2 = abs( length(p)-0.015)-0.001;\n    d = min(d,d2);    \n    \n    p = prevP;\n    p-=vec2(0.0,-0.3);\n    d2 = abs( length(p)-0.015)-0.001;\n    d = min(d,d2);      \n    \n    col = mix(col,vec3(1.),S(d,0.0));\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1275, 1275, 1329, 1329, 1387], [1389, 1389, 1474, 1474, 1714], [1716, 1716, 1759, 1759, 1970], [1972, 1972, 2017, 2017, 2369], [2371, 2371, 2397, 2397, 3071], [3073, 3073, 3093, 3093, 3278], [3280, 3280, 3307, 3307, 3842], [3844, 3844, 3871, 3871, 4284], [4286, 4286, 4313, 4313, 5751], [5753, 5753, 5780, 5780, 6252], [6254, 6254, 6281, 6281, 7317], [7319, 7319, 7346, 7346, 8201], [8203, 8203, 8230, 8230, 9170], [9172, 9172, 9199, 9199, 9912], [9914, 9914, 9941, 9973, 10357], [10359, 10359, 10386, 10386, 10666], [10668, 10668, 10690, 10690, 11251], [11253, 11253, 11310, 11310, 13902]], "test": "untested"}
{"id": "csX3Rs", "name": "Koch Snowflake Optimized", "author": "mla", "description": "The Koch Snowflake using a simple stack (just storing the offset of the \"current instruction\"). Optimized to skip recursion when far from the point being plotted.\n\nNeeds to be full screen for the proper effect.", "tags": ["optimized", "lsystem", "stack", "koch", "gosper"], "likes": 11, "viewed": 211, "published": 3, "date": "1667310859", "time_retrieved": "2024-07-30T16:23:27.228701", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Koch Curve, drawn with stack. mla, 2022.\n//\n// Also showing varying the turn angle from the standard 60°\n//\n// Inspired by https://www.shadertoy.com/view/cdsGRj by FabriceNeyret2\n//\n// Uses an explicit stack to keep track of the recursion.\n// This one keeps track of intermediate segments and avoids recursing far from\n// the point being plotted.\n//\n// Mouse down shows segments actually drawn around mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\n// F → F+F--F+F\nconst int A = 0, END = -1, L = -1, R = 1;\nconst int program[5] =\n  int[] (C(0,A),C(R,A),C(L+L,A),C(R,A),C(0,END));\n\nconst int MAXDEPTH = 6;\n\nvec2 p = vec2(0);     // The drawing point\nvec2 point = vec2(100); // The moving point\nfloat plen = 0.0;     // Cumulative path length\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t >= plen && t < plen+seglen) point = p + (t-plen)/seglen*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\nvec2 map(vec2 pos, float factor) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos.y += 0.8;\n  pos *= factor/3.0;\n  pos.x += 0.5*factor;\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float angle = PI/3.0 + 0.6*sin(0.2*iTime);\n  float factor = 2.0*(1.0+cos(angle)); // Linear scale factor at each level.\n  int maxdepth = 5;\n  //maxdepth = 1+int(iTime/4.0)%MAXDEPTH;\n  vec2 pos = map(fragCoord,factor);\n  vec2 pos2 = pos;\n  if (iMouse.z > 0.0) pos2 = map(iMouse.xy,factor);\n  int stack[MAXDEPTH];\n  int depth = 0;\n  stack[depth++] = 0;\n  float t = mod(iTime,4.0*pow(4.0/factor,float(maxdepth-1))); // Moving point\n  float d = 1e8;\n  float seglen = 1.0;\n  float theta = 0.0;    // Cumulative angle\n  while (depth > 0) {\n    int instr = program[stack[depth-1]++];\n    // Decode instruction\n    int turns = instr>>16;\n    int code = instr<<16>>16;\n    theta += float(turns)*angle; // Apply turn\n    if (code == END) {\n      depth--;    // Terminate level & unwind\n      seglen *= factor;\n    } else if (depth == maxdepth) {\n      d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n    } else {\n      // Work out where we would end up if we did the full recursion\n      // For Koch snowflake, segment length and the angle don't change.\n      vec2 seg = seglen*vec2(cos(theta),sin(theta));\n      vec2 newpoint = p+seg; // Where we end up\n      if (distance(pos2,p+0.5*seg) > 0.8*length(seg)) {\n        polywind(pos,p,p+seg);\n        // Show skipped segments on mouse down.\n        if (iMouse.z > 0.0) d = min(d,segment(pos,p,newpoint));\n        p = newpoint;\n        plen += seglen*pow(4.0/factor,float(maxdepth-depth));\n      } else {\n        stack[depth++] = code;  // Recurse\n        seglen /= factor;\n      }\n    }\n  }\n  vec2 offset = vec2(10,0);\n  polywind(pos,vec2(0),-offset);\n  polywind(pos,-offset,-offset-vec2(0,10));\n  d = min(d,segment(pos,vec2(0),-offset));\n  polywind(pos,p,p+offset);\n  polywind(pos,p+offset,p+offset-vec2(0,10));\n  d = min(d,segment(pos,p,p+offset));\n  //d = min(d,segment(pos,offset,p+offset));\n  float px = fwidth(pos.x);\n  vec3 col = vec3(smoothstep(0.0,px,d));\n  if ((wind&1) == 0) col *= 0.8;\n  //col = mix(vec3(1,0,0), col,smoothstep(0.0,px,distance(pos,point)-0.01*factor/3.0));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "const float PI = 3.1415926;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csX3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[963, 994, 1033, 1068, 1253], [1255, 1255, 1320, 1320, 1550], [1552, 1552, 1586, 1586, 1712], [1714, 1714, 1769, 1769, 3832]], "test": "untested"}
{"id": "mdS3zD", "name": "Calm sea of LEGO®", "author": "LongJohnny", "description": "While I was creating another LEGO shader I decided to play around with domain repetition and ended up creating something that reminded me of a sea so I pushed the idea further and actually made a sea. ", "tags": ["raymarching", "water", "lego", "ripple"], "likes": 19, "viewed": 517, "published": 3, "date": "1667308587", "time_retrieved": "2024-07-30T16:23:28.303826", "image_code": "// The sea of LEGOS\n//\n// While I was creating another LEGO shader I decided\n// to play around with domain repetition and ended up \n// creating something that reminded me of a sea so \n// I pushed the idea further and actually made a sea. \n//\n// The ripples are actually a very simple function, its a sine wave whose domain is clamped and\n// shifted over time. You can combine multiple similar functions and create the waves.\n//\n// The animation will change from smooth to stop-motion like\n// and then back to smooth every now and then because I explored\n// both effects and was torn between them so I decided to leave both :).\n//\n// I hope you enjoy it!\n// ----------------------------------------\n\nvec4 sdScene(vec3 p);\n\nvec4 rayMarch(vec3 ro, vec3 rd, out bool hit) {\n    \n    vec4 res = vec4(-1.); // color = xyz, distance = w \n    \n    float t = 0.;\n    for (int i = 0; i < MAX_MARCH_STEPS && t<MAX_MARCH_DIST; ++i) {\n        \n        vec4 ds = sdScene(ro + rd*t);   \n        if(ds.w*ds.w < 1e-6) {\n            res = vec4(ds.xyz, t);\n            hit = true;\n            break;\n        }\n        \n        t += ds.w;\n    }\n    \n    return res;\n}\n\n// Adapted from this shader by blackle: https://www.shadertoy.com/view/3lcBD2\nvec2 edge(vec2 p, float l) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -l : l, 0.);\n    else             return vec2(0., (p.y < 0.) ? -l : l);\n}\n\nfloat ripple(float x, float sc, float at, float t) {\n\n    // First wave\n    float w1 = sin(2.*clamp(x - t, -2.*PI*0.5, 0.));\n    \n    // Second wave\n    float w2 = (sin(2.*clamp(x - t, -4.5*PI*0.5, -2.5*PI*0.5))*0.5 + 0.5)*0.7;\n   \n    return (w1 + w2)*exp(-abs(x)*at)*sc;\n}\n\nfloat wave(float x, float z, float t) {\n    float ir = cos(z/5.)*0.5;\n    x += ir;\n    return exp(-max(0., (x - t)*2.))*(cos(clamp(x - t, -PI, 0.))*0.5 + 0.5);\n}\n\nvec4 sdScene(vec3 p) {\n    \n    // Repeat domain on the X and Z axis \n    float domainRepeat = BRICK_WIDTH*1.06;\n    vec3 p2 = p;\n    p2.xz = mod(p2.xz + 0.5*domainRepeat, domainRepeat) - 0.5*domainRepeat;\n    vec2 s = (p.xz - p2.xz);\n    vec2 e = edge(p.xz - s, domainRepeat);\n    vec2 s2 = s + e;\n    \n    // Base water movement\n    float h = (1. - texture(iChannel1, s.xy*0.1 - vec2(iTime*0.02)).r)*0.7;\n    \n    // Wave\n    float wt = mod(iTime, 20.);\n    float wh = max(.7, hash1(iTime - wt)*1. + 0.4);\n    float wv = wave((-s.y+s.x*0.2)*0.4 + 4.*PI, s.x, wt*2.)*wh;\n    h += wv;\n    \n    const float MAX_HEIGHT = 3.;\n    \n    float ds = 1000.;\n    vec3 col;\n    \n    // Falling brick\n    {\n        // Frequency of falling brick\n        float time = iTime*5.;\n        float t = mod(time,10.); \n        float ph = time - t;\n        \n        // Random value\n        vec2 r = hash21(round(ph + 100.));\n        float r2 = r.x;\n        \n        // Place where brick will fall\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (7.*r.y);\n        \n        // Brick transformations\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*15., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = sd1by1Brick(p3);\n        col = vec3(1., r2, 0.); \n        \n        // Ripple\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 2., .3, t*1.6);\n    }\n    \n    /*\n    // Falling brick 2\n    {\n        float time = iTime*5. - 5.;\n        float t = mod(time,20.); \n        float ph = time - t;\n\n        vec2 r = hash21(round(ph + 300.));\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (12.*r.y);\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*20., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = min(ds, sd1by1Brick(p3)*1.);\n        col = vec3(1., 1., 0.);\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 1., .3, t*1.6);\n    }\n    \n    // Falling brick 3\n    {\n        float time = iTime*5. - 10.;\n        float t = mod(time,20.); \n        float ph = time - t;\n\n        vec2 r = hash21(round(ph + 600.));\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (3.*r.y);\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*15., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = min(ds, sd1by1Brick(p3)*1.);\n        col = vec3(1., 0., 0.);\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 2., .4, t*1.6);\n    }\n    \n    // Falling brick 4\n    {\n        float time = iTime*5. - 16.;\n        float t = mod(time,20.); \n        float ph = time - t;\n\n        vec2 r = hash21(round(ph + 1000.));\n        r.x *= 2.*PI; // Random angle\n        r.y *= 2.0 - 1.0; // Random offset\n\n        vec3 pos = vec3(cos(r.x)*3., 0., sin(r.x)) * (3.*r.y);\n        vec3 p3 = p;\n        p3 -= vec3(0., 10.5 - pow(t, 0.5)*15., 0.) + pos;\n        p3.xy *= rot(t*PI + ph);\n        p3.xz *= rot(t*PI);\n        ds = min(ds, sd1by1Brick(p3)*1.);\n        col = vec3(1., 1., 0.);\n        float x = length(pos.xz - s.xy);\n        h += ripple(x, 3., .5, t*1.6);\n    }*/\n    \n    if ( mod(floor(iTime/15.),2.) != 0.) h = round(h*3.)/3.; \n    \n    // Ocean distance\n    float ds2 = sd1by1PlateInf(p - vec3(s.x, h, s.y));\n    ds2 = min(ds2, sd1by1PlateInf(p - vec3(s2.x, MAX_HEIGHT, s2.y)));    \n    if (ds2 < ds) {\n        col = mix(vec3(5.,63.,79.)/255., vec3(135.,159.,168.)/255.*2., smoothstep(0.65, 1.0, ((h/MAX_HEIGHT)*0.5 + 0.5)));\n        float tones = 20.;\n        col = ceil(col * tones) / tones;\n        col += hash12(s.xy*0.1)*0.02;\n        ds = ds2;\n    }\n    \n    return vec4(col, ds - 0.2*PIECES_SCALE);\n\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h ).w + \n                      k.yyx*sdScene( p + k.yyx*h ).w + \n                      k.yxy*sdScene( p + k.yxy*h ).w + \n                      k.xxx*sdScene( p + k.xxx*h ).w );\n}\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.27*mix( rg.x, rg.y, f.z );\n}\n\n// duke's stars\nvec3 stars(vec3 rd) {\n    vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\n    vec3 starbg = vec3(0.0);\n    starbg = mix(starbg, \n        vec3(255.,247.,90.)/255., \n        smoothstep(0.99, 1.0, stars)\n        );\n    return starbg;\n}\n\nvec3 renderScene(vec3 ro, vec3 rd, vec3 sky) {\n    \n    vec3 col = sky;\n    vec4 obj = vec4(0., 0., 0., 40.);\n\n    bool hit = false;\n    obj = rayMarch(ro, rd, hit);\n\n    if (hit) {\n        col = vec3(0.);\n\n        vec3 p = ro + rd*obj.w;\n        //vec3 p = obj.xyz;\n        vec3 n = calcNormal(p);\n        vec3 objCol = obj.xyz;\n\n        float R0 = pow((1. - 1.333)/(1. + 1.333),2.);        \n\n        // Side Light\n        {\n            vec3 ld = normalize(vec3(0.0, 0.3, 1.0));\n            float dif = max(0., dot(n, ld));\n\n            vec3 hlf = normalize(-rd + ld);\n            float spe = pow(max(0., dot(n, hlf)), 16.);\n            \n            float fr = R0 + (1. - R0)*pow(1. - dif, 5.);\n            \n            col += spe * vec3(250.,193.,138.)/255. * dif;\n            col += fr  * dif;\n        }\n        \n        // Sky light\n        {\n            vec3 ld = normalize(vec3(0.0, 1.0, 0.0));\n            float dif = max(0., dot(n, ld));\n\n            col += dif * objCol * 0.9;\n            col += sky * .2;\n        }\n\n        col = pow(col, vec3(1./.4545));\n        col = mix(sky, col, (MAX_MARCH_DIST - obj.w) / MAX_MARCH_DIST);\n\n    } else {    \n        obj.w = 40.;\n        col = col = mix(sky, col, (MAX_MARCH_DIST - obj.w) / MAX_MARCH_DIST);\n        col += stars(rd);// * sky * 5.;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 origin = vec3(0.);\n   \n    vec3 ro = vec3(2.,7., -12.);\n    //ro.x += sin(iTime*0.2)*0.3;\n    //ro.y += cos(iTime*0.1)*1.; \n    \n    vec3 rd = rayDir(ro, origin, uv);\n    \n    vec3 sky = mix(vec3(250.,193.,138.)/255.*0.4, vec3(72.,74.,93.)/255.*0.4, uv.y*0.5 + 0.5);\n    \n    vec3 col = renderScene(ro, rd, sky);\n    \n    // Contrast\n    col.r = smoothstep(0.11, 1., col.r);\n    col.b = smoothstep(0.1, 1., col.b);\n    col.g = smoothstep(0.11, 1., col.g);\n    \n    // Vignette\n    col *= pow(-length(uv)+2., 0.6);\n    \n    // Gamma correct ^(1/2.2)\n    col = pow(col, vec3(.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_MARCH_STEPS 400\n#define MAX_MARCH_DIST 30.\n#define MIN_MARCH_DIST 0.0001\n\n#define PI 3.14159265359\n\n#define PIECES_SCALE 0.1\n\n#define PLATE_HEIGHT (3.2 * PIECES_SCALE)\n#define BRICK_WIDTH (8. * PIECES_SCALE)\n#define BRICK_HEIGHT (9.6 * PIECES_SCALE)\n#define STUD_HEIGHT (1.6 * PIECES_SCALE)\n#define STUD_RADIUS (2.4 * PIECES_SCALE)\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec3 rayDir(vec3 ro, vec3 origin, vec2 uv) {\n    \n    vec3 d = normalize(origin - ro);\n    \n    vec3 r = normalize(cross(vec3(0.,1.,0.), d));\n    vec3 u = cross(d, r);\n    \n    return normalize(d + r*uv.x + u*uv.y); \n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nbool intersectSphere(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 oc = ro - p;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return false;\n    return true;\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n/* ----- Iq's SDF functions (https://iquilezles.org/articles/distfunctions/) ---------- */\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  p.xz = abs(p.xz);\n  vec3 q = p - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  // return length(max(q,0.0)) + min(max(q.x,q.y,q.z),0.0) -> Pyramid top\n}\n\n\nfloat sdCappedCylinder( vec3 p, float r, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v,v);\n}\n\nfloat bb( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// Awsome LEGO logo by mmalex: https://www.shadertoy.com/view/MsX3W2\nfloat lego(vec2 uv) { // x is -2 to 2\n    uv.x+=uv.y*-0.1; // italic\n    float oldx=uv.x;\n    uv.x=fract(uv.x)-0.5; // letter repeat\n    if (abs(oldx)>2.0) return 0.0; // clip!\n    float l;\n    if( oldx<0.0) {\n        // l and e\n        float e0=bb(uv-vec2(-0.15,0.0),vec2(0.2,0.0)); // cross of e \n        if (oldx>-1.0) uv.y=-abs(uv.y); else e0=1.0;\n        float l0=bb((uv)-vec2(0.0,-0.75),vec2(0.35,0.0)); // bottom of l\n        float l1=bb((uv)-vec2(-0.35,0.0),vec2(0.0,0.75)); // left of l                                              \n        l0=min(l0,e0);\n        l=min(l0,l1);                                        \n    } else {\n        l=abs(bb(uv,vec2(0.1,0.5))-0.25); // round o\n        if (oldx<1.0) {\n            // g - ugh nasty\n            if (uv.x>0.0 && uv.y>0.0 && uv.y<0.5)                                    \n                            l=bb((uv)-vec2(0.35,0.6),vec2(0.0,0.1));\n            float e0=bb(uv-vec2(0.2,0.0),vec2(0.15,0.0));\n            l=min(l,e0);\n        }\n    }              \n    return smoothstep(0.1,0.05,l);   \n}\n\n/* --- LEGO Common SDFs ---- */\nfloat sdStud(vec3 p) {\n    float ds = sdCappedCylinder(p - vec3(0.0, lego(p.xz*10.)*0.006, 0.0), STUD_RADIUS, .5*STUD_HEIGHT);  \n    return ds;\n}\n\nfloat sd1by1Plate(vec3 p) {\n    float ds = sdBox(p, vec3(.5*BRICK_WIDTH, .5*PLATE_HEIGHT, .5*BRICK_WIDTH ));\n    ds = min(ds, sdStud(p - vec3(0.0, .5*PLATE_HEIGHT + .5*STUD_HEIGHT, 0.0)));\n    return ds;\n}\n\nfloat sd1by1PlateInf(vec3 p) {\n    float ds = sdBox2(p, vec3(.5*BRICK_WIDTH, .5*PLATE_HEIGHT, .5*BRICK_WIDTH ));\n    ds = min(ds, sdStud(p - vec3(0.0, .5*PLATE_HEIGHT + .5*STUD_HEIGHT, 0.0)));\n    return ds;\n}\n\nfloat sd1by1Brick(vec3 p) {\n    float ds = sdBox(p, vec3(.5*BRICK_WIDTH, .5*BRICK_HEIGHT, .5*BRICK_WIDTH ));\n    ds = min(ds, sdStud(p - vec3(0.0, .5*BRICK_HEIGHT + .5*STUD_HEIGHT, 0.0)));\n    return ds;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdS3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[722, 722, 769, 769, 1147], [1149, 1227, 1255, 1255, 1397], [1399, 1399, 1451, 1470, 1673], [1675, 1675, 1714, 1714, 1836], [1838, 1838, 1860, 1907, 5743], [5745, 5791, 5837, 5837, 6157], [6159, 6173, 6196, 6196, 6415], [6417, 6433, 6454, 6454, 6658], [6660, 6660, 6706, 6706, 7979], [7981, 7981, 8038, 8038, 8757]], "test": "untested"}
{"id": "msBGzD", "name": "Through the Cracks (3D)", "author": "jarble", "description": "Another triangle-wave fractal flythrough.", "tags": ["3d", "fractal"], "likes": 4, "viewed": 230, "published": 3, "date": "1667302953", "time_retrieved": "2024-07-30T16:23:29.219378", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 spaghetti(vec3 uv)\n{\n    vec3 col = vec3(0.);\n    for(int k = 0; k < 6; k++){ \n        vec3 offset =\n            vec3(-uv.y,uv.y*(1.+uv.x/2.)-uv.z,uv.z-uv.x)\n            //fract(vec3(-uv.y,uv.y+uv.x/2.-uv.z,uv.z-uv.x))\n\n        ;\n        uv =\n            abs(fract(uv.yzx+offset.zxy)-.5)\n        ;\n        col = vec3(col.yz,uv.x-uv.y);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,0,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = spaghetti(p/16.);\n        float sd1 = col.z-.1;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 279, 279, 623], [625, 625, 666, 666, 1206]], "test": "untested"}
{"id": "mdSGzD", "name": "Canopy descent (3D)", "author": "jarble", "description": "Falling through the trees.", "tags": ["3d", "fractal", "tree", "forest"], "likes": 4, "viewed": 181, "published": 3, "date": "1667301981", "time_retrieved": "2024-07-30T16:23:29.999293", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 spaghetti(vec3 uv)\n{\n    vec3 col = vec3(0.);\n    for(int k = 0; k < 6; k++){ \n        vec3 offset =\n            //vec3(uv.x-.45,uv.y+.45,uv.z-uv.x)\n            vec3(uv.x-.35,uv.y-.35,uv.z-uv.x)\n        ;\n        uv =\n            abs(fract(uv.yzx+offset.zxy)-.5)\n        ;\n        col = vec3(col.yz,uv.x-uv.y);\n    }\n    \n    return\n        col\n        //col - uv;\n    ;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,6.7-t,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = spaghetti(p/16.);\n        float sd1 = col.z-.14;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 279, 279, 631], [633, 633, 674, 674, 1219]], "test": "untested"}
{"id": "csB3zD", "name": "reaction diffusion experiment 2", "author": "ufffd", "description": "exploring some ideas with reaction diffusion. click to draw", "tags": ["reactiondiffusion"], "likes": 4, "viewed": 208, "published": 3, "date": "1667293677", "time_retrieved": "2024-07-30T16:23:30.829075", "image_code": "const int DEBUG = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 buffA = texture(iChannel0,uv);\n    vec4 buffB = texture(iChannel1,uv);\n\n    if (DEBUG==1)\n        fragColor = buffA;\n    if (DEBUG==2)\n        fragColor = buffB;\n    if (DEBUG==3)\n        fragColor = buffB - buffA;\n    if (DEBUG!=0) return;\n\n    // colorize\n    vec3 col = vec3(smoothstep(0.3,0.4,buffA.a));\n    // col.r += smoothstep(0.45,0.4,buffA.a);\n    // Output to screen\n    col = vec3(1. - col.r);\n    col.b += buffB.b;\n    \n    col.b -= buffA.b;\n    \n    col.b += smoothstep(0.9,1.,buffA.a) * 0.2;\n    col.r += smoothstep(0.7,.39,buffB.a) * 0.2;\n    \n    col += smoothstep(0.,1.,buffA.b);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 1.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    px *= 3.;\n    range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.025;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum / 2.;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 1.;\n    float dB = .25;\n    float feed = 0.055;\n    float k = 0.065;\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec2 uvc = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    vec2 muvc = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    uv -= 0.5;\n    uv *= vec2(16.,9.);\n    uv *= 0.9995;\n    uv /= vec2(16.,9.);\n    uv += 0.5;\n    fragColor.ab = setAB(uv,cdist);\n    fragColor.b = mix(fragColor.b,texture(iChannel1,uv,4.).b*1.1,0.01);\n    fragColor *= 1. + cnoise(vec3(uv.xy * 2., iTime * 0.4))*0.015;\n    if (iMouse.z > 0.5) {\n        if (mdist<0.05) { fragColor.b = 1.; fragColor.a = 0.; }\n    }\n    \n    // init animation\n    if (iFrame < 67) {\n        float sdist1 = distance(uvc, vec2(iTime-1.,0.));\n        float sdist2 = distance(uvc, vec2(-iTime+1.,0.));\n        fragColor.b = 1.-step(iTime*0.1,sdist1);\n        fragColor.b += 1.-step(iTime*0.1,sdist2);\n        fragColor.b = clamp(fragColor.b,0.,1.);\n        fragColor.a = 1.-fragColor.b;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 1.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 1.;\n    float dB = .25;\n    float feed = 0.08;\n    float k = 0.06;\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec2 uvc = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    vec2 muvc = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec2 px = 1./iResolution.xy;\n\n    uv -= 0.5;\n    uv *= vec2(iResolution.x,iResolution.y);\n    uv *= 1.0005;\n    uv = rotate(uv, 0.001);\n    uv /= vec2(iResolution.x,iResolution.y);\n    uv += 0.5;\n    // uv.y += px.y/4.;\n    \n    vec2 buffA = texture(iChannel1,uv).ab;\n    \n    fragColor.ab = mix(\n        mix(setAB(uv,cdist),vec2(0.),0.001),\n        buffA,\n        (1.-buffA.x)*0.05\n      );\n    if (iMouse.z > 0.5) {\n        if (mdist<0.05) { fragColor.b = 1.; fragColor.a = 0.; }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 129, 819]], "test": "untested"}
{"id": "dsB3RW", "name": "Mandelbrot Set(simple 2d)", "author": "kanayuki", "description": "Mandelbrot Set", "tags": ["2d", "mandelbrotset"], "likes": 1, "viewed": 163, "published": 3, "date": "1667290152", "time_retrieved": "2024-07-30T16:23:31.671822", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.y;\n    //float a0 = uv.x * 3. - 2.5;\n    //float b0 = uv.y * 3. -1.5;\n    \n    vec2 uv = (2.*fragCoord-iResolution.y)/iResolution.y;\n    float a0 = uv.x-1.;\n    float b0 = uv.y;\n    \n    \n    float a = a0;\n    float b = b0;\n\n    for(int k=0; k<500; k++){\n\n      float as = a0 + a*a-b*b;\n\n      b = b0 + 2.*a*b;\n\n      a = as;\n\n      if( a*a + b*b > 3. ){\n\n        // colour = factor(k);\n        \n        vec3 col = vec3(255,0,255);\n\n        // plotPointAt( a0, b0 );\n        \n        fragColor = vec4(col,1.0);\n\n        return;\n\n      }\n\n    }\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsB3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 215, 845]], "test": "untested"}
{"id": "csB3RD", "name": "the cube", "author": "lomateron", "description": "using fourier transform(FT) to color low frequencies\nfeed the FT result to a neural network(NN)\nthe NN will extract concepts and tell whats going behind the noise\n", "tags": ["automata"], "likes": 6, "viewed": 271, "published": 3, "date": "1667271106", "time_retrieved": "2024-07-30T16:23:32.432787", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec4 tt = floatBitsToUint(texelFetch(iChannel0,ivec2(fragCoord),0));\n    float pi = 3.141592;\n    #define zz 128.\n    #define ww 3\n    float frq = 5.;\n    fragColor = vec4(0);\n    for(int i = 0; i < ww; ++i)\n    {\n        float co = 0.;\n        float si = 0.;\n        float su = 0.;\n        for(float y = .5; y < zz; ++y)\n        {\n                               uint t = tt.x;\n            if(y>=32.*1.&&y<32.*2.){t = tt.y;}\n            if(y>=32.*2.&&y<32.*3.){t = tt.z;}\n            if(y>=32.*3.          ){t = tt.w;}\n            float y2 = frq*(y/zz-.5);\n            float a = float((t>>(int(y)&31))&1U)-.5;\n            float e = 1./exp(y2*y2);  su+=e;\n                  a*= e;\n                  y2*=3.;\n            co += cos(y2)*a;\n            si += sin(y2)*a;\n        }\n        float l = sqrt(si*si+co*co)/su;\n                vec4 msk = vec4(1,0,0,0);\n      //if((i%3)==0){msk = vec4(1,0,0,0);}\n        if((i%3)==1){msk = vec4(0,1,0,0);}\n        if((i%3)==2){msk = vec4(0,0,1,0);}\n        fragColor += l*msk;\n        frq *= 1.3; //2^(1/3)\n    }\n    fragColor *= 4.*(3./float(ww));\n    //if(fragCoord.x>iResolution.x*.5){fragColor = vec4(tt.x&1U);}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rz 120.  //size of each world in pixels\n#define sz  3.   //size of kernel across space\n#define tz  3    //size of kernel across time          must be <= 32\n#define nz  .02  //size of mouse click noise ball", "buffer_a_code": "uvec4 read(vec2 u, vec2 m)\n{\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(u+m),0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    uvec4 tt = read(u,vec2(0,0));\n    float ck = -floor((sz-1.)*.5);    //center the kernel\n    float ev = float(mod(sz,2.)==0.); //move and resize kernel when sz = even\n    uint o = 0U;                      //sum of all bits\n                          float n = (float(iFrame&1)-1.)*ev;\n    for(int   t=0 ; t<tz; ++t){ float m = n*(1.-float(t&1)); float s2 = sz-float(t&1)*ev; \n    for(float i=0.; i<s2; ++i){\n    for(float j=0.; j<s2; ++j){ uint r = read(u,vec2(i,j)+ck+m).x;\n                                o += (r>>t)&1U;\n    }}}\n\n    uint a = +16U*8U        *(16U*7U+12U)\n             +16U*8U*16U*8U *(1U<<8);      \n    o = ((tt.x)<<1U) | ((a>>(o&31U))&1U);\n    tt = uvec4(o,(tt.x>>31)|(tt.y<<1),\n                 (tt.y>>31)|(tt.z<<1),\n                 (tt.z>>31)|(tt.w<<1));\n    fragColor = uintBitsToFloat(tt);\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2  v = (u/iResolution.xy)-.5;\n        float r = fract(cos(dot(u,vec2(1.76543,iTime+9.)))*5467.5678)*11111.;\n              r*= step(dot(v,v),nz);\n        fragColor = vec4(r);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csB3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DsSGRD", "name": "Falling Stars Special", "author": "ArubikU", "description": "stars", "tags": ["stars"], "likes": 12, "viewed": 331, "published": 3, "date": "1667265401", "time_retrieved": "2024-07-30T16:23:33.427128", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define ROT -0.785398\n#define ZOOM .25\n#define STAR_SPEED 4.\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x * p.y);\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\n\nfloat DrawLine(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b);\n    float m = S(.0025, .00001, d);\n    float d2 = length(a-b);\n    m *= S(1., .5, d2) + S(.04, .03, abs(d2-.75));\n    return m;\n}\n\nfloat ShootingStar(vec2 uv) {    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float h = N21(id);\n    \n    float line = DrawLine(gv, vec2(0., h), vec2(.125, h));\n    float trail = S(.14, .0, gv.x);\n\t\n    return line * trail;\n}\n\nfloat rand(in vec2 st) {\n  vec2 r = fract(sin(st) * 2.7644437);\n  return fract(r.y * 276.44437 + r.x);\n}\n\nfloat particles(in vec2 st) {\n  float r = rand(floor(st));\n  return 0.01 + smoothstep(0.995, 1.0, r) * max(0.0, sin(r * 34433.0 + iTime));\n}\n\nconst vec3 BLUE = vec3(0.0, 0.1, 0.2);\n\n#define p(st) particles(st)\nvec3 avg(in vec2 st, in float a) {\n  vec2 A = vec2(0.0, a);\n  return BLUE * (p(st) + p(st + A) + p(st + A.yx) + p(st - A) + p(st - A.yx));\n}\n\nvec3 stars(in vec2 st) {\n  vec3 color = vec3(0.0);\n  for (float i = 8.0; i > 0.0; --i) color += mix(color, avg(st, i), 1.5);\n  return color + p(st);\n}\n\n#define scale 150.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime * STAR_SPEED;\n    vec2 rv1 = vec2(uv.x - t, uv.y + t);\n    rv1.x *= 1.1;\n    \n    float r = 3. * ROT;\n    float s = sin(r);\n    float c = cos(r);\n    mat2 rot = mat2(c, -s, s, c);\n    rv1 *= rot;\n    rv1 *= ZOOM * .9;\n    \n    vec2 rv2 = uv + t * 1.2;\n    rv2.x *= 1.1;\n    \n    r = ROT;\n    s = sin(r);\n    c = cos(r);\n    rot = mat2(c, -s, s, c);\n    rv2 *= rot;\n    rv2 *= ZOOM * 1.1;\n    \n    float star1 = ShootingStar(rv1);\n    float star2 = ShootingStar(rv2);\n\n    \n    vec3 col = vec3(clamp(star1+star2, 0., 1.));\n    fragColor = vec4(col,1.0);\n    \n    \n      vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n      st *= scale;\n\n    fragColor.rgb = fragColor.rgb + stars(st).rgb;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 116, 116, 212], [214, 214, 254, 254, 379], [382, 382, 422, 422, 585], [587, 587, 616, 616, 830], [832, 832, 856, 856, 936], [938, 938, 967, 967, 1078], [1148, 1148, 1182, 1182, 1288], [1290, 1290, 1314, 1314, 1440], [1463, 1463, 1520, 1520, 2310]], "test": "untested"}
