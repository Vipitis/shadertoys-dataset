{"id": "tlByzR", "name": "Head (show primitives)", "author": "teadrinker", "description": "Amazing modelling by tdhooper:   https://www.shadertoy.com/view/wlf3WX\nI just wanted to see the primitives, so I added animation into smin()\n", "tags": ["animation", "head"], "likes": 26, "viewed": 661, "published": 3, "date": "1593549808", "time_retrieved": "2024-07-30T20:58:19.944228", "image_code": "/*\n\nBy:   https://www.shadertoy.com/user/tdhooper\nFrom: https://www.shadertoy.com/view/wlf3WX\n\n\nLicense: Creative Commons Attribution-NonCommercial\nhttps://creativecommons.org/licenses/by-nc/4.0/\n\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    k *= 0.5 * sin(iTime) + 0.5;\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nbool isEye = false;\n\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    p.y -= .11;\n\n    vec3 pa = p;\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = pp;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = pp;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n    \n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // jaw\n\n    p = pp;\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = pp + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    // return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n\tisEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\n\nfloat sstep(float t) {\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\n}\n\nfloat map(vec3 p) {\n    \n    float scale = 1.;\n    float s = .2;\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\n    float rx = sin(iTime * .33) * .2;\n\n    if (iMouse.z > 0.) {\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\n        scale = 2.;\n    }\n    \n    pR(p.yz, rx);\n    pR(p.xz, ry);\n    \n    p /= scale;\n   \treturn mHead(p) * scale;\n}\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0005,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    vec3 col = vec3(.1);\n\n    for (int i = 0; i < 150; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dist = map(rayPosition);\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 5.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        vec3 albedo = isEye ? vec3(2) : vec3(1);\n        vec3 n = calcNormal(rayPosition);\n        vec3 lp = vec3(-.5,.5,.5);\n        float l = max(dot(lp, n), 0.);\n        vec3 ld = normalize(lp - rayPosition);\n        l += .02;\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\n        col = albedo * l;\n        col = pow(col, vec3(1./2.2));\n    }\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByzR.jpg", "access": "api", "license": "cc-by-4.0 OR cc-by-3.0", "functions": [[227, 227, 259, 259, 304], [306, 306, 333, 333, 363], [403, 403, 423, 423, 451], [453, 453, 473, 473, 511], [513, 513, 533, 533, 571], [573, 573, 593, 593, 621], [623, 623, 651, 651, 738], [740, 740, 764, 764, 826], [828, 828, 858, 858, 945], [948, 948, 985, 985, 1051], [1054, 1098, 1162, 1162, 1440], [1442, 1442, 1482, 1482, 1573], [1575, 1575, 1615, 1615, 1707], [1709, 1709, 1747, 1747, 1891], [1893, 1893, 1932, 1932, 1963], [1965, 1965, 2004, 2004, 2075], [2077, 2077, 2116, 2116, 2187], [2190, 2190, 2219, 2219, 2286], [2288, 2288, 2317, 2317, 2384], [2408, 2408, 2429, 2429, 11609], [11611, 11611, 11633, 11633, 11676], [11678, 11678, 11697, 11697, 12129], [12159, 12159, 12185, 12185, 12444], [12446, 12446, 12503, 12503, 13513]], "test": "untested"}
{"id": "wtSyRR", "name": "Import / Export shader with URL", "author": "ttg", "description": "Some simple javascript allows exporting and importing any shader source with a representation embedded in the URL.\n\nSee [url]https://terra-infinitum.com/shadertoy-tricks/export-import-source-url/[/url] for links that may be easily bookmarked.", "tags": ["shadertoy", "fork", "url", "js"], "likes": 12, "viewed": 5439, "published": 3, "date": "1593549459", "time_retrieved": "2024-07-30T20:58:20.835844", "image_code": "                                                                                                                                                                                                                                                                #define XXX /*\n// See https://terra-infinitum.com/shadertoy-tricks/export-import-source-url/\n\n// A shader source may be embedded in a URL like this (example for a simple shader):\n\n// https://www.shadertoy.com/new#Shader=%7B%22ver%22%3A%220.1%22%2C%22renderpass%22%3A%5B%7B%22outputs%22%3A%5B%7B%22channel%22%3A0%2C%22id%22%3A%224dfGRr%22%7D%5D%2C%22inputs%22%3A%5B%5D%2C%22code%22%3A%22%23define%20mainImage(o%2Cu)%20o%2B%3Dsin(u.xyxy%2F9.%2BiTime)%22%2C%22name%22%3A%22Image%22%2C%22description%22%3A%22%22%2C%22type%22%3A%22image%22%7D%5D%2C%22flags%22%3A%7B%22mFlagVR%22%3Afalse%2C%22mFlagWebcam%22%3Afalse%2C%22mFlagSoundInput%22%3Afalse%2C%22mFlagSoundOutput%22%3Afalse%2C%22mFlagKeyboard%22%3Afalse%2C%22mFlagMultipass%22%3Afalse%2C%22mFlagMusicStream%22%3Afalse%7D%2C%22info%22%3A%7B%22id%22%3A%22-1%22%2C%22date%22%3A%221358124981%22%2C%22viewed%22%3A0%2C%22name%22%3A%22%22%2C%22username%22%3A%22None%22%2C%22description%22%3A%22%22%2C%22likes%22%3A0%2C%22hasliked%22%3A0%2C%22tags%22%3A%5B%5D%2C%22published%22%3A0%7D%7D\n\n// These URLs may be loaded into any Shadertoy tab with this javascript:\n(function(){var j=JSON.parse(decodeURIComponent(window.location.hash.slice(1).split('&').filter(\nr=>r.startsWith(\"Shader=\"))[0].slice(7)));j.info=gShaderToy.mInfo;gShaderToy.newScriptJSON(j);}())\n\n// The URL of a shader's source may be exported with this javascript:\n(function(){var j=gShaderToy.exportToJSON();j.renderpass[0].code=\n\"// copied from shadertoy.com/view/\"+j.info.id+\" by \"+j.info.username+\"\\n\\n\"+j.renderpass[0].code;\ndoAlert({mX:420,mY:300},{mX:800,mY:600},\"Source as URL\",\"<pre>\"+htmlEntities(\n\"www.shadertoy.com/new\\n#Shader=\"+encodeURIComponent(JSON.stringify(j)))+\"</pre>\");}())\n\n// If you'd like to overwrite an existing shader, copy only the resulting text beginning with \"#\"\n// and append that to your target tab's URL.\n\n*/\n\nconst uint[] line1 = STRING32(27, E,x,p,o,r,t,_,S,h,a,d,e,r,_,s,o,u,r,c,e,_,t,o,_,U,R,L,_,_,_,_,_);\nconst uint[] line2 = STRING32(29, I,m,p,o,r,t,_,S,h,a,d,e,r,_,s,o,u,r,c,e,_,f,r,o,m,_,U,R,L,_,_,_);\nconst uint[] line3 = STRING32(32, lp,B,o,o,k,m,a,r,k,a,b,l,e,_,j,a,v,a,s,c,r,i,p,t,_,m,a,c,r,o,s,rp);\nconst uint[] line4 = STRING32(20, E,a,s,i,l,y,_,f,o,r,k,_,s,h,a,d,e,r,s,em,_,_,_,_,_,_,_,_,_,_,_,_);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y=1.-uv.y; // Left-handed coordinate system is most natural for Latin text layout\n    fragColor = vec4(vec3(0.),1.0);\n    vec2 grid = vec2(34,8);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,1.0), line1);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,2.5), line2);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,4.0), line3);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,5.5), line4);\n    \n}\n//", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2512, 2512, 2569, 2569, 3033]], "test": "untested"}
{"id": "wlByRR", "name": "Logarithmic Moebius Transform 9", "author": "FabriceNeyret2", "description": "How to get a perfect fit of parameterization along inter-poles arc ?\nvariant of [url]https://shadertoy.com/view/WtlyWs[/url]", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 7, "viewed": 392, "published": 3, "date": "1593547587", "time_retrieved": "2024-07-30T20:58:21.857620", "image_code": "// variant of https://shadertoy.com/view/WtlyWs\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I,\n         U = (u - .5*R) / R.y,                                // normalized coordinates\n\n         z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n    \n#if 1              \n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.283 * vec2(6, 1);  // n  \n  //U *= vec2(10,22)/2.73; // /(.5+iMouse.x/R.x);\n    U *= vec2(11./3., 2./sqrt(3.)*7.); // *1,4,7 ok      // thanks Shane !\n#else                                                    // variant adapted form mla's version\n    U =  vec2( log(length(U+=.5)) , atan(U.y, U.x) ) / 3.1416;\n    U.x += iTime/8.;\n    I = vec2( 7. , 3./sqrt(3.) );\n    // my: (PI/2,  3, -PI/2, .5) * D(3.66,8) = ( 5.75, 11,  -12.6,  4 ) \n    U = mat2(I,-I.y,I) * U;          // here:  ( 7,   1.73, -1.73,  7 )\n    U = U*sqrt(3.)-.5;\n#endif\n    \n    U *= mat2(1,0,.5,sqrt(3.)/2.);                            // triangular mesh\n    z = fwidth(U);\n    I = floor(U); U = fract(U); \n    float s = float(U.x-U.y>0.),                              // parallelogram = 2 triangles\n         id = 6.28*( I.y/6.+I.x/11.)*2.+s*91.;\n    float v = 1.-2.*abs(U.x-U.y);\n    U = abs(U*2.-1.);  v = max(v,max(U.x,U.y));               // dist to border\n    O =   smoothstep(.7,-.7, (v-.95)/( abs(z.x-z.y)>1.?.1:z.y*4.))  // draw AA tiles\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)  ) );         // color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlByRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 1600]], "test": "untested"}
{"id": "wlSyRR", "name": "Double Triangle tiling [Day 193]", "author": "jeyko", "description": "Derp", "tags": ["triangle", "tiling", "mdtmjvm"], "likes": 22, "viewed": 406, "published": 3, "date": "1593543353", "time_retrieved": "2024-07-30T20:58:22.604622", "image_code": "\n// Mathematically correct with no number-crunching! \n// https://tilings.math.uni-bielefeld.de/substitution/double-triangle/\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\nfloat sdEquilateralTriangle(  vec2 p, float r ){   \n    r = r*1./3.;\n\tp.y -= r;\n    p.y += r*1.5;\n    float d = dot(vec2(abs(p.x),p.y) - -normalize(vec2(0.,1)*rot(tau/3.))*(r), -normalize(vec2(0.,1)*rot(tau/3.)));\n    d = max(d,p.y - r*2.);\n    d = max(d,-p.y - r);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0);\n    \n    float iters = 6.;\n    \n    float d = 10e5;\n    \n    // mafs\n    float s = 1.;\n\n    \n    \n\n    \n    uv += vec2(sin(iTime/2.6),cos(iTime/2.))*0.4;    \n    uv *= .03;\n    uv.y -= 0.1;\n    uv.x -= 0.2;\n\n    \n    float id = 0.;\n    vec2 p = uv;\n    float sc = 1.;\n    \n    float palvar = 1.;\n    \n    for(float i = 0.; i < iters; i++){\n        \n        \n        float median = s;\n        float outer = median*2./sqrt(3.);\n\n        vec2 pbtrans = - vec2(0.,sc*median/4.);\n        vec2 pctrans = + vec2(0.,sc*median/4.);\n        vec2 pdtrans = + vec2(0. - sc*outer*.125,sc*median/8.);\n        vec2 petrans = + vec2(0. - sc*outer*.25 , sc*median/(2.+2./3.));\n        vec2 pftrans = + vec2(0. - sc*outer*.25, sc*median/(8.));\n        vec2 pgtrans = + vec2(0. - sc*outer*0.375, sc*median/(2.+2./3.));\n\n\n        float tria = sdEquilateralTriangle( p, s*sc*1.);\n        float trib = sdEquilateralTriangle( p + pbtrans, s*sc/2.);\n        float tric = sdEquilateralTriangle( p + pctrans, s*sc/2.);\n\n        p.x = abs(p.x);\n\n        float trid = sdEquilateralTriangle((p + pdtrans )* rot(1.*pi) , s*sc/4.);\n        float trie = sdEquilateralTriangle((p + petrans )* rot(1.*pi) , s*sc/4.);\n\n        float trif = sdEquilateralTriangle((p + pftrans ), s*sc/4.);\n        float trig = sdEquilateralTriangle((p + pgtrans ) , s*sc/4.);\n\n\n        d = min(d,abs(tria));\n\n        d = min(d,abs(trib));\n        d = min(d,abs(tric));\n        d = min(d,abs(trid));\n        d = min(d,abs(trie));\n        d = min(d,abs(trif));\n        d = min(d,abs(trig));\n\n        if(tria < 0.){\n            if( trib < 0.){\n                p += pbtrans;\n                palvar += 0.4;\n            } else if(tric < 0.){\n                p += pctrans;\n                palvar += 1.4;\n            } else if(trid < 0.){\n                p += pdtrans;\n                palvar += .4;\n            } else if(trie < 0.){\n                p += petrans;\n                palvar += 1.4;\n            } else if(trif < 0.){\n                p += pftrans;\n                palvar += .4;\n            } else if(trig < 0.){\n                p += pgtrans;\n                palvar += 2.4;\n            }\n            if(trid < 0. || trie < 0.){\n                p *= rot(pi);\n            }\n            if(trib < 0. || tric < 0. ){\n                sc *= 0.5;\n            } else {\n                sc *= 0.25;\n            }\n\n        } else {\n        \tbreak;\n        }\n            \n            \n        \n    }\n    \n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    col = mix(col,pal(0.5,0.56,vec3(3.,0.7,0.2),3.4, palvar + iTime + uv.x*2. + uv.y*2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    //col = mix(col,pal(0.5,0.56,vec3(2.,0.7,0.2),1., palvar + iTime + uv.x*2. + uv.y*2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    \n    d = abs(d);\n    \n    float w = 1.1;\n    col = mix(col,vec3(0.01),smoothstep(dFdx(uv.x)*w,dFdx(uv.x)*(w-1.)*1.,d));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 267, 267, 500], [502, 502, 559, 559, 3610]], "test": "untested"}
{"id": "WlSczz", "name": "Mandelbrot disco", "author": "Ausfragezeichen", "description": "My fun first try on implementing z = z² + c", "tags": ["fractal"], "likes": 1, "viewed": 263, "published": 3, "date": "1593537992", "time_retrieved": "2024-07-30T20:58:23.422436", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 3.; //zoom\n    \n    vec2 c = uv;\n    \n    float i2 = 0.;\n    \n    float maxI = 25. + iTime;\n    \n    for( float i = 0.; i < maxI; i++) //iterations\n    {\n        //complex multiplication: c.x = real, c.y = imaginary;\n        float a = c.x * c.x - c.y * c.y;\n        float b = 2. * c.x * c.y;\n        c = vec2( a, b) + uv;\n        \n        //first time it is sure to escape (real | imaginary > 2)\n        if( i2 == 0. && (abs(c.x) > 2. || abs(c.y) > 2.))\n        {\n            i2 = i;\n        }\n    }\n    \n    //red = real, green = imaginary\n    vec3 col = vec3(abs(c.x), abs(c.y), 0.);\n    \n    if( abs(c.x) > 2. || abs(c.y) > 2.)\n    {\n        col = vec3(0.);\n    }\n\t\n    //blue = iterations\n    col += vec3(0.,0.,i2/maxI);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 916]], "test": "untested"}
{"id": "3lSczz", "name": "Parabola Segment - distance 2D", "author": "iq", "description": "The exact distance to a parabola segment given its height and width, which involves solving a cubic. Just an adaptation of [url]https://www.shadertoy.com/view/ws3GD7[/url]", "tags": ["2d", "sdf", "distance", "parabola"], "likes": 20, "viewed": 2965, "published": 3, "date": "1593535638", "time_retrieved": "2024-07-30T20:58:24.370900", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The exact distance to a parabola segment given its height\n// and width, which involves solving a cubic. Just an\n// adaptation of https://www.shadertoy.com/view/ws3GD7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n\nfloat sdParabola( in vec2 pos, in float wi, in float he )\n{\n    pos.x = abs(pos.x);\n\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p);\n    }\n    else        // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n    }\n    \n    x = min(x,wi);\n    \n    return length(pos-vec2(x,he-x*x/ik)) * \n           sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n\tfloat w = 0.7+0.69*sin(iTime*0.61+0.0);\n    float h = 0.4+0.35*sin(iTime*0.53+2.0);\n    \n    // sdf\n    float d = sdParabola( p, w, h );\n    \n    float ra = 0.2*(0.5+0.5*cos(1.4*iTime));\n    d = (cos(0.5*iTime)>0.0) ? abs(d) - ra : d;\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.0,1.1,1.2);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdParabola(m, w, h );\n    d = (cos(0.5*iTime)>0.0) ? abs(d) - ra : d;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // width and height\n    d = length(p-vec2(0.0,h))-0.02;\n    d = min(d, length(p-vec2(w,0.0))-0.02);\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0,0.01,d) );\n    \n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSczz.jpg", "access": "api", "license": "mit", "functions": [[1375, 1375, 1434, 1434, 2063], [2065, 2065, 2120, 2120, 3246]], "test": "untested"}
{"id": "3lSyzz", "name": "The colours unseen", "author": "Leria", "description": "A bit of color to feel alright ;-)\nChilling shader, you can rotate it, play with it and enable or not the the high quality with HIGH_DEF", "tags": ["noise", "transparency", "sound", "music", "color", "nebulae", "colours"], "likes": 13, "viewed": 624, "published": 3, "date": "1593532862", "time_retrieved": "2024-07-30T20:58:25.544762", "image_code": "//A bit laggy in high quality : Nvidia 920M (GPU for laptop) 16 fps, sometimes 5 || Low quality 60 fps\n//Free for any use, just let my name appears\n//Song : colour (amen) by Jasmine Thompson\n\n//Exercise : You can upgrade the code to sync the sound with the moving volume, it can slow the GPU performances \n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> IF in HIGH_DEF mode, you can :\n\t//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t1\n\n//Stretch or not the colored volume\n#define STRETCH\t\t\t0\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\n//taken from https://www.shadertoy.com/view/XsX3zB\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1., pow( 1.4, -3. ) );\n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    #if STRETCH\n   \tp *= stretching;\n    #endif\n    f = noise(p+iTime/10.); p = p*2.;\n    \n    vec3 s = 2./pow(stretching,vec3(.333));\n    \n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    #if STRETCH\n   \tp *= stretching;\n    #endif\n    f = noise(p+iTime/10.); p = p*2.;\n    \n    vec3 s = 2./pow(stretching,vec3(.333));\n    \n    #if HIGH_DEF\n    f *=  2.*noise( p ); p = p*2.;\n    f *=  4.*noise( p ); p = p*2.;\n    f *=  8.*noise( p ); p = p*2.;\n    f *= 16.*noise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tm = Matter(pos, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), .12, RADIUS, RADIUS/8., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 12), m.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    \n    int s = 0;\n    \n    for(s; s < 140; s++)\n    {       \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(d > 0.)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }        \t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float n = abs(fbm(p/4.));\n;\t\n            //sort of \"iso-value\".1*max(0., abs(sin(20.*fbm(p/4.))  )); //iso valeur\n            //complement = n = max(0., 1.-10.*abs(fbm(p/4.)))\n\n            \n            float mask = smoothstep(0., \n                                    1.*RADIUS,\n                                    (RADIUS-length(center))- 128.*n) ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            //How colors (rgb) are absorbed at the point p in the current iteration\n            //k is the step size\n            //4*cos(p.) is a property that defines the quantity of color which is absorbed\n            //cos(p.) is to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 4.* f(p.x) * dens, \n                      \tk * 4.* f(p.y) * dens,\n              \t      \tk * 4.* f(p.z) * dens);    \n            \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = exp(-t_acc);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [{"id": 23277, "src": "https://soundcloud.com/jasmine-thompson/colour-amen?in=jasmine-thompson/sets/colour", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[832, 905, 927, 927, 1100], [1754, 1754, 1811, 1811, 1980], [1982, 2056, 2078, 2331, 3248], [3250, 3250, 3276, 3276, 4101], [4212, 4212, 4237, 4250, 4594], [4596, 4596, 4621, 4634, 4966], [4968, 4968, 4987, 4987, 5080], [5082, 5101, 5177, 5177, 5224], [5226, 5226, 5258, 5258, 5278], [5280, 5280, 5314, 5314, 5336], [5438, 5438, 5462, 5462, 5622], [5624, 5624, 5648, 5648, 5733], [5735, 5764, 5792, 5792, 5962], [5964, 5986, 6032, 6032, 6655], [6705, 6705, 6746, 6746, 6782], [6784, 6784, 6921, 6921, 6952], [6954, 6954, 6997, 6997, 7037], [7039, 7039, 7063, 7063, 7129], [7131, 7131, 7171, 7171, 7475], [7477, 7477, 7501, 7501, 7564], [7566, 7566, 7613, 7613, 7665], [7667, 7667, 7750, 7750, 7889], [7892, 7892, 7945, 7945, 8302], [8305, 8305, 8357, 8357, 10985], [10988, 10988, 11045, 11045, 11653]], "test": "untested"}
{"id": "WtSczR", "name": "Equithirds tiling", "author": "jeyko", "description": "Tried making this tiling. Then I remembered I don't know trigonometry haha.", "tags": ["mdtmjvm"], "likes": 15, "viewed": 412, "published": 3, "date": "1593521189", "time_retrieved": "2024-07-30T20:58:26.359583", "image_code": "// This is a no-math, all number crunched, Equithirds tiling:\n// https://tilings.math.uni-bielefeld.de/substitution/equithirds/\n\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    float iters = 9.;\n    \n    float d = 10e5;\n    \n    // mafs\n    vec2 s = vec2(0.173,0.1);\n\n    \n    uv.y -= s.y*0.35;\n\n    uv += vec2(sin(iTime),cos(iTime))*0.1;    \n    uv *= 0.06;\n\n    \n    float id = 0.;\n    vec2 p = uv;\n    float sc = 1.;\n    \n    float id0cnt = 0.;\n    float id1cnt = 0.;\n    float palcnt = 0.;\n    \n    for(float i = 0.; i < iters; i++){\n        \n        if( id == 0. ){\n        \n        \tmat2 rb = rot(tau/3.*1.);\n        \tmat2 rc = rot(tau/3.*2.); \n        \n            float szsc = 1.*sc;\n            \n            float da = sdTriangleIsosceles( p   , s*szsc);\n            float db = sdTriangleIsosceles( p*rb, s*szsc);\n            float dc = sdTriangleIsosceles( p*rc, s*szsc);\n\n            if( da < 0. ){\n                palcnt++;\n            } else if( db < 0. ){\n\t\t\t\tp *= rb;\n                palcnt += 1.5;\n            } else if( dc < 0. ){\n                palcnt += 2.5;\n\t\t\t\tp *= rc;\n            } \n            p.y -= 0.5*s.y*szsc;\n            \n            d = min(d,abs(da));\n            d = min(d,abs(db));\n            d = min(d,abs(dc));\n            id = 1.;\n            \n            id0cnt ++;\n        \n        } else if (id == 1.) {\n            float ramt = tau/5.*2.0835;\n            mat2 ra = rot(-ramt);\n            mat2 rb = rot(ramt);\n            \n            vec2 transa = vec2(-0.075,0.0144);\n            vec2 transb = vec2(-transa.x,transa.y);\n            \n            float szsc = sc*0.579;\n            \n            vec2 pa = (p*ra + transa*sc );\n            vec2 pb = (p*rb + transb*sc );\n            \n            \n            float da = sdTriangleIsosceles( pa, s*szsc);\n            float db = sdTriangleIsosceles( pb, s*szsc);\n            \n            \n            if(da < 0.){\n                p = p*ra + transa*sc*vec2(1.,-1.);\n                sc = szsc;\n                id = 1.;\n                palcnt += 1.5;\n            } else if(db < 0.){\n                p = p*rb + transb*sc*vec2(1.,-1.);\n                col += 0.03;\n                sc = szsc;\n                id = 1.;\n                palcnt += 1.;\n            } else {\n                p.y -= s.y*szsc/3.5;\n                \n                sc *= 0.335;\n                id = 0.;\n                palcnt += .5;\n            }\n            \n            \n            id1cnt++;\n        \td = min(d,abs(da));\n        \td = min(d,abs(db));\n        }\n    }\n    \n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    col = mix(col,pal(0.5,0.5,vec3(2.,0.7,0.2),1., id1cnt*7. +  id0cnt*5. + palcnt*7. + 4. + iTime/2. + uv.x*1. )/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    d = abs(d);\n    \n    float w = 0.00006;\n    \n    col = mix(col,vec3(0.01),smoothstep(dFdx(uv.x) + w,w,d));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 273, 273, 581], [583, 583, 640, 640, 3495]], "test": "untested"}
{"id": "WtByzR", "name": "Sinusoids Wave 2D - variant2", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/3lScRR[/url]\n\n", "tags": ["2tweets", "trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 2, "viewed": 294, "published": 3, "date": "1593520739", "time_retrieved": "2024-07-30T20:58:27.199337", "image_code": "// variant of https://shadertoy.com/view/3lScRR\n// variant of https://shadertoy.com/view/ttlcDs\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y, C,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    float d, s=0.;\n        for (int k=0; k<25; k++)\n            C = U - round((U+vec2(k%5-2,k/5-2))*.2) / .2,\n            V = C * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n            d = max(0.,1.-.05*dot(C,C)), d*=d*d*d,\n            O += texture(iChannel0,.5+V) * d , s += d;\n    O *= smoothstep( 1.,-1., U.y -37.) / s;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtByzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 133, 133, 564]], "test": "untested"}
{"id": "3lScRR", "name": "Sinusoids Wave 2D - variant", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/ttlcDs[/url]\nantialiasing, undistorted dots, golfing 643 chars [url]https://shadertoy.com/view/wtlyDs[/url]\n", "tags": ["trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 8, "viewed": 337, "published": 3, "date": "1593519281", "time_retrieved": "2024-07-30T20:58:27.955317", "image_code": "// variant of https://shadertoy.com/view/ttlcDs\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y, d, C,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    for (int k=0; k<25; k++)\n        C = round((U+vec2(k%5-2,k/5-2))*.2),\n        V = ( U- C/.2 )\n           * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n        d = max(V-V,1.-.05*dot(U- C/.2,U- C/.2)),\n        O += sin( 36.*length(V) -iTime*0.+C.x) * (d*d*d*d).x *.5+.5;\n    O *= smoothstep(1.,-1.,U.y -37.)/25.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lScRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 511]], "test": "untested"}
{"id": "ttlcDs", "name": "Sinusoids Wave 2D golf+AA+undist", "author": "FabriceNeyret2", "description": "antialiasing, undistorted dots, golfing 643 chars [url]https://shadertoy.com/view/wtlyDs[/url]\n", "tags": ["2tweets", "trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 5, "viewed": 385, "published": 3, "date": "1593505015", "time_retrieved": "2024-07-30T20:58:28.943674", "image_code": "// antialiasing, undistorted dots, golfing https://shadertoy.com/view/wtlyDs\n\n\n// 199 chars -2 by Fab -4 by coyote\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r = iResolution.yy*.1,\n         U = u*5. + u.y* cos( iTime + u.x/r*.56 + 11.*O++.xw );\n    O -= .1*(  min( 35.5*r - U , 5. )\n             + min(5.*length( inverse(mat2(dFdx(U),dFdy(U))) * (U-round(U/r)*r) )\n                   -r*.2 , 5.)  ).y;\n}\n/*\n\n\n// 205 chars  -6 by coyote  -1 by Fab\n\n#define mainImage(O,u)                                                   \\\n    vec2 r = iResolution.yy*.1, U = u/r;                                 \\\n    U = U*5. + U.y* cos( iTime + U.x*.56 + 11.*O.xw );                   \\\n    O -=   min( (35.5-U.y)*r.x*.1, .5 )                                  \\\n         + min(.5*length((U-round(U)) * inverse(transpose(mat2(dFdx(U),dFdy(U))))) \\\n                -r.x*.02, .5) - 1.                                      /*\n\n\n\n\n\n// 212 chars  -9 by Fabrice\n\n#define mainImage(O,u)                                                    \\\n    vec2 R = iResolution.xy*.1, U = u/R.y;                                \\\n    U = U*5. + U.y* cos( iTime + U.x*.56 + 11.*O.xw );                    \\\n    U = max( vec4( (U-35.5)*R/5.,                                         \\\n                    R/25. - length( ( U - round(U) )                      \\\n                                   * inverse(transpose(mat2(dFdx(U),dFdy(U)) )) ) \\\n                 )*.5+.5 , 0. ).yw;                                       \\\n    O += U.x+U.y                                                         /*\n\n\n\n\n\n\n// --- 221 chars -7 by iapafoto -1 by Fab\n\n#define S(v) smoothstep(-1.,1., v).y//\n#define mainImage(O,u)                                          \\\n    vec2 R = iResolution.xy*.1, U = u/R.y;                      \\\n    U = U*5. + U.y* cos( iTime + U.x*.56 + vec2(0,11) );        \\\n    O += S( (U-35.5)*R/5. )                                     \\\n      +  S( R/25. - length( ( U - round(U) )                    \\\n                           * inverse(transpose(mat2(dFdx(U),dFdy(U)) )) ) )  /*\n//          same length:   * inverse(mat2(vec4(dFdx(U),dFdy(U)).xzyw )) ) )  /*\n\n\n\n\n\n// --- 229 chars\n\n#define S(v) smoothstep(-1.,1., v)                               //\n#define mainImage(O,u)                                            \\\n    vec2 R = iResolution.xy, U = u/R.y;                           \\\n    U = U*50. + U.y*10.* cos( iTime + U.x*5.6+vec2(0,11) );       \\\n    O += S( (U.y - 35.5)*R.y/50. )                                \\\n      +  S( R.y/250. - length(  ( U - round(U) )                  \\\n                               * inverse(transpose(mat2(dFdx(U),dFdy(U)))) ) ) /*\n\n\n\n\n\n// --- +21 ch: variant with analytical derivatives:\n\n#define S(v) smoothstep(-1.,1., v)                               //\n#define mainImage(O,u)                                            \\\n    vec2 R = iResolution.xy, V = u/R.y,                           \\\n         C = 10.*cos( iTime + V.x*5.6+vec2(0,11) ),               \\\n    U = V*50. + V.y*C;                                            \\\n    O += S( (U.y - 35.5)*R.y/50. )                                \\\n      +  S( R.y/250. - length(  ( U - round(U) )                  \\\n                               * inverse(mat2( 50.-V.y*5.6*C.y, C.x, V.y*5.6*C.x, 50.+C.y )  / R.y) ) ) /*\n               // is: mat2( 5.+C.y, -C.x, -.56*V.y*C.x, 5.-V.y*.56*C.y )  * R.y/(25.+5.*C.y-.56*V.y*(1.+5.*C.y)))  )\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 152, 152, 407]], "test": "untested"}
{"id": "ttsyDs", "name": "test 111", "author": "indere", "description": "test111", "tags": ["test111"], "likes": 2, "viewed": 242, "published": 3, "date": "1593499954", "time_retrieved": "2024-07-30T20:58:29.679706", "image_code": "float trunct(float x, float num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\n\nfloat randomNoise(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat myRandomColor(vec2 uv, float scale){\n\treturn fract(sin(dot(floor(uv * scale), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random1D(float p){\n\treturn fract(sin(p) * 100000.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float uv_color =  myRandomColor(uv.yy + trunct(iTime, 4.0), 4.0);\n    \n    //try 1.0 and 2.0\n    // 1.0 only time Related\n    // 2.0 both time and uv coord Related\n    \n    //1.0\n    //float uv_offset = random1D(iTime * 0.01) * 0.1;\n    //2.0\n    float uv_offset = trunct(iTime, 24.0 * uv_color) * 6.;\n    \n    //生成随机非均匀宽度线条\n    float blockLine_random = 0.5 * myRandomColor(uv.yy + uv_offset, 6.0);\n    blockLine_random += 0.5 * myRandomColor(uv.yy + uv_offset, 10.0);\n    blockLine_random = blockLine_random * 2. - 1.0;\n    \n    fragColor = vec4(vec3(blockLine_random), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 90], [92, 92, 120, 120, 190], [192, 192, 234, 234, 316], [318, 318, 342, 342, 378], [380, 380, 437, 487, 1134]], "test": "untested"}
{"id": "tllyDs", "name": "Blue Warping Waves", "author": "jackwitherell", "description": "Combining Tiling, sin SDF on one axis, gradients, wave scaling, color filter", "tags": ["webcam", "skooma"], "likes": 2, "viewed": 457, "published": 3, "date": "1593496027", "time_retrieved": "2024-07-30T20:58:30.469594", "image_code": "// Cheated Noise: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Stole some Pi: https://gist.github.com/patriciogonzalezvivo/986341af1560138dde52\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= vec2(sin(uv.x+iTime)+3.0);\n    vec4 col;\n    float pscale = 6.0;\n    if((mod((fragCoord.x+(15.0*sin((fragCoord.y/18.0)+(iTime/2.0)*18.0)))/pscale, 8.0)<1.0)||(mod(fragCoord.y/pscale, 8.0)<1.0)){\n        col = vec4(uv.y,0.3,1.0,1.0);\n    }\n    else{\n        float lights=cnoise(uv+iTime*0.5);\n        col = vec4(lights, 0.5, 1.0, 1.0);\n    }\n    col*=texture(iChannel0,mod(uv,1.0))*vec4(1.7,1.7,1.7,1.0);\n\tfragColor = col;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 241, 241, 277], [278, 278, 299, 299, 336], [338, 338, 359, 359, 1436], [1439, 1439, 1496, 1546, 2020]], "test": "untested"}
{"id": "wtlyDs", "name": "Sinusoids Wave 2D", "author": "changjiu", "description": "Sinusoids Wave; 2D ocean", "tags": ["sinusoidswave"], "likes": 3, "viewed": 361, "published": 3, "date": "1593495598", "time_retrieved": "2024-07-30T20:58:31.207620", "image_code": "/*\ncorrect the dot shape to circle;\nantialias;\nsimplify;\nby FabriceNeyret2;\n*/\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R.y, P;\n  \n    float c = length( U - vec2(.9,.73) ) - 0.1435;\n    \n    U = U*50. + U.y*10.* cos( iTime + U.x*5.6+vec2(0,11) );\n\n    P =   ( U - round(U) )                                     // loc coords % dot center\n        * inverse(transpose(mat2(dFdx(U),dFdy(U)))) *50./R.y;  // in screen coords\n\n    O = abs(U.x-45.) < .5 ? vec4(0,1 ,0 ,1) : vec4(0,.2,.2,1); // dots color\n    O = mix( O, vec4(0,.2,.9,0),  smoothstep(0.,50./R.y, length(P) - .2 )); // draw water & dots\n\n    O *= smoothstep( 200./R.y, 0., U.y - 35.5 );               // draw surface\n    O = mix( vec4(1,0,0,0), O, smoothstep(0., 1.5/R.y, abs(c)-.0015) ); // draw circle\n}\n\n/*old version \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvOld = vec2(uv.x,uv.y);\n    uv *= 50.0;\n    \n    float time0 = iTime + fragCoord.x/iResolution.x*10.0;\n    uv += uvOld.y*10.0*vec2(cos(time0), sin(time0));\n    \n    float top = 35.5;\n    float bottom = 15.5;\n\n    float x = uv.x;\n    float y = uv.y;\n\n    vec3 col = vec3(0,0,0);;\n    \n    float x0 = x-round(x);\n    float y0 = y-round(y);\n    vec2 pos0 = vec2(x0,y0);\n    \n    vec2 center = vec2(0,0);\n\n    \n    \n    if(y<top){\n        col = vec3(0.,0.2,0.9);\n        \n    \tif(distance(pos0,center)<0.2){\n            \n        \tcol = vec3(0.0,0.2,0.2);\n            \n            if(uv.x>44.5 && uv.x<45.5){\n                col = vec3(0.,1.0,0.);\n            }\n    \t}\n    }\n    \n   \n\tvec2 center1 = vec2(0.9,0.73);\n    float dis = distance(uvOld,center1);\n    if(dis<0.145 && dis>0.142){\n    \tcol = vec3(1.,0.,0.);\n    }\n    \n\n\n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 117, 117, 806]], "test": "untested"}
{"id": "tllcWs", "name": "cloth wave", "author": "changjiu", "description": "wave", "tags": ["wave"], "likes": 1, "viewed": 344, "published": 3, "date": "1593487639", "time_retrieved": "2024-07-30T20:58:31.959610", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvOld = vec2(uv.x,uv.y);\n    uv *= 50.0;\n    \n    float time0 = iTime + fragCoord.x/iResolution.x*10.0;\n    uv += 5.0*vec2(cos(time0), sin(time0));\n    \n    float top = 35.5;\n    float bottom = 15.5;\n\n    float x = uv.x;\n    float y = uv.y;\n\n    vec3 col = vec3(0,0,0);;\n    \n    float x0 = x-round(x);\n    float y0 = y-round(y);\n    vec2 pos0 = vec2(x0,y0);\n    \n    vec2 center = vec2(0,0);\n\n    \n    if(y<top && y>bottom){\n    \tif(distance(pos0,center)<0.2){\n            \n        \tcol = vec3(uvOld.x,uvOld.y,1.0);\n    \t}\n    }\n    \n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 676]], "test": "untested"}
{"id": "wlXcRj", "name": "TV glitch", "author": "changjiu", "description": "TV glitch", "tags": ["glitch"], "likes": 1, "viewed": 299, "published": 3, "date": "1593483652", "time_retrieved": "2024-07-30T20:58:32.698634", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\t\n\tfloat amount = 0.08;\n\tfloat angle = 0.02;\n\tfloat seed = 0.02;\n\tfloat seed_x = 0.02;\n\tfloat seed_y = 0.02;\n\tfloat distortion_x = 0.5;\n\tfloat distortion_y = 0.6;\n\tfloat col_s = 0.05;\n\n\t\t\t\tvec2 p = uv;\n\t\t\t\tfloat xs = floor(gl_FragCoord.x / 0.5);\n\t\t\t\tfloat ys = floor(gl_FragCoord.y / 0.5);\n\t\t\t\tvec4 normal = texture (iChannel1, p*seed*seed);\n\t\t\t\t//vec4 normal = vec4(0.5,0.5,0.5,0.5);\n\t\t\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\n\t\t\t\t\tif(seed_x>0.){\n\t\t\t\t\t\tp.y = 1. - (p.y + distortion_y);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.y = distortion_y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\n\t\t\t\t\tif(seed_y>0.){\n\t\t\t\t\t\tp.x=distortion_x;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.x = 1. - (p.x + distortion_x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.x+=normal.x*seed_x*(seed/5.);\n\t\t\t\tp.y+=normal.y*seed_y*(seed/5.);\n\t\t\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));\n\t\t\t\tvec4 cr = texture(iChannel0, p + offset);\n\t\t\t\tvec4 cga = texture(iChannel0, p);\n\t\t\t\tvec4 cb = texture(iChannel0, p - offset);\n\t\t\t\tfragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\t\t\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\n\t\t\t\tfragColor = fragColor+ snow;\n\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [95, 95, 152, 202, 1482]], "test": "untested"}
{"id": "wlsyDl", "name": "Generative Vasarely, Permutation", "author": "ciphered", "description": "A generative recreation of the work Untitled from Permutations, 1968, Victor Vasarely.\nMotion was inspired by the work of Jadarikin.\nMore infos on the top of the shader", "tags": ["vasarely"], "likes": 2, "viewed": 275, "published": 3, "date": "1593477352", "time_retrieved": "2024-07-30T20:58:33.451621", "image_code": "//\n// A generative recreation and rework of the original piece Untitled from Permutations, 1968, Vasarely\n// From its series Permutations\n// ref: \n// https://storage.gra.cloud.ovh.net/v1/AUTH_10e1a9235c63431c95e5b84a247830db/prod/artwork/477670_1_m.jpg\n//\n// This is also inspired by the great work of Jadarikin \n// https://twitter.com/jagarikin\n//\n// In some his work, Jadarikin creates the illusion of a motion by shifting a gradient \n// over time. The brain gets tricked in thinking there is a motion due to how the colors move.\n// This piece is a tribute to both Vasarely and Jadarikin, arranged in my own way. I decided not\n// to keep the circles, trademark of his \"alphabet plastique\", because I couldn't make it work \n// correctly with the illusion of a motion on the checkboard\n//\n// My instagram for some related work:\n// https://instagram.com/ciphrd\n//\n\n#define DIVS 19.0\n#define PI 3.141592653\n#define CIRCLES 0.0\n#define rot(a)   mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n\n\n// @author sam hocevar\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n\n    float c = 0.;\n    \n    // timer [0; 1]\n    float t = iTime / 60.;\n    if (t > .5) {\n        uv*= rot((t-.5) * 10.);\n    }\n    t = min(1., t);\n    \n    \n    // the grid\n    vec2 dv = uv * DIVS + .5; // we add .5 for odd centering\n    vec2 gd = fract(dv) - .5;\n    vec2 id = floor(dv);\n    \n    // checkboard\n    float dm = mod(id.x + id.y, 2.);\n    \n    // hue\n    float hue = mix(1.0, 0.7, dm);\n    \n    // manhattan distance\n    float mand = sin(((abs(id.x) + abs(id.y)) / DIVS * 2. - iTime*(0.1+t*.4)) * 1.5) * .5;\n    \n    \n    vec3 color = hsv2rgb(vec3(hue, .8, mix(mand, 1. - mand, dm)));\n    \n    \n    // the border, source of all motion\n    float bd = smoothstep(0.35, 0.5, abs(gd.x));\n    bd = max(bd, smoothstep(0.35, 0.5, abs(gd.y)));\n    float a = atan(gd.y, gd.x)*2. + cos(iTime * .5) * (t*10.+3.) + (mod(id.x, 2.)*4.-2.) * cos(iTime);\n    a = mod(a, 4.*PI);\n    color = mix(color, color*pow((cos(a)*.5+.5), 2.), bd);\n    \n    \n    // adding circles\n    float cir = smoothstep(0.3, 0.20, length(gd));\n    color-= cir * CIRCLES;\n\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[985, 1067, 1089, 1089, 1258], [1262, 1262, 1319, 1319, 2469]], "test": "untested"}
{"id": "wtlcDl", "name": "Rainbow eels", "author": "jarble", "description": "These colorful blobs are swimming like eels.", "tags": ["3d", "raymarching", "creature", "eel"], "likes": 1, "viewed": 281, "published": 3, "date": "1593472711", "time_retrieved": "2024-07-30T20:58:34.264448", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nvoid animate(inout vec3 uv){\n    //float distortion = 10.0; //this makes them look like \"spaceships\"\n    float distortion = 100.0; //this makes them look like \"planets\"\n    uv += sin(uv.yzx/2.0);\n\tvec3 p1 = (uv+vec3(2.0*iTime))/70.0;\n    uv += cos(p1.yzx)*distortion;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= scale;\n    animate(p);\n    p /= 500.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n\n    p *= scale;\n    animate(p);\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    p/=3.0;\n    return  (length(cos(p))-.5)/scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\t\n    vec3 eye = vec3(5.0, 5.0, 10.0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 2000.0;\nconst float EPSILON = 0.0001;\nconst float scale = 100.0;\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nvoid animate(inout vec3 uv){\n    //float distortion = 10.0; //this makes them look like \"spaceships\"\n    float distortion = 100.0; //this makes them look like \"planets\"\n    uv += sin(uv.yzx/2.0);\n\tvec3 p1 = (uv+vec3(2.0*iTime))/70.0;\n    uv += cos(p1.yzx)*distortion;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= scale;\n    animate(p);\n    p /= 500.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n\n    p *= scale;\n    animate(p);\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    p/=3.0;\n    return  (length(cos(p))-.5)/scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    vec3 eye = vec3(5.0, 5.0, 10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 87, 159, 328], [330, 330, 358, 358, 872], [874, 1114, 1138, 1138, 1350], [1352, 1773, 1864, 1864, 2182], [2197, 2286, 2315, 2315, 2625], [2627, 3119, 3259, 3259, 3849], [3851, 4221, 4306, 4306, 5064], [5068, 5068, 5095, 5095, 5244], [5246, 5246, 5303, 5303, 5911]], "test": "untested"}
{"id": "WlscDs", "name": "Plasma filaments in sphere", "author": "terraquoia", "description": "Attempt to create a specific volumetric shader, it has bugs. Keys 1,2, 3 move camera closer, press together to combine. Mouse LMB click and drag rotate sphere and mouse X coord also changes camera distance.", "tags": ["plasma", "sphere", "volumetric", "raymarcher", "learning", "filements"], "likes": 21, "viewed": 689, "published": 3, "date": "1593459543", "time_retrieved": "2024-07-30T20:58:35.377472", "image_code": "// Derived from \"Supernova remnant\" by Duke and other sources (github etc)\n// source shader is at https://www.shadertoy.com/view/MdKXzc\n// the code presented here is collected from various sources, i lost count how many sites i traversed while learning\n// this is not a standalone shader. it incomplete and i'm in process of learning so please excuse me for any bad practices\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// CHANGELOG\n// 30.06.2020 - Added simple noise as suggested by Shane and jeyko to reduce visible color banding due to limited raymarch step count\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat hash31(vec3 p){  return fract(sin(dot(p, vec3(113.587, 27.609, 57.583)))*43758.5453); }\n\nfloat noise(vec3 p)\n{\n\tvec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n\tvec4 k1 = perm(b.xyxy);\n\tvec4 k2 = perm(k1.xyxy + b.zzww);\n\n\tvec4 c = k2 + a.zzzz;\n\tvec4 k3 = perm(c);\n\tvec4 k4 = perm(c + 1.0);\n\n\tvec4 o1 = fract(k3 * (1.0/ 41.0));\n\tvec4 o2 = fract(k4 * (1.0/ 41.0));\n\n\tvec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n\tvec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n\treturn o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat length2(vec2 p)\n{\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\nfloat length8(vec2 p)\n{\n    p = p * p; p = p * p; p = p * p;\n\treturn pow(p.x + p.y, 1.0 / 8.0);\n}\n\nfloat Disk(vec3 p, vec3 t)\n{\n\tvec2 q = vec2(length2(p.xy) - t.x, p.z * 0.5);\n\treturn max(length8(q) - t.y, abs(p.z) - t.z);\n}\n\n// 1 / sqrt(2)\n#define NORMALIZER 0.70710678118654752440084436210485\n#define NOISE_LOOPS 6\n\nfloat SpiralNoiseC(vec3 p)\n{\n\tfloat n = 0.0;\t// noise amount\n\tfloat iter = 2.5;\n\tfor (int i = 0; i < NOISE_LOOPS; i++)\n    {\n\t\tR(p.yz, noise(p + iTime * 0.031));\n\t\t// add sin and cos scaled inverse with the frequency\n\t\tn += -abs(sin(p.y * iter) + sin(p.x * iter)) / iter;\t// abs for a ridged look\n\t\tp.xy *= NORMALIZER;\n\t\t// rotate on other axis\n\t\tR(p.xz, noise(p + iTime * 0.0045));\n\t\tp.xz *= NORMALIZER;\n\t\t// increase the frequency\n\t\titer *= sqrt(sin(iTime * 0.1) + 2.7); //1.733733;\n\t}\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n    float final = Disk(p.xzy, vec3(noise(p + 0.31 * iTime) * 2.0, noise(p + 0.11 * iTime) * 1.8, noise(p + 0.21 * iTime) * 1.25));\n    final += SpiralNoiseC(p.zxy * 0.5123+ noise(p + 0.31 * iTime)) * 3.0;\n    return final;\n}\n\n#define _MAIN_RADIUS 0.481\n#define _EXCLUSION_RADIUS 0.3\n#define _RAYMARCH_STEPS 50\n#define _SURFACE_DISTANCE 0.075\n\nfloat map(vec3 p)\n{\n\tR(p.xz, iMouse.x * 0.008 * pi + iTime * 0.01);\n\tR(p.zy, iMouse.y * 0.008 * pi + iTime * 0.02);\n    float NebNoise = abs(NebulaNoise(p * 2.0) * 0.9);\n    return NebNoise + 0.07;\n}\n\n// assign color to the media\nvec3 computeColor(float density, float radius)\n{\n    // color based on density alone, gives impression of occlusion within\n    // the media\n    vec3 result = mix(vec3(1.0, 0.9, 0.8), vec3(0.4, 0.15, 0.1), density );\n\n    // color added to the media\n    vec3 colCenter = 7. * vec3(0.8, 1.0, 1.0);\n    vec3 colEdge = 1.5 * vec3(0.48, 0.53, 0.5);\n    result *= mix(colCenter, colEdge, min((radius + .05) / .9, 1.15 ));    \n    return result;\n}\n\n//https://youtu.be/HFPlKQGChpE?t=657\nbool RaySphereIntersect(vec3 rayOrigin, vec3 rayDirection, vec3 center, float radius, out float nearPointStep, out float farPointStep)\n{\n    float midValue = dot(center - rayOrigin, rayDirection);\n    vec3 midPoint = rayOrigin + midValue * rayDirection;\n    float midPointToCenterLength = length(center - midPoint);\n    if (midPointToCenterLength < radius)\n    {\n        // ray is inside, set lengths for calculating ray entry and exit points on sphere ...\n        float intersectionLength = sqrt(radius * radius - midPointToCenterLength * midPointToCenterLength);\n        nearPointStep = midValue - intersectionLength;\n        farPointStep = midValue + intersectionLength;\n        return true;\n    }\n    //...else the ray missed the sphere, set entry and exit points to meaningless zeros and return false to indicate intersection failure\n    nearPointStep = 0.0;\n    farPointStep = 0.0;\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n\tfloat key = 0.0;\n\tkey += 0.1*texture(iChannel1, vec2(KEY_1,0.25)).x;\n\tkey += 0.1*texture(iChannel1, vec2(KEY_2,0.25)).x;\n\tkey += 0.1*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\tvec3 rayDirection = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.0));\n\tvec3 rayOrigin = vec3(0.0, 0.0, -1.3+key*1.6+(iMouse.x*2.0-iResolution.x)/iResolution.x*1.0);\n    const vec3 sphereCenter = vec3(0);\n    float localDensity = 0.0, totalDensity = 0.0, weightFactor = 0.0;\n\n    float dist = 1., rayStep = 0.;\n\n    vec4 sum = vec4(0.0);\n\n    float min_dist = 0.0, max_dist = 0.0;\n    vec3 lightColor = vec3(1.0, 0.5, 0.25);\n\n    if (RaySphereIntersect(rayOrigin, rayDirection, vec3(0, 0, 0), _MAIN_RADIUS, min_dist, max_dist))\n    {\n        rayStep = min_dist * step(rayStep, min_dist);\n\n        // raymarch loop\n        for (int i = 0; i < _RAYMARCH_STEPS; i++)\n        {\n            vec3 pos = rayOrigin + rayStep * rayDirection;\n\n            //if point is inside SDF sphere of given radius, skip all calculations. easier than to make a new RaySphereIntersect() just for this\n            if (length(pos - sphereCenter) - _EXCLUSION_RADIUS <= 0.0) continue;\n            \n            // Loop break conditions.\n            //OLD CODE\n            //if (totalDensity > 0.9 || dist < 0.1 * rayStep || rayStep>10. || sum.a > 0.99 || rayStep > max_dist) break;\n            //NEW CODE \n            if (totalDensity > 0.9 || sum.a > 0.99 || rayStep > max_dist) break;\n\n            // point light calculations\n            vec3 lightVector = sphereCenter - pos;\n            float lightDistance = max(length(lightVector), 0.001);\n\n            // evaluate distance function, point multiplied to allow for visible effects on shrinked down sphere\n            dist = map(pos * 3.);\n\n            // change this string to control density\n            dist = max(dist, 0.0);\n\n            // the color of light\n            sum.rgb += lightColor / exp(lightDistance * lightDistance * lightDistance * .09) / 22. ; // bloom\n\n            if (dist <= _SURFACE_DISTANCE)\n            {\n                // compute local density\n                localDensity = _SURFACE_DISTANCE - dist;\n\n                // compute weighting factor\n                weightFactor = (1. - totalDensity) * localDensity;\n\n                // accumulate density\n                totalDensity += weightFactor + 0.01;\n\n                vec4 col = vec4(computeColor(totalDensity, lightDistance), totalDensity);\n\n                // emission\n                sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;\n\n                // uniform scale density\n                col.a *= 0.2;\n\n                // colour by alpha\n                col.rgb *= col.a;\n\n                // alpha blend in contribution\n                sum = sum + col * (1.0 - sum.a);\n\n            }\n\n            totalDensity += 1. / 70.;\n\n            //Added 30.06.2020 as commented by Shane and jeyko.\n            //Minor change :\n            //Instead affecting distance at start, it is changed here\n            //to only affect rayStep used to raymarch through volume.\n            //Adds sufficient noise with some leftover banding artefacts which should\n            //not be noticable in a more complex visual environment.\n            dist *= 0.51 + hash31(pos + 113.1) * 0.18;\n            \n            // trying to optimize step size near the camera and near the light source\n            rayStep += max(dist * 0.1 * max(min(length(lightVector), length(rayOrigin)), 1.0), 0.01 );\n        }\n\n        // simple scattering\n        sum *= 1. / exp(localDensity * 0.2) * 0.6;\n        sum = clamp(sum, 0.0, 1.0);\n        sum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\n    }\n    \n    fragColor = vec4(sum.xyz,1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscDs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[686, 686, 709, 709, 756], [757, 757, 778, 778, 825], [826, 826, 845, 845, 886], [888, 888, 909, 909, 981], [983, 983, 1004, 1004, 1460], [1462, 1462, 1485, 1485, 1524], [1526, 1526, 1549, 1549, 1623], [1625, 1625, 1653, 1653, 1750], [1844, 1844, 1872, 1872, 2347], [2349, 2349, 2376, 2376, 2601], [2720, 2720, 2739, 2739, 2919], [2921, 2950, 2998, 3089, 3390], [3392, 3429, 3565, 3565, 4336], [4338, 4338, 4395, 4395, 8204]], "test": "untested"}
{"id": "WlsyDs", "name": "Day 192", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 9, "viewed": 330, "published": 3, "date": "1593457128", "time_retrieved": "2024-07-30T20:58:36.214235", "image_code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./50.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[11](4.2*speed,7.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 1.2*speed, 1.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec2 r22(vec2 u){\n    u *= 126.3262;\n\tfloat uv = fract(dot(u, u*vec2(0.35,0.86)));\n\tu /= 124.3262;\n    return fract(sin(vec2(uv*u.y + u.x*uv*0.15 - u.y) - u)*215.125);\n}\n\nfloat starLayer(vec2 u, float sc){\n\tfloat d = 10e5;\n    u *= sc;\n    vec2 id = floor(u);\n    vec2 uv = fract(u) - 0.1;\n\tvec2 r = r22(id)*2. - 1.;\n\tvec2 rb = r22(id + 6.4);\n\td = min(d, (length(uv - r*1. ) - rb.x*0.04)/sc);\n\treturn d;\n}\n\nfloat starNoise(vec2 u){\n\tfloat d = 10e6;\n    \n    d = min(d, starLayer(u,16.));\n    d = min(d, starLayer(u,36.))/0.7;\n    \n    return d; \n}\n\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    uv.y = - uv.y;\n    \n    //t += sumScenes(1.)- 0.;\n    \n    t = mod(t, sumScenes(9.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*0.25;\n    \n    float its = 15.;\n    float scene = 0.;\n    \n    vec2 p = uv;\n\n    vec4 q = vec4(p,1,1);\n\n    float dt = 10e5;\n    float dFirst = 10e5;\n\tfloat boxdel = 10e5; \n    \n    for(float i = 0.; i < its; i++){\n        float tsc = i/its*2.;\n        float enva = eass((t - tsc)/scenes[0]*2.,3.);\n\n        float envb = eass((t - tsc - scenes[0])/scenes[1]*2.,3.);\n\n        float envc = eass((t - tsc - sumScenes(1.))/scenes[2]*1.,3.);\n        float envd = eass((t - tsc - sumScenes(2.))/scenes[3]*1.,7.);\n\n        float enve = eass((t - tsc - sumScenes(3.))/scenes[4]*1.,3.);\n\n        float envf = eass((t - tsc - sumScenes(4.))/scenes[5]*1.,1.);\n\n        float envg = eass((t - tsc - sumScenes(5.))/scenes[6]*1.,3.);\n\n        float envh = eass((t - tsc - sumScenes(6.))/scenes[7]*1.,3.);\n\n        vec2 b = p;\n\n\n        //b = mix(b,abs(b),1.);\n\n        b *= rot(pi*0. );\n\n\n        float itsifs = 0. + envf*0.3  - envh*0.3;\n        for(float j = 0.; j < itsifs + 1.; j++){\n            vec2 f = abs(b);\n            //b -= 0.01;\n\n            //f -= 0.1*envf;\n            f *= rot(0.25*pi);\n            //f *= rot(0.25*pi*envf);\n            \n            b = mix(b,f,smoothstep(0.,1.,itsifs - j));\n\n        }\n\n        b.xy *= rot(tau*i/its*(0.6*envc - 0.6*envd) );\n\n        //b.y -= 0.3;\n        //b.y += 0.2*enva;\n\n        //b.y += sin((i)/1. - t*pi)*0.1;\n        //b.xy *= rot(i*0.4 + iTime/3.);\n\n        vec2 g = b;\n\n        float ld = 10e5;\n\n        \n        ld = min(ld,abs(length(b + vec2(0.24,0.04))-0.01));\n        \n        //\n        vec2 bc = b - vec2(-0.2 + enva*0.1 - envh*0.1,0.04);\n        float dc = length(bc);\n        ld = min(ld,\n                 max(\n                     abs( pmod(atan(bc.y,bc.x),0.4))\n                 \t*length(bc)/smoothstep(1.,0.98,length(bc)*(4.  + sin(atan(bc.y,bc.x)*4.) )),\n                     -dc + 0.04\n                \t)\n                 );\n        ld = min(ld,abs(dc-0.04));\n        \n        \n        \n        //\n        bc = b - vec2(0.34 - envc*0.1 + envh*0.1,-0.3);\n        \n        dc = length(bc);\n        \n        ld = min(ld,\n                 max(\n                     abs( pmod(atan(bc.y,bc.x),0.4))\n                 \t*length(bc)/smoothstep(1.,0.98,length(bc)*(4. + sin(atan(bc.y,bc.x)*4.))),\n                     -dc + 0.04\n                \t)\n                 );\n        ld = min(ld,(dc-0.05));\n        \n        //\n        float tri = sdTri(g,vec2(0.5,0.5));\n        ld = max(ld, -tri);\n        ld = min(ld,abs(tri));\n        \n        //\n        \n        \n        bc = b - vec2(0.4 - enva*0.3 + envh*0.3,0.24);\n        \n        dc = length(bc);\n        \n        ld = min(ld,\n                 max(\n                     abs( pmod(atan(bc.y,bc.x),0.4))\n                 \t*length(bc)/smoothstep(1.,0.98,length(bc)*(4.  + sin(atan(bc.y,bc.x)*3.5))),\n                     -dc + 0.1\n                \t)\n                 );\n        \n        float crem = dc - 0.1;\n\t\t\n        ld = min(ld,abs(dc-0.1));\n        \n        \n        b = abs(b ) - vec2(0.3*envb - envh*0.3,0.4);\n        b *= rot(-0.25*pi + 0.25*pi*envb - envh*0.25*pi);\n\t\t\n        float lbd = sdBox(b,vec2(0.,0.5));\n        lbd = min(lbd, sdBox(b - vec2(0.2,0.3),vec2(0.0,0.8)));\n        //ld = min(ld,boxdel);\n        lbd = sdBox(b - vec2(0.1,0.0),vec2(0.1,0.5));\n        ld = min(ld,abs(lbd));\n        \n        if(i == 0.)\n            boxdel = lbd;\n        \n        //boxdel = min(boxdel, sdBox(b - vec2(0.2,0.3),vec2(0.0,0.8)));\n        \n        \n        b *= rot(-0.25*pi);\n\t\t//ld = min(ld,sdBox(b,vec2(0.00,0.5)));\n        //ld = min(ld,abs(sdBox(pmod( (b -vec2(0.1,0.)),vec2(.3,0.1)),vec2(0.02,0.02))));\n        \n\n        vec4 q = vec4(b,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n\n        q = pmod(abs(q),0.05);\n\n        float dbq = sdBox(q,vec4(0.01 ));\n\n        float slider = smoothstep(0.,1.,i/its + 0.3 )*1.;\n\t\t\n        \n        ld = max(ld,-crem);\n        \n        float ldb = ld;\n        ld = mix(ld,abs(dbq),slider);\n\n\t\t\n        \n        ld = mix(ld,max(ld,ldb),slider);\n\n        \n        dt = min(dt,abs(ld));\n\n        dt = mix(dt, abs(pmod(dt ,0.04 )) ,slider);\n        dt = abs(dt) - 0.0001;\n        \n        float stars = starNoise((p + 0.04*envg)*rot(0.25*envg));\n        \n        stars = max(stars, max(abs(p.x),abs(p.y)) - 0.5*envc + envh*0.5);\n        \n        stars = max(stars, -sdTri(p,vec2(0.5,0.5)));\n        stars = max(stars, -boxdel);\n\n        \n        dt = min(dt, stars);\n\t\t\n        \n        dt = max(dt, -boxdel);\n        \n    }\n    d = min(d,dt); \n    \n    \n\n    \n    \n    //d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    if (abs(uv.x) > 0.5)\n        col -= col;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 318, 318, 374], [377, 388, 425, 425, 733], [734, 734, 771, 771, 818], [819, 819, 856, 856, 921], [976, 976, 1028, 1028, 1147], [1327, 1327, 1355, 1355, 1462], [1464, 1464, 1533, 1533, 1689], [1690, 1690, 1720, 1720, 1829], [1831, 1831, 1848, 1848, 2000], [2002, 2002, 2036, 2036, 2236], [2238, 2238, 2262, 2262, 2378], [2441, 2441, 2468, 2468, 7369]], "test": "untested"}
{"id": "WllyWH", "name": "Brief history of the pyramids", "author": "friol", "description": "THEY are watching us.", "tags": ["raymarching", "glow", "neon", "pyramid", "ufo"], "likes": 33, "viewed": 608, "published": 3, "date": "1593450546", "time_retrieved": "2024-07-30T20:58:37.392085", "image_code": "\n//\n// THEY are seeing us\n//\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel1, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n\nfloat message(vec2 U,int w) \n{\n    vec4 T = vec4(0);\n    if (w==0) { C(116);C(111);C(32);C(98);C(101);C(32);C(99);C(111);C(110);C(116);C(105);C(110);C(117);C(101);C(100);C(46);C(46);C(46); }\n    return length(T.yz)==0. ? -1. : T.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\tvec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (iTime>=88.0)\n    {\n        float c=message((fragCoord/iResolution.y-vec2(0.78,.01))*vec2(10.,10.5),0);\n        if (c>0.2){fragColor=vec4(c*1.0);return;}\n    }\n    \n    // vignette\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2 *=  1.0 - uv2.yx;\n    float vig = uv2.x*uv2.y * 38.0;\n    vig = pow(vig, 0.05);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(texture(iChannel0, uv).rgb*vig, 0.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//\n// THEY are scripting us\n//\n\n// point in time for the various scenes\n\n// scene 1\n#define sceneFadeInBegin 0.0\n#define sceneFadeInEnd 5.0\n#define sceneSpaceWarpEnd 7.5\n#define ufoWarpInEnd 9.5\n#define sceneMovementEnd 19.0\n#define fadeOutEarthBegin 22.0\n#define ufoBehindEarth 25.0\n\n// scene 2\n#define fogSceneFadeIn 28.0\n#define fogFadeoutBegin 31.5\n\n// scene 3\n\n#define ufoDownBegin 35.0\n#define ufoDownEnd 38.0\n#define rayDownEnd 42.0\n#define rayQuadEnd 46.0\n#define pyrGrowingEnd 53.0\n#define blackPyrEnd 58.0\n\n#define fourRaysReturn 62.0\n#define vertRayReturn 64.0\n\n#define zoomInEnd 66.0\n\n#define warpOutBegin 75.5\n#define warpOutEnd 76.5\n#define ufoRunsAway 81.0\n\n#define finalFadeOut 83.0\n#define thatsAllFolks 84.50001\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// Deep Space \n// Star Nest by Kali\n// https://www.shadertoy.com/view/4dfGDM\n\n#define iterations 17\n#define formuparam 0.33\n#define volsteps 10\n#define stepsize 0.1\n#define tile   0.550\n#define brightness 0.0011\n#define darkmatter 1.100\n#define distfading .530\n#define saturation 0.4545\n\nvec4 space(vec3 rd,float time,int mode)\n{\n\tvec3 dir=rd;\n\tvec3 from=vec3(1.,.5,0.5);\n\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) \n    {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\t\n        float multFactor;\n        if (time<sceneFadeInEnd) multFactor=0.04;\n        else multFactor=max(mix(1.4,0.01,time/sceneSpaceWarpEnd),0.01);\n        for (int i=0; i<iterations; i++) \n        { \n\t\t\tif (mode==0) p=abs(p)/dot(p,p)-0.45+sin(time/sceneFadeInEnd)*multFactor;\n\t\t\tif (mode==1) p=abs(p)/dot(p,p)-0.45+0.30;\n            \n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation)*vec3(0.5,0.5,0.86);\n\treturn vec4(v*.01,1.);\t\n}\n\n// from https://www.shadertoy.com/view/Msl3WH\nvec4 spaceWarp(float tm,in vec2 uv)\n{\n\tfloat time = tm*60.0;\n\n    float s = 0.0, v = 0.0;\n\tfloat t = time*0.005;\n\tuv.x += sin(t) * 0.5;\n\tfloat si = 0.0;\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z, 2.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\tcol +=  vec3(v * 0.02, 0.1 - s * 0.12, .2 + v * 0.13) * v * 0.013;\n\t\ts += .01;\n\t}\n\treturn vec4(col, 1.0);\n}\n\n//\n// desert dream\n//\n\n#define PI 3.14159265359\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat terrainH( in vec2 p)\n{\n    //small\n\tfloat valS = noise(p * 0.5) + 0.5;//0~1\n    valS = 1.0 - abs(valS - 0.5) * 2.0;\n    valS = pow(valS,2.0);\n\n    //middle\n    float valM = noise(p * 0.26) + 0.5;//0~1\n    valM = 1.0 - abs(valM - 0.5) * 8.0;\n    //valM = pow(valM,1.0);\n    \n    //big\n    float valB = smoothstep(0.0,1.0,noise(p * 0.2) + 0.5);//0~1\n\n    float val = valS * 0.01 + valM * 0.19 + valB * 0.7;\n\n    return val * 1.3 - 0.3;\n}\n", "sound_code": "\n//\n// THEY are hearing us\n//\n\n#define soundDelayRepetitions 6\n#define soundDelayTime 0.25\n#define soundDelayFeedback 0.85\n#define soundDelayWet 0.55\n\nfloat freqFromMidiNote(float n) {return pow(2.,(n-69.)/12.)*440.0;}\n\n// percussions\n\nfloat modfix(float phase) {\n    return mod(phase, 6.28);\n}\n\nfloat sinf(float t, float freq) {\n\treturn sin(modfix(3.141592*2.0 * t * freq));\n}\n\nfloat kick(float t) \n{\n    return clamp(0.55 * sinf(t, 520. * exp(-t * 15.0)) * exp(-t * 5.), -1.0, 1.0) * smoothstep(0.001, 0.003, t);\n}\n\n// hihat\n\nvec2 hihat(float time,float panning)\n{\n    float tb = mod(time,(60.0/120.0)*1.0);\n    float hihat=(fract(cos(time * 32234.523) * 134.) * exp(mod(tb, 1. / 2.0) / 2.0 * -120.)*(fract(tb) + .2));\n\n    float tbr = mod(time+0.135,(60.0/120.0)*1.0);\n    float hihatr=(fract(cos((time+0.135) * 32234.523) * 134.) * exp(mod(tbr, 1. / 2.0) / 2.0 * -120.)*(fract(tbr) + .2));\n    hihat+=hihatr*0.5;\n    \n    float tb2 = mod(time+0.25,(60.0/120.0)*1.0);\n    float hihat2=(fract(cos((time+0.25) * 32234.523) * 134.) * exp(mod(tb2, 1. / 2.0) / 2.0 * -120.)*(fract(tb2) + .2));\n    hihat2*=0.5;\n    return vec2(\n        (hihat*panning)+(hihat2*(1.0-panning)),\n        hihat*(1.0-panning)+hihat2*panning)*.55;\n}\n\n\n// snare\n\nfloat baseFreq=1.0;\n \n#define TT(d) mod(mod(time,1.0)-d,1.0)\n\nfloat rand(float t){\n    return fract(sin(t*1793.326) * 43758.5453);\n}\n\nfloat ws(float x,float a)\n{\n\treturn x*(abs(x) + a)/(x*x + (a-1.0)*abs(x) + 1.0);\n}\n\nfloat snareDrum(float _time)\n{\n    float freq=680.0*baseFreq;\n\tfloat c=0.0;\n    const int  num=7;\n    for (int i=0;i<num;i++)\n    {\n        float time=_time-float(i)*(0.09+float(i)*0.01);\n\n        if (time<0.0)\n            continue;\n        \n        float t=1.0-(time*1.0);\n        t=max(t,0.0);\n        t=pow(t,2.0);\n\n        float f=sin(t*freq)/PI;\n\n    \tf=ws(f,2.9);\n        t=time*baseFreq;\n        f*=pow(max(0.0,1.0-(t*6.0)),4.0);\n        f+=rand(time)*0.4*pow(1.0-t,20.0);\n    \tf=ws(f,1.9);\n\t    f= clamp(f,-1.0,1.0);\n        f*=0.7;\n        c+=f/float(1+(i*i*4));\n        \n    }\n    \n    return c*0.35;        \n}\n\n// drone/ambient synth by nabr\n\n#define tau 6.2831\nfloat synth(float rt)\n{\n    float sn = .001,sn1 = .001;\n    float m0 = float[](10., 50., 80., 40., 60.)[uint(2. * rt) % 5u];\n    float mrt6 = mod(6. * rt, 1.);\n    float mrt2 = mod(2. * rt, 1.);\n    for (uint n = 0u; n < 5u; n++)\n    {\n        sn += (2. * sin(m0 * tau * rt));\n        sn1 = (.5 + sn) + (1. - sqrt((sn-.527) * (sn-.527)));\n        sn*= min(1., 2. * mrt6) * max(0., 1. - mrt6);;\n        m0 *= 3.;\n    }\n    sn1 *= min(1., 2. * mrt2) * max(0., 1. - mrt2);\n    \n    return  .5 * sn + .25 * sn1;\n}\n\nfloat usynth(float rt)\n{\n    rt = mod(rt, 15.);\n    float sn = .001;\n    float mrt2 = mod(2. * rt, 1.);\n    if (mod(5. * rt, 4.) < 1.)\n    {\n        float sna = \n              (1. - sin(2600. * tau * rt)) \n            + (1. - sin(1600. * tau * rt))\n            + (1. - sin(1300. * tau * rt))\n            + (1. - sin(867. * tau * rt));\n        sn = floor(abs(sna)) * pow(4., 1. - 6. * mod(rt, 1.));\n        sn *= .25 * min(1., mrt2) * max(0., 1. - mrt2);\n    }\n    //return 1e-6; \n\treturn .15 * sn;\n}\n\nvec2 nabrSynth(float time)\n{\n    float dt0[]= float[](0.947288, 0.878126, 0.796571, 0.707107, 0.614240, 0.522137, 0.434333, 0.353553);\n    float dt1[] = float[](1.089587, 0.911173, 1.005095, 1.079870, 0.721942, 0.987824, 1.022421, 0.439581, 1.225677, 0.360320, 0.178849, 1.739190, 0.145721, 0.345178, 2.554054, 0.138851);\n\n    vec2 uni = vec2(0), rev = vec2(0);\n\n    float tick = time * .016667;\n    float t0 = (38.88 * tick), t1 = (7.776 * tick);    \n\n    for (uint i = 0u; i < 7u; i++)\n    {\n        vec2 usy = vec2(usynth(t0 + 1.01 * dt0[i]), usynth(t0 + 1.00 * dt0[i]));\n        uni = (uni - usy);\n    }\n    for (uint j = 0u; j < 16u; j++)\n    {\n        vec2 rsy = vec2(synth(t1 + 1.025 * dt1[j]), synth(t1 + 1.010 * dt1[j]));\n        rev = (rev + uni);\n        rev = (rev + rsy);\n    }\n    \n    rev*=min(1.,time/24.);\n\treturn rev;\n}\n\n// synthie\n\nfloat pulse( float morph, float pulse, float phase )\n{\n\tfloat a, b;\n    if( pulse < 0.5 )\n        a = morph * pulse * 0.5;\n    else\n        a = morph * ( 1.0 - pulse ) / 2.0;\n    if( phase < pulse )\n    {\n        if( phase < a )\n        {\n            b = phase / a - 1.0;\n            return 1.0 - b * b;\n        }\n        if( phase < pulse - a )\n            return 1.0;\n        b = ( phase - pulse + a ) / a;\n        return 1.0 - b * b;\n    }\n    if( phase < pulse + a )\n    {\n        b = ( phase - pulse ) / a - 1.0;\n        return b * b - 1.0;\n    }\n    if( phase <= 1.0 - a )\n        return -1.0;\n    b = ( phase - 1.0 + a ) / a;\n    return b * b - 1.0;\n}\n\nvec2 synthie(float time,float note1,float note2)\n{\n\tfloat y=time*60.0/240.0;\n    float a=8.0;\n    float s=1.0;\n    float b=16.0;\n    float bi=floor(b*y);\n    float w=b*y-bi;\n    float sqe=pow(min(1.0,min(s-s*w,a*w)),2.0)*(3.0-mod(bi,3.0));\n    float x=time*note1;\n    float x2=time*note2;\n    \n    float fltr=0.5+abs(sin(time))*5.0;\n    float wave=\n        pulse(0.75, 1.75, fract(x))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*fltr, 0.5+0.45*sin(y*4.0), fract(x))+\n        pulse(1.75, 0.75, fract(x2))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*fltr, 0.5+0.45*sin(y*2.0), fract(x2));\n        \n    \n    return ((1.0+0.5*sin(time))/2.0)*vec2(\n        (wave*sqe*0.07)*clamp((1.0+sin(time))/2.,0.25,0.75),\n        (wave*sqe*0.07)*clamp((1.0+cos(time))/2.,0.25,0.75)\n    )*vec2(0.6);\n}\n\n// bass\n\nvec2 bass(float time, float tt, float freq, float parm1,float parm2)\n{\n    float freqTime = 3.141592*2.0*time*freq;\n    parm1=.5; parm2=0.29;\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(parm1*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(parm2*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\n// initial swirl\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat warpNoise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm8(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 16; i++) {\n        total += warpNoise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nfloat fbm16(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 16; i++) {\n        total += warpNoise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.25;\n    }\n    return total;\n}\n\nvec2 initialSwirl( float time )\n{\n    vec2 s1 = vec2(sin(440.+fbm8(vec2(time/2.))*70.*exp(fract(time/20.)*12.))+fbm16(vec2(time)))*2.;\n    vec2 s2 = vec2(sin(220.+fbm8(vec2(time))*70.*exp(fract(time/40.)*12.))+fbm8(vec2(time)))*1.;\n    s1 = mix(s1, s2, 0.5);\n    s1 = vec2(s1.x)*0.15;  \n    return s1;\n}\n\n//\n//\n//\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 soundOutput=vec2(0.0);\n    \n    float bassTime=mod(time/2.0,4.0);\n    if ((time>8.0)&&(time<16.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(37.0),-2.0,-2.0)*0.5;\n    else if ((time>16.0)&&(time<24.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(42.0),-2.0,-2.0)*0.5;\n\telse if ((time>=24.0)&&(time<40.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(37.0),-2.0,-2.0)*0.5;    \n\telse if ((time>=40.0)&&(time<48.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(42.0),-2.0,-2.0)*0.5;    \n\telse if ((time>=48.0)&&(time<64.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(44.0),-2.0,-2.0)*0.5;              \n\telse if ((time>=64.0)&&(time<96.0)) soundOutput+=bass(bassTime,bassTime *2.4,freqFromMidiNote(37.0),-2.0,-2.0)*0.5;    \n    \n    if ((time>8.0)&&(time<64.0))\n    {\n\t\tif (time<16.0) soundOutput+=     synthie(time,35.0*11.9,44.0*11.9);\n        else if (time<24.0) soundOutput+=synthie(time,35.0*12.1,46.0*12.1);\n        else if (time<40.0) soundOutput+=synthie(time,35.0*11.9,44.0*11.9);\n        else if (time<48.0) soundOutput+=synthie(time,35.0*12.1,46.0*12.1);\n        else if (time<64.0) soundOutput+=synthie(time,35.0*12.0,52.0*12.0);\n    }\n\n    if ((time>8.0)&&(time<64.0))\n    {\n        if (time>=32.0) soundOutput+=snareDrum(mod(time+0.5,1.0));\n        soundOutput+=kick(mod(time,.5)*0.125);\n        soundOutput+=hihat(time,0.25);\n    }\n    \n    if (time<88.0) soundOutput+=nabrSynth(time)*0.065;\n    \n    if (time<sceneSpaceWarpEnd) soundOutput+=initialSwirl(time*1.4);\n    \n    return soundOutput;\n}\n", "sound_inputs": [], "buffer_a_code": "\n/* \n\t\"Don't you believe in flying saucers, they ask me? Don't you believe in \n\ttelepathy? — in ancient astronauts? — in the Bermuda triangle? — in life after death?\n\tNo, I reply. No, no, no, no, and again no.\n\tOne person recently, goaded into desperation by the litany of unrelieved negation, \n\tburst out \"Don't you believe in anything?\"\n\t\"Yes\", I said. \"I believe in evidence. I believe in observation, measurement, and reasoning, \n\tconfirmed by independent observers. I'll believe anything, no matter how wild and ridiculous, \n\tif there is evidence for it. The wilder and more ridiculous something is, however, \n\tthe firmer and more solid the evidence will have to be.”\n*/\n\n#define GETFAR 999999.0\n\nconst int numRaymarchSteps=64;\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n// planet code by iq\nvec3 textureEarth(vec3 ro,vec3 rd,float t,vec3 N)\n{\n    vec3 pos = ro + t*rd;\n    vec3 nor = N;\n    vec3 col = vec3(0.1);\n\n    vec2 uv;\n    uv.x = atan(0.5+nor.x,nor.z)/6.2831 - 0.003*iTime;\n    uv.y = 0.5+acos(nor.y*0.9999)/3.141521;\n    uv.y *= 0.5;\n\n    col = vec3(0.1,0.2,0.3);\n    vec3 te  = 1.0*texture( iChannel1, 0.5*uv.yx ).xyz;\n    te += 0.3*texture( iChannel1, 2.5*uv.yx ).xyz;\n    col = mix( col, (vec3(0.2,0.2,0.1)*0.55 + 0.45*te + 0.5*texture( iChannel0, 15.5*uv.yx ).xyz)*0.4, smoothstep( 0.45,0.5,te.x) );\n\n    vec3 cl = texture( iChannel0, 2.0*uv ).xxx;\n    col = mix( col, vec3(0.9), 0.75*smoothstep( 0.55,0.8,cl.x) );\n\n    float dif = max(nor.x*1.5+nor.z,0.0);\n    float fre = 1.0-clamp(nor.z,0.0,1.0);\n    float spe = clamp( dot( nor,normalize(vec3(0.9,0.92,.92)) ), 0.0, 1.0 );\n    spe=pow(spe,64.0);\n    col *= 0.03 + 0.75*dif;\n    \n    return col*0.5;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float multf=1.0;\n  if ((iTime>=sceneSpaceWarpEnd)&&(iTime<ufoWarpInEnd)) multf=mix(0.01,1.0,(iTime-sceneSpaceWarpEnd)/(ufoWarpInEnd-sceneSpaceWarpEnd));\n  if ((iTime>=warpOutEnd)&&(iTime<ufoRunsAway)) multf=mix(1.0,0.01,(iTime-warpOutEnd)/(ufoRunsAway-warpOutEnd));\n  vec2 q = vec2(length(p.xz)-t.x,p.y*multf);\n  return length(q)-t.y;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdDiagonalCapsule( vec3 p, float h, float r )\n{\n  p=rotz(p,-0.6);\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdVertTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*(0.5+1.5*abs(sin(iTime*5.0)))+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdEgyptianPyramid( vec3 p, float s)\n{\n    float basepyr=GETFAR;\n    if (iTime>=pyrGrowingEnd)\n    {\n      p=roty(p,0.775);\n      p = abs(p);\n      basepyr=(p.x+p.y+p.z-s)*0.57735027;\n\n      float cutbox1=sdBox(p-vec3(0.0,1.2,0.0),vec3(6.0,max(mix(2.2,0.2,(iTime-pyrGrowingEnd)/(blackPyrEnd-pyrGrowingEnd)),0.0),6.0));\n      basepyr=opSubtraction(cutbox1,basepyr);\n\n      float cutbox2=sdBox(p-vec3(0.0,2.4,0.0),vec3(6.0,max(mix(2.2,0.2,(iTime-pyrGrowingEnd)/(blackPyrEnd-pyrGrowingEnd)),0.0),6.0));\n      basepyr=opSubtraction(cutbox2,basepyr);\n\n      float cutbox3=sdBox(p-vec3(0.0,3.6,0.0),vec3(6.0,max(mix(2.2,0.2,(iTime-pyrGrowingEnd)/(blackPyrEnd-pyrGrowingEnd)),0.0),6.0));\n      basepyr=opSubtraction(cutbox3,basepyr);\n    }\n  \treturn basepyr;\n}\n\nfloat sdPyramid( vec3 p, float s)\n{\n  p=roty(p,0.775);\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdfUfo(in vec3 loc) \n{\n    float mult=40.0;\n    float rangle=atan(abs(loc.z),loc.x);\n\tvec3 loc2=vec3(loc.x,loc.y+0.002*(sin((rangle+iTime)*50.0)),loc.z);\n    float ball1 = length(loc2 - vec3(0.0, -1.8, 0.0)) - 2.;\n    float ball2 = length(loc - vec3(0.0, 2.0, 0.0)) - 2.1;\n    float disc = s_max(ball1, ball2, 0.05);\n    float ball3 = length(loc - vec3(0.0, 0.43, 0.0)) - 0.4;\n    float result=opSubtraction(ball3,disc);\n    return result;\n}\n\nvec2 SDFDesertDream(vec3 r,bool onlyTransp)\n{\n\tfloat t=GETFAR;\n\n    vec3 ufo1Center=vec3(0.0,8.5,0.0);\n\tif ((iTime>=ufoDownBegin)&&(iTime<ufoDownEnd))\n    {\n        ufo1Center=mix(vec3(0.0,12.5,0.0),vec3(0.0,8.5,0.0),(iTime-ufoDownBegin)/(ufoDownEnd-ufoDownBegin));\n    }\n    else if (iTime>=zoomInEnd)\n    {\n        ufo1Center=vec3(0.0,8.5+(iTime-zoomInEnd),0.0);\n        if (iTime>=ufoRunsAway) \n        {\n            ufo1Center.x-=(iTime-ufoRunsAway)*3.0;\n            ufo1Center.y+=((iTime-ufoRunsAway))*15.;\n            ufo1Center.z+=8.0*(iTime-ufoRunsAway);\n        }\n    }\n\n    if (onlyTransp)\n    {\n        float cup=sdSphere(r-vec3(ufo1Center.x,ufo1Center.y-0.1,ufo1Center.z),0.45);\n        float cut=sdBox(r-vec3(ufo1Center.x,ufo1Center.y-0.3,ufo1Center.z),vec3(10.0,.4,10.0));\n        cup=opSubtraction(cut,cup);\n        t=min(t,cup);\n        if (t==cup) return vec2(t,-1.0);\n        return vec2(GETFAR);\n    }\n    \n    float ufo=sdfUfo(r-ufo1Center);\n    t=min(t,ufo);\n    \n\tfloat sand=r.y-terrainH(r.xz);    \n    t=min(t,sand);\n    \n    float pyrone=sdEgyptianPyramid(r-vec3(-0.,-0.0,0.0),5.5);\n    t=min(pyrone,t);\n    \n    if (t==sand) return vec2(t,3.0);\n    if (t==pyrone) return vec2(t,4.0);\n    if (t==ufo) return vec2(t,2.0);\n\n\treturn vec2(GETFAR,-1.0);\n}\n\nvec2 SDFDesertGlow(vec3 r)\n{\n\tfloat t=GETFAR;\n\n    float vertray=GETFAR;\n    \n    float multfact=0.76;\n    if ((iTime>=ufoDownEnd)&&(iTime<rayDownEnd))\n    {\n    \tvertray=sdVerticalCapsule(r-vec3(0.0,8.5-((iTime-ufoDownEnd)*multfact),0.0),\n                                  (iTime-ufoDownEnd)*multfact,0.04);\n    }\n    else if ((iTime>=rayDownEnd)&&(iTime<fourRaysReturn))\n    {\n        vertray=sdVerticalCapsule(r-vec3(0.0,8.5-((rayDownEnd-ufoDownEnd)*multfact),0.0),\n                                  (rayDownEnd-ufoDownEnd)*multfact,0.04);\n    }\n    else if ((iTime>=fourRaysReturn)&&(iTime<zoomInEnd))\n    {\n    \tvertray=sdVerticalCapsule(r-vec3(0.0,8.5-((zoomInEnd-iTime)*multfact),0.0),\n                                  (zoomInEnd-iTime)*multfact,0.04);\n    }\n    t=min(t,vertray);\n\n    float pyrone=GETFAR;\n    \n    if ((iTime>=rayQuadEnd)&&(iTime<blackPyrEnd))\n    {\n        pyrone=sdPyramid(r-vec3(-0.,-0.0,0.0),min((iTime-rayQuadEnd),5.0));\n        float cutBox=sdBox(r-vec3(0.0,-2.5,0.0),vec3(4.0,3.0,4.0));\n        pyrone=opSubtraction(cutBox,pyrone);\n    }\n    t=min(pyrone,t);\n \n    r.x=-abs(r.x);\n    r.z=-abs(r.z);\n    float angray1=GETFAR;\n    if ((iTime>=rayDownEnd)&&(iTime<rayQuadEnd))\n    {\n    \tangray1=udTriangle(r-vec3(0.0,0.0,0.0),\n                            vec3(0.0,5.5,0.0),\n                            mix(vec3(-.4,5.0,-.4),vec3(-3.6,0.5,-3.6),clamp((iTime-rayDownEnd)/4.0,0.0,1.0)),\n                            vec3(0.0,5.51,0.0))-0.02;\n    }\n    else if ((iTime>=rayQuadEnd)&&(iTime<blackPyrEnd))\n    {\n    \tangray1=udTriangle(r-vec3(0.0,0.0,0.0),\n                            vec3(0.0,5.5,0.0),\n                            vec3(-3.6,0.5,-3.6),\n                            vec3(0.0,5.51,0.0))-0.02;\n    }\n    else if ((iTime>=blackPyrEnd)&&(iTime<fourRaysReturn))\n    {\n        angray1=udTriangle(r-vec3(0.0,0.0,0.0),\n                            vec3(0.0,5.5,0.0),\n                            mix(vec3(-3.6,0.5,-3.6),\n                                vec3(-.4,5.0,-.4),\n                                clamp((iTime-blackPyrEnd)/4.0,0.0,1.0)),\n                            vec3(0.0,5.51,0.0))-0.02;\n    }\n    \n    t=min(t,angray1);\n\n    vec3 ringCenter=vec3(0.0,8.56,0.0);\n\tif ((iTime>=ufoDownBegin)&&(iTime<ufoDownEnd))\n    {\n        ringCenter=mix(vec3(0.0,12.56,0.0),vec3(0.0,8.56,0.0),(iTime-ufoDownBegin)/(ufoDownEnd-ufoDownBegin));\n    }\n    else if (iTime>=zoomInEnd)\n    {\n        ringCenter=vec3(0.0,8.56+(iTime-zoomInEnd),0.0);\n        if (iTime>=ufoRunsAway) \n        {\n            ringCenter.x-=(iTime-ufoRunsAway)*3.0;\n            ringCenter.y+=((iTime-ufoRunsAway))*15.;\n            ringCenter.z+=8.0*(iTime-ufoRunsAway);\n        }\n    }\n    \n    float glowring=sdTorus(r-ringCenter,vec2(0.75,0.02));\n    t=min(t,glowring);\n    \n    if (t==vertray) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    if (t==pyrone) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    if (t==angray1) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    if (t==glowring) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    \n    return vec2(GETFAR,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n}\n\nvec2 SDFOpeningGlow(vec3 r)\n{\n\tfloat t=GETFAR;\n\n    vec3 grPos=vec3(6.0,0.,5.5);\n\tif ((iTime>=sceneSpaceWarpEnd)&&(iTime<sceneMovementEnd))\n    {\n        grPos=mix(vec3(0.0,0.86,-14.0),vec3(3.0,0.86,3.5),(iTime-sceneSpaceWarpEnd)/(sceneMovementEnd-sceneSpaceWarpEnd));\n    }\n    else if (iTime<ufoBehindEarth)\n    {\n        grPos=mix(vec3(3.0,0.86,3.5),vec3(6.0,0.86,6.5),(iTime-sceneMovementEnd)/(ufoBehindEarth-sceneMovementEnd));\n    }\n    \n    float glowring=sdTorus(r-grPos,vec2(0.75,0.025));\n    t=min(t,glowring);\n    \n    if (t==glowring) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    \n    return vec2(GETFAR,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n}\n\nvec2 SDFOpeningScene(vec3 r,bool onlyTransp)\n{\n\tfloat t=GETFAR;\n    vec3 origR=r;\n\n    vec3 ufo1Center=vec3(6.0,0.,5.5);\n\tif ((iTime>=sceneSpaceWarpEnd)&&(iTime<sceneMovementEnd))\n    {\n        ufo1Center=mix(vec3(0.0,0.8,-14.0),vec3(3.0,0.8,3.5),(iTime-sceneSpaceWarpEnd)/(sceneMovementEnd-sceneSpaceWarpEnd));\n    }\n    else if (iTime<ufoBehindEarth)\n    {\n        ufo1Center=mix(vec3(3.0,0.8,3.5),vec3(6.0,0.8,6.5),(iTime-sceneMovementEnd)/(ufoBehindEarth-sceneMovementEnd));\n    }\n    \n    if (onlyTransp)\n    {\n        float cup=sdSphere(r-vec3(ufo1Center.x,ufo1Center.y-0.1,ufo1Center.z),0.45);\n        float cut=sdBox(r-vec3(ufo1Center.x,ufo1Center.y-0.3,ufo1Center.z),vec3(10.0,.4,10.0));\n        cup=opSubtraction(cut,cup);\n        t=min(t,cup);\n        if (t==cup) return vec2(t,-1.0);\n        return vec2(GETFAR);\n    }\n    else\n    {\n        float ufo=sdfUfo(r-ufo1Center);\n        t=min(t,ufo);\n\n        float planetEarth=sdSphere(r-vec3(5.,-1.,1.0),2.5);\n        t=min(t,planetEarth);\n\n        if (t==planetEarth) return vec2(t,1.0);\n        if (t==ufo) return vec2(t,2.0);\n        return vec2(GETFAR,-1.0);    \n    }\n}\n\nvec2 SDFDescentGlow(vec3 r)\n{\n\tfloat t=GETFAR;\n\n    vec3 grPos=vec3(0.0,25.05,-0.5);\n    if (iTime>=fogSceneFadeIn)\n    {\n        grPos=vec3(0.0,25.05-((iTime-fogSceneFadeIn)*3.0),-0.5);\n    }\n    \n    float glowring=sdTorus(r-grPos,vec2(0.75,0.025));\n    t=min(t,glowring);\n    \n    if (t==glowring) return vec2(t,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n    \n    return vec2(GETFAR,1. / ( 1.0 + pow(abs(t*20.0),.63)));\n}\n\nvec2 SDFDescentScene(vec3 r,bool onlyTransp)\n{\n\tfloat t=GETFAR;\n    vec3 origR=r;\n\n    vec3 ufo1Center=vec3(0.0,25.,-0.5);\n    if (iTime>=fogSceneFadeIn)\n    {\n        ufo1Center=vec3(0.0,25.-((iTime-fogSceneFadeIn)*3.0),-0.5);\n    }\n    \n    if (onlyTransp)\n    {\n        float cup=sdSphere(r-vec3(ufo1Center.x,ufo1Center.y-0.1,ufo1Center.z),0.45);\n        float cut=sdBox(r-vec3(ufo1Center.x,ufo1Center.y-0.3,ufo1Center.z),vec3(10.0,.4,10.0));\n        cup=opSubtraction(cut,cup);\n        t=min(t,cup);\n        if (t==cup) return vec2(t,-1.0);\n        return vec2(GETFAR);\n    }\n    else\n    {\n        float ufo=sdfUfo(r-ufo1Center);\n        t=min(t,ufo);\n\n        float sand=r.y-terrainH(r.xz);    \n        t=min(t,sand);\n\n        if (t==sand) return vec2(t,3.0);\n        \n        if (t==ufo) return vec2(t,2.0);\n        return vec2(GETFAR,-1.0);    \n    }\n}\n\nvec3 calcNormal(vec3 pos,bool onlyTransp)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        if (iTime<ufoBehindEarth) n += e*SDFOpeningScene(pos+0.0005*e,onlyTransp)[0];\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) n += e*SDFDescentScene(pos+0.0005*e,onlyTransp)[0];\n        else n += e*SDFDesertDream(pos+0.0005*e,onlyTransp)[0];\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n\n    for (int i = 0; i < 128; i++)\n    {\n        vec2 res;\n        if (iTime<ufoBehindEarth) res = SDFOpeningScene(rayOrigin + rayDir * t,false);\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) res = SDFDescentScene(rayOrigin + rayDir * t,false);\n        else res = SDFDesertDream(rayOrigin + rayDir * t,false);\n\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(GETFAR,-1.0);\n}\n\nfloat rayMarchTransp(vec3 rayOrigin,vec3 rayDir)\n{\n    float t = 0.0;\n\n    for (int i = 0; i < numRaymarchSteps; i++)\n    {\n        vec2 res;\n        if (iTime<ufoBehindEarth) res = SDFOpeningScene(rayOrigin + rayDir * t,true);\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) res = SDFDescentScene(rayOrigin + rayDir * t,true);\n        else res = SDFDesertDream(rayOrigin + rayDir * t,true);\n        \n        if (res[0] < (0.0001*t))\n        {\n            return t;\n        }\n        t += res[0];\n    }\n     \n    return -1.0;\n}\n\nvec2 rayMarchNeon(vec3 rayOrigin, vec3 rayDir)\n{\n    float glow=0.0;\n    float t=0.0;\n    bool hit=false;\n    float thit=GETFAR;\n\n    for (int i=0;i<numRaymarchSteps;i++)\n    {\n        vec2 sdfRes;\n        if (iTime<ufoBehindEarth) sdfRes = SDFOpeningGlow(rayOrigin+rayDir*t);\n        else if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin)) sdfRes = SDFDescentGlow(rayOrigin+rayDir*t);\n        else sdfRes = SDFDesertGlow(rayOrigin+rayDir*t);\n        \n        if ((sdfRes[0] < (0.0001*t))&&(!hit))\n        {\n            hit=true; \n            thit=t;\n        }\n        t += sdfRes[0];\n        \n        float d=distance(rayOrigin+rayDir*t,rayOrigin);\n        glow+=sdfRes[1]/((d*0.08+1.0)*(d*0.08+1.0));\n    }\n    \n    return vec2(thit,glow);\n}\n\nvec2 rayMarchFog(vec3 rayOrigin, vec3 rayDir,vec2 fragCoord)\n{\n    float totalfog=0.0;\n\n    vec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    screenPos.x=-screenPos.x;\n\n    vec3 r = normalize(vec3(screenPos,.1))*.2;\n    vec3 p = vec3(rayOrigin.x,rayOrigin.y,rayOrigin.z+iTime*4.0);\n    \n\tfloat q=30.;\n\tfor(int i=0;i<100;i++)\n    {\n        vec4 t=texture(iChannel3,(p.xy+vec2(37,17)*floor(p.z)+iTime*1.5)/1000.);\n        totalfog+=mix(t.x*t.y,cos(t.y)*t.x,fract(p.z))/q;\n        q*=1.01;\n        p+=r;\n    }    \n    \n    return vec2(0.0,totalfog);\n}\n\nfloat fresnel(float bias, float scale, float power, vec3 I, vec3 N)\n{\n    return bias + scale * pow(1.0 + dot(I, N), power);\n}\n\nvec4 reflekt(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col=vec3(0.);\n\tvec3 L = normalize(vec3(.61, 0.9, -1.23 ));\n\n    vec3 finalColor=vec3(0.0);\n    vec2 rayHit = rayMarch(rayOrigin, rayDir);\n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n    \n    vec3 N=calcNormal(pHit,false);\n    float NoL = max(dot(N, L), 0.0);\n  \n    finalColor=space(rayDir,iTime,1).rgb*0.1;\n\n    return vec4(finalColor,1.0);    \n}\n\nvec4 rayMarchCycle(vec3 rayOrigin, vec3 rayDir,vec2 fragCoord,out vec3 outPhit)\n{\n    vec3 col=vec3(0.);\n\tvec3 L = normalize(vec3(.8, 1.4, -1.23 ));\n    vec3 fogcol=vec3(0.1,0.02,0.02);\n\n    vec3 finalColor=vec3(0.0);\n    \n    vec2 rayHit = rayMarch(rayOrigin, rayDir);\n    float tTransp=rayMarchTransp(rayOrigin, rayDir);\n    vec2 tNeon=rayMarchNeon(rayOrigin, rayDir);\n    vec2 tFog=rayMarchFog(rayOrigin, rayDir,fragCoord);\n    \n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n    outPhit=pHit;\n    \n    vec3 N=calcNormal(pHit,false);\n    float NoL = max(dot(N, L), 0.0);\n    float frsnl = fresnel(0.01, 2.0, 8.0, normalize(pHit - rayOrigin), N);\n\n    if (mat==1.0) // earth\n    {\n        finalColor=vec3(0.1,0.3,0.5)*frsnl*NoL;\n        finalColor+=textureEarth(rayOrigin,rayDir,rayHit[0],N);\n    }\n    else if (mat==2.0) // ufo\n    {\n        vec4 refcol=reflekt(pHit,reflect(rayDir,N));\n        //NoL=pow(NoL,64.0);\n        //finalColor=vec3(0.1,0.3,0.5)*NoL*frsnl;\n        finalColor=vec3(0.1,0.1,0.3)*NoL*frsnl;\n        //finalColor+=vec3(0.12,0.23,0.33);\n        finalColor=mix(finalColor,refcol.rgb,0.4);\n        //finalColor*=sqrt(0.17*mix(vec4(0.0),texture(iChannel2,reflect(rayDir,N)),step(dist, 1e1))).rgb;\n        finalColor*=sqrt(0.17*mix(vec4(0.0),texture(iChannel2,reflect(rayDir,N)),0.5)).rgb;\n    }\n    else if (mat==3.0) // desert\n    {\n        vec3 L = normalize( vec3(0.8,0.3,-0.3) );\n\n        vec3 lightColor = vec3(1.0);\n        vec3 sandColor = vec3(0.79,0.50,0.24);        \n    \tvec3 ambientColor = vec3(0.5);\n        \n\t\t//float shadow = desertShadow(pHit + L *0.01,L);\n        \n        vec3 normal = N;\n        normal = normalize(normal + vec3(sin(pHit.x * 100.0 + sin(pHit.z * 31.0) + sin(pHit.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rayDir;\n\n        float lambertian = max(dot(L,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(L + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * pow(texture(iChannel0,pHit.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        finalColor = .2 *( (diff + spec) + ambient);        \n\n        //vec3 spaceColor=space(rayDir,iTime).rgb*0.1;\n        //spaceColor=clamp(spaceColor,vec3(0.0),vec3(1.0));\n        \n        //vec3 shDir=normalize(L-pHit);\n        //vec2 shray=rayMarch(pHit+shDir*0.01,shDir);\n        //if ((shray[0]!=GETFAR)&&(shray[1]!=3.0)) finalColor*=0.5;\n        \n        finalColor=mix(vec3(0.0),finalColor,max(0.0,4.0/dist));\n\n        // fog over desert\n        if ((iTime>=ufoBehindEarth)&&(iTime<ufoDownBegin))\n        {\n            //fog for the descent scene\n            if (tFog[1]!=0.0)\n            {\n                if (iTime<fogFadeoutBegin) finalColor=vec3(pow(tFog[1],3.2))*.1;\n                else finalColor=mix(vec3(pow(tFog[1],3.2))*.1,finalColor,(iTime-fogFadeoutBegin)/(ufoDownBegin-fogFadeoutBegin));\n            }\n        }\n        \n    }\n    else if (mat==4.0) // pyramid\n    {\n        finalColor=vec3(0.1)*0.05*NoL;\n    }\n    else\n    {\n        // for desert scene\n\t\tvec3 pdir=normalize(pHit);\n        vec3 pstraight=normalize(vec3(0.0,1.0,0.0));\n        float nol2=dot(pdir,pstraight);\n        \n        finalColor=space(rayDir,iTime,0).rgb*0.1;\n        \n        vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n        if ((iTime>=warpOutBegin)&&(iTime<thatsAllFolks)) \n        {\n            vec3 sw=spaceWarp(iTime+4.5,uv).rgb;\n            finalColor=mix(finalColor,\n                           sw,\n                           min((iTime-warpOutBegin)/(warpOutEnd-warpOutBegin),1.0));\n        }\n        \n        if ((iTime>=ufoDownBegin)) finalColor*=nol2;\n\t}\n    \n    if (tNeon[1]>0.0)\n    {\n        if ((tNeon[0]==GETFAR)&&((mat==4.0)||(mat==2.0)||(mat==1.0))) ;\n        else if ((tNeon[0]==GETFAR)||(tNeon[0]<dist)||(dist==GETFAR))\n        {\n            finalColor+=vec3(0.04,0.04,0.16)*tNeon[1];\n        }\n    }\n    \n    if (tTransp!=-1.0)\n    {\n        if ((tTransp<dist)||(dist==GETFAR))\n        {\n    \t\tvec3 N2=calcNormal(rayOrigin+rayDir*tTransp,true);\n        \tfloat frsnl = fresnel(.2, 8.0, 7.0, normalize((rayOrigin+rayDir*tTransp) - rayOrigin), N2);\n            //float dot2=max(dot(N2,L),0.0);\n            //dot2=pow(dot2,24.0);\n            finalColor+=vec3(0.01)+vec3(0.32,0.2,0.2)*frsnl;\n        }\n    }\n    \n    return vec4(finalColor,1.0);    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    screenPos.x=-screenPos.x;\n  \n    vec3 camPos;\n\tvec3 camTarget;\n    float camRot=0.0;\n \n    if ((iTime>=sceneFadeInBegin)&&(iTime<sceneSpaceWarpEnd))\n    {\n        camPos=vec3(-1.01,2.5,-5.5);\n        camTarget = vec3(0.0,0.8,-14.0);\n    }\n    else if ((iTime>=sceneSpaceWarpEnd)&&(iTime<sceneMovementEnd))\n    {\n        // camera follows ufo\n        camPos=vec3(-1.01,2.5,-5.5);\n        camTarget=mix(vec3(0.0,0.8,-14.0),vec3(3.0,0.8,3.5),(iTime-sceneSpaceWarpEnd)/(sceneMovementEnd-sceneSpaceWarpEnd));\n    }\n    else if (iTime<ufoBehindEarth)\n    {\n        // camera follows ufo\n        camPos=vec3(-1.01+(iTime-sceneMovementEnd),2.5-(iTime-sceneMovementEnd),-5.5);\n        camTarget=mix(vec3(3.0,0.8,3.5),vec3(6.0,0.8,6.5),(iTime-sceneMovementEnd)/(ufoBehindEarth-sceneMovementEnd));\n    }\n    // descent scene\n    else if ((iTime>=ufoBehindEarth)&&(iTime<fogFadeoutBegin))\n    {\n        camPos=vec3(0.0,28.5-(ufoBehindEarth-sceneMovementEnd),-1.);\n        camTarget=vec3(0.0,2.0,1.0);\n    }\n    else if ((iTime>=fogFadeoutBegin)&&(iTime<ufoDownBegin))\n    {\n    \tcamPos=vec3(0.0,28.5-(ufoBehindEarth-sceneMovementEnd)-((iTime-fogFadeoutBegin)*3.0),-1.0-(iTime-fogFadeoutBegin));\n    \tcamTarget=vec3(0.0,2.0,1.0);\n    }\n    // desert dream scene\n    else if ((iTime>=ufoDownBegin)&&(iTime<ufoDownEnd))\n    {\n    \tcamPos=vec3(0.0,6.0+((iTime-ufoDownBegin)*2.0),-5.0);\n    \tcamTarget=vec3(0.0,8.5,0.0);\n    }\n    else if ((iTime>=ufoDownEnd)&&(iTime<rayQuadEnd))\n    {\n    \tcamPos=vec3(sin(iTime/2.0)*8.0,10.0-(iTime-ufoDownEnd),cos(iTime/2.0)*6.0);\n    \tcamTarget=vec3(0.0,5.0,0.0);\n    }\n    else if ((iTime>=rayQuadEnd)&&(iTime<pyrGrowingEnd))\n    {\n    \tcamPos=vec3(sin(iTime/2.0)*8.0,10.0-(rayQuadEnd-ufoDownEnd),cos(iTime/2.0)*6.0);\n    \tcamTarget=vec3(0.0,5.0,0.0);\n    }\n    else if ((iTime>=pyrGrowingEnd)&&(iTime<blackPyrEnd))\n    {\n    \tcamPos=vec3(sin(iTime/2.0)*8.0,10.0-(rayQuadEnd-ufoDownEnd)+(iTime-pyrGrowingEnd),cos(iTime/2.0)*6.0);\n    \tcamTarget=vec3(0.0,5.0,0.0);\n    }\n    else if ((iTime>=blackPyrEnd)&&(iTime<zoomInEnd))\n    {\n    \tcamPos=vec3(-4.0+(iTime-blackPyrEnd),3.0+(iTime-blackPyrEnd),-13.0);\n    \tcamTarget=vec3(0.0,3.0,0.0);\n    }\n    else\n    {\n    \tcamPos=vec3(0.0,3.0+(iTime-zoomInEnd),-13.0+(iTime-zoomInEnd)*0.5);\n    \tcamTarget=vec3(0.0,3.0+(iTime-zoomInEnd)*1.5,0.0);\n    }\n    \n    mat3 ca = setCamera( camPos, camTarget, camRot );\n    vec3 rayDir = ca * normalize( vec3(screenPos.xy,1.5));\n    \n    vec3 outPhit;\n    \n    vec4 marchCol=rayMarchCycle(camPos, rayDir,fragCoord,outPhit);\n    marchCol.xyz*=0.65;\n    marchCol.xyz=ACESFilm(marchCol.xyz);\n    marchCol.xyz=LinearToSRGB(marchCol.xyz*1.2);\n    marchCol=pow(marchCol,vec4(0.45454));\n \n    if (iTime<sceneFadeInEnd) marchCol=mix(vec4(0.0),marchCol,iTime/(sceneFadeInEnd-sceneFadeInBegin));\n\tif ((iTime>=fadeOutEarthBegin)&&(iTime<ufoBehindEarth)) marchCol=mix(marchCol,vec4(0.0),(iTime-fadeOutEarthBegin)/(ufoBehindEarth-fadeOutEarthBegin));\n\tif ((iTime>=ufoBehindEarth)&&(iTime<fogSceneFadeIn)) marchCol=vec4(0.0);\n    if ((iTime>=fogSceneFadeIn)&&(iTime<fogFadeoutBegin)) marchCol=mix(vec4(0.0),marchCol,(iTime-fogSceneFadeIn)/(fogFadeoutBegin-fogSceneFadeIn));\n    if (iTime>=finalFadeOut) marchCol=mix(marchCol,vec4(0.0),(iTime-finalFadeOut)/(thatsAllFolks-finalFadeOut));\n    if (iTime>=thatsAllFolks) marchCol=vec4(0.0);\n    fragColor = marchCol;\n}\n", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 217, 217, 420], [422, 422, 478, 478, 971]], "test": "untested"}
{"id": "3lsyWs", "name": "Logarithmic Moebius Transform 8g", "author": "FabriceNeyret2", "description": "golfing 522 chars [url]https://shadertoy.com/view/WtlyWs[/url]\ninspired by [url]https://www.facebook.com/eric.wenger.547/videos/2727028317526304/[/url]", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "golf", "reproduction", "3tweets"], "likes": 9, "viewed": 376, "published": 3, "date": "1593449336", "time_retrieved": "2024-07-30T20:58:38.292677", "image_code": "// golfing 522 chars https://shadertoy.com/view/WtlyWs\n\nvoid mainImage(out vec4 O, vec2 u) {                                                \\\n    vec2 R = iResolution.xy, U = ( u+u - R ) / R.y,\n\t     z = U + O.wx;  U.x -= .5;\n    U *= mat2(z,-z.y,z) / dot(U,U);\n    z = U =   log( dot(U+=.5,U) ) / vec2(4,-2) + iTime/vec2(8,4)\n            + atan(U.y,U.x)/6.2832 *vec2(6, 2);\n    U = fract(U*1.5)*5.;\n    int y = int(U.y) , x = ( int(U) + 3*y ) % 5;\n    O = vec4( x<4 ? U = ( fract(U) + vec2(x%2,x<2) ) / 2.,\n                   (x/2+y) % 5 : 5 ) *.1\n      * min(1. - max(U= abs(fract(U)*2.-1.)-.95, U.y) / min(fwidth(z/.1),.3), 2.).x;\n}\n//   better AA without discont:    z=fwidth(U)        / (abs(z.x-z.y)>1.?.1:z.y/.1)", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtlyWs", "name": "Logarithmic Moebius Transform 8", "author": "FabriceNeyret2", "description": "inspired by [url]https://www.facebook.com/eric.wenger.547/videos/2727028317526304/[/url]", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 19, "viewed": 607, "published": 3, "date": "1593447033", "time_retrieved": "2024-07-30T20:58:39.193269", "image_code": "// variant of https://shadertoy.com/view/3llcDl\n// inspired by https://www.facebook.com/eric.wenger.547/videos/2727028317526304/\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I,\n         U = (2.*u - R) / R.y,                                // normalized coordinates\n\t     z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n              \n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.2832 * vec2(6, 1);        \n\t                               // n  \n    U *= 3./vec2(2,1); z = fwidth(U);\n    U = fract(U)*5.; I = floor(U); U = fract(U);              // subdiv big square in 5x5\n    I.x = mod( I.x - 2.*I.y , 5.);                            // rearrange\n    U.x += float(I.x==1.||I.x==3.); U.y += float(I.x<2.);     // recombine big tiles\n    float id = -1.;\n    if (I.x!=4.) U /= 2.,                                     // but small times\n        id = mod(floor(I.x/2.)+I.y,5.);\n    U = abs(fract(U)*2.-1.); float v = max(U.x,U.y);          // dist to border\n    O =   smoothstep(.7,-.7, (v-.95)/( abs(z.x-z.y)>1.?.1:z.y*8.))  // draw AA tiles\n        * (id<0.?vec4(1): .6 + .6 * cos( id  + vec4(0,23,21,0)  ) );// color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 167, 167, 1317]], "test": "untested"}
{"id": "WllyWs", "name": "Basic Slider", "author": "MrOkiDoki", "description": "ahm, slider ? ", "tags": ["slider"], "likes": 4, "viewed": 736, "published": 3, "date": "1593446999", "time_retrieved": "2024-07-30T20:58:40.267397", "image_code": "\nvec4 DrawSlider(vec2 uv,float width,float height,float value)\n{\n    vec4 col = vec4(0.);\n    if(abs(uv.y) < height && abs(uv.x) < width)\n        \n        if(uv.x+width < value*width*2.)\n            col = vec4(mix(vec3(1,0,0),vec3(0,1.,0),value),1);\n        else\n        \tcol = vec4(.1,.1,.1,1);\n    return col;\n}\n\nconst float width = 0.4;\nconst float height = 0.02;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.x;\n    \n    float v = iMouse.x / iResolution.x;\n\n    //Remap value by slider width\n    v-=0.5;\n    v *= 1. / (width * 2.);\n    v+= .5;\n    v = clamp(v,0.,1.);\n\t\n    \n    fragColor = DrawSlider(uv,width,height,v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 64, 64, 313], [368, 368, 425, 425, 699]], "test": "untested"}
{"id": "3llcDl", "name": "Logarithmic Moebius Transform 7", "author": "FabriceNeyret2", "description": "variant of https://shadertoy.com/view/4dySW3", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm"], "likes": 7, "viewed": 401, "published": 3, "date": "1593444678", "time_retrieved": "2024-07-30T20:58:41.278693", "image_code": "// variant of https://shadertoy.com/view/4dySW3\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 z = iResolution.xy, A = vec2(2,1),                   // brick aspect\n         U = (2.*u - z) / z.y;                                // normalized coordinates\n    \n\tz = U - vec2(-1,0);  U.x -= .5;                           // Moebius transform\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n              \n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.2832 * vec2(6, 1);        \n\t                               // n  \n    z = U *= 3./A; \n    if ( fract(iTime/10.)>.5 ) U=U.yx;                        // bricks direction\n    if ( fract(U.y) > .5 ) U.x+=.5;                           // bricking\n    U *= 2./A;\n    U = (1.-abs(fract(U)*2.-1.))*A; float v = min(U.x,U.y);   // dist to border\n    O = texture(iChannel0,z).rrrr;                            // grain\n    O =   smoothstep(-.7,.7, (v-.05)/min(.3,fwidth(z.y*4.)))  // draw AA bricks\n        * vec4(.6,.2,0,0) * (.5+.5*O) + .3*O;                 // color & grain\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 1116]], "test": "untested"}
{"id": "wlscWX", "name": "Pyramid Pattern", "author": "Shane", "description": "An offset grid of square-based pyramids whose tips have been offset according to an underlying directional noise field. The faux lighting is provided via bump mapping. No raymarching was harmed during the making of this example. :)", "tags": ["square", "bump", "pattern", "pyramid"], "likes": 55, "viewed": 1454, "published": 3, "date": "1593433426", "time_retrieved": "2024-07-30T20:58:42.123435", "image_code": "/*\n\n\tPyramid Pattern\n\t---------------\n\t\n    An animated pyramid pattern, which is based on old code that I \n    quickly repurposed after looking at Oggbog's \"Flipping triangles\" \n    example.\n\n\tI've departed from the original considerably, but it's essentially \n    the same thing. The pyramid centers have been offset in correlation \n    with a directional gradient that indexes an underlying noise \n    function. I've applied some exaggerated bumped highlighting to give \n    the pattern a sharp abstract scaly appearance.\n\n    The cells are arranged in a square grid with each alternate row \n    offset by half a cell to give a more distributed feel. In fact, I \n    almost coded a hexagonal version, but figured this had more of an \n    angular feel.\n\n\tI've commented the code, but there's nothing in here that's\n\tparticularly taxing on the brain. If I had it my way, I'd code \n    simple little geometric patterns all day, since it's kind of \n    therapeutic, but I've got some so-called hard stuff to get back\n\tto... Well, it's hard for me anyway. :)\n     \n\n\n\t// Here's a much simpler version.\n    Offset Pyramid Squares - Shane\n\thttps://www.shadertoy.com/view/tlXcDs\n\n    // Great motion: I sometimes go overboard with bells and \n    // whistles, whereas this is elegantly simple.\n\tPyramid torsion - AntoineC\n    https://www.shadertoy.com/view/lsVczK\n\n\t// Inspired by:\n    Flipping triangles - Oggbog\n\thttps://www.shadertoy.com/view/ttsyD2\n\n\n*/\n\n// Offsetting alternate rows -- I feel it distributes the effect more,\n// but if you prefer more order, comment out the following:\n#define OFFSET_ROW\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\nvec2 cellID; // Individual Voronoi cell IDs.\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    //return sin( p*6.2831853 + iTime ); \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22B(i), p);\n    v.y = dot(hash22B(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22B(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22B(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.66 + n2D3G(p*2.)*.34; }\n\n\nfloat bMap(vec2 p){\n    \n    // Put the grid on an angle to interact with the light a little better.\n    p *= rot2(-3.14159/5.);\n   \n    #ifdef OFFSET_ROW\n    // Tacky way to construct an offset square grid.\n    if(mod(floor(p.y), 2.)<.5) p.x += .5;\n    #endif\n\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Recording the cell ID.\n    cellID = ip;\n\n    // Transcendental angle function... Made up on the spot.\n    //float ang = dot(sin(ip/4. - cos(ip.yx/2. + iTime))*6.2831, vec2(.5));\n    \n    // Noise function. I've rotated the point around a bit so that the \n    // objects hang down due to gravity at the zero mark.\n    float ang = -3.14159*3./5. + (fBm(ip/8. + iTime/3.))*6.2831*2.;\n    // Offset point within the cell. You could increase this to cell edges\n    // (.5), but it starts to look a little weird at that point.\n    vec2 offs = vec2(cos(ang), sin(ang))*.35;\n     \n    // Linear pyramid shading, according to the offset point. Basically, you\n    // want a value of zero at the edges and a linear increase to one at the \n    // offset point peak. As you can see, I've just hacked in something quick \n    // that works, but there'd be more elegant ways to achieve the same.\n    if(p.x<offs.x)  p.x = 1. - (p.x + .5)/abs(offs.x  + .5);\n    else p.x = (p.x - offs.x)/(.5 - offs.x);\n\n    if(p.y<offs.y) p.y = 1. - (p.y + .5)/abs(offs.y + .5);\n    else p.y = (p.y - offs.y)/(.5 - offs.y);\n\n    // Return the offset pyramid distance field. Range: [0, 1].\n    return 1. - max(p.x, p.y);\n}\n\n\n// Standard function-based bump mapping function, with an edge value \n// included for good measure.\nvec3 doBumpMap(in vec2 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    // Sample difference. Usually, you'd have different ones for the gradient\n    // and the edges, but we're finding a happy medium to save cycles.\n    vec2 e = vec2(.025, 0);\n    \n    float f = bMap(p); // Bump function sample.\n    float fx = bMap(p - e.xy); // Same for the nearby sample in the X-direction.\n    float fy = bMap(p - e.yx); // Same for the nearby sample in the Y-direction.\n    float fx2 = bMap(p + e.xy); // Same for the nearby sample in the X-direction.\n    float fy2 = bMap(p + e.yx); // Same for the nearby sample in the Y-direction.\n    \n    vec3 grad = (vec3(fx - fx2, fy - fx2, 0))/e.x/2.;   \n    \n    // Edge value: There's probably all kinds of ways to do it, but this will do.\n    edge = length(vec2(fx, fy) + vec2(fx2, fy2) - f*2.);\n    //edge = (fx + fy + fx2 + fy2 - f*4.);\n    //edge = abs(fx + fx2 - f*2.) + abs(fy + fy2 - f*2.);\n    //edge /= e.x;\n    edge = smoothstep(0., 1., edge/e.x);\n     \n    // Applying the bump function gradient to the surface normal.\n    grad -= n*dot(n, grad);          \n    \n    // Return the normalized bumped normal.\n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Unit direction vector. Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    // Scaling and tranlation.\n    const float gSc = 10.;\n    vec2 p = uv*gSc + vec2(0, iTime/2.);\n    vec2 oP = p; // Saving a copy for later.\n    \n    \n    // Take a function sample.\n    float m = bMap(p);\n    \n    vec2 svID = cellID;\n  \n    // Face normal for and XY plane sticking out of the screen.\n    vec3 n = vec3(0, 0, -1);\n    \n    // Bump mapping the normal and obtaining an edge value.\n    float edge = 0., bumpFactor = .25;\n    n = doBumpMap(p, n, bumpFactor, edge);\n   \n    // Light postion, sitting back from the plane and animated slightly.\n\tvec3 lp =  vec3(-0. + sin(iTime)*.3, .0 + cos(iTime*1.3)*.3, -1) - vec3(uv, 0);\n    \n    // Liight distance and normalizing.\n    float lDist = max(length(lp), .001);\n    vec3 ld = lp/lDist;\n    // Unidirectional lighting -- Sometimes, it looks nicer.\n    //vec3 ld = normalize(vec3(-.3 + sin(iTime)*.3, .5 + cos(iTime*1.3)*.2, -1));\n\t\n\t// Diffuse, specular and Fresnel.\n\tfloat diff = max(dot(n, ld), 0.);\n    diff = pow(diff, 4.);\n    float spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 16.);\n\t// Fresnel term. Good for giving a surface a bit of a reflective glow.\n    float fre = min(pow(max(1. + dot(n, rd), 0.), 4.), 3.);\n    \n\n    // Applying the lighting.\n    vec3 col = vec3(.15)*(diff + .251 + spec*vec3(1, .7, .3)*9. + fre*vec3(.1, .3, 1)*12.);\n    \n    \n    // Some dodgy fake reflections. This was made up on the fly. It's no sustitute for reflecting\n    // into a proper back scene, but it's only here to add some subtle red colors.\n    float rf = smoothstep(0., .35, bMap(reflect(rd, n).xy*2.)*fBm(reflect(rd, n).xy*3.) + .1);\n    col += col*col*rf*rf*vec3(1, .1, .1)*15.;\n    \n    /*\n    // Random blinking lights. Needs work. :)\n    float rnd = hash21(svID);\n    float rnd2 = hash21(svID + .7);\n    rnd = sin(rnd*6.2831 + iTime*1.);\n    col *= mix(vec3(1), (.5 + .4*cos(6.2831*rnd2 + vec3(0, 1, 2)))*6., smoothstep(.96, .99, rnd));\n    */\n    \n     // Using the distance function value for some faux shading.\n    float shade = m*.83 + .17;\n    col *= shade;\n    \n    // Apply the edging from the bump function. In some situations, this can add an\n    // extra touch of dimension. It's so easy to apply that I'm not sure why people \n    // don't use it more. Bump mapped edging works in 3D as well.\n    col *= 1. - edge*.8;\n    \n    // Apply a cheap but effective hatch function.\n    float hatch = doHatch(oP/gSc, iRes);\n    col *= hatch*.5 + .7;\n    \n    // Just the distance function.\n    //col = vec3(m);\n   \n  \n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    //col = mix(col*vec3(.25, .5, 1)/8., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1605, 1638, 1660, 1660, 1718], [1721, 1749, 1770, 1770, 1833], [1883, 1905, 1927, 2276, 2412], [2414, 2455, 2480, 2522, 2968], [2970, 2994, 3012, 3012, 3053], [3056, 3056, 3075, 3156, 4603], [4606, 4706, 4779, 4933, 5915], [5918, 5995, 6028, 6119, 6500], [6502, 6502, 6556, 6614, 9603]], "test": "untested"}
{"id": "ttfcDl", "name": "SDF Heart", "author": "ianwall", "description": "Heart SDF\n\n", "tags": ["sdf", "heart"], "likes": 1, "viewed": 338, "published": 3, "date": "1593400877", "time_retrieved": "2024-07-30T20:58:43.078881", "image_code": "float sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n    \n\treturn d;\n}\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n#define PI 3.1415926\nfloat sdHeart(in vec2 p, in float radius) {\n\tfloat offset = 3.0-2.0*sqrt(2.0);\n\tfloat extra = 0.05;\n\tvec2 center = vec2(0.0, offset+extra);\n    float r = 1.0-center.y;\n    \n    // Construct the heart in normalized coordinates where radius of inner circle is 1.0\n\tvec2 _p = (p/radius)*r+center;\n    \n    float br = sqrt(2.0)/2.0;\n    float d = sdRhombus( _p, vec2(1.0) );\n\tfloat dc1 = sdCircle( _p-vec2(0.5, 0.5), br );\n\tfloat dc2 = sdCircle( _p-vec2(-0.5, 0.5), br );\n\n/*\n\tif(dc1 < 0.0 && d < 0.0)\n        d = min(d, -sdArc(_p-vec2(0.5, 0.5), vec2(sin(3.0*PI/4.0), cos(3.0*PI/4.0)), vec2(sin(PI/2.0), cos(PI/2.0)), br, 0.0));\n    else\n        d = min(d, dc1);\n                      \n    if(dc2 < 0.0 && d < 0.0)\n        d = min(d, -sdArc(_p-vec2(-0.5, 0.5), vec2(sin(PI/4.0), cos(PI/4.0)), vec2(sin(PI/2.0), cos(PI/2.0)), br, 0.0));\n    else\n        d = min(d, dc2);\n*/\n\n    d = min(min(d,dc1),dc2);\n\tif(_p.y < 0.0) d += 1.5*abs(_p.x)*abs(_p.y)*abs(_p.y)*r*r\n        ; // pull the sides of the heart inward\n\n    // Fix scaling\n    return d*radius/r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tp /= 0.75;\n\t\n    float radius = 0.7 + 0.1*sin(10.0*iTime);\n    float d = sdHeart(p, radius);\n    \n    vec3 col = sign(-d)*vec3(1.0,0.0,0.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.010,abs(d)));\n\n    //col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.010,abs(sdCircle(p, 0.01))));\n    //col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.010,abs(sdCircle(p, radius))));\n    //col *= 0.8 + 0.2*cos(128.0*abs(d));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 68], [70, 70, 99, 99, 127], [129, 129, 171, 171, 384], [386, 465, 543, 543, 727], [750, 750, 793, 793, 1801], [1803, 1803, 1860, 1860, 2368]], "test": "untested"}
{"id": "WtfyDs", "name": "DiHydrogen ion ground state", "author": "michael0884", "description": "Solving the time-independent Schrodinger equation by using the time rotated time-dependent equation.", "tags": ["simulation", "field"], "likes": 6, "viewed": 421, "published": 3, "date": "1593380410", "time_retrieved": "2024-07-30T20:58:44.117105", "image_code": "vec3 colormap(vec3 x)\n{\n    return 0.5 - 0.5*cos(x);\n}\n\nvoid mainImage( out vec4 col, in vec2 p )\n{\n    vec4 psi = 0.2*texel(ch0, p);\n    \n    //wave function\n    col.xyz = sqrt(      psi.x*psi.x*vec3(1,2,3) \n                   + abs(psi.y*psi.y)*vec3(3,2,1)\n                   + abs(psi.z*psi.z)*vec3(2,3,1));\n\t\n    //electron density\n    //col.xyz = vec3(dot(psi.xyz, psi.xyz));\n    \n    //electric field\n    //col.xyz = 0.1*abs(psi.zzz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 0.8\n\nfloat G(vec2 x, float r)\n{\n    x/=r;\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x, float r)\n{\n    return exp(-length(x/r));\n}", "buffer_a_code": "float U(vec2 p, vec2 c)\n{\n    return -1./(1. + distance(c, p));\n}\n\nvoid mainImage( out vec4 Psi, in vec2 p )\n{\n    Psi = texel(ch0, p);\n    \n    //Laplacian operator\n    vec4 L = 0.25*(texel(ch0, p+vec2(1,0)) + texel(ch0, p-vec2(1,0)) +\n                   texel(ch0, p+vec2(0,1)) + texel(ch0, p-vec2(0,1))) - Psi;\n\t\n    //diffusing the wave function, \n    //its the imaginary time schrodinger equation\n    Psi.xyz += dt*(L.xyz - 0.05*Psi.xyz*( U(p, R*vec2(0.47, 0.5)) + //proton 1\n                   U(p, R*vec2(0.53, 0.5)) + //proton 2\n                   0.01*Psi.z) - //electron repulsion\n                   0.01*Psi.xyz*(Psi.yzx + Psi.zxy)); //pauli exclusion principle;\n        \n    //electron electric field, solving the Poisson equation using the Jacobi method\n    Psi.w += 0.9*L.w - 0.001*dot(Psi.xyz,Psi.xyz);\n    \n    \n    //pseudo-renormalization\n    float lvl = 5.;\n    Psi.xyz /= textureLod(ch0, vec2(0.5), lvl).xyz;\n    \n    if(iFrame == 0)\n    {\n        Psi.xyz = vec3(1., 0., 0.)*G(p - R*0.5, 20.) \n                + vec3(0., 1., 0.)*G(p - R*0.45, 100.)\n                + vec3(0., 0., 1.)*G(p - R*0.51, 60.);\n        Psi.w = 0.;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 54], [56, 56, 99, 99, 442]], "test": "untested"}
{"id": "tllyWX", "name": "Generative Vasarely - Oet-Oet", "author": "ciphered", "description": "As a tribute to Victor Vasarely, a challenge to myself, and one of these urges, I wanted to recreate some works of Vasarel. I posted some of these recreations on my Instagram, feel free to check it out: @ciphrd", "tags": ["generative", "vasarely"], "likes": 4, "viewed": 397, "published": 3, "date": "1593376350", "time_retrieved": "2024-07-30T20:58:45.032656", "image_code": "//\n// A generative recreation of the work Oet-Oet 1955, Victor Vasarely\n// https://i.pinimg.com/originals/04/9b/89/049b89f9d063aeaa88b5f55633553ddd.jpg\n//\n//\n// I tried to focus on the mechanical motion and squares arrangements\n// Nothing else\n//\n// From a series \"Generative Vasarely\", in which I try to explore the work of \n// Victor Vasarely using generative systems.\n// https://instagram.com/ciphrd\n//\n\n\n#define PI \t\t\t3.14159265339\n#define PI4 \t\tPI*.25\n#define hash21(n)  \tfract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453)\n#define rot(a) \t\tmat2(cos(a), -sin(a), sin(a), cos(a))\n\nconst int ITERATIONS = 12;\nconst float LINE_WIDTH = .01;\nconst float LINE_THRESHOLD = .25;\n\n\nfloat band (in vec2 id) {\n    return step(hash21(id.xy), LINE_THRESHOLD);\n}\n\n// @author Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// @author Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    vec2 auv = abs(uv);\n    \n    \n    // a timer value for sequencing\n    float t = iTime / 60.;\n    \n    \n    // the line width oscillates to add a perpetual motion\n    float lw = LINE_WIDTH * (1. + cos(iTime) * .3 + mod(t, .3) * clamp(cos(iTime*4.), -.2, .2) * .8);\n    \n    \n    // a layer of lines\n    vec2 divs = uv / lw;\n    divs.x*= 1. + clamp(cos(iTime), -.1, .1);\n    divs.x*= 1. + clamp(cos(iTime), -.5, .5) * .3;\n    vec2 id = floor(divs);\n    vec2 divs2 = uv / lw * .5;\n    vec2 id2 = floor(divs);\n    \n    \n    // slow animation of the bands\n    // does it work on every machine ?\n    id.x+= (iTime+10.0) * (.00000015 * (cos(iTime*.1)*.2 + 1.));\n    \n    float c = 0.0,\n          a;\n    \n    vec2 s;\n    \n    // we iterate to create layers, and mask more or less\n    for (int i = 0; i < ITERATIONS; i++) {\n        float fi = mod(float(i) + floor(iTime * .1), float(ITERATIONS));\n    \tid.y = fi * 7.;\n    \tid2.y = fi * 7.;\n        float l = max(band(id), band(id2));\n        float mask = 0.0;\n        \n        // first layer, every pixel gets through\n        if (i==0) mask = 1.0;\n        \n        // second layer, only top and bottom gets through\n        else if (i == 1) mask = step(0.3, auv.y);\n        \n        // otherwise, mask will be a rectangme rotated n * PI/2\n        else {\n            float fa = floor(hash11(fi*2.2)*20.)\n            \t\t \t+ clamp(cos(iTime + fi), -.2, .2) / .2\n            \t\t\t+ clamp(cos((iTime+fi) * .5), -.1, .1) / .1;\n\t\t\ta = fa * PI4;\n            vec2 center = hash12(fi*1.5) * .3 - .15;\n            center.x+= cos(iTime+fi) * .1 + cos(iTime*4.+fi) * .05 + cos(iTime*8.+fi) * .01;\n            vec2 tuv = uv * rot(a) + center;\n            vec2 f = vec2(hash11(fi*2.) * .25 + .05);\n            s = smoothstep(f, f+0.0001 * cos(iTime), abs(tuv));\n            mask = s.x * s.y;\n        };\n\n        c = mix(c, l, mask);\n    }\n    \n    \n    // periodic inversion synced to the strenching\n    \n    c = mix(c, (1.-c), step(.08, t) * round(cos(iTime) *.5+.5));\n    \n    \n    // square\n    c*= step(auv.x, .5);\n    s = step(auv, vec2(.4));\n    float inside = s.x*s.y;\n    c*= inside;\n    \n    // background\n    c+= clamp(pow((1.-length(uv)), .2)* 1.1, .2, 1.) * (1. - inside);\n    c+= hash21(uv) * .1;\n    \n    // border\n    s = step(auv, vec2(0.42));\n    c-= s.x*s.y - inside;\n    \n    vec3 color = vec3(uv, c);\n    \n    color*= step(auv.x, .5);\n\n    // Output to screen\n    fragColor = c * vec4(1., 1., 0.92, 1.);\n    //fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[681, 681, 706, 706, 756], [758, 823, 845, 845, 974], [976, 1041, 1064, 1064, 1149], [1152, 1152, 1209, 1209, 3759]], "test": "untested"}
{"id": "WlfyWs", "name": "Day 191", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 11, "viewed": 358, "published": 3, "date": "1593376038", "time_retrieved": "2024-07-30T20:58:45.874406", "image_code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./50.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[11](7.2*speed,4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 1.2*speed, 1.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    //t += sumScenes(0.)- 0.;\n    \n    t = mod(t, sumScenes(7.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*0.25;\n    \n    float its = 12.;\n    float scene = 0.;\n    \n    vec2 p = uv;\n\n    vec4 q = vec4(p,1,1);\n\n    float dt = 10e5;\n    float dFirst = 10e5;\n\n    for(float i = 0.; i < its; i++){\n        float tsc = i/its*1.5;\n        float enva = eass((t - tsc)/scenes[0]*1.5,3.);\n\n        float envb = eass((t - tsc - scenes[0])/scenes[1]*2.,3.);\n\n        float envc = eass((t - tsc - sumScenes(1.))/scenes[2]*1.,3.);\n        float envd = eass((t - tsc - sumScenes(2.))/scenes[3]*1.,3.);\n\n        float enve = eass((t - tsc - sumScenes(3.))/scenes[4]*1.,3.);\n\n        float envf = eass((t - tsc - sumScenes(4.))/scenes[5]*1.,5.);\n\n        float envg = eass((t - tsc - sumScenes(5.))/scenes[6]*1.,3.);\n\n        float envh = eass((t - tsc - sumScenes(6.))/scenes[7]*1.,3.);\n\n        vec2 b = p;\n\n        float ld = 10e5;\n\n        \n        b *= rot(0. );\n        //b = mix(b,abs(b),1.);\n\n        b -= 0. ;\n        \n        b *= rot(pi*0.25*envc - pi*0.25*envf );\n\n        b *= rot(enva*pi/2. - pi/2.*envf );\n\n        float dc = length(b - 0.1) - 0.01 ;\n        dc = min(dc, (length(b + vec2(0.01,0.15)) - 0.02)) ;\n\n        dc = min(dc, abs(length(b - vec2(-0.3,0.15)) - 0.06)) ;\n\n        dc = min(dc, (length(b - vec2(-0.1,0.15)) - 0.02)) ;\n\n        float itsifs = 0. + envb*1. - envf*1.;\n        for(float i = 0.; i < itsifs + 1.; i++){\n            vec2 f = abs(b);\n            f.y -= 0.2 - 0.2*envf - 0.2*envb*(1.-envc) ;\n            f *= rot(-0.25*pi  );\n            b = mix(b,f,smoothstep(0.,1.,itsifs - i));\n\n        }\n\n        b.xy *= rot(tau*i/its/1.  );\n\n        //b.y -= 0.3;\n        //b.y += 0.2*enva;\n\n        //b.y += sin((i)/1. - t*pi)*0.1;\n        //b.xy *= rot(i*0.4 + iTime/3.);\n\n        vec2 g = b;\n        ld = min(ld,sdBox(b,vec2(0.0,1.)));\n        \n        ld = max(ld, mod(length(b) ,0.2 - 0.1*envc   + envf*0.1) - 0.1);\n        \n        ld = max(ld,-length(b) + 0.3- 0.1*envc + envf*0.1 );\n        \n        ld = min(ld,dc);\n        \n        \n        //ld = min(ld, max(abs(length(b) - 0.14), -mod(atan(p.y,p.x),0.6) + 0.4 ));\n        \n        \n        \n        b = abs(b) - vec2(0,.2 - envb*0.1 + envf*0.1 );\n\n        vec4 q = vec4(b,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n\n        q = pmod(abs(q),0.04);\n\n        float dbq = sdBox(q,vec4(0.02));\n\n        \n        \n        ld = min(ld,abs(mix(length(b - vec2(-0.01,0.04)) - 0.01, abs(dbq) - 0.00,0.5)) );\n        \n        //ld = min(ld,abs(mix(length(b - vec2(0.06,-0.1)) - 0.01, abs(dbq) + 0.06,0.1)) );\n        \n        float slider = smoothstep(0.,1.,i/its*0.9 + 0.1)*1.;\n\n        \n        float ldb = ld;\n        ld = mix(ld,abs(dbq),slider);\n\t\t\n        \n        ld = mix(ld,max(ld,ldb),slider);\n\n        dt = min(dt,abs(ld));\n\n        dt = mix(dt, abs(pmod(dt ,0.04 )) ,slider);\n\n\n    }\n    d = min(d,dt); \n    d = min(d,dFirst);\n\n    d = abs(d);\n\n\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 318, 318, 374], [377, 388, 425, 425, 733], [734, 734, 771, 771, 818], [819, 819, 856, 856, 921], [976, 976, 1028, 1028, 1147], [1327, 1327, 1355, 1355, 1462], [1464, 1464, 1533, 1533, 1689], [1690, 1690, 1720, 1720, 1829], [1891, 1891, 1918, 1918, 5120]], "test": "untested"}
{"id": "ttsyWf", "name": "Juliabrot Tomography", "author": "dr2", "description": "Inside and outside views of the quaternion Julia set for f(q) = q^3 + c", "tags": ["fractal", "julia", "quaternion"], "likes": 16, "viewed": 564, "published": 3, "date": "1593337874", "time_retrieved": "2024-07-30T20:58:46.781979", "image_code": "// \"Juliabrot Tomography\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Inside and outside views of the quaternion Julia set for f(q) = q^3 + c\n Mousing recommended\n Based on \"Fractal Tomography\", with fractal from iq's \"Julia - Quaternion 3\"\n*/\n\n#define AA   0  // optional antialiasing\n\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\n\nvec3 ltDir, slBox, slPos;\nfloat dstFar, tCur, nHit;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtSqr (vec4 q)\n{\n  return vec4 (2. * q.w * q.xyz, q.w * q.w - dot (q.xyz, q.xyz));\n}\n\nvec4 QtCub (vec4 q)\n{\n  float b;\n  b = dot (q.xyz, q.xyz);\n  return vec4 (q.xyz * (3. * q.w * q.w - b), q.w * (q.w * q.w - 3. * b));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 q, qq, c;\n  vec2 b;\n  float s, ss, ot;\n  q = vec4 (p, 0.).yzwx;\n  c = vec4 (0.2727, 0.6818, -0.2727, -0.0909);\n  b = vec2 (0.45, 0.55);\n  s = 0.;\n  ss = 1.;\n  ot = 100.;\n  nHit = 0.;\n  for (int j = VAR_ZERO; j < 256; j ++) {\n    ++ nHit;\n    qq = QtSqr (q);\n    ss *= 9. * dot (qq, qq);\n    q = QtCub (q) + c;\n    ot = min (ot, length (q.wy - b) - 0.1);\n    s = dot (q, q);\n    if (s > 32.) break;\n  }\n  return min (ot, max (0.25 * log (s) * sqrt (s / ss) - 0.001, 0.));\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  dMin = dstFar;\n  if (df > 0. && dn < df) dMin = dn;\n  return vec2 (dMin, df);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec2 d2;\n  float dHit, h;\n  d2 = BlkHit (ro - slPos, rd, slBox);\n  dHit = d2.x;\n  if (dHit < dstFar) {\n    for (int j = VAR_ZERO; j < 1024; j ++) {\n      h = ObjDf (ro + dHit * rd);\n      dHit += min (h, 0.005);\n      if (h < 0.0002 || dHit > d2.y) break;\n    }\n  }\n  if (dHit > d2.y) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ColFun ()\n{\n  return (0.6 + 0.4 * cos (log2 (nHit) + 0.1 * tCur + pi * vec3 (0., 0.33, 0.66))) *\n     mix (vec3 (0.6, 0.6, 0.3), vec3 (1.), smoothstep (5., 10., nHit));\n}\n\nvec3 Illum (vec3 col, vec3 rd, vec3 vn)\n{\n  return col * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.7 * max (dot (vn, ltDir), 0.) +\n     0.2 * vec3 (1., 1., 0.5) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colT;\n  float dstObj, dstObjT, c, t;\n  slBox = vec3 (2., 0.03, 2.);\n  t = 50. * mod (0.02 * tCur, 1.);\n  t = (1./50.) * (floor (t) + smoothstep (0.9, 1., mod (t, 1.)));\n  slPos = vec3 (0., 0.5 - SmoothBump (0.25, 0.75, 0.25, t), 0.);\n  dstObj = ObjRay (ro, rd);\n  col = (dstObj < dstFar && nHit > 1.) ? Illum (2. * ColFun (), rd, ObjNf (ro + dstObj * rd)) :\n     vec3 (0.);\n  c = length (col);\n  if (c == 0.) dstObj = dstFar;\n  slBox = vec3 (2.);\n  slPos = vec3 (0.);\n  dstObjT = ObjRay (ro, rd);\n  if (dstObjT < min (dstObj, dstFar) && nHit > 1.) {\n    colT = Illum (0.5 + 1.5 * ColFun (), rd, ObjNf (ro + dstObjT * rd));\n    col = (c > 0.) ? mix (col, colT, 0.25) : 0.4 * colT;\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = floor (tCur / 7.) + smoothstep (0.9, 1., mod (tCur / 7., 1.));\n    az -= 0.22 * pi * t;\n    el -= 0.12 * pi * sin (0.02 * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.);\n  zmFac = 5.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 10.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[632, 632, 653, 653, 721], [723, 723, 744, 744, 857], [859, 859, 881, 881, 1361], [1363, 1363, 1407, 1407, 1633], [1635, 1635, 1668, 1668, 1987], [1989, 1989, 2010, 2010, 2265], [2267, 2267, 2283, 2283, 2442], [2444, 2444, 2485, 2485, 2667], [2669, 2669, 2704, 2704, 3450], [3452, 3452, 3508, 3508, 4618], [4620, 4620, 4642, 4642, 4680], [4682, 4682, 4704, 4704, 4742], [4744, 4744, 4801, 4801, 4884], [4886, 4886, 4916, 4916, 5029], [5031, 5031, 5067, 5067, 5273]], "test": "untested"}
{"id": "ttlyWf", "name": "Hyperbolic Poincaré, animated", "author": "mla", "description": "I was curious how the transformation in std's excellent [url]https://www.shadertoy.com/view/3lscDf[/url] worked, so made this little animation, showing it broken into stages.", "tags": ["conformal", "poincare", "cineshader"], "likes": 34, "viewed": 12983, "published": 3, "date": "1593333787", "time_retrieved": "2024-07-30T20:58:47.865083", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Original: https://www.shadertoy.com/view/3lscDf by stb\n// Extra animation by mla, 2020\n////////////////////////////////////////////////////////////////////////////////\n\n/*\n\tHyperbolic Poincaré transformed\n\t2015-2020 stb\n\n\tJust messing with some old code, and a few complex functions.\n*/\n\n// change these\nconst int N\t\t= 7;\t// number of polygon vertices\nconst int P\t\t= 3;\t// number of polygons meeting at a vertex\nconst int Iters\t= 16;\t// number of iterations\n\n\n#define E \t\t2.71828182\n#define HALFPI\t1.57079633\n#define PI\t\t3.14159265\n#define TWOPI\t6.28318531\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n#define rotate2(p, a) vec2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a))\n\n\nvec2 radialRepeat(vec2 p, vec2 o, int n) {\n    return rotate(vec2(o.x, o.y), floor(atan(p.x, p.y)*(float(n)/TWOPI)+.5)/(float(n)/TWOPI));\n}\n\nvec2 cInvert(vec2 p, vec2 o, float r) {\n    return (p-o) * pow(r, 2.) / dot(p-o, p-o) + o;\n}\n\nvec2 cInvertMirror(vec2 p, vec2 o, float r, float flip){\n    return (length(p-o)<r ^^ flip==1. ? cInvert(p, o, r) : p);\n}\n\nvec4 poincareGetStuff(int n_, int p_) {\n    float n = PI / float(n_), p = PI / float(p_);\n\tvec2 r1 = vec2(cos(n), -sin(n));\n    vec2 r2 = vec2(cos(p+n-HALFPI), -sin(p+n-HALFPI));\n    float dist = (r1.x - (r2.x/r2.y) * r1.y);\n    float rad = length(vec2(dist, 0.)-r1);\n    float d2 = dist*dist - rad*rad;\n    float s = (d2<0. ? 1. : sqrt(d2));\n\treturn vec4(vec3(dist, rad, 1.)/s, float(d2<0.));\n}\n\nvec2 poincareCreateUVs(vec2 p, vec4 pI) {\n    return cInvertMirror(p, radialRepeat(p, vec2(0., pI.x), N), pI.y, pI.w);\n}\n\n// Many complex functions are from: https://raw.githubusercontent.com/julesb/glsl-util/master/complexvisual.glsl\n\n#ifndef sinh\n\t#define sinh(a) (pow(E, a)-pow(E, -a)) / 2.\n#endif\n#ifndef cosh\n\t#define cosh(a) (pow(E, a)+pow(E, -a)) / 2.\n#endif\n\n#define c_abs(a) length(a)\n#define c_arg(a) atan(a.y, a.x)\n\n#define c_conj(a) vec2(a.x, -a.y)\n#define c_exp(a) vec2(exp(a.x)*cos(a.y), exp(a.x)*sin(a.y))\n#define c_sqr(a) vec2(a.x*a.x-a.y*a.y, 2.*a.x*a.y)\n#define c_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define c_div(a, b) vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))\n#define c_sin(a) vec2(sin(a.x)*cosh(a.y), cos(a.x)*sinh(a.y))\n#define c_cos(a) vec2(cos(a.x)*cosh(a.y), -sin(a.x)*sinh(a.y))\n#define c_cartToPolar(a) vec2(length(a), atan(a.y, a.x))\n#define c_polarToCart(a) a.x * vec2(cos(a.y), sin(a.y))\n\nvec2 c_sqrt(vec2 a){\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(.5*(r+a.x));\n    float ipart = sqrt(.5*(r-a.x));\n    if (a.y < 0.) ipart = -ipart;\n    return vec2(rpart, ipart);\n}\n\nvec2 c_tan(vec2 a){ return c_div(c_sin(a), c_cos(a)); }\n\nvec2 c_log(vec2 a){\n    float rpart = length(a);\n    float ipart = atan(a.y, a.x);\n    if (ipart > PI) ipart -= 2. * PI;\n    return vec2(log(rpart), ipart);\n}\n\nvec2 c_toThe(vec2 a, float b){ return c_exp(b*c_log(a)); }\nvec2 c_toThe(vec2 a, vec2 b){ return c_exp(c_mul(b, c_log(a))); }\n\nfloat mmix(float t, float start, float end) {\n  return clamp((t-start)/(end-start),0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = 2. * (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\t\n    //p *= 4.0;\n    // some transformations\n    float cycle = 22.0;\n    float nArms = 3.0+mod(floor(iTime/cycle),7.0); //1.+floor(16.*abs(fract(.025*iTime)-.5));\n    //p = rotate2(p, .2*iTime);\n    float t = mod(iTime,cycle);\n    t = min(t,cycle-t);\n    p /= dot(p, p);\n    p = c_toThe(p, pow(nArms,mmix(t,9.0,10.0)));\n    p.x += 1.0*mmix(t,7.0,8.0);\n    p = c_toThe(p, pow(.5,mmix(t,5.0,6.0)));\n    p.x += .5*mmix(t,3.0,4.0);\n    p /= dot(p, p);\n    p.x -= mmix(t,1.0,2.0);\n    //p = rotate2(p, .1*iTime);\n    \n    \n    // get data for the disk model\n    vec4 pI = poincareGetStuff(N, P);\n    \n    // build the disk\n    for(int i=0; i<Iters; i++)\n        p = poincareCreateUVs(p, pI);\n    \n    // uncomment to mirror from disk's margin\n    //p = cInvertMirror(p, vec2(0., 0.), 1., 1.);\n    \n    \n    // this is the pattern for each polygon\n    float f = 1. - dot(p, p) / pow(pI.z, 2.);\n    \n    fragColor = vec4(vec3(f)*vec3(1.7, 1.2, .8).zyx, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[933, 933, 972, 972, 1025], [1150, 1150, 1189, 1189, 1545], [1547, 1547, 1588, 1588, 1667], [2516, 2516, 2536, 2536, 2712], [2714, 2714, 2733, 2733, 2769], [2771, 2771, 2790, 2790, 2929], [2931, 2931, 2961, 2961, 2989], [2990, 2990, 3019, 3019, 3055], [3057, 3057, 3102, 3102, 3151], [3153, 3153, 3208, 3208, 4230]], "test": "untested"}
{"id": "tllyWf", "name": "Once upon time... space", "author": "mrange", "description": "License CC0: Once upon time... in space\nWhen I grew up I loved the french kid show \"Once upon time... space\". The show had a big influence on me and 30+ years I wanted to make a homage to it. Song: https://www.youtube.com/watch?v=9IsGy0LvV9M\n\n", "tags": ["raymarching", "scifi"], "likes": 22, "viewed": 605, "published": 3, "date": "1593333776", "time_retrieved": "2024-07-30T20:58:49.126710", "image_code": "// License CC0: Once upon time... space\n//  When I grew up I loved the french kid show \"Once upon time... space\". \n//  The show had a big influence on me and 30+ years I wanted to make a homage to it. \n//  Song: https://www.youtube.com/watch?v=9IsGy0LvV9M\n\n//  Shader takes a long time to load, sorry!\n//  Code \"borrowed\" from the usual suspects\n\n// ------------------------------==> COMMON <==--------------------------------\n\nstruct Effect {\n  int      major  ;\n  int      minor  ;\n  float    seq    ;\n  bool     fade   ;\n  float    input0 ;\n  float    input1 ;\n};\n\n#define PI         3.141592654\n#define TAU        (2.0*PI)\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\n#define DURATION1  6.85\n#define DURATION   5.13\n#define DURATIONT  172.0\n\n#define FADEIN     1.0\n#define FADEOUT    2.0\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define SCA(a)      vec2(sin(a), cos(a))\n\n// Uncomment to speed up experimentation\n//#define EXPERIMENTING\n\n#define MINOR_NONE          0\n\n#define MAJOR_NOEFFECT      0\n\n#define MAJOR_IMPULSE       1\n#define MINOR_INTRO         0\n#define MINOR_OUTRO         1\n\n#define MAJOR_ORRERY        2\n#define MINOR_SUNRISE       0\n#define MINOR_CLOSEUP       1\n#define MINOR_APPROACH      2\n#define MINOR_ESCAPE        3\n\n#define MAJOR_WATERWORLD    3\n\n#define MAJOR_BARRENMOON    4\n\n#define MAJOR_GALAXY        5\n\n#define MAJOR_SPACESHIP     6\n#define MINOR_FROM_BEHIND   0\n#define MINOR_CYLINDER_SEA  1\n#define MINOR_FROM_FRONT    2\n\n//#define EXPERIMENTING\n\n#ifdef EXPERIMENTING\n#define ENABLE_IMPULSE\n\nconst Effect effects[] = Effect[](\n    Effect(MAJOR_IMPULSE     , MINOR_INTRO          , 0.0, false , 0.0       , 0.0) // This is special in that it's 7 seconds long, all other about ~5.1 long\n  );\n\n#else\n#define ENABLE_NOEFFECT\n#define ENABLE_IMPULSE\n#define ENABLE_ORRERY\n#define ENABLE_BARRENMOON\n#define ENABLE_WATERWORLD\n#define ENABLE_GALAXY\n#define ENABLE_SPACESHIP\n\nconst Effect effects[] = Effect[](\n    Effect(MAJOR_IMPULSE     , MINOR_NONE           , 0.0, false , 0.0       , 0.0) // This is special in that it's 7 seconds long, all other about ~5.1 long\n  , Effect(MAJOR_ORRERY      , MINOR_SUNRISE        , 0.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_SUNRISE        , 1.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_CLOSEUP        , 0.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_CLOSEUP        , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 0.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 1.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 2.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 0.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 1.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 2.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_ORRERY      , MINOR_APPROACH       , 0.0, true  , -1.1      , 1.0)\n  , Effect(MAJOR_ORRERY      , MINOR_APPROACH       , 1.0, true  , -1.1      , 1.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 0.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 1.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 2.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 3.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 0.0, true  , 0.0       , 0.0) // 20\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 2.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 3.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 0.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 1.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 2.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 0.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 1.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 2.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 0.0, true  , 0.4       , 0.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 1.0, true  , 0.4       , 0.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 0.0, true  , 2.0       , 2.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 1.0, true  , 2.0       , 2.5)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 0.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 2.0, true  , 0.0       , 0.0)\n  );\n#endif\n\n// From planet surface\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = skyCol1*skyCol1*skyCol1*3.0;\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.9,0.8);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.8);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  ringColor     = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  planetCol     = sqrt(vec3(0.9, 0.8, 0.7));\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\nconst vec3  mountainColor = sqrt(vec3(0.95, 0.65, 0.45));\n\n// From space\nconst vec3  sunDirection         = normalize(vec3(0.0, 0.5, -10.0));\nconst vec3  sunColor1            = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2            = vec3(1.0, 0.8, 0.9);\nconst vec3  smallSunDirection    = normalize(vec3(-2.0, -3.5, -10.0));\nconst vec3  smallSunColor1       = vec3(1.0, 0.6, 0.6);\nconst vec3  smallSunColor2       = vec3(1.0, 0.3, 0.6);\n\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n\n  float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n  float q = -abs(pos.x)/(4.0*k*k);\n\n  float h = q*q + p*p*p;\n  float r = sqrt(abs(h));\n\n  float x = (h>0.0) ? pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) : 2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// Not an exact distance field\nfloat softBox(vec3 p, float r) {\n  p *= p;\n  p *= p;\n  p *= p;\n  return pow(p.x + p.y + p.z, 1.0/8.0) - r;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat capsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n  return length(p.xy-c.xy)-c.z;\n}\n\n\nfloat l2(vec2 p) {\n  return dot(p, p);\n}\n\nfloat l2(vec3 p) {\n  return dot(p, p);\n}\nfloat spow(float v, float p) {\n  return sign(v)*pow(abs(v), p);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat smoother(float f, float r) {\n  return tanh(f/r)*r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 cylinderCoord(vec3 p) {\n  return vec2(p.z, atan(p.x, -p.y));\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat roundIntersection(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\nfloat chamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat roundDiff (float a, float b, float r) {  return roundIntersection(a, -b, r);\n}\nfloat pcos(float f) {\n  return 0.5 + 0.5*cos(f);\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec4 cyl) {\n  vec3  oc = ro - cb;\n  float card = dot(cyl.xyz ,rd);\n  float caoc = dot(cyl.xyz, oc);\n  float a = 1.0 - card*card;\n  float b = dot(oc, rd) - caoc*card;\n  float c = dot(oc, oc) - caoc*caoc - cyl.w*cyl.w;\n  float h = b*b - a*c;\n  if (h<0.0) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n\n  if (h<0.0) return vec2(-1.0);\n  h = sqrt(h);\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  return mix(vec2(-1.0), vec2(t1, t2),step(0.0, t2));\n}\n\n\nvec3 raySphereDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float ndbuffer = dbuffer/sph.w;\n  vec3  rc = (ro - sph.xyz)/sph.w;\n\n  float b = dot(rd,rc);\n  float c = dot(rc,rc) - 1.0;\n  float h = b*b - c;\n  if (h<0.0) return vec3(-1.0, -1.0, 0.0);\n  h = sqrt(h);\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  if (t2<0.0 || t1>ndbuffer) return vec3(-1.0, -1.0, 0.0);\n  t1 = max(t1, 0.0);\n  t2 = min(t2, ndbuffer);\n\n  float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n  float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n  return vec3(sph.w*t1, sph.w*t2, (i2-i1)*(3.0/4.0));\n}\n\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n\n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif\n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n\n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nvec4 voronoi(vec2 x) {\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash2(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nconst vec2 sca0 = SCA(0.0);\n\nfloat letteri(vec2 p) {\n  p.y -= 0.25;\n  return box(p, vec2(0.125, 0.75));\n}\n\nfloat letterm(vec2 p) {\n  p.y = -p.y;\n  float l = horseshoe(p - vec2(+0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  float r = horseshoe(p - vec2(-0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  return min(l, r);\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.5));\n}\n\nfloat letters(vec2 p) {\n  rot(p, -PI/6.0);\n  rot(p, -PI/2.0);\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  rot(p, PI);\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat impulse(vec2 p) {\n  p.x += 0.6;\n  const float oi = -3.00;\n  const float om = -1.65;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float di = letteri(p - vec2(oi, 0.0));\n  float dm = letterm(p - vec2(om, 0.0));\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n  float dx = abs(p.y) - oo;\n  dx = abs(dx) - oo*0.5;\n  float d = 1000000.0;\n  d = min(d, di);\n  d = min(d, dm);\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = max(d, -dx);\n\n  return d;\n}\n\nfloat star(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 gasGiant(vec3 ro, vec3 rd, vec3 sunDir) {\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n\n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n\n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n\n  vec3 final = vec3(0.0);\n\n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n\n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  return final;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n//  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n// ------------------------------==> COMMON <==--------------------------------\n\n// -----------------------------==> NOEFFECT <==-------------------------------\n\n#ifdef ENABLE_NOEFFECT\n\nvec3 noeffect_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  return vec3(0.0, 0.5, 0.0);\n}\n\n#endif\n\n// -----------------------------==> NOEFFECT <==-------------------------------\n\n// -----------------------------==> IMPULSE <==--------------------------------\n\n#ifdef ENABLE_IMPULSE\n\nfloat impulse_planet(vec2 p) {\n  p.y = abs(p.y);\n  float dc1 = circle(p, 2.0);\n  float dc2 = circle(p+vec2(0.0, 0.035), 2.0);\n  float dc = max(dc1, -dc2)+0.0025;\n  return dc;\n}\n\nfloat impulse_moon(vec2 p) {\n  float dc5 = circle(p-vec2(-3.6, 1.45), 0.25);\n  float dc6 = circle(p-vec2(-3.6, 1.45)+0.025*vec2(-1.0, 1.0), 0.25);\n  float dc0 = max(dc5, -dc6);\n  return dc0;\n}\n\n\nfloat impulse_stars(vec2 p, float ltime) {\n  const float count = 27.0;\n  const float radius = 5.0;\n  vec2 pp = toPolar(p);\n  pp.y += ltime*TAU/(count*2.0);\n  float n = mod1(pp.y, TAU/count);\n  p = toRect(pp);\n  p -= vec2(radius, 0.0);\n  float ds = (star(p, 0.35, 0.35));\n  return ds;\n}\n\nfloat impulse_df(vec2 p, float s, float ltime, bool stars) {\n  p /= s;\n\n  float di = impulse(p);\n  di = min(abs(di-0.0275) - 0.0155*pow(s, -0.25), di);\n  float dp = impulse_planet(p);\n  float dm = impulse_moon(p);\n  float ds = impulse_stars(p, ltime);\n  float d = di;\n  d = min(d, dp);\n  d = min(d, dm);\n  if (stars) d = min(d, ds);\n  return d*s;\n}\n\nfloat impulse_fbm(vec2 p) {\n  vec2 op = p;\n  const float aa   = 0.3;\n  const float ff   = 2.03;\n  const float tt   = PI/2.5;\n  const float oo   = 1.93;\n\n  float a = 1.0;\n  float o = 0.4;\n  float s = 0.0;\n  float d = 0.0;\n\n  p*=0.55;\n  for (int i; i < 3;++i) {\n    float nn = a*vnoise(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  return 0.65*(s/d);\n}\n\nfloat impulse_warp(vec2 p, float ltime, out vec2 v, out vec2 w) {\n  rot(p, -1.0);\n  p.x += 0.75;\n\n  vec2 o1 = vec2(1.0)*0.125;\n  vec2 o2 = vec2(-1.0)*0.125;\n  vec2 o3 = vec2(1.0)*0.125;\n  vec2 o4 = vec2(-1.0)*0.125;\n  rot(o1, ltime*sqrt(0.5));\n  rot(o2, ltime*sqrt(0.45));\n  rot(o3, -ltime*sqrt(0.35));\n  rot(o4, -ltime);\n  vec2 vv = vec2(impulse_fbm(p + o1), impulse_fbm(p + o2));\n  vv *= -5.0;\n  vec2 ww = vec2(impulse_fbm(p + vv + o2), impulse_fbm(p + vv + o3));\n  ww *= -5.0;\n  v = vv;\n  w = ww;\n  return impulse_fbm(p + ww + o4);\n}\n\nfloat impulse_height(vec2 p, float ltime) {\n  vec2 v;\n  vec2 w;\n  return impulse_warp(p, ltime, v, w);\n}\n\nvec3 impulse_normal(vec2 p, float ltime) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n\n  vec3 n;\n  n.x = impulse_height(p + e.xy, ltime) - impulse_height(p - e.xy, ltime);\n  n.y = 2.0*e.x;\n  n.z = impulse_height(p + e.yx, ltime) - impulse_height(p - e.yx, ltime);\n\n  return normalize(n);\n}\n\nvec3 impulse_intro(float ltime, vec2 p, vec2 q) {\n  // Hard coded to 7 fadein and fadeout\n  float pixel = 5.0/RESOLUTION.y;\n  float s = 30.0/(10.0 + ltime*(100.0/DURATION1));\n  float d = impulse_df(p, s, ltime, true);\n  vec2 op = p;\n  vec3 col = vec3(0.0);\n  p *= 0.5;\n  p -= 0.2;\n\n  vec2 v;\n  vec2 w;\n\n  float h = impulse_warp(p, ltime, v, w);\n  vec3 n = impulse_normal(p, ltime);\n  vec3 lp1 = vec3(-4.0, -2.0, 3.0);\n  vec3 ld1 = normalize(vec3(p.x, h, p.y) - lp1);\n  float dif1 = max(dot(n, ld1), 0.0);\n\n  float vv = 0.8;\n\n  vec3 col1 = hsv2rgb(vec3(0.95*v.yx, vv));\n  vec3 col2 = hsv2rgb(vec3(-0.65*w, vv));\n\n  col = (col1 + col2)*pow(dif1, 2.25);\n\n  col = mix(col, vec3(1.0), smoothstep(0.0, pixel, -d));\n\n  col = postProcess(col, q);\n\n  float fadeIn  = smoothstep(0.0, 2.0, ltime);\n  float fadeOut = smoothstep(DURATION1 - 4.0, DURATION1, ltime);\n\n  col = col + (1.0 - fadeIn);\n  col = mix(col, vec3(0.0), fadeOut*fadeOut);\n\n  return col;\n}\n\nvec3 impulse_outro(float ltime, vec2 p, vec2 q) {\n  float pixel = 5.0/RESOLUTION.y;\n  float s = 10.0/(10.0 + 0.5*ltime*(3.0/DURATION));\n  s *= 0.2;\n  float d = impulse_df(p, s, ltime, false);\n\n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(1.0), smoothstep(0.0, pixel, -d));\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\nvec3 impulse_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 col = vec3(0.5);\n  switch(minor) {\n  case MINOR_INTRO:\n    col = impulse_intro(ltime, p, q);\n    break;\n  case MINOR_OUTRO:\n    col = impulse_outro(ltime, p, q);\n    break;\n  }\n  return col;\n}\n\n#endif\n\n// -----------------------------==> IMPULSE <==--------------------------------\n\n// ------------------------------==> ORRERY <==--------------------------------\n\n#ifdef ENABLE_ORRERY\n\nconst vec3  orrery_moonColor            = vec3(0.6, 0.5, 0.4);\nconst float orrery_farAway              = 1E6;\nconst vec4  orrery_vgasGiant            = vec4(0.0, 0.0, 0.0, 10);\nconst vec4  orrery_vmoon                = vec4(-19.0, 0.7, 0.0, 0.5);\n\nvec3 orrery_skyColor(vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2*1.0;\n\n  col += pow(smallDiff, 10000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 1000.0)*smallSunColor2*0.25;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.25;\n\n  return col;\n}\n\nvec4 orrery_moon(float input0) {\n  vec3 p = orrery_vmoon.xyz;\n  rot(p.xz, input0);\n  p.y *= pcos(input0);\n  return vec4(p, orrery_vmoon.w);\n}\n\nvec4 orrery_rings(float input0, vec3 ro, vec3 rd, inout float pd) {\n  float rsd = (0.0 - ro.y)/rd.y;\n  vec3 p = ro + rd*rsd;\n\n  vec3 pn = vec3(0.0, 1.0, 0.0);\n  vec3 pr = reflect(rd, pn);\n  vec3 pref = orrery_skyColor(pr);\n  float pfres = pow(1.0-abs(dot(rd, pn)), 10.0);\n  float pl = length(p);\n  float pdf = pl-22.0;\n  pdf = abs(pdf) - 3.2;\n  pdf = abs(pdf) - 2.1;\n  pdf = abs(pdf) - 1.0;\n  vec4 pcol = vec4(1.0);\n  pcol.xyz = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 1.0, 1.0), 0.5 - 0.5*cos(15.0*pl))*sunColor1;\n  pcol.xyz = pow(pcol.xyz, vec3(0.75));\n  pcol.w = psin(20.0*pl)*psin(14.0*pl)*psin(21.0*pl);\n  pcol.w *= 0.5*step(pdf, 0.0);\n  pcol.xyz += pfres*pref;\n\n  vec3 rsn = vec3(0.0, 1.0, 0.0);\n\n  pcol.w = pow(pcol.w, 1.0*pow(abs(dot(rd, rsn)), 0.4));\n\n  vec2 psi1 = raySphere(p, sunDirection, orrery_vgasGiant);\n  pcol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi1.y - psi1.x)/(2.0*orrery_vgasGiant.w)));\n\n  vec4 vm = orrery_moon(input0);\n  vec2 psi2 = raySphere(p, sunDirection, vm);\n  pcol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi2.y - psi2.x)/(2.0*vm.w)));\n\n  pd = mix(pd, rsd, pcol.w > 0.0);\n\n  return pcol;\n}\n\nvec4 orrery_gasGiant(float input0, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec3 srsd = raySphereDensity(ro, rd, orrery_vgasGiant, orrery_farAway);\n  vec2 si = srsd.xy;\n  float sdens = srsd.z;\n  vec3 sp = ro + rd*si.x;\n  vec3 smp = ro + rd*(si.x+si.y)*0.5;\n  float smd = length(smp)/orrery_vgasGiant.w;\n  vec3 sn = normalize(sp - orrery_vgasGiant.xyz);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = orrery_skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 15.0);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  float sf = (si.y - si.x)/(2.0*orrery_vgasGiant.w);\n  vec3 sbeer = exp(-90.0*sdens*vec3(0.30, 0.25, 0.22)*pow(smd, -3.0));\n  float srayl = pow(1.0 - abs(dot(rd, sn)), 5.0);\n\n  float slo = atan(sp.z, sp.x);\n  float slat = PI*sp.y/orrery_vgasGiant.w;\n  vec3 scol = vec3(0.8);\n\n  scol = mix(scol, vec3(0.7, 0.7, 0.8), pow(pcos(20.0*slat), 5.0));\n  scol = mix(scol, vec3(0.75, 0.7, 0.8), pow(pcos(14.0*slat), 20.0));\n  scol = mix(scol, vec3(0.2), pow(pcos(21.0*slat)*pcos(13.0*slat+1.0), 15.0));\n  scol = tanh(scol);\n  scol *= pow(sunColor1, vec3(0.66));\n  scol += vec3(0.0, 0.0, srayl*0.5) ;\n\n  vec4 vm = orrery_moon(input0);\n  vec2 mi = raySphere(sp, sunDirection, vm);\n\n  float msha = (1.0  - smoothstep(0.0, 1.0, (mi.y - mi.x)/(2.0*vm.w)));\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + pow(skyCol, vec3(0.85))*sbeer + scol*pow(sdiff, 0.75);\n    col.xyz *= msha;\n    col.w = 1.0;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec4 orrery_moon(float input0, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec4 vm = orrery_moon(input0);\n\n  vec2 si = raySphere(ro, rd, vm);\n  vec3 sp = ro + rd*si.x;\n  vec3 sn = normalize(sp - vm.xyz);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = orrery_skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 5.0);\n  float sf = (si.y - si.x)/(2.0*vm.w);\n\n  vec2 gi = raySphere(sp, sunDirection, orrery_vgasGiant);\n\n  float gsha = (1.0  - smoothstep(0.0, 1.0, (gi.y - gi.x)/(2.0*orrery_vgasGiant.w)));\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + orrery_moonColor*pow(sdiff, 0.75);\n    col.w = (1.0 - exp(-7.0*sf))*gsha;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec4 orrery_ship(float ltime, float input0, float input1, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  const vec3 normal = normalize(-vec3(-1.0, -1.0, -1.0));\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n  const vec3 xx = cross(up, normal);\n  const vec3 yy = cross(xx, normal);\n  const float exc = 0.1;\n\n  vec4 vm = orrery_moon(input0);\n\n  vec4 p = vec4(normal, -dot(normal, vm.xyz));\n  float d = rayPlane(ro, rd, p);\n  vec3 pp = ro + rd*d - vm.xyz;\n\n  vec2 p2 = vec2(dot(xx, pp), dot(yy, pp));\n  p2.y *= -1.0;\n  p2 += vec2(0.0, 2.0*vm.w);\n\n  const float posY = 0.15;\n  const float posX = sqrt(posY/exc);\n\n  float dp = parabola(p2, exc);\n  dp = abs(dp)-0.001;\n\n  float trailt = smoothstep(0.0125+p2.y*p2.y*0.01, 0.0, dp);\n\n  float fadeOut = (smoothstep(10.0, posY, p2.y));\n\n  trailt *= fadeOut*(step(posY, p2.y))*step(p2.x, 0.0);\n  trailt *= 1.5-1.0*smoothstep(0.0, 0.75, p2.y);\n\n  vec4 trailCol = vec4(hsv2rgb(vec3(0.99, 0.0, 1.0)-vec3(0.5, -1.0, 0.5)*(1.0-fadeOut)), trailt);\n\n  float sc = circle(p2-vec2(-posX, posY), 0.0);\n\n  vec4 shipCol = vec4(2.0*vec3(1.5, 1.0, 2.0), 1.0)*smoothstep(-7.0, 1.0, sin(ltime*4.0*TAU))*smoothstep(0.125, 0.0, sc);\n\n  vec4 col = mix(trailCol, shipCol, shipCol.w)*input1;\n\n  pd = mix(pd, d, col.w > 0.0);\n\n\n  return col;\n}\n\nvec3 orrery_render(float ltime, float input0, float input1, vec3 ro, vec3 rd) {\n  vec3 skyCol = orrery_skyColor(rd);\n\n  vec4 col = vec4(skyCol, 1.0);\n  float cold = orrery_farAway;\n\n  vec4 ggcol = orrery_gasGiant(input0, ro, rd, skyCol, cold);\n\n  col.xyz = mix(col.xyz, ggcol.xyz, ggcol.w);\n\n  float md = orrery_farAway;\n  vec4 mcol = orrery_moon(input0, ro, rd, skyCol, md);\n\n  col.xyz = mix(col.xyz, mcol.xyz, mcol.w*step(md, cold));\n  cold = mix(cold, md, step(md, cold));\n\n  float rsd = orrery_farAway;\n  vec3 rsp;\n  vec4 rscol = orrery_rings(input0, ro, rd, rsd);\n\n  col.xyz = mix(col.xyz, rscol.xyz, rscol.w*step(rsd, cold));\n  cold = mix(cold, rsd, step(rsd, cold));\n\n  float sd = orrery_farAway;\n  vec4 scol = orrery_ship(ltime, input0, input1, ro, rd, skyCol, sd);\n\n  col.xyz = mix(col.xyz, scol.xyz, scol.w*step(sd, cold));\n  cold = mix(cold, sd, step(sd, cold));\n\n  return col.xyz;\n}\n\nvec3 orrery_fragment(float ltime, float input0, float input1, vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  vec3 col = orrery_render(ltime, input0, input1, ro, rd);\n  return col;\n}\n\nvec3 orrery_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro = vec3(0.0, 0.0, 52.0);\n  vec3 la = vec3(0.0, 0.0,0.0);\n  vec3 up = vec3(-0.0, 1.0, 0.0);\n\n  switch(minor) {\n  case MINOR_SUNRISE:\n    ro.y += ltime*4.0/(2.0*DURATION)+3.0;\n    la = vec3(0.0, 0.0, -orrery_farAway);\n    break;\n  case MINOR_CLOSEUP:\n    ro = vec3(0.0, 0.0, -25.0);\n    rot(ro.yz, 1.0-0.1*ltime/(2.0*DURATION));\n    la = vec3(0.0, 0.0, 0.0);\n    up = vec3(-0.25, 1.0, 0.0);\n    break;\n  case MINOR_APPROACH:\n    ro = (0.75-ltime/(3.0*DURATION)*0.15)*vec3(-25.0, -20.0, -40.0);\n    la = orrery_moon(input0).xyz;\n    break;\n  case MINOR_ESCAPE:\n    ro = vec3(0.0, 5.0, 30.0);\n    la = vec3(0.0, 0.0, -orrery_farAway);\n    ro.x += -6.0*ltime/(3.0*DURATION);\n    ro.y += 12.0*ltime/(3.0*DURATION);\n    ro.z += 60.0*ltime/(3.0*DURATION);\n    up = vec3(-1.0, 1.0, 0.0);\n    break;\n  default:\n    break;\n  }\n\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n  col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o1);\n\n  col = clamp(col, 0.0, 1.0);\n\n  // Adaptive AA? Is that a good idea?\n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+0.01);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n\n  if (de > 0.1) {\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p-o1);\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o2);\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ------------------------------==> ORRERY <==--------------------------------\n\n// ----------------------------==> WATERWORLD <==------------------------------\n\n#ifdef ENABLE_WATERWORLD\n\n#define WATERWORLD_TOLERANCE       0.00001\n#define WATERWORLD_MAX_ITER        55\n#define WATERWORLD_MAX_DISTANCE    31.0\n\nfloat waterworld_heightMod(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += -pp.x*0.2;\n  p = toRect(pp);\n  return pow((psin(1.0*p.x)*psin(1.0*p.y)), max(0.25, pp.x*0.20))*0.8;\n}\n\nfloat waterworld_height(vec2 p, float dd, int mx) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n\n  float hm = waterworld_heightMod(p);\n\n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n\n  int i = 0;\n\n  p *= 2.0;\n\n  for (; i < mx;++i) {\n    float nn = a*(vnoise(p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n\n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat waterworld_loheight(vec2 p, float d) {\n  return waterworld_height(p, d, 3);\n}\n\nfloat waterworld_height(vec2 p, float d) {\n  return waterworld_height(p, d, 5);\n}\n\nfloat waterworld_hiheight(vec2 p, float d) {\n  return waterworld_height(p, d, 6);\n}\n\nvec3 waterworld_normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = (waterworld_hiheight(p - eps.xy, d) - waterworld_hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (waterworld_hiheight(p - eps.yx, d) - waterworld_hiheight(p + eps.yx, d));\n\n  return normalize(n);\n}\n\nfloat waterworld_march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < WATERWORLD_MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = waterworld_height(p.xz, d);\n\n    if (d > WATERWORLD_MAX_DISTANCE) {\n      max_iter = i;\n      return WATERWORLD_MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < WATERWORLD_TOLERANCE) {\n      return d;\n    }\n\n    const float sl = 0.9;\n\n    dt = max(hd*sl, WATERWORLD_TOLERANCE+0.0005*d);\n    lastd = d;\n    d += dt;\n  }\n\n  max_iter = WATERWORLD_MAX_ITER;\n  return WATERWORLD_MAX_DISTANCE;\n}\n\nvec3 waterworld_sunDirection() {\n  return normalize(vec3(-0.5, 0.2, 1.0));\n}\n\nvec3 waterworld_smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 waterworld_skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = waterworld_sunDirection();\n  vec3 smallSunDir = waterworld_smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  float dustTransparency = smoothstep(-0.15, 0.075, rd.y);\n\n  vec3 skyCol = mix(skyCol1, skyCol2, sqrt(dustTransparency));\n  skyCol *= (1.0-dustTransparency);\n\n  vec3 planetCol = gasGiant(ro, rd, sunDir)*dustTransparency;\n\n  vec3 final = planetCol + skyCol + sunCol + smallSunCol;\n\n  return final;\n}\n\nvec3 waterworld_shipColor(vec2 p, float ltime) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*0.05;\n  p = toRect(pp);\n\n  float n = mod1(p.x, 0.15);\n  p.y += 3.0-ltime*0.5+0.05*abs(n*n);\n\n  float td = abs(p.x) - (0.005-p.y*0.002);\n  td = abs(td) - (0.02*pow(-p.y, 0.25));\n  float sd = circle(p, 0.05);\n\n  vec3 trailCol = vec3(0.5)*smoothstep(-5.0, 0.0, p.y)*step(p.y, 0.0)*smoothstep(0.0, 0.025, -td);\n  vec3 shipCol = vec3(0.5+smoothstep(-1.0, 1.0, sin(ltime*15.0*TAU+n)))*smoothstep(0.0, 0.075, -sd);\n\n  vec3 col = trailCol;\n  col += shipCol;\n\n  float sm = step(abs(n), 2.0);\n\n  return col*sm;\n}\n\nvec3 waterworld_getColor(vec3 ro, vec3 rd, float ltime) {\n  int max_iter = 0;\n  vec3 skyCol = waterworld_skyColor(ro, rd);\n  vec3 col = vec3(0);\n\n  const float shipHeight = 1.0;\n  const float seaHeight = 0.0;\n  const float cloudHeight = 0.2;\n  const float upperCloudHeight = 0.5;\n\n  float id = (cloudHeight - ro.y)/rd.y;\n\n  if (id > 0.0) {\n    float d = waterworld_march(ro, rd, id, max_iter);\n    vec3 sunDir = waterworld_sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, 1.0, -1.0);\n    vec3 p = ro + d*rd;\n\n    float loh = waterworld_loheight(p.xz, d);\n    float loh2 = waterworld_loheight(p.xz+sunDir.xz*0.05, d);\n    float hih = waterworld_hiheight(p.xz, d);\n    vec3 normal = waterworld_normal(p.xz, d);\n\n    float ud = (upperCloudHeight - 4.0*loh - ro.y)/rd.y;\n\n    float sd = (seaHeight - ro.y)/rd.y;\n    vec3 sp = ro + sd*rd;\n    float scd = (cloudHeight - sp.y)/sunDir.y;\n    vec3 scp = sp + sunDir*scd;\n\n    float sloh = waterworld_loheight(scp.xz, d);\n    float cshd = exp(-15.0*sloh);\n\n    float amb = 0.3;\n\n    vec3 seaNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 seaRef = reflect(rd, seaNormal);\n    vec3 seaCol = .25*waterworld_skyColor(p, seaRef);\n    seaCol += pow(max(dot(seaNormal, sunDir), 0.0), 2.0);\n    seaCol *= cshd;\n    seaCol += 0.075*pow(vec3(0.1, 1.3, 4.0), vec3(max(dot(seaNormal, seaRef), 0.0)));\n\n    float spe = pow(max(dot(sunDir, reflect(rd, normal)), 0.0), 3.0);\n    float fre = pow(1.0-dot(normal, -rd), 2.0);\n\n    col = seaCol;\n\n    const float level = 0.00;\n    const float level2 = 0.3;\n    // REALLY fake shadows and lighting\n    vec3 scol = sunCol1*(smoothstep(level, level2, hih) - smoothstep(level, level2, loh2));\n    col = mix(vec3(1.0), col, exp(-17.0*(hih-0.25*loh)));\n    col = mix(vec3(0.75), col, exp(-10.0*loh*(max(d-ud, 0.0))));\n    col += scol;\n\n    col += vec3(0.5)*spe*fre;\n\n    float ssd = (shipHeight - ro.y)/rd.y;\n\n    col += waterworld_shipColor((ro + rd*ssd).xz, ltime);\n\n    col = mix(col, skyCol, smoothstep(0.5*WATERWORLD_MAX_DISTANCE, 1.*WATERWORLD_MAX_DISTANCE, d));\n\n  } else {\n    col = skyCol;\n  }\n\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 waterworld_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro  = vec3(0.5, 5.5, -2.0);\n  vec3 la  = ro + vec3(0.0, -1.+0.75*ltime/(4.0*DURATION),  1.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = waterworld_getColor(ro, rd, ltime)  ;\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n//\n\n\n// ----------------------------==> WATERWORLD <==------------------------------\n\n// ----------------------------==> BARRENMOON <==------------------------------\n\n#ifdef ENABLE_BARRENMOON\n\n#define BARRENMOON_TOLERANCE       0.00001\n#define BARRENMOON_MAX_ITER        65\n#define BARRENMOON_MIN_DISTANCE    0.01\n#define BARRENMOON_MAX_DISTANCE    9.0\n\nconst float barrenmoon_near = 0.3;\nconst float barrenmoon_far  = 0.5;\n\nconst vec3 barrenmoon_sunCol1      = pow(sunCol1, vec3(1.0, 4.0, 4.0));\nconst vec3 barrenmoon_sunCol2      = pow(sunCol2, vec3(2));\nconst vec3 barrenmoon_smallSunCol1 = smallSunCol1;\nconst vec3 barrenmoon_smallSunCol2 = smallSunCol2;\n\nvec2 barrenmoon_hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat barrenmoon_circles(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = barrenmoon_hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  const float r = 0.225;\n\n  float d = circle(p, 2.0*r);\n\n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat barrenmoon_craters(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = barrenmoon_hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  rot(p, TAU*hh.y);\n  const float r = 0.45;\n\n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n\n  float h = -abs(hh.x)*(smoothstep(0.0, r, -2.0*d)-0.3*smoothstep(0.0, 0.2*r, -d));\n\n  return h*0.275;\n}\n\n\nfloat barrenmoon_height(vec2 p, float dd, int mx) {\n  const float aa   = 0.45;\n  const float ff   = 2.03;\n  const float tt   = 1.2;\n  const float oo   = 3.93;\n\n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.075*sin(p.x+p.y);\n  float d = 0.0;\n\n  int i = 0;\n\n  for (; i < 4;++i) {\n    float nn = a*barrenmoon_craters(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float lod = s/d;\n\n  float rdd = dd/BARRENMOON_MAX_DISTANCE;\n  mx = int(mix(float(4), float(mx), step(rdd, barrenmoon_far)));\n\n  for (; i < mx; ++i) {\n    float nn = a*barrenmoon_circles(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float hid = (s/d);\n\n  float m = smoothstep(barrenmoon_near, barrenmoon_far, rdd);\n  return mix(hid, lod, m*m);\n}\n\nfloat barrenmoon_height(vec2 p, float d) {\n  return barrenmoon_height(p, d, 6);\n}\n\nfloat barrenmoon_hiheight(vec2 p, float d) {\n  return barrenmoon_height(p, d, 8);\n}\n\nvec3 barrenmoon_normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = (barrenmoon_hiheight(p - eps.xy, d) - barrenmoon_hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (barrenmoon_hiheight(p - eps.yx, d) - barrenmoon_hiheight(p + eps.yx, d));\n\n  return normalize(n);\n}\n\nfloat barrenmoon_march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  const float initialStep = 1.0;\n  const float secondaryStep = 0.25;\n  float currentStepDist = initialStep;\n  float lastd = d;\n  float mint = -0.005/rd.y;\n  for (int i = 0; i < BARRENMOON_MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = barrenmoon_height(p.xz, d);\n\n    if (d > BARRENMOON_MAX_DISTANCE) {\n      max_iter = i;\n      return BARRENMOON_MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < BARRENMOON_TOLERANCE) {\n      if (currentStepDist < initialStep) {\n        max_iter = i;\n        return d;\n      }\n\n      d = lastd;\n      currentStepDist = secondaryStep;\n      continue;\n    }\n\n    dt = max(hd, mint)*currentStepDist;\n    lastd = d;\n    d += dt;\n  }\n\n  max_iter = BARRENMOON_MAX_ITER;\n  return BARRENMOON_MAX_DISTANCE;\n}\n\nvec3 barrenmoon_sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 barrenmoon_smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 barrenmoon_rocketDirection(float ltime) {\n  return normalize(vec3(0.0, -0.2+mod(ltime, 90.0)*0.0125, 1.0));\n}\n\nvec3 barrenmoon_skyColor(float ltime, vec3 ro, vec3 rd) {\n  vec3 sunDir = barrenmoon_sunDirection();\n  vec3 smallSunDir = barrenmoon_smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, vec3(0.0), smoothstep(0.0 , 1.0, 5.0*angle)), skyCol3, smoothstep(0.0, 1.0, -5.0*angle));\n\n  vec3 sunCol = 0.5*barrenmoon_sunCol1*pow(sunDot, 20.0) + 8.0*barrenmoon_sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*barrenmoon_smallSunCol1*pow(smallSunDot, 200.0) + 4.0*barrenmoon_smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(barrenmoon_sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n\n  float dustTransparency = smoothstep(-0.075, 0.0, rd.y);\n\n  vec3 rocketDir = barrenmoon_rocketDirection(ltime);\n  float rocketDot = max(dot(rd, rocketDir), 0.0);\n  float rocketDot2 = max(dot(normalize(rd.xz), normalize(rocketDir.xz)), 0.0);\n  vec3 rocketCol = vec3(0.25)*(3.0*smoothstep(-1.0, 1.0, psin(ltime*15.0*TAU))*pow(rocketDot, 70000.0) + smoothstep(-0.25, 0.0, rd.y - rocketDir.y)*step(rd.y, rocketDir.y)*pow(rocketDot2, 1000000.0))*dustTransparency;\n\n  vec3 planetCol = gasGiant(ro, rd, sunDir)*dustTransparency;\n\n  vec3 final = planetCol + skyCol + sunCol + smallSunCol + dust + rocketCol;\n\n  return final;\n}\n\nvec3 barrenmoon_getColor(float ltime, vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = barrenmoon_skyColor(ltime, ro, rd);\n  vec3 col = vec3(0);\n\n  float id = (0.125 - ro.y)/rd.y;\n\n  if (id > 0.0)   {\n    float d = barrenmoon_march(ro, rd, id, max_iter);\n    vec3 sunDir = barrenmoon_sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n\n    vec3 normal = barrenmoon_normal(p.xz, d);\n    vec3 dnx = dFdx(normal);\n    vec3 dny = dFdy(normal);\n    float ff = dot(dnx, dnx) + dot(dny, dny);\n    normal = normalize(normal + vec3(0.0, 5.0*ff, 0.0));\n\n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = barrenmoon_sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = barrenmoon_sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = barrenmoon_skyColor(ltime, p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;\n    float fre = max(dot(normal, -rd), 0.0);\n    fre = pow(1.0 - fre, 5.0);\n    col += rcol*fre*0.5;\n    col += (1.0*p.y);\n    col = tanh(col);\n    col = mix(col, skyCol, smoothstep(0.5*BARRENMOON_MAX_DISTANCE, BARRENMOON_MAX_DISTANCE, d));\n\n  } else {\n    col = skyCol;\n  }\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 barrenmoon_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  ltime = ltime + input0;\n  float off = 0.5*ltime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.00,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = barrenmoon_getColor(ltime, ro, rd)  ;\n\n//  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ----------------------------==> BARRENMOON <==------------------------------\n\n// ------------------------------==> GALAXY <==--------------------------------\n\n#ifdef ENABLE_GALAXY\n\nconst float galaxy_twirly   = 2.5;\nconst vec3  galaxy_colDust  = vec3(1.0, 0.9, 0.75);\n\nfloat galaxy_noise(float ttime, vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n  float tm = ttime;\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5)+tm);\n  float d = cos(p.y*sqrt(1.5)+tm);\n\n  return a*b*c*d;\n}\n\nvec2 galaxy_twirl(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*galaxy_twirly + a;\n  p = toRect(pp);\n\n  p *= z;\n\n  return p;\n}\n\nfloat galaxy_galaxy(float ttime, vec2 p, float a, float z) {\n  p = galaxy_twirl(p, a, z);\n\n  return galaxy_noise(ttime, p);\n}\n\nvec3 galaxy_stars(vec2 p) {\n  float l = length(p);\n\n  vec2 pp = toPolar(p);\n  pp.x /= (1.0+length(pp.x))*0.5;\n  p = toRect(pp);\n\n  float sz = 0.0075;\n\n  vec3 s = vec3(10000.0);\n\n  for (int i = 0; i < 3; ++i) {\n    rot(p, 0.5);\n    vec2 ip = p;\n    vec2 n = mod2(ip, vec2(sz));\n    float r = hash(n);\n    vec2 o = -1.0 + 2.0*vec2(r, fract(r*1000.0));\n    s.x = min(s.x, length(ip-0.25*sz*o));\n    s.yz = n*0.1;\n  }\n\n  return s;\n}\n\nfloat galaxy_height(float ttime, vec2 p) {\n  float ang = atan(p.y, p.x);\n  float l = length(p);\n  float sp = mix(1.0, pow(0.75 + 0.25*sin(2.0*(ang + l*galaxy_twirly)), 3.0), tanh(6.0*l));\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 11; ++i) {\n    float g = a*galaxy_galaxy(ttime, p, ttime*(0.025*float(i)), f);\n    s += g;\n    a *= sqrt(0.45);\n    f *= sqrt(2.0);\n    d += a;\n  }\n\n  s *= sp;\n\n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 galaxy_normal(float ttime, vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = galaxy_height(ttime, p - eps.xy) - galaxy_height(ttime, p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = galaxy_height(ttime, p - eps.yx) - galaxy_height(ttime, p + eps.yx);\n\n  return normalize(n);\n}\n\nvec3 galaxy_galaxy(float ttime, vec2 p, vec3 ro, vec3 rd, float d) {\n  rot(p, 0.5*ttime);\n\n  float h = galaxy_height(ttime, p);\n  vec3 s = galaxy_stars(p);\n  float th = tanh(h);\n  vec3 n = galaxy_normal(ttime, p);\n\n  vec3 p3 = vec3(p.x, th, p.y);\n  float lh = 0.5;\n  vec3 lp1 = vec3(-0.0, lh, 0.0);\n  vec3 ld1 = normalize(lp1 - p3);\n  vec3 lp2 = vec3(0.0, lh, 0.0);\n  vec3 ld2 = normalize(lp2 - p3);\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n//  col += vec3(0.5)*pow(diff1, 20.0);\n  col += 0.25*pow(diff2, 4.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n//  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10*l*l);\n\n\n  float sr = hash(s.yz);\n  float si = pow(th*sr, 0.25)*0.001;\n  vec3 scol = sr*5.0*exp(-2.5*l*l)*tanh(pow(si/(s.x), 2.5))*mix(vec3(0.5, 0.75, 1.0), vec3(1.0, 0.75, 0.5), sr*0.6);\n  float sd = length(ro);\n  scol = clamp(scol, 0.0, 1.0);\n  // TODO: Smooth out stars, but it works for the purpose of this shader\n  col += step(sd, 1.5)*scol*smoothstep(0.0, 0.35, 1.0-n.y);\n\n  float ddust = (h - ro.y)/rd.y;\n  if (ddust < d) {\n    float t = d - ddust;\n    col += 0.7*galaxy_colDust*(1.0-exp(-2.0*t));\n  }\n\n  return col;\n}\n\nvec3 galaxy_render(float ttime, vec3 ro, vec3 rd) {\n  float dgalaxy = (0.0 - ro.y)/rd.y;\n\n  vec3 col = vec3(0);\n\n  if (dgalaxy > 0.0) {\n    col = vec3(0.5);\n    vec3 p = ro + dgalaxy*rd;\n\n    col = galaxy_galaxy(ttime, p.xz, ro, rd, dgalaxy);\n  }\n\n  vec2 cgalaxy = raySphere(ro, rd, vec4(vec3(0.0), 0.125));\n\n  float t;\n\n  if (dgalaxy > 0.0 && cgalaxy.x > 0.0) {\n    float t0 = max(dgalaxy - cgalaxy.x, 0.0);\n    float t1 = cgalaxy.y - cgalaxy.x;\n    t = min(t0, t1);\n  } else if (cgalaxy.x < cgalaxy.y){\n    t = cgalaxy.y - cgalaxy.x;\n  }\n\n  col += 1.7*galaxy_colDust*(1.0-exp(-1.0*t));\n\n\n  return col;\n}\n\nvec3 galaxy_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro = vec3(0.0, 0.7, 2.0)*mix(input0, input1, ltime/(2.0*DURATION));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(-0.5, 1.0, 0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  float ttime = 0.05*ltime;\n  vec3 col = galaxy_render(ttime, ro, rd);\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ------------------------------==> GALAXY <==--------------------------------\n\n// -----------------------------==> SPACESHIP <==------------------------------\n\n#ifdef ENABLE_SPACESHIP\n\n#define SPACESHIP_TOLERANCE           0.001\n#define SPACESHIP_NORM_OFF            0.001\n#define SPACESHIP_MAX_RAY_LENGTH      100.0\n\n#define SPACESHIP_MAX_RAY_MARCHES     60\n\nconst float spaceship_refractRatio = 0.95;\n\nconst vec3  spaceship_seaCol1      = vec3(0.15, 0.45, 0.55);\nconst vec3  spaceship_seaCol2      = spaceship_seaCol1*spaceship_seaCol1*spaceship_seaCol1*3.0;\n\nconst float spaceship_innerLength  = 4.0;\nconst float spaceship_outerLength  = 6.25;\nconst vec3  spaceship_sunPos       = vec3(0.0, 0.0, spaceship_innerLength);\nconst vec3  spaceship_sunCol1      = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3  spaceship_sunCol2      = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\nconst vec3  spaceship_engineCol1   = vec3(8.0/8.0,6.0/8.0,6.0/8.0);\nconst vec3  spaceship_engineCol2   = vec3(8.0/8.0,5.0/8.0,6.0/8.0);\n\nconst vec3  spaceship_start       = vec3(0.0);\n\nvec3 spaceship_sunColor(vec3 ro, vec3 rd, float input0, float input1) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n  vec3 col = vec3(0.0);\n\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2;\n\n  col += pow(smallDiff, 8000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.5;\n  col += pow(smallDiff, 150.0)*smallSunColor2*0.5;\n\n  return col;\n}\n\nvec3 spaceship_skyColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n  vec3 gcol = gasGiant(ro+vec3(input0*input1/TAU, 0.0, input1), rd, sunDirection);\n\n  return scol+gcol;\n}\n\nvec3 spaceship_refColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n\n  vec3 final = vec3(0.0);\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) final = vec3(2.0)*rd.y;\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  final *= 0.5;\n  final += scol;\n\n  return final;\n}\n\nvec3 spaceship_domeColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n\n  vec3 final = mix(vec3(0.125, 0.25, 0.5), vec3(0.25), 0.5 + 0.5*rd.y)*0.5;\n  final += scol;\n\n  return final;\n}\n\nvec4 spaceship_backplane(vec3 ro, vec3 rd, inout vec3 scol) {\n  float ed = (spaceship_innerLength - ro.z)/rd.z;\n  vec3 ep = ro + rd*ed;\n  vec3 en = vec3(0.0, 0.0, 1.0);\n\n  float lr = 0.5;\n  float er = (lr*lr-dot(ep.xy, ep.xy))/(lr*lr);\n  float eradius = length(ep.xy);\n  float emradius = eradius;\n  float eangle = atan(ep.y, ep.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.1);\n  mod1(emangle, TAU/60.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n\n  float efadeout = 1.0 - smoothstep(0.0, 0.9, eradius);\n\n  scol = vec3(0.0);\n  scol += 8.0*spaceship_sunCol1*pow(clamp(er, 0.0, 1.0), 8.0);\n  scol += spaceship_sunCol1*pow(clamp(er, 0.0, 1.0), 1.0);\n  scol += spaceship_sunCol2*efadeout*efadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += scol;\n  ecol += elinec*smoothstep(0.01, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.015, 0.0, abs(emangle))*efadeout;\n\n  return vec4(ecol, eradius < 1.0);\n}\n\nfloat spaceship_fbm(vec2 p, int mx) {\n  const float aa = 0.45;\n  const float pp = 2.08;\n  const float rr = 1.0;\n\n  float a = 1.0;\n  float s = 0.0;\n  float d = 0.0;\n\n  for (int i = 0; i < mx; ++i) {\n    s += a*vnoise(p);\n    d += abs(a);\n    a *= aa;\n    p *= pp;\n    rot(p, rr);\n  }\n\n  return 1.0*s/d;\n}\n\nvec3 spaceship_normal(vec2 p, int mx) {\n  vec2 eps = -vec2(0.0001, 0.0);\n\n  vec3 nor;\n\n  nor.x = spaceship_fbm(p + eps.xy, mx) - spaceship_fbm(p - eps.xy, mx);\n  nor.y = 2.0*eps.x;\n  nor.z = spaceship_fbm(p + eps.yx, mx) - spaceship_fbm(p - eps.yx, mx);\n\n  return normalize(nor);\n}\n\nvec3 spaceship_islands(vec3 col, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.7;\n  float beachLevel = level + 0.025;\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n\n  sp *= 2.0;\n  float hih = spaceship_fbm(sp, 6);\n  float loh = spaceship_fbm(sp+vec2(0.075-0.075*sp.x/spaceship_innerLength, 0.0), 3);\n  vec3 hn = spaceship_normal(sp, 6);\n\n  vec3 nn = normalize(hn + n);\n\n  const vec3 sandCol = vec3(1.0, 0.95, 0.9);\n\n  float fdiff = pow(max(dot(sunDir, nn), 0.0), 0.5);\n\n  vec4 treePattern = voronoi(sp*40.0);\n  vec3 islandCol  = mix(vec3(0.5, 0.75, 0.0), vec3(0.1, 0.45, 0.0), treePattern.y*fdiff*2.0);\n  islandCol *= 1.0 - treePattern.x * 0.75;\n\n  col = mix(0.0, 1.0, hih < level)*mix(sandCol, col , 1.0 - exp(8.0*vec3(2.0, 1.0, 1.0)*(hih-level)));\n  col = mix(col, sandCol, vec3((beachLevel >  hih) && (hih > level)));\n  col = mix(col, islandCol, vec3(hih > beachLevel));\n  // Really REALLY fake lighting+shadows\n  const float hh = 0.125;\n  vec3 scol = vec3(1.0)*(smoothstep(level, level+hh, hih) - smoothstep(level, level+hh, loh));\n  col = col+scol*0.5;\n\n  return col;\n}\n\nvec3 spaceship_clouds(vec3 col, vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.5;\n\n  vec3 ref = reflect(rd, n);\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n  float sunL2 = l2(spaceship_sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe1 = 0.5*pow(max(dot(sunDir, ref), 0.0), 10.0);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  sp *= 2.0;\n  sp += 100.0;\n  float hih = max(spaceship_fbm(sp, 6) - level, 0.0);\n  float loh = max(spaceship_fbm(sp, 3) - level, 0.0);;\n\n  // More fake stuff\n  float m = clamp(1.0- exp(-15.0*(hih-0.5*loh)), 0.0, 1.0);\n\n  col = mix(col, vec3(1.25)*spaceship_sunCol1*(sunIll + spe1 + spe2), m*m*m);\n\n  return col;\n}\n\nvec3 spaceship_cloudShadows(vec3 col, vec3 p, float level) {\n  level += 0.5;\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n\n  vec2 ci = rayCylinder(p, sunDir, spaceship_start, vec4(0.0, 0.0, 1.0, 0.8));\n\n  vec3 pp = p + ci.x*sunDir;\n  vec2 pp2 = cylinderCoord(pp);\n\n  pp2 *= 2.0;\n  pp2 += 100.0;\n  float loh = max(spaceship_fbm(pp2, 3) - level, 0.0);\n\n  return col*mix(0.3, 1.0, exp(-3.0\n  *loh));\n}\n\nvec3 spaceship_sea(vec3 ro, vec3 rd, vec3 n, vec3 p, vec2 sp) {\n\n  vec3 ref = reflect(rd, n);\n  ref = normalize(ref + 0.025*psin(mix(110.0, 220.0, psin(2.0*p.z+0.2*p.x))*p.z));\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n  float sunL2 = l2(spaceship_sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  vec3 seaCol = vec3(0.0);\n  seaCol += 1.0*spaceship_seaCol2*pow(1.0-max(dot(n, ref), 0.0), 0.45);\n  seaCol += spaceship_seaCol1*0.5*sunIll;\n  seaCol += spaceship_seaCol1*spaceship_sunCol1*sunDiff*sunIll;\n  seaCol += spaceship_sunCol1*spe2;\n\n  return seaCol;\n}\n\nvec3 spaceship_shipInterior(vec3 ro, vec3 rd, float input0, float input1) {\n  ro += rd*0.05;\n\n  float fd = (0.0 - ro.z)/rd.z;\n  vec2 di = raySphere(ro, rd, vec4(spaceship_start, 1.0));\n  vec2 ci = rayCylinder(ro, rd, spaceship_start, vec4(0.0, 0.0, 1.0, 0.8));\n  vec2 gi = rayCylinder(ro, rd, spaceship_start, vec4(0.0, 0.0, 1.0, 0.9));\n\n  vec3 dp = ro + rd*di.y;\n  vec3 dn = -normalize(dp  -spaceship_start);\n  vec3 drefr = refract(dp, dn, 1.0/spaceship_refractRatio);\n  vec3 dcol = 0.9*spaceship_domeColor(dp, drefr, input0, input1);\n\n  vec3 gp = ro + rd*gi.y;\n  vec3 gpy = ro + rd*gi.x;\n  vec3 gn = -normalize(vec3(gp.xy-spaceship_start.xy, 0.0));\n  vec2 gp2 = cylinderCoord(gp);\n\n  vec3 cp = ro + rd*ci.y;\n  vec3 cn = -normalize(vec3(cp.xy-spaceship_start.xy, 0.0));\n\n  vec3 fpcol = vec3(0.0);\n\n  vec3 scol;\n  vec4 bpcol = spaceship_backplane(ro, rd, scol);\n  vec3 bpn = vec3(0.0, 0.0, 1.0);\n  float bpdiff = max(dot(rd, bpn), 0.0);\n\n  vec3 col = vec3(0.0);\n\n  col = mix(col, fpcol, vec3(fd > gi.y));\n  col = mix(col, dcol, vec3(dp.z < 0.0));\n  col = mix(col, bpcol.xyz, bpcol.w);\n\n  if (gp.z > 0.0 && gpy.z < 0.0 && gp.z < spaceship_innerLength) {\n    float level = 0.0;\n    level += 1.0-smoothstep(0.0, 0.1*spaceship_innerLength, gp2.x);\n    level += 1.0-smoothstep(0.0, 0.1*spaceship_innerLength, spaceship_innerLength-gp2.x);\n\n    /*\n    // Too fix discontinuity. Alternative approach, place the camera correctly ;)\n    level += 1.0-smoothstep(-PI, -PI+0.5, gp2.y);\n    level += 1.0-smoothstep(PI, PI-0.5, gp2.y);\n    */\n\n    level *= 0.125;\n    vec3 gcol = spaceship_sea(ro, rd, gn, gp, gp2);\n    gcol = spaceship_islands(gcol, gp, gn, gp2, level);\n    gcol = spaceship_cloudShadows(gcol, gp, level);\n    gcol = spaceship_clouds(gcol, ro, rd, cp, cn, cylinderCoord(cp), level);\n    col = gcol;\n  }\n\n  float id = max(gi.y-max(gi.x, 0.0), 0.0);\n  col = mix(col, spaceship_sunCol1, 1.0-exp(-0.05*id*id));\n  col = mix(col, 0.75*scol + 1.25*spaceship_sunCol1, pow(bpdiff, 35.0));\n\n  return col;\n}\n\nfloat spaceship_theShip(float ltime, vec3 p, out float nx, out float ny, out int m) {\n  const float rep = 5.0;\n  const float tradius = 1.2;\n  const float sstep = TAU*1.125/rep;\n  const float sradius = 0.45*TAU*1.125/rep;\n  rot(p.xy, ltime*TAU/60.0);\n  float dcapsule = capsule(p, spaceship_outerLength, 1.0);\n  dcapsule = pmin(dcapsule, softBox(p, 0.75), 0.25);\n  float dglobe = max(dcapsule, p.z);\n\n  vec3 pc = p;\n  pc.z -= 0.5*sstep;\n  float n = mod1(pc.z, sstep);\n  float dtorus = torus(pc.xzy, vec2(tradius*1.55, 0.025));\n  float nm = modPolar(pc.xy, rep);\n  float dspoke = cylinder(pc, vec3(tradius*1.55, 0.0, 0.025));\n  dtorus = min(dtorus, dspoke);\n  dtorus = max(dtorus, -p.z + sstep*0.5-0.025);\n  dtorus = max(dtorus, p.z-sstep*5.0 + sstep*0.5-0.025);\n  float dbattery = sphere(pc - vec3(tradius, 0.0, 0.0), sradius);\n  float dbox = softBox(pc - vec3(tradius, 0.0, 0.0), sradius*0.9);\n  dbox = roundDiff(dbox, dbattery, 0.125);\n  dbattery = min(dbattery, dbox);\n  dbattery = max(dbattery, -p.z + sstep*0.05);\n  dbattery = max(dbattery, p.z-sstep*5.0);\n  float dengine1 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+1.0)), 0.9);\n  float dengine2 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+2.0)), 0.9);\n  float dengine3 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+1.0)), 0.25);\n  float dengine = dengine1;\n  dengine = max(dengine, -dengine2);\n  dengine = min(dengine, dengine3);\n  vec3 pe = p;\n  pe -= vec3(0.0, 0.0, spaceship_outerLength+1.8);\n  mod1(pe.x, 0.5);\n  mod1(pe.y, 0.5);\n  float d = dcapsule;\n  d = min(d, dengine);\n  d = chamfer(d, dbattery, 0.035);\n  d = min(d, dtorus);\n\n\n  m = 1;\n\n  if (d == dglobe) m = 3;\n  if (d == dbattery) m = 4;\n  if (d == dtorus) m = 1;\n  if (d == dbox) m = 2;\n  if (d == dengine1) m = 2;\n  if (d == -dengine2) m = 5;\n  if (d == dengine3) m = 5;\n\n  nx = n;\n  ny = nm;\n\n  return d;\n}\n\nfloat spaceship_map(float ltime, vec3 p, out float nx, out float ny, out int m) {\n  return spaceship_theShip(ltime, p, nx, ny, m);\n}\n\n\nfloat spaceship_rayMarch(float ltime, vec3 ro, vec3 rd, out float nx, out float ny, out int mat, out int iter) {\n  float t = 0.0;\n  float d;\n  int i;\n  for (i = 0; i < SPACESHIP_MAX_RAY_MARCHES; i++)\n  {\n    d = spaceship_map(ltime, ro + rd*t, nx, ny, mat);\n    if (d < SPACESHIP_TOLERANCE || t > SPACESHIP_MAX_RAY_LENGTH) break;\n    t += d; // 0.9\n  }\n  iter = i;\n\n  if (abs(d) > 10.0*SPACESHIP_TOLERANCE) return SPACESHIP_MAX_RAY_LENGTH;\n\n  return t;\n}\n\nvec3 spaceship_normal(float ltime, vec3 pos) {\n  vec3  eps = vec3(SPACESHIP_NORM_OFF,0.0,0.0);\n  vec3 nor;\n  float nx;\n  float ny;\n  int mat;\n  nor.x = spaceship_map(ltime, pos+eps.xyy, nx, ny, mat) - spaceship_map(ltime, pos-eps.xyy, nx, ny, mat);\n  nor.y = spaceship_map(ltime, pos+eps.yxy, nx, ny, mat) - spaceship_map(ltime, pos-eps.yxy, nx, ny, mat);\n  nor.z = spaceship_map(ltime, pos+eps.yyx, nx, ny, mat) - spaceship_map(ltime, pos-eps.yyx, nx, ny, mat);\n  return normalize(nor);\n}\n\nvec3 spaceship_innerColor(float ltime, vec3 ro, vec3 rd, vec3 nor, float nx, float ny) {\n  vec2 f = hash2(137.0*vec2(nx, ny)+27.0);\n  vec3 refr = refract(rd, nor, 3.0);\n  float dim = smoothstep(0.6, 0.7, f.x);\n  dim *= mix(0.5, 1.0, psin(2.0*ltime+f.y*TAU));\n  float s1 = mix(0.3, 2.0, dim);\n  float s2 = mix(1.0, 1.25, dim);\n  float m = max(dot(nor, -refr), 0.0);\n  return 1.5*s1*pow(vec3(1.2, 1.1, s2)*m, 1.25*vec3(2.5, 2.5, 5.5));\n}\n\nvec3 engineColor(vec3 ro, vec3 rd, vec3 nor) {\n  float eradius = length(ro.xy);\n  float emradius = eradius;\n  float eangle = atan(ro.y, ro.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.2);\n  mod1(emangle, TAU/20.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n\n  float efadeout = 1.0 - smoothstep(0.0, 0.75, eradius);\n  float ifadeout = smoothstep(0.2, 0.225, eradius);\n\n  vec3 refr = refract(rd, nor, 1.25);\n  float m = max(dot(nor, -refr), 0.0);\n\n\n  vec3 scol = vec3(0.0);\n  scol += 4.0*spaceship_engineCol1*pow(m, 4.0);\n  scol += spaceship_engineCol2*2.0;\n  scol *= 1.0- ifadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += elinec*smoothstep(0.02, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.05, 0.0, abs(emangle))*efadeout;\n  ecol += spaceship_engineCol2*2.0*efadeout*efadeout;\n  ecol *= ifadeout;\n\n  return ecol + scol;\n}\n\nvec3 spaceship_render(float ltime, float input0, float input1, vec3 ro, vec3 rd) {\n  // background color\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  int mat = 0;\n  int iter = 0;\n  float nx;\n  float ny;\n  float t = spaceship_rayMarch(ltime, ro, rd, nx, ny, mat, iter);\n\n//  vec3 icol = 1.0*vec3(1.0, 0.0, 0.9)*smoothstep(0.5, 1.0, float(iter)/MAX_RAY_MARCHES);\n  const  vec3 icol = vec3(0.0);\n\n  vec3 pos = ro + t*rd;\n  vec3 nor = spaceship_normal(ltime, pos);\n\n  float ndif = 1.0;\n  float nref = 0.8;\n\n  vec3 ref  = reflect(rd, nor);\n  vec3 rcol = spaceship_refColor(pos, ref, input0, input1);\n  vec3 refr = refract(rd, nor, spaceship_refractRatio);\n\n  if (t < SPACESHIP_MAX_RAY_LENGTH) {\n    // Ray intersected object\n\n    switch(mat) {\n    case 0:\n      color = mix(vec3(1.0), nor*nor, 0.5);\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 1:\n      color = vec3(0.9) + abs(nor.zxy)*0.1;\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 2:\n      color = vec3(0.25) + abs(nor.zxy)*0.05;\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 3:\n      vec3 sicol = spaceship_shipInterior(pos, refr, input0, input1);\n      color = mix(sicol, rcol, vec3(refr == vec3(0.0)));\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 4:\n      color = spaceship_innerColor(ltime, pos, rd, nor, nx, ny);\n      ndif = 0.75;\n      nref = 0.9;\n      break;\n    case 5:\n      color = engineColor(pos, rd, nor);\n      ndif = 0.5;\n      nref = 0.75;\n      break;\n    default:\n      color = nor*nor;\n      break;\n    }\n\n  }\n  else {\n    // Ray intersected sky\n    return spaceship_skyColor(ro, rd, input0, input1) + icol;\n  }\n\n  vec3 ld0  = vec3(0.0, 1.0, 0.0);\n\n  vec3 lv1  = sunDirection;\n  float ll1 = length(lv1);\n  vec3 ld1  = lv1 / ll1;\n\n  vec3 lv2  = smallSunDirection;\n  float ll2 = length(lv2);\n  vec3 ld2  = lv2 / ll2;\n\n  int rmat = 0;\n  int riter = 0;\n  float st  = spaceship_rayMarch(ltime, pos + ref*10.0*SPACESHIP_TOLERANCE, ref, nx ,ny, rmat, riter);\n  float sha2 = st < SPACESHIP_MAX_RAY_LENGTH ? 0.0 : 1.0;\n\n  float dif0 = pow(max(dot(nor,ld0),0.0), ndif);\n  float dif1 = pow(max(dot(nor,ld1),0.0), ndif);\n  float dif2 = pow(max(dot(nor,ld2),0.0), ndif);\n\n  vec3 col0 = mix(vec3(1.0), dif0*vec3(1.0), 0.8);\n  vec3 col1 = mix(vec3(1.0), dif1*spaceship_sunCol1, 0.8);\n  vec3 col2 = mix(vec3(1.0), dif2*spaceship_sunCol2, 0.8);\n\n  vec3 col = mix(rcol*sha2, color*(col0 + col1 + col2)/2.0, nref);\n\n  return col + icol;\n}\n\nvec3 spaceship_fragment(float ltime, float input0, float input1, vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  return spaceship_render(ltime, input0, input1, ro, rd);\n}\n\n\nvec3 spaceship_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n\n  vec3 ro  =vec3(1.0, 0.0, -3.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  switch(minor) {\n  case MINOR_FROM_BEHIND:\n    ro = 3.0*vec3(0.5-ltime/10., 1.0+ltime/5.0, 15.0-ltime);\n    break;\n  case MINOR_CYLINDER_SEA:\n    ro = vec3(-7.5+ltime, 0.5, -1.5-ltime/10.0);\n    break;\n  case MINOR_FROM_FRONT:\n    ro = -3.0*vec3(-0.5+ltime/10., 1.0-ltime/5.0, 10.0-ltime);\n    break;\n  default:\n    break;\n  }\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n  col += spaceship_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o1);\n\n#ifdef AA\n  // Adaptive AA? Is that a good idea?\n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+1.0/256);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n  if (de > 0.1) {\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p-o1);\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p+o2);\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n#endif\n\n  return col;\n}\n\n#endif\n\n// -----------------------------==> SPACESHIP <==------------------------------\n\n// -------------------------------==> MAIN <==---------------------------------\n\nvec3 mainImage(vec2 p, vec2 q) {\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float effectNo = 0.0;\n  const float totalTime = float(effects.length())*DURATION + (DURATION1-DURATION);\n  float dtime = mod(max(TIME, 0.0), totalTime)-(DURATION1 - DURATION);\n\n  float timeInEffect = mod(dtime, DURATION);\n  int effectIndex = int(effectNo + mod(dtime/DURATION, float(effects.length())));\n\n  if (dtime < DURATION) {\n    // Special handling for first effect\n    timeInEffect = dtime+DURATION1 - DURATION;\n    effectIndex = 0;\n  }\n\n  Effect effect = effects[effectIndex];\n  Effect nextEffect = effects[int(((effectIndex + 1)%effects.length()))];\n  float ltime = timeInEffect + effect.seq*DURATION;\n\n  vec3 col = vec3(0.5);\n\n\n  switch(effect.major) {\n#ifdef ENABLE_NOEFFECT\n  case MAJOR_NOEFFECT:\n    col = noeffect_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_IMPULSE\n  case MAJOR_IMPULSE:\n    col = impulse_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_ORRERY\n  case MAJOR_ORRERY:\n    col = orrery_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_WATERWORLD\n  case MAJOR_WATERWORLD:\n    col = waterworld_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_BARRENMOON\n  case MAJOR_BARRENMOON:\n    col = barrenmoon_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_GALAXY\n  case MAJOR_GALAXY:\n    col = galaxy_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_SPACESHIP\n  case MAJOR_SPACESHIP:\n    col = spaceship_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n  default:\n    col = vec3(0.5, 0.0, 0.0);\n    break;\n  }\n\n  col = clamp(col, 0.0, 1.0);\n\n  float fadeIn  = smoothstep(0.0, FADEIN, timeInEffect);\n  float fadeOut = smoothstep(DURATION - FADEOUT, DURATION, timeInEffect);\n  float tfadeout = smoothstep(DURATIONT - 2.0*DURATION, DURATIONT, TIME);\n\n  if (effect.fade && effect.seq == 0.0) {\n    col = mix(vec3(0.0), col, fadeIn*fadeIn);\n  }\n\n  if (effect.fade && nextEffect.seq == 0.0){\n    col = mix(col, vec3(0.0), fadeOut*fadeOut);\n  }\n\n  col = mix(col, vec3(0.0), tfadeout*tfadeout);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  fragColor = vec4(mainImage(p, q), 1.0);\n}\n\n// -------------------------------==> MAIN <==---------------------------------\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyWf.jpg", "access": "api", "license": "cc0-1.0", "functions": [[6146, 6146, 6167, 6167, 6208], [6210, 6210, 6232, 6232, 6276], [6278, 6278, 6303, 6303, 6332], [6334, 6334, 6373, 6373, 6498], [6500, 6500, 6536, 6536, 6630], [6632, 6632, 6659, 6659, 6728], [6730, 6730, 6779, 6779, 7181], [7183, 7183, 7205, 7205, 7374], [7376, 7376, 7411, 7411, 7729], [7731, 7731, 7762, 7762, 7788], [7790, 7790, 7821, 7821, 7847], [7849, 7849, 7876, 7876, 7952], [7954, 7954, 8004, 8004, 8221], [8223, 8254, 8286, 8286, 8362], [8364, 8364, 8393, 8393, 8458], [8461, 8461, 8502, 8502, 8557], [8559, 8559, 8591, 8591, 8625], [8628, 8628, 8646, 8646, 8668], [8670, 8670, 8688, 8688, 8710], [8711, 8711, 8741, 8741, 8776], [8778, 8778, 8811, 8811, 8896], [8898, 8898, 8932, 8932, 8956], [8958, 8958, 8997, 8997, 9260], [9262, 9262, 9290, 9290, 9329], [9331, 9331, 9355, 9355, 9425], [9427, 9427, 9447, 9447, 9545], [9547, 9547, 9586, 9586, 9675], [9677, 9677, 9729, 9729, 9817], [9819, 9819, 9861, 9861, 9911], [9913, 9913, 9958, 9958, 9997], [9998, 9998, 10019, 10019, 10048], [10050, 10050, 10071, 10071, 10100], [10102, 10102, 10157, 10157, 10480], [10482, 10482, 10524, 10524, 10571], [10573, 10573, 10617, 10617, 10875], [10878, 10878, 10944, 10944, 11447], [11450, 11450, 11472, 11472, 12025], [12027, 12027, 12049, 12049, 12389], [12420, 12420, 12443, 12443, 12496], [12498, 12498, 12521, 12521, 12699], [12701, 12701, 12724, 12724, 12854], [12856, 12856, 12879, 12879, 12952], [12954, 12954, 12977, 12977, 13014], [13016, 13016, 13039, 13039, 13296], [13298, 13298, 13321, 13321, 13399], [13401, 13401, 13424, 13424, 14161], [14163, 14163, 14202, 14202, 14560], [14562, 14562, 14608, 14608, 16039], [16041, 16041, 16077, 16102, 16352], [64833, 64833, 64865, 64865, 67160], [67162, 67162, 67214, 67214, 67319]], "test": "untested"}
{"id": "tllcDX", "name": "simple frosted glass", "author": "indere", "description": "frosted glass", "tags": ["frostedglass"], "likes": 10, "viewed": 1182, "published": 3, "date": "1593329580", "time_retrieved": "2024-07-30T20:58:50.332486", "image_code": "// 2D Random\nfloat random2 (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec2 myPattern(in vec2 uv){\n\tvec2 uv2 = uv;\n    uv2.y = uv2.y + 1.0 * (random2(uv));\n    //uv2.x = uv2.x + 1.0 * (random2(uv));\n    return uv2 - uv;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 p = uv;\n  for (int i = 0; i < 10; i ++) p -= myPattern(p) * 0.03;\n  vec3 col = texture(iChannel0, p).rgb;\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 41, 41, 114], [116, 116, 143, 143, 266], [268, 268, 324, 324, 515]], "test": "untested"}
{"id": "3tsyWf", "name": "Day 190", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 19, "viewed": 518, "published": 3, "date": "1593290927", "time_retrieved": "2024-07-30T20:58:51.146311", "image_code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./50.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[11](4.2*speed,4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 1.2*speed, 1.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    t += sumScenes(7.)- 0.;\n    \n    t = mod(t, sumScenes(9.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*0.25;\n    \n    float its = 15.;\n    float scene = 0.;\n    \n    vec2 p = uv;\n\n    vec4 q = vec4(p,1,1);\n\n    float dt = 10e5;\n    float dFirst = 10e5;\n\n    for(float i = 0.; i < its; i++){\n        float tsc = i/its*1.5;\n        float enva = eass((t - tsc)/scenes[0]*1.,3.);\n\n        float envb = eass((t - tsc - scenes[0])/scenes[0]*1.,3.);\n\n        float envc = eass((t - tsc - sumScenes(1.))/scenes[0]*1.,3.);\n        float envd = eass((t - tsc - sumScenes(2.))/scenes[0]*1.,3.);\n\n        float enve = eass((t - tsc - sumScenes(3.))/scenes[0]*1.,3.);\n\n        float envf = eass((t - tsc - sumScenes(4.))/scenes[0]*1.,3.);\n\n        float envg = eass((t - tsc - sumScenes(5.))/scenes[0]*1.,3.);\n\n        float envh = eass((t - tsc - sumScenes(6.))/scenes[0]*1.,3.);\n\n        vec2 b = p;\n\n\n        b *= rot(enve*pi*1. );\n        //b = mix(b,abs(b),1.);\n\n        b -= 0.25 - 0.25*enve - 0.25*envh;\n        b.x += 0.5*enva;\n        b.y += 0.5*envb;\n        b.x -= 0.5*envc;\n        b.y -= 0.5*envd;\n        b *= rot(enva*pi/2. + envb*pi/2. + envc*pi/2.   - envh*pi*0. );\n\n        b *= rot(envf*pi/1. - .5*envh*pi );\n\n\n        float itsifs = 1. + envg*1.  - envh*1.;\n        for(float i = 0.; i < itsifs + 1.; i++){\n            vec2 f = abs(b);\n            //b -= 0.01;\n\n            f *= rot(0.25*pi*envd - 0.25*pi*envg);\n            //f *= rot(0.25*pi*envf);\n            \n            b = mix(b,f,smoothstep(0.,1.,itsifs - i));\n\n        }\n\n        b.xy *= rot(tau*i/its/1.*(envg - envh) );\n\n        //b.y -= 0.3;\n        //b.y += 0.2*enva;\n\n        //b.y += sin((i)/1. - t*pi)*0.1;\n        //b.xy *= rot(i*0.4 + iTime/3.);\n\n        float ld = sdBox(b,triW);\n\n        vec2 g = b;\n        ld = min(ld,sdBox(b,vec2(0.0,0.4)));\n        b = abs(b) - vec2(0,0.2);\n        ld = min(ld,sdBox(b,vec2(0.01,0.01)));\n        b = b - vec2(0,0.2);\n        ld = min(ld,sdBox(b,vec2(0.01,0.01)));\n\n        ld = max(ld,-sdBox(g,vec2(0.005,0.05)));\n\n\n        vec4 q = vec4(b,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n\n        q = pmod(abs(q),0.04);\n\n        float dbq = sdBox(q,vec4(0.004 + 0.006*envd - envh*0.006));\n\n        float slider = smoothstep(0.,1.,i/its + envd*0.4 - envh*0.4 )*1.;\n\n        if(i == 0.){\n            dFirst = ld;\n\n            dFirst = mix(dFirst,max(ld,dbq),slider);\n\n        } else {\n            //ld = \n            //slider = 0.1;\n\n        }   \n        float ldb = ld;\n        ld = mix(ld,abs(dbq),slider);\n\n        ld = mix(ld,max(ld,ldb),slider);\n\n        dt = min(dt,abs(ld));\n\n        dt = mix(dt, abs(pmod(dt ,0.04 )) ,slider);\n\n\n    }\n    d = min(d,dt); \n    d = min(d,dFirst);\n\n    d = abs(d);\n\n\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 318, 318, 374], [377, 388, 425, 425, 733], [734, 734, 771, 771, 818], [819, 819, 856, 856, 921], [976, 976, 1028, 1028, 1147], [1327, 1327, 1355, 1355, 1462], [1464, 1464, 1533, 1533, 1689], [1690, 1690, 1720, 1720, 1829], [1891, 1891, 1918, 1918, 4906]], "test": "untested"}
{"id": "wlXyDX", "name": "Julia - Triangle Inequality", "author": "iq", "description": "Triangle Inequality coloring, designed by Damien M. Jones and Javier Barrallo. This is an adaptation of code I wrote in 2001. Unfortunately it only works in double precision, so what you see is an incomplete picture (hairs/flumes should be way longer)", "tags": ["2d", "fractal", "julia", "triangleinequality"], "likes": 17, "viewed": 855, "published": 3, "date": "1593285805", "time_retrieved": "2024-07-30T20:58:51.981078", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Triangle Inequality coloring. This is an adaptation of\n// code I wrote in 2001. The algorihtm was designed by \n// Damien M. Jones and Javier Barrallo who were trying to\n// measure the average orbit curvature.\n//\n// The algorithm requires double precision floating point\n// numbers, which GLSL doesn't support. See line 32. So\n// this image you see here is just an approximation to the\n// real image, which should have way longer hairs going out\n// all the way to the border of the image.\n\n\n#define AA 2\n\nvec3 render( vec2 p, float time )\n{\n    // animation\n\tfloat ltime = 0.5-0.5*cos(time*0.06);\n    float zoom = pow( 0.9, 40.0*ltime );\n\tvec2  cen = vec2( 0.2655,0.301 ) + zoom*0.8*cos(4.0+2.0*ltime);\n\tvec2 c = vec2( -0.745, 0.186 ) - 0.045*zoom*(1.0-ltime*0.5);\n\n    // pixel to z plane\n    p = (2.0*p-iResolution.xy)/iResolution.y;\n\tvec2 zo = cen + (p-cen)*zoom;\n    \n    // iteration\n    float th  = 1e7; // th needs to be way bigger to work well, but in\n    float ld2 = 1.0; // WebGL we only have floats, so it that sucks!\n    const int kNumIterations = 2048;\n    vec2  z = zo;\n    float lz2 = dot(z,z);\n    float ti_av1 = 0.0;\n    float ti_av2 = 0.0;\n\tfloat ti_lc = length(c);\n    float n = 0.0;\n    for( int i=0; i<kNumIterations; i++ )\n\t{\n        // z' = 2·z·z', derivative of z for distance computation\n        ld2 *= 4.0*lz2; \n        \n        // z = z²+c\n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n        \n        // escape condition\n\t\tfloat olz2 = lz2;\n        lz2 = dot(z,z);\n\t\tif( lz2>th*th ) break;\n        \n        // triangle inequality\n        if( i>0 )\n        {\n        \tti_av2 = ti_av1;\n            float mi = abs(olz2 - ti_lc);\n            float ma = olz2 + ti_lc;\n            ti_av1 += (sqrt(lz2)-mi)/(ma-mi);\n        }\n        \n        // iteration counter\n        n += 1.0;\n\t}\n    \n    // --- properties ---\n    \n    // continuous iteration : https://iquilezles.org/articles/msetsmooth\n    float f = log2(log(length(z))/log(th));\n    float sn = n - f;\n    \n    // distance: https://iquilezles.org/articles/distancefractals\n    float d = sqrt(lz2/ld2)*log(lz2);\n\n    // triangle inequality\n\tti_av1 = ti_av1/(n    );\n    ti_av2 = ti_av2/(n-1.0);\n\tti_av1 = ti_av2+(ti_av1-ti_av2)*smoothstep(0.0,1.0,1.0-f);\n    \n    // --- coloring ---\n    \n    vec3 col = max(0.6+0.8*sin(ti_av1*1.5 + 5.5 + vec3(0.0,0.3,0.5)),0.0);\n    col *= clamp( 1024.0*d/zoom, 0.0, 1.0 );\n        \n    return col;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = vec2(float(i),float(j))/float(AA)-0.5;\n\t    col += render( fragCoord+of, iTime );\n\t}\n\tcol /= float(AA*AA);\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXyDX.jpg", "access": "api", "license": "mit", "functions": [[1585, 1585, 1620, 1637, 3503], [3506, 3506, 3563, 3563, 3800]], "test": "untested"}
{"id": "WtlcWX", "name": "Moon and Sea", "author": "dean_the_coder", "description": "First attempt at a water effect.\nStarted off making a 'day time' scene, but by happy accident made a 'night scene' instead!", "tags": ["3d", "raymarching", "sea", "water", "moon"], "likes": 16, "viewed": 617, "published": 3, "date": "1593278130", "time_retrieved": "2024-07-30T20:58:52.718108", "image_code": "// Processed by 'GLSL Shader Shrinker' (2,112 to 1,707 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nfloat sdWaves(vec3 p) {\n\tfloat t,\n\t      h = 0.,\n\t      a = 1.,\n\t      f = 1.1;\n\tmat2 r = rot(3.7692);\n\tt = iTime / -3.;\n\tfor (float i = 0.; i < 6.; i++) {\n\t\tp.xz *= r;\n\t\th += 1. - abs(sin(f * ((p.x + sin(p.z * a)) + t))) * a;\n\t\ta /= 1.97;\n\t\tf *= 2.02;\n\t\tt *= -.95;\n\t}\n\n\treturn p.y - h / 7.;\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst vec2 e = vec2(1, -1) * .0005;\n\treturn normalize(e.xyy * sdWaves(p + e.xyy) + e.yyx * sdWaves(p + e.yyx) + e.yxy * sdWaves(p + e.yxy) + e.xxx * sdWaves(p + e.xxx));\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n\tvec3 rd = normalize(lightPos - p);\n\tfloat h,\n\t      minH = 1.,\n\t      d = .1;\n\tfor (int i = 0; i < 16; i++) {\n\t\th = sdWaves(p + rd * d);\n\t\tminH = abs(h / d);\n\t\tif (minH < .01) return 0.;\n\t\td += h;\n\t}\n\n\treturn minH * sharpness;\n}\n\nfloat glow = 0.;\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col;\n\t{\n\t\tvec3 p,\n\t\t     rd = getRayDir(vec3(0, 1.5, -10), vec3(0), uv);\n\t\tbool hit = false;\n\t\tfloat d = .01;\n\t\tfor (float steps = 0.; steps < 128.; steps++) {\n\t\t\tp = vec3(0, 1.5, -10) + rd * d;\n\t\t\tfloat h = sdWaves(p),\n\t\t\t      dd = length(p - vec3(.1, 2, -2));\n\t\t\tglow += .1 / (.1 + dd * dd * 5.);\n\t\t\tif (dd < h) h = dd;\n\t\t\tif (h < .005 * d) {\n\t\t\t\thit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td += h;\n\t\t}\n\n\t\tif (hit) {\n\t\t\tvec3 n = calcNormal(p),\n\t\t\t     lightToPoint = normalize(vec3(4, 20, 10) - p);\n\t\t\tfloat sha = calcShadow(p, vec3(4, 20, 10), 5.),\n\t\t\t      mainLight = max(0., dot(n, lightToPoint)),\n\t\t\t      fog = 1. - exp(-d * .02);\n\t\t\tcol = mix((mainLight * sha + 2.) * vec3(1, .9, .8), vec3(.15, .2, .25), (1. - .98 * max(0., dot(rd, n))));\n\t\t\tcol *= vec3(.2, .32, .41);\n\t\t\tcol = mix(col, vec3(.15, .2, .25), fog);\n\t\t}\n\t\telse col = vec3(.15, .2, .25);\n\t}\n\tfragColor = vec4(pow(vignette(clamp(col + max(0., glow), 0., 1.), fragCoord), vec3(.4545)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 143, 143, 210], [212, 212, 259, 259, 431], [433, 433, 456, 456, 726], [728, 728, 753, 753, 926], [928, 928, 986, 986, 1216], [1235, 1235, 1276, 1276, 1402], [1404, 1404, 1456, 1456, 2475]], "test": "untested"}
{"id": "3tXcWf", "name": "Generative Vasarely - Cinétique", "author": "ciphered", "description": "As a tribute to Victor Vasarely, a challenge to myself, and one of these urges, I wanted to recreate some works of Vasarel. I posted some of these recreations on my Instagram, feel free to check it out: @ciphrd\nSee top of shader for details on this work", "tags": ["moire", "recreation", "vasarely", "cinetic"], "likes": 8, "viewed": 428, "published": 3, "date": "1593221296", "time_retrieved": "2024-07-30T20:58:53.635655", "image_code": "// \n// Beta 1958 - 1964, is a work by Victor Vasarely\n// I found the existence of this piece in the book Vasarely, Magdalena Holzhey, p.10)\n// However, there is little to no existence of this work that can be found online (at\n// least from my research). I could only find some colored version on bidding websites,\n// so I don't know about the authenticity of these pieces. While researching, I found\n// a version I liked:\n// https://www.amorosart.com/oeuvre-vasarely-objet_cin%C3%A9tique-71325.html\n//\n// It is labbeled \"Objet Cinétique\", and unfortunatly a lot of different pieces related \n// to Vasarely labelled \"Objet Cinétique\" can be found online. It is possible that this \n// version was from him, and likely that it was some recreation of his work Beta (this\n// is a guess from me, I haven't verified this information).\n//\n// Vasarely wanted his work to be similar as music sheets,\n// interpretable by anyone as they liked. He really wanted art to be more accessible,\n// regardless of their background. I thought that recreating this particular version,\n// that I liked more than his original work Beta, could be a great tribute to both \n// Beta and Vasarely's ideology.\n//\n// About the piece: since I diverged so much from the original work, I decided to try\n// my best at recreating an accurate version of \"Objet Cinétique\".\n//\n//\n// HOW TO LOOK AT THE PIECE\n//\n// This piece was made to be watched in full screen, by staring at the center for the\n// whole duration of the animation. Due to how vision gets tricked in seeing a slow\n// an continuous motion towards the center, the brain starts to have issues processing \n// the high contrast between the bands, and starts will feel incomfortable keeping the\n// focus at the center. After 55s, once the motion stops, the piece reaches its final\n// state, close to the version I tried to recreate. If the focus was kept at the center\n// the work will seem to glitter because the brain still thinks there is motion and is\n// lost by this static state. Bands becomes unstable. A weird feeling emerge when the\n// brain realizes that nothing moves anymore, but the glitter will never trully stops.\n// If you slightly look arround the center, the \"disk\" will appear to be rotating.\n//\n// Special Thanks to @FabriceNeyret2 for the time he took to review and optimize this\n// shader. This version was re-written with his precious advice.\n//\n\n\n\n#define C_WIDTH_MIN .05\n#define C_WIDTH_MAX .018\n#define L_SMOOTH .15\n#define PI 3.1415926\n\n#define rot(a)   mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define rand(n)  fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    \n    // piece is designed for 55s, t € [0;1]\n    float t = min(1., iTime / 55.0);\n    \n    \n    // space is divided into circles\n   \tfloat cwidth = mix(C_WIDTH_MIN, C_WIDTH_MAX, t);\n    float dc = length(uv) / cwidth;\n    \n    // circle division\n    float circ = abs(fract(dc) - .5);\n    \n    // the square\n    vec2 v = smoothstep(0.27, 0.23, abs(uv) * rot(t * PI * 4.));\n    float rect = pow(v.x* v.y, 10.);\n    \n    // the width of the circle line\n    float width = 0.15 + 0.11 * rect;\n    // we add some variation to it\n    float ang = atan(uv.y, uv.x);\n    float id = floor(dc);\n    width+= cos(-id * .2 + ang*2. + t * 15.) * .05 + .05;\n    \n    // to match with our model, only 20 circles are visible\n    if (dc > 21.) width = .3;\n\n    \n    // this isn't antialiasing, this was made to create moiré patterns, amplifying the illution of a motion \n    // having a constant value to smoothen is what makes the moiré works at any resolution, from my observations\n    float c = smoothstep(width, width - L_SMOOTH, circ);\n    \n    // we cut outer ring\n    c*= step(dc, 22.);\n    \n    // we cut a square out of this, and create a border arround it\n    v = step(abs(uv), vec2(.4));\n    float inside = v.x * v.y;\n    v = step(abs(uv), vec2(.42));\n    float border = v.x * v.y;\n    c*= inside;\n    c+= 1.0 - border;\n    c+= .15 * rand(uv);\n    \n    // the background\n    c*= clamp(pow(max(0., (1.-length(uv))), .2)* 1.1, .2, 1.);\n\n    // Output to screen\n    fragColor = c * vec4(1., 1., 0.92, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2620, 2620, 2677, 2677, 4250]], "test": "untested"}
{"id": "ttfyWX", "name": "background detect", "author": "sh1boot", "description": "Click on output to reset background capture buffer.", "tags": ["webcambackgroundremoval"], "likes": 3, "viewed": 710, "published": 3, "date": "1593216227", "time_retrieved": "2024-07-30T20:58:55.323143", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 cam = texture(iChannel0, uv);\n#if 0\n    vec4 bkg = texture(iChannel1, uv);\n#else\n    vec4 bkg = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n#endif\n\n    vec4 result = mix(cam, bkg, cam.a);\n\n    fragColor = result;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float alpha(vec3 a, vec3 b) {\n    const float k0 = 0.15, k1 = 0.75;\n\n    a = vec3(dot(a, vec3(0.299, 0.587, 0.114)),\n             dot(a, vec3(-0.14713, -0.28886, 0.436)),\n             dot(a, vec3(0.615, -0.51499, -0.10001)));\n    b = vec3(dot(b, vec3(0.299, 0.587, 0.114)),\n             dot(b, vec3(-0.14713, -0.28886, 0.436)),\n             dot(b, vec3(0.615, -0.51499, -0.10001)));\n    a.x *= k1;\n    b.x *= k1;\n    return 1.0 - smoothstep(k0 * 0.9, k0, distance(a, b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 cam = texture(iChannel0, uv).xyz;\n    vec3 bkg = texture(iChannel1, uv).xyz;\n    fragColor = vec4(cam, alpha(cam, bkg));\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 cam = texture(iChannel0, uv);\n    vec4 bkg = texture(iChannel1, uv);\n    vec4 blend = mix(cam, bkg, 0.998);\n    blend = mix(bkg, blend, cam.a);\n    if (iMouse.z > 0.0) blend = cam;\n    fragColor = blend;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 380]], "test": "untested"}
{"id": "ttXyWS", "name": "Fast simple gerstner water", "author": "dagbrynildsentholander", "description": "Attempt at creating fast, \"realistic\" water. Could  look a whole lot better with some tweaking. Some scaling would help solve the repetition issues that comes with not using any noise for the waves. The whole thing could be optimez a lot further.", "tags": ["sea", "water", "ocean"], "likes": 9, "viewed": 960, "published": 3, "date": "1593203440", "time_retrieved": "2024-07-30T20:58:56.164892", "image_code": "float pi = 3.14159265359;\nvec3 sunDir = normalize(vec3(1.5, 0.2, 0.0));\nvec3 sunColor = vec3(1, .6, .3)*3.0;\n\n\n//vec4[] waves = vec4[] (vec4(0.0, 1.0, 0.5, 1.4));\n\nvec4[] waves = vec4[] (vec4(1.0, 0.0, 1.0, 6.4),\n                      vec4(1.0, -0.2, 0.5, 3.6),\n                      vec4(1.0, 0.2, 0.3, 1.2),\n                      vec4(-0.8, -0.1, 0.15, 0.8));\n\nvoid Rx(inout vec3 v1, inout vec3 v2, inout vec3 v3, float theta)\n{\n    mat3 rm = mat3(\n        \t\t  \tvec3(1, 0, 0),\n            \t\tvec3(0, cos(theta), -sin(theta)),\n            \t\tvec3(0, sin(theta), cos(theta))\n             \t  );\n    v1*=rm;\n    v2*=rm;\n    v3*=rm;\n}\n\nvoid Ry(inout vec3 v1, inout vec3 v2, inout vec3 v3, float theta)\n{\n    mat3 rm = mat3(\n        \t\t  \tvec3(cos(theta), 0, sin(theta)),\n            \t\tvec3(0, 1, 0),\n            \t\tvec3(-sin(theta), 0, cos(theta))\n             \t  );\n    v1*=rm;\n    v2*=rm;\n    v3*=rm;\n}\n\nvoid Rz(inout vec3 v1, inout vec3 v2, inout vec3 v3, float theta)\n{\n    mat3 rm = mat3(\n        \t\t  \tvec3(cos(theta), -sin(theta), 0),\n            \t\tvec3(sin(theta), cos(theta), 0),\n            \t\tvec3(0, 0, 1)\n             \t  );\n    v1*=rm;\n    v2*=rm;\n    v3*=rm;\n}\n\nfloat waveFunction(float x)\n{\n    return sin(x-cos(x)/pi);\n}\n\nfloat waveDerivate(float x)\n{\n    return (cos(x - cos(x)/pi)*(pi + sin(x)))/pi;\n}\n\nvec4 oceanSurface(vec3 p)\n{\n    float base = 1.0;\n    vec3 normal = vec3(0);\n    for(int i = 0; i < waves.length(); i++)\n    {\n        vec2 waveDir = normalize(waves[i].xy);\n        float t = (p.x * waveDir.x + p.z * waveDir.y +iTime)/waves[i].w;\n        base += waveFunction(t)*waves[i].z;\n        normal += cross(vec3(1.0-waveDir.x*waveDir.x*(waves[i].z*waveFunction(t)), waveDir.x*(waves[i].z*waveDerivate(t)),-waveDir.x*waveDir.y*(waves[i].z*waveFunction(t))),\n                       vec3(-waveDir.x*waveDir.y*(waves[i].z*waveFunction(t)), waveDir.y*(waves[i].z*waveDerivate(t)),1.0-waveDir.x*waveDir.x*(waves[i].z*waveFunction(t))));\n    }\n    return vec4(base-p.y, -normalize(normal));\n}\n\nfloat ray(vec3 ro, vec3 rd, float mint, float maxt, float delta) \n{\n    float t = 0.0;\n    while(t<maxt)\n    {\n        if(oceanSurface(ro+rd*t).x > 0.0)\n        {\n                return t;\n        }\n        t += delta;\n        delta*=1.002;\n    }\n    return t;\n}\n\nvec3 drawSky(vec3 ro, vec3 rd)\n{\n    vec3 base = vec3(clamp(0.7-(rd.y*0.5), 0.0, 1.0), clamp(0.75-(rd.y*0.5), 0.0, 1.0), clamp(0.97-(rd.y*0.5), 0.0, 1.0));\n    base += pow(max(dot(rd, normalize(sunDir)), 0.0), 8.0)*sunColor*0.15;\n    base += pow(max(dot(rd, normalize(sunDir)), 0.0), 1024.0)*sunColor;\n    float clouds = 0.0;\n    vec2 uv = rd.xz/max(rd.y, 0.00001) + iTime/5.0;\n    clouds += texture(iChannel1, uv/50.0).x*0.75;\n    clouds += texture(iChannel1, uv/25.0).x*0.25;\n    clouds += texture(iChannel1, uv/12.0).x*0.15;\n    clouds += texture(iChannel1, uv/8.0).x*0.1;\n    clouds = min(clouds, 1.0);\n    base = mix(base, mix(vec3(0.5, 0.5, 0.6), sunColor, (1.0-clouds)*(dot(rd, sunDir)+1.0)/2.0),\n               pow(clouds, 4.0));\n    return base;\n}\n\nvec3 lighting(vec3 p, vec3 rd, vec3 n)\n{\n    vec3 result = vec3(0);\n    float specularStrength = 1.;\n\n    vec3 lightDir = normalize(sunDir);\n\n    // fresnel as suggested by blackle\n    \n    float fresnel = 1.0-abs(dot(rd,n))*0.98;\n    fresnel = pow(fresnel, 2.0);\n    \n    // specular\n    vec3 reflectDir = reflect(lightDir, n);\n    float spec = pow(max(dot(rd, reflectDir), 0.0), 512.);\n    vec3 specular = specularStrength * spec*sunColor*fresnel;  \n    \n    // reflection\n    vec3 reflRd = reflect(rd, n);\n    vec3 reflection = drawSky(p, reflRd)*fresnel;\n\n    // refraction //clamp(dot(sunDir, -rd), 0.0, 1.0)\n    vec3 refraction = mix(vec3(0.4, 0.5, 0.6),vec3(0.0, 0.35, 0.3)*sunColor,clamp(dot(sunDir, -n), 0.0, 1.0)*clamp(dot(sunDir, rd), 0.0, 1.0));\n    refraction = mix(refraction, vec3(0.0, 0.025, 0.05), clamp(-rd.y, 0.0, 0.8));\n    result += mix(reflection, refraction, max(dot(n, -rd), 0.0))+specular;\n\n    return result;\n}\n\nvec3 doFog(vec3 rgb, vec3 ro, vec3 rd, float dist)\n{\n    return mix(rgb, drawSky(ro, rd), pow(dist/200., 5.));\n}\n\nvec3 finalColor(vec3 ro, vec3 rd, float rayResult, vec3 n)\n{\n    vec3 col = lighting(ro+rd*rayResult, rd, n);\n    return doFog(col, ro, rd, rayResult);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -  iResolution.xy*.5)/iResolution.y;\n\n    // Camera setup\n    vec3 camRight = vec3(1, 0, 0);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camForward = vec3(0, 0, 1);\n    \n    // Camera rotation\n    vec3 camRot = texture( iChannel0, iResolution.xy).xyz + vec3(0,1.5,0);\n    Rx(camRight, camUp, camForward, camRot.x);\n    Ry(camRight, camUp, camForward, camRot.y);\n    Rz(camRight, camUp, camForward, camRot.z);\n    \n    // Camera movement\n    vec3 ro=texture( iChannel0, vec2(0)).xyz+vec3(0, 8., -5);\n    \n    // Ray\n    vec3 rd = normalize(camForward+(camRight*1.5*uv.x)+(camUp*1.5*uv.y));\n    float rayResult = ray(ro, rd, .1, 200., 0.1);\n    vec3 p = ro+rayResult*rd;\n    vec3 n = oceanSurface(p).yzw;\n\t\n    // Output to screen\n    if(rayResult==0.0)\n        fragColor = vec4(doFog(vec3(0), ro, rd, 100.), 1.);\n    else\n    {\n    \tvec3 col = finalColor(ro, rd, rayResult, n);\n    \t//fragColor = vec4(col,1.0);\n    \tfragColor = vec4(doFog(col, ro, rd, rayResult),1.0);\n    }\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat pi = 3.14159265359;\nvec2 lastNormMouse = vec2(0);\n//Key input taken from \"WASD movement\" by TekF (https://www.shadertoy.com/view/ldyGzW) \nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\n\nvoid Rx(inout vec3 v1, inout vec3 v2, inout vec3 v3, float theta)\n{\n    mat3 rm = mat3(\n        \t\t  \tvec3(1, 0, 0),\n            \t\tvec3(0, cos(theta), -sin(theta)),\n            \t\tvec3(0, sin(theta), cos(theta))\n             \t  );\n    v1*=rm;\n    v2*=rm;\n    v3*=rm;\n}\n\nvoid Ry(inout vec3 v1, inout vec3 v2, inout vec3 v3, float theta)\n{\n    mat3 rm = mat3(\n        \t\t  \tvec3(cos(theta), 0, sin(theta)),\n            \t\tvec3(0, 1, 0),\n            \t\tvec3(-sin(theta), 0, cos(theta))\n             \t  );\n    v1*=rm;\n    v2*=rm;\n    v3*=rm;\n}\n\nvoid Rz(inout vec3 v1, inout vec3 v2, inout vec3 v3, float theta)\n{\n    mat3 rm = mat3(\n        \t\t  \tvec3(cos(theta), -sin(theta), 0),\n            \t\tvec3(sin(theta), cos(theta), 0),\n            \t\tvec3(0, 0, 1)\n             \t  );\n    v1*=rm;\n    v2*=rm;\n    v3*=rm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Normalized mouse coordinates (from 0 to 1)\n    vec2 normMouse = vec2(iMouse.xy/iResolution.xy-.5);\n    \n    // Camera setup\n    vec3 camRight = vec3(1, 0, 0);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camForward = vec3(0, 0, 1);\n    \n    // Camera rotation\n    //vec3 camRot = vec3(-normMouse.y*360., normMouse.x*360.+180., 0)/180.*pi;\n    vec3 camRot = texture(iChannel0, iResolution.xy).xyz;\n\n    if(iMouse.z>0.)\n    \tcamRot += vec3(-normMouse.y*iTimeDelta*180., normMouse.x*iTimeDelta*180., 0)/180.*pi;\n    Rx(camRight, camUp, camForward, camRot.x);\n    Ry(camRight, camUp, camForward, camRot.y);\n    Rz(camRight, camUp, camForward, camRot.z);\n    \n    // Camera movement\n    vec3 ro=texture( iChannel0, vec2(0.0)).xyz;\n    ro+=(ReadKey(Key_W)-ReadKey(Key_S))*camForward*iTimeDelta*3.;\n    ro+=(ReadKey(Key_D)-ReadKey(Key_A))*camRight*iTimeDelta*2.;\n    ro+=(ReadKey(Key_E)-ReadKey(Key_Q))*camUp*iTimeDelta*2.;\n    \n    if(uv.x<=.5)\n    {\n    \tfragColor = vec4(ro.xyz, 1.0);  \n    }\n    else\n    {\n    \tfragColor = vec4(camRot.xyz, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 430, 430, 629], [631, 631, 698, 698, 897], [899, 899, 966, 966, 1165], [1167, 1167, 1196, 1196, 1227], [1229, 1229, 1258, 1258, 1310], [1312, 1312, 1339, 1339, 2005], [2007, 2007, 2074, 2074, 2269], [2271, 2271, 2303, 2303, 3027], [3029, 3029, 3069, 3069, 3965], [3967, 3967, 4019, 4019, 4079], [4081, 4081, 4141, 4141, 4234], [4237, 4237, 4294, 4344, 5343]], "test": "untested"}
{"id": "WlfcWf", "name": " Michaels cool algo + Pressure", "author": "wyatt", "description": ".", "tags": ["virtualtracking"], "likes": 26, "viewed": 644, "published": 3, "date": "1593201463", "time_retrieved": "2024-07-30T20:58:57.041549", "image_code": "\nMain {\n    R = iResolution.xy;\n\tQ = texture(iChannel1,U/R);\n    vec4 \n        n = texture(iChannel1,(U+vec2(0,1))/R),\n        e = texture(iChannel1,(U+vec2(1,0))/R),\n        s = texture(iChannel1,(U-vec2(0,1))/R),\n        w = texture(iChannel1,(U-vec2(1,0))/R);\n    vec3 no = normalize(vec3(e.x-w.x,-n.x+s.x,.1));\n    Q.x = atan(.8*log(1.+Q.x));\n    Q = Q.x*(.8+0.6*abs(cos(2.*Q.w+(1.+Q.y)*vec4(1,2,3,4))));\n    Q *= 0.9+0.5*texture(iChannel2,no);\n    Q = 1.-Q;\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog (U,a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog (U,a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog2 (U,a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog2 (U,a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 M;\nfloat T;\nint I;\n#define A(U) texture(cha,(U)/R)\n#define B(U) texture(chb,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\nfloat signe (float x) {return atan(100.*x);}\nvoid prog (vec2 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = vec4(0); b = vec4(0);\n    float n = 0.;\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 aa = A(U+u), bb = B(U+u);\n        #define q 1.075\n\t\tvec4 w = clamp(vec4(aa.xy-0.5*q,aa.xy+0.5*q),U.xyxy - 0.5,U.xyxy + 0.5);\n        float m = (w.w-w.y)*(w.z-w.x)/(q*q);\n        aa.xy = 0.5*(w.xy+w.zw);\n        a += aa*bb.x*m;\n        b.x += bb.x*m;\n        b.yzw += bb.yzw*bb.x*m;\n        n += bb.x;\n    }\n    if (b.x>0.) {\n        a/=b.x;\n        b.yzw/=b.x;\n        b.yzw = B(a.xy-a.zw).yzw;\n        a.zw = mix(A(a.xy-a.zw).zw,a.zw,clamp(2.*n,0.,1.));\n    }\n}\nvoid prog2 (vec2 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = A(U); b = B(U);\n    vec2 f = vec2(0); float m = 0., p = 0., z = 0.;\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 aa = A(U+u), bb = B(U+u);\n        float l = length(u);\n        if (l>0.) {\n            f += 0.125*b.x*bb.x*(.1+bb.x*bb.y)*u/l;\n            f += 0.125*b.x*bb.x*(b.z*b.w)*vec2(-u.y,u.x)/l;\n            p += 0.125*b.x*bb.x*dot(u/l,aa.zw-a.zw);\n            z += 0.125*b.x*bb.x*dot(vec2(-u.y,u.x)/l,aa.zw-a.zw);\n            m += bb.x;\n        }\n    }\n    if (m>0.) {\n       a.zw += f/m;\n       a.xy += f/m;\n       b.y += p/m;\n       b.z += z/m;\n    }\n    a.xy += a.zw;\n    \n    \n    // Boundaries:\n   \ta.w -= .01/R.y*signe(b.x);\n    if (a.x<10.) {a.z -= -.1;b.y*=0.9;}if (R.x-a.x<10.) {a.z -= .1;b.y*=0.9;}if (a.y<10.) {a.w -= -.1;b.y*=0.9;}if (R.y-a.y<10.) {a.w -= .1;b.y*=0.9;}\n    if (I<1||U.x<1.||R.x-U.x<1.||R.y-U.y<1.||R.x-U.x<1.) {\n    \ta = vec4(U,0,0);\n        b = vec4(0);\n        if (length(U-0.5*R) < 0.3*R.y&&length(U-0.5*R)>0.) {b.x = 2.;a.zw = -.2*normalize(U-0.5*R);}\n    \tb.w = 0.;\n    }\n    if (M.z>0.) {\n        float l = length(U-M.xy);\n        float s = smoothstep(1.,8.,l);\n        b.x = mix(2.,b.x,s);\n        a.xy = mix(U,a.xy,s);\n        a.zw = mix(.25*vec2(cos(.4*T),sin(.4*T)),a.zw,s);\n        if (l<8.) b.w = 1.+sin(.1*T);\n    }\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtXcWX", "name": "Day 189", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 20, "viewed": 424, "published": 3, "date": "1593182337", "time_retrieved": "2024-07-30T20:58:58.060823", "image_code": "// Fork of \"Day whatHHHbbb\" by jeyko. https://shadertoy.com/view/WlsyDj\n// 2020-06-26 10:11:00\n\n// I will rename these eventually!\n// I have no idea what day of my daily challenge it is tho\n\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./60.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[8](4.2*speed,4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    //t += sumScenes(2.)- 0.2;\n    \n    t = mod(t, sumScenes(7.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*1.;\n    \n    float its = 4.;\n    float scene = 0.;\n    \n    if(t < scenes[0]){\n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[0]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[0]*1.,3.);\n\n        vec4 q = vec4(p,1,1);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        for(float i = 0.; i <= its; i++){\n        \tvec2 b = p;\n            b.y += 0.2*enva;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n        }\n        d = min(d,dt); \n\n        d = abs(d);\n        \n    } else if(t < sumScenes(1.)){\n        scene = 1.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        for(float i = 0.; i <= its; i++){\n        \tvec2 b = p;\n            b.y += 0.2;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q) -envb*0.1,0.1);\n\n        float db = sdBox(q,vec4(0.03));\n\n\n        dt = mix(dt,max(dt,db),enva);\n\n\n        d = min(d,dt); \n\n        //d /= dpp;\n            \n\n    }   else if(t < sumScenes(2.)){\n        scene = 2.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.2 + 0.2*enva;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.+ 0.125*enva,+ 0.125*enva,0,0) ,0.1);\n\n        \n        \n        float db = sdBox(abs(q),vec4(0.03 + 0.01*enva));\n\n\n        dt = mix(dt,max(dt,db),1.);\n\n\n        d = min(d,dt); \n\n        //d /= dpp;\n\n\n    }   else if(t < sumScenes(3.)){\n        scene = 3.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.2,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.2,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        p.xy *= rot(2.*pi*enva);\n        \n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4 + envother*envb*3. ;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.5*pi*enva);\n            \tb = mix(b,abs(b),enva);\n            \tb -= 0.1*enva;\n            }\n            //b.x += 0.2;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0) - 0.02*enva,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.5*0.015*enva,0.0)) ,enva);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n\n            \n\n    }     else if(t < sumScenes(4.)){\n        scene = 4.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.2,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.2,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.5*pi);\n            \tb = mix(b,abs(b),1.);\n            \tb -= 0.1; //+ enva*0.1;\n            }\n            b.x -= 0.1*enva;\n            //b.x += 0.2;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0) - 0.02,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1.);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n            \n\n    }     else if(t < sumScenes(5.)){\n        scene = 5.;\n\t\tt -= sumScenes(scene - 1.);\n       \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.2,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.2,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.5*pi - 0.25*pi*enva);\n            \tb = mix(b,abs(b),1.);\n            \tb -= 0.1;\n            }\n            b.x -= 0.1;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0) - 0.02,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1.);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n               \n\n    } else if(t < sumScenes(6.)){\n        scene = 6.;\n\t\tt -= sumScenes(scene - 1.);\n        \n      \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.1,1.4);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.1,2.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.25*pi - 0.25*pi*enva);\n            \tb = mix(b,abs(b),1.);\n            \tb -= 0.1;\n            }\n            b.x -= 0.1 - 0.3*enva;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0)*(1. - enva)  - 0.02 - 0.02*enva,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1.);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n\n    } else if(t < sumScenes(7.)){\n        scene = 7.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.1,1.4);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.1,2.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p *= rot(0.25*pi*enva);\n        \n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            \n            b.y += 0.4 - 0.4*enva;\n                \n            //b.y -= 0.*enva;\n\t\t\t\n        \tb *= rot(1.*pi*enva);\n            for(int j = 0; j < 2; j++){\n            \tb = mix(b,abs(b),1. - enva);\n            \tb -= 0.1 - 0.1*enva;\n            }\n            b.x += 0.2 - 0.2*enva ;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n            \n        }\n        \n        \n        \n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q) - 0.04 ,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1. - enva);\n        \n\n        dt = mix(dt,max(dt,db),1. - enva);\n\n        d = min(d,dt); \n\n    }\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 508, 508, 564], [567, 578, 615, 615, 923], [924, 924, 961, 961, 1008], [1009, 1009, 1046, 1046, 1111], [1165, 1165, 1234, 1234, 1390], [1391, 1391, 1421, 1421, 1525], [1587, 1587, 1639, 1639, 1758], [1904, 1904, 1932, 1932, 2039], [2041, 2041, 2068, 2068, 11106]], "test": "untested"}
{"id": "ttsyD2", "name": "Flipping triangles", "author": "Oggbog", "description": "Supposed to represent triangles being rotated on the diagonal axis. \n", "tags": ["triangle"], "likes": 3, "viewed": 357, "published": 3, "date": "1593177735", "time_retrieved": "2024-07-30T20:58:59.088077", "image_code": "#define PI 3.14159\n\nfloat t(vec2 uv, float a){\n   \n   \tfloat d = step(uv.y,1.+tan(-PI/2.+a)*(1.-uv.x));\n    float b = step(uv.y,uv.x*tan(a));\n\n    if(a>PI/4.){\n    \td *= b;\n    } else {\n        d += b;\n    }\n            \n  \treturn clamp(d,0.,1.);    \n}\n\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    p = p/iResolution.y;\n    \n    vec2 pos = fract(p*12.);\n    vec2 id = floor(p*12.);\n    \n    float a = (id.x-id.y)/15.-iTime*.5;\n    \n    float ti = PI*fract(a)/2.;\n    \n    float d = t(pos, ti);\n    \n    a = floor(mod(a,2.));\n    \n    d = mod(a + d, 2.);   \n       \n    c = vec4(vec3(1.0-abs(d)),1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 46, 46, 252], [255, 255, 296, 296, 614]], "test": "untested"}
{"id": "tllyD2", "name": "crappy days", "author": "yasuo", "description": "Inspired by recent shaders", "tags": ["animation"], "likes": 12, "viewed": 352, "published": 3, "date": "1593170911", "time_retrieved": "2024-07-30T20:59:00.067458", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//https://iquilezles.org/articles/distfunctions2d\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nvec2 getUV(float i)\n{\n    return vec2((i)/iResolution.x, 0);\n}\n\nvec2 animationPos(float i)\n{\n    return texture(iChannel0, getUV(i)).xy;\n}\n\nfloat deg(float i)\n{\n    return texture(iChannel0, getUV(i)).z;\n}\n\nfloat morfval(float i)\n{\n    return texture(iChannel0, getUV(i)).w;\n}\n\nfloat octogons(vec2 p, float rot) {\n    p*=Rot(radians(rot));\n    float size = 0.1;\n    float d = sdOctogon(p,size);\n    for (int i = 0; i < 3; i++) {\n        vec2 q = abs(p);\n        q-=0.15;\n        d = min(d,  sdOctogon(q,size));\n    }\n    return abs(d)-0.01;\n}\n\nfloat rx(vec2 p) {\n    float size = 0.12;\n    float r = 0.01;\n    float d = sdRoundedX(p,size,r);\n    for (int i = 0; i < 3; i++) {\n        vec2 q = abs(p);\n        q-=0.15;\n        d = min(d,  sdRoundedX(q,size,r));\n    }\n    return d;\n}\n\nfloat rhombus(vec2 p) {\n    vec2 size = vec2(0.05);\n    float r = 0.01;\n    float d = sdRhombus(p,size);\n    for (int i = 0; i < 3; i++) {\n        vec2 q = abs(p);\n        q-=0.15;\n        d = min(d,  sdRhombus(q,size));\n    }\n    return abs(d)-0.01;\n}\n\nfloat hexogons(vec2 p, float rot) {\n    p*=Rot(radians(rot));\n    float r = 0.1;\n    float d = sdHexagon(p,r);\n    for (int i = 0; i < 3; i++) {\n        vec2 q = abs(p);\n        q-=0.15;\n        d = min(d,  sdHexagon(q,r));\n    }\n    return abs(d)-0.01;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    vec2 pos = animationPos(fragCoord.x);\n    float r = deg(fragCoord.x);\n    float mf = morfval(fragCoord.x);\n    uv*=Rot(radians(r));\n    \n    uv = abs(uv);\n    uv-=0.005;\n    float d = octogons(uv+(pos),r);\n    float d2 = hexogons(uv+(pos),-r);\n    d = mix(d,d2,mf);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    float d3 = rx(uv+(pos));\n    float d4 = rhombus(uv+(pos));\n    d = mix(d3,d4,mf);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// retrieved data code from https://www.shadertoy.com/view/Md2fzz\n\nvec2 getUV(float i)\n{\n    return vec2((i)/iResolution.x, 0);\n}\n\nvec2 animationPos(float i)\n{\n    return texture(iChannel0, getUV(i)).xy;\n}\n\nfloat deg(float i)\n{\n    return texture(iChannel0, getUV(i)).z;\n}\n\nfloat morfval(float i)\n{\n    return texture(iChannel0, getUV(i)).w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 cur_pos;\n    float cur_deg;\n    float cur_morph;\n    if(iFrame == 0)\n    {\n        cur_pos = vec2(0.0,0.0);\n        cur_deg = 0.0;\n        cur_morph = 0.0;\n        fragColor = vec4(cur_pos, cur_deg,cur_morph);\n        return;\n    }\n    \n\tvec2 prevPos = animationPos(fragCoord.x);\n\tfloat prevDeg = deg(fragCoord.x);\n    float prevMorph = morfval(fragCoord.x);\n    vec2 target = vec2(-0.1,0.3);\n    float targetDeg = 0.0;\n    float targetMorph = 0.0;\n    \n    float t = mod(iTime,6.0);\n    \n\tfloat speed = 0.2;\n    if(t>0.0 && t<1.0){\n        speed = 0.2;\n    \ttarget = vec2(-0.03,-0.03);\n        targetDeg = 45.0;\n        targetMorph = 1.0;\n    } else if(t>=1.0 && t<2.0) {\n        target = vec2(-0.1,-0.1);\n        targetDeg = 90.0;\n         targetMorph = 0.0;\n    } else if(t>=2.0 && t<3.0) {\n        target = vec2(-0.15,-0.15);\n        targetDeg = 135.0;\n         targetMorph = 1.0;\n    } else if(t>=3.0 && t<4.0) {\n        target = vec2(-0.2,-0.2);\n        targetDeg = 180.0;\n         targetMorph = 0.0;\n    } else if(t>=4.0 && t<5.0) {\n        target = vec2(-0.25,-0.25);\n        targetDeg = 225.0;\n         targetMorph = 1.0;\n    } else if(t>=5.0 && t<6.0) {\n        target = vec2(0.0);\n        targetDeg = 0.0;\n        speed = 0.15;\n         targetMorph = 0.0;\n    }\n    \n    cur_pos = prevPos;\n\tcur_pos.x += (target.x-cur_pos.x)*speed;\n    cur_pos.y += (target.y-cur_pos.y)*speed ;\n\n    cur_deg = prevDeg;\n    cur_deg += (targetDeg-cur_deg)*speed;\n    \n    cur_morph = prevMorph;\n    cur_morph += (targetMorph-cur_morph)*(speed*2.0);\n    \n    fragColor = vec4(cur_pos,cur_deg,cur_morph);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 209, 238, 238, 266], [267, 267, 309, 309, 504], [506, 506, 548, 548, 832], [834, 834, 876, 876, 1066], [1068, 1068, 1123, 1123, 1186], [1188, 1188, 1209, 1209, 1250], [1252, 1252, 1280, 1280, 1326], [1328, 1328, 1348, 1348, 1393], [1395, 1395, 1419, 1419, 1464], [1466, 1466, 1501, 1501, 1730], [1732, 1732, 1750, 1750, 1970], [1972, 1972, 1995, 1995, 2224], [2226, 2226, 2261, 2261, 2481], [2483, 2483, 2540, 2540, 3104]], "test": "untested"}
{"id": "tllyW2", "name": "Lorenz Explorer", "author": "dr2", "description": "Study deterministic chaos in a simple system - see source", "tags": ["fractal", "chaos", "butterfly", "tajectory"], "likes": 10, "viewed": 420, "published": 3, "date": "1593161447", "time_retrieved": "2024-07-30T20:59:01.607342", "image_code": "// \"Lorenz Explorer\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n A study of the Lorenz system, namely the three coupled first-order differential equations\n\n    dx/dt = s y - s x\n    dy/dt = r x - y - x z\n    dz/dt = x y - b z\n\n where s = 10, b = 8/3, and r is a variable set by the user.\n \n The most recent portion of the orbit u(t) = vec3 (x(t), y(t), z(t)) is shown in 3D.\n The display is approximately centered on the orbit midpoint.\n \n Depending on r the system exhibits periodic or chaotic behavior, as well as\n convergence to a fixed point. The characteristic butterfly shape of the Lorenz\n attractor is well known. Color changes gradually with time.\n\n The three sliders are used for coarse/medium/fine setting of r (to 6 digit precision);\n the value shown is 1000 x r. Changing r restarts the calculation. Mouse rotates axes.\n*/\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (int idVar);\n\nconst int nbTrail = 1200;  // same for image and buffer (the bigger the better)\n\nvec3 ltDir, vnObj, uAv;\nfloat dstFar, nStep, vuScl;\nint idBall;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat BallHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 u, p, pp;\n  float b, d, w, dMin;\n  bool skip;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nbTrail; n ++) {\n    p = vuScl * (Loadv4 (4 + n).xyz - uAv).xzy;\n    skip = false;\n    if (n == 0) pp = p;\n    else {\n      if (length (pp - p) < 0.5 * rad) skip = true;\n      else pp = p;\n    }\n    if (! skip) {\n      u = ro - p;\n      b = dot (rd, u);\n      w = b * b - dot (u, u) + rad * rad;\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0. && d < dMin) {\n          dMin = d;\n          vnObj = (u + d * rd) / rad;\n          idBall = n;\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s;\n  float dMin, d, a, b, w;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      vnObj = normalize (vec3 (s.xy, 0.));\n    } else {\n      ro.z -= len * sign (s.z);\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vnObj = normalize (ro + d * rd);\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, vnb, vnc, col, roa, rda;\n  float dstBall, dstAx, d, h;\n  dstBall = BallHit (ro, rd, 0.03);\n  vnb = vnObj;\n  dstAx = dstFar;\n  for (int j = 0; j < 3; j ++) {\n    roa = ro + vuScl * uAv.xzy;\n    rda = rd;\n    if (j == 1) {\n      roa.xz = Rot2D (roa.xz, 0.5 * pi);\n      rda.xz = Rot2D (rda.xz, 0.5 * pi);\n    } else if (j == 2) {\n      roa.yz = Rot2D (roa.yz, 0.5 * pi);\n      rda.yz = Rot2D (rda.yz, 0.5 * pi);\n    }\n    roa.z -= 1.;\n    d = CapsHit (roa, rda, 0.02, 1.);\n    if (d < dstAx) {\n      dstAx = d;\n      vnc = vnObj;\n      if (j == 1) vnc.xz = Rot2D (vnc.xz, -0.5 * pi);\n      else if (j == 2) vnc.yz = Rot2D (vnc.yz, -0.5 * pi);\n    }\n  }\n  if (min (dstBall, dstAx) < dstFar) {\n    if (dstBall < dstAx) {\n      ro += rd * dstBall;\n      vn = vnb;\n      col = HsvToRgb (vec3 (mod (0.5 * (float (idBall) + 0.1 * nStep) / float (nbTrail), 1.), 1., 1.));\n    } else {\n      ro += rd * dstAx;\n      vn = vnc;\n      col = vec3 (0.7, 0.7, 1.);\n    }\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = vec3 (0.1);\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec3 wgVal)\n{\n  vec4 wgBx[3];\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < 3; k ++) {\n    wgBx[k] = vec4 ((-0.46 + 0.06 * float (k)) * asp, 0., 0.012 * asp, 0.2);\n    ust = abs (0.5 * uv - wgBx[k].xy) - wgBx[k].zw;\n    if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0., 1., 0.);\n    ust = 0.5 * uv - wgBx[k].xy;\n    ust.y -= (wgVal[k] - 0.5) * 2. * wgBx[k].w;\n    ust = abs (ust) - vec2 (0.8, 0.7) * wgBx[k].z;\n    if (max (ust.x, ust.y) < 0.) col = vec3 (0.8, 0.8, 0.4);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col, wgVal;\n  vec2 canvas, uv;\n  float tCur, az, el, asp, rVar, v;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  dstFar = 500.;\n  stDat = Loadv4 (0);\n  wgVal = stDat.xyz;\n  stDat = Loadv4 (2);\n  el = stDat.x;\n  az = stDat.y;\n  nStep = stDat.z;\n  stDat = Loadv4 (3);\n  uAv = stDat.xyz;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1., -15.);\n  ltDir = vuMat * normalize (vec3 (0., 0.3, -1.));\n  rd = normalize (vec3 (uv, 4.));\n  rd = vuMat * rd;\n  rVar = 100. * dot (wgVal, vec3 (10., 0.1, 0.001));\n  vuScl = 0.02 + 0.08 * (1. - smoothstep (10., 150., rVar));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, wgVal);\n  v = 10. * floor (100. * wgVal.x) + floor (floor (100. * wgVal.y) / 10.);\n  col = mix (col, vec3 (0., 1., 0.), ShowInt (0.5 * uv - vec2 (-0.4 * asp, -0.35),\n       vec2 (0.07 * asp, 0.04), 3., v));\n  v = 100. * mod (floor (100. * wgVal.y), 10.) + floor (100. * wgVal.z);\n  col = mix (col, vec3 (0., 1., 0.), ShowIntPZ (0.5 * uv - vec2 (-0.32 * asp, -0.35),\n       vec2 (0.07 * asp, 0.04), 3., v));\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    val = max (val, 0.);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Lorenz Explorer\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nbTrail = 1200;  // same for image and buffer\n\nvec3 u;\nfloat delT, rVar, sVar, bVar;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 EvalRhs (vec3 u)\n{\n  return vec3 (sVar * (u.y - u.x), (rVar - u.z) * u.x - u.y, u.x * u.y - bVar * u.z);\n}\n\nvec3 RKStep (vec3 u)\n{\n  vec3 k0, k1, k2, k3;\n  k0 = EvalRhs (u);\n  k1 = EvalRhs (u + (delT / 2.) * k0);\n  k2 = EvalRhs (u + (delT / 2.) * k1);\n  k3 = EvalRhs (u + delT * k2);\n  u += (delT / 6.) * (k0 + k3 + 2. * (k1 + k2));\n  return u;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[3], mPtr, mPtrP, stDat, slVal, s;\n  vec3 uAv, wgVal, u0;\n  vec2 canvas, ust;\n  vec2 iFrag;\n  float asp, vW, parmL, el, az, nStep, gap;\n  int pxId, wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId > 4 + nbTrail) discard;\n  sVar = 10.;\n  bVar = 8. / 3.;\n  delT = 0.0002;\n  doInit = false;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    rVar = 40.;\n    wgVal = mod (floor (vec3 (rVar / 10., 10. * rVar, 1000. * rVar)), 100.) / 100.;\n    mPtrP = mPtr;\n    el = -0.2 * pi;\n    az = -0.2 * pi;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (0);\n    wgVal = stDat.xyz;\n    rVar = 100. * dot (wgVal, vec3 (10., 0.1, 0.001));\n    stDat = Loadv4 (1);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (2);\n    el = stDat.x;\n    az = stDat.y;\n    nStep = stDat.z;\n    stDat = Loadv4 (3);\n    uAv = stDat.xyz;\n    stDat = Loadv4 (4);\n    u = stDat.xyz;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 3; k ++) {\n      wgBx[k] = vec4 ((-0.46 + 0.06 * float (k)) * asp, 0., 0.012 * asp, 0.2);\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el = -0.2 * pi + 1.5 * pi * mPtr.y;\n      az = -0.2 * pi + 3. * pi * mPtr.x;\n    }\n  } else {\n    for (int k = 0; k < 3; k ++) {\n      if (wgSel == k) {\n        wgVal[k] = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n        break;\n      }\n    }\n    doInit = true;\n  }\n  if (pxId == 2) {\n    if (doInit) nStep = 0.;\n    else ++ nStep;\n  } else if (pxId == 3) {\n    if (nStep < 2000.) {\n      uAv = vec3 (0.);\n      for (int j = 0; j < nbTrail - 10; j ++) uAv += Loadv4 (4 + j).xyz;\n      uAv /= float (nbTrail - 10);\n    }\n  } else if (pxId == 4) {\n    if (doInit) {\n      u = vec3 (0.1);\n    } else {\n      u0 = u;\n      gap = (rVar > 50.) ? 4. : 2.;\n      for (int j = VAR_ZERO; j < 200; j ++) {\n        u = RKStep (u);\n        if (length (u - u0) > gap) break;\n      }\n    }\n  } else if (pxId > 4 && pxId <= 4 + nbTrail) {\n    u = doInit ? vec3 (0.1) : Loadv4 (pxId - 1).xyz;\n  }\n  if      (pxId == 0) stDat = vec4 (wgVal, 0.);\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 2) stDat = vec4 (el, az, nStep, 0.);\n  else if (pxId == 3) stDat = vec4 (uAv, 0.);\n  else if (pxId >= 4) stDat = vec4 (u, 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1343, 1343, 1388, 1388, 1990], [1992, 1992, 2048, 2048, 2677], [3867, 3867, 3925, 3925, 4445], [4447, 4447, 4503, 4503, 5713], [5715, 5715, 5751, 5751, 5957], [5959, 5959, 5989, 5989, 6102], [6104, 6104, 6128, 6128, 6245], [6247, 6247, 6270, 6270, 6372], [6445, 6445, 6477, 6477, 7019], [7021, 7021, 7083, 7083, 7475], [7477, 7477, 7537, 7537, 8087], [8181, 8181, 8206, 8206, 8334]], "test": "untested"}
{"id": "3tsyzl", "name": "Julia - Quaternion 3", "author": "iq", "description": "The cubic Julia set used in the introduction of my video \"Geodes\" ([url]https://www.shadertoy.com/view/3llyzl[/url]). It has 3 bounces of super simple GI (no specular) and some temporal reprojection to remove noise.", "tags": ["3d", "raymarching", "fractal", "julia", "distance", "quaternion", "cubic"], "likes": 163, "viewed": 11977, "published": 3, "date": "1593154586", "time_retrieved": "2024-07-30T20:59:02.536856", "image_code": "// Copyright Inigo Quilez, 2020 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// The Julia set of f(z) = z³ + c, as rendered for the Youtube\n// video called \"Geodes\": https://www.youtube.com/watch?v=rQ2bnU4dkso\n//\n// I simplified a few things, reduced the number of GI bounces\n// and did some temporal reprojection to keep it more or less\n// real-time while looking similar to the one in the video.\n//\n// Explanations:\n//  https://iquilezles.org/articles/distancefractals\n//  https://iquilezles.org/articles/orbittraps3d\n//\n// Related shaders:\n//\n// Julia - Quaternion 1 : https://www.shadertoy.com/view/MsfGRr\n// Julia - Quaternion 2 : https://www.shadertoy.com/view/lsl3W2\n// Julia - Quaternion 3 : https://www.shadertoy.com/view/3tsyzl\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord / iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n\n    // color grade\n    col = col*2.0/(1.0+col);\n    col = pow( col, vec3(0.4545) );\n    col = pow(col,vec3(0.85,0.97,1.0));\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\n    // vignette\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The Julia set of f(z) = z³ + c, as rendered for the Youtube\n// video called \"Geodes\": https://www.shadertoy.com/view/3llyzl\n//\n// I simplified a few things, reduced the number of GI bounces\n// and did some temporal reprojection to keep it more or less\n// real-time while looking similar to the one in the video.\n//\n// Explanations:\n//  https://iquilezles.org/articles/distancefractals\n//  https://iquilezles.org/articles/orbittraps3d\n//\n// Related shaders:\n//\n// Julia - Quaternion 1 : https://www.shadertoy.com/view/MsfGRr\n// Julia - Quaternion 2 : https://www.shadertoy.com/view/lsl3W2\n// Julia - Quaternion 3 : https://www.shadertoy.com/view/3tsyzl\n\n\n// disable TRAPs to see just the set\n#define TRAPS\n\n// disable CUT to see the whole set\n#define CUT\n\nconst int   kNumIte = 200;\nconst float kPrecis = 0.00025;\nconst vec4  kC = vec4(-2,6,15,-6)/22.0;\nconst float kFocLen = 3.0;\n#ifdef TRAPS\nconst float kBSRad = 2.0;\n#else\nconst float kBSRad = 1.2;\n#endif\n#define     kNumBounces 3\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n//--------------------------------------------------------------------------------\n// http://amietia.com/lambertnotangent.html\n//--------------------------------------------------------------------------------\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand()*2.0-1.0;\n    float a = frand()*6.28318531;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)), u) );\n}\n//--------------------------------------------------------------------------------\n// quaternion manipulation\n//--------------------------------------------------------------------------------\nvec4 qSquare( in vec4 q )\n{\n    return vec4(q.x*q.x - q.y*q.y - q.z*q.z - q.w*q.w, 2.0*q.x*q.yzw);\n}\nvec4 qCube( in vec4 q )\n{\n    vec4  q2 = q*q;\n    return vec4(q.x  *(    q2.x - 3.0*q2.y - 3.0*q2.z - 3.0*q2.w), \n                q.yzw*(3.0*q2.x -     q2.y -     q2.z -     q2.w));\n}\nfloat qLength2( in vec4 q ) { return dot(q,q); }\n//--------------------------------------------------------------------------------\n// ray-sphere intersection\n// https://iquilezles.org/articles/intersectors\n//--------------------------------------------------------------------------------\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n//--------------------------------------------------------------------------------\n// build camera rotation matrix\n//--------------------------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n//--------------------------------------------------------------------------------\n// SDF of the Julia set z³+c\n// https://iquilezles.org/articles/distancefractals\n//--------------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{\n    vec4 z = vec4( p, 0.0 );\n    float dz2 = 1.0;\n\tfloat m2  = 0.0;\n    float n   = 0.0;\n    #ifdef TRAPS\n    float o   = 1e10;\n    #endif\n    \n    for( int i=0; i<kNumIte; i++ ) \n\t{\n        // z' = 3z² -> |z'|² = 9|z²|²\n\t\tdz2 *= 9.0*qLength2(qSquare(z));\n        \n        // z = z³ + c\t\t\n\t\tz = qCube( z ) + kC;\n        \n        // stop under divergence\t\t\n        m2 = qLength2(z);\t\t\n\n        // orbit trapping : https://iquilezles.org/articles/orbittraps3d\n        #ifdef TRAPS\n        o = min( o, length(z.xz-vec2(0.45,0.55))-0.1 );\n        #endif\n        \n        // exit condition\n        if( m2>256.0 ) break;\t\t\t\t \n\t\tn += 1.0;\n\t}\n   \n\t// sdf(z) = log|z|·|z|/|dz| : https://iquilezles.org/articles/distancefractals\n\tfloat d = 0.25*log(m2)*sqrt(m2/dz2);\n    \n    #ifdef TRAPS\n    d = min(o,d);\n    #endif\n    #ifdef CUT\n    d = max(d, p.y);\n    #endif\n    \n\treturn vec2(d,n);        \n}\n\n//--------------------------------------------------------------------------------\n// Compute Normal to SDF\n//--------------------------------------------------------------------------------\n\n#if 1\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.5773*kPrecis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n#else\n// https://iquilezles.org/articles/juliasets3d\nvec3 calcNormal( in vec3 p )\n{\n    #ifdef TRAPS\n    the code below only works for the actual Julia set, not the traps\n    #endif\n        \n    vec4 z = vec4(p,0.0);\n\n    // identity derivative\n    mat4x4 J = mat4x4(1,0,0,0,  \n                      0,1,0,0,  \n                      0,0,1,0,  \n                      0,0,0,1 );\n\n  \tfor(int i=0; i<kNumIte; i++)\n    {\n        // f(q) = q³ + c = \n        //   x =  x²x - 3y²x - 3z²x - 3w²x + c.x\n        //   y = 3x²y -  y²y -  z²y -  w²y + c.y\n        //   z = 3x²z -  y²z -  z²z -  w²z + c.z\n        //   w = 3x²w -  y²w -  z²w -  w²w + c.w\n\t\t//\n        // Jacobian, J(f(q)) =\n        //   3(x²-y²-z²-w²)  6xy            6xz            6xw\n        //    -6xy           3x²-3y²-z²-w² -2yz           -2yw\n        //    -6xz          -2yz            3x2-y²-3z²-w² -2zw\n        //    -6xw          -2yw           -2zw            3x²-y²-z²-3w²\n        \n        float k1 = 6.0*z.x*z.y, k2 = 6.0*z.x*z.z;\n        float k3 = 6.0*z.x*z.w, k4 = 2.0*z.y*z.z;\n        float k5 = 2.0*z.y*z.w, k6 = 2.0*z.z*z.w;\n        float sx = z.x*z.x, sy = z.y*z.y;\n        float sz = z.z*z.z, sw = z.w*z.w;\n        float mx = 3.0*sx-3.0*sy-3.0*sz-3.0*sw;\n        float my = 3.0*sx-3.0*sy-    sz-    sw;\n        float mz = 3.0*sx-    sy-3.0*sz-    sw;\n        float mw = 3.0*sx-    sy-    sz-3.0*sw;\n        \n        // chain rule of jacobians\n        J = J*mat4x4( mx, -k1, -k2, -k3,\n                      k1,  my, -k4, -k5,\n                      k2, -k4,  mz, -k6,\n                      k3, -k5, -k6,  mw );\n        // q = q³ + c\n        z = qCube(z) + kC; \n        \n        // exit condition\n        if(dot2(z)>256.0) break;\n    }\n\n    return (p.y>0.0 ) ? vec3(0.0,1.0,0.0) : normalize( (J*z).xyz );\n}\n#endif\n\n//--------------------------------------------------------------------------------\n// ray-scene intersection\n//--------------------------------------------------------------------------------\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    float tmax = 7.0;\n\tfloat tmin = kPrecis;    \n\n    // intersect clipping plane\n    #ifdef CUT\n    const float kSplit = 0.01;\n    float tpS = (kSplit-ro.y)/rd.y;\n    if( tpS>0.0 )\n    {\n        if( ro.y>kSplit ) tmin = max(tmin,tpS);\n        else              tmax = min(tmax,tpS);\n    }\n\t#endif\n    \n    // intersect lower clipping plane\n    #if 1\n    {\n    float tpF = (-0.8-ro.y)/rd.y;\n    if( tpF>0.0 ) tmax = min(tmax,tpF);\n    }\n    #endif\n\n    // intersect bounding sphere\n    #if 1\n    vec2 bv = iSphere( ro, rd, kBSRad );\n    if( bv.y<0.0 ) return vec2(-2.0,0.0);\n    tmin = max(tmin,bv.x);\n    tmax = min(tmax,bv.y);\n\t#endif\n    \n    // raymarch\n    vec2  res = vec2(-1.0);\n    float t = tmin;\n\tfloat lt = 0.0;\n\tfloat lh = 0.0;\n    for(int i=0; i<1024; i++ )\n    {\n        res = map(ro+rd*t);\n        if( res.x<kPrecis ) break;\n\t\tlt = t;\n\t\tlh = res.x;\n        #ifndef TRAPS\n        t += min(res.x,0.2);\n        #else\n        t += min(res.x,0.01)*(0.5+0.5*frand());\n        #endif\n        if( t>tmax ) break;\n    }\n    // linear interpolation for better isosurface\n\tif( lt>0.0001 && res.x<0.0 ) t = lt - lh*(t-lt)/(res.x-lh);\n\t\n    res.x = (t<tmax)?t:-1.0;\n\n    return res;\n}\n\n//--------------------------------------------------------------------------------\n// color of the surface\n//--------------------------------------------------------------------------------\nvec3 colorSurface( in vec3 pos, in vec3 nor, in vec2 tn )\n{\n    vec3 col = 0.5+0.5*cos(log2(tn.y)*0.9+3.5+vec3(0.0,0.6,1.0));\n    if( pos.y>0.0 ) col = mix(col,vec3(1.0),0.2);\n    float inside = smoothstep(14.0,15.0,tn.y);\n    col *= vec3(0.45,0.42,0.40) + vec3(0.55,0.58,0.60)*inside;\n    col = mix(col*col*(3.0-2.0*col),col,inside);\n    col = mix( mix(col,vec3(dot(col,vec3(0.3333))),-0.4),\n                        col, inside);\n    return clamp(col*0.65,0.0,1.0);\n}\n\n//--------------------------------------------------------------------------------\n// Render the scene through super simplified path-tracing\n//--------------------------------------------------------------------------------\nvec3 render( in  vec2 fragCoord, in vec3 ro, in vec3 rd,\n             out vec3 resPos, out float resT)\n{\n    vec3 colorMask = vec3(1.0);\n \tresT = 1e20;\n    \n    // path-tracing\n    for( int bounce=0; bounce<kNumBounces; bounce++ )\n    {\n        vec2 tn = raycast( ro, rd );\n        float t = tn.x;\n        if( t < 0.0 )\n        {\n            return (bounce>0) ? colorMask*1.65*step(0.0,rd.y) \n                              : vec3(clamp(0.02+0.021*rd.y,0.0,1.0));\n        }\n        else\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal( pos );\n\n            if( bounce==0 ) { resT = t; resPos = pos; }\n\n\t\t\tcolorMask *= colorSurface( pos, nor, tn );\n            rd = cosineDirection(nor);\n        \tro = pos+nor*kPrecis;\n        }\n   }\n   \n   return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //-----------------------------------------------\n\t// init random seed\n    //-----------------------------------------------\n    ivec2 q = ivec2(fragCoord);\n    srand( q, iFrame );\n    \n    //-----------------------------------------------\n    // camera\n    //-----------------------------------------------\n    float an = 0.5+iTime*0.03;\n    vec3  ro = 2.0*vec3(sin(an),0.8,cos(an));\n    #ifdef CUT\n    vec3  ta = vec3( 0.0, -0.3, 0.0 );\n    #else\n    vec3  ta = vec3( 0.0, -0.1, 0.0 );\n\t#endif\n    mat3x3 cam = setCamera(ro,ta,0.0);\n    \n    //-----------------------------------------------\n    // ray direction\n    //-----------------------------------------------\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = normalize( cam*vec3(p.xy,kFocLen) );\n    \n    //-----------------------------------------------\n    // render fractal\n    //-----------------------------------------------\n    vec3 pos; float resT;\n    vec3 col = render(fragCoord,ro,rd,pos,resT);\n\n    //-----------------------------------------------\n\t// reproject to previous frame and pull history\n    //-----------------------------------------------\n\n    // fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4( texelFetch(iChannel0,ivec2(0,0), 0),\n                            texelFetch(iChannel0,ivec2(1,0), 0),\n                            texelFetch(iChannel0,ivec2(2,0), 0) );\n    // world space point\n    vec4 wpos = vec4(pos,1.0);\n    // convert to camera space (note inverse multiply)\n    vec3 cpos = wpos*oldCam;\n    // convert to NDC space (project)\n    vec2 npos = kFocLen*cpos.xy/cpos.z;\n    // convert to screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n\t// convert to raster space\n    vec2 rpos = spos * iResolution.xy;\n\n    // read color+depth from this point's previous screen location\n    vec4 ocolt = textureLod( iChannel0, spos, 0.0 );\n    // if we consider the data contains the history for this point\n    if( iFrame>0 && resT<100.0 && (rpos.y>1.5||rpos.x>3.5) )\n    {\n        // blend with history (it's a IIR low pas filter really)\n        col = mix( ocolt.xyz, col, 0.06 );\n    }\n    // output\n\tif( q.y==0 && q.x<3 )\n    {\n    \t// camera matrix in lower left three pixels, for next frame\n             if( q.x==0 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );\n        else if( q.x==1 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );\n        else              fragColor = vec4( cam[2], -dot(cam[2],ro) );\n    }\n    else\n    {\n        // color and depth\n        fragColor = vec4( col, resT );\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyzl.jpg", "access": "api", "license": "proprietary-license", "functions": [[1429, 1429, 1486, 1486, 1866]], "test": "untested"}
{"id": "WtlyDj", "name": "Spectrum Tiles", "author": "andremichelle", "description": "Some tiling work for a spectrum visualiser I need elsewhere.", "tags": ["spectrum", "visualiser", "tiles"], "likes": 5, "viewed": 486, "published": 3, "date": "1593153007", "time_retrieved": "2024-07-30T20:59:03.344696", "image_code": "float sdRoundBox(vec2 p, vec2 b, float r)\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,.0)) + min(max(q.x,q.y),.0) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord;\n\tuv.y = iResolution.y - uv.y;\n    vec2 nc = vec2(32.0, 24.0);\n    vec2 ts = iResolution.xy / nc;\n    vec2 fr = (fract(uv/ts)-0.5)*2.0;\n    vec2 gr = floor(uv/ts);\n    float d = sdRoundBox(fr, vec2(0.5, 0.4), 0.3);\n    float a = smoothstep(0.04, 0.0, d);\n    \n    float xNorm = floor(uv.x / iResolution.x * nc.x) / nc.x;\n    float yAtX;\n    \n    //yAtX = mod(floor(iTime), nc.y + 1.0) / nc.y;\n    //yAtX = 0.5 + sin((xNorm + iTime * 0.25) * 6.283185) * 0.5;  \n    \n    yAtX = texture(iChannel0, vec2(xNorm,0.25) ).x; \n    \n    float sw = round(yAtX * nc.y) / nc.y;\n\n    float upper = step(1.0 - sw, (gr.y - 0.0) / nc.y);\n    float lower = step(1.0 - sw, (gr.y - 1.0) / nc.y);\n    float amount = upper - lower * 0.5;\n    vec3 b = mix(vec3(0.8, 0.6, 0.4), vec3(0.4, 0.2, 0.0), uv.y / iResolution.y);\n    vec3 c = mix(vec3(0.8, 0.6, 0.4), vec3(1.0, 1.0, 1.0), amount * a * upper);\n    fragColor = vec4(mix(b, c, upper * a), 1.0);\n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 123], [125, 125, 182, 182, 1135]], "test": "untested"}
{"id": "ttlyDj", "name": "zoom call from hell", "author": "mds2", "description": "really simple modification of https://www.shadertoy.com/view/MtKyzc\n\nInspired by a New Yorker cartoon", "tags": ["zoom", "covid", "videochat"], "likes": 13, "viewed": 1175, "published": 3, "date": "1593149424", "time_retrieved": "2024-07-30T20:59:04.400871", "image_code": "\nfloat squash_squircle(in vec2 in_pos, in float aspect_ratio, in float rad4) {\n    vec2 aspect = vec2(aspect_ratio, 1.0);\n    vec2 pos = aspect * in_pos;\n    vec2 tmp = pos * pos;\n    vec2 deriv = 4.0 * pos * tmp;\n    tmp = tmp * tmp;\n    float val4 = dot(vec2(1.0, 1.0), tmp);\n    float deriv_mag = length(aspect * deriv);\n    float sdf = (val4 - rad4) / deriv_mag;\n    return 1.0 - clamp(0.5 * sdf * iResolution.y, 0.0, 1.0);\n}\n\nvec3 color_shift(in vec3 rgb, in float how_much) {\n    const mat3 to_yuvish = mat3(0.299, -0.14713, 0.615,\n                          0.587, -0.28886, -0.51499,\n                          0.114, 0.436, -0.10001);\n    const mat3 from_yuvish = mat3(1.0, 1.0, 1.0,\n                            0.0, -0.39465, 2.03211,\n                            1.13983, -0.58060, 0.0);\n\n    vec3 yuv = to_yuvish * rgb;\n    yuv += 0.3 * vec3(0.0, how_much * cos(how_much + iTime), how_much * sin(how_much + iTime));\n    yuv = clamp(yuv, vec3(0.0), vec3(1.0));\n    vec3 rgb_out = from_yuvish * yuv;\n    return smoothstep(vec3(0.0), vec3(1.0), rgb_out);\n}\n\nvec3 perturb(in vec3 pt) {\n    return pt + 0.1 * sin(4.0 * pt.x + 8.0 * iTime) * vec3(0.0, 1.0, 0.0);\n}\n\n\nvec3 vehicle_sdf_grad(in vec3 loc) {\n    float dist = vehicle_sdf(perturb(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf(perturb(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf(perturb(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf(perturb(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\n\nfloat cast_to_vehicle(in vec3 orig, in vec3 dir) {\n    vec3 p = orig;\n    float accum = 0.0;\n    for (int i = 0; i < 256; ++i) {\n    \tfloat remaining = 0.7 * vehicle_sdf(p);\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb(p);\n        if (remaining < 1.0e-3 || accum > MAX_DIST) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce(in vec3 pt, in vec3 dir) {\n    vec3 norm = normalize(vehicle_sdf_grad(pt));\n    return normalize(reflect(dir, norm));\n}\n\nvec4 castRay(in vec2 tv_coord) {\n\tvec2 uv = 5.0 * tv_coord - vec2(2.5);\n    vec3 ray_orig = vec3(0.0, 0.5, -7.0);\n\tvec3 ray_dir = normalize(vec3(uv, 5.0));\n    \n    float wiggle = abs(mod(0.2 * iTime, 4.0) - 2.0) - 1.0;\n    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    ray_dir = twist * ray_dir;\n    ray_orig = twist * ray_orig;\n    \n    float d = MAX_DIST;\n    \n    if (abs(uv.y) < 1.0 && abs(uv.x) < 1.2) {\n\t    d = cast_to_vehicle(ray_orig, ray_dir);\n    }\n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        ray_dir = get_bounce(pt, ray_dir);\n    }\n\n    return vec4(abs(0.5 + 0.5 * ray_dir), 1.0);\n}\n\nvec4 spaceship(in vec2 tv_coord, in vec2 tv_uv_size) {\n    vec2 pix_scale = tv_uv_size * 2.0 / iResolution.y;\n    vec4 outcolor = 0.25 * castRay(tv_coord + pix_scale * vec2(0.49, -0.47));\n    outcolor += 0.25 * castRay(tv_coord + pix_scale * vec2(0.5, 0.4));\n    outcolor += 0.25 * castRay(tv_coord + pix_scale * vec2(-0.35, 0.48));\n    outcolor += 0.25 * castRay(tv_coord + pix_scale * vec2(-0.48, -0.49));\n    return outcolor;\n}\n\nvec4 castRayUFO(in vec2 tv_coord, in float offset_t) {\n\tvec2 uv = 5.0 * tv_coord - vec2(2.5);\n    vec3 ray_orig = vec3(0.0, 0.5, -7.0);\n\tvec3 ray_dir = normalize(vec3(uv, 15.0));\n    \n    float wiggle = abs(mod(0.2 * iTime + 0.1 * offset_t, 4.0) - 2.0) - 1.0;\n    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    ray_dir = twist * ray_dir;\n    ray_orig = twist * ray_orig;\n    wiggle = 0.1 * sin(iTime + offset_t);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist = mat3(ct, st, 0.0,\n                 -st, ct, 0.0,\n                 0.0, 0.0, 1.0);\n    ray_dir = twist * ray_dir;\n    \n    ray_orig = ray_orig - vec3(0.0, 0.2, 0.0) -\n        sin(vec3(4.2, 1.2, 3.4) * (offset_t + iTime)) * vec3(0.5, 0.1, 0.2);\n    float closeness = MAX_DIST;\n    float d = cast_to_vehicle2(ray_orig, ray_dir, closeness);\n    \n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        ray_dir = get_bounce2(pt, ray_dir);\n        // return vec4(abs(0.5 + 0.5 * ray_dir), 1.0);\n       // return vec4(0.0);\n    }\n\n    return vec4(vec3(0.1, 0.3, 1.0) + \n                0.8 * dot(ray_dir, vec3(0.48, 0.36, -0.8)) +\n                0.25 * vec3(1.0,0.7, -0.2) * smoothstep(0.5, 0.0, closeness) +\n                0.5 * vec3(1.0,0.7, -0.2) * smoothstep(0.15, 0.0, closeness), 1.0);\n}\n\n\nvec4 UFO(in vec2 tv_coord, in vec2 tv_uv_size, in float offset_t) {\n    vec2 pix_scale = tv_uv_size * 2.0 / iResolution.y;\n    vec4 outcolor = 0.25 * castRayUFO(tv_coord + pix_scale * vec2(0.49, -0.47), offset_t);\n    outcolor += 0.25 * castRayUFO(tv_coord + pix_scale * vec2(0.5, 0.4), offset_t);\n    outcolor += 0.25 * castRayUFO(tv_coord + pix_scale * vec2(-0.35, 0.48), offset_t);\n    outcolor += 0.25 * castRayUFO(tv_coord + pix_scale * vec2(-0.48, -0.49), offset_t);\n    // return vec4(1.0, 0.0, 0.0, 1.0);\n    return outcolor;\n}\n\nvec4 color_from(in vec2 in_uv, in vec2 delta, in int i) {\n    vec2 uv = in_uv - vec2(0.5);\n    uv = uv * (1.0 - 0.2 * smoothstep(0.25, 0.0, dot(uv, uv)));\n    uv = uv + vec2(0.5);\n    float float_i = float(i);\n    float t_wave = 2.0 * smoothstep(0.0, 4.0, mod(iTime * (1.0 + 0.01 * float_i), 4.0)) - 0.5;\n    float smooth_t_wave = smoothstep(0.75, 0.0, abs(t_wave - 0.5));\n    int switch_i = i % 10;\n    float spike = smoothstep(0.15, 0.0, abs(in_uv.y - t_wave));\n    \n    if (mod(iTime, 100.0) > 92.0) {\n      switch_i = 8 + (i % 2);\n    }\n    \n\n    switch (switch_i) {\n        case 0:\n        return texture(iChannel0, 0.5 * uv + vec2(0.5));\n        case 1:\n        vec3 col = texture(iChannel0, 0.5 * uv + vec2(0.0, 0.5)).rgb;\n        mat3 blowout = mat3(6.62337, 6.13667, 6.25027,\n                        6.13667, 6.36245, 7.10737,\n                        6.25027, 7.10737, 8.68193);\n    \tvec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n    \n        col = col - cent;\n        return vec4(cent + (0.7 * col + 0.3 * blowout * col), 1.0);  \n        case 2:\n        return texture(iChannel0, 0.5 * uv + vec2(0.5, 0.0));\n        case 3:\n        return texture(iChannel0, 0.5 * uv + vec2(0.0));\n        case 4:\n        return vec4(uv, smooth_t_wave, 1.0);\n        case 5:\n        return spaceship(uv, delta);\n        case 6:\n        return vec4(0.3 * spike, 0.1, 1.0, 1.0);\n        case 7:\n        \tcol = texture(iChannel0, (0.5 * uv + vec2(0.5)) + 0.2 * vec2(spike, 0.0)).rgb;\n         \tblowout = mat3(1.87583893, 0.96308725, 0.,\n       \t\t\t0.96308725, 1.17416107, 0.,\n       \t\t\t0.        , 0.        , 0.5);\n    \t\tcent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n\n   \n    \n    \t\tvec3 dir = blowout * (col - cent);\n    \n    \t\tvec3 maxes = (step(vec3(0.0), dir) - col)/dir;\n    \n    \t\tfloat amount = min(maxes.x, min(maxes.y, maxes.z));\n    \n    \t\t// amount = min(amount, 0.75);\n    \t\n    \n    \t\tcol = col + dir * amount;\n        \treturn vec4(color_shift(col, spike), 1.0);\n        case 8:\n        return UFO(uv, delta, float_i);\n        default:\n        \n        return vec4(color_shift(sin(vec3(0.9, 1.1, 0.7) * iTime + \n                                    1.0 * smooth_t_wave + vec3(1.0, 2.0, 3.0)),\n                                spike), 1.0) + texture(iChannel1, uv);\n    }\n}\n\nvec4 add_screen(in vec2 uv, in vec2 uv_min, in vec2 uv_max, in vec4 old_color,\n                in int i) {\n    vec2 delta = (uv_max - uv_min);\n    vec2 midpoint = 0.5 * (uv_max + uv_min);\n    float aspect = abs(delta.y / delta.x);\n    float rad = 0.4 * abs(delta.y);\n  \tfloat rad2 = rad * rad;\n    float rad4 = rad2 * rad2;\n    float outer_rad = rad + 0.05 * delta.y;\n\t//    float outer_aspect  = (rad * aspect + 0.05 * delta.y) / (rad + 0.05 * delta.y);\n    float outer_rad2 = outer_rad * outer_rad;\n    float outer_rad4 = outer_rad2 * outer_rad2;\n    float inside = squash_squircle(uv - midpoint, aspect, rad4); // abs(delta.x/delta.y), 0.01 * abs(delta.y));\n    float in_border = squash_squircle(uv - midpoint, aspect, outer_rad4);\n    vec4 color = color_from((uv - uv_min)/delta, delta, i);\n    color = mix(vec4(vec3(0.0), 1.0), color, inside);\n    return mix(old_color, color, in_border);\n}\n\nvec2 subdivide(in vec2 uv, in vec2 split, inout vec2 uv_min, inout vec2 uv_max, inout int i) {\n    vec2 delta = uv_max - uv_min;\n    vec2 local_split = uv_min + 0.5 * (1.0 + split) * delta;\n    vec2 out_sign = vec2(1.0);\n    if (uv.x > local_split.x) {\n        uv_min.x = local_split.x;\n    } else {\n        uv_max.x = local_split.x;\n        i = i + 1;\n        out_sign.y *= -1.0;\n    }\n    \n    if (uv.y > local_split.y) {\n        uv_min.y = local_split.y;\n        out_sign.x *= -1.0;\n    } else {\n        uv_max.y = local_split.y;\n        i = i + 2;\n    }\n    return out_sign;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord -iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec4 col = vec4(vec3(0.2), 1.0);\n\n    vec2 uv_min = -iResolution.xy / iResolution.y;\n    vec2 uv_max = iResolution.xy / iResolution.y;\n    int i = 0;\n    \n    vec2 s = subdivide(uv, vec2(0.1, -0.2), uv_min, uv_max, i);\n    i *= 4;\n    s = subdivide(uv, s * vec2(-0.1, 0.2), uv_min, uv_max, i);\n    i *= 4;\n    s = subdivide(uv, s * vec2(-0.2, -0.1), uv_min, uv_max, i);\n    // i = i & 7;\n    // Output to screen\n    fragColor = add_screen(uv, uv_min, uv_max, col, i);\n//    fragColor = vec4(0.5 + 0.5 * uv_min, 0.5 + 0.5 * uv_max.x, 1.0);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_DIST 15.0\n\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat cone_sdf(in vec3 loc) {\n    float cone_length = \n        abs(loc.x) + length(loc.yz);\n\tcone_length = 0.7 * (cone_length - 1.5);\n\n\treturn cone_length;\n}\n\nfloat cyl_sdf(in vec3 loc) {\n    float r = length(loc.yz) - 0.5;\n    float cap1 = loc.x - 0.5;\n    float cap2 = -0.75 - loc.x;\n    return s_max(cap1, s_max(cap2, r, 0.2), 0.2);\n}\n\nfloat inv_sphere(in vec3 loc, in vec3 cent, in float rad) {\n  return max(-rad, rad - length(cent - loc));\n}\n\nfloat vehicle_sdf(in vec3 loc) {\n    float c = cone_sdf(loc);\n    float p = -loc.y;\n    float b = -loc.x + 0.2;\n    float shell = s_max(c, b, 0.6);\n    float back = s_max(cyl_sdf(loc), p, 0.1);\n    shell = s_min(shell, back, 0.4);\n    shell = s_max(shell,  p, 0.2);\n    \n    vec3 eye1 = vec3(0.7, 0.3, 0.3);\n    vec3 eye2 = vec3(0.7, 0.3, -0.3);\n    \n    return shell \n        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy - vec2(0.42, 0.0)))\n        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy + vec2(0.42, 0.0)))\n        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye1))\n        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye2))\n        - 0.1 * smoothstep(0.2, -0.0, loc.y) * (1.0 + 0.2 * smoothstep(0.4, 0.6, abs(loc.z)));\n}\n\nvec3 perturb2(in vec3 loc) {\n    return loc;\n}\n\nfloat vehicle_sdf2(in vec3 loc) {\n    float ball1 = length(loc - vec3(0.0, -0.8, 0.0)) - 1.0;\n    float ball2 = length(loc - vec3(0.0, 0.8, 0.0)) - 1.0;\n    float disc = s_max(ball1, ball2, 0.05);\n    float ball3 = length(loc - vec3(0.0, 0.1, 0.0)) - 0.2;\n    return s_min(disc, ball3, 0.1);\n}\n\nvec3 vehicle_sdf2_grad(in vec3 loc) {\n    float dist = vehicle_sdf2(perturb2(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf2(perturb2(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\nfloat cast_to_vehicle2(in vec3 orig, in vec3 dir, out float mindist) {\n    vec3 p = orig;\n    float accum = 0.0;\n    mindist = MAX_DIST;\n    for (int i = 0; i < 256; ++i) {\n        float dist = vehicle_sdf2(p);\n        mindist = min(dist, mindist);\n    \tfloat remaining = 0.7 * dist;\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb2(p);\n        if (remaining < 1.0e-3 || accum > MAX_DIST) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce2(in vec3 pt, in vec3 dir) {\n    vec3 norm = normalize(vehicle_sdf2_grad(pt));\n    return normalize(reflect(dir, norm));\n}\n\n\n\n\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = abs(2.0 * uv - 1.0);\n    fragColor = texture(iChannel0, uv);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float ramp(in float a, in float b, in float x) {\n    return clamp((x-a)/(b-a), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (4.0 * fragCoord - vec2(0.0, iResolution.y))/iResolution.x;\n    \n    uv.x = 1.5 * uv.x - 1.0;\n    \n    float along = uv.x;\n    uv.x = mod(uv.x, 1.0);\n    \n    uv.y = clamp(uv.y, 0.0, 1.0);\n    \n    float tstep = mod(iTime, 16.0);\n    tstep = tstep - mod(tstep, 1.0);\n    \n    const vec2 ostart = vec2(15.0 / 16.0, 11.0 / 16.0);\n    const vec2 bstart = vec2(2.0 / 16.0, 11.0 / 16.0);\n    const vec2 estart = vec2(5.0 / 16.0, 11.0 / 16.0);\n    const vec2 ystart = vec2(9.0 / 16.0, 10.0 / 16.0);\n    vec2 tstart = ostart;\n    tstart = mix(tstart, bstart, step(1.0, along));\n    tstart = mix(tstart, estart, step(2.0, along));\n    tstart = mix(tstart, ystart, step(3.0, along));\n    \n    \n    vec4 val = texture(iChannel0, tstart + uv / 16.0);\n    \n    const float scale = 1.0/256.0;\n    float dist = val.r + scale * (val.g + scale*val.b);\n\n    // Time varying pixel color\n    vec3 col = clamp(4.0 * sin(0.7521 * iTime) - 3.0, 0.0, 1.0) * vec3(ramp(0.3  , 0.7, dist));\n\n    // Output to screen\n    fragColor = vec4(col, col.r);\n}", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 78, 78, 429], [431, 431, 481, 481, 1062], [1064, 1064, 1090, 1090, 1167], [1170, 1170, 1206, 1206, 1503], [1506, 1506, 1556, 1556, 1897], [1899, 1899, 1941, 1941, 2034], [2036, 2036, 2068, 2068, 2844], [2846, 2846, 2900, 2900, 3276], [3278, 3278, 3332, 3332, 4729], [4732, 4732, 4799, 4799, 5267], [5269, 5269, 5326, 5326, 7637], [7639, 7639, 7745, 7745, 8534], [8536, 8536, 8630, 8630, 9116], [9118, 9118, 9175, 9225, 9867]], "test": "untested"}
{"id": "WlscD2", "name": "Generative Vasarely, Arny", "author": "ciphered", "description": "A generative recreation of the piece Arny, Victor Vasarely. \nMore on my insta: https://instagram.com/ciphrd", "tags": ["vasarely", "arni"], "likes": 2, "viewed": 328, "published": 3, "date": "1593140324", "time_retrieved": "2024-07-30T20:59:05.162835", "image_code": "#define DIVS 20.0\n#define PI 3.141592759\n\n\nfloat rand (vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 rotate (vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nbool approx (float a, float b, float d)\n{\n    return abs(a-b)<=d;\n}\n\nfloat circleSquare (vec2 uv, float t)\n{\n    float power = 4./(cos(t*PI/8.)+1.);\n    float lhs =\n        pow(abs(uv.x-uv.y), power) +\n        pow(abs(uv.y+uv.x), power)\n    ;\n    float rhs = 1.;\n    \n    return smoothstep(0.4, 0.5, rhs - lhs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x*= iResolution.x / iResolution.y;\n    \n    // grid\n    vec2 div = uv * DIVS;\n    vec2 sq = fract(div) - .5;\n    vec2 id = floor(div);\n    \n    // rotation\n    float rot = clamp(cos(iTime + id.x *.2 + id.y * .2), -.5, .5) + .5;\n    sq = rotate(sq, rot * PI * .25);\n    \n    // rectangles\n    vec2 asq = abs(sq);\n\tfloat rect = circleSquare(asq * 2., iTime * 2. + id.x);\n    \n    \n    // we give a background in diagonal\n    vec2 idc = id / DIVS;\n    vec3 col = vec3(0);\n    col = mix(vec3(.9, 0, .1), vec3(0.5, 0.5, 0.8), min(1.0, idc.x - idc.y + .5)) * rect;\n    col-= .5 - length((id+.5) / DIVS);\n    \n    // color is made by having circles running in... circles\n    vec2 ptc1 = vec2(cos(iTime*.5) * .4, sin(iTime*.5) * .4);\n    col.rgb+= vec3(0, 1., .5) * (1. - length(ptc1 - idc)) * (1. - rect);\n    \n    vec2 ptc2 = vec2(cos(iTime*.5 + PI) * .4, sin(iTime*.5 + PI) * .4);\n    col.rgb+= vec3(.5, 0., .8) * (1. - length(ptc2 - idc)) * (1. - rect);\n    vec2 ptc3 = vec2(cos(iTime*1.0 + PI*.5) * .4, sin(iTime*1.0 + PI*.5) * .4);\n    col.rgb+= vec3(1., 1., 1.) * (1. - length(ptc3 - idc)) * (1. - rect) * (cos(iTime)*.2 + .4);\n    \n    col*= rand(uv) * .1 + .9;\n    \n\t\n    // Time varying pixel color\n    //col = mix(col, vec3(1), rect);\n    \n    \n    // we square the view\n    float visible = step(abs(uv.x), .5);\n    visible*= step(abs(id.x), DIVS*.5 - 3.);\n    visible*= step(abs(id.y+.5), DIVS*.5 - 1.);\n    col*= visible;\n    \n    id = floor(div * 2. - .5);\n    id.y = floor(div.y * 2.);\n    visible = step(abs(id.x), DIVS - 5.);\n    visible*= step(abs(id.y + .5), DIVS - 1.5);\n    \n    col+= rand(uv) * .1;\n    \n    // the background\n    col+= (1. - visible) * clamp(pow(max(0., (1.-length(uv))), .2)* 1.1, .2, 1.);\n    col.b*= .92;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 64, 64, 131], [133, 133, 164, 164, 248], [250, 250, 291, 291, 317], [319, 319, 358, 358, 563], [565, 565, 622, 672, 2521]], "test": "untested"}
{"id": "WlsyW2", "name": "L-G-0 Foam", "author": "michael0884", "description": "Landau Ginsburg interacting bubbles.\ncolor - current, Size - pressure", "tags": ["simulation"], "likes": 16, "viewed": 619, "published": 3, "date": "1593127260", "time_retrieved": "2024-07-30T20:59:05.988627", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 col, in vec2 p )\n{\n    if(iMouse.z < 1.)\n    \tp = R*0.45 + p*0.1;\n    ivec2 pp = ivec2(p);\n    vec4 U = texel(ch0, pp);\n    \n    // Output to screen\n    float rho = length(U.xy);\n    float phi = atan(U.y, U.x)/(2.*PI);\n    \n    float md = 1e10;\n    vec2 mr = vec2(0.);\n\tvec2 mf = vec2(0.);\n    \n    //foam render pass 1\n\n    range(i, -2,2) range(j, -2, 2)\n    {\n        ivec2 pos = pp + ivec2(i,j);\n        vec2 hs = hs2(vec2(pos));\n        vec2 dx = vec2(pos) - p;\n        vec4 Ui = texel(ch0, pos);\n        vec2 foam = Psi2Foam(Ui.xy);\n        vec2 r = (1. + 0.3*foam.x)*(dx + foam + 0.6*(hs-0.5));\n        float d = length(r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mf = foam;\n        }\n    }\n    \n    md = 1e10;\n    \n    //foam render pass 2\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        ivec2 pos = pp + ivec2(i,j);\n        vec2 hs = hs2(vec2(pos));\n        vec2 dx = vec2(pos) - p;\n        vec4 Ui = texel(ch0, pos);\n        vec2 foam = Psi2Foam(Ui.xy);\n        \n        vec2 r = (1. + 0.3*foam.x)*(dx + foam + 0.6*(hs-0.5));\n       \n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    float b = smoothstep(0.15+0.7*abs(mf.y), 0.05, md);\n    vec3 c = sin(vec3(4.,2.,3.)*1.*mf.y);\n    col = vec4(vec3(b)*(max(c,0.) + max(-0.3*c,0.)),1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n#define texel(a, p) texelFetch(a, (p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 0.5\n#define freq 0.04\n\nfloat F(vec2 psi)\n{\n    return -0.2*(1. - length(psi));\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\nvec2 Psi2Foam(vec2 psi)\n{\n    float rho = length(psi);\n    float phi = atan(psi.y, psi.x);\n    vec2 foam = (1.1 - rho)*Dir(phi*2.);\n    return 2.*vec2(foam.x, foam.y);\n}\n\nvec2 hs2( vec2 p )\n{\n  \treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n", "buffer_a_code": "void mainImage( out vec4 U, in vec2 p )\n{\n    U = pixel(ch0, p);\n    vec3 dx = vec3(-1., 0., 1.);\n    vec4 L = 0.25*(pixel(ch0, p + dx.zy) + pixel(ch0, p + dx.xy) +\n                   pixel(ch0, p + dx.yz) + pixel(ch0, p + dx.yx)) - U;\n    \n    U.x += dt*(L.y - U.y*F(U.xy));\n    U.xy = Rot(freq*dt)*U.xy;\n    \n    if(iFrame < 1)\n        U = (1. - G(0.1*(p -R*0.5)))*vec4(1., 0., 0., 0.);\n    \n    float T = 0.01*float(iFrame)*dt;\n   \n    U *=  (1. - G(0.3*(p - R*0.5 + 0.2*R.y*Dir(T))));\n      \n    \n    if(iMouse.z > 0.)\n        U *= (1. - 0.0*G(0.1*(p - iMouse.xy)));\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 p )\n{\n    U = pixel(ch0, p);\n    vec3 dx = vec3(-1., 0., 1.);\n    vec4 L = 0.25*(pixel(ch0, p + dx.zy) + pixel(ch0, p + dx.xy) +\n                   pixel(ch0, p + dx.yz) + pixel(ch0, p + dx.yx)) - U;\n    \n    U.y -= dt*(L.x - U.x*F(U.xy));\n    U.xy = Rot(freq*dt)*U.xy;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205]], "test": "untested"}
{"id": "3tlyW2", "name": "Crack Newton", "author": "eiffie", "description": "Intentionally broken Newton's method.", "tags": ["fractal", "newton"], "likes": 12, "viewed": 516, "published": 3, "date": "1593119040", "time_retrieved": "2024-07-30T20:59:06.766547", "image_code": "//Crack Newton by eiffie (intentionally broken Newton's method)\n#define time iTime\n#define rez iResolution.xy\nvec2 CosSin(float a){return vec2(cos(a),sin(a));}\nvec2 cpwr(vec2 v, float p){return pow(length(v),p)*CosSin(atan(v.y,v.x)*p);}\nvec2 cmul(vec2 a,vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 cdiv(vec2 a,vec2 b){return (a*b.x+vec2(a.y,-a.x)*b.y)/dot(b,b);}\nvec2 f(vec2 p){return cmul(p,p)+vec2(0.0044+sin(time*0.14)*0.002,0.07+sin(time*0.1)*0.02);}\nvec2 df(vec2 p){return (0.51+sin(time)*0.01)*p+1.;}\nfloat DE(vec2 p){\n  p+=vec2(cos(time*0.05),cos(time*0.06))*20.0;p=abs(mod(p,20.)-10.)-5.;\n  float r=length(p);\n  for(int i=0;i<32;i++){\n    vec2 p2=p-cdiv(f(p),df(p));\n    r=length(p2-p);if(r<.001)break;\n    p=p2;\n  }\n  return r;\n}\nvec3 pal(float a){return abs(vec3(sin(a),sin(a*1.3),sin(a*1.5)));}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec3 col=vec3(0);\n  float d1,d2;\n  for(int y=0;y<2;y++)for(int x=0;x<2;x++){\n    vec2 uv=(2.0*(U+vec2(x,y)*0.5)-rez)/rez.x;\n    float d=DE(uv*exp(1.+sin(time*0.1)));\n    if(y==x)d1+=d; else d2+=d; \n    col+=pal(d*0.15); \n  }\n  col.b+=100.0*(d1-d2);\n  O=vec4(col*0.25,1.);\n}", "image_inputs": [], "sound_code": "#define bps 6.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,6.0); \n  if(n<1.0)n=0.0; \n  else if(n<2.0)n=2.0; \n  else if(n<3.0)n=6.0; \n  else if(n<4.0)n=8.0; \n  else if(n<5.0)n=5.0; \n  //else if(n<6.0)n=3.0; \n  //else if(n<7.0)n=0.0; \n  else n=2.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n)); \n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(5.5,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr zylo=instr(0.5,1.0,4.0,0.77,-0.51,0.002); \n instr drone=instr(1.,0.,.25,0.75,.0667,0.0); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(10.0,0.2,1.5,0.0,0.25,0.005); \n instr bass=instr(20.0,0.2,1.5,0.0,0.505,.0); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=I(36.,time,0.5,drone)*8.;//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,zylo)*n0.y*0.1;\n   a+=I(n0.x+69.0,time,t0,zylo)*n0.y*0.125;\n   if(mod(i,3.)<1.)a+=I(n0.x+93.0,time+Sin(t0*2.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i; \n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y*.2; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y*.2; \n     a+=I(n1.x+44.0,time,t1,bass)*n1.y;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+44.0,time,t2,bass)*n2.y; \n       //a+=I(n2.x+24.0,time+0.008*sin(t2*15.0),t2,bassdrum)*n2.y*4.0; \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/32.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 131, 131, 159], [160, 160, 187, 187, 236], [237, 237, 262, 262, 308], [309, 309, 334, 334, 378], [379, 379, 394, 394, 470], [471, 471, 487, 487, 522], [523, 523, 540, 540, 754], [755, 755, 773, 773, 821], [822, 822, 860, 860, 1136]], "test": "untested"}
{"id": "WlsyDj", "name": "Day 188", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 17, "viewed": 375, "published": 3, "date": "1593118678", "time_retrieved": "2024-07-30T20:59:07.608296", "image_code": "// I will rename these eventually!\n// I have no idea what day of my daily challenge it is tho\n\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 30 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./60.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n#define smease(p,g) ease(p, 1., 1.24, 0.96, 10.)\n        \n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[8](6.2*speed,3.7*speed, 4.6*speed, 4.6*speed, 4.*speed, 6.75*speed, 1.6*speed, 4.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    //t += sumScenes(5.)- 0.;\n    \n    t = mod(t, sumScenes(7.)  );\n    \n    vec2 triW = vec2(0.1,0.173)*1.;\n    \n    float its = 6.;\n    float scene = 0.;\n    \n    if(t < scenes[0]){\n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[0]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[0]*1.,3.);\n\n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n        //float dpp = dot(q,q);\n        //q /= dpp;\n\n        enva *= envb*2.;\n        \n\n        \n        enva = smoothstep(0.,1.,enva - dot(uv,uv));\n       \t\n        vec4 g = q;\n        q = pmod(abs(q) + enva*0.04,0.1);\n\n        \n        float dt = sdBox(q,vec4(0.04));\n        \n\n        float db = sdBox(g.xy,vec2(0.2));\n        db = max((pmod(db + enva*0.04,0.1)),db);\n\n\n        dt = max(dt,db);\n\t\t\n\n        d = min(d,dt); \n\n        d = abs(d);\n        \n        //d /= dpp;\n\n\n    } else if(t < sumScenes(1.)){\n\t\tt -= sumScenes(0.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[1]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[1]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva*1. + dot(uv,uv)*enva*4.);\n        \n        enva = envother;\n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n        //float dpp = dot(q,q);\n        //q /= dpp;\n\n\n        vec4 g = q;\n        q = pmod(q,(0.1 ));\n\n        float dt = sdBox(q,vec4(0.04 - 0.01*enva));\n\n        float db = sdBox(g.xy,vec2(0.2));\n        //db = max(abs(pmod(db + enva,0.1)),db);\n        db = max((pmod(db+0.2,0.1)),db);\n\n\n        dt = mix(dt,max(dt,db),1. - enva);\n\n\n        d = min(d,dt); \n\n        //d /= dpp;\n            \n\n    }  else if(t < sumScenes(2.)){\n        scene = 2.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = eease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-eease(t/scenes[int(scene)]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n        \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi - 0.25*pi*envother );\n        q.xy *= rot(0.25*pi  );\n\n        //float dpp = dot(q,q);\n        //q /= dpp;\n\n\n        vec4 g = q;\n        q = pmod(abs(q) - envother*envb*0.1,(0.1));\n\n        float dt = sdBox(q,vec4(0.03 - 0.02*envother));\n\n\n        dt = mix(dt, abs(pmod(dt,0.015)),envother);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n            \n\n    }   else if(t < sumScenes(3.)){\n        scene = 3.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = eease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-eease(t/scenes[int(scene)]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n        \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n\t\tq.wx *= rot(-0.25*pi*envother);\n        q.xy *= rot(0.25*pi );\n        \n        float dpp = dot(q,q);\n        \n        //q=mix(q,q / dpp,envother);\n\t\t\n        \n\n        vec4 g = q;\n        q.x -= 0.*envother;\n        q = pmod(q ,(0.1));\n\n        \n        float dt = sdBox(q,vec4(0.01));\n\t\t\n\n        dt = mix(dt, abs(pmod(dt,0.015)) ,1.);\n\n        d = min(d,dt); \n\n        //d *= mix(1.,dpp,envother);\n            \n            \n\n    }     else if(t < sumScenes(4.)){\n        scene = 4.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = eease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-eease(t/scenes[int(scene)]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva*1. + dot(uv,uv)*enva*4.);\n        \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n\t\tq.wx *= rot(-0.25*pi + 0.25*pi*envother);\n        q.xy *= rot(0.25*pi );\n        \n        float dpp = dot(q,q);\n        \n        q=mix(q,q / dpp,envother);\n\t\t\n        \n\n        vec4 g = q;\n        q = pmod(q ,(0.1));\n\n\n        \n        float dt = sdBox(q,vec4(0.01 + 0.03*envother));\n        \n\n        float db = sdBox(g.xy,vec2(0.2));\n        db = max((pmod(db,0.1)),db);\n\n\n        dt = mix(dt, abs(pmod(dt  + 0.5*0.015*enva,0.015)) ,1.);\n        \n        dt = mix(dt, max(dt,db),pow(enva,5.1)*1.);\n\t\t\n\n        d = min(d,dt); \n\n        d = abs(d);\n    \n        \n        d *= mix(1.,dpp,envother);\n           \n        \n        \n        //d *= dpp;\n            \n\n    }     else if(t < sumScenes(5.)){\n        scene = 5.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = eease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-eease(t/scenes[int(scene)]*1.,3.);\n\n\n        float envother = smoothstep(0.,1.,enva*1. + dot(uv,uv)*enva*4.);\n        \n        vec4 q = vec4(p,1,1);\n\n        \n        //q.yx *= rot(0.5*pi*envother);\n        \n        \n        q.wz *= rot(0.25*pi);\n\t\tq.wx *= rot(0.*pi);\n        q.xy *= rot(0.25*pi );\n\n                \n        q.yx *= rot(0.5*pi*envother);\n\n        \n        float dpp = dot(q,q);\n        \n        q=mix(q,q / dpp,1.);\n\t\t\n        vec4 g = q;\n        q = pmod(q ,(0.1 ));\n\n        \n\n        float dt = sdBox(q,vec4(0.04));\n        \n\n        float db = sdBox(g.xy,vec2(0.2+ 0.1*envother));\n        db = max((pmod(db,0.1)),db);\n\n\n        dt = mix(dt, abs(pmod(dt - 0.025*envother + 0.5*0.015,0.015)) ,1.);\n        \n        dt = mix(dt, max(dt,db),1.);\n\t\t\n\n        d = min(d,dt); \n\n        d = abs(d);\n    \n        d *= mix(1.,dpp,1.);\n            \n\n    } else if(t < sumScenes(6.)){\n        scene = 6.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = eease(t/scenes[int(scene)]*1.1,2.);\n\n        float envb = 1.-eease(t/scenes[int(scene)]*1.1,3.);\n\n        float envother = smoothstep(0.,1.,enva*1. + dot(uv,uv)*enva*4.);\n        \n        vec4 q = vec4(p,1,1);\n\n        \n        //q.yx *= rot(0.5*pi*envother);\n        \n        \n\t\tq.xy *= rot(0.5*pi*enva);\n        \n        q.wz *= rot(0.25*pi);\n\t\tq.wx *= rot(0.*pi);\n        q.xy *= rot(0.25*pi );\n\n                \n        q.yx *= rot(0.5*pi);\n\n        \n        float dpp = dot(q,q);\n        \n        q=mix(q, q/dpp, envb);\n\t\t\n        vec4 g = q;\n        q = pmod(q ,(0.1 + enva*envb*6.3 ));\n\n        \n\n        float dt = sdBox(q,vec4(0.04));\n        \n\n        float db = sdBox(g.xy,vec2(0.3));\n        db = max((pmod(db,0.1)),db);\n\n\n        dt = mix(dt, abs(pmod(dt - 0.025 - enva*0. ,0.015 + 0.0*enva)) ,1.);\n        \n        dt = mix(dt, max(dt,db),1.);\n\t\t\n\t\t\n        //dt = mix(dt,max(dt,db), enva);\n\n        \n        d = min(d,dt); \n\n        d = abs(d);\n    \n        d *= mix(1.,dpp,envb);\n            \n\n    } else if(t < sumScenes(7.)){\n        scene = 7.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.1,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.1,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n        \n        vec4 q = vec4(p,1,1);\n\n        \n        //q.yx *= rot(0.5*pi*envother);\n        \n        \n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi*enva);\n        q.xy *= rot(0.25*pi );\n\t\n    \t// ?            \n        q.yx *= rot(0.5*pi);\n\n        \n        vec4 g = q;\n        q = pmod(abs(q) ,0.1 );\n\n        \n\n        float dt = sdBox(q,vec4(0.04));\n        \n\n        float db = sdBox(g.xy,vec2(0.3 - 0.1*enva));\n        db = max((pmod(db,0.1)),db);\n\n\n        \n        dt = mix(dt, abs(pmod(dt - 0.025,0.015)) ,envb);\n        \n        dt = mix(dt, max(dt,db),1.);\n\t\t\n\t\t\n \n        d = min(d,dt); \n\n        d = abs(d);\n//---------------------------------------------------------------------------------------------------------------  ----------\n\n\n\n\n        dt = max(dt,db);\n\t\t\n\n        d = min(d,dt); \n\n        d = abs(d);\n        \n        //d /= dpp;\n            \n\n    }\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 412, 412, 468], [471, 482, 519, 519, 827], [828, 828, 865, 865, 912], [913, 913, 950, 950, 1015], [1069, 1069, 1138, 1138, 1294], [1295, 1295, 1326, 1326, 1430], [1634, 1634, 1662, 1662, 1769], [1771, 1771, 1798, 1798, 9733]], "test": "untested"}
{"id": "WtlcDj", "name": "Generation ship design", "author": "mrange", "description": "License CC0: Generation ship design\nI have been working on SciFi related shaders lately\nCode \"borrowed\" from the usual suspects\nLots and lots of cheating", "tags": ["scifiraymarching"], "likes": 13, "viewed": 432, "published": 3, "date": "1593116919", "time_retrieved": "2024-07-30T20:59:08.596653", "image_code": "// License CC0: Generation ship design\n//  I have been working on SciFi related shaders lately\n//  Code \"borrowed\" from the usual suspects\n//  Lots and lots of cheating\n\n// If you have a better graphics card than me uncomment for anti aliasing\n// #define AA\n#define TOLERANCE           0.001\n#define NORM_OFF            0.001\n#define MAX_RAY_LENGTH      100.0\n\n#define MAX_RAY_MARCHES     60\n\n#define PI                  3.141592654\n#define TAU                 (2.0*PI)\n\n#define TIME                iTime\n#define PERIOD              20.0\n#define PERIODS             3.0\n#define FADETIME            2.0\n#define TPERIOD             (mod(TIME, PERIOD))\n#define NPERIOD             (int(mod(TIME/PERIOD, PERIODS)))\n\nconst vec3  sunDirection        = normalize(vec3(-2.5, 3.5, -10.0));\nconst vec3  sunColor1           = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2           = vec3(1.0, 0.8, 0.9);\nconst vec3  smallSunDirection   = normalize(vec3(0.5, 0, -10.0));\nconst vec3  smallSunColor1      = vec3(1.0, 0.6, 0.6);\nconst vec3  smallSunColor2      = vec3(1.0, 0.3, 0.6);\n\nconst vec3  ringColor           = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet              = vec4(80.0, 20.0, -100.0, 50.0)*1000.0;\nconst vec3  planetCol           = sqrt(vec3(0.8, 0.7, 0.9))*1.3;\nconst vec3  ringsNormal         = normalize(vec3(1.0, 02.25, 0.0));\nconst vec4  rings               = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\nconst vec3  mountainColor       = sqrt(vec3(0.95, 0.65, 0.45));\n\nconst float refractRatio = 0.95;\n\nconst vec3  seaCol1     = vec3(0.15, 0.45, 0.55);\nconst vec3  seaCol2     = seaCol1*seaCol1*seaCol1*3.0;\n\nconst float innerLength = 4.0;\nconst float outerLength = 6.25;\nconst vec3  sunPos      = vec3(0.0, 0.0, innerLength);\n\nconst float radius      = 1.0;\nconst vec3  start      = vec3(0.0);\n  \nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nconst vec3 engineCol1 = vec3(8.0/8.0,6.0/8.0,6.0/8.0);\nconst vec3 engineCol2 = vec3(8.0/8.0,5.0/8.0,6.0/8.0);\n\nvoid rot(inout vec2 v, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  v.xy = vec2(v.x*c + v.y*s, -v.x*s + v.y*c);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// Not an exact distance field\nfloat softBox(vec3 p, float r) {\n  p *= p;\n  p *= p;\n  p *= p;\n  return pow(p.x + p.y + p.z, 1.0/8.0) - r;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat l2(vec2 p) {\n  return dot(p, p);\n}\n\nfloat l2(vec3 p) {\n  return dot(p, p);\n}\n\nfloat capsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n  return length(p.xy-c.xy)-c.z;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat chamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat roundIntersection(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat roundDiff (float a, float b, float r) {\n    return roundIntersection(a, -b, r);\n}\n\nfloat mod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {\n  vec3  oc = ro - cb;\n  float card = dot(ca,rd);\n  float caoc = dot(ca,oc);\n  float a = 1.0 - card*card;\n  float b = dot(oc, rd) - caoc*card;\n  float c = dot(oc, oc) - caoc*caoc - cr*cr;\n  float h = b*b - a*c;\n  if (h<0.0) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 ce, float ra) {\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2( -b-h, -b+h );\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nvec2 cylinderCoord(vec3 p) {\n  return vec2(p.z, atan(p.x, -p.y));\n}\n\nvec4 voronoi(vec2 x) {\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash2(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nfloat noise2(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm(vec2 p, int mx) {\n  const float aa = 0.45;\n  const float pp = 2.08;\n  const float rr = 1.0;\n  \n  float a = 1.0;\n  float s = 0.0;\n  float d = 0.0;\n  \n  for (int i = 0; i < mx; ++i) {\n    s += a*noise2(p);\n    d += abs(a);\n    a *= aa;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return 1.0*s/d;\n}\n\nvec3 normal(vec2 p, int mx) {\n  vec2 eps = -vec2(0.0001, 0.0);\n  \n  vec3 nor;\n  \n  nor.x = fbm(p + eps.xy, mx) - fbm(p - eps.xy, mx);\n  nor.y = 2.0*eps.x;\n  nor.z = fbm(p + eps.yx, mx) - fbm(p - eps.yx, mx);\n  \n  return normalize(nor);\n}\n\nvec3 gasGiant(vec3 ro, vec3 rd, vec3 sunDir) {\n  vec2 si = raySphere(ro, rd, planet.xyz, planet.w);\n  float pi = rayPlane(ro, rd, rings);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  return final;\n}\n\nvec3 sunColor(vec3 ro, vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n  vec3 col = vec3(0.0);\n\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2;\n\n  col += pow(smallDiff, 8000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.5;\n  col += pow(smallDiff, 150.0)*smallSunColor2*0.5;\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n  vec3 gcol = gasGiant(ro+vec3(0.0, 0.0, 200000.0), rd, sunDirection);\n  \n  return scol+gcol;\n}\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 refColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n\n  vec3 final = vec3(0.0);\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) final = vec3(2.0)*rd.y;\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  final *= 0.5;\n  final += scol;\n  \n  return final;\n}\n\nvec3 domeColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n\n  vec3 final = mix(vec3(0.125, 0.25, 0.5), vec3(0.25), 0.5 + 0.5*rd.y)*0.5;\n  final += scol;\n  \n  return final;\n}\n\nvec4 backplane(vec3 ro, vec3 rd, inout vec3 scol) {\n  float ed = (innerLength - ro.z)/rd.z;\n  vec3 ep = ro + rd*ed;\n  vec3 en = vec3(0.0, 0.0, 1.0);\n\n  float lr = 0.5;\n  float er = (lr*lr-dot(ep.xy, ep.xy))/(lr*lr);\n  float eradius = length(ep.xy);\n  float emradius = eradius;\n  float eangle = atan(ep.y, ep.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.1);\n  mod1(emangle, TAU/60.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n  \n  float efadeout = 1.0 - smoothstep(0.0, 0.9, eradius);\n\n  scol = vec3(0.0);  \n  scol += 8.0*lightCol1*pow(clamp(er, 0.0, 1.0), 8.0);\n  scol += lightCol1*pow(clamp(er, 0.0, 1.0), 1.0);\n  scol += lightCol2*efadeout*efadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += scol;\n  ecol += elinec*smoothstep(0.01, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.015, 0.0, abs(emangle))*efadeout;\n \n  return vec4(ecol, eradius < 1.0);\n}\n\nvec3 islands(vec3 col, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.7;\n  float beachLevel = level + 0.025;\n\n  vec3 sunDir = normalize(sunPos - p);\n\n  sp *= 2.0;\n  float hih = fbm(sp, 6);\n  float loh = fbm(sp+vec2(0.075-0.075*sp.x/innerLength, 0.0), 3);\n  vec3 hn = normal(sp, 6);\n\n  vec3 nn = normalize(hn + n);\n\n  const vec3 sandCol = vec3(1.0, 0.95, 0.9);\n\n  float fdiff = pow(max(dot(sunDir, nn), 0.0), 0.5);\n  \n  vec4 treePattern = voronoi(sp*40.0);\n  vec3 islandCol  = mix(vec3(0.5, 0.75, 0.0), vec3(0.1, 0.45, 0.0), treePattern.y*fdiff*2.0);\n  islandCol *= 1.0 - treePattern.x * 0.75;\n\n  col = mix(0.0, 1.0, hih < level)*mix(sandCol, col , 1.0 - exp(8.0*vec3(2.0, 1.0, 1.0)*(hih-level)));\n  col = mix(col, sandCol, vec3((beachLevel >  hih) && (hih > level)));\n  col = mix(col, islandCol, vec3(hih > beachLevel));\n  // Really REALLY fake lighting+shadows\n  const float hh = 0.125;\n  vec3 scol = vec3(1.0)*(smoothstep(level, level+hh, hih) - smoothstep(level, level+hh, loh));\n  col = col+scol*0.5;\n\n  return col;\n}\n\nvec3 clouds(vec3 col, vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.5;\n\n  vec3 ref = reflect(rd, n);\n\n  vec3 sunDir = normalize(sunPos - p);\n  float sunL2 = l2(sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe1 = 0.5*pow(max(dot(sunDir, ref), 0.0), 10.0);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  sp *= 2.0;\n  sp += 100.0;\n  float hih = max(fbm(sp, 6) - level, 0.0);\n  float loh = max(fbm(sp, 3) - level, 0.0);;\n\n  // More fake stuff\n  float m = clamp(1.0- exp(-15.0*(hih-0.5*loh)), 0.0, 1.0);\n\n  col = mix(col, vec3(1.25)*lightCol1*(sunIll + spe1 + spe2), m*m*m);\n\n  return col;\n}\n\nvec3 cloudShadows(vec3 col, vec3 p, float level) {\n  level += 0.5;\n\n  vec3 sunDir = normalize(sunPos - p);\n\n  vec2 ci = rayCylinder(p, sunDir, start, vec3(0.0, 0.0, 1.0), 0.8*radius);\n\n  vec3 pp = p + ci.x*sunDir;\n  vec2 pp2 = cylinderCoord(pp);\n\n  pp2 *= 2.0;\n  pp2 += 100.0;\n  float loh = max(fbm(pp2, 3) - level, 0.0);\n\n  return col*mix(0.3, 1.0, exp(-3.0\n  *loh));\n}\n\nvec3 sea(vec3 ro, vec3 rd, vec3 n, vec3 p, vec2 sp) {\n\n  vec3 ref = reflect(rd, n);\n  ref = normalize(ref + 0.025*psin(mix(110.0, 220.0, psin(2.0*p.z+0.2*p.x))*p.z));\n\n  vec3 sunDir = normalize(sunPos - p);\n  float sunL2 = l2(sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  vec3 seaCol = vec3(0.0);    \n  seaCol += 1.0*seaCol2*pow(1.0-max(dot(n, ref), 0.0), 0.45);\n  seaCol += seaCol1*0.5*sunIll;\n  seaCol += seaCol1*lightCol1*sunDiff*sunIll;\n  seaCol += lightCol1*spe2;\n  \n  return seaCol;  \n}\n\nvec3 shipInterior(vec3 ro, vec3 rd) {\n  ro += rd*0.05;\n  \n  float fd = (0.0 - ro.z)/rd.z;\n  vec2 di = raySphere(ro, rd, start, 1.0);\n  vec2 ci = rayCylinder(ro, rd, start, vec3(0.0, 0.0, 1.0), 0.8*radius);\n  vec2 gi = rayCylinder(ro, rd, start, vec3(0.0, 0.0, 1.0), 0.9*radius);\n\n  vec3 dp = ro + rd*di.y;\n  vec3 dn = -normalize(dp  -start);\n  vec3 drefr = refract(dp, dn, 1.0/refractRatio);\n  vec3 dcol = 0.9*domeColor(dp, drefr);\n\n  vec3 gp = ro + rd*gi.y;\n  vec3 gpy = ro + rd*gi.x;\n  vec3 gn = -normalize(vec3(gp.xy-start.xy, 0.0));\n  vec2 gp2 = cylinderCoord(gp);\n\n  vec3 cp = ro + rd*ci.y;\n  vec3 cn = -normalize(vec3(cp.xy-start.xy, 0.0));\n\n  vec3 fpcol = vec3(0.0);\n  \n  vec3 scol;\n  vec4 bpcol = backplane(ro, rd, scol);\n  vec3 bpn = vec3(0.0, 0.0, 1.0);\n  float bpdiff = max(dot(rd, bpn), 0.0);\n\n  vec3 col = vec3(0.0);\n\n  col = mix(col, fpcol, vec3(fd > gi.y));\n  col = mix(col, dcol, vec3(dp.z < 0.0));\n  col = mix(col, bpcol.xyz, bpcol.w);\n\n  if (gp.z > 0.0 && gpy.z < 0.0 && gp.z < innerLength) {\n    float level = 0.0;\n    level += 1.0-smoothstep(0.0, 0.1*innerLength, gp2.x);\n    level += 1.0-smoothstep(0.0, 0.1*innerLength, innerLength-gp2.x);\n\n    /*\n    // Too fix discontinuity. Alternative approach, place the camera correctly ;)\n    level += 1.0-smoothstep(-PI, -PI+0.5, gp2.y);\n    level += 1.0-smoothstep(PI, PI-0.5, gp2.y);\n    */\n    \n    level *= 0.125;\n    vec3 gcol = sea(ro, rd, gn, gp, gp2);\n    gcol = islands(gcol, gp, gn, gp2, level);\n    gcol = cloudShadows(gcol, gp, level);\n    gcol = clouds(gcol, ro, rd, cp, cn, cylinderCoord(cp), level);\n    col = gcol;\n  }\n  \n  float id = max(gi.y-max(gi.x, 0.0), 0.0);\n  col = mix(col, lightCol1, 1.0-exp(-0.05*id*id));\n  col = mix(col, 0.75*scol + 1.25*lightCol1, pow(bpdiff, 35.0));\n\n  return col;\n}\n\nfloat theShip(vec3 p, out float nx, out float ny, out int m) {\n  const float rep = 5.0;\n  const float tradius = 1.2;\n  const float sstep = TAU*1.125/rep;\n  const float sradius = 0.45*TAU*1.125/rep;\n  rot(p.xy, TIME*TAU/60.0);\n  float dcapsule = capsule(p, outerLength, 1.0);\n  dcapsule = pmin(dcapsule, softBox(p, 0.75), 0.25);\n  float dglobe = max(dcapsule, p.z);\n  \n  vec3 pc = p;\n  pc.z -= 0.5*sstep;\n  float n = mod1(pc.z, sstep);\n  float dtorus = torus(pc.xzy, vec2(tradius*1.55, 0.025));\n  float nm = modPolar(pc.xy, rep);\n  float dspoke = cylinder(pc, vec3(tradius*1.55, 0.0, 0.025));\n  dtorus = min(dtorus, dspoke);\n  dtorus = max(dtorus, -p.z + sstep*0.5-0.025);\n  dtorus = max(dtorus, p.z-sstep*5.0 + sstep*0.5-0.025);\n  float dbattery = sphere(pc - vec3(tradius, 0.0, 0.0), sradius);\n  float dbox = softBox(pc - vec3(tradius, 0.0, 0.0), sradius*0.9);\n  dbox = roundDiff(dbox, dbattery, 0.125);\n  dbattery = min(dbattery, dbox);\n  dbattery = max(dbattery, -p.z + sstep*0.05);\n  dbattery = max(dbattery, p.z-sstep*5.0);\n  float dengine1 = sphere((p-vec3(0.0, 0.0, outerLength+1.0)), 0.9);\n  float dengine2 = sphere((p-vec3(0.0, 0.0, outerLength+2.0)), 0.9);\n  float dengine3 = sphere((p-vec3(0.0, 0.0, outerLength+1.0)), 0.25);\n  float dengine = dengine1;\n  dengine = max(dengine, -dengine2);\n  dengine = min(dengine, dengine3);\n  vec3 pe = p;\n  pe -= vec3(0.0, 0.0, outerLength+1.8);\n  mod1(pe.x, 0.5);\n  mod1(pe.y, 0.5);\n  float d = dcapsule;\n  d = min(d, dengine);\n  d = chamfer(d, dbattery, 0.035);\n  d = min(d, dtorus);\n  \n \n  m = 1;\n\n  if (d == dglobe) m = 3;\n  if (d == dbattery) m = 4;\n  if (d == dtorus) m = 1;\n  if (d == dbox) m = 2;\n  if (d == dengine1) m = 2;\n  if (d == -dengine2) m = 5;\n  if (d == dengine3) m = 5;\n\n  nx = n;\n  ny = nm;\n  \n  return d;\n}\n\nfloat map(vec3 p, out float nx, out float ny, out int m) {\n  return theShip(p, nx, ny, m);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out float nx, out float ny, out int mat, out int iter) {\n  float t = 0.0;\n  float d;\n  int i;\n  for (i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    d = map(ro + rd*t, nx, ny, mat);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d; // 0.9\n  }\n  iter = i;\n  \n  if (abs(d) > 10.0*TOLERANCE) return MAX_RAY_LENGTH;\n  \n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec3  eps = vec3(NORM_OFF,0.0,0.0);\n  vec3 nor;\n  float nx;\n  float ny;\n  int mat;\n  nor.x = map(pos+eps.xyy, nx, ny, mat) - map(pos-eps.xyy, nx, ny, mat);\n  nor.y = map(pos+eps.yxy, nx, ny, mat) - map(pos-eps.yxy, nx, ny, mat);\n  nor.z = map(pos+eps.yyx, nx, ny, mat) - map(pos-eps.yyx, nx, ny, mat);\n  return normalize(nor);\n}\n\nvec3 innerColor(vec3 ro, vec3 rd, vec3 nor, float nx, float ny) {\n  vec2 f = hash2(137.0*vec2(nx, ny)+27.0);\n  vec3 refr = refract(rd, nor, 3.0); \n  float dim = smoothstep(0.6, 0.7, f.x);\n  dim *= mix(0.5, 1.0, psin(2.0*TIME+f.y*TAU));\n  float s1 = mix(0.3, 2.0, dim);\n  float s2 = mix(1.0, 1.25, dim);\n  float m = max(dot(nor, -refr), 0.0);\n  return 1.5*s1*pow(vec3(1.2, 1.1, s2)*m, 1.25*vec3(2.5, 2.5, 5.5));\n}\n\nvec3 engineColor(vec3 ro, vec3 rd, vec3 nor) {\n  float eradius = length(ro.xy);\n  float emradius = eradius;\n  float eangle = atan(ro.y, ro.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.2);\n  mod1(emangle, TAU/20.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n  \n  float efadeout = 1.0 - smoothstep(0.0, 0.75, eradius);\n  float ifadeout = smoothstep(0.2, 0.225, eradius);\n\n  vec3 refr = refract(rd, nor, 1.25); \n  float m = max(dot(nor, -refr), 0.0);\n \n \n  vec3 scol = vec3(0.0);  \n  scol += 4.0*engineCol1*pow(m, 4.0);\n  scol += engineCol2*2.0;\n  scol *= 1.0- ifadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += elinec*smoothstep(0.02, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.05, 0.0, abs(emangle))*efadeout;\n  ecol += engineCol2*2.0*efadeout*efadeout;\n  ecol *= ifadeout;\n \n  return ecol + scol;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n  // background color\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  int mat = 0;\n  int iter = 0;\n  float nx;\n  float ny;\n  float t = rayMarch(ro, rd, nx, ny, mat, iter);\n\n//  vec3 icol = 1.0*vec3(1.0, 0.0, 0.9)*smoothstep(0.5, 1.0, float(iter)/MAX_RAY_MARCHES);\n  const  vec3 icol = vec3(0.0);\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = normal(pos);\n\n  float ndif = 1.0;\n  float nref = 0.8;\n\n  vec3 ref  = reflect(rd, nor);\n  vec3 rcol = refColor(pos, ref);\n  vec3 refr = refract(rd, nor, refractRatio);\n    \n  if (t < MAX_RAY_LENGTH) {\n    // Ray intersected object\n    \n    switch(mat) {\n    case 0:\n      color = mix(vec3(1.0), nor*nor, 0.5);\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 1:\n      color = vec3(0.9) + abs(nor.zxy)*0.1;\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 2:\n      color = vec3(0.25) + abs(nor.zxy)*0.05;\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 3:\n      vec3 sicol = shipInterior(pos, refr);\n      color = mix(sicol, rcol, vec3(refr == vec3(0.0)));\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 4:\n      color = innerColor(pos, rd, nor, nx, ny);\n      ndif = 0.75;\n      nref = 0.9;\n      break;\n    case 5:\n      color = engineColor(pos, rd, nor);\n      ndif = 0.5;\n      nref = 0.75;\n      break;\n    default:\n      color = nor*nor;\n      break;\n    }\n      \n  }\n  else {\n    // Ray intersected sky\n    return skyColor(ro, rd) + icol;\n  }\n\n  vec3 ld0  = vec3(0.0, 1.0, 0.0);\n\n  vec3 lv1  = sunDirection;\n  float ll1 = length(lv1);\n  vec3 ld1  = lv1 / ll1;\n\n  vec3 lv2  = smallSunDirection;\n  float ll2 = length(lv2);\n  vec3 ld2  = lv2 / ll2;\n\n  int rmat = 0;\n  int riter = 0;\n  float st  = rayMarch(pos + ref*10.0*TOLERANCE, ref, nx ,ny, rmat, riter);\n  float sha2 = st < MAX_RAY_LENGTH ? 0.0 : 1.0;\n\n  float dif0 = pow(max(dot(nor,ld0),0.0), ndif);\n  float dif1 = pow(max(dot(nor,ld1),0.0), ndif);\n  float dif2 = pow(max(dot(nor,ld2),0.0), ndif);\n\n  vec3 col0 = mix(vec3(1.0), dif0*vec3(1.0), 0.8);\n  vec3 col1 = mix(vec3(1.0), dif1*lightCol1, 0.8);\n  vec3 col2 = mix(vec3(1.0), dif2*lightCol2, 0.8);\n\n  vec3 col = mix(rcol*sha2, color*(col0 + col1 + col2)/2.0, nref);\n\n  return col + icol;\n}\n\nvec3 fragment(vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float tperiod = TPERIOD;\n  int nperiod = NPERIOD;\n  vec3 ro  =vec3(1.0, 0.0, -3.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n \n  switch(nperiod) {\n  case 0:\n    ro = 3.0*vec3(0.5-tperiod/10., 1.0+tperiod/5.0, 15.0-tperiod);\n    break;\n  case 1:\n    ro = vec3(-10.0+tperiod, 0.5, -3.0);\n    break;\n  case 2:\n    ro = -3.0*vec3(-0.5+tperiod/10., 1.0-tperiod/5.0, 10.0-tperiod);\n    break;\n  default:\n    break;\n  }\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/iResolution.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/  \n  col += fragment(ro, uu, vv, ww, p+o1);\n\n#ifdef AA\n  // Adaptive AA? Is that a good idea?  \n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+1.0/256.0);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n  if (de > 0.1) {\n    col += fragment(ro, uu, vv, ww, p-o1);\n    col += fragment(ro, uu, vv, ww, p+o2);\n    col += fragment(ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n#endif\n\n  col = clamp(col, 0.0, 1.0);\n  float fadeIn = smoothstep(0.0, FADETIME, tperiod);\n  float fadeOut = 1.0 - smoothstep(PERIOD - FADETIME, PERIOD, tperiod);\n  col *= fadeIn;\n  col *= fadeOut;\n  \n  fragColor = vec4(col ,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlcDj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[2036, 2036, 2069, 2069, 2157], [2159, 2159, 2190, 2190, 2216], [2218, 2249, 2281, 2281, 2357], [2359, 2359, 2388, 2388, 2453], [2455, 2455, 2473, 2473, 2495], [2497, 2497, 2515, 2515, 2537], [2539, 2539, 2580, 2580, 2635], [2637, 2637, 2669, 2669, 2703], [2705, 2705, 2754, 2754, 3156], [3158, 3158, 3197, 3197, 3286], [3288, 3288, 3330, 3330, 3380], [3382, 3382, 3434, 3434, 3526], [3528, 3528, 3573, 3573, 3615], [3617, 3617, 3656, 3656, 3789], [3791, 3791, 3855, 3855, 4160], [4162, 4162, 4204, 4204, 4251], [4254, 4254, 4307, 4307, 4504], [4506, 4506, 4527, 4527, 4556], [4558, 4558, 4579, 4579, 4649], [4651, 4651, 4671, 4671, 4769], [4771, 4771, 4799, 4799, 4838], [4840, 4840, 4862, 4862, 5202], [5204, 5204, 5226, 5226, 5701], [5703, 5703, 5730, 5730, 6002], [6004, 6004, 6033, 6033, 6241], [6243, 6243, 6289, 6289, 7746], [7748, 7748, 7781, 7781, 8162], [8164, 8164, 8197, 8197, 8325], [8327, 8327, 8352, 8352, 8381], [8383, 8383, 8416, 8416, 8753], [8755, 8755, 8789, 8789, 8936], [8938, 8938, 8989, 8989, 9796], [9798, 9798, 9860, 9860, 10825], [10827, 10827, 10906, 10906, 11505], [11507, 11507, 11557, 11557, 11877], [11879, 11879, 11932, 11932, 12476], [12478, 12478, 12515, 12515, 14256], [14258, 14258, 14320, 14320, 16034], [16036, 16036, 16094, 16094, 16128], [16131, 16131, 16220, 16220, 16499], [16501, 16501, 16524, 16524, 16855], [16857, 16857, 16922, 16922, 17269], [17271, 17271, 17317, 17317, 18077], [18080, 18080, 18111, 18133, 20285], [20287, 20287, 20346, 20346, 20422], [20424, 20424, 20479, 20479, 22071]], "test": "untested"}
{"id": "3llyzl", "name": "Julia - Distance 2", "author": "iq", "description": "SDF for the Julia set of  f(z) = z^3+C, used for the intro of [url=https://www.youtube.com/watch?v=rQ2bnU4dkso]Geodes[/url]. More info: [url]https://iquilezles.org/articles/distancefractals/distancefractals.htm[/url]", "tags": ["2d", "fractal", "julia", "sdf", "juliaset", "distance", "orbittrap", "traps", "orbittraps", "cubic", "distanceestimator"], "likes": 29, "viewed": 2465, "published": 3, "date": "1593112526", "time_retrieved": "2024-07-30T20:59:09.451368", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The Julia set of f(z) = z^3+c, as rendered for the video\n// \"Geodes\": https://www.youtube.com/watch?v=rQ2bnU4dkso\n\n// It uses the distance to the Julia set for coloring\n// More info:\n// https://iquilezles.org/articles/distancefractals\n\n// Related:\n//\n// Julia - Distance 1 : https://www.shadertoy.com/view/Mss3R8\n// Julia - Distance 2 : https://www.shadertoy.com/view/3llyzl\n// Julia - Distance 3 : https://www.shadertoy.com/view/4dXGDX\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0,ivec2(fragCoord),0).xyz;\n    \n    // vignetting    \n    vec2 p = fragCoord/iResolution.xy;\n    col *= 0.5+0.5*pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.1);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The Julia set of f(z) = z^3+c, as rendered for the video\n// \"Geodes\": https://www.youtube.com/watch?v=rQ2bnU4dkso\n\n// It uses the distance to the Julia set for coloring\n// More info:\n// https://iquilezles.org/articles/distancefractals\n\n// Related:\n//\n// Julia - Distance 1 : https://www.shadertoy.com/view/Mss3R8\n// Julia - Distance 2 : https://www.shadertoy.com/view/3llyzl\n// Julia - Distance 3 : https://www.shadertoy.com/view/4dXGDX\n\n\n// 0: bright\n// 1: dark\n#define COLOR_SCHEMA 0\n// 0: off\n// 1: on\n#define TAA          1\n\n#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 5\n#endif\n\n\n// --------------------------------------\n// Visual Studio rand()\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n    n = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n// --------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\n// --------------------------------------\n\n// pixel to z-plane transform\nmat3x3 pixel2z( in float time )\n{\n    // rotation\n    float an = 0.021*time;\n    float co = cos(an), si=sin(an);\n    // scale\n    float  sc = 1.2*pow(0.95,time);\n    // translation\n    vec2   tr = vec2(0.0,0.17);\n    \n    return mat3x3( sc*co, sc*si, 0.0,\n                  -sc*si, sc*co, 0.0,\n                   tr.x,  tr.y,  1.0 );\n}\n\nvec3 render( in vec2 fragCoord, in float gtime )\n{\n    vec4 col = vec4(0.0);\n    \n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // 2.5 pixel wide filter footprint, cubic falloff\n        const float fw = 2.5;\n        vec2 o = fw*(vec2(float(m),float(n)) / float(AA) - 0.5);\n        float w = smoothstep(fw*0.5,0.0,length(o));\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // motion blur\n        float time = gtime + (0.5/24.0)*frand();\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float w = 1.0;\n        float time = gtime;\n\t\t#endif\n\n        // pixel to z\n        vec2 z = (pixel2z(time)*vec3(p,1.0)).xy;\n\n        // compute Julia set\n        const float threshold = 64.0;\n        const vec2  kC = vec2(0.105,0.7905);\n        const int   kNumIte = 200;\n\n        float it = 0.0;\n        float dz2 = 1.0;\n        float m2 = 0.0;\n        for( int i=0; i<kNumIte; i++ )\n        {\n            // df(z)/dz = 3*z^2\n            dz2 *= 9.0*dot2(vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y));\n            // f(z) = z^3 + c\n            z = vec2( z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y ) + kC;\n            // check divergence\n            it++;\n            m2 = dot2(z);\n            if( m2>threshold ) break;\n        }\n        \n        // distance\n        float d = 0.5 * log(m2) * sqrt(m2/dz2);\n        // interation count\n        float h = it - log2(log2(dot(z,z))/(log2(threshold)))/log2(3.0); // https://iquilezles.org/articles/msetsmooth\n        \n        // coloring\n        vec3 tmp = vec3(0.0);\n        if( it<(float(kNumIte)-0.5) )\n        {\n            #if COLOR_SCHEMA==0\n            tmp = 0.5 + 0.5*cos( 5.6 + sqrt(h)*0.5 + vec3(0.0,0.15,0.2));\n            tmp *= smoothstep(0.0,0.0005,d);\n            tmp *= 1.2/(0.3+tmp);\n            tmp = pow(tmp,vec3(0.4,0.55,0.6));\n            #else\n            tmp = vec3(0.12,0.10,0.09);\n            tmp *= smoothstep(0.005,0.020,d);\n            float f = smoothstep(0.0005,0.0,d);\n            tmp += 3.0*f*(0.5+0.5*cos(3.5 + sqrt(h)*0.4 + vec3(0.0,0.5,1.0)));\n            tmp = clamp(tmp,0.0,1.0);\n\t\t\t#endif\n        }\n        \n        col += vec4(tmp*w,w);\n\t#if AA>1\n    }\n    col /= col.w;\n\t#endif\n\n    return col.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // draw Julia set (supersampled)\n    vec3 col = render(fragCoord,iTime);\n    \n    //----------------------\n    // temporal reprojection\n    //----------------------\n#if TAA==1\n    // new pixel to old pixel transform (velocity vector)\n    mat3x3    z_from_pnew = pixel2z(iTime);\n    mat3x3 pold_from_z    = inverse(pixel2z(iTime - iTimeDelta +  (0.25/24.0) )); // from previous frame\n    mat3x3 pold_from_pnew = pold_from_z*z_from_pnew;\n    \n    // reproject\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 op = (pold_from_pnew*vec3(p,1.0)).xy;\n    vec2 sp = 0.5*(iResolution.y*op + iResolution.xy);\n    \n    // blend color\n    vec4 data = texture(iChannel0,sp/iResolution.xy);\n  \tcol = mix(col,data.xyz,0.8);\n#endif    \n    // output\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyzl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[567, 567, 624, 624, 847]], "test": "untested"}
{"id": "WlscWj", "name": "Star demo", "author": "Nrx", "description": "A very basic star shape, for educational purposes (with step by step explanations on how things are done).", "tags": ["star"], "likes": 3, "viewed": 373, "published": 3, "date": "1593109049", "time_retrieved": "2024-07-30T20:59:10.375896", "image_code": "#define PI\t\t\t3.14159265358979\n#define STEPS\t\t5.0\n#define RADIUS\t\t0.8\n#define SLOPE\t\t2.5\n#define THICKNESS\t0.08\n#define AA\t\t\t0.01\n#define REPEAT\t\t2.0\n\nmat2 rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat starDist (in vec2 p)\n{\n\t// Divide the plan in STEPS sectors\n\tconst float arc = 2.0 * PI / STEPS;\n\tp *= rotate (arc * floor (atan (p.y, p.x) / arc + 0.5));\n\n\t// Compute the signed distance to the triangle edge (there is one triangle per sector)\n\treturn (p.x + abs (p.y) * SLOPE - RADIUS) / sqrt (1.0 + SLOPE * SLOPE);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalization of the fragment coordinates\n\tfragCoord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\t// Define the strip pattern\n\tfloat strip = smoothstep (0.3 - AA * 10.0, 0.3 + AA * 10.0, cos (fragCoord.y * 40.0 + sin (fragCoord.x * 20.0) + iTime * 10.0));\n\n\t// Translation of the plan\n\tvec2 p = fragCoord + vec2 (0.5 * cos (iTime * 0.7), 0.2 * sin (iTime * 1.4));\n\n\t// Rotation of the plan\n\tp *= rotate (iTime);\n\n\t// Zoom of the plan\n\tfloat zoom = 1.0 + 0.5 * cos (iTime * 1.8);\n\tp /= zoom;\n\n\t// Consider the plan is a grid of squares\n\tp = p / REPEAT + 0.5;\n\tvec2 id = floor (p);\n\tp = REPEAT * (fract (p) - 0.5);\n\n\t// Rotation of the square's contents (the angle depends on the position of the square in the grid)\n\tp *= rotate (iTime * (id.x * 2.0 + id.y * 3.0));\n\n\t// Compute the signed distance to the star shape within each square\n\tfloat star = starDist (p);\n\n\t// For the fun, add little stars in the big stars, using the same approach as above\n\tp /= 0.1;\n\tp = REPEAT * (fract (p / REPEAT + 0.5) - 0.5);\n\tstar = max (star, -abs (starDist (p)));\n\n\t// What about adding other stars in the background? (Again, using the same approach as above but starting with \"fragCoord\") \n\tp = fragCoord * rotate (-iTime * 0.6) / 0.3;\n\tp = REPEAT * (fract (p / REPEAT + 0.5) - 0.5);\n\tstar = min (star, max (-star,  starDist (p)));\n\n\t// Display the stars and strips\n\tconst float halfThickness = THICKNESS * 0.5;\n\tfloat halfThicknessAA = halfThickness + AA / zoom;\n\tfloat redGradient =  0.7 + 0.3 * cos (PI * fragCoord.x * iResolution.y / iResolution.x);\n\tfragColor = vec4 (\n\t\tsmoothstep (-halfThicknessAA, -halfThickness, star) * redGradient,\n\t\tsmoothstep (halfThicknessAA, halfThickness, abs (star)),\n\t\tsmoothstep (-halfThickness, -halfThicknessAA, star) * strip,\n\t\t1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 180, 180, 258], [260, 260, 288, 325, 584], [586, 586, 642, 688, 2417]], "test": "untested"}
{"id": "WllcWj", "name": "Generative Vasarely, Eridan", "author": "ciphered", "description": "A generative recreation of the piece Eridan III, Victor Vasarely. \nMore on my insta: https://instagram.com/ciphrd", "tags": ["vasarely", "eridan"], "likes": 3, "viewed": 532, "published": 3, "date": "1593108468", "time_retrieved": "2024-07-30T20:59:11.230611", "image_code": "#define DIVS 20.0\n#define SMOOTH 0.02\n\n\n\nvec2 r2d (vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x*= iResolution.x / iResolution.y;\n    \n    // space is divided into a grid\n    vec2 div = uv * DIVS;\n    vec2 sq = fract(div) - .5;\n    vec2 id = floor(div);\n    \n    // rotation of some squares given their distance to 2 moving points\n    float rot = 0.0;\n    \n    vec2 p1 = vec2(cos(iTime*1.) * sin(iTime*1.4) * .2, sin(iTime*1.) * .5);\n    vec2 dr = p1 - id/DIVS;\n    float lp1 = smoothstep(0.4, -.01, abs(dr.x));\n    lp1*= smoothstep(0.4, -.01, abs(dr.y));\n    rot+= lp1 * cos(iTime) * cos(iTime*2.+4.) * cos(iTime*8.-0.2) * 4.;\n    \n    \n    vec2 p2 = vec2(cos(iTime*1.3 + 2.) * cos(iTime*.2+6.) * .3, sin(iTime*2. + 1.) * .35);\n    dr = p2 - id/DIVS;\n    float lp2 = smoothstep(0.4, -.01, abs(dr.x));\n    lp2*= smoothstep(0.4, -.01, abs(dr.y));\n    rot+= lp2 * cos(iTime) * cos(iTime*1.+4.6) * cos(iTime*12.+.7) * 2.;\n\n    \n    // rotate some of the divs\n    sq = r2d(sq, rot);\n    \n    // the inner rectangle\n    vec2 asq = abs(sq);\n    float s = sqrt(2. * pow(.5*.5, 2.));\n    float rect = smoothstep(s+SMOOTH, s-SMOOTH, asq.x) * smoothstep(s+SMOOTH, s-SMOOTH, asq.y);\n    \n\n    // half is inverted\n    rect = mix(rect, 1. - rect, sign(p2.y) * sign(p1.y) * sign(uv.y)*.5+.5);\n    vec3 col = vec3(rect, rect, rect);\n    \n    // we step on x to only have a visible square\n    float visible = step(uv.x, .5) * step(-.5, uv.x);\n    // and the outer cells\n    visible*= step(abs(id.x), DIVS*.5 - 3.);\n    visible*= step(abs(id.y+.5), DIVS*.5 - 1.);\n    \n    col*= visible;\n    \n    // the background\n    col+= 1. - visible;\n    col*= clamp(pow(max(0., (1.-length(uv))), .2)* 1.1, .2, 1.) + visible;\n\n    col.b*= 0.92;\n    \n    \n    // we add the dots\n    col.b+= smoothstep(0.04, 0.03, length(p1 - uv));\n    col.b+= smoothstep(0.04, 0.03, length(p2 - uv));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllcWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 69, 69, 153], [156, 156, 213, 263, 2137]], "test": "untested"}
{"id": "WtXcW2", "name": "Virtual particle MPM fluid", "author": "michael0884", "description": "Now tracking the angular momentum!\nCellular automaton particle tracking used for advection in a fluid which is also fully conservative\nEach pixel has 1 virtual particle", "tags": ["particles", "ca"], "likes": 17, "viewed": 889, "published": 3, "date": "1593102328", "time_retrieved": "2024-07-30T20:59:12.266840", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-1., 0., 1.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    float curl = -0.5*(V(pos + dx.zy).y - V(pos + dx.xy).y - \n                       V(pos + dx.yz).x + V(pos + dx.yx).x);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = vec3(0.1,0.1,0.1) + 5.*col1*max(-curl, 0.) + 5.*col0*max(curl, 0.);\n    // Output to screen\n    col = vec4(3.);\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.5*b + specular*2.)*rho.z, a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(float rho)\n{\n    //return 0.06*rho; //gas\n    return 0.04*rho*(rho/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.2)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.6), R*vec2(1.5, 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X; //\n    vec2 V; //velocity\n    float M; //mass\n    float I; //angular velocity\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.z;\n    P.I = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M, P.I);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.1\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n   \n    //pass 1 - get center of mass\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n    }\n    \n    //moment of inertia\n    float I = 0.;\n    //pass 2 - get velocity and angular momentum\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        vec2 dx = P0.X - P.X;\n      \n\t\tfloat W = P0.I; \n        //relative velocity of this part of the square\n        vec2 rel_V = P0.V + W*vec2(dx.y, -dx.x);\n        \n        //add momentum\n        P.V += rel_V*m;\n        //add angular momentum\n        P.I += (dx.x*P0.V.y - dx.y*P0.V.x)*m;\n        //add moment of inertia\n        I += dot(dx, dx)*m;\n    }\n   // I = max(I, 0.1);\n    //normalization\n    if(P.M != 0.)\n    {\n        P.V /= P.M; //get velocity\n        P.I /= I;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the forces\n    vec2 F = vec2(0.);\n    float w = 0.;\n    vec2 avgV = vec2(0.);\n    mat2 C = mat2(0.);//affine matrix\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        if(i == 0 && j == 0) continue;\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        vec2 dv = P0.V - P.V;\n        float avgP = 0.5*(Pf(P.M) + Pf(P0.M)); \n        float k = P0.M*G(1.*dx); \n        F -= 0.5*k*avgP*dx;\n        //rotation speed difference \n        float dI = P0.I - P.I;\n        //P.I += 0.5*dI*k;\n        \n        avgV += k*P0.V;\n\n        //constructing the affine matrix\n        C += k*mat2(P0.V*dx.x,P0.V*dx.y); \n        \n        w += k;\n    }\n    \n    avgV /= w;\n    \n    //viscosity\n    F += 0.*P.M*(avgV.xy - P.V);\n   \n    //gravity\n    F += P.M*vec2(0., -0.0006);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/9.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 2.*P.M*N.xy*exp(-abs(N.z));\n    if(N.z < 5.) \n    {\n        //P.X = pos;\n        P.V *= 0.;\n       // P.M = 2.*fluid_rho;\n    }\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n    //angular momentum limit\n    P.I = P.M*clamp(P.I/P.M, -0.01, 0.01);\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec2 F = vec2(0.);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.5) \n        {\n            P.X = pos;\n            P.V = 0.*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = mass;\n            P.I = 0.;\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = 1e-6;\n            P.I = 0.;\n        }\n    }\n    \n   \n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos); \n    \n   \n    if(P.M != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n   \n\t/*\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }*/\n    \n    if(length(pos - R*vec2(0.5, 0.1)) < 10.) \n    {\n      // P.I = 0.2;\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M, P.I)*G((pos - x0)/1.5); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 243, 293], [295, 295, 311, 311, 339], [341, 341, 386, 386, 1693]], "test": "untested"}
{"id": "wtXcW2", "name": " Pancake Conf 2020 LiveShading", "author": "Alkama", "description": "Converted from a liveshading session that happened during the Pancake Conference 2020.\nNot very optimal, tons of artefacts, but was fun to do.\nhttps://psenough.github.io/pancake/", "tags": ["raymarching", "distancefield", "liveshading"], "likes": 16, "viewed": 595, "published": 3, "date": "1593081416", "time_retrieved": "2024-07-30T20:59:13.159454", "image_code": "const float pi=acos(-1.0);\nfloat t,st,m;\n#define sat(a) clamp(a,0.,1.)\nvec2 amod(vec2 p,float m) { float a=mod(atan(p.x,p.y),m)-m*.5; return vec2(cos(a),sin(a))*length(p); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat sphere(vec3 p, float r) { return length(p)-r; }\nfloat caps(vec3 p, float h, float r) { p.y-=clamp(p.y,0.,h); return length(p)-r; }\n///////////////////////////////////////////////////////////////////\n// Simplex  Noise 2D (by IQ): https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nfloat fnoise(vec2 uv) {\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n///////////////////////////////////////////////////////////////////\nfloat scene(vec3 p) {\n  if(length(p)-1.5>.1) return .1;\n  float nz=fnoise(p.xz*8.)*.0001;\n\n  float o=100.;\n  vec3 pp=p;\n  pp*=vec3(1,10.,1);\n  o=min(o,sphere(1.02*pp, 1.)*.1+nz*2.);\n  pp-=vec3(0,1.1+.4*sin(t*6.),0); o=min(o,sphere(1.12*pp, 1.)*.1+nz*6.);\n  pp-=vec3(0,1.1+.4*sin(t*4.),0); o=min(o,sphere(1.1*pp, 1.)*.1+nz*6.);\n  pp-=vec3(0,1.1+.4*sin(t*10.),0); o=min(o,sphere(1.2*pp, 1.)*.1+nz*4.);\n  pp-=vec3(0,1.1+.0*sin(t*4.),0); o=min(o,sphere(1.2*pp, 1.)*.1+nz*4.);\n  vec3 p2=p;\n  p2.xz=amod(p2.xz,pi*.01);\n  p2.xy*=rot(-pi*.34);\n  p2 -= vec3(.55,0,0);\n  float plate=caps(p2,1.2-.05*sin(p.x*p.y*p.z*10.),.05-.01*sin(p.x*p.z*20.));\n  if(plate<o) m=5.;\n  return min(o,plate);\n}\nvec3 camdir(vec2 uv, vec3 og, vec3 tg, float z) {\n  vec3 f=normalize(tg-og);\n  vec3 s=normalize(cross(vec3(.3*sin(t+sin(st)),1,0),f));\n  vec3 u=normalize(cross(f,s));\n  return normalize(f*z+uv.x*s+uv.y*u);\n}\nvec3 normal(vec3 p) {\n  vec2 e=vec2(.001,0);\n  return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx)));\n}\nfloat pales(vec2 uv, float screen, float number) {\n  uv*=rot(-t*screen);\n  return floor(smoothstep(.1,.2,cos(atan(uv.y,uv.x)*number)));\n}\nvec4 march(vec3 og, vec3 dir, int it, float tr, float mx) {\n  float d=0.;\n  vec3 p=og;\n  for(int i=0; i<it; i++) {\n    float h=scene(p)*.8;\n    if(abs(h)<tr || d>mx) break;\n    d+=h;\n    p+=dir*h;\n  }\n  return vec4(p,d);\n}\nfloat shadow(vec3 p, vec3 lp) {\n  vec3 ldir=normalize(lp-p);\n  float ldist=length(lp-p);\n  float d=march(p,ldir,100,.0001,5.).w;\n  if(d<ldist) {\n    return .5;\n  } else {\n    return 1.;\n  }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy / iResolution.xy - .5) * vec2(iResolution.x/iResolution.y, 1.);\n\n  t = mod(.4*iTime,10.*pi);\n  float ft=floor(t);\n  float dt=fract(t);\n  st=ft+dt*dt;\n  m=0.;\n\n  vec2 uv2 = uv;\n  uv2.xy+=.4*vec2((sin(st)+.2*sin(t*2.)),sin(st*.5));\n  vec3 bg=vec3(0);\n  bg+=pales(uv2,.4,30.);\n  bg-=pales(uv2,.2,28.);\n  bg+=pales(uv2,-.6,20.);\n  bg-=pales(uv2,-.3,18.);\n  bg=mix(vec3(1.,.9, .5),vec3(1.,.4, .1),sat(bg));\n  float ccc=1.-length(uv2*(1.+.2*sin(t*8.)));\n  bg+=ccc;\n  bg += .05*step(.9,bg.ggg);\n  vec3 col=bg;\n  \n  vec3 eye=3.*vec3(.1,.35,.1);\n  eye += 2.*vec3(sin(st)+.2*sin(t*2.),.2*sin(st*.5),cos(st-sin(t)));\n  vec3 target=vec3(.2*sin(st*4.),.1*sin(st*2.),.2*cos(st));\n  vec3 dir=camdir(uv,eye,target,.75);\n  \n  vec3 lp=vec3(1,3,-2);\n  lp.xz+=1.5*vec2(sin(t*8.),cos(t*6.));\n  \n  vec4 hit=march(eye,dir,400,.001,5.);\n  float d=hit.w;\n  if(d<5.){\n    vec3 p=hit.xyz;\n    vec3 n=normal(p);\n    vec3 ld=normalize(lp-p);\n    float diff=abs(dot(n,ld));\n    if(m==0.) {\n      float miaou=smoothstep(.96,1.,abs(n.y));\n      col=diff*mix(vec3(1.,.9,.5),vec3(1.,.4,.1),miaou);\n      col-=.5*pow(.5+.5*fnoise(p.xz*(5.-p.y)), 4.);\n    } else {\n      float spec=sat(pow(abs(dot(dir,reflect(ld,n))),50.));\n      float fres=1.-sat(pow(abs(1.-dot(n,-dir)),5.));\n      col=sat(vec3(.8+spec)*fres)*cos(dir);\n    }\n    col*=shadow(p,lp);\n  }\n    \n  fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 98, 98, 173], [174, 174, 193, 193, 243], [244, 244, 275, 275, 297], [298, 298, 336, 336, 380], [381, 517, 538, 538, 653], [654, 654, 680, 680, 1158], [1159, 1159, 1182, 1182, 1408], [1409, 1477, 1498, 1498, 2158], [2159, 2159, 2208, 2208, 2366], [2367, 2367, 2388, 2388, 2494], [2495, 2495, 2545, 2545, 2632], [2633, 2633, 2692, 2692, 2855], [2856, 2856, 2887, 2887, 3047], [3048, 3048, 3105, 3105, 4505]], "test": "untested"}
{"id": "wlfyW2", "name": "Cos Accuracy", "author": "mla", "description": "Compare built in cos & sine with an accurate Taylor expansion - horizontal scale is ±pi/2, vertical is ±1e-4 or ±1e-6 depending on platform. For cos, errors peak around zero where linear approximation is hardest.", "tags": ["cos", "accuracy"], "likes": 3, "viewed": 401, "published": 3, "date": "1593080781", "time_retrieved": "2024-07-30T20:59:13.994222", "image_code": "// Trig function errors. This is mainly intended to show what happens on Intel\n// where cos and sine are computing with a simple piecewise linear\n// approximation. There is a check for GPUs with better trig functions, eg. Nvidia,\n// and zooms in vertically if so (it's just checking a single value so might\n// give false positives though).\n\n// Red channel: error in cos(x)\n// Green channel: error in sin(x)\n// Blue channel: ulps error in cos(x)\n\nfloat PI = 3.141592654;\nfloat mycos(float x) {\n  int N = 12;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\n\nfloat mysin(float x) {\n  int N = 10;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}\n\nbool comp(float y, float r) { return (0.0 < y) == (y < r); }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1e-4;\n  float check = max(0.1,-iTime);\n  if (abs(cos(check)-mycos(check)) < 1e-6) scale = 1e-6;\n  float x = 0.5*PI*(2.0*fragCoord.x-iResolution.x)/iResolution.x;\n  float y = scale * (2.0*fragCoord.y-iResolution.y)/iResolution.y;\n  float r = cos(x) - mycos(x);\n  float s = sin(x) - mysin(x);\n  // The ulps check assumes both values have the same sign.\n  int ulps = floatBitsToInt(cos(x))-floatBitsToInt(mycos(x));\n  //fragColor = vec4(comp(y,r),comp(y,s),comp(y,float(ulps)/float(1<<23)),1);\n  fragColor = vec4(comp(y,r));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[470, 470, 492, 492, 617], [620, 620, 642, 642, 769], [771, 771, 800, 800, 831], [833, 833, 886, 886, 1426]], "test": "untested"}
{"id": "wtfyW2", "name": "deceiving shader 3 :-p", "author": "FabriceNeyret2", "description": "all of them: [url]https://www.shadertoy.com/results?query=deceiving[/url]\n", "tags": ["glsl", "shadertoy", "deceiving"], "likes": 4, "viewed": 379, "published": 3, "date": "1593077371", "time_retrieved": "2024-07-30T20:59:14.865891", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = texture(iChannel0, U/iResolution.xy);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define w rgb*=sin(10.*iTime); float x\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 86]], "test": "untested"}
{"id": "ttfyDj", "name": "Day 187", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 30, "viewed": 535, "published": 3, "date": "1593065386", "time_retrieved": "2024-07-30T20:59:15.618878", "image_code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./60.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\n#define pmod(p,j) mod(p - 0.5*j,j) - 0.5*j\n\n\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[10](6.2*speed,2.7*speed, 2.6*speed, 4.2*speed, 3.*speed, 6.75*speed, 6.2*speed, 7.2*speed, 6.2*speed, 8.9*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    //t += sumScenes(8.)- 0.;\n    \n    t = mod(t, sumScenes(9.)  );\n    \n    vec2 triW = vec2(0.1,0.173)*1.;\n    \n    float its = 6.;\n    \n    if(t < scenes[0]){\n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n           \n            float enva = smease(t/scenes[0]*1.,2.);\n            \n            float envb = 1.-smease(t/scenes[0]*1.,3.);\n \t\t\t\n            \n                        \n            \n            p *= rot(tau*i/its);\n\t\t\t\n            \n            float antiatten = (1. - enva);\n\n            p.y -= 0.105*antiatten;\n            \n            p.y += 0.9*enva*envb;\n            p.xy *= rot(-pi*enva/1.);\n           \n            vec2 q = p;\n            \n            enva*=envb;\n            \n            float dt = sdTri(p,triW);\n            for(int i = 0; i < 2; i++){\n            \tp = abs(p);\n                p.x -= 0.03*antiatten;\n                p.y -= 0.03*antiatten;\n            \t\n                p.xy *= rot( .5*pi*antiatten);\n\t\t\t\n                p.xy *= rot(-0.5*pi*enva);\n                p.y -= 0.1*enva;\n                p.x += 0.15*enva;\n            \t\n                //p.x += 0.05*enva;\n                \n                p.xy *= rot(0.25*pi*enva);\n                \n            }\n            \t\t\t\t\t\n            \n            //p *= rot(0.5*pi*enva);\n                \n            \n            \n            dt = mix(dt,sdBox(p,triW/5.),1.*antiatten);\n            q = pmod(q,triW/2.);\n            dt = mix(dt,sdBox(q,triW/14.),enva*2.5); \n            \n            //dt = mix(dt, max(abs(pmod(dt ,0.02)) - 0.001,dt),0.);\n            \n            //dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),0.);\n            \n            d = min(d,dt); \n            \n            \n        }\n\n    } else if(t <  sumScenes(1.) ) {\n    \tt -=  sumScenes(0.) ;\n        \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(pi*2.*i/its);\n\n            float env = smease(t/scenes[1],2.);\n            p.x -= 0.2*env;\n\t\t\t\n            p *= rot(env*pi/3.);\n            \n\n            d = min(d,sdTri(p,triW)); \n\n        }\n        \n    \n    }else if(t < sumScenes(2.) ) {\n    \tt -= sumScenes(1.); \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(pi*2.*i/its);\n\n            float env = smease(t/scenes[2],2.5);\n            p.x -= 0.2 - 0.2*env;\n\t\t\t\n            p *= rot(pi/3.);\n            \n\n            d = min(d,sdTri(p,triW)); \n\n        }\n        \n    }else if(t < sumScenes(3.)) {\n    \tt -= sumScenes(2.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            \n            \n            p *= rot(pi*2.*i/its);\n\n            \n            float enva = smease(t/scenes[3]*2.,1.);\n\t\t\t\n            float envb = smease(t/scenes[3]*1.,3.);\n\t\t\t\n            p *= rot(envb*pi);\n            p.x += 0.1*enva;\n\n            d = min(d,sdTri(p,triW)); \n\n        }\n        \n    }else if(t < sumScenes(4.)) {\n    \tt -= sumScenes(3.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(pi*2.*i/its);\n\n            \n            float enva = smease(t/scenes[4]*1.,3.);\n\t\t\t\n            float envb = smease(t/scenes[4]*1.5,2.);\n\t\t\t\n            p *= rot(pi + pi*enva);\n            \n            p.x += 0.1 - 0.1*enva;\n            \n            d = min(d,sdTri(p,triW)); \n\n        }\n    \n    }else if(t < sumScenes(5.)) {\n    \tt -= sumScenes(4.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[5]*0.9,3.);\n            \n            p.xy -= 0.1*enva;\n\t\t\t\n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.xy *= rot(-pi*0.25*enva);\n                p.x -= 0.06*enva;\n            }\n            \n            //p *= rot(pi);\n\n            \n            float dt = sdTri(p,triW); \n            dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),1.*enva);\n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(6.)) {\n    \tt -= sumScenes(5.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[6]*0.8,3.);\n            \n            p.xy -= 0.1;\n\t\t\t\n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.xy *= rot(-pi*0.25 + 0.5*pi*enva);\n                p.x -= 0.06;\n            }\n            \n            float dt = sdTri(p,triW); \n            dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),1.);\n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(7.)) {\n    \tt -= sumScenes(6.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[7]*1.,3.);\n            \n            p.xy *= rot(-1.*pi*enva);\n            p.xy -= 0.1;\n            \n            \n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.xy *= rot(0.25*pi + -0.25*pi*enva);\n                p.x -= 0.06 - 0.1*enva;\n            \t\n                p.y += 0.02*enva;\n                \n                p.xy *= rot(0.25*pi*enva);\n\t\t\t\n            }\n            \n            float dt = sdTri(p,triW); \n            dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),1. - 1.*enva);\n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(8.)) {\n    \tt -= sumScenes(7.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[8]*1.25,3.);\n            \n            p.xy *= rot(-1.*pi - 1.*pi*enva);\n            p.xy -= 0.1 - 0.1*enva;\n            \n            \n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.x -= -0.04 + 0.04*enva;\n            \t\n                p.y += 0.02 - 0.02*enva;\n                \n                p.xy *= rot(0.25*pi + .25*pi*enva);\n\t\t\t\n            }\n            \n            float dt = sdTri(p,triW); \n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(9.)) {\n    \tt -= sumScenes(8.) ; \n        \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            float enva = smease(t/scenes[9]*1.25,3.);\n            \n            float envb = 1.-smease(t/scenes[9]*1.25,2.);\n            \n            p *= rot(tau*i/its);\n\n            p *= rot(pi);\n\n            \n            //enva*= envb*6.;\n            \n            enva *= 1.5;\n            \n            p.y -= 0.07*enva;\n\n            //p *= rot(pi*enva/1.);\n\n           \n            \n\n            \n            float dt = sdTri(p,triW); \n            \n            for(int i = 0; i < 2; i++){\n            \tp = abs(p);\n                p.x -= 0.03;\n                p.y -= 0.03;\n            \t\n                //p.y += 0.005;\n                \n                p.xy *= rot( .5*pi);\n\t\t\t\n            }             \n            //p \n            dt = mix(dt,sdBox(p,triW/5.),enva/1.5); \n            //dt = mix(dt, max(abs(pmod(dt ,0.02)) - 0.001,dt), 1.-envb);\n            \n            d = min(d,dt); \n            \n        }\n    }\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    \n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 302, 302, 358], [361, 372, 409, 409, 717], [718, 718, 755, 755, 802], [850, 850, 919, 919, 1075], [1076, 1076, 1108, 1108, 1212], [1382, 1382, 1410, 1410, 1517], [1519, 1519, 1546, 1546, 8866]], "test": "untested"}
{"id": "3lfcD2", "name": "Michael's Cool Algorithm 3D", "author": "wyatt", "description": "..", "tags": ["fluid"], "likes": 14, "viewed": 460, "published": 3, "date": "1593050013", "time_retrieved": "2024-07-30T20:59:16.486559", "image_code": "// Fork of \"Michael's Cool Algorithm\" by wyatt. https://shadertoy.com/view/ttsyzs\n// 2020-06-25 01:31:08\n\nSampler\nMain\n{\n    R = iResolution.xy;\n    vec3 mi = 0.5*vec3(R/N,N*N);\n    vec3 p = vec3(0,0,-R.x/N);\n    vec3 d = normalize(vec3((U-0.5*R)/R.y,1));\n    if (iMouse.z>0.) {\n \t\tp.zx *= e(6.2*iMouse.x/R.x);\n\t\td.zx *= e(6.2*iMouse.x/R.x);\n        p.yz *= e(6.2*iMouse.y/R.y);\n\t\td.yz *= e(6.2*iMouse.y/R.y);\n    } else {\n\t\tp.xz *= e(.1*iTime);\n\t\td.xz *= e(.1*iTime);\n\t}\n    Q = vec4(0);\n    for (int i = 0; i < 100; i++) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m<.1)\n        { \t\n            vec4 a = T(p+mi).wwww;\n            float aa = length(a);\n            Q += 2e-2*(1.-exp(-aa))*(a)*(0.5+0.5*sin(a+vec4(1,2,3,4)));\n            p += d*(.01+exp(-.1*aa*aa));\n           //p = mod(p+mi,R3D)-mi;\n        } else p += d*m;\n        \n \t}\n    Q = .8*atan(log(1.+Q));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n   \tvec4 a, b;\n    \n   \tprog (d3(U),a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n   \tvec4 a, b;\n    \n   \tprog (d3(U),a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n   \tvec4 a, b;\n    \n   \tprog2 (d3(U),a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n   \tvec4 a, b;\n    \n   \tprog2 (d3(U),a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 M;\nint I;\n#define N 9.\n#define R3D vec3(R/N,N*N)\n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define d2(U) ((U).xy+vec2(mod(floor((U).z),N),floor(floor((U).z)/N))*R/N)\n#define d3(u) vec3(mod(u,R/N),floor(u/R*N).x+floor(u/R*N).y*N)\n#define _3D  vec3 U = d3(u)\n#define Sampler vec4 T(vec3 U) {return mix(texture(iChannel0,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel0,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define A(U) texture(cha,d2(mod(U,R3D))/R)\n#define B(U) texture(chb,d2(mod(U,R3D))/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\nfloat signe (float x) {return atan(100.*x);}\nvoid prog (vec3 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = vec4(0); b = vec4(0);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 u = vec3(x,y,z);\n    \tvec4 aa = A(U+u), bb = B(U+u);\n        aa.xyz += bb.xyz;\n        #define q 1.1\n\t\tvec3 w1 = clamp(aa.xyz-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(aa.xyz+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)*(w2.z-w1.z)/(q*q*q);\n        aa.xyz = 0.5*(w1+w2);\n        a.xyz += aa.xyz*aa.w*m;\n        b.xyz += bb.xyz*aa.w*m;\n        a.w += aa.w*m;\n    }\n    if (a.w>0.) {\n        a.xyz/=a.w;\n        b.xyz/=a.w;\n    }\n}\nvoid prog2 (vec3 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = A(U); b = B(U);\n    vec3 f = vec3(0); float m = 0.;\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 u = vec3(x,y,z);\n        float l = length(u);\n        if (l>0.) {\n    \t\tvec4 aa = A(U+u), bb = B(U+u);\n            f += 1e-2*(aa.w*(1.-.2*aa.w))*u/l;\n            m += aa.w;\n        }\n    }\n    if (m>0.) b.xyz += f/m;\n    \n    \n    // Boundaries:\n   \tb.xyz -= 1e-3*signe(a.w)*(a.xyz-0.5*R3D)*sin(1e-5*float(I));\n\n    \n    if (I<1||U.x<1.||R3D.x-U.x<1.||R3D.y-U.y<1.||R3D.x-U.x<1.||U.z<1.||R3D.z-U.z<1.) {\n    \ta = vec4(U,0);\n        b = vec4(0);\n        if (length(U-0.5*R3D) < 0.2*R3D.y) a.w = 20.;\n    }\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 120, 120, 904]], "test": "untested"}
{"id": "WtXyW2", "name": "Pixel Brawl", "author": "RobRob", "description": "This shader simulates groups of pixels brawling and duplicating themselves, using a buffer. Best enjoyed in full screen.\n\nRobRob", "tags": ["2d", "pixel", "rgb", "buffer", "swarm", "robrob", "brawl"], "likes": 7, "viewed": 417, "published": 3, "date": "1593036231", "time_retrieved": "2024-07-30T20:59:17.410089", "image_code": "// This work is licensed under the\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n// International License.\n\n// Created by RobRob for display on shadertoy.com.\n\n// This part of the code uses the r-component of every buffered pixel\n// to determine which colour to render.\n\nconst float PI = 3.14159265359;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Get the pixel value from buffer A set in the previous tab.\n    vec3 texel = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    // If the r-component is not set, the pixel is unpopulated and therefore black.\n    if (texel.r == 0.)  {\n        fragColor = vec4(0., 0., 0., 1.0);\n        return;\n    }\n    \n    // Map the r-component to full colours using a sine function.\n    vec3 col = sin(vec3(0, 2, 4) + texel.r) * .5 + .5;\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXyW2.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[319, 319, 374, 430, 953]], "test": "untested"}
{"id": "WlXcDj", "name": "Sandstone cave system", "author": "jarble", "description": "These caves are rendered using a [url=https://www.shadertoy.com/view/3tXyRN]\"minimal raymarching\"[/url] shader.\nUse the mouse to look around.", "tags": ["procedural", "3d", "raymarching", "caves"], "likes": 3, "viewed": 433, "published": 3, "date": "1593031346", "time_retrieved": "2024-07-30T20:59:18.223913", "image_code": "#define t iTime\n#define r iResolution\n#define iterations 500 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 20.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 surface_color(vec3 p)\n{\n    float color1 = length(sin(p))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p)/10.0)/40.0,color1/2.0)/10.0;\n}\n\nfloat SDF1(vec3 p){\n    return length(sin(p*.6)-sin(p))-1.4;\n}\n\nfloat SDF(vec3 p){\n\tfloat to_return = SDF1(p);\n    for(int i = 1; i <5;i++){\n        p += p.yzx/float(i*i);\n    \tto_return = min(to_return,SDF1(p));\n    }\n    return to_return/1.5;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,6,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    for(int i=0;i<iterations;i++)\n    {\n        float sd1 = SDF(p);\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(surface_color(p*100.0),0)+l1/100.0)*3.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 279, 279, 397], [399, 399, 418, 418, 461], [463, 463, 481, 481, 645], [647, 647, 688, 688, 1185]], "test": "untested"}
{"id": "WtfyDj", "name": "Paint streams", "author": "michael0884", "description": "Cellular automaton particle tracking used for advection in a fluid which is also fully conservative\nEach pixel has 1 virtual particle\nhttps://michaelmoroz.github.io/Reintegration-Tracking/", "tags": ["particles", "ca"], "likes": 601, "viewed": 29464, "published": 3, "date": "1593031206", "time_retrieved": "2024-07-30T20:59:19.051700", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n    col = vec4(3.);\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.5*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0004);\n\n     if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw*vec2(1.0,-1.0))/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 243, 293], [295, 295, 311, 311, 339], [341, 341, 386, 386, 1548]], "test": "untested"}
{"id": "wtlcDS", "name": "Healt Shader", "author": "MrOkiDoki", "description": "A shader for my game.", "tags": ["health"], "likes": 3, "viewed": 308, "published": 3, "date": "1593021725", "time_retrieved": "2024-07-30T20:59:19.808676", "image_code": "\n\n\n\nfloat DrawPlus(vec2 uv,float blur)\n{\n    uv = abs(uv);\n    float plusX = length(uv - vec2(min(uv.x,0.2),0));\n    plusX = smoothstep(0.04,0.04-blur,plusX);\n    \n    float plusY = length(uv - vec2(0,min(uv.y,0.2)));\n    plusY = smoothstep(0.04,0.04-blur,plusY);   \n\t\n    return clamp(plusX + plusY,0.,1.);\n}\nfloat DrawCircle(vec2 uv)\n{\n    float offset = (0.5 * (sin(iTime*10.) + 1. )) * 0.002;\n    \n    float INminD = 0.38 + offset;\n\tfloat INmaxD = 0.42 + offset;\n\t\n\tfloat OUminD = 0.39 + offset;\n\tfloat OUmaxD = 0.41 + offset;\n    \n    float alpha = 0.;\n    float dist = length(uv);\n\n\tif(dist > INminD && dist < INmaxD)\n    {\n        //Get the angle given UV\n        float angle = atan(-uv.y,uv.x) * (180. / 3.1415);\n        \n        //Normalize Angle\n        if(angle < 0.)\n        \tangle = angle + 360.;\n        \n        //Shift & Normalize\n        angle -= 270.;\n        angle = fract(angle/360.)*360.;\n        \n        if(angle < ( fract((iTime * 360.) / 360.)*360.))\n        {\n        \talpha = 1.;\n        }\n        else\n        {\n            if(dist > OUminD && dist < OUmaxD)\n    \t\t{\n    \t\t    alpha = fract(angle/10.);\n                if(alpha < 0.4 || alpha > 0.8)\n\t\t\t\t\talpha = 0.;\n                else\n                    alpha = 1.;\n    \t\t}\n        }\n        \n    }\n\n    return clamp(alpha,0.,1.);\n}\n\nconst vec3 PlusColor = vec3(0.9,.15,.1);\nconst vec3 CircleColor = vec3(1,.6,.1);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5 *iResolution.xy) / iResolution.y;\n    \n\n    vec3 col = vec3(0.);\n    \n    //Circle\n\tfloat circleAlpha = DrawCircle(uv);\n    //Plus\n\tfloat plusAlpha = DrawPlus(uv,.001);\n\t\n    \n    col += PlusColor * plusAlpha;\n    col += CircleColor * circleAlpha;\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 40, 40, 309], [310, 310, 337, 337, 1314], [1399, 1399, 1456, 1456, 1772]], "test": "untested"}
{"id": "WlfcWj", "name": "Projector Laser Show", "author": "Danguafer", "description": "Volumetric projector laser show forked from https://www.shadertoy.com/view/wtlczl", "tags": ["projection", "laser"], "likes": 13, "viewed": 669, "published": 3, "date": "1593017661", "time_retrieved": "2024-07-30T20:59:20.737193", "image_code": "// Forked from https://www.shadertoy.com/view/wtlczl\n\n\nvec3 eye \t\t\t\t\t= vec3(0.f,0.f,5.f);\nvec4 sphere\t\t\t\t\t= vec4(0.f,0.f,0.f, 0.7f);\n// vec3 spotLightDir \t\t\t= normalize(vec3(0.0f,0.0f,-1.f)); // front\nvec3 spotLightDir \t\t\t= normalize(vec3(-0.75f,-0.15f,-1.f));\nvec3 spotLightColor\t\t\t= vec3(0.7f);\nvec3 ambientColor \t\t\t= vec3(0.3f);\nfloat camerafov \t\t\t= 45.f;\nfloat scatteringProbability = 1.f;\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nbool anyHit_sphere(vec3 rayEye, vec3 rayDir, vec4 sphere) {\n    vec3 a = sphere.xyz - rayEye;\n    float a1 = dot(a, rayDir);\n    vec3 a2 = a - a1 * rayDir;\n    float distSq = dot(a2,a2);\n    float rSq = sphere.w*sphere.w;\n    if (distSq < rSq) {\n        float cSq = rSq - distSq;\n        float t = a1 - sqrt(cSq);\n        return t >= -0.01f;\n    } else\n        return false;\n}\n\nbool closestHit_sphere(vec3 rayEye, vec3 rayDir, vec4 sphere, out vec3 hit, out vec3 normal) {\n    vec3 a = sphere.xyz - rayEye;\n    float a1 = dot(a, rayDir);\n    vec3 a2 = a - a1 * rayDir;\n    float distSq = dot(a2,a2);\n    float rSq = sphere.w*sphere.w;\n    if (distSq < rSq) {\n        float cSq = rSq - distSq;\n        float t = a1 - sqrt(cSq);\n        hit = rayEye + rayDir * t;\n        normal = normalize(vec3(hit-sphere.xyz));\n        return true;\n    } else\n        return false;\n}\n\nbool closestHit_plane(vec3 rayEye, vec3 rayDir, vec4 plane, out vec3 hit, out vec3 normal) {\n\tvec3 p0 = plane.xyz * plane.w;\n    vec3 n = -plane.xyz;\n    float d = dot(p0-rayEye,n)/dot(rayDir, n);\n    hit = rayEye + rayDir * d;\n    normal = n;\n    return true;\n}\n\nfloat saturate(float x) { return clamp(x, 0.f, 1.f); }\n\nbool inLightFoV(vec3 Ln, vec3 spotLightDir, float cosHalfAngle) {\n    // return true;\n    return dot(Ln, -spotLightDir) > cosHalfAngle;\n}\n\nvec2 lightUV(vec3 Ln, float fov, vec3 lightLookVector, vec3 lightUpVector, vec3 lightRightVector) {\n    float x = dot(Ln, lightRightVector);\n    float y = dot(Ln, lightUpVector);\n    float d = -1. / dot(Ln, lightLookVector); // 'un-normalize Ln'\n    \n    float q = 1. / (2. * tan(fov));\n    \n    float u = d * x * q + 0.5;\n    float v = d * y * q + 0.5;\n\n    return vec2(u, v);\n}\n\nvoid shading(vec3 Nn, vec3 Ln, vec3 lightColor, inout vec3 result) {\n \t// Diffuse (lambertian) reflectance\n\tfloat dotNL = saturate(dot(Nn, Ln));\n\tvec3 diffuse = dotNL * lightColor;\n    result += diffuse;\n}\n\n// Fast inverse for affine matrix:\nmat4 affineInverse(mat4 m) {\n\tmat3 rot;\n\trot[0] = m[0].xyz;\n\trot[1] = m[1].xyz;\n\trot[2] = m[2].xyz;\n\n\tmat3 invRot = transpose(rot);\n\n\tmat4 result;\n\tresult[0] = vec4(invRot[0], 0);\n\tresult[1] = vec4(invRot[1], 0);\n\tresult[2] = vec4(invRot[2], 0);\n\tresult[3] = vec4(-(invRot * m[3].xyz), 1);\n\treturn result;\n}\n\nvoid SolveQuadratic(float a, float b, float c, out float minT, out float maxT)\n{\n\tfloat discriminant = b*b - 4.0*a*c;\n\n\tif (discriminant < 0.0)\n\t{\n\t\t// no real solutions so return a degenerate result\n\t\tmaxT = 0.0;\n\t\tminT = 0.0;\n\t\treturn;\n\t}\n\n\t// numerical receipes 5.6 (this method ensures numerical accuracy is preserved)\n\tfloat t = -0.5 * (b + sign(b)*sqrt(discriminant));\n\tfloat closestT = t / a;\n\tfloat furthestT = c / t;\n\n\tif (closestT > furthestT)\n\t{\n\t\tminT = furthestT;\n\t\tmaxT = closestT;\n\t}\n\telse\n\t{\n\t\tminT = closestT;\n\t\tmaxT = furthestT;\n\t}\n}\n\nvoid IntersectCone(vec3 rayOrigin, vec3 rayDir, mat4 invConeTransform, float tanAperture, float height, out float minT, out float maxT)\n{\n\tvec4 localOrigin = invConeTransform * vec4(rayOrigin, 1.0);\n\tvec4 localDir = invConeTransform * vec4(rayDir, 0.0);\n\n\tfloat tanTheta = tanAperture * tanAperture;\n\n\tfloat a = localDir.x*localDir.x + localDir.z*localDir.z - localDir.y*localDir.y*tanTheta;\n\tfloat b = 2.0*(localOrigin.x*localDir.x + localOrigin.z*localDir.z - localOrigin.y*localDir.y*tanTheta);\n\tfloat c = localOrigin.x*localOrigin.x + localOrigin.z*localOrigin.z - localOrigin.y*localOrigin.y*tanTheta;\n\n\tSolveQuadratic(a, b, c, minT, maxT);\n\n\tfloat y1 = localOrigin.y + localDir.y*minT;\n\tfloat y2 = localOrigin.y + localDir.y*maxT;\n\n\tif (y1 > 0.0 && y2 > 0.0)\n\t{\n\t\t// both intersections are in the reflected cone so return degenerate value\n\t\tminT = 0.0;\n\t\tmaxT = -1.0;\n\t}\n\telse if (y1 > 0.0 && y2 < 0.0)\n\t{\n\t\t// closest t on the wrong side, furthest on the right side => ray enters volume but doesn't leave it (so set maxT arbitrarily large)\n\t\tminT = maxT;\n\t\tmaxT = 10000.0;\n\t}\n\telse if (y1 < 0.0 && y2 > 0.0)\n\t{\n\t\t// closest t on the right side, largest on the wrong side => ray starts in volume and exits once\n\t\tmaxT = minT;\n\t\tminT = 0.0;\n\t}\n}\n\nfloat InScatter(vec3 start, vec3 dir, vec3 lightPos, float d, vec3 attenuation)\n{\n\t// calculate quadratic coefficients a,b,c\n\tvec3 q = start - lightPos;\n\n\tfloat b = dot(dir, q);\n\tfloat c = dot(q, q);\n\n\t// evaluate integral\n\tfloat s = 1.0f / sqrt(c - b*b);\n\n\tfloat l = s * (atan((d + b) * s) - atan(b*s));\n\n    // attenuation:\n\t//float lightDist = length(q);\n\t//l = l * saturate(1.0 / dot(vec3(1, sqrt(lightDist), lightDist), attenuation));\n\treturn l;\n}\n\nvec4 get_image(vec2 uv) {\n    uv = 2.0 * (uv - 0.5);\n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < 100; i++) {\n        vec2 nuv = uv;\n        float n = float(i) * 0.1 + iTime * 100.0;\n        nuv.x += sin(n*(0.8 + sin(iTime / 200.0) * 0.1))*0.5;\n        nuv.y += cos(n*(0.5 + sin(iTime / 100.0) * 0.1))*0.5;\n    \tcol += vec3(smoothstep(0.05,0.0,length(nuv)));\n\t}\n    return vec4(col.x,0.0,0.0,1.0);\n\t//return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = rayDirection(camerafov, iResolution.xy, fragCoord.xy);\n\n    float spotLightHalfAngle = 25.0f + sin(iTime) * 10.0f;\n    // float spotLightHalfAngle = 35.0f;\n    if (iMouse.z > 0.5f)\n     \t// spotLightDir = normalize(vec3(-normalize(iMouse.xy - iResolution.xy / 2.f), -1.f));\n        spotLightDir = normalize(vec3(sin(6.28*iMouse.x/iResolution.x), cos(3.14*iMouse.y/iResolution.y), cos(6.28*iMouse.x/iResolution.x)));\n    vec3 spotLightOrigin \t= (sphere.xyz - spotLightDir) * 1.4;\n    vec3 lightUp = normalize(cross(spotLightDir, vec3(1,0,0)));\n    vec3 lightRight = cross(spotLightDir, lightUp);\n    float spotfov = radians(spotLightHalfAngle);\n    float cosSpotHalfAngle = cos(spotfov);\n\n    vec3 result = vec3(0.f);\n\n    // lit sphere:\n    vec3 hitPos, hitNormal;\n    float hitDist = 1e5;\n    if (closestHit_sphere(eye, rayDir, sphere, hitPos, hitNormal)) {\n    // if (closestHit_plane(eye, rayDir, vec4(0,0,-1, 0), hitPos, hitNormal)) {\n        hitDist = length(hitPos-eye); // used for cone\n        \n        // for each spotlight:\n        vec3 Ln = normalize(spotLightOrigin-hitPos);\n        if (inLightFoV(Ln, spotLightDir, cosSpotHalfAngle)) {\n            // gobo:\n            vec2 goboUV = lightUV(Ln, spotfov, spotLightDir, lightUp, lightRight);\n            vec4 goboColor = get_image(goboUV);\n            \n        \tshading(hitNormal, Ln, goboColor.xyz * goboColor.a * spotLightColor, result);\n        }\n        \n        shading(hitNormal, normalize(vec3(0.f,0.f,1.f)), ambientColor, result); // directional light\n    } else {\n        // checkerboard background\n        int ix = int(fragCoord.x);\n        int iy = int(fragCoord.y);\n        \n        result = (ix / 16) % 2 == 0 ^^ (iy / 16) % 2 == 0 ? vec3(0.1f) : vec3(0.15f);\n    }\n    \n    // volumetric fog:\n\tfloat height = 30.0;\n\tfloat minT = 0.0;\n\tfloat maxT = 0.0;\n\n\tmat4 LightToWorld;\n\tLightToWorld[0] = vec4(lightRight, 0.0);\n\tLightToWorld[1] = vec4(-spotLightDir, 0.0); // change of basis from XYZ to X-ZY to rotate forward facing cone downward\n\tLightToWorld[2] = vec4(lightUp, 0.0);\n\tLightToWorld[3] = vec4(spotLightOrigin, 1);\n\t\t\t\n\tmat4 invLightToWorld = affineInverse(LightToWorld);\n\n\tfloat tanSpotAngle = tan(radians(spotLightHalfAngle));\n\n\tIntersectCone(eye, rayDir, invLightToWorld, tanSpotAngle, height, minT, maxT);\n\n\tminT = max(minT, 0.f);\n\tmaxT = min(maxT, hitDist);\n\tfloat dt = max(0.0, maxT - minT);\n\n    // analytic fog integral:\n\tvec3 scatter = spotLightColor * /* vec3(0.2, 0.5, 0.8) * */\n        max(0.f, InScatter(eye + rayDir*minT, rayDir,spotLightOrigin, dt, vec3(1,1,1))) \n        * scatteringProbability * 0.5;\n    \n    // ray marched gobo fog:\n    vec3 coneGoboColor = vec3(0.f);\n    for (int i = 0; i < 16; ++i) {\n    \tfloat t = mix(minT, maxT, float(i) / float(16-1));\n        vec3 p = eye + rayDir*t; // point in volume\n        vec3 Ln = normalize(spotLightOrigin-p);\n        // shadow ray:\n        if (!anyHit_sphere(p, Ln, sphere)) \n        {\n        \tvec2 goboUV = lightUV(Ln, spotfov, spotLightDir, lightUp, lightRight);\n        \tvec4 goboColor = get_image(goboUV);\n        \tconeGoboColor += goboColor.xyz * goboColor.a * spotLightColor;\n        }\n    }\n    coneGoboColor /= 16.f;\n\n\tresult += scatter * coneGoboColor;\n    \n    fragColor = vec4(result, 1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfcWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 395, 460, 460, 592], [594, 594, 653, 653, 970], [972, 972, 1066, 1066, 1461], [1463, 1463, 1555, 1555, 1725], [1727, 1727, 1752, 1752, 1781], [1783, 1783, 1848, 1868, 1920], [1922, 1922, 2021, 2021, 2301], [2303, 2303, 2371, 2409, 2508], [2510, 2545, 2573, 2573, 2852], [2854, 2854, 2934, 2934, 3405], [3407, 3407, 3544, 3544, 4657], [4659, 4659, 4740, 4783, 5111], [5113, 5113, 5138, 5138, 5556]], "test": "untested"}
{"id": "ttlyWB", "name": "Timeless depths", "author": "kesson", "description": "A timeless depths, constantly mutating over time.\n\nA raymarch experiment based on the tutorial by The Art Of Code: https://www.youtube.com/watch?v=-adHIyjIYgk", "tags": ["procedural", "3d", "raymarching", "rays", "marching", "generative", "depth", "gyroids", "cineshader"], "likes": 18, "viewed": 27422, "published": 3, "date": "1593015823", "time_retrieved": "2024-07-30T20:59:21.764447", "image_code": "// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n// Thanks to https://www.youtube.com/watch?v=-adHIyjIYgk\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define SURF_DIST .001\n#define GYROID_DETAILS 12\n#define WIDEANGLE 0 // set this to 1 for a wide angle pseudo-distortion\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float s, float t, float b) {\n    vec3 st = p * s;\n    \n    float lx = 1.0 + ((sin(iTime * 0.0576) * 0.5) + 0.5) * 0.25;    \n    float ly = 1.0 + ((cos(iTime * 0.0565) * 0.5) + 0.5) * 0.25;\n    \n    float ls = max(lx, ly);\n    \n    return abs(dot(sin(st * lx), cos(st.zxy * ly)) - b) / (s * ls) - t;\n}\n\nvec3 transform(vec3 p) {\n    p.xy *= rotate(p.z * 0.1);\n    p.z += iTime * 0.1;\n    p.y -= 0.3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    p = transform(p);\n        \n    float s = 10.798;\n    float t = 0.03;\n    float b = 0.3;\n    float m = 0.5;\n    \n    float s1 = 1.345 + ((sin(iTime* 0.01) * 0.5) + 0.5);\n    float g1 = sdGyroid(p, s1, 0.03, 1.5);\n    \n    for (int i = 0; i < GYROID_DETAILS; i++) {\n        if (i <= 1) g1 -= sdGyroid(p, s, t, b) * m;\n        else g1 += sdGyroid(p, s, t, b) * m;\n        s *= 1.75;\n        m *= 0.75;\n    }\n    \n    float d = g1 * 0.7;\n   \t\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 bg(vec3 rd) {\n\tvec3 col = vec3(0.0);\n    float t = iTime * 0.2;\n    \n    float y = clamp(smoothstep(0.3, 1.0, rd.y * 0.5 + 0.5), 0.1, 1.0);\n    col += y * vec3(0.05, 0.18, 0.38) * 6.0;\n    \n    float a = atan(rd.x, rd.z);\n    float flares = 0.7 * sin(a*20.+t)*sin(a*2.-t)*sin(a*6.);\n    flares *= smoothstep(.0, 1.0, y);\n    col += flares;\n    col = max(col, 0.);    \n    return col;\n}\n\nvec3 getDiff(vec3 p, vec3 rd) {\n    vec3 n = GetNormal(p);\n    return reflect(rd, n);\n}\n\n// Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\nvoid camera(float cd, vec2 uv, float an, out vec3 ro, out vec3 rd) {\n    ro = vec3( cd*cos(an), cd * sin(an), cd*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    if (WIDEANGLE == 1) {\n    \tuv += sin(uv*2.0); // wideangle distortion\n    }\n            \n    vec3 col = vec3(0.0);\n    \n    float t = iTime * 0.01;\n    \n    uv += sin(uv*20.+t)*.01;\n    \n    float an = -iTime * 0.05;\n    \n    vec3 ro, rd;\n    float cd = 0.01; // camera distance\n    camera(cd, uv, an, ro, rd); // get the camera\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 dr = getDiff(p, rd);\n    \tcol = texture(iChannel0, dr).xyz;\n        \n        p = transform(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(0.0,0.0,1.0)))*.5+.5;\n        col *= dif;\n    \tcol += dif;\n        \n        float b = sdGyroid(p, 10.798, 0.03, 0.3);\n        col *= smoothstep(-0.05, 0.1, b);\n        \n        float cw = -0.02 + smoothstep(0.0, -0.5, n.y) * 0.02;\n        float c = smoothstep(cw, -0.03, b);\n        float cc = 1.0 - (sdGyroid(p+t, 6.789, 0.03, 0.3) * 4.0);\n        float cc2 = 1.0 - (sdGyroid(p-t*0.5, 3.789, 0.03, 0.3) * 2.0);\n        col += c * vec3(0.1, 0.4, 1.0) * cc * cc2 * 3.0;\n    }\n    \n    col = mix(col, bg(rd), smoothstep(0.0, MAX_DIST, d));\n    \n    fragColor = vec4(col,d / 3.0);\n}", "buffer_a_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//  Blur  effect\n//  Edited  from  https://www.shadertoy.com/view/XdfGDH\n\nfloat  normpdf(in float  x,  in float  sigma)  {\n    return  0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2  uv = fragCoord / iResolution.xy;\n    \n    vec3  c = texture(iChannel0, uv).rgb;\n    \n    vec2  center = vec2(0.5, 0.5);\n    center = vec2(0.5, 0.5);\n\n    float  d = smoothstep(0.3, 1.0, 0.1 + distance(center, uv));\n\n    //  grain  effect\n    float  strength = 4.0;\n    float  x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime * 10.0);\n    vec3  grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n\n    const int  mSize = 11;\n    const int  kSize = (mSize - 1) / 2;\n    float  kernel[mSize];\n    vec3  final_colour = vec3(0.0);\n\n    //create  the  1-D  kernel\n    float  sigma = 0.001 + texture(iChannel0, uv).w * 4.0;//7.0;\n    float  Z = 0.0;\n    for (int  j = 0; j <= kSize; ++j) {\n        kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n    }\n\n    //get  the  normalization  factor  (as  the  gaussian  has  been  clamped)\n    for (int  j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read  out  the  texels\n    for (int  i = -kSize; i <= kSize; ++i) {\n        for(int  j = -kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize + j] * kernel[kSize + i] * texture(iChannel0, (gl_FragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n                }\n    }\n\n    vec3  c_step_1 = final_colour / (Z * Z);\n\n    float  nd = 1.0 - d;\n    vec3 c_step_2 = clamp(c_step_1 * nd, 0.0, 1.0);\n\n    // I don't like the image too clean\n    c_step_2 += grain * 1.0;\n\n    fragColor = vec4(c_step_2, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyWB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[210, 210, 266, 266, 378]], "test": "untested"}
{"id": "WtXcWj", "name": "Volumetric Distorted Sphere", "author": "Danguafer", "description": "A volumetric distorted sphere rotating and mutating.", "tags": ["distortion", "volumetric"], "likes": 34, "viewed": 947, "published": 3, "date": "1593015294", "time_retrieved": "2024-07-30T20:59:22.606197", "image_code": "const float PI = acos(-1.0);\n\n// _ _ _\n//  _ _ \n//\nfloat square(float x) { return sign(sin(x * PI)) * 0.5 + 0.5; }\n//\n// /_/_/\n//\nfloat ramps(float x) { return mod(x,1.0)*square(x); }\n// \n// S_S_S\n//\nfloat smoothed_ramps(float x) { return smoothstep(0.0,1.0,ramps(x)); }\n//      \n//    __\n//  __\n// _\n//\nfloat steps(float x) { return floor(x / 2.0 + 0.5); }\n//\n//    _/\n//  _/\n// /\n//\nfloat ramps_step(float x) { return ramps(x) + steps(x); }\n//\n//    _S\n//  _S\n// S\n//\nfloat smoothed_ramps_step(float x) { return smoothed_ramps(x) + steps(x); }\n\nfloat sphere(vec3 o, float r) { return length(o) - r; }\n\nfloat cylinder(vec3 o, float r) { return length(o.xz) - r; }\n\nmat2 rotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nvec3 fetch(vec3 o) {\n    float deform = iTime / 0.35;\n    o.yz *= rotate(smoothed_ramps_step(iTime + 1.0) * PI / 4.0);\n    o.xy *= rotate(smoothed_ramps_step(iTime + 0.5) * PI / 4.0);\n    o.zx *= rotate(smoothed_ramps_step(iTime) * PI / 4.0);\n    o.z += 0.1 * sin(o.y * 10.0 + deform);\n    o.x += 0.1 * sin(o.z * 10.0 + deform);\n    o.y += 0.1 * sin(o.x * 10.0 + deform);\n    \n    float object = sphere(o, 0.5);\n    if (object < 0.0) {\n        vec3 color = vec3((sin(o.x * 10.0 + iTime) + 1.0) * 0.02 + 0.01,(sin(o.y * 10.0 + iTime) + 1.0) * 0.01 + 0.02,(sin(o.z * 10.0 + iTime) + 1.0) * 0.01 + 0.01);\n        color /= 4.0;\n        return color;\n    } else {\n\t \treturn vec3(0.0);\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 light = vec3(0.0);\n\n    vec3 o = vec3(0.0,0.0,-1.0);\n    vec3 d = normalize(vec3(p.xy, 2.0));\n    \n    float t = 0.0;\n    for (int i = 0; i < 200; i++) {\n        t += 0.01;\n        light += fetch(d * t + o);\n    }\n\n    fragColor = vec4(light,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXcWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 51, 74, 74, 114], [115, 130, 152, 152, 183], [184, 200, 231, 231, 270], [271, 304, 326, 326, 357], [358, 385, 412, 412, 442], [443, 470, 506, 506, 545], [547, 547, 578, 578, 602], [604, 604, 637, 637, 664], [666, 666, 688, 688, 733], [735, 735, 755, 755, 1422], [1425, 1425, 1480, 1480, 1807]], "test": "untested"}
{"id": "tlsyWB", "name": "Red Noisy volume, Dark inside", "author": "Leria", "description": "Test for future shader", "tags": ["noise", "sphere", "red", "dark", "bolume"], "likes": 4, "viewed": 353, "published": 3, "date": "1593000242", "time_retrieved": "2024-07-30T20:59:23.366164", "image_code": "#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct BlackHole\n{\n    vec3 pos; //position\n    vec3 disk_normal;\n    float mass; //blackhole mass\n    float attraction_radius; //attraction radius of the blackhole\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nBlackHole bh;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\n//iq noise\n/*\n\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n*/\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nfloat fbm( vec3 p ) { // in [-1,1]\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.;\n    f += 0.2500*noise( p ); p = p*2.;\n    f += 0.1250*noise( p ); p = p*2.;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tbh = BlackHole(pos, J, mass, radius, inner_rad, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\n//gravity stuff\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 bh_vec = bh.pos - p;\n    float d = dot(bh_vec,bh_vec);\n    vec3 res = normalize(bh_vec) * (GRAV_CONST*bh.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n\nvoid init_black_hole(void)\n{\n \tset_black_hole(vec3(0., 0., 0.), .12, RADIUS, RADIUS/8., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_black_hole();\n    set_camera(vec3(0., 0., 12), bh.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n/*note:\n\n               if(sdf_cylinder(p-bh.pos, vec3(0., 0., -1.), vec3(0., 0., 1.), \n                        RADIUS) < 0.)\n        {\n            vec4 tex = texture(iChannel0, p/16.+0.05*iTime);\n           \n            t_loc = clamp(   smoothstep(-.5,.5,tex.r)\n                            - smoothstep(2.,.5,length(p)-RADIUS/2.+8.*((2.*fbm(p/8.)-1.))) , 0.,1.);\n            t_gen *= t_loc;\n        }  \n\n*/\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    vec3 c_tmp = vec3(0);\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //p = ( vec4(p, 1.)*ROT(vec3(0., 1., 0.), degree) * cam.view).xyz;\n\n    float perturbation = fbm(p);\n  \tfloat dens = perturbation;\n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    \n    int s = 0;\n    \n    for(s; s < 150; s++)\n    {       \n        //p = (vec4(p, 1.)*vec4(ROT(vec3(0., 1., 0.), degree) * cam.view).xyz;\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(bh.pos-cam.pos);\n        vec3 center = p-bh.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5;\n\n        if(d > -.5)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }\n        \n        float anim_coef = 1.5*cos(0.);\n        //center = (vec4( center, 1.) * ROT(vec3(0., 1., 0.), degree) ).xyz*(vec4( center, 1.) * ROT(vec3(1., 0., 0.), degree2) * cam.view ).xyz ;\n\t\t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            float anim_coef = 1.5*cos(iTime);\n            \n            #if COLOR           \n            float n = ( abs(fbm(p/8.*anim_coef)));\n            float mask = smoothstep(.2, \n                                     2.*RADIUS+anim_coef, \n                                     (RADIUS-length(center))- 128.*n) ;\n            \n            /*\n\t\n\t\t\t//Avec Bnoise()\n\n            float n = ( (fbm(p/8.*anim_coef)));\n            float mask = smoothstep(.2, \n                                     3.*RADIUS+anim_coef, \n                                     (RADIUS-length(p))- 64.*n) ;\n*/\n            \n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            vec3 rgb_t = vec3(transp(uniform_step, 4.,  dens), \n                      \ttransp(uniform_step, 16.,dens ),\n              \t      \ttransp(uniform_step, 16., dens));  \n            t_acc *= rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+bh.accretion_disk_radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = t_acc;\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    bh.pos = normalize(vec3(-10, 20., bh.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1299, 1299, 1356, 1356, 1525], [1528, 1528, 1554, 1554, 2379], [2436, 2436, 2457, 2470, 2641], [2643, 2662, 2738, 2738, 2785], [2787, 2787, 2819, 2819, 2839], [2841, 2841, 2875, 2875, 2897], [2998, 2998, 3022, 3022, 3182], [3184, 3184, 3208, 3208, 3293], [3295, 3324, 3352, 3352, 3522], [3524, 3546, 3592, 3592, 4215], [4265, 4265, 4306, 4306, 4342], [4344, 4344, 4485, 4485, 4548], [4550, 4550, 4593, 4593, 4633], [4635, 4651, 4712, 4712, 4912], [4914, 4914, 4942, 4942, 5012], [5014, 5014, 5054, 5054, 5358], [5360, 5360, 5384, 5384, 5452], [5454, 5454, 5501, 5501, 5553], [5555, 5555, 5638, 5638, 5777], [5780, 5780, 5833, 5833, 6190], [6601, 6601, 6653, 6653, 9522], [9525, 9525, 9582, 9582, 10192]], "test": "untested"}
{"id": "3tfcRS", "name": "Liquid in glass", "author": "tmst", "description": "- The glass container can be any SDF (see sdfContainer in Buf A)\n- Drag the container around to \"slosh\" the liquid\n- Inputs: Mouse, ASDF (No opacity, no refraction, steps, normal)", "tags": ["sdf", "refraction", "water", "glass", "liquid", "pendulum", "potion"], "likes": 148, "viewed": 4200, "published": 3, "date": "1592981748", "time_retrieved": "2024-07-30T20:59:24.342553", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = textureLod(iChannel0, uv, 0.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define LAST_FRAME iChannel0\n#define SKYBOX(v) texture(iChannel1, v).rgb\n#define KEY_SAMPLER iChannel2\n\n// ===============================\n// Generic Helpers/Constants\n// ===============================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define SQRT2INV 0.7071067811865475\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\n// https://www.shadertoy.com/view/lsXGzf (iq: \"Input - Keyboard\")\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n\n// Same as built-in 'refract' (cf. link) but replaces the case which would\n// normally result in 0 with a reflection (for total internal reflection)\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\nvec3 refractFix(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    return k < 0.0\n        ? reflect(I, N) // <- 'refract' returns 0 here\n    \t: eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\n// ===============================\n// Quaternion helpers\n// (Unit quaternions: w+xi+yj+zk)\n// ===============================\n\n#define QID vec4(0.0, 0.0, 0.0, 1.0)\n\nvec4 slerp(vec4 a, vec4 b, float t) {\n    float d = dot(a, b);\n    vec4 a2 = a;\n\n    if (d < 0.0) {\n        d = -d;\n        a2 = -a;\n    }\n    if (d > 0.999) {\n        return normalize(mix(a2, b, t));\n    }\n\n    float theta = acos(d);\n    return (sin((1.-t)*theta)*a2 + sin(t*theta)*b) / sin(theta);\n}\n\nvec4 qMul(vec4 a, vec4 b) {\n    return vec4(\n        a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,\n        a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,\n        a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,\n        a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z\n    );\n}\n\nvec4 qConj(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qRot(vec3 nvAxis, float angle) {\n    return vec4(nvAxis*sin(angle*0.5), cos(angle*0.5));\n}\n\nmat3 qToMat(vec4 q) {\n    float wx = q.w*q.x, wy = q.w*q.y, wz = q.w*q.z;\n    float xx = q.x*q.x, xy = q.x*q.y, xz = q.x*q.z;\n    float yy = q.y*q.y, yz = q.y*q.z, zz = q.z*q.z;\n    return mat3(\n        1. - 2.*(yy + zz),\n             2.*(xy + wz),\n             2.*(xz - wy),\n\n             2.*(xy - wz),\n        1. - 2.*(xx + zz),\n             2.*(yz + wx),\n\n             2.*(xz + wy),\n             2.*(yz - wx),\n        1. - 2.*(xx + yy)\n    );\n}\n\n// ===============================\n// Reading/writing state\n// ===============================\n\nstruct state {\n    vec3 p; // Pendulum pivot\n    vec3 q; // Accelerate p toward this point\n    vec3 v; // Pendulum \"bob\" (relative to pivot)\n    vec3 L; // Angular momentum\n    vec4 pr; // Object rotation (unit quaternion)\n};\n\nstate readState() {\n    state s = state(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0, -cos(0.25*PI), sin(0.25*PI)),\n        vec3(0.0, 0.5, 0.0),\n        QID\n    );\n    if (iFrame > 0) {\n        s.p = texelFetch(LAST_FRAME, ivec2(0, 0), 0).xyz;\n        s.q = texelFetch(LAST_FRAME, ivec2(1, 0), 0).xyz;\n        s.v = texelFetch(LAST_FRAME, ivec2(2, 0), 0).xyz;\n        s.L = texelFetch(LAST_FRAME, ivec2(3, 0), 0).xyz;\n        s.pr = texelFetch(LAST_FRAME, ivec2(4, 0), 0);\n    }\n    return s;\n}\n\nvoid writeState(in state s, in vec2 fragCoord, inout vec4 fragColor) {\n    if (abs(fragCoord.y - 0.0-0.5) < 0.5) {\n        if (abs(fragCoord.x - 0.0-0.5) < 0.5) {\n            fragColor = vec4(s.p, 1.0);\n        } else if (abs(fragCoord.x - 1.0-0.5) < 0.5) {\n            fragColor = vec4(s.q, 1.0);\n        } else if (abs(fragCoord.x - 2.0-0.5) < 0.5) {\n            fragColor = vec4(s.v, 1.0);\n        } else if (abs(fragCoord.x - 3.0-0.5) < 0.5) {\n            fragColor = vec4(s.L, 1.0);\n        } else if (abs(fragCoord.x - 4.0-0.5) < 0.5) {\n            fragColor = s.pr;\n        }\n    }\n}\n\n// ===============================\n// Camera setup\n// ===============================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip) {\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid getCamera(in state s, in vec2 uv, out vec3 camPos, out vec3 nvCamDir) {\n    vec2 mouseAng = vec2(HALFPI*0.75, PI*0.45) + 0.2*vec2(cos(0.5*iTime),sin(0.5*iTime));\n    camPos = vec3(0.0, 2.0, 0.0) + 5.0 * SPHERICAL(mouseAng.x, mouseAng.y);\n\n    vec3 lookTarget = mix(vec3(0.0), s.p, 0.05);\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n}\n\n// ===============================\n// Physics, reading/writing state\n// ===============================\n\nvoid updateState(inout state s) {\n\n    // p (object displacement) gets \"lerped\" towards q\n    if (iMouse.z > 0.5) {\n        vec2 uvMouse = iMouse.xy / iResolution.xy;\n        vec3 camPos;\n        vec3 nvCamDir;\n        getCamera(s, uvMouse, camPos, nvCamDir);\n\n        float t = -camPos.y/nvCamDir.y;\n        if (t > 0.0 && t < 50.0) {\n            vec3 center = vec3(0.0);\n            s.q = camPos + t*nvCamDir;\n            float qToCenter = distance(center, s.q);\n            if (qToCenter > 5.0) {\n                s.q = mix(center, s.q, 5.0/qToCenter);\n            }\n        }\n    }\n\n    // pr (object rotation unit quaternion) gets \"slerped\" towards qr\n    float tmod = mod(iTime+6.0, 9.0);\n    vec4 qr = (\n        tmod < 3.0 ? qRot(vec3( SQRT2INV, 0.0, SQRT2INV), 0.75*PI) :\n        tmod < 6.0 ? qRot(vec3(-SQRT2INV, 0.0, SQRT2INV), 0.5*PI) :\n        QID\n    );\n\n    // apply lerp p -> q and slerp pr -> qr\n    s.p += 0.25*(s.q - s.p);\n    s.pr = normalize(slerp(s.pr, qr, 0.075));\n\n    // object acceleration\n    vec3 a = -0.25*(s.q - s.p) + vec3(0.0, -1.0, 0.0);\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    a = prMatInv*a;\n\n    // hand-wavy torque and angular momentum\n    vec3 T = cross(s.v, a);\n    s.L = 0.96*s.L + 0.2*T;\n\n    // hand-wavy angular velocity applied from torque\n    vec3 w = s.L;\n    float ang = 0.25*length(w);\n    if (ang > 0.0001) {\n        mat3 m = qToMat(qRot(normalize(w), ang));\n        s.v = normalize(m*s.v);\n    }\n}\n\n// ===============================\n// Geometry definitions\n// ===============================\n\n#define BOUNDING_SPHERE_RADIUS 4.0\n#define GLASS_THICKNESS 0.25\n\nfloat sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    return dot(p - planePoint, nvPlaneN);\n}\n\nfloat sdfInterval(float a, float b, float x) {\n    return abs(x - 0.5*(a+b)) - 0.5*(b-a);\n}\n\n// From https://iquilezles.org/articles/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdfContainer(vec3 p, state s) {\n    vec3 d = abs(p - s.p);\n    vec3 d2 = d*d;\n    float sdBase = pow(dot(d2,d2), 0.25) - 2.0;\n\n    float sdInner = length(d.xz) - 0.6;\n\n    return opSmoothSubtraction(sdInner, sdBase, 0.5);\n}\n\nfloat sdfWater(vec3 p, state s) {\n    float dglass = sdfContainer(p, s);\n    float depth = -0.25; // Can add e.g. ripples to the surface here\n    float dsurf = sdfPlane(s.p + depth*s.v, -s.v, p);\n    return opSubtraction(opSmoothSubtraction(dsurf, dglass, 0.15), dglass);\n}\n\nfloat sdfGlass(vec3 p, state s) {\n    float etchDepth = 0.0; // Can sample from e.g. cubemap here for some texture\n    return sdfInterval(0.0, GLASS_THICKNESS - etchDepth, sdfContainer(p, s));\n}\n\n#define SDF_N_EPS 0.005\n#define SDF_NORMAL(sdfFn, p, s) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0), s ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0), s ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0), s ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0), s ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS), s ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS), s )  \\\n    ))\n\n// ===============================\n// Marching, lighting/materials\n// ===============================\n\n#define SDF_EPS 0.01\n#define DSTEP_ADJUST_EPS 0.02\n#define STEPS 80\n\n#define LIGHT_COLOR vec3(1.0)\n\n#define GLASS_COLOR vec3(0.01, 0.0, 0.4)\n#define GLASS_OPACITY 0.6\n#define WATER_COLOR vec3(1.0)\n#define WATER_OPACITY 0.15\n\n#define IR_AIR 1.0\n#define IR_GLASS 1.5\n#define IR_WATER 1.333\n\n// Enums\n#define SUBSTANCE_AIR 0\n#define SUBSTANCE_GLASS 1\n#define SUBSTANCE_WATER 2\n\nvec4 computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam\n){\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular*vec4(LIGHT_COLOR, 1.0);\n}\n\nvoid march(in state s, in vec3 pRay, in vec3 nvRayIn, out vec4 color, out vec3 nvRayOut)\n{\n    bool skipOpacity = texelFetch(KEY_SAMPLER, ivec2(KEY_A,0), 0).x > 0.5;\n    bool skipRefraction = texelFetch(KEY_SAMPLER, ivec2(KEY_S,0), 0).x > 0.5;\n    bool debugSteps = texelFetch(KEY_SAMPLER, ivec2(KEY_D,0), 0).x > 0.5;\n    bool debugNormal = texelFetch(KEY_SAMPLER, ivec2(KEY_F,0), 0).x > 0.5;\n\n    // Light (in world coordinates)\n    vec3 pLightO = pRay + vec3(0.0, 10.0, 0.0);\n\n    // Light and camera (in object coordinates)\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    vec3 pCam = prMatInv*(pRay - s.p) + s.p;\n    vec3 pLight = prMatInv*(pLightO - s.p) + s.p;\n\n    // Ray while marching (in object coordinates)\n    vec3 pCur = pCam;\n    vec3 nvRayCur = prMatInv*nvRayIn;\n\n    color = vec4(0.0);\n    int curSubstance = SUBSTANCE_AIR;\n\n    int i=0;\n    for (; i<STEPS; i++) {\n\n        // Quick exits\n        // ----------------\n        vec3 centerToCur = pCur - s.p;\n        if (\n            (length(centerToCur) > BOUNDING_SPHERE_RADIUS) &&\n            (dot(nvRayCur, centerToCur) > 0.0)\n        ) { break; }\n\n        if (color.a > 0.95) { break; }\n\t\t// ----------------\n\n        float sdGlass = sdfGlass(pCur, s);\n        float sdWater = sdfWater(pCur, s);\n        vec3 dpStep = abs(min(sdGlass, sdWater))*nvRayCur;\n\n        vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur, s);\n        vec3 nvWater = SDF_NORMAL(sdfWater, pCur, s);\n\n        if (curSubstance == SUBSTANCE_AIR) {\n\n            if (sdGlass < SDF_EPS && dot(nvGlass,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_GLASS;\n\n                vec4 sColor = computeSpecular(\n                    0.8, 80.0, nvGlass, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                // Schlick approximation\n                float cosHitAngle = clamp(dot(nvGlass, -nvRayCur), 0.0, 1.0);\n                float r0 = pow((IR_GLASS-IR_AIR)/(IR_GLASS+IR_AIR), 2.0);\n                float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 3.0)); // Modified exponent 5 -> 3\n\n                vec3 nvRefl = reflect(nvRayCur, nvGlass);\n                color = blendOnto(color, valRefl*vec4(SKYBOX(nvRefl), 1.0));\n\n                dpStep = sdGlass*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlass;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvGlass, IR_AIR/IR_GLASS);\n                }\n\n            } else if (sdWater < SDF_EPS && dot(nvWater,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_WATER;\n\n                vec4 sColor = computeSpecular(\n                    1.0, 40.0, nvWater, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                // Schlick approximation\n                float cosHitAngle = clamp(dot(nvWater, -nvRayCur), 0.0, 1.0);\n                float r0 = pow((IR_WATER-IR_AIR)/(IR_WATER+IR_AIR), 2.0);\n                float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 5.0));\n\n                vec3 nvRefl = reflect(nvRayCur, nvWater);\n                color = blendOnto(color, valRefl*vec4(SKYBOX(nvRefl), 1.0));\n\n                dpStep = sdWater*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvWater;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvWater, IR_AIR/IR_WATER);\n                }\n\n            }\n\n        } else if (curSubstance == SUBSTANCE_GLASS) {\n\n            float sdGlassInv = -sdGlass;\n            vec3 nvGlassInv = -nvGlass;\n\n            dpStep = abs(sdGlassInv)*nvRayCur;\n\n            if (!skipOpacity) {\n                color = blendOnto(color, clamp(GLASS_OPACITY*sdGlassInv,0.0,1.0)*vec4(GLASS_COLOR, 1.0));\n            }\n\n            if (sdGlassInv < SDF_EPS && dot(nvGlassInv,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdGlassInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlassInv;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvGlassInv, IR_GLASS/IR_AIR);\n                }\n\n            }\n\n        } else if (curSubstance == SUBSTANCE_WATER) {\n\n            float sdWaterInv = -sdWater;\n            vec3 nvWaterInv = -nvWater;\n\n            dpStep = abs(sdWaterInv)*nvRayCur;\n\n            if (!skipOpacity) {\n                color = blendOnto(color, clamp(WATER_OPACITY*sdWaterInv,0.0,1.0)*vec4(WATER_COLOR, 1.0));\n            }\n\n            if (sdWaterInv < SDF_EPS && dot(nvWaterInv,nvRayCur) < 0.0) {\n\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdWaterInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvWaterInv;\n                if (!skipRefraction) {\n                    nvRayCur = refractFix(nvRayCur, nvWaterInv, IR_WATER/IR_AIR);\n                }\n\n            }\n\n        }\n\n        pCur += dpStep;\n\n    }\n\n    // Convert ray direction from object to world coordinates\n    nvRayOut = qToMat(s.pr)*nvRayCur;\n\n    if (debugSteps) {\n        color = vec4( vec3(float(i)/float(STEPS)), 1.0 );\n    } else if (debugNormal) {\n        color = vec4( 0.5 + 0.5*nvRayOut, 1.0 );\n    }\n}\n\n// ===============================\n// Main render\n// ===============================\n\nvec4 mainColor(vec2 fragCoord, state s) {\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord / RES.xy;\n    getCamera(s, uv, camPos, nvCamDir);\n\n    vec4 color;\n    vec3 nvRayOut;\n    march(s, camPos, nvCamDir, color, nvRayOut);\n\n    return blendOnto(color, SKYBOX(nvRayOut));\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    state s = readState();\n\n    fragColor = mainColor(fragCoord, s);\n\n    updateState(s);\n    writeState(s, fragCoord, fragColor);\n}\n", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 147]], "test": "untested"}
{"id": "WtlyWS", "name": "Burning Ship fractal", "author": "lukeathedev", "description": "Very similar to the mandelbrot fractal. Would be a cool prog metal band album cover lol", "tags": ["fractal", "maths"], "likes": 1, "viewed": 112, "published": 3, "date": "1592961925", "time_retrieved": "2024-07-30T20:59:25.094543", "image_code": "// fractais sao legais\n// by lucas\n\n// These are complex number helper functions\n\nvec2\ncmul(vec2 c0, vec2 c1)\n{\n    return vec2(c0.x * c1.x - c0.y * c1.y, c0.x * c1.y + c0.y * c1.x);\n}\n\nfloat\ncabs(vec2 c)\n{\n    return c.x * c.x + c.y * c.y;\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// This is the burning ship fractal\n// https://en.wikipedia.org/wiki/Burning_Ship_fractal\n\nfloat\nfractal(vec2 c, int range)\n{   \n    int i;\n    vec2 z = vec2(0.0);\n    for (i = 0; i < range; ++i)\n    {\n        z = vec2(abs(z.x), abs(z.y));\n        z = cmul(z, z) - c;\n        if (cabs(z) > 4.0) break;\n    }\n    \n    return float(i) / float(range);\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Get offset variable from texture map\n    float scale = 2.5 / pow(1.5, iTime);\n    if (scale < 0.05) scale = 0.05;\n    vec2 offset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    \n    // Calculate pixel color value based on fractal function\n    float pixel = fractal(xy * scale + offset, 75);\n    if (pixel == 1.0) pixel = 0.0;\n    \n    vec3 col = hsv2rgb(vec3(sin(pixel + 0.6), 0.75, 1.0));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// I'll implement mouse panning eventually\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 0,0 offset; 1,0 mouseDown (bool)\n\n    if (ivec2(fragCoord) == ivec2(0, 0))\n    {\n        fragColor = vec4(1.76, 0.0375, 0.0, 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 111, 111, 184], [186, 186, 206, 206, 242], [244, 323, 345, 345, 514], [607, 607, 641, 641, 866], [868, 868, 923, 952, 1460]], "test": "untested"}
{"id": "wsyGRD", "name": "radius wave", "author": "ich", "description": "2d circles change their radius resulting in a fancy wavy pattern\none of my first creations inspired by the ray marching expert 'the art of code' ", "tags": ["2dcircle"], "likes": 4, "viewed": 319, "published": 3, "date": "1592957633", "time_retrieved": "2024-07-30T20:59:25.847530", "image_code": "#define psin(x) (.5+.5*sin(x))\n#define xor(a, b) (a+b-2.*a*b)\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - R*.5) / R.y;\n    float s = 15.;\n    uv *= s;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv) + .5;\n    vec3 col = vec3(0);\n    \n    float t = iTime;\n    float m = 0., n = 0.;\n    for (int i = 0; i < 25; ++i) {\n        vec2 o = vec2(i%5, i/5)-2.;\n        float l = length(id - o) - t;\n        float r = psin(l * .4)\n            + .5 * psin(l * .294)\n            + .3 * psin(l * .87)\n            + .2;\n        n = xor(n, smoothstep(r, r - 2.*s/R.y, length(gv + o)));\n        m += smoothstep(r, r - 2.*s/R.y, length(gv + o));\n        //m = length(uv);\n    }\n    col += hsv2rgb(vec3(fract(m*0.05), 1., n));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 85, 85, 254], [256, 256, 313, 313, 1019]], "test": "untested"}
{"id": "wlfyWB", "name": "voronoise fire", "author": "ich", "description": "voronoise fire", "tags": ["voronoisewavefire"], "likes": 5, "viewed": 367, "published": 3, "date": "1592956690", "time_retrieved": "2024-07-30T20:59:26.748122", "image_code": "#define pi 3.141\n#define pi2 (pi*2.)\n\nfloat n21(vec2 uv) {\n\treturn fract(9876. * sin(dot(uv, vec2(987, 654))));\n}\n\n\nvec2 n22(vec2 uv) {\n\tfloat n = n21(uv);\n\treturn vec2(n, n21(vec2(n)));\n}\n\n\nfloat n11(float v) {\n\treturn n21(vec2(v));\n}\n\nvec2 cs(vec2 uv) {\n\treturn vec2(cos(uv.x), sin(uv.y));\n}\n\nmat2 rot(float a) {\n\treturn mat2(\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t);\n}\n\nvec2 voronoi(vec2 uv, float intens) {\n\tvec2 out_id;\n\tfloat lo = 100.;\n\tfloat r = 1.;\n\tfor (float x = -r; x <= r; ++x) {\n\t\tfor (float y = -r; y <= r; ++y) {\n\t\t\tvec2 o = vec2(x, y);\n\t\t\tvec2 id = floor(uv + o) + .1;\n\t\t\tvec2 lv = fract(uv) - o - .5;\n\t\t\tvec2 t = n22(id) * iTime;\n\t\t\tlv += vec2(1, .6) * cs(t) * .5 * intens;\n            lv += (n22(uv) * .4 - .2) * intens;\n            //lv += cs(t + pi2*sin(uv.x*5.)) * .5 * intens;\n\t\t\tfloat l = length(lv);\n\t\t\tif (l < lo) {\n\t\t\t\tlo = l;\n\t\t\t\tout_id = id;\n\t\t\t}\n\t\t}\n\t}\n\treturn out_id;\n}\n\nfloat tri(float v) {\n\treturn abs(mod(v, 2.) - 1.);\n}\n\nfloat flower(vec2 uv) {\n\tfloat t = 3.+floor(3. * tri(iTime * .1));\n\tuv.x += sin(iTime * .2) * pow(max(0., uv.y + .3), 5.) * 5.;\n\tuv = rot(iTime * .1) * uv;\n\treturn length(uv) * sin(atan(uv.y, uv.x) * 3.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n\tvec3 c = vec3(0);\n\n    // mouse controls\n\tuv -= m * .3;\n    \n    // voronoi\n    float s = smoothstep(-2., 1., flower(uv));\n\tvec2 id = voronoi(uv * 20., s) / 20.;\n    \n    // coloring\n\tc.r += n21(id) * .5 + .5;\n    float l = flower(id);\n\tc.rg += vec2(1, .5) * l;\n\tc *= smoothstep(-2., 1., l);\n \n    // sparks\n    float r = n21(id);\n    float sparks = pow(abs(sin(r * 1234. + iTime * 1.)), 10.);\n    c.rg *= sparks * vec2(.5, 1.) * max(0., l) + 1.;\n    c.b += .3 * c.g * sparks;\n\n    fragColor = vec4(c, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 113], [116, 116, 135, 135, 188], [191, 191, 211, 211, 235], [237, 237, 255, 255, 293], [295, 295, 314, 314, 370], [372, 372, 409, 409, 899], [901, 901, 921, 921, 953], [955, 955, 978, 978, 1161], [1163, 1163, 1218, 1218, 1849]], "test": "untested"}
{"id": "wtfyWB", "name": "Day ilostcount will rename tmrw", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 4, "viewed": 272, "published": 3, "date": "1592946775", "time_retrieved": "2024-07-30T20:59:27.582890", "image_code": "//  2d slice of 4d lattice\n\n\n#define pi acos(-1.)\n#define pmod(p,j) mod(p - 0.5*j,j) - 0.5*j\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define tri(j) asin(sin(j))\n\n#define iTime (iTime + 6.)\n    \nfloat sdBox(vec4 p, vec4 sz){\n\tp = abs(p) - sz;\n\treturn max(p.x,max(p.y,max(p.z,p.w)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(3.,1.,0.1)/2000.; \n        \n    \n    uv *= 12.;\n    \n    vec4 p = vec4(uv,1,1);\n    \n    float md = sin(iTime);\n    \n    float t = tri(uv.x*1. + tri(uv.y + iTime*1.)*md + (iTime)/2. + md/4.  );\n    \n    \n    \n    p.xz *= rot(0.25*pi);\n    \n    \n    p.xy *= rot(0.25*pi );\n    \n    p.xw *= rot(0.125*pi);\n    \n    p.yw *= rot(0.25*pi);\n    \n    //p.yw *= rot(0.25*pi);\n    \n    \n    \n    p.xy += sin(iTime )/300. + t/5. + iTime/76.;\n    \n    \n    //p.y += tri(p.y + iTime)*1.3;\n    \n    \n    \n    p = pmod(p,1.);\n    \n\tfloat db;\n    \n    \n    db = sdBox(pmod(p*1.5,1.),vec4(0.1,0.3,0.3,0.5) );\n    \n    db = abs(db) - 0.05;\n    \n    //col = mix(col,vec3(4.15,1.9,0.6)*0.7,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    col = mix(col,vec3(1.15,0.6,0.9)*.15,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    \n    db = sdBox(p,vec4(0.3,0.3,0.3,0.5));\n    \n    //col = mix(col,vec3(1.15,1.05,0.2)*1.,smoothstep(dFdx(uv.x)*1.,0.,db));\n    col = mix(col,vec3(.25,.45,0.4)*2.1,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    \n    //col = mix(col,vec3(0.05,0.2,1.15)*0.2,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    \n    \n    \n    col /= 1. + col;\n    \n    col *= 1.5;\n    col = mix(col,smoothstep(0.,1.,col),0.8);\n    col = pow(col,vec3(0.45454));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 233, 233, 293], [295, 295, 352, 352, 1690]], "test": "untested"}
{"id": "ttXcDB", "name": "Virtual particle SPH - Boiling", "author": "michael0884", "description": "Everything is improved once more! Also now tracking the temperature!\nCellular automaton particle tracking used for advection in a fluid which is also fully conservative\nEach pixel has 1 virtual particle", "tags": ["particles", "ca"], "likes": 56, "viewed": 2005, "published": 3, "date": "1592944029", "time_retrieved": "2024-07-30T20:59:28.457551", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //pressure\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    \n    //border render\n    vec3 bord = smoothstep(border_h+1.,border_h-1.,border(pos))*vec3(1.);\n    \n    //particle render\n    vec2 rho = vec2(0.);\n\n    range(i, -1, 1) range(j, -1, 1)\n    {\n       vec2 dx = vec2(i,j);\n       vec4 data = texel(ch0, pos + dx);\n       particle P = getParticle(data, pos + dx);\n       \n        vec2 x0 = P.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*P.M*G((pos - x0)/0.75); \n    }\n  \trho = 1.2*rho;\n    \n     vec4 D = pixel(ch2, pos);\n    float ang = atan(D.x, D.y);\n    float mag = 0. + 10.*length(D.xy)*rho.x;\n    \n    // Output to screen\n    fragColor = vec4(1.6*vec3(0.2,0.4,1.)*rho.x + 1.*vec3(1.5,0.3,0.3)*rho.y*rho.x + bord + 0.*abs(P.x),0);\n\tfragColor.xyz = tanh(vec3(1.,1.1,1.3)*fragColor.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho; //gas\n    float GF = smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/0.2 - 1. + 0.1*rho.y), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = 1e10 + sdBox(Rot(0.4*time)*(p - R*0.5) , R*vec2(0.005, 0.2));\n    float drain = -sdBox(p - R*vec2(0.9, 0.05), vec2(0));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.1\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    float Mi = 0.;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n\t\tvec3 D1 = distribution(P0.X, pos, 1.);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        \n        P.M.y += P0.M.y*P0.M.x*D1.z;\n        \n        //add mass\n        P.M.x += m;\n        Mi += P0.M.x*D1.z;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    if(Mi != 0.)\n    {\n        P.M.y /= Mi;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 1.*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0005) + P.M.x*step(0.5, P.M.y)*vec2(0., 0.005);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n        P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 1.*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.x);\n    \n        \n    if(length(vec2(1., 1.)*(P.X - R*vec2(0.5, 0.1))) < 10.) P.M.y = mix(P.M.y, 1., 0.06);\n    if(N.z < 2.*border_h) P.M.y *= 0.9;\n\n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "#define mass 1.\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec2 F = vec2(0.);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.3) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(0.);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec2 F = vec2(0.);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205]], "test": "untested"}
{"id": "3lsyWS", "name": "Kelp forest bubbles", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/tlscRs]\"Rainy jungle\"[/url] shader, but it looks more like a kelp forest.", "tags": ["3d", "raymarching", "bubbles"], "likes": 2, "viewed": 297, "published": 3, "date": "1592943845", "time_retrieved": "2024-07-30T20:59:29.211535", "image_code": "#define t iTime\n#define r iResolution\nint surface_color;\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 jungle_color(vec3 p)\n{\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    uv += ceil(col+sin((col.x+col.y)));\n    col /= sin(uv.x);\n    col2 = col2+col;\n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\nvec3 animate_rain(vec3 p){\n    p.y -= iTime*200.0;\n    vec3 p1 = p/100.0;\n    p += vec3(sin(p1+p1.yzx))*33.33;\n    return p;\n}\n\nvec3 rain_color(in vec3 uv)\n{\n    //uv /= scale;\n    uv = animate_rain(uv);\n    //uv /= scale;\n    \n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(sin(vec2(uv.x, uv.y)));\n        uv.x = uv.y + uv.x;\n        uv.y = uv.x - uv.y;\n    }\n    return vec3((lar * .5), lar*.7, lar)*1.5;\n}\n\n\nfloat rainSDF(vec3 p) {\n    p *= 5.0;\n    p = animate_rain(p);\n\n    float to_return = 3.9 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n    return to_return;\n}\n\n\nfloat jungleSDF(vec3 p) {\n    p /= 40.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  3.9 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat sceneSDF(vec3 p){\n    float jungle = jungleSDF(p);\n    float rain = rainSDF(p);\n\tfloat to_return = min(jungle,rain);\n    if(to_return == jungle){\n    \tsurface_color = 1;\n    }\n    else{\n    \tsurface_color = 2;\n    }\n    return to_return;\n}\n\nvec3 surface_color1(vec3 p){\n    if(surface_color == 1){\n    \treturn jungle_color(p);\n    }\n    else if(surface_color == 2){\n    \treturn rain_color(p);\n    }\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    float scale = .1;\n    vec3 d=vec3(U/r.xy-.5,.5),p=vec3(0,6,t),q;\n    const int iterations = 99;\n    for(int i=0;i<iterations;i++)\n    {\n        p+=d*sceneSDF(p/scale)*scale;\n        if(i==iterations-5)q=p+=d=vec3(.6);\n    }\n    o+=vec4(surface_color1(p*5.0)/5.0,0)*length(p-q)+(p.z-t)/float(iterations/3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 135, 135, 429], [675, 675, 701, 701, 801], [803, 803, 832, 851, 1131], [1134, 1134, 1157, 1157, 1315], [1318, 1318, 1343, 1343, 1468], [1470, 1470, 1493, 1493, 1715], [1717, 1717, 1745, 1745, 1876], [1878, 1878, 1919, 1919, 2231]], "test": "untested"}
{"id": "WtXcWB", "name": "Whack-A-Mole Pistons", "author": "blackle", "description": "experimenting with 2D slicing the sphere packing SDF to get an array of circles of different sizes.\n\nNew: [url=https://youtu.be/I8fmkLK1OKg]The tutorial video[/url]", "tags": ["domainrepetition", "pistons"], "likes": 175, "viewed": 8428, "published": 3, "date": "1592943503", "time_retrieved": "2024-07-30T20:59:30.015386", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//uncomment for slow but pretty version\n//#define PRETTY\n#ifdef PRETTY\n#define AA_SAMPLES 8\n#define MOTION_BLUR\n#else\n#define AA_SAMPLES 1\n#endif\n\n//the following functions assume that p is inside the cube of radius 1 centered at the origin\n//closest vertex of the cube to p\nvec3 vertex(vec3 p) {\n    return step(0.,p)*2.-1.;\n}\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(sign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,sign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n//closest edge of the cube to p\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = vertex(p);\n    vec3 a = v*mask.zxy, b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat corner(vec2 p, float h) {\n    vec2 q = p - vec2(0,h);\n    return super(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\n//returns rhombic dodecahedron tessalation data for p\n//x: distance to circle of radius .6 in current cell\n//y: distance to circle of radius .6 in closest adjacent cell\n//zw: ID of cell\nvec4 grid(vec3 p) {\n    vec3 id = floor(p)+.5;\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z<0.) id += face(p-id);\n    p -= id;\n    float d1 = length(p)-.6;\n    p -= edge(p);\n    float d2 = length(p)-.6;\n    return vec4(d1,d2,id);\n}\n\n#define FBI floatBitsToInt\nfloat hash(float a, float b) {\n    int x = FBI(cos(a))^FBI(a);\n    int y = FBI(cos(b))^FBI(b);\n    return float((x*x+y)*(y*y-x)+x)/2.14e9;\n}\n\n//springy impulse\nfloat spring(float x) {\n    return smoothstep(-.4,.4,x) + smoothstep(-.3,.3,x) - smoothstep(-.7,.7,x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = max(vec3(0),k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//mtime set by \"pixel_color\" to influence the time used by the scene\nfloat mtime;\n//lots of globals set by \"scene\"\nvec2 gid;\nvec3 glocal;\nfloat gnd;\nfloat gt;\nfloat scene(vec3 p) {\n    //ds1 chooses z coordinate in 2d slicing of the rhombic dodecahedron tessalation\n    //by varying it over space, we get different sized circles\n    float ds1 = dot(cos(p.xy/5.), sin(p.xy/4.))*.06;\n    vec3 p3 = vec3(p.xy, ds1);\n    vec4 g = grid(p3);\n    gid = g.zw;\n \n    float s1 = hash(gid.x,gid.y);\n    float s2 = hash(s1,s1);\n    gt = sin(s1*100.+mtime*mix(1.,2.,s2*.5+.5))-.4;\n    float h = spring(gt)*2.-.5;\n\n    vec2 crd = vec2(g.x,p.z);\n    vec2 crd2 = vec2(g.y,p.z);\n    float maxheight = 1.7;\n\n    gnd = corner(crd*vec2(-1,1)+vec2(0.08,0.),0.)-.04; //ground holes\n\n    //transform things into local coordinates for piston\n    crd.y -= h;\n    glocal = p - vec3(gid,h);\n    glocal = erot(glocal,vec3(0,0,1),s1*100.+gt*2.);\n    float curr = corner(crd, 0.); //distance to current piston\n    \n    //little holes on side of piston\n    vec3 lp = glocal;\n    lp.z = asin(sin(lp.z*5.+.5))/5.;\n    curr = -smin(-curr, length(lp.yz)-0.05,.03);\n    \n    float adjacent = corner(crd2, maxheight); //distance to adjacent piston (assumes maximally extended)\n    return min(gnd,min(curr, adjacent)-.02);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 skylight(vec3 p) {\n    float d = dot(p,normalize(vec3(1)));\n    return vec3(1)*d*.2+.2 + pow(max(0.,d),10.)*1.5;\n}\n\nfloat smpl(vec3 p, vec3 dir, float dist) {\n    return smoothstep(-dist,dist,scene(p+dir*dist));\n}\n\nvec3 pixel_color(vec2 uv, float time)\n{\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    mtime = time;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-7,0,0);\n    \n    float yrot = 0.7+sin(time*.3)*.2;\n    float zrot = time*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    \n    init.xy += time*vec2(.5,sqrt(2.));\n    init.z += 2.;\n    vec3 p =init;\n    bool hit = false;\n    float dist; int i;\n    for (i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        if(distance(p,init)>50.)break;\n    }\n    //save globals locally\n    bool g = gnd == dist;\n    vec2 id = gid;\n    float s1 = hash(gid.y,gid.x);\n    float s2 = hash(s1,gid.x);\n    vec3 local = g ? p : glocal+vec3(id,0);\n    \n    float fog = min(1.,smoothstep(5.,50.,distance(p,init))+smoothstep(100.,200.,float(i)));\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ao = smpl(p,n,.1);\n    \n    //brushed metal tops. not sure if this is the right way, but it works!\n    if (!g && n.z>.9) {\n        float ang = atan(p.x-id.x,p.y-id.y);\n        float ang2 = atan(local.x-id.x,local.y-id.y);\n        local = vec3(ang2/2.,length(p.xy-id)*40.,local.z+id.x*.9+id.y*.4);\n        n = normalize(vec3(cos(ang*2.),sin(ang*2.),1));\n    }\n    \n    //rough texture\n    float sharpness = texture(iChannel0,local/2.).x;\n    sharpness = sqrt(texture(iChannel0,local*vec3(1,4,.5)+sharpness*.1).x);\n    sharpness *= pow(texture(iChannel0,local/10.+sharpness*.1).x, 2.);\n    sharpness = sharpness*.5+.9;\n    \n    //fake reflection occlusion\n    float ro = sqrt(smpl(p,r,.9)*smpl(p,r,.5)*smpl(p,r,.2));\n    \n    float spec = length(sin(r*3.*sharpness)*.4+.6)/sqrt(3.) * smoothstep(-1.,-.0,p.z);\n    float fres = 1.-abs(dot(cam,n))*.5;\n    vec3 mcol = abs(erot(vec3(0.4,0.6,0.9), normalize(vec3(0,s2,2)), s1*.6));\n    if (g) mcol = vec3(0.1);\n    \n    vec3 col = (mcol*spec + pow(spec,10.*sharpness))*ro*ao*fres*1.5;\n    vec3 bgcol = skylight(cam);\n    vec3 fragColor = hit ? mix(col,bgcol,fog) : bgcol;\n    return fragColor;\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nfloat bayer(ivec2 uv) {\n    return texelFetch(iChannel1, uv % 8, 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    float b = bayer(ivec2(fragCoord));\n    for (int i = 0; i < AA_SAMPLES+int(min(0,iFrame)); i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n#ifdef MOTION_BLUR\n\t\t//using yx's bayer motion blur idea https://www.shadertoy.com/view/wsfcWX\n        float blur = ((float(i)+b)/float(AA_SAMPLES)-.5) * iTimeDelta;\n#else\n        float blur = 0.;\n#endif\n        fragColor += vec4(pixel_color(uv2, iTime+blur), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n    \n    fragColor.xyz = smin(fragColor.xyz,vec3(1),0.1);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXcWB.jpg", "access": "api", "license": "cc0-1.0", "functions": [[341, 469, 490, 490, 521], [522, 554, 573, 573, 797], [798, 830, 849, 849, 998], [1000, 1000, 1021, 1021, 1053], [1055, 1055, 1086, 1086, 1168], [1170, 1356, 1375, 1375, 1596], [1625, 1625, 1655, 1655, 1765], [1767, 1785, 1808, 1808, 1889], [1891, 1891, 1930, 1930, 2002], [2004, 2004, 2040, 2040, 2116], [2118, 2118, 2156, 2156, 2218], [2379, 2379, 2400, 2548, 3506], [3508, 3508, 3527, 3527, 3642], [3644, 3644, 3667, 3667, 3763], [3765, 3765, 3807, 3807, 3862], [3864, 3864, 3903, 3903, 6159], [6161, 6161, 6182, 6182, 6241], [6243, 6243, 6266, 6266, 6315]], "test": "untested"}
{"id": "ttfyWB", "name": "Blender Donut", "author": "dean_the_coder", "description": "My take on the famous 'Blender donut'.\nCould do with finding a method to stop the ends of the sprinkles getting cut off...\nThanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!", "tags": ["3d", "raymarching", "donut", "blender", "cineshader"], "likes": 20, "viewed": 12907, "published": 3, "date": "1592936209", "time_retrieved": "2024-07-30T20:59:30.766378", "image_code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n    return (noise(p) + noise((p + 0.2) * 1.98) * 0.5 + noise((p + 0.66) * 4.12) * 0.25) / 1.75;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 sdDonut(vec3 p) {\n    float d1 = sdTorus(p, vec2(4.0, 1.4));\n\treturn vec2(d1, 1.5);\n}\n\nvec2 sdCream(vec3 p) {\n    float f = 0.0;\n    f += sin(p.x * 1.1 + p.z * 1.2) * 1.1;\n    f += sin(p.x * 2.5) * 0.5;\n    f += sin(p.z * 4.0) * 0.25;\n    f /= 4.0;\n    \n    float d2 = abs(p.y + f + 2.0) - 2.3;\n    \n    float d1 = sdDonut(p).x;\n    float d = max(d1, -d2);\n    \n\treturn vec2(d - 0.13, 2.5);\n}\n\nvec2 sdSprinkles(vec3 p) {\n    float dd = sdCream(p - vec3(0.0, 0.05, 0.0)).x;\n    \n    vec3 id = floor(p / 0.3);\n    \n    p.xz *= rot(hash(id.xz) * 3.141);\n    p.xy *= rot(hash(id.xy) * 3.141);\n    p.xz *= rot(hash(id.xz) * 3.141);\n    \n    p.x = mod(p.x, 0.3) - 0.15;\n    p.y = mod(p.y, 0.3) - 0.15;\n    p.z = mod(p.z, 0.3) - 0.15;\n    \n    p.xz *= rot(hash(id.xz) * 3.141);\n    p.xy *= rot(hash(id.xy) * 3.141);\n    p.xz *= rot(hash(id.xz) * 3.141);\n    float d = sdCapsule(p, 0.3, 0.02);\n    \n    d = max(d, dd);\n    \n    return vec2(d, mod(id.x, 6.0) + mod(id.y, 6.0) + mod(id.z, 6.0) + 10.5);\n}\n\nvec2 map(vec3 p) {\n    float bumps = fbm(p * 8.0) * 0.02;\n    vec2 d1 = sdDonut(p) - bumps;\n    vec2 d2 = sdCream(p);\n    vec2 d3 = sdSprinkles(p);\n    vec2 d4 = vec2(p.y + 1.7, 3.5);\n    \n    return min2(d1, min2(d2, min2(d3, d4)));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.7;\n    for (int i = 0; i < 16; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col;\n\n    // Raymarch.\n    vec3 ro = vec3(sin(iTime * 0.3), 4.0 + cos(iTime * 0.6) * 0.5, -9.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, -1.0, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 128.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(10.0, 7.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.15, 0.2, 0.25);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float occ = calcOcc(p, n, 4.0);\n        float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Donut.\n            mat = vec3(0.5, 0.3, 0.2);\n        } else if (hit == 2) {\n            // Cream.\n            mat = vec3(1.0, 0.43, 0.85);\n        } else if (hit == 3) {\n            // Plane.\n            mat = vec3(0.2);\n        } else if (hit >= 10) {\n            // Sprinkles!\n            vec3 c = vec3(float(hit)) + vec3(1.0, 2.0, 3.0);\n            mat = sin(floor(c * 3.0) / 3.0);\n        }\n\n        col = (mainLight * sha + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col *= mat;\n        col = mix(col, skyCol, fog);\n    } else {\n        // Sky.\n        col = vec3(0.15, 0.2, 0.25);\n    }\n\n    // Output to screen\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyWB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[88, 88, 108, 108, 172], [174, 230, 251, 251, 527], [529, 529, 548, 548, 646], [648, 648, 667, 667, 743], [745, 745, 776, 776, 841], [843, 843, 886, 886, 941], [943, 943, 990, 990, 1195], [1197, 1197, 1224, 1224, 1256], [1258, 1258, 1280, 1280, 1348], [1350, 1350, 1372, 1372, 1655], [1657, 1657, 1683, 1683, 2257], [2259, 2259, 2277, 2277, 2494], [2496, 2496, 2524, 2524, 2715], [2717, 2717, 2775, 2775, 3073], [3075, 3075, 3122, 3122, 3210], [3300, 3300, 3341, 3341, 3482], [3484, 3484, 3541, 3541, 5548]], "test": "untested"}
{"id": "wtXyWB", "name": "angular blue noise from bluenois", "author": "FabriceNeyret2", "description": "- Left: blue noise, two sub-bluenoise\n- Right: (WIP) try to turn flat bluenoise into angular ( i.e. cyclical in value space )\n\nwas just trying :-) ( how to test, angular blueness / low-discrepancy, BTW ? )\n", "tags": ["bluenoise"], "likes": 5, "viewed": 448, "published": 3, "date": "1592924964", "time_retrieved": "2024-07-30T20:59:31.601146", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy/vec2(6,2), U=u;\n    int x = int(U/R);                               // subwindow index\n    if (U.y < R.y) U /= 4.;                         // bottom: zoom\n    ivec2 I = ivec2(U);\n    \n    O = texelFetch(iChannel0, I%1024, 0).xxxx;      // left: base blue noise,\n    vec4 H = texelFetch(iChannel0, (I+512)%1024, 0).xxxx;\n    \n    if      (x==1)  O = fract(O*4.);                // then two sub-bluenoises  \n    else if (x==2)  O = floor(O*8.)/8.;             // ( LSB & MSB )       \n    else if (x==3)  I = I%2, O = .5*O + .5*vec4(I.x==I.y); // three rights: \n    else if (x==4)  O = .5*O + .5*fract(H*4.);      // trying to make angular bluenoise\n    else if (x==5)  O = .5*O + .5*floor(H*8.)/8.; \n     \n    if ( int(u)%int(R ) == 0  ) O = vec4(1,0,0,1);  // red separators\n    if ( abs(u-R).x      < 2. ) O = vec4(1,0,0,1); \n    if ( abs(u+1.-3.*R).x< 2. ) O = vec4(1,0,0,1); \n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 946]], "test": "untested"}
{"id": "tlfcDS", "name": "Warp/unwarp ", "author": "Yahor10", "description": "Warp formula test", "tags": ["warp"], "likes": 1, "viewed": 115, "published": 3, "date": "1592921425", "time_retrieved": "2024-07-30T20:59:32.494757", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n   \tvec2 distort_uv = texture(iChannel0, uv).xy;\n\n    // Output to screen\n    fragColor = texture(iChannel1, distort_uv);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define radius 0.13\n#define speed 1e-1\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\n#define warp true\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = pos/iResolution.xy;\n    \n    col.xy = texture(iChannel0, uv).xy;//prev value\n    \n    if(iMouse.z > 0.) //mouse is active\n    {\n        vec2 cmouse = iMouse.xy/iResolution.xy;\n        vec2 pmouse = iMouse.zw/iResolution.xy;\n        vec2 dmouse = cmouse-pmouse;\n        //texture uv distorsion\n        float str = exp(-sqr(distance(cmouse, uv)/radius));\n        if(warp)\n        {\n            col.xy = texture(iChannel0, uv - speed*str*dmouse).xy;\n        }\n        else\n        {\n            col.xy = mix(col.xy, uv, 0.1*str);\n        }\n    }\n    \n    \n    \n    //initialize with uniform coordinates\n    if(iFrame < 1)\n    {\n        col.xy = uv;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 273]], "test": "untested"}
{"id": "wlXcDS", "name": "Mellow Voronoi", "author": "Mipmap", "description": "Mellow riff on ZnW's Voronoi Wave, [url]https://www.shadertoy.com/view/3lfyDB[/url]", "tags": ["voronoi", "wave", "gradient", "motion", "pattern", "wallpaper"], "likes": 18, "viewed": 1019, "published": 3, "date": "1592920216", "time_retrieved": "2024-07-30T20:59:33.293621", "image_code": "// Mellow riff on ZnW's Voronoi Wave, https://www.shadertoy.com/view/3lfyDB\n//\nconst int POINTS = 16; // Point rows are determined like N / 10, from bottom to up\nconst float WAVE_OFFSET = 12000.0;\nconst float SPEED = 1.0 / 12.0;\nconst float COLOR_SPEED = 1.0 / 4.0;\nconst float BRIGHTNESS = 1.2;\n\nvoid voronoi(vec2 uv, inout vec3 col)\n{\n    vec3 voronoi = vec3(0.0);\n    float time = (iTime + WAVE_OFFSET)*SPEED; // Vary time offset to affect wave pattern\n    float bestDistance = 999.0;\t\t\n    float lastBestDistance = bestDistance;\t// Used for Bloom & Outline\n    for (int i = 0; i < POINTS; i++)\t\t// Is there a proper GPU implementation of voronoi out somewhere?\n    {\n        float fi = float(i);\n        vec2 p = vec2(mod(fi, 1.0) * 0.1 + sin(fi),\n                      -0.05 + 0.15 * float(i / 10) + cos(fi + time * cos(uv.x * 0.025)));\n        float d = distance(uv, p);\n        if (d < bestDistance)\n        {\n            lastBestDistance = bestDistance;\n            bestDistance = d;\n            \n            // Two colored gradients for voronoi color variation\n            voronoi.x = p.x;\n            voronoi.yz = vec2(p.x * 0.4 + p.y, p.y) * vec2(0.9, 0.87);\n        }\n    }\n    col *= 0.68 + 0.19 * voronoi;\t// Mix voronoi effect and default shadertoy gradient\n    col += smoothstep(0.99, 1.05, 1.0 - abs(bestDistance - lastBestDistance)) * 0.9;\t\t\t// Outline\n    col += smoothstep(0.95, 1.01, 1.0 - abs(bestDistance - lastBestDistance)) * 0.1 * col;\t\t// Outline fade border\n    col += (voronoi) * 0.1 * smoothstep(0.5, 1.0, 1.0 - abs(bestDistance - lastBestDistance));\t// Bloom\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime*COLOR_SPEED+uv.xyx+vec3(0,2,4));\n    \n    // Effect looks nice on this uv scaling\n    voronoi(uv * 4.0 - 1.0, col); \n\n    // Output to screen\n    fragColor = vec4(col,1.0)*BRIGHTNESS;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 336, 336, 1591], [1593, 1593, 1650, 1700, 1994]], "test": "untested"}
{"id": "wtlyRs", "name": "LSD Wormhole", "author": "z0rg", "description": "I started with a fake tunnel effect and finished as a wormhole travel :)", "tags": ["wormhole", "lsd", "drug"], "likes": 11, "viewed": 437, "published": 3, "date": "1592912130", "time_retrieved": "2024-07-30T20:59:34.234106", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.141592653;\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n  float t = iTime*.1+uv.x*2.*sin(iTime)+uv.y*4.*sin(iTime);\n  float tt = iTime;//*(1.+.05*sin(iTime*.2));\n  float blur = 2.*mix(0.01,0.001,sin(iTime*.2)*.5+.5);\n  float l = pow(length(uv),.1)*1.;\n  uv += vec2(sin(t+l),cos(t+l))*.2*pow(length(uv),.5);\n  col = texture(iChannel0, vec2(0.1*atan(uv.y, uv.x)/PI, .05*tt+blur/length(uv))).xyz;\nvec3 col2 = texture(iChannel0, -vec2(.2*atan(uv.y, uv.x)/PI, .05*tt+.001/length(uv))).xyz;\n\n  return vec3(.9,.12,.38)*col2*.8+.1*col*pow(length(uv),.5)*vec3(.5,.3,.7)*max(dot(uv, vec2(1.)),.5)\n  + 3.5*pow(1.-sat(lenny(uv*.5)),5.)*vec3(.32,.45,.65);\n}\n\nvec3 rdrLSDWormHole(vec2 uv)\n{\n    uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n    uv += vec2(sin(iTime)*.1, cos(iTime*.2)*.1);\n    uv*=1.5;\n    vec3 col = rdr(uv);\n    col = mix(col, col.xzy,sin(5.*length(uv)+iTime*2.)*1.);\n    col *= pow(sat(1.-lenny(uv*.05)), 20.);\n\n    col = pow(col, vec3(1./1.2));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec3 col = rdrLSDWormHole(uv);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyRs.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[428, 428, 449, 449, 479], [480, 480, 500, 500, 527], [529, 529, 548, 548, 1149], [1151, 1151, 1181, 1181, 1474], [1477, 1477, 1534, 1534, 1642]], "test": "untested"}
{"id": "WtfyWB", "name": "DifferentClouds filter", "author": "indere", "description": "1.The effect refers to the Different Clouds in ps\n2.buffer A:  Generate noise simulation clouds    （refer \"iq\" 's 'https://www.shadertoy.com/view/XdXGW8）\n3. mainImage : mix noise and origin image. then Reverse mixed color.", "tags": ["differentcloudsfilter"], "likes": 1, "viewed": 299, "published": 3, "date": "1592896553", "time_retrieved": "2024-07-30T20:59:34.988090", "image_code": "\nvec3 reverseColor(in vec3 c1, in vec3 c){\n\treturn abs(c1 - c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 reverse_c = (texture(iChannel0, uv).rgb);\n    vec4 cloud_c = texture(iChannel1, uv);\n    \n    vec3 final_c = mix(reverse_c, cloud_c.rgb, pow(cloud_c.a, 0.2));\n    final_c = reverseColor(reverse_c, final_c);\n    fragColor = vec4(final_c, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 65], [67, 67, 124, 124, 421]], "test": "untested"}
{"id": "3lXyDB", "name": "cellular automata maze maker", "author": "mds2", "description": "inspired by https://www.techspot.com/news/85622-nobody-sure-what-makes-atari-2600-game-entombed.html", "tags": ["feedback", "cellular", "maze"], "likes": 3, "viewed": 311, "published": 3, "date": "1592892950", "time_retrieved": "2024-07-30T20:59:35.866741", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rrr;\n\n    // Output to screen\n    fragColor = vec4(1.0 - col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float cellsize = 8.0;\n\n#define USE_RULE_110_INSTEAD_OF_30 1\n\nvec2 to_uv(in vec2 coord) {\n    return coord / iResolution.xy;\n}\n\nfloat val_at(vec2 coord, vec2 cells) {\n    vec2 uv = to_uv(coord + cellsize * cells);\n    return step(0.5, texture(iChannel0, uv).r);\n}\n\nfloat rule_30_val_at(vec2 coord, vec2 cells) {\n    vec2 uv = to_uv(coord + cellsize * cells);\n    return step(0.5, texture(iChannel0, uv).b);\n}\n\n\nfloat next_rule_30_val(in float a, in float b, in float c) {\n\t// active for 100, 011, 010, or 001\n    if (a > 0.5) {\n        if (b < 0.5 && c < 0.5) {\n            return 1.0;\n        }\n        return 0.0;\n    }\n    if (b > 0.5) {\n        return 1.0;\n    }\n    if (c > 0.5) {\n        return 1.0;\n    }\n    return 0.0;\n}\n\nfloat next_rule_110_val(in float a, in float b, in float c) {\n\t// active for all except 111, 100, 000\n    if (b < 0.5 && c < 0.5) {\n        return 0.0;\n    }\n    if (a > 0.5 && b > 0.5 && c > 0.5) {\n        return 0.0;\n    }\n    return 1.0;\n}\n\n//  d   e\n//  b   c\n//  a   *\nfloat next_val(in float a, in float b, in float c, in float d, in float e, in float local_rand) {\n    if (b < 0.5 && c < 0.5 && d < 0.5 && e < 0.5) {\n        return local_rand;\n    }\n    \n    if (b > 0.5 && c > 0.5 && d > 0.5 && e > 0.5) {\n        return (1.0 - a);\n    }\n    \n    if (a > 0.5 && b > 0.5 && c > 0.5 && (e > 0.5 || d > 0.5)) {\n        return 0.0;\n    }\n    \n    if (a > 0.5 && b > 0.5 && d > 0.5) {\n        return local_rand;\n    }\n    \n    if (c > 0.5 && (b > 0.5 || e > 0.5)) {\n        return 1.0;\n    }\n    \n    return local_rand;\n}\n    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 cell_pos = fragCoord - mod(fragCoord, vec2(cellsize)) + 0.5 * cellsize;\n\n    \n    \n    \n    if (iResolution.y - cell_pos.y <= 1.5 * cellsize) {\n        if (abs(iMouse.x - cell_pos.x) < 5.0 * cellsize) {\n\t        fragColor = vec4(1.0);\n        } else {\n            fragColor = vec4(vec2(0.0), step(cellsize, mod(2.1*cellsize + cell_pos.x, 7.0 * cellsize)), 1.0);\n        }\n        return;\n    }\n\n    if (iResolution.x - fragCoord.x <= cellsize || fragCoord.x <= 2.0 * cellsize) {\n        \n        fragColor = vec4(0.0, 0.0, step(3.0 * cellsize, mod(cell_pos.y, 5.0 * cellsize)), 1.0);\n        return;\n    }\n    \n    vec3 rule_30_vals = vec3(rule_30_val_at(cell_pos, vec2(-1.0,1.0)),\n                             rule_30_val_at(cell_pos, vec2(0.0, 1.0)),\n                             rule_30_val_at(cell_pos, vec2(1.0, 1.0)));\n\n#if USE_RULE_110_INSTEAD_OF_30 \n    float local_rand = next_rule_110_val(rule_30_vals.x, rule_30_vals.y, rule_30_vals.z);\n#else\n    float local_rand = next_rule_30_val(rule_30_vals.x, rule_30_vals.y, rule_30_vals.z);\n#endif\n    float a = val_at(cell_pos, vec2(1.0, 0.0));\n    float c = val_at(cell_pos, vec2(0.0, 1.0));\n    float b = val_at(cell_pos, vec2(1.0));\n    float e = val_at(cell_pos, vec2(0.0, 2.0));\n    float d = val_at(cell_pos, vec2(1.0, 2.0));\n    \n    // local_rand = 1.0 - a;\n    \n    float next_cell = next_val(a,b,c,d,e, local_rand);\n    fragColor = vec4(vec3(next_cell, 0.0, local_rand),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 287]], "test": "untested"}
{"id": "wlsyD7", "name": "Rounded Rhombic Dodecahedron", "author": "blackle", "description": "remix of yx's shader: https://www.shadertoy.com/view/Wd2Gzt", "tags": ["sdf"], "likes": 5, "viewed": 355, "published": 3, "date": "1592881280", "time_retrieved": "2024-07-30T20:59:36.943861", "image_code": "//Original Shader by yx: https://www.shadertoy.com/view/Wd2Gzt\n\n#define pi (acos(-1.))\n\nconst vec3 color = vec3(.3,.01,.05);\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat scene(vec3 p)\n{\n    float offset = 0.05;\n    float radius = .5;\n    p = sqrt(p*p+offset*offset);\n    p = (p+p.yzx)/2.-radius;\n    return length(max(p,0.))+min(0.,max(p.x,max(p.y,p.z)))-offset;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t;\n    for(int i = 0; i < 100; ++i)\n    {\n        float k = scene(cam+dir*t);\n        t += k;\n        if (k < .001)\n        {\n            vec3 h = cam+dir*t;\n    \t\tvec2 o = vec2(.001, 0);\n    \t\tvec3 n = normalize(vec3(\n        \t\tscene(h+o.xyy)-scene(h-o.xyy),\n        \t\tscene(h+o.yxy)-scene(h-o.yxy),\n        \t\tscene(h+o.yyx)-scene(h-o.yyx)\n    \t\t));\n\n\t\t\tif (iMouse.z > 0.)\n    \t\t{\n        \t\treturn n*.5+.5;\n    \t\t}\n    \t\telse\n    \t\t{\n                const vec3 lightdir = normalize(vec3(1,5,2));\n                \n\t\t        float light = dot(n,lightdir)*.5+.5;\n\t\t\n\t\t        return light * color;\n    \t\t}\n        }\n    }\n    return vec3(1);\n}\n\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, .3);\n    p.xz = rotate(p.xz, iTime*.1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-15.);\n    vec3 dir = normalize(vec3(uv,6));\n\n    cameraspin(cam);\n    cameraspin(dir);\n    \n    out_color.rgb = trace(cam,dir);\n    if (iMouse.z <= 0.)\n    {\n    \tout_color.rgb *= pow(color, vec3(2.*dot(uv,uv)));\n    \tout_color.rgb = pow(out_color.rgb,vec3(.45));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 156, 156, 279], [281, 281, 302, 302, 481], [483, 483, 515, 515, 1167], [1169, 1169, 1200, 1200, 1266], [1268, 1268, 1320, 1320, 1711]], "test": "untested"}
{"id": "wllcRl", "name": "specialBlur filter", "author": "indere", "description": "the Principle is similar to surface blur.\n1. border detection\n2. Selecting blur region based on boundary info\n", "tags": ["specialblurfilter"], "likes": 5, "viewed": 549, "published": 3, "date": "1592880557", "time_retrieved": "2024-07-30T20:59:37.857419", "image_code": "// special blur Vertical\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = vec2(0.0, 1.0) / iResolution.xy;\n    vec3 ansColor = specialBlur(iChannel0, iChannel1, uv, offset);\n    if(fragCoord .x >= mod(iTime * 150.0, iResolution.x) - 0.5 && fragCoord .x <= mod(iTime * 150.0, iResolution.x) + 0.5)\n        ansColor = vec3(1.0,0.0,0.0);\n    else if(fragCoord .x > mod(iTime * 150.0, iResolution.x) + 0.5)\n        ansColor = texture(iChannel2, uv).rgb;\n    fragColor = vec4(ansColor, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// gaussian blur\n// first step we apply gaussian blur to remove Noise\n// which is helpful to border detection\n\n// for efficient we can separate our 2-dimensional Gaussian function into two 1-dimensional one  \n// (http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/) \n// Because of the limit of the number of buffers we can't do this on shadertoy\n\n\n// 3 * 3 gaussian blur\nconst float w[9] = float[9](\n\t0.095, 0.118, 0.085, 0.118, 0.147, 0.118, 0.095, 0.118, 0.095\n);\n\nvec3 gaussianBlur(in sampler2D tex, in vec2 uv){\n\tvec3 sumColor = vec3(0.0);\n    for(int x = 0; x < 3; x++){\n        for(int y = 0; y < 3; y++){\n        \tint index = x * 3 + y;\n            vec2 offset = vec2(float(x - 1), float(y - 1)) / iResolution.xy;\n            sumColor += texture(tex, uv + offset).rgb * w[index];\n        }\n    }\n    return sumColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec3 blurColor = gaussianBlur(iChannel0, uv);\n    fragColor = vec4(blurColor, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//soble border detection\n//guassian blur can remove Noise\n//then we apply soble operator on image\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n\tfloat w = 1.0 / iResolution.x;\n\tfloat h = 1.0 / iResolution.y;\n\n\tn[0] = texture(tex, coord + vec2( -w, -h));\n\tn[1] = texture(tex, coord + vec2(0.0, -h));\n\tn[2] = texture(tex, coord + vec2(  w, -h));\n\tn[3] = texture(tex, coord + vec2( -w, 0.0));\n\tn[4] = texture(tex, coord);\n\tn[5] = texture(tex, coord + vec2(  w, 0.0));\n\tn[6] = texture(tex, coord + vec2( -w, h));\n\tn[7] = texture(tex, coord + vec2(0.0, h));\n\tn[8] = texture(tex, coord + vec2(  w, h));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec4 n[9];\n    make_kernel(n, iChannel0, uv);\n    // sobel\n    vec4 gx = (n[6] + 2.0 * n[7] + n[8])  - (n[0] + 2.0 * n[1] + n[2]);\n    vec4 gy = (n[0] + 2.0 * n[3] + n[6]) - (n[2] + 2.0 * n[5] + n[8]);\n    \n    vec4 finalColor = vec4(0.0);\n    //finalColor = sqrt(gx * gx) + sqrt(gy * gy);\n    finalColor = sqrt(gx * gx + gy * gy);\n    \n    fragColor = vec4(clamp(finalColor.rgb, 0.0, 1.0), sqrt(length(gy) / length(gx)));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const float threshold = 0.5;\n//NMS\nbool NMS(in vec2 fragCoord){\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n    float gp = length(c.rgb);\n    float xita = c.a;\n    float p1 = 0.0, p2 = 0.0,p3 = 0.0, p4 = 0.0;\n    float step_x = 1.0 / iResolution.x;\n    float step_y = 1.0 / iResolution.y;\n    if(xita > 1.0){\n    \tp1 = length(texture(iChannel0, uv + vec2(0.0, -step_y)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(step_x, -step_y)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(0.0, step_y)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(-step_x, step_y)).rgb);\n    }else if(xita > 0.0){\n    \tp1 = length(texture(iChannel0, uv + vec2(step_x, -step_y)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(step_x, 0.0)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(-step_x, step_y)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(-step_x, 0.0)).rgb);\n    }else if(xita > -1.0){\n    \tp1 = length(texture(iChannel0, uv + vec2(step_x, 0.0)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(step_x, step_y)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(-step_x, 0.0)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(-step_x, -step_y)).rgb);\n    }else{\n    \tp1 = length(texture(iChannel0, uv + vec2(step_x, step_y)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(0.0, step_y)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(-step_x, -step_y)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(0.0, -step_y)).rgb);\n    }\n    \n    float gp1 = xita * p2 + (1.0 - xita) * p1;\n    float gp2 = xita * p4 + (1.0 - xita) * p3;\n    //float gp1 = xita * p1 + (1.0 - xita) * p2;\n    //float gp2 = xita * p3 + (1.0 - xita) * p4;\n    \n    if(gp >= gp1 && gp >= gp2){\n        if((c.r + c.b + c.g) / 3.0 > threshold)\n            return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if(NMS(fragCoord))\n        fragColor = vec4(vec3(1.0),1.0);\n    else\n        fragColor = vec4(vec3(0.0),1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// now we got img's border info. we can use this to blur img in similar region(not cross the border)\n\nconst float weight[20] = float[20](0.12238567125008,\n        0.11682268619326,\n        0.10158494451587,\n        0.080421414408401,\n        0.057903418374049,\n        0.037859927398416,\n        0.022435512532395,\n        0.012019024570926,\n        0.0058022877238952,\n        0.0025143246803546,\n        0.00097328697304049,\n        0.00033456739698267,\n        0.00010138405969172,\n        2.6836956977219e-05,\n        6.134161594793e-06,\n        1.192753643432e-06,\n        1.9341950974573e-07,\n        2.5449935492859e-08,\n        2.6102497941393e-09,\n        1.9576873456045e-10);\nconst int R = 20;\n\nvec3 specialBlur(in sampler2D originTex, in sampler2D borderTex, in vec2 uv, in vec2 offset)\n{\n    float f = texture(borderTex, uv).r;\n    vec3 ansColor = vec3(0.0);\n    if(f >= 0.5)\n        ansColor = texture(originTex, uv).rgb;\n    else{\n    \tansColor = texture(originTex, uv).rgb * weight[0];\n        float norm = weight[0];\n        for(int i = 1; i < R; i++){\n            float f_t = texture(borderTex, uv + float(i) * offset).r;\n            if(f_t > 0.5)\tbreak;\n        \tansColor += texture(originTex, uv + float(i) * offset).rgb * weight[i];\n            norm += weight[i];\n        }\n        \n        for(int i = 1; i < R; i++){\n        \tfloat f_t = texture(borderTex, uv - float(i) * offset).r;\n            if(f_t > 0.5)\tbreak;\n        \tansColor += texture(originTex, uv - float(i) * offset).rgb * weight[i];\n            norm += weight[i];\n        }\n        \n        ansColor /= norm;\n \n    }\n    \n    return   ansColor; \n}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 82, 82, 555]], "test": "untested"}
{"id": "tlsyzs", "name": "bluenoise autocorrelation", "author": "FabriceNeyret2", "description": "autcorrelation in the horizontal (cyclical) lines of bluenoise texture.\nresult looks similar in R,G,B,A so I average. result also look similar columnwise.\nred: abs(autocorrel)", "tags": ["bluenoise", "histogram", "probability"], "likes": 0, "viewed": 401, "published": 3, "date": "1592862527", "time_retrieved": "2024-07-30T20:59:38.841787", "image_code": "void mainImage(out vec4 O, in vec2 U) {\n    float t = texelFetch(iChannel0,ivec2(270),0).w;   // number or computed lines\n    U /= max(1.,floor(iResolution.y/256.));           // pixel-friendly zoom\n\n    O-=O;\n    for (int y=0; y<256; y++)\n        O += texelFetch(iChannel0,ivec2(int(U.x)/8+90,y),0); \n    \n    O = .4 + O/256. / 2.;\n    t = (O.r+O.g+O.b+O.a)/4.;                        // average 4 channels\n\n    O-=O;\n    O.gb += step(U.y-80.,t);\n    O.r = step(U.y-80.,abs(t));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define T(x,y) (2.*texelFetch(iChannel1, dir ? ivec2(x,y)%1024 : ivec2(y,x)%1024 ,0) -1.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( textureSize(iChannel1,1).x <2 ) {          // wait for texture load\n        if (U.y > 280.) O = vec4(int(U.x)<iFrame);  // waiting scroll \n        return;                           \n    }\n    ivec2 I = ivec2(U);\n    O = texelFetch(iChannel0,I,0);                  // previous state\n    if ( I==ivec2(270) ) O.w++;                     // frame counter\n    if (max(U.x,U.y) > 256.) return;                // only use 256x256 grid\n    float t = texelFetch(iChannel0,ivec2(270),0).w; // current treated line\n    if (t>=MAX) return;                             // scan finished.\n\n    bool dir = t<1024.;                             // if stats on lines then columns\n    for (int x=0; x<1024; x++)\n        O += T(x+128,I.y) * T(x+I.x,I.y);           //  correlation(t)   for each line\n     // O += abs(T(x+128,I.y) - T(x+I.x,I.y));      //  sum of abs(diff)\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "  #define MAX 1.   // stats only on lines\n//#define MAX 2.   // stats on lines + columns\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 481]], "test": "untested"}
{"id": "wtsyzs", "name": "Quantum Penguins", "author": "dr2", "description": " A quantum version of \"Belvedere\" (with apologies to Escher): penguins can  tunnel between the two scenes, and now they are even more confused because  they don't know where they are.\n", "tags": ["escher", "architecture", "folly", "paradox"], "likes": 9, "viewed": 425, "published": 3, "date": "1592858611", "time_retrieved": "2024-07-30T20:59:39.843110", "image_code": "// \"Quantum Penguins\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrFlatCyl2Df (vec2 p, float rhi, float rlo);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_PENG 7\n\nvec3 ltDir, qHit, vuDir, vuPln;\nfloat dstFar, tCur, fAng, sFrame;\nint idObj;\nbool pengOn[N_PENG];\nconst int idFlr = 1, idPil = 2, idBal = 3, idFrz = 4, idRf = 5, idLBld = 6, idLad = 7,\n   idGrnd = 8, idStr = 9, idWal = 10, idPen = 20;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PengDf (vec3 p, float szFac, float rot, int isSit, float dMin)\n{\n  vec3 q;\n  float d, dh;\n  dMin /= szFac;\n  p /= szFac;\n  if (isSit > 0) p.y -= 1.25;\n  else p.y -= 1.55;\n  q = p;\n  q.y -= 0.5;\n  d = PrSphDf (q, 2.5);\n  if (d < dMin) {\n    p.xz = Rot2D (p.xz, rot);\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n    q.y -= 1.5;\n    dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n    DMINQ (idPen + 1);\n    q = p;\n    q.yz -= vec2 (1.6, -0.6);\n    d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n    DMINQ (idPen + 2);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = PrSphDf (q, 0.15);\n    DMINQ (idPen + 3);\n    q = p;\n    q.x = abs (q.x);\n    if (isSit > 0) {\n      q.xy -= vec2 (0.6, -1.05);\n      q.yz = Rot2D (q.yz, -0.5 * pi);\n      q.y -= -0.6;\n    } else {\n      q.xy -= vec2 (0.4, -0.8);\n    }\n    d = PrCylDf (q.xzy, 0.12, 0.7);\n    DMINQ (idPen + 4);\n    q -= vec3 (0.1, -0.67, -0.4);\n    q.xz = Rot2D (q.xz, -0.07 * pi);\n    d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, 0.15 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, -0.3 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    DMINQ (idPen + 5);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (1.1, 0.3, -0.2);\n    q.yz = Rot2D (q.yz, -0.25 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n    d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n    DMINQ (idPen + 6);\n  } else dMin = min (dMin, d);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat StairDf (vec3 p, float st, float w, float h)\n{\n  return 0.7 * max ((st + p.y - p.z - abs (mod (p.y + p.z, 2. * st) - st) / sqrt(2.)),\n     max (abs (p.x) - w, max (abs (p.y) - h, abs (p.z) - h)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, wb, len, wid, b, ds;\n  dMin = dstFar;\n  len = 4.;\n  wid = 1.;\n  b = 0.1;\n  wb = 0.4 * b;\n  q = p;\n  q.y -= (vuDir.y > 0.) ? 1.2 : -3.;\n  q.xz = (vuDir.y > 0.) ? q.xz : q.zx;\n  d = PrBoxDf (q, vec3 (wid + 1.5 * b, 0.1, len + 1.5 * b));\n  DMINQ (idFlr);\n  if (vuDir.y > 0.) {\n    q = p;\n    q.y -= 4.4;\n    d = abs (q.z) - (len + 1.5 * b);\n    q.z = mod (q.z + (1./3.) * len + 0.05, (2./3.) * len + 0.1) - (1./3.) * len - 0.05;\n    d = max (d, min (max (max (length (vec2 (q.yz)) - (1./3.) * len , length (q.xy) - wid - b) - 0.1,\n       0.3 - q.y), min (PrCylDf ((q - vec3 (0., 1.3, 0.)).xzy, 0.07 * (1. - 1.3 * (q.y - 1.3)), 0.35),\n       PrCylDf ((q - vec3 (0., 1.5, 0.)).xzy, 0.15, 0.03))));\n    DMIN (idRf);\n    q = p;\n    q.y = (abs (q.y - 2.4) - 1.8) * sign (q.y - 2.4);\n    d = max (PrBoxDf (q, vec3 (wid + wb, 0.5, len + wb)), - PrBox2Df (q.xz, vec2 (wid, len) - wb));\n    d = max (d, - PrFlatCyl2Df (vec2 (q.x, q.y + 0.4), wid - b - 0.7, 0.8));\n    d = max (d, - PrFlatCyl2Df (vec2 (mod (q.z + (1./3.) * len, (2./3.) * len) -\n       (1./3.) * len, q.y + 0.4), (1./3.) * len - b - 0.7, 0.8));\n    DMIN (idFrz);\n  } else {\n    q = p;\n    q.y -= -4.5;\n    d = PrBoxDf (q, vec3 (len + b, 1.4, wid + b));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (- len - b, 0.3, 0.)).yzx, 0.2, 0.6, 0.4), 0.2 - q.y));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (0.5, 0.3, - wid - b)).yxz, 0.2, 0.6, 0.4), 0.2 - q.y));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (3., -0.3, - wid - b)).yxz, 0.7, 0.5, 0.4), -0.8 - q.y));\n    d = min (d, PrBoxDf (q - vec3 (- len - b, -0.5, - wid - b - 0.5), vec3 (0.35, 0.2, 0.4)));\n    DMINQ (idLBld);\n    q = p - vec3 (-2.7, -4.1, -2.3);\n    d = StairDf (q, 0.25, 1., 1.2);\n    DMINQ (idStr);\n    q = p - vec3 (-9., -5.5, -5.);\n    d = PrBoxDf (q, vec3 (8.1, 0.4, 6.3));\n    DMINQ (idGrnd);\n    q = p - vec3 (-1., -4.7, -6.);\n    d = PrBoxDf (q, vec3 (0.1, 0.4, 5.2));\n    DMINQ (idWal);\n    q = p - vec3 (-7., -4.7, 1.2);\n    d = PrBoxDf (q, vec3 (9., 0.4, 0.1));\n    DMINQ (idWal);\n  }\n  q = p;\n  q.y -= (vuDir.y > 0.) ? 1.7 : -2.5;\n  q.xz = (vuDir.y > 0.) ? q.xz : q.zx;\n  d = max (PrBoxDf (q, vec3 (wid + wb, 0.4, len + wb)), - PrBox2Df (q.xz, vec2 (wid, len) - wb));\n  d = max (d, - PrBoxDf (q - vec3 (- wid, 0., ((vuDir.y > 0.) ? 0. : - (2./3.) * len)),\n     vec3 (0.2, 0.5, (1./3.) * len)));\n  d = max (d, - max (PrFlatCyl2Df (vec2 (q.y, mod (mod (q.z + (1./3.) * len, (2./3.) * len) -\n     (1./3.) * len + 0.2, 0.4) - 0.2), 0.17, 0.13), abs (q.z) - (len - 0.9 * b)));\n  d = max (d, - PrFlatCyl2Df (vec2 (q.y, mod (q.x + 0.2, 0.4) - 0.2), 0.17, 0.13));\n  DMIN (idBal);\n  if (vuDir.y > 0.) {\n    q = p;\n    d = max (abs (q.y - 3.) - 1.8, PrBox2Df (vec2 (abs (q.x) - wid,\n       abs (abs (q.z) - (2./3.) * len) - (1./3.) * len), vec2 (b)));\n    DMIN (idPil);\n  }\n  q = p;\n  q = vec3 (abs (q.x) - wid, q.y + 0.5, abs (abs (q.z) - 2. * len / 3.) - len / 3.);\n  d = max (PrBox2Df (q.xz, vec2 (b)), abs (q.y) - 1.6);\n  if (vuDir.y < 0.) d = max (d, - dot (q, vuPln));\n  DMIN (idPil);\n  q = p;\n  q = vec3 (abs (abs (q.x) - 2. * len / 3.) - len / 3., q.y + 1.1, abs (q.z) - wid);\n  d = max (PrBox2Df (q.xz, vec2 (b)), abs (q.y) - 2.);\n  if (vuDir.y > 0.) d = max (d, dot (q, vuPln));\n  DMIN (idPil);\n  q = p;\n  q.xy -= (vuDir.y > 0.) ? vec2 (-1.3, 1.) : vec2 (-2.39, -2.);\n  d = abs (q.y) - ((vuDir.y > 0.) ? 1.3 : 2.7);\n  q.xy = Rot2D (q.xy, 0.1 * pi);\n  d = max (d, PrBox2Df (vec2 (q.x, abs (q.z) - ((vuDir.y > 0.) ? 0.3 : 0.28)), vec2 (0.05)));\n  ds = (vuDir.y > 0.) ? max (PrCylDf (vec3 (q.x, mod (q.y + 0.1, 0.4) - 0.21, q.z), 0.03, 0.3),\n     abs (q.y + 1.) - 2.2) : max (PrCylDf (vec3 (q.x, Rot2D (vec2 (mod (q.y + 0.15, 0.4) - 0.2, q.z),\n     -0.019 * pi * (q.y + 0.9))), 0.03, 0.3), abs (q.y - 1.) - 2.2);\n  d = min (d, ds);\n  DMIN (idLad);\n  if (pengOn[0]) {\n    q = p - vec3 (-4.1, -4.8, -1.7);\n    dMin = PengDf (q, 0.3, 0.45 * pi, 1, dMin);\n  }\n  if (pengOn[1] && vuDir.y > 0. || pengOn[2] && vuDir.y < 0.) {\n    q = p - ((vuDir.y > 0.) ? vec3 (-0.6, 1.3, 0.9) : vec3 (-2.5, -2.9, -0.9));\n    dMin = PengDf (q, 0.35, ((vuDir.y > 0.) ? 0.6 * pi : 0.), 0, dMin);\n  }\n  if (pengOn[3] && vuDir.y > 0. || pengOn[4] && vuDir.y < 0.) {\n    q = p - ((vuDir.y > 0.) ? vec3 (0.3, 1.3, -3.3) : vec3 (3.3, -2.9, -0.3));\n    dMin = PengDf (q, 0.35, ((vuDir.y > 0.) ? 0. : -0.3 * pi), 0, dMin);\n  }\n  if (pengOn[5] || pengOn[6]) {\n    q = p - vec3 (-3., -5.1, -6.8);\n    if (pengOn[5] && pengOn[6]) q.z = (abs (q.z) - 1.33) * sign (q.z);\n    else q.z -= pengOn[5] ? 1.33 : -1.33;\n    dMin = PengDf (q, 0.4, 0.7 * pi, 0, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.6 + 0.4 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec4 PengCol (vec3 p)\n{\n  vec4 col4;\n  if (idObj == idPen + 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n     vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.15, 0.15, 0.2, 0.1);\n  else if (idObj == idPen + 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n  else if (idObj == idPen + 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);\n  else if (idObj == idPen + 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n  else if (idObj == idPen + 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n  else if (idObj == idPen + 6) col4 = vec4 (0.25, 0.25, 0.3, 0.1);\n  return col4;\n}\n\nvec4 BldgCol (vec3 vn)\n{\n  vec4 col4;\n  if (idObj == idFlr) col4 = (vn.y > -0.99) ? vec4 (0.9, 0.85, 0.85, 0.1) :\n     vec4 (1., 0.3, 0., 0.2);\n  else if (idObj == idBal) col4 = vec4 (0.6, 0.3, 0.1, 0.2);\n  else if (idObj == idLBld) col4 = (abs (qHit.x) < 3.8 && abs (qHit.z) < 0.8) ?\n     vec4 (0., 0., 0.4, 0.) : vec4 (0.85, 0.8, 0.8, 0.2);\n  else if (idObj == idLad) col4 = vec4 (0.95, 0.95, 1., 0.2);\n  else if (idObj == idGrnd) col4 = vec4 (0.7, 0.8, 0.7, 0.1) *\n     (1. - 0.2 * abs (dot (floor (mod (0.75 * qHit.xz, 2.)), vec2 (1., -1.))));\n  else if (idObj == idWal) col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n  else if (idObj == idPil) col4 = vec4 (1., 0.8, 0.2, 0.1);\n  else if (idObj == idStr) col4 = (abs (qHit.x) > 0.85) ? vec4 (0.9, 0.85, 0.85, 0.2) :\n     vec4 (0.6, 0.7, 0.6, 0.1);\n  else if (idObj == idRf) col4 = vec4 (1., 0.3, 0., 0.2);\n  else if (idObj == idFrz) col4 = vec4 (0.9, 0.5, 0., 0.2);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec3 bgCol)\n{\n  vec4 col4;\n  vec3 colD[2], col, roo, vn;\n  float dstObj, ao, tCyc, bt;\n  fAng = -0.2 * pi + 0.15 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (8. * pi * tCur);\n  tCyc = 15.;\n  for (int k = 0; k < N_PENG; k ++) {\n    pengOn[k] = (Hashff (floor (tCur / (0.5 * tCyc)) + 11.1 * float (k)) > 0.5);\n    if (sFrame > 0.) pengOn[k] = ! pengOn[k];\n  }\n  roo = ro;\n  bt = SmoothBump (0.25, 0.75, 0.1, mod (tCur / tCyc + 0.25, 1.));\n  colD[0] = vec3 (0.);\n  colD[1] = vec3 (0.);\n  for (int j = VAR_ZERO; j < 2; j ++) {\n    for (int k = 0; k < N_PENG; k ++) pengOn[k] = ! pengOn[k];\n    if (j == 0 && bt < 1. || j == 1 && bt > 0.) {\n      ro = roo;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = (idObj < idPen) ? BldgCol (vn) : PengCol (ro);\n        if (idObj == idLBld || idObj == idFlr || idObj == idWal) vn = VaryNf (16. * ro, vn, 0.5);\n        ao = (idObj != idLad) ? ObjAO (ro, vn) : 1.;\n        colD[j] = ao * (col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n           col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n      } else {\n        colD[j] = bgCol;\n      }\n    }\n  }\n  col = mix (colD[0], colD[1], bt);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvec3 BgCol (vec2 uv)\n{\n  return (uv.y + 0.05 < 0.05 * Fbm1 (32. * uv.x)) ? mix (mix (vec3 (0.3, 0.5, 0.3),\n     vec3 (0.2, 0.5, 0.2), smoothstep (0.4, 0.6, Fbm2 (256. * uv))),\n     vec3 (0.85, 0.85, 1.) * (1. - 0.05 * Fbm1 (128. * uv.x)),\n     smoothstep (-0.1, -0.01, uv.y + 0.05)) : mix (vec3 (0.7, 0.7, 0.8), vec3 (0.4, 0.4, 1.),\n     uv.y + 0.05);\n}\n\n#define AA  0  // optional antialiasing (risky!)\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col, bgCol, vx, vy;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr, df;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  az = 0.25 * pi;\n  el = 0.;\n  ro = vec3 (0., - 1.5 * sign (uv.y), -10.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  rd = normalize (- ro);\n  vuDir = rd;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  vuPln = vy;\n  zmFac = 0.15;\n  dstFar = 30.;\n  ltDir = normalize (vec3 (-0.5, 0.7, -1.));\n  sFrame = sign (uv.x);\n  uv.x -= 0.85 * sFrame;\n  df = max (abs (uv.x) - 0.76, abs (uv.y) - 0.96);\n  if (df < 0.) {\n    bgCol = BgCol (uv);\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, rd, bgCol);\n    }\n  } else if (df < 0.02) {\n    col = vec3 (0.6, 0.4, 0.1) * (0.6 + 0.4 * smoothstep (0., 0.02, df));\n  } else col = vec3 (0.75);\n  fragColor = vec4 (col, 1);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrFlatCyl2Df (vec2 p, float rhi, float rlo)\n{\n  return length (p - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyzs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1093, 1093, 1163, 1163, 2863], [2865, 2865, 2917, 2917, 3069], [3071, 3071, 3093, 3093, 7696], [7698, 7698, 7731, 7731, 7913], [7915, 7915, 7936, 7936, 8191], [8193, 8193, 8225, 8225, 8428], [8430, 8430, 8453, 8453, 8971], [8973, 8973, 8997, 8997, 9896], [9898, 9898, 9945, 9945, 11231], [11233, 11233, 11255, 11255, 11586], [11638, 11638, 11694, 11694, 13012], [13014, 13014, 13046, 13046, 13146], [13148, 13148, 13181, 13181, 13270], [13272, 13272, 13305, 13305, 13332], [13334, 13334, 13376, 13376, 13427], [13429, 13429, 13488, 13488, 13578], [13580, 13580, 13631, 13631, 13697], [13699, 13699, 13734, 13734, 13796], [13798, 13798, 13843, 13843, 13946], [13948, 13948, 14005, 14005, 14088], [14090, 14090, 14120, 14120, 14233], [14267, 14267, 14291, 14291, 14328], [14330, 14330, 14354, 14354, 14407], [14409, 14409, 14433, 14433, 14545], [14547, 14547, 14572, 14572, 14718], [14720, 14720, 14745, 14745, 14931], [14933, 14933, 14955, 14955, 15109], [15111, 15111, 15132, 15132, 15287], [15289, 15289, 15318, 15318, 15530], [15532, 15532, 15571, 15571, 15751]], "test": "untested"}
{"id": "ttsyzs", "name": "Michael's Cool Algorithm", "author": "wyatt", "description": ".", "tags": ["virtualtracking"], "likes": 15, "viewed": 484, "published": 3, "date": "1592858355", "time_retrieved": "2024-07-30T20:59:40.780603", "image_code": "Main {\n    R = iResolution.xy;\n\tQ = texture(iChannel1,U/R);\n    Q.x = .4*log(1.+Q.x);\n    Q = Q.x*(0.6+0.4*cos(1.2*Q.w*vec4(1,2,3,4)));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog (U,a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog (U,a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog2 (U,a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog2 (U,a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 M;\nfloat T;\nint I;\n#define A(U) texture(cha,(U)/R)\n#define B(U) texture(chb,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\nfloat signe (float x) {return atan(100.*x);}\nvoid prog (vec2 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = vec4(0); b = vec4(0);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 aa = A(U+u), bb = B(U+u);\n        aa.xy += aa.zw;\n        #define q clamp(bb.x,1.,1.1)\n\t\tvec4 w = clamp(vec4(aa.xy-0.5*q,aa.xy+0.5*q),U.xyxy - 0.5,U.xyxy + 0.5);\n        float m = (w.w-w.y)*(w.z-w.x)/(q*q);\n        aa.xy = 0.5*(w.xy+w.zw);\n        a += aa*bb.x*m;\n        b.x += bb.x*m;\n        b.yzw += bb.yzw*bb.x*m;\n    }\n    if (b.x>0.) {\n        a/=b.x;\n        b.yzw/=b.x;\n    }\n}\nvoid prog2 (vec2 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = A(U); b = B(U);\n    vec2 f = vec2(0); float m = 0.;\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    \n    if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 aa = A(U+u), bb = B(U+u);\n        f += .01*(bb.x*(.05-.01*bb.x))*u;\n        m += bb.x;\n    }\n    if (m>0.) a.zw += f;\n    \n    \n    // Boundaries:\n   \ta.w -= .1/R.y*signe(b.x);\n    if (a.x<10.) {a.z -= -.1;b.z*=0.9;}if (R.x-a.x<10.) {a.z -= .1;b.z*=0.9;}if (a.y<10.) {a.w -= -.05;b.z*=0.9;}if (R.y-a.y<10.) {a.w -= .1;b.z*=0.9;}\n    if (I<1||U.x<1.||R.x-U.x<1.||R.y-U.y<1.||R.x-U.x<1.) {\n    \ta = vec4(U,0,0);\n        b = vec4(0);\n        if (length(U-0.5*R) < 0.4*R.y) b.x = 15.;\n        if (U.x<0.5*R.x) b.w = 1.;\n    }\n    if (M.z>0. && length(U-M.xy) < 20.) {\n        b.x = 2.;\n        a.xy = U;\n        a.zw = .6*vec2(cos(.1*T),sin(.1*T));\n        b.w = 2.;\n    }\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlscRs", "name": "Rainy jungle", "author": "jarble", "description": "This is a simple demo of a 3-dimensional rain effect.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "rain", "jungle"], "likes": 1, "viewed": 329, "published": 3, "date": "1592855676", "time_retrieved": "2024-07-30T20:59:41.536582", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nconst float scale = 1.0;\nint surface_color;\n\nvec3 jungle_color(vec3 p)\n{\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\nvec3 animate_rain(vec3 p){\n    p.y -= iTime*200.0;\n    vec3 p1 = p/100.0;\n    p += vec3(sin(p1+p1.yzx))*33.33;\n    return p;\n}\n\nvec3 rain_color(in vec3 uv)\n{\n    uv /= scale;\n    uv = animate_rain(uv);\n    //uv /= scale;\n    \n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(sin(vec2(uv.x, uv.y)));\n        uv.x = uv.y + uv.x;\n        uv.y = uv.x - uv.y;\n    }\n    return vec3((lar * .5), lar*.7, lar)*1.5;\n}\n\n\nfloat rainSDF(vec3 p) {\n    p /= scale;\n    p = animate_rain(p);\n\n    float to_return = 3.9 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n    return to_return * scale;\n}\n\n\nfloat jungleSDF(vec3 p) {\n    p /= 40.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  3.9 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat sceneSDF(vec3 p){\n    float jungle = jungleSDF(p);\n    float rain = rainSDF(p);\n\tfloat to_return = min(jungle,rain);\n    if(to_return == jungle){\n    \tsurface_color = 1;\n    }\n    else{\n    \tsurface_color = 2;\n    }\n    return to_return;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 bump_map(vec3 p3)\n{\n  \t//return vec3(0.0);\n    p3 *= 20.0;\n    return (sin(p3)+sin(p3))/10.0;\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return bump_map(p) + normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float t1 = iTime/3.0;\n    vec3 eye = vec3(sin(t1/5.0)*2.0, cos(t1/5.0)*2.0, -t1)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a;\n    if(surface_color == 1) K_a = jungle_color(p);\n    if(surface_color == 2) K_a = rain_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlscRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 321, 321, 684], [930, 930, 956, 956, 1056], [1058, 1058, 1087, 1087, 1384], [1387, 1387, 1410, 1410, 1578], [1581, 1581, 1606, 1606, 1731], [1733, 1733, 1756, 1756, 1978], [1980, 2401, 2492, 2492, 2853], [2868, 3122, 3187, 3187, 3319], [3321, 3321, 3345, 3368, 3421], [3423, 3512, 3541, 3541, 3865], [3867, 4359, 4499, 4499, 5089], [5091, 5461, 5546, 5546, 6304], [6306, 6633, 6682, 6717, 6848], [6850, 6850, 6907, 6907, 8025]], "test": "untested"}
{"id": "ttsyzM", "name": "Game Console Chat", "author": "dean_the_coder", "description": "Game Console-powered webcam.\nIntended for video meetings using iq's MemixApp.\nThanks to Evvvvil (Glow Broski!), Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!", "tags": ["procedural", "3d", "raymarch", "retro", "gameboy", "webcam"], "likes": 21, "viewed": 1241, "published": 3, "date": "1592849222", "time_retrieved": "2024-07-30T20:59:42.407254", "image_code": "// Game Console-powered webcam.\n// Intended for video meetings using iq's MemixApp.\n// Thanks to Evvvvil (Glow Broski!), Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat glow = 0.0;\nfloat pathGlow = 0.0;\nfloat terrainGlow = 0.0;\n\n#define gt (mod(iTime, 10.0))\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.x -= clamp(p.x, 0.0, h);\n  return length(p) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 min4(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec3 sdScreen(vec3 p, vec3 box) {\n    box *= vec3(0.85, 0.45, 0.05);\n    p += vec3(0.0, -0.8, 0.27);\n    return vec3(sdBox(p, box) - 0.025, p.x / box.x * 0.5, p.y / box.y * 0.5);\n}\n\nfloat sdButton(vec3 p) {\n    float d = sdCylinder(p, 0.08, 0.08) - 0.05;\n    float r = 2.0;\n    return smin(d, -sdSphere(p + vec3(0.0, 0.0, r + 0.1), r), -0.05);\n}\n\nfloat sdControls(vec3 p) {\n    // D-pad\n    vec3 pp = p + vec3(0.55, 0.45, 0.37);\n    vec3 dpad = vec3(0.1, 0.3, 0.1);\n    float d = min(sdBox(pp, dpad), sdBox(pp, dpad.yxz));\n    float r = 2.0;\n    d = smin(d, -sdSphere(pp + vec3(0.0, 0.0, r), r), -0.05);\n    r = 0.17;\n    d = max(d, -sdSphere(pp + vec3(0.0, 0.0, r * 0.9), r));\n    \n    // Fire buttons.\n    d = min(d, sdButton(p + vec3(-0.32, 0.5, 0.3)));\n    d = min(d, sdButton(p + vec3(-0.7, 0.35, 0.3)));\n\n    // Start/select.\n    p += vec3(0.0, 1.15, 0.34);\n    p.x = abs(p.x) - 0.12;\n    d = min(d, sdCapsule(p, 0.2, 0.06));\n    \n    return d;\n}\n\nvec4 sdCase(vec3 p) {\n    const float height = 3.4;\n    \n    p.yz *= rot(sin(fract(iTime * 0.1) * 6.283) * 0.1);\n    p.xz *= rot(sin(fract(iTime * 0.2) * 6.283) * 0.2);\n    \n    // Front base.\n    vec3 pp = p;\n    pp.z += pp.z < 0.0 ? (abs(0.5 + 0.5 * cos(pp.y * 0.7)) - 1.0) * max(0.0, (-pp.y - 1.3) / height * 2.0) : 0.0;\n    \n    float edgeIndent = sin(3.14159 * smoothstep(-0.10, -0.04, pp.z)) * 0.005;\n    vec3 box = vec3(1.0, height / 2.0, 0.2);\n    float d = sdBox(pp, box - vec3(edgeIndent, edgeIndent, 0.0)) - 0.1;\n    \n    // P1 P2\n    pp = p + vec3(0.00, 0.99, 0.37);\n    d = max(d, -sdSphere(pp + vec3(0.22, 0.0, 0.0), 0.08));\n    pp.x = abs(pp.x - 0.22) - 0.06;\n    d = max(d, -sdSphere(pp + vec3(0.0, 0.0, 0.0), 0.08));\n\n#if 0\n    // Rear bump.\n    d = smin(d, sdBox(p - vec3(0.0, -0.3, 0.4), box * vec3(0.90, 0.7, 0.2)) - 0.05, 0.2);\n#endif\n    \n    // Power light.\n    float power = sdSphere(p - vec3(-0.75, 1.4, -0.3), 0.03);\n    glow += 0.01 / (0.01 + power * power * 400.0);\n    \n    // Screen indent.\n    return min4(min4(min4(vec4(d, 1.5, 0.0, 0.0), vec4(sdScreen(p, box), 2.5).xwyz), vec4(power, 3.5, 0.0, 0.0)), vec4(sdControls(p), 4.5, 0.0, 0.0));\n}\n\nvec2 sdTraveller(vec3 p) {\n    p.z = mod(p.z + gt * 40.0, 50.0) - 25.0;\n    \n    float open = abs(sin(gt * 4.0));\n    \n    vec3 pp = p;\n    pp.yz *= rot(open);\n    float bodyTop = max(sdSphere(pp, 1.3), -pp.y);\n    \n    pp.yz += vec2(-0.6, 1.0);\n    pp.x = abs(pp.x) - 0.6;\n    float eyes = sdSphere(pp, 0.2);\n    \n    p.yz *= rot(-open);\n    float bodyBottom = max(sdSphere(p, 1.3), p.y);\n    \n    float body = min(bodyTop, bodyBottom);\n   \n    return min2(vec2(body, 6.0), vec2(eyes, 4.0));\n}\n\nvec2 sdRoad(vec3 p) {\n    p.x += 8.0;\n    p.xz *= rot(-0.75 + sin(p.z * 0.1) * 0.06);\n    \n    p.y += sin(p.z * 0.1);\n\n    // Road.\n    p.y += 4.0;\n    \n    vec3 pp = p;\n    pp.x = abs(pp.x) - 2.0;\n    float d1 = length(pp.xy) - 0.3;\n    \n    // Traveller.\n    p.z -= 10.0;\n    p.y -= 1.0;\n    vec2 d2 = sdTraveller(p);\n    \n    // Glow.\n    pathGlow += 0.1 / (0.1 + d1 * d1 * 5.0);\n    \n    return min2(vec2(d1, 5.0), d2);\n}\n\nvec2 sdTerrain(vec3 p) {\n    p.y += 5.0;\n    p.z += iTime;\n    \n    p.xz = mod(p.xz, 5.0) - 2.5;\n\n    float d = min(length(p.xy), length(p.yz));\n    \n    terrainGlow += 0.001 / (0.001 + d * d * 5.0);\n    \n    return vec2(d, 3.5);\n}\n\nvec4 map(vec3 p) {\n    return min4(min4(sdCase(p), vec4(sdRoad(p), 0.0, 0.0)), vec4(sdTerrain(p), 0.0, 0.0));\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.01;\n    for (int i = 0; i < 5; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.08;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 getWebCam(vec2 uv) {\n    if (iTime < 5.0) return vec3(0.01);\n    if (iTime < 6.0) return vec3(0.03);\n    \n    ivec2 t = textureSize(iChannel0, 0);\n    float ar = float(t.y) / float(-t.x);\n    \n    const vec2 res = vec2(160.0, 144.0) * 0.4;\n    uv = floor(uv * res) / res;\n    \n    vec3 col = texture(iChannel0, (uv * vec2(ar, 1.0) + vec2(0.5))).rgb;\n    col = floor(col * 12.0) / 12.0;\n    \n    return mix(vec3(0.03), col, clamp(iTime - 7.0, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    // Raymarch.\n    vec3 ro = vec3(0.0, 1.0, -4.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, 0.2, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    float steps;\n    vec2 puv;\n    for (steps = 0.0; steps < 55.0; steps++) {\n        p = ro + rd * d;\n        vec4 h = map(p);\n\n        if (h.x < 0.001 * d) {\n            hit = int(h.y);\n            puv = h.zw;\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(3.0, 3.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.05);\n        float occ = calcOcc(p, n, 20.0);\n        float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Case\n            mat = vec3(0.1, 0.8, 0.15);\n        } else if (hit == 2) {\n            // Screen.\n            vec2 uv = (puv - vec2(0.0, 0.05)) * 1.4;\n            mat = abs(uv.x) < 0.5 && abs(uv.y) < 0.5 ? getWebCam(uv) : vec3(0.0);\n            \n            if (puv.y < -0.36 && puv.y > -0.45) {\n                puv.x = (puv.x - 0.45) * 15.0 - puv.y * 8.0;\n                if (puv.x > 0.0 && puv.x < 3.0)\n                {\n                    switch(int(puv.x)) {\n                        case 0: mat = vec3(1.0, 0.0, 0.0); break;\n                        case 1: mat = vec3(0.0, 1.0, 0.0); break;\n                        case 2: mat = vec3(0.0, 0.0, 1.0); break;\n                    }\n                }\n            }\n        } else if (hit == 3) {\n            // Power light.\n            mat = vec3(0.1);\n        } else if (hit == 4) {\n            // Controls.\n            mat = vec3(0.1);\n        } else if (hit == 5) {\n            // Road.\n            mat = vec3(0.7);\n        } else if (hit == 6) {\n            // Traveller.\n            mat = vec3(0.7, 0.7, 0.1) * 2.0;\n        }\n        \n        col = (mainLight + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col = mix(col * mat, vec3(0.0), fog);\n    }\n    \n    // Glow.\n    if (iTime < 5.0) glow = 0.0;\n    col += (glow + terrainGlow) * vec3(0.7, 0.1, 0.1);\n    col += pathGlow * vec3(0.1, 0.1, 0.8);\n\n    // Output to screen\n    col = pow(vignette(col, fragCoord), vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[385, 385, 424, 424, 527], [529, 529, 548, 548, 624], [626, 626, 659, 659, 687], [689, 689, 720, 720, 813], [815, 815, 859, 859, 972], [974, 974, 1017, 1017, 1072], [1074, 1074, 1121, 1121, 1326], [1328, 1328, 1355, 1355, 1387], [1389, 1389, 1416, 1416, 1448], [1450, 1450, 1483, 1483, 1630], [1632, 1632, 1656, 1656, 1795], [1797, 1797, 1823, 1836, 2402], [2404, 2404, 2425, 2425, 3577], [3579, 3579, 3605, 3605, 4073], [4075, 4075, 4096, 4096, 4500], [4502, 4502, 4526, 4526, 4733], [4735, 4735, 4753, 4753, 4846], [4848, 4848, 4876, 4894, 5094], [5096, 5096, 5154, 5154, 5452], [5454, 5454, 5501, 5501, 5590], [5680, 5680, 5721, 5721, 5862], [5864, 5864, 5889, 5889, 6324], [6326, 6326, 6383, 6383, 9057]], "test": "untested"}
{"id": "wlscRl", "name": "Euler's Identity ", "author": "jeyko", "description": "potato", "tags": ["pi", "i", "euler", "mdtmjvm"], "likes": 8, "viewed": 365, "published": 3, "date": "1592837544", "time_retrieved": "2024-07-30T20:59:43.445478", "image_code": "// Great lecture on the subject! https://youtu.be/ZxYOEwM6Wbk?t=2177\n\n\n#define rot(j) mat2(cos(j),sin(j),sin(j),cos(j))\n\n#define pi acos(-1.)\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + b.y*b.x ); }\n// cpolar() and cpow() I borrowed from some shader on shadertoy! not sure which\nvec2 cpolar( float k , float t ){  return k*vec2(cos(t),sin(t));}\nvec2 cpow( vec2 z , float k ) { return cpolar(pow(length(z),k) , k*atan(z.y,z.x) ); }\n\n\nfloat factoriel(float a){\n\tfloat f = 1.;\n    for(float i = 1.; i <= a; i++){\n    \tf *= i;\n    }\n    return f;\n}\n\n// from iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n        \n    \n    vec2 z = vec2(1,0.);\n    \n    \n    \n    col = mix(col,vec3(1.,1.,1.),smoothstep(1.*dFdx(uv.x),0.,abs(length(uv.x)) - 0.002));\n    \n    col = mix(col,vec3(1.,1.,1.),smoothstep(1.*dFdx(uv.x),0.,abs(length(uv.y)) - 0.002));\n    \n    float modD = 0.125;\n    col = mix(col,vec3(1.,1.,1.),smoothstep(1.*dFdx(uv.x),0.,max(\n        abs(length(mod(uv.x - modD/2.,modD) - modD/2.)) - 0.002,\n        abs(uv.y) - 0.01                                            )));\n    \n    col = mix(col,vec3(1.,1.,1.),smoothstep(1.*dFdx(uv.x),0.,max(\n        abs(length(mod(uv.y - modD/2.,modD) - modD/2.)) - 0.002,\n        abs(uv.x) - 0.01                                            )));\n    \n    \n    col = mix(col,vec3(0.2,0.4,0.9),smoothstep(1.*dFdx(uv.x),0.,abs(length(uv) - 0.25) - 0.002));\n    \n    \n    // lines\n    \n    float dotSz = 0.01;\n    \n    float dDots = length(uv - z/4.) - dotSz;\n    float dLines = 10e5;\n    float theta = pi*1. - sin(iTime/2.)*pi*0.75;\n    vec2 numerator = vec2(0,theta);\n    for(float i = 1.; i < 20.; i++){\n        vec2 denominator = vec2(factoriel(i),0.);\n        vec2 oldz = z;\n        z +=  cpow(numerator,i) / denominator.x;\n   \t\t\n        dLines = min(dLines, sdSegment(uv,oldz/4.,z/4.) - 0.002);\n        dDots = min(dDots, length(uv - z/4.) - dotSz);\n    \n    }\n    \n    col = mix(col,vec3(1.,0.4,0.2),smoothstep(1.*dFdx(uv.x),0.,dLines));\n    col = mix(col,vec3(1.,0.2,0.4),smoothstep(1.*dFdx(uv.x),0.,dDots));\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 173, 173, 228], [229, 309, 342, 342, 374], [375, 375, 406, 406, 460], [463, 463, 488, 488, 574], [576, 587, 639, 639, 758], [761, 761, 818, 818, 2431]], "test": "untested"}
{"id": "WlscRs", "name": "Digit rendering", "author": "luluco250", "description": "If anyone can figure out why using a `switch` causes the center pixels to not render, I'd be very thankful.", "tags": ["2d", "text", "digit"], "likes": 2, "viewed": 298, "published": 3, "date": "1592828936", "time_retrieved": "2024-07-30T20:59:44.459766", "image_code": "// Set to 1 to see a very weird bug when using\n// a switch over a series of ifs.\n#define USE_SWITCH 0\n\nconst ivec2 CharSize = ivec2(3, 5);\nconst int CharArraySize = CharSize.x * CharSize.y;\n\nconst int _0[] = int[CharArraySize](\n\t1, 1, 1,\n    1, 0, 1,\n    1, 0, 1,\n    1, 0, 1,\n    1, 1, 1\n);\n\nconst int _1[] = int[CharArraySize](\n\t0, 0, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1\n);\n\nconst int _2[] = int[CharArraySize](\n\t1, 1, 1,\n    0, 0, 1,\n    1, 1, 1,\n    1, 0, 0,\n    1, 1, 1\n);\n\nconst int _3[] = int[CharArraySize](\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1\n);\n\nconst int _4[] = int[CharArraySize](\n    1, 0, 1,\n    1, 0, 1,\n    1, 1, 1,\n    0, 0, 1,\n    0, 0, 1\n);\n\nconst int _5[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 0,\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1\n);\n\nconst int _6[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 0,\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1\n);\n\nconst int _7[] = int[CharArraySize](\n    1, 1, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1\n);\n\nconst int _8[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1\n);\n\nconst int _9[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1\n);\n\nconst int _Empty[] = int[CharArraySize](\n    0, 0, 0,\n    0, 0, 0,\n    0, 0, 0,\n    0, 0, 0,\n    0, 0, 0\n);\n\nconst int RainbowColorCount = 7;\n\nconst vec3 RainbowColors[] = vec3[RainbowColorCount](\n    vec3(1, 0, 0),\n    vec3(1, 0.5, 0),\n    vec3(1, 1, 0),\n    vec3(0, 1, 0),\n    vec3(0, 1, 1),\n    vec3(0, 0, 1),\n    vec3(0.5, 0, 1)\n);\n\nint[CharArraySize] GetDigitArray(int digit)\n{\n    #if USE_SWITCH\n        switch (digit)\n        {\n            case 0:\n                return _0;\n            case 1:\n                return _1;\n            case 2:\n                return _2;\n            case 3:\n                return _3;\n            case 4:\n                return _4;\n            case 5:\n                return _5;\n            case 6:\n                return _6;\n            case 7:\n                return _7;\n            case 8:\n                return _8;\n            case 9:\n                return _9;\n            default:\n                return _Empty;\n        }\n    #else\n        // I really, really hate OpenGL.\n        //\n        // For some reason using a switch causes the center pixels\n        // of the digits to not render and I have no idea why.\n        //\n        // So for now, we'll use ifs, maybe later use a single\n        // array with all the digits.\n\n        if (digit == 0)\n            return _0;\n\n        if (digit == 1)\n            return _1;\n\n        if (digit == 2)\n            return _2;\n\n        if (digit == 3)\n            return _3;\n\n        if (digit == 4)\n            return _4;\n\n        if (digit == 5)\n            return _5;\n\n        if (digit == 6)\n            return _6;\n\n        if (digit == 7)\n            return _7;\n\n        if (digit == 8)\n            return _8;\n\n        if (digit == 9)\n            return _9;\n\n        return _Empty;\n    #endif\n}\n\nint GetDigitPixel(int digit, ivec2 pos)\n{\n    return GetDigitArray(digit)[pos.x + CharSize.x * pos.y];\n}\n\nvoid RenderDigit(\n    inout vec4 color,\n    vec2 coord,\n    int digit,\n    ivec2 digitOffset,\n    int digitScale,\n    vec4 digitColor)\n{\n    ivec2 pos = ivec2(coord);\n    pos /= digitScale;\n    pos -= digitOffset;\n    \n    if (pos.x < 0 || pos.x >= CharSize.x || pos.y < 0 || pos.y >= CharSize.y)\n        return;\n    \n    float isDigit = float(GetDigitPixel(digit, pos));\n    color.rgb = mix(color.rgb, digitColor.rgb, isDigit * digitColor.a);\n}\n\nvec4 GetDigitColor(int index)\n{\n    index += int(iTime);\n    return vec4(RainbowColors[index % RainbowColorCount], 0.65);\n}\n\nvoid RenderTime(inout vec4 color, vec2 coord)\n{\n    const int Digits = RainbowColorCount;\n    \n    int t = int(iTime);\n    \n    for (int i = Digits - 1; i >= 0; --i)\n    {\n        RenderDigit(\n            color,\n            coord,\n            t % 10,\n            ivec2(i * 4, 0),\n            28,\n            GetDigitColor(i));\n        \n        t /= 10;\n    }\n}\n\nvoid RenderStaticSample(inout vec4 color, vec2 coord)\n{\n    for (int i = 0; i < RainbowColorCount; ++i)\n    {\n        RenderDigit(\n            color,\n            coord,\n            (i + int(iTime)) % 10,\n            ivec2(i * 4, 6),\n            28,\n            GetDigitColor(i));\n    }\n}\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    color = vec4(vec3(0.1), 1.0);\n    \n    // Ugly hack to use normalized coords.\n    vec2 uv = coord / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 450.0;\n    \n    RenderTime(color, uv);\n    \n    RenderStaticSample(color, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3021, 3021, 3062, 3062, 3125], [3127, 3127, 3263, 3263, 3572], [3574, 3574, 3605, 3605, 3697], [3699, 3699, 3746, 3746, 4059], [4061, 4061, 4116, 4116, 4348], [4350, 4350, 4394, 4394, 4671]], "test": "untested"}
{"id": "3llyzs", "name": "Disintegrating Holed Cylinder", "author": "Leria", "description": "An easy raw mix of 2 shaders", "tags": ["noise", "cylinder"], "likes": 0, "viewed": 323, "published": 3, "date": "1592828230", "time_retrieved": "2024-07-30T20:59:45.436155", "image_code": "//from https://www.shadertoy.com/view/lssSRn by FabriceNeyret2\n\n#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\n\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\n\nvec2 sphere1Pos = vec2(0.,0.);\nfloat sphere1Rad = .7;         // sphere radius\n\nfloat planePos = .1;\n\nvec2 sphere2Pos = vec2(1.,0.);\nfloat sphere2Rad = .2;         \n\n// cloud appearance (superseeded by mouse tuning)\n\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\nfloat sharp = 0.9;            // cloud sharpness (0= ultra sharp ).\n\n\n\n#define ANIM 1         // 1/0\n\n#define PI 3.14159\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )  // base rand in [0,1]; \n{\n    return fract(sin(n-765.36334)*43758.5453);\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\n}\n\nfloat noise( in vec3 x ) // base noise in [0,1]; \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE==1\n\treturn res;\n#elif NOISE==2\n\treturn abs(2.*res-1.);\n#elif NOISE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n\n\n// smooth distance to sphere = [-1,1] around radius +- thickness H\n\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\n{\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\n\tfloat d = (1.-length(p))/H;  \n\treturn clamp(d,-1.,1.);\n}\n\t\t\n// smooth distance to plane = [-1,1] around plane +- thickness H\n\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\n{\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\n\tfloat d = -p.x/(H*planeRad);  \n\treturn clamp(d,-1.,1.);\n}\n\t\n// smooth intersect operator\n\nfloat inter(float d0, float d1) {\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*d0*d1 -1.;\n}\n\n// smooth union operator\n\nfloat add(float d0, float d1) {\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*(d0+d1-d0*d1) -1.;\n}\n\n// jitter the distance around 0  and smoothclamp\n\nfloat perturb(vec2 p, float d, float H) {\n#if ANIM\n   float t = iTime;\n#else\n  float t = 0.; \n#endif\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\n\t\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\n}\n\n// convert [-1,1] distances into densities\n\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\n\treturn smoothstep(-sharp,sharp,d);\n}\n\n\n// user-define shape\n\t\nfloat shape(vec2 uv,float n) {\n\t\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\n\tfloat v;\n\n#define globalNoise false\n\t\n\tif (globalNoise || (n==0.)) {\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\n\t}\n\telse {\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\n\t}\n\t\n\treturn v;\n}\n\n// main loop\n\nvec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n\nconst vec3 cam = vec3(0., 0., 10.);\nfloat uniform_step = .5;\nvoid draw_disk(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing\n    vec3 p = cam+dir*antialiasing;\n    float s = 0.;\n  \t\n    \n    for(s; s < 150.; s++)\n    {               \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p, p);\n        float dist_center = length(center-cam);\n        \n        vec2 nu = polar_coord(p-(center));\n\n        //if too far, then big step\n        \n        if(sqrt(dist_dist) < (dist_center-radius))\n        {\n        \tk_step = dist_center-radius;\n        }\n\n        //if in the shape, draw\n        else if( (length(nu) - 5. <= 0.) && (length(nu) - 2.5 >= 0.) && (distance(p.y, center.y) < 2.))\n        {\n        \tc += 0.2*vec3(0.4, 0.4, 0.6);\n        }   \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p) > (dist_center+radius))\n        {\n         \tbreak;   \n        }\n        \n        p += dir*k_step;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    \n   \tif (iMouse.z>0.)\n    {       \t\t\t\t   // mouse tuning\n\t\tvec2 m = iMouse.xy / iResolution.xy;\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \n\t}\n\n\tfloat v = dist2dens( shape(uv,1.) ); \n\tvec3 col = vec3(v);\n    \n    draw_disk(normalize(vec3(uv, -1.)), vec3(0., 0., 0.), vec3(0., 1., 0.), 30., color);\n    \n    fragColor = vec4(min(color, max(vec3(0.), col)), 1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[991, 991, 1039, 1039, 1144], [1146, 1146, 1197, 1197, 1700], [1702, 1702, 1764, 1764, 1947], [2079, 2079, 2135, 2135, 2269], [2339, 2339, 2441, 2441, 2572], [2605, 2605, 2638, 2638, 2747], [2775, 2775, 2806, 2806, 2923], [2975, 2975, 3016, 3016, 3358], [3404, 3404, 3430, 3477, 3515], [3541, 3541, 3571, 3571, 4128], [4144, 4144, 4170, 4170, 4318], [4381, 4381, 4461, 4461, 5443], [5445, 5445, 5502, 5502, 5951]], "test": "untested"}
{"id": "Wtlczl", "name": "Light2D", "author": "xach", "description": "GLSL implementation of https://github.com/miloyip/light2d/blob/master/csg.c", "tags": ["2d", "math", "light"], "likes": 3, "viewed": 300, "published": 3, "date": "1592814410", "time_retrieved": "2024-07-30T20:59:46.359686", "image_code": "const float MAX_STEP = 30.0;\nconst float MAX_DISTANCE = 1.0;\nconst float EPSILON = 0.0001;\nconst float SAMPLES = 256.0;\n\nconst float TWO_PI = 6.28318530718;\n\nconst float BIAS = 1e-4f;\nconst int MAX_DEPTH = 2;\n\nvec2  m;\n\n\nstruct ssDot{float sd; float emission; float reflectivity;};\n\n\nssDot unionOp(ssDot a, ssDot b){\n    if (a.sd < b.sd){\n        return a;\n    }else{\n        return b;\n    }\n}\n\nfloat box(float x, float y, float cx, float cy, float theta, float sx, float sy) {\n    float costheta = cos(theta), sintheta = sin(theta);\n    float dx = abs(x - cx) - sx;\n    float dy = abs(y - cy) - sy;\n    float ax = max(dx, 0.0f), ay = max(dy, 0.0f);\n    return min(max(dx, dy), 0.0f) + length(vec2(ax, ay)) * ax + ay * ay;\n}\n\nfloat rectangle(vec2 samplePosition, vec2 cntr, vec2 halfSize){\n    vec2 componentWiseEdgeDistance = samplePosition - halfSize - cntr;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nfloat circle(in vec2 pos, in vec2 cntr, in float radius){\n    return distance(pos, cntr) - radius;\n}\n\nssDot scene(in vec2 pos){\n    ssDot r1 = ssDot(circle(pos,vec2(0.5,0.5), 0.25), 0.70, 0.2);\n    ssDot r2 = ssDot(circle(pos,m, 0.1), 1.0, 1.7);\n    ssDot r3 = ssDot(circle(pos,vec2(-0.4,0.0), 0.5), 1.0, 1.2);\n    ssDot r4 = ssDot(rectangle(pos,vec2(0.0,-0.1),vec2(0.05,0.35)), 0.70, 0.1);\n    return unionOp(unionOp(unionOp(r1, r2),r3),r4);\n}\n\n\nvoid gradient(float x, float y, out float nx, out float ny) {\n    nx = (scene(vec2(x + EPSILON, y)).sd - scene(vec2(x - EPSILON, y)).sd) * (0.5 / EPSILON);\n    ny = (scene(vec2(x, y + EPSILON)).sd - scene(vec2(x, y - EPSILON)).sd) * (0.5 / EPSILON);\n}\n\nfloat trace3(float ox,float oy, float dx, float dy, int depth){\n    float t = 0.0;\n    for(float i = 0.0; i < MAX_STEP && t < MAX_DISTANCE; i++){\n        float x = ox + dx * t;\n        float y = oy + dy * t;\n        ssDot r = scene(vec2(x,y));\n        if (r.sd < EPSILON){\n            float sum = r.emission;\n        \tif (depth < MAX_DEPTH && r.reflectivity > 0.0f) {\n//               float nx, ny, rx, ry;\n//                gradient(x, y, nx, ny);\n//                reflect(dx, dy, nx, ny, rx, ry);\n                sum += r.reflectivity;// * trace2(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1.0);\n            }\n            return sum;\n        }\n        t += r.sd;\n    }\n    return 0.0;\n}\n\nfloat trace2(float ox,float oy, float dx, float dy, int depth){\n    float t = 0.0;\n    for(float i = 0.0; i < MAX_STEP && t < MAX_DISTANCE; i++){\n        float x = ox + dx * t;\n        float y = oy + dy * t;\n        ssDot r = scene(vec2(x,y));\n        if (r.sd < EPSILON){\n            float sum = r.emission;\n        \tif (depth < MAX_DEPTH && r.reflectivity > 0.0f) {\n                float nx, ny, rx, ry;\n                gradient(x, y, nx, ny);\n                vec2 reflected = reflect(vec2(dx, dy), vec2(nx, ny));\n                sum += r.reflectivity * trace3(x + nx * BIAS, y + ny * BIAS, reflected.x, reflected.y, depth + 1);\n            }\n            return sum;\n        }\n        t += r.sd;\n    }\n    return 0.0;\n}\n\nfloat trace(float ox,float oy, float dx, float dy, int depth){\n    float t = 0.0;\n    for(float i = 0.0; i < MAX_STEP && t < MAX_DISTANCE; i++){\n        float x = ox + dx * t;\n        float y = oy + dy * t;\n        ssDot r = scene(vec2(x,y));\n        if (r.sd < EPSILON){\n            float sum = r.emission;\n        \tif (depth < MAX_DEPTH && r.reflectivity > 0.0f) {\n                float nx, ny, rx, ry;\n                gradient(x, y, nx, ny);\n               \tvec2 reflected = reflect(vec2(dx, dy), vec2(nx, ny));\n                sum += r.reflectivity * trace2(x + nx * BIAS, y + ny * BIAS, reflected.x, reflected.y, depth + 1);\n            }\n            return sum;\n        }\n        t += r.sd;\n    }\n    return 0.0;\n}\n\n\nfloat rand(){\n\treturn fract(sin(iTime)*100000.0);\n}\n\nfloat sampleFun(float x, float y){\n    float sum = 0.0;\n    for (float i = 0.0; i < SAMPLES; i++){\n        float a = TWO_PI*i/SAMPLES;\n        sum += trace(x, y, cos(a), sin(a),0);\n        if (sum > 1000.0){return sum/i;}\n    }\n                     \n    return sum / SAMPLES;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy ) / iResolution.y;\n    \n    m  = (2.*iMouse.xy-iResolution.xy ) / iResolution.y;\n\n    float v = sampleFun(uv.x, uv.y);\n    \n    // Time varying pixel color\n    vec3 col =vec3(v);\n\n    // Output to screen\n    fragColor = vec4(col,v);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtlczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 316, 316, 393], [395, 395, 477, 477, 724], [726, 726, 789, 789, 1080], [1082, 1082, 1139, 1139, 1182], [1184, 1184, 1209, 1209, 1526], [1529, 1529, 1590, 1590, 1780], [1782, 1782, 1845, 1845, 2474], [2476, 2476, 2539, 2539, 3197], [3199, 3199, 3261, 3261, 3919], [3922, 3922, 3935, 3935, 3973], [3975, 3975, 4009, 4009, 4252], [4254, 4254, 4311, 4403, 4686]], "test": "untested"}
{"id": "Wllyzl", "name": "joint probability in bluenoise", "author": "FabriceNeyret2", "description": "reading the blue noise texture as 4*1024 independent lines ( + cycling), plot the probability of value x knowing that the previous value was y.\nNB: result looks similar in R,G,B,A so I average. result also look similar columnwise.\nNot cycling: same result", "tags": ["bluenoise", "histogram", "probability"], "likes": 3, "viewed": 627, "published": 3, "date": "1592804437", "time_retrieved": "2024-07-30T20:59:47.148577", "image_code": "void mainImage(out vec4 O, in vec2 U) {\n    float t = texelFetch(iChannel0,ivec2(270),0).w;   // number or computed lines\n    U /= max(1.,floor(iResolution.y/256.));           // pixel-friendly zoom\n              \n    O = 25.* texelFetch(iChannel0,ivec2(U),0) / min(MAX,t); //  25 = 32-stddev\n    //O = step(vec4(1),O); return;         // check overflow ( to find the gain above )\n    O = vec4(O.r+O.g+O.b+O.a)/4.;          // average 4 channels\n  //O = pow(O, vec4(1./2.2));              // to sRGB\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define T(x,y) ivec4(round(255.*texelFetch(iChannel1, dir ? ivec2(x,y) : ivec2(y,x) ,0)))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( textureSize(iChannel1,1).x <2 ) {          // wait for texture load\n        if (U.y > 280.) O = vec4(int(U.x)<iFrame);  // waiting scroll \n        return;                           \n    }\n    ivec2 I = ivec2(U);\n    O = texelFetch(iChannel0,I,0);                  // previous state\n    if ( I==ivec2(270) ) O.w++;                     // frame counter\n    if (max(U.x,U.y) > 256.) return;                // only use 256x256 grid\n    float y = texelFetch(iChannel0,ivec2(270),0).w; // current treated line\n    if (y>=MAX) return;                             // scan finished.\n\n    bool dir = y<1024.;                             // if stats on lines then columns\n    ivec4 P,V = T(1023,y);\n    for (int x=0; x<1024; x++) {\n        P = V; \n     // P = T((x+OFS)%1024,y);\n        V = T(x,y);                                 // prev and cur values ( x4 channels )\n        for (int i=0; i < 4; i++ )\n            if ( I == ivec2(V[i],P[i]) ) O[i]++;    // add to joint histogramm\n   }      \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "  #define MAX 1024.   // stats only on lines\n//#define MAX 2048.   // stats on lines + columns\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wllyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 501]], "test": "untested"}
{"id": "3tlyzl", "name": "rtset", "author": "elmt", "description": "voronoi bump map mosaic ", "tags": ["voronoi", "shader"], "likes": 1, "viewed": 132, "published": 3, "date": "1592803548", "time_retrieved": "2024-07-30T20:59:47.903558", "image_code": "// July 2020\n// Ethan M\n\nconst float EPSILON = 0.01;\nconst int MAX_ITER = 400;\n\nconst vec2 RND_SEED = vec2(0.8388678474921857, 0.31300111519792606);\n\nstruct PointLight {\n    vec3 position;\n    float strength;\n};\n\nconst int LIGHT_COUNT = 2;\nconst PointLight lights[LIGHT_COUNT] = PointLight[](\n\tPointLight(vec3(0, 2, -0.1), 20.),\n    PointLight(vec3(-4, 0, 0), 11.)\n);\n\nvec3 rotateX(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float y = c * vec.y - s * vec.z, z = s * vec.y + c * vec.z;\n    \n    return vec3(vec.x, y, z);\n}\nvec3 rotateY(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x + s * vec.z, z = -s * vec.x + c * vec.z;\n    \n    return vec3(x, vec.y, z);\n}\nvec3 rotateZ(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x - s * vec.y, y = s * vec.x + c * vec.y;\n    \n    return vec3(x, y, vec.z);\n}\n\nfloat project(vec2 v0, vec2 v1, vec2 p) {\n    float dx = v0.x - v1.x, dy = v0.y - v1.y;\n    return 1.-((p.x*dx - v1.x*dx + p.y*dy - v1.y*dy)/(dx*dx + dy*dy));\n}\n\nfloat random(vec2 pos, float offset) {\n\treturn fract(sin(dot(pos, RND_SEED) * 640. + offset) * 640.);\n}\n\nfloat lighting(vec3 position, vec3 normal, float k) {\n    float mult = 0.0;\n    \n    for (int i = 0; i < LIGHT_COUNT; i++) {\n    \tPointLight light = lights[i];\n        \n        vec3 diff = light.position - position;\n        float diff_len = dot(diff, diff);\n        \n        float local = pow(dot(normal, normalize(diff)), k) / (diff_len) * light.strength;\n        \n        if (local > 0.0) { mult += local; }\n    }\n    \n    return mult;\n}\nfloat lighting(vec3 position, vec3 normal) { return lighting(position, normal, 1.); }\n\nconst float PI_6 = 0.5235987756;\nconst float SPHERE_RADIUS = 0.5;\nvec3 sphere_get_center() {\n\treturn vec3(1. + sin(iTime), -1. + cos(iTime / 2.) * 0.1, 4);\n}\nfloat sphereSDF(vec3 position) {\n\treturn length(sphere_get_center() - position) - SPHERE_RADIUS;\n}\nvec3 sphere_color(vec3 position) {\n    vec3 diff = position - sphere_get_center();\n    \n    vec2 m = diff.xz;\n    vec2 h = diff.yz;\n    \n    \n\treturn vec3(mod(floor((atan(m.y, m.x) - iTime) / PI_6), 2.));\n}\nvec3 sphere_normal(vec3 position) {\n    return normalize(position - sphere_get_center());\n}\n\nfloat wallSDF(vec3 position) {\n\treturn abs(5. - position.z);\n}\nfloat back_wallSDF(vec3 position) {\n    return abs(-4. - position.z);\n}\n\nconst float CHECKER_SIZE = 1.2;\nvec3 back_wall_color(vec3 position) {\n    float row = floor(position.x / CHECKER_SIZE);\n    float col = floor(position.y / CHECKER_SIZE);\n    bool is_black = mod(col, 2.) != mod(row, 2.);\n    return vec3(is_black ? 0. : 1.);\n}\n\nconst float VORONOI_CELL_SIZE = .76;\nconst int VORONOI_SEARCH_DEPTH_X = 3;\nconst int VORONOI_SEARCH_DEPTH_Y = 6;\n\nvec2 voronoi_cell_rnd(vec2 new_pos) {\n    vec2 new_center = vec2(random(new_pos, 0.), random(new_pos, 1.));\n    return (new_pos + new_center)*VORONOI_CELL_SIZE;\n}\n\nvec3 voronoi_cell_color(vec2 new_pos) {\n\treturn vec3(\n    \trandom(new_pos, 2.), random(new_pos, 3.), random(new_pos, 4.)\n    ) * 0.5 + 0.5;\n}\n\n/*\n\tFirst, find the random cell center that is closest to the point we're drawing\n\tThen, look around the chosen rnd cell center for other rnd cell centers\n\tFor each cell center, draw a line between the closest center and the center\n\twe're looking at.  Draw a perpendicular line in the middle of the line and\n\tproject the point we're drawing onto the perpendicular line.   The length of\n\tthat projected line is the length between the border and the point.  The\n\tsmallest distance is our uniform voronoi value\n*/\nvec3 wall_color(vec3 position, out vec3 normal) { \n\tvec2 pos = position.xy;\n    vec2 cell_pos = floor(pos / VORONOI_CELL_SIZE);\n\n    float smallest = 100.;\n    vec2 closest = vec2(0);\n    vec2 closest_pos = vec2(0);\n    vec3 color = vec3(0);\n    \n    for (int i = 0; i < 9; i++) {\n    \tvec2 offset = vec2(i / 3 - 1, (i % 3) - 1);\n\n        vec2 new_pos = cell_pos + offset;\n        vec2 new_point = voronoi_cell_rnd(new_pos);\n        \n        vec2 diff = new_point - pos;\n\n        float r2 = dot(diff, diff);\n\n        if (r2 < smallest) {\n            smallest = r2;\n            closest_pos = new_pos;\n            closest = new_point;\n            color = voronoi_cell_color(new_pos);\n        }\n    }\n    \n    smallest = 100.;\n    vec2 norm = vec2(0);\n    for (int i = -VORONOI_SEARCH_DEPTH_X; i < VORONOI_SEARCH_DEPTH_X; i++) {\n    for (int j = -VORONOI_SEARCH_DEPTH_Y; j < VORONOI_SEARCH_DEPTH_Y; j++) {\n    \tvec2 offset = vec2(i, j);\n        \n        vec2 new_pos = closest_pos + offset;\n        vec2 new_point = voronoi_cell_rnd(new_pos);\n        \n        vec2 cntr = mix(closest, new_point, 0.5);\n        vec2 dir = normalize(closest - cntr);\n        \n        float d = dot(dir, pos - cntr);\n        \n        if (d < smallest) {\n        \tsmallest = d;\n            norm = -dir; \n        }\n    }\n    }\n  \n    float level = smoothstep(0.0, 0.05, smallest);\n    norm = normalize(norm);\n    \n    /*\n\t\tBasically the idea is we take a straight vector perpendicular to the wall\n\t\tand interpolate that and our 2 dimensional direction vector pointing to the\n\t\tclosest voronoi wall.  Then we normalize the result.  It isn't 100% accurate\n\t\tbut its good enough and we dont have to deal with rotation matricies\n\t*/\n    vec3 normal_3d = normalize(mix(vec3(0, norm), vec3(0, 0, -1), level));\n    \n    normal = normal_3d;\n    \n    return color;\n}\n\nconst int FRONT_WALL = 0;\nconst int BACK_WALL = 1;\nconst int SPHERE_D = 2;\n\nvec3 march_point(vec3 position, vec3 direction, out int int_type, bool exclude_front) {\n    int type;\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n    \tfloat front_d = exclude_front ? 100. : wallSDF(position);\n        float back_d = back_wallSDF(position);\n        float sphere_d = sphereSDF(position);\n        \n        float d = min(min(front_d, back_d), sphere_d);\n        \n        if (d == sphere_d) { type = SPHERE_D; }\n        else if (d == back_d) { type = BACK_WALL; }\n        else if (d == front_d) { type = FRONT_WALL; }\n        \n        if (d <= EPSILON) { break; }\n        \n        position += direction * d;\n    }\n    \n    int_type = type;\n    \n    return position;\n}\n\nconst vec3 FRONT_WALL_NORMAL = vec3(0, 0, -1);\nconst vec3 BACK_WALL_NORMAL = vec3(0, 0, 1);\nconst float SPECULAR_CONSTANT = 0.4;\nconst float DIFFUSE_CONSTANT = 1. - SPECULAR_CONSTANT;\n\nvec3 march(vec3 position, vec3 direction) {\n\tvec3 color = vec3(0);\n    bool bounced = false;\n    \n\tfor (int i = 0; i < 3; i++) {\n        int kind;\n        vec3 pos = march_point(position, direction, kind, bounced);\n        \n        if (kind == FRONT_WALL) {\n            vec3 n;\n            vec3 cell_color = wall_color(pos, n);\n            color = cell_color * lighting(pos, n);\n            \n            bounced = true;\n            \n        \tvec3 incident = direction;\n            direction = reflect(incident, n);\n            position = pos;\n        } else if (kind == BACK_WALL)  {\n            vec3 b_col = back_wall_color(pos) * lighting(pos, BACK_WALL_NORMAL);\n            if (bounced) {\n                color = DIFFUSE_CONSTANT * color + SPECULAR_CONSTANT * b_col;\n            } else {\n            \tcolor = b_col;\n            }\n            break;\n        } else if (kind == SPHERE_D) {\n        \tvec3 n = sphere_normal(pos);\n            vec3 s_col = sphere_color(pos) * lighting(pos, n);\n            if (bounced) {\n            \tcolor = DIFFUSE_CONSTANT * color + SPECULAR_CONSTANT * s_col;\n            } else {\n            \tcolor = s_col;\n            }\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.));\n    ray = rotateX(rotateY(ray, cos(iTime / 2.) * 0.15), sin(iTime / 2.) * 0.15);\n    \n    fragColor = vec4(march(vec3(0), ray), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 406, 406, 549], [550, 550, 587, 587, 731], [732, 732, 769, 769, 912], [914, 914, 955, 955, 1074], [1076, 1076, 1114, 1114, 1179], [1181, 1181, 1234, 1234, 1620], [1621, 1621, 1665, 1665, 1706], [1774, 1774, 1800, 1800, 1865], [1866, 1866, 1898, 1898, 1964], [1965, 1965, 1999, 1999, 2171], [2172, 2172, 2207, 2207, 2263], [2265, 2265, 2295, 2295, 2327], [2328, 2328, 2363, 2363, 2399], [2433, 2433, 2470, 2470, 2659], [2775, 2775, 2812, 2812, 2937], [2939, 2939, 2978, 2978, 3080], [3082, 3593, 3642, 3642, 5425], [5503, 5503, 5590, 5590, 6183], [6370, 6370, 6413, 6413, 7581], [7583, 7583, 7638, 7638, 7883]], "test": "untested"}
{"id": "wtfyzs", "name": "Thick Graffiti", "author": "57ar7up", "description": "based on FabriceNeyret2's https://www.shadertoy.com/view/4d2yzW", "tags": ["worm", "maze", "graffiti"], "likes": 3, "viewed": 356, "published": 3, "date": "1592783926", "time_retrieved": "2024-07-30T20:59:48.746305", "image_code": "// \"maze worms / graffitis {X}\" by FabriceNeyret2\n// 3c https://www.shadertoy.com/view/Xs2cRD\n// 1b https://www.shadertoy.com/view/XdjczW\n\nvoid mainImage(out vec4 O, vec2 U) {\n\tO = texture(iChannel0, U / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 175, 175, 222]], "test": "untested"}
{"id": "wlXcRs", "name": "VPyramid", "author": "Del", "description": "Variable Pyramid, scalable with base etc.", "tags": ["pyramid"], "likes": 2, "viewed": 325, "published": 3, "date": "1592781212", "time_retrieved": "2024-07-30T20:59:49.717708", "image_code": "// Variable Pyramid\n// largely IQ's code, adjusted slightly for my requirements (scalable, box aligned and with a working base)\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// signed distance to a pyramid bs=xz size, h = y size\nfloat sdPyramid( in vec3 p, in float bs, in float h )\n{\n    // box adjust\n    p.y += h;\n    vec3 p2 = p;\n    h*=2.0;\n    bs*=2.0;\n    h/=bs;\n    p/=bs;\n    \n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz); // do p=abs(p) instead for double pyramid\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y-0.5*p.x, h*p.x+0.5*p.y);\n        \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*q.x)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = max(-q.y,q.x*m2+q.y*0.5) < 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    float d = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    \n    // adjust distance for scale\n    //return bs*d;\n    \n    // hacked on the base\n    vec2 fx = abs(p2.xz)-vec2(bs*0.5);\n    float d1 = length(max(fx,0.0)) + min(max(fx.x,fx.y),0.0);\n\tvec2 w = vec2( d1, abs(p2.y) - 0.0001 );\n    d1= min(max(w.x,w.y),0.0) + length(max(w,0.0));    \n    return min(d1,bs*d);\n    \n}\n\nfloat map( in vec3 pos )\n{\n    vec3 size = 0.5+sin(vec3(iTime,iTime*1.5,iTime*2.0))*0.5;\n    float xs = 0.5 + (size.x);\n    float zs = 0.5 + (size.y);\n    float ys = 0.5 + (0.5*size.z);\n    \n    float d1 = sdPyramid(pos,xs, ys);\n    \n    if (iMouse.z>0.5)\n        return d1;\n    \n    float boff = 0.3;\t\t// bounding box offset\n    float bthick = 0.025;\t// bounding box thickness\n    float d3 =  sdBoundingBox(pos,vec3(xs+boff,ys+boff,xs+boff),bthick);\n    d1 = min(d1,d3);\n    return d1;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 5.0*cos(an), -2.5, 5.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 176, 176, 464], [466, 521, 576, 594, 1639], [1641, 1641, 1667, 1667, 2129], [2131, 2177, 2209, 2209, 2447]], "test": "untested"}
{"id": "ttfyRs", "name": "Infinite bridges", "author": "jarble", "description": "This fractal seems to be a city full of bridges and arches.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 286, "published": 3, "date": "1592773987", "time_retrieved": "2024-07-30T20:59:50.600348", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n   \n\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON\n    \n  ; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0));\n    float color2 = length(cos(p/100.0));\n    return vec3(color1/1.5,color1/2.0,color2/3.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y-p.z/2000.0)-p1.y,sin(p1.z)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 10.0; i *= 2.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*vec3(cos(iTime)/3.0,sin(iTime)/1.8,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 384, 384, 540], [784, 784, 813, 813, 947], [949, 949, 973, 973, 1218], [1220, 1641, 1732, 1732, 2038], [2053, 2307, 2372, 2372, 2504], [2506, 2595, 2624, 2624, 2934], [2936, 3428, 3568, 3568, 4178], [4180, 4550, 4635, 4635, 5339], [5341, 5668, 5717, 5752, 5883], [5885, 5885, 5942, 5942, 7075]], "test": "untested"}
{"id": "tlfczl", "name": "Fractal flowers", "author": "jarble", "description": "This recursive signed distance function makes a very \"flowery\" fractal shape.", "tags": ["3d", "raymarching", "fractal"], "likes": 0, "viewed": 277, "published": 3, "date": "1592768863", "time_retrieved": "2024-07-30T20:59:51.424145", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/50.0));\n    float color2 = length(cos(p/50.0));\n    return vec3(color1,color2/1.5,color1);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    return length(sin(p/size)*size) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n        p /= (vec3(2.0)+sin(p/(400.0)));\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(10.0+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 378, 378, 524], [768, 768, 797, 797, 843], [845, 845, 869, 869, 1157], [1159, 1580, 1671, 1671, 1983], [1998, 2252, 2317, 2317, 2449], [2451, 2540, 2569, 2569, 2879], [2881, 3373, 3513, 3513, 4123], [4125, 4495, 4580, 4580, 5352], [5354, 5681, 5730, 5765, 5896], [5898, 5898, 5955, 5955, 7120]], "test": "untested"}
{"id": "tlXczl", "name": "TWedge", "author": "Del", "description": "Variable Triangle Wedge", "tags": ["sdf", "wedge"], "likes": 3, "viewed": 331, "published": 3, "date": "1592767105", "time_retrieved": "2024-07-30T20:59:52.439431", "image_code": "// Variable Triangle Wedge Test - adapted from IQ's distance functions\n// Likely already exists elsewhere on shadertoy, but I couldn't find it!\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat sdTriangle( in vec3 p, in vec3 q )\n{\n    p.z += q.z;\n    q.z *= 2.0;\n    p.x = abs(p.x);\n\tvec2 a = p.xz - q.xz*clamp( dot(p.xz,q.xz)/dot(q.xz,q.xz), 0.0, 1.0 );\n    vec2 b = p.xz - q.xz*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.z );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.z-p.z*q.x),k*(p.z-q.z)  );\n\tfloat sdf= sqrt(d)*sign(s);\n    vec2 w = vec2( sdf, abs(p.y) - q.y );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));    \n}\n\n\n\nfloat map( in vec3 pos )\n{\n    vec3 size = 0.5+sin(vec3(iTime,iTime*1.5,iTime*2.0))*0.5;\n    float xs = 0.5 + (size.x);\n    float zs = 0.5 + (size.y);\n    float ys = 0.5 + (0.5*size.z);\n\n    \n\tfloat d1 =  sdTriangle(pos,vec3(xs,ys,zs));\n    \n    if (iMouse.z>0.5)\n        return d1;\n    \n    float boff = 0.3;\t\t// bounding box offset\n    float bthick = 0.025;\t// bounding box thickness\n    float d3 =  sdBoundingBox(pos,vec3(xs+boff,ys+boff,zs+boff),bthick);\n    d1 = min(d1,d3);\n    return d1;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 5.0*cos(an), 2.5, 5.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 192, 192, 480], [483, 483, 525, 525, 970], [974, 974, 1000, 1000, 1470], [1472, 1518, 1550, 1550, 1788]], "test": "untested"}
{"id": "ttXczl", "name": "Screenprinting [Day 184] ", "author": "jeyko", "description": "mdtjvm", "tags": ["halftone", "popart", "art", "pop", "mdtmjvm", "screenprint", "screenprinting"], "likes": 10, "viewed": 532, "published": 3, "date": "1592765747", "time_retrieved": "2024-07-30T20:59:53.242286", "image_code": "// Trying to reprudce the classic screenprinting style\n\n// Most of all of the look comes from the dots() function\n// You feed it the luminosity of the image, and then multiply image by the return value\n\n\n#define CELL_SZ 0.02\n#define COL_SEP 0.2\n#define STR 1.4\n\n#define LUM_EPS (6.0 )\n\n#define T(u) texture(iChannel0,(u)/iResolution.xy)\n\n#define Neighborhood \\\nvec3 n = getImg(U + vec2(0.,1.)*LUM_EPS);vec3 s = getImg(U - vec2(0.,1.)*LUM_EPS);vec3 e = getImg(U + vec2(1.,0.)*LUM_EPS);vec3 w = getImg(U - vec2(1.,0.)*LUM_EPS);\\\nvec3 se = getImg(U + vec2(1.,-1.)*LUM_EPS);vec3 sw = getImg(U - vec2(-1.,-1.)*LUM_EPS);vec3 ne = getImg(U + vec2(1.,1.)*LUM_EPS);vec3 nw = getImg(U + vec2(-1.,1.)*LUM_EPS);\n\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pmod(p,j) mod(p,j) - 0.5*j\n#define pi acos(-1.)\n\n#define smoothness 0.004\n\n//#define noise(i) texture(iChannel0,vec2(mod((i),256.)/256.,floor(i/256.)/256.))\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat noise(vec2 p){\n\tvec2 fruv = fract(p);\n\tvec2 fluv = floor(p);\n    return mix( \n        mix(\n            hash22(fluv).x,\n            hash22(fluv + vec2(1,0)).x,\n        \tfruv.x\n        ), \n        mix(\n            hash22(fluv + vec2(0,1)).x,\n            hash22(fluv + vec2(1,1)).x,\n        \tfruv.x\n        ),\n        fruv.y\n    );\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdCoolBall(vec2 uv){\n\tfloat sdBall = length(uv) - 0.4; \n    sdBall = opSmoothUnion( sdBall, length(uv + 0.5 + vec2(sin(iTime)*0.1)) - 0.1,0.4 );\n    sdBall = opSmoothUnion( sdBall, length(uv - 0.5 + vec2(sin(iTime/2. + cos(iTime))*0.1)) - 0.1,0.4 );\n    sdBall = opSmoothUnion( sdBall, length(uv - vec2(-0.5,0.2) + vec2(sin(iTime/2.), cos(iTime+ 4.) )/14.) - 0.04,0.3 );\n    //sdBall = opSmoothUnion( sdBall, length(uv - vec2(0.5,-0.4) + vec2(sin(iTime/2. )*0.1,cos(iTime))*0.1) - 0.1,0.4 );\n    \n    return sdBall;\n}\n\nvec3 getImg(vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.,0.,0.);\n    \n    vec2 puv = vec2(atan(uv.y,uv.x)/pi + 1.,length(uv));\n    \n    \n    if(puv.x < 0.4)\n    \tcol = vec3(0.2,0.5,0.4)*1.55;\n    else if(puv.x < 1.)\n    \tcol = vec3(0.5,0.5,0.9);\n    else if(puv.x < 1.4)\n    \tcol = vec3(1.,0.716,0.7);\n    else \n    \tcol = vec3(0.9,0.6,0.6);\n    \n    //col *= smoothstep(1.,0.,length(uv)/3.);\n    \n    //uv *= rot(-0.7);\n    \n    col = mix(col,vec3(1,0.1,0.6),smoothstep(1.,0.,length(abs(uv.y) + 0.)*4. + 0.3));\n    \n    uv *= rot(-1.2);\n    col = mix(col,vec3(1,0.1,0.5),smoothstep(1.,0.,length(abs(uv.y) + 0.)*4. + 0.3));\n    \n    \n    uv *= rot(-1.4);\n    \n    \n    vec3 bc = vec3(1.,0.7,0.6) *mix(vec3(1.),vec3(0.1,0.,0.),smoothstep(0.,1.,uv.x + uv.y*1.5 -0.1 + length(uv)/1.5));\n    \n    \n    float dBalla = sdCoolBall(uv);\n        \n    float dBallb = sdCoolBall(uv-0.04);\n        \n    \n    col = mix(col,vec3(1,1.,0.9), smoothstep(smoothness,0.,dBallb));\n    \n    \n    col = mix(col,bc, smoothstep(smoothness,0.,dBalla));\n    \n    \n    col = mix(col,vec3(1,0.7,1.),smoothstep(1.,0.,length(uv + vec2(0.13,0.25))*18. + 0.3));\n    \n    col = mix(col,vec3(1,0.7,1.),smoothstep(1.,0.,length(uv + vec2(0.7,0.4))*14. + 0.3));\n    \n    \n    \n    return col;\n}\n\n\n// get avg lum\nvec3 getAvg(vec2 U){\n    \n    float l = 0.4;\n    Neighborhood;\n    \n    vec3 avg = (n + e + w + s + ne + sw + se + nw)/8.;\n    \n    return avg;\n\n}\n    \n\nfloat dots(vec2 p,float lum){\n\tfloat t = 0.;\n    vec2 q = p ;\n    \n    p *= rot(0.25*pi);\n    \n    \n    q /= CELL_SZ/pi;\n    // some distortion\n    p -= length(sin(q))*normalize(p)*CELL_SZ/6.;\n    \n    \n    p = pmod(p,CELL_SZ);\n    p -= length(sin(q))*normalize(p)*CELL_SZ/6.;\n    \n    float lsz = 0.;\n    \n    float n = noise(q*10.);\n    \n    n = pow(n,2.)*0.07;\n    lsz = pow(smoothstep(0.,1.,lum*(0.45 +n)),STR)*CELL_SZ*0.6;\n    \n    float col = smoothstep(0.003,0.,length(p) - lsz);\n    //col = mix(col,smoothstep(0.01,0.,sin(q.x)*sin(q.y)* lsz*1. ),0.1);\n\t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 tex = getImg(fragCoord);\n    \n    tex = getAvg(fragCoord);\n    \n    float lum = length(tex);\n    \n    col = vec3(0.1,0.5,0.9)*0.1;\n    col = mix(col,floor(tex/COL_SEP)*COL_SEP,dots(uv,lum));\n    \n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[835, 937, 958, 958, 1092], [1093, 1093, 1113, 1113, 1429], [1432, 1432, 1484, 1484, 1583], [1585, 1585, 1611, 1611, 2108], [2110, 2110, 2138, 2138, 3425], [3428, 3443, 3463, 3463, 3589], [3596, 3596, 3625, 3625, 4175], [4177, 4177, 4234, 4234, 4607]], "test": "untested"}
{"id": "3tfczs", "name": "60's psychedelic wallpaper", "author": "Oggbog", "description": "Happy accident :-)", "tags": ["psychedelic"], "likes": 2, "viewed": 330, "published": 3, "date": "1592749556", "time_retrieved": "2024-07-30T20:59:54.205708", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *=9.;\n\n    float d = (cos(uv.x)*sin(uv.y))+iTime*3.;\n    \n    vec3 col = fract(vec3(d,1.-d/2.,d/2.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 294]], "test": "untested"}
{"id": "WlXcRs", "name": "if(false)texture performance bug", "author": "ffcr", "description": "A glsl running on NVIDIA may have a lower frame rate than on integrated graphics and mobile phones", "tags": ["bug"], "likes": 2, "viewed": 330, "published": 3, "date": "1592738666", "time_retrieved": "2024-07-30T20:59:55.112284", "image_code": "/*\nWhen TEST is set to 0, the NVIDIA will occupy a very high rate, \nwhich will cause the frame rate to drop or even make NVIDIA stop running.\nBut when TEST is set to 1 or 2, replace 'if' with 'do' loop,\nthe graphics card occupancy will be normal. \nWhen TEST is set to 3, use \"texelfetch\" instead of \"texture\",\nno bug even with \"if\" statement\nIf it is running in the browser of mobile phone or integrated graphics card,\nsetting TEST to 0 will not increase performance consumption.\n*/\n#define TEST 0\n#define EXECUTE false\n#define IF(a) do{if(!(a))break;\n#define ENDIF }while(false);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    bool b=iTime<0.0;//always false\n                                    if(EXECUTE)b=!b;\n    #if TEST==0\n    if(b){\n    \tfor(float a=0.;a<2000.;a++){\n            col+=texture(iChannel0,uv+a).xyz;\n        }\n    }\n    #elif TEST==1\n    do{\n        if(!b)break;\n        for(float a=0.;a<2000.;a++){\n            col+=texture(iChannel0,uv+a).xyz;\n        }\n    }while(false);\n    #elif TEST==2\n    IF(b)\n        for(float a=0.;a<2000.;a++){\n            col+=texture(iChannel0,uv+a).xyz;\n        }\n    ENDIF\n\t#else\n\tif(b){\n        for(float a=0.;a<2000.;a++){\n        \tcol+=texelFetch(iChannel0,ivec2(fragCoord+a),0).xyz;\n        }\n    }\n    #endif\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tXcRs", "name": "Simplex Trabeculae", "author": "izutionix", "description": "Using simplex noise to generate a trabecular structure (faster than voronoi based methods)\nstatic version: [url]https://www.shadertoy.com/view/WtXcRj[/url]\n2d version: [url]https://www.shadertoy.com/view/tlfczS[/url]", "tags": ["simplex", "sponge", "cave", "trabeculum", "network"], "likes": 30, "viewed": 612, "published": 3, "date": "1592737634", "time_retrieved": "2024-07-30T20:59:56.069724", "image_code": "#define STEPS 256\n#define TMAX 100.\n#define PRECIS .0001\n\n#define r(a) mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n#define shaded 0\n\nvec3 hash33(vec3 c, float r) {\n\tvec3 h = .5*normalize(fract(vec3(8., 1., 64.)*sin( dot(vec3(17., 59.4, 15.), c) )*32768.)-.5);\n    return mix(vec3(.4), h, r); // attenuate randomness (make sure everything on the path of the camera is not random)\n}\n\n/* 3d simplex noise from candycat's \"Noise Lab (3D)\" https://www.shadertoy.com/view/4sc3z2\nbased on the one by nikat: https://www.shadertoy.com/view/XsX3zB */\nvec4 simplex_noise(vec3 p, float r) {\n    \n    const float K1 = .333333333;\n    const float K2 = .166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.), d0 - d0.yzx);\n\tvec3 i1 = e * (1. - e.zxy);\n\tvec3 i2 = 1. - e.zxy * (1. - e);\n    \n    vec3 d1 = d0 - (i1 - 1. * K2);\n    vec3 d2 = d0 - (i2 - 2. * K2);\n    vec3 d3 = d0 - (1. - 3. * K2);\n    \n    vec4 h = max(.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i, r)), dot(d1, hash33(i + i1, r)), dot(d2, hash33(i + i2, r)), dot(d3, hash33(i + 1., r)));\n    \n    return 70.*n;\n}\n\n// see https://www.shadertoy.com/view/ttsyRB\nvec4 variations(vec4 n) {\n    vec4 an = abs(n);\n    vec4 s = vec4(\n        dot( n, vec4(1.) ),\n        dot( an,vec4(1.) ),\n        length(n),\n        max(max(max(an.x, an.y), an.z), an.w) );\n    \n    float t =.27;\n    \n    return vec4(\n\t\t// worms\n\t\tmax(0., 1.25*( s.y*t-abs(s.x) )/t),\n\t\t// cells (trabeculae)\n    \tpow( (1.+t)*( (1.-t)+(s.y-s.w/t)*t), 2.), //step( .7, (1.+t)*( (1.-t)+(s.y-s.w/t)*t) ),\n\t\t.75*s.y,\n    \t.5+.5*s.x);\n}\n\nfloat map(vec3 p) {\n    float c = smoothstep(0., 1., length(p.xy)-.1); // controls the randomness\n    p += vec3(-.65, .35, 44.85);\n    float s = 1.;\n    float n = variations( simplex_noise(p*s*.5, c) ).y;\n    n = .78-n;\n    n /= s*4.;\n    \n    return n;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = .01;\n    for(int i=0; i<STEPS; i++) {\n        float h = map(ro + rd * t);\n        t += h;\n        if(t>TMAX || abs(h)<PRECIS) break;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.4, 0);\n    return normalize(\n        map(p) - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n        ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.); ro.z = iTime*.67;\n    vec3 rd = vec3(uv, .5);\n    \n    vec3 l = normalize( vec3(-3,2,1) );\n    \n    float fc = exp2( .5*dot(rd, l) )*.5;\n    \n\tfloat t = march(ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float dif = 0.;\n#if shaded\n    vec3 n = normal(p);\n    dif = dot(n, l)*.5+.5;\n    dif *= .125;\n#endif\n    \n    float fog = pow(1.-.05/(t*.75+.5), 25.);\n    float v = mix(dif, fc, fog);\n    v *= v;\n    \n    vec3 col = 1.-vec3(.67, .45, .05);\n    col = pow(vec3(v), col*1.5 );\n    \n\t// subtle texture\n    col += .004*(texture(iChannel0, fragCoord*.001*r(.2)+.1).x-.5)\n          +.008*(texture(iChannel0, fragCoord*.002*r(.3)+.1).x-.5)\n          +.015*(texture(iChannel0, fragCoord*.004*r(.5)+.1).x-.5)\n          +.03 *(texture(iChannel0, fragCoord*.008*r(.7)+.1).x-.5);\n    \n    col = smoothstep(0., 1., 2.3*col);\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 160, 160, 377], [379, 538, 575, 575, 1224], [1226, 1271, 1296, 1296, 1702], [1704, 1704, 1723, 1723, 1959], [1961, 1961, 1992, 1992, 2158], [2160, 2160, 2181, 2181, 2332], [2335, 2335, 2392, 2392, 3328]], "test": "untested"}
{"id": "WlfyRs", "name": "Spherical 360 camera", "author": "jeyko", "description": "This is a description of a shader", "tags": ["camera", "spherical", "360"], "likes": 13, "viewed": 487, "published": 3, "date": "1592737606", "time_retrieved": "2024-07-30T20:59:56.972311", "image_code": "\n// This is a way to get camera effects like in here: https://youtu.be/xO8nJXu2RUI?t=6\n\n// The function which does the magic is getRdSpherical(vec3 ro,vec2 uv); in Buffer A\n\n\n// it maps uv > polar uv > parametrized sphere\n\n\n\n// This buffer is for post-processing effects\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 40.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.5)*0.1;\n    float chromAb = pow(length(uv - 0.5),1.9)*3.;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    fragColor = pow(fragColor, vec4(1. + dot(uvn,uvn))*1. );\n    fragColor = max(fragColor, 0.);\n    //fragColor.b *= 1. + uv.x*0.4;\n    fragColor *= 1. - dot(uvn,uvn)*2.;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pmod(p,z) mod(p,z) - 0.5*z\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n\nvec3 getRdSpherical(vec3 ro,vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    uv += 0.5;\n    uv.y *= tau/2.;\n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1. + sin(iTime)/2.)*pi);\n    \n    vec3 lookAt = ro + offs;\n    \n    return normalize(lookAt - ro);\n}\n\n\nvec3 glow = vec3(0);\n\nvec3 path (float z){\n    z *= 0.24;\n\treturn vec3(0. + sin(z),0. + cos(z),0.)*0.;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.y, max(p.z,p.x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n   \n    p -= path(p.z);\n    \n    //p = pmod(p,1.);\n   \n    //p = abs(p);\n    \n    \n    //d.x = min(d.x, abs(p.y - 1.)-0.);\n   \n    \n    //d.x = min(d.x, abs(p.y + 1.2));\n    \n    \n    p.xz = pmod(p.xz,1.);\n   \t\n    \n    vec3 q = p;\n    \n    q.y = pmod(q.y,1.);\n    \n    q = abs(q);\n    p.y = pmod(q.y,1.);\n   \t\n   \t\n    d.x = min(d.x, max(q.x,q.y) - 0.04);\n    d.x = min(d.x, max(q.y,q.z) - 0.03);\n    d.x = min(d.x, length(p.xz) - 0.03);\n    \n    \n    d.x = min(d.x, length(p) - 0.1);\n   \n    \n    \n    d.x = abs(d.x) - 0.00;\n    d.x += 0.001;\n    d.x *= 0.2;\n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    p = ro;; t = 0.; hit = false;\n    \n    for(float i = 0.; i < 130.; i++){\n    \td = map(p)*dith;\n        float eps = 0.001;\n        if(d.x < eps){\n            t += 0.0004;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(vec3(\n        map(p - t.xyy).x - map(p + t.xyy).x,\n        map(p - t.yxy).x - map(p + t.yxy).x,\n        map(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    dith = mix(0.95,1.,texture(iChannel0,iResolution.xy*(uv + iTime*10.)/256.).x);\n    \n    vec3 col = vec3(0);\n\n\tvec3 ro = vec3(0);\n    \n    ro.z += iTime*1.7;\n    \n    ro += path(ro.z);\n    \n    ro.y += 0.;\n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z + .5);\n    \n    //vec3 rd = getRd(ro, lookAt,uv);\n  \tvec3 rd = getRdSpherical(ro, uv);\n  \t\n    float v = 1.;\n    \n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    col += glow*0.001;\n    \n    vec3 fc = pal(0.6,0.5,vec3(1.,0.5,0.4) + cos(uv.yxx)*.8, 1.9  - dot(uv,uv)*0.1,-2.1);\n    fc = max(fc,0.);\n    col = mix(col,fc, smoothstep(0.,1.,t*0.1));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 329, 329, 1369]], "test": "untested"}
{"id": "WtfyRs", "name": "SphereTreeBulb", "author": "eiffie", "description": "A mod of TGlad's SphereTree fractal based on a mclarekin frag.", "tags": ["spheretree"], "likes": 12, "viewed": 372, "published": 3, "date": "1592737336", "time_retrieved": "2024-07-30T20:59:57.835006", "image_code": "//TGlad's SphereTree fractal mod by eiffie of a mclarekin DE\n#define rez iResolution.xy\nvec3 mcol=vec3(0.0);\n#define dot2(a) dot(a,a)\nfloat InvSc=.4,FF=0.95;\nbool bOutChk=false;\n// a mod of a mod of tglad's sphereTree distance estimation function from mclarekin then I simplified some \nfloat DE(vec3 p0) { \n  vec3 orbitTrap=vec3(1000);\n  vec4 p=vec4(p0,1.);\n  const float root3 = 1.732050807, root3d2 = 0.8660254, t = 0.53333334, M=2.15;  \n  const vec2 t1 = vec2(root3d2, -0.5), t2 = vec2(-root3d2, -0.5);\n  const mat2 mx=mat2(.8660254,.5,-.5,.8660254);//cos(sqrt(.75)) or pi/6\n  p.z=abs(p.z)+0.1725;//more sphere than tree now\n  for (int i = 0; i < 7; i++) {  \n    if(bOutChk){vec3 pC = p.xyz-vec3(0,0,t); if (dot(pC, pC) > t*t) break;} // definitely outside \n    float invSC = InvSc / dot(p.xyz,p.xyz); \n    p *= invSC;\n    p.z -= 1.0; \n    p.z *= -1.0;\n    p *= root3;\n    p.z=abs(p.z+.5)+.5;\n    p.xy=mx*p.xy;//rotate\n    // now modolu the space so we move to being in just the central hexagon, inner radius 0.5  \n    vec2 p2=mod(vec2(dot(p.xy,-t1.yx),dot(p.xy,-t2.yx))*M/root3,1.0); \n    if (p2.x + p2.y > 1.0) p2=vec2(1.)-p2; \n    p.xy = p2.x*t1 - p2.y*t2;\n    // fold the space to be in a kite \n    float l0 = dot2(p.xy), l1 = dot2(p.xy-t1), l2 = dot2(p.xy+t2); \n    if (l1 < min(l0,l2)) p.xy -= t1 * (2.0*dot(t1, p.xy) - 1.0); \n    else if (l2 < min(l0,l1)) p.xy -= t2 * (2.0 * dot(p.xy, t2) + 1.0); \n    p.z *= InvSc;\n    orbitTrap = min(orbitTrap, abs(p.xyz)); \n  }\n  if(mcol.x>0.)mcol+=vec3(1.0)+3.*(orbitTrap.zzx+orbitTrap.zyx);\n  float d = (length(p.xyz-vec3(0,0,0.4)) - 0.4); // the 0.4 is slightly more averaging than 0.5 \n  d = (sqrt(d + 1.0) - 1.) * 2.0; \n  return FF*d / p.w; \n} \n\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=max(0.,0.4+0.6*dot(rd,L));\n  return pow(vec3(d*d*d*d,d*d*0.5,d-pow(d*d,10.0)),vec3(.2));\n}\nfloat rnd=0.;\nfloat rand(){rnd=fract((rnd+1.62340)*342.123);return rnd;}\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.34,117.71)))*4231.76);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rand(),s=1.0,d,mn=0.01;\n for(int i=0;i<6;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rand(),d,od=1.,px=1.0/rez.y;\n  vec4 edge=vec4(0,0,-1,-1);\n  for(int i=0;i<199;i++){\n    d=DE(ro+rd*t);\n    if(d<px*t*t*.5 && d>od){if(edge.x<0.){edge=vec4(edge.yzw,t);break;}else {edge=vec4(edge.yzw,t);t+=px*t*t;}}\n    t+=d;od=d;\n    if(t>10.0)break;\n  }\n  if(d<px*t*t*.5)edge=vec4(edge.yzw,t);\n  vec3 L=vec3(0,0,1);\n  vec3 col=sky(rd,L);\n  for(int i=0;i<4;i++){\n    if(edge.w>0.){//valid distance, color back to front\n      mcol=vec3(0.01);\n      float d=DE(ro+rd*edge.w);\n      if(d<0.)d*=2.;\n      vec3 so=ro+rd*(edge.w+d);\n      vec3 N=normal(so,px*edge.w);\n      vec3 scol=mcol*0.2;\n      float dif=0.5+0.5*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=pow(1.-vis,5.0);\n      float shad=ShadAO(so,L);\n      col=mix((scol*dif+fr*sky(reflect(rd,N),L))*shad,col,clamp(0.8*d/(px*edge.w*edge.w*.5),0.,1.));\n    }\n    edge=edge.wxyz;\n  }\n  return col;\n}\nmat3 lookat(vec3 fw){fw=normalize(fw);vec3 up=vec3(0,0,1);vec3 rt=normalize(cross(fw,up));\n  return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*rez)/rez.x;\n  randomize(U);\n  float t=iTime;\n  vec3 ro=vec3(cos(t),sin(t*1.1),0.5+0.5*sin(t*.7));\n  vec3 rd=lookat(-ro)*normalize(vec3(uv.xy,1.0));\n  t=mod(t,60.);\n  if(t<20.){InvSc=.5;FF=0.75;bOutChk=true;}\n  else if(t<40.){InvSc=1.;FF=0.45;bOutChk=true;}\n  O=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 286, 305, 305, 1696], [1699, 1699, 1728, 1738, 1874], [1875, 1875, 1901, 1901, 2002], [2017, 2017, 2030, 2030, 2075], [2076, 2076, 2102, 2102, 2166], [2168, 2168, 2205, 2205, 2341], [2342, 2342, 2371, 2371, 3264], [3265, 3265, 3286, 3286, 3392], [3393, 3393, 3431, 3431, 3739]], "test": "untested"}
{"id": "WlXczX", "name": "Polar Flow", "author": "Oggbog", "description": "Messing about with polar coords", "tags": ["polar"], "likes": 2, "viewed": 264, "published": 3, "date": "1592728870", "time_retrieved": "2024-07-30T20:59:58.683735", "image_code": "#define TWO_PI 6.2831853\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 pv = vec2(atan(uv.x,uv.y),length(uv));\n                   \n    uv = vec2(pv.x/TWO_PI+0.5,pv.y);\n   \n    float a = TWO_PI*TWO_PI;\n    float b = TWO_PI/2.;\n    \n\tuv.x += iTime*.01;\n    uv.y += -iTime*.1;\n    float d = b*tan(uv.x/TWO_PI*a)*cos(uv.x/TWO_PI*a)/tan(sin(uv.y/TWO_PI*a));\n    \n    \n    d = floor(d*2.)/16.;\n    vec3 col = vec3(d/2.,d-.4,smoothstep(1.,d,pv.y));\n\t\n    \n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor,vec4(1./2.2))-.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 620]], "test": "untested"}
{"id": "Wlfyzl", "name": "Line Segment (SDF)", "author": "57ar7up", "description": "Modified https://www.shadertoy.com/view/3tdSDj by IQ", "tags": ["2d", "distancefield", "sdf", "line", "distance", "segment"], "likes": 8, "viewed": 5080, "published": 3, "date": "1592726027", "time_retrieved": "2024-07-30T20:59:59.657133", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and line segment\n\n// Segment:              https://www.shadertoy.com/view/3tdSDj\n// and many more here:   https://iquilezles.org/articles/distfunctions2d\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\tfloat zoom = 2.5;\n\tpos *= zoom;\n\n\tvec2 v1 = cos(iTime + vec2(0.,5.));\n\tvec2 v2 = cos(iTime + vec2(0.,5.) + 3.1);\n\tfloat thickness = .2 * (.5 + .5 * sin(iTime * 1.));\n\n\tfloat d = line_segment(pos, v1, v2) - thickness;\n\n\tvec3 color = vec3(1.) - sign(d) * vec3(0., 0., 0.);\n\tcolor *= 1.5 - exp(.5 * abs(d));\n\tcolor *= .5 + .3 * cos(120. * d);\n\tcolor = mix(color, vec3(1.), 1. - smoothstep(.0, .015, abs(d)));\n\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlfyzl.jpg", "access": "api", "license": "mit", "functions": [[1252, 1252, 1305, 1305, 1425], [1427, 1427, 1482, 1482, 1985]], "test": "untested"}
{"id": "WlfcRl", "name": "filtering white vs blue noise", "author": "FabriceNeyret2", "description": "Interest of bluenoise / low discrepancy / poisson-disc distribution:\nsince it has no low frequency, averaging it just a bit (as subpixel oversampling, or just in your eyes with distance) smooth out the variations, while white noise keep some at all scales", "tags": ["filtering", "dithering", "bluenoise"], "likes": 7, "viewed": 489, "published": 3, "date": "1592718942", "time_retrieved": "2024-07-30T21:00:00.551741", "image_code": "#define T(ch)  texelFetch( ch, ivec2(U) % textureSize(ch,l), l).xxxx\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O-=O;\n    if (   int(U.x+2.)%int(R.x/2.) < 5     // separators\n        || int(U.x)   %int(R.x/4.) < 2 \n        || int(U.y)   %int(R.y/5.) < 1 )  return; \n    \n    int l = int(5.*U.y/R.y);                // vertical: LOD bands\n    float x = U.x - R.x/2.;\n    if (abs(x)>R.x/4.) U /= 2.;             // extremes: zoom\n    O = x<0. ? T(iChannel0) : T(iChannel1); // left: white noise  right : blue noise\n\n    if ( iMouse.z > 0. ) O = .5 + (O-.5)*float(1<<l); // click: normalize by std-dev(avg)\n      \n    O = pow( O , vec4(1./2.2) );            // to sRGB\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfcRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 108, 108, 697]], "test": "untested"}
{"id": "ttlczf", "name": "Cave explorer game demo", "author": "jarble", "description": "Use the mouse and arrow keys to fly through the cave.\nI used one of my [url=https://www.shadertoy.com/view/Wllyz2]cave generators[/url] to make this demo.", "tags": ["3d", "raymarching", "fractal", "game", "cave"], "likes": 0, "viewed": 316, "published": 3, "date": "1592699525", "time_retrieved": "2024-07-30T21:00:01.953993", "image_code": "const float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 ground_color(vec3 p)\n{\n    p /= 100.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p)/10.0)/20.0,color1/2.0);\n}\n\nvec3 foliage_color(vec3 p)\n{\n    p /= 1.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\nvec3 spaceship_color(vec3 p)\n{\n    return vec3(0.5,0.5,0.5);\n}\n\nvec3 jungle_color(vec3 p)\n{\n    //p /= scale;\n    p = sin(p/100.0)*100.0;\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0))/2.0;\n}\n\n\n\n\n\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3((fragCoord - size / 2.0), -z));\n}\n\nvec3 bump_map(vec3 p3)\n{\n  \t//return vec3(0.0);\n    p3 *= 10.0;\n    return (sin(p3)+sin(p3))/10.0;\n}\n\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    \n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    vec3 rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n\n    \n\n    //ro /= scale;\n    \n    vec3 eye = ro;\n    \n    vec3 worldDir = rd;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    EPSILON1 = EPSILON;\n    \n    if (dist > MAX_DIST - EPSILON1) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a;\n    if(color == 3){\n    \tK_a = foliage_color(p);\n    }\n    else if(color == 2){\n    \tK_a = jungle_color(p);\n    }\n    else if(color == 1){\n    \tK_a = ground_color(p);\n    }\n    else if(color == 4){\n    \tK_a = spaceship_color(p);\n    }\n    else{\n    \tK_a = vec3(1.0,1.0,1.0);\n    }\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nfloat EPSILON1;\nint color;\nfloat scale = EPSILON*10.0;\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat planet_surface(vec3 p){\n    float size = 1000.0;\n    vec3 p1 = p/size;\n    //p1 += sin(length(p/50.0+iTime))/5.0;\n    p = (sin(p1+sin(length(p/50.0)/10.0))+cos(p1.zxy+length(p.yzx/50.0)/10.0))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    color = 1;\n    p /= scale*40.0;\n    float result = planet_surface(p);\n    float j = 1.0;\n    for(int i = 0; i < 4; i++){\n    \tresult += max(result, planet_surface(p*j)/(j));\n        j *= 2.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float depth, float end) {\n    //float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}", "buffer_a_code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, min(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta * 5.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 238, 238, 373], [375, 375, 403, 403, 500], [502, 502, 532, 532, 564], [566, 566, 593, 611, 1006], [1026, 1280, 1345, 1345, 1461], [1463, 1463, 1487, 1510, 1563], [1567, 2059, 2199, 2199, 2789], [2791, 3161, 3246, 3246, 3937], [3939, 4266, 4315, 4350, 4481], [4483, 4483, 4540, 4540, 5912]], "test": "untested"}
{"id": "wtlyzf", "name": "BoS - Mondrian on the Wall", "author": "zeta", "description": "Exercise from https://thebookofshaders.com/07/: use boxes to make a composition that resembles a Mondrian painting.\n\nReference: https://upload.wikimedia.org/wikipedia/commons/a/a4/Piet_Mondriaan%2C_1930_-_Mondrian_Composition_II_in_Red%2C_Blue%2C_and_Yell", "tags": ["2d", "painting", "art", "mondrian", "thebookofshaders"], "likes": 8, "viewed": 398, "published": 3, "date": "1592694282", "time_retrieved": "2024-07-30T21:00:02.751858", "image_code": "#define PI 3.1415926538\n\n#define put(shape, color, bg) mix(bg, color, shape)\n\n\nconst vec3 white = vec3(1),\n           black = vec3(0),\n           wall_c = vec3(0.9),\n           shadow_c = vec3(0.6),\n           frame_c = white,\n           paint_black = vec3(14, 16, 15) / 255.0,\n           paint_white = vec3(231, 232, 226) / 255.0,\n           paint_red = vec3(214, 34, 19) / 255.0,\n           paint_red2 = vec3(231, 63, 54) / 255.0,\n           paint_blue = vec3(0, 90, 160) / 255.0,\n           paint_yellow = vec3(230, 208, 97) / 255.0;\n\n\nfloat box_smooth(vec2 uv, vec4 bounds, vec4 smth)\n{\n\treturn smoothstep(bounds.x, bounds.x + smth.x, uv.x) *\n\t       smoothstep(bounds.y, bounds.y + smth.y, 1.0 - uv.x) *\n\t       smoothstep(bounds.z, bounds.z + smth.z, 1.0 - uv.y) *\n\t       smoothstep(bounds.w, bounds.w + smth.w, uv.y);\n}\n\n\nfloat box(vec2 uv, vec4 bounds)\n{\n\treturn step(bounds.x, uv.x) *\n\t       step(bounds.y, 1.0 - uv.x) *\n\t       step(bounds.z, 1.0 - uv.y) *\n\t       step(bounds.w, uv.y);\n}\n\n\nfloat box_border(vec2 uv, vec4 bounds, vec4 border_size)\n{\n    return box(uv, bounds) *\n\t       (\n               step(bounds.x, uv.x) * (1.0 - step(bounds.x + border_size.x, uv.x)) + \n               step(bounds.y, 1.0 - uv.x) * (1.0 - step(bounds.x + border_size.y, 1.0 - uv.x)) +\n               step(bounds.z, 1.0 - uv.y) * (1.0 - step(bounds.z + border_size.z, 1.0 - uv.y)) +\n               step(bounds.w, uv.y) * (1.0 - step(bounds.w + border_size.w, uv.y))\n           );\n}\n\n\n// Compute bounds relative to other bounds.\nvec4 brel(vec4 bounds, vec4 rel_to)\n{\n\treturn rel_to + vec4(\n\t\t(1.0 - rel_to.x - rel_to.y) * bounds.x,\n\t\t(1.0 - rel_to.x - rel_to.y) * bounds.y,\n\t\t(1.0 - rel_to.z - rel_to.w) * bounds.z,\n\t\t(1.0 - rel_to.z - rel_to.w) * bounds.w\n\t);\n}\n\n\n// https://easings.net/\nfloat easeOutExpo(float x)\n{\n\treturn x >= 1.0 ? 1.0 : 1.0 - pow(2.0, - 10.0 * x);\n}\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return x >= 1.0 ? 1.0 : 1.0 - c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 3.0;\n\n    return x <= 0.0\n      ? 0.0\n      : x >= 1.0\n      ? 1.0\n      : 0.0, 1.0, pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = fragCoord;\n\n\tfloat _min = min(iResolution.x, iResolution.y);\n\tfloat _max = max(iResolution.x, iResolution.y);\n\n\tfloat off = (_max - _min) * 0.5;\n\tif (iResolution.x > iResolution.y) {\n\t\tfc.x -= off;\n\t} else {\n\t\tfc.y -= off;\n\t}\n\n\tvec2 uv = fc.xy / _min;\n\n    vec4 frame_border_size = vec4(0.1);\n\tvec4 frame_b = vec4(0.15, 0.15, 0.05, 0.25);\n\tvec4 shadow_b = frame_b + vec4(0.02, 0.02, 0.02, -0.02);\n\tvec4 paint_b = frame_b + frame_border_size;\n    \n    float speed = iTime*0.5;\n    vec4 lnv  = mix(vec4(1, 0, 0, 0), vec4(0.25, 0.78, 0   , 0   ), easeOutElastic(speed)),\n\t     lnh  = mix(vec4(0, 0, 0, 1), vec4(0   , 0   , 0.75, 0.28), easeOutElastic(speed)),\n\t     ln13 = mix(vec4(0, 0, 0, 1), vec4(0   , 0   , 0.36, 0.7 ), easeOutElastic(speed)),\n\t     ln56 = mix(vec4(1, 0, 0, 0), vec4(0.93, 0.1 , 0   , 0   ), easeOutElastic(speed)),\n\t     ln67 = mix(vec4(0, 0, 0, 1), vec4(0   , 0   , 0.89, 0.15), easeOutElastic(speed));\n\n\tvec4 s1 = brel(vec4(0.0, lnv.y, 0.0, ln13.w), paint_b);\n\tvec4 s2 = brel(vec4(lnv.x, 0.0, 0.0, lnh.w), paint_b);\n\tvec4 s3 = brel(vec4(0.0, lnv.y, ln13.z, lnh.w), paint_b);\n\tvec4 s4 = brel(vec4(0.0, lnv.y, lnh.z, 0.0), paint_b);\n\tvec4 s5 = brel(vec4(lnv.x, ln56.y, lnh.z, 0.0), paint_b);\n\tvec4 s6 = brel(vec4(ln56.x, 0.0, lnh.z, ln67.w), paint_b);\n\tvec4 s7 = brel(vec4(ln56.x, 0.0, ln67.z, 0.0), paint_b);\n\n\tvec3 col = wall_c;\n\tcol = put(box_smooth(uv, shadow_b, vec4(0.01)), shadow_c, col);\n\tcol = put(box(uv, paint_b), paint_black, col);\n\tcol = put(box(uv, s1), paint_white, col);\n\tcol = put(box(uv, s2), mix(paint_red, paint_red2, uv.x), col);\n\tcol = put(box(uv, s3), paint_white, col);\n\tcol = put(box(uv, s4), paint_blue, col);\n\tcol = put(box(uv, s5), paint_white, col);\n\tcol = put(box(uv, s6), paint_white, col);\n\tcol = put(box(uv, s7), paint_yellow, col);\n    col = put(box_border(uv, frame_b, frame_border_size), frame_c, col);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 590, 590, 827], [830, 830, 863, 863, 1000], [1003, 1003, 1061, 1061, 1479], [1482, 1526, 1563, 1563, 1759], [1762, 1786, 1814, 1814, 1869], [1870, 1870, 1898, 1898, 2045], [2046, 2046, 2077, 2077, 2255], [2258, 2258, 2315, 2315, 4223]], "test": "untested"}
{"id": "wlscRf", "name": "Black hole wave bending", "author": "michael0884", "description": "Not accurate, only a toy model", "tags": ["wave"], "likes": 9, "viewed": 402, "published": 3, "date": "1592691412", "time_retrieved": "2024-07-30T21:00:03.668408", "image_code": "// Fork of \"Time Inversion \" by wyatt. https://shadertoy.com/view/wsySDh\n// 2019-12-19 20:34:57\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 t =A(U); \n     float DT = dt*(1. - 0.5*exp(-distance(R*vec2(0.5, 0.5), U)/150.));\n    Q = vec4(sqrt(dot(t.xy,t.xy))*4.);\n    Q.z /= 0.5*DT;\n    Q.x += 0.7*(dt - DT)/dt;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define PI 3.14159265\n//use max possible dt without sim breaking\n#define dt sqrt(2.)\n//apparently its sqrt(2)\n", "buffer_a_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    Q = A(U);\n    vec4 m = 0.25*(A(U+vec2(0,1))+A(U-vec2(0,1))+A(U+vec2(1,0))+A(U-vec2(1,0)));\n\t\n    //wave \n    float DT = dt*(1. - 0.5*exp(-distance(R*vec2(0.5, 0.5), U)/150.));\n    \n    Q.y += DT*(m.x-Q.x);\n    Q.x += DT*Q.y;\n\n    //cell interaction\n    vec4 mval = mod(4.*m,9.);\n    Q.z = mval.z;\n \n    if (iFrame < 5) {\n    \tQ = exp(-pow(40.*length(U-vec2(0.9, 0.8)*R)/R.x, 2.))*vec4(sin(PI*0.5*U.x),PI*0.5*cos(PI*0.5*U.x),0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 138, 138, 318]], "test": "untested"}
{"id": "wllcRf", "name": "Jade jungle", "author": "jarble", "description": "This fractal has many flower-like shapes, with a nice \"jade\" color.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 280, "published": 3, "date": "1592690805", "time_retrieved": "2024-07-30T21:00:04.549053", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p *= 10.0;\n    float color1 = length(sin(p/1000.0))/2.0;\n    return vec3(color1/2.0,color1/1.8+sin(length(p/10.0)/10.0)/20.0,color1/2.0);\n}\n\n//vec3 surface_color(vec3 p){\n//\treturn (surface_color1(p)*(3.0/5.0)+surface_color1(p*5.0))*(2.0/5.0);\n//}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    //p1 += sin(length(p/50.0+iTime))/5.0;\n    return length((cos(length(p/100.0)/(3.0+cos(p/size))))*size) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*(50.0);\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 10.0; i *= 2.0){\n    \tresult = max(result,planet_surface(p*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale-0.5;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    return mat3(s, cross(s, f), -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 7.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 311, 311, 455], [807, 807, 836, 879, 954], [956, 956, 980, 980, 1231], [1233, 1654, 1745, 1745, 2051], [2066, 2320, 2385, 2385, 2517], [2519, 2608, 2637, 2637, 2947], [2949, 3441, 3581, 3581, 4191], [4193, 4563, 4648, 4648, 5420], [5422, 5749, 5798, 5833, 5948], [5950, 5950, 6007, 6007, 6977]], "test": "untested"}
{"id": "wtlyRf", "name": "Sandstone pillars", "author": "jarble", "description": "This fractal resembles a weathered sandstone canyon.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 268, "published": 3, "date": "1592687422", "time_retrieved": "2024-07-30T21:00:05.381827", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    float color1 = length(sin(p/1000.0))/1.5;\n    return vec3(color1,color1/1.8+sin(length(p/10.0)/10.0)/20.0,color1/2.0);\n}\n\n//vec3 surface_color(vec3 p){\n//\treturn (surface_color1(p)*(3.0/5.0)+surface_color1(p*5.0))*(2.0/5.0);\n//}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    //p1 += sin(length(p/50.0+iTime))/5.0;\n    float l1 = length(p/100.0);\n    p = (cos(p1+l1/(10.0+sin(p1+l1))))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*50.0;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 10.0; i *= 2.0){\n    \tresult += max(result,planet_surface(p*i)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    return mat3(s, cross(s, f), -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 7.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 377, 377, 502], [854, 854, 883, 883, 1056], [1058, 1058, 1082, 1082, 1334], [1336, 1757, 1848, 1848, 2154], [2169, 2423, 2488, 2488, 2620], [2622, 2711, 2740, 2740, 3050], [3052, 3544, 3684, 3684, 4294], [4296, 4666, 4751, 4751, 5523], [5525, 5852, 5901, 5936, 6051], [6053, 6053, 6110, 6110, 7273]], "test": "untested"}
{"id": "wllczX", "name": "Phyllotaxes", "author": "tdhooper", "description": "4k executable graphics entry for Nova 2020", "tags": ["plant", "phyllotaxis", "succulent", "exegfx", "nova2020"], "likes": 133, "viewed": 8045, "published": 3, "date": "1592686869", "time_retrieved": "2024-07-30T21:00:06.397112", "image_code": "\n/*\n\n    Phyllotaxes\n    -----------\n\n\t4k executable graphics entry for Nova 2020\n\n\tModel from my earlier succulent shaders:\n\n\t    Bloom [skull] https://www.shadertoy.com/view/WdScDG\n\t    Echeveria II https://www.shadertoy.com/view/WtGXWm\n\t    Echeveria https://www.shadertoy.com/view/wlVGRz\n\n\tLighting and tracing loop adapted from yx's Primitive Portrait:\n\n\t    https://www.shadertoy.com/view/ts2cWm\n\n*/\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb / float(iFrame + 1);\n    col *= 2.;\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007);\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.3);\n    \n\tcol = mix(col, vec3(Luma(col)), .25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n\tcol = max(col, vec3(0));\n    col = pow( col, vec3(0.4545) );\n    col = aces(col);\n\tfragColor.rgb = col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// HG_SDF\n\n#define PI 3.1415926\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n\n// hash function by Blackle\n// https://suricrasia.online/demoscene/functions/\n//#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return (float((x-y*y)*(x*x+y)-x)/2.14e9) * .5 + .5;\n}\n\nvec2 hash22(vec2 p){\n    return vec2(hash(p), hash(p + vec2(1)));\n}\n\nvec2 hash12(float n) {\n\treturn hash22(vec2(n));\n}\n\nfloat hash31(vec3 p) {\n  return hash(p.xy + p.z * 1.6453);\n}\n\nvec3 hash33(vec3 p){\n    return vec3(\n        hash31(p),\n        hash31(p + vec3(0.3183099, 0.3678794, 0.5376431)),\n        hash31(p + vec3(0.167348, 0.665734, 0.84331))\n    );\n}\n\n// noise function by IQ\n// https://www.shadertoy.com/view/4sfGzS\nfloat noise31(const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash31(p+vec3(0,0,0)), \n                        hash31(p+vec3(1,0,0)),f.x),\n                   mix( hash31(p+vec3(0,1,0)), \n                        hash31(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(p+vec3(0,0,1)), \n                        hash31(p+vec3(1,0,1)),f.x),\n                   mix( hash31(p+vec3(0,1,1)), \n                        hash31(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(const in vec3 p, const in int octaves) {\n    float accum = 0.;\n    vec3 temp_p = p;\n    float weight = 1.;\n    for (int i=0; i<octaves; i++) {\n        accum += weight * noise31(temp_p);\n        weight *= .5;\n        temp_p *= 2.;\n    }\n    return abs(accum);\n}\n\nfloat voronoi3( in vec3 x )\n{\n    vec3 cell = floor(x);\n    float d = 1e12;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 offset = vec3(float(i),float(j),float(k));\n        vec3 pos = hash33( cell + offset );\n        vec3 r = cell + offset + pos;\n        d = min(d, length(x - r));\n    }\n    return d;\n}\n\n//========================================================\n// Modelling\n//========================================================\n\nstruct Model {\n    float d;\n    int id;  \n    vec3 pos;\n    vec2 uv;\n    vec2 cell;\n    float cellt;\n    float wedges;\n    float slice;\n    float len;\n    float edge;\n    float point;\n};\n\nModel newModel() {\n    return Model(1e12, 0, vec3(0), vec2(0), vec2(0), 0., 0., 0., 0., 0., 0.);\n}\n\nModel opU(Model a, Model b) {\n    Model m = a;\n    if (b.d < a.d) {\n        m = b;\n    }\n    return m;\n}\n\nfloat hitEps = .001;\n\nstruct BloomSpec {\n    float stretch;\n    vec2 minmax;\n    float size;\n    float boundSize;\n    float width;\n    float thickness;\n    float pointy;\n    float cutback;\n    vec3 color;\n};\n\nfloat rangec(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\n// Adapted from https://www.shadertoy.com/view/WdScDG\nModel leaf(vec3 p, vec3 cellData, BloomSpec spec) {\n    \n    float scale = spec.size * .78;\n    p /= scale;\n    \n    float thickness = spec.thickness;\n    float width = spec.width;\n    float pointy = spec.pointy;\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z * 2.;\n    \n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    vec3 pp = p;\n\n    float core = length(p) - .1;\n\n    float len = cellTime;\n\n    len *= mix(1., mix(.2, 1., rangec(.8, .6, cellTime/2.)), spec.cutback);\n    \n  \tlen = pow(len, .33);\n\n    float llen = len;\n\n    Model model = newModel();\n\n    float top = p.y - len * .5;\n    float curve = smoothstep(0., .6, cellTime);\n    float lenCurve = len * mix(1.5, .65, curve);\n    pR(p.zy, -mix(.2, .7, curve));\n    slice = length(p - vec3(0,lenCurve,0)) - lenCurve;\n\n    p = pp;\n    float point = (p.z / len - .8) * 5. * (.5 - slice / thickness);\n\n    // wedge\n    float ins = .25;\n    p.z += ins;\n    vec3 n = normalize(vec3(1,0,.35));\n    wedge = -dot(p, n);\n    wedge = smax(wedge, dot(p, n * vec3(1,1,-1)), clamp((slice / thickness / 2.) + .25, 0., 1.) * .1);\n    wedge = smax(wedge, p.z - len*1.12 - ins, len);\n    p.z -= ins;\n\n    // wedge2\n    ins = .2;\n    p.z += ins;\n    n = normalize(vec3(1,0,width));\n    float wedge2 = -dot(p, n);\n    wedge2 = smax(wedge2, dot(p, n * vec3(1,1,-1)), .1);\n    wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n    p.z -= ins;\n\n    float r = len / 8.;\n\n    d2 = abs(slice) - thickness;\n    d2 = max(d2, top);\n\n    float wedgeT = smax(d2, wedge, thickness);\n    float wedgeT2 = smax(d2, wedge2, thickness);\n    d = mix(wedgeT2, smin(wedgeT, wedgeT2, .01), pointy);\n    wedges = mix(wedge2, wedge2, pointy);\n\n    p = pp;\n    vec2 uv = p.xz / len;\n\n    model.pos = p;\n    model.d = d * scale;\n    model.uv = uv;\n    model.cell = cell;\n    model.cellt = cellData.z;\n    model.wedges = mix(wedge2, smin(wedge, wedge2, .01), pointy);\n    model.slice = slice;\n    model.len = len;\n    model.edge = distance(model.wedges*1.5, (slice + thickness / 2.));\n    model.point = point;\n\n    return model;\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x / cc.y);\n    float scale = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1./scale,0,0,1./scale);\n    phyllotaxis = mRot * mScale;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    mat2 worldToGrid,\n    mat2 gridToWorld,\n    BloomSpec spec\n) {\n    // Snap to cell center and move to neighbour\n    cell = gridToWorld * (round(worldToGrid * cell) + offset);\n\n    // Clamp first and last cell\n    float o = .5 / spec.stretch;\n    cell.y = clamp(cell.y, spec.minmax.x + o, spec.minmax.y - o);\n    cell = gridToWorld * round(worldToGrid * cell);\n\n    // Calc cell time\n    float t = 1. - (cell.y - spec.minmax.x) / (spec.minmax.y - spec.minmax.x);\n\n    return vec3(cell, t);\n}\n\nModel mBloom(\n    vec3 p,\n    int id,\n    BloomSpec spec\n) {\n    Model model = newModel();\n    float bound = length(p) - spec.boundSize;\n\n    if (bound > hitEps * 2.) {\n        model.d = bound;\n        return model;\n    }\n    vec3 pp = p;\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz))\n    );\n    spec.minmax = spec.minmax * PI / 2.;\n    mat2 worldToGrid = phyllotaxis * mat2(1,0,0,spec.stretch);\n    mat2 gridToWorld = inverse(worldToGrid);    \n    for( int m=-1; m<=1; m++ )\n    for( int n=-1; n<=1; n++ )\n    {\n        vec3 cellData = calcCellData(cell, vec2(m,n), worldToGrid, gridToWorld, spec);\n        p = pp;\n        pR(p.xz, -cellData.x);\n        pR(p.zy, cellData.y);\n        model = opU(model, leaf(p, cellData, spec));\n    }\n    model.id = id;\n    return model;\n}\n\nModel map(vec3 p) {\n\n    Model model = newModel();\n\n    float bound = p.y - .7;\n    if (bound > hitEps * 2.) {\n        model.d = bound;\n        return model;\n    }\n    \n    vec3 pp = p;\n       \n    pR(p.xz, .49);\n    model = opU(model, mBloom(p, 1, BloomSpec(2.5, vec2(-.25, 1.), 1., .85, .37, .045, 1., .6, vec3(.5))));\n    \n   \tp = pp;\n    p -= vec3(-1.1,.06,0.15);\n    pR(p.xz, 8.1);\n    float f = dot(p, normalize(vec3(1.2,0,1)));\n\tmodel = opU(model, mBloom(p, 2, BloomSpec(1.9, vec2(.2, 1.), 1.3, .8, .13, .03, 0., smoothstep(.5, -.1, f) * 1.0, vec3(.5))));\n\n   \tp = pp;\n    p -= vec3(-.7,.1,.8);\n    pR(p.xz, 1. + 2.6);\n    model = opU(model, mBloom(p, 3, BloomSpec(1.05, vec2(-.25, 1.), .45, .45, .41, .15, .5, -.5, vec3(.5))));\n\n    return model;\n}\n\n//========================================================\n// Rendering\n//========================================================\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nmat3 basisMatrix(vec3 forward, vec3 up) {\n    vec3 ww = normalize(forward);\n    vec3 uu = normalize(cross(up,ww));\n    vec3 vv = normalize(cross(ww,uu));\n    return mat3(-uu, vv, ww);\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    float len;\n    bool sky;\n};\n\nHit march(vec3 origin, vec3 rayDir, float maxDist) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    bool sky = false;\n    Model model;\n\n    for (float i = 0.; i < 150.; i++) {\n        len += dist;\n        p = origin + len * rayDir;\n        model = map(p);\n        dist = model.d;\n        if (dist < hitEps) {\n            break;\n        }\n        if (len >= maxDist) {\n            sky = true;\n            break;\n        }\n    }   \n\n    return Hit(model, p, len, sky);\n}\n\n// bokeh offset from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec2 bokeh(vec2 seed){\n\tvec2 a=seed;\n    if(a.y>a.x)\n        a=1.-a;\n    a.y*=PI*2./a.x;\n    return a.x*vec2(cos(a.y),sin(a.y));\n}\n\n// texturing, this is pretty messy :/\nvec4 shade(Hit hit) {\n    Model model = hit.model;\n    vec3 p = hit.pos;\n\n    vec3 col;\n\n    float vor = 1. - voronoi3(p * 150.);\n    float vor2 = 1. - voronoi3(p * 50.);\n    float v1 = smoothstep(.7, .0, (mix(vor, vor * vor2, .5))/2. + .8 - model.edge * 20.);\n\n    vec3 mp = model.pos*30.;\n\n    if (model.id == 2) {\n        mp *= 2.5;\n    }\n    if (model.id == 1) {\n        mp *= 1.25;\n    }\n\n    float f = fbm(mp, 7);\n    float v = smoothstep(.4, .8, noise31(p * 8.));\n    \n    if (model.id == 1) {\n        col = vec3(.15,.16,.22);\n        col = mix(col, col * vec3(.8,1.4,.9), 1.-smoothstep(.0, .05, model.slice+.025));\n        //col = mix(col, col * vec3(1,1.2,1.5), smoothstep(.0, .05, model.edge) * step(vor2, .8) * smoothstep(1.3, .6, model.cell.y));\n        col = mix(col, col *  vec3(1,1.2,1.5), smoothstep(.0, .05, model.edge) * step(vor2, .8) * smoothstep(.1, .52, model.cellt));\n        col = mix(col, col * .7, (1. - step(vor2, .8)) * smoothstep(.0, .05, model.edge));\n        //col = mix(col, col * vec3(3.,1.,1.), (1.-v1) * smoothstep(.05, 0., model.edge) * smoothstep(.6, 1., model.uv.y) * smoothstep(1.3, .6, model.cell.y));\n        col = mix(col, col * vec3(3.,1.,1.), (1.-v1) * smoothstep(.05, 0., model.edge) * smoothstep(.6, 1., model.uv.y) * smoothstep(.1, .52, model.cellt));\n        //col = mix(col, vec3(.08,.02,.07), (1.-v1) * smoothstep(-.1, 0., model.wedges) * smoothstep(.9, 1., model.uv.y) * smoothstep(2., 1., model.cell.y));\n        col = mix(col, vec3(.08,.02,.07), (1.-v1) * smoothstep(-.1, 0., model.wedges) * smoothstep(.9, 1., model.uv.y) * smoothstep(-.2, .3, model.cellt));\n        col = max(col, vec3(0));\n        col = pow(col * vec3(1,1,1.6), vec3(1,1.1,1.3));      \n    }\n\n    if (model.id == 2) {\n        col = vec3(.2,.3,.25);\n        col = mix(col, vec3(.1,.25,.3), smoothstep(.7, .1, model.uv.y));\n        col = mix(col, vec3(.7,.9,1), .5 * smoothstep(.4, 1., model.uv.y));\n        col = mix(col, col * vec3(2.,3.,3.5), smoothstep(.8, .1, model.uv.y) * clamp(sin(f * 2. + 10. + v * 5.), 0., 1.) );\n    }\n\n    if (model.id == 3) {\n        col = vec3(.125,.15,.3);\n        col = mix(col, vec3(.3,.17,.3), smoothstep(.6, .2, model.cellt));\n        col = mix(col, vec3(.2,.05,.12), smoothstep(.0, 1., model.point+.2));\n        col = mix(col, col * vec3(.45,.4,.55), .7 * (1. - step(vor * (1.-vor2), .35)) * smoothstep(.0, .05, model.edge));\n        col = mix(col, vec3(.2,.05,.12) * .5, .8 * smoothstep(.4, .0, vor2 * vor * (model.edge * 100. - model.point - .5)));\n    }\n\n    float dust = (sin(f * 4. + 3. + mp.x * .25) * .5 + .5);\n    dust = pow(dust, 2.);\n    dust = max(0., v - dust);\n    dust = dust * .5 + pow(dust*.79, 3.);\n    \n    if (model.id == 1) {\n\t    dust *= smoothstep(.008, .1, model.edge);\n        dust *= .66;\n    }\n    \n    if (model.id == 3) {\n\t    dust *= smoothstep(.0, .05, model.edge);\n        dust *= .2;\n    }\n    \n    dust *= mix(1., smoothstep(.4, .6, 1.-vor), .5);\n    col = mix(col, col * 3., dust);\n\n    return vec4(col, 1.);\n}\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    calcPhyllotaxis();\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sampl = vec4(0);\n    \n    #ifdef PREVIEW\n        sampl = vec4(0);\n    #endif\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n\n    vec2 seed = hash22(uv * 200. + iTime * .01);\n    vec2 seed2 = hash22(uv * 300. + iTime * .02);\n\n    // jitter for antialiasing\n    #ifndef PREVIEW\n        p += 2. * (seed - .5) / iResolution.xy;\n    #endif\n\n    vec3 camPos = vec3(.025,2.4,1.025);\n    vec3 camTar = vec3(-.475,-.2,.025);\n\n    camTar = mix(camTar, camPos, .25);\n    \n    #ifndef PREVIEW\n        mat3 bokehMat = basisMatrix(camTar - camPos, vec3(1,0,0));\n    \tcamPos += bokehMat * vec3(bokeh(seed2) * .02, 0);\n    #endif\n\n    mat3 camMat = basisMatrix(camTar - camPos, vec3(-1,1,-2));\n    vec3 rayDir = normalize(camMat * vec3(p.xy, 4.));\n\n    vec3 origin = camPos;\n\n    Hit hit;\n    vec3 col = vec3(0);\n    vec3 nor, ref;\n\n    vec3 sunPos = vec3(5,5,-5);\n    vec3 accum = vec3(1);\n    vec3 sunColor = vec3(8.10,6.00,4.20)/5.;\n    vec3 skyColor = vec3(0.50,0.70,1.00);\n    vec3 bgCol = skyColor * .001 * vec3(.75,.75,1.);\n    \n    Hit firstHit;\n\n    #ifdef PREVIEW\n        const int MAX_BOUNCE = 1;\n    #else\n        const int MAX_BOUNCE = 4;\n    #endif\n    \n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n        hit = march(origin, rayDir, 15.);\n        \n        if (bounce == 0) {\n            firstHit = hit;\n            \n            if (hit.sky) {\n            \tcol = bgCol;\n                break;\n            }\n        }\n        \n        if (hit.sky) {\n            nor = normalize(hit.pos);\n            col += max(nor.y, 0.) * accum * skyColor;\n           \tcol += smoothstep(.2, 1., dot(nor, normalize(sunPos))) * sunColor * accum;\n            break;\n        }\n        \n       \tvec4 material = shade(hit);\n        accum *= material.rgb;\n        nor = calcNormal(hit.pos);\n\n        #ifdef PREVIEW\n            col += max(nor.y + .3, 0.) * accum * skyColor * .5;\n           \tcol += smoothstep(.2, 1., dot(nor, normalize(sunPos))) * sunColor * accum * .5;\n        #endif\n        \n        // shoot randomly perturbed ray towards sun,\n        // if it doesn't hit geo, add to result\n        vec3 sunDirection = sunPos - hit.pos;\n        vec3 sunSampleDir = getConeSample(sunDirection, .005, seed);\n        float sunLight = dot(nor, sunSampleDir);\n        vec3 shadowOrigin = hit.pos + nor * .01;\n        bool hitSun = sunLight > 0. && march(shadowOrigin, sunSampleDir, 5.).sky;\n        \n        if (hitSun) {\n            col += accum * sunColor * sunLight;\n        }\n\n        // set new origin and direction for dffuse bounce\n        origin = hit.pos + nor * .002;\n        rayDir = getSampleBiased(nor, 1., seed);\n\n        seed = hash12(seed.x);\n    }\n    \n    float fog = 1. - exp((firstHit.len - 1.9) * - 5.);\n    col = mix(col, bgCol, clamp(fog, 0., 1.)); \n\n    col /= 2.;\n    \n    fragColor = vec4(col,1);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    #ifdef TRACE_PREVIEW\n\t\tfragColor = col * float(iFrame + 1); return;\n    #endif\n    #ifdef PREVIEW\n\t\tfragColor = col * float(iFrame + 1); return;\n    #endif\n\tvec4 last = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    fragColor = last + col;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define PREVIEW;\n//#define TRACE_PREVIEW;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 427, 427, 618], [620, 718, 742, 742, 793], [795, 795, 850, 850, 1342]], "test": "untested"}
{"id": "ttlyRX", "name": "Hey VJ show me your screen, p1.", "author": "postviolet", "description": "my next tattoo will like \"sin(iTime)\".", "tags": ["2d"], "likes": 2, "viewed": 296, "published": 3, "date": "1592665564", "time_retrieved": "2024-07-30T21:00:07.233875", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nconst int TIMES = 10;\nconst float ZOOM = 20.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv*rotate2d(5.);\n\nfor(int i = 0; i < TIMES; i++) {\n            float dist = distance(st.x, st.y);\n\n            st.x = st.x + sin(st.y + sin(dist*0.5)) + noise(uv)+iTime;\n            st.y = st.y - cos(st.x + cos(dist*0.5)) + noise(uv)+iTime;\n        }\n\n    fragColor = vec4(noise(sin(st*0.5+iTime)),0.,noise(sin(st/0.2+iTime)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 143], [145, 145, 167, 167, 465], [467, 467, 494, 494, 576], [626, 626, 683, 683, 1072]], "test": "untested"}
{"id": "WtsczX", "name": "Moiré challenge (paradoxal ?)", "author": "FabriceNeyret2", "description": "This Moiré pattern is tuned so as to make a square fitting screen height.  ( variants in comments ).\nChallenge: could you it deform into a rectangle fitting the window ?\n( without storing it as a texture in BuffA ;-) )", "tags": ["aliasing", "moir", "challenge"], "likes": 2, "viewed": 362, "published": 3, "date": "1592630962", "time_retrieved": "2024-07-30T21:00:08.034733", "image_code": "// inspired by wj's https://shadertoy.com/view/wtXczf\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = u - vec2(R.y/2.,0) ;\n    O +=    fract(U.x*U.y/R.y)\n         * ( abs(u.x-R.y)<R.y/2.?1.:.5 ); }\n//  O += fract(U.x*U.y/R.y + iTime)                   \\\n//  O += abs(u.x-R.y)<R.y/2. ? fract(U.x*U.y/R.y) : 0.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 91, 91, 229]], "test": "untested"}
{"id": "wlXczf", "name": "Lord Oculon's Birthday", "author": "blackle", "description": "coded in 1 hour 30 minutes for the Nova 2020 shader freestyle. the sacrificial altar sure looks like a birthday cake!", "tags": ["eyes", "eye", "livecode", "shaderfreestyle"], "likes": 34, "viewed": 760, "published": 3, "date": "1592609657", "time_retrieved": "2024-07-30T21:00:08.887454", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nconst float bpm = 168.;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec3 arot(vec3 p, vec3 a, vec3 b) {\n    vec3 ax = normalize(cross(a,b));\n    float ro = acos(dot(a,b));\n    return erot(p,ax,ro);\n}\n\nvec3 urot(vec3 p, vec3 a, vec3 b, vec3 u) {\n    float ang = atan(dot(u,cross(a,b)), dot(a,b));\n    p = erot(p, u, ang);\n    a = erot(a, u, ang);\n    return arot(p,a,b);\n}\n\nvec3 face(vec3 p) {\n    vec3 ap = abs(p); vec4 k = vec4(sign(p),0);\n    if (ap.x >= max(ap.y,ap.z)) return k.xww;\n    if (ap.y >= max(ap.x,ap.z)) return k.wyw;\n    if (ap.z >= max(ap.y,ap.x)) return k.wwz;\n}\n\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = sign(p);\n    vec3 a = v*mask.zxy;\n    vec3 b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a),y=FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat pentagram(vec2 p) {\n    float dist = 10000.;\n    for (int i = 0; i < 5; i ++ ){\n        float ang = float(i)*3.14/5.*2.;\n        float ang2 = float(i+2)*3.14/5.*2.;\n        vec2 a = vec2(sin(ang), cos(ang));\n        vec2 b = vec2(sin(ang2), cos(ang2));\n        dist = min(linedist(p,a,b),dist);\n    }\n    return dist;\n}\n\nvec3 lpos;\nvec3 id;\nfloat pedistal;\nfloat l1;\nfloat dbg;\nfloat torch;\nfloat scene(vec3 p) {\n    vec3 op = p;\n    \n    vec2 pc = vec2(length(p.xy),p.z);\n    pedistal = box(pc+vec2(0.,3.8), vec2(2.,0.1));\n    float ang = atan(p.x,p.y);\n    pedistal += smoothstep(-.2,.2,sin(ang*100.))*.02;\n    pedistal = min(pedistal, box(pc+vec2(0.,3.8), vec2(1.9,0.15)));\n    float ang2 = round(ang*4.)/4.;\n    vec2 clos = vec2(sin(ang2),cos(ang2))*1.7;\n    \n    float ang3 = round(ang*2.)/2.;\n    vec2 clos2 = vec2(sin(ang3),cos(ang3))*2.;\n    \n    pc = vec2(length(p.xy-clos),p.z);\n    vec2 pc2 = vec2(length(p.xy-clos2),p.z);\n    dbg = sin(min(pentagram(p.xy),pc.x)*100.);\n    pedistal = min(pedistal, box(pc+vec2(0.,4.), vec2(.01,0.8)))-0.03;\n    pedistal = min(pedistal, box(pc2+vec2(0.,6.5), vec2(.1,2.8)));\n    torch = box(pc+vec2(0.,3.2), vec2(.05,0.05));\n    pedistal = min(torch, pedistal);\n    \n    \n    vec3 beyp = vec3(7,0,0);\n    id = floor(p)+.5;\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z < 0.) id += face(p-id);\n    float sd = hash(hash(id.x,id.z),id.y);\n    if (length(id) < 6. || sd < -0.5 || distance(id,beyp) < 3.7) {\n        id += edge(p-id);\n    }\n    p -= id;\n    float balls = max(5.-length(op),length(p)-.7);\n    l1 = distance(op,lpos) - .3;\n    if (distance(op,beyp) < 3.1) {\n        id = beyp;\n    }\n    balls = min(distance(op,beyp) - 3.,balls);\n    return min(pedistal, min(l1, balls));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float bpmt = iTime/60.*bpm;\n    float t = mix(pow(sin(fract(bpmt)*3.14/2.),50.) + floor(bpmt), bpmt, 0.8);\n    lpos = vec3(sin(t),cos(t),sin(t/3.))*4.;\n    vec3 cam = normalize(vec3(.8 + sin(t*3.14)*.2,uv));\n    vec3 init = vec3(-3.5+cos(t*3.14/2.),0,0) + cam*.1;\n    \n    cam = erot(cam, vec3(0,1,0), sin(t/2.-.5)*.5);\n    init = erot(init, vec3(0,1,0), sin(t/2.)*.5);\n    cam = erot(cam, vec3(0,0,1), cos(t/5.-.5)*.5);\n    init = erot(init, vec3(0,0,1), cos(t/5.)*.5);\n    cam = erot(cam, vec3(1,0,0), (asin(sin(t/2.))*-1.)*.2);\n    init.z -= 2.; \n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glo = 0.;\n    float glo2 = 0.;\n    for (int i = 0; i < 100 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        glo += 100./(1.+l1*2000.)*dist;\n        glo2 += 200./(1.+torch*5000.)*dist;\n    }\n    float dbgg = dbg;\n    bool tc = torch == dist;\n    bool pd = dist == pedistal;\n    vec3 lid = id;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    \n    vec3 lookat = normalize(init-lid);\n    vec3 lookat2 = normalize(lpos-lid);\n    lookat = normalize(mix(lookat,lookat2,smoothstep(8.,5.,distance(lid,lpos))));\n\n    vec3 eycrd = urot(n, lookat, vec3(1,0,0), vec3(0,0,1));\n    float ey = eycrd.x;\n    float garble = atan(eycrd.y,eycrd.z) + dot(sin(eycrd.yz*11.),sin(eycrd.yz*25.))*.05;\n    garble = (sin(garble*50.)+sin(garble*131.))*.2+.9;\n    \n    vec3 ldir = normalize(lpos-p);\n    float ao = smoothstep(12.,6.,length(p));\n    float nd = dot(ldir,n)*.5+.5;\n    float rd = max(0.,dot(ldir,n));\n    float fres = 1.-abs(dot(cam,n))*.98;\n    vec3 ecol = vec3(0.3,0.4,0.7);\n    float sd1 = hash(hash(lid.x,lid.y),lid.z);\n    float sd2 = hash(sd1,sd1);\n    ecol = erot(ecol, vec3(0,1,0), sd2);\n    ecol = erot(ecol, vec3(1,0,0), sd1*.4)*garble;\n    float atten = 3./pow(distance(p,lpos),1.4) + .4/pow(length(vec2(length(p.xy)-1.8, p.z+3.2)), 1.2);\n    \n    vec3 dcol = mix(vec3(.9),ecol, smoothstep(.8,.9,ey));\n    dcol = mix(dcol,vec3(0), smoothstep(.95,.98,ey));\n    \n    if (pd) dcol = vec3(0.5,0.4,0.3)*(dbgg*.25+.75);\n    vec3 col = (dcol*nd + pow(smoothstep(.7,1.,rd),100.)*fres*1.2)*ao*atten;\n    if (distance(lpos,p) < .4) {\n        col = vec3(0.2,0.5,0.9);\n    }\n    if (tc) col = vec3(0.8,0.5,0.2);\n    fragColor.xyz = (hit ? col : vec3(.1))+glo*glo + glo*vec3(0.2,0.5,0.9) +glo2*glo2 + glo2*vec3(0.8,0.5,0.2);\n    fragColor = smoothstep(vec4(0.1),vec4(1.02),sqrt(fragColor));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXczf.jpg", "access": "api", "license": "cc0-1.0", "functions": [[219, 219, 257, 257, 319], [321, 321, 356, 356, 452], [454, 454, 497, 497, 624], [626, 626, 645, 645, 833], [835, 835, 854, 854, 1010], [1068, 1068, 1098, 1098, 1171], [1173, 1173, 1200, 1200, 1278], [1280, 1280, 1320, 1320, 1411], [1413, 1413, 1438, 1438, 1738], [1810, 1810, 1831, 1831, 3153], [3155, 3155, 3174, 3174, 3287], [3289, 3289, 3346, 3346, 5868]], "test": "untested"}
{"id": "ttXczf", "name": "Day 182 v2", "author": "jeyko", "description": "ooo", "tags": ["mdtmjvm"], "likes": 5, "viewed": 312, "published": 3, "date": "1592605995", "time_retrieved": "2024-07-30T21:00:09.720227", "image_code": "// Fork of \"Day ilostcount, will update tmrw\" by jeyko. https://shadertoy.com/view/3lXczf\n// 2020-06-19 22:30:04\n\n\n#define T iTime\n\n#define pi acos(-1.)\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pmod(p,j) mod(p - 0.5*j,j)  - 0.5*j\n\nfloat sdBox(vec3 p, vec3 s){\n  p = abs(p) - s;\n  return max(p.x,max(p.y,p.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv*=1.5;\n\n  vec3 col = vec3(0,0.5,0.5);\n  \n  float tt = T*0.82;\n  \n  uv += vec2(cos(tt*0.7 + cos(tt/2.)), sin(tt*0.9) + sin(tt*0.6))/3.;\n  \n\n  vec3 p = vec3(uv,1);\n  \n  p = mix(p,p/dot(p,p),smoothstep(0.,1.,mod(iTime/4.,2.)-smoothstep(0.,1.,mod(iTime/4. + 1.,2.))));\n  \n  //p.xy = vec2(atan(p.y,p.x)*pi*2./7.,log(length(p.xy) ));\n\n  p.x += tt*0.003;\n  p.y += tt*0.003;\n  p.xz *= rot(0.25*pi - sin(T/2.)/20. + tt*0.1);\n  \n  p.xy *= rot(0.25*pi + sin(T/2.)/20.);\n\n\n  \n  p = pmod(p,0.3);\n  \n  \n  //\n  col = mix(col,vec3(0.1,0.1,0.5),smoothstep(0.001,0.,abs(length(p-0.1)-0.1)-0.02));\n  \n  \n  // \n  float db = sdBox(p - 0.01,vec3(0.1));\n  db = abs(db) - 0.01;\n  \n  col = mix(col,vec3(0.0,0.8,0.5)*1.,smoothstep(0.001,0.,db));\n  \n  // \n  db = sdBox(p,vec3(0.1));\n  col = mix(col,vec3(0.1,0.4,0.1)*4.,smoothstep(0.001,0.,db));\n  \n  //\n  db = sdBox(p,vec3(0.1));\n  \n  db = abs(db)-0.01;\n  col = mix(col,vec3(0.9,0.4,0.5)*0.1,smoothstep(0.001,0.,db));\n  \n  // circ\n  db = length(p + 0.05)-0.05;\n  db = abs(db) - 0.01;\n\n  \n  col = mix(col,vec3(0.9,0.4,0.1)*4.,smoothstep(0.001,0.,db));\n  \n  \n  \n\n  \n  col = pow(col,vec3(0.454545));\n  fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 323, 323, 375], [377, 377, 434, 434, 1653]], "test": "untested"}
{"id": "3lXczf", "name": "Day 182", "author": "jeyko", "description": "ooo", "tags": ["mdtmjvm"], "likes": 7, "viewed": 289, "published": 3, "date": "1592605313", "time_retrieved": "2024-07-30T21:00:10.536046", "image_code": "\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\nfloat sdBox(vec3 p, vec3 s){p = abs(p) - s; return max(p.x,max(p.y,p.z));}\n\n#define pmod(p,j) mod(p - 0.5*j,j) - 0.5*j \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv*=3.;\n    \n    uv.xy += vec2(sin(iTime)/6.,cos(iTime)/5.);\n    \n    vec3 col = vec3(0.4,0.6,0.5)/1.;\n\n    \n    vec3 p = vec3(uv,1.);\n    #define pi acos(-1.)\n    \n    p.yx *= rot(0.0*pi );\n    \n    p.yz *= rot(0.25*pi + 0.  - iTime*0.02);\n    \n    p.xz *= rot(0.25*pi + sin(iTime)/20.);\n    \n    \n    p /= dot(p,p);\n    \n    \n    p.x += iTime/20.;\n    /*\n    p.x -=  iTime/10.;\n    p.y +=  iTime/30.;\n    \n    \n    p.z -= iTime/20.;\n    */\n    \n    p = pmod(p,0.45);\n    \n    \n    float d;\n    \n    d = length(p-0.1)-0.1;\n    col = mix(col,vec3(0.1,0.4,0.6)/5.,smoothstep(0.002,0.,abs(d)-0.03));\n   \n    \n    // --\n    d = sdBox(p-0.01,vec3(0.14,0.3,0.1)/1.);\n    col = mix(col,vec3(0.4,0.9,0.7)/0.6,smoothstep(0.001,0.,d-0.01));\n    \n    \n    d = sdBox(p,vec3(0.14,0.3,0.1)/1.);\n    col = mix(col,vec3(1,0.9,0.4),smoothstep(0.001,0.,d));\n    \n    col = mix(col,vec3(0.44,0.71,0.91),smoothstep(0.002,0.,abs(d)-0.01));\n    \n    \n    \n    // --\n    \n    d = sdBox(p-0.01,vec3(0.1,0.1,0.1)/1.);\n    col = mix(col,vec3(0.1,0.4,0.6)/20.,smoothstep(0.002,0.,d));\n    \n    d = sdBox(p,vec3(0.1,0.1,0.1)/1.);\n    col = mix(col,vec3(0.1,0.4,0.6),smoothstep(0.002,0.,d));\n    \n    \n    \n    \n    p.yx *= rot(0.5*pi);\n    d = sdBox(p,vec3(0.02,0.02,0.4)/1.);\n    col = mix(col,vec3(0.9,0.4,0.6),smoothstep(0.002,0.,abs(d)-0.01));\n    \n    p.yx *= rot(-0.5*pi);\n    col /= 1. + col;\n    col = smoothstep(0.,1.,col*1.6);\n    \n    col = pow(col,vec3(0.45454));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 79, 79, 125], [172, 172, 229, 229, 1778]], "test": "untested"}
{"id": "wlfczX", "name": "Broken Space Division", "author": "petet", "description": "everyone's first instinct when they learn about raymarching infinite things is to rip off the big man himself, m.c. escher.  so that's exactly what i did", "tags": ["raymarching"], "likes": 11, "viewed": 384, "published": 3, "date": "1592598014", "time_retrieved": "2024-07-30T21:00:11.379790", "image_code": "float hash3d(vec3 p3) {\n    //thank you mr. hoskins\n   \tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z); \n}\n\nfloat valueNoise(vec3 v) {\n    vec3 vfloor=floor(v);\n \tfloat aaa=hash3d(vfloor);\n    float aab=hash3d(vfloor+vec3(0,0,1));\n    float aba=hash3d(vfloor+vec3(0,1,0));\n    float abb=hash3d(vfloor+vec3(0,1,1));\n    float baa=hash3d(vfloor+vec3(1,0,0));\n    float bab=hash3d(vfloor+vec3(1,0,1));\n    float bba=hash3d(vfloor+vec3(1,1,0));\n    float bbb=hash3d(vfloor+vec3(1,1,1));\n    \n    vec3 vfrac=v-vfloor;\n    vfrac=smoothstep(0.,1.,vfrac);\n    \n    float aa=mix(aaa,aab,vfrac.z);\n    float ab=mix(aba,abb,vfrac.z);\n    float ba=mix(baa,bab,vfrac.z);\n    float bb=mix(bba,bbb,vfrac.z);\n    \n    return mix(mix(aa,ab,vfrac.y),mix(ba,bb,vfrac.y),vfrac.x);\n}\n\nfloat sphereSDF(vec3 v, vec3 p, float r) {\n    return length(v-p)-r;\n}\n\nfloat boxSDF(vec3 v, vec3 p, vec3 b) {\n \tvec3 q=abs(v-p)-b;\n\treturn length(max(q,vec3(0.)))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat SDF(vec3 v) {\n    float decay=clamp(valueNoise(30.*v)*valueNoise(80.*v+sin(20.*v.zxy))-0.3,0.,1.);\n    float rounding=0.02*(1.-decay);\n    //vec3 vmod = v-vec3(0.2,0.2,3);\n    vec3 vmod = mod(v,1.);\n    float box1 = boxSDF(vmod, vec3(0.5,0.5,0.5), vec3(.12,.12,.12));\n    float box2 = boxSDF(vmod, vec3(0.5,0.5,0.5),vec3(1.,.03,.03));\n    float box3 = boxSDF(vmod, vec3(0.5,0.5,0.5),vec3(.03,1.,.03));\n    float box4 = boxSDF(vmod, vec3(0.5,0.5,0.5),vec3(.03,.03,1.));\n    \n    \n    float morphtime=iTime*0.1+(v.x-v.y-v.z)*0.02;\n    \n    float noisemorph = 2.*(floor(morphtime)+smoothstep(0.3,0.7,fract(morphtime)));\n    \n    return max(min(box1,min(box2,min(box3,box4))),valueNoise(v+vec3(0.5)+noisemorph)-0.5)-rounding;\n    \t\t\n}\n\nvec3 normal(vec3 v) {\n    const float epsilon = 0.0001;\n    float sdf1=SDF(v);\n \treturn normalize(vec3(SDF(v+vec3(epsilon,0,0))-sdf1,\n                SDF(v+vec3(0,epsilon,0))-sdf1,\n                SDF(v+vec3(0,0,epsilon))-sdf1));\n}\n\nmat2 rotate2d(float theta) {\n \treturn mat2(cos(theta),-sin(theta),sin(theta),cos(theta));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x;\n\tvec3 col = vec3(1);\n    const int ITERATIONS = 60;\n    \n    \n    vec3 camera = vec3(iTime*0.2,0,iTime*0.5);\n    vec3 pos = camera;\n    vec3 dir = normalize(vec3(uv,1.));\n    float theta=iTime*0.1;\n    \n    dir.yz=rotate2d(sin(iTime*0.1))*dir.yz;\n    \n    dir.xz=rotate2d(theta)*dir.xz;\n                  \n    vec3 light=normalize(vec3(-1,1,-2));\n    \n    float fogdist=13.;\n    \n    const float surf_threshold = 0.002;\n    \n    for (int i = 0; i < ITERATIONS; i++) {\n    \tfloat dist = SDF(pos);\n        if (dist < surf_threshold) {\n            //vec3 light = normalize(vec3(0,0,iTime)-pos);\n            vec3 norm = normal(pos);\n            float luminance = 0.5+0.5*dot(norm,light);\n            //col = vec3(valueNoise(pos*10.));\n            col = vec3(0.2)+0.2*texture(iChannel0,vec2(fract(pos.xy+vec2(0,pos.z)))).xyz;\n            col *= luminance;\n            col *= 0.4+0.6*(SDF(pos+norm*0.1)-dist)/0.1;\n            \n           \t//col += length(pos-camera)/fogdist;\n            \n            float fog=float(i)/float(ITERATIONS);\n            \n            col += fog*fog;\n            break;\n        }\n        pos += dir*dist;\n    }\n\t//col+=vec3(hash3d(vec3(200.*uv,iTime)))*0.05; //ez dither\n\tcol += smoothstep(0.3,2.0,length(uv)); //vignette\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 51, 158], [160, 160, 186, 186, 814], [816, 816, 858, 858, 886], [888, 888, 926, 926, 1012], [1014, 1014, 1033, 1033, 1750], [1752, 1752, 1773, 1773, 1983], [1985, 1985, 2013, 2013, 2079], [2081, 2081, 2138, 2189, 3550]], "test": "untested"}
{"id": "3djBDh", "name": "Packed Spheres SDF", "author": "blackle", "description": "a rhombic dodecahedral honeycomb domain repetition!", "tags": ["sdf", "packedspheres", "spherepacking"], "likes": 42, "viewed": 1075, "published": 3, "date": "1592585490", "time_retrieved": "2024-07-30T21:00:12.232510", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//the following functions assume that p is inside the cube of radius 1 centered at the origin\n//closest vertex of the cube to p\nvec3 vertex(vec3 p) {\n    return max(sign(p),vec3(0))*2.-1.;\n}\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(sign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,sign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n//closest edge of the cube to p\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = vertex(p);\n    vec3 a = v*mask.zxy, b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\nfloat hills(vec3 p) {\n    return sin(2.*dot(sin(p.xy/16.), cos(p.xy/4.)))*3.;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\n//rhombic dodecahedron SDF with rounded corners\nfloat rho_dod(vec3 p)\n{\n    float offset = 0.1;\n    float radius = .9;\n    p = sqrt(p*p+offset*offset/2.);\n    p = (p+p.yzx)-radius;\n    return super(max(p,0.))+min(0.,max(p.x,max(p.y,p.z)))-offset;\n}\n\nfloat spheres(vec3 p, out vec3 id, out vec3 loc, float density) {\n    vec3 op = p;\n    id = floor(p)+.5;\n    vec3 d = face(p-id);\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z<0.) id += d;\n    if (id.z + hills(id) > -5.) { //if this ball is absent, get the distance to its neighbour\n        vec3 e = edge(p-id);\n        id += e;\n    }\n    p -= id;\n    float rad = 0.7;\n    float sph = mix(rho_dod(p), length(p)-.7, smoothstep(-.2,.2,cos(iTime)));\n    loc = p;\n    return max((op.z+3.5+hills(op))/2.,sph);\n}\n\nfloat scene(vec3 p) {\n    vec3 id,loc;\n    float s1 = spheres(p, id, loc, 0.4);\n    return s1;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 skycol(vec3 p) {\n    float dt = dot(p,normalize(vec3(1)));\n    float sun = pow(max(dt,0.),10.);\n    return vec3(sun) + .2+dt*.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 samplepos = erot(vec3(-10,0,0), vec3(0,0,1), iTime*.2);\n    vec3 init = vec3(-20.,0,0);\n    \n    float yrot = 0.6+sin(iTime/5.)*.4;\n    float zrot = iTime/4.;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 250 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>50.) break;\n    }\n    float fog = smoothstep(5.,50.,distance(p,init));\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ao = smoothstep(-6.5,-4.8,p.z + hills(p))*smoothstep(-.3,.2,scene(p+n*.2)); //fake \"ao\" based on sphere's depth in the stack\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float spec = length(sin(r*vec3(1.,2.,2.5))*0.5+0.5)/sqrt(3.);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n\n    \n    vec3 col = vec3(.1)*diff*ao + pow(spec,10.)*frens*2.*ao;\n    vec3 bg = skycol(cam);\n    fragColor.xyz = (hit ? mix(col,bg,fog) : bg);\n    fragColor.xyz = smoothstep(vec3(-0.1),vec3(1),sqrt(fragColor.xyz))*smoothstep(2.,.5,length(uv));\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djBDh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 424, 445, 445, 486], [487, 519, 538, 538, 762], [763, 795, 814, 814, 963], [965, 965, 986, 986, 1044], [1046, 1046, 1067, 1067, 1099], [1101, 1149, 1172, 1172, 1349], [1351, 1351, 1416, 1416, 1865], [1867, 1867, 1888, 1888, 1963], [1965, 1965, 1984, 1984, 2100], [2102, 2102, 2123, 2123, 2237], [2239, 2239, 2296, 2296, 3779]], "test": "untested"}
{"id": "3tfyRX", "name": "Animated squares", "author": "vlams1", "description": "Yet another stylized animated background.", "tags": ["background", "stylized"], "likes": 9, "viewed": 374, "published": 3, "date": "1592561557", "time_retrieved": "2024-07-30T21:00:13.081241", "image_code": "mat2 r(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.y*5.+10.)*r(iTime*.1);\n    float id = mod(floor(uv.x)+floor(uv.y),2.);\n    float f = smoothstep(-.6,.6,cos(fract(iTime*(id*2.-1.)+id*.5)*3.1415));\n    vec2 guv = (fract(uv)-.5)*(cos(fract(iTime+id*.5)*6.282)*.5+1.5)*r(f*1.5707);\n    fragColor = vec4(.5,.2,1,1)*(length(max(abs(guv)-.25,0.)) < .1 ? 1. : .6);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 90], [92, 92, 147, 147, 514]], "test": "untested"}
{"id": "tllcR2", "name": "cheap bluenoise", "author": "FabriceNeyret2", "description": "From left to right:\ntexture  white and blue noise,    procedural cheap  white and blue noise.\nbottom: zoom\nClick for for random changing at each frame.", "tags": ["raymarching", "sdf", "banding", "antialiasing", "dithering", "bluenoise", "tuto", "short", "whitenoise"], "likes": 42, "viewed": 3052, "published": 3, "date": "1592547358", "time_retrieved": "2024-07-30T21:00:13.887086", "image_code": "#define T(ch)    texelFetch(ch,ivec2(U) % textureSize(ch,0),0).x\n#define hash(p)  fract(sin(dot(p, vec2(11.9898, 78.233))) * 43758.5453) // iq suggestion, for Windows\n// #define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) // classical verison\n\n// see power spectrum here: https://www.shadertoy.com/view/7dyfzW\n#if 1\nfloat B(vec2 U) {\n    float v = 0.;\n    for (int k=0; k<9; k++)\n        v += hash( U + vec2(k%3-1,k/3-1) ); \n  //return       1.125*hash(U)- v/8.  + .5; // some overbound, closer contrast\n    return .9 *( 1.125*hash(U)- v/8.) + .5; // \n  //return .75*( 1.125*hash(U)- v/8.) + .5; // very slight overbound\n  //return .65*( 1.125*hash(U)- v/8.) + .5; // dimmed, but histo just fit without clamp. flat up to .5 +- .23\n}\n#else\nfloat B(vec2 U) {                           // 5-tap version \n    float v =  hash( U + vec2(-1, 0) )\n             + hash( U + vec2( 1, 0) )\n             + hash( U + vec2( 0, 1) )\n             + hash( U + vec2( 0,-1) ); \n    return  hash(U) - v/4.  + .5;\n}\n#endif\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t = iMouse.z<=0. ? 0. : float(77*iFrame);\n    vec3  R = iResolution,\n          D = vec3(.3*(U+U-R.xy)/R.y, -1),  // ray direction\n          p = 30./R, q;                     // marching point along ray \n    O-=O;\n    int x = int(4.*U.x/R.x);\n    U = mod(U-t,R.xy);\n    if (D.y<0.) U = floor(U/2.);\n    O +=   x == 0 ? T(iChannel0)            // white texture noise\n         : x == 1 ? T(iChannel1)            // blue texture noise\n         : x == 2 ? hash(U)                 // white  procedural noise\n         :          B(U);                   // blue procedural noise\n    \n  //O.x>1. ? O-=O,O.x++ : O.x<0. ? O-=O,O.y++ : t ;   // verify not out of bounds\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1023, 1023, 1059, 1059, 1745]], "test": "untested"}
{"id": "wtlcR2", "name": "anti-banding by white/blue offse", "author": "FabriceNeyret2", "description": "Ray marching ( with regular or adaptive steps ) is prone to band aliasing ( left ).\nA classical solution (middle) is to offset ray start with randomize value (here, white noise texture).\nBut blue noise is visually even better (right).\nBottom: zoom noise. ", "tags": ["raymarching", "sdf", "banding", "antialiasing", "dithering", "bluenoise", "tuto", "short", "whitenoise"], "likes": 10, "viewed": 590, "published": 3, "date": "1592546003", "time_retrieved": "2024-07-30T21:00:14.634089", "image_code": "#define T(ch) texelFetch(ch,ivec2(U-t) % textureSize(ch,0),0).x\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t = iMouse.z<=0. ? 0. : float(37*iFrame);\n    vec3  R = iResolution,\n          D = vec3(.3*(U+U-R.xy)/R.y, -1),  // ray direction\n          p = 30./R, q;                     // marching point along ray \n    O-=O;\n    int x = int(3.*U.x/R.x);\n    if (D.y<0.) U /= 2.;\n    t =   x == 1 ? T(iChannel0)             // white noise offset ray start\n        : x == 2 ? T(iChannel1)             // blue noise offset ray start\n        : .5;\n    if (abs(D.y)>.25) { O+= t; return; }\n    p += 2.*t*D; \n    for ( O++,t=1.; O.x > 0. && t > .01 ; O-=.015 ) // ray march\n        q = p, q.x = mod(q.x+5.,10.)-5.,\n        t = min(t, length(q) - 5.),         // sphere\n        p += .7*t*D;                        // step forward = dist to obj\n    O = (O-.1)*2.8;                         // force contrast\n  //O *= 2.2;\n  //O.x>1. ? O.x-- : O.x<0. ? O.y++ : t ;   // verify not out of bounds\n    if ( int(U.y)%int(R.y/2.) < 2 ) O-=O,O.r++; // red separator\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 100, 100, 1066]], "test": "untested"}
{"id": "wlsyR2", "name": "RadialBlur-indere", "author": "indere", "description": "Radial Blur", "tags": ["radialblur"], "likes": 8, "viewed": 574, "published": 3, "date": "1592540517", "time_retrieved": "2024-07-30T21:00:15.378099", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= 2.0;\n    if(uv.x <= 1.0)\n        fragColor = texture(iChannel0, uv);\n    else\n         fragColor = texture(iChannel1, uv - vec2(1.0, 0.0));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// buffer A creates a \"blur radius scale param mask\"\n// which nearest to center the scale param smaller\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(0.0);\n    //vec2 uv = fragCoord / iResolution.xy;\n    //uv *= 2.0;\n    //uv -= 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec2 offset = uv - center;\n    \n    fragColor = vec4(vec3(length(offset)) * 0.57, 1.0);\n}", "buffer_a_inputs": [], "common_code": "#define ROTATE 1\n#define SCALE 2\nconst vec2 center = vec2(0.5);\n\nvec3 RadialBlur(in sampler2D mulriple_tex, in sampler2D origin_tex, in vec2 uv, int type, float R, vec2 stepp)\n{    \n    vec2 offset = uv - center;\n    offset = normalize(offset);\n    vec2 direction = offset;\n    if(type == ROTATE){\n    \tdirection = vec2(-offset.y,offset.x);\n    }\n    \n    float mulriple = texture(mulriple_tex, uv).r;\n    float r = R * mulriple;\n    vec3 sum_c = vec3(0.0);\n    float norm = 0.0;\n    for(float i = -r; i < r; i++){\n    \tvec2 uv2 = uv + direction * i * stepp;\n        sum_c += texture(origin_tex, uv2).rgb;\n        norm += 1.0;\n    }\n    sum_c /= norm;\n    return sum_c;\n}", "buffer_b_code": "//radialBulr -- rotate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 stepp = vec2(1.0) / iResolution.xy;\n    float R = 0.0 + 20.0 * (0.5 + 0.5 * sin(iTime * 4.23));\n    int type = 1;\n    vec3 fianl_c = RadialBlur(iChannel0, iChannel1, uv, type, R, stepp);\n    \n    fragColor = vec4(fianl_c, 1.0);\n}", "buffer_b_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//radialBulr -- scale\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 stepp = vec2(1.0) / iResolution.xy;\n    float R = 0.0 + 20.0 * (0.5 + 0.5 * sin(iTime* 4.23));\n    int type = 2;\n    vec3 fianl_c = RadialBlur(iChannel0, iChannel1, uv, type, R, stepp);\n    \n    fragColor = vec4(fianl_c, 1.0);\n}", "buffer_c_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 297]], "test": "untested"}
{"id": "wllyR2", "name": "BoS - Shapes", "author": "zeta", "description": "https://thebookofshaders.com/07/\nToying around with bounding boxes proportions, border smoothing and simple animation.", "tags": ["thebookofshaders"], "likes": 2, "viewed": 283, "published": 3, "date": "1592537445", "time_retrieved": "2024-07-30T21:00:16.193918", "image_code": "#define PI 3.14159265359\n\nvec3 box(vec2 uv, vec4 bounds, float smth)  // left, right, top, bottom\n{\n    return vec3(\n        smoothstep(bounds.x, bounds.x + smth, uv.x) *\n        smoothstep(bounds.y, bounds.y + smth, 1.0 - uv.x) *\n        smoothstep(bounds.z, bounds.z + smth, 1.0 - uv.y) *\n        smoothstep(bounds.w, bounds.w + smth, uv.y)\n    );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 c1 = vec3(250, 142, 209) / 255.0;\n    vec3 c2 = vec3(58, 0, 79) / 255.0;\n    \n    float nsquares = 20.0;\n    \n    float x = floor(uv.x * nsquares) / nsquares;\n\n    \n    float pct = (1.0 - cos(iTime + x * PI * 2.0)) / 2.0;\n    float pct_bot = (1. - cos(iTime+PI+x * PI * 2.0)) / 2.0;\n    float pct_col = (1.0 - cos(iTime + (x - PI*2.) * PI * 2.0)) / 2.0;\n    float pct_smooth = pct_col;\n    \n    vec4 bounds = vec4(x,\n                       1.0 - x - 0.03,\n                       0.3 * pct,\n                       0.3 * pct_bot);\n\n    vec3 b = box(uv, bounds, mix(0.001, 0.01, pct_smooth));\n    vec3 b_col = b * mix(c1, c2, pct_col);\n    \n    vec3 col = b_col;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 99, 99, 351], [354, 354, 409, 409, 1201]], "test": "untested"}
{"id": "tllyR2", "name": "surface blur 1", "author": "indere", "description": "surface blur ", "tags": ["surfaceblur"], "likes": 1, "viewed": 349, "published": 3, "date": "1592536677", "time_retrieved": "2024-07-30T21:00:17.019710", "image_code": "const float R = 5.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 offset = vec2(1.0) / iResolution.xy;\n    \n    vec3 final_c = surfaceBlur(iChannel0, uv, R, offset);\n    \n    if(fragCoord.x > mod(iTime * 150.0, iResolution.x))\n        final_c = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(final_c, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Y = 78.0;\n\nvec3 surfaceBlur(in sampler2D tex, in vec2 uv, float r, in vec2 offset){\n    \n    // rgb Separate calculation\n    vec3 center_c = texture(tex, uv).rgb;\n    vec3 sum_c = vec3(0.0);\n    for(int i = 0; i < 3; i++){\n    \tfloat sum_i = 0.0;\n        float norm = 0.0;\n        for(float x = -r; x <= r; x++){\n            \n           \tfor(float y = -r; y <= r; y++){\n               \tvec2 uv2 = uv + vec2(x * offset.x, y * offset.y);\n               \tvec3 cur_c = texture(tex, uv2).rgb;\n\t\t\t\t\n                float para = 1.0 - abs(center_c[i] - cur_c[i]) * 255.0 / (2.5 * Y);\n\t\t\t\tsum_i += para * cur_c[i] * 255.0;\n                norm += para;\n           \t}\n        }\n        sum_c[i] = sum_i / norm;\n    }\n    \n\treturn sum_c / 255.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 376]], "test": "untested"}
{"id": "wtlyR2", "name": "Desert cave planet", "author": "jarble", "description": "I added some caves to my \"cratered desert planet\" model. It looks much more interesting now.", "tags": ["fractal", "planet", "cave"], "likes": 3, "viewed": 316, "published": 3, "date": "1592536012", "time_retrieved": "2024-07-30T21:00:17.868441", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.1;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime/speed))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float planet_size = 10000.0;\n#define image_scale 4.0\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/(2.5+sin((p.x+p.y+p.z)/50.0));\n    return vec3(color1*2.0,color1,color1);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat sceneSDF1(vec3 p) {\n    p /= 20.0;\n    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));\n}\n\nfloat sceneSDF2(vec3 p){\n    p *= 3.0;\n\treturn 0.5 + sceneSDF1(p/2.0+sceneSDF1(p/5.0));\n}\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat planet_surface(vec3 p){\n return\tlength(p)-planet_size;\n}\n\nfloat cave1(vec3 p){\n    float size = 1000.0;\n    vec3 p1 = p/size;\n    //p1 += sin(length(p/50.0+iTime))/5.0;\n    p = (sin(p1+sin(length(p/50.0)/10.0))+cos(p1.yzx+length(p.yzx/50.0)/10.0))*size;\n    return length(p) - size+10.0;\n}\n\nfloat cave(vec3 p) {\n    p /= scale*50.0;\n    float result = cave1(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n    \tresult += max(result, cave1(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale-30.0;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = 1.1+dunes(p/100.0,10.0)+max(max(planet_surface(p),cave(p)),-min(sceneSDF2(p/7.0),min(sceneSDF2(p.xzy/11.0),sceneSDF2(p/13.0))));\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.1;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime/speed))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n\n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 481, 572, 572, 919], [934, 1188, 1253, 1253, 1385], [1387, 1476, 1505, 1505, 1815], [1817, 2309, 2449, 2449, 3059], [3061, 3431, 3516, 3516, 4288], [4290, 4617, 4666, 4701, 4832], [4834, 4834, 4861, 4861, 5010], [5012, 5012, 5069, 5069, 5846]], "test": "untested"}
{"id": "ttsczj", "name": "in Void*", "author": "wyatt", "description": "--", "tags": ["fluid"], "likes": 4, "viewed": 416, "published": 3, "date": "1592529381", "time_retrieved": "2024-07-30T21:00:18.726148", "image_code": "// Fork of \"in Void\" by wyatt. https://shadertoy.com/view/wtlyWM\n// 2020-06-19 01:14:12\n\nMain {\n\tQ = (A(U));\n    Q = .8*Q.wwww;\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    vec3 no = normalize(vec3(e.w-w.w,n.w-s.w,.1));\n    Q *= 1.-0.5*texture(iChannel1,no);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\n\n#define jet if (length(U-M) < 10.) Q = vec4(.4,0,Q.z,1);if (length(U-vec2(R.x-M.x,M.y)) < 10.) Q = vec4(-.4,0,Q.z,1);\n\n#define boundary if (U.x<1.||U.y<3.||R.x-U.x<3.||R.y-U.y<3.) Q = vec4(0,0,Q.z,Q.w);\n", "buffer_a_code": "#define T(U) A((U))\nvec4 F (vec2 U, vec2 u,vec4 o) {\n\tvec4 a = T(U+u);\n      u = normalize(u);\n     return vec4(u*(a.z*a.w-o.z*o.w)+min(3.*a.w,1.)*(a.xy-o.xy),0,0);\n}\nMain {\n\tQ = T(U);\n    vec4 o = Q;\n    Q += 0.25*F(U,vec2(0,1),o);\n    Q += 0.25*F(U,vec2(1,0),o);\n    Q += 0.25*F(U,vec2(0,-1),o);\n    Q += 0.25*F(U,vec2(-1,0),o);\n    \n    \n    \n    vec2 M = vec2(.1,0.8)*R;\n    if (iMouse.z>0.)M=iMouse.xy;\n\tjet\n    boundary\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define T(U) A((U))\nvec4 F (vec2 U, vec2 u,vec4 o) {\n\tvec4 a = T(U+u);\n     u = normalize(u);\n     return vec4(0,0,a.w*(dot(u,(a.xy-o.xy))),0);\n}\nMain {\n\tQ = T(U);\n    vec4 o = Q;\n    Q += 0.25*F(U,vec2(0,1),o);\n    Q += 0.25*F(U,vec2(1,0),o);\n    Q += 0.25*F(U,vec2(0,-1),o);\n    Q += 0.25*F(U,vec2(-1,0),o);\n    vec2 M = vec2(.1,0.8)*R;\n    if (iMouse.z>0.)M=iMouse.xy;\n\tjet\n    boundary\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = vec4(0);\n    float n = 0.;\n    for (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++) \n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        n += a.w*a.w/(1.+length(u));\n        Q += a*a.w*a.w/(1.+length(u));\n   \t}\n    if (n>0.) Q/=n;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define T(U) A((U)-C(U).xy)\n#define Y(U) C((U)-C(U).xy)\nvec4 F (vec2 U, vec2 u, vec4 o) {\n    vec4 a = Y(U+u);\n    u = normalize(u);\n    return -dot(u,a.xy-o.xy)*(a);\n\n}\nMain {\n    Q = T(U);\n\tvec4 o = Q;\n    Q += 0.25*(\n    \tF(U,vec2(0,1),o)+\n    \tF(U,vec2(1,0),o)+\n    \tF(U,vec2(0,-1),o)+\n    \tF(U,vec2(-1,0),o));\n    vec2 f = vec2(0);\n    for (int x = -2; x<=2; x++)\n    for (int y = -2; y<=2; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 c = Y(U+u);\n        float l = length(u);\n\t\tu = normalize(u);\n    \tf += u*c.w*(1.-c.w)/l;\n    }\n    Q.xy += 1e-1*f*(1.-Q.w)*Q.w;\n    Q.y -= 5e-4*min(100.*Q.w,1.);\n    Q.w = max(Q.w,0.);\n    Q.zw += .6e-2*vec2(1,-1)*Q.wz*(1.-Q.w)*Q.w;\n    if (Q.w<=0.) Q *= 0.;\n    vec2 M = vec2(.1,0.8)*R;\n    if (iMouse.z>0.)M=iMouse.xy;\n\t\n    jet\n    boundary\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wllcRj", "name": "inspired by something on instagr", "author": "mds2", "description": "I saw https://www.instagram.com/p/CBk_UttnIi9/ and wondered if I could copy the effect myself.", "tags": ["simple", "lines", "webcam"], "likes": 19, "viewed": 860, "published": 3, "date": "1592523062", "time_retrieved": "2024-07-30T21:00:19.549945", "image_code": "\nconst float spacing = 7.0;\nconst float thick = 1.0;\n\nfloat to_stripe(in float frag_y) {\n    float saw = mod(frag_y, spacing) - 0.5 * spacing;\n    float tri = abs(saw);\n    tri = tri - 0.5 * thick;\n    return clamp(tri, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float y_samp = fragCoord.y - mod(fragCoord.y, spacing);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(fragCoord.x, y_samp)/iResolution.xy;\n    \n    float bright = dot(texture(iChannel0, uv).rgb, vec3(0.57735));\n    bright = clamp(bright, 0.0, 1.0);\n    \n    float perturbed_y = fragCoord.y + spacing * bright;\n\n    // Time varying pixel color\n    vec3 col = vec3(to_stripe(perturbed_y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 88, 88, 232], [235, 235, 292, 292, 770]], "test": "untested"}
{"id": "Wllyz2", "name": "Yet another cave generator", "author": "jarble", "description": "I modified my [url=https://www.shadertoy.com/view/WllyW4]\"Honeycomb Tunnels\"[/url] shader to generate some interesting-looking caves.", "tags": ["3d", "raymarching", "cave"], "likes": 2, "viewed": 368, "published": 3, "date": "1592513510", "time_retrieved": "2024-07-30T21:00:20.373743", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    float color1 = length(sin(p/1000.0))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p/10.0)/10.0)/20.0,color1/2.0);\n}\n\n//vec3 surface_color(vec3 p){\n//\treturn (surface_color1(p)*(3.0/5.0)+surface_color1(p*5.0))*(2.0/5.0);\n//}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    //p1 += sin(length(p/50.0+iTime))/5.0;\n    p = (sin(p1+sin(length(p/50.0)/10.0))+cos(p1.yzx+length(p.yzx/50.0)/10.0))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*50.0;\n    float result = planet_surface(p);\n    float j = 1.0;\n    for(int i = 0; i < 4; i++){\n    \tresult += max(result, planet_surface(p*j)/(j));\n        j *= 2.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wllyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 377, 377, 502], [854, 854, 883, 883, 1064], [1066, 1066, 1090, 1090, 1366], [1368, 1789, 1880, 1880, 2204], [2219, 2473, 2538, 2538, 2670], [2672, 2761, 2790, 2790, 3100], [3102, 3594, 3734, 3734, 4344], [4346, 4716, 4801, 4801, 5573], [5575, 5902, 5951, 5986, 6117], [6119, 6119, 6176, 6176, 7340]], "test": "untested"}
{"id": "3llyz2", "name": "First Shader - Movement", "author": "Ravbug", "description": "This very basic fragment shader uses the current time to move an image across the screen while blending a color on the right side.", "tags": ["texture", "blending", "movement"], "likes": 0, "viewed": 99, "published": 3, "date": "1592513262", "time_retrieved": "2024-07-30T21:00:21.275332", "image_code": "#define speedDamp 5.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //get the pixel coordinate and translate it into unitized space\n   vec2 xy = fragCoord.xy;\n    xy.x = xy.x / iResolution.x;\n    xy.y = xy.y / iResolution.y;\n    \n   //get the color of the pixel on the texture, offsetting by iTime\n   vec4 texColor = texture(iChannel0,xy+iTime/speedDamp);\n    \n    //apply the color transformation\n    texColor.r *= xy.x*2.0 * abs(sin(iTime));\n    \n    //write the pixel into the output\n    fragColor = texColor;\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 147, 530]], "test": "untested"}
{"id": "3llyR2", "name": "growing triangle wave", "author": "blackle", "description": "Two kinds of triangle waves that grow the further you go from the origin. for the top the wavelength increases linearly, the bottom increases exponentially.", "tags": ["wave"], "likes": 3, "viewed": 292, "published": 3, "date": "1592507883", "time_retrieved": "2024-07-30T21:00:22.093145", "image_code": "float curve(float x) {\n    float id = pow(floor(sqrt(abs(x))),2.);\n    float sgn = mod(id,2.)*2.-1.;\n    return sgn*(x-sign(x)*(id+sqrt(id)));\n}\n\n//thanks to @jay@cybre.space !\n//https://cybre.space/@jay/104367634214778284\nfloat curve_fractal(float x) {\n    float id = floor(log2(abs(x)));\n    float sgn = sign(mod(id,2.)-.5);\n    return (4./3.*pow(2.,id)-abs(x))*sgn;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*vec2(iResolution.x,0))/iResolution.y;\n    bool top = uv.y<.5;\n    uv.y = mod(uv.y,.5)-.25;\n    uv *= 90.;\n\n    float scale = mix(1.,10.,sin(iTime)*.5+.5);\n    float y = top ? curve_fractal(uv.x*scale) : curve(uv.x*scale);\n    float col = smoothstep(.2,.3,abs(y-uv.y*scale)/scale);\n    col -= smoothstep(.3,.1,abs(uv.y))*.5;\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 144], [146, 223, 253, 253, 370], [373, 373, 430, 430, 836]], "test": "untested"}
{"id": "3lsyR2", "name": "bench ~gaussian filters", "author": "FabriceNeyret2", "description": "we often need to filter by a gaussian-like with finite supports\n(1-x²)⁴ is pretty good, and cheapest.\nGraph: see [url]https://www.desmos.com/calculator/ioek66ltzu[/url]", "tags": ["filter", "bench", "perf"], "likes": 1, "viewed": 326, "published": 3, "date": "1592507310", "time_retrieved": "2024-07-30T21:00:22.896996", "image_code": "// graph: see https://www.desmos.com/calculator/ioek66ltzu\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    for (int i = min(0,iFrame); i < 10000; i++ )\n     // O = exp(-.5*O*O/9.);                     //  7.5 fps  Gauss\n     // O = .5+.5*cos(O/6.28);                   //  7.5 fps  Cos\n        O =    (1.-O*O)    , O=O*O*O*O;          // 10.  fps  Polynomial\n    \n     // O = O.x>1. ? exp(-.5*O*O/9.)   : O-O;    //  7.5 fps  same with clamp\n     // O = O.x>1. ? .5+.5*cos(O/6.28) : O-O;    //  6.7 fps\n     // O = max(1.-O*O, 0.), O=O*O*O*O;          //  8.6 fps\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 98, 98, 561]], "test": "untested"}
{"id": "WllyR2", "name": "Voronoi caustics", "author": "4yk4a", "description": "Caustics like effect with brute force Voronoi diagram", "tags": ["voronoi", "caustics"], "likes": 3, "viewed": 407, "published": 3, "date": "1592506334", "time_retrieved": "2024-07-30T21:00:23.717801", "image_code": "// number of cells\nconst int N = 30;\n\nconst float sqrtN = sqrt(float(N)); // small speed up\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // more or less evenly spaced cell centers\n    vec2 p[N];\n    for (int i=0; i<N; i++) {\n        float fi = float(i);\n        p[i].x = fi/float(N);\n        p[i].y = mod(fi,sqrtN)/sqrtN;\n        \n        // move centers in circles\n        p[i]+=(0.2+0.1*cos(iTime*0.03))*vec2(sin(iTime*fi*0.05),cos(iTime*fi*0.07));\n    }\n    \n    // Voronoi-like processing, find squared distance to the nearest center\n    float r = 1.0;\n    for (int i=0; i<N; i++) {\n        vec2 distance = uv-p[i]; \n        r = min(r, dot(distance,distance));\n    }\n\n    // make it closer to white\n    r *= 10.0;\n    \n    // Output to screen\n    fragColor = vec4(r,r,r,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 150, 200, 890]], "test": "untested"}
{"id": "3tsyzj", "name": "Bisection method [Day 181]", "author": "jeyko", "description": "Great lecture on Newton's method - https://www.youtube.com/watch?v=j6ikEASjbWE\n", "tags": ["tutorial", "bisection", "maths", "root"], "likes": 9, "viewed": 383, "published": 3, "date": "1592497387", "time_retrieved": "2024-07-30T21:00:24.558554", "image_code": "// Also check out Newton's method demonstration - https://shadertoy.com/view/wtsyRS\n\n// Bisection root finding method\n// Great video on the subject - https://www.youtube.com/watch?v=MlP_W-obuNg\n\n// function smoothing thanks to iq and mla\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define offs \t\t(iTime/1.5)\n\n#define fn(j) \t\t(cos(j+offs)+sin( (j+offs)*2. ))\n\n\n#define RANGE 1.\n\n#define ITERATIONS 6.\n\n\n// Plotting width\nconst float W = 0.025;\n\n\nconst float eps = 0.01;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,W*width*0.5, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*5.;\n\n    vec3 col = vec3(0);\n    \n    // function\n\tcol += graph( uv.y, fn(uv.x),\t  fn(uv.x+eps),     vec3(0.8,.75,0.8), 1. );\n    \n    \n    // plotlines\n    \n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1),0.5);\n    \n    \n    float offA = 0.;\n    float offB = RANGE;\n    float offMid = 0.; \n    \n    \n    for(float i = 0.; i <= ITERATIONS; i++){\n        offMid = offA + (offB - offA)/2.;\n        \n        float fA = fn(offA);\n        float fB = fn(offB);\n        float fMid = fn(offMid);\n    \t\n        vec2 fnAuv = uv - vec2(offA,fA);\n        vec2 fnBuv = uv - vec2(offB,fB);\n        vec2 fnMiduv = uv - vec2(offMid,fMid);\n        \n        \n        vec3 c1 = pal(0.5,0.5,vec3(0.9,0.4,0.1),1.,i*1. + 1.);\n        vec3 c2 = pal(0.5,0.5,vec3(0.9,0.4,0.1),1.,i*1. + 5.);\n        \n        // function values\n        col = mix(col,c1,smoothstep(W*3.,W*2.,length(fnAuv) ));\n        \n        col = mix(col,c1,smoothstep(W*3.,W*2.,length(fnBuv)  ));\n        \n        col = mix(col,c2,smoothstep(W*3.,W*2.,length(fnMiduv)  ));\n        \n        \n        if(sign(fMid) != sign(fA)){\n        \toffB = offMid;\n        } else {\n        \toffA = offMid;\n        }\n        \n    }\n    \n    \n    \n    col = smoothstep(0.,1.,col);\n    \n    // gamma correction\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 547, 547, 662], [665, 665, 722, 722, 2104]], "test": "untested"}
{"id": "WlscRj", "name": "Tracing My Path", "author": "lams3", "description": "Having fun with path tracing.", "tags": ["pathtracing"], "likes": 0, "viewed": 263, "published": 3, "date": "1592495840", "time_retrieved": "2024-07-30T21:00:25.398309", "image_code": "struct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n     \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0f - 1.0f, 1.0f);\n     \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n \t\n    Ray ray = Ray(rayPosition, rayDir);\n    \n    // show the ray direction\n    fragColor = vec4(rayDir, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 166, 724]], "test": "untested"}
{"id": "3llcRj", "name": "Rocket Mach Diamonds", "author": "michael0884", "description": "Cellular automaton particle tracking used for advection in a fluid/gas which is also fully conservative\nEach pixel has 1 virtual particle\ntakes time for the diamonds to appear", "tags": ["particles", "ca"], "likes": 42, "viewed": 1682, "published": 3, "date": "1592495530", "time_retrieved": "2024-07-30T21:00:26.271973", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //cur particle\n    vec4 U = decode(texel(ch0, pos).zw);\n    \n    //pressure\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    \n    //border render\n    vec3 bord = smoothstep(border_h-1.,border_h-3.,border(pos))*vec3(1.);\n    \n    //particle render\n    float rho = 0.;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        vec2 x0 = data.xy; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vm0.z*G((pos - x0)/1.);\n    }\n    \n    rho = tanh(8.*rho);\n    \n     vec4 D = pixel(ch2, pos);\n    float ang = atan(D.x, D.y);\n    float mag = 0. + 40.*dot(D.xy,D.xy)*rho*rho*rho;\n    \n    // Output to screen\n    fragColor = vec4(1.*vec3(0.4,0.5,1.)*rho + mag + bord + 0.*abs(P.x),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nfloat time;\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSph( in vec2 p, in float r )\n{\n    return length(p) - r; \n}\n\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.52, 0.5)); \n    \n    float box = 100000.;//sdSph(p - R*vec2(0.2, 0.3), R.x*0.04);\n    //box =min(box, sdSph(p - R*vec2(0.2, 0.7), R.x*0.04));\n    float drain = -sdBox(p - R*vec2(0.9, 0.05), vec2(0));\n    return max(drain,min(bound, box));\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec4 decode(vec2 x)\n{\n    uint v = floatBitsToUint(x.x);\n    //uint m = floatBitsToUint(x.y);\n    return vec4(unpack(v),x.yy); \n}\n\nvec2 encode(vec4 x)\n{\n    uint v = pack(x.xy);\n    //uint m = pack(x.zw/1.);\n    return vec2(uintBitsToFloat(v),x.z); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n", "buffer_a_code": "#define mass 0.1\n#define div 0.7\n\nvec2 Force(vec2 dx)\n{\n    return 0.*dx*exp(-dot(dx,dx));\n}\n\nvec2 P(vec2 p)\n{\n    return pixel(ch1, p).zw;\n}\n\n//diffusion amount\n#define dif 1.07\nvec3 distribution(vec2 x, vec2 p)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - dif*0.5, x + dif*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(dif*dif); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec4 vm = vec4(0.);\n    vec2 F = vec2(0., -0.00);\n    vec2 dF = vec2(0.);\n    \n    //particle position\n    vec2 x = pos*vm.z;\n\n    //reintegration advection\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n       \n        vec2 vv = vm0.xy;\n        vec2 xx = data.xy + vv*dt; //integrate position\n\n        vec3 D = distribution(xx, pos);\n\n        //the deposited mass into this cell\n        float m = vm0.z*D.z;\n        //local center of mass in this cell\n        xx = D.xy; \n\n        //add weighted positions by mass\n        x += xx*m;\n        //add weighted velocities by mass\n        vm.xy += vv*m;\n        //add mass\n        vm.z += m;\n    }\n    \n    if(vm.z != 0.)\n    {\n        //normalize\n        x /= vm.z;\n        vm.xy /= vm.z;\n\n        //update velocity\n        //border \n        vec3 N = bN(x);\n        N.z += 0.0001;\n\n        float vdotN = step(abs(N.z), border_h)*dot(N.xy, vm.xy);\n        vm.xy = vm.xy - 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += N.xy*step(abs(N.z), border_h)/N.z;\n\n         vec3 dx = vec3(-1., 0., 1.) + 1.;\n        //global force field\n        vec2 pressure = P(x);\n\n        F += 0.4*pressure - 0.01*vm.xy*step(N.z, border_h + 5.);\n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.01*dm*exp(-d*d);\n        }\n        vm.xy += 0.4*F*dt;\n        \n        //velocity limit\n        float v = length(vm.xy);\n        vm.xy /= (v > 1.)?v:1.;\n    }\n\n    if(pos.x < 3.)\n    {\n        x = mix(pos, x, 0.);\n        vm.xyz = vec3(0.01, 0., 0.5*mass);\n    }\n    \n    //rocket nozzle \n    if(distance(R*vec2(0.2,0.5), pos) < R.x*0.024)\n    {\n        x = pos;\n        vm.xyz = vec3(0.5, 0., 0.06*mass);\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.1) \n        {\n            x = pos;\n            vm = vec4(0.5*(rand.xy-0.5) + vec2(0., 0.), 4.*mass, mass);\n        }\n        else\n        {\n            x = pos;\n        \tvm = vec4(0.);\n        }\n    }\n    \n    U = vec4(x, encode(vm));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//velocity blur\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n\tU = texel(ch1, pos);\n    vec4 av = vec4(0.); float s = 0.0001;\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 dx = vec2(i,j);\n        vec4 dc = decode(texel(ch0, pos + dx).zw);\n        float k = dc.z*G(dx/2.);\n        s += k;\n        av += k*dc.xyzz;\n    }\n    U = av/s; \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//pressure solve\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat P(vec2 p)\n{\n    return texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //velocity divergence\n    float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                     V(pos + dx.yz).y - V(pos + dx.yx).y);\n    //neighbor average\n    float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                    P(pos + dx.yz) + P(pos + dx.yx));\n    U.x = 0.995*L + div;\n  \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//pressure solve + gradient\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat sqr(float x)\n{\n\treturn x*x;\n}\n\nfloat Pf(float rho)\n{\n    return 6.*rho; //gas\n    return 0.*rho*clamp(pow(abs(rho/0.2), 5.) - 1., -1., 1.); //water pressure\n}\n\nfloat P(vec2 p)\n{\n    return -Pf(texel(ch0, p).z)+ 0.*texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    if(b > 0. || true) \n    {\n        vec3 dx = vec3(-1., 0., 1.);\n        //velocity divergence\n        float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                         V(pos + dx.yz).y - V(pos + dx.yx).y);\n        //neighbor average\n        float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                       P(pos + dx.yz) + P(pos + dx.yx));\n        U.x = 0.995*L + div;\n    }  \n    \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //global force field\n    vec2 pressure = 0.5*vec2(P(pos + dx.zy) - P(pos + dx.xy),\n                             P(pos + dx.yz) - P(pos + dx.yx));\n    U.zw = pressure;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205]], "test": "untested"}
{"id": "wtfcz2", "name": "memory streched Perlin", "author": "FabriceNeyret2", "description": "bottom: no noise stretching.\ntop: global noise stretching.\nmiddle: the higher the wavelength, the more stretch. \nInterpretation: larger phenomema are often slower: deformation has time to act. Small ones are often fast and just born and thus less distort", "tags": ["distortion", "perlin", "anisotropic", "stretch"], "likes": 6, "viewed": 403, "published": 3, "date": "1592495455", "time_retrieved": "2024-07-30T21:00:27.082805", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R.y /16. + vec2(.002*iTime,0),\n         S, T = vec2(0); // vec2(.01*iTime,0);\n    mat2 rot = mat2(cos( 2. + vec4(0,1.5708,-1.5708,0))), M = rot;\n\n    int y = int(3.*u.y/R.y);                // panel id\n    float N = 7.,                           // amount of details\n          k = exp2(-N), e, v = 0., w = -.2*sign(iMouse.z-1.) ;\n    \n    for (float i=0.; i<N; i++, k*=2.)       // Perlin fractal cascade\n        S = vec2( pow( 1.4, y==0 ? 0. : y==1 ? -i : -N ) ,1 ),       // stretching\n        v += abs(2.* texture(iChannel0, (U/k-T) *S *M ).x -1. ) * k, // base noise\n        M *= rot;                           // to avoid grid-aligned artifacts\n    \n    v = smoothstep(-w,w, v-.37);            // shaping function\n    O = vec4( pow(v,1./2.2) );              // to sRGB\n    if (int(3.*(u.y-.5))%int(R.y)<2) O-=O,O.r++; // separator\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 922]], "test": "untested"}
{"id": "3tlyRj", "name": "Voxel Jungle", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/wdBfWd]\"Infinite Jungle\"[/url] shader, rendered using voxels.", "tags": ["voxel", "jungle"], "likes": 1, "viewed": 299, "published": 3, "date": "1592489141", "time_retrieved": "2024-07-30T21:00:27.886655", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 300;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0;\n\nvec3 surface_color(vec3 p)\n{\n    p = floor(p);\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p = floor(p);\n    p /= 40.0;\n\n\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  3.9 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist <= EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(sin(iTime/5.0)*2.0, cos(iTime/5.0)*2.0, -iTime)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 210, 210, 591], [594, 834, 858, 858, 1003], [1005, 1426, 1517, 1517, 1824], [1839, 2093, 2158, 2158, 2290], [2293, 2382, 2411, 2411, 2721], [2723, 3215, 3355, 3355, 3945], [3947, 4317, 4402, 4402, 5160], [5162, 5489, 5538, 5573, 5704], [5706, 5706, 5763, 5763, 6678]], "test": "untested"}
{"id": "wtXcz2", "name": "deceiving shader 2 :-p", "author": "FabriceNeyret2", "description": "all of them: [url]https://www.shadertoy.com/results?query=deceiving[/url]", "tags": ["glsl", "shadertoy", "deceiving"], "likes": 2, "viewed": 324, "published": 3, "date": "1592487524", "time_retrieved": "2024-07-30T21:00:28.710453", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / R;\n    O = texture(iChannel0, U );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define texture(ch,U) mod(iTime,4.) < 2.       \\\n  ? U =  floor(U*32.), vec4(mod(U.x+U.y,2.))   \\\n  : 1. - texture( ch, 2.*U + iTime )\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 92]], "test": "untested"}
{"id": "ttXcz2", "name": "bench discard vs return", "author": "FabriceNeyret2", "description": "all is in Common.    Use acceleration factor 16.\nI cannot measure any cost difference between discard vs return", "tags": ["bench", "discard", "perf"], "likes": 0, "viewed": 314, "published": 3, "date": "1592486751", "time_retrieved": "2024-07-30T21:00:29.496351", "image_code": "", "image_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "common_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    for(int i=min(0,int(iSampleRate)); i<20; i++) // some cost the optimizer can't turn around\n        O = sin(O);\n    \n    if (O.x == 0.)\n#if 1\n        discard;\n#else\n        return;\n#endif\n}", "buffer_c_code": "", "buffer_c_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlfcR2", "name": "Cradles of Newton", "author": "dr2", "description": "Lots of different 'Newton's Cradles' - mouseable", "tags": ["mechanics", "physics", "pendulum"], "likes": 12, "viewed": 350, "published": 3, "date": "1592481787", "time_retrieved": "2024-07-30T21:00:30.362037", "image_code": "// \"Cradles of Newton\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 Hashv3v2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltAx, qHit, fSize;\nvec2 gId, cellSz, csP, csS;\nfloat tCur, dstFar, cRad, szFac, pLen, sLen, bRad, pAng, kMin, kMax;\nint idObj;\nbool isOcc;\nconst float kLim = 4.;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid CellConf ()\n{\n  vec3 h;\n  float sAng;\n  h = Hashv3v2 (17.7 * gId + 1.1);\n  isOcc = (length (h) > 0.3);\n  szFac = min (1.2 + 0.7 * h.x, 1.6);\n  pAng = 0.2 * pi * sin (0.4 * 2. * pi * tCur / sqrt (szFac));\n  csP = sin (pAng + vec2 (0.5 * pi, 0.));\n  bRad = 0.3;\n  pLen = 1.2;\n  kMax = 1. + floor (kLim * h.y);\n  kMin = -1. + floor ((kMax + 1.) * h.z);\n  fSize = vec3 (1., pLen + bRad, (2. * kMax + 1.3) * bRad);\n  sAng = atan (fSize.x / (2. * pLen - bRad));\n  sLen = pLen / cos (sAng);\n  csS = sin (sAng + vec2 (0.5 * pi, pi));\n}\n\nfloat MechDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fRad, sRad, sz;\n  dMin /= szFac;\n  p /= szFac;\n  fRad = 0.08;\n  sRad = 0.05;\n  for (float k = float (VAR_ZERO); k <= kLim; k ++) {\n    q = p;\n    q.y -= fSize.y + bRad - fRad + pLen;\n    if (k == 0.) {\n      if (kMin == 0.) q.yz = Rot2Cs (q.yz, csP);\n    } else {\n      sz = sign (q.z);\n      q.z = abs (q.z) - 2. * k * bRad;\n      if (k > kMin && sz * pAng > 0.) q.yz = Rot2Cs (q.yz, vec2 (csP.x, abs (csP.y)));\n    }\n    q.y -= - 2. * pLen;\n    d = PrSphDf (q, bRad);\n    DMINQ (2);\n    q.x = abs (q.x);\n    q.y -= bRad;\n    q.yx = Rot2Cs (q.yx, csS);\n    q.y -= sLen - bRad;\n    d = PrCylDf (q.zxy, sRad, sLen);\n    DMINQ (3);\n    if (k == kMax) break;\n  }\n  q = vec3 (abs (p.x) - fSize.x, p.y - 2. * fSize.y, p.z);\n  d = PrCapsDf (q, fRad, fSize.z);\n  DMINQ (4);\n  q = vec3 (p.x, p.y - 2. * fSize.y, abs (p.z) - fSize.z).yzx;\n  d = PrCapsDf (q, fRad, fSize.x);\n  DMINQ (5);\n  q = vec3 (abs (p.xz) - fSize.xz, p.y - fSize.y);\n  d = PrCylDf (q, fRad, fSize.y);\n  q.z -= - 0.97 * fSize.y;\n  d = min (d, PrCylDf (q, 3. * fRad, 0.03 * fSize.y));\n  DMINQ (5);\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, hc, r;\n  dMin = dstFar;\n  r = cRad - length (p.xz);\n  p.xz = Rot2D (p.xz, 2. * pi * cellSz.x * gId.x);\n  p.x += cRad + 3.;\n  p.y -= cellSz.y * gId.y;\n  q = p;\n  d = SmoothMax (r, - PrBoxDf (q, vec3 (4., 0.5 * cellSz.y - 0.5, 7.2)), 0.2);\n  DMINQ (1);\n  if (r < 0.01) {\n    if (isOcc) {\n      p.y -= - (0.5 * cellSz.y - 0.5);\n      dMin = MechDf (p, dMin);\n    }\n  } else dMin = min (dMin, r + 0.02);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float dHit, d;\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + dHit * rd;\n    gId = vec2 ((floor (atan (p.z, - p.x) / (2. * pi * cellSz.x)) + 0.5),\n       floor (p.y / cellSz.y + 0.5));\n    if (gId != gIdP) {\n      gIdP = gId;\n      CellConf ();\n    }\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BaseShd (vec3 p)\n{\n  vec3 q;\n  float d, sz;\n  d = dstFar / szFac;\n  p.xz = Rot2D (p.xz, 2. * pi * cellSz.x * gId.x);\n  p.x += cRad + 3.;\n  p.y -= cellSz.y * (gId.y - 0.5) + 0.5;\n  p /= szFac;\n  for (float k = float (VAR_ZERO); k <= kLim; k ++) {\n    q = p;\n    q.y -= fSize.y + bRad;\n    if (k == 0.) {\n      if (kMin == 0.) q.yz = Rot2Cs (q.yz, csP);\n    } else {\n      sz = sign (q.z);\n      q.z = abs (q.z) - 2. * k * bRad;\n      if (k > kMin && sz * pAng > 0.) q.yz = Rot2Cs (q.yz, vec2 (csP.x, abs (csP.y)));\n    }\n    d = min (d, length (q.xz));\n    if (k == kMax) break;\n  }\n  return smoothstep (1., 1.2, d / bRad);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ld;\n  float dstObj, lw, nDotR;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      nDotR = - dot (vn, rd);\n      if (vn.y < -0.99 && length (ro.xz) > cRad + 1. && nDotR > 0.) {\n        col4 = vec4 (vec3 (0.8, 0.8, 0.6) * (0.2 + 0.8 * nDotR), -1.);\n      } else {\n        col4 = vec4 (0.6, 0.6, 0.7, 0.);\n        if (vn.y > 0.9) col4 *= 0.8 * (isOcc ? 0.6 + 0.4 * BaseShd (ro) : 1.);\n        else if (vn.y < -0.9) col4 *= 1.5;\n        vn = VaryNf (16. * ro, vn, 0.5);\n      }\n    } else if (idObj == 2) {\n      col4 = vec4 (HsvToRgb (vec3 (mod (17.11 * gId.x + 27.33 * gId.y, 1.), 0.8, 1.)), 0.3);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.7, 0.7, 0.4, 0.1) * (0.9 + 0.1 * sin (16. * pi * qHit.y));\n    } else if (idObj == 4) {\n      col4 = mix (vec4 (0.7, 0.7, 0.4, 0.1), vec4 (0.7, 0.3, 0.2, 0.2) * (0.8 +\n         0.2 * sin (32. * pi * qHit.z)), step (0.05, abs (mod (qHit.z + bRad, 2. * bRad) - bRad)));\n    } else if (idObj == 5) {\n      col4 = vec4 (0.7, 0.3, 0.2, 0.2) * (0.8 + 0.2 * sin (32. * pi * qHit.z));\n    }\n    if (col4.a >= 0.) {\n      col = 0.2 * col4.rgb;\n      for (int k = 0; k < 2; k ++) {\n        if (k == 0) {\n          ld = ltAx;\n          lw = 0.1 + 0.9 * smoothstep (0.95, 0.98, - dot (ltAx, rd)); \n        } else {\n          ld = vec3 (0., 1., 0.);\n          lw = 1.; \n        }\n        col += lw * (0.4 * col4.rgb * max (dot (vn, ld), 0.) +\n           0.5 * col4.a * pow (max (dot (ld, reflect (rd, vn)), 0.), 32.));\n      }\n    } else col = col4.rgb;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, tStep, t, fd;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  fd = floor (dateCur.w / 7200.);\n  tCur = mod (tCur, 36000.) + 30. * fd;\n  az = 0.;\n  el = -0.05 * pi;\n  tStep = 5.;\n  t = floor (tCur / tStep) + smoothstep (0.8, 1., mod (tCur / tStep, 1.));\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  zmFac = 4. + 5. * abs (az) / pi;\n  cellSz = vec2 (1./16., 8.);\n  cRad = 40.;\n  az += 2. * pi * cellSz.x * (t + 0.5) * sign (2. * mod (fd, 2.) - 1.);\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., - 0.7 * cRad);\n  ro.y += cellSz.y * (t + 0.2);\n  dstFar = 4. * cRad;\n  ltAx = vuMat * normalize (vec3 (0., 0., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec3 (0., cHashVA2.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[886, 886, 904, 904, 1418], [1420, 1420, 1455, 1455, 2559], [2561, 2561, 2583, 2583, 3027], [3029, 3029, 3062, 3062, 3479], [3481, 3481, 3502, 3502, 3757], [3759, 3759, 3783, 3783, 4389], [4391, 4391, 4426, 4426, 6052], [6054, 6054, 6110, 6110, 7520], [7522, 7522, 7554, 7554, 7654], [7656, 7656, 7689, 7689, 7716], [7718, 7718, 7760, 7760, 7811], [7813, 7813, 7856, 7856, 7920], [7922, 7922, 7946, 7946, 8063], [8065, 8065, 8110, 8110, 8213], [8215, 8215, 8260, 8260, 8298], [8300, 8300, 8336, 8336, 8542], [8544, 8544, 8574, 8574, 8687], [8689, 8689, 8720, 8720, 8784], [8818, 8818, 8842, 8842, 8954], [8956, 8956, 8980, 8980, 9092], [9094, 9094, 9119, 9119, 9305], [9307, 9307, 9336, 9336, 9548], [9550, 9550, 9589, 9589, 9769]], "test": "untested"}
{"id": "3lfyRS", "name": "LAMB CHOP!!", "author": "Torumu106", "description": "https://www.nicovideo.jp/series/12303 の支援絵(?)です。\nコードの冒頭にある定数の値を変えることである程度のカスタマイズができるようになっています\nこのサイトの機能で録画も可能ですのでご自由にお使いください\n追加要素の要望は@torumu106へ\n\nCheering shader for https://www.nicovideo.jp/series/12303\nPlease change settings if you want to customize.", "tags": ["chop", "lamb"], "likes": 0, "viewed": 293, "published": 3, "date": "1592480705", "time_retrieved": "2024-07-30T21:00:31.176858", "image_code": "//ここでカスタマイズが可能です\n//Settings are here.\n\n//color = vec3(R, G, B)\nconst vec3 back_ground_color = vec3(0.1, 0.1, 0.1);\nconst vec3 bone_color = vec3(0.7, 0.7, 0.7);\nconst vec3 fat_color = vec3(1.0, 1.0, 1.0);\nconst vec3 meat_color = vec3(1.0,0.35,0.35);\nconst vec3 ahoge_color = vec3(1.0, 1.0, 0.4);\nconst vec3 tuina_color = vec3(1.0, 0.7, 0.8);\n\n//true or false\nconst bool party_parrot_mode = false;\nconst bool rainbow_mode = false;\nconst bool wave_mode = false;\nconst bool circle_wave_mode = false;\nconst bool ahoge_mode = false;\nconst bool tuina_mode = true;\n\n//以上、設定でした\n//Settings ended.\n\nfloat rectangle(vec2 r, vec2 bottomLeft, vec2 topRight)\n{\n    float ret;\n    float d = 0.005;\n    ret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n    ret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n    ret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n    ret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n    return ret;\n}\nfloat disk(vec2 r, vec2 center, float radius)\n{\n    return 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = back_ground_color;\n    \n    r /= 0.7;\n    r.y += 0.2;\n    \n    float GlobalTime = mod(iTime * 4.0 * 3.14, 3.14 * 2.0);\n    if(party_parrot_mode){\n    \tfloat parrot = 0.2 * min(1.0, max(r.y + 1.0, 0.0));\n    \tr += vec2(cos(GlobalTime) * parrot , sin(GlobalTime) *  parrot);\n    }\n    if(wave_mode){\n    \tr.x += sin(r.y * 10.0 * 3.14 + GlobalTime) * 0.02;\n    }\n    if(circle_wave_mode){\n    \tr += r * sin(sqrt(r.x * r.x + r.y * r.y) * 20.0 * 3.14 + GlobalTime) * 0.02;\n    }\n    \n    //ahoge\n    if(ahoge_mode){\n    \tfloat sq0 = max(0., max(disk(r, vec2(0.5, 0.8), 0.5) - disk(r, vec2(0.6, 0.7), 0.6) , disk(r, vec2(-0.3, 0.8), 0.4) - disk(r, vec2(-0.4, 0.7), 0.5) ));\n    \tret = ret*(1.0-sq0) + ahoge_color*sq0;\n    }\n    \n    //tuina\n    if(tuina_mode){\n    \tvec2 r_t = r, r_tr = r;\n        r_t *= 4.0;\n        r_tr *= 4.0;\n        \n        r_t.x -= 0.3;\n        r_t.y += 0.5;\n        r_t.x = abs(r_t.x);\n        r_t.x -= 4.0;\n        \n        r_tr.x -= 0.3;\n        r_tr.y += 0.5;\n        r_tr.x = abs(r_tr.x);\n        r_tr.x -= 4.0;\n        \n        float angle = 0.2 * 3.14 * r_t.y * 0.1 + 3.14 * 0.1;\n        r_t.x = cos(angle)*r_t.x + sin(angle)*r_t.y;\n        r_t.y = -sin(angle)*r_t.x + cos(angle)*r_t.y;\n        angle = 0.2 * 3.14 * r_tr.y * 0.1 + 3.14 * 0.1;\n        r_tr.x = cos(angle)*r_tr.x + sin(angle)*r_tr.y;\n        r_tr.y = -sin(angle)*r_tr.x + cos(angle)*r_tr.y;\n        \n        if(r_t.y >= 3.14 || r_t.y <= -3.14){\n        \tr_t.x += 100.0;\n            r_tr.x += 100.0;\n        }\n        \n        r_t.x /= sin(r_t.y * 0.5 + 3.14 * 0.5);\n        r_t.y = mod(r_t.y, 0.4)-0.3;\n        r_t.y += acos(r_t.x) * 0.2 / 3.14;\n        \n        r_tr.x /= sin(r_tr.y * 0.5 + 3.14 * 0.5);\n        r_tr.y =  mod(r_tr.y+0.2, 0.4)-0.3;\n        r_tr.y += acos(-r_tr.x) * 0.2 / 3.14;\n        \n        \n        float sq_t = rectangle(r_tr, vec2(-1.0, -0.1), vec2(1.0, 0.1));\n        ret = ret*(1.0-sq_t) + tuina_color*sq_t * 0.5; \n        sq_t = rectangle(r_t, vec2(-1.0, -0.1), vec2(1.0, 0.1));\n        ret = ret*(1.0-sq_t) + tuina_color*sq_t;\n    }\n    \n    //bone\n    vec2 r1 = r;\n    \n    float the = 3.14 * 0.05* (-r1.y+1.5);\n    r1.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float sq1 = rectangle(r1, vec2(0.5,-1.0), vec2(0.6, 0.6) );\n    ret = ret*(1.0-sq1) + bone_color*sq1;\n    sq1 = rectangle(r1, vec2(0.5,-.0), vec2(0.6, 0.6) );\n    ret = ret*(1.0-sq1) + fat_color*sq1;\n    \n    \n    //meat\n    vec2 r2 = r;\n    \n    the = -3.14 * 0.02;\n    r2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    r2.y /= 1.8;\n    \n    vec2 r3 = r2;\n    r3.y *= 1.8;\n    the = 3.14 * 0.1;\n    r3.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    r3.y /= 0.8;\n    \n    if(r1.x>0.5){\n    \tr3.x = (r3.x-0.08) /.8;\n    }\n    \n    float sq2 = max(disk(r2, vec2(0.1,-0.), 0.5 ), disk(r3, vec2(-0.,0.55), 0.65 ) );\n    sq1 = rectangle(r1, vec2(0.5,-1.0), vec2(0.8, 1.0) );\n    \n    vec2 r4 = r;\n    \n    the = 3.14 * 0.05* (-r4.y*0.5-3.5);\n    r4.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float sq3 = rectangle(r4, vec2(-0.3,-1.0), vec2(-0.2, 0.9) );\n    sq1 = max(sq1, sq3);\n    sq3 = rectangle(r4, vec2(-0.5,-1.0), vec2(-0.37, 0.9) );\n    sq1 = max(sq1, sq3);\n    ret = ret*(1.0-sq2) +( meat_color * (1.0 - sq1) + fat_color * sq1)*sq2;\n    \n    \n    //rainbow\n    if(rainbow_mode){\n    \tfloat maxi = max(ret.x, max(ret.y, ret.z)), mini = min(ret.x, min(ret.y, ret.z));\n        float h = 0.;\n        if(ret.x - 0.005 <= maxi && maxi <= ret.x + 0.005){\n        \th = 60. * (ret.y - ret.z) / (maxi - mini);\n        }else if (ret.y - 0.005 <= maxi && maxi <= ret.y + 0.005){\n        \th = 60. * (ret.z - ret.x) / (maxi - mini) + 120.;\n        }else{\n        \th = 60. * (ret.x - ret.y) / (maxi - mini) + 240.;\n        }\n        h += GlobalTime * 180. / 3.14;\n        h = mod(h, 360.);\n        if(0. <= h && h < 60.){\n        \tret = vec3(maxi, max(h / 60. * (maxi - mini) ,0.)+ mini , mini);\n        }else if(60. <= h && h < 120.){\n        \tret = vec3(max((120. - h) / 60. * (maxi - mini) ,0.)+ mini , maxi, mini);\n        }else if(120. <= h && h < 180.){\n        \tret = vec3(mini, maxi, max((h - 120.) / 60. * (maxi - mini) ,0.)+ mini);\n        }else if(180. <= h && h < 240.){\n        \tret = vec3(mini, max((240. - h) / 60. * (maxi - mini) ,0.)+ mini , maxi);\n        }else if(240. <= h && h < 300.){\n        \tret = vec3(max((h - 240.) / 60. * (maxi - mini) ,0.)+ mini , mini, maxi);\n        }else{\n        \tret = vec3(maxi, mini, max((360. - h) / 60. * (maxi - mini) ,0.)+ mini);\n        }\n    }\n    \n    //finish\n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[632, 632, 689, 689, 1002], [1003, 1003, 1050, 1050, 1134], [1135, 1135, 1192, 1192, 5919]], "test": "untested"}
{"id": "wlfyzj", "name": "antialiasing: comparisons", "author": "FabriceNeyret2", "description": "from bottom to top:\n - no filtering ( i.e. aliasing )\n - sub-pixel integration with box filter (note remaining aliasing)\n  - sub-pixel integration with smooth filters: polynomial ,  Sinc()\n", "tags": ["antialiasing"], "likes": 6, "viewed": 325, "published": 3, "date": "1592479449", "time_retrieved": "2024-07-30T21:00:31.913888", "image_code": "#define sinc(x)  sin(3.1416*(x)+1e-5) / (3.1416*(x)+1e-5)\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y;\n    float v = 0.,\n          x = abs( 360.* dot( U, cos( .2*sin(iTime) + vec2(0,11)) ) ),\n          k = .003,\n          f = 6.28*k*x,           // v = sin(f.x)\n          X = 6.28*k*x*x/2.;      // integrating phase x with freq f from 0 to x\n    int y = int(4.*(U.y+.5));     // strip index\n    \n    if (y==0) v = cos(X);                                // bottom: no filtering ( thus aliased ) \n    else {\n        float h, w,wt=0., n = ceil(2.*f);\n        for( float d=-n; d <= n; d++)                     // --- sub-pixel integration\n            h = d/n,\n           w =  y==1 ?  step(abs(h),n/2.)                 // mid: Box filter Kernel\n              : y==2 ? ( h = max(0.,1.-h*h), w = h*h*h*h) // top: Polynomial filter Kernel\n          //  : y==2 ?   exp(-.5*h*h*9.)                  // top: Gaussian filter Kernel\n              : sinc(h),                                  // top+: Sinc filter Kernel\n            v  += w * cos(X+d),                           // weigthed sum\n            wt += w;                                      // sum of weigths\n        v /= wt;                                          // normalization\n    }\n    O = vec4( pow(.5+.5*v, 1./2.2 ) );                    // to sRGB\n    if ( int(4.*(u.y-.5))%int(R.y) < 1 ) O--;             // separators\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 96, 96, 1436]], "test": "untested"}
{"id": "ttXcRj", "name": "smooth Mandelbrot 2", "author": "FabriceNeyret2", "description": "playing with iq smooth Mandelbrot technique reusing jorge2017a1 setup.\nin particular:    marquetry pattern    + fade-to-grey antialiasing ( NB: I preferred to trade slight aliasing for pitch).\nAntialiasing tuned with mouse.xy (analytic) + #def N (oversamp", "tags": ["mandelbrot", "smooth", "atialiasing"], "likes": 8, "viewed": 342, "published": 3, "date": "1592466527", "time_retrieved": "2024-07-30T21:00:32.653909", "image_code": "// Fork of jorge2017a1 https://shadertoy.com/view/WlfyR2\n// Fork of IQ https://www.shadertoy.com/view/4df3Rn\n//   See here for more information on smooth iteration count:\n//   https://iquilezles.org/articles/msetsmooth\n// mouse.x controls the threshold to grey,    and mouse.y how the transition span.\n     \n#define N 1   // antialiasing oversampling = NxN\n#define linstep(a,b,x) clamp( (x-(a))/(b-(a)),0.,1.)\n\nfloat mandelbrot( vec2 c , out vec2 z,out vec2 _z )\n{\n#if 1 // --- optimizations : \n    float c2 = 16.* dot(c, c);\n    // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n    if( c2*c2 - 6.*c2 + 32.*c.x < 3. ) return 0.;\n    // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n    if( c2 + 32.*c.x + 16.  < 1. ) return 0.;\n#endif\n\n    float B = 256., l = 0.;\n    z  = vec2(0);\n    for( int i=0; i<512; i++, l++ ) {\n       _z = z;\n        z = mat2(z,-z.y,z.x) * z  + c;\n        if( dot(z,z) >  B*B ) break;\n    }\n    if( l > 511. ) return 0.;\n    \n    return l -= log2(log2(length(z))/log2(B));  // smooth iteration count  \n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float t = iTime, l,lc=0.,l0,AA=1.,a,_a,ac=0.,sac=0.,\n       zoom = pow( .62 + .38*cos(.07*t) ,8.);   \n    vec2 R = iResolution.xy, z, _z,\n         M = length(iMouse.xy)<10. ? vec2(-3.75,2.25) : vec2(4,0)+iMouse.xy/R*vec2(-11,8);\n\n    // --- compute Mandelbrot\n    \n    int k = N*N/2;                              // NxN = subsampling. \n    for (int k=0; k<N*N; k++) {                 // oversampling\n        vec2 sp = vec2(k%N,k/N)/float(N)-.5,    // subpixel pos\n              p = ( 2.* (U+sp) - R ) / R.y,\n              c =   vec2(-.745,.186) \n                  + zoom * p * mat2( cos( .15*(1.-zoom)*t + vec4(0,11,33,0) )) ;\n          l = mandelbrot(c, z,_z);\n          a = atan(z.y,z.x);  _a = atan(_z.y,_z.x); \n        ac +=          mix(_a,a,fract(l)); \n       sac += sin( 6.* mix(_a,a,fract(l)) ); \n        lc += l;\n    } l = lc / float(N*N); ac /= float(N*N), sac /= float(N*N);\n    \n    // --- tweak patterns and color from it\n    \n    l0=l; // keep for LOD & AA\n    if (l0==0.) { O = vec4(.5,0,0,1); return; }\n\n#if 1                                       // play with angle(z) rather than l\n    l = 6.*ac;\n  //l = mod( ac+3.14159*mod(floor(l0),2.), 6.283 );\n#endif    \n    \n // O = vec4( .5 + .5* cos( 3. + l*.15 + vec4(0,.6,1,0)) ); // jorge2017a1 colors\n // O = vec4( .5 + .5* sin(l*vec4(1,.33,.1,0)));\n     \n // l = sin(l); O = vec4( l/fwidth(l) );           // draw strips or isolines\n // l = sin(l); O = vec4( sqrt( abs(l)/fwidth(l) ) );  \n // l = sin(l); O = vec4( .5+ l/fwidth(l) ); \n    \n // AA = smoothstep(-3.,-6.,log2(fwidth(l0)));     // play with antialiasing (fade to grey)\n // AA = smoothstep(exp2(-3.),exp2(-6.),fwidth(l0));\n // AA = linstep(-3.,-6.,log2(fwidth(l0)));\n // AA = linstep(-1.5,-6.,log2(fwidth(l0)));\n    AA = linstep(M.x+M.y,M.x-M.y,log2(fwidth(l0)/float(N)));\n // AA = linstep(exp2(-1.),exp2(-6.),(fwidth(l0)));\n  //l = sin(l); O = vec4( sqrt( .5+ l/fwidth(l)*AA  ) ); \n  //l = sin(l); O = vec4( sqrt( .5- l/fwidth(l) * (.2+.8*AA  )) ); \n    l = sin(l); O = vec4( sqrt( .5- clamp(l/fwidth(l),-.5,.5)* AA ) ); \n  //l = sin(l); O = vec4( sqrt( .5- clamp(l/fwidth(l),-.5,.5)* (.2+.8*AA  )) ); \n\n    O = vec4( sqrt( .5- sac* AA ) ); \n  //O = vec4( sqrt( .5 - sac ) ) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 411, 464, 464, 1079], [1081, 1081, 1119, 1119, 3330]], "test": "untested"}
{"id": "WlXyz2", "name": "fast Surface blur", "author": "indere", "description": "Surface blur", "tags": ["surfaceblur"], "likes": 1, "viewed": 331, "published": 3, "date": "1592447408", "time_retrieved": "2024-07-30T21:00:33.411882", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    if(fragCoord.x < mod(iTime * 150.0, iResolution.x) - 0.5)\n        fragColor = texture(iChannel0,uv);\n    else if(fragCoord.x > mod(iTime * 150.0, iResolution.x) + 0.5)\n        fragColor = texture(iChannel1,uv);\n    else \n        fragColor = vec4(1.0 ,0.0 ,0.0, 1.0);\n    \n    \n  \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define kernelSize 20\nconst float weight[kernelSize] = float[]( 0.12238567125008,\n        0.11682268619326,\n        0.10158494451587,\n        0.080421414408401,\n        0.057903418374049,\n        0.037859927398416,\n        0.022435512532395,\n        0.012019024570926,\n        0.0058022877238952,\n        0.0025143246803546,\n        0.00097328697304049,\n        0.00033456739698267,\n        0.00010138405969172,\n        2.6836956977219e-05,\n        6.134161594793e-06,\n        1.192753643432e-06,\n        1.9341950974573e-07,\n        2.5449935492859e-08,\n        2.6102497941393e-09,\n        1.9576873456045e-10);\n\nvec3 fastSurfaceBlur(sampler2D sobleTex, sampler2D OriginTex, in vec2 uv, in vec2 sstep){\n\tvec3 sum_c = texture(OriginTex, uv).rgb * weight[0];\n    vec3 norm = vec3(weight[0]);\n    \n    float threshold = 1.0;\n    float soble_c = texture(sobleTex, uv).r;\n    vec3 para = vec3(threshold);\n    \n    for(int i = 1; i < kernelSize; i++){\n    \tvec2 uv1 = uv + float(i) * sstep;\n        float offset_c = texture(sobleTex, uv1).r;\n        para -= abs(offset_c - soble_c);\n        para.r = clamp(para.r, 0.0, 1.0);\n        para.g = clamp(para.g, 0.0, 1.0);\n        para.b = clamp(para.b, 0.0, 1.0);\n        float max_edge = max(para.r, max(para.g, para.b));\n        if(max_edge < 0.2) continue;\n        sum_c += texture(OriginTex, uv1).rgb * weight[i] * para;\n        norm += weight[i] * para; \n    }\n    \n     para = vec3(threshold);\n     for(int i = 1; i < kernelSize; i++){\n    \tvec2 uv1 = uv + float(i) * sstep;\n        float offset_c = texture(sobleTex, uv1).r;\n       \tpara -= abs(offset_c - soble_c);\n        para.r = clamp(para.r, 0.0, 1.0);\n        para.g = clamp(para.g, 0.0, 1.0);\n        para.b = clamp(para.b, 0.0, 1.0);\n        float max_edge = max(para.r, max(para.g, para.b));\n        if(max_edge < 0.2) continue;\n        sum_c += texture(OriginTex, uv1).rgb * weight[i] * para;\n        norm += weight[i] * para; \n    }\n    \n    return sum_c / norm;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 433]], "test": "untested"}
{"id": "WlXyR2", "name": "SFT Trip", "author": "eiffie", "description": "More perturbation of bogus reference data. Only 4 points of actual orbit data, one long zoom", "tags": ["sft"], "likes": 14, "viewed": 449, "published": 3, "date": "1592437031", "time_retrieved": "2024-07-30T21:00:34.150907", "image_code": "//SFT trip\n#define time iTime\n#define rez iResolution.xy\n\nvec2 cmul(vec2 a, vec2 b){return mat2(a,-a.y,a.x)*b;}\n\nconst int CYC=4;//only 4 real orbit points\nconst float fCYC=4.;\nvec2 O[CYC];\nvoid FillOrb(vec2 Z){\n  vec2 Z0=Z;\n  for(int i=0;i<CYC;i++){\n    O[i]=Z;\n    Z=cmul(Z,Z)+Z0;\n  }\n}\nfloat mndfk(vec2 dZ){//fake mandelbrot using sft math from K.I.Martin\n  vec2 Z,dC=dZ;\n  float iters=24.+time*8.,i=0.,m=dot(dZ,dZ);\n  for(i=0.;i<iters;i+=1.){\n    Z=O[int(mod(i,fCYC))];\n    dZ=2.*cmul(Z,dZ)+cmul(dZ,dZ)+dC;\n    m=dot(dZ,dZ);\n    if(m>40.0)break;\n  }\n  return (iters-i+1.33*log(log(m)))/iters;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=.5*(2.0*U-rez)/rez.x;\n  FillOrb(vec2(-.9,0.26)+vec2(0.05,0.01)*sin(time*0.1*exp(-time*.0001)));\n  float zoom=exp(-time*.5);\n  float a=mndfk(uv*zoom);//just one long zoom\n  uv+=vec2(0.01);\n  //float a2=mndfk(uv*zoom),a3=a2-a;a=(a+a2)*.5;\n  O=vec4(mix(vec3(-0.25),vec3(2.5+sin(a*100.0),cos(a*1000.)*1.5,2.),a),1);\n  O+=mix(vec4(0),vec4(1.,.9,0,0),fwidth(a)*2.);//pow(a3,2.)*20.);\n}", "image_inputs": [], "sound_code": "#define bps 7.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n=0.0; \n  else if(n<2.0)n=3.0; \n  else if(n<3.0)n=6.0; \n  else if(n<4.0)n=9.0; \n  else if(n<5.0)n=6.0; \n  else if(n<6.0)n=3.0; \n  else if(n<7.0)n=0.0; \n  else n=3.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n)); \n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(5.5,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr zylo=instr(0.5,1.0,4.0,0.77,0.51,0.002); \n instr drone=instr(1.,0.,.25,0.75,.063,0.0); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(10.0,0.2,1.5,0.0,0.25,0.005); \n instr bass=instr(20.0,0.2,1.5,0.0,1.01,.0); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=I(36.,time,0.5,drone)*8.;//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,zylo)*n0.y*0.5;\n   a+=I(n0.x+69.0,time,t0,zylo)*n0.y*0.25;\n   //if(mod(i,3.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i; \n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+44.0,time,t1,bass)*n1.y;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+44.0,time,t2,bass)*n2.y*4.0; \n       //a+=I(n2.x+24.0,time+0.008*sin(t2*15.0),t2,bassdrum)*n2.y*4.0; \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/32.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 84, 84, 111], [190, 190, 211, 211, 288], [289, 289, 310, 358, 598], [599, 599, 637, 637, 1027]], "test": "untested"}
{"id": "Wsl3Wr", "name": "Oh Sodd0ff", "author": "deuZige", "description": "Nvm i found it! I needed to put buffer a into the ichannel0 box!!!! Oh sweet satisfaction!\nbut i'm stumped.... again...\nXM modules?? how?\nAnyone wanna point me to the solution? I'd appreciate it like crazy!!", "tags": ["not", "it", "getting"], "likes": 3, "viewed": 642, "published": 3, "date": "1592436618", "time_retrieved": "2024-07-30T21:00:35.076432", "image_code": "/*\nI continue with my amiga retro effects.\nThis time a sinus scroller & a starfield.\n\nThe code is *NOT* optimized at all\nIt was coded as a proof of concept and a personal challenge (don't laugh).\n\nI borrowed some code (thats the concept of shadertoy isnt'it ?) from:\nStarfield:  https://www.shadertoy.com/view/lst3Wn by Gigatron\nFonts: https://www.shadertoy.com/view/4s3XDn by Andre\n*/\n\n\nvec3 SinusScroll(vec2 uv)\n{\n    uv.y+=0.22*sin(uv.x*6.+iTime*6.);\n    return texture(iChannel0, uv).xyz;\n    \n}\n\nconst vec2 O = vec2(0.,1.);\n\nfloat rand (in vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241);\n}\n\n\nfloat noise (in vec2 uv)\n{\n\tvec2 b = floor(uv);\n\treturn mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);\n}\n\nvec3 Starfield(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float stars = 0.;\n\tfloat fl, s;\n\tfor (int layer = 0; layer < 4; layer++) {\n\t\tfl = float(layer);\n\t\ts = (400.-fl*20.);\n\t\tstars += step(.1,pow(noise(mod(vec2(uv.x*s + iTime*-80. - fl*100.,uv.y*s),iResolution.x)),18.)) * (fl/float(4.));\n\t}\n\t \n\treturn vec3(stars);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pat = iTime*5.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    vec3 rainbow = vec3(0.5 + 0.5 * sin(uv.x*8. + 3.14 + pat), 0.5 + 0.5 * cos (uv.x*8. + pat), 0.5 + 0.5 * sin (uv.x*8. + pat));\n    float ay=0.1;\n    vec3 Color=vec3(0);\n    \n    if (uv.y > ay && uv.y < ay+0.006 || uv.y > (1.-ay) && uv.y < 1.-ay+0.006 ) Color = rainbow;\n    if(uv.y<ay || uv.y>1.-ay+0.006) Color=vec3 (0.0, 0.15, 0.25);\n    if(uv.y>ay+0.006 && uv.y<1.-ay && ay==0.1) Color+=SinusScroll(uv);\n    if(uv.y>ay+0.006 && uv.y<1.-ay && Color==vec3(0)) Color=Starfield(fragCoord);\n    \n\tfragColor = vec4( Color, 1.0 );\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 coord;\n\n#define scrolltext BOLD d_ e_ u_ Z_ i_ g_ e_ _ b_ e_ a_ t_ i_ n_ g_ _ u_ r_ _ B_ r_ a_ i_ n_ _ w_ i_ t_ h_ _ A_ n_ o_ t_ h_ e_ r_ _ O_ l_ d_ s_ c_ h_ o_ o_ l_ M_ i_ x_ X_   _ _exclam _exclam  _   _ _dot _dot _dot _dot _dot _dot\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n#define _ cp+=.5;\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n#define crlf uv.y += 2.0; cp = 0.;\n\n// the test scroller\nvec3 Scroller(vec2 fragCoord )\n{\n    float ms = float(iMouse.w>0.);\n    float scale = 0.8;\n    vec2 mouseOffs = vec2(0);\n\tvec2 uv = (fragCoord+mouseOffs-.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n    uv.x+=8.*iTime;\n    uv.x-=290.;\n    uv.y-=0.55;\n    uv.x=mod(uv.x,150.)-30.;\n  \n    float px = 22.0/iResolution.x*scale;\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0.,0.,0.,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n    uv.x += 10.1;\n\n    //uv.x=uv.x+0.5*sin(uv.y+2.*iTime);\n    uv.y = mod(uv.y,2.0)-1.;\n    scrolltext\n    float weight  = 0.06;\n    return vec3(mix(us.rgb,vec3(0.5),smoothstep(weight-px,weight+px, x)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 Color=vec3(0);\n    float x = fragCoord.x;\n    float pat = iTime*5.0;\n    vec3 rainbow = vec3(0.5 + 0.5 * sin(x/120. + 3.14 + pat), 0.5 + 0.5 * cos (x/120. + pat), 0.5 + 0.5 * sin (x/120. + pat));\n    \n    if(uv.y>0.35 && uv.y<0.55)\n    {\n    vec3 cc = Scroller(fragCoord);\n    if(cc!=vec3(0.5)) Color=rainbow;\n    }\n    \n    fragColor = vec4( Color, 1.0 );\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsl3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 415, 415, 499], [530, 530, 555, 555, 623], [626, 626, 652, 652, 752], [754, 754, 786, 786, 1099], [1101, 1101, 1158, 1158, 1766]], "test": "untested"}
{"id": "3lXyR2", "name": "Rotors", "author": "michael0884", "description": "Cellular automaton particle tracking used for advection in a fluid(WIP) which is also fully conservative\nEach pixel has 1 virtual particle\nWIP", "tags": ["particles", "ca"], "likes": 14, "viewed": 447, "published": 3, "date": "1592436091", "time_retrieved": "2024-07-30T21:00:35.818448", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //cur particle\n    vec4 U = decode(texel(ch0, pos).zw);\n    \n    //pressure\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    \n    //border render\n    vec3 bord = smoothstep(border_h-1.,border_h-3.,border(pos))*vec3(1.);\n    \n    //particle render\n    float rho = 0.;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        vec2 x0 = data.xy; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vm0.z*G((pos - x0)/0.75);\n    }\n    \n    vec4 D = pixel(ch2, pos);\n    float ang = atan(D.x, D.y);\n    float mag = 0.4 + 3.*length(D.xy);\n    \n    // Output to screen\n    fragColor = vec4(hsv2rgb(vec3(ang, 1., mag*tanh(8.*rho))) + bord + 0.*abs(P.x),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nfloat time;\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSph( in vec2 p, in float r )\n{\n    return length(p) - r; \n}\n\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    \n    float box = sdSph(p - R*vec2(0.5, 0.3), R.x*0.05);\n    box =min(box, sdSph(p - R*vec2(0.5, 0.7), R.x*0.05));\n    float drain = -sdBox(p - R*vec2(0.9, 0.05), vec2(0));\n    return max(drain,min(bound, box));\n}\n\n\nvec2 border_v(vec2 p)\n{\n    vec2 v = vec2(0);\n\t    \n  \tv += Rot(PI*0.5)*(p - R*vec2(0.5, 0.3))*\n         exp(-abs(sdSph(p - R*vec2(0.5, 0.3), R.x*0.05))/border_h);\n    v += Rot(-PI*0.5)*(p - R*vec2(0.5, 0.7))*\n         exp(-abs(sdSph(p - R*vec2(0.5, 0.7), R.x*0.05))/border_h);\n    \n    return 0.1*v;\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec4 decode(vec2 x)\n{\n    uint v = floatBitsToUint(x.x);\n    //uint m = floatBitsToUint(x.y);\n    return vec4(unpack(v),x.yy); \n}\n\nvec2 encode(vec4 x)\n{\n    uint v = pack(x.xy);\n    //uint m = pack(x.zw/1.);\n    return vec2(uintBitsToFloat(v),x.z); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n", "buffer_a_code": "#define mass 0.1\n#define diffusion 0.38\n\nvec2 Force(vec2 dx)\n{\n    return 0.*dx*exp(-dot(dx,dx));\n}\n\nvec2 P(vec2 p)\n{\n    return pixel(ch1, p).zw;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec4 vm = vec4(0.);\n    vec2 F = vec2(0., 0.);\n    vec2 dF = vec2(0.);\n    \n    //particle position\n    vec2 x = pos*vm.z;\n\n    vec2 r[3];\n    r[0] = Dir(0.);\n    r[1] = Dir(PI*4./3.);\n    r[2] = Dir(-PI*4./3.);\n    //reintegration advection\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        //divide particle into 3 particles with diverging positions \n        loop(k, 3)\n        {\n            vec2 vv = vm0.xy;\n         \t//diffused + integrated position\n            vec2 dx = vv*dt + clamp(diffusion+0.15*length(vm0.xy), diffusion, 0.6)*r[k];\n            vec2 xx = data.xy + dx; \n            float m = vm0.z/3.0002; //divide mass into 3 wait what\n            \n            //how much mass falls into this pixel(is exact, 0 or 1)\n            m *= step(max(abs(pos.x - xx.x),\n                          abs(pos.y - xx.y)), 0.5);\n\n            //add weighted positions by mass\n            x += xx*m;\n            //add weighted velocities by mass\n            vm.xy += vv*m;\n            //add mass\n            vm.z += m;\n        }\n    }\n    \n    if(vm.z != 0.)\n    {\n        //normalize\n        x /= vm.z;\n        vm.xy /= vm.z;\n\n        //update velocity\n        //border \n        vec3 N = bN(x);\n        N.z += 0.0001;\n\n        float vdotN = step(abs(N.z), border_h)*dot(N.xy, vm.xy);\n        vm.xy = vm.xy - 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += N.xy*step(abs(N.z), border_h)/N.z;\n\n         vec3 dx = vec3(-1., 0., 1.) + 1.;\n        //global force field\n        vec2 pressure = P(x);\n\n        F += 0.4*pressure - 0.04*(vm.xy - border_v(x))*step(N.z, border_h + 5.);\n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.01*dm*exp(-d*d);\n        }\n        vm.xy += 0.4*F*dt;\n        \n        //velocity limit\n        float v = length(vm.xy);\n        vm.xy /= (v > 1.)?v:1.;\n    }\n\n    if(pos.x < 1.)\n    {\n        //x = pos;\n        //vm.xyz = vec3(0.7, 0., 0.5*mass);\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.1) \n        {\n            x = pos;\n            vm = vec4(0.5*(rand.xy-0.5) + vec2(1.5, 0.), 4.*mass, mass);\n        }\n        else\n        {\n            x = pos;\n        \tvm = vec4(0.);\n        }\n    }\n    \n    U = vec4(x, encode(vm));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//velocity blur\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n\tU = texel(ch1, pos);\n    vec4 av = vec4(0.); float s = 0.0001;\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 dx = vec2(i,j);\n        vec4 dc = decode(texel(ch0, pos + dx).zw);\n        float k = dc.z*G(dx/1.7);\n        s += k;\n        av += k*dc.xyzz;\n    }\n    U = av/s; \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//pressure solve\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat P(vec2 p)\n{\n    return texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //velocity divergence\n    float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                     V(pos + dx.yz).y - V(pos + dx.yx).y);\n    //neighbor average\n    float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                    P(pos + dx.yz) + P(pos + dx.yx));\n    U.x = L + div;\n  \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//pressure solve + gradient\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat sqr(float x)\n{\n\treturn x*x;\n}\n\nfloat P(vec2 p)\n{\n    return -0.0*sqr(texel(ch0, p).z - 0.1) + texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    if(b > 0. || true) \n    {\n        vec3 dx = vec3(-1., 0., 1.);\n        //velocity divergence\n        float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                         V(pos + dx.yz).y - V(pos + dx.yx).y);\n        //neighbor average\n        float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                       P(pos + dx.yz) + P(pos + dx.yx));\n        U.x = L + div;\n    }  \n    \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //global force field\n    vec2 pressure = 0.5*vec2(P(pos + dx.zy) - P(pos + dx.xy),\n                             P(pos + dx.yz) - P(pos + dx.yx));\n    U.zw = pressure;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205]], "test": "untested"}
{"id": "Wlfczj", "name": "Boat floating", "author": "trickstival", "description": "boat floating", "tags": ["boat"], "likes": 0, "viewed": 286, "published": 3, "date": "1592433375", "time_retrieved": "2024-07-30T21:00:36.650224", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.2) - vec3(distance(vec2(.5), uv));\n    \n    // sea\n    if ((uv.y - sin(iTime + uv.x) * .15) * 5.5 -1.9  < .5 * cos(iTime) + 1. * .5) {\n    \tcol = vec3(0., 0., .2);\n    }\n    \n    \n    // Boat\n    \n    if (distance(uv, vec2(.5, .5 + sin(iTime) * .25)) < .2) {\n    \tcol *= vec3(.2, .2, 0.1);\n    }\n   \t\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlfczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 561]], "test": "untested"}
{"id": "3lfyDr", "name": "Fractals: Multibrot", "author": "4rknova", "description": "A simple Multibrot fractal shader.\nhttps://en.wikipedia.org/wiki/Multibrot_set", "tags": ["fractal", "multibrot"], "likes": 4, "viewed": 570, "published": 3, "date": "1592433225", "time_retrieved": "2024-07-30T21:00:37.465046", "image_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATE\n//#define SMOOTH_SHADING\n#define KVAL   (4.0)\n\n#define AA\t    2.\n#define ZOOM    1.4\n#define ITER    48 // Max number of iterations\n#define COL_IN  vec3(0)\n#define T       iTime\n\nvec2 DeMoivre(vec2 p, float e)\n{\n    // Convert to polar coords\n    float r = sqrt(dot(p,p));\n    float t = atan(p.y, p.x);\n   \t// Apply DeMoivre theorem\n    r = pow(r, e);\n    t = e * t;\n    // Convert back to cartesian coords\n    return r * vec2(cos(t), sin(t));\n}\n\nvec3 fractal(vec2 p)\n{    \n\tvec2 z = vec2(0);  \n\n\tfor (int i = 0; i < ITER; ++i) {\n        \n        float k = KVAL;\n        \n        #ifdef ANIMATE\n         k = 1. + mod(iTime * 0.5, 10.);\n        #endif // ANIMATE\n            \n\t\tz = DeMoivre(z, k) + p; \n\n        #ifdef SMOOTH_SHADING\n        // Smooth shading code contributed by Shane\n        float rad = 64.;\n\t\tif (dot(z,z) > rad) {\t     \n\t\t\tfloat s = float(i) - log2(log2(dot(z,z))/(log2(rad)))/log2(k);\n\t\t\treturn vec3(vec3(cos(s + .9), cos(s + .3), cos(s + .2)) * .4 + .6);\n\t\t}        \n        #else\n\t\tif (dot(z,z) > 4.) {\n\t\t\tfloat s = .125662 * float(i);\n\t\t\treturn vec3(vec3(cos(s + .9), cos(s + .3), cos(s + .2)) * .4 + .6);\n\t\t}\n        #endif // SMOOTH_SHADING\n\t}\n\n    return COL_IN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 c = (fragCoord.xy / iResolution.xy * 2. - 1.)\n\t\t   * vec2(iResolution.x / iResolution.y, 1)\n\t\t   * ZOOM - vec2(.5,0.);\n\n    vec3 col = vec3(0);\n    \n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += fractal(c + ZOOM * vec2(i, j) * (e/AA)) / (4.*AA*AA);\n        }\n    }\n#else\n    col = fractal(c);\n#endif /* AA */\n\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyDr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[316, 316, 348, 379, 582], [584, 584, 606, 606, 1328], [1330, 1330, 1387, 1387, 1888]], "test": "untested"}
{"id": "3tXczj", "name": "Lens Distortion Example", "author": "peterekepeter", "description": "This example demonstrates lens distortion effect. While not physically accurate, the parameters can be tweaked to reach something aesthetically pleasing.", "tags": ["lensdistortionfisheye"], "likes": 27, "viewed": 1745, "published": 3, "date": "1592431342", "time_retrieved": "2024-07-30T21:00:38.231995", "image_code": "#define DARK_EDGES\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n   \tvec2 disorsion = uv-.5;\n    \n    disorsion.x*=aspect; // aspect correction\n    \n    // take distance from center\n   \tfloat len = length(disorsion);\n    \n    // these are the lens parameters\n    float k1 = 1.2;\n    float k2 = 1.0;\n    float k3 = -3.2;\n    \n    disorsion \n        = disorsion*k1 \n        + disorsion*len*k2 \n        + disorsion*len*len*k3;\n        // higher powers may be added if necessary\n    \n    \n    disorsion.x/=aspect; // aspect correction\n    \n    vec4 col = texture(iChannel0, disorsion+.5);\n    \n    #ifdef DARK_EDGES\n    {\n        float edge = 0.7;\n        float dispersion = 0.03;\n    \tcol *= vec4(\n            pow(max(edge-len, 0.0), 0.2),\n            pow(max(edge-dispersion-len, 0.0), 0.2),\n            pow(max(edge-dispersion*2.0-len, 0.0), 0.2),\n        1)*1.2;\n    }\n    #endif\n\n    fragColor = col;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 127, 1054]], "test": "untested"}
{"id": "3tXyzj", "name": "blue-orange exaggerator", "author": "mds2", "description": "blows out image colors, with emphasis on blue/orange", "tags": ["simple", "video", "color"], "likes": 2, "viewed": 486, "published": 3, "date": "1592429051", "time_retrieved": "2024-07-30T21:00:39.086710", "image_code": "#define GENTLE 1 // set to 1 for a more plausible photo setting\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n     vec3 col = texture(iChannel0, uv).rgb;\n  \n    mat3 blowout = mat3(1.87583893, 0.96308725, 0.,\n       0.96308725, 1.17416107, 0.,\n       0.        , 0.        , 0.5);\n    vec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n\n   \n    \n    vec3 dir = blowout * (col - cent);\n    \n    vec3 maxes = (step(vec3(0.0), dir) - col)/dir;\n    \n    float amount = min(maxes.x, min(maxes.y, maxes.z));\n    \n    float weight = 0.75;\n    if (iMouse.x < fragCoord.x) {\n\t    amount = min(amount, 0.5);\n    \tweight = 1.0;\n    }\n    \n    col = col + dir * weight * amount;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 172, 877]], "test": "untested"}
{"id": "3tfyRj", "name": "Fractal cave explorer game", "author": "jarble", "description": "Use the mouse and arrow keys to fly through the cave!\nThis is based on my [url=https://www.shadertoy.com/view/wtlczB]\"Sandstone caves.\"[/url]", "tags": ["3d", "fractal", "game", "cave"], "likes": 2, "viewed": 335, "published": 3, "date": "1592423677", "time_retrieved": "2024-07-30T21:00:39.909510", "image_code": "//based on https://www.shadertoy.com/view/4lVXRm\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    //m.y = -m.y; //invert up/down key\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (sceneSDF(p) < 1.0) p = prev + estimateNormal(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 100.0;\n    \n    //target.y -= 2.0; //gravity\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    vec4 mouse = iMouse;\n    mouse.x *= -1.0;\n    mouse.x += iResolution.x;\n    mouse /= 8.0;\n\n    \n    if (any(greaterThan(mouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(vm.xy + (mouse.zw - mouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(VMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100000.0;\nconst float EPSILON = 0.1;\nfloat EPSILON1;\nint color;\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)+cos(p)))-2.2;\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    p.x += 20.0;\n    p /= 8.0;\n    for(float i = 1.0; i < 2.0; i*= -2.0){\n        p += (sin(p.yzx/i+i)+cos(p.yzx/i))*(i);\n    }\n    result = -sceneSDF1(-p*2.0)/2.0;\n\n    return -(result-.8)*2.0;\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float depth, float end) {\n    //float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}", "buffer_a_code": "//based on https://www.shadertoy.com/view/4lVXRm\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    //m.y = -m.y; //invert up/down key\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (sceneSDF(p) < 1.0) p = prev + estimateNormal(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 100.0;\n    \n    //target.y -= 2.0; //gravity\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    vec4 mouse = iMouse;\n    mouse.x *= -1.0;\n    mouse.x += iResolution.x;\n    mouse /= 8.0;\n\n    \n    if (any(greaterThan(mouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(vm.xy + (mouse.zw - mouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(VMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[2140, 2140, 2170, 2170, 2492], [2495, 2495, 2536, 2536, 2595], [2597, 2597, 2654, 2654, 3862]], "test": "untested"}
{"id": "ttsyzB", "name": "Virtual particle SPH", "author": "michael0884", "description": "Cellular automaton particle tracking used for advection in a fluid which is also fully conservative\nEach pixel has 1 virtual particle", "tags": ["particles", "ca"], "likes": 42, "viewed": 896, "published": 3, "date": "1592418465", "time_retrieved": "2024-07-30T21:00:40.805115", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //pressure\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    \n    //border render\n    vec3 bord = smoothstep(border_h+1.,border_h-1.,border(pos))*vec3(1.);\n    \n    //particle render\n    float rho = 0.;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n       vec2 dx = vec2(i,j);\n       vec4 data = texel(ch0, pos + dx);\n       particle P = getParticle(data, pos + dx);\n       \n        vec2 x0 = P.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*P.M.x*G((pos - x0)/0.75);\n    }\n  \trho = tanh(2.*rho);\n    \n     vec4 D = pixel(ch2, pos);\n    float ang = atan(D.x, D.y);\n    float mag = 0. + 10.*length(D.xy)*rho;\n    \n    // Output to screen\n    fragColor = vec4(vec3(0.1,0.2,0.5)*rho + hsv2rgb(vec3(ang, 1., mag)) + bord + 0.*abs(P.x),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nfloat time;\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.4*time)*(p - R*0.5) , R*vec2(0.005, 0.2));\n    float drain = -sdBox(p - R*vec2(0.9, 0.05), vec2(0));\n    return max(drain,min(bound, box));\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.15\nvec3 distribution(vec2 x, vec2 p)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - dif*0.5, x + dif*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(dif*dif); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos);\n\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n", "buffer_a_code": "#define mass 1.\n#define div 0.7\n\nvec2 Force(vec2 dx)\n{\n    return 0.*dx*exp(-dot(dx,dx));\n}\n\nvec2 Pressure(vec2 p)\n{\n    return pixel(ch1, p).zw;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec2 F = vec2(0.);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        vec2 x = P.X;\n     \n        //border \n        vec3 N = bN(x);\n        N.z += 0.0001;\n\n        float vdotN = step(abs(N.z), border_h)*dot(N.xy, P.V);\n        P.V -= 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += N.xy*step(abs(N.z), border_h)/N.z;\n\n        vec3 dx = vec3(-1., 0., 1.) + 1.;\n        \n        //global force field\n        vec2 pressure = Pressure(x);\n        \n        //avg velocity\n        vec2 av = pixel(ch2, x).xy;\n\n        F += 0.4*pressure + 0.*P.M.x*(av - P.V) + P.M.x*vec2(0., -0.0004);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.001*dm*exp(-d*d);\n        }\n        \n        //integrate\n        P.V += 0.4*F*dt/P.M.x;\n        \n        //velocity limit\n        float v = length(P.V);\n        P.V /= (v > 1.)?v:1.;\n    }\n   \n    if(pos.x < 1.)\n    {\n    \t//vm.xyz = vec3(1.5, 0., 3.*mass);\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, mass);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(0.);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//velocity blur\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n\tU = texel(ch1, pos);\n    vec4 av = vec4(0.); float s = 0.0001, s0 = s;\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 dx = vec2(i,j);\n        vec4 data = texel(ch0, pos + dx); \n    \tparticle P = getParticle(data, pos);\n        vec4 dc = vec4(P.V, P.M);\n        float k = G(dx/1.2);\n        s0 += k;\n        s += dc.z*k;\n        av += vec4(dc.zz, 1., 1.)*k*dc.xyzw;\n    }\n    U.xy = av.xy/s; \n    U.zw = av.zw/s0; \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//pressure solve\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat P(vec2 p)\n{\n    return texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //velocity divergence\n    float rho = texel(ch0, pos).z;\n    float div = 0.5*rho*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                     V(pos + dx.yz).y - V(pos + dx.yx).y);\n    //neighbor average\n    float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                    P(pos + dx.yz) + P(pos + dx.yx));\n    U.x = L + div;\n  \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//pressure solve + gradient\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat sqr(float x)\n{\n\treturn x*x;\n}\n\n\nfloat Pf(float rho)\n{\n    //return 0.2*rho; //gas\n    return 0.14*rho*clamp(pow(abs(rho/0.2), 1.) - 1., -1., 1.); //water pressure\n}\n\nfloat Pv(vec2 p)\n{\n    return texel(ch1, p).x;\n}\n\nfloat P(vec2 p)\n{\n    float rho = texel(ch0, p).z;\n    return -Pf(rho) - 0.*rho + 0.0*texel(ch1, p).x;\n}\n\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    if(b > 0. || true) \n    {\n        vec3 dx = vec3(-1., 0., 1.);\n        //velocity divergence\n         float rho = texel(ch0, pos).z;\n        float div = 0.5*rho*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                         V(pos + dx.yz).y - V(pos + dx.yx).y);\n        //neighbor average\n        float L = 0.25*(Pv(pos + dx.zy) + Pv(pos + dx.xy) +\n                       Pv(pos + dx.yz) + Pv(pos + dx.yx));\n        U.x = L + div;\n    }  \n    \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //global force field\n    vec2 pressure = 0.5*vec2(P(pos + dx.zy) - P(pos + dx.xy),\n                             P(pos + dx.yz) - P(pos + dx.yx));\n    U.zw = pressure;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205]], "test": "untested"}
{"id": "wtlczB", "name": "Sandstone caves", "author": "jarble", "description": "This cave system was generated using trigonometric functions at several different scales.\nThere is also an [url=https://www.shadertoy.com/view/3tfyRj]interactive version[/url] of this shader with mouse and keyboard control.", "tags": ["3d", "raymarching", "fractal", "caves"], "likes": 0, "viewed": 303, "published": 3, "date": "1592418257", "time_retrieved": "2024-07-30T21:00:41.552118", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p)/10.0)/20.0,color1/2.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n       \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    float speed = 10.0;\n    vec3 eye = scale*vec3(1.0+cos(iTime)/4.0,sin(iTime)/4.0-0.5,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "const int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat caves1(vec3 p){\n    vec3 p1 = p/size;\n    float l1 = length(p/50.0);\n    p1 += (sin(l1)+cos(l1))/50.0;\n    return length(sin(vec3(sin(p1.x/20.0)-p1.x,cos(p1.y/20.0)-p1.y,sin(p1.z/20.0)-p1.z))*size) - size-300.0;\n}\n\nfloat caves(vec3 p) {\n    //p += sin(p.y/100.0)*100.0;\n    float result = caves1(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n        p = p.yxz+p.zyx;\n        result = max(result, -caves1(p)/i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n\treturn result;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn caves(p/scale)*scale;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 228], [230, 651, 742, 742, 1048], [1063, 1317, 1382, 1382, 1514], [1516, 1605, 1634, 1634, 1944], [1946, 2438, 2578, 2578, 3188], [3190, 3560, 3645, 3645, 4007], [4009, 4336, 4385, 4420, 4551], [4553, 4553, 4610, 4610, 5626]], "test": "untested"}
{"id": "WtfyW7", "name": "Virtual particle advection", "author": "michael0884", "description": "Cellular automaton particle tracking used for advection in a fluid(WIP) which is also fully conservative\nEach pixel has 1 virtual particle\nWIP", "tags": ["particles", "ca"], "likes": 69, "viewed": 2100, "published": 3, "date": "1592406066", "time_retrieved": "2024-07-30T21:00:42.298123", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //cur particle\n    vec4 U = decode(texel(ch0, pos).zw);\n    \n    //pressure\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    \n    //border render\n    vec3 bord = smoothstep(border_h-1.,border_h-3.,border(pos))*vec3(1.);\n    \n    //particle render\n    float rho = 0.;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        vec2 x0 = data.xy; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vm0.z*G((pos - x0)/0.5);\n    }\n    \n    // Output to screen\n    fragColor = vec4(tanh(4.*vec3(1.,2.,3.)*rho) + bord + 0.*abs(P.x),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nfloat time;\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSph( in vec2 p, in float r )\n{\n    return length(p) - r; \n}\n\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.52, 0.5)); \n    \n    float box = sdSph(p - R*vec2(0.2, 0.3), R.x*0.05);\n    box =min(box, sdSph(p - R*vec2(0.2, 0.7), R.x*0.05));\n    float drain = -sdBox(p - R*vec2(0.9, 0.05), vec2(0));\n    return max(drain,min(bound, box));\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec4 decode(vec2 x)\n{\n    uint v = floatBitsToUint(x.x);\n    //uint m = floatBitsToUint(x.y);\n    return vec4(unpack(v),x.yy); \n}\n\nvec2 encode(vec4 x)\n{\n    uint v = pack(x.xy);\n    //uint m = pack(x.zw/1.);\n    return vec2(uintBitsToFloat(v),x.z); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n", "buffer_a_code": "#define mass 0.1\n#define div 0.7\n\nvec2 Force(vec2 dx)\n{\n    return 0.*dx*exp(-dot(dx,dx));\n}\n\nvec2 P(vec2 p)\n{\n    return pixel(ch1, p).zw;\n}\n\n//diffusion amount\n#define dif 0.93\nvec3 distribution(vec2 x, vec2 p)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - dif*0.5, x + dif*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(dif*dif); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec4 vm = vec4(0.);\n    vec2 F = vec2(0., -0.00);\n    vec2 dF = vec2(0.);\n    \n    //particle position\n    vec2 x = pos*vm.z;\n\n    //reintegration advection\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n       \n        vec2 vv = vm0.xy;\n        vec2 xx = data.xy + vv*dt; //integrate position\n\n        vec3 D = distribution(xx, pos);\n\n        //the deposited mass into this cell\n        float m = vm0.z*D.z;\n        //local center of mass in this cell\n        xx = D.xy; \n\n        //add weighted positions by mass\n        x += xx*m;\n        //add weighted velocities by mass\n        vm.xy += vv*m;\n        //add mass\n        vm.z += m;\n    }\n    \n    if(vm.z != 0.)\n    {\n        //normalize\n        x /= vm.z;\n        vm.xy /= vm.z;\n\n        //update velocity\n        //border \n        vec3 N = bN(x);\n        N.z += 0.0001;\n        \n        if(N.z < 0.) vm.z*=0.99;\n\n        float vdotN = step(abs(N.z), border_h)*dot(N.xy, vm.xy);\n        vm.xy = vm.xy - 1.*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += N.xy*step(abs(N.z), border_h)/N.z;\n\n         vec3 dx = vec3(-1., 0., 1.) + 1.;\n        //global force field\n        vec2 pressure = P(x);\n\n        F += 0.4*pressure - 0.01*vm.xy*step(N.z, border_h + 5.);\n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.01*dm*exp(-d*d);\n        }\n        vm.xy += 0.4*F*dt;\n        \n        //velocity limit\n        float v = length(vm.xy);\n        vm.xy /= (v > 1.)?v:1.;\n    }\n\n    if(pos.x < 1.)\n    {\n        x = pos;\n        vm.xyz = vec3(0.6, 0., 0.5*mass);\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.1) \n        {\n            x = pos;\n            vm = vec4(0.5*(rand.xy-0.5) + vec2(0.5, 0.), 4.*mass, mass);\n        }\n        else\n        {\n            x = pos;\n        \tvm = vec4(0.);\n        }\n    }\n    \n    U = vec4(x, encode(vm));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//velocity blur\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n\tU = texel(ch1, pos);\n    vec4 av = vec4(0.); float s = 0.0001;\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 dx = vec2(i,j);\n        vec4 dc = decode(texel(ch0, pos + dx).zw);\n        float k = dc.z*G(dx/1.);\n        s += k;\n        av += k*dc.xyzz;\n    }\n    U = av/s; \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//pressure solve\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat P(vec2 p)\n{\n    return texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //velocity divergence\n    float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                     V(pos + dx.yz).y - V(pos + dx.yx).y);\n    //neighbor average\n    float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                    P(pos + dx.yz) + P(pos + dx.yx));\n    U.x = 0.995*L + div;\n  \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//pressure solve + gradient\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat sqr(float x)\n{\n\treturn x*x;\n}\n\nfloat P(vec2 p)\n{\n    return -0.08*texel(ch0, p).z+ texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    if(b > 0. || true) \n    {\n        vec3 dx = vec3(-1., 0., 1.);\n        //velocity divergence\n        float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                         V(pos + dx.yz).y - V(pos + dx.yx).y);\n        //neighbor average\n        float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                       P(pos + dx.yz) + P(pos + dx.yx));\n        U.x = 0.995*L + div;\n    }  \n    \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //global force field\n    vec2 pressure = 0.5*vec2(P(pos + dx.zy) - P(pos + dx.xy),\n                             P(pos + dx.yz) - P(pos + dx.yx));\n    U.zw = pressure;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205]], "test": "untested"}
{"id": "wtlczS", "name": "fast box blur", "author": "indere", "description": "box blur", "tags": ["boxblur"], "likes": 4, "viewed": 1017, "published": 3, "date": "1592404900", "time_retrieved": "2024-07-30T21:00:43.040139", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tif(uv.x <= iMouse.x / iResolution.x)\n    \tfragColor = texture(iChannel1, uv);\n    else\n    \tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float R = 12.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 sum_c = texture(iChannel0, uv).rgb;\n   \tvec2 offset = vec2(1.0 / iResolution.x, 0.0);\n    for(float i = 1.5; i <= R; i+=2.0){\n    \tsum_c += texture(iChannel0, uv + offset * i).rgb * 2.0;\n        sum_c += texture(iChannel0, uv - offset * i).rgb * 2.0;\n    }\n    fragColor = vec4(sum_c / (2.0 * R + 1.0), 1.0);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float R = 12.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 sum_c = texture(iChannel0, uv).rgb;\n   \tvec2 offset = vec2(0.0,1.0 / iResolution.y);\n    for(float i = 1.5; i <= R; i+=2.0){\n    \tsum_c += texture(iChannel0, uv + offset * i).rgb * 2.0;\n        sum_c += texture(iChannel0, uv - offset * i).rgb * 2.0;\n    }\n    fragColor = vec4(sum_c / (2.0 * R + 1.0), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 278]], "test": "untested"}
{"id": "wtsyRS", "name": "Newton's method [Day 180]", "author": "jeyko", "description": "Great lecture on Newton's method - https://www.youtube.com/watch?v=j6ikEASjbWE\n", "tags": ["tutorial", "newton", "maths", "root", "mdtmjvm"], "likes": 9, "viewed": 370, "published": 3, "date": "1592403857", "time_retrieved": "2024-07-30T21:00:43.858950", "image_code": "// Also check out Bisection method demonstration - https://www.shadertoy.com/view/3tsyzj\n\n// Newton's root finding method\n// Great video on the subject - https://www.youtube.com/watch?v=j6ikEASjbWE\n\n// function smoothing thanks to iq and mla\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(j) mat2(cos(j), sin(j), -sin(j), cos(j))\n        \n#define feps 0.0001\n\n#define offs \t\t(iTime/1.5)\n\n#define fn(j) \t\t(cos(j+offs)+sin( (j+offs)*2. ))\n#define deriv(j) \t(fn(j+feps)-fn(j))/feps\n\n\n// Plotting width\nconst float W = 0.025;\n\n\nconst float eps = 0.01;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,W*width*0.5, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*5.;\n\n    vec3 col = vec3(0);\n    \n    // function\n\tcol += graph( uv.y, fn(uv.x),\t  fn(uv.x+eps),     vec3(0.8,.75,0.8), 1. );\n    \n    \n    // plotlines\n    \n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1),0.5);\n    \n    \n    float off = 0.;\n    \n    float iters = 4.;\n    for(float i = 0.; i <= iters; i++){\n        float f = fn(0. - off);\n    \tfloat dfdx = deriv(0. - off);\n    \t\n        vec2 fnuv = uv - vec2(-off,f);\n        \n        \n        vec3 c1 = pal(0.5,0.5,vec3(0.9,0.1,0.1),1.,i*1. + 1.);\n        \n        // slope\n        float theta = atan(dfdx);\n        \n        col = mix(col, c1,smoothstep(W*1., W*0.5, abs( ( fnuv*rot(theta)).y))) ;\n        \n        // column\n        col = mix(col,c1,smoothstep(W*1.,W*0.5, max(abs(fnuv.x), abs(fnuv.y +f/2. ) -abs(f/2.))) );\n        \n        float hypotenuse = f/sin(theta); // cos(theta) = adj / hypotenuse\n        float lowerleg = sqrt(hypotenuse*hypotenuse - f*f); \n        \n        // not my proudest line of code lol\n        lowerleg = lowerleg*(-1. + float(dfdx <0.)*2. - float(f <0. && dfdx < 0.)*2. + float(f <0. && dfdx > 0. )*2. );\n        \n        // lower leg of triangle\n        col = mix(col,c1,smoothstep(W*1.,W*0.5,length(fnuv - vec2( lowerleg,-f))));\n        \n        off -= lowerleg;\n        \n        // function value\n        col = mix(col,c1,smoothstep(W*3.,W*2.,length(fnuv)));\n        \n        \n    }\n    \n    \n    \n    col = smoothstep(0.,1.,col);\n    \n    // gamma correction\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 568, 633, 633, 748], [751, 751, 808, 808, 2406]], "test": "untested"}
{"id": "wtlcRS", "name": "Pulse From Center", "author": "fermion", "description": " ", "tags": ["2d", "pulse", "visualization", "hypnotic"], "likes": 0, "viewed": 182, "published": 3, "date": "1592398770", "time_retrieved": "2024-07-30T21:00:44.594982", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    float aspectRatio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.x;\n    \n    //center at (0, 0)\n    uv = (2.0 * uv) - vec2(1, aspectRatio);\n    \n    //polar coords\n    float distanceFromCenter = distance(vec2(0, 0), uv.xy);\n    float angle = atan(uv.y, uv.x);\n    \n    float angularSpeed = 2.0f;\n    float spiralOffset = sin(iTime * 0.05f) * distanceFromCenter * 25.0f;\n    \n    float rippleVariance = (1.0f - abs( cos(iTime * 0.01f) )) * 0.07f + 0.01f;\n    int numPetals = 9;\n    \n    // apply petals\n    distanceFromCenter += sin(iTime * angularSpeed + angle * float(numPetals) + spiralOffset) * rippleVariance;\n    \n    float speed = 1.0f;\n    float zoom = log(iTime + 1.0f) * 3.0f + 5.0f;\n    float phase = -(speed * iTime / zoom) + distanceFromCenter;\n\n    vec3 brightness = sin(vec3(phase * zoom));\n    \n    //make sin oscillate between 0 and 1\n    brightness = (0.5 * brightness) + 0.5;\n    \n    // blend between colors\n    float lowColorBlend = 0.5f * sin(iTime * 0.1) + 0.5f;\n    vec3  lowColor_0 = vec3(0.9, 0.0, 0.3);\n    vec3  lowColor_1 = vec3(0.2, 0.0, 0.9);\n    vec3  lowColor = mix(lowColor_0, lowColor_1, lowColorBlend);\n    \n    float highColorBlend = 0.5f * sin(iTime * 0.04f) + 0.5f;\n    vec3  highColor_0 = vec3(1.0, 0.5, 0.4);\n    vec3  highColor_1 = vec3(0.3, 0.0, 0.3);\n    vec3  highColor = mix(highColor_0, highColor_1, highColorBlend);\n    \n    vec3 color = mix(lowColor, highColor, brightness);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 1615]], "test": "untested"}
{"id": "WlsyzB", "name": "Very simple buffer", "author": "Oggbog", "description": "Trying out persistence \nThanks to pato and his shader https://www.shadertoy.com/view/XllBRj for the tips :)", "tags": ["buffer"], "likes": 2, "viewed": 326, "published": 3, "date": "1592398511", "time_retrieved": "2024-07-30T21:00:45.337996", "image_code": "void mainImage( out vec4 F, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x += .5;\n    \n\tF *= 0.;\n    float d= 0.;\n    for (int y = 0; y < balls; y++) {\n    \tvec4 c = texelFetch(iChannel0, ivec2(0, y), 0);\n    \td += smoothstep(radius,radius-0.001,length(uv-c.xy));\n        //F = mix(F,vec4(vec3(d),1.0),d/2.)*vec4(1.,0.,0.,1.);\n    } \n    F = vec4(vec3(d),0.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float hash12(vec2 p) {\n\tfloat h = dot(p , vec2(120.1,311.7));\t\n    return fract(abs(sin(h)*43758.5453123))*(1.-2.*radius)+radius*2.;\n}\n\nvoid mainImage(out vec4 C, in vec2 fragCoord)\n{\n    C = vec4(-.5);\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) < balls) {        \n\t\tfloat w = iResolution.x/iResolution.y/2.;\n        \n        // First frame - randomize \n        if (iFrame == 0) {            \n            \n            // initial position\n            C.x = 0.5;\n            C.y = 0.5;\n            //C.y = hash12(fragCoord.xy)-radius;\n            \n            // initial speed vector\n            C.z = hash12(fragCoord.xy * C.xy);          \n            C.w = hash12(fragCoord.yx * C.xy);            \n            \n        \n        // after first frame - move\n        } else {\n            C = texelFetch(iChannel0, ivec2(fragCoord.xy), 0) -.5;  \n\t\t\t\n            if (C.x > w-radius){\n                C.x = w-radius;\n                C.z = -C.z;\n            }\n            if (C.x < -w+radius){\n                C.x = -w+radius;\n                C.z = -C.z;\n            }\n            C.x += C.z*iTimeDelta;\n            \n            if (C.y > 0.5-radius){\n                C.y = 0.5-radius;\n               C.w = - C.w; \n            }\n            if (C.y < -0.5+radius){\n                C.y = -0.5+radius;\n               C.w = - C.w; \n            }\n            C.y += C.w*iTimeDelta;\n            \n            C += 0.5;\n    \t\t        \n        }\n\t\t\n    }\t\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define balls 200\n#define radius 0.01", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 451]], "test": "untested"}
{"id": "tllyRS", "name": "BlackHole with opacity", "author": "Leria", "description": "BlackHole with opacity", "tags": ["blackhole", "black", "opacity"], "likes": 1, "viewed": 274, "published": 3, "date": "1592395482", "time_retrieved": "2024-07-30T21:00:46.075025", "image_code": "#define PI \t\t\t\t\t3.1415926\n#define GRAV_CONST\t\t\t6.674\n\n//play with radius, thickness and mass\n#define RADIUS\t\t\t\t8.0\n#define THICCCC\t\t\t\t.1\n#define MASS\t\t\t\t.3\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n    mat4 projection;\n \tvec3 pos; //position\n    vec3 focal_point; //focal point = target point\n    float vfov; //vertical fov\n};\n\nstruct BlackHole\n{\n    vec3 pos; //position\n    vec3 disk_normal;\n    float mass; //blackhole mass\n    float attraction_radius; //attraction radius of the blackhole\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nBlackHole bh;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\n//iq noise\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n/////////////////////\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.;\n    f += 0.2500*noise( p ); p = p*2.;\n    f += 0.1250*noise( p ); p = p*2.;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tbh = BlackHole(pos, J, mass, radius, inner_rad, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\n//gravity stuff\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 bh_vec = bh.pos - p;\n    float d = dot(bh_vec,bh_vec);\n    vec3 res = normalize(bh_vec) * (GRAV_CONST*bh.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n\nvoid init_black_hole(void)\n{\n \tset_black_hole(vec3(0., 0., 0.), MASS, RADIUS, RADIUS/8., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target, float theta /*degree*/)\n{\n    cam = Camera(mat4(1), pos, target, theta);\n}\n\nvoid init_camera(void)\n{\n    init_black_hole();\n    set_camera(vec3(0., 0., 2.*RADIUS), bh.pos, 60.); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\nfloat sdf_plane(vec3 pXp0, vec4 n)\n{\n\treturn dot(pXp0,n.xyz) + n.w ;   \n}\n\nfloat sdf_box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\nfloat sdf_torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n\n    float t = 1.;\n    \n    float jit = 1.;\n    //jit = fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);\n    vec3 tmp = p;\n    \n    float dist_acc = 0.;\n    \n    float perturbation = fbm(p*3.5);\n  \tfloat dens = perturbation;\n    \n    //rgb transparency\n    \n    vec3 rgb_t = vec3(transp(uniform_step, .14, .05), \n                      transp(uniform_step, .12, .05),\n                      transp(uniform_step, .1, .05));\n    \n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n\n    float t_loc = transp(uniform_step, 20., .05);\n    float t_gen = 5.;\n    \n    int s = 0;\n    \n    for(s; s < 150; s++)\n    {               \n        vec2 nu = polar_coord(p-bh.pos);\n        \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(bh.pos-cam.pos);\n        \n        //if too far, then big step        \n        if(sqrt(dist_dist)-(dist_center-bh.accretion_disk_radius) < 0.)\n        {\n        \tk = dist_center-(bh.accretion_disk_radius);\n        }\n        \n        if((length(nu) - bh.inner_radius >= 0.) && (length(nu)-bh.accretion_disk_radius <= 0.) && (distance(p.y, bh.pos.y) < THICCCC))\n        {\n            vec4 tex = texture(iChannel0, p/32.+0.05*iTime);\n            \n            //blending\n        \tc += 2.*t_gen*vec3(.6, .3, .2)*tex.rrr*(1.-t_loc);\n\t\t\tt_gen *= t_loc;\n        }\n        \n\n        if(sdf_sphere(p-bh.pos, 2.*RADIUS) < 0.)\n        {\n            //blending\n        \tc += 2.5*t_acc*vec3(1., 1., 1.)*(1.-rgb_t);\n\t\t\tt_acc *= rgb_t;\n        }\n        \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p-cam.pos) >(dist_center+bh.accretion_disk_radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        space_time_bending(r, p, k); //comment this line to see what's behind\n        k = uniform_step;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    vec3 ray_dir = vec3(uv, -1.);\n    bh.pos = normalize(vec3(-10, 20., bh.pos.z));\n   \tfloat d = 0.;\n    ray_march_scene(Ray((vec4(cam.pos, 1.)*rotation_matrix(I, ((d) )*PI/180.)).xyz, normalize(ray_dir)), .1, color);\n    \n    fragColor = vec4(color, 1.);\n}\n\n\n////////////////////////////////", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[876, 887, 910, 910, 946], [948, 948, 974, 974, 1294], [1319, 1319, 1340, 1352, 1523], [1525, 1544, 1620, 1620, 1667], [1669, 1669, 1701, 1701, 1721], [1723, 1723, 1757, 1757, 1779], [1846, 1893, 1921, 1921, 2091], [2093, 2115, 2161, 2161, 2784], [2805, 2805, 2846, 2846, 2882], [2884, 2884, 3025, 3025, 3088], [3090, 3090, 3133, 3133, 3173], [3175, 3191, 3252, 3252, 3452], [3454, 3454, 3482, 3482, 3553], [3555, 3555, 3619, 3619, 3668], [3670, 3670, 3694, 3694, 3774], [3776, 3776, 3823, 3823, 3875], [3877, 3877, 3960, 3960, 4099], [4101, 4101, 4137, 4137, 4174], [4176, 4176, 4209, 4209, 4300], [4302, 4302, 4355, 4355, 4712], [4714, 4714, 4749, 4749, 4814], [4816, 4816, 4842, 4842, 4990], [4992, 4992, 5044, 5044, 6938], [6940, 6940, 6997, 6997, 7374]], "test": "untested"}
{"id": "3lsyRB", "name": "inside Simplex Noise ", "author": "FabriceNeyret2", "description": "playing with the n vector usually producing the simplex noise via n.x+n.y+n.z ( from Iq's implem, inspired by izutionix's [url]https://shadertoy.com/view/tlfczS[/url] ).\nleft to right:  n.xyz, sorted, sum, length, max, min, harmon\nbottom: idem for abs(n)", "tags": ["voronoi", "noise", "worley", "simplex", "cells", "worms", "brain", "intestines"], "likes": 35, "viewed": 1640, "published": 3, "date": "1592376402", "time_retrieved": "2024-07-30T21:00:46.819036", "image_code": "// === analyzing the effects of Simplex Noise components ==============\n//    - isolate effect of n components, sorted or not, without or with abs\n//    - normalized on different ways ( uncomment #48 and possibly #47 )\n//    - using gradients normalized or not ( swap comment #13/14 )\n//    uncomment #44 to see identical noise in tiles\n//    click for better histogram balance\n\n// inspired by izutionix's \"Simplex Noise Worms and Cells\" https://shadertoy.com/view/tlfczS\n// playing with Iq's Simplex Noise implem https://www.shadertoy.com/view/Msf3WH\n\n#define S 2.     // scale of noise\n\n// refactored from Iq's version\n  #define  hash(p) fract(sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123)\n  #define shash(p)          ( 2.*hash(p) -1. )\n//#define shash(p) normalize( 2.*hash(p) -1. )\n\nvec3 snoise( vec2 p ) {\n    float K1 = .366025404, // (sqrt(3)-1)/2; = -.5+.5*sqrt(3)\n          K2 = .211324865; // (3-sqrt(3))/6; =  .5-.5/sqrt(3)\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 ), // F(p*M), M = ( sqrt(3) + mat2(1,-1,-1,1) )/2.\n          a =    p - i + (i.x+i.y)*K2  , // p -F(pM)M⁻¹  \n          o = step( a.yx, a ), // set 1 on the axis of max value\n          b = a - o  +    K2,\n\t      c = a - 1. + 2.*K2;  // < a,b,c > ~= 3 hexa axis: show every 2 seconds\n    if (mod(iTime,2.)>1.) return vec3(length(a),length(b),length(c))*2.-1.;\n    vec3  h = max( .5 - vec3( dot(a,a), dot(b,b), dot(c,c) ), 0. ),\n\t      n = h*h*h*h * vec3( dot(a, shash(i   )),   // random gradients at each...\n                              dot(b, shash(i+o )),   //   node of the triangle grid\n                              dot(c, shash(i+1.)) ); // h⁴: pseudo-Gaussian kernel cf https://www.desmos.com/calculator/ioek66ltzu\n    \n // return dot( n, vec3(70.) );  // original\n    return 70.*n;                // I instead return the full vector\n}\n\n//                                   if signed, remap to 0,1\n#define V(n,s)   s==1 && y==1 ? vec4(.5+.5*vec3(n)      , 1 ) \\\n               : s==2 && y==1 ? vec4(.5+.5*vec3(n)/.627 , 1 ) \\\n               :                vec4(vec3(n), 1 )\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 R = iResolution.xy,\n         U = 7.*u/R.y;\n    int  x = int(7.*u/R), y = int(2.*u.y/R.y); \n // U = 7./R.y*mod(u,R/vec2(7,2));                 // identical noise in tiles\n    vec3 n = snoise(S*U),s=n, \n         m = iMouse.z>0. ? y==1 && x==1 ? vec3(1.5) : vec3(1,3.4,14.3) : vec3(1); \n    float v=0.;      \n  //v = (n.x+n.y+n.z)/3.;                          // below: center first\n  //s = n = v+(n-v)/length(n-v);                   // normalization by variance\n    if (y==0) s = n = abs(n);\n    s =   s.y <= min(s.x,s.z) ? s.yxz              // s = sorted n ( NB: <= is crucial ! )\n        : s.z <  min(s.x,s.y) ? s.zxy : s,\n    s =   s.z <  s.y ? s.xzy : s; \n    \n    O =   x==0 ? V( n           , 2)               // components of n\n        : x==1 ? V( s.zyx *m    , 2)               // sorted components\n        : x==2 ? V( n.x+n.y+n.z , 1)               // usual noise: sum (= average)\n        : x==3 ? V( length(n)   , 0)               // quadratic sum\n        : x==4 ? V( s.z +.1     , 0)               // max\n        : x==5 ? iMouse.z<=0. ? V( .8+2.*s.x , 1 ) // min\n                 :  vec4( y>0 ?.9+s.x : 8.*s.x   ) //  if click, better hist balancing\n        :      ( v = n.x*n.y*n.z,\n                 V( 8.*sign(v)*pow(abs(v),1./3.) , 1) );   // harmonic average\n     \n    if (m.x==1.5) O -= vec4(.43,.3,-.15,0), O.b = 1.-O.b;\n            \n  //if (iFrame/10%2==0) O = fract(O);                      // test under/overflow              \n    if ( mod(iTime,4.)<2.) O = pow(O,vec4(1./2.2));        // to sRGB\n    U = mod(u,R/vec2(7,2)); if ( U.x<1. || U.y<1. ) O-=O;  // separator\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[801, 801, 824, 824, 1832], [2074, 2074, 2112, 2112, 3711]], "test": "untested"}
{"id": "WlscRS", "name": "Mysterious Hole", "author": "blackle", "description": "initially made on evvvvil's stream and improved upon later\n\noriginal is here (warning, long compile time) https://www.shadertoy.com/view/3lsyRS", "tags": ["mysterious"], "likes": 29, "viewed": 555, "published": 3, "date": "1592363476", "time_retrieved": "2024-07-30T21:00:47.567036", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec4 wrot(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.zwy - p.wyz - p.xxx)/2.;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec4 gated_domain(vec4 p, float scale, bool gated) {\n    if (!gated) {\n        p.xyz = abs(p.xyz);\n        if (p.x > p.y) p.yx = p.xy;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.yx = p.xy;\n        p.z -= scale;\n    }\n    return p;\n}\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9*.5+.5;\n}\n\nfloat cube(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(max(q.x,q.y),max(q.z,q.w)));\n}\n\nfloat cmp(vec4 p) {\n    float scale = 1.7;\n    vec4 id = floor(p/scale);\n    p.xyz = (fract(p.xyz/scale)-0.5)*scale;\n    float hs = hash(hash(id.x,id.y),id.z);\n    p = gated_domain(p, scale, hs<0.4);\n    float h2 = hash(hs,hs);\n    \n    p = wrot(p);\n    p =abs(p);\n    p = wrot(p);\n    p = mix(p,wrot(p),h2*h2*h2);\n\n    return cube(p,vec4(0.4))-.1;\n}\n\nfloat t;\nfloat fdobjs(vec4 p) {\n    p.xyz = erot(p.xyz, vec3(1,0,0),0.9);\n    p.xwz = erot(p.xwz, vec3(0,1,0),0.6);\n    p.ywz = erot(p.ywz, vec3(0,1,0),0.9);\n    return cmp(p);\n}\n\nfloat rocks(vec3 p, float d) {\n    vec4 cds = vec4(p,d+.1);\n    float objs = fdobjs(cds)/sqrt(2.);\n    p = erot(p, vec3(1,0,0),0.3);\n    cds = vec4(p,d+.05);\n    float objs2 = fdobjs(cds*3.)/3.;\n    p = erot(p, vec3(0,1,0),0.5);\n    cds = vec4(p,d+.02);\n    float objs3 = fdobjs(cds*6.)/6.;\n    return min(objs,min(objs2,objs3));\n}\nfloat barf;\nfloat rox;\nfloat scene(vec3 p) {\n    float hills = texture(iChannel0, p.xy).x*.1 + sin(2.*dot(sin(p.xy/2.), cos(p.xy*2.)))*3.;\n    p.z += hills*.04;\n    vec2 holcrds = vec2(length(p.xy),p.z);\n    float h1 = linedist(holcrds, vec2(1,0), vec2(200,10))-.2;\n    float h2 = linedist(holcrds, vec2(1,0), vec2(1,-100))-.2;\n    float gnd = min(h1,h2);\n    rox = rocks(p,h1);\n    barf = rocks(p*1.5+vec3(0,0,-t/3.),length(p.xy*1.5))/1.5;\n    return min(gnd,min(rox,barf));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat bayer(ivec2 uv) {\n    return texelFetch(iChannel2, uv % 8, 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float b = bayer(ivec2(fragCoord));\n\n    t = iTime;\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-4,0,.6);\n    cam = erot(cam, vec3(0,1,0), sin(t*.2)*.2+0.6);\n    init = erot(init, vec3(0,1,0), sin(t*.2)*.2+0.6);\n    cam = erot(cam, vec3(0,0,1), t*.1);\n    init = erot(init, vec3(0,0,1), t*.1);\n    vec3 p = init;\n    bool hit = false;\n    float fog = 0.;\n    float glow = 0.;\n    float dist;\n    for (int i = 0; i <100 && !hit; i++ ) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=cam*dist;\n        if (distance(p,init)>10.)break;\n    }\n    if (!hit) p = init+cam*10.;\n    bool bf = barf == dist;\n    bool rx = rox == dist;\n    float dst = distance(p,init);\n\tfor (int i = 0; i < 16; i++) {\n        vec3 k = mix(init, p, (float(i)+b/2.)/15.);\n        scene(k);\n     \tfloat fogdensity = texture(iChannel1, k/12.+texture(iChannel1, k/20.).x/20.+t/100.).x;\n       \tfog += fogdensity*dst/80.;\n       \tglow += fogdensity*dst/15./(1.+barf*barf*70.);\n    }\n    float tx = smoothstep(0.6,.3,texture(iChannel0, p.xy).x);\n    fog = smoothstep(0.,1.,fog);\n\n    vec3 ldir = normalize(vec3(0,0,1.5+asin(sin(t))*.2)-p);\n    vec3 ax = normalize(cross(ldir,normalize(vec3(1))));\n    float ro = acos(dot(ldir,normalize(vec3(1))));\n\n    vec3 n = norm(p);\n    vec3 r =reflect(cam,n);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    float ss = pow(smoothstep(-.1,.1,scene(p+ldir*.1)),5.);\n    float diff = ss*smoothstep(-1.,0.2,p.z);\n    r = erot(r, ax,ro);\n    float spec = length(sin(r*2.5)*.5+.5)/sqrt(3.);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float specpow = mix(3.,6.,tx*(rx?0.5:1.));\n    vec3 matcol = mix(vec3(0.12,0.08,0.07), vec3(0.05,0.04,0.03), smoothstep(1.5,.9,length(p.xy)));\n    if (rx) matcol = vec3(0.05,0.04,0.04);\n    vec3 col = matcol*diff*ao + pow(spec,specpow)*fres*ao*.4;\n    if (bf) col = vec3(spec*.5+.5)*vec3(1.,1.1,1.3);\n    col = erot(col, n.xzy, 0.1);\n\n    fragColor.xyz=hit?col*ao:vec3(0.02);\n    fragColor.xyz = mix(fragColor.xyz, vec3(.17,.18,.19)*smoothstep(-6.,0.,p.z), fog)+glow;\n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.xyz = smoothstep(vec3(0),vec3(1),fragColor.xyz);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscRS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 234, 234, 325], [326, 326, 366, 366, 457], [459, 459, 497, 497, 559], [561, 561, 580, 580, 649], [651, 651, 690, 690, 760], [762, 762, 814, 814, 1012], [1069, 1069, 1099, 1099, 1185], [1187, 1187, 1215, 1215, 1311], [1313, 1313, 1332, 1332, 1663], [1674, 1674, 1696, 1696, 1843], [1845, 1845, 1875, 1875, 2176], [2200, 2200, 2221, 2221, 2654], [2656, 2656, 2675, 2675, 2788], [2790, 2790, 2813, 2813, 2862]], "test": "untested"}
{"id": "3lscRS", "name": "Day 179", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 18, "viewed": 497, "published": 3, "date": "1592351107", "time_retrieved": "2024-07-30T21:00:48.304065", "image_code": "\n#define T iTime\n\n// wrighter here \n// -- plant -- //\n// fractal in the middle\n// mist \n// floating object inside walls \n// floating mysterius tentacles\n\n// everything is going to be glowy, transparent\n// except of the floating objects inside of the walls \n\n\n// if i have time\n// transparent\n// polar repetetion, 4 times\n\nvec3 path (float z){\n    z *= 0.5;\n    return vec3(sin(z), cos(z),0);\n}\n\nvec3 glow = vec3(0);\n\n#define pal(a,b,c,d,e) ((a)+(b)*sin((c)*(d) + (e)))\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define kick (floor(T) + pow(fract(T),7.))\n\n\nvec2 map(vec3 p){\n\t\tvec2 d = vec2(10e6);\n        float dTrans = 10e7;\n\n        p.y -= 1.;\n\n    \tp -= sin(p)/1.;\n    \n        //p.z += T; \n        vec4 q = vec4(p,1.);\n        for(int i = 0; i < 4; i++){\n\n            float dpp = dot(q.xyz,q.xyz);\n            q /= dpp;\n\n            q.xyz = abs(q.xyz) - vec3(0.03,0.02,0.4);\n\t\t\t\n            //q.xz *= rot(0.5);\n            q.xy *= rot(0. + sin( (T + kick*pi/2.)*0.6)*0.14 );\n            \n            //q.zx *= rot(-0.2 );\n\n        }\n\n        dTrans = min(dTrans, length(q.xyz)/q.w);\n\n        dTrans = min(dTrans, length(q.xy)/q.w);\n\n        dTrans -= 0.003;\n\n        dTrans *= 0.5; \n        dTrans = abs(dTrans) + 0.004;\n\n\n        //dTrans = min(dTrans, length(p)-0.4);\n\n        glow += 0.7/(0.01 + dTrans*dTrans*2000.)*pal(0.5,0.5,vec3(0.7,0.2,0.1),1.,length(p) + T );\n\t\t\n        d.x = min(d.x, dTrans);\n\n        dTrans = 10e8;\n        dTrans = min(dTrans, length(q.xz)/q.w);\n    \tglow += 8.7/(0.01 + dTrans*dTrans*200.)*pal(0.5,0.5,vec3(0.89,0.2,0.1),1.,length(p) + T )*pow(abs(sin(length(p)*4. + T - kick*4.)),40.);\n\n        dTrans = abs(dTrans*0.5) + 0.004;\n\n        d.x = min(d.x, dTrans);\n\n        q.yz *= rot(.0);\n\n    \tq.x +=.0;\n    \tq.z -=.0;\n    \t\n    \tq.z -= 0.;\n    \tq.xy *= rot(0.3*pi);\n    \tq = abs(q);\n        float db = max(q.z,q.x)/q.w*0.4;\n        db -= 0.04;\n        //glow += 0.7/(0.01 + dTrans*dTrans*200.)*pal(0.5,0.5,vec3(0.89,0.2,0.1),1.,length(p) + T )*pow(abs(sin(p.x*4. + T)),40.);\n\n        d.x = min(d.x,db);\n\t\t\n    \tfloat dbb = abs(length(p)-1.5)+0.003; \n        d.x = min(d.x,dbb);\n    \tglow += exp(-dbb)*0.1;\n\t\t\n    \n    \td.x *= 0.9;\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.04,0.0,0.0);\n    //col = vec3(0.7,0.1,0.5);\n\n    uv *= 1. + dot(uv,uv);\n    \n    vec3 ro = vec3(0,0,0.0);\n    ro.y += sin(T);\n    ro.xz += vec2(cos(T)*0.4 + 1.,sin(T)*0.5-1.2)*9.;\n\n    vec3 lookAt = vec3(0);\n\n    lookAt.z = ro.z + 2.;\n\n    lookAt -= lookAt;\n\n    ro += path(ro.z);\n\n    lookAt += path(lookAt.z);\n\n\n    vec3 dir = normalize(lookAt - ro);\n\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up= normalize(cross(dir, right));\n\n    vec3 rd = normalize(dir + right*uv.x + up*uv.y);\n\n\n    vec3 p = ro; float t = 0.; vec2 d = vec2(10e7);\n    bool didHit = false;\n\n\n\n    //p.z -= T + 4.;\n\n    for(int i = 0; i < 110; i++){\n        d = map(p);\n        if(d.x < 0.001){\n        \tdidHit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n\n    col += glow*0.06;\n\n    \n    \n    \n    if(didHit){\n    \tvec2 t = vec2(0.001,0);\n        vec3 n = normalize(map(p).x - vec3(map(p-t.xyy).x,map(p-t.yxy).x,map(p-t.yyx).x));\n        \n        \n        #define AO(j) clamp(map(p + n*j).x/j,0.,1.)\n        \n        col += 2.*AO(0.9)*AO(0.1);\n\n    }\n\n    col = 1. - col;\n    col = smoothstep(0.,1.,col);\n    \n    col *= 1. - dot(uv,uv)*0.1;\n    \n    //col = mix(col,vec3(0.5),smoothstep(0.,1.,t*0.001));\n    //col \n    /*\n    col /= 1. - col*0.2;\n    \n    */\n    //col = smoothstep(0.,1.,col*1.);\n    \n    col = pow(col,vec3(0.454545));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 342, 342, 393], [608, 608, 625, 625, 2233], [2235, 2235, 2292, 2292, 3789]], "test": "untested"}
{"id": "WtscRS", "name": "Many Little Particles", "author": "wyatt", "description": "We come and we go. People will only remember how you made them feel.", "tags": ["sph"], "likes": 22, "viewed": 525, "published": 3, "date": "1592350235", "time_retrieved": "2024-07-30T21:00:49.049073", "image_code": "Main {\n\tvec4 b = B(U);\n    vec4 a = A(b.xy);\n    Q = (0.5+0.5*sin(6.*length(a.zw)+vec4(1,2,3,4)))*smoothstep(1.,0.,length(a.xy-U));\n\tQ += 2.*(D(U));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\n#define O 8.\n#define For for (float i = -(O); i<=(O); i++)\n#define S vec4(4,3,2.5,2)\n#define Gaussian(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n", "buffer_a_code": "Main {\n    if (abs(U.x-0.5*R.x)>0.1*R.x) {Q=vec4(-1e9);return;}\n    Q = A(U);\n    vec4 d = D(U);\n    vec2 f = vec2(0);\n    for (int x = -1; x<=1; x++)\n    for (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 d = D(Q.xy+u);\n        f += 1.*(d.z-3.*d.w*d.w)*u;\n    \n    }\n    Q.zw += f;\n    Q.xy += f+Q.zw*sqrt(1./(1.+dot(Q.zw,Q.zw)));;\n    if (length(Q.zw)>2.) Q.zw = 2.*normalize(Q.zw);\n    if (Q.x<1.)Q.xz = vec2(1,-Q.z);\n    if (Q.y<1.)Q.yw = vec2(1,-Q.w);\n    if (R.x-Q.x<1.)Q.xz = vec2(R.x-1.,-Q.z);\n    if (R.y-Q.y<1.)Q.yw = vec2(R.y-1.,-Q.w);\n    if (iMouse.z>0.){\n    \tif (length(Q.xy-iMouse.xy)<15.&&length(iMouse.zw-iMouse.xy)>0.)\n            Q.zw = -normalize(iMouse.zw-iMouse.xy);\n    \telse Q.zw += .01*normalize(Q.xy-iMouse.xy);\n    }\n    if (iFrame < 1) {\n    \tQ = vec4(U,0,0);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define N 12\nvoid X (inout vec4 Q, inout float r, vec2 U, vec4 b) {\n\t\n    vec4 a = A(b.xy);\n    \n    if (length(a.xy-U)<r) {\n    \tr = length(a.xy-U);\n        Q.xy = b.xy;\n    }\n\n}\n\nvoid Z (inout vec4 Q, inout float r, vec2 U, vec4 b) {\n\t\n    vec4 a = A(b.zw);\n    \n    if (length(a.xy-U)<r) {\n    \tr = length(a.xy-U);\n        Q.zw = b.zw;\n    }\n\n}\n\nMain {\n    \n    Q = B(U);\n    float r = length(A(Q.xy).xy-U);\n    X(Q,r,U,B(U+vec2(0,1)));\n    X(Q,r,U,B(U+vec2(1,0)));\n    X(Q,r,U,B(U-vec2(0,1)));\n    X(Q,r,U,B(U-vec2(1,0)));\n    X(Q,r,U,B(U+vec2(0,2)));\n    X(Q,r,U,B(U+vec2(2,0)));\n    X(Q,r,U,B(U-vec2(0,2)));\n    X(Q,r,U,B(U-vec2(2,0)));\n    X(Q,r,U,Q.zwzw);\n    r = length(A(Q.zw).xy-U);\n    if (iFrame%N==0) Q.zw = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tZ(Q,r,U,B(U+vec2(0,k)));\n    \tZ(Q,r,U,B(U+vec2(k,0)));\n    \tZ(Q,r,U,B(U-vec2(0,k)));\n    \tZ(Q,r,U,B(U-vec2(k,0)));\n    }\n    \n\t\n    if (iFrame < 1) Q = vec4(U,U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = vec4(0);\n    For {\n        vec2 u = U+vec2(i,0);\n        vec4 b = B(u);\n        vec4 a = A(b.xy);\n\n        Q += Gaussian(i)*smoothstep(1.,0.,length(u-a.xy));\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = vec4(0);\n    For {\n        Q += Gaussian(i)*A(U+vec2(0,i));\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ttXczS", "name": "Day 179 - Maxwell equations", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 2, "viewed": 345, "published": 3, "date": "1592331501", "time_retrieved": "2024-07-30T21:00:49.790092", "image_code": "// References used: \n// https://www.youtube.com/watch?v=sxv_L4rscL0  and  https://www.shadertoy.com/view/tsB3Rz \n\n// I am using some of https://www.shadertoy.com/user/wyatt/'s naming conventions, because they work very well.\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/iResolution.xy;\n    vec2 uvn = (U - 0.5*iResolution.xy)/iResolution.y;\n    C-=C;\n    \n    C += 0.5 + sin( length((T2(U)*1. + 2.*T(U)).xyxy)*15. - vec4(0.6,0.2,0.1,0.)-2.8 );\n    C /= 1. + C;\n    \n    C = smoothstep(0.,1.,C*1.4);\n    \n    C = pow(max(C,0.),vec4(0.45454));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// electric\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/iResolution.xy;\n    vec2 uvn = (U - 0.5*iResolution.xy)/iResolution.y;\n \tNeighborhood;   \n    \n    \n    \n    C.xyz = mix(T(U).xyz,avg.xyz,diffusion) - dt*curl/permutivity;\n\t\n    \n    // mouse\n    C.xy = mix(C.xy,0.5*sin(uv*240.),smoothstep(1.,0.,length(((iMouse.xy - U - 0.5)/iResolution.y))*90.)*float(iMouse.z>0.4) );\n    \n    \n\tif(iFrame < 2){\n\t\tC -= C;\t\n\t\t//C.xy += (sin(uv*48.+1.2))*exp(-length(uvn)*9.);\t\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// magnetic\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/iResolution.xy;\n    vec2 uvn = (U - 0.5*iResolution.xy)/iResolution.y;\n \tNeighborhood;   \n \n    C.xyz = mix(T(U).xyz,avg.xyz,diffusion)+ dt*curl/permiability;\n\t    \n\tif(iFrame < 2){\n\t\tC -= C;\t\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt 1.\n  \n\n#define grad(j) vec2(e.j - w.j, n.j - s.j)\n#define div 0.25*(n.y-s.y+e.x-w.x)\n\n#define l inversesqrt(2.)\n#define inv l\n#define curl (cross(vec3(1,0,0),oe.xyz)+cross(vec3(-1,0,0),ow.xyz)+cross(vec3(0,1,0),on.xyz)+cross(vec3(0,-1,0),os.xyz))/4.\n//cross(vec3(inv,inv,0),one.xyz)+cross(vec3(-inv,-inv,0),osw.xyz)+cross(vec3(-inv,inv,0),onw.xyz)+cross(vec3(inv,-inv,0),osw.xyz)  )/8.\n\n    \n#define avg 0.15*(e+n+s+w)\n        \n#define diffusion 0.006    \n    \n#define permutivity 1.\n#define permiability 0.4\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define R iResolution.xy\n\n#define T(j) texture(iChannel0,(j)/R)\n#define T2(j) texture(iChannel1,(j)/R)\n\n\n#define Neighborhood \\\nvec4 n = T(U + vec2(0.,1.));vec4 s = T(U - vec2(0.,1.));vec4 e = T(U + vec2(1.,0.));vec4 w = T(U - vec2(1.,0.));\\\nvec4 se = T(U + vec2(1.,-1.));vec4 sw = T(U - vec2(-1.,-1.));vec4 ne = T(U + vec2(1.,1.));vec4 nw = T(U + vec2(-1.,1.));\\\nvec4 on = T2(U + vec2(0.,1.));vec4 os = T2(U - vec2(0.,1.));vec4 oe = T2(U + vec2(1.,0.));vec4 ow = T2(U - vec2(1.,0.));\\\nvec4 ose = T2(U + vec2(1.,-1.));vec4 osw = T2(U - vec2(-1.,-1.));vec4 one = T2(U + vec2(1.,1.));vec4 onw = T2(U + vec2(-1.,1.));\n    \n\n  ", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 268, 268, 558]], "test": "untested"}
{"id": "wtXczS", "name": "Repeating Celtic Pattern (272ch)", "author": "FabriceNeyret2", "description": "regolfing of 360 chars [url]https://shadertoy.com/view/wsyXWR[/url]\n", "tags": ["hexagon", "pattern", "tiling", "short", "golf", "3tweets"], "likes": 4, "viewed": 342, "published": 3, "date": "1592325219", "time_retrieved": "2024-07-30T21:00:50.534103", "image_code": "// regolfing of 360 chars  https://shadertoy.com/view/wsyXWR\n// colored golfing of 1114 chars  https://shadertoy.com/view/3syXDz\n\n// -3 by coyote\n\n#define D(r) smoothstep(-p, p, r - length(U//\nvoid mainImage(out vec4 O, vec2 u) {  O-=O; O.a++;\n    for (float v, S=.577, p=9./iResolution.x,\n         i=0.; i<3.;  ) {\n        vec2 U = u*p - i*vec2(.5,.28), a = 33. * O.zw;\n        mod( U.y *= S+S , 2.) > 1. ? U.x += .5 : v;\n        U = fract(U) - S;\n        U.y /= S+S;\n        for ( v = D(.4))); a.x < 5.;  a += 2.1 )\n             v -= D(.41)+sin(a)*S));\n        O[int(i++)] = v * D(.39)));\n   }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlfyzS", "name": "Mezzotint  filter", "author": "indere", "description": "test", "tags": ["test"], "likes": 2, "viewed": 344, "published": 3, "date": "1592321800", "time_retrieved": "2024-07-30T21:00:51.275121", "image_code": "const float min_scale = 300.0;\nconst float max_scale = 300.0;\n\nvec2 random2( vec2 p ) {\n    return abs(fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453));\n}\n\nfloat random1(float p){\n\treturn fract(sin(p) * 100000.0);\n}\n\nbool judgeMin(in vec3 c, int tag){\n\tfloat min_c = min(c.r, min(c.g, c.b));\n    if(min_c == c[tag])\t\treturn true;\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t\n    \n    float scale = min_scale + (max_scale - min_scale) * (0.5 + 0.5 * sin(iTime * 0.12423));\n    \n    vec2 st = fragCoord / iResolution.xy;\n    \n    //fragColor = texture(iChannel0, st);\n    //return ;\n    \n    if(st.x <= iMouse.x / iResolution.x){\n    \tfragColor = texture(iChannel0, st);\n        return ;\n    }\n    \n    st.x *= iResolution.x / iResolution.y;\n    \n    st *= scale;\n    \n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    float m_dist = 100.;  // minimum distance\n    vec2 uv = st;\n    bool tag = false;\n    for(int y = -1; y <= 1; ++y){\n        for(int x = -1; x <= 1; ++x){\n        \tvec2 neighbor = vec2(float(x),float(y));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            // Keep the closer distance\n            if(dist < 0.65 && m_dist > dist){\n            \tm_dist = dist;\n                uv = st + diff;\n                tag = true;\n            }\n        }\n    }\n    \n    if(!tag){\n    \tfragColor = vec4(vec3(1.0), 1.0);\n        return ;\n    }\n    \n    \n    if(m_dist < 0.35){\n        float random_v = random2(st).r;\n        float t1 = 0.0;\n        if(random_v >= 0.25)\tt1 = 1.0;\n    \tfragColor = vec4(vec3(t1), 1.0);\n    }else{\n\n        float th = 0.15;\n    \tst /= scale;\n        st.x /= iResolution.x / iResolution.y;\n         vec3 color = texture(iChannel0, st).rgb;\n        float maxV = max(color.r, max(color.g, color.b));\n        float minV = min(color.r, min(color.g, color.b));\n        if(maxV - minV < th){\n        \tfragColor = vec4(vec3(smoothstep(0.399, 0.401, maxV)), 1.0);\n            return ;\n        }\n            \n        \n        if(judgeMin(color,0)){\n        \tint maxTag = 1;\n            int secondTag = 2;\n            if(color.g < color.b)\t{maxTag = 2; secondTag = 1;}\n            vec3 new_c = vec3(0.0);\n            new_c[maxTag] = 1.0;\n            if(color[secondTag] == 0.0){\n                fragColor = vec4(new_c, 1.0);\n            }else if(color[maxTag] - color[secondTag] < th * 0.75){\n                new_c[secondTag] = 1.0;\t\n                fragColor = vec4(new_c, 1.0);\n            }else{\n                float random_v = random2(st).r;\n               if(random_v <= 0.3)\t\tnew_c[secondTag] = 1.0;\t\n                fragColor = vec4(new_c, 1.0);\n            }\n            \n        }else if(judgeMin(color, 1)){\n            int maxTag = 0;\n            int secondTag = 2;\n            if(color.r < color.b)\t{maxTag = 2; secondTag = 0;}\n            vec3 new_c = vec3(0.0);\n            new_c[maxTag] = 1.0;\n             if(color[secondTag] == 0.0){\n                fragColor = vec4(new_c, 1.0);\n            }else if(color[maxTag] - color[secondTag] < th * 0.75){\n                new_c[secondTag] = 1.0;\t\n                fragColor = vec4(new_c, 1.0);\n            }else{\n                float random_v = random2(st).r;\n\n                if(random_v <= 0.3)\t\tnew_c[secondTag] = 1.0;\t\n                fragColor = vec4(new_c, 1.0);\n             }\n        \n        }else{\n        \tint maxTag = 0;\n            int secondTag = 1;\n            if(color.r < color.g)\t{maxTag = 1; secondTag = 0;}\n            vec3 new_c = vec3(0.0);\n            new_c[maxTag] = 1.0;\n            if(color[secondTag] == 0.0){\n                fragColor = vec4(new_c, 1.0);\n            }else if(color[maxTag] - color[secondTag] < th * 0.75){\n                new_c[secondTag] = 1.0;\t\n                fragColor = vec4(new_c, 1.0);\n            }else{\n                float random_v = random2(st).r;\n\n                if(random_v <= 0.3)\t\tnew_c[secondTag] = 1.0;\t\n                fragColor = vec4(new_c, 1.0);\n            }\n            \n        }\n\n        \n    }    \n    \n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(130.0 / 255.0,67.0/255.0,50.0/255.0,1.0);\n    fragColor = vec4(1.0, 1.0, 0.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 87, 87, 185], [187, 187, 210, 210, 246], [248, 248, 282, 282, 380], [383, 383, 440, 440, 4195]], "test": "untested"}
{"id": "WlfczS", "name": "cube technical drawing", "author": "FabriceNeyret2", "description": "- silhouette lines in bold\n- hidden lines in grey\n- facing lines in regular\n  ( For high face distortions, I should split edges )   Mouse.x controls rotation (bottom-left corner: back to autodemo)", "tags": ["cube", "short", "technicaldrawing"], "likes": 10, "viewed": 511, "published": 3, "date": "1592312099", "time_retrieved": "2024-07-30T21:00:52.014145", "image_code": "vec3 point[14];                                       // 8 corners + 6 faces center\nvec2  proj[8];                                        // screen proj of the 8 corners\nint   face[24] = int[]( 4,2,  3,4,  2,5,  5,3,        // 2 faces adjacent to each edge\n                        2,0,  0,3,  1,2,  3,1, \n                        0,4,  5,0,  4,1,  1,5);\n\n// --- utils from https://www.shadertoy.com/view/llySRh\n#define S(d,r) smoothstep( -1.5, 1.5, (r) - (d)*R.y ) // antialiased draw\nfloat seg(vec2 p, vec2 a,vec2 b) {                    // --- draw segment with round ends\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y,\n         M = iMouse.xy;\n    vec3 P,A,B, C = vec3(0,0,-4);                     // C: camera pos 76\n    O-=O;\n    float t = length(M)<20. ? iTime : 6.28 * M.x/R.x;\n    int i = 0, a,b,c;\n    for(; i<8; i++ )                        // --- compute 3D corners coords + 2D proj\n        P =    vec3( i%2, i/2%2, i/4%2 ) *2. - 1.     // cubes corner\n            + .1*cos(iTime+vec3(1+i,2+2*i,3-i)),      // jittering\n        P.zx *= rot(t),\n        P.zy *= rot(-.5),\n        point[i] = P,                                 // corner i\n        point[ 8+i/4  ] += P/4.,                      // faces corner i belongs to\n        point[10+i%2  ] += P/4.,                      // ( indeed, calc faces center)\n        point[12+i/2%2] += P/4.,\n        P -= C , proj[i] = P.xy / P.z;                // screen proj of corner i\n\n#define N(c) dot( cross( point[8+face[2*i+c]]-A , B-A ) , A-C ) // dot(Normal,View)\n    for(i=0; i<12; i++) \n        a = i%4*(i<4?1:2) - (i/4==1 ?i%2:0), b = a + (4>> i/4), // index of line i ends\n        A = point[a], B = point[b],                             // 3D coords of line i  ends\n        //F = ivec3(a/4, 2+a%2 ,4+a/2%2),\n        //G = ivec3(b/4, 2+b%2 ,4+b/2%2) - F,\n        //F.xy= G.x==0 ? F.yz : G.y==0 ? F.xz :F.xy,            // F[c] replaces face[] (but array shorter)\n        c = N(0) < 0. ? 1 : 0 , N(1) > 0. ? c++ : c,            // visibility of adjacent faces \n        O = max(O, S( seg(U,proj[a],proj[b]), c<1 ?0.: c<2 ?4.:2. ) );// draw segment\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 518, 573, 744], [790, 790, 828, 828, 2369]], "test": "untested"}
{"id": "WtXyRB", "name": "Desert Reflections", "author": "dr2", "description": "Desert reflections", "tags": ["reflection", "desert"], "likes": 13, "viewed": 380, "published": 3, "date": "1592293948", "time_retrieved": "2024-07-30T21:00:52.752172", "image_code": "// \"Desert Reflections\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Desert reflections (with bits from \"Extreme Desert\" and \"Ozymandias Redux\")\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nvec4 dateCur;\nvec3 sunDir, qHit, rPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize;\nint idObj;\nbool isOcc;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= rPos;\n    q = p;\n    q.y -= -1.;\n    d = PrCylDf (q.xzy, 0.5, 2.);\n    DMINQ (1);\n    q.y -= 3.9;\n    d = PrSphDf (q, 2.);\n    DMINQ (2);\n  }\n  return dMin;\n}\n\nvoid SetGrdConf ()\n{\n  rPos.xz = 0.5 * hgSize * sin (2. * pi * Hashfv2 (17.1 * gId + 0.3) + vec2 (0.5 * pi, 0.));\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz);\n  isOcc = (Hashfv2 (19.1 * gId + 0.3) > 0.2);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.03;\n  for (int j = 0; j < 24; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (h < 0.005) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 col, vn;\n  float dFac;\n  dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n  ro += dstObj * rd;\n  vn = ObjNf (ro);\n  if (idObj == 1) {\n    vn = VaryNf (8. * qHit, vn, 4. * dFac);\n    col = vec3 (0.7, 0.75, 0.8);\n  } else if (idObj == 2) {\n    col = (qHit.y > 0.) ? vec3 (0.5, 0.5, 1.) : vec3 (0.7, 0.7, 0.2);\n  }\n  col = col * (0.2 + 0.1 * max (0., - dot (vn, sunDir)) +\n     0.7 * max (0., dot (vn, sunDir))) +\n     0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstObj / dstFar, 4.));\n  return col;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dFac, f, sh;\n  dFac = 1. - smoothstep (0.15, 0.35, dstGrnd / dstFar);\n  ro += dstGrnd * rd;\n  vn = GrndNf (ro);\n  col = mix (vec3 (0.65, 0.45, 0.1), vec3 (0.9, 0.7, 0.4), smoothstep (1., 3., ro.y));\n  col *= 1. - 0.3 * dFac * Fbm2 (128. * ro.xz);\n  if (dFac > 0.) {\n    if (vn.y > 0.3) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.3, 0.8, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 4. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.95 + 0.05 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrdConf ();\n    if (isOcc) col *= 0.7 + 0.3 * smoothstep (0.5, 0.8, length (ro.xz -\n       HexToPix (gId * hgSize) - rPos.xz));\n  }\n  sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n  sh = min (sh, 1. - 0.6 * smoothstep (0.4, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.))));\n  col *= 0.1 + sh * (0.2 * vn.y + 0.7 * max (0., dot (vn, sunDir)));\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dstObjO;\n  bool isRef;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  isRef = false;\n  if (dstObj < min (dstGrnd, dstFar) && idObj == 2) {\n    isRef = true;\n    dstObjO = dstObj;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    col = (dstObj < dstGrnd) ? ObjCol (ro, rd, dstObj) : GrndCol (ro, rd, dstGrnd);\n    if (isRef) col = mix (col, SkyBg (rd), pow (dstObjO / dstFar, 8.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (2. * (v.z * a.x - v.x * a.z), -0.2 * pi, 0.2 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv;\n  float el, az, sunEl, sunAz, t, hSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  hgSize = 16.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  t = 3. * tCur;\n  ro = TrackPath (t);\n  fpF = TrackPath (t + 1.);\n  fpB = TrackPath (t - 1.);\n  flMat = EvalOri ((fpF - fpB) / 2., fpF - 2. * ro + fpB);\n  hSum = 0.;\n  for (float k = 0.; k < 7.; k ++) hSum += GrndHt (TrackPath (t + 0.5 * (k - 1.)).xz);\n  ro.y = 8. * gr.hFac + hSum / 7.;\n  sunAz = 0.005 * 2. * pi * tCur;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunEl) * sin (sunAz + vec2 (0.5 * pi, 0.)), sin (sunEl)).xzy;\n  rd = flMat * (vuMat * normalize (vec3 (uv, 4.)));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXyRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[735, 735, 758, 758, 1014], [1016, 1016, 1050, 1050, 1516], [1518, 1518, 1540, 1540, 1679], [1752, 1752, 1774, 1774, 2038], [2040, 2040, 2060, 2060, 2256], [2258, 2258, 2291, 2291, 3557], [3559, 3559, 3580, 3580, 3828], [3830, 3830, 3867, 3867, 4273], [4275, 4275, 4300, 4300, 4679], [4681, 4681, 4725, 4725, 4924], [4926, 4926, 4948, 4948, 5042], [5044, 5044, 5076, 5076, 5406], [5408, 5408, 5454, 5454, 6042], [6044, 6044, 6092, 6092, 7119], [7121, 7121, 7156, 7156, 7844], [7846, 7846, 7877, 7877, 8146], [8148, 8148, 8174, 8174, 8287], [8289, 8289, 8345, 8345, 9536], [9538, 9538, 9571, 9571, 9598], [9600, 9600, 9642, 9642, 9693], [9695, 9695, 9717, 9717, 9755], [9757, 9757, 9781, 9781, 10011], [10013, 10013, 10037, 10037, 10097], [10099, 10099, 10129, 10129, 10242], [10244, 10244, 10280, 10280, 10486], [10520, 10520, 10544, 10544, 10674], [10676, 10676, 10700, 10700, 10760], [10762, 10762, 10787, 10787, 10973], [10975, 10975, 10996, 10996, 11151], [11153, 11153, 11182, 11182, 11394], [11396, 11396, 11435, 11435, 11615]], "test": "untested"}
{"id": "WtfyRS", "name": "Point In Shape Playground", "author": "demofox", "description": "some simple point in shape tests, for use as bokeh in this shader:\nhttps://www.shadertoy.com/view/3tXyRS", "tags": ["2d"], "likes": 3, "viewed": 355, "published": 3, "date": "1592277074", "time_retrieved": "2024-07-30T21:00:53.524108", "image_code": "// BOKEH SHAPES:\n// 0 = circle\n// 1 = triangle\n// 2 = hour glass\n// 3 = diamond\n// 4 = star\n#define BOKEH_SHAPE 4\n\nfloat SignedTriArea(vec2 a, vec2 b, vec2 c)\n{\n    return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);\n}\n\nvec3 BaryCentricCoordinates(vec2 P, vec2 A, vec2 B, vec2 C)\n{\n    float ABC = SignedTriArea(A, B, C);\n    \n    vec3 ret;\n    ret.x = SignedTriArea(C, A, P) / ABC;\n    ret.y = SignedTriArea(A, B, P) / ABC;\n    ret.z = SignedTriArea(B, C, P) / ABC;    \n    return ret;\n}\n\nbool PointInTriangle(vec2 uv, vec2 A, vec2 B, vec2 C)\n{\n    vec3 bary = BaryCentricCoordinates(uv, A, B, C);\n    return clamp(bary, 0.0f, 1.0f) == bary;\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // https://iquilezles.org/articles/distfunctions2d\n\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nbool PointInShape(vec2 uv)\n{\n    #if BOKEH_SHAPE == 0\n    return length(uv - 0.5f) < 0.5f;\n    #elif BOKEH_SHAPE == 1\n    return PointInTriangle(uv, vec2(0.0f, 0.0f), vec2(0.5f, 1.0f), vec2(1.0f, 0.0f));\n    #elif BOKEH_SHAPE == 2\n    return PointInTriangle(uv, vec2(0.0f, 0.0f), vec2(0.5f, 0.7f), vec2(1.0f, 0.0f)) ||\n           PointInTriangle(uv, vec2(0.0f, 1.0f), vec2(0.5f, 0.3f), vec2(1.0f, 1.0f));\n    #elif BOKEH_SHAPE == 3\n    return PointInTriangle(uv, vec2(0.2f, 0.5f), vec2(0.5f, 1.0f), vec2(0.8f, 0.5f)) ||\n           PointInTriangle(uv, vec2(0.2f, 0.5f), vec2(0.5f, 0.0f), vec2(0.8f, 0.5f));    \n    #elif BOKEH_SHAPE == 4\n    return sdStar(uv - 0.5f, 0.5f, 5, 3.0f) < 0.0f;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= (iResolution.x - iResolution.y) / iResolution.x;\n    \n    if (clamp(uv, 0.0f, 1.0f) != uv)\n    {\n        fragColor = vec4(0.2f, 0.2f, 0.2f, 1.0f);\n        return;\n    }\n    \n    float shade = PointInShape(uv) ? 1.0f : 0.0f;\n    fragColor = vec4(shade, shade, shade, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 160, 160, 224], [226, 226, 287, 287, 494], [496, 496, 551, 551, 650], [652, 652, 711, 824, 1224], [1226, 1226, 1254, 1254, 1927], [1929, 1929, 1986, 1986, 2356]], "test": "untested"}
{"id": "tlscW7", "name": "Sin() approximation", "author": "Moniewski", "description": "Sine approximation based on Bhaskara I's formula\nhttps://en.wikipedia.org/wiki/Bhaskara_I%27s_sine_approximation_formula", "tags": ["sin", "sine"], "likes": 6, "viewed": 432, "published": 3, "date": "1592266436", "time_retrieved": "2024-07-30T21:00:54.266124", "image_code": "// Sine approximation based on Bhaskara I's formula\n// White pixels are difference between sin() and my function\n\n#define ZOOM 1.5\n#define SCROLL_SPEED 0.5\n\n#define M_1_PI 0.318309886183790671538  /* 1/pi */\nfloat aprSin(float x) {\n    x *= M_1_PI;\n    float a = fract(x);\n    float b = a * (1.0 - a);\n    float c = (b * 4.0) / (1.25 - b);\n    float f = -sign(fract(x * 0.5) - 0.5);\n\treturn c * f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/(iResolution.y*0.5);\n    uv *= ZOOM;\n    float xScroll = uv.x + iTime * SCROLL_SPEED;\n    float pSin = step(sin(xScroll), uv.y);\n    float pAprSin = step(aprSin(xScroll), uv.y);\n    float o = max(mix(0.5, 0.2, pAprSin), abs(pSin - pAprSin));\n    fragColor = vec4(vec3(o), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlscW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 231, 231, 399], [401, 401, 458, 458, 783]], "test": "untested"}
{"id": "ttlcDM", "name": "blending smooth spheres", "author": "cabbibo", "description": "testing smooth min", "tags": ["spheres", "smoothmin"], "likes": 2, "viewed": 367, "published": 3, "date": "1592255569", "time_retrieved": "2024-07-30T21:00:55.005148", "image_code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n// power smooth min (k = 8);\n// polynomial smooth min (k = 0.1);\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h),a.y);\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    \n    vec2 res = vec2(10000.,-1.);\n    for( int i = 0; i< 8; i++){\n       res = opU(res, vec2(sdSphere( pos - vec3( -1.2 , float(i) * .15 -.5 , -.4) , .1  ),1.));\n        \n    }\n    \n    float blendTime = .5*abs(sin(iTime));\n    \n    for( int i = 0; i< 8; i++){\n       res = smin(res, vec2(sdSphere( pos - vec3( 0. , float(i) * .15 -.5 , -.4) , .1 ),1.),  blendTime);\n        \n    }\n    \n    \n    vec2 rightRes = vec2(10000.,-1.);\n    for( int i = 0; i< 8; i++){\n    \trightRes = opU(rightRes, vec2(sdSphere( pos - vec3( 1.2 , float(i) * .15 -.5 , -.4) , .1  ),1.));\n    }\n    \n    rightRes = smin( rightRes , rightRes , blendTime );\n\n    \n    res = opU( rightRes , res );\n    \n        \n\n \t//vec2 res = vec2( sdSphere( pos - vec3( .3 , .3 , -0.4 ) , 1.1 ) , 1. ); \n    //res = opU( res , vec2( sdBox( pos- vec3( -.8 , -.4 , 0.2 ), vec3( .4 , .3 , .2 )) , 2. ));\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0. );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n      \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n    // Balloon\n    if( res.y == 1. ){\n            \n    \tcolor = vec3( 1. , 0., 0.) * match + vec3( .3 , .1, .2 );\n        vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n    // Box\n    }else if(res.y == 2. ){\n        \n        color = norm;\n        \n    }\n        \n        \n  }\n   \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 291, 355, 355, 533], [535, 629, 658, 658, 701], [703, 703, 734, 734, 830], [832, 832, 867, 867, 891], [894, 959, 997, 997, 1108], [1110, 1194, 1215, 1215, 2114], [2118, 2118, 2166, 2166, 2633], [2637, 2750, 2781, 2781, 3007], [3012, 3012, 3056, 3056, 3667], [3671, 3671, 3728, 3728, 4215]], "test": "untested"}
{"id": "wtscWM", "name": "oscillating spiral", "author": "FabriceNeyret2", "description": "study:\ntrying to grasp the pattern behind [url]https://www.facebook.com/groups/procgenart/permalink/2021842221279930/[/url]\n(see image below)\nNot even  close for now :-)", "tags": ["spiral", "logarithmic", "short", "reproduction"], "likes": 7, "viewed": 460, "published": 3, "date": "1592252542", "time_retrieved": "2024-07-30T21:00:55.796034", "image_code": "#define PI           3.141593\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))\n#define lin(x)       .5+.5*sin(30.*(x))\n#define osc(u,v)     lin(P.x+u*sin(v*2.*PI*P.y))\n#define spi(a,u,v) ( P = Q*rot(PI*a) , osc(u,v)  )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O-=O;\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n      // M = iMouse.xy/R,\n         Q = vec2( atan(U.y,U.x), log2(length(U)) /* -iTime */ ),  P;\n\n    O.r = spi(.117, .05,1.28);\n    O.g = spi(.333, .1 ,.912);\n    \n    O =   pow(O,vec4(16.*dot(U,U))) \n        * smoothstep(.2,-.4,Q.y);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 259, 259, 569]], "test": "untested"}
{"id": "wtlyDM", "name": "Caverns of Chaos", "author": "jarble", "description": "With a few changes to my \"corridor\" fractal, I made these \"caverns.\"", "tags": ["3d", "raymarching", "fractal", "cave"], "likes": 0, "viewed": 302, "published": 3, "date": "1592251745", "time_retrieved": "2024-07-30T21:00:56.546029", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p)/10.0)/20.0,color1/2.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat caves1(vec3 p){\n    vec3 p1 = p/size;\n    return length(sin(vec3(sin(p1.x)/p1.x,cos(p1.y)-p1.y,sin(p1.z)+p1.z))*size) - size;\n}\n\nfloat caves(vec3 p) {\n    //p += sin(p.y/100.0)*100.0;\n    float result = caves1(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n        p = p.yxz-p.zyx;\n        result = max(result, caves1(p/i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n\treturn result;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn caves(p/scale)*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float speed = 10.0;\n    vec3 eye = scale*vec3(cos(iTime)/3.0,sin(iTime)/1.8,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 377, 377, 517], [761, 761, 782, 782, 894], [896, 896, 917, 950, 1180], [1182, 1182, 1205, 1205, 1237], [1239, 1660, 1751, 1751, 2106], [2121, 2375, 2440, 2440, 2572], [2574, 2663, 2692, 2692, 3002], [3004, 3496, 3636, 3636, 4246], [4248, 4618, 4703, 4703, 5407], [5409, 5736, 5785, 5820, 5951], [5953, 5953, 6010, 6010, 7122]], "test": "untested"}
{"id": "wtlyWM", "name": "in Void", "author": "wyatt", "description": "This is a simulation of a fluid in a void. ", "tags": ["fluid"], "likes": 14, "viewed": 442, "published": 3, "date": "1592246106", "time_retrieved": "2024-07-30T21:00:57.413709", "image_code": "// Can we get built-in speedup please!!\nMain {\n\tQ = (A(U));\n    Q = Q.w*min(1.+.3*sin(16.+10.*Q.z*Q.w+vec4(1,2,3,4)),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\n", "buffer_a_code": "#define T(U) A((U))\nvec4 F (vec2 U, vec2 u,vec4 o) {\n\tvec4 a = T(U+u);\n      u = normalize(u);\n     return vec4(u*(a.z*a.w-o.z*o.w),0,0);\n}\nMain {\n\tQ = T(U);\n    vec4 o = Q;\n    Q += 0.25*F(U,vec2(0,1),o);\n    Q += 0.25*F(U,vec2(1,0),o);\n    Q += 0.25*F(U,vec2(0,-1),o);\n    Q += 0.25*F(U,vec2(-1,0),o);\n    \n    \n    \n    vec2 M = vec2(.1,0.5)*R;\n    if (iMouse.z>0.)M=iMouse.xy;\n\tif (length(U-M) < 10.) \n        Q = vec4(.3,0,Q.z,1);\n\tif (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)\n        Q = vec4(0,0,Q.z,Q.w);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define T(U) A((U))\nvec4 F (vec2 U, vec2 u,vec4 o) {\n\tvec4 a = T(U+u);\n     u = normalize(u);\n     return vec4(0,0,a.w*dot(u,(a.xy-o.xy)),0);\n}\nMain {\n\tQ = T(U);\n    vec4 o = Q;\n    Q += 0.25*F(U,vec2(0,1),o);\n    Q += 0.25*F(U,vec2(1,0),o);\n    Q += 0.25*F(U,vec2(0,-1),o);\n    Q += 0.25*F(U,vec2(-1,0),o);\n    vec2 M = vec2(.1,0.5)*R;\n    if (iMouse.z>0.)M=iMouse.xy;\n\tif (length(U-M) < 10.) \n        Q = vec4(.3,0,Q.z,1);\n\tif (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)\n        Q = vec4(0,0,Q.z,Q.w);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = vec4(0);\n    float n = 0.;\n    for (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++) \n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        n += a.w*a.w*length(u);\n        Q += a*a.w*a.w*length(u);\n   \t}\n    if (n>0.) Q/=n;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define T(U) A((U)-C(U).xy)\n#define Y(U) C((U)-C(U).xy)\nvec4 F (vec2 U, vec2 u, vec4 o) {\n    vec4 a = Y(U+u);\n    u = normalize(u);\n    float d = dot(u,a.xy-o.xy);\n    if (d>0.) return -d*o;\n    return -d*(a);\n\n}\nMain {\n    Q = T(U);\n\tvec4 o = Q;\n    Q += 0.25*(\n    \tF(U,vec2(0,1),o)+\n    \tF(U,vec2(1,0),o)+\n    \tF(U,vec2(0,-1),o)+\n    \tF(U,vec2(-1,0),o));\n    Q.w = max(Q.w,0.);\n    Q.zw += 1e-2*vec2(1,-1)*Q.wz*(1.-Q.w)*Q.w;\n    if (Q.w <= 0.) Q *= 0.;\n    vec2 M = vec2(.1,0.5)*R;\n    if (iMouse.z>0.)M=iMouse.xy;\n\tif (length(U-M) < 10.) \n        Q = vec4(.3,0,Q.z,1);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtscD7", "name": "Cities on Mars", "author": "jarble", "description": "This planet's surface is covered with mesh-like megastructures.", "tags": ["3d", "raymarching", "planet"], "likes": 2, "viewed": 351, "published": 3, "date": "1592245437", "time_retrieved": "2024-07-30T21:00:58.153730", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float planet_size = 1000.0;\nint color;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\nvec3 plant_color(vec3 p)\n{\n    return vec3(0.8,0.8,0.8)+vec3(sin(length(p*5.0)))/8.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat sceneSDF1(vec3 p) {\n    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));\n}\n\nfloat sceneSDF2(vec3 p){\n    p *= 3.0;\n\treturn 0.5 + sceneSDF1(p/2.0+sceneSDF1(p/5.0));\n}\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat planet_surface(vec3 p){\n return\tlength(p)-planet_size;\n}\n\nfloat foliage1(vec3 p){\n    float size = 100.0;\n    p += sin(p/50.0)*50.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)-p1.y,cos(p1.y)-p1.z,sin(p1.z)-p1.x))*size;\n    return length(p) - size;\n}\n\nfloat foliage(vec3 p,float jungle) {\n    float result = foliage1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, foliage1(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return max(result,jungle-3.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = 1.1+dunes(p,10.0)/5.0+max(planet_surface(p),-min(sceneSDF2(p/7.0),min(sceneSDF2(p.xzy/11.0),sceneSDF2(p/13.0))));\n    float mesh_scale = 25.0*sin(length(p/1000.0))+50.0;\n    float foliage1 = min(foliage(p,result-mesh_scale),foliage(p.zxy,result-mesh_scale));\n    float result1 = min(result, foliage1);\n    if(result1 == result){\n    \tcolor = 1;\n    }\n    else if(result1 == foliage1){\n    \tcolor = 2;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result1*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale/1000.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime/speed))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a;\n    if(color == 1){\n    \tK_a = surface_color(p);\n    }\n    else{\n    \tK_a = plant_color(p);\n    }\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 326, 326, 464], [466, 466, 492, 492, 553], [797, 797, 822, 869, 925], [927, 927, 951, 951, 1016], [1018, 1018, 1056, 1056, 1131], [1132, 1132, 1169, 1169, 1228], [1230, 1230, 1259, 1259, 1292], [1294, 1294, 1317, 1317, 1491], [1493, 1493, 1529, 1529, 1759], [1761, 1761, 1785, 1785, 2317], [2319, 2740, 2831, 2831, 3162], [3177, 3431, 3496, 3496, 3628], [3630, 3719, 3748, 3748, 4058], [4060, 4552, 4692, 4692, 5302], [5304, 5674, 5759, 5759, 6531], [6533, 6860, 6909, 6944, 7075], [7077, 7077, 7134, 7134, 8195]], "test": "untested"}
{"id": "tlfcD7", "name": "Random  pattern", "author": "z0rg", "description": "Some weird looking shader coded on Android shader editor.", "tags": ["2d", "random", "abstract", "pattern"], "likes": 5, "viewed": 223, "published": 3, "date": "1592235533", "time_retrieved": "2024-07-30T21:00:58.902727", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,-sina,sina,cosa);}\nconst float PI = 3.14159265;\nbool rng(float a, float mi, float ma)\n{\n  return (a>mi && a<ma)|| (a>ma && a<mi);\n}\nvec3 cols[4];\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat loz(vec2 uv, float sz)\n{\n  return lenny(uv)-sz;\n}\n\nfloat cir(vec2 uv, float r)\n{\n  return length(uv)-r;\n}\n\nvoid setup()\n{\n  cols[0] = .8*vec3(106, 48, 128)/255.;\n  cols[1] = vec3(125, 44, 82)/255.;\n  cols[2] = .8*vec3(232, 26, 77)/255.;\n  cols[3] = .9*vec3(227, 187, 54)/255.;\n}\n\nfloat rdrLine(vec2 p, float tim)\n{\n  float xPosl = smoothstep(-1.,1., sin(tim))-.5;\n  float xPosr = smoothstep(-1.,1., sin(tim+.5))-.5;\n  float width = .5;\n  float thick = .05;\n  float line = float(rng(p.y+.1*sin((tim+p.x)*PI*5.), -thick,+thick) && rng(p.x,xPosl,xPosr));\n  return line+.1*max(xPosl,.5)*sat(1.-length(p));\n}\n\nvec3 rdr(vec2 uv)\n{\n\n  setup();\n\n  vec3 col;\n  int i = 0;\n  int cnt =16;\n  float fcnt = float(cnt);\n  float tim = iTime+(.5+.5*sin(iTime*.5))*floor(asin(sin(iTime*PI*2.)))+abs(sin(iTime*PI));\n  tim*=.1;\n    \n  while (i<cnt)\n  {\n    float fi = float(i);\n    col += rdrLine(uv-vec2(0.,(fi-fcnt/2.)*.05),fi*.1*tim+fi)*cols[int(mod(fi,4.))];\n   ++i;\n  }\n\n  col *= cols[int(clamp(length(uv)*5.,0.,3.))];\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec2 uv2 = uv*r2d(uv.x);\n  uv2.x += sin(uv.y*15.)*.1;\n  vec3 col = rdr(uv2).yzx+rdr(uv*length(uv+vec2(sin(iTime),cos(iTime))*.5))*.5;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv *= 2.+sin(iTime*.25)*.5;\n  vec3 col = rdr2(abs(r2d(pow(length(uv*r2d(uv.y))+sin(iTime+uv.x)*.1,5.))*uv));\n\n  col*=col*(abs(sin(iTime))+.5)*2.;\n  col += 5.*cols[0]*pow(sat(1.-lenny(uv)),5.);\n  col = pow(col,vec3(1./2.2));\n  col = mix(col, col.zxy, sin(iTime*.2)*.5+.5);\n  fragColor = vec4(col.zyx, 1.0);\n}\n", "image_inputs": [{"id": 23169, "src": "https://soundcloud.com/nutone/cannibals-feat-dynamite-preview", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcD7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 415, 415, 490], [520, 520, 559, 559, 603], [619, 619, 639, 639, 666], [667, 667, 688, 688, 718], [719, 719, 749, 749, 774], [776, 776, 805, 805, 830], [832, 832, 846, 846, 1003], [1005, 1005, 1039, 1039, 1328], [1330, 1330, 1349, 1349, 1744], [1746, 1746, 1766, 1766, 1918], [1920, 1920, 1977, 1977, 2378]], "test": "untested"}
{"id": "WlscDM", "name": "Simple Blobby Cloud 1", "author": "Leria", "description": "Simple blobby cloud", "tags": ["noise", "cloud", "perlin"], "likes": 2, "viewed": 399, "published": 3, "date": "1592229918", "time_retrieved": "2024-07-30T21:00:59.770408", "image_code": "#define RADIUS 10.\n\n#define PI 3.14\n\n\n\n//iq noise\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n/////////////////////\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.;\n    f += 0.2500*noise( p ); p = p*2.;\n    f += 0.1250*noise( p ); p = p*2.;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n \treturn length((pXp0)) - radius;   \n}\n\nvec3 cam = vec3(0., 0., 30.);\nfloat uniform_step = .1;\n\nvoid draw(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    //antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing/jittering\n    vec3 p = cam+dir*antialiasing;\n    int s = 0;\n        \n    float t = 1.;\n    float dist_acc = 0.;\n    \n    float perturbation = fbm(p*3.5);\n  \tfloat dens = perturbation;\n    vec3 rgb_t = vec3(transp(uniform_step, .15, dens), transp(uniform_step, .15, dens), transp(uniform_step, .15, dens));\n    \n\n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n    \n    for(s; s < 120; s++)\n    {                       \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p-cam, p-cam);\n        float dist_center = length(center-cam);\n        \n        //if too far, then big step        \n        if(sqrt(dist_dist)-(dist_center-(radius+perturbation*10.)) < 0.)\n        {\n        \tk_step = dist_center-(radius);\n        }\n\n        //if in the shape, draw\n        if( sdf_sphere(p-center, RADIUS+perturbation*10.) <= 0.)\n        {            \n           \t//blending\n        \tc += t_acc*vec3(1.)*(1.-rgb_t);\n            dens = fbm(p);\n            //rgb_t = vec3(transp(uniform_step, .2, dens), transp(uniform_step, .2, dens), transp(uniform_step, .2, dens));\n\t\t\tt_acc *= rgb_t;  \n        }   \n                \n        //if it will never be in the shape anymore, return;\n        if(length(p-cam) >(dist_center+radius+perturbation*10.))\n        {\n         \tbreak;\n        }\n        \n        p += dir*k_step;       \n    }\n}\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(.5, .5, .7);\n    vec2 m = (2.*PI * iMouse.xy/iResolution.xy - PI)/100.;\n    \n    vec3 ray_dir = vec3(uv, -1.);\n    vec3 C = cam, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    cam = C;\n    draw(normalize(R), vec3(0., 0., 0.), vec3(0., 1., 0.), RADIUS, color);\n    \n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 50, 73, 73, 109], [111, 111, 137, 137, 457], [482, 482, 503, 515, 686], [689, 689, 765, 765, 812], [814, 814, 846, 846, 866], [868, 868, 902, 902, 924], [963, 963, 1006, 1006, 1045], [1103, 1103, 1178, 1178, 2668], [2671, 2671, 2695, 2695, 2780], [2783, 2783, 2840, 2840, 3295]], "test": "untested"}
{"id": "WlsyWM", "name": "Rainbow Hypnosis Zoom", "author": "izutionix", "description": " ", "tags": ["zoom", "spiral", "rainbow"], "likes": 5, "viewed": 439, "published": 3, "date": "1592225532", "time_retrieved": "2024-07-30T21:01:00.597197", "image_code": "// onetweet version by Fabrice:\n/*\n#define mainImage(O,u)  vec2 R = iResolution.xy, U = u-.5*R;          \\\nO =  .5 - .5*cos( 3.*( atan(U.x,U.y) + log2(length(U)/R.y) -2.*iTime  \\\n                       + vec4(-.5, 0, .5,0) ) )\n*/\n\n#define t iTime\n\nvec3 pal(float g) {\n    float f = 6.; //factor\n    //f *= cos(t); //uncomment to animate colors\n    vec3 o = vec3(.5, .75, 1); //offset\n    o -= (o.r+o.g+o.b)/3.; //center (subtract average)\n    return 0.5 + 0.5*-cos( f*(g/f+o) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 pv = vec2( atan(uv.x, uv.y), length(uv) );\n    pv.y = log2(pv.y);\n    pv -= t;\n    pv *= 3.;\n\n    vec3 col = pal(pv.x+pv.y);\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 267, 267, 480], [482, 482, 539, 539, 770]], "test": "untested"}
{"id": "tlfcWn", "name": "Cyclic Rainbow", "author": "izutionix", "description": " ", "tags": ["rainbow"], "likes": 3, "viewed": 240, "published": 3, "date": "1592224907", "time_retrieved": "2024-07-30T21:01:01.425981", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 f = vec3(1., 1., 1.); //factor\n    vec3 o = vec3(.5, .75, 1); //offset\n    o -= (o.r + o.g + o.b)/3.; //center (subtract average)\n\n    vec3 col = 0.5 + 0.5*-cos( 6.283*(uv.x + o + iTime*.125) );\n    \n    col = pow(col, f);\n    //col *= vec3(1., .75, .5);\n    //col = .01/abs(col-uv.yyy); //graph\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 435]], "test": "untested"}
{"id": "3tsyWM", "name": "Crappy code", "author": "z0rg", "description": "A small thingy did this noon, don't judge the code, it's mainly been done on my smartphone and I did not take time to clean it.", "tags": ["2d", "design", "vaporwave", "chill", "clean"], "likes": 2, "viewed": 222, "published": 3, "date": "1592223150", "time_retrieved": "2024-07-30T21:01:02.190936", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,-sina,sina,cosa);}\n\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\n\nfloat _union(float a, float b)\n{\n  return min(a,b);\n}\nvec3 cols[4];\nvoid setup()\n{\n  cols[0] = .8*vec3(106, 48, 128)/255.;\n  cols[1] = vec3(125, 44, 82)/255.;\n  cols[2] = .8*vec3(232, 26, 77)/255.;\n  cols[3] = .9*vec3(227, 187, 54)/255.;\n}\nvec3 rdr(vec2 uv, float sh, float tm)\n{\n  int cnt = 8;\n  float fcnt = float(cnt);\n  int i = 0;\n  vec3 col = vec3(1.);\n\nfloat sharp = 200.;//(uv.y<0. ? 20.*(abs(uv.x)+.1) : 200.)*sh;\n   while(i <cnt)\n   {\n     float fi = 0.;//float(i);\n     float rx = .0;//(fi-(fcnt/2.))/(fcnt/2.);\n     vec2 p = r2d(5.*smoothstep(0.,1.,(.5+.5*sin(.1*float(i)+tm*.1))))*(vec2(sin(iTime)*.1, .1*cos(iTime*.5))+vec2(1.*(abs(.8+.4*sin(iTime*.5))))*uv-vec2(rx,0.));\nfloat shading = 2.*dot(p,vec2(p.x,p.y));\n     col = mix(col, shading*vec3(1.), (1.-sat((lenny(p)-.55-.1*abs(sin(fi*15.+iTime*.1)))*sharp)));\n     ++i;\n   }\n   col *= pow(1.-sat(lenny(uv*.5)),.5);\n\n   setup();\n   float axis = uv.y;\n   if (abs(axis) < .4)\n   {\n     col *= vec3(1.)+cols[int(mod(abs((1.9+uv.y+uv.x+mod(iTime*sh,1.)*.6)*20.),4.))].zyx;\n   }\n  return col;\n}\n\n\n\nvec3 tone(vec3 c,vec2 uv)\n{\n  c *= mix(vec3(1.),vec3(.78,.87,.98), sat(length(uv)-.9));\nc = pow(c, vec3(1./.6));\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv*=5.;\n  vec3 col = rdr(uv,.4,iTime);\n  col = mix(rdr(uv*.5,-.2,iTime*2.),col, 1.-sat((length(uv)-1.2)*200.));\n    vec3 col2 = col;\n    col2.xy = col2.xy * r2d(length(uv));\n    col = mix(col, col2, (1.-length(uv))*.5+sin(2.7));\n    col = pow(col, vec3(1./.8));\n  fragColor = vec4(tone(col,uv), 1.0);\n}\n", "image_inputs": [{"id": 23162, "src": "https://soundcloud.com/emil-rottmayer/detached?in=emil-rottmayer/sets/detached-ep-vinyl-edition", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyWM.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 415, 415, 490], [493, 493, 513, 513, 540], [542, 542, 563, 563, 593], [595, 595, 627, 627, 648], [663, 663, 677, 677, 834], [835, 835, 874, 874, 1649], [1653, 1653, 1680, 1680, 1779], [1781, 1781, 1838, 1838, 2234]], "test": "untested"}
{"id": "wtXyD7", "name": "pointillze", "author": "indere", "description": "inspired by https://www.shadertoy.com/view/lttBRs", "tags": ["ps"], "likes": 3, "viewed": 274, "published": 3, "date": "1592217504", "time_retrieved": "2024-07-30T21:01:02.950904", "image_code": "const float min_scale = 10.0;\nconst float max_scale = 200.0;\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t\n    \n    float scale = min_scale + (max_scale - min_scale) * (0.5 + 0.5 * sin(iTime * 0.62423));\n    \n    vec2 st = fragCoord / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    \n    st *= scale;\n    \n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    float m_dist = 100.;  // minimum distance\n    vec2 uv = st;\n    bool tag = false;\n    for(int y = -1; y <= 1; ++y){\n        for(int x = -1; x <= 1; ++x){\n        \tvec2 neighbor = vec2(float(x),float(y));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            // Keep the closer distance\n            if(dist < 0.65 && m_dist > dist){\n            \tm_dist = dist;\n                uv = st + diff;\n                tag = true;\n            }\n        }\n    }\n    \n    if(!tag){\n    \tfragColor = vec4(vec3(0.5), 1.0);\n        return ;\n    }\n    \n    uv /= scale;\n    uv.x /= iResolution.x / iResolution.y;\n    vec3 color = texture(iChannel0, uv).rgb;\n    //color += m_dist;\n    \n    //center\n    //color += 1.-step(.06, m_dist);\n    \n    //color.r +=  step(0.98, f_st.x) + step(0.98, f_st.y);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat rgb2gray(vec3 c){\n\treturn dot(c, vec3(0.299, 0.587,0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 86, 86, 179], [182, 182, 239, 239, 1495]], "test": "untested"}
{"id": "tlXcW7", "name": "Channel Pixel Sorting", "author": "Xaymar", "description": "Sorting pixels by their color value, either per channel or overall. It is a stupid idea to do this in a pixel shader, but it's not like I can prevent you from trying this either.", "tags": ["pixelsort"], "likes": 5, "viewed": 736, "published": 3, "date": "1592215998", "time_retrieved": "2024-07-30T21:01:03.806616", "image_code": "// BUG: Snapping does not align with edges, instead centers on the edge.\n// BUG: Snapping also seems broken when not done using round().\n\n#define PI 3.141\n\n#define _RAD 0.01745329251994329576923690768489\n#define TO_RAD(x) (x * _RAD)\n\n#define PIXELSORT_RANGE 16u\n#define PIXELSORT_HORIZONTAL\n//#define PIXELSORT_SNAP\n#define PIXELSORT_DIR <\n\n// Channel sort is somehow 2x faster.\n#define PIXELSORT_CHANNEL\n\n#define PIXELSORT_ARRAY_SIZE ((PIXELSORT_RANGE * 2u) + 1u)\n#define PIXELSORT_ARRAY_MIN 0u\n#define PIXELSORT_ARRAY_CENTER PIXELSORT_RANGE\n#define PIXELSORT_ARRAY_MAX PIXELSORT_RANGE * 2u - 1u\n\n//#define DEBUG (uint(iTime) % PIXELSORT_ARRAY_SIZE)\n\nvoid sort_channel(inout vec4 a[PIXELSORT_ARRAY_SIZE], int length)\n{    \n    int i, j;\n    float value;\n    for(i = 1; i < length; i++)\n    {\n        value = a[i].r;\n        for (j = i - 1; j >= 0 && a[j].r PIXELSORT_DIR value; j--)\n            a[j + 1].r = a[j].r;\n        a[j + 1].r = value;\n    }\n    for(i = 1; i < length; i++)\n    {\n        value = a[i].g;\n        for (j = i - 1; j >= 0 && a[j].g PIXELSORT_DIR value; j--)\n            a[j + 1].g = a[j].g;\n        a[j + 1].g = value;\n    }\n    for(i = 1; i < length; i++)\n    {\n        value = a[i].b;\n        for (j = i - 1; j >= 0 && a[j].b PIXELSORT_DIR value; j--)\n            a[j + 1].b = a[j].b;\n        a[j + 1].b = value;\n    }\n}\n\nfloat vec4_value(in vec4 v) {\n    return v.r + v.g + v.b;\n}\n\nvoid sort_value(inout vec4 a[PIXELSORT_ARRAY_SIZE], int length)\n{    \n    int i, j;    \n    vec4 value;\n    for(i = 1; i < length; i++)\n    {\n        value = a[i];\n        for (j = i - 1; j >= 0 && a[j].a PIXELSORT_DIR value.a; j--)\n            a[j + 1] = a[j];\n        a[j + 1] = value;\n    }\n}\n\nvec4 getSample(vec2 uv) {\n    vec4 smp = texture(iChannel0, uv);\n    #ifndef PIXELSORT_CHANNEL\n    smp.a = (smp.r * 0.2126) + (smp.g * 0.7152) + (smp.b * 0.0722);\n    #endif\n    return smp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 pixels[PIXELSORT_ARRAY_SIZE];\n    #ifdef PIXELSORT_HORIZONTAL\n    vec2 xystep = vec2(1., 0.);\n    #else\n    vec2 xystep = vec2(0., 1.);\n    #endif\n    \n    vec2 xy = fragCoord.xy;\n    #ifdef PIXELSORT_SNAP\n    // Snap to a the nearby sort center.\n    #ifdef PIXELSORT_HORIZONTAL\n    float _x1 = xy.x / float(PIXELSORT_ARRAY_SIZE);\n    float _x2 = round(_x1) + .5;\n    float _x3 = _x2 * float(PIXELSORT_ARRAY_SIZE);\n    float d = _x3 - xy.x;\n    xy.x = _x3;\n    #else\n    float _x1 = xy.y / float(PIXELSORT_ARRAY_SIZE);\n    float _x2 = round(_x1) + .5;\n    float _x3 = _x2 * float(PIXELSORT_ARRAY_SIZE);\n    float d = _x3 - xy.y;\n    xy.y = _x3;\n    #endif\n    #endif\n    \n    for (uint idx = 0u; idx < PIXELSORT_ARRAY_SIZE; idx++) {\n    #ifdef PIXELSORT_SNAP\n        vec2 uv = xy + xystep * float(int(idx) - int(PIXELSORT_ARRAY_CENTER));\n    #else        \n        vec2 uv = xy + xystep * float(int(idx) - int(PIXELSORT_ARRAY_CENTER));\n    #endif\n        uv /= iResolution.xy;\n\t    pixels[idx] = getSample(uv);\n    }\n    \n    #ifdef DEBUG\n    fragColor.rgb = pixels[uint(DEBUG)].rgb;\n    #else\n    #ifdef PIXELSORT_CHANNEL\n    sort_channel(pixels, int(PIXELSORT_ARRAY_SIZE));\n    #else\n    sort_value(pixels, int(PIXELSORT_ARRAY_SIZE));\n    #endif\n    \n    #ifdef PIXELSORT_SNAP\n    fragColor.rgb = pixels[int(d)].rgb;\n    #else\n    fragColor.rgb = pixels[PIXELSORT_ARRAY_CENTER].rgb;\n    #endif\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1346, 1346, 1375, 1375, 1405], [1704, 1704, 1729, 1729, 1895], [1897, 1897, 1954, 1954, 3371]], "test": "untested"}
{"id": "ttXyW7", "name": "An Entourage", "author": "mehmetoguzderin", "description": "Lean", "tags": ["lean"], "likes": 0, "viewed": 224, "published": 3, "date": "1592210309", "time_retrieved": "2024-07-30T21:01:04.623433", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float epsilon = 0.2;\n    \n    // d(x,y)≤ε → (x,y) ∈ U\n    if (distance(uv.x, uv.y) > epsilon) col = vec3(0.0);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 426]], "test": "untested"}
{"id": "wlfyWM", "name": "Spaceship fractal", "author": "jarble", "description": "I made some changes to my [url=https://www.shadertoy.com/view/3tfcD7]\"corridor\"[/url] fractal, so it looks more like a fleet of spaceships now.", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 306, "published": 3, "date": "1592188174", "time_retrieved": "2024-07-30T21:01:05.671629", "image_code": "\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.001)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat speed = .2;\n    vec3 eye = vec3(cos(iTime*speed)/3.0,sin(iTime*speed)/1.8,iTime*speed)*size;\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n//this is based on https://www.shadertoy.com/view/4tcGDr\n#define image_scale 8.0\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\n//const float F = EPSILON\n    \n\nvec3 surface_color(vec3 p)\n{\n    p /= 10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y+p1.z)-p1.y,sin(p1.z+p1.x)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result;\n}", "buffer_a_code": "\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.001)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dmap = depth_map(fragCoord);\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float speed = .2;\n    vec3 eye = vec3(cos(iTime*speed)/3.0,sin(iTime*speed)/1.8,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = (length(dmap.xyz-eye));\n    //if(abs(sceneSDF(dmap.xyz) - sceneSDF(eye+l0*worldDir)) > .25 || sceneSDF(eye+l0*worldDir) < EPSILON){\n        l0 = log(1.0+l0)*2.0;\n    //}\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, dist);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 423, 514, 514, 881], [896, 1150, 1215, 1215, 1347], [1349, 1438, 1467, 1467, 1777], [1779, 2271, 2411, 2411, 3021], [3023, 3393, 3478, 3478, 4250], [4252, 4579, 4628, 4663, 4794], [4796, 4796, 4823, 4823, 4972], [4974, 4974, 5031, 5031, 5757]], "test": "untested"}
{"id": "3tfcD7", "name": "Fractal city corridor", "author": "jarble", "description": "I discovered this \"corridor\" by chance when I modified the formula of a [url=https://www.shadertoy.com/view/wtsyWN]foliage\" fractal[/url].", "tags": ["3d", "raymarching", "fractal", "city"], "likes": 1, "viewed": 379, "published": 3, "date": "1592184574", "time_retrieved": "2024-07-30T21:01:06.523353", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y)-p1.y,sin(p1.z)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    float i = 1.0;\n    for(int k = 0; k < 3; k++){\n    \tresult = max(result, planet_surface(p*i)/(i));\n        i *= 10.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*vec3(cos(iTime)/3.0,sin(iTime)/1.8,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/((t/4096)%5+(t/4096)%3)))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 311, 311, 415], [659, 659, 688, 688, 811], [813, 813, 837, 837, 1108], [1110, 1531, 1622, 1622, 1970], [1985, 2239, 2304, 2304, 2436], [2438, 2527, 2556, 2556, 2866], [2868, 3360, 3500, 3500, 4110], [4112, 4482, 4567, 4567, 5271], [5273, 5600, 5649, 5684, 5815], [5817, 5817, 5874, 5874, 6814]], "test": "untested"}
{"id": "3lXcW8", "name": "radial flare filter", "author": "TheNosiriN", "description": "The original shader isn't mine but I modified it for a better look and better use. I don't remember where I got it but I know it's not from shadertoy.", "tags": ["posteffect", "blur", "flare", "fliter"], "likes": 47, "viewed": 1260, "published": 3, "date": "1592157586", "time_retrieved": "2024-07-30T21:01:07.356126", "image_code": "#define T texture(iChannel0,.5+(p.xy*=.992)).rgb\n\n#define radialLength 0.95     //0.5 - 1.0\n#define imageBrightness 9.0   //0 - 10\n#define flareBrightness 4.5   // 0 - 10\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3(fragCoord / iResolution.xy, max(0.0, (imageBrightness/10.0)-0.5)) - 0.5;\n    vec3 o = T;\n    \n    for (float i=0.0; i<100.0; i++)\n    {\n        p.z += pow(max(0.0, 0.5-length(T)), 10.0/flareBrightness) * exp(-i * (1.0-(radialLength)) );\n    }\n    \n    vec3 flare = p.z * vec3(0.7, 0.9, 1.0); //tint\n    \n    fragColor = vec4(o*o+flare, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 229, 229, 591]], "test": "untested"}
{"id": "wtsyDN", "name": "Reintegration fluid", "author": "michael0884", "description": "Cellular automaton particle tracking with full conservation of mass/energy and approximately particle number\nYou need 8x-16x acceleration to see anything!", "tags": ["particles", "ca"], "likes": 31, "viewed": 851, "published": 3, "date": "1592149663", "time_retrieved": "2024-07-30T21:01:08.118088", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    vec4 U = decode(texel(ch0, pos).zw);\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    vec4 D = pixel(ch2, pos);\n    float ang = atan(D.w, D.z);\n    float mag = length(D.zw);\n    vec3 bord = smoothstep(border_h-1.,border_h-3.,border(pos))*vec3(1.);\n\tvec3 rho = vec3(1.,1.7,4.)*(0.*abs(U.z)+5.*smoothstep(0.1, 0.25, P.w));\n    // Output to screen\n    fragColor = vec4(sqrt(rho)*(0.15+hsv2rgb(vec3(ang, 1., mag))) + bord,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nfloat time;\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*0.5); \n    float box = sdBox(Rot(0.5*time)*(p - R*0.5), R*vec2(0.1, 0.01));\n    float drain = -sdBox(p - R*vec2(0.9, 0.05), vec2(50));\n    return max(drain,min(bound, box));\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec4 decode(vec2 x)\n{\n    uint v = floatBitsToUint(x.x);\n    uint m = floatBitsToUint(x.y);\n    return vec4(unpack(v),unpack(m)*128.); \n}\n\nvec2 encode(vec4 x)\n{\n    uint v = pack(x.xy);\n    uint m = pack(x.zw/128.);\n    return vec2(uintBitsToFloat(v),uintBitsToFloat(m)); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n", "buffer_a_code": "#define mass 0.1\n#define div 0.7\n\n\nvec2 Force(vec2 dx)\n{\n    return 20.*dx*exp(-dot(dx,dx));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n        \n    //particle position\n    vec2 x = vec2(0.);\n    //particle velocity, mass and grid distributed density\n    vec4 vm = vec4(0.); \n    vec2 F = vec2(0., -0.0004);\n    vec2 dF = vec2(0.);\n    \n    //reintegration advection\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        vec2 x0 = data.xy; //update position\n        //how much mass falls into this pixel(is exact, 0 or full)\n        vm.w += vm0.z*G((pos - x0)/1.5);\n        float D = step(max(abs(pos.x - x0.x),\n                           abs(pos.y - x0.y)), 0.5);\n        float D1 = 0.25*step(max(abs(pos.x - x0.x),\n                          \t\t abs(pos.y - x0.y)), 1.00);\n        \n        float pvm = vm0.z;\n        vm0.z *= (pvm<4.*mass)?D:D1;\n        if(pvm>=4.*mass && pvm > 0.) \n        {\n            x0 = mix(x0, pos, 0.5);\n        }\n           \n        //add weighted positions by mass\n        x += x0*vm0.z;\n        //add weighted velocities by mass\n        vm.xy += vm0.xy*vm0.z;\n        //add mass\n        vm.z += vm0.z;\n        dF += vm0.z*Force(pos - x0)*(1. - D);\n    }\n    vm.z = clamp(vm.z, 0., 2.);\n    \n    if(vm.z != 0. || any(isnan(vm))) //not vacuum\n    {\n        //normalize\n        x /= vm.z;\n        vm.xy /= vm.z;\n        \n        vec3 dx = vec3(-1.,0,1.);\n        vec2 px = x;\n        vec3 rand = hash32(pos+x)-0.5;\n        \n    \t//update velocity\n         //border \n    \tvec3 N = bN(px);\n        float vdotN = step(abs(N.z), border_h)*dot(N.xy, vm.xy);\n        vm.xy = vm.xy - 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += N.xy*step(abs(N.z), border_h)/N.z;\n        \n        //global force field\n        \n        vec4 GF = pixel(ch1, px);\n\n        F += (-GF.xy + (GF.zw - vm.xy)*0.15 - 0.01*vm.xy*step(N.z, border_h + 5.)); \n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.01*dm*exp(-d*d);\n        }\n   \t    vm.xy += 0.4*F*dt/(0.0001+vm.z);\n        //velocity limit\n        float v = length(vm.xy);\n        vm.xy /= (v > 1.)?v:1.;\n        x = x + (vm.xy + dF)*dt; \n    }\n    else\n    {\n        x = pos;\n        vm.xyz = vec3(0.);\n        if(distance(pos, R*vec2(0.55, 0.75)) < 1. || distance(pos, R*vec2(0.45, 0.75)) < 1.)\n        {\n            vm.xyz = vec3(0., -0.52, 3.*mass);\n        }\n        if(distance(pos, R*vec2(0.1, 0.75)) < 5.)\n        {\n            vm.xyz = vec3(0.5, -0.5, 3.*mass);\n        }\n    }\n   \n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.05) \n        {\n            x = pos;\n            vm = vec4(0.3*vec2(2.*rand.xy - 1.), 4.*mass, mass);\n        }\n        else\n        {\n            x = pos;\n        \tvm = vec4(0.);\n        }\n    }\n    \n    U = vec4(x, encode(vm));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define Radius 3\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    vec4 avm = vec4(0.);\n    float sum = 1.;\n    range(i, -Radius, Radius)\n    {\n        ivec2 p = ivec2(pos) + ivec2(i,0);\n        if(p.x >= 0 && p.x < int(R.x))\n        {\n            float k = G(vec2(i,0)*1.5/float(Radius));\n            vec4 d = decode(texel(ch0, p).zw);\n        \tavm += vec4(d.xy*d.z, d.zw)*k;\n        \tsum += k;\n        }\n    }\n    U = avm/sum;\n    U.xy = avm.xy/(avm.z+0.0001); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define Radius 3\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec4 avm = vec4(0.);\n    float sum = 1.;\n    range(i, -Radius, Radius)\n    {\n        ivec2 p = ivec2(pos) + ivec2(0,i);\n        float k = G(vec2(0,i)*1.5/float(Radius));\n        vec4 d = texel(ch0, p);\n        avm += vec4(d.xy*d.z, d.zw)*k;\n        sum += k;\n    }\n    U = avm/sum;\n    U.z = 0.5*U.z*clamp(pow(abs(U.z/0.07), 7.) - 1., -1., 1.); //water\n    //U.z = 1.2*U.z;//gas\n    U.xy = avm.xy/(avm.z+0.0001); \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//force field\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n   vec3 dx = vec3(-1., 0., 1.);\n   U.xy = 0.5*vec2(texel(ch0, pos + dx.zy).z - texel(ch0, pos + dx.xy).z,\n                   texel(ch0, pos + dx.yz).z - texel(ch0, pos + dx.yx).z);\n   //average velocity\n   vec4 a = texel(ch0, pos); \n   U.zw = a.xy;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 258, 258, 717]], "test": "untested"}
{"id": "wtlcWN", "name": "BoS - HSB in polar coords", "author": "zeta", "description": "Keep m1 pressed on a hue to expand it. The closer to the center, the more it will expand.\nhttps://thebookofshaders.com/06/\nExercise: Use a shaping function to expand a particular hue value and shrink the rest.", "tags": ["bookofshaders"], "likes": 0, "viewed": 363, "published": 3, "date": "1592148037", "time_retrieved": "2024-07-30T21:01:08.873070", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n// Function from Iñigo Quiles\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// http://www.flong.com/texts/code/shapers_poly/\nfloat doubleCubicSeatWithLinearBlend(float x, float a, float b)\n{\n  float epsilon = 0.00001;\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = min(max_param_a, max(min_param_a, a));  \n  b = min(max_param_b, max(min_param_b, b)); \n  b = 1.0 - b; //reverse for intelligibility.\n  \n  float y = 0.;\n  if (x<=a){\n    y = b*x + (1.-b)*a*(1.-pow(1.-x/a, 3.0));\n  } else {\n    y = b*x + (1.-b)*(a + (1.-a)*pow((x-a)/(1.-a), 3.0));\n  }\n  return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 m = iMouse / iResolution.xyxy;\n    vec3 color = vec3(0.0);\n\n    vec2 toCenter = vec2(0.5)-uv;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n\n    float hue = (angle/TWO_PI)+0.5;\n    \n    // Exercise: use a shaping function to expand a particular hue based on mouse coords.\n    if (m.z > 0.0) {\n        vec2 m_toc = vec2(.5) - m.xy;\n        float lens = .5 + (atan(m_toc.y, m_toc.x) / TWO_PI);\n        float lens_width = 1.0 - (length(m_toc) * 2.0);\n        hue = doubleCubicSeatWithLinearBlend(hue, lens, lens_width);\n    }\n    \n    // TODO: the opposite color of red should be green, but in our example it is cyan. Can you find a way to fix that\n    // hue = shaping_function(hue);\n    color = hsb2rgb(vec3(hue,radius,1.0));\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 173, 199, 199, 432], [434, 483, 548, 548, 1007], [1009, 1009, 1066, 1066, 1917]], "test": "untested"}
{"id": "wtsyWN", "name": "Fractal foliage 2", "author": "jarble", "description": "This fractal looks somewhat more realistic than my other [url=https://www.shadertoy.com/view/3llcW4]\"Fractal Foliage\"[/url] shader.", "tags": ["3d", "raymarching", "fractal", "trees"], "likes": 4, "viewed": 364, "published": 3, "date": "1592144031", "time_retrieved": "2024-07-30T21:01:09.804580", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 250;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)-p1.y,cos(p1.y)-p1.z,sin(p1.z)-p1.x))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    \n    \n    \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 250;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)-p1.y,cos(p1.y)-p1.z,sin(p1.z)-p1.x))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 dmap = depth_map(fragCoord);\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n        fragCoord *= image_scale;\n        vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14*0.5);\n            viewDir.xz *= rot(-iMouse.x/iResolution.x*3.14*2.0+3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = (length(dmap.xyz-eye));\n    \n    if(l0 > 250.0){\n        l0 = min(pow(l0,.9),l0);\n    }\n    else{\n        l0 = 0.0;\n    }\n    \n    \n    //if(abs(sceneSDF(dmap.xyz) - sceneSDF(eye+l0*worldDir)) > .25 || sceneSDF(eye+l0*worldDir) < EPSILON){\n        //l0 = log(1.0+l0)*2.0;\n        //l0 = pow(l0,-.9);\n    //}\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 378, 378, 482], [726, 726, 755, 755, 878], [880, 880, 904, 904, 1152], [1154, 1575, 1666, 1666, 2029], [2044, 2298, 2363, 2363, 2495], [2497, 2586, 2615, 2615, 2925], [2927, 3419, 3559, 3559, 4169], [4171, 4541, 4626, 4626, 5398], [5400, 5727, 5776, 5811, 5942], [5944, 5944, 5971, 5971, 6120], [6122, 6122, 6179, 6179, 7042]], "test": "untested"}
{"id": "WllyD4", "name": "BoS - Colorful Flag", "author": "zeta", "description": "https://thebookofshaders.com/06/\n\nExercise: use the step() function to create a colorful flag.", "tags": ["bookofshaders"], "likes": 0, "viewed": 259, "published": 3, "date": "1592138516", "time_retrieved": "2024-07-30T21:01:10.562552", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Poland can into shaders.\n    vec3 col = mix(vec3(1., 0., 0.), vec3(1., 1., 1.), step(.5, uv.y));\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 244]], "test": "untested"}
{"id": "wtsyD8", "name": "BoS - Rainbow", "author": "zeta", "description": "Exercise: make a raimbow.", "tags": ["bookofshaders"], "likes": 1, "viewed": 297, "published": 3, "date": "1592138367", "time_retrieved": "2024-07-30T21:01:11.417267", "image_code": "vec3[] colors = vec3[](\n    vec3(255.,   0.,   0.) / 255.,\n    vec3(255., 127.,   0.) / 255.,\n    vec3(255., 255.,   0.) / 255.,\n    vec3(  0., 255.,   0.) / 255.,\n    vec3(  0.,   0., 255.) / 255.,\n    vec3( 46.,  43.,  95.) / 255.,\n    vec3(139.,   0., 255.) / 255.\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float len = float(colors.length());\n    float h = 1. / len;\n    int i = int(floor(uv.y / h));\n    float j = fract(uv.y / h);\n\n    int next = int(mod(float(i+1), len));\n    vec3 col = mix(colors[i], colors[next], j);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 330, 380, 680]], "test": "untested"}
{"id": "WtXcDH", "name": "BoS - Turner's Sunset", "author": "zeta", "description": "Trying to recreate a Turner's sunset (https://thebookofshaders.com/06/turner.jpg)", "tags": ["bookofshaders"], "likes": 1, "viewed": 272, "published": 3, "date": "1592138332", "time_retrieved": "2024-07-30T21:01:12.276969", "image_code": "const float PI = 3.14159265359;\n    \n    const vec3[] colors = vec3[] (\n    vec3( 90./255.,  92./255., 145./255.),\n    vec3(225./255.,  73./255.,   7./255.),\n    vec3(234./255., 163./255., 118./255.),\n    vec3(234./255., 163./255., 118./255.),\n    vec3( 90./255.,  92./255., 145./255.)\n);\n\n// https://iquilezles.org/articles/functions\nfloat expImpulse(float x, float k)\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\n\n\nfloat fn0(float x)\n{\n    return 0.;\n}\n\nfloat fn1(float x)\n{\n    return (1.8+sin(1.9*PI*x))/5.;\n}\n\nfloat fn2(float x)\n{\n\treturn .5 + (1.-pcurve(x, 14., .2))/4.;\n}\n\nfloat fn3(float x)\n{\n    return .9;\n}\n\nfloat fn4(float x)\n{\n    return 1.+pow(x, 2.);\n}\n\n\nvec3 mixfn(vec2 uv)\n{\n    float[] ths = float[](fn0(uv.x), fn1(uv.x), fn2(uv.x), fn3(uv.x), fn4(uv.x));\n    \n    for (int i = 1; i < ths.length(); i++) {\n        if (uv.y >= ths[i-1] && uv.y <= ths[i]) {\n            return mix(colors[i-1], colors[i], smoothstep(ths[i-1], ths[i], uv.y));\n        }\n    }\n    return vec3(0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //vec3 sky = mix(SKY_COLORS[0], SKY_COLORS[1], -uv.y);\n    //vec3 sun = mix(SUN_COLORS[0], SUN_COLORS[1], expImpulse(uv.y, 7.)) * step(1.-expImpulse(1.-uv.x+.15, 3.), uv.y) - sky;\n\n    vec3 img = mixfn(uv);\n\n    fragColor = vec4(img,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 335, 371, 371, 417], [419, 419, 462, 462, 560], [564, 564, 584, 584, 601], [603, 603, 623, 623, 660], [662, 662, 682, 682, 725], [727, 727, 747, 747, 764], [766, 766, 786, 786, 814], [1145, 1145, 1200, 1200, 1490]], "test": "untested"}
{"id": "3lfyR4", "name": "BoS - Shaping Functions Exercise", "author": "zeta", "description": "https://thebookofshaders.com/05/kynd.png\n\nTODO: plot all functions side by side, as in the original png.", "tags": ["bookofshaders"], "likes": 3, "viewed": 305, "published": 3, "date": "1592138216", "time_retrieved": "2024-07-30T21:01:13.036937", "image_code": "const float PI = 3.14159265359;\n\n// from https://iquilezles.org/articles/functions\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n\nfloat plot(vec2 uv, float pct)\n{\n    return cubicPulse(pct, 0.01, uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float[] a = float[] (0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5);\n    //float[] a = float[] (1.0);\n    vec3 color = vec3(0.);\n\n    for (int i = 0; i < a.length(); i++) {;\n        float shape = 1.0 - pow(abs(uv.x), a[i]);\n        vec3 plot_color = vec3(0.0, 1.0, 0.0) * float(i+1) / float(a.length());\n        color = mix(color, plot_color, plot(uv, shape));\n    }\n\n    for (int i = 0; i < a.length(); i++) {\n        float shape = pow(cos(PI * uv.x / 2.0), a[i]);\n        vec3 plot_color = vec3(1.0, 0.0, 0.0) * float(i+1) / float(a.length());;\n        color = mix(color, plot_color, plot(uv, shape));\n    }\n\n    for (int i = 0; i < a.length(); i++) {\n        float shape = 1.0 - pow(abs(sin(PI * uv.x / 2.0)), a[i]);\n        vec3 plot_color = vec3(0.0, 0.0, 1.0) * float(i+1) / float(a.length());;\n        color = mix(color, plot_color, plot(uv, shape));\n    }\n    \n    for (int i = 0; i < a.length(); i++) {\n        // This is the same as pow(1.0 - abs(uv.x), why min with cos is needed?\n        float shape = pow(min(cos(PI * uv.x / 2.0), 1.0 - abs(uv.x)), a[i]);\n        vec3 plot_color = vec3(1.0, 1.0, 0.0) * float(i+1) / float(a.length());;\n        color = mix(color, plot_color, plot(uv, shape));\n    }\n\n    for (int i = 0; i < a.length(); i++) {\n        float shape = 1.0 - pow(max(0.0, abs(uv.x) * 2.0 - 1.0), a[i]);\n        vec3 plot_color = vec3(0.0, 1.0, 1.0) * float(i+1) / float(a.length());;\n        color = mix(color, plot_color, plot(uv, shape));\n    }\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 83, 128, 128, 222], [225, 225, 257, 257, 299]], "test": "untested"}
{"id": "td2fDt", "name": "Bos - Shapers Poly", "author": "zeta", "description": "Porting functions from http://www.flong.com/texts/code/shapers_poly/ as suggested by https://thebookofshaders.com/05/", "tags": ["bookofshaders"], "likes": 1, "viewed": 266, "published": 3, "date": "1592138149", "time_retrieved": "2024-07-30T21:01:13.791918", "image_code": "// http://www.flong.com/texts/code/shapers_poly/\n\n#define PI 3.14159265359\n\nfloat double_cubic_seat(vec2 uv, float a, float b)\n{\n    if (uv.x <= a) {\n        return b - b*pow(1.0 - uv.x / a, 3.0);\n    } else {\n        return b + (1.0 - b) * pow((uv.x - a) / (1.0 - a), 3.0);\n    }\n}\n\nfloat double_cubic_seat_linear_blend(vec2 uv, float a, float b)\n{\n    if (uv.x <= a) {\n        return b * uv.x + (1.0 - b) * a * (1.0 - pow(1.0 - uv.x / a, 3.0));\n\n    } else {\n        return b * uv.x + (1.0 - b) * (a + (1.0 - a) * pow((uv.x - a) / (1.0 - a), 3.0));\n    }\n}\n\n\nfloat double_odd_poly_seat(vec2 uv, float a, float b, float n)\n{\n    float epsilon = 0.00001;\n    float min_param_a = 0.0 + epsilon;\n    float max_param_a = 1.0 - epsilon;\n    float min_param_b = 0.0;\n    float max_param_b = 1.0;\n    a = min(max_param_a, max(min_param_a, a));  \n    b = min(max_param_b, max(min_param_b, b)); \n\n    float p = 2.0*n + 1.0;\n    float y = 0.0;\n    if (uv.x <= a){\n        y = b - b*pow(1.0-uv.x/a, p);\n    } else {\n        y = b + (1.0-b)*pow((uv.x-a)/(1.0-a), p);\n    }\n    return y;\n}\n\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    //float y = ;\n\n    //vec3 color = vec3(y);\n    //float pct = plot(uv, y);\n    //color = (1.0 - pct) * color + pct * vec3(0.0,1.0,0.0);\n    vec3 color =\n        plot(uv, double_cubic_seat(uv, m.x, m.y)) * vec3(1.0, 0.0, 0.0) + \n        plot(uv, double_cubic_seat_linear_blend(uv, m.x, m.y)) * vec3(0.0, 1.0, 0.0) +\n\t\tplot(uv, double_odd_poly_seat(uv, m.x, m.y, clamp(1.0, 20.0, 20.0*sin(PI * iTime / 2.0)))) * vec3(0.0, 0.0, 1.0);\n        \n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2fDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 128, 128, 282], [284, 284, 349, 349, 558], [561, 561, 625, 625, 1077], [1080, 1080, 1111, 1111, 1202], [1205, 1205, 1262, 1262, 1825]], "test": "untested"}
{"id": "ttlcD4", "name": "photo sim api", "author": "way2sky", "description": "filter depth texture as linear, and everything else as nearest", "tags": ["test"], "likes": 0, "viewed": 365, "published": 3, "date": "1592138145", "time_retrieved": "2024-07-30T21:01:14.558868", "image_code": "// image pass code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = texture(iChannel1,fragCoord/iResolution.xy).rgb;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// common code", "buffer_a_code": "// buf a code\nvoid mainImage( out vec4 O, vec2 U )\n{\n    // initialize\n    { O=vec4(0.); return; }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// buf b code\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(0.);\n}", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// buf c code\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = texture(iChannel2, U/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 76, 76, 147]], "test": "untested"}
{"id": "wlsyD4", "name": "math - simple round square ", "author": "catafest", "description": "a simple round square build using the math function sqrt;", "tags": ["example", "simple", "math", "round", "square"], "likes": 2, "viewed": 721, "published": 3, "date": "1592137723", "time_retrieved": "2024-07-30T21:01:15.312852", "image_code": "// create a function for round square \nvec3 round_square( vec2 uv )\n{\n  // Set the size of the square, can be changed .01 6.\n  float square_dimension = 6.;\n    \n  // Create math function for round sqare shape  \n  float my_square = sqrt(length(pow(uv-vec2(.0,.0),vec2(square_dimension))))-.1;\n    \n  //Set default poz \n  vec3 poz = vec3(1.,1.,1.);\n    \n  // Return the result \n  return mix(vec3(0.1),poz*poz, smoothstep(0.,.001,my_square));\n}\n\n// Set color for the round square\nvec3 color = vec3(.1, 76., 76.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Set color 0,0,0,0\n    fragColor = vec4(0);\n    // u=Use for to build with round_square\n    for (int i = 0; i < 10+int(min(0,iFrame)); i++) {\n        // Set UV2 from basic UV\n        vec2 uv2 = uv + 1. / iResolution.y * 1.25;\n        // Create the round square\n        fragColor += vec4(round_square(uv2) + color.xyz , 1.);\n    }\n    // show the square\n\tfragColor.xyz = (fragColor.xyz/fragColor.w);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 69, 124, 441], [511, 511, 568, 618, 1084]], "test": "untested"}
{"id": "WtfcWN", "name": "traffic master game", "author": "FabriceNeyret2", "description": "Score increases when vehicle reach the other side,\nand decreases in case of collision.\nYour only control: click on a vehicle to stop/restart it.\n\ndebug mod: uncomment /** in Image -> /**/", "tags": ["game", "short"], "likes": 6, "viewed": 510, "published": 3, "date": "1592137215", "time_retrieved": "2024-07-30T21:01:16.134654", "image_code": "// Fork of \"traffic master game\" by FabriceNeyret2. https://shadertoy.com/view/WtfcWN\n\n// === draw vehicles ==============================\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    N(U);                                               // d,N = closest vehicle\n    O = vec4(max(0.,S-d));                            // draw disc\n      N.z>0. ?  O.gb = U-U, O.r *= 1.-N.z/3e2           // collided vehicle\n    : N.z<0. ?  O.rb = U-U, d : d;\n    U.y<3. ? v = 3.*T(8).w, d = U.x-R.x/2.,             // draw score\n             O.rg += vec2( d<0. && v<d, d>0. && v>d) :U;// red if -, green if +\n\n/**\n    U/=S+S; if (U.x < 4. && U.y < 6.) {                 // --- debug: show vehicle states\n        W = T(U);\n        vec2 V =  R/2. - abs(W.xy - R/2.); \n        O.b += min(V.x,V.y)>0. ? .7 : .3; // blue cell: out of screen\n#define sig(v,d) O += vec4(-v,v,v==0.,0) * 2.*S* max(0.,.2 - length(fract(U-d)-.5))\n        sig(W.z,-.2);              // B.L.: red: collision  green: touch border\n        sig(W.w,.2);               // T.R.: red: dead  green: moving  blue: frozen  \n        V = W.xy; N(iMouse.zw); if (d<S+S && V==N.xy) O.r+=.4;\n        if (V==R+R) O.g += .4;     // green cell: stuck dead collided \n        if (V==-R)  O.r += .4;     // red cell:   stuck dead out \n    }\n/**/\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === simulates the vehicles ====================\n// grid 4x6. rows = direction > , < , ^ , v \n//           O.xy : vehicle position   \n//           O.z  : <0: touch border      >0 collision (timeout)\n//           O.w  : 1: moving  0: frozen  <0: dead (timeout)\n//  (8,8):   z: mouse.z  w: score\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = iFrame > 0 ? T(U) : vec4(-R,0,-.5);             // recover current state or trigger init                                 \n    if (U==vec2(8.5)) {    \n        O.z = iMouse.z;                                 // store mouse.z (to test release)\n        L                                               // browse the 4x6 list   \n            if (W.z<0.) W.z /= 20.; // why ? \n            abs(W.z)<=1. ? O.w -= W.z :d;               // update score with + and - marks\n    }     }\n    if ( U.x>4. && U.y > 6. ) return;                   // no vehicle cell: abort.\n    float h = fract(sin(dot(U, vec2(13,78))-iTime) *4e5), // hash\n          a = U.x < 2. ? 1. :3.,                        // mvt axis: 1 = horiz,    3 = vertical\n          s = .5 + a - U.x;                             // mvt side: 1 = left/bot, 0 = right/up\n    T(8).z<=0. && length(iMouse.zw-O.xy) < 1.3*S ? O.w = 1.-O.w :d;// stop/restart on mouse click\n    if (O.z==0.)                                        // not already collided\n      { N(O.xy); d<S+S ? O.z++, O.w = 0. :d; }          // if collision, mark & freeze\n    else if( ++O.z > 3e2 ) O = vec4(R+R,0,-h*2e2);      // timeout then recycle\n    if ( O.w > 0. ) {                                   // --- active vehicle \n        O[ a<  2. ?0 :1 ] += sign(U.x-a)*S*.1;               // move position \n        vec2 V =  R/2. + (2.*s-1.)*(O.xy - R/2.);       // distance to window border\n        d = min(V.x,V.y);\n        d < 0. ?  O.xy=-R, O.z=0., O.w = -h*2e2 : d < S ? O.z-- : d;// getting out: score, then recycle after random timeout\n    } else if ( O.w < 0.                                // if not frozen\n                && U.x+4.*U.y-4. < .1*iTime             // number of vehicles increase with time\n                && ++O.w >= 0.) do {                    // --- start new vehicle once dead state ended\n        vec4 P = .5+ vec4( ceil(S*10.+(R-S*20.)*(s*1.1+h*.9)/2.), R*s ); // prep border & position on it\n        O = vec4( a<2. ? P.zy : P.xw , 0,1 );           // choose start position according to direction\n        N(O.xy); h+=2.*S/(R.x-2e2);\n    } while(d<25.);                                     // avoid start collided\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define S    (10.*R.y/360.)                        // vehicle radius\n\n#define R    iResolution.xy\n#define T(U) texelFetch(iChannel0,ivec2(U),0)\n\nfloat d,v;   vec4 N,W;\n#define L    for( int k = 0; k < 24; k++ ) {       /* browse the 4x6 list of vehicles */\\\n                 W = T(vec2(k%4,k/4));             // current vehicle in list\n\n#define N(U) /* --- get d,N = vehicle closest to U (but itself, if is a vehicle)      */\\\n    d = 1e5;                                                                            \\\n    L   v = length(U-W.xy),                        /* browse the 4x6 list of vehicles */\\\n        W.w >= 0. && v > 0. && v<d ? d=v, N=W : N; /* find the closest active vehicle */\\\n     }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 178, 178, 1276]], "test": "untested"}
{"id": "3llcDN", "name": "Two tone sound", "author": "qwert33", "description": "blah", "tags": ["oscilloscope", "sound"], "likes": 5, "viewed": 423, "published": 3, "date": "1592124575", "time_retrieved": "2024-07-30T21:01:16.965937", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XsjSzc\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat ssdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2  pa = p - a;\n\tvec2  ba = b - a;\n    float bam = dot(ba,ba);\n    if( bam>0.1 ) return 10.0;\n\tfloat h = clamp( dot(pa,ba)/bam, 0.0, 1.0 );\n\t\n\treturn length2( pa - ba*h );\n}\n\nconst float freq = 44.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    float f = 1.5;\n    float ox = 0.0;\n    float oy = 0.0;\n    \n   \n        \n    for( int i=0; i<1024; i++ )\n    {\n        float h = float(i)/1024.0;\n    \n        \n        float tt = floor(iTime*freq)/freq;\n        float t = tt + h/freq;\n        //t -= fract(iTime / 44.);\n    \n        //----------------        \n        vec2 sound = mainSound(0, t);\n        sound.x = 4.*(h-.5); \n        sound.y *= 3.;\n        //----------------        \n        \n        \n        if( i>0 ) \n        {\n            float dis = ssdSegment( p, sound, vec2(ox,oy) );\n            f += exp( -5000.0*dis )*1.00 + \n                 exp( - 100.0*dis )*0.04;\n        }\n        ox = sound.x;\n        oy = sound.y;\n    }    \n    \n    float h = clamp( f*0.05, 0.0, 1.0 );\n    vec3 col = vec3( h*h, h, h*h*h )*3.0;\n   \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    float grid = 1.0;\n    grid *= 1.0-smoothstep( 0.98, 0.99, 2.0*abs(fract( q.x*10.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.96, 0.98, 2.0*abs(fract( q.y*6.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.90, 0.92, 2.0*abs(fract( q.x*50.0 )-0.5) )*\n                smoothstep( 0.84, 0.85, 2.0*abs(fract( q.y* 6.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.91, 0.92, 2.0*abs(fract( q.y*30.0 )-0.5) )*\n                smoothstep( 0.85, 0.86, 2.0*abs(fract( q.x*10.0 )-0.5) );\n    col *= 0.5 + 0.5*grid;\n  \n    col += 0.06*smoothstep(0.2,0.7,q.y);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "#define PI 3.1415926535897932384626433832795\n#define TAU 2.*PI\n\nvec2 mainSound( in int samp,float t){\n\tfloat f1 = 440.;\n\tfloat f2 = 881.;\n    \n    \n    float m = 1.0;\n    #define ADDITIVE false\n    if (ADDITIVE) {\n        f1 += m;\n        f2 += m;\n    } else {\n        f1 *= m;\n        f2 *= m;\n    }\n\n    \n    \n    float tone1 = sin(f1*TAU*t);\n    float tone2 = sin(f2*TAU*t);\n    \n    return (tone1 + tone2) * vec2(1,1) * 0.1;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcDN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[166, 166, 194, 194, 213], [215, 215, 268, 268, 445], [474, 474, 531, 531, 2060]], "test": "untested"}
{"id": "WlsyW4", "name": "BoS - Dawn to Dusk Transition", "author": "zeta", "description": "Hi there! I'm learning shaders, feedback is always welcome!\n\nhttps://thebookofshaders.com/06/\nExercise: animate a transition between a sunrise and sunset using u_time.", "tags": ["bookofshaders"], "likes": 3, "viewed": 399, "published": 3, "date": "1592101306", "time_retrieved": "2024-07-30T21:01:17.720918", "image_code": "const float TIME_SPEED = .2;\nconst float SUN_COLOR_SIZE = 3.;\n\nconst float PI = 3.14159265359;\n\nconst vec3[] sky = vec3[](\n    vec3(2., 28., 78.) / 255.,     // night\n    vec3(12., 228., 223.) / 255.   // day\n);\n\nconst vec3[] sun = vec3[](\n    vec3(255., 102., 0.) / 255.,   // dusk\n    vec3(255., 253., 195.) / 255.  // dawn\n);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = iTime * TIME_SPEED;\n    float sun_h = sin(time);\n    \n    vec3 sky_col = mix(sky[0], sky[1], smoothstep(-1., 1., sun_h));\n    vec3 sun_col = mix(sun[0], sun[1], smoothstep(-1., 1., sun_h));\n    \n    vec3 col;\n    if (uv.y < sun_h) {\n    \tcol = mix(sky_col, sun_col, smoothstep(sun_h-(SUN_COLOR_SIZE/2.), sun_h, uv.y));\n    } else {\n        col = mix(sun_col, sky_col, smoothstep(sun_h, sun_h+(SUN_COLOR_SIZE/2.), uv.y));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 386, 386, 909]], "test": "untested"}
{"id": "3tfcD8", "name": "anamorphic effects", "author": "TheNosiriN", "description": "I'm compiling different anamorohic post processing effects shaders I found all over shadertoy. With links to the makers.\nCurrent Status: I'm yet to find proper bloom.", "tags": ["flare", "chromaticabberation", "cinematic", "anamorphic"], "likes": 26, "viewed": 1832, "published": 3, "date": "1592098105", "time_retrieved": "2024-07-30T21:01:18.541724", "image_code": "float NoiseSeed;\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nfloat SCurve (float value, float amount, float correction) {\n\n\tfloat curve = 1.0; \n\n    if (value < 0.5)\n    {\n\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    }\n        \n    else\n    { \t\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    }\n\n    return pow(curve, correction);\n}\n\n\n\n\n//ACES tonemapping from: https://www.shadertoy.com/view/wl2SDt\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n\n\n//Chromatic Abberation from: https://www.shadertoy.com/view/XlKczz\nvec3 chromaticAbberation(sampler2D tex, vec2 uv, float amount)\n{\n    float aberrationAmount = amount/10.0;\n   \tvec2 distFromCenter = uv - 0.5;\n\n    // stronger aberration near the edges by raising to power 3\n    vec2 aberrated = aberrationAmount * pow(distFromCenter, vec2(3.0, 3.0));\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 1; i <= 8; i++)\n    {\n        float weight = 1.0 / pow(2.0, float(i));\n        color.r += texture(tex, uv - float(i) * aberrated).r * weight;\n        color.b += texture(tex, uv + float(i) * aberrated).b * weight;\n    }\n    \n    color.g = texture(tex, uv).g * 0.9961; // 0.9961 = weight(1)+weight(2)+...+weight(8);\n    \n    return color;\n}\n\n\n\n\n//film grain from: https://www.shadertoy.com/view/wl2SDt\nvec3 filmGrain()\n{\n    return vec3(0.9 + randomFloat()*0.15);\n}\n\n\n\n\n//Sigmoid Contrast from: https://www.shadertoy.com/view/MlXGRf\nvec3 contrast(vec3 color)\n{\n    return vec3(SCurve(color.r, 3.0, 1.0), \n                SCurve(color.g, 4.0, 0.7), \n                SCurve(color.b, 2.6, 0.6)\n               );\n}\n\n\n\n\n//anamorphic-ish flares from: https://www.shadertoy.com/view/MlsfRl\nvec3 flares(sampler2D tex, vec2 uv, float threshold, float intensity, float stretch, float brightness)\n{\n    threshold = 1.0 - threshold;\n    \n    vec3 hdr = texture(tex, uv).rgb;\n    hdr = vec3(floor(threshold+pow(hdr.r, 1.0)));\n    \n    float d = intensity; //200.;\n    float c = intensity*stretch; //100.;\n    \n    \n    //horizontal\n    for (float i=c; i>-1.0; i--)\n    {\n        float texL = texture(tex, uv+vec2(i/d, 0.0)).r;\n        float texR = texture(tex, uv-vec2(i/d, 0.0)).r;\n        hdr += floor(threshold+pow(max(texL,texR), 4.0))*(1.0-i/c);\n    }\n    \n    //vertical\n    for (float i=c/2.0; i>-1.0; i--)\n    {\n        float texU = texture(tex, uv+vec2(0.0, i/d)).r;\n        float texD = texture(tex, uv-vec2(0.0, i/d)).r;\n        hdr += floor(threshold+pow(max(texU,texD), 40.0))*(1.0-i/c) * 0.25;\n    }\n    \n    hdr *= vec3(0.5,0.4,1.0); //tint\n    \n\treturn hdr*brightness;\n}\n\n\n\n\n//glow from: https://www.shadertoy.com/view/XslGDr (unused but useful)\nvec3 samplef(vec2 tc, vec3 color)\n{\n\treturn pow(color, vec3(2.2, 2.2, 2.2));\n}\n\nvec3 highlights(vec3 pixel, float thres)\n{\n\tfloat val = (pixel.x + pixel.y + pixel.z) / 3.0;\n\treturn pixel * smoothstep(thres - 0.1, thres + 0.1, val);\n}\n\nvec3 hsample(vec3 color, vec2 tc)\n{\n\treturn highlights(samplef(tc, color), 0.6);\n}\n\nvec3 blur(vec3 col, vec2 tc, float offs)\n{\n\tvec4 xoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.x;\n\tvec4 yoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.y;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += hsample(col, tc + vec2(xoffs.x, yoffs.x)) * 0.00366;\n\tcolor += hsample(col, tc + vec2(xoffs.y, yoffs.x)) * 0.01465;\n\tcolor += hsample(col, tc + vec2(    0.0, yoffs.x)) * 0.02564;\n\tcolor += hsample(col, tc + vec2(xoffs.z, yoffs.x)) * 0.01465;\n\tcolor += hsample(col, tc + vec2(xoffs.w, yoffs.x)) * 0.00366;\n\t\n\tcolor += hsample(col, tc + vec2(xoffs.x, yoffs.y)) * 0.01465;\n\tcolor += hsample(col, tc + vec2(xoffs.y, yoffs.y)) * 0.05861;\n\tcolor += hsample(col, tc + vec2(    0.0, yoffs.y)) * 0.09524;\n\tcolor += hsample(col, tc + vec2(xoffs.z, yoffs.y)) * 0.05861;\n\tcolor += hsample(col, tc + vec2(xoffs.w, yoffs.y)) * 0.01465;\n\t\n\tcolor += hsample(col, tc + vec2(xoffs.x, 0.0)) * 0.02564;\n\tcolor += hsample(col, tc + vec2(xoffs.y, 0.0)) * 0.09524;\n\tcolor += hsample(col, tc + vec2(    0.0, 0.0)) * 0.15018;\n\tcolor += hsample(col, tc + vec2(xoffs.z, 0.0)) * 0.09524;\n\tcolor += hsample(col, tc + vec2(xoffs.w, 0.0)) * 0.02564;\n\t\n\tcolor += hsample(col, tc + vec2(xoffs.x, yoffs.z)) * 0.01465;\n\tcolor += hsample(col, tc + vec2(xoffs.y, yoffs.z)) * 0.05861;\n\tcolor += hsample(col, tc + vec2(    0.0, yoffs.z)) * 0.09524;\n\tcolor += hsample(col, tc + vec2(xoffs.z, yoffs.z)) * 0.05861;\n\tcolor += hsample(col, tc + vec2(xoffs.w, yoffs.z)) * 0.01465;\n\t\n\tcolor += hsample(col, tc + vec2(xoffs.x, yoffs.w)) * 0.00366;\n\tcolor += hsample(col, tc + vec2(xoffs.y, yoffs.w)) * 0.01465;\n\tcolor += hsample(col, tc + vec2(    0.0, yoffs.w)) * 0.02564;\n\tcolor += hsample(col, tc + vec2(xoffs.z, yoffs.w)) * 0.01465;\n\tcolor += hsample(col, tc + vec2(xoffs.w, yoffs.w)) * 0.00366;\n\n\treturn color;\n}\n\nvec3 glow(vec3 col, vec2 uv)\n{\n    vec3 color = blur(col, uv, 2.0);\n\tcolor += blur(col, uv, 3.0);\n\tcolor += blur(col, uv, 5.0);\n\tcolor += blur(col, uv, 7.0);\n\tcolor /= 4.0;\n\t\n\tcolor += samplef(uv, col);\n    \n    return color;\n}\n\n\n\n\n//margins from: https://www.shadertoy.com/view/wl2SDt\nvec3 margins(vec3 color, vec2 uv, float marginSize)\n{\n    if(uv.y < marginSize || uv.y > 1.0-marginSize)\n    {\n        return vec3(0.0);\n    }else{\n        return color;\n    }\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).xyz;\n    \n    \n    //chromatic abberation\n    color = chromaticAbberation(iChannel0, uv, 0.8);\n    \n    \n    //film grain\n    color *= filmGrain();\n    \n    \n    //ACES Tonemapping\n  \tcolor = ACESFilm(color);\n    \n    \n    //contrast\n    color = contrast(color) * 0.9;\n    \n    \n    //flare\n    color += flares(iChannel0, uv, 0.9, 200.0, 0.5, 0.06);\n    \n    \n    //margins\n    color = margins(color, uv, 0.1);\n    \n    \n    //output\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 37, 37, 116], [118, 118, 178, 178, 438], [443, 506, 529, 529, 669], [674, 741, 805, 805, 1419], [1424, 1481, 1499, 1499, 1544], [1549, 1612, 1639, 1639, 1789], [1794, 1862, 1966, 1966, 2752], [2757, 2828, 2863, 2863, 2906], [2908, 2908, 2950, 2950, 3061], [3063, 3063, 3098, 3098, 3145], [3147, 3147, 3189, 3189, 4937], [4939, 4939, 4969, 4969, 5166], [5171, 5225, 5278, 5278, 5402], [5407, 5407, 5464, 5464, 6027]], "test": "untested"}
{"id": "WtscW4", "name": "@Party Concert Visuals 2020", "author": "blackle", "description": "visuals for the concert at @party online 2020, programmed in about 1 hour", "tags": ["raymarching", "4d", "lasers"], "likes": 146, "viewed": 8013, "published": 3, "date": "1592097490", "time_retrieved": "2024-07-30T21:01:19.395441", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat comp (vec3 p) {\n    p = asin(sin(p)*.9);\n    return length(p)-1.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec4 wrot(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.zwy - p.wyz - p.xxx)/2.;\n}\n\nfloat d1, d2, d3;\nfloat t;\nfloat lazors, doodad;\nvec3 p2;\nfloat bpm = 125.;\nfloat scene(vec3 p) {\n    p2 = erot(p, vec3(0,1,0), t);\n    p2 = erot(p2, vec3(0,0,1), t/3.);\n    p2 = erot(p2, vec3(1,0,0), t/5.);\n    \n    float bpt = iTime/60.*bpm;\n        vec4 p4 = vec4(p2,0);\n        p4=mix(p4,wrot(p4),smoothstep(-.5,.5,sin(bpt/4.)));\n        p4 =abs(p4);\n        p4=mix(p4,wrot(p4),smoothstep(-.5,.5,sin(bpt)));\n    float fctr = smoothstep(-.5,.5,sin(bpt/2.));\n    float fctr2 = smoothstep(.9,1.,sin(bpt/16.));\n        doodad = length(max(abs(p4)-mix(0.05,0.07,fctr),0.)+mix(-0.1,.2,fctr))-mix(.15,.55,fctr*fctr)+fctr2;\n    /*\n        vec4 p4 = vec4(p2,0);\n        p4=wrot(p4);\n        p4 = abs(p4);\n        p4=mix(p4,wrot(p4),smoothstep(-.5,.5,sin(t)));\n        doodad = length(max(abs(p4)-0.07,0)+0.2)-.55;\n    }*/\n    \n    p.x += asin(sin(t/80.)*.99)*80.;\n    \n    lazors = length(asin(sin(erot(p,vec3(1,0,0),t*.2).yz*.5+1.))/.5)-.1;\n    d1 = comp(p);\n    d2 = comp(erot(p+5., normalize(vec3(1,3,4)),0.4));\n    d3 = comp(erot(p+10., normalize(vec3(3,2,1)),1.));\n    return min(doodad,min(lazors,.3-smin(smin(d1,d2,0.05),d3,0.05)));\n}\n\nvec3 norm(vec3 p) {\n    float precis = length(p) < 1. ? 0.005 : 0.01;\n    mat3 k = mat3(p,p,p)-mat3(precis);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float bpt = iTime/60.*bpm;\n    float bp = mix(pow(sin(fract(bpt)*3.14/2.),20.)+floor(bpt), bpt,0.4);\n    t = bp;\n\tvec3 cam = normalize(vec3(.8+sin(bp*3.14/4.)*.3,uv));\n    vec3 init = vec3(-1.5+sin(bp*3.14)*.2,0,0)+cam*.2;\n    init = erot(init,vec3(0,1,0),sin(bp*.2)*.4);\n    init = erot(init,vec3(0,0,1),cos(bp*.2)*.4);\n    cam = erot(cam,vec3(0,1,0),sin(bp*.2)*.4);\n    cam = erot(cam,vec3(0,0,1),cos(bp*.2)*.4);\n    vec3 p = init;\n    bool hit = false;\n    float atten = 1.;\n    float tlen = 0.;\n    float glo = 0.;\n    float dist;\n    float fog = 0.;\n    float dlglo = 0.;\n    bool trg = false;\n    for (int i = 0; i <80 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        glo += .2/(1.+lazors*lazors*20.)*atten;\n        dlglo += .2/(1.+doodad*doodad*20.)*atten;\n        if (hit && ((sin(d3*45.)<-0.4 && (dist!=doodad )) || (dist==doodad && sin(pow(length(p2*p2*p2),.3)*120.)>.4 )) && dist != lazors) {\n            trg = trg || dist==doodad;\n            hit = false;\n            vec3 n = norm(p);\n            atten *= 1.-abs(dot(cam,n))*.98;\n            cam = reflect(cam,n);\n            dist = .1;\n        }\n        p += cam*dist;\n        tlen += dist;\n        fog += dist*atten/30.;\n    }\n    fog = smoothstep(0.,1.,fog);\n    bool lz = lazors == dist;\n    bool dl = doodad == dist;\n    vec3 fogcol = mix(vec3(0.5,0.8,1.2), vec3(0.4,0.6,0.9), length(uv));\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.3,0.3,scene(p+vec3(.3)))+.5;\n    float fact = length(sin(r*(dl?4.:3.))*.5+.5)/sqrt(3.)*.7+.3;\n    vec3 matcol = mix(vec3(0.9,0.4,0.3), vec3(0.3,0.4,0.8), smoothstep(-1.,1.,sin(d1*5.+iTime*2.)));\n    matcol = mix(matcol, vec3(0.5,0.4,1.0), smoothstep(0.,1.,sin(d2*5.+iTime*2.)));\n    if (dl) matcol = mix(vec3(1),matcol,0.1)*.2+0.1;\n    vec3 col = matcol*fact*ss + pow(fact,10.);\n    if (lz) col = vec3(4);\n    fragColor.xyz = col*atten + glo*glo + fogcol*glo;\n    \n    fragColor.xyz = mix(fragColor.xyz, fogcol, fog);\n    if(!dl)fragColor.xyz = abs(erot(fragColor.xyz, normalize(sin(p*2.)),0.2*(1.-fog)));\n    if(!trg&&!dl)fragColor.xyz+=dlglo*dlglo*.1*vec3(0.4,0.6,0.9);\n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.xyz = smoothstep(vec3(0),vec3(1.2),fragColor.xyz);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscW4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 215, 215, 267], [269, 269, 307, 307, 369], [371, 371, 410, 410, 480], [482, 482, 501, 501, 570], [648, 648, 669, 669, 1708], [1710, 1710, 1729, 1729, 1894], [1896, 1896, 1953, 1953, 4266]], "test": "untested"}
{"id": "3llcW4", "name": "Fractal foliage", "author": "jarble", "description": "There are infinitely many leaves and trees in this forest, generated by a simple recursive function.", "tags": ["raymarching", "fractal", "leaf"], "likes": 4, "viewed": 444, "published": 3, "date": "1592095362", "time_retrieved": "2024-07-30T21:01:20.328945", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define image_scale 1.0\n\nconst int MAX_MARCHING_STEPS = 250;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nfloat planet_surface(vec3 p){\n    \n    vec3 p1 = p/size;\n    p = vec3(sin(p1.x+sin(p1.y)),cos(p1.y+sin(p1.z)),sin(p1.z+sin(p1.x)))*size;\n    return length(p) - size+10.0;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)*image_scale/2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 dmap = depth_map(fragCoord);\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = length(dmap.xyz-eye);\n    \n    l0 = min(l0,pow(l0, .75));\n    //if(abs(sceneSDF(dmap.xyz) - sceneSDF(eye+l0*worldDir)) > .25 || sceneSDF(eye+l0*worldDir) < EPSILON){\n        //l0 = (log(1.0+l0)+1.0)*2.0;\n        //l0 /= 2.0;\n    //}\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n\n    //float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 86, 86, 190], [195, 616, 707, 707, 1070], [1085, 1339, 1404, 1404, 1536], [1538, 1627, 1656, 1656, 1966], [1968, 2460, 2600, 2600, 3210], [3212, 3582, 3667, 3667, 4439], [4441, 4768, 4817, 4852, 4983], [4985, 4985, 5012, 5012, 5161], [5163, 5163, 5220, 5220, 5979]], "test": "untested"}
{"id": "3tsyW4", "name": "PowerBrot Zoom", "author": "eiffie", "description": "SuperFractalThingy Math for higher power brots. I was working my way towards a 3d mandelbulb zoom but triplex math isn't an algebra so I'm not sure if you can separate Z and deltaZ.", "tags": ["sft"], "likes": 4, "viewed": 336, "published": 3, "date": "1592092713", "time_retrieved": "2024-07-30T21:01:21.088913", "image_code": "//Power Brot Zoom by eiffie (SuperFractalThingy Math for higher powers, delta not approx)\n//#define PWR 3\n#define PWR 4\n//#define PWR 5\n\n#define rez iResolution.xy\n\nvec2 cpwr(vec2 C, float pwr){\n  float a=atan(C.y,C.x)*pwr;\n  return pow(length(C),pwr)*vec2(cos(a),sin(a));\n}\nvec2 cmul(vec2 A, vec2 B){return vec2(A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x);}\n\nfloat tym,scale,yFlip;\nfloat mndfk(vec2 dZ){\n  dZ*=scale;\n#if(PWR==3)\n  vec2 Z=vec2(-.5448069,.27999981*yFlip);\n#elif(PWR==4)\n  vec2 Z=vec2(-.7194003,.27*yFlip);\n#elif(PWR==5)\n  vec2 Z=vec2(-.755805,.2*yFlip);\n#endif\n  vec2 dC=dZ,C=Z;\n  float iters=32.+tym*8.;\n  float i=0.;\n  for(i=0.;i<iters;i+=1.){\n#if(PWR==3)\n    dZ=3.*cmul(cpwr(Z,2.),dZ)+3.*cmul(Z,cpwr(dZ,2.))+cpwr(dZ,3.)+dC;\n    Z=cpwr(Z,3.)+C;\n#elif(PWR==4)\n    dZ=4.*cmul(cpwr(Z,3.),dZ)+6.*cpwr(cmul(Z,dZ),2.)+4.*cmul(Z,cpwr(dZ,3.))+cpwr(dZ,4.)+dC;\n    Z=cpwr(Z,4.)+C;\n#elif(PWR==5)\n    dZ=5.*cmul(cpwr(Z,4.),dZ)+10.*cmul(cpwr(Z,3.),cpwr(dZ,2.))+10.*cmul(cpwr(Z,2.),cpwr(dZ,3.))+5.*cmul(Z,cpwr(dZ,4.))+cpwr(dZ,5.)+dC;\n    Z=cpwr(Z,5.)+C;\n#endif\n    if(dot(dZ,dZ)>40.)break;\n  }\n  return ((iters-i)+log2(log2(dot(dZ,dZ))/log2(40.00))/log2(float(PWR)))/iters;\n}\nvoid mainImage(out vec4 O,in vec2 U){\n  vec2 uv=(2.0*U-rez)/rez.x;\n  tym=mod(iTime,110.)-55.;\n  yFlip=sign(tym);\n  tym=55.-abs(tym);\n  scale=exp(-tym*.5);\n  float a=mndfk(uv);\n  O=vec4(a,a,a,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 194, 194, 274], [275, 275, 301, 301, 347], [372, 372, 393, 393, 1168], [1169, 1169, 1206, 1206, 1367]], "test": "untested"}
{"id": "WllyW4", "name": "Honeycomb Tunnels", "author": "jarble", "description": "These tunnels go on forever!", "tags": ["3d", "raymarching", "fractal", "beehive"], "likes": 9, "viewed": 393, "published": 3, "date": "1592092279", "time_retrieved": "2024-07-30T21:01:21.842897", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/4.0;\n    return vec3(color1*3.0,color1*2.0,0.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = (sin(p1)+cos(p1.yzx))*size;\n    return length(p) - size+10.0;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 3; k++){\n    \tresult = max(result, planet_surface(p*i)/(i));\n        i *= 10.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 200], [202, 623, 714, 714, 1026], [1041, 1295, 1360, 1360, 1492], [1494, 1583, 1612, 1612, 1922], [1924, 2416, 2556, 2556, 3166], [3168, 3538, 3623, 3623, 4395], [4397, 4724, 4773, 4808, 4939], [4941, 4941, 4998, 4998, 6146]], "test": "untested"}
{"id": "wtXyWN", "name": "MX Space Jelly", "author": "xjorma", "description": "Visually insired by Rhodium liquid carbon https://www.shadertoy.com/view/llK3Dy ", "tags": ["audioreactive", "jello"], "likes": 9, "viewed": 719, "published": 3, "date": "1592081108", "time_retrieved": "2024-07-30T21:01:22.606855", "image_code": "// Created by David Gallardo - xjorma/2020\n\n#define BIASED_NORMAL 0\n#define MAX_DIST 6.\n#define EXIT_DIST 3.\n#define LIGHT_DIR vec3(0.000000,0.943858,0.330350)\n\nfloat hig;\nfloat mid;\nfloat low;\n\nfloat saturate(in float v)\n{ \n    return clamp(v, 0.0, 1.0);\n}\n\n// rotation\nvec3 rotX(in vec3 p,float ang) \n{\n    mat3 m = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang),\t-sin(ang),\n\t\t\t0.0,\t\tsin(ang),\tcos(ang));\n\treturn m*p;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdfX1(in vec3 p)\n{\n    return opExtrussion(p, sd2dMX(p.xy), 0.5);\n\n}\n\nfloat map(vec3 p)\n{\t\n    p = rotX(p, sin(0.5 * p.x + iTime) * 0.9);\n    return sdfX1(p + vec3(0, 0, mid)) - .3 * noise(6. * p + 3. * iTime) * low;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\n\nfloat rayMarch(in vec3 ro,in vec3 rd, in float maxDist, in int maxStep, out float minDist) \n{\n    minDist = maxDist;\n    float t=0.;\n\tfor(int i=0; i < maxStep; i++) \n\t{\n\t\tfloat h = map(ro+rd*t);\n        minDist = min(h, minDist);\n        if(abs(h) < .001 || t > maxDist)\n            break;\n        t+=h;\n\t}\n    return t;\n}\n\n\n//\tmain function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    hig = texture(iChannel0, vec2(0.1,0.25)).x;\n    mid = texture(iChannel0, vec2(0.5,0.25)).x;\n    low = texture(iChannel0, vec2(0.9,0.25)).x;\n       \n    vec3 rd = normalize(vec3(2. * fragCoord - iResolution.xy, iResolution.y));\n    vec3 ro = vec3(0, 0, -3.);  \n    \n    vec3 oppositeNormal = vec3(0.);    \n    vec3 basecol = vec3(sin(iTime), sin(iTime * 1.5), sin(iTime * 2.2)) / 2. + 0.5;\n    vec3 color =vec3(0.);\n    float minDist = 0.;\n    float distIn = 0.;\n    float\tt = rayMarch(ro, rd, MAX_DIST, 50, minDist);\n    if(t < MAX_DIST)\n    {\n\t\tvec3\tp = ro + rd * t;\n\t\tvec3\tn = calcNormal(p);\n        // diffuse\n        color =  vec3(max(dot(LIGHT_DIR, n), 0.));\n        // specular\n    \tcolor += basecol * pow(max(dot(reflect(rd, n), LIGHT_DIR), 0.), 20.) * 0.5;\n        // Find the exit wound\n        vec3 refractDir = -refract(rd, n, 0.8);\n        vec3 oppositePos = p - refractDir * EXIT_DIST;\n        float dummyMinDist;\n        float reflectT = rayMarch(oppositePos, refractDir, EXIT_DIST, 20, dummyMinDist);\n        oppositeNormal = calcNormal(oppositePos + refractDir * reflectT);\n        distIn = EXIT_DIST - reflectT;\n\t}      \n\n    color += hig * basecol * pow(distIn * 2., 2.) * max(0.,(dot(oppositeNormal, rd)));\t\t// inner glow\n    float outer = max(1. - minDist, 0.);\n    outer = smoothstep(1., 0.7, outer) * outer;\n    color += basecol * pow(outer * 4. * low, 2.);\t\t\t\t// outer glow\n    color = pow(color, vec3(1. / 2.2));\n    fragColor = vec4(color, 1.);\n}\n\n\n\n", "image_inputs": [{"id": 23123, "src": "https://soundcloud.com/babelian/rob-hubbard-goldrunner-khatchadour-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "float opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Oriented Box\nfloat sdOBox(vec2 p, vec2 c, vec2 b, vec2 d)\n{\n    mat2\tr;\n    r[0]\t= d;\n   \tr[1]\t= vec2(-d.y, d.x);\n    vec2\tlp = (p - c) * r;\n    vec2\tq = abs(lp) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);  \n}\n\n// Axis Aligned Box\nfloat sdAABox(vec2 p, vec2 c, vec2 b)\n{ \n    vec2\tq = abs(p - c) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// Circle\nfloat sdCircle(vec2 p, vec2 c, float r)\n{\n    return\tlength(p - c) - r;\n}\n\nfloat sd2dM(vec2 p)\n{\n    float d0 = sdAABox(p, vec2(-1.5990, -0.2965), vec2(0.2900, 0.7035));\n    float d1 = sdAABox(p, vec2(-0.8555, -0.2965), vec2(0.2905, 0.7035));\n    float d2 = sdAABox(p, vec2(-0.1135, -0.2965), vec2(0.2905, 0.7035));\n    float cl = sdCircle(p, vec2(-1.3349, 0.4478), 0.5545);\n    float cr = sdCircle(p, vec2(-0.3787, 0.4478), 0.5565);\n    float cb = opUnion(cl, cr);\n    float dl = opUnion(d0, opUnion(d1, d2));\n    cb = opIntersection(cb, 0.2 - p.y);\n    float hl = sdCircle(p, vec2(-1.2275, 0.2000), 0.0815);\n    float hr = sdCircle(p, vec2(-0.4845, 0.2000), 0.0815);\n    float hb = opUnion(hl, hr);\n    return opSubtraction(hb, opUnion(dl, cb));    \n}\n\nfloat sd2dX(vec2 p)\n{\n    float dd = sdOBox(p, vec2(1.0765, -0.0245), vec2(1.2410, 0.2679), vec2(-0.4634, 0.8861));\n    float du = sdOBox(p, vec2(1.0535, -0.0245), vec2(1.2480, 0.2532), vec2(0.4776, 0.8786));\n    float dx = opUnion(dd, du);\n    return opIntersection(sdAABox(p, vec2(1.0620, -0.0245), vec2(0.8270, 0.9755)), dx);\n}\n\nfloat sd2dMX(vec2 p)\n{\n    return opUnion(sd2dM(p), sd2dX(p));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 223, 223, 257], [259, 271, 304, 304, 418], [420, 420, 443, 443, 482], [484, 484, 510, 510, 915], [917, 917, 976, 976, 1072], [1074, 1074, 1098, 1098, 1148], [1150, 1150, 1169, 1169, 1298], [1808, 1808, 1901, 1901, 2130], [2133, 2150, 2204, 2204, 3684]], "test": "untested"}
{"id": "tlfyWN", "name": "MX Psychedelic Lager", "author": "xjorma", "description": "What you drop some LSD into your beer?\nRendering Beer using beer lamber law.", "tags": ["reflection", "refraction", "lambert", "beer", "audioreactive"], "likes": 11, "viewed": 469, "published": 3, "date": "1592081082", "time_retrieved": "2024-07-30T21:01:23.365825", "image_code": "// Created by David Gallardo - xjorma/2020\n\n#define MAX_DIST\t\t5.\n#define PI              radians(180.)\n#define TAU             radians(360.)\n#define AA              0\n#define BIASED_NORMAL \t1\n#define MAX_BOUNCES     8\n\n#define BUBBLE1_BASE_SIZE\t0.005\n#define BUBBLE1_MUSIC_SIZE\t0.07\n#define BUBBLE2_BASE_SIZE\t0.008\n#define BUBBLE2_MUSIC_SIZE\t0.09\n\n#define ABSORB\t\t\tvec3(0., 0., 1.7)\n\n\nfloat low, mid, hig;\n\nmat3\tm0, m1;\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\n\nfloat sdSphere(in vec3 p, in float r)\n{\n  return length(p) - r;\n}\n\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat sdfX1(in vec3 p)\n{\n    return opExtrussion(p, sd2dMX(p.xy), 0.5);\n\n}\n\nvec3 repeat(in vec3 p, in vec3 v, out vec3 fl)\n{\n    fl = floor((p + v / 2.) / v );\n    return mod(p + v / 2., v) - v / 2.;\n}\n\nfloat rand(vec3 n)\n{ \n    return fract(sin(dot(n, vec3(12.9898, 4.1414,14.6313))) * 43758.5453);\n}\n\nfloat sdBubbles(in vec3 p)\n{\n    vec3 f0;\n    vec3 d0 = repeat(m0 * (p - vec3(0, iTime * 0.13, 0)), vec3(0.52, 0.45, 0.44), f0);\n    vec3 f1;\n    vec3 d1 = repeat(m0 * (p - vec3(0, iTime * 0.06, 0)), vec3(0.72, 0.61, 0.53), f1);\n\treturn smin(sdSphere(d0, (BUBBLE1_MUSIC_SIZE * hig + BUBBLE1_BASE_SIZE) * rand(f0)), \n\t\t\t\tsdSphere(d1, (BUBBLE2_MUSIC_SIZE * low + BUBBLE2_BASE_SIZE) * rand(f1)), 20.0);\n}\n\n\nfloat map(in vec3 p)\n{\n  float dX1 = sdfX1(p);\n  float dBB = sdBubbles(p);\n\n  return opSubtraction(dBB, dX1);\n}\n\nfloat vv(float x, float y)\n{\n \tfloat angle = atan(y, x);\n    float att = max( 0.0, 2.0 * mid -  length(vec2(x, y)));\n\treturn cos(7.*angle) * att;\t   \n}\n\nfloat flower(vec2 uv, vec2 f)\n{\n\tfloat x = (uv.x - sin( iTime * f.x));\n   \tfloat y = (uv.y - cos( iTime * f.y) / 4.);\n    //\n    float v = 0.;\n    v += vv(x, y);\n    v += vv(x + 2., y);\n    v += vv(x - 2., y);\n\treturn v;\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    //return texture(iChannel1, rd).rgb;\n    vec2 uv = vec2(atan(rd.z, rd.x) / PI , tan(rd.y) / 2.);\n    float p = 0.;\t\n\tp += flower(uv, vec2(0.03, 0.06));\n\tp += flower(uv, vec2(0.07, 0.01));\n\tp += flower(uv, vec2(0.08, 0.02));\n\tp += flower(uv, vec2(0.09, 0.04));\n    return vec3((cos(p*1.25 + 0.3566 + iTime) + 1.) / 2., (cos(p*2.2255 + 1.524 + iTime) + 1.) / 2., (cos(p*3.258 + 5.325 + iTime) + 1.) / 2.);\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 60; i++)\n  {\n    float h = sgn * map(ro + rd*t);\n    t += h;\n    if (h < 0.0002 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float sgn = 1.;\n    float cref = 0.7;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.9;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float t = rayMarch(sgn, ro, rd, 0.02);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * calcNormal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(1./2.2));\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 genMat(in vec3 dir,in vec3 up)\n{\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mid = texture(iChannel0, vec2(0.5,0.25)).x;\n    low = texture(iChannel0, vec2(0.9,0.25)).x;\n    hig = texture(iChannel0, vec2(0.1,0.25)).x;\n    \n    m0 = genMat(vec3(1,2,3), vec3(0,1,1));\n    m1 = genMat(vec3(2,1,4), vec3(1,1,0));\n    \n    vec3 tot = vec3(0.0);\n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(90. + iTime*12.);\n        float phi\t= radians(90.);\n        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        //float theta\t= radians(90.);\n        //float phi\t= radians(50.);\n        vec3 ro = 3.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [{"id": 23124, "src": "https://soundcloud.com/babelian/rob-hubbard-goldrunner-khatchadour-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "float opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Oriented Box\nfloat sdOBox(vec2 p, vec2 c, vec2 b, vec2 d)\n{\n    mat2\tr;\n    r[0]\t= d;\n   \tr[1]\t= vec2(-d.y, d.x);\n    vec2\tlp = (p - c) * r;\n    vec2\tq = abs(lp) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);  \n}\n\n// Axis Aligned Box\nfloat sdAABox(vec2 p, vec2 c, vec2 b)\n{ \n    vec2\tq = abs(p - c) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// Circle\nfloat sdCircle(vec2 p, vec2 c, float r)\n{\n    return\tlength(p - c) - r;\n}\n\nfloat sd2dM(vec2 p)\n{\n    float d0 = sdAABox(p, vec2(-1.5990, -0.2965), vec2(0.2900, 0.7035));\n    float d1 = sdAABox(p, vec2(-0.8555, -0.2965), vec2(0.2905, 0.7035));\n    float d2 = sdAABox(p, vec2(-0.1135, -0.2965), vec2(0.2905, 0.7035));\n    float cl = sdCircle(p, vec2(-1.3349, 0.4478), 0.5545);\n    float cr = sdCircle(p, vec2(-0.3787, 0.4478), 0.5565);\n    float cb = opUnion(cl, cr);\n    float dl = opUnion(d0, opUnion(d1, d2));\n    cb = opIntersection(cb, 0.2 - p.y);\n    float hl = sdCircle(p, vec2(-1.2275, 0.2000), 0.0815);\n    float hr = sdCircle(p, vec2(-0.4845, 0.2000), 0.0815);\n    float hb = opUnion(hl, hr);\n    return opSubtraction(hb, opUnion(dl, cb));    \n}\n\nfloat sd2dX(vec2 p)\n{\n    float dd = sdOBox(p, vec2(1.0765, -0.0245), vec2(1.2410, 0.2679), vec2(-0.4634, 0.8861));\n    float du = sdOBox(p, vec2(1.0535, -0.0245), vec2(1.2480, 0.2532), vec2(0.4776, 0.8786));\n    float dx = opUnion(dd, du);\n    return opIntersection(sdAABox(p, vec2(1.0620, -0.0245), vec2(0.8270, 0.9755)), dx);\n}\n\nfloat sd2dMX(vec2 p)\n{\n    return opUnion(sd2dM(p), sd2dX(p));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 421, 460, 460, 527], [530, 530, 569, 569, 595], [598, 598, 657, 657, 754], [756, 756, 780, 780, 830], [832, 832, 880, 880, 957], [959, 959, 979, 979, 1057], [1059, 1059, 1087, 1087, 1460], [1463, 1463, 1485, 1485, 1574], [1576, 1576, 1604, 1604, 1727], [1729, 1729, 1760, 1760, 1951], [1953, 1953, 1980, 2021, 2390], [2393, 2393, 2462, 2462, 2632], [3189, 3189, 3226, 3226, 4433], [4435, 4435, 4478, 4478, 4536], [4538, 4538, 4582, 4582, 4681], [4683, 4683, 4725, 4725, 4828], [4831, 4831, 4873, 4873, 5037], [5039, 5039, 5076, 5076, 5212]], "test": "untested"}
{"id": "ttfyD4", "name": "MX Onion", "author": "xjorma", "description": "Inspired by : https://www.instagram.com/p/B5DBbWtHXm1/ ", "tags": ["sdf", "audioreactive", "onion"], "likes": 3, "viewed": 381, "published": 3, "date": "1592081065", "time_retrieved": "2024-07-30T21:01:24.120807", "image_code": "#define STRIPE 50.\n#define AUDIOREACTONION\t\t0.3\n#define AUDIOREACTSPIRAL\t1.5 \n#define CONSTCOLOR 0\nconst\tvec3 col1 = vec3(255,  25, 128) / 255.;\nconst\tvec3 col2 = vec3(200, 255, 200) / 255.;\nconst\tbool spiralEnabled = true;\n\n\n#if HW_PERFORMANCE==0\n#define AA 0\n#else\n#define AA 1\n#endif\n\n#define BIASED_NORMAL 1\n\n\nfloat mid;\nfloat low;\n\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec2 minVecSelect(vec2 a, vec2 b)\n{\n    return a.y<b.y?a:b;\n}\n\nfloat triangle(float v)\n{\n    return -(abs((v - 4. * floor(0.25 * v)) - 2.) - 1.);\n}\n\n//---------------------------------\n\nvec2 map(in vec3 pos)\n{\n    float\tl;\n    vec3\tp;\n    p = vec3(sin(0.13 * iTime + 0.36), sin(0.07 * iTime + 1.25), sin(0.08 * iTime + 2.33));\n    l = length(p - pos) + low * AUDIOREACTONION;\n\tvec2\tv1 = vec2(triangle(l * STRIPE + iTime) / STRIPE, l);\n    p = vec3(sin(0.12 * iTime + 3.66), sin(0.08 * iTime + 4.36), sin(0.17 * iTime + 4.95));\n    l = length(p - pos) + low * AUDIOREACTONION;\n\tvec2\tv2 = vec2(triangle(l * STRIPE + iTime) / STRIPE, l); \n    p = vec3(sin(0.19 * iTime + 1.26), sin(0.09 * iTime + 3.33), sin(0.14 * iTime + 0.15));\n    l = length(p - pos) + low * AUDIOREACTONION;\n\tvec2\tv3 = vec2(triangle(l * STRIPE + iTime) / STRIPE, l);\n    vec2\tv = minVecSelect(v1, minVecSelect(v2, v3));\n    float d = opExtrussion( pos, sd2dMX(pos.xy), 1. );\n    float m = max(d, v.x);\n    return vec2(m,v.y);\n}\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.0001, 0);\n\tfloat d = map(pos).x;\n\treturn normalize(vec3(map(pos + eps.xyy).x - d, map(pos + eps.yxy).x - d, map(pos + eps.yyx).x - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\n// From IQ\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist,vec2 fracCoord)\n{\n    float t = 0.5;\n    float d;\n    float r = 1.;\n    for( int i=0; i<100; i++ )\n    {\n        vec3\tp = ro + t*rd;\n        float\th = map(p).x;\n        t += h;\n        d = dot(t*rd,cd);\n        if( abs(h) < 0.001 || d > dist )\n        {\n            r = float(i) / 100.;\n            break;\n        }\n    }\n\n    vec3 col = vec3(0.5);\n\n    if( d<dist )\n    {\n        vec3 light = vec3(0.,10.,2.);\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        #if CONSTCOLOR\n        vec3 c1 = col1;\n        vec3 c2 = col2;\n        #else\n        vec3 c1 = normalize(vec3(1. + sin(iTime * 0.7 + 1.3) / 2., 1. + sin(iTime * 0.8 + 4.45) / 2., 1. + sin(iTime * 0.5 + 2.3) / 2.));\n        vec3 c2 = normalize(vec3(1. + sin(iTime * 0.4 + 0.2) / 2., 1. + sin(iTime * 0.6 + 2.33) / 2., 1. + sin(iTime * 0.45 + 3.3) / 2.));\n        #endif\n        vec3 c = mix(c1, c2, step(0., triangle((map(p).y * STRIPE + iTime) / 2.)));\n        float ao = calcAO(p, n);\n        \n        vec3 v = normalize(ro-p);\n        vec3 l = normalize(light-p);\n        vec3 h = normalize(l+v);\n        \n        //vec3 diffcol = vec3(mix(saturate(pow(abs(sin(noise*16.))*1.5,15.)) ,1.,0.3)); \n        vec3 diffcol = c; \n        vec3 speccol = vec3(1.,1.,1.);\n        vec3 ambcol = diffcol;\n        \n        col = saturate(dot(n,l)) * diffcol;\n        col+= pow(saturate(dot(n,h)),20.) * speccol;\n        col+= 0.2 * ambcol;\n        col*= ao;\n        col*= (1. - r);\n\n    }\n    else\n    {\n        if(spiralEnabled)\n        {\n            float len = length(fracCoord);\n            float angle = atan(fracCoord.y, fracCoord.x);\n\n            float sinAngle = sin(angle + iTime) / 2. + 0.5;\n\n            float powLen = 1. / len;\n\n            float spiral = sin(powLen * 10.0  + angle * 3. - iTime * 4.0) / 2. + 0.5;\n\n            float value = (powLen - iTime) * 10.;\n            col\t= vec3(sin(0.13 * value + 0.36 + mid * AUDIOREACTSPIRAL), sin(0.11 * value + 1.25 + mid * AUDIOREACTSPIRAL), sin(0.08 * value + 2.33 + mid * AUDIOREACTSPIRAL)) / 2. + 0.5;\n            col *= mid * AUDIOREACTSPIRAL;\n            col = mix(vec3(0), col,smoothstep(0.4, 1., len)) * spiral;\n        }\n    }\n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Audio reactive   \n    mid = texture(iChannel0, vec2(0.5,0.25)).x;\n    low = texture(iChannel0, vec2(0.9,0.25)).x;\n    \n    float theta\t= radians(90.) + sin(iTime / 2.) * radians(20.);\n\tfloat phi\t= radians(80.) + sin(iTime / 3.) * radians(10.);\n\tvec3 ro = 3.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n     \n\tvec3 tot = vec3(0.0);    \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd , ca[2], 100., p);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n    tot = pow(tot, vec3(1./2.2));\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 23121, "src": "https://soundcloud.com/babelian/rob-hubbard-goldrunner-khatchadour-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "float opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Oriented Box\nfloat sdOBox(vec2 p, vec2 c, vec2 b, vec2 d)\n{\n    mat2\tr;\n    r[0]\t= d;\n   \tr[1]\t= vec2(-d.y, d.x);\n    vec2\tlp = (p - c) * r;\n    vec2\tq = abs(lp) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);  \n}\n\n// Axis Aligned Box\nfloat sdAABox(vec2 p, vec2 c, vec2 b)\n{ \n    vec2\tq = abs(p - c) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// Circle\nfloat sdCircle(vec2 p, vec2 c, float r)\n{\n    return\tlength(p - c) - r;\n}\n\nfloat sd2dM(vec2 p)\n{\n    float d0 = sdAABox(p, vec2(-1.5990, -0.2965), vec2(0.2900, 0.7035));\n    float d1 = sdAABox(p, vec2(-0.8555, -0.2965), vec2(0.2905, 0.7035));\n    float d2 = sdAABox(p, vec2(-0.1135, -0.2965), vec2(0.2905, 0.7035));\n    float cl = sdCircle(p, vec2(-1.3349, 0.4478), 0.5545);\n    float cr = sdCircle(p, vec2(-0.3787, 0.4478), 0.5565);\n    float cb = opUnion(cl, cr);\n    float dl = opUnion(d0, opUnion(d1, d2));\n    cb = opIntersection(cb, 0.2 - p.y);\n    float hl = sdCircle(p, vec2(-1.2275, 0.2000), 0.0815);\n    float hr = sdCircle(p, vec2(-0.4845, 0.2000), 0.0815);\n    float hb = opUnion(hl, hr);\n    return opSubtraction(hb, opUnion(dl, cb));    \n}\n\nfloat sd2dX(vec2 p)\n{\n    float dd = sdOBox(p, vec2(1.0765, -0.0245), vec2(1.2410, 0.2679), vec2(-0.4634, 0.8861));\n    float du = sdOBox(p, vec2(1.0535, -0.0245), vec2(1.2480, 0.2532), vec2(0.4776, 0.8786));\n    float dx = opUnion(dd, du);\n    return opIntersection(sdAABox(p, vec2(1.0620, -0.0245), vec2(0.8270, 0.9755)), dx);\n}\n\nfloat sd2dMX(vec2 p)\n{\n    return opUnion(sd2dM(p), sd2dX(p));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 363, 363, 392], [394, 394, 453, 453, 549], [551, 551, 586, 586, 612], [614, 614, 639, 639, 698], [737, 737, 760, 760, 1547], [2035, 2046, 2088, 2088, 2387], [2389, 2389, 2453, 2453, 4616], [4619, 4619, 4661, 4661, 4825], [4827, 4873, 4895, 4895, 5028], [5029, 5029, 5052, 5052, 5137], [5139, 5139, 5183, 5183, 5282], [5284, 5284, 5324, 5324, 5394]], "test": "untested"}
{"id": "tlXcWN", "name": "MX Metal Fuzion", "author": "xjorma", "description": "Metal Fuzion, kind of proud of the use of inverse distance weighting.", "tags": ["sdf", "meta", "audioreactive"], "likes": 4, "viewed": 416, "published": 3, "date": "1592081042", "time_retrieved": "2024-07-30T21:01:24.883767", "image_code": "// Created by David Gallardo - xjorma/2020\n\n#define COLOR_X\t\tvec3(255, 215,   0) / 255.;\n#define COLOR_1 \tvec3(184, 115,  51) / 255.;\n#define COLOR_SURF\tvec3(200, 200, 200) / 255.;\n\n\n#define\tAA 0\n#define BIASED_NORMAL 1\n#define EXTRUDE 0\n#define CUBEMAP 1\n#define GAMMA\t1\n\nmat3 m1;\nmat3 mX;\nvec3 p1;\nvec3 pX;\n\nfloat low;\nfloat mid;\n\n\nfloat sdWaterSurface(in vec3 p )\n{\n    float h = 0.;\n    h += cos( iTime * 5.0 - distance( vec2( -25, -10) , p.xz) * 3.0 )  * 0.15 * low;\n    h += cos( iTime * 5.0 - distance( vec2( 25, -10) , p.xz) * 3.8 ) * 0.06 * mid;\n    \n    return  p.y + 1. + h * max( 0.0, 1.0 -  length( p.xz) / 33. );\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdfX(in vec3 p)\n{\n    p = mX * (p + pX);\n    return opExtrussion(p, sd2dM(p.xy + vec2(-0.6415, 0.0000)), 0.5);\n\n}\n\nfloat sdf1(in vec3 p)\n{\n    p = m1 * (p + p1);\n    return opExtrussion(p, sd2dX(p.xy + vec2(1.4875, 0.0000)), 0.5);\n\n}\n\nconst float k = 8.;\n\nfloat sminAcc(in float v)\n{\n    return exp2(-k * v);\n}\n\nfloat sminFinal(in float v)\n{\n    return -log2(v) / k;\n}\n\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 0.; \n    d += sminAcc(sdfX(pos));\n    d += sminAcc(sdf1(pos));\n    d += sminAcc(sdWaterSurface(pos));\n    return sminFinal(d);\n}\n\n\nconst float IDWMin = 0.01;\n// https://en.wikipedia.org/wiki/Inverse_distance_weighting\nvec3 color(in vec3 pos)\n{\n    vec3 c0 = COLOR_X;\n    vec3 c1 = COLOR_1;\n    vec3 c2 = COLOR_SURF;\n    float d0 = 1. / max(sdfX(pos), IDWMin);\n    float d1 = 1. / max(sdf1(pos), IDWMin);\n    float d2 = 1. / max(sdWaterSurface(pos), IDWMin);    \n    return (c0 * d0 + c1 * d1  + c2 * d2) / ( d0 + d1 + d2);\n}\n\n\n#define EPS  0.01\n\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    vec2 eps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nfloat ambientOcclusion(in vec3 pos, in vec3 normal, in float scale )\n{\n    float d = map( pos + normal * scale );\n    return d / scale;\n    \n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float t = 0.5;\n    float d;\n    float noise = 0.;\n    for( int i=0; i<1024; i++ )\n    {\n        vec3\tp = ro + t*rd;\n        float\th = map(p);\n        d = dot(t*rd,cd);\n        if( abs(h)<0.0001 || d>dist ) break;\n        t += 0.8 * h;\n    }\n\n    vec3 col = vec3(0.5);\n\n    if( d<dist )\n    {\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 dir = reflect( rd, n );\n        #if CUBEMAP\n        col = texture(iChannel0, dir).xyz;\n        #else\n        col = texture(iChannel0, (dir.xy / 2.) + 0.5).xyz;\n        #endif\n        #if GAMMA\n        \tcol = pow(col, vec3(2.2));\n       \t#endif\n        col = desaturate(col, 0.7);\n        col *= color(p); \n        //col *= ambientOcclusion(p, n, 0.1);\n    }\n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n    #if GAMMA\n\t\tcol = pow(col, vec3(1. / 2.2));\n    #endif\n    col = desaturate(col, -0.4);\n    col = vignette(col, q, 0.8);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set translation and rotation\n\n    m1 = fromEuler(vec3(sin(iTime * 1.2) * radians(20.), -0.2 * iTime, sin(iTime * 1.3) * radians(20.)));\n    mX = fromEuler(vec3(sin(iTime * 0.9) * radians(20.),  0.1 * iTime, sin(iTime * 0.8) * radians(20.)));\n    \n    float cx = cos(0.4 * iTime) * 2.5;\n    float cyX = cos(0.23 * iTime) * 0.8;\n    float cy1 = cos(0.29 * iTime) * 0.8;\n    pX = vec3(-cx,cyX,0);\n    p1 = vec3(cx,cy1,0);\n    \n    // Audio reactive\n    \n    mid = texture(iChannel1, vec2(0.5,0.25)).x;\n    low = texture(iChannel1, vec2(0.9,0.25)).x;\n    \n    float theta\t= radians(90.) + sin(iTime / 3.) * radians(20.);\n\tfloat phi\t= radians(50.) + sin(iTime / 4.) * radians(5.);\n\tvec3 ro = 4.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n     \n\tvec3 tot = vec3(0.0);    \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],100.);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23125, "src": "https://soundcloud.com/babelian/rob-hubbard-goldrunner-khatchadour-remix", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "float opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Oriented Box\nfloat sdOBox(vec2 p, vec2 c, vec2 b, vec2 d)\n{\n    mat2\tr;\n    r[0]\t= d;\n   \tr[1]\t= vec2(-d.y, d.x);\n    vec2\tlp = (p - c) * r;\n    vec2\tq = abs(lp) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);  \n}\n\n// Axis Aligned Box\nfloat sdAABox(vec2 p, vec2 c, vec2 b)\n{ \n    vec2\tq = abs(p - c) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// Circle\nfloat sdCircle(vec2 p, vec2 c, float r)\n{\n    return\tlength(p - c) - r;\n}\n\nfloat sd2dM(vec2 p)\n{\n    float d0 = sdAABox(p, vec2(-1.5990, -0.2965), vec2(0.2900, 0.7035));\n    float d1 = sdAABox(p, vec2(-0.8555, -0.2965), vec2(0.2905, 0.7035));\n    float d2 = sdAABox(p, vec2(-0.1135, -0.2965), vec2(0.2905, 0.7035));\n    float cl = sdCircle(p, vec2(-1.3349, 0.4478), 0.5545);\n    float cr = sdCircle(p, vec2(-0.3787, 0.4478), 0.5565);\n    float cb = opUnion(cl, cr);\n    float dl = opUnion(d0, opUnion(d1, d2));\n    cb = opIntersection(cb, 0.2 - p.y);\n    float hl = sdCircle(p, vec2(-1.2275, 0.2000), 0.0815);\n    float hr = sdCircle(p, vec2(-0.4845, 0.2000), 0.0815);\n    float hb = opUnion(hl, hr);\n    return opSubtraction(hb, opUnion(dl, cb));    \n}\n\nfloat sd2dX(vec2 p)\n{\n    float dd = sdOBox(p, vec2(1.0765, -0.0245), vec2(1.2410, 0.2679), vec2(-0.4634, 0.8861));\n    float du = sdOBox(p, vec2(1.0535, -0.0245), vec2(1.2480, 0.2532), vec2(0.4776, 0.8786));\n    float dx = opUnion(dd, du);\n    return opIntersection(sdAABox(p, vec2(1.0620, -0.0245), vec2(0.8270, 0.9755)), dx);\n}\n\nfloat sd2dMX(vec2 p)\n{\n    return opUnion(sd2dM(p), sd2dX(p));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 368, 368, 628], [630, 630, 689, 689, 785], [787, 787, 810, 810, 906], [908, 908, 931, 931, 1026], [1049, 1049, 1076, 1076, 1103], [1105, 1105, 1134, 1134, 1161], [1201, 1201, 1225, 1225, 1368], [1398, 1458, 1483, 1483, 1764], [2260, 2260, 2330, 2330, 2402], [2404, 2404, 2444, 2444, 2514], [2516, 2516, 2565, 2565, 3310], [3313, 3313, 3355, 3355, 3519], [3522, 3522, 3548, 3548, 3900], [3902, 3902, 3945, 3945, 4003], [4005, 4005, 4049, 4049, 4148], [4150, 4150, 4192, 4192, 4335]], "test": "untested"}
{"id": "ttXcD4", "name": "MX Icing", "author": "xjorma", "description": "Variation of my shader https://www.shadertoy.com/view/tltXDN", "tags": ["audioreactive", "icing"], "likes": 5, "viewed": 462, "published": 3, "date": "1592081025", "time_retrieved": "2024-07-30T21:01:25.643735", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#define AA 0\n#else\n#define AA 1\n#endif\n\n\nconst float\tlayerThickness\t\t= 0.05;\nconst int\tnbLayers \t\t\t= 8;\nconst vec3\tflowDir \t\t\t= vec3(0.3, -1, 0);\nconst vec3\tbackgroundColor\t\t= vec3( 60,  60,  60) / 255.;\nconst bool\tglowEnabled\t\t\t= true;\nconst float audioReactGlow\t\t= 10.;\nconst bool\tglowConstantColor\t= true;\nconst vec3\tglowColor\t\t\t= vec3( 27, 188, 232) / 255.;\n\nfloat mid;\nfloat low;\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdfX1(in vec3 p)\n{\n    return opExtrussion(p, sd2dMX(p.xy), 0.5);\n\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n\nvec2 minVecSelect(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nvec2 map(in vec3 p)\n{\n    float slide = iTime / 1.;\n    float fr = fract(slide);\n    int   fl = int(floor(slide));    \n    vec2  vd = vec2(100., -1.);\n    float cnoise = noise(p * 2.5 + iTime / 8.) / 3.;\n    for( int i = 0; i < nbLayers; i++)\n    {\n        float m = mod(float(i + fl), float(nbLayers));\n        float r = (0.01 + layerThickness * low) * (float(nbLayers-3) - m + ( 1. - fr));\n        //float d = sdTorus( p, vec2(1, r)) ;\n        float d = sdfX1(p) - r;\n        d = abs(d) - layerThickness / 2.;\n        float o =  - 4. * fract( (iTime + float(i)) / float(nbLayers));\n\t\td = max(d, 1.9 + dot(p, normalize(flowDir)) + o + cnoise);\n\t\tvd = minVecSelect(vec2(d, float(i)), vd);        \n    }   \n    return vd;\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy*h).x + \n                      k.yyx * map(p + k.yyx*h).x + \n                      k.yxy * map(p + k.yxy*h).x + \n                      k.xxx * map(p + k.xxx*h).x );\n}\n\n// From IQ\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/12.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return saturate(1.0 - 4. * occ);    \n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float t = 0.5;\n    float d;\n    float m = 0.;\n    float minDist = dist;\n    for( int i=0; i<1024; i++ )\n    {\n        vec3\tp = ro + t*rd;\n        vec2\th = map(p);\n        t += h.x*0.7;\n        d = dot(t*rd,cd);\n        m = h.y;\n        minDist = min(h.x, minDist);\n        if( abs(h.x)<0.0001 || d>dist )\n            break;\n    }\n\n    vec3 col = backgroundColor;\n\n    if( d<dist )\n    {\n        vec3 light = vec3(0.,4.,2.);\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 v = normalize(ro-p);\n        vec3 l = normalize(light-p);\n        vec3 h = normalize(l+v);\n        \n        vec3 diffcol = normalize(vec3(1. + sin(m * 0.7 + 1.3) / 2., 1. + sin(m * 1.3 + 4.45) / 2., 1. + sin(m * 1.9 + 2.3) / 2.)); \n        vec3 speccol = vec3(1.,1.,1.);\n        vec3 ambcol = diffcol;\n\t\tfloat ao = calcAO(p, n);\n        \n        col = saturate(dot(n,l)) * diffcol;\n        col+= pow(saturate(dot(n,h)),40.) * speccol * 0.5;\n        col+= 0.2 * ambcol;\n        col*= ao;\n    }\n    else\n    {\n        if(glowEnabled)\n        {\n            vec3 glowCol;\n            if(glowConstantColor)\n            {\n                glowCol = glowColor;\n            }\n            else\n            {\n            \tglowCol = vec3(sin(iTime), sin(iTime * 1.3 + 2.3), sin(iTime * 1.8 + 4.3)) / 2. + 0.5;\n            }\n            float outer = max(0.3 - minDist, 0.);\n            col += glowCol * pow(outer * audioReactGlow * low, 4.);\n        }\n    }\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Audio reactive   \n    mid = texture(iChannel0, vec2(0.5,0.25)).x;\n    low = texture(iChannel0, vec2(0.9,0.25)).x;\n    \n    float theta\t= radians(90.) + sin(iTime / 2.) * radians(20.);\n\tfloat phi\t= radians(80.) + sin(iTime / 3.) * radians(15.);\n\tvec3 ro = 3.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n     \n\tvec3 tot = vec3(0.0);    \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],100.);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n    tot = pow(tot, vec3(1./2.2));\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 23122, "src": "https://soundcloud.com/babelian/rob-hubbard-goldrunner-khatchadour-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "float opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Oriented Box\nfloat sdOBox(vec2 p, vec2 c, vec2 b, vec2 d)\n{\n    mat2\tr;\n    r[0]\t= d;\n   \tr[1]\t= vec2(-d.y, d.x);\n    vec2\tlp = (p - c) * r;\n    vec2\tq = abs(lp) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);  \n}\n\n// Axis Aligned Box\nfloat sdAABox(vec2 p, vec2 c, vec2 b)\n{ \n    vec2\tq = abs(p - c) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// Circle\nfloat sdCircle(vec2 p, vec2 c, float r)\n{\n    return\tlength(p - c) - r;\n}\n\nfloat sd2dM(vec2 p)\n{\n    float d0 = sdAABox(p, vec2(-1.5990, -0.2965), vec2(0.2900, 0.7035));\n    float d1 = sdAABox(p, vec2(-0.8555, -0.2965), vec2(0.2905, 0.7035));\n    float d2 = sdAABox(p, vec2(-0.1135, -0.2965), vec2(0.2905, 0.7035));\n    float cl = sdCircle(p, vec2(-1.3349, 0.4478), 0.5545);\n    float cr = sdCircle(p, vec2(-0.3787, 0.4478), 0.5565);\n    float cb = opUnion(cl, cr);\n    float dl = opUnion(d0, opUnion(d1, d2));\n    cb = opIntersection(cb, 0.2 - p.y);\n    return opUnion(dl, cb);    \n}\n\nfloat sd2dX(vec2 p)\n{\n    float dd = sdOBox(p, vec2(1.0765, -0.0245), vec2(1.2410, 0.2679), vec2(-0.4634, 0.8861));\n    float du = sdOBox(p, vec2(1.0535, -0.0245), vec2(1.2480, 0.2532), vec2(0.4776, 0.8786));\n    float dx = opUnion(dd, du);\n    return opIntersection(sdAABox(p, vec2(1.0620, -0.0245), vec2(0.8270, 0.9755)), dx);\n}\n\nfloat sd2dMX(vec2 p)\n{\n    return opUnion(sd2dM(p), sd2dX(p));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXcD4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[522, 522, 581, 581, 677], [679, 679, 703, 703, 753], [755, 755, 788, 788, 843], [846, 846, 871, 871, 900], [903, 903, 938, 938, 964], [966, 966, 989, 989, 1028], [1030, 1030, 1056, 1056, 1461], [2189, 2189, 2214, 2214, 2482], [2484, 2495, 2537, 2537, 2829], [2832, 2832, 2881, 2881, 4346], [4348, 4348, 4426, 4426, 4498], [4500, 4500, 4542, 4542, 4706], [4708, 4708, 4752, 4752, 4851], [4853, 4853, 4893, 4893, 4963]], "test": "untested"}
{"id": "tlXyD4", "name": "Chocolate candy web", "author": "jarble", "description": "This is a simple fractal formula, resembling a web made of chocolate candy.", "tags": ["3d", "raymarching", "fractal"], "likes": 3, "viewed": 300, "published": 3, "date": "1592079221", "time_retrieved": "2024-07-30T21:01:26.413676", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001; //increase epsilon with each step\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        vec3 s1 = surface_color(worldDir*10.0+iTime/10.0).yzx;\n        fragColor = vec4(s1, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float planet_size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    p += sin(p/10.0);\n    p = sin(p/planet_size)*planet_size;\n    return length(p) - planet_size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    float i = 1.0;\n    for(int k = 0; k < 3; k++){\n    \tresult = max(result, planet_surface(p*i)/(i));\n        i *= 5.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001; //increase epsilon with each step\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 481, 572, 572, 961], [975, 975, 1002, 1002, 1151], [1153, 1153, 1210, 1210, 2026]], "test": "untested"}
{"id": "WtXyW4", "name": "Alien Waterworld", "author": "mrange", "description": "License CC0: Alien Waterworld\n  Been working on space themed shaders\n  Code \"borrowed\" from the usual suspects\n", "tags": ["terrainscifi"], "likes": 38, "viewed": 1328, "published": 3, "date": "1592052399", "time_retrieved": "2024-07-30T21:01:27.191596", "image_code": "// License CC0: Alien Waterworld\n//  Been working on space themed shaders\n//  Code \"borrowed\" from the usual suspects\n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.00001\n#define MAX_ITER        55\n#define MAX_DISTANCE    31.0\n#define PERIOD          45.0\n#define TIME            mod(iTime, PERIOD)\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = skyCol1*skyCol1*skyCol1*3.0;\nconst vec3  sunCol1       = vec3(1.0,0.9,0.8);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.8);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  ringColor     = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  planetCol     = sqrt(vec3(0.9, 0.8, 0.7));\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere)\n{\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n\nfloat noise2(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat smoother(float d, float s) {\n  return s*tanh(d/s);\n}\n\nfloat heightMod(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += -pp.x*0.2;\n  p = toRect(pp);\n  return pow((psin(1.0*p.x)*psin(1.0*p.y)), max(0.25, pp.x*0.20))*0.8;\n}\n\nfloat loheight(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 3; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat height(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 5; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat hiheight(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 6; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n  \nvec3 normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy, d) - hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx, d) - hiheight(p + eps.yx, d));\n  \n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz, d);\n    \n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE) {\n      return d;\n    }\n\n    float sl = 0.9;\n\n    dt = max(hd*sl, TOLERANCE+0.0005*d);\n    lastd = d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.2, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n  \n  float dustTransparency = smoothstep(-0.15, 0.075, rd.y);\n\n  vec3 skyCol = mix(skyCol1, skyCol2, sqrt(dustTransparency));\n  skyCol *= (1.0-dustTransparency);\n  \n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*dustTransparency*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  final += skyCol + sunCol + smallSunCol;\n\n  return final;\n}\n\nvec3 shipColor(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*0.05;\n  p = toRect(pp);\n\n  float n = mod1(p.x, 0.15);\n  p.y += 3.0-TIME*0.5+0.05*abs(n*n);\n\n  float td = abs(p.x) - (0.005-p.y*0.002);\n  td = abs(td) - (0.02*pow(-p.y, 0.25));\n  float sd = circle(p, 0.05);\n  \n  vec3 trailCol = vec3(0.5)*smoothstep(-5.0, 0.0, p.y)*step(p.y, 0.0)*smoothstep(0.0, 0.025, -td);\n  vec3 shipCol = vec3(0.5+smoothstep(-1.0, 1.0, sin(TIME*15.0*TAU+n)))*smoothstep(0.0, 0.075, -sd);\n  \n  vec3 col = trailCol;\n  col += shipCol;\n\n  float sm = step(abs(n), 2.0);\n  \n  return col*sm;\n}\n\nvec3 getColor(vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  const float shipHeight = 1.0;\n  const float seaHeight = 0.0;\n  const float cloudHeight = 0.2;\n  const float upperCloudHeight = 0.5;\n  \n  float id = (cloudHeight - ro.y)/rd.y;\n  \n  if (id > 0.0) {\n    float d = march(ro, rd, id, max_iter);\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, 1.0, -1.0);\n    vec3 p = ro + d*rd;\n\n    float loh = loheight(p.xz, d);\n    float loh2 = loheight(p.xz+sunDir.xz*0.05, d);\n    float hih = hiheight(p.xz, d);\n    vec3 normal = normal(p.xz, d);\n\n    float ud = (upperCloudHeight - 4.0*loh - ro.y)/rd.y;\n    \n    float sd = (seaHeight - ro.y)/rd.y;\n    vec3 sp = ro + sd*rd;\n    float scd = (cloudHeight - sp.y)/sunDir.y;\n    vec3 scp = sp + sunDir*scd;\n    \n    float sloh = loheight(scp.xz, d);\n    float cshd = exp(-15.0*sloh);\n\n    float amb = 0.3;\n \n    vec3 seaNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 seaRef = reflect(rd, seaNormal);    \n    vec3 seaCol = .25*skyColor(p, seaRef);\n    seaCol += pow(max(dot(seaNormal, sunDir), 0.0), 2.0); \n    seaCol *= cshd;\n    seaCol += 0.075*pow(vec3(0.1, 1.3, 4.0), vec3(max(dot(seaNormal, seaRef), 0.0)));\n\n    float spe = pow(max(dot(sunDir, reflect(rd, normal)), 0.0), 3.0);\n    float fre = pow(1.0-dot(normal, -rd), 2.0);\n\n    col = seaCol;\n\n    \n    const float level = 0.00;\n    const float level2 = 0.3;\n    // REALLY fake shadows and lighting\n    vec3 scol = sunCol1*(smoothstep(level, level2, hih) - smoothstep(level, level2, loh2));\n    col = mix(vec3(1.0), col, exp(-17.0*(hih-0.25*loh)));\n    col = mix(vec3(.75), col, exp(-10.0*loh*(max(d-ud, 0.0))));\n    col += scol;\n      \n    col += vec3(0.5)*spe*fre;    \n    \n    float ssd = (shipHeight - ro.y)/rd.y;\n\n    col += shipColor((ro + rd*ssd).xz);\n\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.*MAX_DISTANCE, d));\n    \n  } else {\n    col = skyCol;\n  }\n\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 getSample1(vec2 p, float time) {\n  vec3 ro  = vec3(0.5, 5.5, -2.0);\n  vec3 la  = ro + vec3(0.0, -1.+0.9*TIME/PERIOD,  1.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd)  ;\n \n  return col;\n  \n}\n\nvec3 getSample2(vec2 p, float time) {\n  p.y-=time*0.25;\n  float h = height(p, 0.0);\n  vec3 n = normal(p, 0.0);\n  \n  vec3 lp = vec3(10.0, -1.2, 0.0);\n  \n  vec3 ld = normalize(vec3(p.x, h, p.y)- lp);\n  \n  float d = max(dot(ld, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n\n  col = vec3(1.0)*(h+0.1);\n  col += vec3(1.5)*pow(d, 0.75);\n \n  return col;\n  \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = getSample1(p, TIME);\n  \n  col = postProcess(col, q);\n  \n  col *= smoothstep(0.0, 2.0, TIME);\n  col *= 1.0-smoothstep(PERIOD-2.0, PERIOD, TIME);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXyW4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[956, 956, 989, 989, 1074], [1076, 1076, 1097, 1097, 1126], [1128, 1128, 1149, 1149, 1190], [1192, 1192, 1214, 1214, 1258], [1260, 1260, 1299, 1299, 1424], [1426, 1426, 1457, 1457, 1483], [1485, 1485, 1527, 1527, 1574], [1576, 1576, 1623, 1623, 1874], [1876, 1876, 1900, 1900, 1970], [1973, 1973, 1995, 1995, 2470], [2472, 2472, 2506, 2506, 2530], [2532, 2532, 2557, 2557, 2693], [2695, 2695, 2728, 2728, 3212], [3214, 3214, 3245, 3245, 3729], [3731, 3731, 3764, 3764, 4248], [4252, 4252, 4282, 4282, 4501], [4503, 4503, 4562, 4562, 5038], [5040, 5040, 5061, 5061, 5105], [5107, 5107, 5133, 5133, 5179], [5181, 5181, 5214, 5214, 7300], [7302, 7302, 7326, 7326, 7872], [7874, 7874, 7907, 7907, 9934], [9936, 9936, 9979, 10004, 10253], [10255, 10255, 10292, 10292, 10611], [10613, 10613, 10650, 10650, 10956], [10958, 10958, 11010, 11010, 11308]], "test": "untested"}
{"id": "WdBBz3", "name": "Glass Cube With Dispersion", "author": "ChrisK", "description": "Modified version of my previous shader: https://www.shadertoy.com/view/WdSczh", "tags": ["3d", "raytracing", "refraction", "reflections", "translucency", "dispersion"], "likes": 55, "viewed": 1099, "published": 3, "date": "1592021456", "time_retrieved": "2024-07-30T21:01:27.947575", "image_code": "//June 21, 2020: Added chromatic abberation\n\n#define ABSORBTION \t\t\t\tvec3(0.03)\n#define IOR \t\t\t\t\t1.5\n#define DISPERSION \t\t\t\t0.03\n#define CHROMATIC_ABBERATION\t0.01\n\n#define TIMESCALE 0.35\n#define INTERNAL_REFLECTIONS 4\n#define SAMPLES 30.0\n\n\n#define rot2(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nvec3 rotate ( vec3 p, vec3 r ) {\n    p.yz *= rot2(r.x);\n    p.xz *= rot2(-r.y);\n    p.xy *= rot2(r.z);\n    return p;\n}\n\n\nfloat InteriorCubeReflection ( vec3 ro, vec3 rd ) {\n    vec3 d = (0.5*sign(rd)-ro)/rd;\n    return min( min(d.x, d.y), d.z );\n}\n\n\nfloat IntersectCube ( vec3 ro, vec3 rd ) {\n    float dfront = -InteriorCubeReflection(-ro,rd);\n    float dback  = InteriorCubeReflection(ro,rd);\n    return dback>=dfront ? dfront : -1.0;\n}\n\n\nfloat GetReflectance ( vec3 i, vec3 t, vec3 nor, float iora, float iorb ) {\n    vec2 c = nor * mat2x3(i,t);\n    vec2 ior = vec2(iora,iorb);\n    vec2 sp = ( mat2(c,-c.yx)*ior ) / ( mat2(c,c.yx)*ior );\n    return dot(sp,sp)/2.0;\n}\n\n\nvec3 GetSky ( vec3 rd ) {\n    float v = dot(rd, vec3(0.5,-0.15,0.85));\n    v = smoothstep(-0.05, 0.05, sin(v*50.0));\n    return vec3( v );\n}\n\n\nvec3 GetDispersedColor( float w ) {\n    return max( sin( ( w - vec3(0.0,0.25,0.5) ) * 6.28318531 ), 0.0);\n    /*\n    vec3 s = vec3(0.9, 1.0, 0.8);\n    vec3 c = w - vec3( 0.0, 0.25, s.b-0.5 );\n    c = clamp(c*s, 0.0, 1.0) * 6.28318531;\n    c = sin(c) * s;\n    return max( c, 0.0);\n\t*/\n}\n\n\nvec3 GetRenderSample ( vec3 ro, vec3 rd, float df ) {\n\tfloat rl = IntersectCube( ro, rd );\n    \n    if ( rl > 0.0 ) {\n        \n        float iord = IOR + DISPERSION*(df-0.5);\n        \n        vec3 xyz = ro + rd*rl;\n        vec3 nor = round( xyz*1.00001 );\n        vec3 power = vec3(1.0);\n        vec3 refractd = refract( rd, nor, 1.0/iord );\n        vec3 reflectd = reflect( rd, nor );\n        float refl = GetReflectance ( rd, refractd, nor, 1.0, iord );\n        vec3 c = GetSky(reflectd) * refl;\n        power *= 1.0-refl;\n        rd = refractd;\n\n        for ( int i=0; i<INTERNAL_REFLECTIONS; i++ ) {\n        \trl = InteriorCubeReflection( xyz, rd );\n        \txyz += rd*rl;\n            nor = round( xyz*1.00001 );\n        \trefractd = refract( rd, -nor, 1.0/iord );\n        \treflectd = reflect( rd, -nor );\n        \trefl = GetReflectance ( rd, refractd, -nor, iord, 1.0 );\n        \tpower *= exp( -ABSORBTION * rl );\n            c += GetSky(refractd) * (1.0-refl) * power;\n            power *= refl;\n            rd = reflectd;\n        }\n        return c;\n    } else {\n    \treturn GetSky(rd);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.x;\n    \n    vec3 col = vec3(0.0);\n    for ( float f = 0.0; f<SAMPLES; f++ ) {\n        float w = f/SAMPLES;\t\t// wavelength sample ( 0 => 1 across visible spectrum )\n        \n        float b = (fract(f*134.102119) - 0.5) / 60.0;\t\t\t\t\t\t\t//temporal offset for motion blur\n        vec2 aa = (fract((f+uv)*134.102119+iTime)-0.5)/iResolution.x*3.0;\t\t//quick and sloppy positional offset for aa\n        \n        vec3 cp = vec3( aa, -2.5);\n        vec3 cr = normalize( vec3(uv,1.0+w*CHROMATIC_ABBERATION) );\n    \tcp = rotate( cp, vec3( (iTime + b) * TIMESCALE ) );\n        cr = rotate( cr, vec3( (iTime + b) * TIMESCALE ) );\n        \n        vec3 c = GetRenderSample( cp, cr, w );\n        \n        vec3 sp = GetDispersedColor(w);\n    \tcol += c * sp;\n    }\n    col /= SAMPLES/3.0;\n    \n    col = smoothstep(0.0, 1.0, col);\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 325, 325, 411], [414, 414, 465, 465, 540], [543, 543, 585, 585, 731], [734, 734, 809, 809, 962], [965, 965, 990, 990, 1105], [1108, 1108, 1143, 1143, 1393], [1396, 1396, 1449, 1449, 2495], [2498, 2498, 2555, 2555, 3501]], "test": "untested"}
{"id": "WtscDH", "name": "Mandelbrot Navigator", "author": "Cieric", "description": "Just general Mandelbrot navigator.", "tags": ["mandelbrot"], "likes": 1, "viewed": 260, "published": 3, "date": "1592004283", "time_retrieved": "2024-07-30T21:01:28.882076", "image_code": "//Controls:\n//\n// W - move up\n// S - move down\n// A - move left\n// D - move right\n//\n// E - zoom in\n// E - zoom out\n\n//#define ENABLE_TEXT\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n#define FONT_EFFECTS\n#define AUTO_FONT_SPACING\n\n#define FONT_SAMPLER iChannel0\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n// SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n    {\n        return 0.1f;\n    }\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )\n    {     \n        return 0.8f;\n    }\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n    \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n#ifdef FONT_EFFECTS    \n    float fShadowDistance;\n    vec2 vNormal;    \n#endif\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n#ifdef FONT_EFFECTS        \n    state.fShadowDistance = 1000000.0;\n    state.vNormal = vec2(0.0);    \n#endif    \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold;\n#ifdef FONT_EFFECTS        \n    bool bShadow;\n    vec2 vShadowOffset;\n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(16.0f, 16.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n#ifdef FONT_EFFECTS        \n    style.vShadowOffset = vec2(0);\n    style.bShadow = false;\n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n#ifdef FONT_EFFECTS            \n    vec3 vOutlineColor;\n    vec3 vHighlightColor;\n    float fOutlineWeight;\n    float fBevelWeight;\n    float fShadowSpread;\n    float fShadowStrength;\n    vec2 vLightDir;\n#endif    \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;\n#ifdef FONT_EFFECTS            \n    style.vOutlineColor = vec3(1);\n    style.vHighlightColor = vec3(0);\n    style.fOutlineWeight = 0.0f;\n    style.fBevelWeight = 0.0f;\n    style.fShadowSpread = 0.0f;\n    style.fShadowStrength = 0.0f;\n    style.vLightDir = vec2(-1.0f, -0.5f );\n#endif    \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;\n#ifdef FONT_EFFECTS            \n        state.vNormal = v.yz;\n#endif        \n    }\n\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fShadowDistance = SampleCharacter( iChar, vUV - style.vShadowOffset ).a;\n        if ( style.bBold )\n        {\n            fShadowDistance -= 0.025f;\n        }\n        \n        if ( fShadowDistance < state.fShadowDistance )\n        {\n            state.fShadowDistance = fShadowDistance;\n        }        \n    }\n#endif\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fSize = renderStyle.fFontWeight + renderStyle.fOutlineWeight;\n        float fBlendShadow = clamp( (state.fShadowDistance - fSize - renderStyle.fShadowSpread * 0.5) / -renderStyle.fShadowSpread, 0.0, 1.0);\n        color.rgb = mix( color.rgb, vec3(0.0), fBlendShadow * renderStyle.fShadowStrength);    \n    }\n\n    if ( renderStyle.fOutlineWeight > 0.0f )\n    {        \n        float fBlendOutline = GetFontBlend( state, style, renderStyle.fFontWeight + renderStyle.fOutlineWeight );\n        color.rgb = mix( color.rgb, renderStyle.vOutlineColor, fBlendOutline);\n    }\n#endif\n    \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n\t\n#ifdef FONT_EFFECTS            \n    if ( renderStyle.fBevelWeight > 0.0f )\n    {    \n        float fBlendBevel = GetFontBlend( state, style, renderStyle.fFontWeight - renderStyle.fBevelWeight );    \n        float NdotL = dot( state.vNormal, normalize(renderStyle.vLightDir ) );\n        float shadow = 1.0 - clamp(-NdotL, 0.0, 1.0f);\n        float highlight = clamp(NdotL, 0.0, 1.0f);\n        highlight = pow( highlight, 10.0f);\n        vCol = mix( vCol, vCol * shadow + renderStyle.vHighlightColor * highlight, 1.0 - fBlendBevel);\n    }\n#endif\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i<CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\nconst ivec2 txCameraPos = ivec2(0,0);\nconst ivec2 txCameraZoom  = ivec2(1,0);\nconst ivec2 txPrevCameraPos = ivec2(0,1);\nconst ivec2 txPrevCameraZoom  = ivec2(1,1);\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel1, re, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(1);\n    fragColor.rgb = texture(iChannel2, fragCoord.xy/iResolution.xy).rgb;\n    \n#ifdef ENABLE_TEXT\n    \n    vec2 vCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y );    \n    vec2 vCanvasPixelSize = vec2(1.0);\n    \n    PrintState state = PrintState_InitCanvas( vCanvasCoord, vCanvasPixelSize );\n\n    LayoutStyle style = LayoutStyle_Default();\n    style.vSize = vec2(64.0f, 64.0f) * 0.6;\n    PrintBeginNextLine(state, style);\n    \n    RenderStyle renderStyle = RenderStyle_Default( vec3(0.0) );\n\n    float cameraZoom = loadValue(txCameraZoom).x;\n    vec2 cameraPos = loadValue(txCameraPos).xy;\n    \n    Print( state, style, cameraZoom, 3 );\n    PrintEOL( state, style );\n        \n    renderStyle.fFontWeight = 0.0f;\n    renderStyle.vFontColor = vec3(0.4, 0.7, 1.0);\n                 \n    renderStyle.vOutlineColor = vec3(0.0, 0.0, 0.0);\n    renderStyle.vHighlightColor = vec3(0.0);\n    renderStyle.fOutlineWeight = 0.05;\n    renderStyle.fBevelWeight = 0.0;\n    \n    RenderFont( state, style, renderStyle, fragColor.rgb );\n#endif\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//\n// Gameplay computation.\n//\n// The gameplay buffer is 14x14 pixels. The whole game is run/played for each one of these\n// pixels. A filter in the end of the shader takes only the bit  of infomration that needs \n// to be stored in each texl of the game-logic texture.\n\n// storage register/texel addresses\nconst ivec2 txCameraPos = ivec2(0,0);\nconst ivec2 txCameraZoom  = ivec2(1,0);\n\nconst ivec2 txPrevCameraPos = ivec2(0,1);\nconst ivec2 txPrevCameraZoom  = ivec2(1,1);\n\nconst int KEY_SPACE = 32;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S\t= 83;\nconst int KEY_D\t= 68;\nconst int KEY_E\t= 69;\nconst int KEY_Q\t= 81;\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n \n    // don't compute gameplay outside of the data area\n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n    fragColor = vec4(0.0);\n    \n    //---------------------------------------------------------------------------------   \n\t// load game state\n\t//---------------------------------------------------------------------------------\n    vec2 cameraPos  = loadValue( txCameraPos ).xy;\n    vec2 cameraZoom = loadValue( txCameraZoom ).xy;\n    \n    storeValue( txPrevCameraPos, vec4(cameraPos,0.0,0.0), fragColor, ipx );\n    storeValue( txPrevCameraZoom, vec4(cameraZoom,0.0,0.0), fragColor, ipx );\n    \n\t\n    //---------------------------------------------------------------------------------\n    // reset\n\t//---------------------------------------------------------------------------------\n\t\n    if(cameraZoom.x == 0.0)\n        cameraZoom.x = 1.0;\n    \n    cameraZoom.x = max(cameraZoom.x, 0.01);\n    \n    float zoomSpeed = 2.0/cameraZoom.x;\n    \n    float moveIn\t= texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x;\n    float moveOut\t= texelFetch( iChannel1, ivec2(KEY_Q,0), 0 ).x;\n    cameraZoom.x += iTimeDelta*cameraZoom.x*(moveIn - moveOut);\n    \n    float moveRight = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x;\n    float moveLeft  = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x;\n    cameraPos.x += iTimeDelta*zoomSpeed*(moveRight - moveLeft);\n    \n    float moveUp\t= texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x;\n    float moveDown\t= texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x;\n    cameraPos.y += iTimeDelta*zoomSpeed*(moveUp - moveDown);\n    \n    cameraZoom.y = abs(moveRight - moveLeft) + abs(moveUp - moveDown) + abs(moveIn - moveOut);\n    if(iFrame == 0)\n        cameraZoom.y = 1.0;\n        \n\t//---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n    \n    \n    storeValue( txCameraPos, vec4(cameraPos,0.0,0.0), fragColor, ipx );\n    storeValue( txCameraZoom, vec4(cameraZoom,0.0,0.0), fragColor, ipx );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define ITERATIONS_PER_FRAME 16\n\n\n#define InputChannel iChannel1\n\nvec3 stepMandelbrot(vec2 c, vec3 z)\n{\n    if(length(z.xy) > 2.0) return z;\n    vec2 tempz;\n    tempz.y = 2.0*z.x*z.y+c.y;\n    tempz.x = (z.x*z.x)-(z.y*z.y)+c.x;\n    return vec3(tempz, z.z+1.0);\n}\n\nvec3 map(vec3 i)\n{\n \treturn vec3((i.xy+1.0)/2.0, i.z / float(iFrame));\n}\n\nvec3 unmap(vec3 i)\n{\n \treturn vec3(i.xy*2.0-1.0, i.z * float(iFrame));\n}\n\nconst ivec2 txCameraPos = ivec2(0,0);\nconst ivec2 txCameraZoom  = ivec2(1,0);\nconst ivec2 txPrevCameraPos = ivec2(0,1);\nconst ivec2 txPrevCameraZoom  = ivec2(1,1);\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel1, re, 0 );\n}\n\nvec2 screen2world(vec2 pos, vec4 window)\n{\n    return pos * window.zw + (window.xy - window.zw/2.0);\n}\n\nvec2 world2screen(vec2 pos, vec4 window)\n{\n    return (pos - (window.xy - window.zw/2.0)) / window.zw;\n}\n\nvec2 screen2screen(vec2 pos, vec4 window1, vec4 window2)\n{\n    return (pos * window1.zw + (window1.xy - window1.zw/2.0) - (window2.xy - window2.zw/2.0)) / window2.zw;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 window = vec4(0.5, 0.0, 3., 3.);\n    float cameraZoom = loadValue(txCameraZoom).x;\n    vec2 cameraPos = loadValue(txCameraPos).xy;\n    window.xy += cameraPos;\n    window.zw /= cameraZoom;\n    vec2 c = screen2world(fragCoord/iResolution.xy, window);\n    vec3 z = unmap(texture(iChannel0, fragCoord/iResolution.xy).xyz);\n    if(iFrame == 1) {\n    \tz = vec3(0.0, 0.0, 0.0);\n    }\n    \n    if(loadValue(txCameraZoom).y > 0.0)\n    {\n        vec4 prevWindow = vec4(0.5, 0.0, 3., 3.);\n        float prevCameraZoom = loadValue(txPrevCameraZoom).x;\n        vec2 prevCameraPos = loadValue(txPrevCameraPos).xy;\n        prevWindow.xy += prevCameraPos;\n    \tprevWindow.zw /= prevCameraZoom;\n        \n    \tvec2 uv = world2screen(c, prevWindow);\n        fragColor = texture(iChannel0, uv);\n        //z = stepMandelbrot(c, z);\n        //fragColor = mix(texture(iChannel0, uv), vec4(vec3(map(z)), 1.0), 0.5);\n   \t\treturn;\n    }\n    else if(loadValue(txPrevCameraZoom).y > 0.0)\n    {\n    \tz = vec3(0.0, 0.0, 0.0);\n    }\n\n    for(int i=0; i<ITERATIONS_PER_FRAME; i++)\n    \tz = stepMandelbrot(c, z);\n    \n    fragColor = vec4(map(z), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const ivec2 txCameraPos = ivec2(0,0);\nconst ivec2 txCameraZoom  = ivec2(1,0);\nconst ivec2 txPrevCameraPos = ivec2(0,1);\nconst ivec2 txPrevCameraZoom  = ivec2(1,1);\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel2, re, 0 );\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 map2color(vec3 val)\n{\n    float di=val.z;\n    float zn;\n    float hue;\n\n    zn = sqrt(val.x*val.x + val.y*val.y);\n    hue = di + 1.0 - log(log(abs(zn)))/log(2.0);\n    hue = 0.95 + 20.0 * hue;\n    hue = mod(mod(hue,360.0)+360.0, 360.0);\n\n    return hsv2rgb(vec3(hue / 360.0, 0.8, 1.0));\n}\n\nvec3 unmap(vec3 i)\n{\n \treturn vec3(i.xy*2.0-1.0, i.z * float(iFrame));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = unmap(texture(iChannel0, uv).rgb);\n    //if(color.z >= 0.9)\n    //    discard;\n    fragColor = vec4(map2color(color), 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2542, 2542, 2595, 2595, 2749], [2755, 2755, 2805, 2805, 3774], [4658, 4744, 4790, 4790, 4947], [4949, 4949, 4991, 4991, 5418], [5682, 5682, 5732, 5732, 5839], [5841, 5841, 5890, 5890, 6038], [6040, 6040, 6107, 6107, 6291], [6497, 6497, 6532, 6532, 6832], [7118, 7118, 7170, 7170, 7566], [7568, 7568, 7645, 7661, 7863], [7865, 7865, 7941, 8003, 8101], [8103, 8103, 8169, 8169, 8311], [8313, 8313, 8396, 8396, 10132], [10134, 10134, 10205, 10205, 10390], [10392, 10392, 10500, 10500, 11864], [12000, 12000, 12069, 12069, 12443], [12445, 12445, 12513, 12513, 12659], [12661, 12661, 12750, 12750, 13551], [13813, 13813, 13844, 13844, 13889], [13891, 13891, 13948, 13948, 15022]], "test": "untested"}
{"id": "ttsyW8", "name": "Sine melody (source)", "author": "ttg", "description": "Of course this is more efficient of code than [url]https://www.shadertoy.com/view/WtsyWr[/url] but listing the values in a table makes a clear demonstration of the absolute absence of any modulation on the sinusoid components.", "tags": ["sound", "music", "interference", "sines", "sampleprecise"], "likes": 10, "viewed": 478, "published": 3, "date": "1592003555", "time_retrieved": "2024-07-30T21:01:29.637058", "image_code": "                                                                                                                                                                                                                                                                /*\n\n    Main source is in the Common tab.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\n\n\n\n\n/* \n\nExpression Plotter\n\nUsage: PLOT_CONTINUOUS( fragColor, uv, window, domain,\n                        linecolor, side, blend, linewidth, expression );\n\n  fragColor - output (linear RGB)\n  uv - coordinate system for window\n  window - mat2, first col: window corner, second col: window size\n  domain - mat2, first col: min x,y, second col: max x,y\n  linecolor - RGB\n  side - 0 = line, 1 = below, -1 = above (see demo)\n  blend - 0=paint, 1=light-trace, 2=ink (see demo)\n  linewidth - measured in units of uv.x; only for side=0\n  expression - uses x as the independent variable\n\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/3t3XWf\", is displayed within the source.\n\n*/\n\n\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\n/*\nCopyright 2020 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    PLOT_CONTINUOUS(col, uv, mat2(0,0,1,1), mat2(0.,-1.,1.,1.), vec3(1.), 0, 1, .002, texture(iChannel0, vec2(x,0.)).x );\n    PLOT_CONTINUOUS(col, uv, mat2(0,0,1,1), mat2(0.,-1.,1.,1.), .04*vec3(.1,1.,.1), 0, 1, .02, texture(iChannel0, vec2(x,0.)).x );\n    col += .003*vec3(.1,1.,.1);\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\nvec2 mainSound( in int samp, float time_DO_NOT_USE)\n{\n    return mainSound(samp);\n}\n", "sound_inputs": [], "buffer_a_code": "void mainImage( out vec4 v, in vec2 fc )\n{\n    if (int(fc.y)!=0) discard;\n    float x = fc.x/iResolution.x-.5;\n    v.x = mainSound(int((.02*x+round(iTime*264.)/264.)*iSampleRate)).x;\n}\n", "buffer_a_inputs": [], "common_code": "\nfloat intfract(int s, float p);\nconst float pi = 3.1415927;\n\nfloat sineosc(int s, float f, float p) {\n    float a = 2.*pi*intfract(s, iSampleRate/f);\n    return cos(a-p);\n}\n\nvec2 mainSound( int s) {\n  float v = 0.;\n\n// PASTE BELOW INTO SH \\\ncc -xc -DC - && ./a.out | sort -t, -k2 -n\n#ifdef C\n#include <stdio.h>\nint main () {\n#define intc(x) ((int)(x))\n#define floatc(x) ((float)(x))\n#define QUOTE(X) #X\n#define EXPAND(...) __VA_ARGS__\n#define ARRV(a,i) ((float[]){EXPAND a}[i])\n#define SINE(G,F,P) printf(QUOTE(vec3(%2.f,%11.6f,%6.3f)\\054), G,F,P);\n#define NEWLINE printf(QUOTE(\\n));\n#else\n#define intc(x) (int(x))\n#define floatc(x) (float(x))\n#define ARRV(a,i) (float[]a[i])\n#define SINE(g,f,p) v += (g)/320.*sineosc(s,(f),2.*pi*(p));\n#define NEWLINE\n#endif\n\n  float f0 = 264.;\n\n  for (int i3=0; i3<=3; i3+=3) // loop over overtones\n  for (int i0=0; i0<10; i0++) // loop over composition\n  for (float h=1.; h<9.1; h+=2.) { // loop over pulse harmonic\n\n    float f = f0*ARRV((.5,1.,2.,1.5,.75, .5,1.,1.25,1.5,0.75), i0)*\n      ARRV((1.,4./3.),i0/5) * floatc(i3+1);\n    float p = 0.;\n    float g = 1.+1.*floatc((i0%5)==0);\n    float pf = 1.+1.*floatc((i0%5)==0);\n    float pp = ARRV((0.,0.,.25,.5,.75),i0%5);\n    float fp = .25*floatc(i0/5);\n\n    for (float f0=-1.; f0<=1.; f0+=2.)\n    for (float f1=-1.; f1<=1.; f1+=2.)\n    for (float f2=-1.; f2<=1.; f2+=2.)\n      SINE(f2*g, f+f0*h*pf/2.+f1*.1+f2*.002778, f0*h*pp/2.+f1*fp)\n    NEWLINE\n  }\n#ifdef C\nreturn 0; }\n#endif\n// END.  ^D to complete.\n\n  return vec2(v);\n}\n\nfloat intfract(int s, float p) {\n  // Implements fract(s/n)\n  // Explanation and copyright: shadertoy.com/view/4ltfRN\n  // Given sample number and period, calculate phase with high accuracy.\n  // Uses integer overflow for modulo.\n  int sp = int(p), a = s%sp, b = (s/sp);\n  const float MAXF = float(uint(-1))+1.;\n  return fract(  (float(a)/p) + float((uint(b)*uint(MAXF*float(sp)/p)))/MAXF );\n}\n", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyW8.jpg", "access": "api", "license": "isc", "functions": [[1217, 1265, 1408, 1408, 1409], [4619, 4619, 4676, 4726, 5153]], "test": "untested"}
{"id": "WtscD8", "name": "Green and Purple thing", "author": "Oggbog", "description": "Playing with wave formulas", "tags": ["sin", "cos"], "likes": 1, "viewed": 281, "published": 3, "date": "1591980030", "time_retrieved": "2024-07-30T21:01:30.399021", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n    uv.x = fract(uv.x)-0.5;\n    \n    float d = length(uv*vec2(0.12,0.25))*80.-iTime*2.;\n    float e = length(uv)*sin(iTime/6.0)*8.-iTime*2.;\n    \n    d = pow(min(sin(d),cos(d)),sin(d)*2.);\n    e = pow(min(sin(e),cos(d)),cos(e)*2.);\n    d = max(d,e);\n\n    d = smoothstep(sin(d),e,sin(d)+cos(e));\n    e = step(0.5,cos(e));\n    vec3 col = vec3(d/2.,1.-e,d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 582]], "test": "untested"}
{"id": "3lsyW8", "name": "Reintegration tracking", "author": "michael0884", "description": "Cellular automaton particle tracking with full conservation of mass/energy and approximately particle number", "tags": ["particles", "ca"], "likes": 19, "viewed": 553, "published": 3, "date": "1591974623", "time_retrieved": "2024-07-30T21:01:31.230797", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\n    vec4 U = decode(texel(ch0, pos).zw);\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    vec4 D = pixel(ch2, pos);\n    float ang = atan(D.w, D.z);\n    float mag = length(D.zw);\n\tvec3 rho = vec3(1.,1.7,4.)*(0.*U.w+5.*smoothstep(0.2, 0.3, P.w));\n    // Output to screen\n    fragColor = vec4(sqrt(rho)*(0.15+hsv2rgb(vec3(ang, 1., mag))),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec4 decode(vec2 x)\n{\n    uint v = floatBitsToUint(x.x);\n    uint m = floatBitsToUint(x.y);\n    return vec4(unpack(v),unpack(m)*128.); \n}\n\nvec2 encode(vec4 x)\n{\n    uint v = pack(x.xy);\n    uint m = pack(x.zw/128.);\n    return vec2(uintBitsToFloat(v),uintBitsToFloat(m)); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n", "buffer_a_code": "#define mass 0.1\n#define div 0.7\nfloat border(vec2 p)\n{\n    return -sdBox(p - R*0.5, R*0.5);\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nvec2 Force(vec2 dx)\n{\n    return 10.*dx*exp(-dot(dx,dx));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n        \n    //particle position\n    vec2 x = vec2(0.);\n    //particle velocity, mass and grid distributed density\n    vec4 vm = vec4(0.); \n    vec2 F = vec2(0., -0.0002);\n    vec2 dF = vec2(0.);\n    \n    //reintegration advection\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        vec2 x0 = data.xy; //update position\n        //how much mass falls into this pixel(is exact, 0 or full)\n        vm.w += vm0.z*G((pos - x0)/1.5);\n        float D = step(max(abs(pos.x - x0.x),\n                           abs(pos.y - x0.y)), 0.5);\n        vm0.z *= (vm0.z<4.*mass)?D:(0.25*step(max(abs(pos.x - x0.x),\n                          \t\t                  abs(pos.y - x0.y)), 1.002));\n        if(vm0.z>=4.*mass) \n        {\n            x0 = mix(x0, pos, 1.);\n        }\n           \n        //add weighted positions by mass\n        x += x0*vm0.z;\n        //add weighted velocities by mass\n        vm.xy += vm0.xy*vm0.z;\n        //add mass\n        vm.z += vm0.z;\n        dF += vm0.z*Force(pos - x0)*(1. - D);\n    }\n    \n    if(vm.z != 0.) //not vacuum\n    {\n        //normalize\n        x /= vm.z;\n        vm.xy /= vm.z;\n        \n        vec3 dx = vec3(-1.,0,1.);\n        vec2 px = x;\n        vec3 rand = hash32(pos+x)-0.5;\n        \n    \t//update velocity\n         //border \n    \tvec3 N = bN(px);\n        float vdotN = step(abs(N.z), 10.)*dot(N.xy, vm.xy);\n        vm.xy = vm.xy - 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += N.xy*step(abs(N.z), 10.)/N.z;\n        \n        //global force field\n        \n        vec4 GF = pixel(ch1, px);\n\n        F += (-GF.xy + (GF.zw - vm.xy)*0.2 - 0.01*vm.xy*step(N.z, 15.)); \n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.1*dm*exp(-d*d);\n        }\n   \t    vm.xy += 0.4*F*dt/(0.01+vm.z);\n        //velocity limit\n        float v = length(vm.xy);\n        vm.xy /= (v > 1.)?v:1.;\n        x += (vm.xy + dF)*dt;\n    }\n    else\n    {\n        x = pos;\n        vm.xyz = vec3(0.);\n    }\n    \n\n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.1) \n        {\n            x = pos;\n            vm = vec4(0.3*vec2(2.*rand.xy - 1.), 4.*mass, mass);\n        }\n        else\n        {\n            x = pos;\n        \tvm = vec4(0.);\n        }\n    }\n    \n    U = vec4(x, encode(vm));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define Radius 3\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec4 avm = vec4(0.);\n    float sum = 1.;\n    range(i, -Radius, Radius)\n    {\n        ivec2 p = ivec2(pos) + ivec2(i,0);\n        if(p.x >= 0 && p.x < int(R.x))\n        {\n            float k = G(vec2(i,0)*1.5/float(Radius));\n            vec4 d = decode(texel(ch0, p).zw);\n        \tavm += vec4(d.xy*d.z, d.zw)*k;\n        \tsum += k;\n        }\n    }\n    U = avm/sum;\n    U.xy = avm.xy/(avm.z+0.0001); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define Radius 3\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec4 avm = vec4(0.);\n    float sum = 1.;\n    range(i, -Radius, Radius)\n    {\n        ivec2 p = ivec2(pos) + ivec2(0,i);\n        float k = G(vec2(0,i)*1.5/float(Radius));\n        vec4 d = texel(ch0, p);\n        avm += vec4(d.xy*d.z, d.zw)*k;\n        sum += k;\n    }\n    U = avm/sum;\n    U.z = 0.5*U.z*clamp(pow(abs(U.z/0.07), 6.) - 1., -1., 1.); //water\n    //U.z = 1.2*U.z;//gas\n    U.xy = avm.xy/(avm.z+0.0001); \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//force field\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n   vec3 dx = vec3(-1., 0., 1.);\n   U.xy = 0.5*vec2(texel(ch0, pos + dx.zy).z - texel(ch0, pos + dx.xy).z,\n                   texel(ch0, pos + dx.yz).z - texel(ch0, pos + dx.yx).z);\n   //average velocity\n   vec4 a = texel(ch0, pos); \n   U.zw = a.xy;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 258, 258, 596]], "test": "untested"}
{"id": "3lscW8", "name": "This is fine fire", "author": "akella", "description": "small exercise in glsl", "tags": ["fire", "meme"], "likes": 5, "viewed": 465, "published": 3, "date": "1591974243", "time_retrieved": "2024-07-30T21:01:31.992759", "image_code": "vec3 flame1 = vec3(0.994, 0.904, 0.216);\nvec3 flame2 = vec3(0.993, 0.719, 0.000);\nvec3 border = vec3(0.211, 0.193, 0.002);\n\n\n// Worley noise  https://github.com/Erkaman/glsl-worley\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n  vec3 Pi = mod(floor(P), 289.0);\n   vec3 Pf = fract(P) - 0.5;\n\n  vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n  vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n  vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n  vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n  vec3 p1 = permute(p + Pi.y - 1.0);\n  vec3 p2 = permute(p + Pi.y);\n  vec3 p3 = permute(p + Pi.y + 1.0);\n\n  vec3 p11 = permute(p1 + Pi.z - 1.0);\n  vec3 p12 = permute(p1 + Pi.z);\n  vec3 p13 = permute(p1 + Pi.z + 1.0);\n\n  vec3 p21 = permute(p2 + Pi.z - 1.0);\n  vec3 p22 = permute(p2 + Pi.z);\n  vec3 p23 = permute(p2 + Pi.z + 1.0);\n\n  vec3 p31 = permute(p3 + Pi.z - 1.0);\n  vec3 p32 = permute(p3 + Pi.z);\n  vec3 p33 = permute(p3 + Pi.z + 1.0);\n\n  vec3 ox11 = fract(p11*K) - Ko;\n  vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n  vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n  vec3 ox12 = fract(p12*K) - Ko;\n  vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n  vec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n  vec3 ox13 = fract(p13*K) - Ko;\n  vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n  vec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n  vec3 ox21 = fract(p21*K) - Ko;\n  vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n  vec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n  vec3 ox22 = fract(p22*K) - Ko;\n  vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n  vec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n  vec3 ox23 = fract(p23*K) - Ko;\n  vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n  vec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n  vec3 ox31 = fract(p31*K) - Ko;\n  vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n  vec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n  vec3 ox32 = fract(p32*K) - Ko;\n  vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n  vec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n  vec3 ox33 = fract(p33*K) - Ko;\n  vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n  vec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n  vec3 dx11 = Pfx + jitter*ox11;\n  vec3 dy11 = Pfy.x + jitter*oy11;\n  vec3 dz11 = Pfz.x + jitter*oz11;\n\n  vec3 dx12 = Pfx + jitter*ox12;\n  vec3 dy12 = Pfy.x + jitter*oy12;\n  vec3 dz12 = Pfz.y + jitter*oz12;\n\n  vec3 dx13 = Pfx + jitter*ox13;\n  vec3 dy13 = Pfy.x + jitter*oy13;\n  vec3 dz13 = Pfz.z + jitter*oz13;\n\n  vec3 dx21 = Pfx + jitter*ox21;\n  vec3 dy21 = Pfy.y + jitter*oy21;\n  vec3 dz21 = Pfz.x + jitter*oz21;\n\n  vec3 dx22 = Pfx + jitter*ox22;\n  vec3 dy22 = Pfy.y + jitter*oy22;\n  vec3 dz22 = Pfz.y + jitter*oz22;\n\n  vec3 dx23 = Pfx + jitter*ox23;\n  vec3 dy23 = Pfy.y + jitter*oy23;\n  vec3 dz23 = Pfz.z + jitter*oz23;\n\n  vec3 dx31 = Pfx + jitter*ox31;\n  vec3 dy31 = Pfy.z + jitter*oy31;\n  vec3 dz31 = Pfz.x + jitter*oz31;\n\n  vec3 dx32 = Pfx + jitter*ox32;\n  vec3 dy32 = Pfy.z + jitter*oy32;\n  vec3 dz32 = Pfz.y + jitter*oz32;\n\n  vec3 dx33 = Pfx + jitter*ox33;\n  vec3 dy33 = Pfy.z + jitter*oy33;\n  vec3 dz33 = Pfz.z + jitter*oz33;\n\n  vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n  vec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n  vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n  vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n  vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n  vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n  vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n  vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n  vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n  vec3 d1a = min(d11, d12);\n  d12 = max(d11, d12);\n  d11 = min(d1a, d13); // Smallest now not in d12 or d13\n  d13 = max(d1a, d13);\n  d12 = min(d12, d13); // 2nd smallest now not in d13\n  vec3 d2a = min(d21, d22);\n  d22 = max(d21, d22);\n  d21 = min(d2a, d23); // Smallest now not in d22 or d23\n  d23 = max(d2a, d23);\n  d22 = min(d22, d23); // 2nd smallest now not in d23\n  vec3 d3a = min(d31, d32);\n  d32 = max(d31, d32);\n  d31 = min(d3a, d33); // Smallest now not in d32 or d33\n  d33 = max(d3a, d33);\n  d32 = min(d32, d33); // 2nd smallest now not in d33\n  vec3 da = min(d11, d21);\n  d21 = max(d11, d21);\n  d11 = min(da, d31); // Smallest now in d11\n  d31 = max(da, d31); // 2nd smallest now not in d31\n  d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n  d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n  d12 = min(d12, d21); // 2nd smallest now not in d21\n  d12 = min(d12, d22); // nor in d22\n  d12 = min(d12, d31); // nor in d31\n  d12 = min(d12, d32); // nor in d32\n  d11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n  d11.y = min(d11.y,d12.z); // Only two more to go\n  d11.y = min(d11.y,d11.z); // Done! (Phew!)\n  return sqrt(d11.xy); // F1, F2\n\n}\n\n\nfloat aastep(float threshold, float value) {\n  #ifdef GL_OES_standard_derivatives\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n  #else\n    return step(threshold, value);\n  #endif  \n}\n\nvec3 getFlame(float fl){\n  vec3 color = vec3(0.5);\n  float step1 = aastep(0.5,fl);\n  float step2 = aastep(0.78,fl) - aastep(0.8,fl);\n  float step21 = aastep(0.46,fl) - aastep(0.5,fl);\n  float step3 = -aastep(0.78,fl) + aastep(0.5,fl);\n  color =mix(color, step1*flame1 , step1);\n  color =mix(color, step3*flame2 , step3);\n  color =mix(color, step2*border , step2);\n  color =mix(color, step21*border , step21);\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // fra\n    float t = floor(iTime*5.)/5.;\n    float n = 1. - worley(\n        vec3(\n    \t\t0.1*uv.x * 90.,\n    \t\t0.1*uv.y * 10. -2.*t,\n    \t\tt/3.\n    ), 1., true).x;\n\n\n    float dist = smoothstep( 0.4,1.2,length(uv - vec2(0.5, 1.1)));\n    float s1 = 2.*(dist - 0.5);\n    float fl = n + s1;\n\n\n    fragColor = vec4(getFlame(fl), 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 228, 250, 250, 295], [297, 297, 357, 357, 442], [444, 444, 503, 503, 5053], [5056, 5056, 5100, 5100, 5343], [5345, 5345, 5369, 5369, 5771], [5773, 5773, 5830, 5880, 6267]], "test": "untested"}
{"id": "3tlcW8", "name": "Mandelbrot Thingy", "author": "BigWIngs", "description": "Not as cool as Shanes, but still pretty neat ;)", "tags": ["mandelbrot"], "likes": 32, "viewed": 1049, "published": 3, "date": "1591972999", "time_retrieved": "2024-07-30T21:01:32.744749", "image_code": "// \"Mandelbrot thingy\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n//\n// Since Shane posted a mandelbrot experiment he had lying around here:\n// https://www.shadertoy.com/view/ttscWn\n//\n// I figured I'd do the same. This is a super quick and dirty mandelbrot \n// port from this tutorial: https://youtu.be/zmWkhlocBRY\n\nvec4 _Area;\nfloat _Angle=0., _Color=0., _Repeat, _Speed, _Symmetry, _Time;\n#define T iTime\n#define MAX_ITER 100.\n#define AA 3\n\nvec2 rot(vec2 p, vec2 pivot, float a) {\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n    p += pivot;\n\n    return p;\n}\n\nvec3 Gradient(vec2 p) {\n    // IQ palette idea\n    \n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 0.5);\n    vec3 d = vec3(0.8, 0.9, 0.3);\n    \n\treturn a + b*cos(6.2832*(c*p.x+d));\n}\n\nvec4 Mandelbrot(vec2 uv) {\n    \n    vec2 c = _Area.xy + uv*_Area.zw;\n    c = rot(c, _Area.xy, _Angle);\n\n    float r = 20.; // escape radius\n    float r2 = r * r;\n\n    vec2 z=vec2(0), zPrevious;\n    float iter;\n    for (iter = 0.; iter < MAX_ITER; iter++) {\n        zPrevious = rot(z, vec2(0), T);\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y) + c;\n\n        if (dot(z, zPrevious) > r2) break;\n    }\n    if (iter > MAX_ITER) return vec4(0);\n\n    float dist = length(z); // distance from origin\n    float fracIter = (dist - r) / (r2 - r); // linear interpolation\n    fracIter = log2( log(dist) / log(r) ); // double exponential interpolation\n\n    float m = sqrt(iter / MAX_ITER);\n    vec4 col = sin(vec4(.3, .45, .65, 1)*m*20.)*.5+.5; // procedural colors\n    col = Gradient(vec2(m*_Repeat + T*_Speed, _Color+T*.03)).rgbb;\n\n    float angle = atan(z.x, z.y); // -pi and pi\n    //if(i.uv.x>.5)\n    col *= smoothstep(3., 0., fracIter);\n\n    col *= 1.+sin(angle * 2.+T*4.)*.2;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _Time = iTime;\n    _Repeat = 5.;\n    _Speed = -.2;\n    \n    float scale = 5.581448e-4;\n    _Area = vec4(.3177064,.03223879,scale,scale);\n    \n    vec3 col = vec3(0);\n    for(int x=0;x<AA; x++) {\n        for(int y=0;y<AA; y++) {\n            vec2 offs = vec2(x, y)/float(AA);\n            \n            vec2 uv = (fragCoord+offs)/iResolution.xy;\n\n            col += Mandelbrot(uv).rgb;\n        }}\n    col /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcW8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[551, 551, 590, 590, 724], [726, 726, 749, 772, 957], [959, 959, 985, 985, 1946], [1948, 1948, 2005, 2005, 2484]], "test": "untested"}
{"id": "ttscWn", "name": "Mandelbrot Pattern Decoration", "author": "Shane", "description": "Applying a simple pattern and coloring to a standard iterative Mandelbrot transformation.", "tags": ["julia", "mandelbrot", "complex", "pattern", "imaginary"], "likes": 176, "viewed": 3726, "published": 3, "date": "1591965313", "time_retrieved": "2024-07-30T21:01:33.495741", "image_code": "/*\n\n\n\tMandelbrot Pattern Decoration\n\t-----------------------------\n\n\n\tAfter looking at Fabrice's Mandelbrot derivative example, it occurred\n\tto me that I have a heap of simple Mandelbrot and Julia related \n    demonstrations that I've never gotten around to posting, so here's one \n    of them. I put it together a long time ago using the standard base code, \n    which you'll find in countless examples on the internet. I'm pretty sure \n    I started with IQ's \"Orbit Traps\" shader, which is a favorite amongst \n    many on here, then added a few extra lines to produce the effect you \n\tsee. There's not a lot to this at all, so hopefully, it'll be easy to \n    consume.\n\n    Producing Mandelbrot and Julia patterns is pretty straight forward. At \n    it's core, you're simply transforming each point on the screen in a \n    certain way many times over, then representing the transformed point \n    in the form of shades and colors.\n\n    In particular, you treat each point as if it were on a 2D complex plane, \n    then perform an iterative complex operation -- which, ironically, is not \n    complex at all. :) In this particular example, the iterative complex \n    derivative is recorded also, which is used for a bit of shading.\n\n    In regard to the shading process itself, most people tend to set a \n    bailout, then provide a color based on the transformed point distance,\n\tand leave it at that. However, with barely any extra code, it's \n    possible to makes things look more interesting.    \n\n    The patterns look pretty fancy, but they're nothing more than repeat \n    circles and grid boundaries applied after transforming the coordinates. \n    The shading and highlights were made up on the spot, but none of it was\n    complex, nor was it based on reality (no pun intended).\n\n\t\n\n    Related examples:\n\n    Based on one of IQ's really nice Mandelbrot example. I love the\n    subtle feathering.\n \tMandelbrot - orbit traps -- IQ\n \thttps://www.shadertoy.com/view/ldf3DN\n\n    // Beautiful example.\n\tHeading To The Sun -- NivBehar\n\thttps://www.shadertoy.com/view/wtdSzS\n\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Base color.\n    vec3 col = vec3(0);\n    \n    // Anitaliasing: Just a 2 by 2 sample. You could almost get away with not using\n    // it at all, but it is necessary.\n    #define AA 2\n    for(int j=0; j<AA; j++){\n        for(int i=0; i<AA; i++){\n\n            // Offset centered coordinate -- Standard AA stuff.\n            vec2 p = (fragCoord + vec2(i, j)/float(AA) - iResolution.xy*.5)/iResolution.y;\n            \n            // Time, rotating back and forth.\n            float ttm = cos(sin(iTime/8.))*6.2831;\n           \n            // Rotating and translating the canvas... More effort needs to be put in here,\n            // but it does the job.\n            p *= mat2(cos(ttm), sin(ttm), -sin(ttm), cos(ttm));\n            p -= vec2(cos(iTime/2.)/2., sin(iTime/3.)/5.);\n             \n            \n            // Jump off point and zoom... Where and how much you zoom in greatly effects what\n            // you see, so I probably should have put more effort in here as well, but this\n            // shows you enough.\n            float zm = (200. + sin(iTime/7.)*50.);\n            vec2 cc = vec2(-.57735 + .004, .57735) + p/zm;\n \n\n            // Position and derivative. Initialized to zero.\n            vec2 z = vec2(0), dz = vec2(0);\n\n            // Iterations: Not too many. You could get away with fewer, if need be.\n            const int iter = 128;\n            int ik = 128; // Bail out value. Set to the largest to begin with.\n            vec3 fog = vec3(0); //vec3(.01, .02, .04);\n             \n            for(int k=0; k<iter; k++){\n\n\n                // Derivative: z' = z*z'*2. + 1.\n                // Imaginary partial derivatives are similar to real ones.\n                dz = mat2(z, -z.y, z.x)*dz*2. + vec2(1, 0); // A better way. Thanks, Fabrice. :)\n                //dz = vec2(z.x*dz.x - z.y*dz.y, z.x*dz.y + z.y*dz.x)*2. + vec2(1, 0);\n              \n                \n                // Position: z = z*z + c.\n                // Squaring an imaginary point is slightly different to squaring a real\n                // one, but at the end of the day, it's just a transformation.\n                z =  mat2(z, -z.y, z.x)*z + cc;\n                //z = (vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y)) + cc;\n                \n                \n                // Experimental transformation with twisting... It's OK, but I wasn't\n                // feeling it.\n                //float l = (float(k)/500.);\n                //z = mat2(cos(l), sin(l), -sin(l), cos(l))*mat2(z, -z.y, z.x)*z + cc;\n \n               \n                // If the length (squared to save cycles) of the transformed point goes \n                // out of bounds, break. In layperson's terms, points that stay within \n                // the set boundaries longer appear brighter... or darker, depending what\n                // you're trying to achieve.\n                if(dot(z, z) > 1./.005){\n                    ik = k; // Record the break number, or however you say it.\n                    break;\n                }\n                \n            }\n            \n            \n            \n            // Lines and shading. There'd be a few ways to represent a boundary line, and\n            // I'd imagine there'd be better ways than this, but it works, so it'll do.\n            float ln = step(0., length(z)/15.5  - 1.);\n            \n            \n            // Distance... shade... It's made up, but there's a bit of logic there. Smooth \n            // coloring involves the log function. I remember reading through a proof a few \n            // years back, when I used to like that kind of thing. It made sense at the time. :)\n            float d = sqrt(1./max(length(dz), .0001))*log(dot(z, z));\n            // Mapping the distance from zero to one.\n            d = clamp(d*50., 0., 1.); \n            \n            // Flagging successive layers. You can use this to reverse directions, alternate\n            // colors, etc.\n            float dir = mod(float(ik), 2.)<.5? -1. : 1.;\n            \n            // Layer coloring and shading. Also made up.\n            float sh = (float(iter - ik))/float(iter); // Shade.\n            vec2 tuv = z/320.; // Transformed UV coordinate.\n            \n            // Rotating the coordinates, based on the global canvas roations and distance\n            // for that parallax effect to aid the depth illusion.\n            float tm = (-ttm*sh*sh*16.);\n            // Rotated, repeat coordinates.\n            tuv *= mat2(cos(tm), sin(tm), -sin(tm), cos(tm));\n            tuv = abs(mod(tuv, 1./8.) - 1./16.); \n          \n            // Rendering a grid of circles, and showing the grid boundaries. Anything is \n            // possible here: Truchets, Voronoi, etc.\n            float pat = smoothstep(0., 1./length(dz), length(tuv) - 1./32.);\n            pat = min(pat, smoothstep(0., 1./length(dz), abs(max(tuv.x, tuv.y) - 1./16.) - .04/16.));\n            \n            // Coloring the layer. These are based on the shaded distance value, but you can\n            // choose anything you want.\n            //vec3 lCol = (.55 + .45*cos(6.2831*(d*d)/3. + vec3(0, 1, 2) - 4.))*1.25;\n            vec3 lCol = pow(min(vec3(1.5, 1, 1)*min(d*.85, .96), 1.), vec3(1, 3, 16))*1.15;\n            \n            // Appolying the circular grid pattern to the color, based on successive layer count.\n            // We're also applying a boundary line.\n            lCol = dir<.0? lCol*min(pat, ln) : (sqrt(lCol)*.5 + .7)*max(1. - pat, 1. - ln);\n            \n            \n            \n            // A fake unit direction vector to provide a fake reflection vector in order\n            // to produce a fake glossy diffuse value for fake highlights. The knowledge\n            // behind all this is also fake. :D\n            vec3 rd = normalize(vec3(p, 1.));\n            rd = reflect(rd, vec3(0, 0, -1));\n            // Synchronizing the gloss movement... It wasn't for me.\n            // rd.xy = mat2(cos(tm), sin(tm), -sin(tm), cos(tm))*rd.xy; \n            float diff = clamp(dot(z*.5 + .5, rd.xy), 0., 1.)*d;\n            \n            \n            // Fake reflective pattern, which has been offset slightly, and moved in a \n            // reflective manner.\n            tuv = z/200.;\n            tm = -tm/1.5 + .5;\n            tuv *= mat2(cos(tm), sin(tm), -sin(tm), cos(tm));\n            tuv = abs(mod(tuv, 1./8.) - 1./16.); \n            pat = smoothstep(0., 1./length(dz), length(tuv) - 1./32.);\n            pat = min(pat, smoothstep(0., 1./length(dz), abs(max(tuv.x, tuv.y) - 1./16.) - .04/16.));\n\n            \n            // Adding the fake gloss. The \"ln\" variable is there to stop the gloss from \n            // reaching the outer fringe, since I thought that looked a little better.\n            lCol += mix(lCol, vec3(1)*ln, .5)*diff*diff*.5*(pat*.6 + .6);\n            \n            // Swizzling the color on every sixth layer -- I thought it might break up the\n            // orange and red a little.\n            if (mod(float(ik), 6.)<.5) lCol = lCol.yxz;\n            lCol = mix(lCol.xzy, lCol, d/1.2); // Shade based coloring, for something to do.\n            \n            // This was a last minute addition. I put some deep black lined fringes on the layers\n            // to add more illusion of depth. Comment it out to see what it does.\n            lCol = mix(lCol, vec3(0), (1. - step(0., -(length(z)*.05*float(ik)/float(iter)  - 1.)))*.95);\n           \n            // Applying the fog.\n            lCol = mix(fog, lCol, sh*d);\n            \n             \n            // Used for colored fog.\n            //lCol *= step(0., d - .25/(1. + float(ik)*.5));\n            \n            // Applying the color sample.\n            col += min(lCol, 1.);\n        }\n    }\n    \n    // Divide by the sample number.\n\tcol /= float(AA*AA);\n    \n    \n    // Toning down the highlights... but I'm going to live on the edge and leave it as is. :D\n    //col = (1. - exp(-col))*1.25;\n    \n     // Subtle vignette.\n    vec2 uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./8.)*1.15;\n    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttscWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wtfcWH", "name": "Crystallize", "author": "indere", "description": "Inspired by  https://thebookofshaders.com/12/\n\n", "tags": ["crystallizevoronoi"], "likes": 5, "viewed": 505, "published": 3, "date": "1591955109", "time_retrieved": "2024-07-30T21:01:34.255709", "image_code": "const float min_scale = 10.0;\nconst float max_scale = 200.0;\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float scale = min_scale + (max_scale - min_scale) * (0.5 + sin(iTime * 0.677) * 0.5);\n    vec2 st = fragCoord / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    \n    st *= scale;\n    \n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    float m_dist = 100.;  // minimum distance\n    vec2 uv = st;\n    for(int y = -1; y <= 1; ++y){\n        for(int x = -1; x <= 1; ++x){\n        \tvec2 neighbor = vec2(float(x),float(y));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            // Keep the closer distance\n            if(dist < m_dist){\n            \tm_dist = dist;\n                uv = st + diff;\n            }\n        }\n    }\n    \n    \n    uv /= scale;\n    uv.x /= iResolution.x / iResolution.y;\n    vec3 color = texture(iChannel0, uv).rgb;\n    //color += m_dist;\n    \n    //center\n    //color += 1.-step(.06, m_dist);\n    \n    //color.r +=  step(0.98, f_st.x) + step(0.98, f_st.y);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 86, 86, 179], [182, 182, 239, 239, 1342]], "test": "untested"}
{"id": "tlXyWH", "name": "Shaggy Feeder", "author": "dr2", "description": "Hairy critter that eats grass, shoots, roots and leaves...", "tags": ["hair", "fur", "animal"], "likes": 8, "viewed": 455, "published": 3, "date": "1591950095", "time_retrieved": "2024-07-30T21:01:35.013682", "image_code": "// \"Shaggy Feeder\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Hairy critter that eats grass, shoots, roots and leaves...\n\n// Learned hairstyling from \"furball\" by simesgreen \n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat dstFar, tCur, tRot, rBall, furThk;\nconst float pi = 3.1415927;\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  float b, d;\n  d = dstFar;\n  b = dot (rd, ro);\n  d = b * b + rBall * rBall - dot (ro, ro);\n  return (d > 0.) ? - b - sqrt (d) : dstFar;\n}\n\nvec3 FurPos (vec3 p)\n{\n  float s, t;\n  s = length (p);\n  p /= s;\n  t = 1. + (s - rBall) / furThk;\n  p.xz = Rot2D (p.xz, 0.5 * t * sin (2. * pi * tRot));\n  return vec3 (atan (p.z, p.x), acos (p.y) - 0.3 * t, s);\n}\n\nfloat FurDens (vec3 q)\n{\n  vec2 s;\n  s = Noisev2v2 (96. * q.xy);\n  return smoothstep (0.3, 1., s.x) * smoothstep (1., 1.2, s.y - (q.z - rBall) / furThk);\n}\n\nvec3 FurCol (vec3 ro, vec3 rd, vec3 col)\n{\n  vec4 col4, c4;\n  vec3 p, q, vn;\n  vec2 e;\n  float d;\n  const float nLay = 96.;\n  furThk = 0.2;\n  rBall = 1.;\n  d = BallHit (ro, rd);\n  col4 = vec4 (0.);\n  if (d < dstFar) {\n    p = ro + (d + 0.001) * rd;\n    p.xz = Rot2D (p.xz, 0.5 * sin (2. * pi * tRot + 0.5 * pi));\n    for (float j = 0.; j < nLay; j ++) {\n      q = FurPos (p);\n      c4.a = (j < nLay - 1. || q.z > rBall - furThk) ? FurDens (q) : 1.;\n      if (c4.a > 0.) {\n        e = vec2 (0.01, 0.);\n        vn = normalize (c4.a - vec3 (FurDens (FurPos (p + e.xyy)),\n           FurDens (FurPos (p + e.yxy)), FurDens (FurPos (p + e.xxy))));\n        c4.rgb = mix (vec3 (0.7, 0.4, 0.2), vec3 (0.3, 0.3, 0.5),\n           smoothstep (0.4, 0.6, Fbm2 (16. * q.xy)));\n        c4.rgb = c4.rgb * (0.5 + 0.5 * max (0., dot (vn, sunDir)));\n        c4.rgb *= c4.a * (0.6 + 0.4 * smoothstep (0.3, 0.7, (q.z - (rBall - furThk)) / furThk));\n        col4 += c4 * (1. - col4.a);\n      }\n      p += (2. * furThk / nLay) * rd;\n      if (p.y < 0.02 || col4.a > 0.95 || q.z > rBall) break;\n    }\n  }\n  if (col4.a > 0.95) col = col4.rgb;\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, trCol, vn, gPos;\n  vec2 vf;\n  float dstGrnd, dMove, s, bRad, f, w;\n  dMove = 0.1 * tCur;\n  if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    gPos = ro + vec3 (0., 0., dMove);\n    vf = vec2 (8., 4. * (1. - smoothstep (0.5, 0.9, dstGrnd / dstFar)));\n    col = mix (vec3 (0.4, 0.5, 0.3), vec3 (0., 0.5, 0.1),\n       smoothstep (0.2, 0.8, Fbm2 (8. * gPos.xz)));\n    w = 0.1 * (Noisefv2 (8. * gPos.xz) - 0.5);\n    if (ro.z < 0. && abs (gPos.x) < 0.8 + w) {\n      f = Fbm2 (32. * gPos.xz);\n      trCol = vec3 (0.6, 0.7, 0.1) * (0.5 + 0.5 * f);\n      bRad = 0.1 + 0.15 * Fbm1 (floor ((gPos.z + 1.) / 2.));\n      s = length (vec2 (gPos.x, mod (gPos.z + 1., 2.) - 1.));\n      if (s < bRad) {\n        trCol = mix (vec3 (0.1 + 0.2 * f, 0., 0.), trCol, smoothstep (-0.04, 0., s - bRad));\n        vf = vec2 (8., 8.);\n      } else vf = vec2 (16., 1.);\n      col = mix (trCol, col, smoothstep (0.75, 0.8, abs (gPos.x) - w));\n    }\n    col *= 0.9 + 0.1 * smoothstep (0.8, 0.9, length (ro.xz));\n    col = mix (vec3 (0.2, 0.5, 0.2), col,  1. - smoothstep (0.5, 0.9, dstGrnd / dstFar));\n    if (vf.x > 0.) vn = VaryNf (vf.x * gPos, vn, vf.y);\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n    col = mix (0.8 * col, vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  col = FurCol (ro, rd, col);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.17 * pi;\n  tRot = 0.4 * tCur;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el += 0.08 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n  dstFar = 50.;\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v2 (vec2 p)\n{\n  return vec2 (Noisefv2 (p), Noisefv2 (p + vec2 (17., 23.)));\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyWH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[520, 520, 554, 554, 693], [695, 695, 717, 717, 907], [909, 909, 933, 933, 1064], [1066, 1066, 1108, 1108, 2197], [2199, 2199, 2233, 2233, 2993], [2995, 2995, 3030, 3030, 4455], [4457, 4457, 4513, 4513, 5250], [5252, 5252, 5288, 5288, 5494], [5496, 5496, 5526, 5526, 5639], [5673, 5673, 5697, 5697, 5750], [5752, 5752, 5776, 5776, 5906], [5908, 5908, 5933, 5933, 6079], [6081, 6081, 6106, 6106, 6292], [6294, 6294, 6319, 6319, 6383], [6385, 6385, 6407, 6407, 6561], [6563, 6563, 6584, 6584, 6739], [6741, 6741, 6770, 6770, 6982], [6984, 6984, 7023, 7023, 7203]], "test": "untested"}
{"id": "3lfcDH", "name": "reaction diffusion grid", "author": "mds2", "description": "first creates an abstract grid of rectangles, then runs a reaction-diffusion (based on rock-paper-scissors replicator dynamics) in each cell.", "tags": ["abstract", "diffusion", "feedback", "reaction"], "likes": 6, "viewed": 477, "published": 3, "date": "1591923551", "time_retrieved": "2024-07-30T21:01:35.768664", "image_code": "#define EXAGGERATE 0 // set to 1 to wildly exagerate color diffs\n#define MAP_THROUGH_TEX 0 // set to 1 to map texture through texture\n#define EXTRA_MASK 0\n\nconst vec3 base_color = vec3(0.4, 0.2, 0.0);\nconst float base_color_weight = 0.0;\n\nconst mat3 color_xform = mat3(1.0, 0.5, 0.0,\n                              0.8, 0.2, 0.0,\n                              0.2, 0.2, 1.0);\n\n// most fun stuff to modify is in \"Buffer B\"\n// click that tab and start hacking.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    float mag_mask = smoothstep(0.0, 0.1, length(col));\n#if EXTRA_MASK\n    mag_mask *= smoothstep(0.2, 0.6, col.r + 0.25 * col.g);\n#endif\n    \n    col = 2.0 * col - 0.5;\n    \n#if EXAGGERATE\n    col = sin(7.0 * col);\n#endif\n\n#if MAP_THROUGH_TEX\n    col = texture(iChannel1, col).rgb;\n#else\n    col = 0.5 * col;\n    col = transpose(color_xform) * col;\n#endif\n    \n    \n\n    col = mix(col, base_color, base_color_weight);\n    \n    col = col * mag_mask;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\nvec2 fetch_dir(in vec2 in_pixels) {\n    vec2 dir = texture(iChannel0, to_uv(in_pixels)).rg;\n    dir = step(vec2(0.5), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n    return dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    float refresh_period = 25.0 * iResolution.y / 300.0;\n    float t = iTime - mod(iTime, refresh_period);\n    mat2 rotator = mat2(cos(t), sin(t),\n                          -sin(t), cos(t));\n    vec2 dir = step(vec2(0.985), texture(iChannel1, to_uv(rotator * p)).rg);\n    dir = vec2(step(dir.y, dir.x), step(dir.x, dir.y)) * dir;\n \n    if (mod(iTime, refresh_period) < 0.1) {\n      fragColor = vec4(dir, 0.0, 1.0);\n        return;\n    }\n   \n    if (dot(dir, dir) < 0.5) {\n\t    dir = step(vec2(0.9), texture(iChannel0, to_uv(p)).rg);\n    }\n     \n    if (dot(dir, dir) < 0.01) {\n    \tvec2 dir1 = vec2(1.0, 0.0);\n    \tvec2 dir2 = dir1.yx;\n        \n        \n    \tfloat val1 = max(abs(dot(dir1, fetch_dir(p + dir1))),\n                     \tabs(dot(dir1, fetch_dir(p - dir1))));\n        \n            \n    \tfloat val2 = max(abs(dot(dir2, fetch_dir(p + dir2))),\n        \t             abs(dot(dir2, fetch_dir(p - dir2))));\n        \n    \t\n        if (val1 > val2) {\n            val2 = 0.0;\n        } else {\n            val1 = 0.0;\n        }\n        \n        val1 = step(0.9, val1);\n        val2 = step(0.9, val2);\n        \n    \n    \tdir = mix(dir, dir1, val1);\n    \tdir = mix(dir, dir2, val2);\n    }\n    \n    dir = step(vec2(0.9), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n \n    fragColor = vec4(dir,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define ERODE 1\n#define CHAOS_FILL 0 // set to 1 for more interesting fill patterns.  Looks very nice with color_to_val_3\n\nconst float diffuse_weight = 0.75; // higher means less diffusion.  set greater than 0 and less than 1\nconst float react_weight = 0.25; // reaction speed : don't exceed 0.25.  higher is faster reaction\n\n// in the function \"greatest\" there are two calls to \"color_to_val_4\"\n// change those to \"color_to_val_1\", \"color_to_val_2\" etc to get different effects\n\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec2 dir = step(vec2(0.98), texture(iChannel0, to_uv(p)).rg);\n\n    if (dot(dir, dir) > 0.81) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    float refresh_period = 25.0 * iResolution.y / 300.0;\n    \n    vec4 color = texture(iChannel2, to_uv(p));\n    \n    // color.rg = mod(10.0 * to_uv(p), vec2(1.0));\n    color.b = 1.0 - 0.5 * color.r - 0.5 * color.g;\n    \n    \n    if (mod(iTime, refresh_period) + 0.05 < 0.15 * refresh_period) { // about 3 frames at 60 fps\n\t    fragColor = vec4(1.0);\n        return;\n    }\n\n    if (mod(iTime, refresh_period) < 0.15 * refresh_period) {\n\t    fragColor = vec4(color.rgb, 1.0);\n        return;\n    }\n   \n    \n    color = diffuse_weight * texture(iChannel1, to_uv(p));\n    \n    float w = 0.25 * (1.0 - diffuse_weight);\n    color = color +  w * texture(iChannel1, to_uv(p + vec2(1.1, 0.0)));\n    color = color +  w * texture(iChannel1, to_uv(p + vec2(0.0, 1.1)));\n    color = color +  w * texture(iChannel1, to_uv(p - vec2(1.1, 0.0)));\n    color = color +  w * texture(iChannel1, to_uv(p - vec2(0.0, 1.1)));\n    \n#if ERODE\n    color.a = 1.0;\n#endif\n\n    color = color / color.a;\n    \n    color.rgb = color.rgb + react_weight * (1.0 * color.rgb * color.gbr - color.rgb * color.brg);//  + 0.005;\n    \n    float delta = 1.5 - dot(color.rgb, vec3(1.0));\n\n    color += 0.005 * delta;\n    \n \n    fragColor = vec4(color.rgb,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[459, 459, 516, 566, 1194]], "test": "untested"}
{"id": "3tfyWH", "name": "Continents and oceans", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/tlXyz7#]\"Cratered desert planet\"[/url] shader. It's a small planet with several continents and oceans with moving water.", "tags": ["raymarching", "planet"], "likes": 2, "viewed": 322, "published": 3, "date": "1591906902", "time_retrieved": "2024-07-30T21:01:36.520653", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nconst float planet_size = 10000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\nvec3 final_color;\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\nvec3 water_color(vec3 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy)/10.0;\n    // Time varying pixel color\n    vec2 col = (uv*10.0);\n    for(float i = 1.0; i <6.0; i++){\n        uv += col;\n        col = cos(uv.yx*i+fragCoord.z);\n    }\n    // Output to screen\n    return vec3(col,1.0)/2.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat carve(vec3 p,float size) {\n    //p += sin(p/size);\n    //p += (sin(p.x+p.y+p.z));\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n\t//size += sin((p.x+p.y+p.z));\n    //p += sin(p/size);\n    return sin(p.x)+sin(p.y)+sin(p.z);\n}\n\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\n\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat planet_surface(vec3 p){\n return length(p)-planet_size+dunes(p,0.2)*0.05;\n}\n\nfloat caves(vec3 p,float iterations){\n    //p += sin(p/17.0);\n    p /= 100.0;\n    float to_return = carve(p,1.0);\n    for(float i = 2.0; i <iterations; i++){\n        p += p.yzx+sin(p/i);\n        //p += sin(p)-cos(p);\n        p /= i;\n        to_return += carve(p,i);\n    }\n    return to_return-length(sin(p));\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float thing1 = max(planet_surface(p),-caves(p,5.0));\n    vec3 p2 = sin((p)/200.0+vec3(iTime*3.0))*100.0;\n    float p1 = length(p2);\n    float thing2 = planet_surface(p) + 100.0+p1;\n    float result = min(thing1, thing2);\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    if(result == thing1){\n    \tfinal_color = surface_color(p*scale);\n    }\n    else if(result == thing2){\n    \tfinal_color = water_color(p*scale);\n    }\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(1.2+.2*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = final_color;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 338, 338, 476], [478, 478, 512, 562, 813], [1056, 1056, 1088, 1324, 1365], [1368, 1368, 1406, 1406, 1481], [1483, 1483, 1520, 1520, 1579], [1581, 1581, 1610, 1610, 1661], [1663, 1663, 1700, 1724, 1973], [1976, 1976, 2000, 2000, 2483], [2485, 2906, 2997, 2997, 3309], [3324, 3578, 3643, 3643, 3775], [3777, 3866, 3895, 3895, 4205], [4207, 4699, 4839, 4839, 5449], [5451, 5821, 5906, 5906, 6678], [6680, 7007, 7056, 7091, 7222], [7224, 7224, 7281, 7281, 8251]], "test": "untested"}
{"id": "WtfyD8", "name": "Pixel graphics \"ПТО\"", "author": "tanya", "description": "pixelgraphics", "tags": ["pixelgraphics"], "likes": 1, "viewed": 274, "published": 3, "date": "1591899130", "time_retrieved": "2024-07-30T21:01:37.274637", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nfloat box(float x,float y) {\n\treturn 1.0 - max(abs(x),abs(y));\n}\n\n\nvec2 rotate(float a,vec2 v) {\n\tfloat c_a = cos(a);\n\tfloat s_a = sin(a);\n\tfloat x1 = v.x * c_a + v.y * s_a;\n\tfloat y1 = v.x * -s_a + v.y * c_a;\n\tv.x = x1;\n\tv.y = y1;\n    return v;\n}\nvec2 scale(float s1,float s2,vec2 v) {\n\tv.x /= s1;\n\tv.y /= s2;\n    return v;\n}\n\n\nvec2 translate(vec2 dv,vec2 v) {\n\tv.x -= dv.x;\n\tv.y -= dv.y;\n    return v;\n}\nvec2 shearx(float t,vec2 v)\n{\n   v.x -= v.y*t;return v;\n}\n\nvec2 sheary(float t,vec2 v)\n{\n   v.y -= v.x*t;return v;\n}\nfloat axes(float x, float y)\n{\n    float axis_y;\n    float axis_x;\n    if(abs(x)< 0.1) axis_y=1.0;\n    if(abs(y)< 0.1) axis_x=1.0;\n    return   axis_y+axis_x;           \n}\n\nfloat grid(float x, float y)\n{\n    float grid_y = 0.0;\n    float grid_x = 0.0;\n    if(abs(mod(x,1.0)) < 0.2) grid_x=1.0;\n    if(abs(mod(y,1.0)) < 0.2) grid_y=1.0;\n    return (grid_y+grid_x)/4.0;\n}\nfloat drawP(float x, float y)\n{\n \tvec2 left = vec2(x, y);\n    left = translate(vec2(-21, 13), left);\n\tleft = scale(2.0, 10.0, left);\n\tfloat leftP = box(left[0], left[1]);\n\n\tvec2 right = vec2(x, y);\n\tright = translate(vec2(-5, 13), right);\n\tright = scale(2.0, 10.0, right);\n\tfloat rightP = box(right[0], right[1]);\n\n\tvec2 top = vec2(x, y);\n\ttop = translate(vec2(-13, 21), top);\n\ttop = rotate(PI / 2.0, top);\n\ttop = scale(2.0, 9.0, top);\n\tfloat topP = box(top[0], top[1]);\n\n\n\treturn \n       max (leftP,max(rightP,(topP))); \n}\n\n\nfloat drawT(float x, float y)\n{\n \tvec2 center = vec2(x, y);\n    center = translate(vec2(21, 13), center);\n\tcenter = scale(2.0, 10.0, center);\n\tfloat centerT = box(center[0], center[1]);\n\t\n\tvec2 top = vec2(x, y);\n\ttop = translate(vec2(21, 21), top);\n\ttop = rotate(PI / 2.0, top);\n\ttop = scale(2.0, 9.0, top);\n\tfloat topT = box(top[0], top[1]);\n\n\n\treturn \n       max (centerT,(topT)); \n}\n\n\nfloat drawO(float x, float y)\n{\n \tvec2 left = vec2(x, y);\n    left = translate(vec2(21, -13), left);\n\tleft = scale(2.0, 10.0, left);\n\tfloat leftO = box(left[0], left[1]);\n\n\tvec2 right = vec2(x, y);\n\tright = translate(vec2(5, -13), right);\n\tright = scale(2.0, 10.0, right);\n\tfloat rightO = box(right[0], right[1]);\n\n\n\tvec2 top = vec2(x, y);\n\ttop = translate(vec2(13, -5), top);\n\ttop = rotate(PI / 2.0, top);\n\ttop = scale(2.0, 9.0, top);\n\tfloat topO = box(top[0], top[1]);\n    \n    vec2 down = vec2(x, y);\n\tdown = translate(vec2(13, -21), down);\n\tdown = rotate(PI / 2.0, down);\n\tdown = scale(2.0, 9.0, down);\n\tfloat downO = box(down[0], down[1]);\n\n\n\treturn \n       max (leftO,max(rightO,max(topO,(downO)))); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wmax=max(iResolution.x,iResolution.y);\n    float aspect =iResolution.y/iResolution.x;\n    vec2  vnorm = vec2(wmax,wmax);   \n    vec2 uv = fragCoord/vnorm ; \n    float x=uv.x;\n    float y=uv.y;\n\n    x *=100.0;\n    y *=100.0;\n    \n    x -=50.0;\n    y -=50.0*aspect;\n    \n\n    float grid =  max(grid(x,y), axes(x,y))/2.0;\n\n    float f = drawP(x,y)/10.0;\n    f = max(f, drawT(x,y)/10.0);\n     f = max(f, drawO(x,y)/10.0);\n    f = 0.01/f; \n    vec3 col = vec3(0.0,grid,0.0);\n\n    if(f >= 0.0)col.x =  f;\n    else      col.z = -f;\n    fragColor = vec4(col,1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 81, 81, 117], [120, 120, 149, 149, 300], [301, 301, 339, 339, 379], [382, 382, 414, 414, 458], [459, 459, 488, 488, 516], [518, 518, 547, 547, 575], [576, 576, 606, 606, 747], [749, 749, 779, 779, 945], [946, 946, 977, 977, 1469], [1472, 1472, 1503, 1503, 1857], [1860, 1860, 1891, 1891, 2568], [2569, 2569, 2626, 2626, 3193]], "test": "untested"}
{"id": "3tfyD8", "name": "modern art", "author": "mds2", "description": "Creates an abstract grid of brightly colored irregular rectangles.  What else would it do?\n\nBased on a modification of an earlier shader : https://www.shadertoy.com/view/4lffWs", "tags": ["abstract", "feedback", "creative"], "likes": 10, "viewed": 437, "published": 3, "date": "1591898565", "time_retrieved": "2024-07-30T21:01:38.039592", "image_code": "// most fun stuff to modify is in \"Buffer B\"\n// click that tab and start hacking.\n\n#define INTENSIFY_COLOR 0\n#define DISTORT_INTENSE_COLORS 0\n\nvec3 color_blowout(in vec3 col)\n{\n    mat3 blowout = mat3(4.72376,  -8.85515,   3.84846,\n                        -8.85515,  18.4378,   -8.71892,\n                        3.84846,  -8.71892,   4.48226);\n    vec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n\n    \n    vec3 dir = col - cent; // blowout * (col - cent);\n    \n#if DISTORT_INTENSE_COLORS\n    dir = blowout * dir;\n#endif\n    \n    vec3 maxes = (step(vec3(0.0), dir) - col)/dir;\n    \n    float amount = min(maxes.x, min(maxes.y, maxes.z));\n    \n    col = col + dir * amount;\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n#if INTENSIFY_COLOR\n    col = color_blowout(col);\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MORE_VISUAL_INTEREST_IN_CENTER 1 // set to 0 to make better images for tiling\n// set to 1 for visually interesting variation in density\n\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\nvec2 fetch_dir(in vec2 in_pixels) {\n    vec2 dir = texture(iChannel0, to_uv(in_pixels)).rg;\n    dir = step(vec2(0.5), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n    return dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    float refresh_period = 15.0 * iResolution.y / 300.0;\n    float t = iTime - mod(iTime, refresh_period);\n    mat2 rotator = mat2(cos(t), sin(t),\n                          -sin(t), cos(t));\n    vec2 center = abs(p.xy - vec2(0.5) * iResolution.yx);\n    vec2 thresh = vec2(0.9875);\n#if MORE_VISUAL_INTEREST_IN_CENTER\n    vec2 distorted = 1.5 * iResolution.yx - 0.5 * iResolution.xy;\n    thresh = thresh - vec2(0.03, 0.005) * smoothstep(0.4 * distorted.y, 0.0, center.y) * smoothstep(0.4 * distorted.x, 0.0, center.x);\n#else\n    // thresh = thresh - 0.0075;\n#endif\n    vec2 dir = step(thresh, texture(iChannel1, to_uv(rotator * p)).rg);\n    dir = vec2(step(dir.y, dir.x), step(dir.x, dir.y)) * dir;\n \n    if (mod(iTime, refresh_period) < 0.1) {\n      fragColor = vec4(dir, 0.0, 1.0);\n        return;\n    }\n   \n    if (dot(dir, dir) < 0.5) {\n\t    dir = step(vec2(0.9), texture(iChannel0, to_uv(p)).rg);\n    }\n     \n    if (dot(dir, dir) < 0.01) {\n    \tvec2 dir1 = vec2(1.0, 0.0);\n    \tvec2 dir2 = dir1.yx;\n        \n        \n    \tfloat val1 = max(abs(dot(dir1, fetch_dir(p + dir1))),\n                     \tabs(dot(dir1, fetch_dir(p - dir1))));\n        \n            \n    \tfloat val2 = max(abs(dot(dir2, fetch_dir(p + dir2))),\n        \t             abs(dot(dir2, fetch_dir(p - dir2))));\n        \n    \t\n        if (val1 > val2) {\n            val2 = 0.0;\n        } else {\n            val1 = 0.0;\n        }\n        \n        val1 = step(0.9, val1);\n        val2 = step(0.9, val2);\n        \n    \n    \tdir = mix(dir, dir1, val1);\n    \tdir = mix(dir, dir2, val2);\n    }\n    \n    dir = step(vec2(0.9), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n \n    fragColor = vec4(dir,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define CHAOS_FILL 1 // set to 1 for more interesting fill patterns.  Looks very nice with color_to_val_3\n\n// in the function \"greatest\" there are two calls to \"color_to_val_4\"\n// change those to \"color_to_val_1\", \"color_to_val_2\" etc to get different effects\n\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\nvec2 fetch_dir(in vec2 in_pixels) {\n    vec2 dir = texture(iChannel0, to_uv(in_pixels)).rg;\n    dir = step(vec2(0.5), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n    return dir;\n}\n\n// favors slightly more garish primary colors than color_to_val_2\nfloat color_to_val_1(in vec3 color) {\n    vec3 radial = color - vec3(1.0) * dot(color, vec3(1.0))/3.0;\n    return length(radial);\n}\n\n// favors solid primary colors\nfloat color_to_val_2(in vec3 color) {\n    return  max(abs(color.r - color.g), max(abs(color.g - color.b), abs(color.b - color.r)));\n}\n\n// produces a pastel palette\nfloat color_to_val_3(in vec3 color) {\n    return length(color);\n}\n\n// produces a pleasing, miami, cyan-magenta-yellow thing\nfloat color_to_val_4(in vec3 color) {\n    return color_to_val_1(color) + color_to_val_3(color);\n}\n\nfloat color_to_val_cmy(in vec3 color) {\n    vec3 pair_mins = min(color.rgb, color.gbr);\n    float second = max(pair_mins.r, max(pair_mins.g, pair_mins.b));\n    float last = min(pair_mins.r, min(pair_mins.g, pair_mins.b));\n    return second - last;\n}\n\nfloat color_to_val_5(in vec3 color) {\n    return color_to_val_cmy(color) + 2.0 * color_to_val_2(color);\n}\n\nvec3 greatest(in vec3 color1, in vec3 color2) {\n    float val1 = color_to_val_3(color1);\n    float val2 = color_to_val_3(color2);\n#if CHAOS_FILL\n    return mix(color1, color2, smoothstep(val1 - 0.05, val1 + 0.05, val2));\n#else\n    return mix(color1, color2, step(val1, val2));\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec2 dir = step(vec2(0.98), texture(iChannel0, to_uv(p)).rg);\n\n    if (dot(dir, dir) > 0.81) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    float refresh_period = 15.0 * iResolution.y / 300.0;\n    \n    float t = iTime - mod(iTime, refresh_period);\n    mat2 rotator = mat2(cos(t), -sin(t),\n                          sin(t), cos(t));\n    vec3 color = texture(iChannel2, to_uv(rotator * p)).rgb;\n    \n    \n    if (mod(iTime, refresh_period) + 0.05 < 0.3 * refresh_period) { // about 3 frames at 60 fps\n\t    fragColor = vec4(1.0);\n        return;\n    }\n\n    if (mod(iTime, refresh_period) < 0.3 * refresh_period) {\n\t    fragColor = vec4(color, 1.0);\n        return;\n    }\n   \n    \n    \n    \n    color = greatest(color, texture(iChannel1, to_uv(p + vec2(1.1, 0.0))).rgb);\n    color = greatest(color, texture(iChannel1, to_uv(p - vec2(1.1, 0.0))).rgb);\n    color = greatest(color, texture(iChannel1, to_uv(p + vec2(0.0, 1.1))).rgb);\n    color = greatest(color, texture(iChannel1, to_uv(p - vec2(0.0, 1.1))).rgb);\n    color = greatest(color, texture(iChannel1, to_uv(p + vec2(1.1, 1.1))).rgb);\n    color = greatest(color, texture(iChannel1, to_uv(p - vec2(1.1, 1.1))).rgb);\n    color = greatest(color, texture(iChannel1, to_uv(p + vec2(1.1, -1.1))).rgb);\n    color = greatest(color, texture(iChannel1, to_uv(p - vec2(1.1, -1.1))).rgb);\n \n    fragColor = vec4(color,1.0);\n}", "buffer_b_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 176, 176, 739], [741, 741, 798, 848, 1084]], "test": "untested"}
{"id": "WlfcW8", "name": "fun hacking of mainImage :-p", "author": "FabriceNeyret2", "description": "Do you get what happens ? :-p\n\n( this hack can have more serious uses like auto-antialiasing and profiling )\nMore deceiving shaders: [url]https://www.shadertoy.com/results?query=deceiving[/url]", "tags": ["glsl", "shadertoy", "hack", "macro", "deceiving"], "likes": 6, "viewed": 679, "published": 3, "date": "1591896127", "time_retrieved": "2024-07-30T21:01:38.841448", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define mainImage(O,U)                            \\\n    mainImage( O, U*2.+ .3*iResolution.xy*iTime); \\\n    color = 1.-color;", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 0x2F246191AB8608F48E262AA04820682D06FF8240000A80D6160989AE3510076031DF161761376A90842FFA00009312E50C0AE2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 140]], "test": "untested"}
{"id": "3tXcW8", "name": "[TWITCH] Lunar Quadrant Glitch", "author": "evvvvil", "description": "Lunar Quadrant Glitch - Influenced by the work of flopine and yx aka Luna, You ladies rock!\nResult of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["fractal", "demoscene", "abstract", "glitch", "glitch", "glow", "rotating", "gyroscope", "easing", "lunar", "twitch", "improv", "flopine", "yx"], "likes": 15, "viewed": 805, "published": 3, "date": "1591894738", "time_retrieved": "2024-07-30T21:01:39.602413", "image_code": "// Lunar Quadrant Glitch - Result of an improvised live code session on Twitch\n\n// Influenced by the work of flopine and yx aka Luna, you ladies rock!\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"I've had more prime ministers than Madonna had number one hits.\" - Queen Elizabeth II\n\nvec2 z,v,e=vec2(.0035,-.0035),gpo=vec2(0),gl=vec2(0);float t,tt,b,bb,pi,g,gg,ti;vec3 op,np,bp,cp,pp,po,no,al,ld;\nfloat cx(vec3 p,vec3 r){return max(abs(length(p.yz)-r.x)-r.y,abs(p.x)-r.z);}\nfloat cz(vec3 p,vec3 r){return max(abs(length(p.xy)-r.x)-r.y,abs(p.z)-r.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n} \nfloat tick(float t){\n  t=fract(t/40.);\n  t=smoothstep(0.,1.,t);\n  t=pow(sin(t*2.*pi),2.);    \n  return t*2.*pi;\n}\nvec2 fb( vec3 p, float mat, float tw) \n{\n  pp=abs(p)-vec3(6,0,0);\n  vec2 h,t=vec2(length(pp)-1.9,6);\n  gl[int(mat)]+=0.1/(0.1+t.x*t.x*20.);\n  h=vec2(cx(pp,vec3(2,.5,.5)),5); t=t.x<h.x?t:h;  \n  h=vec2(length(p)-sin(tt*10.)*10.,6);\n  gl.y+=(0.1/(0.1+h.x*h.x*.1))*(gpo.x-.2)*-10.;\n  h=vec2(cx(pp,vec3(2,.7,.3)),6); t=t.x<h.x?t:h;\n  h=vec2(cx(pp,vec3(2,.8,.1)),3); t=t.x<h.x?t:h;\n  pp=abs(p)-vec3(0,2,0);\n  pp.xz*=r2(sin(pp.y*.12)*2.);\n  h=vec2(cz(pp,vec3(6,.5,.5)),5);h.x*=0.6; t=t.x<h.x?t:h;\n  h=vec2(cz(pp,vec3(6,.3,.7)),6);h.x*=0.6; t=t.x<h.x?t:h;\n  h=vec2(cz(pp,vec3(6,.1,.8)),3);h.x*=0.6; t=t.x<h.x?t:h;\n  np=p;\n  for(int i=0;i<8;i++){\n    np=abs(np);\n    np.xy*=r2(-.1);\n  }\n  h=vec2(length(np.xz)-.35,3);\n  h.x=max(h.x,cz(pp,vec3(6,.7,.5)));\n  h.x=max(h.x,-(length(np.xz)-.2)); t=t.x<h.x?t:h;  \n  h=vec2(length(np.xz),6);\n  h.x=max(h.x,cz(pp+vec3(0,1.5,0),vec3(6.5,1.9,1.5)));  \n  gl[int(mat)]+=0.1/(0.1+h.x/tw*h.x/tw*(40.-39.*abs(cos(pp.x*pp.y*.05-tt*4.))));\n  t=t.x<h.x?t:h; \n  return t;\n}\nvec2 mp( vec3 p ){ \n  op=p;\n  vec4 np=vec4(p,1);\n  float mat,bro;\n  vec2 h,t=vec2(1000);\n  for(int i=0;i<5;i++){     \n    mat=mod(float(i),2.);\n    bro=cos(mat*pi);\n    np.xy*=r2(ti*bro);\n    np.yz*=r2(-ti*bro);\n    h=fb(np.xyz,mat,np.w);\n    h.x/=np.w; t=t.x<h.x?t:h;\n    np*=2.;\n  }\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd)\n{\n  vec2 h,t= vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>30.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>30.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  pi=acos(-1.);\n  tt=mod(iTime,62.83)+3.; ti=tick(tt);\n  gpo=vec2(ceil(sin((sin(tt*5.+cos(tt*12.))))));\n  gpo.y=1.-gpo.y; gpo*=0.2;\n  if(cos(ti)<.7) gpo=vec2(0.2); \n  vec2 tnoi=vec2(texNoise(uv*gpo*17.).r);\n  tnoi+=(ceil(sin(abs(uv.x)*500.*gpo.x-tt*10.))+ceil(sin(abs(uv.y)*500.*gpo.y-tt*10.)))*(gpo.x-gpo.y);\n  v=(gpo-.2)*.2*(tnoi); uv*=1.-(v.y+v.x)*4.;\n  vec3 ro=vec3(0.,0,+11.+4.*cos(tick(tt))),\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.7)),co,fo;\n  ld=normalize(vec3(.1,.5,.3));\n  co=fo=vec3(.1,.03,.15)-length(uv)*.1-rd.y*.15;\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); \n    al=vec3(.5); \n    if(z.y<5.) al=vec3(0);\n    if(z.y>5.) al=vec3(1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n    co=mix(sp+mix(vec3(.7),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(.5)),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.0003*t*t*t));\n  }\n  fragColor = vec4(pow(co+gl.x*gpo.x*vec3(1,.4,.2)+gl.y*vec3(.1,.2,.4)*gpo.y,vec3(.45)),1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[468, 468, 492, 492, 544], [545, 545, 569, 569, 621], [622, 622, 639, 639, 682], [683, 683, 706, 706, 905], [907, 907, 927, 927, 1020], [1021, 1021, 1061, 1061, 2016], [2017, 2017, 2035, 2035, 2315], [2316, 2316, 2344, 2344, 2509], [2599, 2599, 2656, 2656, 3926]], "test": "untested"}
{"id": "WlfyW8", "name": "rand dots in cubic grid", "author": "FabriceNeyret2", "description": "just for the look, illustrates random dots in grid as used in 3D Voronoï / Worley patterns.\nAnd shake them, because. :-)\n\nNote the plug-and-play shader antialiasing technics at the end.", "tags": ["raymarching", "voronoi", "sdf", "antialiasing", "tuto", "short"], "likes": 22, "viewed": 677, "published": 3, "date": "1591894320", "time_retrieved": "2024-07-30T21:01:40.354403", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))\nvoid mainImage0(out vec4 O, vec2 U) {\n    \n    float t=1.,s,C;\n    vec3  R = iResolution, \n          D = normalize(vec3(.2*(U+U-R.xy)/R.y, -1)), // ray direction\n          p = 30./R, T,a,f,q;                         // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p, \n        q.yz *= rot(-.2),                             // rotations\n        q.xz *= rot(.3*iTime),\n        T = q,                                      \n        a = abs(T), C = max(a.x,max(a.y,a.z))-4.03;   // big cube\n        if (C>.2) t = C; else                         // BBox ( omment to compare perfs )\n        {                                             // --- tubes\n          q = mod(q+1.,2.)-1.,                        // 3D tiling (staggered compare to cube)\n          t = min(length(q.xy),                       // cylinders in 3 directions\n              min(length(q.yz),                       // ( cross at middle of cells )\n                  length(q.xz)))-.03,\n                                                      // --- balls\n          f = fract(4e5*sin(ceil(T/2.)*mat3(R,R.zxy,-R.yzx))), // random seed per cell\n          f *= .95+.05*sin(iTime*40.+63.*f.y),        // shake\n       // f *= sin(iTime*5.+63.*f.y),                 // shake variant\n          q = mod(T,2.)-1.,                           // now consider stagered cells (small cubes)\n          t = min( t, s = length(1.4*f-.7 - q) -.2 ), // red ball at random pos\n\n          t = max( t, C );                            // --- intersection with big cube\n        }\n        p += t*D;                                     // step forward = dist to obj\n    }\n    s==t ? O.gba *= 0. : R ;                          // paint red balls\n}\n\n// Antialiasing \"module\" by FabriceNeyret2 https://www.shadertoy.com/view/WlfyW8\n#define AA 2 // antialiasing level ( AA*AA subsamples )\nvoid mainImage(out vec4 O, vec2 U) {\n    vec4 T;  O=vec4(0);                                          \n    for (int k=0; k<AA*AA; k++, O+=T)                  \n        mainImage0(T,U+.33*vec2(k%AA-AA/2,k/AA-AA/2));  \n    O /= float(AA*AA);\n}        \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 82, 82, 1771], [1910, 1910, 1946, 1946, 2150]], "test": "untested"}
{"id": "ttsyWn", "name": "Mandelbrot derivative", "author": "FabriceNeyret2", "description": "just for fun, displaying the derivative of Mandelbrot (yes :-p ).\nleft: hardware derivative after loop. Right: during loop. ( look different in OpenGL, not sure for windows/Angle. see capture below).\n\nInterior looks better with less iterations.", "tags": ["fractal", "mandelbrot", "fwidth", "short", "short"], "likes": 5, "viewed": 414, "published": 3, "date": "1591854355", "time_retrieved": "2024-07-30T21:01:41.105395", "image_code": "// variant of https://shadertoy.com/view/MllXWM\n\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    O-=O;\n    float k=0., v, l=k, t = mod(iTime,88.); t = min(t,88.-t);\n    vec2  R = iResolution.xy,\n          z = (U-.5*R)/R.y / pow(t,t/20.) - vec2(1.001105,0.300717),\n          c = z;\n    \n    for (; k++ <40. && l<4.; )         // Mandelbrot iterations\n         l = dot( z = mat2(z,-z.y,z.x) *z + c, z ), // z = z*z + c\n         v = fwidth(l);\n    \n    if ( U.x < .5*R.x ) v = fwidth(l); // left: post derivative. right: inloop\n    O +=  pow(v,.2); \n  //O -= .1*log(v);\n    \n  //if (O.x==0.) O++;   // test: difference is just fwidth undefined (thus 0)  at divergences\n    if (int(U)==int(.5*R)) O.r ++;     // red separator\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 88, 88, 720]], "test": "untested"}
{"id": "ttlyWn", "name": "Mandelbrot  set", "author": "changjiu", "description": "Mandelbrot Set", "tags": ["mandelbrot"], "likes": 3, "viewed": 303, "published": 3, "date": "1591848642", "time_retrieved": "2024-07-30T21:01:41.948142", "image_code": "vec2 pow2(vec2 n){\n\tfloat x = n.x*n.x-n.y*n.y;\n    float y = 2.0*n.x*n.y;\n\treturn vec2(x,y);\n}\n\nvec2 plus(vec2 n, vec2 m){\n\tfloat x = n.x+m.x;\n    float y = n.y+m.y;\n\treturn vec2(x,y);\n}\n\nvec2 pow2plus(vec2 n, vec2 m){\n\tvec2 p2 = pow2(n);\n    vec2 result = plus(p2,m);\n\treturn result;\n}\n\n\nfloat isInMandelbrot(float x, float y){\n    vec2 z0 = vec2(0.0,0.0);\n    vec2 m = vec2(x,y);\n    vec2 zn = z0;\n    for(int i=0; i<60; i++){\n        zn = pow2plus(zn,m);\n    }\n    \n\treturn length(zn);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    \n\tfloat t = mod(iTime,47.), v=0.;\n    t = min(t, 47.-t);\n    float  scale = 1./(pow(t,t/6.));\n\n    vec2  R = iResolution.xy, U;\n    O -= O;\n\n    for (int k=0; k<9;k++) { \n        U  = ( u+.33*vec2(k%3-1,k/3-1) - .5* R ) / R.y*scale;\n        v  = isInMandelbrot(U.x-0.7652, U.y+0.1);\n        O +=  sin(3.14*v);\n    }\n    O = .5 + .5* O/9.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 94], [96, 96, 122, 122, 186], [188, 188, 218, 218, 286], [289, 289, 328, 328, 490], [492, 492, 530, 530, 875]], "test": "untested"}
{"id": "WtlcDr", "name": "metal grid screensaver", "author": "mds2", "description": "riff on https://www.shadertoy.com/view/XlSfzz to create desktop backgrounds.", "tags": ["grid", "metal", "pattern"], "likes": 4, "viewed": 424, "published": 3, "date": "1591844362", "time_retrieved": "2024-07-30T21:01:42.703123", "image_code": "#define MULTI_SAMPLE_4 0\n#define MULTI_SAMPLE_8 0\n#define MULTI_SAMPLE_3 0\n#define MULTI_SAMPLE_2 1\n\n#define ONLY_BLURRY_REFLECTIONS 1 // set to 0 to make parts of reflection crisp\n\nconst float tor_rad1 = 0.5;\nconst float tor_rad2 = 0.2;\n\nvec4 background(vec3 orig, vec3 dir, float bounced) {\n   \n    vec4 c1 = texture(iChannel1, dir);\n#if ONLY_BLURRY_REFLECTIONS\n    vec4 c0 = c1;\n#else\n    vec4 c0 = texture(iChannel2, dir);\n#endif\n    return mix(c1, c0, smoothstep(0.0, 0.2, bounced));\n}\n\n\nvec3 raymarch(in vec3 orig, in vec3 dir) {\n    float d = -orig.z/dir.z;\n    vec3 p = orig + d * dir;\n    return p;\n}\n\n\n\n\nvec2 tor_angles(in vec3 point) {\n    return mod(point.xy * 1.0, vec2(1.0));\n}\n\nvec3 tor_norm(in vec3 point, out float glow_mag) {\n    vec3 n = vec3(0.0, 0.0, 1.0);\n    vec2 uv =tor_angles(point);\n    vec3 t1 = vec3(1.0, 0.0, 0.0);\n    vec3 t2 = vec3(0.0, 1.0, 0.0);\n    \n    float h = 1.0 / min(iResolution.x, iResolution.y);\n    float img_samp = length(texture(iChannel0, uv).rg);\n    glow_mag = img_samp;\n    vec2 img_grad =\n        vec2(length(texture(iChannel0, \n                            mod(uv + vec2(h, 0.0), vec2(1.0))).rg) - img_samp,\n             length(texture(iChannel0,\n                            mod(uv + vec2(0.0, h), vec2(1.0))).rg) - img_samp) / h;\n\treturn n - 0.1 * (img_grad.x * t1 + img_grad.y * t2);\n}\n\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec4 color_mul = vec4(1.0);\n    vec4 color_add = vec4(0.0);\n    \n    float stheta = 0.0; // sin(0.125 * iTime);\n    float ctheta = 1.0; // cos(0.125 * iTime);\n    float pitch = -0.0;\n    mat3 turn_mat = \n        mat3(ctheta, 0.0, stheta,\n             0.0, 1.0, 0.0,\n             -stheta, 0.0, ctheta) *\n        mat3(1.0, 0.0, 0.0,\n                         0.0, cos(pitch), sin(pitch),\n                         0.0, -sin(pitch), cos(pitch));\n    \n    vec3 ray_orig = turn_mat * vec3(0.0, 0.0, -0.5);\n    \n    vec3 ray_dir = normalize(turn_mat * vec3(uv, 0.5));\n    \n    float bounced = 0.0;\n    \n\tvec3 hit = raymarch(ray_orig, ray_dir);\n    if (true) {\n        float glow;\n    \tvec3 n = tor_norm(hit, glow);\n        ray_dir = normalize(reflect(ray_dir, n));\n        ray_orig = hit;\n        \n        color_add.b = 0.5 * smoothstep(0.3, 0.9, glow);\n        bounced = 1.0 - glow;\n        \n    }\n    \n\treturn color_mul * background(ray_orig, ray_dir, bounced) + color_add;\n}\n\n\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + offsets[0]);\n    nsamps += 1.0;\n    \n#if MULTI_SAMPLE_8\n    result += getSample(fragCoord + offsets[1]);\n    result += getSample(fragCoord + offsets[2]);\n    result += getSample(fragCoord + offsets[3]);\n    result += getSample(fragCoord + offsets[4]);\n    result += getSample(fragCoord + offsets[5]);\n    result += getSample(fragCoord + offsets[6]);\n    result += getSample(fragCoord + offsets[7]);\n    nsamps += 7.0;\n#elif MULTI_SAMPLE_4\n    result += getSample(fragCoord + offsets[2]);\n    result += getSample(fragCoord + offsets[4]);\n    result += getSample(fragCoord + offsets[6]);\n    nsamps += 3.0;\n#elif MULTI_SAMPLE_3\n    result += getSample(fragCoord + offsets[3]);\n    result += getSample(fragCoord + offsets[6]);\n    nsamps += 2.0;\n#elif MULTI_SAMPLE_2\n    result += getSample(fragCoord + offsets[4]);\n    nsamps += 1.0;\n#endif\n    \n    \n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\nvec2 fetch_dir(in vec2 in_pixels) {\n    vec2 dir = texture(iChannel0, to_uv(in_pixels)).rg;\n    dir = step(vec2(0.5), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n    return dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    float refresh_period = 3.0 * iResolution.y / 300.0;\n    float t = iTime - mod(iTime, refresh_period);\n    mat2 rotator = mat2(cos(t), sin(t),\n                          -sin(t), cos(t));\n    vec2 dir = step(vec2(0.999), texture(iChannel1, to_uv(rotator * p)).rg);\n    dir = vec2(step(dir.y, dir.x), step(dir.x, dir.y)) * dir;\n \n    if (mod(iTime, refresh_period) < 0.1) {\n      fragColor = vec4(dir, 0.0, 1.0);\n        return;\n    }\n   \n    if (dot(dir, dir) < 0.5) {\n\t    dir = step(vec2(0.9), texture(iChannel0, to_uv(p)).rg);\n    }\n     \n    if (dot(dir, dir) < 0.01) {\n    \tvec2 dir1 = vec2(1.0, 0.0);\n    \tvec2 dir2 = dir1.yx;\n        \n        \n    \tfloat val1 = max(abs(dot(dir1, fetch_dir(p + dir1))),\n                     \tabs(dot(dir1, fetch_dir(p - dir1))));\n        \n            \n    \tfloat val2 = max(abs(dot(dir2, fetch_dir(p + dir2))),\n        \t             abs(dot(dir2, fetch_dir(p - dir2))));\n        \n    \t\n        if (val1 > val2) {\n            val2 = 0.0;\n        } else {\n            val1 = 0.0;\n        }\n        \n        val1 = step(0.9, val1);\n        val2 = step(0.9, val2);\n        \n    \n    \tdir = mix(dir, dir1, val1);\n    \tdir = mix(dir, dir2, val2);\n    }\n    \n    dir = step(vec2(0.9), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n \n    fragColor = vec4(dir,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pix_delta = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * pix_delta;\n    vec4 result = 16.0 * texture(iChannel0, uv);\n    result = result + texture(iChannel0, uv + pix_delta * vec2( 1.1, 0.0));\n    result = result + texture(iChannel0, uv + pix_delta * vec2(-1.1, 0.0));\n    result = result + texture(iChannel0, uv + pix_delta * vec2(0.0,  1.1));\n    result = result + texture(iChannel0, uv + pix_delta * vec2(0.0, -1.1));\n    fragColor = mix(0.05 * result, texture(iChannel1, uv), 0.025);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 292, 292, 490], [493, 493, 535, 535, 609], [614, 614, 646, 646, 691], [693, 693, 743, 743, 1339], [1342, 1342, 1378, 1378, 2443], [2788, 2788, 2845, 2845, 3833]], "test": "untested"}
{"id": "WtsyWr", "name": "Sine melody", "author": "ttg", "description": "Nothing but 800 sine waves superimposed!", "tags": ["sound", "music", "interference", "sines", "sampleprecise"], "likes": 3, "viewed": 465, "published": 3, "date": "1591839231", "time_retrieved": "2024-07-30T21:01:43.641614", "image_code": "                                                                                                                                                                                                                                                                /*\n\n    Main source is in the Common tab.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\n\n\n\n\n/* \n\nExpression Plotter\n\nUsage: PLOT_CONTINUOUS( fragColor, uv, window, domain,\n                        linecolor, side, blend, linewidth, expression );\n\n  fragColor - output (linear RGB)\n  uv - coordinate system for window\n  window - mat2, first col: window corner, second col: window size\n  domain - mat2, first col: min x,y, second col: max x,y\n  linecolor - RGB\n  side - 0 = line, 1 = below, -1 = above (see demo)\n  blend - 0=paint, 1=light-trace, 2=ink (see demo)\n  linewidth - measured in units of uv.x; only for side=0\n  expression - uses x as the independent variable\n\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/3t3XWf\", is displayed within the source.\n\n*/\n\n\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\n/*\nCopyright 2020 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    PLOT_CONTINUOUS(col, uv, mat2(0,0,1,1), mat2(0.,-1.,1.,1.), vec3(1.), 0, 1, .002, texture(iChannel0, vec2(x,0.)).x );\n    PLOT_CONTINUOUS(col, uv, mat2(0,0,1,1), mat2(0.,-1.,1.,1.), .04*vec3(.1,1.,.1), 0, 1, .02, texture(iChannel0, vec2(x,0.)).x );\n    col += .003*vec3(.1,1.,.1);\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec3[] partials = vec3[](\nvec3(-2, 122.897222,-0.000),vec3( 2, 122.902778,-0.000),vec3(-2, 123.097222, 0.000),vec3( 2, 123.102778, 0.000),vec3(-2, 140.897222, 0.000),vec3( 2, 140.902778, 0.000),vec3(-2, 141.097222, 0.000),vec3( 2, 141.102778, 0.000),\nvec3(-2, 124.897222,-0.000),vec3( 2, 124.902778,-0.000),vec3(-2, 125.097222, 0.000),vec3( 2, 125.102778, 0.000),vec3(-2, 138.897222, 0.000),vec3( 2, 138.902778, 0.000),vec3(-2, 139.097222, 0.000),vec3( 2, 139.102778, 0.000),\nvec3(-2, 126.897222,-0.000),vec3( 2, 126.902778,-0.000),vec3(-2, 127.097222, 0.000),vec3( 2, 127.102778, 0.000),vec3(-2, 136.897222, 0.000),vec3( 2, 136.902778, 0.000),vec3(-2, 137.097222, 0.000),vec3( 2, 137.102778, 0.000),\nvec3(-2, 128.897222,-0.000),vec3( 2, 128.902778,-0.000),vec3(-2, 129.097222, 0.000),vec3( 2, 129.102778, 0.000),vec3(-2, 134.897222, 0.000),vec3( 2, 134.902778, 0.000),vec3(-2, 135.097222, 0.000),vec3( 2, 135.102778, 0.000),\nvec3(-2, 130.897222,-0.000),vec3( 2, 130.902778,-0.000),vec3(-2, 131.097222, 0.000),vec3( 2, 131.102778, 0.000),vec3(-2, 132.897222, 0.000),vec3( 2, 132.902778, 0.000),vec3(-2, 133.097222, 0.000),vec3( 2, 133.102778, 0.000),\nvec3(-2, 166.897222,-0.250),vec3( 2, 166.902778,-0.250),vec3(-2, 167.097222, 0.250),vec3( 2, 167.102778, 0.250),vec3(-2, 184.897222,-0.250),vec3( 2, 184.902778,-0.250),vec3(-2, 185.097222, 0.250),vec3( 2, 185.102778, 0.250),\nvec3(-2, 168.897222,-0.250),vec3( 2, 168.902778,-0.250),vec3(-2, 169.097222, 0.250),vec3( 2, 169.102778, 0.250),vec3(-2, 182.897222,-0.250),vec3( 2, 182.902778,-0.250),vec3(-2, 183.097222, 0.250),vec3( 2, 183.102778, 0.250),\nvec3(-2, 170.897222,-0.250),vec3( 2, 170.902778,-0.250),vec3(-2, 171.097222, 0.250),vec3( 2, 171.102778, 0.250),vec3(-2, 180.897222,-0.250),vec3( 2, 180.902778,-0.250),vec3(-2, 181.097222, 0.250),vec3( 2, 181.102778, 0.250),\nvec3(-2, 172.897222,-0.250),vec3( 2, 172.902778,-0.250),vec3(-2, 173.097222, 0.250),vec3( 2, 173.102778, 0.250),vec3(-2, 178.897222,-0.250),vec3( 2, 178.902778,-0.250),vec3(-2, 179.097222, 0.250),vec3( 2, 179.102778, 0.250),\nvec3(-2, 174.897222,-0.250),vec3( 2, 174.902778,-0.250),vec3(-2, 175.097222, 0.250),vec3( 2, 175.102778, 0.250),vec3(-2, 176.897222,-0.250),vec3( 2, 176.902778,-0.250),vec3(-2, 177.097222, 0.250),vec3( 2, 177.102778, 0.250),\nvec3(-1, 193.397222,-3.375),vec3( 1, 193.402778,-3.375),vec3(-1, 193.597222,-3.375),vec3( 1, 193.602778,-3.375),vec3(-1, 202.397222, 3.375),vec3( 1, 202.402778, 3.375),vec3(-1, 202.597222, 3.375),vec3( 1, 202.602778, 3.375),\nvec3(-1, 194.397222,-2.625),vec3( 1, 194.402778,-2.625),vec3(-1, 194.597222,-2.625),vec3( 1, 194.602778,-2.625),vec3(-1, 201.397222, 2.625),vec3( 1, 201.402778, 2.625),vec3(-1, 201.597222, 2.625),vec3( 1, 201.602778, 2.625),\nvec3(-1, 195.397222,-1.875),vec3( 1, 195.402778,-1.875),vec3(-1, 195.597222,-1.875),vec3( 1, 195.602778,-1.875),vec3(-1, 200.397222, 1.875),vec3( 1, 200.402778, 1.875),vec3(-1, 200.597222, 1.875),vec3( 1, 200.602778, 1.875),\nvec3(-1, 196.397222,-1.125),vec3( 1, 196.402778,-1.125),vec3(-1, 196.597222,-1.125),vec3( 1, 196.602778,-1.125),vec3(-1, 199.397222, 1.125),vec3( 1, 199.402778, 1.125),vec3(-1, 199.597222, 1.125),vec3( 1, 199.602778, 1.125),\nvec3(-1, 197.397222,-0.375),vec3( 1, 197.402778,-0.375),vec3(-1, 197.597222,-0.375),vec3( 1, 197.602778,-0.375),vec3(-1, 198.397222, 0.375),vec3( 1, 198.402778, 0.375),vec3(-1, 198.597222, 0.375),vec3( 1, 198.602778, 0.375),\nvec3(-1, 259.397222,-0.000),vec3( 1, 259.402778,-0.000),vec3(-1, 259.597222, 0.000),vec3( 1, 259.602778, 0.000),vec3(-1, 268.397222, 0.000),vec3( 1, 268.402778, 0.000),vec3(-1, 268.597222, 0.000),vec3( 1, 268.602778, 0.000),\nvec3(-1, 259.397222,-3.625),vec3( 1, 259.402778,-3.625),vec3(-1, 259.597222,-3.125),vec3( 1, 259.602778,-3.125),vec3(-1, 268.397222, 3.125),vec3( 1, 268.402778, 3.125),vec3(-1, 268.597222, 3.625),vec3( 1, 268.602778, 3.625),\nvec3(-1, 260.397222,-0.000),vec3( 1, 260.402778,-0.000),vec3(-1, 260.597222, 0.000),vec3( 1, 260.602778, 0.000),vec3(-1, 267.397222, 0.000),vec3( 1, 267.402778, 0.000),vec3(-1, 267.597222, 0.000),vec3( 1, 267.602778, 0.000),\nvec3(-1, 260.397222,-2.875),vec3( 1, 260.402778,-2.875),vec3(-1, 260.597222,-2.375),vec3( 1, 260.602778,-2.375),vec3(-1, 267.397222, 2.375),vec3( 1, 267.402778, 2.375),vec3(-1, 267.597222, 2.875),vec3( 1, 267.602778, 2.875),\nvec3(-1, 261.397222,-0.000),vec3( 1, 261.402778,-0.000),vec3(-1, 261.597222, 0.000),vec3( 1, 261.602778, 0.000),vec3(-1, 266.397222, 0.000),vec3( 1, 266.402778, 0.000),vec3(-1, 266.597222, 0.000),vec3( 1, 266.602778, 0.000),\nvec3(-1, 261.397222,-2.125),vec3( 1, 261.402778,-2.125),vec3(-1, 261.597222,-1.625),vec3( 1, 261.602778,-1.625),vec3(-1, 266.397222, 1.625),vec3( 1, 266.402778, 1.625),vec3(-1, 266.597222, 2.125),vec3( 1, 266.602778, 2.125),\nvec3(-1, 262.397222,-0.000),vec3( 1, 262.402778,-0.000),vec3(-1, 262.597222, 0.000),vec3( 1, 262.602778, 0.000),vec3(-1, 265.397222, 0.000),vec3( 1, 265.402778, 0.000),vec3(-1, 265.597222, 0.000),vec3( 1, 265.602778, 0.000),\nvec3(-1, 262.397222,-1.375),vec3( 1, 262.402778,-1.375),vec3(-1, 262.597222,-0.875),vec3( 1, 262.602778,-0.875),vec3(-1, 265.397222, 0.875),vec3( 1, 265.402778, 0.875),vec3(-1, 265.597222, 1.375),vec3( 1, 265.602778, 1.375),\nvec3(-1, 263.397222,-0.000),vec3( 1, 263.402778,-0.000),vec3(-1, 263.597222, 0.000),vec3( 1, 263.602778, 0.000),vec3(-1, 264.397222, 0.000),vec3( 1, 264.402778, 0.000),vec3(-1, 264.597222, 0.000),vec3( 1, 264.602778, 0.000),\nvec3(-1, 263.397222,-0.625),vec3( 1, 263.402778,-0.625),vec3(-1, 263.597222,-0.125),vec3( 1, 263.602778,-0.125),vec3(-1, 264.397222, 0.125),vec3( 1, 264.402778, 0.125),vec3(-1, 264.597222, 0.625),vec3( 1, 264.602778, 0.625),\nvec3(-1, 347.397222,-0.250),vec3( 1, 347.402778,-0.250),vec3(-1, 347.597222, 0.250),vec3( 1, 347.602778, 0.250),vec3(-1, 356.397222,-0.250),vec3( 1, 356.402778,-0.250),vec3(-1, 356.597222, 0.250),vec3( 1, 356.602778, 0.250),\nvec3(-1, 348.397222,-0.250),vec3( 1, 348.402778,-0.250),vec3(-1, 348.597222, 0.250),vec3( 1, 348.602778, 0.250),vec3(-1, 355.397222,-0.250),vec3( 1, 355.402778,-0.250),vec3(-1, 355.597222, 0.250),vec3( 1, 355.602778, 0.250),\nvec3(-1, 349.397222,-0.250),vec3( 1, 349.402778,-0.250),vec3(-1, 349.597222, 0.250),vec3( 1, 349.602778, 0.250),vec3(-1, 354.397222,-0.250),vec3( 1, 354.402778,-0.250),vec3(-1, 354.597222, 0.250),vec3( 1, 354.602778, 0.250),\nvec3(-1, 350.397222,-0.250),vec3( 1, 350.402778,-0.250),vec3(-1, 350.597222, 0.250),vec3( 1, 350.602778, 0.250),vec3(-1, 353.397222,-0.250),vec3( 1, 353.402778,-0.250),vec3(-1, 353.597222, 0.250),vec3( 1, 353.602778, 0.250),\nvec3(-1, 351.397222,-0.250),vec3( 1, 351.402778,-0.250),vec3(-1, 351.597222, 0.250),vec3( 1, 351.602778, 0.250),vec3(-1, 352.397222,-0.250),vec3( 1, 352.402778,-0.250),vec3(-1, 352.597222, 0.250),vec3( 1, 352.602778, 0.250),\nvec3(-1, 391.397222,-2.250),vec3( 1, 391.402778,-2.250),vec3(-1, 391.597222,-2.250),vec3( 1, 391.602778,-2.250),vec3(-1, 400.397222, 2.250),vec3( 1, 400.402778, 2.250),vec3(-1, 400.597222, 2.250),vec3( 1, 400.602778, 2.250),\nvec3(-1, 392.397222,-1.750),vec3( 1, 392.402778,-1.750),vec3(-1, 392.597222,-1.750),vec3( 1, 392.602778,-1.750),vec3(-1, 399.397222, 1.750),vec3( 1, 399.402778, 1.750),vec3(-1, 399.597222, 1.750),vec3( 1, 399.602778, 1.750),\nvec3(-1, 393.397222,-1.250),vec3( 1, 393.402778,-1.250),vec3(-1, 393.597222,-1.250),vec3( 1, 393.602778,-1.250),vec3(-1, 398.397222, 1.250),vec3( 1, 398.402778, 1.250),vec3(-1, 398.597222, 1.250),vec3( 1, 398.602778, 1.250),\nvec3(-1, 394.397222,-0.750),vec3( 1, 394.402778,-0.750),vec3(-1, 394.597222,-0.750),vec3( 1, 394.602778,-0.750),vec3(-1, 397.397222, 0.750),vec3( 1, 397.402778, 0.750),vec3(-1, 397.597222, 0.750),vec3( 1, 397.602778, 0.750),\nvec3(-1, 395.397222,-0.250),vec3( 1, 395.402778,-0.250),vec3(-1, 395.597222,-0.250),vec3( 1, 395.602778,-0.250),vec3(-1, 396.397222, 0.250),vec3( 1, 396.402778, 0.250),vec3(-1, 396.597222, 0.250),vec3( 1, 396.602778, 0.250),\nvec3(-1, 435.397222,-1.375),vec3( 1, 435.402778,-1.375),vec3(-1, 435.597222,-0.875),vec3( 1, 435.602778,-0.875),vec3(-1, 444.397222, 0.875),vec3( 1, 444.402778, 0.875),vec3(-1, 444.597222, 1.375),vec3( 1, 444.602778, 1.375),\nvec3(-1, 436.397222,-1.125),vec3( 1, 436.402778,-1.125),vec3(-1, 436.597222,-0.625),vec3( 1, 436.602778,-0.625),vec3(-1, 443.397222, 0.625),vec3( 1, 443.402778, 0.625),vec3(-1, 443.597222, 1.125),vec3( 1, 443.602778, 1.125),\nvec3(-1, 437.397222,-0.875),vec3( 1, 437.402778,-0.875),vec3(-1, 437.597222,-0.375),vec3( 1, 437.602778,-0.375),vec3(-1, 442.397222, 0.375),vec3( 1, 442.402778, 0.375),vec3(-1, 442.597222, 0.875),vec3( 1, 442.602778, 0.875),\nvec3(-1, 438.397222,-0.625),vec3( 1, 438.402778,-0.625),vec3(-1, 438.597222,-0.125),vec3( 1, 438.602778,-0.125),vec3(-1, 441.397222, 0.125),vec3( 1, 441.402778, 0.125),vec3(-1, 441.597222, 0.625),vec3( 1, 441.602778, 0.625),\nvec3(-1, 439.397222,-0.375),vec3( 1, 439.402778,-0.375),vec3(-1, 439.597222, 0.125),vec3( 1, 439.602778, 0.125),vec3(-1, 440.397222,-0.125),vec3( 1, 440.402778,-0.125),vec3(-1, 440.597222, 0.375),vec3( 1, 440.602778, 0.375),\nvec3(-2, 518.897222,-0.000),vec3( 2, 518.902778,-0.000),vec3(-2, 519.097222, 0.000),vec3( 2, 519.102778, 0.000),vec3(-2, 536.897222, 0.000),vec3( 2, 536.902778, 0.000),vec3(-2, 537.097222, 0.000),vec3( 2, 537.102778, 0.000),\nvec3(-2, 520.897222,-0.000),vec3( 2, 520.902778,-0.000),vec3(-2, 521.097222, 0.000),vec3( 2, 521.102778, 0.000),vec3(-2, 534.897222, 0.000),vec3( 2, 534.902778, 0.000),vec3(-2, 535.097222, 0.000),vec3( 2, 535.102778, 0.000),\nvec3(-2, 522.897222,-0.000),vec3( 2, 522.902778,-0.000),vec3(-2, 523.097222, 0.000),vec3( 2, 523.102778, 0.000),vec3(-2, 532.897222, 0.000),vec3( 2, 532.902778, 0.000),vec3(-2, 533.097222, 0.000),vec3( 2, 533.102778, 0.000),\nvec3(-1, 523.397222,-1.125),vec3( 1, 523.402778,-1.125),vec3(-1, 523.597222,-1.125),vec3( 1, 523.602778,-1.125),vec3(-1, 532.397222, 1.125),vec3( 1, 532.402778, 1.125),vec3(-1, 532.597222, 1.125),vec3( 1, 532.602778, 1.125),\nvec3(-1, 523.397222,-2.500),vec3( 1, 523.402778,-2.500),vec3(-1, 523.597222,-2.000),vec3( 1, 523.602778,-2.000),vec3(-1, 532.397222, 2.000),vec3( 1, 532.402778, 2.000),vec3(-1, 532.597222, 2.500),vec3( 1, 532.602778, 2.500),\nvec3(-1, 524.397222,-0.875),vec3( 1, 524.402778,-0.875),vec3(-1, 524.597222,-0.875),vec3( 1, 524.602778,-0.875),vec3(-1, 531.397222, 0.875),vec3( 1, 531.402778, 0.875),vec3(-1, 531.597222, 0.875),vec3( 1, 531.602778, 0.875),\nvec3(-1, 524.397222,-2.000),vec3( 1, 524.402778,-2.000),vec3(-1, 524.597222,-1.500),vec3( 1, 524.602778,-1.500),vec3(-1, 531.397222, 1.500),vec3( 1, 531.402778, 1.500),vec3(-1, 531.597222, 2.000),vec3( 1, 531.602778, 2.000),\nvec3(-2, 524.897222,-0.000),vec3( 2, 524.902778,-0.000),vec3(-2, 525.097222, 0.000),vec3( 2, 525.102778, 0.000),vec3(-2, 530.897222, 0.000),vec3( 2, 530.902778, 0.000),vec3(-2, 531.097222, 0.000),vec3( 2, 531.102778, 0.000),\nvec3(-1, 525.397222,-0.625),vec3( 1, 525.402778,-0.625),vec3(-1, 525.597222,-0.625),vec3( 1, 525.602778,-0.625),vec3(-1, 530.397222, 0.625),vec3( 1, 530.402778, 0.625),vec3(-1, 530.597222, 0.625),vec3( 1, 530.602778, 0.625),\nvec3(-1, 525.397222,-1.500),vec3( 1, 525.402778,-1.500),vec3(-1, 525.597222,-1.000),vec3( 1, 525.602778,-1.000),vec3(-1, 530.397222, 1.000),vec3( 1, 530.402778, 1.000),vec3(-1, 530.597222, 1.500),vec3( 1, 530.602778, 1.500),\nvec3(-1, 526.397222,-0.375),vec3( 1, 526.402778,-0.375),vec3(-1, 526.597222,-0.375),vec3( 1, 526.602778,-0.375),vec3(-1, 529.397222, 0.375),vec3( 1, 529.402778, 0.375),vec3(-1, 529.597222, 0.375),vec3( 1, 529.602778, 0.375),\nvec3(-1, 526.397222,-1.000),vec3( 1, 526.402778,-1.000),vec3(-1, 526.597222,-0.500),vec3( 1, 526.602778,-0.500),vec3(-1, 529.397222, 0.500),vec3( 1, 529.402778, 0.500),vec3(-1, 529.597222, 1.000),vec3( 1, 529.602778, 1.000),\nvec3(-2, 526.897222,-0.000),vec3( 2, 526.902778,-0.000),vec3(-2, 527.097222, 0.000),vec3( 2, 527.102778, 0.000),vec3(-2, 528.897222, 0.000),vec3( 2, 528.902778, 0.000),vec3(-2, 529.097222, 0.000),vec3( 2, 529.102778, 0.000),\nvec3(-1, 527.397222,-0.125),vec3( 1, 527.402778,-0.125),vec3(-1, 527.597222,-0.125),vec3( 1, 527.602778,-0.125),vec3(-1, 528.397222, 0.125),vec3( 1, 528.402778, 0.125),vec3(-1, 528.597222, 0.125),vec3( 1, 528.602778, 0.125),\nvec3(-1, 527.397222,-0.500),vec3( 1, 527.402778,-0.500),vec3(-1, 527.597222, 0.000),vec3( 1, 527.602778, 0.000),vec3(-1, 528.397222, 0.000),vec3( 1, 528.402778, 0.000),vec3(-1, 528.597222, 0.500),vec3( 1, 528.602778, 0.500),\nvec3(-2, 694.897222,-0.250),vec3( 2, 694.902778,-0.250),vec3(-2, 695.097222, 0.250),vec3( 2, 695.102778, 0.250),vec3(-2, 712.897222,-0.250),vec3( 2, 712.902778,-0.250),vec3(-2, 713.097222, 0.250),vec3( 2, 713.102778, 0.250),\nvec3(-2, 696.897222,-0.250),vec3( 2, 696.902778,-0.250),vec3(-2, 697.097222, 0.250),vec3( 2, 697.102778, 0.250),vec3(-2, 710.897222,-0.250),vec3( 2, 710.902778,-0.250),vec3(-2, 711.097222, 0.250),vec3( 2, 711.102778, 0.250),\nvec3(-2, 698.897222,-0.250),vec3( 2, 698.902778,-0.250),vec3(-2, 699.097222, 0.250),vec3( 2, 699.102778, 0.250),vec3(-2, 708.897222,-0.250),vec3( 2, 708.902778,-0.250),vec3(-2, 709.097222, 0.250),vec3( 2, 709.102778, 0.250),\nvec3(-2, 700.897222,-0.250),vec3( 2, 700.902778,-0.250),vec3(-2, 701.097222, 0.250),vec3( 2, 701.102778, 0.250),vec3(-2, 706.897222,-0.250),vec3( 2, 706.902778,-0.250),vec3(-2, 707.097222, 0.250),vec3( 2, 707.102778, 0.250),\nvec3(-2, 702.897222,-0.250),vec3( 2, 702.902778,-0.250),vec3(-2, 703.097222, 0.250),vec3( 2, 703.102778, 0.250),vec3(-2, 704.897222,-0.250),vec3( 2, 704.902778,-0.250),vec3(-2, 705.097222, 0.250),vec3( 2, 705.102778, 0.250),\nvec3(-1, 787.397222,-3.375),vec3( 1, 787.402778,-3.375),vec3(-1, 787.597222,-3.375),vec3( 1, 787.602778,-3.375),vec3(-1, 796.397222, 3.375),vec3( 1, 796.402778, 3.375),vec3(-1, 796.597222, 3.375),vec3( 1, 796.602778, 3.375),\nvec3(-1, 788.397222,-2.625),vec3( 1, 788.402778,-2.625),vec3(-1, 788.597222,-2.625),vec3( 1, 788.602778,-2.625),vec3(-1, 795.397222, 2.625),vec3( 1, 795.402778, 2.625),vec3(-1, 795.597222, 2.625),vec3( 1, 795.602778, 2.625),\nvec3(-1, 789.397222,-1.875),vec3( 1, 789.402778,-1.875),vec3(-1, 789.597222,-1.875),vec3( 1, 789.602778,-1.875),vec3(-1, 794.397222, 1.875),vec3( 1, 794.402778, 1.875),vec3(-1, 794.597222, 1.875),vec3( 1, 794.602778, 1.875),\nvec3(-1, 790.397222,-1.125),vec3( 1, 790.402778,-1.125),vec3(-1, 790.597222,-1.125),vec3( 1, 790.602778,-1.125),vec3(-1, 793.397222, 1.125),vec3( 1, 793.402778, 1.125),vec3(-1, 793.597222, 1.125),vec3( 1, 793.602778, 1.125),\nvec3(-1, 791.397222,-0.375),vec3( 1, 791.402778,-0.375),vec3(-1, 791.597222,-0.375),vec3( 1, 791.602778,-0.375),vec3(-1, 792.397222, 0.375),vec3( 1, 792.402778, 0.375),vec3(-1, 792.597222, 0.375),vec3( 1, 792.602778, 0.375),\nvec3(-1,1051.397222,-0.000),vec3( 1,1051.402778,-0.000),vec3(-1,1051.597222, 0.000),vec3( 1,1051.602778, 0.000),vec3(-1,1060.397222, 0.000),vec3( 1,1060.402778, 0.000),vec3(-1,1060.597222, 0.000),vec3( 1,1060.602778, 0.000),\nvec3(-1,1051.397222,-3.625),vec3( 1,1051.402778,-3.625),vec3(-1,1051.597222,-3.125),vec3( 1,1051.602778,-3.125),vec3(-1,1060.397222, 3.125),vec3( 1,1060.402778, 3.125),vec3(-1,1060.597222, 3.625),vec3( 1,1060.602778, 3.625),\nvec3(-1,1052.397222,-0.000),vec3( 1,1052.402778,-0.000),vec3(-1,1052.597222, 0.000),vec3( 1,1052.602778, 0.000),vec3(-1,1059.397222, 0.000),vec3( 1,1059.402778, 0.000),vec3(-1,1059.597222, 0.000),vec3( 1,1059.602778, 0.000),\nvec3(-1,1052.397222,-2.875),vec3( 1,1052.402778,-2.875),vec3(-1,1052.597222,-2.375),vec3( 1,1052.602778,-2.375),vec3(-1,1059.397222, 2.375),vec3( 1,1059.402778, 2.375),vec3(-1,1059.597222, 2.875),vec3( 1,1059.602778, 2.875),\nvec3(-1,1053.397222,-0.000),vec3( 1,1053.402778,-0.000),vec3(-1,1053.597222, 0.000),vec3( 1,1053.602778, 0.000),vec3(-1,1058.397222, 0.000),vec3( 1,1058.402778, 0.000),vec3(-1,1058.597222, 0.000),vec3( 1,1058.602778, 0.000),\nvec3(-1,1053.397222,-2.125),vec3( 1,1053.402778,-2.125),vec3(-1,1053.597222,-1.625),vec3( 1,1053.602778,-1.625),vec3(-1,1058.397222, 1.625),vec3( 1,1058.402778, 1.625),vec3(-1,1058.597222, 2.125),vec3( 1,1058.602778, 2.125),\nvec3(-1,1054.397222,-0.000),vec3( 1,1054.402778,-0.000),vec3(-1,1054.597222, 0.000),vec3( 1,1054.602778, 0.000),vec3(-1,1057.397222, 0.000),vec3( 1,1057.402778, 0.000),vec3(-1,1057.597222, 0.000),vec3( 1,1057.602778, 0.000),\nvec3(-1,1054.397222,-1.375),vec3( 1,1054.402778,-1.375),vec3(-1,1054.597222,-0.875),vec3( 1,1054.602778,-0.875),vec3(-1,1057.397222, 0.875),vec3( 1,1057.402778, 0.875),vec3(-1,1057.597222, 1.375),vec3( 1,1057.602778, 1.375),\nvec3(-1,1055.397222,-0.000),vec3( 1,1055.402778,-0.000),vec3(-1,1055.597222, 0.000),vec3( 1,1055.602778, 0.000),vec3(-1,1056.397222, 0.000),vec3( 1,1056.402778, 0.000),vec3(-1,1056.597222, 0.000),vec3( 1,1056.602778, 0.000),\nvec3(-1,1055.397222,-0.625),vec3( 1,1055.402778,-0.625),vec3(-1,1055.597222,-0.125),vec3( 1,1055.602778,-0.125),vec3(-1,1056.397222, 0.125),vec3( 1,1056.402778, 0.125),vec3(-1,1056.597222, 0.625),vec3( 1,1056.602778, 0.625),\nvec3(-1,1403.397222,-0.250),vec3( 1,1403.402778,-0.250),vec3(-1,1403.597222, 0.250),vec3( 1,1403.602778, 0.250),vec3(-1,1412.397222,-0.250),vec3( 1,1412.402778,-0.250),vec3(-1,1412.597222, 0.250),vec3( 1,1412.602778, 0.250),\nvec3(-1,1404.397222,-0.250),vec3( 1,1404.402778,-0.250),vec3(-1,1404.597222, 0.250),vec3( 1,1404.602778, 0.250),vec3(-1,1411.397222,-0.250),vec3( 1,1411.402778,-0.250),vec3(-1,1411.597222, 0.250),vec3( 1,1411.602778, 0.250),\nvec3(-1,1405.397222,-0.250),vec3( 1,1405.402778,-0.250),vec3(-1,1405.597222, 0.250),vec3( 1,1405.602778, 0.250),vec3(-1,1410.397222,-0.250),vec3( 1,1410.402778,-0.250),vec3(-1,1410.597222, 0.250),vec3( 1,1410.602778, 0.250),\nvec3(-1,1406.397222,-0.250),vec3( 1,1406.402778,-0.250),vec3(-1,1406.597222, 0.250),vec3( 1,1406.602778, 0.250),vec3(-1,1409.397222,-0.250),vec3( 1,1409.402778,-0.250),vec3(-1,1409.597222, 0.250),vec3( 1,1409.602778, 0.250),\nvec3(-1,1407.397222,-0.250),vec3( 1,1407.402778,-0.250),vec3(-1,1407.597222, 0.250),vec3( 1,1407.602778, 0.250),vec3(-1,1408.397222,-0.250),vec3( 1,1408.402778,-0.250),vec3(-1,1408.597222, 0.250),vec3( 1,1408.602778, 0.250),\nvec3(-1,1579.397222,-2.250),vec3( 1,1579.402778,-2.250),vec3(-1,1579.597222,-2.250),vec3( 1,1579.602778,-2.250),vec3(-1,1588.397222, 2.250),vec3( 1,1588.402778, 2.250),vec3(-1,1588.597222, 2.250),vec3( 1,1588.602778, 2.250),\nvec3(-1,1580.397222,-1.750),vec3( 1,1580.402778,-1.750),vec3(-1,1580.597222,-1.750),vec3( 1,1580.602778,-1.750),vec3(-1,1587.397222, 1.750),vec3( 1,1587.402778, 1.750),vec3(-1,1587.597222, 1.750),vec3( 1,1587.602778, 1.750),\nvec3(-1,1581.397222,-1.250),vec3( 1,1581.402778,-1.250),vec3(-1,1581.597222,-1.250),vec3( 1,1581.602778,-1.250),vec3(-1,1586.397222, 1.250),vec3( 1,1586.402778, 1.250),vec3(-1,1586.597222, 1.250),vec3( 1,1586.602778, 1.250),\nvec3(-1,1582.397222,-0.750),vec3( 1,1582.402778,-0.750),vec3(-1,1582.597222,-0.750),vec3( 1,1582.602778,-0.750),vec3(-1,1585.397222, 0.750),vec3( 1,1585.402778, 0.750),vec3(-1,1585.597222, 0.750),vec3( 1,1585.602778, 0.750),\nvec3(-1,1583.397222,-0.250),vec3( 1,1583.402778,-0.250),vec3(-1,1583.597222,-0.250),vec3( 1,1583.602778,-0.250),vec3(-1,1584.397222, 0.250),vec3( 1,1584.402778, 0.250),vec3(-1,1584.597222, 0.250),vec3( 1,1584.602778, 0.250),\nvec3(-1,1755.397222,-1.375),vec3( 1,1755.402778,-1.375),vec3(-1,1755.597222,-0.875),vec3( 1,1755.602778,-0.875),vec3(-1,1764.397222, 0.875),vec3( 1,1764.402778, 0.875),vec3(-1,1764.597222, 1.375),vec3( 1,1764.602778, 1.375),\nvec3(-1,1756.397222,-1.125),vec3( 1,1756.402778,-1.125),vec3(-1,1756.597222,-0.625),vec3( 1,1756.602778,-0.625),vec3(-1,1763.397222, 0.625),vec3( 1,1763.402778, 0.625),vec3(-1,1763.597222, 1.125),vec3( 1,1763.602778, 1.125),\nvec3(-1,1757.397222,-0.875),vec3( 1,1757.402778,-0.875),vec3(-1,1757.597222,-0.375),vec3( 1,1757.602778,-0.375),vec3(-1,1762.397222, 0.375),vec3( 1,1762.402778, 0.375),vec3(-1,1762.597222, 0.875),vec3( 1,1762.602778, 0.875),\nvec3(-1,1758.397222,-0.625),vec3( 1,1758.402778,-0.625),vec3(-1,1758.597222,-0.125),vec3( 1,1758.602778,-0.125),vec3(-1,1761.397222, 0.125),vec3( 1,1761.402778, 0.125),vec3(-1,1761.597222, 0.625),vec3( 1,1761.602778, 0.625),\nvec3(-1,1759.397222,-0.375),vec3( 1,1759.402778,-0.375),vec3(-1,1759.597222, 0.125),vec3( 1,1759.602778, 0.125),vec3(-1,1760.397222,-0.125),vec3( 1,1760.402778,-0.125),vec3(-1,1760.597222, 0.375),vec3( 1,1760.602778, 0.375),\nvec3(-1,2107.397222,-1.125),vec3( 1,2107.402778,-1.125),vec3(-1,2107.597222,-1.125),vec3( 1,2107.602778,-1.125),vec3(-1,2116.397222, 1.125),vec3( 1,2116.402778, 1.125),vec3(-1,2116.597222, 1.125),vec3( 1,2116.602778, 1.125),\nvec3(-1,2107.397222,-2.500),vec3( 1,2107.402778,-2.500),vec3(-1,2107.597222,-2.000),vec3( 1,2107.602778,-2.000),vec3(-1,2116.397222, 2.000),vec3( 1,2116.402778, 2.000),vec3(-1,2116.597222, 2.500),vec3( 1,2116.602778, 2.500),\nvec3(-1,2108.397222,-0.875),vec3( 1,2108.402778,-0.875),vec3(-1,2108.597222,-0.875),vec3( 1,2108.602778,-0.875),vec3(-1,2115.397222, 0.875),vec3( 1,2115.402778, 0.875),vec3(-1,2115.597222, 0.875),vec3( 1,2115.602778, 0.875),\nvec3(-1,2108.397222,-2.000),vec3( 1,2108.402778,-2.000),vec3(-1,2108.597222,-1.500),vec3( 1,2108.602778,-1.500),vec3(-1,2115.397222, 1.500),vec3( 1,2115.402778, 1.500),vec3(-1,2115.597222, 2.000),vec3( 1,2115.602778, 2.000),\nvec3(-1,2109.397222,-0.625),vec3( 1,2109.402778,-0.625),vec3(-1,2109.597222,-0.625),vec3( 1,2109.602778,-0.625),vec3(-1,2114.397222, 0.625),vec3( 1,2114.402778, 0.625),vec3(-1,2114.597222, 0.625),vec3( 1,2114.602778, 0.625),\nvec3(-1,2109.397222,-1.500),vec3( 1,2109.402778,-1.500),vec3(-1,2109.597222,-1.000),vec3( 1,2109.602778,-1.000),vec3(-1,2114.397222, 1.000),vec3( 1,2114.402778, 1.000),vec3(-1,2114.597222, 1.500),vec3( 1,2114.602778, 1.500),\nvec3(-1,2110.397222,-0.375),vec3( 1,2110.402778,-0.375),vec3(-1,2110.597222,-0.375),vec3( 1,2110.602778,-0.375),vec3(-1,2113.397222, 0.375),vec3( 1,2113.402778, 0.375),vec3(-1,2113.597222, 0.375),vec3( 1,2113.602778, 0.375),\nvec3(-1,2110.397222,-1.000),vec3( 1,2110.402778,-1.000),vec3(-1,2110.597222,-0.500),vec3( 1,2110.602778,-0.500),vec3(-1,2113.397222, 0.500),vec3( 1,2113.402778, 0.500),vec3(-1,2113.597222, 1.000),vec3( 1,2113.602778, 1.000),\nvec3(-1,2111.397222,-0.125),vec3( 1,2111.402778,-0.125),vec3(-1,2111.597222,-0.125),vec3( 1,2111.602778,-0.125),vec3(-1,2112.397222, 0.125),vec3( 1,2112.402778, 0.125),vec3(-1,2112.597222, 0.125),vec3( 1,2112.602778, 0.125),\nvec3(-1,2111.397222,-0.500),vec3( 1,2111.402778,-0.500),vec3(-1,2111.597222, 0.000),vec3( 1,2111.602778, 0.000),vec3(-1,2112.397222, 0.000),vec3( 1,2112.402778, 0.000),vec3(-1,2112.597222, 0.500),vec3( 1,2112.602778, 0.500));\n\nfloat intfract(int s, float p);\nconst float pi = 3.1415927;\n\nvec2 mainSound( int s) {\n  float v = 0.;\n    \n  for (int i=0; i<partials.length(); i++) {\n    vec3 p = partials[i];\n    v += p.x/320.*cos(2.*pi*(intfract(s, iSampleRate/p.y) - p.z));\n  }\n\n  return vec2(v);\n}\n\nfloat intfract(int s, float p) {\n  // Implements fract(s/n)\n  // Explanation and copyright: shadertoy.com/view/4ltfRN\n  // Given sample number and period, calculate phase with high accuracy.\n  // Uses integer overflow for modulo.\n  int sp = int(p), a = s%sp, b = (s/sp);\n  const float MAXF = float(uint(-1))+1.;\n  return fract(  (float(a)/p) + float((uint(b)*uint(MAXF*float(sp)/p)))/MAXF );\n}\n", "sound_code": "\nvec2 mainSound( in int s, float time_DO_NOT_USE)\n{\n    return mainSound(s);\n}\n", "sound_inputs": [], "buffer_a_code": "void mainImage( out vec4 v, in vec2 fc )\n{\n    if (int(fc.y)!=0) discard;\n    float x = fc.x/iResolution.x-.5;\n    v.x = mainSound( int((.02*x+round(iTime*264.)/264.)*iSampleRate)).x;\n}\n", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsyWr.jpg", "access": "api", "license": "isc", "functions": [[1217, 1265, 1408, 1408, 1409], [4619, 4619, 4676, 4726, 5153]], "test": "untested"}
{"id": "3tscWr", "name": "Multi-Pass Fluid", "author": "wyatt", "description": "..", "tags": ["fluid"], "likes": 4, "viewed": 436, "published": 3, "date": "1591837062", "time_retrieved": "2024-07-30T21:01:44.409560", "image_code": "Main {\n\tQ = 0.5+0.5*A(U)+B(U)*10.+.4*A(U).wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage(out vec4 Q, vec2 U)", "buffer_a_code": "Main {\n\tQ = A(U-A(U).xy);\n    vec4 \n        n = B(U+vec2(0,1)),\n        e = B(U+vec2(1,0)),\n        s = B(U-vec2(0,1)),\n        w = B(U-vec2(1,0));\n\tQ.xy -= vec2(e.z-w.z,n.z-s.z);\n    \n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<5.)\n        Q.xw = vec2(.5,1);\n    if (length(U-0.5*R)<5.)\n        Q.xw = vec2(-.5,1);\n\tif (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tvec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n\t\n    Q = -0.25*vec4(e.x-w.x+n.y-s.y);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = vec4(0);\n    for (int x = -10; x <= 10; x++) {\n    \tfor (int y = -10; y <= 10; y++) {\n    \t\tvec2 u = vec2(x,y);\n            vec4 a = B(U+u);\n            float l = length(u);\n            if (length(l)>0.) {\n            \tQ += a/(l*l);\n            }\n    \t}\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = vec4(0);\n    for (int x = -3; x <= 3; x++) {\n    \tfor (int y = -3; y <= 3; y++) {\n    \t\tvec2 u = vec2(x,y);\n            vec4 a = C(U+u);\n            float l = length(u);\n            if (length(l)>0.) {\n            \tQ += a*exp(-l*l);\n            }\n    \t}\n    }\n    Q /= 2.5;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tscWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3llcDn", "name": "bubble gum", "author": "firanolfind", "description": "2d colourful plasma", "tags": ["metaballs", "plasma", "bubbles"], "likes": 17, "viewed": 674, "published": 3, "date": "1591829201", "time_retrieved": "2024-07-30T21:01:45.176510", "image_code": "// forked from https://www.shadertoy.com/view/4tl3Rn\n\nfloat roundLookingBlob(vec2 fragCoord, vec2 tPos, float r) {\n    vec2 pos = fragCoord.xy/iResolution.yy - vec2(0.5);\n    pos.x -= ((iResolution.x-iResolution.y)/iResolution.y)/2.0;\n    return pow(max(1.0-length(pos-tPos), 0.0) , r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat v = 0.0 \n        + roundLookingBlob(fragCoord * 0.2,vec2(sin(iTime)* 2.0, cos(iTime)*0.004), 10.0)\n    \t+ roundLookingBlob(fragCoord,vec2(sin(iTime*0.6)*0.2, cos(iTime)*0.3), 7.0)\n    \t+ roundLookingBlob(fragCoord,vec2(cos(iTime*0.8)*0.3, sin(iTime*1.1)*0.04), 5.0)\n    \t+ roundLookingBlob(fragCoord,vec2(cos(iTime*0.2)*0.2, sin(iTime*0.9)*0.05), 8.0)\n    \t+ roundLookingBlob(fragCoord,vec2(cos(iTime*1.2)*0.2, 2.0 *sin(iTime*0.9)*0.05), 8.0)\n        + roundLookingBlob(fragCoord,vec2(cos(iTime*0.3)*0.4, sin(iTime*1.1)*0.4), 5.0)\n    \t+ roundLookingBlob(fragCoord,vec2(sin(iTime*0.6)*0.9, cos(iTime)*0.3), 7.0)\n    \t+ roundLookingBlob(fragCoord,vec2(sin(iTime*0.6)*0.3, cos(iTime)*0.8), 7.0)\n        + roundLookingBlob(fragCoord,vec2(cos(iTime*0.3)*0.9, sin(iTime*0.1)*0.4), 3.0)\n        ;\n    v = clamp((v-0.5)*1000.0, 0.0, 1.0);\n    //v = 1.0;\n    //float color = cos(iTime * fragCoord.x) * 1.0;\n    //v *= color;\n    //float r = 1.0 + fragCoord.y *sin(iTime * 0.5) +  0.0001 * (2.0 * sin(iTime * 1.0)) ;\n    float r = \n        -1.0 * 1.0 *sin(iTime) \n        - 2.0* cos(1.0 * iTime) * fragCoord.x / iResolution.x * fragCoord.y / iResolution.y;\n    float g = 0.0 - 0.5 * cos(2.0 * iTime) *  fragCoord.y / iResolution.y; //1.0* sin(iTime) - r + 0.8;\n    float b = 4.0 + sin(iTime) - g + 0.8;\n\tfragColor = vec4(r * v, v * g, v * b, 0.0);\n}\n\n//* fragCoord.y * fragCoord.x", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 114, 114, 288], [290, 290, 347, 347, 1695]], "test": "untested"}
{"id": "tlXcDr", "name": "Random Number Towers", "author": "Oggbog", "description": "Random number thingy\nBased on my LED clock https://www.shadertoy.com/view/tllyz7", "tags": ["random"], "likes": 11, "viewed": 425, "published": 3, "date": "1591826510", "time_retrieved": "2024-07-30T21:01:46.040201", "image_code": "//   Segment numbers\n//   ===============\n//\n//\t\t 0\n//\t\t###\n//\t   #   #\n//\t  1#   #2\n//\t   # 3 #\n//\t\t###\n//\t   #   #\n//\t  4#   #5\n//\t   #   #\n//\t\t###\n//\t\t 6\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n\nfloat segment(vec2 uv,int o){\n    \n    \n    float d = o==1 ? abs(uv.x):abs(uv.y);\n   \n    d = smoothstep(0.11,0.101,d);\n    d *= smoothstep(0.49,0.488,abs(uv.x+uv.y));\n    d *= smoothstep(0.49,0.488,abs(uv.x-uv.y));\n    \n    return d;\n}\n\nfloat digit(vec2 uv,int n){\n    float d = 0.0;\n    float b = 0.2; // brightness\n    uv *= 2.4;\n    // segment 0\n    if(n!=1 && n!=4){\n    \td += segment(uv-vec2(0.0,1.0),0);\n    } else {\n        d += segment(uv-vec2(0.0,1.0),0)*b;\n    }\n    // segment 1\n    if (n!=1 && n!=2 && n!=3 && n!=7){\n    \td += segment(uv-vec2(-0.5,0.5),1);\n    } else {\n        d += segment(uv-vec2(-0.5,0.5),1)*b;\n    }\n    // segment 2\n    if (n!=5 && n!=6){ \n    \td += segment(uv-vec2(0.5),1);\n    } else {\n        d += segment(uv-vec2(0.5),1)*b;\n    }\n    // segment 3\n    if (n!=0 && n!=1 && n!=7){\n    \td += segment(uv,0);\n    } else {\n        d += segment(uv,0)*b;\n    }\n    // segment 4\n    if(n==0 || n==2 || n==6 || n==8){\n    \td += segment(uv-vec2(-0.5),1);\n    } else {\n        d += segment(uv-vec2(-0.5),1)*b;\n    }\n    // segment 5\n    if(n!=2){\n    \td += segment(uv-vec2(0.5,-0.5),1);\n    } else {\n        d += segment(uv-vec2(0.5,-0.5),1)*b;\n    }\n    // segment 6\n    if(n!=1 && n!=4 && n!=7){\n    \td += segment(uv-vec2(0.0,-1.0),0);\n    } else {\n        d += segment(uv-vec2(0.0,-1.0),0)*b;\n    }\n    return d;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates and adjust aspect ratio\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 lv = uv;\n    //uv.y -= iTime/2.;\n    uv.x -= sin(iTime/3.);\n    uv *= 2.; \n    vec2 gv = fract(uv * 5.0)-0.5;\n    vec2 id = floor(uv * 5.0);\n    \n    vec2 id2 = floor(lv * 200.0);\n    \n    float rd = mod(iTime*0.2+hash21(id2),10.0);\n    float d = digit(gv,int(mod(hash21(id)*10.+iTime,10.0)));\n    float e = digit(lv,int(rd));\n    \n    d *= abs(sin(uv.x*1.9)*0.8);\n    \n    vec3 col = vec3(d,0.,d/3.0);\n   \tcol = mix(col,vec3(e,e,e),e);\n\t\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 180, 180, 280], [283, 283, 312, 312, 519], [521, 521, 548, 548, 1626], [1632, 1632, 1689, 1749, 2329]], "test": "untested"}
{"id": "3llcWn", "name": "Overlapping Voronoi - Squares", "author": "izutionix", "description": "euclidean version: [url]https://shadertoy.com/view/WdjfDK[/url]\ncomment out the #define AA to disable anti-aliasing (for performance)", "tags": ["voronoi", "worley", "manhattan", "layers", "greeble", "chebychev", "sorted", "overlapping"], "likes": 16, "viewed": 554, "published": 3, "date": "1591825799", "time_retrieved": "2024-07-30T21:01:46.879955", "image_code": "#define AA\n\n#define t iTime + 5.\n#define screen(a, b) a + b - a*b\n#define s(t, b, g) smoothstep(t+b*t, t-b*t, abs(g-.5) )\n\n//hash functions from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p *= 733.424;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 *= 733.424;\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\t\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 voronoi2d(vec2 p, float s, bool m) {\n    vec2 gv = fract(p)-.5;\n\tvec2 iv = floor(p);\n    vec2 id;\n    \n    vec2 o;\n    float res = 8.;\n    \n    for(int y=-1; y<=1; y++)\n\tfor(int x=-1; x<=1; x++)\n    {\n        o = vec2(x, y);\n\n        vec2 n = hash22(iv+o);\n        vec2 p = o+.5*sin(t*n);\n        vec2 a = gv-p;\n        a = abs(a);\n        \n        float d;\n        if(m)\n        \td = (a.x+a.y)/s; //manhattan\n        else\n        \td = max(a.x, a.y)/s; //chebychev\n\n        if(hash12(n)>.5 ? d<1. : 1.<res) {\n            res = d;\n            id = iv+p;\n        }\n    }\n    return vec3(res, id*float(res<1.) );\n}\n\nvec4 voronoi3d(vec3 p, float s, bool m) {\n    vec3 gv = fract(p)-.5;\n\tvec3 iv = floor(p);\n    vec3 id;\n    \n    vec3 o;\n    float res = 8.;\n    \n    for(int z=-1; z<=1; z++)\n    for(int y=-1; y<=1; y++)\n\tfor(int x=-1; x<=1; x++)\n    {\n        vec3 o = vec3(x, y, z);\n\n        vec3 n = hash33(iv+o);\n        vec3 p = o+.5*sin(t*n);\n\t\tvec3 a = gv-p;\n        a = abs(a);\n        \n        float d;\n        if(m)\n\t\t\td = (a.x+a.y+a.z)/s; //manhattan\n        else\n        \td = max(max(a.x, a.y), a.z)/s; //chebychev\n\n        if(hash13(n)>.5 ? d<1. : 1.<res) {\n            res = d;\n            id = iv+p;\n        }\n    }\n    return vec4(res, id*float(res<1.) );\n}\n\nfloat getCol(vec2 coord) {\n    vec2 R = iResolution.xy;\n\tvec2 uv1 = (coord-.5*R.xy)/R.y;\n    vec3 uv2 = vec3(coord/R.xy, R.x/R.y);\n\tuv1 *= 8.;\n    \n    float size = 1.;\n    bool method = uv2.x<.5;\n    \n    float v = voronoi2d(uv1, size, method).x;\n    \n    if(uv2.y>.5)\n    \tv = step(.9, v)*float(v<1.);\n    else\n    \tv = voronoi3d(vec3(uv1, 0), size, method).w*.5+.5;\n    \n    v = screen(v, s(.0025, \t\t .2, uv2.x ) );\n    v = screen(v, s(.0025*uv2.z, .2, uv2.y ) );\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 R = iResolution.xy;\n    \n    float v;\n    \n#ifdef AA\n    // AA from https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n\tconst float S = .125;\n    const float L = .375;\n    v  = getCol( fragCoord + vec2( S,-L) );\n    v += getCol( fragCoord + vec2( L, S) );\n    v += getCol( fragCoord + vec2(-S,-L) );\n    v += getCol( fragCoord + vec2(-L,-S) );\n    v *= .25;\n    \n#else\n\tv = getCol(fragCoord);\n    \n#endif\n    fragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 183, 204, 204, 355], [357, 357, 379, 379, 522], [525, 525, 547, 547, 664], [666, 666, 689, 689, 792], [795, 795, 836, 836, 1411], [1413, 1413, 1454, 1454, 2068], [2070, 2070, 2096, 2096, 2557], [2559, 2559, 2616, 2616, 3071]], "test": "untested"}
{"id": "3lsyWn", "name": "F***************************", "author": "postviolet", "description": "♥\ninspired by newsfeed", "tags": ["raymarching", "fuck"], "likes": 9, "viewed": 382, "published": 3, "date": "1591824805", "time_retrieved": "2024-07-30T21:01:47.716718", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nmat4 rotateX( in float angle ) {\n  return mat4(1.0,0,0,0,0,cos(angle),-sin(angle),0,0,sin(angle),cos(angle),0,0,0,0,1);\n}\n\nmat4 rotateY( in float angle ) {\n  return mat4(cos(angle),0,sin(angle),0,0,1.0,0,0,-sin(angle),0,cos(angle),0,0,0,0,1);\n}\n\nmat4 rotateZ( in float angle ) {\n  return mat4(cos(angle),-sin(angle),0,0,sin(angle),cos(angle),0,0,0,0,1,0,0,0,0,1);\n}\n\nfloat Capsule( vec3 p, float h, float r ) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat Fuck (vec3 p) {\n    \n    float f1 = Capsule(vec3(p.x,p.y+0.25,p.z),0.5, 0.29);\n    float f2 = Capsule(vec3(p.x+0.5,p.y,p.z),0.5,0.29);\n    \n    float f3 = Capsule(vec3(p.x+1.0,p.y,p.z),0.7,0.29);\n    \n    float t3 = sin(iTime*5.)/5.8+0.5;\n    vec3 pf3a = (vec4(vec3(p.x+1.0,p.y-0.75,p.z),1.) * rotateX(5.01+t3)).xyz;\n    float f3a = Capsule(pf3a,0.65,0.29);\n    \n    float f3combo = opSmoothUnion(f3,f3a,0.1);\n    \n    float f4 = Capsule(vec3(p.x+1.5,p.y,p.z),0.55,0.29);\n    \n    vec3 p5 = (vec4(p,1.) * rotateZ(-0.6)).xyz;\n    float f5 = Capsule(vec3(p5.x+1.6,p5.y-0.65,p5.z-0.2),0.5,0.28);\n    \n    float fngrs = opSmoothUnion(\n        opSmoothUnion(\n            opSmoothUnion(\n                opSmoothUnion(f1, f2, 0.1)\n                ,f3combo, 0.1),\n            f4,0.1),\n        f5,0.1);\n    \n    vec3 pk1 = (vec4(p,1.) * rotateZ(-1.6)).xyz;\n    float k1 = Capsule(vec3(pk1.x+0.35,pk1.y-0.04,pk1.z),1.5, 0.34);\n    \n    return opSmoothUnion(fngrs,k1,0.1);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    \n  samplePoint = (rotateY(sin(iTime/2.)) * vec4(samplePoint, 1.)).xyz;\n  samplePoint = opRep(samplePoint, vec3(10., 10., 14.));\n    \n    return Fuck(samplePoint+0.2);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n      return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          2.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.8,0.1,0.1);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(1.5,5.0,2.0);\n    vec3 light2Intensity = vec3(1.0,0.5,0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 dir = rayDirection(45., iResolution.xy, fragCoord.xy);\n    \n    vec3 eye = vec3(0., 0., 10);\n    \n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n    }\n    \n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.5,0.0,0.4);\n    vec3 K_d = vec3(0.7,1.0,2.0+sin(iTime));\n    vec3 K_s = vec3(1.0,1.0,1.0);\n    float shininess = 20.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 160, 160, 211], [213, 213, 245, 245, 334], [336, 336, 368, 368, 457], [459, 459, 491, 491, 578], [580, 580, 623, 623, 682], [684, 684, 736, 736, 835], [837, 837, 858, 858, 1806], [1808, 1808, 1842, 1842, 2015], [2017, 2017, 2108, 2108, 2417], [2419, 2419, 2484, 2484, 2616], [2618, 2618, 2647, 2647, 2957], [2959, 2959, 3099, 3099, 3528], [3530, 3530, 3615, 3615, 4317], [4319, 4319, 4376, 4376, 4958]], "test": "untested"}
{"id": "tlXyWr", "name": "Transparency Test 2", "author": "Leria", "description": "With density", "tags": ["transparency", "color", "blending", "density", "opacity"], "likes": 1, "viewed": 307, "published": 3, "date": "1591807301", "time_retrieved": "2024-07-30T21:01:48.581407", "image_code": "#define RADIUS 10.\n\n#define PI 3.14\n\nfloat current_transparency(vec3 p, float l, float material_coef)\n{\n   vec4 dens = texture(iChannel0, p);\n   return exp(-l*material_coef*dens.r); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o;   \n}\n\n#define transp current_transparency\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n \treturn length((pXp0)) - radius;   \n}\n\nconst vec3 cam = vec3(0., 0., 20.);\nfloat uniform_step = .1;\n\nvoid draw(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    //antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing/jittering\n    vec3 p = cam+dir*antialiasing;\n    int s = 0;\n    \n    vec3 h_col = vec3(1., .1, .8);\n    \n    float t = 1.;\n    float dist_acc = 0.;\n    \n    float r_t = transp(p, uniform_step, .1);\n    float g_t = transp(p, uniform_step, .9);\n    float b_t = transp(p, uniform_step, .1);\n    \n    vec3 rgb_t = vec3(r_t, g_t, b_t);\n    \n    float r_t2 = transp(p, uniform_step, .9);\n    float g_t2 = transp(p, uniform_step, .1);\n    float b_t2 = transp(p, uniform_step, .1);\n    \n    vec3 rgb_t2 = vec3(r_t2, g_t2, b_t2);\n\n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n    vec3 t_acc2 = vec3(1.); //accumulated transparency\n    \n    for(s; s < 150; s++)\n    {               \n        \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p-cam, p-cam);\n        float dist_center = length(center-cam);\n        \n        //if too far, then big step        \n        if(sqrt(dist_dist)-(dist_center-radius) < 0.)\n        {\n        \tk_step = dist_center-(radius);\n        }\n\n        //if in the shape, draw\n        if( sdf_sphere(p-center, RADIUS) <= 0.)\n        {\n            \n           \t//blending\n        \tc += t_acc*vec3(1.)*(1.-rgb_t);\n\t\t\tt_acc *= rgb_t;  \n        }   \n        \n        if( sdf_sphere(p-vec3(2., -3., -2.), RADIUS-1.) <= 0.)\n        {\n            c += t_acc*vec3(1., 1., 0.)*(1.-rgb_t2);\n\t\t\tt_acc *= rgb_t2;\n        }   \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p-cam) > max((dist_center+radius), (length(vec3(2., -3., -2.)-cam)+(radius-1.))))\n        {\n         \tbreak;\n        }\n        \n        p += dir*k_step;       \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    \n    draw(normalize(vec3(uv, -1.)), vec3(0., 0., 0.), vec3(0., 1., 0.), RADIUS, color);\n    \n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 103, 103, 184], [186, 186, 218, 218, 238], [240, 240, 274, 274, 298], [337, 337, 380, 380, 419], [483, 483, 558, 558, 2323], [2325, 2325, 2382, 2382, 2609]], "test": "untested"}
{"id": "tllyz7", "name": "LED Clock", "author": "Oggbog", "description": "LED clock", "tags": ["clock", "led", "digits"], "likes": 6, "viewed": 432, "published": 3, "date": "1591806240", "time_retrieved": "2024-07-30T21:01:49.441108", "image_code": "//   Segment numbers\n//   ===============\n//\n//\t\t 0\n//\t\t###\n//\t   #   #\n//\t  1#   #2\n//\t   # 3 #\n//\t\t###\n//\t   #   #\n//\t  4#   #5\n//\t   #   #\n//\t\t###\n//\t\t 6\n\n\n\n\nfloat segment(vec2 uv,int o){\n    \n    \n    float d = o==1 ? abs(uv.x):abs(uv.y);\n   \n    d = smoothstep(0.11,0.101,d);\n    d *= smoothstep(0.49,0.488,abs(uv.x+uv.y));\n    d *= smoothstep(0.49,0.488,abs(uv.x-uv.y));\n    \n    return d;\n}\n\nfloat digit(vec2 uv,int n){\n    float d = 0.0;\n    float b = 0.2; // brightness\n    uv *= 2.4;\n    // segment 0\n    if(n!=1 && n!=4){\n    \td += segment(uv-vec2(0.0,1.0),0);\n    } else {\n        d += segment(uv-vec2(0.0,1.0),0)*b;\n    }\n    // segment 1\n    if (n!=1 && n!=2 && n!=3 && n!=7){\n    \td += segment(uv-vec2(-0.5,0.5),1);\n    } else {\n        d += segment(uv-vec2(-0.5,0.5),1)*b;\n    }\n    // segment 2\n    if (n!=5 && n!=6){ \n    \td += segment(uv-vec2(0.5),1);\n    } else {\n        d += segment(uv-vec2(0.5),1)*b;\n    }\n    // segment 3\n    if (n!=0 && n!=1 && n!=7){\n    \td += segment(uv,0);\n    } else {\n        d += segment(uv,0)*b;\n    }\n    // segment 4\n    if(n==0 || n==2 || n==6 || n==8){\n    \td += segment(uv-vec2(-0.5),1);\n    } else {\n        d += segment(uv-vec2(-0.5),1)*b;\n    }\n    // segment 5\n    if(n!=2){\n    \td += segment(uv-vec2(0.5,-0.5),1);\n    } else {\n        d += segment(uv-vec2(0.5,-0.5),1)*b;\n    }\n    // segment 6\n    if(n!=1 && n!=4 && n!=7){\n    \td += segment(uv-vec2(0.0,-1.0),0);\n    } else {\n        d += segment(uv-vec2(0.0,-1.0),0)*b;\n    }\n    return d;\n}\n\nfloat box(vec2 uv){\n    float d = abs(uv.x);\n    \n    d = smoothstep(0.05,0.045,d) * smoothstep(0.05,0.045,abs(uv.y));\n    \n    return d;\n}\n\nfloat colon(vec2 uv){\n    \n    float d = box(uv-vec2(0.0,0.13));\n    \n    d += box(uv-vec2(0.0,-0.13));\n    \n    return d;\n    \n}\n\nfloat clock(vec2 uv){\n    float d = 0.0;\n    float time = iDate.w;\n    \n    float hour = floor(time/3600.0);\n    float minute = floor((time - hour*3600.0)/60.0);\n    float second = time - hour*3600.0 - minute*60.0;\n        \n    d += digit(uv-vec2(-1.55,0.0),int(floor(hour/10.0)));\n    d += digit(uv-vec2(-1.0,0.0),int(floor(mod(hour,10.0))));\n    \n    d += colon(uv-vec2(-0.65,0.0));\n    \n    d += digit(uv-vec2(-0.3,0.0),int(floor(minute/10.0)));\n    d += digit(uv-vec2(0.25,0.0),int(floor(mod(minute,10.0))));\n    \n    d+= colon(uv-vec2(0.6,0.0));\n    \n    d += digit(uv-vec2(0.95,0.0),int(floor(second/10.0)));\n    d += digit(uv-vec2(1.5,0),int(floor(mod(second,10.0))));    \n    \n    return d;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates and adjust aspect ratio\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 2.5; \n    \n    float d = clock(uv);\n    \n    vec3 col = vec3(0.0,d,0.0);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 190, 190, 397], [399, 399, 426, 426, 1504], [1506, 1506, 1525, 1525, 1645], [1647, 1647, 1668, 1668, 1776], [1778, 1778, 1799, 1799, 2478], [2483, 2483, 2540, 2600, 2811]], "test": "untested"}
{"id": "tlfcDn", "name": "Lattice Percolation", "author": "dr2", "description": "Percolation on a cubic lattice", "tags": ["random", "lattice", "cluster"], "likes": 12, "viewed": 379, "published": 3, "date": "1591805710", "time_retrieved": "2024-07-30T21:01:50.297817", "image_code": "// \"Lattice Percolation\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Lattice percolation: grid cells are randomly occupied with probability p; adjacent\n  occupied cells are assigned to the same cluster; as p increases the mean cluster size\n  grows, and above a critical vaue of p there is a nonzero probability that a cell belongs\n  to the 'infinite' cluster. This is an extensively studied model that exhibits critical\n  behavior, and is widely used in many fields (including disease spreading).\n  \n  Here, the value of p oscillates slowly over a range of values, occupied cells are shown\n  containing spheres, and adjacent occupied cells are connected.\n  \n  Normal and panoramic views - mouseable\n*/\n\nfloat Minv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\n\nvec3 ltDir, cId;\nfloat tCur, dstFar, pVal;\nbool cOcc;\nconst float pi = 3.14159;\n\nbool IsOcc (vec3 c)\n{\n  return (pVal + Hashfv3 (c) > 1.);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d, rc, bl;\n  d = dstFar;\n  rc = 0.1;\n  bl = 0.251;\n  if (cOcc) {\n    p -= cId + 0.5;\n    for (float s = -1.; s <= 1.; s += 2.) {\n      if (IsOcc (cId + vec3 (s, 0., 0.)))\n         d = min (d, max (length (p.yz) - rc, abs (p.x - s * bl) - bl));\n      if (IsOcc (cId + vec3 (0., s, 0.)))\n         d = min (d, max (length (p.xz) - rc, abs (p.y - s * bl) - bl));\n      if (IsOcc (cId + vec3 (0., 0., s)))\n         d = min (d, max (length (p.xy) - rc, abs (p.z - s * bl) - bl));\n    }\n    /*if (d < dstFar)*/ d = min (d, length (p) - 1.5 * rc);\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p);\n    if (cId != cIdP) {\n      cOcc = IsOcc (cId);\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (cId + step (0., rd) - p) * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, nDotL;\n  bgCol = vec3 (0.1, 0.25, 0.3);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = vec3 (0.3, 1., 0.7);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col * (0.1 + 0.3 * max (- dot (vn, ltDir), 0.) + 0.8 * nDotL * nDotL) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, 0.3 + 0.7 * smoothstep (0.4, 1., dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, colF[2], col;\n  vec2 canvas, uv, ut, mSize, mMid, msw;\n  float el, az, asp, regId, regBdy, tc, ti, nStep;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (asp * (1. - mSize.y), 1. - mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuMode = 0;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuMode = 1;\n  }\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    regId = 0.;\n    msw = (mPtr.xy * vec2 (asp, 1.) - 0.5 * mMid) / mSize;\n    if (max (abs (msw.x), abs (msw.y)) < 0.5) regId = 1.;\n    else msw = mPtr.xy;\n    if (vuMode == 0) {\n      az += 2. * pi * msw.x;\n      el += pi * msw.y;\n    }\n    if (regId == 1.) vuMode = 1 - vuMode;\n  }\n  regBdy = length (uv * vec2 (1. / asp, 1.)) - 1.5 * SmoothBump (0.5, 0.997, 0.003, mod (0.03/4. * tCur, 1.));\n  if (regBdy < 0.) vuMode = 1 - vuMode;\n  if (vuMode == 0 && mPtr.z <= 0.) {\n    az = -0.3 * pi * sin (0.01 * pi * tCur);\n    el = -0.1 * pi * cos (0.005 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.01, 0.01, 0.5 * tCur);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 50.;\n  if (vuMode == 0) rd = normalize (vec3 (uv, 2.));\n  else rd = normalize (vec3 (0.5 * sin (uv.x * pi / asp + vec2 (0., 0.5 * pi)), uv.y).xzy);\n  rd = vuMat * rd;\n  tc = 1. - abs (1. - mod (0.03 * tCur, 2.));\n  nStep = 25.;\n  ti = floor (nStep * tc) / nStep;\n  for (int k = 0; k < 2; k ++) {\n    pVal = 0.01 + 0.98 * (ti + float (k) / nStep) ;\n    colF[k] = ShowScene (ro, rd);\n  }\n  col = mix (colF[0], colF[1], (tc - ti) * nStep);\n  if (vuMode == 1) col = pow (col, vec3 (0.9));\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 3. ||\n     abs (regBdy) * canvas.y < 1.) col = vec3 (0.5, 0.5, 0.);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcDn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1017, 1017, 1038, 1038, 1076], [1078, 1078, 1100, 1100, 1666], [1668, 1668, 1701, 1701, 2274], [2276, 2276, 2297, 2297, 2545], [2547, 2547, 2582, 2582, 3111], [3113, 3113, 3166, 3166, 5138], [5140, 5140, 5162, 5162, 5200], [5202, 5202, 5259, 5259, 5342], [5344, 5344, 5380, 5380, 5586], [5588, 5588, 5618, 5618, 5676], [5710, 5710, 5734, 5734, 5799]], "test": "untested"}
{"id": "3tfyDn", "name": "Shadertoy tutorial demofox", "author": "demofox", "description": "This is the final state of the tutorial in this video:\nhttps://www.youtube.com/watch?v=1DLxaQD0YXM", "tags": ["tutorial"], "likes": 1, "viewed": 372, "published": 3, "date": "1591804820", "time_retrieved": "2024-07-30T21:01:51.251268", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    // calculate pixel as a percent\n\tvec2 percent = fragCoord/iResolution.xy;\n    percent -= vec2(0.5f, 0.5f);\n    percent.x /= aspectRatio;\n\n    // get the circle instance grid cell\n    vec2 instanceCell = floor(percent / 0.3f);\n    \n    // repeat the circle\n    percent = mod(percent, 0.3f);\n    \n    // calculate radius\n    float radiusPercent = (((sin(instanceCell.x * 100.0f) + cos(instanceCell.y * 537.0f)) + 2.0f) / 4.0f);\n    float radius = mix(0.05, 0.12, radiusPercent);\n    \n    // calculate color\n    vec3 color = vec3(\n        mod(abs(instanceCell.x) * 1043.0f, 10.0) / 10.0f,\n        mod(abs(instanceCell.y) * 1043.0f, 10.0) / 10.0f,\n        mod(abs(instanceCell.x*instanceCell.y + 3.0f) * 1043.0f, 10.0) / 10.0f\n    );\n    \n    // calculate distance of pixel from circle\n    float dist = length(percent - vec2(0.15, 0.15)) - radius;\n\n    // calculate shade of circle based on distance & smooth it out for anti aliasing.\n    float shade = smoothstep(0.0f, 0.005f, dist);\n    \n    // make the actual color\n    color = mix(color, vec3(1.0f, 1.0f, 1.0f), shade);\n    \n    // output final color\n\tfragColor = vec4(color, 1.0f);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1260]], "test": "untested"}
{"id": "3tscR8", "name": "2D Realtime Path Tracing", "author": "Shane", "description": "Low sample realtime 2D global illumination of a bidirectional Truchet field with temporal camera reprojection to give the impression of higher sampled imagery.", "tags": ["global", "illumination", "truchet", "tracing", "path", "denoise", "reprojection", "radiosity"], "likes": 71, "viewed": 2428, "published": 3, "date": "1591792254", "time_retrieved": "2024-07-30T21:01:52.309439", "image_code": "/*\n\n\t2D Realtime Path Tracing\n\t------------------------\n\n\t2D path tracing, or just one ultra expensive Voronoi-Truchet texture, depending on \n    your perspective. :) Technically speaking, this is a very low-sample path traced \n    rendering of a 2D distance field that has been stored in the channels of a screen \n    buffer, then camera reprojected a few times to give the impression of a much higher \n    sampling... I'll explain that in more detail further down the page. :) The 2D \n    distance field itself is an animated bidirectional Truchet pattern, encoded into \n    one of the faces of the cube map.\n\n\tI love the 2D path tracing aesthetic. In fact, I even like the low sampled realtime\n    noisy imagery as well, but that's a personal thing. Not everyone likes digital noise, \n    and not everyone likes the expense of path tracing, which is fair enough, so that's \n    why you don't see too many examples on here. There's also the issue of being forced \n    to construct uninspiring low instruction scenery, which can be limiting as well.\n\n    However, it's possible to use a buffer with precalculated values to enable better \n    scenery, which I'm sure most are aware of. What people may not know, however, is\n    that there are great denoising techniques to alleviate noise issues -- Not entirely, \n    but enough so that some people might like to give realtime path tracing, or path \n    tracing in general, a try.\n\n    In this case, each screen render is stored in a buffer and mixed with the next to \n    blend in the noise. It's very effective on static imagery for anyone who's tried it. \n    Unfortunately, with moving imagery, you see ghosting trails, which look kind of cool, \n    but don't help with the illusion. Thankfully, it's possible to calculate  where the \n    current screen render is in relation to the previous one, then blend in the previous \n    render at the new position. This alleviates ghosting to quite a large degree. The end \n\tresult is a low sampled moving image that looks like (or is, in fact) a high sampled, \n    much more appealing one... to most people. Ironically, I love the noisy, pixelated \n    fake 90s demo aesthetic, which means this is redundant to me. :D\n\n\tAnyway, this is just a proof of concept to show that it's possible, but I wouldn't \n    pay too much attention to the code itself... It's correct enough to get the job done, \n    but was slapped together pretty quickly. Honestly, I wouldn't want to try to\n    interpret this, but I've commented it to enable anyone to get the general idea.\n    \n    Additionally, there are a few compiler directives in the \"Common\" tab to try that \n    might help.\n\n    By the way, this can be extended to 3D situations as well, and I intend to show that \n\tat some stage. In the meantime, IQ has an awesome 3D gloabally illuminated example, \n\tcomplete with denoising camera reprojection on Shadertoy that's well worth the look, \n    especially since examples like that are thin on the ground. On a side note, I remember \n    reading somewhere that if it wasn't for IQ, the average graphics programmer would be \n    several years behind where they are today. :)\n\n\n    Useful links:\n\n\t// 3D temporal reprojection: IQ puts up a lot of difficult to find code with\n    // very little fanfare. This is one example.\n    Some boxes - iq\n    https://www.shadertoy.com/view/Xd2fzR\n\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Gamma correction and screen presentation.\n    fragColor = pow(col, vec4(.4545));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Temporal camera reprojection: Without this option, you can see what the original\n// looks like without the higher sampling this technique brings. Just for the record,\n// the noisy image has a certain kind of shabby chic appeal to me. :D\n#define TEMPORAL_REPROJECTION\n\n// Show the Truchet pattern, or not. The alternative is just a grid of circles.\n// If you change this from the Truchet pattern to the circles one, remember to hit the \n// back\\reset button to reload the cube map.\n//\n// The Truchet pattern is more interesting, but I believe the static circles play off\n// the light better.\n#define TRUCHET_PATTERN\n\n\n// Even cheaper without the light tracing, but the shadows won't be there. \n// However, I've darkened the surrounds to give that effect.\n#define LIGHT_TRACE\n\n// Display the underlying distance field. Sometimes, this can be helpful. The\n// lighting definitely isn't as interesting though.\n//#define DISTANCE_FIELD_ONLY\n\n\n// Grid boundaries.\n//#define SHOW_GRID\n\n\n// Display the glowing light. It just a glowing blob moving in front of the\n// camera through the pattern.\n//#define SHOW_LIGHT\n\n\n// Distance field object ID. For the Truchet case, we're simply flagging the\n// inner and outer rails to give them some color.\nvec2 gIP;\n\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly. Basically, the pattern is wrapped on a 32 by 32 unit basis.\nfloat repSc = 32.;\n\n// The cubemap texture resolution.\n//#define iRes0 vec2(1024)\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\nvec2 hash22(vec2 p) {\n    //return vec2(0);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\n// IQ's vec2 to float hash, but with a repeat factor. If you repeat random\n// textures to wrap, then you need to wrap the random functions.\nfloat hash21Rep(vec2 p){ \n    p = mod(p, repSc); \n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\nvec2 hash22Rep(vec2 p) {\n    //return vec2(0);\n    p = mod(p, repSc);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\n// Believe it or not, the simple one-line function below took me ages to figure out. The \n// only refrences to it seem to be from some Microsoft documentation somewhere, because it's \n// all written in some obscure way that involves the term, \"fract(p)*2. - 1.,\" etc.\n//\n// Anyway, the following should have been obvious to me, but it wasn't: A unit cube centered \n// on a grid has six faces with a center at vec3(0), and 8 vertices at coordinates, \n// vec3(-.5, -.5, -.5), vec3(-.5, -.5, .5), etc. Therefore, using very basic UV mapping logic, \n// the faces will be the following:\n//\n// Left face: \n// // Wrapping and centering coordinates on the YZ plain: \n// p.yz = fract(p.yz) - .5;\n// // The X coordinate is at \"-.5\".\n// p.x = -.5;\n// // Texture coordinate. \n// vec4 tx = texture(texChannel, vec3(-.5, fract(p.yz) - .5));\n//\n// All faces follow the same logic, with a bit of UV flipping to get things facing the right \n// way, etc. Using uv = fract(uv) - .5:\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\n//\n//\n// From what I've noticed, the size of the cube you use doesn't seem to matter -- I'm \n// assuming this is due to an internal normalization process. Therefore, to save extra \n// calculations (which matter when doing 3D stuff), you may as well use the unit cube \n// figures above -- instead of vec3(fract(p)*2. - 1., 1), vec3(fract(p) - .5)*n, n), etc.\n \n\n// Reading in the texture from the right face of the cube: I chose this because it \n// writes more easily, but you can read from any, or as many, faces you'd like. I'm\n// assuming that all sides index into memory at the same rate, otherwise you'd have to\n// take that into consideration when favoring one side or the other.\n//\n// By the way, \"p\" is simply your \"uv\" coordinates, which are usually: \n// uv = fragCoord/iResolution.y, but could represent cube sides, like p.xz, etc.\nvec4 tx(samplerCube tx, vec2 p){    \n\n    return texture(tx, vec3(fract(p) - .5, .5));\n}\n\n// IQ's box function, with modified smoothing element.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's box function.\nfloat sBox(in vec2 p, in vec2 b){\n    \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n", "cube_a_code": "float dfGridObjects(vec2 p, vec2 ip, float sc){\n    \n    ip = mod(ip, repSc);\n  \n    float rnd = hash21(ip);\n    vec2 rnd2 = hash22(ip);\n    \n    if(ip.x < .001) {\n        sc *= .7; \n        \n    }\n    \n    float sz = (.07 + rnd*.15)*sc*1.55;\n    float d  = length(p - (rnd2 - .5)*.5*sc*1.) - sz;\n    // Rotated Manhattan... Needs work, so circles it is. :)\n    //p *= rot2(rnd*3.14159/4.);\n    //float d = sBoxS(p - (rnd2 - .5)*.5*sc*1.2, vec2(sz*1.3), .8*sc);\n    \n    \n    gIP = rnd2;\n    \n    return d;\n}\n\n\n// The Truchet pattern -- This one is animated, plus it has inner and outer \n// rails travelling in opposite directions, which I don't recall seeing here,\n// but someone may have done it already.\nfloat dfTruchet(vec2 p, vec2 ip, float sc){\n    \n   \n   \n    ip = mod(ip, repSc);\n    \n    // Unique random cell number.\n    float rnd = hash21(ip);\n    \n    // Horizontally flip random cell tiles.\n    if (rnd < .5) p = p.yx*vec2(1, -1);//p.y = -p.y; // p.x = -p.x, \n    \n    \n    // TRUCHET TILE.\n    //\n    // Two arcs, centered on diagonally opposite grid cell corners.\n    \n    // Circles, in opposite corners.\n    float d1 = length(p - .5*sc) - .5*sc;\n    float d2 = length(p + .5*sc) - .5*sc;\n    \n    \n    // Individual polar coordinates.\n    vec2 uv1 = vec2(d1, atan(p.y - .5*sc, p.x - .5*sc));\n    vec2 uv2 = vec2(d2, atan(p.y + .5*sc, p.x + .5*sc));\n\n   \n     \n    // Switch directions on alternate checkered cells. That's the standard\n    // way it's done.\n    if (mod(ip.x + ip.y, 2.)<.5) {\n        uv1 *= -1.;\n        uv2 *= -1.;\n    }\n    \n    if (rnd < .5){\n        uv1 *= -1.;\n        uv2 *= -1.;\n    }   \n   \n    // UV coordinates for each arc.\n    float gTm = 0.;// Global time: iTime, etc.\n    uv1 = vec2(uv1.x, fract(uv1.y*4./6.2831 + gTm));   \n    uv2 = vec2(uv2.x, fract(uv2.y*4./6.2831 + gTm));   \n\n \n    // Arc thickness.\n    float th = .175/2.*sc;\n\n    \n    // Number of polar partitions. Any more than 2, and it starts to look\n    // too busy.\n    const float aSc = 1.;\n    \n    // Arc length. Range: [0, 1]. \n    float arcL = .6;\n    \n    // Scaling to get to the right range... Circle circumferance, etc. Annoying, fiddly stuff. :)\n    arcL *= sc/3.1459/aSc;\n    \n    // The angular time component, which is set to twice that of the camera time to\n    // allow the light to pass through the open gaps unhindered.\n    float tm = iTime/3.;\n     \n\n    // Using the texture coordinates to render some repeat squares. You do this in the same\n    // way that you'd render any repeat squares. The added complication is the inside and \n    // outside tracks moving in opposing directions, but it's not that difficult.\n    \n    // This relates to the arc tangent (uv.y) normalization process, since we divided by\n    // this to convert so need to compensate. See above.\n    sc *= (4./6.2831);\n    \n    // Inner and outer arcs subtended to the top-left grid cell corner.\n    float tracksA = (mod(uv1.y + tm, 1./aSc) - 1./aSc/2.);\n    float tracksB = (mod(uv1.y - tm, 1./aSc) - 1./aSc/2.);\n\n    float tracks1 = sBoxS(vec2((uv1.x - (th + .002)), tracksA*sc), vec2((th - .002), arcL), .05*sc);\n    float tracks2 = sBoxS(vec2((uv1.x + (th - .002)), tracksB*sc), vec2((th - .002), arcL), .05*sc);\n\n    // Inner and outer arcs subtended to the bottom right grid cell corner.\n    tracksA = (mod(uv2.y + tm, 1./aSc) - 1./aSc/2.);\n    tracksB = (mod(uv2.y - tm, 1./aSc) - 1./aSc/2.);\n    \n    float tracks3 = sBoxS(vec2((uv2.x - (th + .002)), tracksA*sc), vec2((th - .002), arcL), .05*sc);\n    float tracks4 = sBoxS(vec2((uv2.x + (th - .002)), tracksB*sc), vec2((th - .002), arcL), .05*sc);\n\n    // Minimum inner and outer tracks.\n    tracks1 = min(tracks1, tracks3);\n    tracks2 = min(tracks2, tracks4);\n    \n    // ID for inner and out tracks. You could put more effort in here, but\n    // this will do.\n    gIP = tracks1<tracks2? vec2(0) : vec2(1);\n    \n    \n    // Return the minimum distance.\n    return min(tracks1, tracks2); \n    //d = max(d, sBox(p, vec2(.5*sc + .001))); // Used for neighbor checks.\n\n    \n}\n\n\n// Iterating through grid neighbors at a particular scale. Fiddly coding, but necessary.\nvec3 dfNeighbors(vec2 q){\n\n    \n    // Scale, ID, and distance field storage.\n    float sc = 1./repSc;\n    float d = 1e5;\n    vec2 id = vec2(0);\n    \n    \n    // It's funny. There are things that I deep down know won't work, but I'll try them\n    // anyway, because I know how annoying doing it properly will be. This is a rendering\n    // of a grid of offset circles. If you wish to offset them so there's cell overlap, you \n    // need to consider neighbors, which is fine.\n    //\n    // However, if you wish to bounce light around, things can be affected by objects that \n    // are several cells away. In this case, about 8 on either side. This means checking\n    // a crazy number of cells -- The kind of numbers that would fry your GPU. Thankfully,\n    // we can do this once at runtime, and store the overall distance field in a texture, or\n    // one of the cube map faces, which is what we're doing here.\n    \n    int iters = min(0, iFrame) + 8;\n    for(int j = -iters; j<=iters; j++){\n        for(int i = -iters; i<=iters; i++){\n\n \n            vec2 ip = floor(q/sc + vec2(i, j)*sc);\n            \n        \tvec2 p = q - (ip + .5)*sc;\n            \n            float dij = dfGridObjects(p, ip, sc);\n          \n            if(dij<d) {\n                d = dij;\n                id = gIP;//ip;\n            }\n \n        }\n    }\n    \n\n    \n    return vec3(d, id);\n    \n}\n\n\n// Loading a scaled distance field. In this case, it's the Truchet pattern. Technically,\n// it might be more correct to check the neighboring cells, but we're trying to save cycles.\nvec3 dfScale(vec2 p){\n\n    \n    // Scale, ID, and distance field storage.\n    float sc = 2./repSc;\n \n    // Cell ID and scale.\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n\n    // The Truchet distance field.\n    float d = dfTruchet(p, ip, sc);\n    \n    // Return the distance and object ID.\n    return vec3(d, gIP);\n    \n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n  \n    // Pixel storage.\n    vec3 col;\n   \n    // Initial conditions -- Performed just the once upon initialization.\n    //if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    //\n    // IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    // I'm not sure how he figured this out, but he pretty much knows everything. :D\n    //\n    // If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    // you wish to initialize. In this case, I'm precalculating an expensive distance\n    // field and storing it in one of the cube map faces.\n    #ifndef TRUCHET_PATTERN\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        // INITIAL CONDITIONS.\n       \n        // Construct a distance field whilst seting the wrapping value, then store it.\n        repSc = 16.;\n        col = dfNeighbors(uv); // Distance field in X, and object IDs in YZ.\n        //col.yz += .5;\n        \n    }\n    else col = tx(iChannel0, uv).xyz;\n    #else \n    \n    // Construct a distance field whilst seting the wrapping value, then store it.\n    repSc = 16.;\n    col = dfScale(uv); // Distance field in X, and object IDs in YZ.\n     \n    #endif\n\n    // Store in the cube map.\n    fragColor = vec4(col, 1.);\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n\tThe 2D path tracing code itself...  I'm not even sure that\n\tyou'd strickly call it path tracing, but it's randomly \n\tsampled rays sent off in random directions that are \n\treflected off of objects according to their surface \n\tproperties, so close enough. Obviously, if you want a \n\ttreatise on the process itself, there are heaps of awesome\n\texamples on here already.\n\n\tOn a side note, I intend to put up a few myself at some \n\tstage.\n\n\n*/\n\n\n\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p);\n    p = abs(p - ip - .5);\n\n    return abs(max(p.x, p.y) - .5) - .003;\n}\n\n\n// Reading the distance field from the texture map.\nfloat map(vec2 p){\n\t// Reading distance fields from a texture means taking scaling into\n    // consideration. If you zoom coordinates by a scalar (4, in this case), \n    // you need to scale the return distance value accordingly... Why does \n    // everything have to be so difficult? :D\n    const float sc = 4.;\n    vec4 tex = tx(iChannel0, p/sc);\n    gIP = tex.yz; // The object ID is stored in the YZ channels..\n    return tex.x*sc;\n}\n\n\n\n#define FAR 8.\n#define DELTA .003\n#define RSF 1.\n#define RSF_SHAD 1.\n\nfloat trace(vec2 o, vec2 r){\n    \n    // Raymarching.\n    float d, t = 0.;\n    \n    // 96 iterations here: If speed and complilation time is a concern, choose the smallest \n    // number you can get away with. Apparently, swapping the zero for min(0, frame) can\n    // force the compliler to not unroll the loop, so that can help sometimes too.\n    for(int i=0; i<16; i++){\n        \n        // Surface distance.\n        d = map(o + r*t);\n        \n        // In most cases, the \"abs\" call can reduce artifacts by forcing the ray to\n        // close in on the surface by the set distance from either side. Because this is\n        // two dimensional, it appears to be necessary -- rather than an option -- to avoid \n        // negative values... I haven't thought it through enough, but basically, 2D \n        // raymarching, or whatever you wish to call the process, works differently.\n        //\n        // Equivalent to abs(d)<DELTA... I'll assume it's faster, but I can't be sure.\n        if(d*d<DELTA*DELTA || t>FAR) break;\n        //if(d<DELTA || t>FAR) break;\n        \n        // No ray shortening is needed here, and in an ideal world, you'd never need it, but \n        // sometimes, something like \"t += d*.7\" will be the only easy way to reduce artifacts.\n        t += d*RSF;\n    }\n    \n    t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n    \n    return t;\n    \n}\n\nfloat lightTrace(vec2 o, vec2 r, float maxDst){\n    \n    // Raymarching.\n    float d, t = 0.;\n    \n    \n    // 96 iterations here: If speed and complilation time is a concern, choose the smallest \n    // number you can get away with. Apparently, swapping the zero for min(0, frame) can\n    // force the compliler to not unroll the loop, so that can help sometimes too.\n    for(int i=0; i<16; i++){\n        \n        // Surface distance.\n        d = map(o + r*t);\n        \n        // In most cases, the \"abs\" call can reduce artifacts by forcing the ray to\n        // close in on the surface by the set distance from either side.\n        if(d<0. || t>maxDst) break;\n        \n        \n        // No ray shortening is needed here, and in an ideal world, you'd never need it, but \n        // sometimes, something like \"t += d*.7\" will be the only easy way to reduce artifacts.\n        t += d*RSF_SHAD;\n    }\n    \n    //t = min(t, maxDst); // Clipping to the far distance, which helps avoid artifacts.\n    \n    return t;\n    \n}\n\n/*\nfloat shadowTrace(vec2 o, vec2 r){\n    \n    // Raymarching.\n    float d, t = 0.;\n    \n    \n    // 96 iterations here: If speed and complilation time is a concern, choose the smallest \n    // number you can get away with. Apparently, swapping the zero for min(0, frame) can\n    // force the compliler to not unroll the loop, so that can help sometimes too.\n    for(int i=0; i<16;i++){\n        \n        // Surface distance.\n        d = map(o + r*t);\n        \n        // In most cases, the \"abs\" call can reduce artifacts by forcing the ray to\n        // close in on the surface by the set distance from either side.\n        if(d<0. || t>FAR) break;\n        \n        \n        // No ray shortening is needed here, and in an ideal world, you'd never need it, but \n        // sometimes, something like \"t += d*.7\" will be the only easy way to reduce artifacts.\n        t += d*RSF_SHAD;\n    }\n    \n    t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n    \n    return t;\n    \n}\n*/\n\n// Standard 2D normal function.\nvec2 nr(in vec2 p){\n    \n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec2(map(p + e.xy) - map(p - e.xy), \n                          map(p + e.yx) - map(p - e.yx)));\n}\n\n// Translating the camera.\nvec2 getCamTrans(float t){ return vec2(sin(t/8.)/8., -t/6.); }\n\n// Rotating the camera.\nmat2 getCamRot(float t){\n    \n    //return rot2(0.);\n    return rot2(cos(t/4.)/8.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    \n    // The overall scene color.\n    vec3 col = vec3(0);\n    \n   \n    vec2 cam = getCamTrans(iTime);\n    mat2 camRot = getCamRot(iTime);\n    \n    // Threading a light through the moving pattern. The velocity is 1/6 units per second, and the\n    // zoom factor is 8, so considering that the angular segment velocity is half that of the camera\n    // velocity... I'm just going to take a few guesses... Can't believe that actually worked. Yay. \n    // We're doing physics. :D\n    vec2 lp = vec2(0) - vec2(0, cam.y - 2./8.); // 2./texMapScale.\n    vec2 rd;\n    \n \n    // Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    uv = uv*camRot - cam;\n    \n    // Making a copy of the rotated coordinates for later use.\n    vec2 rUV = uv;\n    \n    float sf = 1./iResolution.y*4.;\n    float grid = gridField(uv*2.);\n    \n    \n    #ifndef DISTANCE_FIELD_ONLY\n \n    // Number of samples and the number of reflective bounces. As you can see, there are\n    // far fewer than you'd expect.\n    const int SAMPLES = 4;\n    const int BOUNCES = 2;\n    \n    // Sample loop.\n    for (int i =0; i < SAMPLES; i++){\n        \n        float fi = float(i);\n        \n        // Reflection factor: Basically, this controls the the reflected amount. Normally,\n        // you'd have reflection coefficients for each object material, etc, but we're \n        // trying to keep things simple, so this will simply be reduced globally per \n        // reflective iteration... It's not that important. :)\n        float refFactor = 1.; \n        \n        // Random time.\n        float fTm = fract(iTime) + fract(float(iFrame)*.01);\n        \n        // The initial jittered ray origin or camera point for this sample.\n        vec2 ro = uv + (hash22(uv + fi + fTm + .35) - .5)/iResolution.y*1.;\n        \n        // The initial random unit direction ray for this sample.\n        float ti = (fi + hash21(uv + fi + fTm))*6.2831/float(SAMPLES);\n        rd = vec2(cos(ti), sin(ti));\n        \n        // The sample color.\n        vec3 sCol = vec3(0);\n        \n        // Bounce loop.\n        for(int j = 0; j<BOUNCES; j++){\n            \n            // Bounce trace.\n            float t = trace(ro, rd);\n            vec2 svID = gIP; // Saving the ID here.\n            \n            float fj = float(j);\n            vec3 rCol = vec3(0);\n            vec2 sp = ro + rd*t;\n            \n            if(t<FAR){\n                \n                // The randomly distributed unit direction vector: For 2D stuff, this seems \n                // to be the accepted way to go about it. Basically it's just a normalized\n                // vector in a random circular direction, which makes sense on a 2D plane.\n                float fij = fi*float(BOUNCES) + fj;\n                float tij = (fij + hash21(uv + fij + fTm))*6.2831/float(SAMPLES*BOUNCES);\n                vec2 rndRD = vec2(cos(tij), sin(tij));\n                \n                // Basic lighting stuff... I'm not sure it makes perfect sense in a 2D \n                // environment, but it'll do.\n                //\n                vec2 sn = nr(sp); // Normal.\n                vec2 ld = (lp - sp); // Light direction.\n                float lDist = length(ld); // Light distance.\n                ld /= lDist; // Normalizing.\n                float udif = dot(ld, sn); // Unsigned diffuse value.\n                float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 32.); // Specular.\n\n                // You could do much fancier things with the object ID, but\n                // I'm simply giving the rails different colors.\n                vec3 oCol = svID.x < .5? vec3(.25, .5, 1) : vec3(1.5, .3, .15);\n                 \n                // No textures, but you could have them.\n                //vec3 tx = texture(iChannel2, uv).xyz; tx *= tx;\n                //tx = smoothstep(.0, .5, tx);\n                \n                \n                 \n                // Sending a ray from the hit point out toward the light.\n                // Some people might call it shadowing. :)\n                #ifdef LIGHT_TRACE\n                vec3 dL = vec3(0);\n                //vec3 shad = vec3(1);\n                if(udif>0.){\n                    float maxDist = lDist;//lDist; // FAR.\n                    // Lamest cone sampled light ray ever. :)\n                    vec2 cnLD = normalize(mix(ld, rndRD, .05));\n                    float rt = lightTrace(sp + sn*DELTA*2., cnLD, maxDist);\n                    //float rt = shadowTrace(sp + sn*DELTA*2., cnLD);\n                    \n                    // If we've reached the light, light things up. It's\n                    // slightly different to the shadowed approach which \n                    // dictates that you darken things if you hit an object.\n                    if(rt >= maxDist - DELTA) {\n                        dL += pow(udif, 4.)*2.5;///(1. + rt*rt*4.);//\n                         \n                    }\n                    //if(rt < maxDist) shad = vec3(0);\n                }\n                #endif\n                \n                \n                // Shading and texture option. Not used.\n                //float sh = max(.2 - dfIJ/.01, 0.);\n                //oCol = mix(oCol, oCol*tx, (1. - step(0., -(dfIJ))));\n                \n                \n                #ifdef LIGHT_TRACE\n                // Apply the light traced light. Nicer, but more expensive. By the way,\n                // this is all fake lighting. The specular is there because I was bored,\n                // and it looked OK, so don't take any of this at face value.\n                rCol = oCol*(dL + spec); \n                #else\n                // Just some diffuse and specular light.\n                float dfIJ = map(sp);\n                rCol = oCol*(pow(max(udif, 0.), 4.)*2. + spec);\n                rCol *= 1. - smoothstep(0., .0005, dfIJ)*.75; // Darkenging the background\n                #endif\n               \n                // Light attenuation.\n                rCol *= 4./(1. + lDist*lDist*4.);\n                \n                \n                #ifdef SHOW_LIGHT\n                // Displaying the moving light.\n                rCol = mix(rCol, rCol*5., 1. - smoothstep(0., sf*4., length(uv - lp)));\n                #endif\n                \n              \n                // Mostly reflective, but adding in a little roughness.\n                rd = normalize(mix(reflect(rd, sn), rndRD, .05)); \n\n                // Updating the ray origin to the hit point, then bumping the ray\n                // off the surface to avoid self collisions.\n                ro = sp + sn*DELTA*2.;\n\n            }\n            \n            #ifdef SHOW_GRID\n            // Display the grid as a background pattern.\n            rCol = mix(rCol, rCol*2., (1. - smoothstep(0., sf*3., grid - .002))*.5);\n            rCol = mix(rCol, vec3(0), (1. - smoothstep(0., sf, grid))*.9);\n            #endif\n            \n             \n            // Blending in the bounce color. Additive blending is an option, but\n            // I'm mixing.\n            sCol = mix(sCol, rCol, 1./float(1 + j)*refFactor);\n            //lCol += rCol;\n            refFactor *= .9;\n            \n            if(t>FAR-DELTA) break;\n           \n        }\n         \n        \n        // Technially, this should be capped to one, but I wanted to really exaggerate\n        // the effect.\n        col += min(sCol, 2.);\n        \n        \n    }\n    \n    // Divide by the sample number.\n    col /= float(SAMPLES); \n    \n    // If you cap the reflective colors, this isn't necessary. You might also choose\n    // not to cap them, then cap here, etc. Too many choices. :)\n    //col = min(col, 1.);\n \n    \n    \n    #ifdef TEMPORAL_REPROJECTION\n    // Camera reprojection. This is basically the crux of the example, and as you \n    // can see, it's not that involved. In essence, we're calculating where we \n    // believe the previous frame should be placed on the sceen in relation to the\n    // new one -- Effectively, we'd like to place it directly under the new one. \n    // To do that, we index into the stored buffer at the current position minus \n    // the frame to frame camera difference.\n    //\n    // On a side note, I think the calculations are correct, but it's been a while \n    // since I've done this, so if there's something that doesn't look quite right,\n    // it probably isn't... And feel free to let me know that. It's the only way\n    // I'll learn not to be stupid. :D\n    \n    // Recalculating the UV coordinates.\n    uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n   \n    // Frame to frame camera translation difference.\n    vec2 camDelta = getCamTrans(iTime - iTimeDelta);\n    vec2 camOffs = -(camDelta - cam);\n    \n    // Frame to frame camera rotation difference.\n    mat2 rotDelta = getCamRot(iTime - iTimeDelta);\n    vec2 rotOffs = -(rotDelta*uv - camRot*uv);\n    \n    \n    // Offsetting the UV coordinates accordingly, then projecting to the current\n    // screen coordinates, which have to range from zero to one along X and Y.\n    vec2 cuv = (uv - rotOffs - camOffs)*vec2(iResolution.y/iResolution.x, 1)  + .5;\n    \n    // Two differently rotated-translated rectangles are more than likely not going\n    // to line up, so you need to check boundaries. You might note a bit of smudging\n    // on the screen borders. Usually, your offscreen buffer would be larger, or the\n    // onscreen buffer will be smaller. Basically, I could put a screen border around\n    // everything, but I don't think it's that noticeable.\n    if(cuv.x<0. || cuv.x>1.) cuv.x = uv.x*iResolution.y/iResolution.x + .5;\n    if(cuv.y<0. || cuv.y>1.) cuv.y = uv.y + .5;\n    vec3 tCol = texture(iChannel1, cuv).xyz;\n    \n    \n    // Mixing in the new frmae with the previous one. In fact, we're cycling about\n    // 8 screens. This effectively gives you 8 times the sampling. So, if your \n    // original sample count is just 8, this would boost it to 64. The reason you\n    // don't go too high is that temporal reprojection is just an estimation, so\n    // eventually, temporal screen lag will catch up with you.\n    const float totTimeFrames = 8.;\n    col = mix(tCol, col, 1./totTimeFrames);\n    \n    #endif\n    \n    #else\n    \n    // Display the distanc field only.\n    \n    // For anyone interested in the distance field map itself, uncomment the\n    // DISTANCE_FIELD_ONLY option, and you'll see that it's nothing more than \n    // a moring Voronoi texture or moving Voronoi Truchet arrangement.\n    //\n    vec3 txM = tx(iChannel0, rUV/4.).xyz;\n    col = vec3(0) + txM.x*repSc/2.;\n    #ifdef SHOW_GRID\n    col = mix(col, col*2., (1. - smoothstep(0., sf*3., grid - .0035))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid))*.9);\n    #endif \n    \n    float sh = max(.65 - txM.x*repSc*4., 0.);\n    vec3 tCol = txM.y<.5? vec3(.15, .4, 4) : vec3(4, .4, .1);\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, txM.x*repSc/2. - .03)));\n    col = mix(col, tCol*sh, (1. - smoothstep(0., sf, txM.x*repSc/2.)));\n    #endif \n    \n    // Output to the buffer.\n    fragColor = vec4((max(col, 0.)), 1);\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tscR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3377, 3377, 3431, 3468, 3620]], "test": "untested"}
{"id": "WlfyWr", "name": "Mandelbrot?? Zoom", "author": "eiffie", "description": "Deep Fake zoom.", "tags": ["sft"], "likes": 10, "viewed": 422, "published": 3, "date": "1591774385", "time_retrieved": "2024-07-30T21:01:53.062425", "image_code": "//Mandelbrot?? Zoom by eiffie (SuperFractalThingy Math on bs orbit data)\n#define time iTime\n#define rez iResolution.xy\n\nvec2 cmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,dot(a,b.yx));}\n\nvec2 ZI[40];\nvoid fillZ(){//a few iterations of real data until it comes close to repeating\n  vec2 Z=vec2(-.7482003,.18466048),C=Z;\n  for(int i=0;i<40;i++){ZI[i]=Z;Z=cmul(Z,Z)+C;}\n}\n\nfloat scale;\nfloat mndfk(vec2 dZ){\n  dZ*=scale;\n  vec2 dC=dZ;\n  float iters=100.+time*6.;\n  float i=0.;\n  for(i=0.;i<iters;i+=1.){\n    int idx=int(mod(i,40.));//add a bogus offset to the orbit for some variety\n    dZ=2.*cmul(ZI[idx]+vec2(cos(i),sin(i))*i*0.000001,dZ)+cmul(dZ,dZ)+dC;//mod of sft math by K.I.Martin\n    if(dot(dZ,dZ)>40.)break;\n  }\n  return ((iters-i)+1.33*log(log(dot(dZ,dZ))))/iters;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ) {\n  vec2 uv=(2.0*U-rez)/rez.x;\n  fillZ();\n  scale=exp(-time);\n  float a=mndfk(uv);a*=(0.8+time*time*0.001);\n  O=vec4(a,a,a,1.0);\n}", "image_inputs": [], "sound_code": "#define bps 5.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n=4.0; \n  else if(n<2.0)n=3.0; \n  else if(n<3.0)n=2.0; \n  else if(n<4.0)n=1.0; \n  else if(n<5.0)n=0.0; \n  else if(n<6.0)n=3.0; \n  else if(n<7.0)n=4.0; \n  else n=3.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n)); \n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(5.5,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr zylo=instr(10.0,1.5,4.0,0.77,1.2505,0.002); \n //instr bassdrum=instr(500.0,1.0,4.0,0.75,1.0,0.0125); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(10.0,0.2,1.5,0.0,0.25,0.005); \n instr bass=instr(20.0,0.2,1.5,0.0,1.01,.0); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,zylo)*n0.y*0.25;\n   a+=I(n0.x+68.0,time,t0,zylo)*n0.y*0.25;\n   //if(mod(i,3.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i; \n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+44.0,time,t1,bass)*n1.y;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       \n       a+=I(n2.x+44.0,time,t2,bass)*n2.y*4.0; \n       //a+=I(n2.x+24.0,time+0.008*sin(t2*15.0),t2,bassdrum)*n2.y*4.0; \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/24.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 146, 146, 188], [203, 203, 216, 281, 371], [386, 386, 407, 407, 776], [778, 778, 819, 819, 948]], "test": "untested"}
{"id": "WtfcDn", "name": "Wikipedia Test shader", "author": "sguzman", "description": "Got this shader from Wikipedia ShaderToy article", "tags": ["wikipedia"], "likes": 6, "viewed": 365, "published": 3, "date": "1591767008", "time_retrieved": "2024-07-30T21:01:53.815412", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // input: pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x);\n    \n    // modified distance metric\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\n    \n    // index texture by (animated inverse) radius and angle\n    vec2 uv = vec2( 1.0/r + 0.2*iTime, a );\n\n    // pattern: cosines\n    float f = cos(12.0*uv.x)*cos(6.0*uv.y);\n\n    // color fetch: palette\n    vec3 col = 0.5 + 0.5*sin( 3.1416*f + vec3(0.0,0.5,1.0) );\n    \n    // lighting: darken at the center    \n    col = col*r;\n    \n    // output: pixel color\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfcDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 741]], "test": "untested"}
{"id": "WtfcWn", "name": "Grid Ripples", "author": "ShnitzelKiller", "description": "Testing out a simple way of creating ripples around grid cells using 6 basis functions instead of enumerating all cases like marching squares.", "tags": ["2d", "ripples", "grid", "water", "marching", "squares"], "likes": 3, "viewed": 477, "published": 3, "date": "1591761323", "time_retrieved": "2024-07-30T21:01:54.598319", "image_code": "#define CELL_SIZE 0.05\n//#define SMOOTH_OFFSET 0.2\n#define DENSITY 0.7\n\nfloat rand(in vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\n//1 if there is land, 0 otherwise\nfloat occupancy(in vec2 id) {\n    return step(DENSITY, rand(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x/CELL_SIZE + vec2(0.5, 1.7) * iTime + iMouse.xy*CELL_SIZE;\n    vec2 id = floor(uv);\n    vec2 id2 = floor(uv + 0.5);\n    vec2 modpos2 = fract(uv + 0.5)-0.5;\n    \n    vec3 offsets = vec3(-1.,0.,1);\n    bool occ00 = occupancy(id2) > 0.5;\n    bool occ11 = occupancy(id2+offsets.xx) > 0.5;\n    bool occ10 = occupancy(id2+offsets.xy) > 0.5;\n    bool occ01 = occupancy(id2+offsets.yx) > 0.5;\n    \n    //compose wave pattern within each offset grid cell (where each corner is at the center of one of the visual grid cells).\n    //one basis function for each corner block, plus two basis functions for the cases where two opposite corners are occupied\n    //(this gives the smooth ripples in concave regions).\n    float height = 100.;\n    if (occ00)\n    \theight = min(height, length(max(vec2(0.), -modpos2)));\n    if (occ11)\n    \theight = min(height, length(max(vec2(0.), modpos2*offsets.zz)));\n    if (occ10)\n        height = min(height, length(max(vec2(0.), modpos2*offsets.zx)));\n    if (occ01)\n        height = min(height, length(max(vec2(0.), modpos2*offsets.xz)));\n    if (occ11 && occ00) {\n        height = min(height, 0.5-min(length(modpos2 + 0.5*offsets.zx), length(modpos2+0.5*offsets.xz)));\n    }\n    if (occ01 && occ10) {\n        height = min(height, 0.5-min(length(modpos2 + 0.5*offsets.xx), length(modpos2+0.5*offsets.zz)));\n    }\n    /*if (occ11 && occ00) {\n        height = min(height, 0.5-SMOOTH_OFFSET-min(length(min(vec2(0.), (modpos2 + (0.5-SMOOTH_OFFSET)*offsets.zx)*offsets.xz)), length(min(vec2(0.), (modpos2+(0.5-SMOOTH_OFFSET)*offsets.xz)*offsets.zx))));\n    }*/\n    \n    // minimalistic rendering\n    float wavefac = exp(-max(0.,height)*10.) * sin(height*50. - iTime * 5.)*.5+.5;\n    vec2 modpos = fract(uv);\n    modpos = abs(modpos-0.5);\n    modpos *= modpos;\n    fragColor = vec4(mix(mix(vec3(0., 0.4, 1.), vec3(0., 1., 1.), vec3(wavefac)), vec3(0.7, 0.6, 0.4) * 1.-max(modpos.x, modpos.y), vec3(occupancy(id))) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 96, 96, 149], [151, 185, 214, 214, 252], [254, 254, 311, 311, 2288]], "test": "untested"}
{"id": "WlXyDn", "name": "Baymax_v1", "author": "CS_climber", "description": "A simple model", "tags": ["raymarching"], "likes": 2, "viewed": 247, "published": 3, "date": "1591760204", "time_retrieved": "2024-07-30T21:01:55.340335", "image_code": "//计算机图形学大作业\nconst int Max_Steps=300;\nconst float Max_Distance=300.0;\nconst float Threshold=0.001;\nconst float EPSILON=0.001;\n\n//Part1  基于符号距离函数构造场景\n//基本操作\nfloat Intersect(float A,float B){return max(A,B);}\nfloat Union(float A,float B){return min(A,B);}\nfloat Diffence(float A,float B){return max(A,-B);}\nfloat dot2( in vec3 v ){ return dot(v,v);}\n//地面SDF\nfloat Set_Ground(vec3 p){\n    return p.y;\n}\n//金子塔SDF\nfloat Set_Pyramid(vec3 p,float h) {\n  float m2 = h*h + 0.25; \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n  float s = max(-q.x,0.0);\n  float t = clamp((q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0);   \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t); \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n//球形SDF\nfloat Set_Sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n//梨形SDF\nfloat Set_RoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n//环形SDF\nfloat Set_CappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n//环形SDF\nfloat Set_Ellipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n//胶囊形SDF\nfloat Set_Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n//整个场景SDF\nvec2 Senery(vec3 p){\n    //a. 地面\n    float conponent[10],part[4];\n    part[0]=Set_Ground(p);\n    \n    //b. 模型主体\n    //构建身体\n    vec3 a=vec3(0.0,0.76,0);\n    vec3 b=vec3(0.0,0.0,0);\n    conponent[0]=Set_RoundCone( p-vec3(0,0.4,0),  a,  b, 0.35, 0.75);\n    //构建手臂\n    vec2 sc=vec2(1,2);\n    conponent[1]=Set_CappedTorus(p-vec3(0,0.2,0), vec2(0.866025,-0.50), 1.0, 0.2);\n    //构建头部\n    vec3 r=vec3(0.4,0.3,0.3);\n    conponent[2]=Set_Ellipsoid(p-vec3(0,1.5,0), r );\n    //构建腿部\n    vec3 c=vec3(-0.25,0.1,1);\n    vec3 d=vec3(-0.3,0.1,0);\n    conponent[3]=Set_RoundCone( p,  c,  d, 0.15, 0.41);\n    vec3 e=vec3(0.25,0.1,1);\n    vec3 f=vec3(0.3,0.1,0);\n    conponent[4]=Set_RoundCone( p,  e,  f, 0.15, 0.41);\n    part[1]=1e7;\n    for(int i=0;i<5;i++){\n        part[1]=Union(part[1],conponent[i]); \n    }\n    \n    //c. 模型细节\n    //构建眼睛\n    conponent[5]=Set_Sphere(p-vec3(0.15,1.55,0.25),0.059);\n    conponent[6]=Set_Sphere(p-vec3(-0.15,1.55,0.25),0.059);\n    conponent[7]=Set_Capsule(p, vec3(0.15,1.55,0.28),vec3(-0.15,1.55,0.28),0.019);\n    part[2]=1e7;\n    for(int i=5;i<8;i++){\n        part[2]=Union(part[2],conponent[i]); \n    }\n                           \n    //d. 组合场景中的各个部分\n    float m,min_dis=100000000.0;\n    for(int i=0;i<3;i++){\n        if(min_dis>part[i]){\n            min_dis=part[i];\n            m=float(i);\n        }\n    }\n    return vec2(min_dis,m);\n}\n\n//Part2  Ray_marching算法\n//光线以当前位置到最近的点距离作为步长前进，当超过设定迭代次数和阈值时返回结果\nvec2 Ray_marching(vec3 start,vec3 dir){\n    float l=0.0,m=0.0;\n    for(int i=0;i<Max_Steps;i++){\n        vec2 new_pos=Senery(start+l*dir);\n        //超出边界返回全零\n        if(l>Max_Distance||abs(new_pos.x)<Threshold)break;\n        l+=new_pos.x;\n        m=new_pos.y;\n    }\n    if(l>Max_Distance)m=-1.0;\n    return vec2(l,m);\n}\n//Part3 光照\nvec3 Get_Normal(vec3 p) {\n    return normalize(vec3(//中间差分求梯度\n        Senery(vec3(p.x + EPSILON, p.y, p.z)).x - Senery(vec3(p.x - EPSILON, p.y, p.z)).x,\n        Senery(vec3(p.x, p.y + EPSILON, p.z)).x - Senery(vec3(p.x, p.y - EPSILON, p.z)).x,\n        Senery(vec3(p.x, p.y, p.z  + EPSILON)).x - Senery(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\nfloat soft_shadow(vec3 start,vec3 dir){\n    float l=0.0,ans=1.0;\n    for(int i=0;i<Max_Steps;i++){\n        float new_pos=Senery(start+l*dir).x;\n        ans=min(ans,new_pos/(l*0.05));\n        if(l>6.0)break;\n        l+=clamp(new_pos, 0.005, 0.50);\n    }\n    return ans;\n}\nvec3 Phong_shader(vec3 p, vec3 eye,vec3 kd) {\n    //设置参数\n    vec3 light_pos = vec3(-30, 30, 40);\n    vec3 light_intensity = vec3(1.5, 1.5, 1.5);\n    vec3 amb_light_intensity=vec3(0.4, 0.4, 0.4);\n\n    vec3 ka = vec3(0.005, 0.005, 0.005);\n    vec3 ks = vec3(1.0, 1.0, 1.0);\n    float alpha = 6.0;\n    \n    //测试阴影\n    //将当前点沿着法向移动一点，从该点向光源光线步计算阴影系数\n    vec3 n =  Get_Normal(p);\n    float s=soft_shadow(p,normalize(light_pos -p));\n    kd*=s;\n    \n    //计算向量\n    vec3 l = normalize(light_pos  - p);\n    vec3 v = normalize(eye - p);\n    vec3 r = normalize(reflect(-l, n));\n    //计算phong模型三类光\n    vec3 color=ka*amb_light_intensity;\n    float l_n = dot(l, n);\n    float r_v = dot(r, v);\n    if (l_n< 0.0) {//照不到\n        return vec3(0.0, 0.0, 0.0);\n    }else if (r_v < 0.0) {\n        color+=light_intensity*kd*l_n;\n    }\n    else{\n        color+=light_intensity*(kd * l_n+ ks * pow(r_v, alpha));\n    }\n    return color;\n}\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n    vec3 x = texture( sa, p.yz ).xyz;\n    vec3 y = texture( sa, p.zx ).xyz;\n    vec3 z = texture( sa, p.xy ).xyz;\n    return x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n//mainImage函数\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    \n    //cast_ray;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    float ctime = iTime;\n    float an = sin(5.3+0.05*ctime) - 6.2831*(m.x-0.5);\n    vec3 ro = vec3(5.0*sin(an),5.0,5.0*cos(an));\n    vec3 ta = vec3(1.0,1.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    vec2 dist = Ray_marching(ro,rd);\n    vec3 n = Get_Normal(dist.x*rd+ro);\n    if (dist.y==-1.0) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        return;\n    }else if (dist.y==1.0) {\n       vec3 kd = vec3(1.0,0.98431,0.9411);\n       vec3 temp=Phong_shader(dist.x*rd+ro, ro,kd);\n       fragColor = vec4(temp, 0.5);\n       return;\n    }else if(dist.y==0.0){\n        vec3 kd=0.7*pow( texturize( iChannel1, 0.45*(dist.x*rd+ro), n ).xyz, vec3(2.0) );\n        vec3 temp2=Phong_shader(dist.x*rd+ro,ro,kd) ;\n        fragColor = vec4(temp2, 1.0);\n        return;\n    }  \n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 205, 238, 238, 255], [256, 256, 285, 285, 302], [303, 303, 335, 335, 353], [354, 354, 378, 378, 396], [397, 409, 434, 434, 452], [453, 468, 503, 503, 966], [967, 979, 1016, 1016, 1040], [1041, 1053, 1118, 1118, 1633], [1634, 1646, 1718, 1718, 1852], [1853, 1865, 1904, 1904, 1987], [1988, 2003, 2057, 2057, 2178], [2179, 2197, 2217, 2233, 3633], [3635, 3780, 3819, 3819, 4115], [4116, 4131, 4156, 4156, 4489], [4490, 4490, 4529, 4529, 4760], [4761, 4761, 4806, 4825, 5773], [5774, 5774, 5822, 5822, 5987], [5988, 6006, 6059, 6080, 7191]], "test": "untested"}
{"id": "3tfcWn", "name": "Numerical bug in step?", "author": "ShnitzelKiller", "description": "For some reason, the output of step does not appear to be 0 or 1. Replace occupancy(id2) on line 23 with 1.0, and the stairstep artifacts are gone. The value of height should be length(max(vec2(0.), -modpos2), a continuous quantity. Any ideas?", "tags": ["bug"], "likes": 2, "viewed": 301, "published": 3, "date": "1591756639", "time_retrieved": "2024-07-30T21:01:56.143188", "image_code": "#define CELL_SIZE 0.1\n\nfloat rand(in vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nfloat occupancy(in vec2 id) {\n    return step(0.5, rand(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x/CELL_SIZE;\n\t\n    vec2 id = floor(uv);\n    vec2 id2 = floor(uv + 0.5);\n    //vec2 modpos = fract(uv);\n    vec2 modpos2 = fract(uv + 0.5)-0.5;\n    \n    vec3 offsets = vec3(-1.,0.,1);\n    float height = 1e6;\n    height = mix(height, min(height, length(max(vec2(0.), -modpos2))), occupancy(id2));\n    //height = mix(height, min(height, length(max(vec2(0.), -modpos2))), occupancy(id2));\n    //height = mix(height, min(height, length(max(vec2(0.), -modpos2*offsets.xx))), occupancy(id2+offsets.xx));\n    // Output to screen\n    fragColor = vec4(vec3(occupancy(id) + height*1.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 47, 47, 100], [102, 102, 131, 131, 165], [167, 167, 224, 274, 893]], "test": "untested"}
{"id": "wllczM", "name": "Forested planet", "author": "jarble", "description": "I added some trees to my [url=https://www.shadertoy.com/view/tlXyz7]desert planet[/url] shader.", "tags": ["3d", "planet", "forest"], "likes": 1, "viewed": 308, "published": 3, "date": "1591729787", "time_retrieved": "2024-07-30T21:01:56.950031", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\nconst float planet_size = 30000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale/planet_size*1000000.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\nvec3 jungle_color(vec3 p)\n{\n    return vec3(0,1.0,0.5);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat SDF1(vec3 p) {\n    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));\n}\n\nfloat SDF2(vec3 p){\n    p *= 3.0;\n\treturn 0.5 + SDF1(p/2.0+SDF1(p/5.0));\n}\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat bump(vec3 p3)\n{\n    //add bumps to the planet's surface\n    float distortion = 5.0;\n    p3 *= distortion;\n    return length(sin(p3))/(distortion*5.0);\n}\n\nfloat jungle(vec3 p,float width) {\n    p /= 200.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    float to_return = width +1.2 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n    return to_return;\n}\n\nfloat sceneSDF(vec3 p) {\n    vec3 p0 = p;\n    p /= scale;\n    float jungle1 = jungle(p,(length(p)-planet_size)/100.0);\n    float planet_surface = 1.1+length(p)-planet_size;\n    //float result = SDF1(p/1000.0+SDF1(p/1000.0));\n    float result = min(jungle1,planet_surface);\n    \n    \n    return result*scale;\n}\n\nvec3 sceneSDF_color(vec3 p) {\n    vec3 p0 = p;\n    p /= scale;\n    float jungle1 = jungle(p,(length(p)-planet_size)/300.0);\n    float planet_surface = 1.1+length(p)-planet_size;\n    //float result = SDF1(p/1000.0+SDF1(p/1000.0));\n    float result = min(jungle1,planet_surface);\n    \n    if(result == planet_surface){\n    \treturn surface_color(p0);\n    }\n    else if(result == jungle1){\n    \treturn jungle_color(p0);\n    }\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    //lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(1.6+.6*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = sceneSDF_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 316, 316, 470], [472, 472, 499, 499, 529], [773, 773, 793, 840, 896], [898, 898, 917, 917, 972], [974, 974, 1012, 1012, 1087], [1088, 1088, 1125, 1125, 1184], [1186, 1186, 1207, 1247, 1344], [1346, 1346, 1380, 1380, 1545], [1547, 1547, 1571, 1571, 1856], [1858, 1858, 1887, 1887, 2281], [2283, 2704, 2795, 2795, 3101], [3116, 3370, 3435, 3435, 3567], [3569, 3658, 3687, 3687, 3997], [3999, 4491, 4631, 4653, 5243], [5245, 5615, 5700, 5700, 6404], [6406, 6733, 6782, 6817, 6948], [6950, 6950, 7007, 7007, 7983]], "test": "untested"}
{"id": "WdBfDd", "name": "House of Happy", "author": "boeroboy", "description": "Remix of Happy Jumper by Inigo Quilez as I've been learning through the shader deconstruction.", "tags": ["sound"], "likes": 2, "viewed": 381, "published": 3, "date": "1591722250", "time_retrieved": "2024-07-30T21:01:57.954346", "image_code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n// An animation test - a happy and blobby creature jumping and\n// looking around. It gets off-model very often, but it looks\n// good enough I think.\n//\n// Making-of and related math/shader/art explanations (6 hours\n// long): https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\n// Video capture: https://www.youtube.com/watch?v=s_UOFo2IULQ\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n//------------------------------------------------------------------\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n// https://iquilezles.org/articles/smin\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float js = 2.1;\n    atime *= js;    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     atime/js - 1.5);\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );\n\n    if( res.x-1.0 < pos.y ) // bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t// legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n    \n    // ground\n    float fh = -0.2 - 0.05*(sin(pos.x)+sin(pos.z));\n    float t5f = fract((atime)+0.05);\n    float t5i = atime/2.1-0.25; \n    float bt4 = abs(fract(t5i/2.0)-0.5)*2.0;\n    vec2  bcen = vec2( floor(cen.x) + .5, cen.z);\n    \n    float k = length(pos.xz-bcen);\n    float tt = t5f*15.0-6.2831 - k*3.0;\n    fh -= 0.05*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);\n    float d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );\n    \n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }\n    }\n\n    // candy\n    {\n        float beat = texture(iChannel0, vec2(0.9,0.)).x * 2.;\n        float fs = 5.0;\n        vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n        vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n        vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y - beat,fract(qos.z+0.5)-0.5);\n        vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n        float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n        float fid = id.x*0.143 + id.y*0.372;\n        float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n        d = sdSphere( vp, 0.35*ra)/fs;\n        if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n    return res;\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.5-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    // raymarch scene\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n    \n\n    // scene geometry\n    vec4 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.144,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n\t\telse // terrain\n        {\n            // base green            \n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        //ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 23028, "src": "https://soundcloud.com/cafedelantaarn/house-of-pain-jump-around", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[644, 684, 725, 725, 797], [799, 839, 877, 877, 974], [976, 1016, 1057, 1057, 1129], [1131, 1180, 1215, 1215, 1241], [1243, 1292, 1351, 1351, 1440], [1442, 1442, 1516, 1516, 1669], [1671, 1711, 1741, 1741, 1774], [1971, 1971, 2009, 2009, 7085], [7087, 7087, 7139, 7139, 7641], [7643, 7688, 7748, 7748, 8186], [8188, 8234, 8278, 8278, 8841], [8843, 8843, 8904, 8904, 9197], [9199, 9199, 9250, 9267, 12539], [12541, 12541, 12593, 12593, 12770]], "test": "untested"}
{"id": "tllyRM", "name": "Transparency Test 1", "author": "Leria", "description": "Testing transparency on 2 semi-transparent sphere\nTrying a color blending at line 106", "tags": ["transparency", "colors", "blending", "alpha", "opacity"], "likes": 0, "viewed": 967, "published": 3, "date": "1591719150", "time_retrieved": "2024-07-30T21:01:58.716309", "image_code": "#define RADIUS 10.\n\n#define PI 3.14\n\nfloat current_transparency(float l, float material_coef)\n{\n   return exp(-l*material_coef); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o;   \n}\n\n#define transp current_transparency\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n \treturn length((pXp0)) - radius;   \n}\n\nconst vec3 cam = vec3(0., 0., 30.);\nfloat uniform_step = .1;\n\nvoid draw(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    //antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing/jittering\n    vec3 p = cam+dir*antialiasing;\n    int s = 0;\n    \n    vec3 h_col = vec3(1., .1, .8);\n    \n    float t = 1.;\n    float dist_acc = 0.;\n    \n    float r_t = transp(uniform_step, .1);\n    float g_t = transp(uniform_step, .9);\n    float b_t = transp(uniform_step, .1);\n    \n    vec3 rgb_t = vec3(r_t, g_t, b_t);\n    \n    float r_t2 = transp(uniform_step, .9);\n    float g_t2 = transp(uniform_step, .1);\n    float b_t2 = transp(uniform_step, .1);\n    \n    vec3 rgb_t2 = vec3(r_t2, g_t2, b_t2);\n\n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n    vec3 t_acc2 = vec3(1.); //accumulated transparency\n    \n    for(s; s < 150; s++)\n    {               \n        \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p-cam, p-cam);\n        float dist_center = length(center-cam);\n        \n        //if too far, then big step        \n        if(sqrt(dist_dist)-(dist_center-radius) < 0.)\n        {\n        \tk_step = dist_center-(radius);\n        }\n\n        //if in the shape, draw\n        if( sdf_sphere(p-center, RADIUS) <= 0.)\n        {\n            \n           \t//blending\n        \tc += t_acc*vec3(1.)*(1.-rgb_t);\n\t\t\tt_acc *= rgb_t;  \n        }   \n        \n        if( sdf_sphere(p-vec3(2., -3., -2.), RADIUS-1.) <= 0.)\n        {\n            c += t_acc*vec3(1., 1., 0.)*(1.-rgb_t2);\n\t\t\tt_acc *= rgb_t2;\n        }   \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p-cam) > max((dist_center+radius), (length(vec3(2., -3., -2.)-cam)+(radius-1.))))\n        {\n         \tbreak;\n        }\n        \n        p += dir*k_step;       \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    \n    draw(normalize(vec3(uv, -1.)), vec3(0., 0., 0.), vec3(0., 1., 0.), RADIUS, color);\n    \n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 95, 95, 131], [133, 133, 165, 165, 185], [187, 187, 221, 221, 245], [284, 284, 327, 327, 366], [430, 430, 505, 505, 2252], [2254, 2254, 2311, 2311, 2538]], "test": "untested"}
{"id": "3tscz7", "name": "Uniforms - TBOS 3.0", "author": "stungeye", "description": "Chapter 3 - The Book of Shaders - Uniforms\n\nThe input \"uniforms\":\n\n- iResolution\n- iMouse\n- iTime\n\nCalled uniforms as their values are equal across pixel threads.\n\nTrig functions to ease R & G by position and time. Mouse-click X changes rate of B easing.", "tags": ["simple", "gradient", "tbos"], "likes": 2, "viewed": 479, "published": 3, "date": "1591715432", "time_retrieved": "2024-07-30T21:01:59.452341", "image_code": "// Working Through The Book of Shaders\n// Chapter 03 - Uniforms - https://thebookofshaders.com/03/\n// 3.0 Uniforms\n\n\n// Sinusoidal function shifted and scaled to range betwen 0 and 1.\n// See: https://www.desmos.com/calculator/w9jrdpvsmk\nfloat sinEase(float x) {\n\treturn 0.5 * sin(x) + 0.5;\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n    // Set scale according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    float blueRateScale = iMouse.x / iResolution.x; \n       \n    // Ease back and forth 1 and 100 using time-based sine.\n    float stretchFactor = 99.0 * sinEase(iTime) + 1.0;\n    \n    // Setting red and green pixel value.\n    // Ease back and forth between 0 and 1 based on pixel position and time-based stretch factor.\n    float red   = sinEase(fragCoord.x / stretchFactor);\n    float green = sinEase(fragCoord.y / stretchFactor);\n    \n    // Blue will ease in and out based on time and the x position of the mouse.\n    // Ease speed increases from left to right.\n    float blue = abs(tan(iTime * blueRateScale));\n    \n    // Set the pixel value based on the RGB calculated above.\n    fragColor = vec4(red,green,blue,1);\n}\n\n\n// Stung Eye 2020 - Unlicense - https://unlicense.org\n// This is free and unencumbered software released into the public domain.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tscz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 237, 261, 261, 291], [293, 398, 542, 707, 1432]], "test": "untested"}
{"id": "WtsyzM", "name": "continuous bool as proba or sets", "author": "FabriceNeyret2", "description": "Boolean operator sextended to continuum:\n- as probability ( or \"fuzzy logic\" )     ( isovalue 0.5 in red )\n- as set operators\nAttention: A&B are supposed uncorrelated,  and (A|B) vs !(A&B)  are not, so it's easy to get it wrong (e.g. Xor \"variant\" )", "tags": ["xor", "boolean", "bitwise", "and", "fuzzylogic"], "likes": 26, "viewed": 602, "published": 3, "date": "1591704333", "time_retrieved": "2024-07-30T21:02:00.192362", "image_code": "#define S(v)  smoothstep(7./R.y,0.,v)\n\nfloat char(vec2 p, int c) { // from https://www.shadertoy.com/view/llySRh\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return 0.;\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy ).x;\n}\n#define C(c)  ( F.x-=.5, char(F,c) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O -= O;\n    vec2 R = iResolution.xy,\n         U = 4.*u/R.y, F;                          // layout\n    U.x -= 1.;   U.y -= .2; if (U.y<0.) U.y = 0.;\n    if (U.y>3.2) U.y += .3;\n    if (U.y>1.)  U.y>1.5 ? U.y -= .5 : U.y = 0.;\n    \n    int  x = int(U)-int(U.x<0.), y = int(U.y);     // cell indexs \n    F = fract(U);                                  // cell local coords\n\n    float A = F.x, B = 1.-F.y, b;                  // axis proba\n    A = -.05+1.1*A;                                // layout\n    B = -.05+1.1*B;\n    if ( x<0 || x>4 || A<0.||A>1. || B<0.||B>1. ) { O.b+=.3; return; }\n            \n    if (x>0 && abs(U.y-2.5)<.05) O += A;           // display axis B proba\n    else if (x>0 && abs(U.y-2.2)<.2) {             // display formulas\n       F.y -= .1; F*=6.;\n        O +=   x==1 ? F.x-=1.5, C(65)+C(42)+C(66)               // A*B\n             : x==2 ? C(65)+C(43)+C(66)+C(45)+C(65)+C(42)+C(66) // A+B-A*B\n             : x==3 ? C(65)+C(43)+C(66)+C(45)+C(50)+C(65)+C(42)+C(66) // A+B-2A*B\n             :        C(65)+C(124)+C(66)+C(38)+C(33)+C(40)+C(65)+C(38)+C(66)+C(41);\n    }                                                           // A|B&!(A&B)\n    else if (y==1)\n        O +=   x==0 ? abs(U.x-.5)<.05 ? B : 0.     // display axis A proba\n             : x==1 ? A*B                          // A & B\n             : x==2  ? A+B-A*B                     // A | B\n             : x==3  ? A+B-2.*A*B                  // A ^ B  with correl\n             : (A+B-A*B)*(1.-A*B);                 // A ^ B  without correl\n    else if (y==0 && x>0 ) {                       // --- sets operators\n        A = length(F-.6)-.35;\n        B = length(F-.4)-.35;\n        b = S(abs(A)) + S(abs(B));\n        A = S(A);\n        B = S(B);\n        O +=   x==1 ?  A*B       + .6*b            // A & B\n             : x==2 ?  A+B-A*B   -.4*b             // A | B\n             :        (A+B-A*B)*(1.-A*B);          // A ^ B\n    }\n    else if (y==3 && x>0) {                        // --- text title\n        F = 2.*F; F.x-=.5;\n        O +=   x==1 ? char(F, 38)                  // &\n             : x==2 ? char(F,124)                  // |\n             :        char(F, 94);                 // ^\n    }\n    else if (x==0 && y==2) \n               F-=.1, F.x-=.25, \n               O += char(3.*(F-.25),66) + char(3.*F,65);\n        \n    O.r += S(abs(O.x-.5));                         // isovalue 0.5 in red     \n    if (O.x==0.) O.b+=.3;                          // background\n    else if (x==4) O.gb -= .3;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 66, 112, 332], [371, 371, 409, 409, 2901]], "test": "untested"}
{"id": "3llyzM", "name": "Red Zeroes", "author": "eiffie", "description": "wait for it", "tags": ["sft"], "likes": 1, "viewed": 284, "published": 3, "date": "1591699690", "time_retrieved": "2024-07-30T21:02:01.125866", "image_code": "//Red Zeroes by eiffie\n#define time iTime\n#define rez iResolution.xy\n\nfloat segment(vec2 uv){//from Andre https://www.shadertoy.com/view/Xsy3zG\n uv = abs(uv);return (1.0-smoothstep(0.0,0.28,uv.x)) * (1.0-smoothstep(0.4-0.14,0.4+0.14,uv.y+uv.x));\n}\nfloat sevenSegment(vec2 uv,int num){\n uv=(uv-0.5)*vec2(1.5,2.2);\n float seg=0.0;if(num>=2 && num!=7 || num==-2)seg+=segment(uv.yx);\n if (num==0 || (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):(uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))seg += segment(abs(uv)-0.5); \n if (num>=0 && num!=1 && num!=4 && (num!=7 || uv.y>0.))seg += segment(vec2(abs(uv.y)-1.0,uv.x)); \n return seg;\n}\n//prints a \"num\" filling the \"rect\" with \"spaces\" # of digits including minus sign\nfloat formatFloat(vec2 uv, vec2 rect, float num, float spaces){\n uv/=rect;if(uv.x<0.0 || uv.y<0.0 || uv.x>1.0 || uv.y>1.0)return 0.0;\n uv.x*=float(spaces);\n float place=ceil(uv.x);\n uv.x=fract(uv.x);\n num *= pow(10.,place);//assumes num is 0-1\n num = mod(floor(num),10.0);\n return sevenSegment(uv,int(num));\n}\nvec2 cmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,dot(a,b.yx));}\nfloat scale;\nfloat mndfk(vec2 dZ){\n  dZ*=scale;\n  vec2 dC=dZ,Z=vec2(1.,.5606);\n  float iters=200.+time*4.;\n  float n=0.;\n  for(float i=0.;i<400.;i+=1.){n=i;\n    dZ=2.*cmul(Z,dZ)+cmul(dZ,dZ)+dC;//sft math by K. I. Martin\n    if(dot(dZ,dZ)>4000.||i>=iters)break;\n  }\n  return((iters-n)+1.33*log(log(dot(dZ,dZ))))/iters;\n}\nvoid mainImage( out vec4 O, in vec2 U ) {\n  vec2 uv=(2.0*U-rez)/rez.x;\n  scale=0.25*exp(-time);\n  float a=-time*0.62+3.;\n  a=mndfk(uv+vec2(cos(a),sin(a))*0.5);\n  float d=formatFloat(U,vec2(rez.x,rez.y*.07),scale,32.);\n  O=vec4(d,a,a,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 93, 143, 247], [248, 248, 284, 284, 638], [639, 722, 785, 785, 1031], [1032, 1032, 1058, 1058, 1100], [1114, 1114, 1135, 1135, 1420], [1421, 1421, 1462, 1462, 1661]], "test": "untested"}
{"id": "wllczN", "name": "Flooded Megacity (no shadows)", "author": "ShnitzelKiller", "description": "I am releasing a no-shadows version of the shader. For some reason uncommenting lines 211-231 and line 255 causes the compile time to go out of control on Windows+Nvidia despite only a handful of shadow steps being taken. Someone know why?", "tags": ["voxels", "city", "ruins"], "likes": 20, "viewed": 500, "published": 3, "date": "1591696901", "time_retrieved": "2024-07-30T21:02:02.111232", "image_code": "#define FDIST 0.5\n\n#define CELL_SIZE 3.\n#define MINI_CELL_SIZE .15\n#define WINDOW_SIZE vec3(0.5, 0.5, 0.45)\n#define WINDOW_STRIDE 1.\n#define WINDOW_THICKNESS 0.05\n#define ROOM_DEPTH 10.\n#define MAX_VOXELS 200\n#define REFLECTION_VOXELS 20\n#define REFRACTION_VOXELS 10\n#define MAX_HEIGHT 40.\n#define SHADOW_STEPS 10\n#define EPS 0.005\n#define SHADOW_EPS 0.01\n#define WATER_HEIGHT -2.\n#define IOR 1.33\n#define GLASS_IOR 5.\n#define ABSORPTION_RATE vec3(0.7, 0.8, 0.9)\n\n#define WATER_MAT 6\n\n#define MOON_COL vec3(0.4, 0.4, 0.4)\n#define MOON_RADIUS 0.11\n#define AMBIENT_COL vec3(0.1, 0.1, 0.15)\n\n#define SILL_COLOR vec3(1., 0.9, 0.9)\n\n#define PI 3.141593\n\nstruct Hit {\n    float t;\n    int mat;\n    vec3 n;\n    vec3 id;\n};\n\n\nfloat hash( in vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nvec3 tex(in vec3 p) {\n    float fac = 0.5*(hash(p)+hash(p*2.5));\n    float fac2 = smoothstep(0.45, 0.65, fac);\n    return mix(vec3(0.9, 0.8, 0.8), vec3(0.8, 0.7, 0.6), fac2);\n}\n\nvec3 ramp(in float t) {\n\treturn abs(fract(t + vec3(3,2,1)/3.)*6. - 3.) - 1.;\n}\n\nfloat buildings(in vec3 ro) {\n    return -ro.z/2. + 5.*sin(ro.x/2.) * sin(ro.y/2.);\n}\n\nfloat holes(in vec3 id) {\n    id = mod(id+5., 10.)-5.;\n    return step(10., dot(id, id));\n}\n\nfloat cylinders(in vec3 id) {\n    id.xy = mod(id.xy+22.5, 45.)-22.5;\n    float density = step(abs(length(id.xy)-5.), 1.);\n    density = min(density, step(4., length(id.xz-vec2(0., 2.))));\n\treturn density;\n}\n\nfloat voxMap(in vec3 id) {\n    float build1 = min(max(buildings(id), buildings(id*0.25)) + 2.*(hash(id)-0.5), holes(id));\n\tfloat build2 = cylinders(id);\n    return max(build1, build2);\n}\n\nfloat occupancy(in vec3 id) {\n    //return step(0.5, -step(length(id.xz - vec2(0., 4.)), 2.5) + voxMap(id/10.) + 0.25*(voxMap(id)-0.5));\n    return step(0.5, voxMap(id));\n}\n\n\nvec3 cellID(in vec3 ro) {\n    return floor(ro/(2.*CELL_SIZE) + 0.5);\n}\n\nvec3 cellMod(in vec3 ro) {\n    return mod(ro + CELL_SIZE, CELL_SIZE*2.) - CELL_SIZE;\n}\n\nfloat traceCell(in vec3 ro, in vec3 rd) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = CELL_SIZE * abs(dr);\n    \n    vec3 pout =  k - n;\n    return min(pout.x, min(pout.y, pout.z));\n}\n\nfloat traceCell_normal(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    nn = -sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return min(pout.x, min(pout.y, pout.z));\n}\n\nfloat skinnyBox(in vec3 modpos, in vec3 rd, in vec3 id, out vec3 pnear, out vec3 pfar) {\n    vec2 offset = vec2(1., 0.);\n    vec3 occp = vec3(\n        occupancy(id + offset.xyy),\n    \toccupancy(id + offset.yxy),\n    \toccupancy(id + offset.yyx)\n    );\n    vec3 occm = vec3(\n        occupancy(id - offset.xyy),\n    \toccupancy(id - offset.yxy),\n    \toccupancy(id - offset.yyx)\n    );\n    vec3 sig = step(-0.5, sign(rd));\n    vec3 sizesp = mix(vec3(MINI_CELL_SIZE), vec3(CELL_SIZE), occp);\n    vec3 sizesm = -mix(vec3(MINI_CELL_SIZE), vec3(CELL_SIZE), occm);\n    pnear = (mix(sizesp, sizesm, sig) - modpos)/rd;\n    pfar = (mix(sizesm, sizesp, sig) - modpos)/rd;\n    /*vec3 ts[2];\n    ivec3 index = ivec3(step(-0.5, sig));\n    ts[index.x].x = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.x) - modpos.x)/rd.x;\n    ts[index.y].y = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.y) - modpos.y)/rd.y;\n    ts[index.z].z = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.z) - modpos.z)/rd.z;\n    ts[1-index.x].x = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.x) - modpos.x)/rd.x;\n    ts[1-index.y].y = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.y) - modpos.y)/rd.y;\n    ts[1-index.z].z = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.z) - modpos.z)/rd.z;\n    pnear = ts[0];\n    pfar = ts[1];*/\n    return occp.x + occp.y + occp.z + occm.x + occm.y + occm.z;\n}\n\n\nHit voxtrace(in vec3 ro, in vec3 rd, int iters, bool stopWater) {\n    Hit h;\n    h.t = 0.;\n    // box marching\n    for (int i=0; i<iters; i++) {\n        vec3 pos = ro + rd*h.t;\n        h.id = cellID(pos);\n        if (stopWater && h.id.z < WATER_HEIGHT) {\n            h.mat = WATER_MAT;\n            return h;\n        } else if (h.id.z > MAX_HEIGHT) {\n            return h;\n        }\n        vec3 modpos = cellMod(pos);\n        float maxdist = traceCell(modpos, rd);\n        \n        \n        if (occupancy(h.id) > 0.5) {\n            vec3 pnear, pfar;\n            float neighbors = skinnyBox(modpos, rd, h.id, pnear, pfar);\n            float tnear = max(pnear.x, max(pnear.y, pnear.z));\n            float tfar = min(pfar.x, min(pfar.y, pfar.z));\n            if (neighbors > 0.5 && tfar > tnear && tnear > -2.*EPS) {\n                if (h.id.z >= WATER_HEIGHT) {\n                    if (neighbors < 2.5) {\n                        h.mat = 3;\n                    } else if (neighbors < 4.5) {\n                        h.mat = 1;\n                    } else {\n                        h.mat = 2;\n                    }\n                } else {\n                    h.mat = 5;\n                }\n                h.t += tnear;\n                h.n = -sign(rd) * step(pnear.zxy, pnear.xyz) * step(pnear.yzx, pnear.xyz);\n                return h;\n            }\n    \t}\n        \n        h.t += maxdist + EPS;\n        \n    }\n     \n    h.mat = 0;\n    return h;\n}\n\n/*float shadowtrace(in vec3 ro, in vec3 rd) {\n    float t = 0.;\n    for (int i=0; i<SHADOW_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        vec3 id = cellID(pos);\n        vec3 modpos = cellMod(pos);\n        float maxdist = traceCell(modpos, rd);\n        \n        if (occupancy(id) > 0.5) {\n            vec3 pnear, pfar;\n            skinnyBox(modpos, rd, id, pnear, pfar);\n            float tnear = max(pnear.x, max(pnear.y, pnear.z));\n            float tfar = min(pfar.x, min(pfar.y, pfar.z));\n            if (tfar > tnear && tnear > -SHADOW_EPS) {\n                return 0.;\n            }\n    \t}\n        t += maxdist + EPS;\n    }\n    return 1.;\n}*/\n\n\n\n// Schlick approximation for the Fresnel factor\nfloat schlick_fresnel(float R0, float cos_ang) {\n    return R0 + (1.-R0) * pow(1.-cos_ang, 5.);\n}\n\nvec3 shade(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + h.t * rd;\n    if (h.mat == 0) {\n        // sky color\n        vec3 sky = mix(vec3(0.), vec3(0.1, 0.05, 0.0), 1.-pow(max(0., rd.z), .5));\n        float c = max(0., dot(rd, sundir));\n        float s = sqrt(1.-c*c);\n        vec2 n = normalize(vec2(s, sqrt(MOON_RADIUS*MOON_RADIUS-s*s)));\n        float fac = max(0.,1.-0.5*(1.-n.y));\n        sky = mix(fac * vec3(0.9, 0.95, 1.), sky, smoothstep(MOON_RADIUS-0.01, MOON_RADIUS, s));\n        return sky;\n    } else if (h.mat == 1 || h.mat == 3 || h.mat == 4 || h.mat == 5) {\n        // buildings\n        \n        float fac = max(0., dot(h.n, sundir));\n        //fac *= shadowtrace(ro + SHADOW_EPS*sundir, sundir);\n        float fac2 = abs(dot(h.n, -sundir));\n        vec3 albedo;\n        if (h.mat == 1) albedo = tex(ro);\n        else if (h.mat == 3) {\n            vec3 absmod = abs(cellMod(ro));\n            float coord = max(absmod.x, max(absmod.y, absmod.z))*1.253;\n            float stripe = smoothstep(0.45, 0.55, 2.*abs(fract(coord)-0.5) + 0.5*(hash(ro*2.)-0.5));\n            albedo = mix(1.-tex(ro), 0.5*tex(ro*2.), stripe);\n        }\n        else if (h.mat == 4) albedo = SILL_COLOR;\n        else if (h.mat == 5) albedo = vec3(1.); //underwater\n        return albedo * (MOON_COL * fac + AMBIENT_COL * fac2);\n    } else return vec3(1., 0., 1.);\n}\n\nvec3 winmod(in vec3 ro) {\n    return (fract(ro/(WINDOW_STRIDE*2.)+0.5)-0.5)*2.*WINDOW_STRIDE;\n}\n\nvec3 winID(in vec3 ro) {\n    return floor(ro/(WINDOW_STRIDE*2.)+0.5);\n}\n\nfloat win_mask(in vec3 ro, in vec3 n, float margin) {\n    vec3 win = step(1.-(WINDOW_SIZE + margin)/WINDOW_STRIDE, abs(fract(ro/(WINDOW_STRIDE*2.))-0.5)*2.);\n    return win.x * win.y * win.z * step(abs(n.z), 0.2) * step(WATER_HEIGHT * CELL_SIZE*2., ro.z);\n}\n\nvec3 shade_interior(in vec3 eye, in vec3 rd, in vec3 id, in vec3 sundir) {\n    vec3 n;\n    float t = traceCell_normal(eye, rd, vec3(WINDOW_THICKNESS,WINDOW_SIZE.y, WINDOW_SIZE.z), n);\n    vec3 albedo;\n    vec3 ro = eye + rd * t;\n    if (n.x > 0.5) {\n        t = traceCell_normal(eye, rd, vec3(ROOM_DEPTH, WINDOW_STRIDE, WINDOW_STRIDE), n);\n    \tro = eye + rd * t;\n        float hass = hash(id);\n        vec3 tilecolor = 0.8 + 0.2 * (ramp(hass)-0.5);\n        float ang = hass * PI * .5;\n        float sr = sin(ang);\n        float cr = cos(ang);\n        mat2 rot = mat2(cr, -sr, sr, cr);\n        vec2 tile = step(mod(rot*ro.xy, hass), vec2(0.5*(1.-hass)));\n        float tilefac = abs(tile.x-tile.y);\n        vec3 floorcol = mix(vec3(0.5+0.5*fract(hass*145.7)), tilecolor, tilefac);\n        vec3 wallcol = 0.95+0.05*(ramp(1.-hass)-0.5);\n        albedo = mix(wallcol, floorcol, step(0.1, n.z));\n    } else {\n        albedo = SILL_COLOR;\n    }\n    vec3 lightpos = vec3(-0.25*ROOM_DEPTH, 0., WINDOW_STRIDE*0.95);\n    vec3 l = lightpos - ro;\n    float ll = length(l);\n    float fac = max(0.25, dot(n, l)/(ll*ll));\n    \n    return albedo * fac * 3. * hash(id);\n}\n\nvec3 shade_fake(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + rd * h.t;\n    if (h.mat == 2) {\n        // add in fake windows without reflections\n        if (win_mask(ro, h.n, 0.) > 0.5) {\n            vec3 id = winID(ro);\n            vec3 row = winmod(ro);\n            mat2 rot = mat2(h.n.x, -h.n.y, h.n.y, h.n.x);\n            vec3 ro2 = vec3(rot * row.xy, row.z);\n            vec3 rd2 = vec3(rot * rd.xy, rd.z);\n            sundir = vec3(rot * sundir.xy, sundir.z);\n            return shade_interior(ro2, rd2, id, sundir);\n        } else if (win_mask(ro, h.n, 0.2) > 0.5) {\n            h.mat = 4;\n\t\t\treturn shade(eye, rd, h, sundir);\n        } else {\n            h.mat = 1;\n            return shade(eye, rd, h, sundir);\n        }\n    } else if (h.mat == WATER_MAT) {\n        // water refractions\n        vec3 rdr = refract(rd, h.n, 1./1.33);\n        Hit h3 = voxtrace(ro, rdr, REFRACTION_VOXELS, false);\n        vec3 refrcol = shade(ro, rdr, h3, sundir);\n        refrcol *= pow(ABSORPTION_RATE, vec3(h3.t));\n        return refrcol;\n    } else {\n        return shade(eye, rd, h, sundir);\n    }\n}\n\n// shade materials which require reflections\nvec3 shade_refl(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + h.t * rd;\n    if (h.mat == 2) {\n        // windows\n        vec3 basecolor = shade_fake(eye, rd, h, sundir);\n        if (win_mask(ro, h.n, 0.) > 0.5) {\n            vec3 rdr = reflect(rd, h.n);\n            Hit h2 = voxtrace(ro, rdr, REFLECTION_VOXELS, true);\n            vec3 reflcol = shade_fake(ro, rdr, h2, sundir);\n            float R0 = (GLASS_IOR-1.)/(GLASS_IOR+1.);\n            float fresnel = schlick_fresnel(R0, dot(h.n, rdr));\n            return mix(basecolor, reflcol, fresnel);\n        } else {\n            return basecolor;\n        }\n    } else if (h.mat == WATER_MAT) {\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        float fresnel = schlick_fresnel(R0, -rd.z);\n        \n        vec2 disp = 0.01 * vec2(cos(ro.x*0.5 + 0.25*ro.y + 10.*iTime), sin(ro.x +2.*ro.y));\n        vec3 wn = normalize(vec3(disp, 1.));\n        h.n = wn;\n        vec3 refrcol = shade_fake(eye, rd, h, sundir);\n        \n     \t// water reflections\n         \n        vec3 rdr = reflect(rd, wn);\n        Hit h2 = voxtrace(ro, rdr, REFLECTION_VOXELS, false);\n        vec3 reflcol = shade_fake(ro, rdr, h2, sundir);\n        \n        return mix(refrcol, reflcol, fresnel);\n    } else {\n        return shade_fake(eye, rd, h, sundir);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseY = iMouse.y < 1. ? 0. : (0.5-iMouse.y/iResolution.y) * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 eye = vec3(0., iTime * 30., 20.1);\n    vec3 w = vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), -sin(mouseY));\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(FDIST*w + uv.x*u + uv.y*v);\n    \n    Hit h = voxtrace(eye, rd, MAX_VOXELS, true);\n    vec3 ro = eye + h.t * rd;\n    vec3 sundir = normalize(vec3(1., -2., 1.2));\n\n    vec3 col = shade_refl(eye, rd, h, sundir);\n    fragColor = vec4(pow(col, vec3(0.75)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[718, 718, 743, 864, 1687], [1689, 1689, 1710, 1710, 1865], [1867, 1867, 1890, 1890, 1945], [1947, 1947, 1976, 1976, 2032], [2034, 2034, 2059, 2059, 2125], [2127, 2127, 2156, 2156, 2333], [2335, 2335, 2361, 2361, 2521], [2523, 2523, 2552, 2659, 2695], [2698, 2698, 2723, 2723, 2768], [2770, 2770, 2796, 2796, 2856], [2858, 2858, 2899, 2899, 3053], [3055, 3055, 3127, 3127, 3347], [3349, 3349, 3437, 3437, 4648], [4651, 4651, 4716, 4716, 6092], [6750, 6798, 6846, 6846, 6895], [6897, 6897, 6960, 6960, 8276], [8278, 8278, 8303, 8303, 8373], [8375, 8375, 8399, 8399, 8446], [8448, 8448, 8501, 8501, 8705], [8707, 8707, 8781, 8781, 9862], [9864, 9864, 9932, 9932, 10985], [10987, 11032, 11100, 11100, 12351], [12353, 12353, 12410, 12410, 13121]], "test": "untested"}
{"id": "Wd2yWt", "name": "eggs", "author": "ga354", "description": "eggs", "tags": ["eggs"], "likes": 1, "viewed": 269, "published": 3, "date": "1591684368", "time_retrieved": "2024-07-30T21:02:02.855242", "image_code": "                // Some useful functions\n                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n                //\n                // Description : GLSL 2D simplex noise function\n                //      Author : Ian McEwan, Ashima Arts\n                //  Maintainer : ijm\n                //     Lastmod : 20110822 (ijm)\n                //     License :\n                //  Copyright (C) 2011 Ashima Arts. All rights reserved.\n                //  Distributed under the MIT License. See LICENSE file.\n                //  https://github.com/ashima/webgl-noise\n                //\n                float snoise(vec2 v) {\n\n                    // Precompute values for skewed triangular grid\n                    const vec4 C = vec4(0.211324865405187,\n                                        // (3.0-sqrt(3.0))/6.0\n                                        0.366025403784439,\n                                        // 0.5*(sqrt(3.0)-1.0)\n                                        -0.577350269189626,\n                                        // -1.0 + 2.0 * C.x\n                                        0.024390243902439);\n                                        // 1.0 / 41.0\n\n                    // First corner (x0)\n                    vec2 i  = floor(v + dot(v, C.yy));\n                    vec2 x0 = v - i + dot(i, C.xx);\n\n                    // Other two corners (x1, x2)\n                    vec2 i1 = vec2(0.0);\n                    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n                    vec2 x1 = x0.xy + C.xx - i1;\n                    vec2 x2 = x0.xy + C.zz;\n\n                    // Do some permutations to avoid\n                    // truncation effects in permutation\n                    i = mod289(i);\n                    vec3 p = permute(\n                            permute( i.y + vec3(0.0, i1.y, 1.0))\n                                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n                    vec3 m = max(0.5 - vec3(\n                                        dot(x0,x0),\n                                        dot(x1,x1),\n                                        dot(x2,x2)\n                                        ), 0.0);\n\n                    m = m*m ;\n                    m = m*m ;\n\n                    // Gradients:\n                    //  41 pts uniformly over a line, mapped onto a diamond\n                    //  The ring size 17*17 = 289 is close to a multiple\n                    //      of 41 (41*7 = 287)\n\n                    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n                    vec3 h = abs(x) - 0.5;\n                    vec3 ox = floor(x + 0.5);\n                    vec3 a0 = x - ox;\n\n                    // Normalise gradients implicitly by scaling m\n                    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n                    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n                    // Compute final noise value at P\n                    vec3 g = vec3(0.0);\n                    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n                    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n                    return 130.0 * dot(m, g);\n                }\n\n  vec3 lin2srgb( vec3 cl )\n        {\n                //cl = clamp( cl, 0.0, 1.0 );\n                vec3 c_lo = 12.92 * cl;\n                vec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n                vec3 s = step( vec3(0.0031308), cl);\n                return mix( c_lo, c_hi, s );\n        }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    vec2 r = iResolution.xy;\n    \n    float t = iTime;\n    // Time varying pixel color\n    vec4 col;\n\n//@shader_bot\n#define c(s)d=length(g-vec2(.1-0.01*snoise(p-t/5.)))-s \n#define s smoothstep(e, -e, d)\n//void main(){\nvec2 g=p;g.x*=r.x/r.y;\nfloat d,e;e = fwidth(p).x;\ng=mod(g,.2);\nc(.06)-0.01*snoise(5.*p + t/5.);    \ncol += 1.;\ncol-=s*.2;\nd=c(.015);\ncol-=s*vec4(-.2,.5,3.,.1);\ng-=vec2(0.005);d=c(0.0015);col+=s;\n//}\n    \n    // Output to screen\n    fragColor.xyz = lin2srgb(col.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 57, 78, 78, 125], [142, 142, 163, 163, 210], [227, 227, 249, 249, 284], [302, 783, 805, 874, 3307], [3311, 3311, 3345, 3391, 3606], [3609, 3609, 3666, 3716, 4260]], "test": "untested"}
{"id": "3llyRM", "name": "Morphing Squid Monster", "author": "jarble", "description": "What is this strange creature?", "tags": ["raymarching", "squid"], "likes": 0, "viewed": 311, "published": 3, "date": "1591681838", "time_retrieved": "2024-07-30T21:02:03.603242", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nvec3 hash33(vec3 p)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    vec2 col = (uv.yx*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\nfloat sceneSDF(vec3 p) { \n    return (length(p)-0.5/sin(p.y));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/5.0), 10.0*sin(iTime/5.0), 10.0*cos(iTime/5.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 204, 254, 636], [881, 881, 905, 905, 945], [947, 1368, 1459, 1459, 1765], [1780, 2034, 2099, 2099, 2231], [2233, 2322, 2351, 2351, 2661], [2663, 3155, 3295, 3295, 3885], [3887, 4257, 4342, 4342, 5100], [5102, 5429, 5478, 5513, 5644], [5646, 5646, 5703, 5703, 6620]], "test": "untested"}
{"id": "tlXyz7", "name": "Cratered desert planet", "author": "jarble", "description": "This planet has many caves, craters, and sand dunes. It looks fairly realistic up close, but it has many moiré patterns when viewed from a distance.", "tags": ["3d", "planet", "cave", "dunes", "desert", "crater"], "likes": 2, "viewed": 401, "published": 3, "date": "1591669271", "time_retrieved": "2024-07-30T21:02:04.408090", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float planet_size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat sceneSDF1(vec3 p) {\n    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));\n}\n\nfloat sceneSDF2(vec3 p){\n    p *= 3.0;\n\treturn 0.5 + sceneSDF1(p/2.0+sceneSDF1(p/5.0));\n}\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat planet_surface(vec3 p){\n return\tlength(p)-planet_size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = 1.1+dunes(p,10.0)/5.0+max(planet_surface(p),-min(sceneSDF2(p/7.0),min(sceneSDF2(p.xzy/11.0),sceneSDF2(p/13.0))));\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 315, 315, 453], [697, 697, 722, 769, 825], [827, 827, 851, 851, 916], [918, 918, 956, 956, 1031], [1032, 1032, 1069, 1069, 1128], [1130, 1130, 1159, 1159, 1192], [1194, 1194, 1218, 1218, 1456], [1458, 1879, 1970, 1970, 2276], [2291, 2545, 2610, 2610, 2742], [2744, 2833, 2862, 2862, 3172], [3174, 3666, 3806, 3806, 4416], [4418, 4788, 4873, 4873, 5645], [5647, 5974, 6023, 6058, 6189], [6191, 6191, 6248, 6248, 7226]], "test": "untested"}
{"id": "wlXcR7", "name": "Recursive Donut Path Traced", "author": "ShnitzelKiller", "description": "Path traced version of https://www.shadertoy.com/view/tls3WB. Use the mouse to change the shape of the fractal.", "tags": ["fractal", "interactive", "torus", "pathtracing", "mouseable"], "likes": 13, "viewed": 418, "published": 3, "date": "1591668674", "time_retrieved": "2024-07-30T21:02:05.268789", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor = vec4(pow(col, vec3(0.5)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//camera, path tracing, material parameters\n#define FOV 1.9\n#define FOCAL_DIST 2.\n#define APERTURE 0.01\n#define MAXSTEP 100\n#define TOL 0.005\n#define MAXDIST 100.\n#define EPS 0.01\n#define BOUNCES 8\n#define SCATTER_FACTOR 0.15\n#define PI 3.1415926\n#define RENDERS_PER_FRAME 1\n#define SKYCOL vec3(0.0, 0.0, 0.0)\n#define ATMOSPHERE_TRANSMISSION 0.9\n\n//donut parameters\n#define min_rings 3.\n#define max_rings 10.\n#define levels 6\n#define ratio 0.4\n#define ring_offset 1.5\n#define offsetdiff 0.8\n#define indent 0.2\n#define base_radius 2.    \n#define plane_height -2.\n#define laplace_factor 0.7\n\nvec2 sdTorus( vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    \n    float theta = atan(-p.z, p.x); //outer angle\n    return vec2(d, theta);\n}\n\nvec2 map(vec3 p) {\n    float final_offset;\n    if (iMouse.y < 1.)\n        final_offset = offsetdiff*1.9 + ring_offset;\n    else\n        final_offset = (iMouse.y/iResolution.y-0.5)*3.+2.;\n    float final_ratio = ratio/final_offset;\n    \n    float ringdiff = (max_rings-min_rings)*0.5;\n    float ring_count = (max_rings+min_rings)*0.5;\n    float final_ringcount;\n    if (iMouse.x < 1.)\n    \tfinal_ringcount = ringdiff*-0.2 + ring_count;\n    else\n    \tfinal_ringcount = ringdiff*(iMouse.x/iResolution.x-0.5)*2. + ring_count;\n    float sector = 2.*PI/(final_ringcount);\n    float outerrad = base_radius;\n    float innerrad = outerrad*final_ratio;\n    vec2 h = sdTorus(p, vec2(outerrad, innerrad));\n    int i;\n    float currindent = indent;\n    vec2 minh = h;\n    \n    for (i=0; i<levels; i++) {\n        \n        //mod polar coordinates\n        float theta = mod(abs(h.y), sector)-sector/2.;\n        \n        //new cartesian coords\n        float s = length(p.zx);\n        p.z = cos(theta)*s - outerrad;\n        p.x = sin(theta)*s;\n        p = p.zxy;\n        \n        //new torus\n        outerrad = innerrad*final_offset;        \n        innerrad = outerrad*final_ratio;\n        h = sdTorus(p, vec2(outerrad, innerrad));\n        \n        minh.x = max(minh.x, currindent-h.x);\n        if (h.x < minh.x) {\n            minh = h;\n        }\n        \n        currindent = currindent * final_ratio * final_offset;\n    }\n    return vec2(minh.x, 2.0);\n}\n\nvec4 getnormal(vec3 pos) {\n    //if on the ground, use preset value (it's not part of the SDF)\n    if (pos.y < plane_height + TOL) return vec4(0., 1., 0., 0.);\n    vec2 offset = vec2(TOL, 0.0);\n    float dx0 = map(pos-offset.xyy).x;\n    float dxf = map(pos+offset.xyy).x;\n    float dy0 = map(pos-offset.yxy).x;\n    float dyf = map(pos+offset.yxy).x;\n    float dz0 = map(pos-offset.yyx).x;\n    float dzf = map(pos+offset.yyx).x;\n    float ddd = map(pos).x;\n    return vec4(normalize(vec3(dxf - dx0, dyf - dy0, dzf - dz0)), (dx0+dxf+dy0+dyf+dz0+dzf-6.*ddd)/TOL);\n}\n\nvec2 raymarch(in vec3 eye, in vec3 rd) {\n    \n    float t = 0.0;\n    for (int i=0; i<MAXSTEP; i++) {\n        vec3 pos = eye + rd*t;\n        vec2 dist = map(pos);\n        t += dist.x;\n        if (abs(dist.x) < TOL) {\n            return vec2(t, dist.y);\n        } else if (t > MAXDIST) break;\n    }\n    //raytrace ground plane\n    t = (plane_height-eye.y) / rd.y;\n    return vec2(t, step(-t, 0.)*step(length((eye+t*rd).zx), 50.));\n}\n\nuint seed;\nuint wang_hash()\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nuint pcg_hash()\n{\n    uint word = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;\n    seed = seed * 747796405u + 2891336453u;\n    return (word >> 22u) ^ word;\n}\n\nfloat GetRandom()\n{\n    return float(pcg_hash()) / 4294967296.0;\n}\nvec2 GetRandom2(){return vec2(GetRandom(), GetRandom());}\n\nvec3 randnorm() {\n    vec2 utheta = GetRandom2() * 2. - 1.;\n    utheta.y *= PI;\n    float rho = sqrt(1.-utheta.x * utheta.x);\n    return vec3(cos(utheta.y)*rho, sin(utheta.y)*rho, utheta.x);\n}\n\nvec3 pathtrace(in vec3 eye, in vec3 rd) {\n    vec3 col = vec3(0.);\n    vec3 thru = vec3(1.);\n    for (int i=0; i<BOUNCES; i++) {\n        vec2 d = raymarch(eye, rd);\n        thru *= pow(ATMOSPHERE_TRANSMISSION, d.x);\n        if (d.y < 0.5) {\n            col += thru * SKYCOL;\n            break;\n        }\n        eye = eye + d.x * rd;\n        vec4 n = getnormal(eye);\n        vec3 nr = randnorm();\n        vec3 nref = reflect(rd, n.xyz);\n        //materials\n        vec3 albedo = vec3(1.);\n        vec3 emissive = vec3(0.);\n        float scatter_factor = 1.0;\n        if (d.y < 1.5) {\n            //checker ground\n            vec2 uv = eye.zx;\n            uv = abs(mod(uv, 2.)-1.);\n            float checker = abs(step(uv.x, .5) - step(uv.y, .5));\n            albedo = mix(vec3(0.8, 0.8, 0.9), vec3(0.1), checker);\n            emissive = (1.-checker) * vec3(0.3, 0.7, 0.9);\n            scatter_factor = mix(0.05, 0.004, checker);\n        } else if (d.y < 2.5) {\n            //glowy donut\n            float edgefac = abs(n.w*laplace_factor);\n            albedo = vec3(1., 0.7, 0.6);\n            float emissfac = edgefac * edgefac;\n            emissive = vec3(1., 0.9, 0.6) * emissfac;\n            scatter_factor = smoothstep(0., 1., emissfac * 30.);\n        }\n        nr = mix(nref, normalize(n.xyz + nr), scatter_factor);\n        col += thru * emissive;\n        thru *= albedo;\n        \n        float maxthru = max(thru.x, max(thru.y, thru.z));\n        if (GetRandom() > maxthru) {\n            break;\n        }\n        thru *= 1.0/maxthru;\n        \n        rd = nr;\n        eye += EPS * rd;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //camera position\n\t//float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    //float mouseX = iMouse.x < 1. ? 0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    float mouseY = 0.5;\n    float mouseX = 0.25;\n    vec3 eyeo = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    \n    vec4 oldCol = texture(iChannel0, fragCoord/iResolution.xy);\n    bool dirty = iMouse.z > 1. || iMouse.w > 1. || iFrame == 0;\n    float oldWeight = oldCol.w;\n    vec3 w = normalize(vec3(0., -.5, 0.) - eyeo);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    \n    //if (dirty) {\n    //    fragColor = vec4(pathtrace(eye, rd, 0.), 1.);\n    //} else {\n    if (dirty) oldWeight = 0.0;\n        for (int i=0; i<RENDERS_PER_FRAME; i++) {\n            fragCoord += GetRandom2() - 0.5;\n    \n            vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x * FOV;\n            vec2 c = cos(uv);\n            vec2 s = sin(uv);\n            vec3 rd = normalize(s.x * c.y * u + s.y * v + c.x * c.y * w);\n            vec3 focalPt = eyeo + rd * FOCAL_DIST;\n            vec2 rtheta = GetRandom2();\n            float sampledist = sqrt(rtheta.x);\n            vec2 xy = APERTURE * sampledist * vec2(sin(rtheta.y), cos(rtheta.y));\n            vec3 eye = eyeo + rd + u * xy.x + v * xy.y;\n            rd = normalize(focalPt - eye);\n            \n            vec3 col = pathtrace(eye, rd);\n            float newWeight = oldWeight + 1.0;\n            oldCol.xyz = (oldCol.xyz * oldWeight + col) / newWeight;\n            oldWeight = newWeight;\n        }\n        fragColor = vec4(oldCol.xyz,oldWeight);\n    //}\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 181]], "test": "untested"}
{"id": "3tXyRM", "name": "Trippy Shitty Waves", "author": "sin3point14", "description": "two opposite waves", "tags": ["waves"], "likes": 4, "viewed": 287, "published": 3, "date": "1591652575", "time_retrieved": "2024-07-30T21:02:06.070645", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist = 7.0f * length(fragCoord.xy - iResolution.xy)/length(iResolution.xy);\n    float red = abs(cos(iTime - dist));\n    //float red = 0.0f;\n    dist = 7.0f * length(fragCoord.xy)/length(iResolution.xy);\n    float green = abs(cos(iTime - dist));\n\t//float green = 0.0f;\n    fragColor = vec4(red, green, 0.0f, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 383]], "test": "untested"}
{"id": "wlXcRM", "name": "Xor Roller 2", "author": "Chris_M_Thomasson", "description": "Testing out the granularity...", "tags": ["fractal"], "likes": 5, "viewed": 331, "published": 3, "date": "1591651248", "time_retrieved": "2024-07-30T21:02:06.912395", "image_code": "// Chris M. Thomasson's Stupid Simple Xor Roller. ;^)\n// version: pre-alpha 0.0.3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n    vec2 uv = fragCoord.xy / iResolution.xy; \n\n    int x = int(fragCoord.x); \n    int y = int(fragCoord.y); \n\n    int xy_xor = (x + iFrame) ^ (y);\n    //float s = .01 + abs(sin(iTime * .01)) * (abs(cos(iTime * sin(iTime * .05) * .001) * .01));\n    \n    float s = 0.89 + abs(sin(iTime * .0001)) * .1;\n    \n    float cr = mod(float(xy_xor) * 1.1 * s, 1.0);\n    float cg = cr;\n    float cb = cr;\n\t//float cg = mod(float(xy_xor) * abs(sin(iTime * 0.01)) * 1.234 * s, 1.0);\n    //float cb = mod(float(xy_xor) * 2.253 * s, 1.0);\n    \n    float dis = .5 + abs(sin(iTime * .5)) * .3;\n    \n    if (cr < dis)\n    {\n     \tcg = (cr / dis) * .1;\n        cb = (cr / dis) * .2;\n        cr = 0.;\n    }\n    \n    fragColor = vec4(cr, cg, cb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 139, 139, 872]], "test": "untested"}
{"id": "wlfyzN", "name": "Curly", "author": "Oggbog", "description": "An experiment with four layers of Truchets.", "tags": ["truchet"], "likes": 4, "viewed": 365, "published": 3, "date": "1591623629", "time_retrieved": "2024-07-30T21:02:07.661392", "image_code": "float hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nfloat qCircle(vec2 uv){\n    float p;\n    float d = length(uv);\n    \n    p = smoothstep(0.2,0.19,d);\n    p -= smoothstep(0.1,0.09,d);\n    \n    return p;\n    \n}\n\nvec3 layer(vec2 uv, float size, vec2 scroll, vec3 color,vec3 canvas){\n    uv *= size;\n    uv += scroll;\n    \n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    float n = hash21(id);\n    n = floor(n*2.0);\n    \n    float d1,d2;\n    float off = 1.0;\n    \n    if (n==0.0){\n        d1 = length(gv-vec2(0.0,0.0));\n    \td2 = length(gv-vec2(off,off));  \n    } else {\n        d1 = length(gv-vec2(off,0.0));\n    \td2 = length(gv-vec2(0.0,off));\n    }\n    \n    // truchet\n    float p = smoothstep(0.65,0.64,d1);\n    p -= smoothstep(0.35,0.34,d1);\n    p += smoothstep(0.65,0.64,d2);\n    p -= smoothstep(0.35,0.34,d2);\n    \n    // inner circle\n    p += qCircle(gv-vec2(0.0));\n    p += qCircle(gv-vec2(0.0,off));\n    p += qCircle(gv-vec2(off,0.0));\n    p += qCircle(gv-vec2(off,off));\n    \n    // add color\n    if (p==1.0){\n    \tcanvas = color;\n    }\n    \n    return canvas;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 canvas = mix(vec3(1.0,1.0,0.0),vec3(1.0,0.0,0.0),uv.x);\n    fragColor = vec4(canvas,1.0);\n    \n    float a = iTime/4.0;\n    uv = uv * mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    vec3 l = layer(uv,50.0,vec2(iTime/8.0,0.0),vec3(0.2),canvas);\n    l = layer(uv,20.0,vec2(0.0,sin(iTime/4.0)),vec3(0.5),l);\n    l = layer(uv,8.0,vec2(iTime/2.0,sin(-iTime/2.0)),vec3(0.7),l);\n    l = layer(uv,6.0,vec2(cos(-iTime/1.5),iTime/1.5),vec3(0.98),l);\n    fragColor = vec4(l,1.0);\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 122], [124, 124, 147, 147, 282], [284, 284, 353, 353, 1153], [1155, 1155, 1212, 1212, 1764]], "test": "untested"}
{"id": "wtsczN", "name": "Expnd. Fibonacci Flower loopless", "author": "FabriceNeyret2", "description": "t[url]https://shadertoy.com/view/wllyzH[/url] was looping on disks splatting.\nTo make it loopless,  find which disk might cover the cur pixel.\nHere disks can be larger than spiral strips, so we still have to sum over a span ( mouse click & see img below).", "tags": ["fibonacci", "loopless"], "likes": 37, "viewed": 861, "published": 3, "date": "1591610943", "time_retrieved": "2024-07-30T21:02:08.400416", "image_code": "// looplessing julianlumia's \"Expanding Fibonacci Flower\" https://shadertoy.com/view/wllyzH\n\nvoid mainImage(out vec4 O, vec2 u) {            \n    vec2  R = iResolution.xy,                               \n          U = u+u-R, A = abs(U);                            \n    float m = 1e6, \n          r = max(A.x, A.y)*.06,                       // disk radius\n          X = floor(sin(iTime)*95.+95.),               // smaller disk index\n          D = 24. * r/R.y/.06,                         // spiral strips window (disk coverage)\n         PI = 3.1415927,\n          a = atan(-U.y,U.x), l = length(U)/R.y*15., \n         x1 = ( a -iTime/2.) / 2.307, L = 2.*PI/2.307,\n         x2 = l*l +  X,\n          k = round((x2-x1)/L),\n          x = round( x1 + L*k);                        // disk center\n    if (x>=X) D = 2. + D*sqrt( x - X ) / sqrt(2e2);    // update strip window according to local spiral width\n    O-=O; \n    if (iMouse.z>0.) O += U.y > 0. ? fract(x1+k*L)       // top:    show underlying spirals\n                                   : floor(2.*D/2.3)/23.;// bottom: show strip window size: white=22\n    for( float d = -D; d <= D; d+=2.307)  { \n        k = round((x2+d-x1)/L), x = round( x1 + L*k);\n        if (x>=X && x<=2e2 )\n      //for (x=0.; x++<2e2;) {                  // initial loop on disks\n        m = min( m,  length( U - R.y*sqrt( x - X ) / 15.\n                                 *cos (x * 2.307 + iTime/2. + vec2(0,PI/2.))) ) ;  \n       }\n    O += vec4(0,1,abs(U/R).yy) * clamp(.5-(m-r)/3., 0.,1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 129, 129, 1513]], "test": "untested"}
{"id": "wtlyzN", "name": "antialiasing: the correlation pb", "author": "FabriceNeyret2", "description": "At max filtering each layer is assumed ~= 50% opaque unif color.\nPb: alpha-based blending (Middle) is correct only if no correlation in visibility, which is not the case here ( like all Moirés, but occurs in many other situations).\nRight: ground truth.", "tags": ["antialiasing", "filtering", "moir", "correlation", "short", "visibility"], "likes": 7, "viewed": 359, "published": 3, "date": "1591605268", "time_retrieved": "2024-07-30T21:02:09.220225", "image_code": "#define strip(v) (   n!=1 ? mod(floor(v),2.)                                 \\\n                   :        smoothstep(-.8/s,.8/s, abs(mod(v+1.,2.)-1.)-.5 ) \\\n                 )                    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R  = iResolution.xy,\n         U  = u ;\n    float s = .2+floor(U.y/R.y*5.);              // strip width\n    int   n = int(u.x/R.x*3.);                   // subwindow index\n\n    O-=O;\n    if ( int(U)*3%int(R)<3 || int(U.y)*5%int(R.y)<5) return; // black separators\n    U /= s;                                      // scale strips\n\n    if (n<2) {\n        O.ra += strip(U.x);                      // red strip\n\n        U *= mat2(cos( .05 + vec4(0,11,33,0) )); // rotate second layer\n        O.ga += (1.-O.a) *strip(U.x);            // blend green strip behind red layer\n    } \n    else {                                       // --- same with numerical integration\n        float d=1./100., x,i,a;\n        for ( i=-.5;  i<.5; i+=d) {              // oversampling\n            x = U.x+i/s;\n            a = strip(x); O.ra += a;             // red strip\n         // O.ra += a = strip(x);                // no longer compiles\n            x = dot( vec2(x,U.y),  cos( .05 + vec2(0,11) )); // rotate\n            O.ga += (1.-a) *strip(x);            // subpixel-blend green strip behind red layer\n        }\n        O *= d;\n    }\n    \n    O = pow(O,vec4(1./2.2));                     // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 235, 235, 1426]], "test": "untested"}
{"id": "wlscRN", "name": "XOR ^ float(n)", "author": "FabriceNeyret2", "description": "effect of bitwise operators XOR, AND, OR once powered by fractionals from 0 (left) to 4 (right)\nStrange how Xor \"hashes\" into circuit-like patterns.\n\nsee also [url]https://shadertoy.com/view/ttscRN[/url] and  [url]https://shadertoy.com/view/wllcRN[/url]", "tags": ["xor", "pattern", "hash", "bitwise", "circuits"], "likes": 15, "viewed": 428, "published": 3, "date": "1591599929", "time_retrieved": "2024-07-30T21:02:09.986176", "image_code": "// variant of https://shadertoy.com/view/ttscRN\n// variant of https://shadertoy.com/view/wllcRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy;\n    ivec2 I = ivec2(U+60.*iTime);\n    int t = int(iTime) % 3, \n        n = int(U.x/R.x*4.),\n        i =   t==1 ? I.x ^ I.y\n            : t==2 ? I.x | I.y\n            :        I.x & I.y;\n                 //  I.x * I.y;\n    \n    float v = pow( float(i), floor(U.x/R.x*4.*5.)/5. );\n\n    O = vec4( fract( v / 256.) );\n    \n    if ( int(U.x)*20 % int(R.x) < 20 ) O.r++; // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 135, 135, 549]], "test": "untested"}
{"id": "ttscRN", "name": "XOR ^ n", "author": "FabriceNeyret2", "description": "effect of bitwise operators XOR, AND, OR once powered to 1,2,3,4 (from left to right )\nStrange how Xor \"hashes\" into circuit-like patterns.\n\nsee also [url]https://shadertoy.com/view/wllcRN[/url]", "tags": ["xor", "pattern", "hash", "bitwise", "circuits"], "likes": 7, "viewed": 383, "published": 3, "date": "1591598625", "time_retrieved": "2024-07-30T21:02:10.796011", "image_code": "// variant of https://shadertoy.com/view/wllcRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy;\n    ivec2 I = ivec2(U+60.*iTime);\n    int t = int(iTime) % 3, \n        n = int(U.x/R.x*4.),\n        i =   t==1 ? I.x ^ I.y\n            : t==2 ? I.x | I.y\n            :        I.x & I.y;\n                 //  I.x * I.y;\n    \n    i = n==0 ? i : n==1 ? i*i : n==2 ? i*i*i : i*i*i*i; \n    float v = float( i );\n\n    O = vec4( fract( v / 256.) );\n    \n    if ( int(U.x)*4 % int(R.x) < 4 ) O.r++; // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttscRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 526]], "test": "untested"}
{"id": "wllcRN", "name": "fract ( XOR / n )", "author": "FabriceNeyret2", "description": "effect of bitwise operators XOR, AND, OR once divided by:\n    left:  pow of 2 (i.e. direct content)   \n    right: non-power of 2\n\ntry also: i*i , i*i*i\nStrange how Xor \"hashes\" into circuit-like patterns.\nSee also [url]https://www.shadertoy.com/view/ttscR", "tags": ["xor", "pattern", "hash", "bitwise", "circuits"], "likes": 15, "viewed": 453, "published": 3, "date": "1591598048", "time_retrieved": "2024-07-30T21:02:11.591883", "image_code": "// inspired from python273 https://shadertoy.com/view/4ldyW8\n// See also https://www.shadertoy.com/view/ttscRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    ivec2 I = ivec2(U+60.*iTime);\n    int t = int(iTime) % 3,\n        i =   t==1 ? I.x ^ I.y\n            : t==2 ? I.x | I.y\n            :        I.x & I.y;\n                 //  I.x * I.y;\n    \n    float v = float(i);  // try also: i*i , i*i*i\n\n    O = vec4( U.x < R.x/2. \n                 ? fract( v / 256.)\n                 : fract( v / 13. )\n            );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 150, 150, 540]], "test": "untested"}
{"id": "wlsyRN", "name": "Shining Jacks", "author": "ShnitzelKiller", "description": "Path tracing practice", "tags": ["raymarching", "pathtracing"], "likes": 9, "viewed": 413, "published": 3, "date": "1591597133", "time_retrieved": "2024-07-30T21:02:12.530374", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FOV 1.9\n#define FOCAL_DIST 7.\n#define LENS_DIST 1.\n#define APERTURE 0.1\n#define MAXSTEP 100\n#define TOL 0.01\n#define MAXDIST 100.\n#define EPS 0.02\n#define BOUNCES 8\n#define SCATTER_FACTOR 0.1\n#define SHARP 4.\n#define RADIUS 0.6\n#define RINGRAD 3.\n#define RINGPERIOD 6.\n#define PERIOD 3.2\n#define HEIGHT 0.7\n#define PI 3.1415926\n#define RENDERS_PER_FRAME 3\n#define SKYCOL vec3(0.0, 0.0, 0.0)\n#define ATMOSPHERE_TRANSMISSION 0.9\n    \nvec2 condmin(in vec2 d1, in vec2 d2) {\n    return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvec2 map(in vec3 ro) {\n    vec2 d = vec2(1e10, 0);\n    ro.z = 5.-abs(-ro.z+5.);\n    d = condmin(d, vec2(ro.z, 1));\n    ro.xy = mod(ro.xy+0.5*PERIOD, PERIOD)-0.5*PERIOD;\n    float metadist = length(ro-vec3(0, 0, HEIGHT))-RADIUS*1.2;\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            float otherdist = length(ro - vec3(i*2-1, j*2-1, HEIGHT))-RADIUS;\n            metadist = -log(exp(-SHARP * metadist) + exp(-SHARP * otherdist))/SHARP;\n        }\n    }\n    d = condmin(d, vec2(metadist, 2.));\n    return d;\n}\n\nvec3 getnormal(vec3 ro) {\n    vec2 d = vec2(TOL, 0.0);\n    return normalize(vec3(\n        map(ro+d.xyy).x-map(ro-d.xyy).x,\n        map(ro+d.yxy).x-map(ro-d.yxy).x,\n        map(ro+d.yyx).x-map(ro-d.yyx).x));\n}\n\nvec2 raymarch(in vec3 eye, in vec3 rd) {\n    \n    float t = 0.0;\n    for (int i=0; i<MAXSTEP; i++) {\n        vec3 pos = eye + rd*t;\n        vec2 dist = map(pos);\n        t += dist.x;\n        if (abs(dist.x) < TOL) {\n            return vec2(t, dist.y);\n        } else if (t > MAXDIST) break;\n    }\n    return vec2(t, 0.);\n}\n\nuint seed;\n\nuint wang_hash()\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat GetRandom()\n{\n    return float(wang_hash()) / 4294967296.0;\n}\n\nvec2 GetRandom2(){return vec2(GetRandom(), GetRandom());}\n\nvec3 randnorm() {\n    vec2 utheta = GetRandom2() * 2. - 1.;\n    utheta.y *= PI;\n    float rho = sqrt(1.-utheta.x * utheta.x);\n    return vec3(cos(utheta.y)*rho, sin(utheta.y)*rho, utheta.x);\n}\n\nvec3 pathtrace(in vec3 eye, in vec3 rd) {\n    vec3 col = vec3(0.);\n    vec3 thru = vec3(1.);\n    for (int i=0; i<BOUNCES; i++) {\n        vec2 d = raymarch(eye, rd);\n        thru *= pow(ATMOSPHERE_TRANSMISSION, d.x);\n        if (d.y < 0.5) {\n            col += thru * SKYCOL;\n            break;\n        }\n        eye = eye + d.x * rd;\n        vec3 n = getnormal(eye);\n        vec3 nr = randnorm();\n        vec3 nref = reflect(rd, n);\n\t\tnr = mix(nref, normalize(n + nr), SCATTER_FACTOR);\n        vec3 albedo = vec3(1.);\n        vec3 emissive = vec3(0.);\n        if (d.y < 1.5) {\n            albedo = vec3(0.3, 0.7, 0.9);\n        } else if (d.y < 2.5) {\n            float fac = 1.-smoothstep(0., RADIUS+0.5, length(mod(eye.xy+0.5*PERIOD, PERIOD)-0.5*PERIOD));\n            vec2 id = floor(eye.xy/PERIOD + 0.5);\n            id = mod(id, RINGPERIOD)-RINGPERIOD*0.5;\n            float fac2 = length(id) - RINGRAD;\n            fac2 = max(0., 1.-fac2*fac2);\n            fac *= fac2;\n            albedo = vec3(0.6, 0.9, 0.5);\n            emissive = fac * 10.*vec3(0.4, 0.1, 0.0);\n        }\n        \n        col += thru * emissive;\n        thru *= albedo;\n        \n        float maxthru = max(thru.x, max(thru.y, thru.z));\n        if (GetRandom() > maxthru) {\n            break;\n        }\n        thru *= 1.0/maxthru;\n        \n        rd = nr;\n        eye += EPS * rd;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //camera position\n\tfloat mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? 0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eyeo = 7.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = -normalize(eyeo);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec4 oldCol = texture(iChannel0, fragCoord/iResolution.xy);\n    bool dirty = iMouse.z > 1. || iMouse.w > 1. || iFrame == 0;\n    float oldWeight = oldCol.w;\n    //if (dirty) {\n    //    fragColor = vec4(pathtrace(eye, rd, 0.), 1.);\n    //} else {\n    if (dirty) oldWeight = 0.0;\n        for (int i=0; i<RENDERS_PER_FRAME; i++) {\n            fragCoord += GetRandom2() - 0.5;\n    \n            vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x * FOV;\n            vec2 c = cos(uv);\n            vec2 s = sin(uv);\n            vec3 rd = normalize(s.x * c.y * u + s.y * v + c.x * c.y * w);\n            vec3 focalPt = eyeo + rd * FOCAL_DIST;\n            vec2 rtheta = GetRandom2();\n            float sampledist = sqrt(rtheta.x);\n            vec2 xy = APERTURE * sampledist * vec2(sin(rtheta.y), cos(rtheta.y));\n            vec3 eye = eyeo + LENS_DIST * rd + u * xy.x + v * xy.y;\n            rd = normalize(focalPt - eye);\n            vec3 col = pathtrace(eye, rd);\n            float newWeight = oldWeight + 1.0;\n            oldCol.xyz = (oldCol.xyz * oldWeight + col) / newWeight;\n            oldWeight = newWeight;\n        }\n        fragColor = vec4(oldCol.xyz,oldWeight);\n    //}\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 182]], "test": "untested"}
{"id": "3tlcRN", "name": "Swiss cheese planet", "author": "jarble", "description": "This planet is full of holes!\nI was trying to make a planet with realistic caves, but it looks more like Swiss cheese.", "tags": ["raymarching", "sdf", "planet"], "likes": 2, "viewed": 385, "published": 3, "date": "1591562060", "time_retrieved": "2024-07-30T21:02:13.459889", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\nvec3 surface_color(vec3 p)\n{\n    return sin(p);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat bump(vec3 p3)\n{\n    //add bumps to the planet's surface\n    float distortion = 5.0;\n    p3 *= distortion;\n    return length(sin(p3))/(distortion*5.0);\n}\n\nfloat sceneSDF1(vec3 p) {\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  5.0 + sin((p.x*2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    return max(length(p)-200.0,-sceneSDF1(p/100.0))+(bump(p/40.0)*40.0+bump(p/20.0)*20.0)+bump(p/10.0)*10.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n      \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(sin(iTime/5.0), 10.0*sin(iTime/5.0), 10.0*cos(iTime/5.0))*80.0;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 209, 209, 230], [473, 473, 494, 534, 631], [633, 633, 658, 658, 768], [771, 771, 795, 795, 906], [908, 1329, 1420, 1420, 1726], [1741, 1995, 2060, 2060, 2192], [2194, 2283, 2312, 2312, 2622], [2624, 3116, 3256, 3256, 3866], [3868, 4238, 4323, 4323, 4752], [4754, 5081, 5130, 5165, 5296], [5298, 5298, 5355, 5355, 6279]], "test": "untested"}
{"id": "3tlcz4", "name": "Xor Roller ", "author": "Chris_M_Thomasson", "description": "Another version of the xor roller, showing less, can show more? ;^)", "tags": ["fractal"], "likes": 8, "viewed": 792, "published": 3, "date": "1591557452", "time_retrieved": "2024-07-30T21:02:14.311611", "image_code": "// Chris M. Thomasson's Stupid Simple Xor Roller. ;^)\n// version: pre-alpha 0.0.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n    vec2 uv = fragCoord.xy / iResolution.xy; \n\n    int x = int(fragCoord.x); \n    int y = int(fragCoord.y); \n\n    int xy_xor = (x + iFrame) ^ (y);\n    float s = .01 + abs(sin(iTime * .01)) * (abs(cos(iTime * sin(iTime * .05) * .001) * .01));\n    \n    float cr = mod(float(xy_xor) * 1.1 * s, 1.0);\n\tfloat cg = mod(float(xy_xor) * abs(sin(iTime * 0.01)) * 1.234 * s, 1.0);\n    float cb = mod(float(xy_xor) * 2.253 * s, 1.0);\n    \n    float dis = .5 + abs(sin(iTime * .5)) * .4;\n    \n    if (cr < dis)\n    {\n     \tcr = 0.;  \n    }\n    \n    fragColor = vec4(cr, cr, cr, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 139, 139, 714]], "test": "untested"}
{"id": "3tXczn", "name": "Alien Corridor Surprise", "author": "dean_the_coder", "description": "Travelling an alien corridor - What's at the end?", "tags": ["procedural", "3d", "raymarching", "alien"], "likes": 7, "viewed": 488, "published": 3, "date": "1591556367", "time_retrieved": "2024-07-30T21:02:15.148374", "image_code": "#define FAST_NOISE\n//#define USE_WEBCAM\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 87.43))) * 5432.3);\n}\n\nfloat noise(vec2 p) {\n#ifdef FAST_NOISE\n    p *= 0.05;\n    return texture(iChannel1, p).r;\n#else\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(a, b, f.x) +\n            (c - a) * f.y * (1.0 - f.x) +\n            (d - b) * f.x * f.y;\n#endif\n}\n\nfloat fbm(vec2 p) {\n\tfloat f;\n    f  = 0.5 * noise(p * 1.1);\n    f += 0.22 * noise(p * 2.3);\n    f += 0.0625 * noise(p * 8.4);\n    return f / 0.7825;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  return length(vec2(length(p.xy) - t.x, p.z)) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCorridorRibs(vec3 p) {\n    float d = 0.6;\n    p.z = mod(p.z, d) - d * 0.5;\n    \n    return sdTorus(p, vec2(2.0, 0.2));\n}\n\nfloat sdCorridorTube(vec3 p) {\n    \n    float lxy = length(p.xy);\n    float d = max(lxy - 2.0, 1.9 - lxy);\n    \n    float t = fbm((p.xy + p.yz) * 4.0) * 0.05;\n    return d - t;\n}\n\nfloat sdCorridorRoof(vec3 p) {\n    p.y -= 2.5;\n    float rib = abs(0.5 + 0.5 * sin(p.z * 1.4));\n    return length(p.xy) - 1.2 + 0.2 * pow(rib, 4.0);\n}\n\nvec3 applyCorriderCurve(vec3 p) {\n    // Curve the tunnel (Remember there is no spoon!)\n    p.xz *= rot(-0.01 * p.z);\n    \n    // Walk.\n    if (iTime < 44.0)\n    \tp.z += iTime;\n    else\n        p.z += 44.0 + 2.6 * smoothstep(0.0, 1.0, min(1.0, (iTime - 44.0) / 2.6));\n    \n    return p;\n}\n\n#define EGG_Z 49.0\n\nfloat sdCorridorFloor(vec3 p) {\n    p = applyCorriderCurve(p);\n    p.y += sin(p.x * 1.1 + sin(p.z * 0.7)) * 0.15;\n    float d = p.y + 1.5 + sin(p.z) * 0.05;\n    \n    d = min(d, length(p - vec3(0.0, -3.3, EGG_Z)) - 2.0);\n    \n    return d - fbm(p.xz) * 0.1;\n}\n\nfloat sdCorridor(vec3 p) {\n    p = applyCorriderCurve(p);\n    vec3 pp = p;\n    pp.x = abs(pp.x) - 0.8;\n    float d = smin(sdCorridorRibs(pp), sdCorridorTube(pp), 0.1);\n    d = smin(d, sdCorridorRoof(p), 0.3);\n    \n    return d;\n}\n\nfloat sdEgg(vec3 p) {\n    p = applyCorriderCurve(p);\n    \n    vec3 pp = p;\n    pp.z -= EGG_Z;\n    pp.y += 1.0;\n    \n    float d;\n\n    pp.y *= 0.7;\n    d = length(pp) - 0.4;\n    \n    float startOpenTime = 45.0;\n    float openness = min(1.0, max(0.0, iTime - startOpenTime) * 0.1);\n    if (iTime >= 55.0)\n        openness += sin((iTime - 55.0) * 1.0) * 0.05;\n    \n    float cutOut = length(pp.xz) - p.y * 0.5 - mix(0.1, 0.7, openness);\n    d = smin(d, -cutOut, -0.1);\n    \n    float rim = sdTorus(\n        (pp - vec3(0.0, mix(0.40, 0.25, openness), 0.0)).xzy,\n        vec2(0.35, 0.04) * openness);\n    d = smin(d, rim, 0.05 * openness);\n    \n    d -= fbm(pp.xz + pp.xy) * 0.05;\n    \n    return d;\n}\n\nfloat sdSurprise(vec3 p) {\n    float t = min(1.0, max(0.0, iTime - 62.0));\n    if (t <= 0.0) return 1e10;\n\n    p = applyCorriderCurve(p);\n    p.z -= EGG_Z;\n    \n    p.y += 1.5 - 1.4 * sin(t * 3.14159 * 0.5);\n    \n    float tt = max(0.0, iTime - 62.8) * 2.5;\n    return length(p) - mix(0.1, 2.0, clamp(0.0, 1.0, tt));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 map(vec3 p) {\n    vec2 d1 = vec2(sdCorridor(p), 1.5);\n    vec2 d2 = vec2(sdCorridorFloor(p), 2.5);\n    vec2 d3 = vec2(sdEgg(p), 3.5);\n    \n    vec2 d = min2(min2(d1, d2), d3);\n    d = min2(d, vec2(sdSurprise(p), 4.5));\n    return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.01;\n    for (int i = 0; i < 16; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\nfloat calcSpotlight(vec3 p, vec3 lightPos, vec3 lightDir, float cutOff, float edgeBlur) {\n    float l = dot(normalize(lightPos - p), -lightDir);\n    edgeBlur += 1.0;\n    float spotLight = smoothstep(1.0 - cutOff, (1.0 - cutOff) * edgeBlur, l) * 0.3;\n    cutOff *= 0.7;\n    spotLight = max(spotLight, smoothstep(1.0 - cutOff, (1.0 - cutOff) * 1.06, l)) * 0.5;\n    cutOff *= 0.7;\n    return max(spotLight, smoothstep(1.0 - cutOff, (1.0 - cutOff) * 1.07, l));\n}\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec2 getTorchDir() {\n    \n    float tSeg = iTime;\n    \n    // Look at ceiling.\n    if (tSeg < 2.0) return vec2(0.0, 1.0);\n    tSeg -= 2.0;\n    \n    // Look ahead.\n    if (tSeg < 4.0) return vec2(0.0, mix(1.0, 0.0, smoothstep(0.0, 1.0, min(1.0, tSeg / 2.0))));\n    tSeg -= 4.0;\n    \n    // Down to floor.\n    if (tSeg < 3.5) return vec2(0.0, mix(0.0, -0.4, smoothstep(0.0, 1.0, min(1.0, tSeg / 1.5))));\n    tSeg -= 3.5;\n\n    // Up the wall.\n    if (tSeg < 4.0) {\n        float f = smoothstep(0.0, 1.0, min(1.0, tSeg / 4.0));\n        return vec2(sin(f * 3.141) * -0.6, -0.4 + 1.1 * sin(f * 3.141 / 2.0));\n    }\n    tSeg -= 4.0;\n\n    // Look ahead - Walking.\n    if (tSeg < 12.0) return vec2(0.0, mix(0.7, -0.2, smoothstep(0.0, 1.0, min(1.0, tSeg))));\n    tSeg -= 12.0;\n\n    // Is that an egg?\n    if (tSeg < 17.0) return vec2(0.0, mix(-0.2, -0.05, smoothstep(0.0, 1.0, min(1.0, tSeg / 5.0))));\n    tSeg -= 17.0;\n\n    \n    // Let's have a look...\n    return vec2(0.0, mix(-0.05, -0.35, smoothstep(0.0, 1.0, min(1.0, tSeg / 5.0))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n#ifdef USE_WEBCAM\n    if (iTime > 63.5) {\n    \tfragColor = vec4(mix(vec3(0.0), texture(iChannel0, fragCoord / iResolution.xy).rgb, min(1.0, (iTime - 63.5) * 5.0)), 1.0);\n        return;\n    }\n#endif\n\n    // Raymarch.\n    vec3 torchDir = normalize(vec3(getTorchDir(), 0.8));\n    \n    vec2 walkBump = vec2(sin(iTime * 2.5) * 0.05, pow(0.5 + 0.5 * sin(iTime * 5.0), 2.0) * 0.03);\n    walkBump *= mix(1.0, 0.0, min(1.0, max(0.0, iTime - 44.0) / 2.6));\n    \n    vec3 ro = vec3(walkBump, 0.0);\n    vec3 rd = getRayDir(ro, torchDir + vec3(0.0, 0.1, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 120.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n        if (h.x < 0.005 * d) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    vec3 col;\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(0.0, -0.75, 0.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.15, 0.2, 0.25);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float occ = calcOcc(p, n, 4.0);\n        float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 3.0);\n        float torch = calcSpotlight(p, lightPos, torchDir, 0.1, 0.02);\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.05;\n        float fog = 1.0 - exp(-d * 0.006);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Tunnel walls.\n            mat = vec3(0.05, 0.06, 0.05);\n        } else if (hit == 2) {\n            // Tunnel floor.\n            mat = vec3(0.055, 0.06, 0.06) * 0.6;\n        } else if (hit == 3) {\n            // Egg.\n            mat = mix(vec3(0.5, 0.3, 0.2), vec3(0.05, 0.06, 0.05), 0.7);\n        } else if (hit == 4) {\n            // Surprise.\n            mat = vec3(0.0);\n        }\n\n        col = (torch * sha + (backLight + spe) * occ) * lightCol;\n        col *= mat;\n        col += torch * 0.02 * lightCol;\n        col = mix(col, skyCol, fog);\n    }\n\n    // Output to screen\n    col = pow(vignette(col, fragCoord), vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23078, "src": "https://soundcloud.com/chrisjung49-1/only-war-wind-ambient", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 61, 61, 124], [126, 126, 147, 147, 533], [535, 535, 554, 554, 686], [688, 688, 727, 727, 830], [832, 832, 851, 851, 927], [929, 929, 956, 956, 988], [990, 990, 1021, 1021, 1077], [1079, 1079, 1108, 1108, 1199], [1201, 1201, 1231, 1231, 1329], [1331, 1331, 1361, 1361, 1509], [1511, 1511, 1541, 1541, 1661], [1663, 1663, 1696, 1750, 1951], [1973, 1973, 2004, 2004, 2231], [2233, 2233, 2259, 2259, 2462], [2464, 2464, 2485, 2485, 3160], [3162, 3162, 3188, 3188, 3480], [3482, 3482, 3529, 3529, 3734], [3736, 3736, 3754, 3754, 3975], [3977, 3977, 4005, 4023, 4223], [4225, 4225, 4283, 4283, 4582], [4584, 4584, 4631, 4631, 4719], [4721, 4721, 4810, 4810, 5179], [5181, 5181, 5222, 5222, 5363], [5365, 5365, 5385, 5385, 6395], [6397, 6397, 6454, 6454, 8666]], "test": "untested"}
{"id": "3lsyR4", "name": "Day 171 - Bitonic Sort", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 5, "viewed": 375, "published": 3, "date": "1591552795", "time_retrieved": "2024-07-30T21:02:16.022038", "image_code": "// Does a bitonic sort, depending on the red colour\n// Currently only works with rectangle input image\n\n// Shoutout to michael0884, great example on Bitonic Sort here - ahttps://www.shadertoy.com/view/ttVXDV\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    C = T(U);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    if(iFrame < 3){\n\t\tC = texture(iChannel1, vec2(U)/SZ);\n    \t//C = texture(iChannel1, vec2(mod(idx,256.)/256., floor(idx/256.)));\n        //C = texture(iChannel1, vec2(mod(U.x+U.y,256.)/256., floor((U.x+U.y)/256.)/256.));\n    \tC -= C * float( U.x > SZ.x);\n    } else if (mod(float(iFrame),2.)==0.) {\n        // x pass\n        \n        C = T(U);\n    \n        float coeff = pow(2., 1. + mod( floor(float(iFrame)), log2(SZ.x/2.)));\n        \n        float jmpAmt = SZ.x/coeff;\n        \n        bool jumpedOver = mod(U.x, jmpAmt) > jmpAmt/2.;\n        \n        float destination = U.x + jmpAmt *( 1. - 2. * float(jumpedOver) );\n        \n        vec4 other = T(vec2( destination , U.y));\n    \t\n        \n\t\tif ( jumpedOver ){\n        \tif (other.COMPONENT_TO_SORT < C.COMPONENT_TO_SORT)\n                C = other;\n        } else {\n        \tif (other.COMPONENT_TO_SORT > C.COMPONENT_TO_SORT)\n                C = other;\n        }\n    } else {\n    \t// y pass\n\n        C = T(U);\n\n        float coeff = pow(2., 1. + mod( floor(float(iFrame)), log2(SZ.y/2.)));\n\n        float jmpAmt = SZ.y/coeff;\n\n        bool jumpedOver = mod(U.y, jmpAmt) > jmpAmt/2.;\n\n        float destination = U.y + jmpAmt *( 1. - 2. * float(jumpedOver) );\n\n        vec4 other = T(vec2( destination , U.x));\n\n\n        if ( jumpedOver ){\n            if (other.COMPONENT_TO_SORT < C.COMPONENT_TO_SORT)\n                C = other;\n        } else {\n            if (other.COMPONENT_TO_SORT > C.COMPONENT_TO_SORT)\n                C = other;\n        }\n\n\n    }\n    \n    if(U.y>SZ.y || U.x>SZ.x )\n        discard;\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(j) texture(iChannel0, (j)/iResolution.xy)\n\n#define SZ vec2(iResolution.y)\n\n#define COMPONENT_TO_SORT g", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 250, 250, 271]], "test": "untested"}
{"id": "WtlyR4", "name": "March of the Androids 2", "author": "dr2", "description": "Updated, with a more appropriate color scheme", "tags": ["robot", "order"], "likes": 11, "viewed": 370, "published": 3, "date": "1591550116", "time_retrieved": "2024-07-30T21:02:16.821900", "image_code": "// \"March of the Androids 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar, rAngH, rAngL, rAngA, gDisp;\nint idObj;\nbool walk;\nconst float pi = 3.1415927;\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb, rDir;\n  bool rotStep;\n  rPath = 34.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 4.;\n  tWb = 2.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 1.;\n  rDir = 2. * floor (mod (t / ti[4], 2.)) - 1.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 - rDir * (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.xz -= 2.5;\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  vec2 ip;\n  float dMin, d, bf, hGap, bFac, ah;\n  int objType;\n  hGap = 2.5;\n  bf = PrBoxDf (p, vec3 (9. * hGap, 6., 9. * hGap));\n  pp = p;\n  ip = floor ((pp.xz + hGap) / (2. * hGap));\n  pp.xz = pp.xz - 2. * hGap * ip;\n  objType = (ip.x == 0. && ip.y == 4.) ? 20 : 10;\n  bFac = (objType == 20) ? 1.6 : 1.;\n  ah = rAngH * (walk ? sign (1.1 - bFac) : - step (1.1, bFac));\n  dMin = dstFar;\n  q = p;\n  d = q.y + 1.;\n  DMINQ (1);\n  q = pp;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  d = max (d, bf);\n  DMINQ (objType + 1);\n  q = pp;\n  q.y -= 0.55;\n  d = PrRoundCylDf (q.xzy, 0.9, 0.28, 0.7);\n  d = max (d, bf);\n  DMINQ (objType + 1);\n  q = pp;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (pp.x));\n  q.y -= -0.525;\n  d = PrRoundCylDf (q.xzy, 0.25, 0.15, 0.55);\n  d = max (d, bf);\n  DMINQ (objType + 1);\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  if (bFac > 1.) {\n    q.xz = Rot2D (q.xz, 2. * pi * floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 6.);\n    q.x += 0.4;\n  } else {\n    q.x = abs (q.x) - 0.4;\n  }\n  q.y -= 2.;\n  q.xy = Rot2D (q.xy, -0.2 * pi * sign (bFac - 1.1));\n  q.y -= 0.2 * (2. * bFac - 1.);\n  d = PrRoundCylDf (q.xzy, 0.06, 0.04, 0.4 * (2. * bFac - 1.));\n  d = max (d, bf);\n  DMINQ (objType + 2);\n  q = pp;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (pp.x) : 1.));\n  q.y -= -0.6;\n  d = PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6);\n  d = max (d, bf);\n  DMINQ (objType + 3);\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6 + 0.3 * (bFac - 1.), 0.7 - 0.3 * (bFac - 1.));\n  d = PrSphDf (q, 0.15 * bFac);\n  d = max (d, bf);\n  DMINQ (objType + 4);\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f, s;\n  p.z += gDisp;\n  q = p.xz + vec2 (0.5, 0.25);\n  iq = floor (q);\n  s = 0.5 + 0.5 * Noisefv2 (q * 107.);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0., 0.02, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFar;\n  return s * (1. - 0.9 * exp (-2. * f * f) * (1. - q.x * q.y));\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn, float dHit)\n{\n  vec3 col;\n  int idObjP;\n  idObjP = idObj;\n  if (idObjP == 1) {\n    col = mix (vec3 (0.2, 0.3, 0.2), vec3 (0.3, 0.3, 0.35),\n       (0.5 + 0.5 * ChqPat (qHit / 5., dHit)));\n  } else if (idObjP > 20) {\n    idObjP -= 20;\n    if (idObjP == 1 || idObjP == 2 || idObjP == 3) col = vec3 (1., 0.7, 0.1);\n    else if (idObjP == 4) col = vec3 (0.3, 1., 0.1);\n  } else if (idObjP > 10) {\n    idObjP -= 10;\n    if (idObjP == 1) col = vec3 (0.05);\n    else if (idObjP == 2) col = (qHit.y > 0.) ? vec3 (1.) : vec3 (0.05);\n    else if (idObjP == 3) col = (qHit.y < 0.) ? vec3 (1.) : vec3 (0.05);\n    else if (idObjP == 4) col = vec3 (1., 0.1, 0.1);\n  }\n  return col * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n     0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    col = vec3 (0.1) + 0.2 * pow (1. - max (rd.y, 0.), 8.);\n    col = mix (col, vec3 (1.), clamp (0.1 + 1.5 * Fbm2 (0.05 * (ro.xz +\n       rd.xz * (50. - ro.y) / rd.y)) * rd.y, 0., 1.));\n  } else {\n    col = mix (vec3 (0.6, 0.5, 0.3), 0.9 * (vec3 (0.1) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  col *= vec3 (1., 0.7, 0.7);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, c;\n  float dstHit, tCyc, refl, spd;\n  spd = 0.7;\n  tCyc = mod (spd * tCur, 7.);\n  if (tCyc < 4.) {\n    walk = true;\n    tCyc = mod (tCyc, 1.);\n    gDisp = mod (spd * tCur, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = 0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    tCyc = mod (tCyc, 1.);\n    gDisp = 0.;\n    rAngH = 0.4 * sin (2. * pi * tCyc);\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    col = ObjCol (rd, vn, dstHit);\n    if (idObj != 1) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refl = 0.2 + 0.3 * pow (1. - dot (vn, rd), 4.);\n      dstHit = ObjRay (ro, rd);\n      if (dstHit < dstFar) {\n        ro += rd * dstHit;\n        c = ObjCol (rd, ObjNf (ro), dstHit);\n      } else {\n        c = BgCol (ro, rd);\n      }\n      col = mix (col, c, refl);\n    }\n    col *= ObjSShadow (ro, sunDir);\n  } else {\n    col = BgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, vd, u;\n  vec2 canvas, uv;\n  float f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  ro = TrackPath (tCur);\n  vd = normalize (vec3 (0., 2., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 2.2));\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 2., 1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float s, hz;\n  s = length (p.xy) - r;\n  hz = abs (p.z) - h;\n  return min (min (max (s + rt, hz), max (s, hz + rt)), length (vec2 (s, hz) + rt) - rt);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlyR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[519, 519, 545, 545, 1347], [1349, 1349, 1371, 1371, 3057], [3059, 3059, 3092, 3092, 3268], [3270, 3270, 3291, 3291, 3539], [3541, 3541, 3576, 3576, 3903], [3905, 3905, 3949, 3949, 4712], [4714, 4714, 4751, 4751, 4972], [4974, 4974, 5005, 5005, 5399], [5401, 5401, 5436, 5436, 6522], [6524, 6524, 6580, 6580, 7149], [7151, 7151, 7181, 7181, 7294], [7296, 7296, 7328, 7328, 7428], [7430, 7430, 7463, 7463, 7490], [7492, 7492, 7549, 7549, 7703], [7737, 7737, 7761, 7761, 7873], [7875, 7875, 7900, 7900, 8086], [8088, 8088, 8109, 8109, 8264]], "test": "untested"}
{"id": "tlfyzN", "name": "Hover Glow", "author": "Paltoquet", "description": "first attempt for a mouse hover effect on card", "tags": ["mouse", "light", "glow", "card", "hover"], "likes": 3, "viewed": 406, "published": 3, "date": "1591545248", "time_retrieved": "2024-07-30T21:02:17.620764", "image_code": "\n// Author:\n// Title:\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.142\n#define ANIMATION_DURATION 120.0\n#define ANIMATION_SPEED 2.000\n#define BLUR_RADIUS 12\n\nfloat random (float theta) {\n    float period = 230.000;\n    return fract(sin(dot(theta, period * period))* 2.856);\n}\n\nfloat getCurrentTime() {\n    float coef = mod(iTime * ANIMATION_SPEED, ANIMATION_DURATION);\n    coef = coef / ANIMATION_DURATION;\n    coef = max(0.0, coef);\n    return coef;\n}\n\nfloat getAngle(vec2 pos) {\n    float coef = getCurrentTime();\n    float theta = atan(pos.y, pos.x);\n    theta = theta + coef * 2.0 * PI;\n    return theta;\n}\n\nfloat period(float theta, float nbCroissant) {\n    float period = 2.0 * PI;\n\tperiod = period * nbCroissant;\n    return sin(theta * period);\n}\n\nfloat square(vec2 position, vec2 dim) {\n    if(abs(position.x) < dim.x && abs(position.y) < dim.y) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat rect(vec2 p, vec2 size) {  \n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec2 position, vec2 center, float radius) {\n    float dist = length(position - center);\n    if(length(position - center) <= radius) {\n        return dist;\n    } \n    return 0.0;\n}\n\nfloat circle(vec2 position, float radius, float width){\n    float dist = abs(length(position) - radius);\n    if(dist < width) {\n        return width;\n    }\n    return 0.0;\n}\n\nfloat easingIn(float val) {\n    return pow(val, 3.0);\n}\n\nfloat easingOut(float val) {\n    return 1.0 - pow(1.0 - val, 5.0);\n}\n\nfloat generateSphere(vec2 position, float theta, float time) {\n    vec2 centers[8];\n    float radius[8];\n    centers[6] = vec2(0.150,-0.730);\n    centers[1] = vec2(0.320,0.630);\n    centers[2] = vec2(-0.660,0.440);\n    centers[3] = vec2(-0.590,-0.450);\n\tcenters[4] = vec2(-0.630,-0.430);    \n\tcenters[5] = vec2(-0.740,0.260);   \n    centers[6] = vec2(0.150,-0.730);\n    centers[7] = vec2(0.590,0.050);\n    \n    radius[0] = 0.028;\n    radius[1] = 0.037;\n    radius[2] = 0.049;\n\tradius[3] = 0.032;\n    radius[4] = 0.024;\n    radius[5] = 0.042;\n    radius[6] = 0.062;\n    radius[7] = 0.080;\n    \n    float result = 0.0;\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    float a = time * 2.0 * PI;\n    float s = sin(a);\n\tfloat c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    \n    time = 1.0;\n    for(int i = 0; i < 8; i++){\n        vec2 center = centers[i];\n        center = m * center;\n        float radius = radius[i];\n        //center = mix(vec2(0), center, time);\n        //radius = mix(0.001, radius, time);\n        result = max(result, sphere(position, center, radius));\n    }\n    return result;\n}\n\nfloat generateCroissant(vec2 position, float nbCroissant, float theta, float time) {\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n\n    float currentCroissant = floor(current * nbCroissant);\n    float amplitude = random(currentCroissant) * 0.9;\n    \n    float range = period(current, nbCroissant);\n    float dist = length(position);\n    range = range * amplitude;\n    dist = dist < range ? range : 0.0;\n    return dist;\n} \n\nvec4 getColor(vec2 pos, float theta, float time){\n    float nbCroissant = 140.0;\n    //nbCroissant = mix(0.0, 200.0, currentTime);\n    \n    //float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    vec4 firstRedColor = vec4(0.995,0.454,0.192,1.000);\n    vec4 firstYellowColor = vec4(0.179,0.179,0.995,1.000);\n    vec4 firstColor = mix(firstYellowColor, firstRedColor, easingIn(1.0 - abs((current - 0.5)) * 1.0));\n    vec4 secondColor = vec4(0.995,0.924,0.362,1.000);\n    vec4 backGroundColor = vec4(0.001,0.000,0.005,1.000);\n    \n    float circleRadius = mix(0.0, 0.065, time);\n    float circleWidth = mix(0.01, 0.065, time);\n    \n    float dist = generateCroissant(pos, nbCroissant, theta, time);\n    dist = max(dist, generateCroissant(pos, nbCroissant / 5.0, theta, time)); // play with thoose\n    dist = max(dist, generateCroissant(pos, nbCroissant * 1.8, theta, time)); // play with thoose\n    dist = max(dist, generateSphere(pos, theta, time));\n    //dist = max(dist, easingIn(circle(pos, circleRadius, circleWidth)));\n    vec4 color = dist != 0.0 ? mix(firstColor, secondColor, easingIn(dist)) : backGroundColor;\n    \n    float width = 0.428;\n    float glowRadius = 0.240;\n    float rectBorder = max(rect(pos, vec2(width)), 0.0);\n    if(rectBorder >= 0.0 && rectBorder < glowRadius) {\n        float range = 1.0 - glowRadius;\n        float easing = 1.0 - rectBorder;\n        float coef = 1.0 / glowRadius;\n        rectBorder = (easing - range) * coef;\n        color = mix(color, secondColor, easingIn(rectBorder));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.xy;\n    st = st * vec2(2.0) - vec2(1.0);\n    vec2 pixelOffset = vec2(1.0) / iResolution.xy;\n\tint blurRadius = 5;\n    \n    float time = getCurrentTime();\n    vec4 color = getColor(st, getAngle(st), time);//;vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for(int i = -1 * BLUR_RADIUS; i < BLUR_RADIUS; i++) {\n        for(int j = -1 * BLUR_RADIUS; j < BLUR_RADIUS; j++) {\n            vec2 offset = vec2(i, j) * pixelOffset;\n            vec2 pos = st + offset;\n            float angle = getAngle(pos);\n            color += getColor(st + offset, angle, time);\n        }\n    }\n    \n    color = color / vec4(BLUR_RADIUS * BLUR_RADIUS);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 273, 273, 362], [364, 364, 388, 388, 539], [541, 541, 567, 567, 697], [699, 699, 745, 745, 840], [842, 842, 881, 881, 987], [989, 989, 1020, 1020, 1105], [1107, 1107, 1163, 1163, 1299], [1301, 1301, 1356, 1356, 1474], [1476, 1476, 1503, 1503, 1531], [1533, 1533, 1561, 1561, 1601], [1603, 1603, 1665, 1665, 2856], [2858, 2858, 2942, 2942, 3428], [3431, 3431, 3480, 3480, 5158], [5160, 5160, 5215, 5215, 5893]], "test": "untested"}
{"id": "WtsyRH", "name": "Storage Room", "author": "blackle", "description": "1995 byte graphics entry for nova", "tags": ["reflect"], "likes": 4, "viewed": 404, "published": 3, "date": "1591543611", "time_retrieved": "2024-07-30T21:02:18.448551", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = sqrt(fragColor/fragColor.w);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float box(vec3 p, vec3 d) {\n\tvec3 q = abs(p)-d;\n\treturn length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat tex(vec3 p) {\n\t//marbly texture, also used for RNG\n\treturn sin(dot(sin(p*32.),vec3(2,3,1)))*cos(dot(cos(p*43.),vec3(3,1,2)))\n\t\t+sin(dot(sin(p*52.),vec3(2,3,1)))*cos(dot(cos(p*73.),vec3(3,1,2)));\n}\n\nfloat ref;\nfloat scene(vec3 p) {\n\tfloat tx = tex(p*100.)/5000.*(exp(tex(p)+tex(p*2.)+tex(p/5.))*.3+.6); //add very tiny bumps to the SDF itself, which will cause glossy reflections!\n\tfloat bx = -box(p, vec3(7.9));\n\tp = asin(sin(p));\n\tfloat sbx = box(p,vec3(.7,.6,.6))-.02;\n\tref = sbx>bx?sin(length(p)*20.):1.;\n\treturn min(bx, sbx)+tx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (texelFetch(iChannel2, ivec2(32,1), 0).x > 0.) fragColor = vec4(0);\n\tfor (int j = iFrame; j < iFrame+1; j++) {\n\t\tvec2 uv = (gl_FragCoord.xy-iResolution.xy*vec2(.52,.46))/(iResolution.y*.92);\n        uv += vec2(tex(vec3(j+1)),tex(vec3(j)))/2./iResolution.y;\n\n\t\tvec3 cam = normalize(vec3(.5-dot(uv,uv)*.6,uv)) + vec3(0,tex(vec3(j)),tex(vec3(j+1)))*.01;\n\t\tvec3 p = vec3(-6.5,2,-5.2) - vec3(0,tex(vec3(j)),tex(vec3(j+1)))*.03;\n\t\tfloat atten = 1.;\n\t\tfloat dist;\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tdist = scene(p);\n\t\t\tif (dist*dist<1e-6 && ref > -0.5) { //reflect within the raymarching loop!\n\t\t\t\tmat3 k = mat3(p,p,p)-mat3(0.01);\n\t\t\t\tvec3 n = normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n\t\t\t\tatten *= 1.-abs(dot(cam,n))*.98;\n\t\t\t\tcam = reflect(cam, n);\n\t\t\t\tdist = 0.1;\n\t\t\t}\n\t\t\tp += cam*dist;\n\t\t}\n\t\tfragColor += vec4(dist*dist<1e-6?(sin(vec3(0,5,4)-p*.2)*.2+1.2)*atten:vec3(0.01), 1);\n\t}\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsyRH.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 251, 251, 358]], "test": "untested"}
{"id": "wtXyz4", "name": "earthbound bg 4", "author": "thefox231", "description": "these are too fun to make. help me", "tags": ["2d", "abstract", "snes", "earthbound"], "likes": 7, "viewed": 959, "published": 3, "date": "1591534762", "time_retrieved": "2024-07-30T21:02:19.237441", "image_code": "const vec3 mainColor = vec3(.8, .1, .2);\n\nfloat spiral(vec2 m, float t) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(50.*(sqrt(r)-0.02*a-.3*t));\n\treturn clamp(v,0.,1.);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // fix aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    uv.x -= (aspectRatio - 1.) * .5;\n     \n    // pixelate\n    float pxAmt = 90.;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // interlacing .\n    if (mod(fragCoord.y, 2.) < 1.) {\n        uv += .4 + sin(iTime * .5 + uv.y * 5.) * (.3 + sin(iTime) * .1);\n    } else {\n        uv -= .4 + sin(iTime * .5 + uv.y * 5. + .5) * (.3 + sin(iTime) * .1);\n    }\n    \n    // spiralllllllllllllll\n    vec3 color = mainColor * spiral(uv - .5, iTime * .2 + sin(uv.y * 7.) * .2);\n        \n    // color shortening\n    // gives it a kind of like snes-like palette\n    float shortAmt = 4.0;\n    color = ceil(color * shortAmt) / shortAmt;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 73, 73, 192], [194, 194, 249, 249, 1106]], "test": "untested"}
{"id": "tlXcR4", "name": "Circle parallax", "author": "Oggbog", "description": "Simple circle parallax scroller", "tags": ["parallax"], "likes": 4, "viewed": 414, "published": 3, "date": "1591533622", "time_retrieved": "2024-07-30T21:02:20.230785", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 luv;\n    vec3 col;\n    float p;\n    fragColor = vec4(0.6,0.8,0.9,1.0);\n    \n    for(float l = 10.0; l > 0.0; l -= 1.0){\n \n    \t\n        \n\t\tluv = vec2(fract( (l*uv.x+ iTime) *2.), l*uv.y);\n        \n        p = luv.y > l - 2.06\n            ? smoothstep(.57,.55, distance(luv, vec2(.5,l-2.06)))\n            : 1.;\n\n       \n        \n        if (p>0.0){\n            col = p*vec3(0.0,1.0-l/10.0,0.1);\n            fragColor = vec4(col,1.0);\n        }\n\n    \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 623]], "test": "untested"}
{"id": "wtXcR4", "name": "earthbound bg 3", "author": "thefox231", "description": "fourth attempt, this one looks the neatest imo\nlooks a lot like a plasma. i like it", "tags": ["2d", "abstract", "snes", "earthbound"], "likes": 5, "viewed": 1011, "published": 3, "date": "1591533408", "time_retrieved": "2024-07-30T21:02:21.017682", "image_code": "const float thickness = .1;\nconst vec3 mainColor = vec3(.1, .3, .3);\n\nbool equals(float a, float b) {\n    return mod(abs(a - b), 0.2) < thickness;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(.0);\n    \n    // fix aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    uv.x -= (aspectRatio - 1.) * .5;\n    \n    // pixelate\n    float pxAmt = 90.;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // repixelate\n    pxAmt = 90.;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // interlacing .\n    if (mod(fragCoord.y, 2.) < 1.) {\n        uv += .4 + sin(iTime * .5 + uv.y * 15.) * 0.1;\n    } else {\n        uv -= .4 + cos(iTime * .5 + uv.y * 15. + .5) * 0.1;\n    }\n    \n    // weird plasma circles thing......\n    vec2 circlePosition = vec2(.5, .5);\n    float circleDistance = 1.0 - length(circlePosition - uv);\n    \n    vec3 circleColor = mainColor * .8 + sin(iTime + uv.x * 6. + uv.y * 9. + sin(uv.x * 8.) + cos(iTime)) * .15;\n    \n    if (equals(circleDistance, iTime * .1 + sin(uv.y * 3.) * (.6 + sin(iTime * .3) * .4))) {\n    \tcolor += circleColor;\n    } else {\n        float avg = (circleColor.r + circleColor.g + circleColor.b) / 3.;\n        color += vec3(avg) * .4 * circleDistance;\n    }\n    \n    // color shortening\n    // gives it a kind of like snes-like palette\n    float shortAmt = 8.0;\n    color = ceil(color * shortAmt) / shortAmt;\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 101, 101, 148], [150, 150, 205, 205, 1592]], "test": "untested"}
{"id": "3lXczN", "name": "uv discontinuity fix", "author": "teadrinker", "description": "Method of fixing uv discontinuities by generating additional uvs that shifts the discontinuity to another place, and then chose the smallest gradient.\n\nEdit: trying to get the correct gradient seem overkill, simply warping with abs(uv - 0.5) work fine...", "tags": ["gradient", "discontinuity", "texturegrad", "seam", "discontinuities", "textureseam"], "likes": 2, "viewed": 586, "published": 3, "date": "1591529280", "time_retrieved": "2024-07-30T21:02:21.754711", "image_code": "\n\nvoid fix_uv_discontinuities(vec2 uv_alternative, inout vec2 dx, inout vec2 dy) {\n            \n\tvec2 dx2 = dFdx(uv_alternative);\n\tvec2 dy2 = dFdy(uv_alternative);\n\tif(dot(dx,dx)+dot(dy,dy) > dot(dx2,dx2)+dot(dy2,dy2)) {\n\t\tdx = dx2;\n\t\tdy = dy2;\n\t}\n\n}  \n\n\nvec2 warpUV(vec2 uv) {\n    float a =  iTime * 0.03;\n    uv *= mat2x2(cos(a),sin(a),-sin(a),cos(a));\n    uv = uv*(6. + 150.*pow(iMouse.x/iResolution.x,5.)) + iTime * 0.03;\n    uv = fract(uv); \n    return uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/max(iResolution.x,iResolution.y);\n\n\tuv = warpUV(uv);\n\tvec2 uv_alternative  = fract(uv+0.25);\n\tvec2 uv_alternative2 = fract(uv+0.5);\n\n    bool useFastHack = iMouse.z > 0.5;\n\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    if(fragCoord.x > iResolution.x * 0.5) {\n        if(!useFastHack) {\n    \t\tfix_uv_discontinuities(uv_alternative, dx, dy);\n    \t\tfix_uv_discontinuities(uv_alternative2, dx, dy);\n        } else {\n        \tvec2 uv2 = abs(uv - 0.5);\n        \tdx = dFdx(uv2);\n    \t\tdy = dFdy(uv2);\n        }\n\n    }\n    \n    if(fragCoord.y > iResolution.y * 0.5)\n        fragColor = textureGrad(iChannel0, uv, dx, dy);\n\telse\n    \tfragColor = 10.* vec4(length(dx),length(dy),length(dx), 1.);\n}\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 82, 82, 250], [255, 255, 277, 277, 463], [466, 466, 523, 523, 1242]], "test": "untested"}
{"id": "3tXcR4", "name": "Cornell_box_test", "author": "chen1180", "description": "https://raytracing.github.io/books/RayTracingTheNextWeek.html", "tags": ["raytracing", "cornellbox"], "likes": 3, "viewed": 290, "published": 3, "date": "1591520364", "time_retrieved": "2024-07-30T21:02:23.066205", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    vec4 col=texture(iChannel0,uv);\n    col/=float(iFrame);\n    // Output to screen\n    fragColor =pow(col,vec4(1.0/2.2));\n    \n   \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\nfloat g_seed = 0.0;\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray trace helper functions\n//\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}", "buffer_a_code": "#define Samples 1\n#define MaxDepth 10\n#define T_MIN 1e-3\n#define T_MAX 1000.0\n#define CornellBoxSize 2.0\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELETRIC 2\n#define EMISSIVE 3\nstruct Material{\n\tint matType;\n    vec3 albedo;\n    float ior;\n};\nstruct Sphere{\n\tvec3 center;\n    float radius;\n    Material material;\n};\n struct Plane{\n\tvec3 p;\n    vec3 normal;\n    Material material;\n};\nstruct Rectangle{\n\tPlane plane;\n    float size;\n};\nSphere sceneList[] =Sphere[](Sphere(vec3(1.0,-1.5,-1.0),0.5,Material(METAL,vec3(0.8,0.8,0.8),0.0)),\n    Sphere(vec3(-0.0,-1.5,-0.5),0.5,Material(DIELETRIC,vec3(0.8,0.8,0.8),1.3)),\n    Sphere(vec3(-0.5,-1.5,-1.5),0.5,Material(LAMBERTIAN,vec3(0.1,1.0,0.1),0.0)));\n\nRectangle planeList[]=Rectangle[](\n    //Left wall\n    Rectangle(Plane(vec3(-CornellBoxSize,0.0,0.0),vec3(1.0,0.0,0.0),Material(LAMBERTIAN,vec3(0.1,1.0,0.1),0.0)),CornellBoxSize),\n    //Right wall\n     Rectangle(Plane(vec3(CornellBoxSize,0.0,0.0),vec3(1.0,0.0,0.0),Material(LAMBERTIAN,vec3(1.0,0.1,0.1),0.0)),CornellBoxSize),\n    //back\n     Rectangle(Plane(vec3(0.0,0.0,-CornellBoxSize),vec3(0.0,0.0,1.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0)),CornellBoxSize),\n    //floor\n     Rectangle(Plane(vec3(0.0,-CornellBoxSize,0.0),vec3(0.0,1.0,0.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0)),CornellBoxSize),\n    //ceiling\n     Rectangle(Plane(vec3(0.0,CornellBoxSize,0.0),vec3(0.0,1.0,0.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0)),CornellBoxSize)\n);\n\nRectangle lightList[]=Rectangle[](\nRectangle(Plane(vec3(0.0,2.0,0.0),vec3(0.0,1.0,0.0),Material(EMISSIVE,vec3(1.0,1.0,1.0),0.0)),1.0)\n);\nstruct HitRecord{\n    bool isHit;\n    vec3 p;\n    vec3 normal;\n    Material material;\n    \n};\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n    };\n//Primitive:Sphere\nfloat intersectSphere(Ray r,Sphere s){\n    vec3 oc=r.origin-s.center;\n    vec3 t=r.direction;\n\tfloat a=dot(t,t);\n    float b=2.0*dot(t,oc);\n    float c=dot(oc,oc)-s.radius*s.radius;\n    float discriminant=b*b-4.0*a*c;\n    if (discriminant<=0.0)\n        return -1.0;\n    else\n    {\n    \tfloat x1=(-b-sqrt(discriminant))/(2.0*a);\n        if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n        x1=(-b+sqrt(discriminant))/(2.0*a);\n         if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n    }\n}\nvec3 getSphereNormal(vec3 hitPoint,Sphere s){\n\treturn normalize(hitPoint-s.center);\n}\n//Primitive:Plane\nfloat intersectPlane(Ray r,Plane s){\n\tvec3 op=s.p-r.origin;\n    float d=dot(op,s.normal)/dot(r.direction,s.normal);\n    return d;\n\n}\nvec3 getPlaneNormal(vec3 hitPoint,Plane p){\n\treturn normalize(hitPoint+p.normal);\n}\n//Primitive:Rectangle\nfloat intersectRectangle(Ray r, Rectangle rec){\n    float d=intersectPlane(r,rec.plane);\n    vec3 hitPoint=r.origin+d*r.direction;\n    float size=rec.size;\n    //XZ_PLANE\n    if (rec.plane.normal==vec3(0.0,1.0,0.0)){\n    \tvec3 tmin=rec.plane.p-vec3(size,0.0,size);\n        vec3 tmax=rec.plane.p+vec3(size,0.0,size);\n        if (hitPoint.x>tmin.x&&hitPoint.x<tmax.x)\n            if (hitPoint.z>tmin.z&&hitPoint.z<tmax.z)\n                return d;\n     //YZ_PLANE\n    }else if (rec.plane.normal==vec3(1.0,0.0,0.0)){\n    \tvec3 tmin=rec.plane.p-vec3(0.0,size,size);\n        vec3 tmax=rec.plane.p+vec3(0.0,size,size);\n        if (hitPoint.y>tmin.y&&hitPoint.y<tmax.y)\n            if (hitPoint.z>tmin.z&&hitPoint.z<tmax.z)\n                return d;\n    }//XY_PLANE\n    else if (rec.plane.normal==vec3(0.0,0.0,1.0)){\n    \tvec3 tmin=rec.plane.p-vec3(size,size,0.0);\n        vec3 tmax=rec.plane.p+vec3(size,size,0.0);\n        if (hitPoint.x>tmin.x&&hitPoint.x<tmax.x)\n            if (hitPoint.y>tmin.y&&hitPoint.y<tmax.y)\n                return d;\n    }\n    \n    return -1.0;\n    \n}\nvec3 getRectangleNormal(Ray r,Rectangle rec){\n    vec3 normal=normalize(rec.plane.normal);\n    if (dot(r.direction,rec.plane.normal)>T_MIN)\n    {\n    \treturn  -normal;\n    }else\n\t\treturn normal;\n}\n\nvec3 skyColor(float t){\n    return (1.0-t)*vec3(1.0)+t*vec3(0.2,0.5,0.7);\n\t\n}\n\nvec3 checkerTexture(vec2 uv, vec3 dir){\n\tfloat sines=sin(dir.x*10.0)*sin(dir.y*10.0)*sin(dir.z*10.0);\n    if (sines>0.0)\n        return vec3(1.0);\n    else\n        return vec3(0.0);\n}\n\nHitRecord intersectScene(Ray r){\n    float tMax=T_MAX;\n    float tMin=T_MIN;\n    HitRecord hit_record;\n    hit_record.isHit=false;\n    //interseciton of the spheres \n    for (int i=0;i<sceneList.length();i++)\n    {\n    \tfloat ts=intersectSphere(r, sceneList[i]);\n   \t\t if (ts>tMin && ts<tMax){\n            tMax=ts;\n             hit_record.p=r.origin+r.direction*ts;\n            hit_record.normal=getSphereNormal(hit_record.p,sceneList[i]);\n             hit_record.material=sceneList[i].material;\n             hit_record.isHit=true;\n         }\n        \n    }\n    //intersection of the Light emitter\n    for (int i=0;i<lightList.length();i++)\n    {\n    \t float tp=intersectRectangle(r,lightList[i]);\n   \t\t if (tp>tMin && tp<tMax){\n            tMax=tp;\n             hit_record.p=r.origin+r.direction*tp;\n            hit_record.normal=getPlaneNormal(hit_record.p,lightList[i].plane);\n             hit_record.material=lightList[i].plane.material;\n             hit_record.isHit=true;\n         }\n        \n    }\n   \n    //intersection of the cornell box\n    for (int i=0;i<planeList.length();i++)\n    {\n    \t float tp=intersectRectangle(r,planeList[i]);\n   \t\t if (tp>tMin && tp<tMax){\n            tMax=tp;\n             hit_record.p=r.origin+r.direction*tp;\n            hit_record.normal=getRectangleNormal(r,planeList[i]);\n             hit_record.material=planeList[i].plane.material;\n             hit_record.isHit=true;\n         }\n        \n    }\n     \n    return hit_record;\n\n}\nfloat schlick(float cos_theta, float n2)\n{\n    const float n1 = 1.0f;  // refraction index for air\n\n    float r0s = (n1 - n2) / (n1 + n2);\n    float r0 = r0s * r0s;\n\n    return r0 + (1.0f - r0) * pow((1.0f - cos_theta), 5.0f);\n}\nbool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n\n    float dt = dot(uv, n);\n\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n\n    if (discriminant > 0.0f)\n    {\n        refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n\n        return true;\n    }\n    else\n        return false;\n}\nbool material_bsdf(HitRecord hit_record,Ray inRay, out Ray outRay,out vec3 attenuation){\n    vec3 col=vec3(0.0);\n    //lambertian\n    if(hit_record.material.matType==LAMBERTIAN){\n        vec3 ray_origin=hit_record.p;\n        vec3 ray_dir=random_cos_weighted_hemisphere_direction(hit_record.normal,g_seed);\n        outRay=Ray(ray_origin,ray_dir);\n        attenuation=hit_record.material.albedo;\n        return true;\n    }else if(hit_record.material.matType==METAL){\n     //metal\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        outRay=Ray(hit_record.p,reflected);\n        attenuation=hit_record.material.albedo;\n         return true;\n    }else if(hit_record.material.matType==DIELETRIC){\n     //dieletric\n        vec3 outward_normal,refracted;\n        float ni_over_nt,cosine,reflect_prob;\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        if (dot(inRay.direction,hit_record.normal)>0.0){\n        \toutward_normal=-hit_record.normal;\n            ni_over_nt=hit_record.material.ior;\n            cosine=dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n            cosine=sqrt(1.0-ni_over_nt*ni_over_nt*(1.0-cosine*cosine));\n            \n        }else{\n            outward_normal=hit_record.normal;\n        \tni_over_nt = 1.0f / hit_record.material.ior;\n            cosine=-dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n        }\n        if (refractVec(inRay.direction, outward_normal, ni_over_nt, refracted))\n            reflect_prob = schlick(cosine, hit_record.material.ior);\n        else\n            reflect_prob = 1.0f;\n  \n        if (hash1(g_seed)<reflect_prob)\n        {\n        \toutRay=Ray(hit_record.p,reflected);\n\n        } \t\n        else\n        {\n\n            outRay=Ray(hit_record.p,refracted);\n        }\n        attenuation=hit_record.material.albedo;\n        return true;\n\n        \n    }\n    return false;\n\n}\n\nvec3 radiance(Ray r,vec2 uv,Rectangle rec){\n  \tvec3 col=vec3(1.0);\n    HitRecord hit_record;\n    for(int bounce=0;bounce<MaxDepth;bounce++)\n    {\n        hit_record=intersectScene(r);\n        vec3 emitter=rec.plane.material.albedo;\n        if (hit_record.isHit)\n        {\n\t\t\t\n            Ray outRay;\n            vec3 color;\n\n            bool scattered=material_bsdf(hit_record,r,outRay,color);\n            r.origin=outRay.origin;\n            r.direction=outRay.direction;\n            if (scattered)\n            {\n                col*=color;\n            }\n            \n            else\n            {\n            \tcol*=emitter;\n                break;\n            }\n               \n  \n        }else\n        {\n            col*=vec3(0.0);\n        \tbreak;\n        }\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    g_seed = float(base_hash(floatBitsToUint(fragCoord.xy)))/float(0xffffffffU)+iTime;\n    //camera ray calculation\n    vec3 cameraPos=vec3(0.0,0.0,3.5);\n    vec3 cameraLookAt=vec3(0.0,0.0,-1.0);\n    float zNear=1.0,zFar=1000.0;\n    float fov=60.0;\n    float height=zNear*tan(radians(fov/2.0));\n    float ratio=iResolution.x/iResolution.y;\n    float viewport_height=2.0*height;\n    float viewport_width=viewport_height*ratio;\n\n    vec3 t=normalize(cameraLookAt-cameraPos);\n    vec3 up=vec3(0.0,1.0,0.0);\n    vec3 h=normalize(cross(t,up));\n    vec3 v=normalize(cross(h,t));\n    vec3 horizontal=viewport_width*h;\n    vec3 vertical=viewport_height*v;\n\n    vec3 leftBotCorner=cameraPos+t-horizontal*0.5-vertical*0.5;\n    vec3 rayDir=leftBotCorner+uv.x*horizontal+uv.y*vertical-cameraPos;\n    Ray r=Ray(cameraPos,rayDir);\n \n     vec3 col=vec3(0.0);\n     float x=(fragCoord.x+ hash1(g_seed))/iResolution.x;\n     float y=(fragCoord.y+ hash1(g_seed))/iResolution.y;\n     for(int n=0;n<lightList.length();n++)\n         col+=radiance(r,vec2(x,y),lightList[n]);\n    // Output to screen\n    fragColor = vec4(col,1.0)+texture(iChannel0,uv);\n       \t\n    \n   \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    fragColor =texture(iChannel0,uv);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 283]], "test": "untested"}
{"id": "WlXcRN", "name": "Sky dome with twin suns", "author": "mrange", "description": "Through lots of trial and error I created a skydome for another shader.\nI ended up reasonably satisified with the skydome and extracted it in it's ownshader to simplify if someone like to use it or build upon it.\n\n", "tags": ["skydome"], "likes": 12, "viewed": 550, "published": 3, "date": "1591517229", "time_retrieved": "2024-07-30T21:02:23.913938", "image_code": "////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n// License CC0: Sky dome with twin suns, a gas giant and a rocket launch\n//  Through lots of trial and error I created a skydome for another shader.\n//  I ended up reasonably satisified with the skydome and extracted it in it's own\n//  shader to simplify if someone like to use it or build upon it.\n//  Note: There's a distant rocket launch after about 10 sec\n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = vec3(0.0);\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.6,0.4);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.7);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  ringColor     = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\n\n// From: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 plane) {\n  return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2(-b-h, -b+h);\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 rocketDirection() {\n  return normalize(vec3(0.0, -0.2+mod(iTime, 90.0)*0.0125, 1.0));\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, skyCol2, smoothstep(0.0 , 1.0, 5.0*angle)), skyCol3, smoothstep(0.0, 1.0, -5.0*angle));\n  \n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dustCol = pow(sunCol2*ringColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n  \n  float dustTransparency = smoothstep(-0.075, 0.0, rd.y);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*vec3(0.9, 0.8, 0.7), 0.3*vec3(0.9, 0.8, 0.7), pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 rocketDir = rocketDirection();\n  float rocketDot = max(dot(rd, rocketDir), 0.0);\n  float rocketDot2 = max(dot(normalize(rd.xz), normalize(rocketDir.xz)), 0.0);\n  vec3 rocketCol = vec3(0.25)*(3.0*smoothstep(-1.0, 1.0, psin(iTime*15.0*TAU))*pow(rocketDot, 70000.0) + smoothstep(-0.25, 0.0, rd.y - rocketDir.y)*step(rd.y, rocketDir.y)*pow(rocketDot2, 1000000.0))*dustTransparency*(1.0 - smoothstep(0.5, 0.6, rd.y));\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  vec3 ringsSurface = ro + pi*rd;\n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*dustTransparency*borderTransparency + ringsCol*(1.0 - borderTransparency);\n  final += skyCol + sunCol + smallSunCol + dustCol + rocketCol;\n\n  return final;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 ro  = vec3(0.0, 0.0, -2.0);\n  vec3 la  = vec3(0.0, 0.4, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = skyColor(ro, rd);\n\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXcRN.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1182, 1236, 1282, 1282, 1341], [1343, 1343, 1390, 1390, 1632], [1634, 1634, 1655, 1655, 1701], [1703, 1703, 1729, 1729, 1775], [1777, 1777, 1801, 1801, 1869], [1871, 1871, 1892, 1892, 1921], [1923, 1923, 1956, 1956, 4600], [4602, 4602, 4654, 4654, 5068]], "test": "untested"}
{"id": "WlXyRN", "name": "hollow cube 3", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "short"], "likes": 12, "viewed": 306, "published": 3, "date": "1591512213", "time_retrieved": "2024-07-30T21:02:24.731751", "image_code": "// variant of https://shadertoy.com/view/WtXyRN\n\n#define B(a) max(a.x,max(a.y,a.z))                // box\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,c=t,m=1e9;\n    mat2  R = mat2( cos(.3*T +vec4(0,33,11,0)) ); // rotation\n    vec3  q = iResolution, a,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.zxy,\n        q.xy *= R,\n        a = abs(q), t = abs(B(a)-6.)-.2,          // hollow cube\n        t = max(t,  -(min(a.x,min(a.y,a.z))-3.) ),// carve\n        t = min(t, c = length(q) - 5.),           // central sphere\n        m = min(m,c),                             // closed distance to sphere\n        p += .7*t*D;                              // step forward = dist to obj\n    c==t ? O *= vec4(.5,0,0,1)                    // color inner sphere\n         : O += (.5+.5*sin(T))* exp(-.2*m)*vec4(.5,0,0,1); // glow\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 1010]], "test": "untested"}
{"id": "WtXyRN", "name": "hollow cube 2", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "short"], "likes": 8, "viewed": 294, "published": 3, "date": "1591511441", "time_retrieved": "2024-07-30T21:02:25.546572", "image_code": "#define B(a) max(a.x,max(a.y,a.z))               // box\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,c=0.;\n    mat2  R = mat2( cos(.3*T +vec4(0,33,11,0)) );// rotation\n    vec3  q = iResolution, a,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),       // ray direction\n          p = 30./q;                             // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.zxy,\n        q.xy *= R,\n        a = abs(q), t = abs(B(a)-6.)-.5,         // hollow cube\n        a.z = ( mod(q.z-1.5,3.)-1. )*6.,         // windows: repeat + sym\n        a = abs(a-vec3(4,4,0)),\n        t = max(t,  -(B(a)-3.) ),                // carve windows\n      //q.xy *= R,\n        a = abs(q), t = min(t, c=B(a)-3.),       // add inner cube\n        p += .7*t*D;                             // step forward = dist to obj\n    c==t ? O*=vec4(.5,0,0,1) : O;                // color inner cube\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 93, 93, 932]], "test": "untested"}
{"id": "Wtfcz4", "name": "more Circuit Diagram 3 (112 ch)", "author": "FabriceNeyret2", "description": "pattern exploration variant.\n( I already so them in shadertoy under other names, but can find back ).", "tags": ["2d", "xor", "pattern", "onetweet", "golf", "circuits"], "likes": 5, "viewed": 328, "published": 3, "date": "1591509829", "time_retrieved": "2024-07-30T21:02:26.344439", "image_code": "// variant https://shadertoy.com/view/3lfyz4\n\nvoid mainImage(out vec4 O, vec2 U) {\n  int r = int(U.x+U.y) ^ int(U.x-U.y);\n  O = fract(vec4(r*r*r)/(99.+ceil(iTime*4.)/4.+vec4(0,1,2,1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtfcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 82, 82, 187]], "test": "untested"}
{"id": "3tXcz4", "name": "more Circuit Diagram 2 ( 95 ch )", "author": "FabriceNeyret2", "description": "( I already so them in shadertoy under other names, but can find back ).", "tags": ["2d", "xor", "pattern", "onetweet", "golf", "circuits"], "likes": 7, "viewed": 299, "published": 3, "date": "1591509022", "time_retrieved": "2024-07-30T21:02:27.139314", "image_code": "// variant of https://shadertoy.com/view/3lfyz4\n\nvoid mainImage(out vec4 O, vec2 U) {\n  int r = int(U) ^ int(U.y + 30.*iTime);\n  O = fract(vec4(r*r*r)/(997.+vec4(0,1,2,1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 175]], "test": "untested"}
{"id": "3lfyz4", "name": "more Circuit Diagram ( 111 ch )", "author": "FabriceNeyret2", "description": "( I already so them in shadertoy under other names, but can find back ).", "tags": ["2d", "xor", "pattern", "onetweet", "golf", "circuits"], "likes": 5, "viewed": 326, "published": 3, "date": "1591508835", "time_retrieved": "2024-07-30T21:02:27.918231", "image_code": "void mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 30. * iTime),\n      r = (x+y)^(x-y);\n  O = fract(vec4(r*r*r)/(997.+vec4(0,1,2,1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 160]], "test": "untested"}
{"id": "wlsczH", "name": "earthbound bg 2", "author": "thefox231", "description": "third attempt! this one doesn't look as nice as a background, but still really neat\nmaking these is really fun actually", "tags": ["2d", "abstract", "snes", "earthbound"], "likes": 6, "viewed": 490, "published": 3, "date": "1591489334", "time_retrieved": "2024-07-30T21:02:28.664237", "image_code": "const float thickness = 0.02;\nconst vec3 mainColor = vec3(136./255., .6, .2);\n\nbool equals(float a, float b) {\n    return abs(a - b) < thickness;\n}\n\nfloat sum(vec2 a) {\n    return a.x + a.y;\n}\nfloat sum(vec3 a) {\n    return a.x + a.y + a.z;\n}\n\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(.0);\n    \n    // fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // pixelate\n    float pxAmt = 50.0;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    vec2 uvOrig = uv;\n    \n    // unfix aspect ratio\n    uvOrig.x /= iResolution.x / iResolution.y;\n    \n    // interlacing .\n    float pixAmt = 2.;\n    if (mod(fragCoord.y, pixAmt) < pixAmt * 0.5) {\n        uv += 0.1 + tan(iTime * 0.2 + uv.y * 8.) * 0.05;\n    } else {\n        uv -= 0.1 + tan(iTime * 0.2 + uv.y * 8. + .5) * 0.05;\n    }\n    \n    // move ing...\n    uv.x += sin(iTime * 1.6) * 0.3;\n    uv.y += cos(iTime * .2) * 2.5;\n    \n    // rotate......\n    uv.xy *= rotate2d(iTime * 0.15);\n    \n    // bg waves\n    if (equals(sin(uvOrig.x * 90. + iTime) * 0.1 + 0.2, mod(uvOrig.y + sin(iTime * 0.4) * 0.2 + sin(uv.x) * 0.3, 0.3146))) {\n        color += mainColor * 0.2;\n    }\n    if (equals(sin(uvOrig.y * 50. + iTime) * 0.1 + 0.2, mod(uvOrig.x + sin(iTime * 0.7) * 0.2 + sin(uv.y) * 0.3, 0.3146))) {\n        color += mainColor * 0.2;\n    }\n    \n    // rotating squares\n    // repeat them\n    float repeatNum = 4.3;\n   \tuv = mod(uv, 1. / repeatNum) * repeatNum;\n    \n    // get a \"seed\" based on which one it is\n    vec2 seed = floor(uv);\n    \n    float brightness = 1.0;\n    \n    vec3 squareColor = vec3(.0);\n    vec2 squarePos = vec2(.5, .5);\n    squareColor = mainColor * brightness * sum(abs(uv - squarePos));\n    if (sum(abs(uv - squarePos)) < .6) {\n        squareColor -= 0.2;\n    }\n    \n    // glowy......\n    squareColor += sin(iTime) * 0.1;\n    \n    if (sum(squareColor) > .1) {\n    \tcolor = squareColor;\n    }\n    \n    // also add some circles, for good measure\n    uv = uvOrig;\n    \n    // move ing...\n    uv.x += sin(iTime * .6) * 0.7;\n    uv.y += cos(iTime * .9) * 1.5;\n    \n    // rotate......\n    uv.xy *= rotate2d(iTime * 0.18);\n    \n    // fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // interlacing .\n    if (mod(fragCoord.y, pixAmt) < pixAmt * 0.5) {\n        uv += 0.2 + sin(iTime * 0.2 + uv.y * 8.) * 0.05;\n    } else {\n        uv -= 0.2 + cos(iTime * 0.5 + uv.y * 8. + .5) * 0.05;\n    }\n    \n    repeatNum = 1.3;\n   \tuv = mod(uv, 1. / repeatNum) * repeatNum;\n    \n    vec2 circlePosition = vec2(.5, .5);\n    color += mainColor * 1.0 - length(circlePosition - uv);\n    \n    // color shortening\n    // gives it a kind of like snes-like palette\n    float shortAmt = 14.0;\n    color = ceil(color * shortAmt) / shortAmt;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 110, 110, 147], [149, 149, 168, 168, 192], [193, 193, 212, 212, 242], [244, 244, 272, 272, 354], [356, 356, 411, 411, 2993]], "test": "untested"}
{"id": "tlsyRH", "name": "3D fractal jungle explorer", "author": "jarble", "description": "Use the mouse and arrow keys to move around.\nThe scene's geometry is defined in the \"Common\" buffer.\nThe camera control is based on this shader: https://www.shadertoy.com/view/4lVXRm", "tags": ["raymarching", "game", "collisiondetection"], "likes": 3, "viewed": 516, "published": 3, "date": "1591485701", "time_retrieved": "2024-07-30T21:02:29.583778", "image_code": "const float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 ground_color(vec3 p)\n{\n    p /= 2.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\nvec3 foliage_color(vec3 p)\n{\n    p /= 1.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1,0.0);\n}\n\nvec3 spaceship_color(vec3 p)\n{\n    return vec3(0.5,0.5,0.5);\n}\n\nvec3 jungle_color(vec3 p)\n{\n    //p /= scale;\n    p = sin(p/100.0)*100.0;\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0))/2.0;\n}\n\n\n\n\n\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    return normalize(vec3((fragCoord - size / 2.0), -size.y / tan(radians(fieldOfView) / 2.0)));\n}\n\nvec3 bump_map(vec3 p3)\n{\n  \t//return vec3(0.0);\n    p3 *= 10.0;\n    return (sin(p3)+sin(p3))/10.0;\n}\n\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(normalize(reflect(-L, N)), normalize(eye - p));\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n  \n    return color+phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  eye,\n                                  vec3(0.4, 0.4, 0.4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    \n    \n    vec3 rd = normalize(vec3((fragCoord - iResolution.xy*0.5)/max(iResolution.x, iResolution.y), 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n\n    \n\n    //ro /= scale;\n    \n    float dist = shortestDistanceToSurface(ro, rd, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = ro + dist * rd;\n    \n    vec3 K_a;\n    if(color == 3){\n    \tK_a = foliage_color(p);\n    }\n    else if(color == 2){\n    \tK_a = jungle_color(p);\n    }\n    else if(color == 1){\n    \tK_a = ground_color(p);\n    }\n    else if(color == 4){\n    \tK_a = spaceship_color(p);\n    }\n    else{\n    \tK_a = vec3(1.0,1.0,1.0);\n    }\n    \n    vec3 color = phongIllumination(K_a, K_a, vec3(1.0), 10.0, p, ro);\n    \n    fragColor = vec4(color/2.2, 1.0);\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, min(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta * 20.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = .001;\nint color;\n\n//const float scale = 1.0;\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat caves1(vec3 p){\n    float size = 100.0;\n    vec3 p1 = p/size;\n    return length(sin(vec3(sin(p1.x)/p1.x,cos(p1.y)-p1.y,sin(p1.z)+p1.z))*size) - size;\n}\n\nfloat caves(vec3 p) {\n    //p += sin(p.y/100.0)*100.0;\n    float result = caves1(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n        p = p.yxz-p.zyx;\n        result = max(result, caves1(p/i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n\treturn result;\n}\n\nfloat corridor1(vec3 p){\n    float size = 100.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y)-p1.y,sin(p1.z)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat corridor(vec3 p) {\n    float result = corridor1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, corridor1(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result;\n}\n\nfloat bump(vec3 p3)\n{\n    p3 *= 3.;\n  \t//return vec3(0.0);\n    float distortion = 5.0;\n    p3 *= distortion;\n    return length(sin(p3))/(distortion*4.0);\n}\n\nfloat sceneSDF1(vec3 p) {\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  5.0 + sin((p.x*2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat ground1(vec3 p){\n    vec3 p1 = p/5.0;\n\treturn p.y+10.0+sin(p1.x/10.0+sin(p1.z))+sin(p1.z/10.0+sin(p1.x));\n    //return max(-caves(p),to_return);\n    //return p.y;\n}\n\nfloat ground(vec3 p){\n    vec3 p1 = p/5.0;\n\t//float to_return = p.y+10.0+sin(p1.x/10.0+sin(p1.z))+sin(p1.z/10.0+sin(p1.x));\n    vec3 p2 = p1/5.0;\n    //return  max(ground1(p),-sceneSDF1(p2/100.0))+(bump(p2/40.0)*20.0+bump(p2/20.0)*20.0)+bump(p2/10.0)*10.0;\n    return ground1(p);\n    //return p.y;\n}\n\nfloat jungle(vec3 p) {\n    p /= 100.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    float to_return = 4.2 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5+bump(p);\n    return to_return;\n}\n\nfloat foliage1(vec3 p){\n    float size = 100.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)-p1.y,cos(p1.y)-p1.z,sin(p1.z)-p1.x))*size;\n    return length(p) - size;\n}\n\nfloat foliage(vec3 p,float jungle) {\n    float result = foliage1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, foliage1(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return max(result,jungle-3.0);\n}\n\nfloat spaceship1(vec3 p){\n    float size = 200.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y+p1.z)-p1.y,sin(p1.z+p1.x)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat spaceship(vec3 p) {\n    float result = spaceship1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, spaceship1(p*i)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result;\n}\n\nfloat sceneSDF(vec3 p){\n    float ground1 = ground(p);\n    float jungle1 = jungle(p);\n    float foliage1 = foliage(p,jungle1);\n    //float spaceship1 = spaceship(p/10.0);\n\tfloat result1 = min(jungle1,min(foliage1,ground1));\n    if(result1 == jungle1){\n    \tcolor = 2;\n    }\n    else if(result1 == ground1){\n    \tcolor = 1;\n    }\n    else if(result1 == foliage1){\n    \tcolor = 3;\n    }\n    //else if(result1 == spaceship1){\n    //\tcolor = 4;\n    //}\n    else{\n    \tcolor = 2;\n    }\n    return result1;\n}\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\n\n/*\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n*/\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 estimateNormal(in vec3 p){\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * sceneSDF(p + e.xyy) + e.yyx * sceneSDF(p + e.yyx) + e.yxy * sceneSDF(p + e.yxy) + e.xxx * sceneSDF(p + e.xxx));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float depth, float end) {\n    //float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}", "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\n\n// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}\n\n/*\nvec2 sound1( float time )\n{\n    int t = int(time * 4000.0);\n    t = (t>>4&t*2&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        if(i>3){\n        \tresult += sound1(time*factor)/(factor);\n        }\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n*/", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 238, 238, 368], [370, 370, 398, 398, 495], [497, 497, 527, 527, 559], [561, 561, 588, 606, 1001], [1021, 1275, 1340, 1340, 1439], [1441, 1441, 1465, 1488, 1541], [1545, 2037, 2177, 2177, 2735], [2737, 3107, 3192, 3192, 3449], [3451, 3451, 3508, 3508, 4767]], "test": "untested"}
{"id": "wtlyzH", "name": "earthbound bg 1", "author": "thefox231", "description": "second attempt! this one much more successful, i think it looks nice : )", "tags": ["2d", "abstract", "snes", "earthbound"], "likes": 10, "viewed": 672, "published": 3, "date": "1591478318", "time_retrieved": "2024-07-30T21:02:30.483373", "image_code": "const vec3 mainColor = vec3(.6, .0, 136./255.);\n\nfloat sawtooth(float a, float freq) {\n    if (mod(a, freq) < freq * 0.5) return mod(a, freq * 0.5);\n    return freq * 0.5 - mod(a, freq * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float resolutionRatio = iResolution.x / iResolution.y;\n    \n    // uv fuckery !\n    // pixelate\n    \n    float pxAmt = 60.0;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // interlacing .\n    float pixAmt = 2.;\n    if (mod(fragCoord.y, pixAmt) < pixAmt * 0.5) {\n        uv += 0.1 + sin(iTime * 0.2 + uv.y * 8.) * 0.05;\n    } else {\n        uv -= 0.1 + sin(iTime * 0.2 + uv.y * 8. + .5) * 0.05;\n    }\n    \n    vec2 uv2 = uv;\n    \n    vec3 color = vec3(0.1);\n    \n    // first one (bg-ish thing??)\n    \n    color = vec3(mod(abs(sawtooth(uv.x, 0.6) * resolutionRatio + sawtooth(uv.y, 0.6) + iTime * 0.3), 0.4)) * mainColor;\n    \n    // second one (stripes-like thing)\n    \n    if (uv2.x < 0.5) {\n        uv2.x = 1.0 - uv2.x;\n    }\n    if (uv2.y > 0.5) {\n        uv2.y = 1.0 - uv2.y;\n    }\n\n    uv2.x += sin(uv2.y * 4.0 + iTime) * 0.1;\n    \n    if (mod(abs(uv2.x * resolutionRatio + uv2.y + iTime * 0.2), 0.2) < 0.1) {\n        vec3 lines = vec3(cos(uv.x * 2.0 + iTime + uv.y * 3.0)) * mainColor * 0.7;\n        color = mix(color, lines, 0.3);\n    }\n    \n    // color shortening\n    // gives it a kind of like snes-like palette\n    float shortAmt = 10.0;\n    color = ceil(color * shortAmt) / shortAmt;\n    \n    // feed the frag color .\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 194], [196, 196, 253, 253, 1611]], "test": "untested"}
{"id": "3tlyRH", "name": "Primitive cubic lattice", "author": "Roninkoi", "description": "Cube consisting of many dots, inspired by a Kefrens demo", "tags": ["cube", "dots"], "likes": 13, "viewed": 528, "published": 3, "date": "1591473955", "time_retrieved": "2024-07-30T21:02:31.359032", "image_code": "#define PI 3.14159265\n#define MAXIT 128\n#define EPSILON 0.001\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a)\n{\t\n    vec3 p = (abs(r) - a);\n    \n    return length(max(p, 0.));\n}\n \nfloat pbox(vec3 r, float a)\n{\t\n    vec3 p = (abs(r) - a);\n    \n    float dr = 0.02 / (a);\n    float n = 16.;\n    p = p - (a / n) * clamp(round(p / (a / n)), -n, n);\n    p = (length(p) - vec3(dr));\n    \n    return length(max(p, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n    obj = mat3(1.);\n    \n    float ts = (sin(t) + 1.) * (sin(t) + 1.) * (sin(t) + 1.) / 8.;    \n    float tss = (cos(t) + 1.) * 0.8;\n    \n    obj *= rotY((t + tss) * 2.) * rotX((t + tss) * 2.);\n    r = obj * r;\n    \n    float d = pbox(r, ts * 1.4 + 0.5);\n    \n    return vec2(d, d);\n}\n\nvec3 matCol(vec2 o)\n{\n    return vec3(0.0, 1.0, o.y);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime * 0.5;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 0.5, -4.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(1.0 - uv.y * 0.5 + cos(1.5*uv.x), 0.2 - uv.y, uv.y);\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x * 0.001);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.6 - 0.1 * hash(uv);\n\t\tr += rd * d.x;\n        \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    \n\tcol.rgb *= exp(-sh * 1.0);\n    col.rgb = mix(col.rgb, vec3(0.0, 1.0, 0.7), glow * 0.03);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 181, 181, 283], [286, 286, 306, 306, 410], [413, 413, 433, 433, 535], [549, 549, 580, 580, 608], [611, 611, 640, 640, 714], [717, 717, 754, 754, 782], [784, 784, 816, 816, 918], [920, 920, 940, 940, 1012], [1014, 1014, 1041, 1041, 1107], [1110, 1110, 1139, 1139, 1344], [1346, 1346, 1376, 1376, 1431], [1434, 1434, 1476, 1476, 1516], [1529, 1529, 1547, 1547, 1836], [1838, 1838, 1859, 1859, 1893]], "test": "untested"}
{"id": "wtsyRH", "name": "mouse interlace", "author": "DPS2004", "description": "h", "tags": ["mouse", "interlace"], "likes": 2, "viewed": 261, "published": 3, "date": "1591473536", "time_retrieved": "2024-07-30T21:02:32.098056", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n\n    vec2 uv = fragCoord/iResolution.xy;\n    if(mod(fragCoord.y,2.) > 1.0) {\n    uv.x+=sin(uv.y*10.0+iMouse.x/iResolution.x*4.0)*0.0700;\n    } else { \n    uv.x+=sin(uv.y*10.0+iMouse.x/iResolution.x*4.0)*-0.0700;\n    }\n    uv.y+=sin(uv.x*10.0+iMouse.y/iResolution.y*4.0)*0.0700;\n    // Output to screen\n    vec4 uv2 = texture(iChannel1, uv);\n\n    fragColor = uv2;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 112, 482]], "test": "untested"}
{"id": "ttlyRH", "name": "haha funny interlacing", "author": "DPS2004", "description": "shaders are pretty cool tbh", "tags": ["interlace"], "likes": 4, "viewed": 420, "published": 3, "date": "1591471539", "time_retrieved": "2024-07-30T21:02:32.883954", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n\n    vec2 uv = fragCoord/iResolution.xy;\n    if(mod(fragCoord.y,2.) > 1.0) {\n    uv.x+=sin(uv.y*10.0+iTime)*0.0700;\n    } else { \n    uv.x+=sin(uv.y*10.0+iTime)*-0.0700;\n    }\n    uv.y+=sin(uv.x*10.0+iTime)*0.0700;\n    // Output to screen\n    vec4 uv2 = texture(iChannel1, uv);\n\n    fragColor = uv2;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 112, 419]], "test": "untested"}
{"id": "wtscz8", "name": "Dithered bokeh", "author": "michael0884", "description": "Added manual camera controls and collision detection. WASD move, QE - speed requlation. ", "tags": ["fractal", "ray", "terrain", "sdf", "perlin", "marching", "tracing"], "likes": 16, "viewed": 767, "published": 3, "date": "1591470305", "time_retrieved": "2024-07-30T21:02:33.910210", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    fragColor = vec4(HDRmapping(col, 0.6),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.14159265\n#define SQRT2 1.4142135\n#define SQRT3 1.7320508\n#define SQRT5 2.2360679\n#define FOV 2.5\n\n#define MAX_DIST 500.\n#define MIN_DIST 1e-5\n#define MAX_MARCHES 512.\n#define LIGHT_ANGLE 0.04\n\n//how much does the terrain change in large scale\n#define PERLIN_SCALE 2\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n#define N_instructions 6.\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define LIGHT_INDX 4\n#define SPEED_INDX 5\n\n//coefficients are fine-tuned\n//you can get all kinds of weird terrain by carefully setting the coefficients, \n//even forests are possible, but they may look not as realistic as the rock fractals\nconst int FRACTAL_ITER = 17;\nconst float iFracScale = 1.6467;\nconst float iFracAng1 = 2.7315;\nconst float iFracAng2 = -0.2082;\nconst vec3 iFracShift = vec3(-8.92, 3.66, 5.49);\nconst vec3 iFracCol = vec3(0.3, 0.3, -0.2);\nfloat s1 = sin(iFracAng1), c1 = cos(iFracAng1), s2 = sin(iFracAng2), c2 = cos(iFracAng2);\n\nfloat PBR_METALLIC = 0.;\nfloat PBR_ROUGHNESS = 0.1;\n\nvec3 BACKGROUND_COLOR = vec3(0.);\nvec3 LIGHT_DIRECTION = normalize(vec3(-1.,1.,0.68));\nvec3 LIGHT_COLOR = vec3(1., 0.95, 0.8);\nbool SHADOWS_ENABLED = true; \n\nfloat gamma_material = 0.1;\nfloat gamma_sky = 0.6;\nfloat gamma_camera = 2.2;\n\nfloat LOD;\n\nconst float PHI = 0.5*(sqrt(5.) + 1.); \nconst float PHI2 = 0.5*(sqrt(5.) - 1.); \n\nvec2 fibonacci_lattice(int i, int N)\n{\n    return vec2((float(i)+0.5)/float(N), mod(float(i)/PHI, 1.)); \n}\n\nvec2 fcircle(int i, int N)\n{\n    vec2 xy = fibonacci_lattice(i, N);\n    vec2 pt = vec2(2.*PI*xy.y, pow(xy.x, PHI2));\n    return pt.y*vec2(cos(pt.x), sin(pt.x));\n}\n\n\nfloat hash(float p)\n{\n   p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\n//normally distributed random numbers\nvec3 randn(float p)\n{\n    vec4 rand = hash41(p);\n    vec3 box_muller = sqrt(-2.*log(max(vec3(rand.x,rand.x,rand.z),1e-8)))*vec3(sin(2.*PI*rand.y),cos(2.*PI*rand.y),sin(2.*PI*rand.w));\n    return box_muller;\n}\n\n//uniformly inside a sphere\nvec3 random_sphere(float p)\n{\n    return normalize(randn(p))*pow(hash(p+85.67),0.333333);\n}\n\nvec3 cosdistr(vec3 dir, float seed)\n{\n    vec3 rand_dir = normalize(randn(seed*SQRT2));\n    vec3 norm_dir = normalize(rand_dir - dot(dir,rand_dir)*dir);\n    float u = hash(seed);\n    return normalize(dir*sqrt(u) + norm_dir*sqrt(1.-u));\n}\n\n\nvec4 perlin_octave(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 a = vec2(0.,1.);\n   \n   vec4 a00 = hash42(pi+a.xx);\n   vec4 a01 = hash42(pi+a.xy);\n   vec4 a10 = hash42(pi+a.yx);\n   vec4 a11 = hash42(pi+a.yy);\n   \n   vec4 i1 = mix(a00, a01, pfc.y);\n   vec4 i2 = mix(a10, a11, pfc.y);\n   \n   return mix(i1, i2, pfc.x);  \n}\n\nmat2 rotat = mat2(cos(0.5), -sin(0.5), sin(0.5), cos(0.5));\n\nvec4 perlin4(vec2 p)\n{\n\tfloat a = 1.;\n\tvec4 res = vec4(0.);\n\tfor(int i = 0; i < PERLIN_SCALE; i++)\n\t{\n       \n\t\tres += a*(perlin_octave(p)-0.5);\n        //inverse perlin\n         p *= 0.2*rotat;\n\t\ta *= 15.;\n\t\t\n\t}\n\treturn res;\n}\n\n/////\n/////Code from Marble Marcher Community Edition\n/////\n\n#define COL col_scene\n#define DE de_scene\n#define DEv de_scene_var\n//##########################################\n//   Space folding\n//##########################################\nvoid planeFold(inout vec4 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\nvoid sierpinskiFold(inout vec4 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\n\n// Polynomial smooth minimum by iq\nfloat smoothmin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\n/*void mengerFold(inout vec4 z) {\n\tfloat a = smoothmin(z.x - z.y, 0.0, 0.03);\n\tz.x -= a;\n\tz.y += a;\n\ta = smoothmin(z.x - z.z, 0.0, 0.03);\n\tz.x -= a;\n\tz.z += a;\n\ta = smoothmin(z.y - z.z, 0.0, 0.03);\n\tz.y -= a;\n\tz.z += a;\n}*/\n\nvoid mengerFold(inout vec4 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\nvoid boxFold(inout vec4 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\nvoid rotX(inout vec4 z, float s, float c) {\n\tz.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvoid rotY(inout vec4 z, float s, float c) {\n\tz.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\nvoid rotZ(inout vec4 z, float s, float c) {\n\tz.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\nvoid rotX(inout vec4 z, float a) {\n\trotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec4 z, float a) {\n\trotY(z, sin(a), cos(a));\n}\nvoid rotZ(inout vec4 z, float a) {\n\trotZ(z, sin(a), cos(a));\n}\n\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_sphere(vec4 p, float r) {\n\treturn (length(p.xyz) - r) / p.w;\n}\nfloat de_box(vec4 p, vec3 s) {\n\t\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0))) / p.w;\n}\nfloat de_tetrahedron(vec4 p, float r) {\n\tfloat md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),\n\t\t\t\tmax(-p.x + p.y + p.z, p.x - p.y + p.z));\n\treturn (md - r) / (p.w * sqrt(3.0));\n}\nfloat de_capsule(vec4 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r) / p.w;\n}\n\n//##########################################\n//   Main DEs\n//##########################################\nfloat de_fractal(vec4 p, float error)\n{\n\tvec3 p0 = p.xyz*2.;\n   \n\tp.xz = mod(p.xz + vec2(2.*p.w), vec2(4.*p.w)) - vec2(2.*p.w); \n\tvec4 perlin1 = 0.08*perlin4(p0.xz);\n\tvec3 shift =iFracShift + perlin1.xyz;\n    \n    //estimating the number of iterations needed to have this error\n    float iter = log(length(shift)/error)/log(iFracScale)-2.;\n    float max_iter = min(float(FRACTAL_ITER)+1e-4, iter);\n    \n    vec4 prev_p;\n\tfor (float i = 0.; i < max_iter; ++i) {\n\t\tprev_p = p;\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n        if(i == 1.) shift -= perlin1.xyz;\n\t\trotX(p, s2, c2);\n\t\tp *= iFracScale*(1.);\n\t\tp.xyz += shift;\n\t}\n    \n    //interpolate between LOD's\n\tfloat de = mix(de_box(prev_p, vec3(6.0)), de_box(p, vec3(6.0)), fract(max_iter));\n    \n\treturn 0.75*de;\n}\n\nvec4 col_fractal(vec4 p) \n{\n\tvec3 p0 = p.xyz;\n\tvec3 orbit = vec3(0.0);\n\tp.xz = mod(p.xz + vec2(0.5*p.w), vec2(1.*p.w)) - vec2(0.5*p.w); \n\tvec4 perlin1 = perlin4(p0.xz);\n\tvec3 shift =iFracShift + 0.35*(perlin1.xyz - 0.5);\n\tfor (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n\t\trotX(p, s2, c2);\n\t\tp *= iFracScale*(1.);\n\t\tp.xyz += shift;\n\t\torbit = max(orbit, p.xyz*iFracCol);\n\t}\n\treturn vec4(orbit, de_box(p, vec3(6.0)));\n}\n\nfloat de_scene(vec3 pos) \n{\n\tvec4 p = vec4(pos,1.f);\n\tfloat d = de_fractal(p, MIN_DIST);\n\treturn d;\n}\n\nfloat de_scene_var(vec3 pos, float error)\n{\n    vec4 p = vec4(pos,1.f);\n\tfloat d = de_fractal(p, error);\n\treturn d;\n}\n\nvec4 col_scene(vec3 pos) \n{\n\tvec4 p = vec4(pos,1.f);\n\tvec4 col = col_fractal(p);\n\treturn vec4(min(col.xyz,1.), 0.0);\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*DEv(p + k.xyy*dx, 2.*dx) +\n\t\t\t k.yyxx*DEv(p + k.yyx*dx, 2.*dx) +\n\t\t\t k.yxyx*DEv(p + k.yxy*dx, 2.*dx) +\n\t\t\t k.xxxx*DEv(p + k.xxx*dx, 2.*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid scene_material(vec3 pos, inout vec4 color, inout vec2 pbr)\n{\n\t//DE_count = DE_count+1;\n\tvec4 p = vec4(pos,1.f);\n\t\n\tcolor = vec4(1.);\n\t\n\tpbr = vec2(PBR_METALLIC, PBR_ROUGHNESS);\n\tfloat reflection = 0.;\n\n\tcolor = vec4(min(color.xyz,1.), reflection);\n}\n\n\n#define overrelax 1.35\n\nvoid ray_march(inout vec4 p, inout vec4 ray, inout vec4 var, float angle, float max_d)\n{\n    float prev_h = 0., td = 0.;\n    float omega = overrelax;\n    float candidate_td = 1.;\n    float candidate_error = 1e8;\n    for(; ((ray.w+td) < max_d) && (var.x < MAX_MARCHES);   var.x+= 1.)\n    {\n        p.w = DEv(p.xyz + td*ray.xyz, LOD*td);\n        \n        if(prev_h*omega>max(p.w,0.)+max(prev_h,0.)) //if overtepped\n        {\n            td += (1.-omega)*prev_h; // step back to the safe distance\n            prev_h = 0.;\n            omega = (omega - 1.)*0.6 + 1.; //make the overstepping smaller\n        }\n        else\n        {\n\t\t\tif(p.w < 0.)\n\t\t\t{\n\t\t\t\tcandidate_error = 0.;\n\t\t\t\tcandidate_td = td;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n            if(p.w/td < candidate_error)\n            {\n                candidate_error = p.w/td;\n                candidate_td = td; \n\t\t\t\t\n                if(p.w < (ray.w+td)*angle) //if closer to the surface than the cone radius\n                {\n                    break;\n                }\n            }\n            \n            td += p.w*omega; //continue marching\n            \n            prev_h = p.w;        \n        }\n    }\n    candidate_td += p.w;\n    ray.w += candidate_td;\n\tp.xyz = p.xyz + candidate_td*ray.xyz;\n\tp.w = candidate_error*candidate_td;\n}\n\n\nvoid ray_march(inout vec4 p, inout vec4 ray, inout vec4 var, float angle)\n{\n\tray_march(p, ray, var, angle, MAX_DIST);\n}\n\n\n\n#define shadow_steps 256\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, float dist2cam)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = DE(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n\t\tpos.w = DEv(pos.xyz, (dist2cam+dir.w)*LOD);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5*(1.-dDEdt);\n\t\tfloat angle = d/(max(MIN_DIST,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\t//minimizing banding even further\n\t\tdDEdt = dDEdt*0.75 + 0.25*(pos.w-ph)/ph;\n\t\t\n\t\tph = pos.w;\n\t\t\n\t\tif(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(LOD*dir.w, MIN_DIST))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n#define AMBIENT_MARCHES 3\n#define AMBIENT_COLOR 2*vec4(1,1,1,1)\n\n\n///PBR functions \nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n///END PBR functions\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = LIGHT_DIRECTION;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./gamma_sky)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.y;\n\tpos.xyz = normalize(vec3(1,0,0));\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\nvec4 ambient_occlusion(in vec4 pos, in vec4 norm, in vec4 dir)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = normalize(norm.xyz);\n\tvec3 ambient_color = ambient_sky_color(norm.xyz);\n\t//step out\n\tpos.xyz += 0.05*dir.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = 0; i < AMBIENT_MARCHES; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = DEv(pos.xyz, dir.w*LOD);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= float(AMBIENT_MARCHES); // average weighted by importance\n\treturn vec4(ambient_color,1.)*(0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\n\nvec3 refraction(vec3 rd, vec3 n, float p) {\n\tfloat dot_nd = dot(rd, n);\n\treturn p * (rd - dot_nd * n) + sqrt(1.0 - (p * p) * (1.0 - dot_nd * dot_nd)) * n;\n}\n\nvec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, vec3 refl, vec3 refr, float shadow) \n{\n\tvec3 albedo = color.xyz;\n\talbedo = pow(albedo,vec3(1.f/gamma_material)); //square it to make the fractals more colorfull \n\t\n\tvec4 ambient_color = ambient_occlusion(pos, norm, dir);\n\t\n\tfloat metallic = pbr.x;\n\tvec3 F0 = vec3(0.04); \n\tF0 = mix(F0, albedo, metallic);\n\t\n\t//reflectance equation\n\tvec3 Lo = vec3(0.0);\n\tvec3 V = -dir.xyz;\n\tvec3 N = norm.xyz;\n\t\n\t{ //ambient occlusion contribution\n\t\tfloat roughness = max(pbr.y,0.5);\n\t\tvec3 L = normalize(N);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = ambient_color.xyz;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\tif(!SHADOWS_ENABLED)\n\t{\n\t\tshadow = ambient_color.w;\n\t}\n\t\n\tvec3 sun_color = sky_color(LIGHT_DIRECTION);\n\n\t{ //light contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(LIGHT_DIRECTION);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = sun_color*shadow*(0.65+0.35*ambient_color.w);        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\t{ //light reflection, GI imitation\n\t\tfloat roughness = max(PBR_ROUGHNESS,0.8);\n\t\tvec3 L = normalize(-LIGHT_DIRECTION);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = 0.5*sun_color*ambient_color.w*(1.-ambient_color.w);        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\n\tif(color.w>0.5) // if metal\n\t{\n\t\tvec3 n = normalize(norm.xyz);\n\t\tvec3 q = dir.xyz - n*(2.*dot(dir.xyz,n));\n\t\n        //metal\n        vec3 F0 = vec3(0.6); \n        vec3 L = normalize(q);\n        vec3 H = normalize(V + L);\n        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);  \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        Lo += kS*refl;\n\t}\n\t\n\treturn Lo;\n}\n\nvec3 shading_simple(in vec4 pos, in vec4 dir, float fov)\n{\n\tif(pos.w < max(1.*fov*dir.w, MIN_DIST))\n\t{\n\t\t//calculate the normal\n\t\tfloat error = 0.75*fov*dir.w;\n\t\tvec4 norm = calcNormal(pos.xyz, max(MIN_DIST, error)); \n\t\tnorm.xyz = normalize(norm.xyz);\n        \n        vec4 spos = vec4(pos.xyz, pos.w);\n\t\tfloat shadow = shadow_march(spos, vec4(LIGHT_DIRECTION,0.), 5., LIGHT_ANGLE, dir.w);\n\t\tif(norm.w < -error)\n\t\t{\n\t\t\treturn COL(pos.xyz).xyz;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//optimize color sampling \n\t\t\tvec3 cpos = pos.xyz - pos.w*norm.xyz;\n\t\t\t//cpos = cpos - DE(cpos)*norm.xyz;\n\t\t\t//cpos = cpos - DE(cpos)*norm.xyz;\n\t\t\t\n\t\t\tvec4 color; vec2 pbr;\n\t\t\tscene_material(cpos, color, pbr);\n\t\t\treturn lighting(color, pbr, pos, dir, norm, vec3(0), vec3(0), shadow); \n\t\t}\n\t}\n\telse\n\t{\n\t\treturn sky_color(dir.xyz);\n\t}\n}\n\n\nvec3 render_ray(in vec4 pos, in vec4 dir, float fov)\n{\n\tvec4 var = vec4(0,0,0,1);\n\tray_march(pos, dir, var, fov); \n\treturn shading_simple(pos, dir, fov);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / gamma_camera));\n}\n\n\nmat3 getCamera(vec2 angles)\n{\n    angles.y = - angles.y;\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   sin(angles.y),  cos(angles.y),\n                          0,  -cos(angles.y),  sin(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),  0.,  -sin(angles.x),\n        \t\t       0.,  1., 0.,\n        \t\t        sin(angles.x),              0.,           cos(angles.x)); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n", "buffer_a_code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(iChannel0,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(iChannel0,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = texelFetch(iChannel0,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(iChannel0,  ivec2(VEL_INDX,0), 0);\n\t\tvec4 speed = texelFetch(iChannel0,  ivec2(SPEED_INDX,0), 0);\n        vec4 norm = calcNormal(posit.xyz, MIN_DIST);\n        norm.xyz = norm.xyz/(length(norm.xyz) + 0.0001);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n            fragColor.y *= 1.- 0.01*clamp(length(vel.xyz),0.,1.);\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(0.,0.);\n            }\n            break;\n            \n        case POS_INDX:  //position\n          \n            float DX = length(vel.xyz*speed.x)+0.0001;\n            float MAXDX = DE(fragColor.xyz + vel.xyz*speed.x) + norm.w;\n            if(DX > MAXDX)\n                vel *= 0.25;\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0.,11.,1.);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            fragColor.xyz *= 0.8; //slowing down\n            \n            //fractal collision detection, removing the normal velocity component \n          \tfragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/0.04);\n            break;\n          case LIGHT_INDX:  //light\n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz = posit.xyz;\n                fragColor.w = .08;\n            }\n            if(iFrame < 1)\n            {\n                fragColor = vec4(12.5,-4,10.5, 0.1);\n            }\n            break; \n          case SPEED_INDX: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fork of \"Fractal terrain explorer\" by michael0884. https://shadertoy.com/view/3ldGRX\n// 2020-06-06 19:02:29\n\n// Fork of \"Fractal terrain generator\" by michael0884. https://shadertoy.com/view/3lcGRX\n// 2019-12-22 20:51:23\n\n#define Nsamp 512\n#define aperture 0.01\n#define focal_plane 0.6\n\nvoid getRay(out vec3 ro, out vec3 rd, vec2 pos, ivec2 p)\n{\n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n \tmat3 camera = getCamera(angles);\n    int kk = int(iMouse.z);\n  \t//dither position on the aperture\n    vec4 blue = texture(iChannel0, vec2(p)/1024. + PI*iTime);\n    int I = int(blue.x * float(Nsamp));\n    \n    pos += (blue.yz - 0.5)/iResolution.x;\n    vec2 delta = 2.*aperture*fcircle(I, Nsamp);\n    vec3 ro0 = vec3(delta.x, 0., delta.y);\n    vec3 rd0 = focal_plane*vec3(FOV*pos.x, 1, FOV*pos.y) - ro0;\n    \n    ro = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0).xyz + transpose(camera)*ro0;\n    rd = normalize(transpose(camera)*rd0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized centered pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    LOD = 0.25/max(iResolution.x,iResolution.y);\n    \n    vec3 r;\n    vec3 p;\n    getRay(p, r, pos, ivec2(fragCoord));\n    \n  \n \tvec3 ray = r;\n    \n    vec4 cpos = vec4(p, 0.);\n    vec4 dir = vec4(ray,0.);\n    \n    vec3 col = render_ray(cpos, dir, LOD);\n    fragColor = clamp(texture(iChannel1, fragCoord/iResolution.xy),0.,1.);\n    // Output to screen\n    if(any(isnan(col))) col = vec3(0.);\n    fragColor.xyz = mix(fragColor.xyz, col, 0.1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 177]], "test": "untested"}
{"id": "WdScWw", "name": "flitzekacke", "author": "Virgill", "description": "fast made compofiller for Revision 2020\nSorry, had just an hour to come up with this mess. But that´s what compofillers are about :)\nHi las.\nSigning off, the compo saving crew", "tags": ["4k", "demoscene", "volumetric"], "likes": 15, "viewed": 498, "published": 3, "date": "1591467802", "time_retrieved": "2024-07-30T21:02:34.650232", "image_code": "//Madtracer ftw\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n    fragColor = texture(iChannel0, uv);\n}\n\n//-------------------------------------------------------------------------------------------\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\nvoid dmin(inout vec3 d, float x, float y, float z)\n{\n\tif( x < d.x ) d = vec3(x, y, z);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(3.-2.*p);\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat hash11(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n    float u = hash11( 78.233 + seed);\n    float v = hash11( 10.873 + seed);\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n// smooth minimum function (iq)\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// signed distance capsule function\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// 2d box\nfloat box(vec2 p)\n{\n\tp=abs(p); return max(p.x, p.y);\n}\n\n\n// rotation\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\n}\n\n\n//***************************************************************************************************\n// MAP\n//***************************************************************************************************\n\nfloat pattern(vec2 p)\n{\n    p.x += 5.;\n    p.y *= 2.;\n    p = floor(p*2.);\n    p.y += floor(iTime*2.)*17.;\n    p = floor(p);\n    return (sin(p.y*p.y) > 0.8) ? 2. : .99;\n}\n\n\n\n\n\nvec3 map(vec3 p)\n{\n\tvec3 d = vec3(1, 0, 0);\n    float floornoise = .8*noise(3.*p+0.2*iTime)+0.1*noise(15.*p+0.1*iTime); // noise for the floor\n\n    \n    if (iTime<=10.)\n    {\n    \n    dmin(d, 2.8+p.y, .55, 0.); \t\t\t// floor\n    dmin(d, 0.8-p.y, pattern(p.xz+p.zx),0.); // ceil\n\tdmin(d, sdCapsule(p,vec3( -15,0,1),vec3( 15,0,1),.8+1.6*floornoise),.1+floornoise,0.); // glowing capsule\n\t}    \n\n\n    if (iTime>10.&&iTime<=20.)\n    {\n    \n    dmin(d, 2.8+p.y, .05, 0.); \t\t\t// floor\n    dmin(d, 0.8-p.y, pattern(p.xz),0.); // ceil\n    float sd = length(p+vec3(0, 0, 2))-.5;\n\tfloat sd2=mod(sd,.5);\n    dmin(d, sd2, .1, 0.); \t\t\t\t// sphere\n    dmin(d, sd, .1, 0.); \t\t\t\t// sphere\n\t}    \n\n\n    if (iTime>20.&&iTime<=30.)\n    {    \n    dmin(d, 0.6*sin(6.*p.x+1.6*iTime)+p.y, .05, 0.); \t\t\t// floor\n    dmin(d, 0.8-p.y, pattern(p.xz),0.); // ceil\n\t} \n\n\n    if (iTime>30.)  \n    {\n    vec3 q = p - 0.9*iTime*vec3(0, 1, 0);\n\n\n\tpR(q.yz, 1.);\n\n\n\tfloat cd = length(p.xz-vec2(0, -3)), sd = length(p+vec3(0, 0, 2))-.5;\n\tdmin(d, 0.6+0.01*sin(8.*p.z+iTime)*sin(6.*p.x+1.6*iTime)+p.y, .05, 0.); \t\t\t// floor\n\tdmin(d, 1.5-abs(p.x), .99, 0.); \t\t// sides\n\tdmin(d, 0.8-p.y, pattern(p.xz),0.); // ceil\n\tdmin(d, sd, .1, 0.); \t\t\t\t// sphere\n\n\n\tq = abs(p);\n\tq.x -= 1.5;\n\tq.y -= 0.4;\n\n\n\tq = abs(p-round(p-.5)-.5);\n\tdmin(d, max(max(\n\t\tmin(min(box(q.xy), box(q.xz)), box(q.yz))-.05,\n\t\tmin(.6-abs(p.x+p.z), .45-abs(p.y))\n\t), 1.8-cd), .1, .5); \t\t\t\t// lattice\n    }\n    \n\n\treturn d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(0, .0001);\n\treturn normalize(map(p).x-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\n\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    //scene = 5;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// borders :(\n\tif( uv.y>.2 && uv.y<.8)\n\t{\n\t\tfloat seed = sin(fragCoord.x + fragCoord.y)*sin(fragCoord.x - fragCoord.y)+fract(iTime), t1 = 0., t2 = 0., t3=0.;\n\n\n\t\t// camera\n\t\tvec3 ro1 = vec3(0, 0, -5.), rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\n\t\t// rotate scene\n\t\tpR(rd1.xz,-.05*sin(.17*iTime));\n\t\tpR(rd1.yz, .02*sin(.19*iTime));\n\n//***************************************************************************************************\n// Cast ray\n//***************************************************************************************************        \n       \n\t\tvec3 scol = vec3(0);\t\t\t\t\t\t\t\t\t\t// clear color accumulator \n\n\t\tvec3 m1=vec3(0), m2, m3, ro2,ro3,rd2,rd3, nor2, nor3, roold=ro1, rdold=rd1;\n\t\tfor( int i = 0; i < 140; i++ )\n\t\t{\n\t\t\tseed+=0.1;\n\t\t\tro1=mix(roold, hashHs(ro1, seed), .002);\t\t\t\t// antialiasing\n\t\t\tif (fract(0.2*iTime)>0.8)rd1=mix(rdold,hashHs(rdold,seed),0.02*(t1-2.4));\t\t\t// dof (strength*(focus-t1))\n            m1 = map(ro1+rd1*t1);\n\t\t\tt1+=.25*(m1.z!=0. ? abs(m1.x) : m1.x);\n\t\t\t\n            // bounce 1:\n\t\t\tro2 = ro1 + rd1*t1;\n\t\t\tnor2 = normal(ro2); \t\n            seed+=0.1;\n\t\t\trd2 = mix(reflect(rd1,nor2),hashHs(nor2,seed),m1.y);\t// reflect depending on material\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tm2 = map(ro2+ rd2*t2); \n\t\t\tt2+=.25*(m2.z!=0. ? abs(m2.x) : m2.x);\n            \n            // bounce 2:\n            ro3 = ro2 + rd2*t2;\n\t\t\tnor3 = normal(ro3); \t\n            seed+=0.1;\n\t\t\trd3 = mix(reflect(rd2,nor3),hashHs(nor3,seed),m2.y);\t// reflect depending on material\t\n            m3 = map(ro3+rd3*t3); \n\t\t\tt3+=.25*(m3.z!=0. ? abs(m3.x) : m3.x);            //\n\n\n\t\t\t// changed for intensity of emitting materials\n\t\t\tscol += vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*(m1.y-1.) \n                  + vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)*(m2.y-1.)\n            \t  + vec3(1.+m3.z, 1., 1.-m3.z)*step(1., m3.y)*(m3.y-1.);\n\t\t}\n\n\n\t\t//fragColor =vec4(scol*0.02,0); //without blur\n\t\tfragColor =clamp(vec4(.005*scol+texture(iChannel0, uv).xyz, 0.)*.8, 0., 1.); // with blur\n\t}\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdScWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 75, 160]], "test": "untested"}
{"id": "WsBBR3", "name": "Demofox Path Tracing 2", "author": "demofox", "description": "demofox path tracing in shadertoy part 2\nBlog post at blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/", "tags": ["pathtracing"], "likes": 79, "viewed": 7494, "published": 3, "date": "1591467795", "time_retrieved": "2024-07-30T21:02:35.682472", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    // apply exposure (how long the shutter is open)\n    color *= c_exposure;\n\n    // convert unbounded HDR color range to SDR color range\n    color = ACESFilm(color);\n\n    // convert from linear to sRGB for display\n    color = LinearToSRGB(color);\n    \n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "uint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct SMaterialInfo\n{\n    vec3 albedo;           // the color used for diffuse lighting\n    vec3 emissive;         // how much the surface glows\n    float percentSpecular; // percentage chance of doing specular instead of diffuse lighting\n    float roughness;       // how rough the specular reflections are\n    vec3 specularColor;    // the color tint of specular reflections\n};\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.1f, 0.7f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.9f, 0.5f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n        hitInfo.material.percentSpecular = 0.1f;\n        hitInfo.material.roughness = 0.2f;\n        hitInfo.material.specularColor = vec3(0.9f, 0.9f, 0.9f);        \n    } \n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);   \n        hitInfo.material.percentSpecular = 0.3f;\n        hitInfo.material.roughness = 0.2;\n        hitInfo.material.specularColor = vec3(0.9f, 0.9f, 0.9f);        \n    }    \n    \n    // a ball which has blue diffuse but red specular. an example of a \"bad material\".\n    // a better lighting model wouldn't let you do this sort of thing\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.0f, 0.0f, 1.0f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.percentSpecular = 0.5f;\n        hitInfo.material.roughness = 0.4f;\n        hitInfo.material.specularColor = vec3(1.0f, 0.0f, 0.0f);        \n    }\n    \n    // shiny green balls of varying roughnesses\n    {\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);       \n        }     \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.25f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.5f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.75f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }        \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 1.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }           \n    }\n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    // initialize\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    \n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo;\n        hitInfo.dist = c_superFar;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n        \n        // if the ray missed, we are done\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += SRGBToLinear(texture(iChannel1, rayDir).rgb) * c_skyboxBrightnessMultiplier * throughput;\n            break;\n        }\n        \n\t\t// update the ray position\n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        \n        // calculate whether we are going to do a diffuse or specular reflection ray \n        float doSpecular = (RandomFloat01(rngState) < hitInfo.material.percentSpecular) ? 1.0f : 0.0f;\n \n        // Calculate a new ray direction.\n        // Diffuse uses a normal oriented cosine weighted hemisphere sample.\n        // Perfectly smooth specular uses the reflection ray.\n        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.roughness * hitInfo.material.roughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        \n\t\t// add in emissive lighting\n        ret += hitInfo.material.emissive * throughput;\n        \n        // update the colorMultiplier\n        throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);      \n        \n        // Russian Roulette\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        {\n        \tfloat p = max(throughput.r, max(throughput.g, throughput.b));\n        \tif (RandomFloat01(rngState) > p)\n            \tbreak;\n\n        \t// Add the energy we 'lose' by randomly terminating paths\n        \tthroughput *= 1.0f / p;            \n        }\n    }\n \n    // return pixel color\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    \n    // calculate the camera distance\n\tfloat cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);     \n    \n    // calculate subpixel camera jitter for anti aliasing\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3(((fragCoord+jitter)/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    // correct for aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // raytrace for this pixel\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    \tcolor += GetColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    \n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    // show the result\n    fragColor = vec4(color, blend);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\n\n// number of ray bounces allowed max\nconst int c_numBounces = 8;\n\n// a multiplier for the skybox brightness\nconst float c_skyboxBrightnessMultiplier = 2.0f;\n    \n// a pixel value multiplier of light before tone mapping and sRGB\nconst float c_exposure = 0.5f; \n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 8;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nconst float KEY_SPACE = 32.5/256.0;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 418]], "test": "untested"}
{"id": "wsBBDV", "name": "The dream of a red paper plane", "author": "friol", "description": "Music is synthesized. Clouds too.", "tags": ["sdf", "landscape", "plane", "paper", "cage"], "likes": 28, "viewed": 676, "published": 3, "date": "1591465666", "time_retrieved": "2024-07-30T21:02:36.702744", "image_code": "\n//\n// friol 2o2o\n// sdf funtions by iq\n//\n\n// by halcy\nvec3 hexablur(sampler2D tex, vec2 uv) \n{\n    vec2 scale = vec2(1.0) / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float asum = 0.0;\n    float coc = texture(tex, uv).a;\n    for(float t = 0.0; t < 8.0 * 2.0 * 3.14; t += 3.14 / 32.0) {\n    \tfloat r = cos(3.14 / 6.0) / cos(mod(t, 2.0 * 3.14 / 6.0) - 3.14 / 6.0);\n        \n        // Tap filter once for coc\n        vec2 offset = vec2(sin(t), cos(t)) * r * t * scale * coc;\n        vec4 samp = texture(tex, uv + offset * 1.0);\n        \n        // Tap filter with coc from texture\n        offset = vec2(sin(t), cos(t)) * r * t * scale * samp.a;\n        samp = texture(tex, uv + offset * 1.0);\n        \n        // weigh and save\n        col += samp.rgb * samp.a * t;\n        asum += samp.a * t;\n        \n    }\n    col = col / asum;\n    return(col);\n}\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel1, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n\nfloat message(vec2 U,int w) \n{\n    vec4 T = vec4(0);\n    if (w==0) { C(116);C(104);C(101); }\n    if (w==1) { C(100);C(114);C(101);C(97);C(109); }\n    if (w==2) { C(111);C(102); }\n    if (w==3) { C(97); }\n    if (w==4) { C(114);C(101);C(100); }\n    if (w==5) { C(112);C(97);C(112);C(101);C(114); }\n    if (w==6) { C(112);C(108);C(97);C(110);C(101); }\n    return length(T.yz)==0. ? -1. : T.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\tvec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // cinema bands\n    if ((screenPos.y<-0.9)||(screenPos.y>0.9)) { fragColor=vec4(0.0,0.0,0.0,1.0); return; }\n    \n    // the dream of a red paper plane\n    if ((iTime>=36.0)&&(iTime<44.0))\n    {\n        const float yadd=0.04;\n        float c=message((fragCoord/iResolution.y-vec2(1.4,.7+yadd))*vec2(8.,8.5),0);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.28,.6+yadd))*vec2(8.,8.5),1);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.47,.5+yadd))*vec2(8.,8.5),2);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.53,.41+yadd))*vec2(8.,8.5),3);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.405,.31+yadd))*vec2(8.,8.5),4);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.28,.21+yadd))*vec2(8.,8.5),5);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.28,.11+yadd))*vec2(8.,8.5),6);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n    }\n    \n    // vignette\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2 *=  1.0 - uv2.yx;\n    float vig = uv2.x*uv2.y * 38.0;\n    vig = pow(vig, 0.05);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(hexablur(iChannel0, uv)*vig, 0.0);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// clouds thanks to demofox - https://www.shadertoy.com/view/4tlBz8\n\nfloat hash21(vec2 p) {\n  return fract(sin(dot(p, vec2(425.215, 714.388)))*45758.5453);\n}\n\n#define NUM_STEPS 128\n#define NUM_NOISE_OCTAVES 3\n#define HEIGHT_OFFSET 1.25\n#define WHITE_NOISE_GRID_SIZE 128.0\n\n// from \"Hash without Sine\" https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat BilinearInterpolateWhiteNoise (vec2 uv)\n{\n    uv = fract(uv);\n    \n    vec2 uvPixels = uv * WHITE_NOISE_GRID_SIZE;\n    \n    vec2 uvFrac = uvPixels - floor(uvPixels);\n    \n    vec2 uvDiscreteFloor = floor(uvPixels) / WHITE_NOISE_GRID_SIZE;\n    vec2 uvDiscreteCeil = ceil(uvPixels) / WHITE_NOISE_GRID_SIZE;\n    \n    float noise00 = hash12(vec2(uvDiscreteFloor.x, uvDiscreteFloor.y));\n    float noise01 = hash12(vec2(uvDiscreteFloor.x, uvDiscreteCeil.y ));\n    float noise10 = hash12(vec2(uvDiscreteCeil.x , uvDiscreteFloor.y));\n    float noise11 = hash12(vec2(uvDiscreteCeil.x , uvDiscreteCeil.y ));\n    \n    float noise0_ = mix(noise00, noise01, uvFrac.y);\n    float noise1_ = mix(noise10, noise11, uvFrac.y);\n    \n    float noise = mix(noise0_, noise1_, uvFrac.x);\n\n    return noise;\n}\n\nfloat RandomNumber(in vec3 position)\n{\n    vec2 uv = (position.xz+ceil(position.y))/float(NUM_STEPS);\n    return BilinearInterpolateWhiteNoise(uv);\n}\n\n// skybox\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = hash21(i + vec2(0., 0.));\n    float rb = hash21(i + vec2(1., 0.));\n    float lt = hash21(i + vec2(0., 1.));\n    float rt = hash21(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += noise(uv) * amplitude;\n        amplitude *= .5;\n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(in vec3 ro, in vec3 rd,float iTime,vec3 sundir)\n{\n    const float SC = 1e5;\n\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    vec3 lightDir = normalize(vec3(.1, .1, .3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 colorSky=(iTime<52.0)?vec3(0.3,0.5,0.85):vec3(0.5,0.13,0.1);\n    vec3 colorHor=(iTime<52.0)?vec3(.25, .394, .572):vec3(.65, .25, .25);\n    \n    vec3 cloudCol = vec3(1.);\n    vec3 skyCol = colorSky - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun;\n    \n    float t = -iTime * 0.1;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    skyCol = mix( skyCol, 0.88 * colorHor, pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return clamp(skyCol,vec3(0.0),vec3(1.0));\n}\n\nvec3 nightSky(in vec3 ro, in vec3 rd,float iTime,vec3 moondir)\n{\n    const float SC = 1e5;\n\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    vec3 lightDir = normalize(vec3(.1, .1, .3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    vec3 skyCol = vec3(0.01,0.05,0.07) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.35 * vec3(0.017,0.075,0.085), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    float t = -iTime * 0.1;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.6, .8, den));\n    \n    float cloudShade = 1.0 - smoothstep(0.2, 0.9 , den);\n    float moonDot = dot(lightDir, rd);\n    float moonA = smoothstep(0.9985, 0.999, moonDot);\t\t\n    skyCol += (moonA*cloudShade)*vec3(0.421,0.421,0.421);\n    skyCol += vec3(0.05) * smoothstep(0.91, 0.9985, moonDot); \n    \n    if (0.999*fbm(vec2(p.x*t*p.x*t, p.y*t*p.y * t))>0.91) skyCol+=vec3(1.0);\n    skyCol = mix( skyCol, 0.18 * vec3(.01, .01, .01), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\n\n// wave functions by afl_ext - https://www.shadertoy.com/user/afl_ext\n\n#define ITERATIONS_RAYMARCH 12\n#define DRAG_MULT 0.048\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, float itm){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<ITERATIONS_RAYMARCH;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, itm);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n", "buffer_a_code": "\n// if you feel brave.\n//#define ANTIALIASED\n\nfloat sdSeaBox( vec3 p, vec4 n )\n{\n    float ns=getwaves(p.xz*0.1,iTime);\n    p.y-=ns/1.0;\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdVertTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdPaperplane(vec3 r)\n{\n\tfloat paperplane;\t\n    r.x=-abs(r.x);\n    float lwing=udTriangle(r,vec3(0.0,0.5,0.8),vec3(-0.05,0.5,0.0),vec3(-0.25,0.5,0.0))-0.005;\n    //float rwing=udTriangle(r,vec3(0.0,0.5,0.8),vec3( 0.05,0.5,0.0),vec3( 0.25,0.5,0.0))-0.005;\n    float lbase=udTriangle(r,vec3(0.0,0.51,0.8),vec3(-0.05,0.5,0.0),vec3(0.0,0.35,0.0))-0.002;\n    //float rbase=udTriangle(r,vec3(0.0,0.51,0.8),vec3(0.0,0.35,0.0),vec3( 0.05,0.5,0.0))-0.002;\n    paperplane=min(lbase,lwing);\n    //paperplane=min(rwing,lwing);\n    //paperplane=min(paperplane,lbase);\n    //paperplane=min(paperplane,rbase);\n    return paperplane;\n}\n\n// by mercury\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle = 2.0*3.141592/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\treturn c;\n}\n\nvec2 SDFscene(vec3 r)\n{\n\tfloat t=999999.0;\n    \n    vec3 curpoint;\n    curpoint.x=sin(iTime)*0.2;\n    curpoint.y=-3.0+cos(iTime)*0.3;\n    if (iTime<28.0) curpoint.z=13.4+iTime-(iTime*0.06);\n    else curpoint.z=11.0+iTime;\n    r=r-vec3(curpoint.x,curpoint.y+2.0,curpoint.z);\n\n    t=sdPaperplane(r);\n\n    if (t!=999999.0) return vec2(t,1.0);\n    \n    return vec2(-1.0);    \n}\n\nvec2 SDFSeaScene(vec3 r)\n{\n\tfloat t=999999.0;\n\n    float seaplane=sdSeaBox(r,vec4(0.0,1.0,0.0,1.0));\n    t=min(t,seaplane);\n\n    vec3 curpoint;\n    curpoint.x=0.0;\n    if (iTime<65.0) curpoint.y=0.0;\n    else curpoint.y=1.5;\n    if (iTime<60.0) curpoint.z=8.0+iTime*10.0;\n    else if (iTime<65.0) curpoint.z=-58.0+iTime*10.0;\n    else curpoint.z=iTime*10.0;\n    r=r-vec3(curpoint.x,curpoint.y,curpoint.z);\n\n    float paperplane=sdPaperplane(r);\n    t=min(t,paperplane);\n    \n    if (t==paperplane) return vec2(t,1.0);\n    if (t==seaplane) return vec2(t,2.0);\n    \n    return vec2(-1.0);    \n}\n\nvec2 SDFCageScene(vec3 r,int traceMode)\n{\n\tfloat t=999999.0;\n    vec3 origR=r;\n\tconst float barDim=0.005;\n\n    // paperplane\n    if (traceMode==1)\n    {\n        r=r-vec3(0.0,0.0,-0.3+iTime-12.0);\n    }\n    else r=r-vec3(0.0,0.0,-0.3);\n    float paperplane=sdPaperplane(r);\n    t=min(t,paperplane);\n    \n    if ((t==paperplane)&&(traceMode==1)) return vec2(t,1.0);\n    \n    // floor\n    r=origR;\n    float floory=sdPlane(r-vec3(0.0,0.0,0.0),vec4(0.0,1.0,0.0,1.0));\n    t=min(t,floory);\n    \n    // cage structure\n    float base=sdRoundedCylinder(r-vec3(0.0,0.31,0.0),0.37,0.01,0.02);\n\tfloat minBase=sdRoundedCylinder(r-vec3(0.0,0.37,0.0),0.34,0.01,0.06);\n    base=max(-minBase,base);\n    t=min(t,base);\n    float upperCircle=sdTorus(r-vec3(0.0,1.21,0.0),vec2(0.7,barDim));\n    t=min(t,upperCircle);\n    float lowerCircle=sdTorus(r-vec3(0.0,0.7,0.0),vec2(0.7,barDim));\n    t=min(t,lowerCircle);\n    float upperHang=sdVertTorus(r-vec3(0.0,1.98,0.0),vec2(0.08,0.01));\n    t=min(t,upperHang);\n\n    //\n\n    r=origR;\n\tpModPolar(r.xz,12.0);\n    \n    float bar=sdVerticalCapsule(r-vec3(.7,.3,0.0),0.98,barDim);\n    t=min(t,bar);\n    \n\tfloat arc=sdCappedTorus(r-vec3(0.0,1.2,0.0),vec2(1.,.01),0.702,barDim);\n    t=min(t,arc);\n    \n    if (t==paperplane) return vec2(t,1.0);\n    if (t==bar) return vec2(t,3.0);\n    if (t==arc) return vec2(t,3.0);\n    if (t==upperCircle) return vec2(t,3.0);\n    if (t==lowerCircle) return vec2(t,3.0);\n    if (t==upperHang) return vec2(t,3.0);\n    if (t==base) return vec2(t,4.0);\n    if (t==floory) return vec2(t,5.0);\n    \n    return vec2(-1.0);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += (iTime<20.0)?e*SDFCageScene(pos+0.0005*e,0)[0]:\n        (iTime<52.0)?e*SDFscene(pos+0.0005*e)[0]:\n        (iTime<70.0)?e*SDFSeaScene(pos+0.0005*e)[0]:\n        e*SDFCageScene(pos+0.0005*e,0)[0];\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDir, out vec3 cloudColor,vec2 fragCoord, int traceMode)\n{\n    float t = 0.0;\n    vec3 pixelColor;\n    vec3 skyColor = vec3(0.9);\n\n    if ((iTime>20.0)&&(iTime<52.0))\n    {\n    \tfloat adder=((iTime>=36.0)&&(iTime<44.0))?(fract(hash12(rayDir.xz))*0.1):0.0;\n        for (int rayStep = 0; rayStep < NUM_STEPS; ++rayStep)\n        {\n            vec3 position = adder+0.05 * float(NUM_STEPS - rayStep) * rayDir;\n            position.z+=iTime;\n            float noiseScale=0.75;\n            float posMulty=((iTime>=28.0)&&(iTime<36.0))?0.35:1.25;\n            float signedCloudDistance = position.y+posMulty;\n            for (int octaveIndex = 0; octaveIndex < NUM_NOISE_OCTAVES; ++octaveIndex)\n            {\n                position *= 2.0;\n                noiseScale *= 2.0;\n                signedCloudDistance -= RandomNumber(position) / noiseScale;\n            }\n            if (signedCloudDistance < 0.0)\n                pixelColor+=(pixelColor-1.-signedCloudDistance * skyColor.zyx)*signedCloudDistance*0.15;\n        }\n\n        cloudColor=pixelColor;\n    }\n    \n    for (int i = 0; i < 128; i++)\n    {\n        vec2 res = (iTime<20.0)?SDFCageScene(rayOrigin + rayDir * t,traceMode):\n        \t(iTime<52.0)?SDFscene(rayOrigin + rayDir * t):\n        \t(iTime<70.0)?SDFSeaScene(rayOrigin + rayDir * t):\n        \tSDFCageScene(rayOrigin + rayDir * t,traceMode);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float fogAmount = 1.0 - exp(-dist * .35);\n    return mix(c, fxcol, fogAmount);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = SDFCageScene( pos + h*nor,0 ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n/*\nvec3 reflekkt(vec3 rayOrigin,vec3 rayDir,vec2 fragCoord)\n{\n    vec3 finalColor=vec3(0.0);\n\tvec3 L = normalize( vec3(.1, .9, -.23 ));\n    vec3 cloudColor;\n\n    vec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,0);\n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n\n    vec3 N=calcNormal(pHit);\n    float NoL = max(dot(N, L), 0.0);\n    \n    if (mat==1.0)\n    {\n        finalColor=vec3(NoL)*vec3(0.58,0.12,0.12);\n    }\n    else\n    {\n        vec3 sunPos=normalize(vec3(0.2,1.2,-1.0));\n    \tvec3 skyColor=Sky(pHit,reflect(rayDir,N),iTime,sunPos);\n        finalColor=skyColor;\n    }\n    \n    \n    return finalColor;\n}\n*/\n\nvec4 rayMarchCycle(vec3 rayOrigin, vec3 rayDir,vec2 fragCoord,out vec3 outPhit)\n{\n    vec3 col=vec3(0.);\n\tvec3 L = normalize( vec3(.1, .9, -.23 ));\n\n    vec3 finalColor=vec3(0.0);\n    vec3 cloudColor;\n    vec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,0);\n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n    outPhit=pHit;\n    \n    vec3 N=calcNormal(pHit);\n    float NoL = max(dot(N, L), 0.0);\n    float ao=calcAO(pHit,N);\n\n    vec3 skyColor=Sky(pHit,(mat==2.0)?reflect(rayDir,N):rayDir,iTime,L);\n    vec3 darkSkyColor=nightSky(pHit,(mat==2.0)?reflect(rayDir,N):rayDir,iTime,L);\n    vec3 finSkyCol=skyColor;\n    \n    if (mat==1.0) // paper plane\n    {\n        finalColor=vec3(NoL)*vec3(0.58,0.12,0.12);\n    }\n    else if (mat==2.0) // sea plane sea scene/night\n    {\n        if ((iTime>=60.0)&&(iTime<65.0)) finSkyCol=mix(darkSkyColor,skyColor,(65.0-iTime)/5.0);\n        else if (iTime>=65.0) finSkyCol=darkSkyColor;\n\t\t//vec3 reflektCol=reflekkt(rayOrigin,rayDir,fragCoord);        \n        vec3 col=mix(vec3(pow(NoL,8.0))*vec3(0.01,0.01,0.02),finSkyCol,0.6);\n        finalColor=clamp(col,vec3(0.0),vec3(1.0));\n        // final fadeout\n        if (iTime>=65.0) finalColor=mix(finalColor,vec3(0.0),clamp((iTime-65.0)/3.0,0.0,1.0));\n    }\n    else if (mat==3.0) // cage bars\n    {\n        vec3 barCol=vec3(0.74);\n        finalColor=barCol.xyz*ao;\n        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));\n    }\n    else if (mat==4.0) // cage base\n    {\n        vec3 barCol=vec3(0.22);\n        //float d=distance(pHit,vec3(0.0));\n        //vec3 fgcol=fog(barCol,d,vec3(0.8));\n        finalColor=barCol.xyz*ao;\n        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));\n    }\n    else if (mat==5.0) // cage floor\n    {\n        float d=distance(pHit,vec3(0.0));\n        vec3 floorCol=vec3(0.01);\n        vec3 fgcol=fog(floorCol,d,vec3(0.8));\n        finalColor=fgcol.xyz;\n        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));\n    }\n    else if ((iTime<20.0)||(iTime>=70.0)) // cage scene\n    {\n        finalColor=vec3(0.8);\n    }\n    else\n    {\n        if ((iTime>=60.0)&&(iTime<65.0)) finSkyCol=mix(darkSkyColor,skyColor,(65.0-iTime)/5.0);\n        else if (iTime>=65.0) finSkyCol=darkSkyColor;\n        \n        finalColor=finSkyCol+cloudColor*0.85;\n\n        // final fadeout\n        if (iTime>=65.0) finalColor=mix(finalColor,vec3(0.0),clamp((iTime-65.0)/3.0,0.0,1.0));\n    }\n\n    // ghost mode\n    if ((iTime>12.0)&&(iTime<20.0))\n    {\n    \tvec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,1);\n        if (rayHit[1]==1.0)\n        {\n            finalColor+=vec3(NoL)*vec3(0.58,0.12,0.12);\n        }\n    }\n    \n    return vec4(finalColor,-999999.0);    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    screenPos.x=-screenPos.x;\n  \n    vec3 camPos;\n\tvec3 camTarget;\n    float camRot=0.0;\n \n    if (iTime<=20.0)\n    {\n    \tcamPos=vec3(0.0+sin(iTime)*2.0,2.2,(-2.0*3.141592-7.28+iTime*0.8)*cos(iTime*0.19));\n\t\tcamTarget = vec3(0.0,0.7,1.0);\n        if (iTime>12.0) camTarget=vec3(0.0,0.7,iTime-11.0);\n    }\n    else if ((iTime>=20.0)&&(iTime<28.0)) // on clouds\n    {\n        camPos=vec3(0.0,0.5+((27.0-iTime)*0.4),8.0+iTime);\n        camTarget=vec3(0.0,0.7,10.0+iTime);\n        camRot=sin(iTime*0.25)*0.1;\n    }\n    else if ((iTime>=28.0)&&(iTime<36.0)) // plane from bottom vs sky\n    {\n        camPos=vec3(-1.2,-1.8,10.0+iTime);\n        camTarget=vec3(0.0,-1.2,11.0+iTime);\n    }\n    else if ((iTime>=36.0)&&(iTime<44.0)) // upper plane\n    {\n        camPos=vec3(0.0,6.8-((iTime-36.0)/4.0),10.0+iTime);\n        camTarget=vec3(0.0,-1.2,12.0+iTime);\n    }\n    else if ((iTime>=44.0)&&(iTime<52.0)) // plane from below\n    {\n        camPos=vec3(0.0,-2.0,15.0+iTime);\n        camTarget=vec3(0.0,2.5,10.0+iTime);\n    }\n    else if ((iTime>=52.0)&&(iTime<60.0)) // around on water\n    {\n        camPos=vec3(0.0,8.3-(iTime-52.0)*0.5,iTime*10.0);\n        camTarget=vec3(0.0,2.5,8.0+iTime*10.0);\n        camRot=sin(-iTime*0.5)*0.1;\n    }\n    else if ((iTime>=60.0)&&(iTime<65.0))\n    {\n        //camPos=vec3(3.0*sin(-iTime/2.0),5.3-(iTime-35.0)*0.1,3.0*cos(-iTime/4.0)-35.0+iTime*10.0);\n        //camTarget=vec3(0.0,1.5,-33.0+iTime*10.0);\n       \tcamPos=vec3(3.0*sin(-iTime/2.0),5.3-(iTime-35.0)*0.1,3.0*cos(-iTime/4.0)-60.0+iTime*10.0);\n        camTarget=vec3(0.0,1.5,-58.0+iTime*10.0);\n     }\n    else if ((iTime>=65.0)&&(iTime<70.0))\n    {\n        camPos=vec3(2.0*sin(-iTime/2.0),4.3,3.0*cos(-iTime/4.0)+2.0+iTime*10.0);\n        camTarget=vec3(0.0,1.5,iTime*10.0);\n    }\n    else if ((iTime>=70.0))\n    {\n        camPos=vec3(2.0*sin(-iTime/2.0),2.8,1.5*cos(-iTime/4.0)+2.0);\n        camTarget=vec3(0.0,0.0,-0.3);\n    }\n     \n    mat3 ca = setCamera( camPos, camTarget, camRot );\n    vec3 rayDir = ca * normalize( vec3(screenPos.xy,1.5));\n    \n    vec3 outPhit;\n    \n    #ifdef ANTIALIASED\n    vec4 marchCol=vec4(0.0);\n    for (int i=0;i<4;i++)\n    {\n    \tvec3 rayDir = ca * normalize( vec3(screenPos.xy,1.5));\n\t\trayDir.x+=0.001*sin(3.141592*2.0*float(i)/4.0);\n\t\trayDir.y+=0.001*cos(3.141592*2.0*float(i)/4.0);\n    \tmarchCol+=rayMarchCycle(camPos, rayDir,fragCoord,outPhit);\n    }\n    marchCol/=4.0;\n    #else\n    vec4 marchCol=rayMarchCycle(camPos, rayDir,fragCoord,outPhit);\n    #endif\n    \n\tfloat depth = -dot(outPhit - camPos, normalize(camPos - camTarget));\n    float coc = 0.7 * abs(1.0 - length(camPos - camTarget) / depth);\n    vec4 finalCol;\n    if (iTime<6.28) finalCol=vec4(pow(marchCol.rgb,vec3(0.65)),max(0.01, min((6.28-iTime)*0.05, coc)));\n    else finalCol=vec4(pow(marchCol.rgb,vec3(0.65)),0.0001);\n    \n    fragColor = finalCol;\n    \n    if (iTime<2.0) fragColor=mix(vec4(0.0),fragColor,iTime/2.0);\n\tif ((iTime>=18.0)&&(iTime<20.0)) fragColor=mix(fragColor,vec4(1.0),(iTime-18.0)/2.0);\n\tif ((iTime>=20.0)&&(iTime<21.0)) fragColor=mix(vec4(1.0),fragColor,(iTime-20.0));\n\tif ((iTime>=50.0)&&(iTime<52.0)) fragColor=mix(fragColor,vec4(1.0),(iTime-50.0)/2.0);\n\tif ((iTime>=52.0)&&(iTime<53.0)) fragColor=mix(vec4(1.0),fragColor,(iTime-52.0));\n    if (iTime>=80.0) fragColor=mix(fragColor,vec4(0.0),clamp((iTime-80.0)/5.0,0.0,1.0));\n}", "buffer_a_inputs": [], "sound_code": "//\n// supersound\n//\n\nfloat frequencyFromNotenum( float n ) { return 440.0 * pow( 2.0, ( n-49.0) / 12.0 ); }\n\n// pads\n\nfloat pads(float t, float s) \n{\n    return mix(fract(t)*2.0-1.0, -sin(t*2.0*3.141592), s);\n}\n\nfloat phatsaw(float t, float form) {\n    float w = 0.0;\n    for (int i=0;i<4;i++) \n    {\n        w+= pads(t + sin(0.4*float(i))*0.2, form)*0.25;\n    }\n    return w;\n}\n\nfloat pitch(float p) \n{\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\nfloat arp_pattern(float t) \n{\n    int tones[16] = int[](0,0,0,0,12,0,0,0,0,7,0,0,0,12,0,0);\n    float arp = 0.0;\n    float at = t;\n    int arpind = int(at*4.0) % 16;\n    float arpnote = float(tones[arpind]) + 0.0;\n    arp = pow(phatsaw(t*pitch(arpnote), 0.7 + sin(t*.2)*0.1), 3.0);\n    arp *= 0.7*(0.4 + sin(float(arpind)*3.0)*0.1)*max(0.4, -pads(at*6.0, 0.8));\n    return arp;\n}\n\n// saw\n\nvec2 ssaw( float t, float f )\n{\n    float m = fract( t * f );\n    vec2 s = vec2(\n        m + fract( t * f * 1.015 ) + 0.5 * fract( t * f * 0.98 ),\n        m + fract( t * f * 0.985 ) + 0.5 * fract( t * f * 1.02 )\n    );\n    s *= 0.08 * t;\n    return s;\n}\n\nfloat saw(float phase) \n{\n\tfloat s = 0.0;\n \n    for (float k = 1.0; k <= 8.0; k++) \n    {\n        s += (sin(2.0*3.141592*float(k)*phase) / float(k));\n    }\n    \n\treturn (1.0/2.0) - (1.0/3.141592)*s - 0.5;\n}\n\n// pad\n\nvec4 sqc( float time, float tick,float BPM )\n{\n\tvec4 s_t;\n\t\n\tfloat s = mod(floor(time/240.*BPM*float(2)),4.);\n\tfloat t = fract(time/240.*BPM*float(tick));\n\tfloat u = mod( floor( time/240.*BPM*float(tick)),tick );\n\tfloat v = floor(time/240.*BPM);\n\t\n\ts_t.x = s;\n\ts_t.y = t;\n\ts_t.z = u;\n\ts_t.w = v;\n\t\n\treturn s_t;\n}\n\nfloat jappad( float time,float semi,float BPM){\n\tfloat s = 0.0; float semitones[4];\n\tsemitones[0] = 0.0; semitones[1] = 4.0;\n\tsemitones[2] = 7.0; semitones[3] =9.0;\n\n\tconst int VOICES = 4;\n\t\n\t/*float t1 = mod(floor(time/240.*BPM*float(2)),4.);\n\tfloat t2 = fract(time/240.*BPM*float(2));\n\tfloat t3 = 1.0;\n\t*/\n\n    float main_seq[4];\n    if ((time<36.0)||(time>=68.0))\n    {\n\t\tmain_seq[0]=0.,main_seq[1]=0.,main_seq[2]=3.,main_seq[3]=3.;\n    }\n    else if (time<52.0)\n    {\n\t\tmain_seq[0]=5.,main_seq[1]=5.,main_seq[2]=7.,main_seq[3]=7.;\n    }\n    else\n    {\n\t\tmain_seq[0]=-5.,main_seq[1]=-5.,main_seq[2]=-7.,main_seq[3]=-7.;\n    }\n\n\tvec4 sq = sqc(time, .5,BPM);\n\n\tfor (int i = 0 ; i < 4; i++) {\n\t \n\t float q = mod(sq.w,4.);\n\t \n\t\t float f = pitch(semi+main_seq[int(q)]+(semitones[i]));\n\t\t \n\t\t const int UNISON = 8;\n\t\t for (int u = 0; u < UNISON-1; u++) {\n\t\t \n\t\t\t float fu = float(u);\n\t\t\t float new_f = f + fu * sin(fu);\n\t\t\n             float t1=mod(time,16.);\n\t\t\t s += saw(t1 * new_f) * (1.0/float(UNISON))\n\t\t\t * (1./float(VOICES))\n\t\t\t *min(1., sq.y*6.)\n\t\t\t *max(0., 1.5-sq.y)\n\t\t\t ;\n\t\t }\n\t }\n\n\t return s;\n}\n\n// kickkkk\n\nfloat kick(float t)\n{\n\treturn sin(315.*t-10.*exp(-50.*t))*exp(-t*3.0);;\n}\n\n// bazz\n\n// parm1 to 0.5 amd parm2 to 0.9\nvec2 bass(float time, float tt, float freq, float parm1,float parm2)\n{\n    float freqTime = 6.2831*time*freq;\n    parm1=0.5; parm2=0.9;\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(parm1*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(parm2*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\n// hihat\n\nvec2 hihat(float time,float panning)\n{\n    float tb = mod(time,(60.0/120.0)*1.0);\n    float hihat=(fract(cos(time * 32234.523) * 134.) * exp(mod(tb, 1. / 2.0) / 2.0 * -120.)*(fract(tb) + .2));\n\n    float tbr = mod(time+0.135,(60.0/120.0)*1.0);\n    float hihatr=(fract(cos((time+0.135) * 32234.523) * 134.) * exp(mod(tbr, 1. / 2.0) / 2.0 * -120.)*(fract(tbr) + .2));\n    hihat+=hihatr*0.5;\n    \n    float tb2 = mod(time+0.25,(60.0/120.0)*1.0);\n    float hihat2=(fract(cos((time+0.25) * 32234.523) * 134.) * exp(mod(tb2, 1. / 2.0) / 2.0 * -120.)*(fract(tb2) + .2));\n    hihat2*=0.5;\n    return vec2(\n        (hihat*panning)+(hihat2*(1.0-panning)),\n        hihat*(1.0-panning)+hihat2*panning)*.55;\n}\n\n//\n// simple blip with reverb\n//\n\nfloat simpleBlip( float freq, float time )\n{    \n    float y = 0.70*sin(6.2831*freq*time)*exp(-0.009*freq*time);\n    y += 0.20*sin(2.01*6.2831*freq*time)*exp(-0.007*freq*time);\n    y += 0.16*sin(4.01*6.2831*freq*time)*exp(-0.004*freq*time);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\treturn y;\t\n}\n\nvec2 blipArp(float time)\n{\n    int seqNumNotes=8;\n    float noteseq[8]=float[](37.0,42.0,37.0,42.0,42.0,37.0,33.0,16.0);\n\n    time=mod(time*0.5,float(seqNumNotes));\n    vec2 finalSound=vec2(0.0);\n    for (float i=0.0;i<float(seqNumNotes);i++)\n    {\n        if ((time>=i)&&(time<i+2.0)) finalSound+=simpleBlip(frequencyFromNotenum(noteseq[int(i)]),(time-i)*0.5)*vec2(.4,.6);\n    }\n\n\treturn finalSound;\n}\n\nvec2 blipArpHi(float time)\n{\n    int seqNumNotes=8;\n    float noteseq[8]=float[](100.0,96.0,83.0,73.0,83.0,96.0,100.0,96.0);\n\n    time=mod(time*8.0,float(seqNumNotes));\n    vec2 finalSound=vec2(0.0);\n    for (float i=0.0;i<float(seqNumNotes);i++)\n    {\n        if ((time>=i)&&(time<i+2.0)) \n        {\n            finalSound+=simpleBlip(frequencyFromNotenum(noteseq[int(i)]),(time-i)*0.25)*(8.0-i)/16.0;\n        }\n    }\n\n\treturn finalSound;\n}\n\n#define superSaw(note,timestart,timeend)\\\nif ((internalTime>=timestart)&&(internalTime<=timeend))\\\n{\\\n    float decay=1.0;\\\n \tif (internalTime>=(timeend-2.0)) decay=(timeend-internalTime)/2.0;\\\n    finalSound+=ssaw(mod(internalTime-timestart,16.0),frequencyFromNotenum(note))*decay*0.15;\\\n}\\\n    \n// bladerunnerish sound\n    \nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n}\n\nvec2 windRush(float t)\n{\n    vec2 b=bass(10.0-t,(10.0-t)*2.4,frequencyFromNotenum(6.0),0.1,0.012)*1.*nse(t/900.0);\n    if (t>18.0) b*=(20.0-t)/2.1;\n    return b;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 finalSound=vec2(0.0);\n    float internalTime=time;\n\n    // chimes\n\tif ((internalTime>=12.0)&&(internalTime<16.0)) finalSound+=blipArpHi(internalTime-4.0)*(16.0-internalTime)*0.125*vec2((internalTime-12.0)/4.0,(16.0-internalTime)/4.0);\n\tif ((internalTime>=48.0)&&(internalTime<52.0)) finalSound+=blipArpHi(internalTime-4.0)*(52.0-internalTime)*0.125*vec2((internalTime-48.0)/4.0,(52.0-internalTime)/4.0);\n    \n    if ((internalTime>10.0)&&(internalTime<20.0)) finalSound+=windRush(internalTime-10.0)*0.1;\n    if ((internalTime>44.0)&&(internalTime<52.0)) finalSound+=windRush(internalTime-44.0)*0.1;\n\n    // intro saw\n\tsuperSaw(25.0,0.0,7.0);\n\tsuperSaw(51.0,0.0,7.0);\n\tsuperSaw(63.0,6.0,16.0);\n\tsuperSaw(44.0,10.0,18.0);\n\tsuperSaw(30.0,16.0,24.0);\n\n\tsuperSaw(51.0,52.0,58.0);\n\tsuperSaw(53.0,56.0,62.0);\n\n\tsuperSaw(54.0,58.0,64.0);\n\tsuperSaw(56.0,62.0,72.0);\n    \n    if ((internalTime>=20.0)&&(internalTime<68.0))\n    {\n        float arpTime=mod(internalTime,2.0);\n        vec2 arp = vec2(arp_pattern(arpTime), arp_pattern(arpTime-0.03)*0.8);\n        arp += vec2(arp_pattern(arpTime-0.3)*0.3, arp_pattern(arpTime-0.6)*0.2);\n        if (internalTime>=20.6) finalSound+=arp*0.5;\n    }\n\n\tfinalSound += jappad(internalTime, -7.0,120.0)*vec2(.9,.4);\n\tfinalSound += jappad(internalTime+.24, -7.0,120.0)*vec2(.3,.8);\n\tfinalSound += jappad(internalTime+.48, -7.0,120.0)*vec2(.7,.7);\n\n    if (internalTime>=20.0)\n    {\n        float kickTime=mod(internalTime,4.0);\n        if (internalTime<68.0) finalSound+=kick(kickTime)*.3;\n        if ((internalTime<68.0)&&(kickTime>0.25)) finalSound+=kick(kickTime-0.25)*.1;\n\n        float bassTime=mod(internalTime,4.0);\n\n        if ((internalTime>52.0)&&(internalTime<68.0))\n        {\n            finalSound+=bass(bassTime,bassTime *2.4,frequencyFromNotenum(13.0),-2.0,-2.0)*0.3;\n            if (bassTime>2.0) finalSound+=bass(bassTime-2.0,(bassTime-2.0)*2.4,frequencyFromNotenum(6.0),-2.0,-2.0)*0.3;\n        }\n        else if (internalTime<68.0)\n        {\n        \tfinalSound+=bass(bassTime,bassTime *2.4,frequencyFromNotenum(18.0),-2.0,-2.0)*0.3;\n        \tif (bassTime>2.0) finalSound+=bass(bassTime-2.0,(bassTime-2.0)*2.4,frequencyFromNotenum(6.0),-2.0,-2.0)*0.3;\n        }\n    }\n    \n    // hihat\n    if ((internalTime>20.0)&&(internalTime<68.0)) finalSound+=hihat(internalTime,0.25);\n    \n    // blipping arp intro bassline\n    if ((internalTime>=8.0)&&(internalTime<20.0)) finalSound+=blipArp(internalTime);\n    \n    if (internalTime<2.0) finalSound*=internalTime/2.0;\n    \n    if (internalTime>=80.0) finalSound=mix(finalSound,vec2(0.0),clamp((internalTime-80.0)/7.0,0.0,1.0));\n    return finalSound;\n}\n", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 56, 96, 96, 852], [1011, 1011, 1041, 1041, 1403], [1405, 1405, 1461, 1461, 3023]], "test": "untested"}
{"id": "tllcR8", "name": "Random Truchet", "author": "Oggbog", "description": "Random truchet generator", "tags": ["truchet"], "likes": 4, "viewed": 280, "published": 3, "date": "1591464871", "time_retrieved": "2024-07-30T21:02:37.445757", "image_code": "\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n\nvec2 rot(vec2 uv,float a){\n    return uv * mat2(sin(a),-sin(a),sin(a),cos(a));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 6.0;\n    uv += 0.5;\n    \n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n\tfloat n = hash21(id);\n    \n    n = floor(n*4.0);\n    n =  mod(floor(iTime*2.0)+n,4.0);\n   \t\n    if (n==1.0){\n        gv.x *= -1.0;\n    } else if (n==2.0) {\n        gv.y *= -1.0;\n    } else if (n==3.0) {\n        gv.x *= -1.0;\n        gv.y *= -1.0;\n    }\n    \n    \n    \n    float m = smoothstep(gv.x,gv.x + 0.01,gv.y);\n     \n    vec3 col = vec3(m);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 24, 24, 124], [127, 127, 153, 153, 207], [210, 210, 267, 267, 837]], "test": "untested"}
{"id": "wtlcR8", "name": "modified \"Circuit Diagram2\"", "author": "jarble", "description": "I edited [url=https://www.shadertoy.com/view/wtlyR8]ntsutae's \"Circuit Diagram2\" [/url] to make this animation. Surprisingly, it has several moving patterns that resemble \"gliders\" from cellular automata.", "tags": ["xor"], "likes": 27, "viewed": 823, "published": 3, "date": "1591464744", "time_retrieved": "2024-07-30T21:02:38.199742", "image_code": "// \"Circuit Diagram2\" by ntsutae (modified by jarble)\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x);\n  int y = int(fragCoord.y + 30.0 * iTime);\n  int r = (x+y)^(x-y);\n  bool b = abs(r*r*r/(y+x+int(iTime*50.0))) % (9970) < 1000;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 160, 215, 215, 418]], "test": "untested"}
{"id": "wlsyR8", "name": "Shortest Starfield - 79 chars", "author": "GregRostami", "description": "Having some fun with STARS!!\nI wonder if I can make is smaller with a very short noise function.", "tags": ["2d", "stars", "starfield", "short", "onetweet"], "likes": 8, "viewed": 458, "published": 3, "date": "1591464101", "time_retrieved": "2024-07-30T21:02:38.961704", "image_code": "void mainImage(out vec4 o, vec2 u) { o += .004 / texture(iChannel0, u/6e2 + .1*iTime).r; }", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 90]], "test": "untested"}
{"id": "3lsczH", "name": "video temporal statistics", "author": "FabriceNeyret2", "description": "red = temporal mean, green = temporal std-dev, blue = temporal autocorrelation\n( relaxation time Common:relax )", "tags": ["video"], "likes": 8, "viewed": 671, "published": 3, "date": "1591459176", "time_retrieved": "2024-07-30T21:02:39.772537", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n    float  m = O.r/O.a, s = O.b, c = s/m;     // mean, std-dev, autocorrelation\n    O = vec4( sqrt(m), sqrt(s), sqrt(c), 1);  // to sRGB\n  //O = O.zzzz;                               // display autocorrelation only\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O.r = T(U).a;\n    O.g = O.r*O.r;\n    O.a = 1.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float relax = 20. , // relaxation time in frames\n      b = 0.;       // LOD bias\n\n#define R iResolution.xy\n \n#define  T(U) texture(iChannel0,(U)/R, b)\n#define T1(U) texture(iChannel1,(U)/R ,b)\n#define T2(U) texture(iChannel2,(U)/R, b)", "buffer_b_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U.x = R.x-U.x;           // video = mirror\n    O   =  T(U);\n    O.a = dot(O.rgb,O.rgb);  // sRGB to flat\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- compute temporal moments M1,M2 (.rg), and std-dev (.b) \n//     .a = normalization -> mean = .r/.a\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T2(U);\n  //b = 2.;                                    // use LOD input \n  //relax = mix(40., 2., clamp(4.*O.b,0.,1.)); // adaptive integration\n    O = mix( O , T(U), 1./relax );             // relaxation\n    \n    float m =               O.r/O.a,           // temporal mean \n          s = sqrt( max(0., O.g/O.a - m*m ) ); // temporal std dev\n    O.b = s;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 269]], "test": "untested"}
{"id": "3llcRH", "name": "Stretcher", "author": "Oggbog", "description": "Simple stretch and rotate", "tags": ["stretch"], "likes": 1, "viewed": 241, "published": 3, "date": "1591457345", "time_retrieved": "2024-07-30T21:02:40.649192", "image_code": "float circle(vec2 p,float r){\n    float d = length(p);\n    \n    // comment/uncomment lines 6 and 7 for variations\n    \n    //d = abs(smoothstep(r,r+0.05,d)-smoothstep(r - 0.1,r - 0.1 + 0.05,d));\n    d = 1.0-abs(smoothstep(r,r+0.05,d));\n    return d;\n}\n\nvec2 rot(float a, vec2 c){\n    \n    vec2 r = c * mat2(sin(a),-sin(a),sin(a),cos(a));\n    \n    return r;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.5,0.1,0.4);\n    \n    uv = uv * 8.0;\n    uv += 0.5;\n    \n    uv = rot(-iTime,uv);\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    \n    \n    float d = circle(gv,0.5-(abs(id.x+id.y)*sin(iTime*3.0)*0.05+0.5)*0.05);\n    \n    col += d;\n\tcol *= vec3(0.6,0.4,0.8);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 251], [253, 253, 279, 279, 363], [366, 366, 423, 423, 824]], "test": "untested"}
{"id": "3llyzH", "name": "BVH bokeh II", "author": "michael0884", "description": "Made some visual improvements.\nHDR tonemapping, faster particles and a perspective camera. Now it can be used as a background for a random vlog =)", "tags": ["raytracing", "volume", "hierarchy", "bounded"], "likes": 17, "viewed": 516, "published": 3, "date": "1591452639", "time_retrieved": "2024-07-30T21:02:42.010553", "image_code": "// Fork of \"BVH bokeh\" by rory618. https://shadertoy.com/view/ttXyR8\n// 2020-06-06 13:50:06\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nvec4 F(vec2 p, vec2 r)\n{\n    vec4 t = texture(iChannel2, (p+r)/R.xy);\n    return 0.005*exp(-.03*dot(r,r))*(exp(2.*t)-1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    O = max(texture(iChannel2, I/R.xy), 0.);\n    for (float i = 0.; i < 7.; i+=1.1) {\n    \tO += F(I,+vec2(-i,i));\n    \tO += F(I,+vec2(i,i));\n    \tO += F(I,-vec2(-i,i));\n    \tO += F(I,-vec2(i,i));\n    }\n    O.xyz = HDRmapping(O.xyz,3.);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "getters}\n\n//Generate random particles each frame, and use a pipelined bitonic sorting network to arrange them in a list\n//so that they are in ascending order along a z curve covering uv space, saving the xy coordinate at each step.\n\n//Get the partner to be compared with for a bitonic sort at a given stage\n//See https://en.wikipedia.org/wiki/Bitonic_sorter#Alternative_representation\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n\n//Combine two bounding boxes, return null bbox if one of the bboxes is also null\nBBox mergeBBox(BBox A, BBox B){\n    if((A.a==vec3(0) && A.b==vec3(0)) || (B.a==vec3(0) && B.b==vec3(0)) ){\n        return BBox(vec3(0),vec3(0));\n    }\n    return BBox(min(A.a,B.a), max(A.b,B.b) );\n}\n\nvoid mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    ivec2 XYTall = ivec2(XYFace.x, XYFace.y + 1024*XYFace.z);\n    int index = XYTall.x*16 + (XYTall.y%16);\n    if(XYTall.y < 16){\n        /*int seed = XYFace.x + XYFace.y*2000;// + iFrame*2000*2000;\n        seed = IHash(seed);\n        vec3 coord = rand3(seed);\n        coord = mix(coord,normalize(coord-.5)/2.5+.5,.9);\n        \n        coord-=.5;\n        coord.xz = mat2(coord.xz,-coord.z,coord.x) * vec2(cos(iTime/10.), sin(iTime/10.));\n        coord.xz = mat2(coord.xz,-coord.z,coord.x) * vec2(cos(iTime/10.), sin(iTime/10.));\n        coord+=.5;*/\n        vec4 coord = texelFetch(iChannel2, ivec2(index/128,index%128),0);\n        //coord.x=coord.z;\n        O = (coord);\n    } else  {\n        int stage = XYTall.y/16;\n        int sortStage = stage - 1;\n        if(stage<106){\n        \t//Execute the sorting network swaps\n            int partner = getPartner(index,sortStage);\n            vec4 A = sampleIndexStage(index, stage-1);\n            vec4 B = sampleIndexStage(partner, stage-1);\n            int zA = ZOrder(A.xyz);\n            int zB = ZOrder(B.xyz);\n            if(index > partner){\n                if(zA>zB){\n                    O=A;\n                } else {\n                    O=B;\n                }\n            } else {\n                if(zA>zB){\n                    O=B;\n                } else {\n                    O=A;\n                }\n            }\n        } else if(stage==BVHStage0){\n            //Fetch the BVH graph from buf A\n            vec4 A = texelFetch(iChannel1, ivec2(index%128, index/128), 0);\n            int childLeft = int(A.z);\n            int childRight = int(A.w);\n            //Pack a 15 bit integer into a pair of cubemap channels\n            O = vec4(childLeft%128,childLeft/128,childRight%128,childRight/128);\n        } else if(stage>=BBoxStage0){\n            //Compute the bounding boxes from leaf nodes upwards towards the root node\n            int BBoxStage = (stage - BBoxStage0)/2;\n            int substage = (stage - BBoxStage0)%2;\n            BBox bbox = BBox(sampleIndexStage(index, BBoxStage0+BBoxStage*2-2).xyz,\n                             sampleIndexStage(index, BBoxStage0+BBoxStage*2-1).xyz);\n            if((bbox.a==vec3(0) && bbox.b==vec3(0)) || BBoxStage==0){\n                vec4 node = sampleIndexStage(index, BBoxStage+BVHStage0);\n\n                int childLeft = int(node.x) + int(node.y)*128;\n                int childRight = int(node.z) + int(node.w)*128;\n\n                BBox bboxLeft = BBox(vec3(0),vec3(0));\n                BBox bboxRight =BBox(vec3(0),vec3(0));\n                \n                if(BBoxStage!=0){\n                    \n                     bboxLeft = BBox(sampleIndexStage(childLeft, BBoxStage0+BBoxStage*2-2).xyz,\n                                     sampleIndexStage(childLeft, BBoxStage0+BBoxStage*2-1).xyz);\n                \tbboxRight = BBox(sampleIndexStage(childRight, BBoxStage0+BBoxStage*2-2).xyz,\n                                     sampleIndexStage(childRight, BBoxStage0+BBoxStage*2-1).xyz);\n                }\n\n                //Particle 'nodes' are indexed starting from 16384. Make a 1x1 bounding box if its a particle\n                if(childLeft>=16384){\n                    childLeft -= 16384;\n                    vec4 data = sampleIndexStage(childLeft, sortedStage+BBoxStage+1);\n                    bboxLeft = leafToBBox(data);\n                }\n                if(childRight>=16384){\n                    childRight -= 16384;\n                    vec4 data = sampleIndexStage(childRight, sortedStage+BBoxStage+1);\n                    bboxRight = leafToBBox(data);\n                }\n                bbox = mergeBBox(bboxLeft, bboxRight);\n            } else {\n                //bbox.a -= sin(iTime*4. + float(index)/7e2)/1e4;\n                //bbox.b += sin(iTime*4. + float(index)/7e2)/1e4;\n            }\n            O.xyz = substage==0?bbox.a:bbox.b;\n        } else {\n            //Keep shifting the result down so that JFA pipeline always can find the particles\n            O = sampleIndexStage(index, stage-1);\n        }\n        \n    }\n    \n    \n}\n    \n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\n\n\n\nconst float dMin = 1e3;\nconst int sortedStage = 106;\nconst int BBoxStages = 70;\nconst int BVHStage0 = sortedStage+BBoxStages;\nconst int BBoxStage0 = BVHStage0+BBoxStages;\nconst int BBoxStageFinal = BBoxStage0 + BBoxStages - 3;\n\nstruct BBox {\n    vec3 a;\n    vec3 b;\n};\n    \n    \n\nbool inBBox(BBox bbox, vec3 p){\n    return (p.x>bbox.a.x && p.y>bbox.a.y && p.z>bbox.a.z && \n            p.x<bbox.b.x && p.y<bbox.b.y && p.z<bbox.b.z);\n}\nvec2 rayBox(BBox bbox, vec3 p, vec3 rdir){\n    if(inBBox(bbox,p)) return vec2(0.);\n    vec3 tMin = (bbox.a - p) / rdir;\n    vec3 tMax = (bbox.b - p) / rdir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if(tNear>tFar || tNear < 0.) return vec2(1e9); else return vec2(length(rdir*tNear),length(rdir*tFar));\n}\n\n\n//Treating aabb as a sphere is faster overall\nbool PointIntersectsCone(vec3 P0, vec3 cone_o,vec3 cone_d,float cone_a){\n    \n    float g = abs(dot(normalize(cone_d), normalize(P0-cone_o)));\n    return (acos(g)<cone_a);\n    /*\n    P0 -= cone_o;\n    vec3 U = normalize(cone_d);\n\tfloat cone_cosAngle = cos(cone_a);\n    \n    // Test whether P0 or P1 is inside the cone.\n    float g = dot(U, P0) - cone_cosAngle * length(P0);\n    if (g > 0.)\n    {\n        // X0 = P0 + V is inside the cone.\n        return true;\n    }*/\n}\n\nbool LineIntersectsCone(vec3 P0, vec3 P1, vec3 cone_o,vec3 cone_d,float cone_a){\n    // Define F(X) = Dot(U,X - V)/|X - V|, where U is the unit-length\n    // cone axis direction and V is the cone vertex.  The incoming\n    // points P0 and P1 are relative to V; that is, the original\n    // points are X0 = P0 + V and X1 = P1 + V.  The segment <P0,P1>\n    // and cone intersect when a segment point X is inside the cone;\n    // that is, when F(X) > cosAngle.  The comparison is converted to\n    // an equivalent one that does not involve divisions in order to\n    // avoid a division by zero if a vertex or edge contain (0,0,0).\n    // The function is G(X) = Dot(U,X-V) - cosAngle*Length(X-V).\n    P0 -= cone_o;\n    P1 -= cone_o;\n    vec3 U = cone_d;\n\tfloat cone_cosAngle = cos(cone_a);\n\n    // Test whether an interior segment point is inside the cone.\n    vec3 E = P1 - P0;\n    vec3 crossP0U = cross(P0, U);\n    vec3 crossP0E = cross(P0, E);\n    float dphi0 = dot(crossP0E, crossP0U);\n    vec3 crossP1U = cross(P1, U);\n    float dphi1 = dot(crossP0E, crossP1U);\n    float t = dphi0 / (dphi0 - dphi1);\n    vec3 PMax = P0 + t * E;\n            float g = dot(U, PMax) - cone_cosAngle * length(PMax);\n\n    return (dphi0 > 0.) && (dphi1 < 0.) && (g > 0.);\n}\n\nbool BBoxIntersectsCone(BBox b, vec3 cone_o,vec3 cone_d,float cone_a){\n    \n    vec3 mp = (b.a+b.b)/2.;\n    float g = dot(normalize(cone_d), normalize(mp-cone_o));\n    //if(g<0.) return false;\n    float a = acos(g)-cone_a;\n    if(a<0.) return true;\n    return length(mp-cone_o)*sin(a)<length(mp-b.a);\n    \n    \n    \n    \n    /*if(rayBox(b,cone_o,cone_d).x < 1e8){return true;}\n    vec3 A = vec3(b.a.x,b.a.y,b.a.z);\n    vec3 B = vec3(b.a.x,b.a.y,b.b.z);\n    vec3 C = vec3(b.a.x,b.b.y,b.a.z);\n    vec3 D = vec3(b.a.x,b.b.y,b.b.z);\n    vec3 E = vec3(b.b.x,b.a.y,b.a.z);\n    vec3 F = vec3(b.b.x,b.a.y,b.b.z);\n    vec3 G = vec3(b.b.x,b.b.y,b.a.z);\n    vec3 H = vec3(b.b.x,b.b.y,b.b.z);\n    int k = 0;\n    if(PointIntersectsCone(A,cone_o,cone_d,cone_a)) return true;\n    if(PointIntersectsCone(B,cone_o,cone_d,cone_a)) return true;\n    if(PointIntersectsCone(C,cone_o,cone_d,cone_a)) return true;\n    if(PointIntersectsCone(D,cone_o,cone_d,cone_a)) return true;\n    if(PointIntersectsCone(E,cone_o,cone_d,cone_a)) return true;\n    if(PointIntersectsCone(F,cone_o,cone_d,cone_a)) return true;\n    if(PointIntersectsCone(G,cone_o,cone_d,cone_a)) return true;\n    if(PointIntersectsCone(H,cone_o,cone_d,cone_a)) return true;\n    return false;\n    if(LineIntersectsCone(A,B,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(B,D,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(D,C,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(C,A,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(E,F,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(F,H,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(H,G,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(F,E,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(A,E,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(B,F,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(C,G,cone_o,cone_d,cone_a)) return true;\n    if(LineIntersectsCone(D,H,cone_o,cone_d,cone_a)) return true;\n    return false;*/\n}\nBBox unpackBBox(vec4 data){\n    uint A = packHalf2x16(data.xy);\n    uint B = packHalf2x16(data.zw);\n    \n    uint a = A & 0x00007FFFu;\n    uint b = (A & 0x7FFF0000u) >> 16;\n    uint c = B & 0x00007FFFu;\n    uint d = (B & 0x7FFF0000u) >> 16;\n    \n    \n    uint x0 = a & 0x3FFu;\n    uint y0 = (a >> 10) | ((b & 0x1Fu) << 5);\n    uint z0 = (b & 0x7FE0u) >> 5;\n    \n    uint x1 = c & 0x3FFu;\n    uint y1 = (c >> 10) | ((d & 0x1Fu) << 5);\n    uint z1 = (d & 0x7FE0u) >> 5;\n    \n    x0 &= 0x3FEu;\n    x1 &= 0x3FEu;\n    y0 &= 0x3FEu;\n    y1 &= 0x3FEu;\n    z0 &= 0x3FEu;\n    z1 &= 0x3FEu;\n    \n    return BBox((vec3(x0,y0,z0))/1024.,(vec3(x1,y1,z1))/1024.);\n}\n\nvec4 packBBox(BBox bbox){\n    uint x0 = uint(bbox.a.x*1024.);\n    uint y0 = uint(bbox.a.y*1024.);\n    uint z0 = uint(bbox.a.z*1024.);\n    \n    uint x1 = uint(bbox.b.x*1024.);\n    uint y1 = uint(bbox.b.y*1024.);\n    uint z1 = uint(bbox.b.z*1024.);\n    \n    \n    x0 &= 0x3FEu;\n    x1 &= 0x3FEu;\n    y0 &= 0x3FEu;\n    y1 &= 0x3FEu;\n    z0 &= 0x3FEu;\n    z1 &= 0x3FEu;\n    \n    uint a = x0 | ((y0 & 0x1Fu)<<10);\n    uint b = y0 >> 5 | z0 << 5;\n    uint c = x1 | ((y1 & 0x1Fu)<<10);\n    uint d = y1 >> 5 | z1 << 5;\n    \n    uint A = a | (b << 16);\n    uint B = c | (d << 16);\n    \n    return vec4(unpackHalf2x16(A),unpackHalf2x16(B));\n}\n\nBBox leafToBBox(vec4 data){\n    vec3 point = data.xyz;\n    return BBox(floor(point*1024.)/1024.,(floor(point*1024.)+1.)/1024.);\n}\n\n//Line segment sdf\nfloat dLine(vec2 p, vec2 a, vec2 b){\n    p-=a;\n    b-=a;\n    float l2 = dot(b,b);\n    p -= b*clamp(dot(p,b/l2),0.,1.);\n    return length(p);\n}\n\n\n//Magic to convert a binary number 0xbbbb into 0x00b00b00b00b\nint spreadBits(int x){\n    x = (x | (x << 16)) & 0x030000FF;\n    x = (x | (x <<  8)) & 0x0300F00F;\n    x = (x | (x <<  4)) & 0x030C30C3;\n    x = (x | (x <<  2)) & 0x09249249;\n    return x;\n}\n\n//Convert a 0-1 xy coordinate to a 20 bit morton/z order code\nint ZOrder(vec3 coord){\n    int x = int(coord.x*1024.);\n    int y = int(coord.y*1024.);\n    int z = int(coord.z*1024.);\n    return spreadBits(x) | (spreadBits(y)<<1) | (spreadBits(z)<<2);\n}\n    \n//Random number functions\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n   \n//Cubemap utils to convert between a 1024 x 1024 x 6 buffer coordinate to a cubemap ray direction\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n\n//Functions to sample a particle coordinate from the cubemap as a 1024 x 6144 buffer and a 16384 x 384 buffer\n#define getters \\\nvec4 sampleXYTall(ivec2 XYTall){\\\n    ivec3 XYFace = ivec3(XYTall.x, XYTall.y%1024, XYTall.y/1024);\\\n\treturn texture(iChannel0, XYFaceToRayDir(XYFace));\\\n}\\\nvec4 sampleIndexStage(int index, int stage){\\\n    ivec2 XYTall = ivec2(index/16, index%16+stage*16);\\\n    return sampleXYTall(XYTall);", "buffer_a_code": "getters}\n\n//Length of the shared prefix of the morton codes of a pair of particles.\n//If the codes are the same, then also count shared bits of the list index which will never be the same.\n//Return -1 if the j particle is outside the range of all particles\nint plen(int i, int j){\n    if(j<0||j>=16384) return -1;\n    int mi = ZOrder(sampleIndexStage(i, sortedStage).xyz);\n    int mj = ZOrder(sampleIndexStage(j, sortedStage).xyz);\n    if(mi!=mj){\n        int x = mi^mj;\n        float f = log2(float(x)+0.5);\n        return 32 - int(f);\n    } else {\n        int x = i^j;\n        float f = log2(float(x)+0.5);\n        return 64 - int(f);\n    }\n}\n        \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //index always indicates either the left or right end of the range of particle indecies it contains\n    int i = int(I.x) + int(I.y)*128;\n    \n    //Check direction if this node\n    int d = sign(plen(i,i+1)-plen(i,i-1));\n    \n    //Scan to find the other end of this node, so that all the nodes share a prefix at least \n    //as long as the shared prefix between the first two elements\n    //Scan away to find an upper bound\n    int dmin = plen(i,i-d);\n    int lmax = 2;\n    for(int k = 0; k<16; k++){\n        if (plen(i, i + lmax*d) <= dmin)\n            break;\n        lmax *= 2;\n    }\n    \n    //Scan back with a binary search\n    int l = 0;\n    int t = lmax/2;\n    for(int k = 0; k<16; k++){\n        if (plen(i, i + (l+t)*d) > dmin){\n            l = l+t;\n        }\n        if(t==1) break;\n        t /= 2;\n        \n    }\n    //Compute the other end of the range of particle indecies this node contains\n    int j = i + l * d;\n\n    //Find the split index where the nodes on one side share a different longes prefix from the other\n    int dnode = plen(i, j);\n    int s = 0;\n    float ft = float(l)/2.;\n    for(int k = 0; k<16; k++){\n        t = int(max(1.,ceil(ft)));\n        if(plen(i, i + (s + t) * d ) > dnode){\n            s += t;\n        }\n        ft /= 2.;\n    }\n    //Compute split index\n    int y = i + s * d + min(d,0);\n    \n    //Compute the child node indecies using the split index y and two ends i and j\n    int childLeft;\n    int childRight;\n    if (min(i,j) == y) {\n        childLeft = y + 16384;\n    } else {\n        childLeft = y;\n    }\n    if (max(i,j) == y+1){\n        childRight = (y+1) + 16384;\n    } else {\n        childRight = y+1;\n    }\n    \n    //Safe the left index and right index (just for testing), as well as left and right child nodes\n    O = vec4(min(i,j),max(i,j),childLeft,childRight);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Draw 16 thousand volumes around a sphere\n//See:\n//https://www.shadertoy.com/view/WssfDn\n//https://www.shadertoy.com/view/Wdlfz7\n//https://www.shadertoy.com/view/tdlBz7\n//https://www.shadertoy.com/view/wdsBRn\n//for all the utilities and algorithm leading up to this,\n//and the paper: https://devblogs.nvidia.com/wp-content/uploads/2012/11/karras2012hpg_paper.pdf\n\ngetters}\n\nconst float eps = 1e-1;\n\n// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define angle 0.04\n\nvec4 DFS(vec3 p, vec3 rd){\n    int count = 0;\n    int[] stack_data = int[] (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    float[] stack_d = float[] (0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    int stack_pos = -1;\n    int v = 0;\n    float fd = length(rd);\n    \n    #define pop() stack_data[stack_pos--]\n    #define push(data)  stack_data[++stack_pos] = data\n    \n    int node = 0;\n    BBox bbox = BBox(sampleIndexStage(node, BBoxStageFinal+BBoxStages-2).xyz,\n                     sampleIndexStage(node, BBoxStageFinal+BBoxStages-3).xyz);\n    float d = 1e8;\n    vec3 c = vec3(0);\n    count++;\n    for(int k = 0; k < 6000; k++){\n        vec4 node_data = sampleIndexStage(node, BBoxStageFinal-BBoxStages+1);\n        \n        \n        int childLeft = int(node_data.x) + int(node_data.y)*128;\n        int childRight = int(node_data.z) + int(node_data.w)*128;\n        bool leafLeft = childLeft >= 16384;\n        bool leafRight = childRight >= 16384;\n        \n        \n        vec4 pDataLeft = sampleIndexStage(childLeft & 16383, leafLeft?sortedStage+BBoxStages-1:BBoxStageFinal+BBoxStages-2);\n        vec4 pDataRight = sampleIndexStage(childRight & 16383, leafRight?sortedStage+BBoxStages-1:BBoxStageFinal+BBoxStages-2);\n        vec4 pDataLeftB = sampleIndexStage(childLeft & 16383, leafLeft?sortedStage+BBoxStages-1:BBoxStageFinal+BBoxStages-3);\n        vec4 pDataRightB = sampleIndexStage(childRight & 16383, leafRight?sortedStage+BBoxStages-1:BBoxStageFinal+BBoxStages-3);\n        \n        BBox bboxLeft = BBox(pDataLeft.xyz,pDataLeftB.xyz);\n        BBox bboxRight = BBox(pDataRight.xyz,pDataRightB.xyz);\n        if(leafLeft){ bboxLeft = leafToBBox(pDataLeft); }\n        if(leafRight){ bboxRight = leafToBBox(pDataRight); }\n        \n        \n        bool validLeft = BBoxIntersectsCone(bboxLeft, p+rd/2., rd, angle);\n        bool validRight = BBoxIntersectsCone(bboxRight, p+rd/2., rd, angle);\n        \n        /*\n        if(validLeft){\n        \tfloat g = -1.+cos(iTime*4. + float(childLeft)/7e2);\n        \tc += 4e-6;\n        }\n        if(validRight){\n        \tfloat g = -1.+cos(iTime*4. + float(childRight)/7e2);\n        \tc += 4e-6;\n        }\n        */\n        count += int(validLeft);\n        count += int(validRight);\n        validLeft = validLeft && (!leafLeft);\n        validRight = validRight && (!leafRight);\n        \n        vec4 pData;\n        \n        if(leafLeft){\n           pData = pDataLeft;\n        }\n        if(leafRight){\n            pData = pDataRight;\n        }\n        \n        float l = max(.03,abs(length(p-pData.xyz)-fd));\n\t\tvec3 color = hsv2rgb(vec3(pData.w, 1.,abs(4.*cos(10.*pData.w))));\n        c += .0003/l/l*float( PointIntersectsCone(pData.xyz, p+rd, rd, angle) || PointIntersectsCone(pData.xyz, p, rd, 2./R.x)) \n            * color;\n        \n        if(validRight){\n            if(validLeft){\n                push(childRight);\n                node = childLeft;\n            } else {\n                //Go right\n                node = childRight;\n            }\n        } else {\n            if(validLeft){\n                //Go left\n                node = childLeft;\n            } else {\n                //Go up stack\n                if(stack_pos >= 0){\n                    node = pop();\n                } else {\n                    return vec4(c,0);\n                }\n            }\n        }\n    }\n        \n    return vec4(c,1);\n}\n\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\n#define FOV 1.5\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    //Dot Dot Dot while pipeline fills up\n    if(iFrame<BVHStage0){\n        float fracDone = float(iFrame) / float(BVHStage0);\n        vec2 c = mod(I,R.xy/vec2(3,1));\n        O = vec4(min(1.,R.x/30.-length(c-R.xy/vec2(6,2))));\n        O *= .25+.75*vec4(I.x/R.x<floor(fracDone*4.)/3.);\n    } else {\n        vec2 uv = (I-R.xy/2.)/R.y;\n        \n        float p = (iMouse.y/R.y*2.-1.)*3.14/2.;\n        float y = (iMouse.x/R.x*2.-1.)*3.14 + iTime/4.;\n        vec2 angles = vec2(y, p);\n        \n        vec3 r0 = 0.5 -1.*getRay(angles, vec2(0.));\n        vec3 rd = getRay(angles, uv)/1.4;\n       \n        O = DFS(r0,rd);\n    }\n    /*\n    vec3 ba = vec3(iMouse.zw/R.xy,.1);\n    vec3 bb = vec3(iMouse.xy/R.xy,.9);\n    \n    ba = floor(ba*1024.+.5)/1024.;\n    bb = floor(bb*1024.+.5)/1024.;\n    \n    BBox b = BBox(ba,bb);\n    BBox x = unpackBBox(packBBox(b));\n    O = vec4(inBBox(x, vec3(I/R.xy,.5)));*/\n}", "buffer_b_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define pi 3.1415\nvec3 sbf(vec3 c, vec3 w, float s){\n    //float x = sin(pi*c.x*w.x) * cos(pi*c.y*w.y) * cos(pi*c.z*w.z);\n    //float y = sin(pi*c.y*w.y) * cos(pi*c.z*w.z) * cos(pi*c.x*w.x);\n    //float z = sin(pi*c.z*w.z) * cos(pi*c.x*w.x) * cos(pi*c.y*w.y);\n    vec3 k = sin(pi*c*w) * cos(pi*c.yzx*w.yzx) * cos(pi*c.zxy*w.zxy);\n    k = mix(k, k* cross(normalize(w), normalize(vec3(2,4,1))), s);\n    return 10.*k;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    if(iFrame<3){\n       int seed = int(I.x) + 2000*int(I.y);// + iFrame*2000*2000;\n        seed = IHash(seed);\n        vec3 coord = rand3(seed);\n        coord = mix(coord,normalize(coord-.5)/2.5+.5,.9);\n        O.xyz = coord;\n        O.w = dot(sin(6.*coord*vec3(4,5,6)),vec3(1));\n    } else{\n        O = texture(iChannel0, I/R.xy);\n        O.xyz += sbf(O.xyz,vec3(3,3 ,3) ,.8 + .2*abs(sin(iTime/4.)))/1300.  *(2.+cos(iTime*.4));\n        O.xyz += sbf(O.xyz,vec3(1,23,1), .8 + .2*abs(sin(iTime/4.)))/1445. *(2.+sin(iTime*.5));\n        O.xyz += sbf(O.xyz,vec3(3,12,5), .8 + .2*abs(sin(iTime/4.)))/753.*(2.+sin(iTime*.65));\n        O.xyz += sbf(O.xyz,vec3(4,7 ,1) ,.8 + .2*abs(sin(iTime/4.)))/1725.  *(2.+cos(iTime*.67));\n        O.xyz -= sbf(O.xyz,vec3(100,100 ,100) ,.8 + .2*abs(sin(iTime/4.)))/2034. *(2.+cos(iTime*.87));\n        O.xyz -= sbf(O.xyz,vec3(1,4 ,4) ,.8 + .2*abs(sin(iTime/4.)))/3646. *(2.+sin(iTime*.9));\n        O.xyz += sbf(O.xyz,vec3(1,9 ,3) ,.8 + .2*abs(sin(iTime/4.)))/2420. *(2.+cos(iTime*.3));\n        O.xyz = clamp(O.xyz,vec3(0), vec3(1));\n        O.xyz = mix(O.xyz, vec3(.5), .0003);\n    }\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 117, 117, 257], [259, 259, 304, 330, 444], [446, 446, 470, 470, 569], [571, 571, 612, 612, 853]], "test": "untested"}
{"id": "WdjfDG", "name": "Isosurface with SSS", "author": "tmst", "description": "- Subsurface scattering (SSS) through any level surface (see fDensity in Common)\n- First pass computes light penetration to each voxel; second pass hits level surface and emits that light\n- Inputs: Mouse, ASDF (SSS debug, disable SSS, normal debug, depth)", "tags": ["sss", "mandelbulb", "voxel", "volumetric", "scattering", "subsurface"], "likes": 113, "viewed": 2672, "published": 3, "date": "1591441709", "time_retrieved": "2024-07-30T21:02:43.120585", "image_code": "#define CUBE_SAMPLER iChannel0\n#define SKY_SAMPLER iChannel1\n#define IMAGE_SAMPLER iChannel2\n#define BLUR_V_SAMPLER iChannel3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float dCorner = length(vec2(0.5) - uv) * SQRT2;\n    float vignetteFactor = mix(1.0, 0.6, smoothstep(0.3, 0.9, dCorner));\n    \n    vec3 finalRGB;\n    if (INITIALIZING) {\n        finalRGB = mainRender(CUBE_SAMPLER, SKY_SAMPLER, iResolution, iMouse, fragCoord, ITIME).rgb;\n    } else {\n        vec4 data = textureLod(IMAGE_SAMPLER, uv, 0.0);\n        vec3 rgbBlur = blurH(BLUR_V_SAMPLER, uv);\n        finalRGB = mix(data.rgb, rgbBlur, clamp(data.a, 0.05, 1.0));\n    }\n\n    fragColor = vec4(vignetteFactor*finalRGB, 1.0);\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ITIME iTime\n#define INITIALIZING (iFrame < 3)\n\n// ===========\n// References\n// ===========\n\n// Keyboard input:\n// - https://www.shadertoy.com/view/lsXGzf (iq: \"Input - Keyboard\")\n// Colormap:\n// - https://www.shadertoy.com/view/ll2GD3 (iq: \"Palettes\")\n// Hash functions:\n// - https://www.shadertoy.com/view/4djSRW (Dave_Hoskins: \"Hash without Sine\")\n// Mandelbulb DE:\n// - https://www.shadertoy.com/view/wl2SDt (loicvdb: \"Filmic mandelbulb animation\")\n\n// ==========================\n// Generic Helpers/Constants\n// ==========================\n\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define PI_OVER_4 0.7853981633974483\n#define SQRT2 1.414213562373095\n#define SQRT3 1.732050807568877\n#define INV_SQRT_2 0.7071067811865476\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\n// #define IR_LIQUID 1.333\n// #define IR_AIR 1.000\n// SCHLICK_R0 = pow((IR_LIQUID-IR_AIR)/(IR_LIQUID+IR_AIR), 2.0)\n#define SCHLICK_R0 0.02040816326530612\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat len3Inf(vec3 v) {\n    vec3 d = abs(v);\n    return max(d.x, max(d.y, d.z));\n}\n\nvoid boxClip(\n    in vec3 boxMin, in vec3 boxMax,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out bool didHit\n){\n    //for each coord, clip tRange to only contain t-values for which p+t*v is in range\n    vec3 tb0 = (boxMin - p) / v;\n    vec3 tb1 = (boxMax - p) / v;\n    vec3 tmin = min(tb0, tb1);\n    vec3 tmax = max(tb0, tb1);\n\n    //t must be > tRange.s and each tmin, so > max of these; similar for t1\n    tRange = vec2(\n        max(max(tmin.x, tmin.y), tmin.z),\n        min(min(tmax.x, tmax.y), tmax.z)\n    );\n\n    //determine whether ray intersects the box\n    didHit = step(tRange.s, tRange.t) > 0.5;\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define PAL(t, a, b, c, d) ( a + b*cos(TWOPI*(c*t+d)) )\nvec3 colormap(float t) {\n    return PAL(t, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67));\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip) {\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\n// ======================\n// Voxel packing helpers\n// ======================\n\n#define BOX_MIN vec3(-1.0)\n#define BOX_MAX vec3(1.0)\n#define BOX_CENTER vec3(0.0)\n#define BOX_N 128.0\n\nvec3 lmnFromWorldPos(vec3 p) {\n    vec3 uvw = (p - BOX_MIN) / (BOX_MAX - BOX_MIN);\n    return uvw * vec3(BOX_N-1.0);\n}\n\nvec3 worldPosFromLMN(vec3 lmn) {\n    return mix(BOX_MIN, BOX_MAX, lmn/(BOX_N-1.0));\n}\n\n// Data is organized into 3 \"pages\" of 128x128x128 voxels.\n// Each \"page\" takes up 2 faces of the 1024x1024 cubemap,\n// each face storing 8x8=64 of the 128x128 slices.\n\nvec3 vcubeFromLMN(in int page, in vec3 lmn) {\n    // subtexture within [0,8)^2\n    float l = mod(round(lmn.x), 128.0);\n    float tm = mod(l, 8.0);\n    float tn = mod((l - tm)/8.0, 8.0);\n    vec2 tmn = vec2(tm, tn);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(round(lmn.yz), 128.0);\n\n    // pixel position on 1024x1024 face\n    vec2 fragCoord = 128.0*tmn + mn + 0.5;\n    vec2 p = fragCoord*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else {\n        fv = fv = vec3(p, 1.0);\n    }\n\n    return l < 64.0 ? fv : -fv;\n}\n\nvoid lmnFromVCube(in vec3 vcube, out int page, out vec3 lmn) {\n    // page and parity, and pixel position on 1024x1024 texture\n    vec2 p;\n    float parity;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        page = 1;\n        p = vcube.yz/vcube.x;\n        parity = vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        page = 2;\n        p = vcube.xz/vcube.y;\n        parity = vcube.y;\n    } else {\n        page = 3;\n        p = vcube.xy/vcube.z;\n        parity = vcube.z;\n    }\n    vec2 fragCoord = floor((0.5 + 0.5*p)*1024.0);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(fragCoord, 128.0);\n\n    // subtexture within [0,8)^2\n    vec2 tmn = floor(fragCoord/128.0);\n\n    float lAdd;\n    if (parity > 0.0) {\n        lAdd = 0.0;\n    } else {\n        lAdd = 64.0;\n    }\n    lmn = vec3(tmn.y*8.0 + tmn.x + lAdd, mn);\n}\n\n// =============\n// Blur helpers\n// =============\n\n#define BLUR_D 0.0025\n#define CBLUR(offset) textureLod(src, uv+offset, 2.0).rgb\n\nvec3 blurV(vec3 iResolution, sampler2D src, vec2 uv) {\n    float blurD = BLUR_D * iResolution.x/iResolution.y;\n    return (\n        0.006 * CBLUR(vec2(0.0, -3.0*blurD)) +\n        0.061 * CBLUR(vec2(0.0, -2.0*blurD)) +\n        0.242 * CBLUR(vec2(0.0, -1.0*blurD)) +\n        0.383 * CBLUR(vec2(0.0,  0.0*blurD)) +\n        0.242 * CBLUR(vec2(0.0,  1.0*blurD)) +\n        0.061 * CBLUR(vec2(0.0,  2.0*blurD)) +\n        0.006 * CBLUR(vec2(0.0,  3.0*blurD))\n    );\n}\n\nvec3 blurH(sampler2D src, vec2 uv) {\n    return (\n        0.006 * CBLUR(vec2(-3.0*BLUR_D, 0.0)) +\n        0.061 * CBLUR(vec2(-2.0*BLUR_D, 0.0)) +\n        0.242 * CBLUR(vec2(-1.0*BLUR_D, 0.0)) +\n        0.383 * CBLUR(vec2( 0.0*BLUR_D, 0.0)) +\n        0.242 * CBLUR(vec2( 1.0*BLUR_D, 0.0)) +\n        0.061 * CBLUR(vec2( 2.0*BLUR_D, 0.0)) +\n        0.006 * CBLUR(vec2( 3.0*BLUR_D, 0.0))\n    );\n}\n\n// ===================\n// Density definition\n// ===================\n\n// Density value for level surface\n#define D_SURF 0.5\n\n#define MAX_ALPHA_PER_UNIT_DIST 8.0\n#define QUIT_ALPHA_L 0.99\n\n#define RAY_STEP 0.0125\n#define RAY_STEP_L 0.04\n\n#define CAM_THETA(t) (0.2*t)\n#define CAM_PHI(t) (HALFPI - 0.3)\n#define LIGHT_POS(t) (3.0*POLAR(CAM_THETA(t) - 0.25*PI) + vec3(0.0, 1.0, 0.0))\n\nfloat Power;\nfloat PhiShift;\nfloat ThetaShift;\n\nfloat distanceEstimation(vec3 pos) {\n    if(length(pos) > 1.5) return length(pos) - 1.2;\n    vec3 z = pos;\n    float dr = 1.0, r = 0.0, theta, phi;\n    for (int i = 0; i < 8; i++) {\n        r = length(z);\n        if (r>1.5) break;\n        dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        theta = acos(z.z/r) * Power + ThetaShift;\n        phi = atan(z.y,z.x) * Power + PhiShift;\n        float sinTheta = sin(theta);\n        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nfloat fDensity(vec3 lmn, float time) {\n    // Current position adjusted to [-1,1]^3\n    vec3 uvw = (lmn - vec3(63.5))/63.5;\n\n    #if 1\n        // Mandelbulb\n        time -= 1.5;\n\n        Power = 5.0;\n        ThetaShift = time;\n        PhiShift = 0.5 * time;\n\n        float dRaw = distanceEstimation(uvw*1.3);\n        return 0.01 + smoothstep(0.1, -0.1, dRaw);\n    #else\n    \t// Any other density is fine...\n    \tfloat r = 1.0 - smoothstep(0.4, 1.0, length(uvw));\n    \tr = step(0.15, r)*r;\n    \tvec3 vsph = mod(lmn, 16.0)/8.0 - vec3(1.0);\n    \tfloat dsph = mix(length(vsph), len3Inf(vsph), 0.75);\n    \treturn smoothstep(r+0.5, r-0.5, dsph);\n\n    #endif\n}\n\n// ========================\n// Marching through volume\n// ========================\n\n#define DENSITY(lmn) fDensity(lmn, time)\n#define T_MAX 1000.0\n\nvoid hitSurface(\n    in vec3 p, in vec3 nv, in float time,\n\tin vec2 fragCoord,\n    out float tHit, out bool didHit\n) {\n    vec2 tRange;\n    bool didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n    tRange.s = max(0.0, tRange.s);\n\n    if (!didHitBox) {\n        tHit = T_MAX;\n        didHit = false;\n        return;\n    }\n\n    float t = tRange.s + min(tRange.t-tRange.s, RAY_STEP)*hash12(fragCoord);\n    for (int i = 0; i < 150; i++) { // Theoretical max steps: (BOX_MAX-BOX_MIN)*sqrt(3)/RAY_STEP\n        if (t > tRange.t) { break; }\n\n        vec3 rayPos = p + t*nv;\n        vec3 lmn = lmnFromWorldPos(rayPos);\n        float density = DENSITY(lmn);\n\n        if (density > D_SURF) {\n            // binary search between last step and this step\n            float substep = (max(tRange.s, t-RAY_STEP) - t) * 0.5;\n            for(int j=0; j<4; j++) {\n                t += substep;\n\n                rayPos = p + t*nv;\n                lmn = lmnFromWorldPos(rayPos);\n                density = DENSITY(lmn);\n\n                substep = density < D_SURF ? abs(substep)*0.5 : -abs(substep)*0.5;\n            }\n\n\t\t\ttHit = t;\n            didHit = true;\n            return;\n        }\n\n        t += RAY_STEP;\n    }\n\n    tHit = T_MAX;\n    didHit = false;\n}\n\n// ==================\n// Surface rendering\n// ==================\n\n#define LIGHT(lmn) texture(cubeSampler, vcubeFromLMN(2, lmn)).t\n\nfloat getLightInterp(samplerCube cubeSampler, vec3 lmn) {\n    vec3 flmn = floor(lmn);\n\n    float d000 = LIGHT( flmn );\n    float d001 = LIGHT( flmn + vec3(0.0, 0.0, 1.0) );\n    float d010 = LIGHT( flmn + vec3(0.0, 1.0, 0.0) );\n    float d011 = LIGHT( flmn + vec3(0.0, 1.0, 1.0) );\n    float d100 = LIGHT( flmn + vec3(1.0, 0.0, 0.0) );\n    float d101 = LIGHT( flmn + vec3(1.0, 0.0, 1.0) );\n    float d110 = LIGHT( flmn + vec3(1.0, 1.0, 0.0) );\n    float d111 = LIGHT( flmn + vec3(1.0, 1.0, 1.0) );\n\n    vec3 t = lmn - flmn;\n    return mix(\n        mix(mix(d000, d100, t.x), mix(d010, d110, t.x), t.y),\n        mix(mix(d001, d101, t.x), mix(d011, d111, t.x), t.y),\n        t.z\n    );\n}\n\nvec3 getNormalInterp(vec3 lmn, float time) {\n    vec3 grad = vec3(\n        DENSITY(lmn + vec3(0.1, 0.0, 0.0)) - DENSITY(lmn - vec3(0.1, 0.0, 0.0)),\n        DENSITY(lmn + vec3(0.0, 0.1, 0.0)) - DENSITY(lmn - vec3(0.0, 0.1, 0.0)),\n        DENSITY(lmn + vec3(0.0, 0.0, 0.1)) - DENSITY(lmn - vec3(0.0, 0.0, 0.1))\n    );\n    return -grad/(length(grad) + 1e-5);\n}\n\nvec3 skybox(vec3 nvDir) {\n    return ( mix(0.25, 0.75, smoothstep(-0.2,0.2, nvDir.y)) )*vec3(0.7, 0.8, 1.0);\n}\n\n#define SPECULAR_COEFF 0.75\n#define SPECULAR_EXP 30.0\n\nbool inputOnlySSS;\nbool inputNoSSS;\nbool inputDebugNormal;\nbool inputDebugDepth;\n\nvec4 mainRender(\n    samplerCube cubeSampler, samplerCube skySampler,\n    vec3 iResolution, vec4 iMouse, vec2 fragCoord, float time\n) {\n    vec2 uv = fragCoord / RES.xy;\n\n    // Camera\n    bool isMousePressed = clamp(iMouse.z, 0.0, 1.0) > 0.5;\n    vec2 mouseAng = isMousePressed\n        ? PI * vec2(4.0, 1.0)*iMouse.xy / RES.xy\n        : vec2(CAM_THETA(time), CAM_PHI(time));\n\n    vec3 camPos = 1.4 * SPHERICAL(mouseAng.x, mouseAng.y);\n    vec3 lookTarget = vec3(0.0);\n\n\tvec3 nvCamFw = normalize(lookTarget - camPos);\n    vec3 nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n\n    // Hit surface\n    float tSurf;\n    bool didHitSurf;\n    hitSurface(camPos, nvCamDir, time, fragCoord, tSurf, didHitSurf);\n    vec3 p = camPos + tSurf*nvCamDir;\n    \n    // Skybox\n    vec3 nvCamToLight = normalize(LIGHT_POS(time) - camPos);\n    float towardLight = clamp(dot(nvCamToLight, nvCamDir), 0.0, 1.0);\n    towardLight = pow(towardLight, 7.0);\n    vec3 bgColor = mix(skybox(nvCamDir), vec3(1.0), towardLight);\n\n    // Render\n    vec4 color = vec4(0.0);\n    if (didHitSurf) {\n        vec3 lmn = lmnFromWorldPos(p);\n        vec3 nvNormal = getNormalInterp(lmn, time);\n        float lightAmount = getLightInterp(cubeSampler, lmn);\n\n        // User input adjustments\n        // -----------------------\n\n        if (inputNoSSS) {\n            lightAmount = 0.5;\n        }\n        if (inputOnlySSS) {\n            return vec4(vec3(lightAmount), 0.0);\n        } else if (inputDebugNormal) {\n            return vec4(0.5+0.5*nvNormal, 0.0);\n        }\n        // -----------------------\n\n        vec3 cSurfIn = colormap(0.1*time);\n        vec3 cSurfOut = mix(colormap(0.1*time+0.375), vec3(1.0), 0.5);\n        vec3 cSurfMix = mix(cSurfIn, cSurfOut, lightAmount);\n\n        vec3 nvFragToLight = normalize(LIGHT_POS(time) - p);\n        vec3 nvFragToCam = normalize(camPos - p);\n\n        // Specular contribution\n        vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n        float valSpecular = SPECULAR_COEFF * pow(max(0.0, dot(nvNormal, blinnH)), SPECULAR_EXP);\n\n        // Schlick approximation\n        float cosHitAngle = dot(nvNormal, nvFragToCam);\n        float valRefl = mix(SCHLICK_R0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 5.0));\n        valRefl = clamp(valRefl, 0.025, 0.125);\n\n        vec3 vRefl = reflect(-nvFragToCam, nvNormal);\n        vec3 cRefl = texture(skySampler, vRefl).rrr;\n\n        color = vec4(0.1*cSurfOut, 1.0); // Ambient contribution\n        color = blendOnto(lightAmount*vec4(cSurfMix, 1.0), color);\n        color = blendOnto(valRefl*vec4(cRefl, 1.0), color);\n        color = blendOnto(lightAmount*valSpecular*vec4(1.0), color);\n        \n    }\n    vec3 finalColor = blendOnto(color, bgColor).rgb;\n\n    float camDist = distance(camPos, BOX_CENTER);\n    float blurAmount = clamp(unmix(-SQRT3*0.5, SQRT3*0.375, tSurf - camDist), 0.0, 1.0);\n\n    return inputDebugDepth ? vec4(vec3(blurAmount), 0.0) : vec4(finalColor, blurAmount);\n}\n", "cube_a_code": "#define CUBE_SAMPLER iChannel0\n\n// ==========================\n// Store density on \"page 1\"\n// ==========================\n\nvec4 doPage1(vec3 lmn) {\n    return vec4(fDensity(lmn, ITIME), 1.0, 1.0, 1.0);\n}\n\n// NOTE: Used by \"page 2\" when computing lighting.  On the first frame, \"page 1\"\n// won't have been written, so we compute rather than just looking up the value.\nvec4 getPage1(vec3 lmn) {\n    return INITIALIZING ? doPage1(lmn) : texture(CUBE_SAMPLER, vcubeFromLMN(1, lmn));\n}\n\n// ===========================\n// Store lighting on \"page 2\"\n// ===========================\n\nfloat march(vec3 p, vec3 nv) {\n    float lightAmount = 1.0;\n\n    vec2 tRange;\n    bool didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n    tRange.s = max(0.0, tRange.s);\n\n    if (!didHitBox) {\n        return 0.0;\n    }\n\n    float t = tRange.s;\n    for (int i = 0; i < 150; i++) { // Theoretical max steps: (BOX_MAX-BOX_MIN)*sqrt(3)/RAY_STEP_L\n        if (t > tRange.t || lightAmount < 1.0-QUIT_ALPHA_L) { break; }\n\n        vec3 rayPos = p + t*nv;\n        vec3 lmn = lmnFromWorldPos(rayPos);\n\n        float density = getPage1(lmn).s;\n        float calpha = clamp(density * MAX_ALPHA_PER_UNIT_DIST * RAY_STEP_L, 0.0, 1.0);\n\n        lightAmount *= 1.0 - calpha;\n\n        t += RAY_STEP_L;\n    }\n\n    return lightAmount;\n}\n\nvec4 doPage2(vec3 lmn) {\n\tvec3 p = worldPosFromLMN(lmn);\n    float lightAmount = march(p, normalize(LIGHT_POS(ITIME) - p));\n\n    return vec4(1.0, lightAmount, 1.0, 1.0);\n}\n\n// ==================\n// Write to cube map\n// ==================\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec3 lmn;\n    int pageDst;\n    lmnFromVCube(rayDir, pageDst, lmn);\n\n    if (pageDst == 1) {\n        fragColor = doPage1(lmn);\n    } else if (pageDst == 2) {\n        fragColor = doPage2(lmn);\n    } else {\n        discard;\n    }\n}\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define CUBE_SAMPLER iChannel0\n#define SKY_SAMPLER iChannel2\n#define KEY_SAMPLER iChannel1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    inputOnlySSS = texelFetch(KEY_SAMPLER, ivec2(KEY_A,0), 0).x > 0.5;\n    inputNoSSS = texelFetch(KEY_SAMPLER, ivec2(KEY_S,0), 0).x > 0.5;\n    inputDebugNormal = texelFetch(KEY_SAMPLER, ivec2(KEY_D,0), 0).x > 0.5;\n    inputDebugDepth = texelFetch(KEY_SAMPLER, ivec2(KEY_F,0), 0).x > 0.5;\n\n    fragColor = mainRender(CUBE_SAMPLER, SKY_SAMPLER, iResolution, iMouse, fragCoord, ITIME);\n}\n", "buffer_a_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define IMAGE_SAMPLER iChannel0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / RES.xy;\n    fragColor = vec4(blurV(iResolution, IMAGE_SAMPLER, uv), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 182, 182, 745]], "test": "untested"}
{"id": "3llcR8", "name": "recursive Bézier construction", "author": "FabriceNeyret2", "description": "Recusive form of the nice geometric construction of Bezier curve:[url]https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Higher-order_curves[/url] .\n Note the fast convergence.\nUse mouse to control spot of refinement.", "tags": ["bezier", "spline", "tuto"], "likes": 12, "viewed": 531, "published": 3, "date": "1591428631", "time_retrieved": "2024-07-30T21:02:43.985273", "image_code": "// === Recusive form of the nice geometric construction of Bezier curve ===\n// https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Higher-order_curves \n// for real-use, would draw segments and stop subdiv when length or angle < threshold\n\nvec2  P0_ = vec2(-1.6,-.8), T0 = .8*vec2(1.5,2), // Bezier cage: points + tangents\n      P3_ = vec2( 1.4,-.8), T3 = .8*vec2(.2 ,2), \n      P0,P1,P2,P3;                               // recursive Bezier cage ( 4 points )\n#define R  iResolution.xy\n\n// --- line drawing from https://www.shadertoy.com/view/llySRh\n// NB: for perf, would better return dot(,) take the min dist, then draw only the sqrt of this one.\n#define S(v,r) smoothstep( -3., 0., r-abs(v)*R.y )\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h); \n}\n\n// --- recursive construction\n// M:        target point ( e.g., Mouse  or cur pixel )\n// constr:   true: draw construction line   false: only draw the final point.\nvoid Bezier( vec2 U, vec2 M, inout vec4 O , bool constr) {\n    for( int i=0; i< (constr ? 4 : 8 ); i++ ) {\n        vec2 P01 = ( P0+P1 )/2., P12 = ( P1+P2 )/2., P23 = (P2+P3)/2., // NB: pretty integer friendly\n             P02 = (P01+P12)/2., P13 = (P12+P23)/2., \n              Pb = (P02+P13)/2.;                 // mid-point on spline, delimiting the 2 sub-cages\n        if (constr) O.rg += S(line(U,P01,P02),), // draw construction lines ( including sub cages )\n                    O.rg += S(line(U,P02,P12),)*.5, \n                    O.rg += S(line(U,P13,P23),),\n                    O.rg += S(line(U,P12,P13),)*.5,\n                    O.g  += S(line(U,P02,Pb) ,),\n                    O.r  += S(line(U,Pb,P13) ,), // draw point on spline\n                    O    += S(length(Pb-U), 4.);\n        else        O    += S(length(Pb-U),   );\n\n        if ( dot( M-Pb, P13-P02 ) < 0. )\n      //if ( M.x < Pb.x ) \n                        P1=P01, P2=P02, P3=Pb;   // choose closest sub-cages\n            else        P2=P23, P1=P13, P0=Pb;\n    }\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( 2.*u - R ) /R.y,\n         M = length(iMouse.xy) < 20. \n                 ?  vec2 ( cos(iTime), 0 )\n                 : ( 2.*iMouse.xy - R ) /R.y; \n    O = vec4(0);\n    T0 += .2 * cos(iTime+vec2(0,11));            // animate Bezier cage\n    T3 += .2*sin(2.3*iTime+vec2(0,11));\n    \n   \n    P0 = P0_, P3=P3_, P1 = P0+T0, P2 = P3+T3;    // set Bezier cage\n    O.r  += S(line(U,P0,P1),);                   // draw Bezier cage\n    O.rg += S(line(U,P1,P2),);\n    O.g  += S(line(U,P2,P3),);\n    \n    O += S(length(M-U)/8.,);                     // draw mouse spot \n    Bezier(U,M,O, true);                         // recursive draw Bezier around mouse spot\n    \n    P0 = P0_, P3=P3_, P1 = P0+T0, P2 = P3+T3;    // set Bezier cage\n    Bezier(U,U,O, false);                        // recursive draw Bezier curve (here, just points)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 731, 731, 837]], "test": "untested"}
{"id": "WllyR8", "name": "mouseworms", "author": "kowbell", "description": "Fork of \"10 years old nattou\" by tomohiro\nhttps://www.shadertoy.com/view/MtGGWc\n\nMain changes:\n- Use original noise result to mix between two colors\n---- colors determined by relative mouse coords as the hue\n- move long skewF() comment to end of file", "tags": ["2d", "simplexnoise"], "likes": 5, "viewed": 412, "published": 3, "date": "1591414479", "time_retrieved": "2024-07-30T21:02:44.874894", "image_code": "// /////////////////////////////////////////////////////////////////////////////\n// HSV/RGB by iq, MIT License: https://www.shadertoy.com/view/lsS3Wc\n// /////////////////////////////////////////////////////////////////////////////\n\nconst float eps = 0.0000001; vec3 hsv2rgb( in vec3 c ){ vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); return c.z * mix( vec3(1.0), rgb, c.y); } vec3 rgb2hsv( in vec3 c) { vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0); vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0); vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0); float d = q.x - min(q.w, q.y); return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x); }\n\n// /////////////////////////////////////////////////////////////////////////////\n// Fork of \"10 years old nattou\" by tomohiro\n// https://www.shadertoy.com/view/MtGGWc\n//\n// Main changes:\n// - Use original noise result to mix between two colors\n// ---- colors determined by relative mouse coords as the hue\n// - move long skewF() comment to end of file\n// /////////////////////////////////////////////////////////////////////////////\n\n//Number of layers.\n//Higher value shows more layers of effects.\n//Lower value higher FPS.\nconst int numLayers = 16;\n\n//Length of worm\nconst int wormLength = 8;\n\n//Write output color from anywhere to see value of temporary variable.\nvec3 cout;\n\nfloat rand(vec3 pos)\n{\n\tvec3 p = pos + vec3(2.);\n\tvec3 fp = fract(p*p.yzx*222.)+vec3(2.);\n\tp.y *= p.z * fp.x;\n\tp.x *= p.y * fp.y;\n\treturn\n\tfract\n\t(\n\t\tp.x*p.x\n\t);\n}\n\nfloat skewF(float n)\n{\n\treturn (sqrt(n + 1.0) - 1.0)/n;\n}\n\nfloat unskewG(float n)\n{\n\treturn (1.0/sqrt(n + 1.0) - 1.0)/n;\n}\n\nvec2 smplxNoise2DDeriv(vec2 x, float m, vec2 g)\n{\n\tvec2 dmdxy = min(dot(x, x) - vec2(0.5), 0.0);\n\tdmdxy = 8.*x*dmdxy*dmdxy*dmdxy;\n\treturn dmdxy*dot(x, g) + m*g;\n}\n\nfloat smplxNoise2D(vec2 p, out vec2 deriv, float randKey, float roffset)\n{\n\t//i is a skewed coordinate of a bottom vertex of a simplex where p is in.\n\tvec2 i0 = floor(p + vec2( (p.x + p.y)*skewF(2.0) ));\n\t//x0, x1, x2 are unskewed displacement vectors.\n\tfloat unskew = unskewG(2.0);\n\tvec2 x0 = p - (i0 + vec2((i0.x + i0.y)*unskew));\n\n\tvec2 ii1 = x0.x > x0.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\tvec2 ii2 = vec2(1.0);\n\n//  vec2 i1 = i0 + ii1;\n//  vec2 x1 = p - (i1 + vec2((i1.x + i1.y)*unskew));\n//          = p - (i0 + ii1 + vec2((i0.x + i0.y + 1.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii1 - vec2(1.0)*unskew;\n\tvec2 x1 = x0 - ii1 - vec2(unskew);\n//  vec2 i2 = i0 + ii2;\n//  vec2 x2 = p - (i2 + vec2((i2.x + i2.y)*unskew));\n//          = p - (i0 + ii2 + vec2((i0.x + i0.y + 2.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii2 - vec2(2.0)*unskew;\n\tvec2 x2 = x0 - ii2 - vec2(2.0*unskew);\n\n\tvec3 m = max(vec3(0.5) - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n\tm = m*m;\n\tm = m*m;\n\n\tfloat r0 = 3.1416*2.0*rand(vec3(mod(i0, 16.0)/16.0, randKey));\n\tfloat r1 = 3.1416*2.0*rand(vec3(mod(i0 + ii1, 16.0)/16.0, randKey));\n\tfloat r2 = 3.1416*2.0*rand(vec3(mod(i0 + ii2, 16.0)/16.0, randKey));\n\n\tfloat randKey2 = randKey + 0.01;\n\tfloat spmin = 0.5;\n\tfloat sps = 2.0;\n\tfloat sp0 = spmin + sps*rand(vec3(mod(i0, 16.0)/16.0, randKey2));\n\tfloat sp1 = spmin + sps*rand(vec3(mod(i0 + ii1, 16.0)/16.0, randKey2));\n\tfloat sp2 = spmin + sps*rand(vec3(mod(i0 + ii2, 16.0)/16.0, randKey2));\n\n\tr0 += iTime*sp0 + roffset;\n\tr1 += iTime*sp1 + roffset;\n\tr2 += iTime*sp2 + roffset;\n\t//Gradients;\n\tvec2 g0 = vec2(cos(r0), sin(r0));\n\tvec2 g1 = vec2(cos(r1), sin(r1));\n\tvec2 g2 = vec2(cos(r2), sin(r2));\n\n\tderiv = smplxNoise2DDeriv(x0, m.x, g0) + smplxNoise2DDeriv(x1, m.y, g1) + smplxNoise2DDeriv(x2, m.z, g2);\n\treturn dot(m*vec3(dot(x0, g0), dot(x1, g1), dot(x2, g2)), vec3(1.0));\n//    return dot(m*vec3(length(x0), length(x1), length(x2)), vec3(1.0));\n}\n\nvec3 norm(vec2 deriv)\n{\n\tderiv *= 2000.0;\n\tvec3 tx = vec3(1.0, 0.0, deriv.x);\n\tvec3 ty = vec3(0.0, 1.0, deriv.y);\n\treturn normalize(cross(tx, ty));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\n\tvec3 color = vec3(0.0);\n\tfloat s = 1.0;\n\tfor(int i=0; i<numLayers; ++i)\n\t{\n\t\tfloat sn = 0.0;\n\t\tfloat y = 0.0;\n\t\t\n\t\tvec2 deriv;\n\t\tfloat nx = smplxNoise2D(uv*s*4.0, deriv, 0.1+1./s, 0.0);\n\t\tfloat ny = smplxNoise2D(uv*s*4.0, deriv, 0.11+1./s, 0.0);\n\t\tfor(int j=0; j<wormLength; ++j)\n\t\t{\n\t\t\tvec2 deriv;\n\n\t\t\tsn += smplxNoise2D(uv*s+vec2(1./s, 0.)+vec2(nx,ny)*4., deriv, 0.2+1./s, y);\n\t\t\tcolor += vec3(norm(deriv).z)/s;\n\t\t\ty += 0.1;\n\t\t}\n\t\ts *= 1.1;\n\t}\n\tcolor /= 4.;\n\n\tvec2 deriv;\n\tfloat delay = smplxNoise2D(uv*s*1.0, deriv, 0.111, 0.0);\n\tcolor = mix(color, vec3(1.0) - color, clamp(sin(iTime*0.25+uv.x*0.5+delay*32.)*32., 0.0, 1.0));\n\n\tcout = color;\n\t\n\t\n\tfloat rgb = color.r * color.g * color.b;\n\t\n\t\n\tfloat mouseX = iMouse.x/iResolution.x;\n\tfloat mouseY = iMouse.y/iResolution.y;\n    \n    // offset mouseX a bit so when you start it isn't just red\n    // (mouse.x and mouse.y are 0 at start)\n    mouseX += 0.2;\n\t\n\tvec3 colA = hsv2rgb(vec3(mouseX*2., 1., 1.));\n\tvec3 colB = hsv2rgb(vec3(mouseY*1., 1., 1.));\n\t\n\tcout = mix( colA, colB, rgb);\n\n\tfragColor = vec4(cout, 1.0);\n}\n\n\n// Original comment from skewF()\n/*\nn∈N\nX∈R^n\nX'∈R^n\nA∈R^n ∧ |A| = 1\ns∈R\nf is a non-uniform scaling along direction A and s is the scaling factor.\nf:R^n → R^n\nX' = f(X)\n   = X・A*s*A - X・A*A + X\n   = X・A*(s-1)*A + X\n\n∀B(B∈R^n ∧ B・A = 0 ⇒ f(X)・B = X)\n\nX' = f^-1(X)\n   = X・A*(1/s-1)*A + X\n\nf^-1(f(X)) = X\nX' = X・A*(s-1)*A + X\nX = X'・A*(1/s-1)*A + X'\n  = (X・A*(s-1)*A + X)・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(s-1)*(A・A)*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(1-s-1/s+1)*A          + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = -X・A*(s-1)*A - X・A*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X\n\nWhen creating simplex noise, A is a unit vector parallel to a unit hypercube's longest diagonal.\nA = (1/√(n), 1/√(n), ...)\n  = 1/√(n)(1, 1, ...)\n\nX' = f(X) = (s-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nIn skewed coordinate system, basis is not orthogonal.\nAny points P in skewed coordinate system such that P∈Z^n become a vertex of a simplex.\nIn the Cartesian coordinate, all edge of a simplex should have a same length.\nBut it is not possible in 3D and higher dimension.\nEquilateral triangle alone can fill space, but regular tetrahedra alone do not.\nFind 's' such that |f^-1((1, 0, 0, ...))| = |f^-1((1, 1, 1, ...))|\n|(1/s-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)/n*(1, 1, ...)・(1, 1, ...)*(1, 1, ...) + (1, 1, 1)|\n|(1/s-1)/n*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)*(1, 1, ...) + (1, 1, 1)|\n((1/s-1)/n+1)^2 + (((1/s-1)/n)^2)*(n-1) = ((1/s)^2)*n\n(1/s-1)*(1/s-1)/(n*n)+ 2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*(n-1)/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*n/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)/n = n/(s*s)\n(1/s-1)/n*(2 + (1/s-1)) + 1 = n/(s*s)\n(1/s-1)/n*(1 + 1/s) + 1 = n/(s*s)\n(1-s)/n*(s + 1) + s*s = n\n(1-s)*(s + 1) + s*s*n = n*n\n(n-1)*s*s + 1 = n*n\ns*s = (n*n - 1)/(n-1) = (n+1)(n-1)/(n-1) = n+1\ns = sqrt(n+1)\n\nX' = f(X) = (√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\nf^-1(X) = (1/√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nLength of edge of a simplex in Cartesian coordinate system:\n f^-1((1, 0, 0, ...))  = (1/√(n+1)-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)\n\t\t\t\t\t   = (1/√(n+1)-1)/n*(1, 1, ...) + (1, 0, 0, ...)\n|f^-1((1, 0, 0, ...))| = √( ((1/√(n+1)-1)/n+1)^2 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n\t\t\t\t\t   = √( ((1/√(n+1)-1)/n)^2 + 2*(1/√(n+1)-1)/n + 1 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n\t\t\t\t\t   = √( (((1/√(n+1)-1)/n)^2)*n + 2*(1/√(n+1)-1)/n + 1 )\n\t\t\t\t\t   = √( (1/√(n+1)-1)/n*(1/√(n+1)-1 + 2) + 1 )\n\t\t\t\t\t   = √( (1/(n+1) - 1)/n + 1 )\n\t\t\t\t\t   = √( -n/(n+1)/n + 1 )\n\t\t\t\t\t   = √( -1/(n+1) + 1 )\n\t\t\t\t\t   = √( n/(n+1) )\nhttps://www.wolframalpha.com/input/?i=sqrt(+((1%2Fsqrt(n%2B1)-1)%2Fn%2B1)^2+%2B+(((1%2Fsqrt(n%2B1)-1)%2Fn)^2)*(n-1)+)\n\nLength of edges of a simplex in Cartesian coordinate system in 3 or higher dimension are not equal.\nY∈{0,1}^n\nm = Y・(1, 1, ...)\nf^-1(Y) = m*(1/√(n+1)-1)/n*(1, 1, ...) + Y\n|f^-1(Y)| = √( ((m*(1/√(n+1)-1)/n+1)^2)*m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n\t\t  = √( ((m*(1/√(n+1)-1)/n)^2)*m + 2*m*m*(1/√(n+1)-1)/n + m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n\t\t  = √( ((m*(1/√(n+1)-1)/n)^2)*n + 2*m*m*(1/√(n+1)-1)/n + m )\n\t\t  = √( (m*(1/√(n+1)-1)/n)*( (m*(1/√(n+1)-1)) + 2*m ) + m )\n\t\t  = √( (m*(1/√(n+1)-1)/n)*m*( 1/√(n+1)+1 ) + m )\n\t\t  = √( m*m*(1/(n+1)-1)/n + m )\n\t\t  = √( m*m*(-n)/(n+1)/n + m )\n\t\t  = √( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*m/(n+1))/√( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0 when m = 0.5*(n+1)\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2/(n+1))/√( n/(n+1) )\n\t\t\t\t= 0.5*(n-1)/√( n*(n+1) ) > 0 when m = 1\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*n/(n+1))/√( n/(n+1) )\n\t\t\t\t= 0.5*(1-n)/√( n*(n+1) ) < 0 when m = n\n\nSo length of edge is shortest when m = 1 or m = n and other edge is longer than them.\n\nShortest distance between a vertex on simplex and the opposite edge:\nL = √( n/(n+1) )*√(3)/2\n\nReferences:\nhttps://en.wikipedia.org/wiki/Simplex_noise\nhttp://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyR8.jpg", "access": "api", "license": "mit", "functions": [[261, 261, 287, 287, 408], [409, 409, 435, 435, 730], [1411, 1411, 1433, 1433, 1574], [1576, 1576, 1598, 1598, 1633], [1635, 1635, 1659, 1659, 1698], [1700, 1700, 1749, 1749, 1862], [1864, 1864, 1938, 2013, 3843], [3845, 3845, 3868, 3868, 3994], [3996, 3996, 4053, 4053, 5187]], "test": "untested"}
{"id": "tlXyRH", "name": "Cool velocimeter", "author": "makaronsito", "description": "Gas gas gas", "tags": ["procedural"], "likes": 3, "viewed": 317, "published": 3, "date": "1591392360", "time_retrieved": "2024-07-30T21:02:45.646830", "image_code": "const float MAX_VEL = 20.;\nconst float MIN_ANGLE = -36.;\nconst float MAX_ANGLE = 120.;\nconst float GROSOR_AGUJA = .1; //porcentaje\nconst float LARGO_AGUJA = .5; //porcentaje\nconst float LARGO_MARCA = .12; //porcentaje\nconst float GROSOR_MARCA = 1.5; //en grados\nconst float ANG_ESP_MARCA = 12.; //en grados\nconst float GROSOR_CIRC = .02; //porcentaje\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float vel = abs(sin(iTime/20.)) * MAX_VEL;\n    \n\tvec3 col = vec3(-1);\n\tvec2 centerUV = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tfloat velCoef = vel/MAX_VEL;\n\tfloat angle = mix(MIN_ANGLE, MAX_ANGLE, velCoef) + sin(iTime * velCoef * 90.) * velCoef * 3.;\n\tfloat uvDisp = length(centerUV);\n\t\n\t//crea un círculo rojo que delimita la zona en que la aguja gira\n\tif (uvDisp > GROSOR_AGUJA * 1.2 && uvDisp < GROSOR_CIRC + GROSOR_AGUJA * 1.2)\n\t\tcol = vec3(0.1,-1,-1);\n\t\t\n\t//solo renderizamos la parte de la línea que \"se mueve en la dirección adecuada\" creando la ilusión de una aguja\n\tvec2 dir = vec2(cos(radians(angle)), sin(radians(angle)));\n\tfloat dirCos = (centerUV.x*dir.x+centerUV.y*dir.y)/(length(centerUV)*length(dir));\n\tif (length(centerUV) < GROSOR_AGUJA || dirCos > 0.) {\n\t\t//ecuación distancia punto-recta\n\t\tfloat dist = abs(centerUV.y*dir.x - centerUV.x*dir.y) / length(dir);\n\t\tif (dist < GROSOR_AGUJA/2.){\n\t\t\tfloat centerDistCoef = clamp(1.-uvDisp/LARGO_AGUJA,0.,1.);\n\t\t\tfloat lineDistCoef = (GROSOR_AGUJA/2.)/dist-1.;\n\t\t\tcol = vec3(clamp(lineDistCoef * centerDistCoef, 0., 1.),-1.,-1.);\n\t\t}\n\t}\n\t\n\t//ángulo del UV, de 0 a 360\n\tfloat aUV = degrees(atan(centerUV.y/centerUV.x));\n    if (centerUV.x < 0.)\n        aUV += 180.;\n\t\n\t//si nos encontramos en la franja donde debe haber marcas\n\tif (uvDisp > LARGO_AGUJA - LARGO_MARCA && uvDisp < LARGO_AGUJA){\n\t\tif (uvDisp > LARGO_AGUJA-LARGO_MARCA/2. && uvDisp < LARGO_AGUJA + GROSOR_CIRC - LARGO_MARCA/2.)\n\t\t\tcol = vec3(0.1);//asignar color gris al círculo delimitador\n\t\tif (mod(aUV, ANG_ESP_MARCA) < GROSOR_MARCA && aUV < MAX_ANGLE + GROSOR_MARCA && aUV > MIN_ANGLE){ //marcas de velocidad\n\t\t\tif (aUV < 0.)//asignamos el color a cada marca según el ángulo de la línea que siga\n\t\t\t\tcol = vec3(0.3, 0, 1);\n\t\t\telse if (aUV < 90.)\n\t\t\t\tcol = vec3(0, 1, 0.3);\n\t\t\telse\n\t\t\t\tcol = vec3(1, 1, 0.);\n\t\t}\n\t}\n\t\t\n\tfragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 407, 407, 2305]], "test": "untested"}
{"id": "wlfyz8", "name": "Endless waves", "author": "jarble", "description": "This is a modification of my [url=https://www.shadertoy.com/view/wdBfD3]\"Aquatic ecosystem\"[/url] shader, using a slightly modified raymarching algorithm. As the objects get closer, they seem to get smaller and smaller.", "tags": ["raymarching"], "likes": 5, "viewed": 364, "published": 3, "date": "1591385570", "time_retrieved": "2024-07-30T21:02:46.386852", "image_code": "\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nfloat EPSILON1;\n\nvec3 animate(vec3 p){\n    float t1 = iTime/10.0;\n    vec3 p1 = p/100.0+vec3(t1,t1,t1);\n    p += vec3(sin(p1.y+t1)+cos(p1.z),sin(p1.z)+cos(p1.x),sin(p1.x)+cos(p1.y))*100.0;\n    return p;\n}\n\nvec3 surface_color(in vec3 uv)\n{\n    uv = animate(uv);\n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(sin(vec2(uv.x, uv.y)));\n        uv.x = uv.y + uv.x;\n        uv.y = uv.x - uv.y;\n    }\n    return vec3((lar * .5), lar*.7, lar)*1.5;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p = animate(p);\n\n    return  4.1 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float epsilon1 = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        \n        EPSILON1 += EPSILON*depth; //adjust the level of detail\n        \n        if (dist < EPSILON1) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON1, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON1, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON1, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON1, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON1)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON1))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    \n    \n    \n    vec3 eye = vec3(0.0, 0.0, iTime)*50.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON1) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 222, 222, 388], [390, 390, 422, 422, 673], [675, 915, 939, 939, 1046], [1048, 1469, 1560, 1560, 1975], [1990, 2244, 2309, 2309, 2441], [2443, 2532, 2561, 2561, 2877], [2879, 3371, 3511, 3511, 4101], [4103, 4473, 4558, 4558, 5316], [5318, 5645, 5694, 5729, 5860], [5862, 5862, 5919, 5919, 6819]], "test": "untested"}
{"id": "tlfcR8", "name": "lawn pattern 2 ( 136 chars )", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/WtfczH[/url]", "tags": ["2d", "pattern", "short", "onetweet", "golf"], "likes": 7, "viewed": 313, "published": 3, "date": "1591382852", "time_retrieved": "2024-07-30T21:02:47.212644", "image_code": "// variant of https://shadertoy.com/view/WtfczH\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = 44.* ( u+u - R )/ R.y,\n         V = U * mat2(1,1,1,-1) *.707;\n    O -= 2.*cos(vec2(length(U),V)) [V.x*sign(V.y) > 2. ?1:0]; // variant: > 1.9\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 271]], "test": "untested"}
{"id": "WlXczH", "name": "sphere uniform point", "author": "Danielhu", "description": "Different sphere uniform distribution algorithms", "tags": ["sphere", "distribution"], "likes": 12, "viewed": 919, "published": 3, "date": "1591376455", "time_retrieved": "2024-07-30T21:02:48.060377", "image_code": "float sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nmat3 rotate() {\n    float theta = iTime * 0.3;\n    float phi = iTime * 0.3;\n    \n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nbool drawSphere(vec2 coor, vec3 c, float r, out vec3 hit, out vec3 col) {\n    vec3 p = vec3(coor, -1.0);\n    vec3 dir = vec3(0, 0, 1);\n    for (int i = 0; i < 32; ++i) {\n        float sdf = sphere(p, c, r);\n        if (sdf < 0.0001) {\n            hit = p;\n            col = 0.3  + 0.4 * vec3(dot(normalize(hit - c), vec3(0, 0, -1))) * (sin(iTime) * 0.5 + 0.5);\n            return true;\n        }\n        p += sdf * 0.5 * dir;\n    }\n    return false;\n}\n\n#define axis_num 12.0\n#define PI acos(-1.0)\n\nvec3 snapEachAxis(vec3 p, vec3 c, float r) {\n    vec3 col = vec3(0);\n    vec3 rp = (p - c) * rotate();\n    vec3 d = round(rp * axis_num ) / axis_num ;\n    d = normalize(d) * r;\n    col += step(length(rp - d), 0.004);\n    col += (d * 173.0 - round(d * 173.0)) * (1.0 - (sin(iTime) * 0.5 + 0.5)); \n    return col;\n}\n\nvec3 snapSpherical(vec3 p, vec3 c, float r) {\n    vec3 col = vec3(0);\n    vec3 rp = (p - c) * rotate();\n    vec3 d;\n    float phi = asin(rp.z / r);\n    d.z = sin(round(phi / PI * axis_num) / axis_num * PI) * r;\n    float theta = atan(rp.y, rp.x);\n    \n    float xyMag = sqrt(r * r - d.z * d.z);\n    float roundedTheta = round(theta / PI * round(xyMag / r * axis_num) ) * PI / round(xyMag / r * axis_num);\n    \n    d.x = cos(roundedTheta) * xyMag;\n    d.y = sin(roundedTheta) * xyMag;\n    \n   \n    col += step(length(rp - d), 0.005);\n    col += (d * 173.0 - round(d * 173.0)) * (1.0 - (sin(iTime) * 0.5 + 0.5)); \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coor = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    vec3 hit;\n    \n    vec3 col; \n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    if(drawSphere(coor, vec3(-0.45, 0.0, 0), 0.4, hit, col))\n       fragColor.xyz += col + snapEachAxis(hit, vec3(-0.45, 0.0, 0), 0.4);\n    \n    if(drawSphere(coor, vec3(0.45, 0.0, 0), 0.4, hit, col))\n       fragColor.xyz += col + snapSpherical(hit, vec3(0.45, 0.0, 0), 0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 71], [73, 73, 88, 88, 365], [367, 367, 440, 440, 818], [865, 865, 909, 909, 1178], [1180, 1180, 1225, 1225, 1809], [1812, 1812, 1869, 1869, 2293]], "test": "untested"}
{"id": "WtfczH", "name": "lawn pattern ( 163 chars )", "author": "FabriceNeyret2", "description": "ref: [url]https://www.cafedeclic.com/images/copy/uploads/actus/thumb/6b228bcc25b4430780951aa14f316225f4f86994.jpg[/url]\nTry also the variant", "tags": ["2d", "pattern", "2tweets", "short", "golf", "reproduction"], "likes": 3, "viewed": 382, "published": 3, "date": "1591374155", "time_retrieved": "2024-07-30T21:02:48.904121", "image_code": "void mainImage(out vec4 O, vec2 u) { O-=O; O.a++;\n    vec2 R = iResolution.xy,\n         U = 44.* ( u+u - R ) /R.y,\n         V = U * mat2(1,1,1,-1) *.707;\n    O += dot( clamp( -2.*cos(vec2(length(U),V)), 0.,1.) ,\n              V.x*sign(V.y) > 2. ? .5*O.ww:O.wx  );\n  //O -= 2.*cos(vec2(length(U),V)) [V.x*sign(V.y)>2. ?1:0]       // variant ( or >1.9 )\n} \n\n\n/*\n// --- 170 chars \n\n#define mainImage(O,u)                                            \\\n    vec2 R = iResolution.xy,                                      \\\n         U = 44.* ( u+u - R ) /R.y,                               \\\n         V = U * mat2(1,1,1,-1) *.707;                            \\\n    O += dot( clamp( -2.*cos(vec2(length(U),V)), 0.,1.) ,         \\\n              abs(V.x)>2. && V.y*V.x > 0. ? .5*O.ww:O.wx  )      /* \n    O += -2.*cos(vec2(length(U),V))[abs(V.x)>1.9 && V.x*V.y > 0. ?1:0]   /* variant\n\n\n\n\n// --- 179 chars \n\n#define mainImage(O,u)                                              \\\n    vec2 R = iResolution.xy,                                        \\\n         U = 7.* ( u+u - R ) / R.y,                                 \\\n         V = U * mat2(1,1,1,-1) *.707;                              \\\n    O += dot( clamp( -R.y/2e2* cos(6.3*vec2(length(U),V)), 0.,1.) , \\\n              abs(V.x)>.31 && V.y*V.x > 0. ? .5*O.ww:O.wx  )       /* \n    O += -R.y/2e2* cos(6.3*vec2(length(U),V))[abs(V.x)>.31 && V.x*V.y > 0. ?1:0] /* variant  \n   \n\n\n\n\n// --- 202 chars \n\n#define mainImage(O,u)                                \\\n    vec2 R = iResolution.xy,                          \\\n         U = 7.* ( u+u - R ) / R.y,                   \\\n         V = U * mat2(1,1,1,-1) *.707;                \\\n    O += dot( clamp( R.y/28.* ( abs(abs(mod(vec2(length(U),V)-.5,2.)-1.)-.5) -.25), 0.,1.), \\\n              abs(V.x)>.31 && V.y*V.x > 0. ? .5*O.ww:O.wx)    /* \n    O +=  R.y/28.* ( abs(abs(mod(vec2(length(U),V)-.5,2.)-1.)-.5) -.25)[abs(V.x)>.31 && V.x*V.y > 0. ?1:0] /* variant  \n   \n\n\n\n\n// --- 205 chars \n\n#define mainImage(O,u)                                \\\n    vec2 R = iResolution.xy,                          \\\n         U = 7.* ( u+u - R ) / R.y,                   \\\n         V = U * mat2(1,-1,1,1) *.707,                \\\n         l = .5 * clamp( R.y/28.* ( abs(abs(mod(vec2(length(U),V.y)-.5,2.)-1.)-.5) -.25), 0.,1.);\\\n    O += ( abs(V.y)>.31 && V.x*V.y > 0. ? l.y : l.x ) +l.x  /* try without final +l.x\n        \n   \n\n\n\n// --- 210 chars \n\n#define S .5 * clamp( R.y/28.* ( abs(abs(mod(l-.5,2.)-1.)-.5) -.25), 0.,1.)//\n#define mainImage(O,u)                                \\\n    vec2 R = iResolution.xy,                          \\\n         U = 7.* ( u+u - R ) / R.y,                   \\\n         V = U * mat2(1,-1,1,1) *.707;                \\\n    float l = length(U), s = S;                       \\\n    O += ( abs(l=V.y)>.31 && V.x*l > 0. ? S : s ) +s /* try without +s\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 353]], "test": "untested"}
{"id": "3tfyz8", "name": "Day 169 - kdtree", "author": "jeyko", "description": "potato", "tags": ["kdtree", "mdtmjvm"], "likes": 12, "viewed": 432, "published": 3, "date": "1591365823", "time_retrieved": "2024-07-30T21:02:49.773796", "image_code": "// Fork of \"Day 168 - Quadtree\" by jeyko. https://shadertoy.com/view/WlsyRr\n// 2020-06-05 07:34:31\n\n// This is a classifier of kdtree points, but it doesn't build the actual structure. \n// That would require a bit different of an approach \n\n\nvec2 r12(float i){\n\treturn texture(iChannel0,vec2(mod(i,256.)/256.,floor(i/256.)*256.)).xy*2. - 1.;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U- 0.5*iResolution.xy)/iResolution.y;\n\n    //uv /= dot(uv,uv)*19.;\n    \n    vec3 col = vec3(0);\n\n    \n    float id = 0.;\n    \n    float d = 10e6;\n    float dside = 10e6;\n    \n    #define ITERS 19.\n    #define DOTS 19.\n    \n    for(float i = 0.; i < DOTS; i++){\n    \tvec2 p = r12(i+24.)/1.;\n        \n        p.xy += vec2(sin(i+iTime),cos(i+iTime))/20.;\n        \n        d = min(d, length(p-uv));\n        \n        vec2 split = vec2(0.,0.);\n        \n        for(float k = 1.; k < ITERS; k++ ){\n\t\t\n            float stsz = 1./(pow(2.,floor(k/2.)));\n            \n            vec2 poffs = sign(p-split);\n            vec2 uoffs = sign(uv-split);\n            \n            if(uoffs == poffs){\n            \tsplit += stsz*vec2( poffs.x * float( mod(k,2.) == 1. ) , poffs.y * float( mod(k,2.) == 0. ) );\n            \t\n                id += 2.4;\n            } else {\n                \n                \n                dside = min(dside , abs(uv.x - split.x)-0.0 );\n                dside = min(dside , abs(uv.x - split.x - stsz*2.)-0.0 );\n                dside = min(dside , abs(uv.y - split.y)-0.0 );\n                dside = min(dside , abs(uv.y - split.y - stsz*2.)-0.0 );\n                break;\n            }\n\n        }\t\n    \n    }\n    \n    col += 0.5 + sin(id + vec3(1.,0.5,0.5))/3.;\n    \n    float dw = 0.005;\n    float dott = smoothstep(dw*1.4,dw,d);\n    dw *= 0.8;\n    dside = smoothstep(dw*1.14,dw,dside);\n    \n    col -= vec3(0.,0.4,0.8)*dside;\n    \n    col = mix(col,vec3(1,0.1,0.4),dott);\n    \n    C = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 260, 260, 343], [344, 344, 385, 385, 1915]], "test": "untested"}
{"id": "3lfcR8", "name": "more video trails", "author": "mds2", "description": "Started out as some experiments to see if I could do cheap background removal.  I can't.\n\nModified to leave cool trails.", "tags": ["video", "hack", "webcam", "quick", "trails"], "likes": 4, "viewed": 695, "published": 3, "date": "1591339516", "time_retrieved": "2024-07-30T21:02:50.588618", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 219]], "test": "untested"}
{"id": "3lfyR8", "name": "dark trails", "author": "mds2", "description": "simple hack for leaving trails", "tags": ["simple", "hack", "webcam", "trails"], "likes": 5, "viewed": 560, "published": 3, "date": "1591336056", "time_retrieved": "2024-07-30T21:02:51.395460", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0, uv).rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 new_rgb = texture(iChannel1, uv).rgb;\n    vec4 result = texture(iChannel0, uv);\n    vec3 old_rgb = result.rgb;\n    \n    if (length(old_rgb) >  length(new_rgb)) {\n\t\tresult.rgb = new_rgb;\n    } else {\n        result.rgb = mix(old_rgb, new_rgb, 0.01);\n    }\n    \n    fragColor = result;\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 234]], "test": "untested"}
{"id": "tllcRr", "name": "Checker Warping", "author": "percentcer", "description": "Messing with fragcoords", "tags": ["checkers"], "likes": 3, "viewed": 325, "published": 3, "date": "1591311847", "time_retrieved": "2024-07-30T21:02:52.281092", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.x;\n    \n    vec3 col;\n    for (int i = 0; i < 3; i++) {\n        float time = iTime - .2 * float(i);\n        vec2 uv_ = uv - vec2(sin(time),cos(time))*.2;\n\n        vec2 px = fragCoord - (iResolution.xy/2.);\n        vec3 col_ = 0.5 + 0.5 * cos(/*time + */length(uv_) * 2. + uv_.xyx + vec3(0,2,4) );\n\n        px *= length(uv_);\n        float squareSize = iResolution.y * .1;\n        if (mod(floor(px / squareSize), vec2(2.)) == vec2(0.)\n           || mod(floor(px / squareSize), vec2(2.)) == vec2(1.)) {\n            col_ = 1.-col_;\n        }\n        col[i] = col_[i];\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 727]], "test": "untested"}
{"id": "ttlcRr", "name": "Slow fractal clock", "author": "creikey", "description": "Better for something in the background, based on https://www.shadertoy.com/view/3lscRr", "tags": ["clock"], "likes": 4, "viewed": 373, "published": 3, "date": "1591310331", "time_retrieved": "2024-07-30T21:02:53.144783", "image_code": "#define P 3.14159265359\n#define DARK_THEME\n#define SPEED 0.2\nmat2 r(float a) { float c = cos(a), s = sin(a); return mat2(c,s,-s,c); }\nfloat sq(vec2 p, vec2 sz, float r) { return length(max(abs(p) - sz,0.)) - r; }\n\nfloat anim1(float x) { float sp = P*12.; x = x*sp; return (x + sin(x - P))/sp; }\n\nvec2 m;\nfloat t;\nfloat aa;\nfloat shape(vec2 p) {\n    float d = 10e+9;\n    vec2 s1 = vec2(0.,(0.34444));\n    float s2 = .3;\n    for(int i = 0; i < 8; i++) {\n        float d1 = min(d,sq(p, s1, .002));\n        float d2 = sq(p*r(P*.25),vec2(.15)*s2, max(.001,aa));\n        d2 = min(d2,sq(p*r(P*.25) + .5*s2,vec2(.075)*s2, max(.001,aa)));\n        d2 = min(d2,sq(p*r(P*.25) - .5*s2,vec2(.075)*s2, max(.001,aa)));\n        float d3 = abs(length(p) - .7155*s2) - .001;\n        \n        d =  min(d1,d2);\n        d =  min(d,d3);\n        \n        p *= r(P*anim1(-t*.125)*.5);\n        p *= r(P*-0.3333);\n        p.y = abs(p.y) - s2*m.y;\n        p.x = abs(p.x) - s2*m.x;\n        p *= r(P);\n        s2 *= 0.5;\n        s1.y *= 0.496;\n    }\n    \n    //d = abs(d - .001) - .0005;\n    float dd = d;\n    d = smoothstep(-aa,aa,d);\n    float color = mix(0.,1.,d);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    t = iTime*SPEED;\n    m = iMouse.xy/iResolution.xy - .1;\n    aa = (1./iResolution.x);\n    \n    vec3 color = vec3(0.);\n    /*color.r += shape(st + vec2(aa + length(st*.002),0.));\n    color.g += shape(st + vec2(0.,0.));\n    color.b += shape(st + vec2(0.,aa + length(st*.002)));*/\n    color = vec3(shape(st));\n    \n    #ifdef DARK_THEME\n    color = vec3(1.0) - color;\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(color - pow(length(st)*.9,1.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 78, 78, 133], [134, 134, 170, 170, 212], [214, 214, 236, 236, 294], [323, 323, 344, 344, 1162], [1164, 1164, 1221, 1221, 1789]], "test": "untested"}
{"id": "wd2BWd", "name": "Farey Sequences", "author": "mla", "description": "Farey Sequences: [url]https://en.wikipedia.org/wiki/Farey_sequence[/url]", "tags": ["continued", "farey", "fractions"], "likes": 10, "viewed": 364, "published": 3, "date": "1591308822", "time_retrieved": "2024-07-30T21:02:53.991519", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Farey Sequences\n// https://en.wikipedia.org/wiki/Farey_sequence\n// Each coloured band is a Farey sequence, the black lines form the Stern-\n// Brocot tree.\n// mla, 2020\n////////////////////////////////////////////////////////////////////////////////\n\nbool incircle(vec2 z, float x1, float x2) {\n  float centre = 0.5*(x1+x2);\n  float radius = 0.5*(x1-x2);\n  z -= vec2(centre,0);\n  return dot(z,z) < radius*radius;\n}\n\n// Distance of z from circle with centre on y=0, passing\n// through x-x1,x+x2 (or x-x2,x+x1).\nfloat circledist(vec2 z, float x1, float x2) {\n  float centre = 0.5*(x1+x2);\n  float radius = 0.5*abs(x1-x2);\n  z -= vec2(centre,0);\n  return length(z)-radius;\n}\n\nfloat check(vec2 z, ivec4 a) {\n  int p = a.x, q = a.y, r = a.z, s = a.w;\n  // z is in the half disc under [p/q,r/s] (in some order),\n  // but not under either of the subsidiary discs\n  float x0 = float(p)/float(q);\n  float x1 = float(p+r)/float(q+s); // The mediant\n  float x2 = float(r)/float(s);\n  float d = 1e8;\n  d = min(d,abs(z.x-x1));\n  d = min(d,abs(circledist(z,x0,x2)));\n  d = min(d,abs(circledist(z,x1,x2)));\n  d = min(d,abs(circledist(z,x1,x0)));\n  float lwidth = 0.03*z.y;\n  //return smoothstep(0.5*lwidth,lwidth,d);\n  float pwidth = fwidth(z.x);\n  //return smoothstep(max(0.0,lwidth-pwidth),max(pwidth,lwidth),d);\n  return smoothstep(-pwidth,pwidth,d-lwidth);\n}\n\nint farey(vec2 z, out ivec4 a) {\n  z = abs(z);\n  float x = z.x;\n  int p=1,q=0,r=0,s=1;\n  int count = 0;\n  // The \"slow\" continued fraction algorithm\n  for (int i = 0; i < 20; i++) {\n    int p1=r, q1=s;\n    for( ; x >= 1.0; x -= 1.0,count++) {\n      float x1 = float(p)/float(q);\n      float x2 = float(p1+p)/float(q1+q);\n      if (!incircle(z,x1,x2)) {\n        a = ivec4(p,q,p1,q1);\n        return count;\n      }\n      p1 += p; q1 += q;\n    }\n    x = 1.0/x;\n    r=p; s=q; p=p1; q=q1;\n  }\n  return -1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec3 aacol = vec3(0);\n  int AA = 2;\n  float t = 0.5*sqrt(5.0)-0.5;\n  if (iMouse.x > 0.0) t = iMouse.x/iResolution.x;\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (fragCoord.xy+vec2(i,j)/float(AA))/iResolution.x;\n      z.x -= t;\n      z *= exp(-mod(0.5*iTime,18.0));\n      z.x += t;\n      ivec4 a;\n      int k = farey(z,a);\n      vec3 col = vec3(1);\n      if (k >= 0) {\n        col = hsv2rgb(vec3(float(k)/6.0,0.8,1));\n        col *= check(z,a);\n      }\n      aacol += col;\n    }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545));\n  fragColor = vec4(aacol,1);\n}\n", "image_inputs": [], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2BWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 377, 377, 497], [499, 593, 639, 639, 754], [756, 756, 786, 786, 1430], [1432, 1432, 1464, 1464, 1934], [1936, 1936, 1992, 1992, 2606]], "test": "untested"}
{"id": "wlsczn", "name": "Netflix Shader", "author": "s_h_m", "description": "looks fun", "tags": ["lines", "dancing", "neon", "netflix"], "likes": 0, "viewed": 154, "published": 3, "date": "1591306903", "time_retrieved": "2024-07-30T21:02:54.946964", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    vec2 r = iResolution.xy;\n    uv = 100000.*abs(cos(iTime)*sin(iTime))*(uv+uv-r)/r.y;\n    uv.y = -uv.x;\n    uv/=1.+uv.y/100.;\n    uv.y -= iTime;\n    uv=abs(fract(uv)-.05);\n    uv = .05/sqrt(uv);\n    //uv = vec2(cos(time)*uv.x-uv.y*sin(time),uv.x*sin(time)+uv.y*cos(time));\n    mat2 roth = mat2(vec2(cos(iTime),-sin(iTime)),vec2(sin(iTime),cos(iTime)));\n    uv*=roth;\n    fragColor=(uv.x+uv.y)*vec4(1.,.6+.4*sin(iTime*.25),0.,0.)*.8;\n    fragColor+=(uv.x+uv.y)*vec4(.8,.4,0.,0.)*.8;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 576]], "test": "untested"}
{"id": "ts2cRy", "name": "glitch pattern", "author": "boysx", "description": "glitch pattern", "tags": ["glitch", "pattern"], "likes": 18, "viewed": 817, "published": 3, "date": "1591299554", "time_retrieved": "2024-07-30T21:02:55.695962", "image_code": "float rand(vec2 p)\n{\n    float t = floor(iTime * 20.) / 10.; // glitch FPS\n    //t = exp(t);\n    return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float blockiness)\n{   \n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    float n1 = rand(id);\n    float n2 = rand(id+vec2(1,0));\n    float n3 = rand(id+vec2(0,1));\n    float n4 = rand(id+vec2(1,1));\n    \n    vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n\n    return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n}\n\nfloat fbm(vec2 uv, int count, float blockiness, float complexity)\n{\n    float val = 0.0;\n    float amp = 0.5;\n    \n    while(count != 0)\n    {\n    \tval += amp * noise(uv + (rand(ceil(uv * 3.) / 3.) * 2. + (float(floor(iTime * 20.) / 10.)/float(count)) - 1.), blockiness);\n        amp *= 0.5;\n        uv *= complexity;    \n        count--;\n    }\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv;\n    \n    uv *= 5.;\n    //uv.x *= noise((ceil(uv * 5.) / 5.) * 0.3, 3.0); // should i?\n    uv.x *= fbm(uv, 2, 3.0, 1.0);\n    \n    float noiseVal = (smoothstep(0.5, 1.0, fbm(uv, 2, 3.0, 1.5))); // take the noise\n\n    vec3 col = vec3(texture(iChannel0, vec2(uv2.x + noiseVal * 0.05, uv2.y)).r,\n                   texture(iChannel0, vec2(uv2.x - noiseVal * 0.05, uv2.y)).g,\n                   texture(iChannel0, vec2(uv2.x, uv2.y)).b); // adjust amplitude\n    col = vec3(1.0, 0.0, 0.0)*smoothstep(0.2, 0.3, noiseVal);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2cRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 169], [171, 171, 211, 211, 516], [887, 887, 944, 994, 1625]], "test": "untested"}
{"id": "ttlcRn", "name": "Infinite jungle (modified)", "author": "jarble", "description": "Fly through the canopy of an otherworldly rainforest!\nThis is a more complex version of my [url=https://www.shadertoy.com/view/wdBfWd]\"Infinite jungle\"[/url] scene, with many fireflies flying through it.\nClick and drag the mouse to look around.", "tags": ["raymarching", "lod", "jungle"], "likes": 2, "viewed": 373, "published": 3, "date": "1591296651", "time_retrieved": "2024-07-30T21:02:56.587578", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.00001;\nfloat EPSILON1;\nint color;\n\nvec3 animate(vec3 p){\n    vec3 p1 = p/100.0+vec3(iTime/20.0);\n    p += vec3(sin(p1.y),cos(p1.z),sin(p1.x))*100.0;\n    return p;\n}\n\nvec3 surface_color2(vec3 p)\n{\n    p = animate(p);\n    vec3 col;\n    col = p.xyz*sin(p.x+p.y+p.z);\n    \n    // Output to screen\n    return vec3(col.y,col.z,p.x)/500.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF3(vec3 p) {\n    p *= 2.0;\n    p = animate(p)/10.0;\n    return  4.2 +sin(length(p*5.0)/2.0) + (sin(p.x+p.y+p.z)+cos(p.y)+cos(p.z))*1.1;\n}\n\nvec3 surface_color1(vec3 p)\n{\n    p = sin(p/100.0)*100.0;\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(sin(uv.y)/20.0+.5,sin(col2.x),sin(uv.x)/5.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p = sin(p/100.0)*100.0;\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(sin(uv.y)/20.0+.5,sin(uv.x)/5.0,sin(col2.x)*1.5)/1.5;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat bump(vec3 p3)\n{\n    p3 *= 3.;\n  \t//return vec3(0.0);\n    float distortion = 5.0;\n    p3 *= distortion;\n    return length(sin(p3))/(distortion*4.0);\n}\n\n\nfloat sceneSDF1(vec3 p) {\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  4.2 + sin((p.x*2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5+bump(p);\n}\n\n\nfloat sceneSDF2(vec3 p){\n\treturn min(sceneSDF1(p/5.0),sceneSDF1(p.zyx/2.0));\n}\n\nfloat sceneSDF(vec3 p){\n    p += sin(p/2.0);\n    p /= 30.0;\n    float p1 = sceneSDF2(p);\n    float p2 = sceneSDF1(p.yxz/5.0);\n    float p3 = sceneSDF3(p*20.0);\n\tfloat result = min(p1,min(p2,p3));\n    if(result == p1){\n    \tcolor = 1;\n    }\n    else if(result == p2){\n    \tcolor = 2;\n    }\n    else if(result == p3){\n    \tcolor = 3;\n    }\n    return result;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        //reduce the level of detail for distant objects\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        \n        \n        EPSILON1 = EPSILON*depth*depth;\n        if (dist < EPSILON1) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON1, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON1, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON1, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON1, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON1)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON1))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(sin(iTime/5.0)*2.0, cos(iTime/5.0)*2.0, -iTime)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON1) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a;\n    if (color == 2){\n    \tK_a = surface_color((p));\n    }\n    else if(color == 1){\n    \tK_a = surface_color1(p);\n    }\n    else if(color == 3){\n    \tK_a = surface_color2(p);\n    }\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color1 = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 235, 235, 343], [345, 345, 374, 374, 513], [515, 755, 780, 780, 905], [907, 907, 936, 936, 1333], [1335, 1335, 1363, 1363, 1768], [2012, 2012, 2033, 2033, 2167], [2170, 2170, 2195, 2195, 2313], [2316, 2316, 2340, 2340, 2394], [2396, 2396, 2419, 2419, 2754], [2756, 3177, 3268, 3268, 3699], [3714, 3968, 4033, 4033, 4165], [4167, 4256, 4285, 4285, 4601], [4603, 5095, 5235, 5235, 5825], [5827, 6197, 6282, 6282, 6637], [6639, 6966, 7015, 7050, 7181], [7183, 7183, 7240, 7240, 8317]], "test": "untested"}
{"id": "tlsyRn", "name": "Snakeskin", "author": "yacodes", "description": "Snake-like skin shader", "tags": ["snakeskin"], "likes": 1, "viewed": 269, "published": 3, "date": "1591296416", "time_retrieved": "2024-07-30T21:02:57.550005", "image_code": "#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x, 0.0, 0.0, _scale.y);\n}\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nfloat polygon(in vec2 st, in int edges, in float size) {\n    vec2 _st = st * 2. - 1.;\n    float a = atan(_st.x,_st.y)+PI;\n    float r = (PI*2.)/float(edges);\n    float d = cos(floor(0.5+a/r)*r-a)*length(_st);\n\treturn 1.0-smoothstep(size,size+0.01,d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n    vec3 color = vec3(0.);\n    vec2 pos = st.xy*vec2(28.,28.);\n    float pattern = pos.x;\n    pos = rotate2d(noise(pos / 20.) + 5.5 + iTime / 4.) * pos + iTime * 3.;\n    pattern = polygon(fract(pos), 3, noise(pos + iTime) + 0.2);\n    color = mix(color, vec3(0.316,0.635,0.286), pattern * noise(pos * 72.));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 62, 62, 137], [139, 221, 243, 243, 541], [543, 543, 570, 570, 652], [654, 654, 678, 678, 727], [729, 729, 763, 763, 919], [921, 921, 977, 977, 1173], [1175, 1175, 1230, 1230, 1655]], "test": "untested"}
{"id": "wtsyRn", "name": "Sandwave", "author": "yacodes", "description": "Sandwave noisy shader", "tags": ["sandwave"], "likes": 4, "viewed": 357, "published": 3, "date": "1591296373", "time_retrieved": "2024-07-30T21:02:58.581247", "image_code": "#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat gnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x, 0.0, 0.0, _scale.y);\n}\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nfloat polygon(in vec2 st, in int edges, in float size) {\n    vec2 _st = st * 2. - 1.;\n    float a = atan(_st.x,_st.y)+PI;\n    float r = (PI*2.)/float(edges);\n    float d = cos(floor(0.5+a/r)*r-a)*length(_st);\n\treturn 1.0-smoothstep(size,size+0.01,d);\n}\n\nfloat hline(in vec2 st, in float width) {\n    width = .5 - width / 2.;\n    return step(step(width, st.x) - width, st.x);\n}\n\nfloat vline(in vec2 st, in float width) {\n    width = (.5 - width / 2.);\n    return smoothstep(\n        gnoise(st * 3000.),\n        smoothstep(\n            width,\n            width + 0.001,\n            st.y\n        ) - width,\n        st.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n  st.y *= iResolution.y/iResolution.x;\n  vec3 color = vec3(0.);\n  vec2 pos = st.xy;\n  pos = rotate2d(sin(atan(gnoise(pos * 12.)) / 12.)) * pos;\n  float pattern = 1. - vline(fract(pos * 15.), 0.3);\n  color = mix(color, vec3(1.), pattern);\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 62, 62, 137], [139, 139, 161, 161, 285], [287, 369, 391, 391, 689], [691, 691, 714, 714, 1118], [1120, 1120, 1147, 1147, 1229], [1231, 1231, 1255, 1255, 1304], [1306, 1306, 1340, 1340, 1496], [1498, 1498, 1554, 1554, 1750], [1752, 1752, 1793, 1793, 1874], [1876, 1876, 1917, 1917, 2118], [2120, 2120, 2175, 2175, 2488]], "test": "untested"}
{"id": "ttsyRn", "name": "Bit Texture", "author": "yacodes", "description": "Random 8bit texture", "tags": ["8bit"], "likes": 5, "viewed": 274, "published": 3, "date": "1591296280", "time_retrieved": "2024-07-30T21:02:59.599525", "image_code": "float box(vec2 _st, vec2 _size){\n    _size = vec2(0.940,0.460)-_size*0.532;\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat random (in float _st) {\n    return fract(sin(_st)*43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n  vec3 color = vec3(0.0);\n  st.x *= 64.0;\n  st.y *= 128.;\n  float direction = (step(0.5, fract(iTime)) * 2.) - 1.;\n  if (fract(iTime / 4.) > 0.5) {\n      direction = (random(floor(iTime / 4.)) * 4.);\n  } else {\n      direction = - (random(floor(iTime / 4.)) * 4.);\n  }\n  vec2 board1 = st;\n  board1.x +=  step(1., mod(board1.y,2.)) * (iTime*5.) * 2. * direction + random(floor(iTime / 44.));\n  board1.x +=  step(-1., mod(-board1.y,2.)) * (iTime*5.) * -direction + random(floor(iTime / 12.));\n  vec2 board2 = st;\n  board2.x +=  step(1., mod(board2.y,2.)) * (iTime*5.) * 2. * direction  + random(floor(iTime / 5.));\n  board2.x +=  step(-1., mod(-board2.y,2.)) * (iTime*5.) * -direction - random(floor(iTime / 2.));\n  vec2 board3 = st;\n  board3.x +=  step(1., mod(board3.y,2.)) * (iTime*5.) * 2. * direction - random(floor(iTime / 3.));\n  board3.x +=  step(-1., mod(-board3.y,2.)) * (iTime*5.) * -direction + random(floor(iTime / 4.));\n  vec2 ipos1 = floor(board1);\n  vec2 ipos2 = floor(board2);\n  vec2 ipos3 = floor(board3);\n\n  color = vec3(\n    step(0.684, random(ipos1)),\n    step(0.684, random(ipos2)),\n    step(0.508, random(ipos3))\n  );\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 213], [215, 215, 243, 243, 317], [319, 319, 348, 348, 392], [394, 394, 449, 449, 1663]], "test": "untested"}
{"id": "wllyRn", "name": "Bitfall", "author": "yacodes", "description": "Bit waterfall", "tags": ["8bit"], "likes": 5, "viewed": 335, "published": 3, "date": "1591296228", "time_retrieved": "2024-07-30T21:03:00.611818", "image_code": "float random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat random (float st) {\n  return fract(sin(st)*4375.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n  vec2 m = vec2(cos(iTime + 0.7652) / 2. + 0.5, sin(iTime + 0.3745) / 2. + 0.5);\n\tvec2 board = st;\n\n  // Rows/Cols\n  board.y *= 128.0;\n  board.x *= 64.;\n\n  // Speed\n  float freq = random(floor(board.x)) + 0.256;\n  float sy = (freq * iTime * 64.);\n  board.y += sy;\n\n  // Render\n  vec3 color = vec3(\n    smoothstep(m.y - 0.5, m.y, random(floor(board.y))),\n    smoothstep(m.x - 0.5, m.x, random(floor(board.y - 0.5))),\n    smoothstep(m.x, m.y, random(floor(board.y + 0.5)))\n  );\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 95], [96, 96, 121, 121, 161], [163, 163, 218, 218, 770]], "test": "untested"}
{"id": "wtlyRn", "name": "That's why I want to learn shdrs", "author": "postviolet", "description": "The magic of copy and paste", "tags": ["raymarching"], "likes": 5, "viewed": 326, "published": 3, "date": "1591295418", "time_retrieved": "2024-07-30T21:03:01.640070", "image_code": "//ромбики фрактальные\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec3 opCheapBend(in vec3 p )\n{\n    const float k = -0.50; \n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nmat4 rotateX( in float angle ) {\n  return mat4(  1.0,    0,      0,      0,\n           0,   cos(angle),  -sin(angle),    0,\n          0,   sin(angle),   cos(angle),    0,\n          0,       0,        0,     1);\n}\n\nmat4 rotateY( in float angle ) {\n  return mat4(  cos(angle),    0,    sin(angle),  0,\n               0,    1.0,       0,  0,\n          -sin(angle),  0,    cos(angle),  0,\n              0,     0,        0,  1);\n}\n\nmat4 rotateZ( in float angle ) {\n  return mat4(  cos(angle),    -sin(angle),  0,  0,\n           sin(angle),    cos(angle),    0,  0,\n              0,        0,    1,  0,\n              0,        0,    0,  1);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n  samplePoint = (rotateY(sin(iTime/2.)) * vec4(samplePoint, 1.)).xyz;\n  samplePoint = (rotateX(sin(iTime/2.)) * vec4(samplePoint, 1.)).xyz;\n  samplePoint = (rotateZ(sin(iTime/2.)) * vec4(samplePoint, 1.)).xyz;\n  samplePoint = opRep(samplePoint, vec3(3., 4., 14.));\n    \n    return sdOctahedron(samplePoint, 0.446);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n      return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.800,0.096,0.119);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(1.736,\n                          2.0 ,\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 dir = rayDirection(45., iResolution.xy, fragCoord.xy);\n    vec3 eye = vec3(0., 0., 40.)+sin(iTime);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n    }\n    \n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.222,0.141,0.440);\n    vec3 K_d = vec3(0.700,0.602,0.194);\n    vec3 K_s = vec3(0.179,0.962,1.000);\n    float shininess = 20.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 201, 201, 241], [243, 243, 280, 280, 363], [365, 365, 395, 395, 551], [553, 553, 607, 607, 709], [711, 711, 749, 749, 802], [804, 804, 837, 837, 902], [904, 904, 956, 956, 1055], [1057, 1057, 1092, 1092, 1143], [1145, 1145, 1177, 1177, 1357], [1359, 1359, 1391, 1391, 1570], [1572, 1572, 1604, 1604, 1781], [1783, 1783, 1817, 1817, 2134], [2137, 2137, 2228, 2228, 2537], [2540, 2540, 2605, 2605, 2737], [2740, 2740, 2769, 2769, 3079], [3082, 3082, 3222, 3222, 3651], [3654, 3654, 3739, 3739, 4506], [4509, 4509, 4566, 4566, 5157]], "test": "untested"}
{"id": "ttlyRn", "name": "Tictactoe", "author": "postviolet", "description": "The result of second week of learning shaders with Book of Shaders.", "tags": ["2d", "2dshaders"], "likes": 2, "viewed": 362, "published": 3, "date": "1591295161", "time_retrieved": "2024-07-30T21:03:02.622443", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat random (float puk) {\n    return fract(sin(puk)* 43758.5453123);\n}\n\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  return mix(random(i), random(i + 1.0), smoothstep(0.,1.,f));\n}\n\nfloat circle(in vec2 _st, in float _radius, vec2 _pos, float border){\n    vec2 l = _st-_pos;\n    float c1 = 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n    float c2 = 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0*(border));\n    \n    return c1-c2;}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.660;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat cross(in vec2 _st, float _size){\n    return  box(_st, vec2(_size+(noise(iTime*3.)),_size/4.)) +\n            box(_st, vec2(_size/4.,_size+(noise(iTime*3.))));\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = fragCoord.xy/vec2(iResolution.y, iResolution.y);\n  st.x -= iResolution.y / iResolution.x / 1.5;\n  \n  vec3 color = vec3(0.180,0.180,0.180);\n\n  vec2 space1 =st;\n  float n = noise(iTime);\n  float c = circle(space1,0.604, vec2(0.5,0.5), 1.5*(noise(iTime*3.)));\n  color = mix(color, vec3(0.620,0.479,0.601),c);\n\n  vec2 space3 = st;\n  space3 -= vec2(0.5);\n  space3 = rotate2d((noise(iTime*5.99999)))*space3;\n  space3 += vec2(0.5);\n  float cr2 = cross(space3, 0.50);\n  color = mix(color, vec3(0.945,0.858,0.930),cr2);\n\n  vec2 space2 = st;\n  space2 -= vec2(0.5);\n  space2 = rotate2d((noise(iTime*6.)))*space2;\n  space2 += vec2(0.5);\n  float cr1 = cross(space2, 0.5);\n  color = mix(color, vec3(0.0,0.,0.),cr1);\n\n  fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 115, 115, 158], [160, 160, 186, 186, 231], [233, 233, 255, 255, 364], [366, 366, 435, 435, 775], [777, 777, 815, 815, 1084], [1086, 1086, 1124, 1124, 1251], [1253, 1253, 1281, 1281, 1367], [1369, 1369, 1426, 1426, 2174]], "test": "untested"}
{"id": "Wlsczr", "name": "When the ocean is marching rays", "author": "postviolet", "description": "In the wake of Char Stiles's workshop ♥ ", "tags": ["raymarching"], "likes": 3, "viewed": 285, "published": 3, "date": "1591294959", "time_retrieved": "2024-07-30T21:03:03.488128", "image_code": "vec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size * 0.5)/size);\n\tp = mod (p + size * 0.5, size) - size * 0.5;\n\treturn c;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nconst int steps = 250;\nconst float smallNumber = 0.00001;\nconst float maxDist = 10.;\n\nfloat scene(vec3 position){    \n    \n    vec3 st = position;\n    pMod3 (st, vec3 (0.364, 4.2, 0.));\n    \n    float ground = st.y + sin(position.x*8. * abs(sin(iTime/15.)))/9. \n                              + cos(position.z*10. * fract (iTime/5.)) / 10. + 1.5 ;\n    \n    float shar1 = sdSphere (vec3(position.x-0.844, position.y-1.036, position.z+1.788), -0.800 );\n\n    return opSmoothUnion(shar1, ground*ground, 3.);\n}\n\nvec4 trace (vec3 origin, vec3 direction){\n    \n    float dist = 0.;\n    float totalDistance = 0.;\n    vec3 positionOnRay = origin;\n    \n    for(int i = 0 ; i < steps; i++){\n        \n        dist = scene(positionOnRay);\n\n        positionOnRay += dist * direction;\n\n        totalDistance += dist;\n\n        if (dist < smallNumber){\n\n            return 1.000 - (vec4(totalDistance) / maxDist);\n        }\n        \n        if (totalDistance > maxDist){\n \n            return vec4(0);\n        }\n    }\n    \n    return vec4(0.890+sin(iTime),0.583+sin(iTime),0.540,1.000);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  uv += -0.5;\n  uv *= 2.;\n\n  vec3 camOrigin = vec3(0., 0., -2.);\n  vec3 rayOrigin = vec3(uv + camOrigin.xy, camOrigin.z + 1.);\n  vec3 dir = camOrigin + rayOrigin;\n\n  vec4 color = vec4(trace(rayOrigin, dir));\n  fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlsczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 136], [138, 138, 190, 190, 289], [292, 292, 327, 327, 351], [439, 439, 466, 466, 857], [859, 859, 900, 900, 1422], [1425, 1425, 1480, 1480, 1752]], "test": "untested"}
{"id": "3lsczr", "name": "pixel goose paws", "author": "postviolet", "description": "The result of third week of learning shaders with Book of Shaders.", "tags": ["2d", "bookofshaders", "2dshaders"], "likes": 4, "viewed": 269, "published": 3, "date": "1591293571", "time_retrieved": "2024-07-30T21:03:04.327883", "image_code": "float box(vec2 _st, vec2 _size){\n    _size = vec2(0.940,0.460)-_size*0.532;\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n  vec3 color = vec3(0.0);\n\n  st.x *= 32.0;\n  st.y *= 8.0;\n\n  st.x +=  step(1., mod(st.y,2.0)) * fract(st.x);\n  st.y +=  step(1., mod(st.x,2.0)) * fract(st.y)+(iTime);\n\n  vec2 ipos = floor(st);\n  vec2 fpos = fract(st);\n  color = vec3(step(0.332, random(ipos+iTime/24.)));\n\n  fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 213], [215, 215, 243, 243, 351], [353, 353, 410, 410, 756]], "test": "untested"}
{"id": "3lsyzr", "name": "Sdf blob", "author": "stlsnk", "description": "A blob made from the smooth union of two spheres with three lights: blue fixed directional, green moving direction and red moving point. \nBy taking the derivative of the distance field, we can calculate the normals at any point.", "tags": ["3d", "raytracing", "sdf", "light"], "likes": 3, "viewed": 685, "published": 3, "date": "1591290424", "time_retrieved": "2024-07-30T21:03:05.275349", "image_code": "// position of the green/yellow light\nvec3 gpos;\n\nfloat dot2(in vec3 v) { return dot(v, v); }\n\nfloat sdf_sph(in vec3 p, in float r) {\n  return length(p) - r;\n}\n\n// the main blob made from two sphere\nfloat sdf_min(in vec3 p) {\n    float a = sdf_sph(p - vec3(-0.3, 0.0, 0.0), 0.3);\n    float b = sdf_sph(p - vec3(0.2, 0.0, -0.2), 0.5);\n    float res = exp2( -32.*a ) + exp2( -32.*b );\n    return -log2( res ) / 32.;\n}\n\n// added a new sphere at the position of the purple light\nfloat sdf_uni(in vec3 p) {\n    return min(sdf_min(p), sdf_sph(p - gpos, 0.05));\n}\n\nfloat sdf(in vec3 p) {\n    return sdf_uni(p);\n}\n\n// normal vector, gradient of sdf at p\nvec3 d_sdf(in vec3 p) {\n    return vec3(\n               (sdf(p) - sdf(p - vec3(0.0001, 0., 0.))) / 0.0001, \n               (sdf(p) - sdf(p - vec3(0., 0.0001, 0.))) / 0.0001,\n               (sdf(p) - sdf(p - vec3(0., 0., 0.0001))) / 0.0001\n           );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates to y in (-1, 1), origo in (0, 0), aspect is correct\n    vec2 uv = fragCoord / iResolution.y * 2.0 - vec2(iResolution.x / iResolution.y, 1);\n   \n    \n    // moving light point\n    gpos = vec3(-0.2, sin(iTime*1.414), 0.6);\n    // rotation around the y axis\n    mat3 rot = mat3(cos(iTime), 0., -sin(iTime), \n                            0., 1.,          0., \n                    sin(iTime), 0., cos(iTime));\n   \tvec3 p = rot * vec3(uv, 1.);\n    vec3 dir = rot * vec3(0., 0., -1.);\n    \n    for(int i = 0; i < 16; ++i) {\n        p = p + dir * sdf(p) * 1.0;// * sign(dot(d_sdf(p), -dir));\n    }\n    \n    /* // Debug position\n    if(abs(sdf(p)) < 2.0) {\n   \t    fragColor = vec4(p * 0.5 + 0.5, 1.);\n        return;\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    //*/\n    \n    \n    /* // Debug final sdf value\n    if(sdf(p) > 0.1) {\n        fragColor = vec4(1.0);\n        return;\n    } else {\n        fragColor = vec4(sdf(p) * 10., -sdf(p) * 10., 0., 0.);\n        return;\n    } //*/\n    \n   \n    // normal vector\n    vec3 n = normalize(d_sdf(p));\n    \n    // blue color, from a fix direction\n    vec3 bdir = normalize(vec3(-0.3, 0.4, -0.3));\n   \tfloat bcol = dot(n, bdir);\n    \n    \n    // green color, from a moving direction\n    vec3 gdir = normalize(gpos - p);\n    float gcol = dot(n, normalize(gdir));\n    \n    // red color, from a moving point, with distance\n    vec3 rdir = normalize(gpos - p);\n   \tfloat rcol = pow(max(dot(n, rdir), 0.), 4.);\n    \n    \n    \n    if(sdf(p) > 0.1) { \n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n    else {\n        fragColor = vec4(rcol, gcol, bcol, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 73, 73, 93], [95, 95, 133, 133, 159], [161, 199, 225, 225, 415], [417, 475, 501, 501, 556], [558, 558, 580, 580, 605], [607, 646, 669, 669, 900], [902, 902, 959, 1030, 2617]], "test": "untested"}
{"id": "3tlyRr", "name": "[TWITCH] Cheshire Box Parkour", "author": "evvvvil", "description": "Cheshire Box Parkour - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["fractal", "demoscene", "abstract", "glow", "alien", "bounce", "kifs", "trippy", "scifi", "world", "architecture", "network", "twitch", "improv"], "likes": 23, "viewed": 798, "published": 3, "date": "1591289779", "time_retrieved": "2024-07-30T21:03:06.129067", "image_code": "// Cheshire Box Parkour - Result of an improvised live code session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"The Cheshire cat is probably on drugs, well, I know I am.\" - Lewis Carroll\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,bb,sbb,boxZ,boxR,g,gg;vec3 np,bp,pp,op,po,no,ld,al;//Global vars. About as boring as living in North-East of France (I should know I grew up there).\nfloat cx(vec3 p,vec3 r){return max(abs(length(p.yz)-r.x)-r.y,abs(p.x)-r.z);} //Hollow Tunbe primitive. My own primitive function, don't laugh, I'm not very good at Math but I'm better than you at skateboarding. (seriously though, wanna challenge me? game of skate? You're on broski)\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //Box Primitive. Someone elese's primitive function (told you I'm not very good at Math but I'm French so I'm good at stealing and showing off)\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//Rotate function. Short and sweet, just like the perfect argument with your partner. It never fucking is though, here we are 5 hours later like two howler monkeys hurling bananas at eachother.\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; //Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n} \t\nvec2 fb( vec3 p, float s) //fb is \"fucking bit\" function that make base geometry for the more complex network / kifs made in mp\n{\n  p.yz*=r2(sin(p.x*.5)*.5);//Rotate everything along x axis\n  p=abs(p)-vec3(4,0,0); //Everything is abs symetry cloned along the x to create mroe geom\n  vec2 h,t=vec2(length(p)-1.8,6); //Big glowy spheres\n  g+=0.1/(0.1+t.x*t.x*20.); //Glow trick from Balkhan, push distance field of geom in vairable and add at the end (see last line)\n  h=vec2(length(abs(p.yz)-vec2(1.5))-.3,6);//4 GREY cylinders on sides\n  h.x=min(h.x,cx(p,vec3(2.2,.3,.2)));//hollow tube / ring around the big glowy spheres\n  h.x=max(h.x,abs(p.y)-1.4); //Cut grey sylinders and tube to reveal the blue ones underneath\n  t=t.x<h.x?t:h;  //Merge glowy sphere and all grey shapes above\n  h=vec2(length(abs(p.yz)-vec2(1.5))-.2,5); //Make 4 blue cylinders\n  h.x=min(h.x,cx(p,vec3(2.2,.3,.2))); //Add blue hollow tube / ring around glowy spheres\n  t=t.x<h.x?t:h;  //Add all blue shapes to rest of geometries\n  h=vec2(length(p.yz-vec2(1.6,2.0))-s*min(.02,.1*sin(-p.x*.2)),3); //RED thin tubes going up the columns the variable \"s\" is to hide / show them depending on kifs we are using\n  gg+=0.1/(0.1+h.x*h.x*(200.-190.*sin(p.x*.7-tt*4.-2.)))*s;//Glow the red fuckers with animated sweep along the y axis.\n  t=t.x<h.x?t:h; //Add red fuckers to rest of scene\n  return t;\n}\nvec2 road(vec3 p){ //Road make the black / glowy road like geometry AND the bouncing cheshire boxes\n  vec2 h,t=vec2(bo(abs(p)-vec3(1.15,2.,0.),vec3(.2,.1,100.)),3); //Dull box making dull road\n  h=vec2(bo(abs(p)-vec3(1.15,2.,0.),vec3(.05,.12,100.)),6); //Everybody loves a fucking glow on the road\n  g+=(.5+0.4*abs(sin(p.z*5.))*sbb)/(0.1+h.x*h.x*(400.-sin(p.z+1.57+boxZ)*399.*sbb)); //Make it glow again, reusing boxz position of boxes to align the glow, no real math fuckery here more of some gut feeling bullshit.\n  t=t.x<h.x?t:h;  //Merge dullbox and glow bit\n  vec3 flyPos=p+vec3(0,-.2-(bb),boxZ); //We make the actual box bouncing position in flyPos, I know lame variable name but hey I'm not the one actually called \"Kevin\", you are.\n  flyPos.xy=abs(flyPos.xy)-vec2(1.15,2.);  //Somehow abs symetry cloning of pos seemed a good idea. I don't know since writting this plenty neurones went down the bottle and I even forgot pet lizard name... Dr something? Dr Dre? no wait. Dr Drizzle, that's it. Anyways what are we talking about here?\n  flyPos.yz*=r2(sin(op.z)+boxR); //Just like throwing a soft dildo at your partner's face, the boxes nicely bend as they rotate in space with \"sin(op.z)\". Also they always land on the right face with mix(3.14,0.,fract(tt*2.))\n  h=vec2(bo(flyPos,min(fract(tt*.2),.1)*10.*vec3(.05,mix(.05,.15,bb),.05)),6);//Draw the actual cheshire boxes with mad position above\n  gg+=0.1/(0.1+h.x*h.x*75.); //Make em glow a bit but this time red for bit of contrast\n  t=t.x<h.x?t:h; //Add cheshire boxes to the rest of road\n  t.x/=.6; t.x*=.8; //Tweak distance field to avoid aritfact. I know not exactly elegant to have 2 calc in a row, but then I had 7 pints in a row last friday and despite wearing a fancy hat, it wasn't elegant either.\n  return t; \n}\nvec2 mp( vec3 p )\n{ \n  op=np=p; //op is original position and it is just here to remember how p was orginally before we start tweaking the fuck outta everything\n  np.z=mod(np.z+tt*2.,75.)-37.5;  //np is the more complex position based on p which we put in loop to make a KIFS (kaleidoscopic iteration funciton system)\n  for(int i=0;i<4;i++){ //Here is our KIFS loop, I used to call it \"pseudo fractal\" because I'm not a nerd but someone self-righteous showed me the virtuous jargon-filled path and now I call them KIFS and I'm ok being a self-righteous prick.\n    np.xz=abs(np.xz)-vec2(6,6); //Push out a bit each loop, sort of a \"reverse fucking\", if you don't think about it too long. Indulge me, it's the lockdown and I have to amuse myself.\n    np.xz*=r2(.7+sin(np.z*.2)*.3); //Yeah rotate bit and add sin(np.z) to break symetry along z.\n  }\n  vec2 h,t=fb(np,0.); t.x*=0.8; //Make first bunch of geometry with kifs above\n  h=vec2(p.y,6); //Make simple \"terrain\" with plane at 0, not eveything has to be fancy marble fucking columns, this isn't some crass nouveau-riche footballer's bachelor pad.\n  t=t.x<h.x?t:h; //merge terrain and 1st kifs\n  bp=np*.5; //Create new position bp based on np but twice bigger, to make bigger round of kifs\n  bp.xz*=r2(.785); //Rotate the fuckers a bit for good luck\n  bp.xz+=vec2(.5,-2.5); //And shift them into place so it';s snug  with the first round of kifs\n  h=fb(bp,0.); h.x/=.6; //Draw 2nd bigger bit of geom with kifs, and it is snug with first one\n  t=t.x<h.x?t:h; //Merge 2nd kifs with rest\n  h=road(bp); //Make da road and the bouncing cheshire boxes because shadertoy need more comedy\n  t=t.x<h.x?t:h; //Merge road and rest\n  bp=np*.5; //yeah yeah we do it again, dumb shit i know but don't care broh\n  bp.xy*=r2(1.57); //Rotate 180 to make it stand up, yeah we making oclumns basically\n  bp.xz-=vec2(1.,1.6); //Shift columns a bit make it snug with rest\n  h=fb(bp,1.); h.x/=.7; //Here we draw column with bp position above\n  t=t.x<h.x?t:h; //Merge columns with rest\n  pp=np; //PP is the position used for BLACK boxes on terrain, it is based on np so it's also a kifs\n  pp.xz=mod(pp.xz,2.)-1.;  //Make loads of em by doing a grid of em\n  h=vec2(bo(pp,vec3(.5,1.+2.*(.5+.5*sin(np.z*.5)),.5)),3); // Draw all those black boxes\n  h.x=max(h.x,-(length(bp.yz)-3.2)); //Remove black boxes that are too close to the blue / grey kifs geometry based on bp\n  h.x=max(h.x,-(length(np.yz)-4.8)); //Remove black boxes that are too close to the blue / grey kifs geometry based on np\n  t=t.x<h.x?t:h; //Merge black boxes with rest of scene\n  t.x*=.7; //Tweak distance field of everything to avoid artifact\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>40.) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>40.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.82)+24.5;  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  bb=abs(sin(tt*2.)); //bb is an animation variable used to move boxes\n  boxZ=mix(0.,6.7,fract(tt*.2)); //boxZ is the bouncing box z pos animation variable\n  boxR=mix(3.14,0.,fract(tt*2.)); //boxR is the bouncing box angle rotation animation variable\n  sbb=1.-smoothstep(0.,1.,bb);  //sbb is the reverse of bb but also smoothed / eased animation variable\n  vec3 ro=mix(vec3(1),vec3(-1,1.7,1),ceil(sin(tt*.4)))*vec3(cos(tt*.4+.1)*2.,7.,-10),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(-.1,.5,-.3));//ld=light direction\n  co=fo=vec3(.1)-length(uv)*.1-rd.y*.1;//background is dark with vignette and small gradient along y, like a  horizon\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many brain cells I lost during my mid 2000s raving haydays.\n    float tnoi=texNoise(np.xz*.5).r;\n    if(z.y==5.) {no+=tnoi*.4;no=normalize(no);al=vec3(.0,.3,1.)*(.5+.5*cos(bp*.5))+tnoi;} //defaulkt material is gradient of blue and green with some noi\n    if(z.y<5.) al=vec3(0); //material system if less than 5 make it black\n    if(z.y>5.) al=vec3(1); //material system if more than 5 make it white\n    float dif=max(0.,dot(no,ld)-tnoi), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from shane\n    co=clamp(mix(sp+mix(vec3(.7),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(1.)),fo,min(fr,.5)),0.,1.);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich    \n  }\n  co=mix(fo,co+g*.2*vec3(0.1,.2,.7)+gg*.1*mix(vec3(1.,.1,.0),vec3(.7,0.2,.1),.5+.5*sin(np.y*.5)),exp(-.0001*t*t*t)); //Fog soften things, but it won't stop your annoying uncle from thinking \"Bloody fiddling with bloody numbers, ain't gonna get you a job, son. Real graft is what ye need, wee man.\"(last sentence read with Scottish accent if you can)\n  fragColor = vec4(pow(co,vec3(.65)),1); //Add glow at the end. g & gg are red and blue glow global variables containg distance fields see lines 42,50,58\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 460, 484, 484, 536], [537, 743, 767, 767, 808], [809, 953, 970, 970, 1013], [1013, 1207, 1230, 1230, 1539], [1542, 1542, 1671, 1671, 2904], [2905, 2905, 2923, 3004, 4684], [4685, 4685, 4704, 4704, 7337], [7338, 7338, 7419, 7419, 8185], [8275, 8275, 8404, 8404, 11630]], "test": "untested"}
{"id": "WlsyRr", "name": "Day 168 - Quadtree", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 19, "viewed": 458, "published": 3, "date": "1591286743", "time_retrieved": "2024-07-30T21:03:06.955856", "image_code": "// This is a classifier of quadtree points, but it doesn't build the actual structure. \n// That would require a bit different of an approach \n\n\nvec2 r12(float i){\n\treturn texture(iChannel0,vec2(mod(i,256.)/256.,floor(i/256.)*256.)).xy*2. - 1.;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U- 0.5*iResolution.xy)/iResolution.y;\n\n    //uv /= dot(uv,uv)*19.;\n    \n    vec3 col = vec3(0);\n\n    \n    float id = 0.;\n    \n    float d = 10e6;\n    float dside = 10e6;\n    \n    #define ITERS 25.\n    #define DOTS 10.\n    \n    for(float i = 0.; i < 19.; i++){\n    \tvec2 p = r12(i+24.)/1.;\n        \n        p.xy += vec2(sin(i+iTime),cos(i+iTime))/20.;\n        \n        d = min(d, length(p-uv));\n        \n        \n        for(float k = 1.; k < pow(2.,ITERS); k*=2.){\n\t\t\n        \tdside = min(dside, abs(max(abs(fract((uv.y)*k) - 0.5), abs(fract((uv.x)*k)) - 0.5)-0.5)/k);\n            \n            vec2 uid = floor(uv*k)/(k);\n            \n            float stsz = 1./k;\n            if(p.x < uid.x + stsz && p.x > uid.x && p.y < uid.y+stsz && p.y > uid.y ){\n            \t//id+= uid.y + uid.x*1. + 4.;\n                id += 3.6;\n            } else {\n            \tbreak;\n            }\n            \n        }\t\n    \n    }\n    \n    col += 0.5 + sin(id + vec3(1.,0.5,0.5))/3.;\n    \n    float dw = 0.005;\n    float dott = smoothstep(dw*1.4,dw,d);\n    dside = smoothstep(dw*1.04,dw,dside);\n    \n    col -= vec3(0.,0.4,0.8)*dside;\n    \n    col = mix(col,vec3(1,0.1,0.4),dott);\n    \n    \n    C = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 162, 162, 245], [246, 246, 287, 287, 1500]], "test": "untested"}
{"id": "3tsyzn", "name": "Quasicrystals – The Cut Method", "author": "natpbs", "description": "Generate a generalized penrose tiling through the cut method.\n\nThis has been a work in progress for so much time that I decided to release this version as is and start from scratch ':D", "tags": ["tiling", "tessellation", "penrose", "quasicrystals", "nonperiodic"], "likes": 0, "viewed": 124, "published": 3, "date": "1591280029", "time_retrieved": "2024-07-30T21:03:07.951195", "image_code": "/* ==== Types ====*/\n\nstruct vec5 {\n    // first 2 entries\n    vec2 a;\n    // last 3 entries\n    vec3 b;\n};\n    \nstruct mat5 {\n    // first 2 columns\n\tmat2 a; mat2x3 b;\n    // last 3 columns\n    mat3x2 c; mat3 d;\n};\n    \n/* ==== Constants ====*/\n\nconst float tau = 2.*acos(-1.);\nconst float a = sqrt(2./5.);\nconst float b = 2.*acos(-1.)/5.;\nconst mat5 B = mat5(\n a * mat2(\n  1.,cos(b),\n  0.,sin(b)\n ),\n a * mat2x3(\n  cos(2.*b),cos(3.*b),cos(4.*b),\n  sin(2.*b),sin(3.*b),sin(4.*b)\n ),\n a * mat3x2(\n  1.,cos(2.*b),\n  0.,sin(2.*b),\n  sqrt(.5),sqrt(.5)\n ),\n a * mat3(\n  cos(4.*b),cos(b),cos(3.*b),\n  sin(4.*b),sin(b),sin(3.*b),\n  sqrt(.5),sqrt(.5),sqrt(.5)\n )\n);\n\nconst mat5 Bt = mat5(\n    transpose(B.a), transpose(B.c),\n    transpose(B.b), transpose(B.d)\n    );\n\n#define wedgeTwo(u) vec2(u.y, -u.x)\n#define wedgeThree(v1, v2) cross(v1, v2)\n\nconst vec2 Z[5] = vec2[5](\n    wedgeTwo(Bt.a[0]),\n    wedgeTwo(Bt.a[1]),\n    wedgeTwo(Bt.c[0]),\n    wedgeTwo(Bt.c[1]),\n    wedgeTwo(Bt.c[2])\n);\n\nconst float detF[10] = float[10](\n    dot(Bt.a[0], Z[1]), // 0,1\n\tdot(Bt.a[0], Z[2]), // 0,2\n\tdot(Bt.a[0], Z[3]), // 0,3\n\tdot(Bt.a[0], Z[4]), // 0,4\n\tdot(Bt.a[1], Z[2]), // 1,2\n\tdot(Bt.a[1], Z[3]), // 1,3\n\tdot(Bt.a[1], Z[4]), // 1,4\n\tdot(Bt.c[0], Z[3]), // 2,3\n\tdot(Bt.c[0], Z[4]), // 2,4\n\tdot(Bt.c[1], Z[4]) // 3,4 \n);\n\nconst ivec2 indexF[10] = ivec2[10](\n    ivec2(1,0),\n    ivec2(2,0),\n    ivec2(3,0),\n    ivec2(4,0),\n    ivec2(2,1),\n    ivec2(3,1),\n    ivec2(4,1),\n    ivec2(3,2),\n    ivec2(4,2),\n    ivec2(4,3)\n);\n\nconst vec3 W[10] = vec3[10](\n    wedgeThree(Bt.b[0], Bt.b[1]), // 0 - 0,1\n    wedgeThree(Bt.b[0], Bt.d[0]), // 1 - 0,2\n    wedgeThree(Bt.b[0], Bt.d[1]), // 2 - 0,3\n    wedgeThree(Bt.b[0], Bt.d[2]), // 3 - 0,4\n    wedgeThree(Bt.b[1], Bt.d[0]), // 4 - 1,2\n    wedgeThree(Bt.b[1], Bt.d[1]), // 5 - 1,3\n    wedgeThree(Bt.b[1], Bt.d[2]), // 6 - 1,4\n    wedgeThree(Bt.d[0], Bt.d[1]), // 7 - 2,3\n    wedgeThree(Bt.d[0], Bt.d[2]), // 8 - 2,4\n    wedgeThree(Bt.d[1], Bt.d[2]) // 9 - 3,4\n);\n\nconst float detG[10] = float[10](\n\tdot(Bt.d[0], W[9]), // 0 - 2,3,4\n\tdot(Bt.b[1], W[9]), // 1 - 1,3,4\n\tdot(Bt.b[1], W[8]), // 2 - 1,2,4\n\tdot(Bt.b[1], W[7]), // 3 - 1,2,3\n\tdot(Bt.b[0], W[9]), // 4 - 0,3,4\n\tdot(Bt.b[0], W[8]), // 5 - 0,2,4\n\tdot(Bt.b[0], W[7]), // 6 - 0,2,3\n\tdot(Bt.b[0], W[6]), // 7 - 0,1,4\n\tdot(Bt.b[0], W[5]), // 8 - 0,1,3\n\tdot(Bt.b[0], W[4]) // 9 - 0,1,2\n);\n\nconst ivec3 indexG[10] = ivec3[10](\n\tivec3(9,8,7), // 0\n\tivec3(9,6,5), // 1\n\tivec3(8,6,4), // 2\n\tivec3(7,5,4), // 3\n\tivec3(9,3,2), // 4\n\tivec3(8,3,1), // 5\n\tivec3(7,2,1), // 6\n\tivec3(6,3,0), // 7\n\tivec3(5,2,0), // 8\n\tivec3(4,1,0) // 9\n);\n\n#define translate 2\nconst vec3 bin = vec3(0,-1,1);\nconst vec5 K[] = vec5[](\n\tvec5(bin.xx, bin.xxx)\n    #if translate>0\n    ,\n\tvec5(bin.yx, bin.xxx),\n\tvec5(bin.xy, bin.xxx),\n\tvec5(bin.xx, bin.yxx),\n\tvec5(bin.xx, bin.xyx),\n\tvec5(bin.xx, bin.xxy)\n    #endif\n    #if translate>1\n    ,\n\tvec5(bin.zx, bin.xxx),\n\tvec5(bin.xz, bin.xxx),\n\tvec5(bin.xx, bin.zxx),\n\tvec5(bin.xx, bin.xzx),\n\tvec5(bin.xx, bin.xxz)\n    #endif\n);\n\n/* ==== Functions ==== */\n\nvec5 fract5(vec5 x) {\n    x.a = fract(x.a);\n    x.b = fract(x.b);\n    return x;\n}\n\nvec5 plus(vec5 x, vec5 y) {\n    x.a += y.a;\n    x.b += y.b;\n    return x;\n}\n\nvec5 fiveFromTwo(vec2 u) {\n    vec5 x = vec5(\n        B.a * u,\n        B.b * u\n    );\n    return x;\n}\n\nvec5 fiveFromThree(vec3 v) {\n    vec5 x = vec5(\n        B.c * v,\n        B.d * v\n    );\n    return x;\n}\n\nvec2 twoFromFive(vec5 x) {\n    vec2 u = x.a * B.a + x.b * B.b;\n    return u;\n}\n\nvec3 threeFromFive(vec5 x) {\n    vec3 v = x.a * B.c + x.b * B.d;\n    return v;\n}\n\nfloat [5] getZed(vec2 u) {\n    float z[5];\n    for (int j=0; j<5; j++) {\n        z[j] = dot(Z[j], u);\n    }\n    return z;\n}\n\nfloat [10] getWiu(vec3 v) {\n    float w[10];\n    for (int j=0; j<10; j++) {\n        w[j] = dot(W[j], v);\n    }\n    return w;\n}\n\nvec5 getTile(float z[5], float w[10]) {\n    for (int j=0; j<10; j++) {\n        ivec2 iF = indexF[j];\n        float dF = detF[j];\n        vec2 aF = vec2(z[iF.x],-z[iF.y])/dF;\n        vec2 bin = vec2(0,1);\n        if( any(lessThan(aF,bin.xx)) || any(greaterThan(aF,bin.yy)) ) {\n            continue;\n        }\n        ivec3 iG = indexG[j];\n        float dG = detG[j];\n        vec3 aG = -vec3(w[iG.x],-w[iG.y],w[iG.z])/dG;\n        # define noGCheck 0\n        # if noGCheck\n        \taG = vec3(.1);\n        # endif\n        if( all(greaterThanEqual(aG,bin.xxx)) && all(lessThanEqual(aG,bin.yyy)) ) {\n  \t\t    vec5 a = vec5(aF, aG);\n            return a;\n        }\n    }\n    vec5 a = vec5(vec2(2),vec3(2));\n    return a;\n}\n/* ==== Main ==== */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n    vec3 offset3 = vec3(\n        (iMouse.xy - .5*iResolution.xy) / iResolution.x,\n        .2*(fract(iTime / 60.) - .5)\n    );\n    vec5 offset5 = fiveFromThree(offset3);\n    vec2 u = 4.*(fragCoord - iResolution.xy / 2.) / iResolution.x;\n    vec5 x = fiveFromTwo(u);\n    x = plus(x, offset5);\n    \n    // x = fract5(x);\n    // x = plus(x, vec5(bin.xx, bin.xxx));\n    for (int j = 0; j<K.length(); j++) {\n            vec5 k = K[j];\n            vec5 xk = plus(x, k);\n        vec2 u = twoFromFive(xk);\n        vec3 v = threeFromFive(xk);\n\n        float z[5] = getZed(u);\n        float w[10] = getWiu(v);\n\n        vec5 a = getTile(z, w);\n        if (a.a.x != 2.) {\n        \tfragColor.rgb = .5*a.b + .5*vec3(0, a.a);\n            return;\n        }\n    }\n    \n    ivec2 iCoord = ivec2(fragCoord/iResolution.xy*255.);\n    fragColor.rgb = 1. / 255. * vec3(\n        iCoord.x,\n        iCoord.y,\n        iCoord.x ^ iCoord.y\n    ).brg;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3044, 3044, 3065, 3065, 3125], [3127, 3127, 3154, 3154, 3202], [3204, 3204, 3230, 3230, 3305], [3307, 3307, 3335, 3335, 3410], [3412, 3412, 3438, 3438, 3490], [3492, 3492, 3520, 3520, 3572], [3827, 3827, 3866, 3866, 4541], [4564, 4564, 4619, 4619, 5567]], "test": "untested"}
{"id": "Wlsyzn", "name": "ORIGAMI KING GOOMBA", "author": "yasuo", "description": "Hey! I'm Goomba and waiting for Mario, who will stamp on me.", "tags": ["mario", "reproduction"], "likes": 6, "viewed": 430, "published": 3, "date": "1591279047", "time_retrieved": "2024-07-30T21:03:08.985430", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n// The modeling is based on simple plane distance and created a useful custom box distance function that is easy for me to model.\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 80.\n#define SURF_DIST .002\n#define GOOMBA_THICKNESS 0.05\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat customBoxDist(vec3 p, vec4 btm, vec4 top, vec4 rt, vec4 lt, vec4 fw, vec4 b) {\n    float p1 = dot(p,btm.xyz) + btm.w;\n    float p2 = dot(p,top.xyz) + top.w;\n    float p3 = dot(p,rt.xyz) + rt.w;\n    float p4 = dot(p,lt.xyz) + lt.w;\n    float p5 = dot(p,fw.xyz) + fw.w;\n    float p6 = dot(p,b.xyz) + b.w;\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\n// 2D distance box https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 origamiPattern(vec2 p, vec3 col, vec3 colA, vec3 colB) {\n    mat2 rot = Rot(radians(45.0));\n\tfloat d = sdBox(p*rot,vec2(0.1));\n    d = max(-p.x,d);\n    col = mix(col,colA,S(d,0.0));\n    d = sdBox(p*rot,vec2(0.1));\n    d = max(p.x,d);\n    col = mix(col,colB,S(d,0.0));\n    return col;\n}\n\nvec3 background(vec2 p, vec3 col){\n    p*=2.0;\n    p.x+=sin(iTime*0.5)*1.0;\n    vec2 prevP = p;\n    vec3 colA = vec3(0.5,0.7,0.8)*1.05;\n    vec3 colB = vec3(0.4,0.6,0.7)*1.15;\n    \n    p.x = mod(p.x,0.29)-0.145;\n    p.y = mod(p.y,0.29)-0.145;\n    \n    col = origamiPattern(p,col,colA,colB);\n    p = prevP;\n    \n    p.x+=0.145;\n    p.y+=0.145;\n\tp.x = mod(p.x,0.29)-0.145;\n    p.y = mod(p.y,0.29)-0.145;\n    \n    col = origamiPattern(p,col,colA,colB);\n    \n    return col;\n}\n\nvec3 floorMat(vec2 p, vec3 col){\n    p*=0.3;\n    vec2 prevP = p;\n    vec3 colA = vec3(0.3,0.5,0.3);\n    vec3 colB = vec3(0.3,0.5,0.3)*0.9;\n    \n    p.x = mod(p.x,0.28)-0.14;\n    p.y = mod(p.y,0.28)-0.14;\n    \n    col = origamiPattern(p,col,colA,colB);\n    p = prevP;\n    \n    p.x+=0.14;\n    p.y+=0.14;\n\tp.x = mod(p.x,0.28)-0.14;\n    p.y = mod(p.y,0.28)-0.14;\n    \n    col = origamiPattern(p,col,colA,colB);\n    \n    return col;\n}\n\nfloat goombaDist1(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(-3.0,-size,0.0,1.5); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right     \n    vec4 a4 = vec4(-size,1.0,0.0,0.3); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist2(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm \n    vec4 a2 = vec4(0.0,-size,0.0,1.9); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.7); // right      \n    vec4 a4 = vec4(-size,0.0,0.0,0.7); // left         \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward              \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist3(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(-0.5,-size,0.0,0.3); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.5); // right      \n    vec4 a4 = vec4(-size,0.7,0.0,0.75); // left           \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward            \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist4(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(-0.7,size,0.0,0.3); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.3); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.4); // right      \n    vec4 a4 = vec4(-size,0.0,0.0,0.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward            \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist5(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.3); // top   \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right       \n    vec4 a4 = vec4(-size,0.0,0.0,0.2); // left           \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward               \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return  customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist6(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.3); // btm\n    vec4 a2 = vec4(-1.0,-size,0.0,0.04); // top   \n    vec4 a3 = vec4(size,0.0,0.0,0.1); // right        \n    vec4 a4 = vec4(-size,0.0,0.0,0.1); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward               \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist7(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.3); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.105); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.08); // right       \n    vec4 a4 = vec4(-size,0.0,0.0,0.08); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward               \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist8(vec3 p) {\n    float size = 2.0;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,-1.0); // btm\n    vec4 a2 = vec4(-size*2.0,-size,0.0,3.0); // top  \n    vec4 a3 = vec4(size,-size*0.5,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,1.0,0.0,1.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist9(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(-0.3,size,0.0,-0.8); // btm\n    vec4 a2 = vec4(0.5,-size,0.0,1.0); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.7); // right     \n    vec4 a4 = vec4(-size,-1.5,0.0,1.5); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist10(vec3 p) {\n    float size = 2.0;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,-1.4); // btm\n    vec4 a2 = vec4(-size*2.0,-size,0.0,2.0); // top  \n    vec4 a3 = vec4(size,-size*0.5,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,1.0,0.0,1.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist11(vec3 p) {\n    float size = 2.0;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,-1.6); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,2.0); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.33); // right     \n    vec4 a4 = vec4(-size,0.0,0.0,0.33); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat floorDist(vec3 p) {\n    float size = 1.0;\n    \n    vec4 a1 = vec4(0.0,size,0.0,0.0); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.05); // top  \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,0.0,-size*0.5,1.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,1.0); // foward\n    vec4 a6 = vec4(0.0,0.0,size,1.0); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nvec4 goomba(vec3 p) {\n    vec3 prevP = p;\n    \n    // face1\n    p.x = abs(p.x);\n    p.x-=0.6;\n    float g1 = goombaDist1(p);\n    p = prevP;\n    float g2 = goombaDist2(p);\n    float resG = min(g1,g2);\n    \n    vec4 res1 = vec4(vec3(0.7,0.38,0.0),resG*0.5);\n        \n    // kind of chin, don't know what we call this part.\n    p.x = abs(p.x);\n    p.x-=0.3;\n    \n    mat3 rot = matRotateX(radians(-20.0));\n    \n    g1 = goombaDist3((p-vec3(0.0,0.0,0.2))*rot);\n    resG = g1;\n    p = prevP;\n    vec4 res2 = vec4(vec3(0.7,0.38,0.0),resG*0.5);\n    \n    // body\n    p.x = abs(p.x);\n    p.x-=0.4;\n    g1 = goombaDist4(p-vec3(0.0,-0.4,0.1));\n    p = prevP;\n    g2 = goombaDist5(p-vec3(0.0,-0.4,0.1));\n    p = prevP;\n    resG = min(g1,g2);\n    vec4 res3 = vec4(vec3(0.9,0.8,0.5),resG*0.5);\n    \n    // legs\n    p*=0.8;\n    p.x = abs(p.x);\n    p.x-=0.4;\n  \n    p.x = abs(p.x);\n    p.x-=0.16;\n    g1 = goombaDist6(p-vec3(0.0,-0.5,0.05));\n    \n    p.x+=0.12;\n    g2 = goombaDist7(p-vec3(0.0,-0.5,0.05));\n    resG = min(g1,g2);\n    vec4 res4 = vec4(vec3(0.5,0.2,0.0),resG*0.5);\n    p = prevP;\n    \n    // teeth\n    p.x*=2.0;\n    p.x = abs(p.x);\n    p.x-=0.95;\n    g1 = goombaDist8(p-vec3(0.0,-0.7,0.1));\n    resG = g1;\n    vec4 res5 = vec4(vec3(1.0),resG*0.5);\n    p = prevP;\n    \n    // eyebrow\n    p.x = abs(p.x);\n    p.x-=0.5;\n    g1 = goombaDist9(p-vec3(0.0,0.5,0.1));\n    resG = g1;\n    vec4 res6 = vec4(vec3(0.3),resG*0.5);\n    p = prevP;\n    \n    // eye\n    p.x = abs(p.x);\n    p.x -=0.3;\n    p.y -= 0.65;\n    p.x*=0.9;\n    p.y*=1.5;\n    p.y = abs(p.y);\n    p.y+=0.55;\n    g1 = goombaDist10(p-vec3(0.0,0.0,0.1));\n    p = prevP;\n\tp.x = abs(p.x);\n    p.x -=0.3;\n    p.y -= 0.6;\n    g2 = goombaDist11(p-vec3(0.0,-0.85,0.1));\n    resG = min(g1,g2);\n    vec4 res7 = vec4(vec3(1.0),resG*0.5);\n    p = prevP;\n    \n    // eye ball\n    p.x*=2.0;\n    p.y*=0.8;\n    p.x = abs(p.x);\n    p.x -=0.6;\n\tg1 = goombaDist11(p-vec3(0.0,-0.37,0.13));\n    resG = g1;\n    vec4 res8 = vec4(vec3(0.1),resG*0.5);\n    \n    return combine(combine(combine(combine(combine(combine(combine(res1,res2),res3),res4),res5),res6),res7),res8);\n}\n\nfloat fflowerDist1(vec3 p) {\n\tfloat size = 3.5;\n    float thickness = GOOMBA_THICKNESS;\n    \n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(-2.0,-size,0.0,1.0); // top  \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,0.0,0.0,0.75); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat fflowerDist2(vec3 p) {\n\tfloat size = 3.5;\n    float thickness = GOOMBA_THICKNESS;\n    \n    vec4 a1 = vec4(0.0,size,0.0,1.86); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,1.86); // top  \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,0.0,0.0,0.8); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat leafDist(vec3 p) {\n    vec3 prevP = p;\n    p.x*=0.9;\n    p.x = abs(p.x);\n    p.x -=0.5;\n    p.y = abs(p.y);\n    p.y -= 0.1;\n    float f1 = fflowerDist1(p);\n    p = prevP;\n    p.x*=0.9;\n    float f2 = fflowerDist2(p);\n    \n    return min(f1,f2);\n}\n\nvec4 fflower(vec3 p) {\n    vec3 prevP = p;\n\tfloat f1 = leafDist(p-vec3(0,0.6,0.0));\n    float resF = f1;\n    vec4 res1 = vec4(vec3(0.9,0.0,0.0),resF*0.5);\n    p = prevP;\n    \n    p.xy*=1.3;\n    f1 = leafDist(p-vec3(0,0.8,0.05));\n    resF = f1;\n    vec4 res2 = vec4(vec3(1.0,0.6,0.0),resF*0.5);\n    p = prevP;\n    \n    p.xy*=1.8;\n    f1 = leafDist(p-vec3(0,1.1,0.1));\n    resF = f1;\n    vec4 res3 = vec4(vec3(1.0,0.9,0.0),resF*0.5);\n    p = prevP;\n    \n    // eye\n    p.x*=5.0;\n    p.y*=4.0;\n    p.x = abs(p.x);\n    p.x-=1.0;\n    f1 = fflowerDist2(p-vec3(0,2.5,0.15));\n    resF = f1;\n\tvec4 res4 = vec4(vec3(0.1),resF*0.5);\n    p = prevP;\n    \n    // branch\n    p.x*=2.5;\n    f1 = fflowerDist2(p-vec3(0,-0.15,-0.05));\n    resF = f1;\n\tvec4 res5 = vec4(vec3(0.5,0.9,0.0),resF*0.5);\n    p = prevP;\n    \n    // leaf\n    mat3 rot = matRotateZ(radians(50.0));\n    p.y+=0.2;\n    p.x = abs(p.x);\n    p.x -=0.5;\n    p*=rot;\n    p.x *=1.8;\n    p.y *=1.2;\n    \n    p.xy = abs(p.xy);\n    p.xy -= vec2(0.2,0.1);\n    \n    f1 = fflowerDist1((p-vec3(0,0.0,-0.05)));\n    resF = f1;\n\tvec4 res6 = vec4(vec3(0.4,0.9,0.0),resF*0.5);\n    \n    return combine(combine(combine(combine(combine(res1,res2),res3),res4),res5),res6);\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n\t\n    // ground\n    p.xz*=0.2;\n    p.xz = abs(p.xz);\n    p.xz -=1.;\n\n    float _floor = floorDist(p+vec3(0.0,0.7,0.0));\n    vec4 f = vec4(floorMat(prevP.xz,vec3(0.5,0.7,0.8)),_floor*0.6);\n    \n    // goomba\n    p = prevP;\n    float c = 2.0;\n    p.z+=3.0;\n    float l = 2.0;\n    p.z += -c*clamp(round(p.z/c),-l,l);\n    \n    float k = sin(iTime*6.0)*0.1;\n    c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    p.xz*=m;\n    \n    mat3 rot = matRotateX(radians(sin(iTime*6.0)*5.0));\n    vec4 g = goomba((p -vec3(0.0,0.25,0.0))*rot);\n    \n    // fire flower\n    p = prevP;\n    p.z+=2.5;\n    p.x=abs(p.x);\n    p.x-=3.0;\n    vec4 ff = fflower(p);\n    \n    vec4 model = combine(f,combine(g,ff));\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    float shadow = shadowMap(p + n * 0.001, l);\n\n    return vec2((lambert+dif),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(180.0)+radians(sin(iTime*0.5)*60.0));\n    ro.yz *= Rot(radians(30.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(0.5,0.7,0.8);\n        col = background(uv,col)*1.2;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlsyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[781, 781, 822, 822, 913], [915, 915, 951, 951, 993], [995, 995, 1079, 1079, 1383], [1385, 1452, 1489, 1489, 1569], [1571, 1571, 1632, 1632, 1861], [1863, 1863, 1897, 1897, 2335], [2337, 2337, 2369, 2369, 2766], [2768, 2768, 2795, 2795, 3220], [3222, 3222, 3249, 3249, 3688], [3690, 3690, 3717, 3717, 4157], [4159, 4159, 4186, 4186, 4624], [4626, 4626, 4653, 4653, 5097], [5099, 5099, 5126, 5126, 5571], [5573, 5573, 5600, 5600, 6045], [6047, 6047, 6074, 6074, 6511], [6513, 6513, 6540, 6540, 6967], [6969, 6969, 6997, 6997, 7434], [7436, 7436, 7464, 7464, 7891], [7893, 7893, 7918, 7918, 8302], [8304, 8304, 8325, 8325, 10405], [10407, 10407, 10435, 10435, 10863], [10865, 10865, 10893, 10893, 11321], [11323, 11323, 11347, 11347, 11575], [11577, 11577, 11599, 11599, 12780], [12782, 12782, 12804, 12804, 13561], [13563, 13563, 13596, 13596, 13849], [13851, 13851, 13885, 13885, 14199], [14201, 14201, 14225, 14225, 14426], [14428, 14428, 14451, 14451, 14798], [14800, 14800, 14842, 14842, 15037], [15039, 15039, 15096, 15096, 15851]], "test": "untested"}
{"id": "tlXyzr", "name": "International Shipping", "author": "blackle", "description": "International shipping, ported to shadertoy! complete with the correct water heightmap and multisampling.\n\nTakes about 2 seconds at 60 fps for the water heightmap to finish computing and multisampling to begin. watch the loading bar.", "tags": ["boat", "origami", "revision2019"], "likes": 133, "viewed": 2974, "published": 3, "date": "1591268774", "time_retrieved": "2024-07-30T21:03:10.279969", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9 * .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float ltime = float(iFrame)/float(WAVE_DEPTH);\n\n\tvec2 uv = (fragCoord/iResolution.xy*2.0-1.0)/2.0;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.xyz /= fragColor.w;\n\n    float seed = hash(min(1.,ltime), hash(uv.x,uv.y));\n\tfragColor += pow(seed,2.)*0.2 *vec4(0.8,0.9,1.0,0.); //noise\n\tfragColor *= (1.0 - pow(length(uv)*0.70, 2.0)); //vingetting lol\n\tfragColor = pow(log(fragColor+1.0), vec4(1.3))*1.25; //colour grading\n    \n    if (fragCoord.y < 10. && ltime < 1.) {\n        float grad = sin(fragCoord.y/10.*3.14);\n        float bright = pow(clamp(sin(fragCoord.y/15.*3.14),0.,1.),20.);\n        float barpos = smoothstep(-1., 1., ltime*iResolution.x - fragCoord.x);\n        fragColor.xyz = grad*mix(vec3(.1), vec3(.9,0.1,0), barpos) + bright*0.3;\n        return;\n    }\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//generates the heightmap for the waves.\n//in the original C code, there was only one seed. in order to improve performance by doing this on the GPU,\n//I split the FFT calculation across multiple frames, and each frame has a different starting seed.\n#define WAVE_SAMPLES 1024\nuint rndseeds[WAVE_DEPTH] = uint[WAVE_DEPTH](\n920413359u,344147060u,354025938u,2510083042u,2912208450u,663489309u,61347429u,1209816006u,2738590810u,1234092029u,2528347578u,650889515u,2709794373u,2069110031u,3520323237u,2915168753u,\n2322632710u,2989421851u,4280850451u,1474778517u,2881594422u,2265295789u,1910491705u,2277565322u,707509521u,4060625072u,1372978273u,1639299946u,3485656693u,2998509085u,782651004u,2758988468u,\n493098580u,3703975077u,1132795244u,576308370u,4166192603u,3865744844u,778731983u,3968879059u,2600244750u,3395962586u,2377424722u,4075108333u,315984429u,1583277414u,3826192035u,586903153u,\n1054474534u,745246921u,4256406772u,463193934u,4136561045u,3304490676u,341015040u,1744393505u,972704065u,1478460815u,1812621133u,1603688544u,133969005u,2700557178u,331483363u,3460139081u,\n2871210438u,728092432u,1103924991u,3631508649u,754385041u,3315783261u,2534947633u,4169942121u,2234451975u,784357094u,2163247278u,736096301u,46193931u,561970122u,1297583479u,2406700841u,\n3250333395u,4178599644u,3702373126u,765792619u,2445818533u,2923499364u,2779363917u,3023050847u,1398972607u,1789970279u,609453859u,2893149445u,1569196009u,849325608u,2774450625u,3723681545u,\n2566077401u,3280027661u,3653271294u,4104918169u,1195760183u,4160009305u,3870009279u,1062551007u,2914502300u,909266381u,319407879u,3833525574u,3364539115u,2669656718u,2439999609u,4245366155u,\n2936252450u,1040930787u,2376589173u,1582139829u,1312299439u,539453860u,982510869u,1214352644u,652148852u,3976312046u,4133709151u,2936335549u,3245026616u,2197966989u,1791165629u,616285886u);\n\nuint randomstate;\nfloat rand_float() {\n\trandomstate = randomstate ^ (randomstate << 13u);\n\trandomstate = randomstate ^ (randomstate >> 17u);\n\trandomstate = randomstate ^ (randomstate << 5u);\n\trandomstate *= 1685821657u;\n\tuint intermediate = ( (randomstate & 0x007FFFFFu) | 0x3F800000u );\n\treturn uintBitsToFloat(intermediate) - 1.0;\n}\n\nfloat rand_gauss() {\n\tfloat a = 0.0;\n\tfor (int i = 0; i < 12; i++) {\n\t\ta += rand_float();\n\t}\n\treturn a - 6.0;\n}\n\nfloat phillips_spectrum(float x, float y) {\n\tfloat scale = 250.0;\n\tx *= scale; y *= scale;\n\tfloat k = x*x+y*y;\n    if (k == 0.) return 0.0;\n\tif (k > float(WAVE_SAMPLES/2)) return 0.0;\n\treturn exp(-2.0/k)/(k*k) * y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int i = iFrame;\n    if (i >= WAVE_DEPTH) return;\n    randomstate = rndseeds[i];\n    for (int j = 0; j < WAVE_DEPTH; j++) {\n\t\tfloat x = float(i)/float(WAVE_SAMPLES);\n\t\tfloat y = float(j)/float(WAVE_SAMPLES);\n        float ps = phillips_spectrum(x, y);\n        \n    \tif (i == 0 && j <= 92) continue;\n        float re = rand_gauss()*ps;\n        float im = rand_gauss()*ps;\n        float t = dot(-uv, vec2(j,i))*acos(-1.)*2.;\n        fragColor += sin(t)*re + cos(t)*im;\n\t}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//original International Shipping shader. not much different here.\n//it waits until the wave heightmap is done calculating (WAVE_DEPTH frames, see Common) before doing multisampling.\n\n#define MAXDEPTH 4\n\nfloat maxdist = 100.0;\nvec3 suncol = vec3(1.5,1.0,0.6);\nvec3 skycol = vec3(0.4,0.75,1.0);\nvec3 sundir = normalize(vec3(-1.0,-1.0,0.1));\n\nuint rand = 0u;\nvoid stepState()\n{\n\trand = rand ^ (rand << 13u);\n\trand = rand ^ (rand >> 17u);\n\trand = rand ^ (rand << 5u);\n\trand *= 1685821657u;\n}\n\nvoid feed(float value)\n{\n\trand += floatBitsToUint(value);\n\tstepState();\n}\n\nfloat getFloat() {\n\tstepState();\n\treturn uintBitsToFloat( (rand & 0x007FFFFFu) | 0x3F800000u ) - 1.5;\n}\n\nvec3 getVec3() {\n\treturn vec3(getFloat(),getFloat(),getFloat());\n}\n\nstruct Ray\n{\n\tvec3 m_origin;\n\tvec3 m_direction;\n\tvec3 m_point;\n\tint m_intersected;\n\tvec3 m_color;\n\tvec3 m_attenuation;\n};\n\nRay newRay(vec3 origin, vec3 direction, vec3 attenuation) {\n\t// Create a default ray\n\treturn Ray(origin, direction, origin, 0, vec3(0.0), attenuation);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n\tvec3 cb = c - b; vec3 pb = p - b;\n\tvec3 ba = b - a; vec3 pa = p - a;\n\tvec3 ac = a - c; vec3 pc = p - c;\n\tvec3 nor = cross( ba, ac );\n\n\treturn sqrt(\n\t(sign(dot(cross(ba,nor),pa)) +\n\t sign(dot(cross(cb,nor),pb)) +\n\t sign(dot(cross(ac,nor),pc))<2.0)\n\t ?\n\t min( min(\n\t dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n\t dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n\t dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n\t :\n\t dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\nfloat scene(vec3 p) {\n\tvec3 point = vec3(abs(p.xy), p.z+0.04);\n\tif (length(point)>0.8) return 0.8;\n\tfloat scale = 3.5;\n\tpoint *= scale;\n\tpoint += sin(point.yzx*6.0)*0.005;\n\n\t// return bottle(p4b);\n\tvec3 mast = vec3(0.03, 0.0, 1.8);\n\tvec3 keel = vec3(0.0, 0.3, 0.0);\n\tvec3 port = vec3(0.0, 0.9, 0.7);\n\tvec3 port_bow = vec3(1.0, 0.0, 0.0);\n\tvec3 bow = vec3(1.9, 0.0, 1.2);\n\tvec3 mid = vec3(0.02, 0.5, 0.4);\n\n\tfloat tri1 = udTriangle(point, mast, mid, port_bow);\n\tfloat tri2 = udTriangle(point, port, keel, port_bow);\n\tfloat tri3 = udTriangle(point, port, bow, port_bow);\n\n\treturn (min(min(tri2, tri3),tri1)-0.01+cos(p.x*8.0)*.005)/scale;\n}\n\nfloat wake(vec2 uv) {\n\tvec2 uvm = vec2(uv.x,sqrt(uv.y*uv.y+0.0004));\n\tvec2 wakeangle = normalize(vec2(1.0));\n\tvec2 wakeangleflipped = vec2(wakeangle.y,-wakeangle.x);\n\n\tfloat wakeangledot = dot(uvm,wakeangle);\n\tfloat wakeangleflippeddot = dot(uvm,wakeangleflipped);\n\n\n\tfloat xwiggly = sqrt(1.0-8.0*wakeangledot/(1.0+8.0*abs(wakeangledot)));\n\n\tfloat distance = xwiggly*(wakeangledot > 0.0 ? abs(wakeangleflippeddot) : length(uvm));\n\treturn sign(wakeangleflippeddot)*sin(distance*120.0)*exp(-distance*20.0-wakeangledot*5.0);\n}\n\nfloat heightmap(vec2 uv) {\n\tfloat height = texture(iChannel0, uv*0.15).x*0.04+0.01;\n\treturn height - (wake(vec2(0.28,0.0)-uv)+wake(-uv)+0.1*wake(vec2(-0.3,0.0)-uv))*0.025;\n}\n\nvec2 epsi = vec2(0.0005, 0.0);\nvec3 heightmapNormal(vec2 uv) {\n\tfloat xdiff = heightmap(uv) - heightmap(uv+epsi.xy);\n\tfloat ydiff = heightmap(uv) - heightmap(uv+epsi.yx);\n\treturn normalize(cross(vec3(epsi.yx, -xdiff), vec3(epsi.xy, -ydiff)));\n}\n\nvec3 sceneGrad(vec3 point) {\n  float t = scene(point);\n  return normalize(vec3(\n    t - scene(point + epsi.xyy),\n    t - scene(point + epsi.yxy),\n    t - scene(point + epsi.yyx)));\n}\n\nvoid castRay(inout Ray ray) {\n\t// Cast ray from origin into scene\n\tfloat dt = 0.008;\n\tfloat lastdiff = 0.0;\n\tfor (int i = 0; i < 200; i++) {\n\t\tif (length(ray.m_origin - ray.m_point) > maxdist) return;\n\t\tif (ray.m_point.z > 0.1 && ray.m_point.y + ray.m_point.x < -0.5 && ray.m_direction.z > 0.0) return;\n\t\tfloat dist2scene = scene(ray.m_point);\n\t\tfloat diff = ray.m_point.z - heightmap(ray.m_point.xy);\n\n\t\tif (abs(dist2scene) < epsi.x) {\n\t\t\tray.m_intersected = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (diff < 0.0) {\n\t\t\tray.m_point -= dt * diff / (diff - lastdiff) * ray.m_direction;\n\t\t\tray.m_intersected = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tdt = dt*1.02;\n\t\tray.m_point += min(dt*max(diff*(1.0-abs(ray.m_direction.z)+max(ray.m_direction.z,0.0)*30.0)*80.0,1.0),dist2scene) * ray.m_direction;\n\t\tlastdiff = diff;\n\t}\n}\n\n//this is trash and needs to be better\nvec3 skyDomeShade(vec3 angle) {\n\treturn mix(vec3(1.71, 1.31, 0.83),skycol, pow(abs(angle.z), 0.5)) + pow(max(dot(angle, sundir),0.0),1500.0)*suncol*4.0;\n}\n\nRay reflectionForRay(Ray ray, float fade) {\n\tvec3 normal = -heightmapNormal(ray.m_point.xy);\n\tfloat frensel = abs(dot(ray.m_direction, normal));\n\tvec3 atten = fade * ray.m_attenuation * 0.9 * (1.0 - frensel*0.98);\n\tvec3 reflected = reflect(ray.m_direction, normal);\n\n\treturn newRay(ray.m_point + normal*0.01, reflected, atten);\n}\n\nvoid shadeBoat(inout Ray ray) {\n\t//this code is super spaghetti and I'm so fucking sorry\n\tvec3 normal = -sceneGrad(ray.m_point);\n\tfloat frensel = abs(dot(ray.m_direction, normal));\n\tfloat nearness = abs(ray.m_point.z);\n\tnearness = sqrt(min(nearness*6.0+.1,1.0));\n\tvec3 reflected_sun = reflect(sundir, normal);\n\tvec3 reflected_sky = reflect(vec3(0.0,0.0,1.0), normal);\n\tfloat specular_sun = pow(max(dot(ray.m_direction, reflected_sun),0.0), 20.0) * (1.0-frensel*0.98);\n\tfloat specular_sky = pow(max(dot(ray.m_direction, reflected_sky)+0.75,0.0)/1.75, 2.0) * (1.0-frensel*0.98);\n\n\tfloat ao = mix(1.0,scene(ray.m_point + normal*0.1)/0.1,0.3);\n\n\tfloat shitty_shadow_approximation = scene(ray.m_point + sundir*0.1) < scene(ray.m_point + sundir*0.2) ? 1.0 : 0.0;\n\n#ifdef FINLANDSFARJAN\n    vec2 crds = vec2(-abs(ray.m_point.x), ray.m_point.z);\n\tbool mst = sin(dot(crds,vec2(.5,2))*20.+.5) > 0.;\n\tvec3 diffusecol = mst ? vec3(0.9) : vec3(0.9, 0.05, 0.01);\n#else\n    vec3 diffusecol = vec3(.8,.3,.1);\n#endif\n\tfloat sundot = dot(normal, sundir);\n\tsundot = max(sundot, 0.0) + frensel*0.0;\n\tray.m_color += ao * (sundot*suncol*diffusecol + (1.0+normal.z)/2.0 * mix(suncol,skycol,0.6) * diffusecol ) * nearness + shitty_shadow_approximation*specular_sun*suncol + specular_sky * skycol * nearness + skycol*0.02;\n}\n\nRay rayQueue[MAXDEPTH];\nint raynum = 1;\nvoid addToQueue(Ray ray) {\n\tif (raynum >= MAXDEPTH) return;\n\trayQueue[raynum] = ray;\n\traynum++;\n}\n\nvoid recursivelyRender(inout Ray ray) {\n\t//jump close to surface of water\n\t//this was useful in the demo to only jump if not in the middle of the frame but here it makes no sense\n\tfloat t = -(dot(ray.m_point, vec3(0.0,0.0,1.0)) - 0.08)/dot(ray.m_direction, vec3(0.0,0.0,1.0));\n\t//except near boat\n\tray.m_point += ray.m_direction*t*0.5;\n\trayQueue[0] = ray;\n\n\tfor (int i = 0; i < MAXDEPTH; i++) {\n\t\tif (i >= raynum) break;\n\n\t\tcastRay(rayQueue[i]);\n\t\t//shading...\n\t\tfloat fading = (rayQueue[i].m_intersected > 0) ? pow(max(maxdist - distance(rayQueue[i].m_origin, rayQueue[i].m_point), 0.0)/maxdist, 2.0) : 0.0;\n\t\trayQueue[i].m_color = (1.0-fading)*skyDomeShade(rayQueue[i].m_direction);\n\t\t//reflection\n\t\tif (rayQueue[i].m_intersected == 1) {\n\t\t\taddToQueue(reflectionForRay(rayQueue[i], fading));\n\t\t} else if (rayQueue[i].m_intersected == 2) {\n\t\t\tshadeBoat(rayQueue[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < raynum; i++) {\n\t\tray.m_color += rayQueue[i].m_color * rayQueue[i].m_attenuation;\n\t}\n\traynum = 1;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n\tvec2 uv_base = (fragCoord/iResolution.xy*2.0-1.0)/2.0;\n\tuv_base.x *= iResolution.x/iResolution.y;\n\n\tfeed(uv_base.x);\n\tfeed(uv_base.y);\n    feed(float(iFrame));\n\n\t// Camera parameters\n\n\tvec2 uv = uv_base + getVec3().xy/500.0;\n\tvec3 cameraOrigin = vec3(3.5, 3.5, heightmap(vec2(3.5, 3.5))+1.5) + normalize(getVec3())*0.04;\n\tvec3 focusOrigin = vec3(0.0, 0.0, 0.15);\n\tvec3 cameraDirection = normalize(focusOrigin-cameraOrigin);\n\n    vec3 up = vec3(0.0,0.0,-1.0);\n\tvec3 plateXAxis = normalize(cross(cameraDirection, up));\n\tvec3 plateYAxis = normalize(cross(cameraDirection, plateXAxis));\n\n\tvec3 platePoint = (plateXAxis * -uv.x + plateYAxis * uv.y) * 0.3;\n\n\tRay ray = newRay(cameraOrigin, normalize(platePoint + cameraDirection), vec3(1.0));\n\trecursivelyRender(ray);\n\n    //skip multisampling while wave heightmap is being computed\n    if (iFrame < WAVE_DEPTH) {\n\t\tfragColor = vec4(0);\n    }\n    fragColor += vec4(ray.m_color, 1);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define WAVE_DEPTH 128", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyzr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[249, 249, 279, 279, 364], [366, 366, 423, 423, 1229]], "test": "untested"}
{"id": "wtfcRr", "name": "Channeling Marbles", "author": "dr2", "description": "  Marbles in Voronoi channels (mouseable, click upper-right for new run, lower-right to switch between distant viewpoint and viewpoint near random marble)\n", "tags": ["voronoi", "collision", "ball", "dynamics", "physics"], "likes": 28, "viewed": 433, "published": 3, "date": "1591261041", "time_retrieved": "2024-07-30T21:03:11.629361", "image_code": "// \"Channeling Marbles\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nmat3 QtToRMat (vec4 q);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec2 Hashv2v2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBall = 64;\nvec3 vnObj, ltDir, vorSmth;\nfloat tCur, dstFar, vorHt, vorAmp, vorScl;\nint idBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = - (ro.y - vorHt) / rd.y;\n    sLo = s;\n    for (int j = 0; j < 160; j ++) {\n      p = ro + s * rd;\n      h = p.y - SurfHt (p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.2, 0.4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > SurfHt (p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnObj = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return 0.5 + 0.5 * step (0., sign (a.x) * sign (a.y));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.5, 0.7, 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstSurf, sh;\n  HexVorInit ();\n  bgCol = BgCol (rd);\n  dstObj = BallHit (ro, rd);\n  dstSurf = SurfRay (ro, rd);\n  if (min (dstObj, dstSurf) < dstFar) {\n    if (dstObj < dstSurf) {\n      ro += dstObj * rd;\n      vn = vnObj;\n      col4 = vec4 (HsvToRgb (vec3 (float (idBall) / float (nBall), 0.8, BallChqr (idBall, vn))), 0.3);\n    } else if (dstSurf < dstFar) {\n      ro += dstSurf * rd;\n      vn = SurfNf (ro);\n      vn = VaryNf (4. * ro, vn, max (0.1, 2. - 2. * dstSurf / dstFar));\n      col4 = vec4 (mix (vec3 (0.4, 0.3, 0.3), vec3 (0.8, 0.85, 0.8), smoothstep (0., 0.02, ro.y)), 0.);\n    }\n    sh = BallHitSh (ro + 0.01 * ltDir, ltDir, 10.);\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn.xz, normalize (ltDir.xz)), 0.) + \n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, 1. - min (1., exp2 (8. * (1. - 1.2 * min (dstObj, dstSurf) / dstFar))));\n    \n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro, vd, bMid;\n  vec2 canvas, uv, ut;\n  float az, el, asp, zmFac, s, mb;\n  int fBall;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (4 * nBall + 0);\n  vorSmth = stDat.xyz;\n  stDat = Loadv4 (4 * nBall + 1);\n  vorAmp = stDat.x;\n  vorHt = stDat.y;\n  vorScl = stDat.z;\n  stDat = Loadv4 (4 * nBall + 2);\n  mPtr.xyz = stDat.xyz;\n  fBall = int (stDat.w);\n  az = 0.;\n  el = 0.;\n  ut = vec2 (mPtr.x, abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5;\n  mb = min (ut.x, ut.y);\n  if (mPtr.z > 0. && mb < 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.5 * pi * (mPtr.y + 0.25);\n  } else {\n    if (fBall < 0) {\n      az += 0.03 * pi * tCur;\n      el += pi * (0.17 + 0.1 * sin (0.041 * pi * tCur));\n    }\n  }\n  if (fBall >= 0) {\n    ro = Loadv4 (4 * fBall + 0).xyz;\n    ro.y += 0.7;\n    vd = Loadv4 (4 * fBall + 1).xyz;\n    vd = normalize (vec3 (vd.x, 0., vd.z));\n    vd.xz = Rot2D (vd.xz,  - az);\n    ro.xz -= 0.7 * vd.xz;\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x), vec3 (0., 1., 0.), vd);\n    zmFac = 2.;\n  } else {\n    el = clamp (el, 0.02 * pi, 0.4 * pi);\n    bMid.xz = vec2 (0.);\n    for (int n = 0; n < nBall; n ++) bMid.xz += Loadv4 (4 * n).xz;\n    bMid.xz /= float (nBall);\n    bMid.y = vorHt;\n    ro = bMid + 60. * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), 2. * sin (el)).xzy;\n    vd = normalize (bMid - ro);\n    s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n       - vd.y * vd.z) / s, vd);\n    zmFac = 4.;\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 200.;\n  ltDir = normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  if (mPtr.z > 0. && min (uv.x - asp, abs (uv.y) - 1.) > -0.1)\n     col = mix (col, vec3 (1., 0.3, 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Channeling Marbles\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMin (float a, float b, float r);\nfloat Hashff (float p);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nint fBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 5.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., 0.5 * sin (0.005 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 1.5 * mIdf) + 35. * mod (todCur, 10.);\n  rm.y = vorHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\n#define SHTOY 0\n\n#if SHTOY\n  vec4 iMouse;\n  vec3 iResolution;\n  vec4 iDate;\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 1.;\n  vorScl = 0.2;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 2);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, float (fBall));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Channeling Marbles\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMin (float a, float b, float r);\nfloat Hashff (float p);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nint fBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 5.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., 0.5 * sin (0.005 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 1.5 * mIdf) + 35. * mod (todCur, 10.);\n  rm.y = vorHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\n#define SHTOY 0\n\n#if SHTOY\n  vec4 iMouse;\n  vec3 iResolution;\n  vec4 iDate;\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 1.;\n  vorScl = 0.2;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 2);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, float (fBall));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Channeling Marbles\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMin (float a, float b, float r);\nfloat Hashff (float p);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nint fBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 5.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., 0.5 * sin (0.005 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 1.5 * mIdf) + 35. * mod (todCur, 10.);\n  rm.y = vorHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\n#define SHTOY 0\n\n#if SHTOY\n  vec4 iMouse;\n  vec3 iResolution;\n  vec4 iDate;\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 1.;\n  vorScl = 0.2;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 2);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, float (fBall));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Channeling Marbles\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat SmoothMin (float a, float b, float r);\nfloat Hashff (float p);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nint fBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fDamp = 0.5;\n  grav = 5.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., 0.5 * sin (0.005 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 1.5 * mIdf) + 35. * mod (todCur, 10.);\n  rm.y = vorHt + 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\n#define SHTOY 0\n\n#if SHTOY\n  vec4 iMouse;\n  vec3 iResolution;\n  vec4 iDate;\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 1.;\n  vorScl = 0.2;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 2);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, float (fBall));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfcRr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[530, 530, 553, 553, 619], [621, 621, 655, 655, 1231], [1233, 1233, 1255, 1255, 1395], [1397, 1397, 1431, 1431, 1840], [1842, 1842, 1889, 1889, 2250], [2252, 2252, 2294, 2294, 2500], [2502, 2502, 2524, 2524, 2556], [2558, 2558, 2593, 2593, 3672], [3674, 3674, 3730, 3730, 5657], [5659, 5659, 5683, 5683, 5913], [5915, 5915, 5939, 5939, 5999], [6025, 6025, 6045, 6045, 6265], [6267, 6267, 6290, 6290, 6806], [6808, 6808, 6833, 6833, 7229], [7231, 7231, 7276, 7276, 7379], [7381, 7381, 7411, 7411, 7524], [7526, 7526, 7550, 7550, 7667], [7701, 7701, 7725, 7725, 7837], [7839, 7839, 7864, 7864, 8050], [8052, 8052, 8081, 8081, 8293], [8295, 8295, 8334, 8334, 8519], [8613, 8613, 8638, 8638, 8761]], "test": "untested"}
{"id": "ttXczn", "name": "Field of asteroids", "author": "jarble", "description": "These asteroid-like objects were constructed using signed distance functions.\nThis is based on my [url=https://www.shadertoy.com/view/ts2fW3]\"Infinite planets\"[/url] shader.\nClick and drag the mouse to look around.", "tags": ["asteroids"], "likes": 1, "viewed": 347, "published": 3, "date": "1591245885", "time_retrieved": "2024-07-30T21:03:12.367388", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float scale_factor = EPSILON*10.0;\n\n\nvec3 animate(vec3 uv){\n    //float distortion = 100.0; //this makes them look like \"comets\"\n    float distortion = 10.0; //this makes them look like \"planets\"\n    \n\tvec3 p1 = uv/100.0+vec3(iTime);\n    uv += vec3(sin(p1.x),cos(p1.z),sin(p1.y))*distortion;\n    return uv;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale_factor;\n    p = animate(p);\n    p /= 100.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0))/5.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF2(vec3 p) {\n\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    vec3 p1 = p / 5.0;\n    return  3.0 + sin(length(p*10.0)/10.0) + cos(p1.x)+cos(p1.y)+cos(p1.z);\n}\n\nfloat sceneSDF1(vec3 p){\n\treturn max(sceneSDF2(p/2.0),-sceneSDF2(p));\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale_factor;\n    p = animate(p);\n    return max(sceneSDF1(p*1.0),sceneSDF1(p/1.5))*scale_factor;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 247, 316, 496], [498, 498, 526, 526, 1055], [1057, 1297, 1322, 1449, 1550], [1552, 1552, 1576, 1576, 1623], [1625, 1625, 1649, 1649, 1758], [1760, 2181, 2272, 2272, 2578], [2593, 2847, 2912, 2912, 3044], [3046, 3135, 3164, 3164, 3474], [3476, 3968, 4108, 4108, 4698], [4700, 5070, 5155, 5155, 5913], [5915, 6242, 6291, 6326, 6457], [6459, 6459, 6516, 6516, 7399]], "test": "untested"}
{"id": "tlXcRn", "name": "Interactive 2D Moire Eye", "author": "zalo", "description": "Click and drag to see the moire pattern grid overlaid on top!\n\nA quick test in baking a 2D parameterized animation into a static texture that is indexed/viewed through a thin-film grid (ie a moire pattern).\n\nBased on the \"Realistic Eye\" Shader by TekF ", "tags": ["2d", "eye", "effect", "moire", "animation"], "likes": 4, "viewed": 484, "published": 3, "date": "1591240483", "time_retrieved": "2024-07-30T21:03:13.287926", "image_code": "// Based on the Realistic Eye Shader: \n// https://www.shadertoy.com/view/XsfGWj\n// Hazel Quantock - 15/08/2013\n\n/*\nEye ball effects:\n- Ray-marched shape\n- Ray-traced iris refraction\n- Fake photon mapping on iris\n- Subsurface scattering on sclera\n- HDR reflections with fresnel\n- Eyelid reflection occlusion\n- Eyelid ambient occlusion\n- Procedural textures\n- Procedural animation\n*/\n\n// MOIRE PATTERN CONTROLS\nconst float gridSize = 10.0;\nconst float gridHoleSize = 0.7;\n\nfloat calculateMoireGrid(vec2 fragCoord){\n  vec2 mouseOffset = vec2(fragCoord.xy) + (((vec2(-iMouse.xy)/iResolution.xy) + 0.5) * gridSize);\n  vec2 cellUV = (mod(mouseOffset-(iResolution.xy*.5), gridSize) * (1.0/gridSize));\n  vec2 cellEdginess = 0.5-abs((cellUV * 2.0) - 1.0);\n  float brightness = min(cellEdginess.x, cellEdginess.y);\n  brightness -= (1.0-gridHoleSize);\n  brightness = clamp(brightness*10.0, 0.0, 1.0);\n  return brightness;\n}\n\n\n// KEY CONTROLS - (click on eye to give keyboard focus)\nconst int Key_M = 77; // mouse controls camera / eye direction\n\nconst int Key_E = 69; // refraction on/off\nconst int Key_P = 80; // photon mapping on/off\nconst int Key_L = 76; // change photon mapping technique (both fake, but one is imitating reality and the other is prettier)\n\nconst int Key_S = 83; // subsurface scattering on/off\nconst int Key_A = 65; // ambient occlusion on/off\n\nconst int Key_R = 82; // reflection on/off\nconst int Key_O = 79; // reflection eyelid occlusion on/off\n\nconst int Key_C = 67; // iris colour\nconst int Key_N = 78; // iris normal\n\n\n// Lights\n#if (1)\n\t// High-contrast light edge-on\n\tconst vec3 lightDir = vec3(-2,2,.5);\n\tconst vec3 lightColour = vec3(1.0);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8)*.7;//vec3(.15,.2,.25);\n#else\n\t// more neutral \"good\" lighting (doesn't show off the effects)\n\tconst vec3 lightDir = vec3(-2,2,-1);\n\tconst vec3 lightColour = vec3(.83,.8,.78);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8);\n#endif\n\n\n\n// Constants\nconst float tau = 6.28318530717958647692;\n\n// Forward declarations\nfloat Noise( in vec3 x );\nvec2 Noise2( in vec3 x );\n\n\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\n// ------- EDIT THESE THINGS! -------\n\n// Camera (also rotated by mouse)\nconst vec3 CamPos = vec3(0,0.0,-125.0);\nconst vec3 CamLook = vec3(0,0,0);\nconst float CamZoom = 10.0;\nconst float NearPlane = 0.0; // actually not needed\nconst float drawDistance = 1000.0;\n\nconst vec3 SkyColour = vec3(.4,.25,.2);//fillLightColour*.5;//vec3(.1,.3,.5);\n\nvec3 SkyDome( vec3 rd )\n{\n\t//the cube maps have lines in, and aren't HDR, so make our own shapes\n\t\n\t// random variation\n\tvec3 result = ToLinear(SkyColour)*2.0*Noise(rd);\n\t\n\t// square sky-light\n\tresult = mix( result, vec3(8), smoothstep(.8,1.0,rd.y/max((rd.x+1.0),abs(rd.z))) );\n\n\treturn result;\n}\n\n// Eye params\nconst float IrisAng = tau/12.0;\nconst float PupilAng = (1.6*IrisAng/5.0);\nconst float EyeRadius = 10.0;\nconst float BulgeRadius = 6.0; // used for photon trace, must be bigger than EyeRadius*sin(IrisAng)\n\nvec4 ComputeEyeRotation(vec2 fragCoord)\n{\n\tvec2 rot;\n    rot.xy = (mod(fragCoord.xy-(iResolution.xy*.5), gridSize) * (1.0/gridSize) - 0.5) * tau * 0.25;\n\treturn vec4(cos(rot.x),sin(rot.x),\n                cos(rot.y),sin(rot.y));\n}\n\n\nvec3 ApplyEyeRotation( vec3 pos, vec4 rotation )\n{\n\tpos.yz = rotation.z*pos.yz + rotation.w*pos.zy*vec2(1,-1);\n\tpos.xz = rotation.x*pos.xz + rotation.y*pos.zx*vec2(1,-1);\n\t\n\treturn pos;\n}\n\t\n\n\n// Shape\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nfloat Isosurface( vec3 pos, vec4 eyeRotation )\n{\n\tpos = ApplyEyeRotation(pos,eyeRotation);\n\t\n/*\tfloat f = length(pos)-EyeRadius;\n\t\n//\tf += Noise(pos*3.0)*.008;\n\n\t// cornea bulge\n\tfloat o = EyeRadius*cos(IrisAng)-sqrt(BulgeRadius*BulgeRadius-EyeRadius*EyeRadius*pow(sin(IrisAng),2.0));\n\tfloat g = length(pos-vec3(0,0,-o))-BulgeRadius;\n\n//g += Noise(pos/2.0)*.5;\n\n\treturn min(f,g);\n\t//return -log(exp(-g*2.0)+exp(-f*2.0))/2.0;*/\n\t\n\tvec2 slice = vec2(length(pos.xy),pos.z);\n\t\n\tfloat aa = atan(slice.x,-slice.y);\n\tfloat bulge = cos(tau*.2*aa/IrisAng);\n\tbulge = bulge*.8-.8;\n\tbulge *= smoothstep(tau*.25,0.0,aa);\n\t\n\t// sharp-edged bulge\n//\tif ( aa < IrisAng )\n//\t\tbulge += cos(tau*.25*aa/IrisAng)*.5;\n\tbulge += cos(tau*.25*aa/IrisAng)*.5 * smoothstep(-.02,.1,IrisAng-aa); // slightly softer\n\t\n\treturn length(slice) - EyeRadius - bulge;\n}\n\n\n\nfloat GetEyelidMask( vec3 pos, vec4 eyeRotation )\n{\n\tvec3 eyelidPos = pos;\n\tfloat eyelidTilt = -.05;\n\teyelidPos.xy = cos(eyelidTilt)*pos.xy + sin(eyelidTilt)*pos.yx*vec2(1,-1);\n\t\n\tfloat highLid = tan(max(tau*.05,asin(eyeRotation.w)+IrisAng+.05));\n\tfloat lowLid = tan(tau*.1);\n\t\n\tfloat blink = smoothstep(.0,.02,abs(Noise(vec3(iTime*.2,0,0))-.5 ));\n\thighLid *= blink;\n\tlowLid *= blink;\n\t\n\treturn min(\n\t\t\t\t(-eyelidPos.z-2.0) - (-eyelidPos.y/lowLid),\n\t\t\t\t(-eyelidPos.z-2.0) - (eyelidPos.y/highLid)\n\t\t\t);\n}\n\t\nfloat GetIrisPattern( vec2 uv )\n{\n\treturn Noise( vec3( 10.0*uv/pow(length(uv),.7), 0 ) );\n}\n\n// Colour\nvec3 Shading( vec3 worldPos, vec3 norm, float shadow, vec3 rd, vec4 eyeRotation )\n{\n\tvec3 view = normalize(-rd);\n\n\t// eyelids - just match BG colour\n\tfloat eyelidMask = GetEyelidMask(worldPos, eyeRotation);\n\t\n\tif ( eyelidMask < 0.0 || (-worldPos.z-3.0) < (worldPos.x/tan(tau*.23)) )\n\t{\n\t\treturn ToLinear(SkyColour);\n\t}\n\t\n\tvec3 pos = ApplyEyeRotation(worldPos,eyeRotation);\n\t\n\tfloat lenposxy = length(pos.xy);\n\tfloat ang = atan(lenposxy/(-pos.z));\n\tif ( ang < 0.0 )\n\t\tang += tau/2.0;\n\t\n\n\t// refract ray\n\tvec3 irisRay = ApplyEyeRotation(-view,eyeRotation);\n\tvec3 localNorm = ApplyEyeRotation(norm,eyeRotation);\n\tfloat a = dot(irisRay,localNorm);\n\tfloat b = cos(acos(a)*1.33);\n\tif ( !ReadKey( Key_E, true ) )\n\t\tirisRay += localNorm*(b-a);\n\tirisRay = normalize(irisRay);\n\t\n\t// intersect with plane\n\tfloat planeDist = -cos(IrisAng)*EyeRadius;\n\tfloat t = (planeDist-pos.z)/irisRay.z;\n\n\tvec3 ppos = t*irisRay+pos;\n\n\n\t// polar coord map\n\tfloat rad = length(ppos.xy);\n\tfloat pupilr = EyeRadius*sin(PupilAng);\n\tfloat irisr = EyeRadius*sin(IrisAng);\n\t\n\tfloat irisPattern = GetIrisPattern(ppos.xy); // reduce contrast of this now we have actual lighting!\n\n/*\tvec3 iris = mix( mix( vec3(.3,.1,.1)*.5+.5*vec3(.6,.4,.1), vec3(.6,.4,.1), irisPattern ), // hazel\n\t\t\t\t\tmix( vec3(.2,.2,.2)*.5+.5*vec3(.5,.45,.2), vec3(.5,.45,.2), irisPattern ),*/\n\n/*\tvec3 iris = mix( mix( vec3(.1,.1,.4), vec3(.7,.9,1), irisPattern ), // blue\n\t\t\t\t\tmix( vec3(.1,.1,.4), vec3(.3,.4,.7), irisPattern ),*/\n\n//\t\t\t\t\tsmoothstep(pupilr*2.0,irisr,rad));\n\n\tvec3 iris = ToLinear( mix( pow( vec3(.65,.82,.85), 2.0*vec3(1.2-sqrt(irisPattern)) ),\n\t\t\t\t\tvec3(1,.5,.2), .7*pow( mix( smoothstep(pupilr,irisr,rad), Noise(ppos), .7), 2.0) ));\n\n\tif ( ReadKey( Key_C, true ) )\n\t\tiris = vec3(1);\n\n\t// darken outer\n\tiris *= pow( smoothstep( irisr+1.0, irisr-1.5, rad ), GAMMA );\n\n\n\tvec3 irisNorm;\n\tirisNorm.x = GetIrisPattern(ppos.xy+vec2(-.001,0)) - GetIrisPattern(ppos.xy+vec2(.001,0));\n\tirisNorm.y = GetIrisPattern(ppos.xy+vec2(0,-.001)) - GetIrisPattern(ppos.xy+vec2(0,.001));\n\n\t// add a radial lump\n\tirisNorm.xy += -.01*normalize(ppos.xy)*sin(1.*tau*rad/irisr);\n\n\tirisNorm.z = -.15; // adjust severity of bumps\n\tirisNorm = normalize(irisNorm);\n\n\tif ( ReadKey( Key_N, true ) )\n\t\tirisNorm = vec3(0,0,-1);\n\t\t\n\n\t// lighting\n\t// fake photon mapping by crudely sampling the photon density\n\n\t// apply lighting with this modified normal\n\tvec3 lightDirN = normalize(lightDir);\n\tvec3 localLightDir = ApplyEyeRotation(lightDirN,eyeRotation);\n\n\tvec3 fillLightDirN = normalize(fillLightDir);\n\tvec3 localFillLightDir = ApplyEyeRotation(fillLightDirN,eyeRotation);\n\n\t// Bend the light, imitating results of offline photon-mapping\n\t// Jimenez's paper makes this seem very complex, because their mapping used a non-flat receiver\n\t// but the self-shadowing was negligible, so the main effect was just like premultiplying by a normal\n\t// where we'd get better results by using the actual normal.\n\n\tfloat photonsL, photonsFL;\n\n\tif ( !ReadKey( Key_P, true ) )\n\t{\n\t\tif ( !ReadKey( Key_L, true ) )\n\t\t{\n\t\t\t// Nice retro-reflective effect, but not correct\n\t\t\tvec3 nn = normalize(vec3( ppos.xy, -sqrt(max(0.0,BulgeRadius*BulgeRadius-rad*rad)) ));\n\t\t\t\n\t\t\tvec3 irisLDir = localLightDir;\n\t\t\tvec3 irisFLDir = localFillLightDir;\n\t\t//\tirisLDir.z = -cos(acos(-irisLDir.z)/1.33); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t//\tirisFLDir.z = -cos(acos(-irisFLDir.z)/1.33); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t\tfloat d = dot(nn,irisLDir);\n\t\t\tirisLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\td = dot(nn,irisFLDir);\n\t\t\tirisFLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\tirisLDir = normalize(irisLDir);\n\t\t\tirisFLDir = normalize(irisFLDir);\n\t\t\tphotonsL = smoothstep(0.0,1.0,dot(irisNorm,irisLDir)); //soften terminator\n\t\t\tphotonsFL = (dot(irisNorm,irisFLDir)*.5+.5);\n\t\t\t//Seriously, this^ looks really nice, but not like reality. Bah!\n\t\t\n\t\t/* reverse it, to make it look a lot like the accurate version - meh\n\t\t\tvec3 nn = normalize(vec3( -ppos.xy, -sqrt(max(0.0,BulgeRadius*BulgeRadius-rad*rad)) ));\n\t\t\t\n\t\t\tvec3 irisLDir = localLightDir;\n\t\t\tvec3 irisFLDir = localFillLightDir;\n\t\t\tfloat d = dot(nn,irisLDir);\n\t\t\tirisLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\td = dot(nn,irisFLDir);\n\t\t\tirisFLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\tirisLDir = normalize(irisLDir);\n\t\t\tirisFLDir = normalize(irisFLDir);\n\t\t\t\n\t\t\tfloat photonsL = smoothstep(0.0,1.0,dot(irisNorm,irisLDir)); // soften the terminator\n\t\t\tfloat photonsFL = (dot(irisNorm,irisFLDir)*.5+.5);\n\t\t*/\n\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//this is a reasonable match to the dark crescent effect seen in photos and offline photon mapping, but it looks wrong to me.\n\t\t\tvec3 irisLDir = localLightDir;\n\t\t\tvec3 irisFLDir = localFillLightDir;\n\t\t\tirisLDir.z = -cos(acos(-irisLDir.z)/1.5); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t\tirisFLDir.z = -cos(acos(-irisFLDir.z)/1.5); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t\tirisLDir = normalize(irisLDir);\n\t\t\tirisFLDir = normalize(irisFLDir);\n\t\t\n\t\t\tphotonsL = smoothstep(0.0,1.0,dot(irisNorm,irisLDir)); // soften the terminator\n\t\t\tphotonsFL = (dot(irisNorm,irisFLDir)*.5+.5);\n\t\t\n\t\t\t// dark caustic ring\n\t\t\tphotonsL *= .3+.7*smoothstep( 1.2, .9, length(ppos.xy/irisr+.2*irisLDir.xy/(irisLDir.z-.05)) );\n\t\t//\tphotonsFL *= ...;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// no photons\n\t\tphotonsL = max( 0.0, dot(irisNorm,localLightDir) ); \n\t\tphotonsFL = .5+.5*dot(irisNorm,localLightDir); \n\t}\n\t\t\n\tvec3 l = ToLinear(lightColour)*photonsL;\n\tvec3 fl = ToLinear(fillLightColour)*photonsFL;\n\n\tvec3 ambientOcclusion = vec3(1);\n\tvec3 eyelidShadow = vec3(1);\n\tif ( !ReadKey( Key_A, true ) )\n\t{\n\t\t// ambient occlusion on fill light\n\t\tambientOcclusion = mix( vec3(1), ToLinear(vec3(.8,.7,.68)), pow(smoothstep( 5.0, 0.0, eyelidMask ),1.0) );\n\t\t\n\t\t// shadow on actual light\n\t\teyelidShadow = mix( vec3(1), ToLinear(vec3(.8,.7,.68)), smoothstep( 2.0, -2.0, GetEyelidMask( worldPos+lightDir*1.0, eyeRotation ) ) );\n\t}\n\tfl *= ambientOcclusion;\n\tl *= eyelidShadow;\n\t\n\tiris *= l+fl;\n\n\t// darken pupil\n\tiris *= smoothstep( pupilr-.01, pupilr+.5, rad );\n\n\n\t// veins\n\tfloat theta = atan(pos.x,pos.y);\n\ttheta += Noise(pos*1.0)*tau*.03;\n\tfloat veins = (sin(theta*60.0)*.5+.5);\n\tveins *= veins;\n\tveins *= (sin(theta*13.0)*.5+.5);\n\tveins *= smoothstep( IrisAng, tau*.2, ang );\n\tveins *= veins;\n\tveins *= .5;\n\t\n\tvec3 sclera = mix( ToLinear(vec3(1,.98,.96)), ToLinear(vec3(.9,.1,0)), veins );\n\n\tfloat ndotl = dot(norm,lightDirN);\n\t\n\t// subsurface scattering\n//\tfloat subsurface = max(0.0,-2.0*ndotl*EyeRadius);\n//\tl = pow(ToLinear(vec3(.5,.3,.25)),vec3(subsurface*.2)); // more intense the further light had to travel\n\n\t// fake, because that^ approximation gives a hard terminator\n\tl = pow(ToLinear(vec3(.5,.3,.25)), vec3(mix( 3.0, 0.0, smoothstep(-1.0,.2,ndotl) )) );\n\t\n\tif ( ReadKey( Key_S, true ) )\n//\t\tl = mix( l, vec3(max(0.0,ndotl)), 0.5 );\n//\telse\n\t\tl = vec3(max(0.0,ndotl));\n\n\tl *= ToLinear(lightColour);\n\t\n\tfl = ToLinear(fillLightColour)*(dot(norm,fillLightDirN)*.5+.5);\n\n\tfl *= ambientOcclusion;\n\tl *= eyelidShadow;\n\t\n\t\n\tsclera *= l+fl;\n\n\t// blend between them\n\tfloat blend = smoothstep(-.1,.1,ang-IrisAng);\n\tvec3 result = mix(iris,sclera,blend);\n\n\t\n\t// eyelid ambient occlusion/radiosity\n//\tif ( !ReadKey( Key_A, true ) )\n\t\t//result *= mix( vec3(1), ToLinear(vec3(.65,.55,.55)), exp2(-eyelidMask*2.0) );\n//\t\tresult *= mix( vec3(1), ToLinear(vec3(.8,.7,.68)), pow(smoothstep( 5.0, 0.0, eyelidMask ),1.0) );\n\t\n\t\n\t// bumps - in specular only to help sub-surface scattering look smooth\n\tvec3 bumps;\n\tbumps.xy = .7*Noise2( pos*3.0 );\n\tbumps.z = sqrt(1.0-dot(bumps.xy,bumps.xy));\n\n\tbumps = mix( vec3(0,0,1), bumps, blend );\n\t\n\tnorm.xy += bumps.xy*.1;\n\tnorm = normalize(norm);\n\t\n\tfloat glossiness = mix(.7,1.0,bumps.z);\n\t\n\t// reflection map\n\tfloat ndoti = dot( view, norm );\n\tvec3 rr = -view+2.0*ndoti*norm;\n\tvec3 reflection = SkyDome( rr );\n\t\n\t// specular\n\tvec3 h = normalize(view+lightDir);\n\tfloat specular = pow(max(0.0,dot(h,norm)),2000.0);\n\n\t// should fresnel affect specular? or should it just be added?\n\treflection += specular*32.0*glossiness*ToLinear(lightColour);\n\n\t// reflection of eyelids\n\t//float eyelidReflection = smoothstep( 1.8, 2.0, eyelidMask );\n\t// apply some parallax (subtle improvement when looking up/down at eye)\n\tfloat eyelidReflection = smoothstep( .8, 1.0, GetEyelidMask( normalize(worldPos + rd*2.0)*EyeRadius, eyeRotation ) );\n\tif ( !ReadKey( Key_O, true ) )\n\t\treflection *= eyelidReflection;\n\n\t// fresnel\n\tfloat fresnel = mix(.04*glossiness,1.0,pow(1.0-ndoti,5.0));\n\n\tif ( !ReadKey( Key_R, true ) )\n\t\tresult = mix ( result, reflection, fresnel );\n\n\n\t//anti-alias the edge\n\tfloat mask2 = min( eyelidMask, (-worldPos.z-3.0) - (worldPos.x/tan(tau*.23)) );\n\tresult = mix( ToLinear(SkyColour), result, smoothstep(.0,.3,mask2) );\n\t\n\treturn result;\n}\n\n\n// Precision controls\nconst float epsilon = .003;\nconst float normalPrecision = .1;\nconst float shadowOffset = .1;\nconst int traceDepth = 100; // takes time\n\n\n\n// ------- BACK-END CODE -------\n\nvec2 Noise2( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\t\t\nfloat Noise( in vec3 x )\n{\n\treturn Noise2(x).x;\n}\n\nfloat Trace( vec3 ro, vec3 rd, vec4 eyeRotation )\n{\n\tfloat t = 0.0;\n\tfloat dist = 1.0;\n\tfor ( int i=0; i < traceDepth; i++ )\n\t{\n\t\tif ( abs(dist) < epsilon || t > drawDistance || t < 0.0 )\n\t\t\tcontinue;\n\t\tdist = Isosurface( ro+rd*t, eyeRotation );\n\t\tt = t+dist;\n\t}\n\t\n\treturn t;//vec4(ro+rd*t,dist);\n}\n\n// get normal\nvec3 GetNormal( vec3 pos, vec4 eyeRotation )\n{\n\tconst vec2 delta = vec2(normalPrecision, 0);\n\t\n\tvec3 n;\n\n// it's important this is centred on the pos, it fixes a lot of errors\n\tn.x = Isosurface( pos + delta.xyy, eyeRotation ) - Isosurface( pos - delta.xyy, eyeRotation );\n\tn.y = Isosurface( pos + delta.yxy, eyeRotation ) - Isosurface( pos - delta.yxy, eyeRotation );\n\tn.z = Isosurface( pos + delta.yyx, eyeRotation ) - Isosurface( pos - delta.yyx, eyeRotation );\n\treturn normalize(n);\n}\t\t\t\t\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nconst float N = 0.5; // grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n\t// filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 camPos = CamPos;\n\tvec3 camLook = CamLook;\n\n\tvec2 camRot = .5*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n\tif ( !ReadKey( Key_M, true ) )\n\t\tcamRot = vec2(0,0);\n\tcamPos.yz = cos(camRot.y)*camPos.yz + sin(camRot.y)*camPos.zy*vec2(1,-1);\n\tcamPos.xz = cos(camRot.x)*camPos.xz + sin(camRot.x)*camPos.zx*vec2(1,-1);\n\t\n\tvec4 eyeRotation = ComputeEyeRotation(fragCoord.xy);\n\t\n\tif ( Isosurface(camPos, eyeRotation) <= 0.0 )\n\t{\n\t\t// camera inside ground\n\t\tfragColor = vec4(0,0,0,0);\n\t\treturn;\n\t}\n\n\tvec3 ro = camPos;\n\tvec3 rd;\n\trd = GetRay( camLook-camPos, CamZoom, uv );\n\t\n\tro += rd*(NearPlane/CamZoom);\n\t\n\trd = normalize(rd);\n\t\n\tfloat t = Trace(ro,rd,eyeRotation);\n\n\tvec3 result = ToLinear(SkyColour);\n\tif ( t > 0.0 && t < drawDistance )\n\t{\n\t\tvec3 pos = ro+t*rd;\n\t\t\t\n\t\tvec3 norm = GetNormal(pos,eyeRotation);\n\t\t\n\t\t// shadow test\n\t\tfloat shadow = 1.0;\n\t\tif ( Trace( pos+lightDir*shadowOffset, lightDir, eyeRotation ) < drawDistance )\n\t\t\tshadow = 0.0;\n\t\t\n\t\tresult = Shading( pos, norm, shadow, rd, eyeRotation );\n\t\t\n\t\t// fog\n//\t\tresult = mix ( SkyColour, result, exp(-t*t*.0002) );\n\t}\n\n    \n    if (iMouse.z > .00001 ) {\n\t\tresult *= calculateMoireGrid(fragCoord.xy);\n    }\n    \n\tfragColor = vec4( ToGamma( result ), 1.0 );\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[471, 471, 512, 512, 912], [2195, 2195, 2225, 2292, 2327], [2329, 2329, 2358, 2445, 2484], [3077, 3077, 3102, 3196, 3373], [3594, 3594, 3635, 3635, 3824], [3827, 3827, 3877, 3877, 4014], [4019, 4181, 4229, 4229, 5013], [5017, 5017, 5068, 5068, 5519], [5522, 5522, 5555, 5555, 5613], [5615, 5625, 5708, 5708, 14499], [14696, 14696, 14722, 14722, 14987], [14991, 14991, 15017, 15017, 15040], [15042, 15042, 15093, 15093, 15340], [15342, 15356, 15402, 15402, 15843], [15849, 15914, 15960, 15960, 16172], [16195, 16209, 16274, 16292, 16593], [16595, 16595, 16652, 16652, 17919]], "test": "untested"}
{"id": "wtXcRn", "name": "Spiral Waves 3D", "author": "wyatt", "description": "For a class", "tags": ["3d", "fluid"], "likes": 12, "viewed": 586, "published": 3, "date": "1591236624", "time_retrieved": "2024-07-30T21:03:14.203478", "image_code": "// Fork of \"Volumetric Fluid\" by wyatt. https://shadertoy.com/view/ws2fDc\n// 2020-06-04 01:11:18\n\nSampler\nMain\n{\n    vec3 mi = 0.5*vec3(R/N,N*N);\n    vec3 p = vec3(0,0,-2.*R.y/N);\n    vec3 d = normalize(vec3((u-0.5*R)/R.y,1));\n    if (iMouse.z>0.) {\n \t\tp.zx *= e(6.2*iMouse.x/R.x);\n\t\td.zx *= e(6.2*iMouse.x/R.x);\n        p.yz *= e(6.2*iMouse.y/R.y);\n\t\td.yz *= e(6.2*iMouse.y/R.y);\n    } else {\n\t\tp.xz *= e(.2*iTime);\n\t\td.xz *= e(.2*iTime);\n        \n\t\tp.yz *= e(.05*iTime);\n\t\td.yz *= e(.05*iTime);\n\t}\n    Q = vec4(0);\n    for (int i = 0; i < 120; i++) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m<.01)\n        { \t\n            vec4 a = .4*T(p+mi).xyyy*vec4(1,3,3,1);\n            float aa = length(a);\n            Q += 6e-3*(1.-exp(-aa*aa))*abs(a);\n            p += d*(.1+exp(-aa*aa));\n            p = mod(p+mi,R3D)-mi;\n        } else p += d*m;\n        \n \t}\n\tQ = atan(Q)*.8;\n    //Q = texture(iChannel0,gl_FragCoord.xy/R);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 11.\n#define R iResolution.xy\n#define R3D vec3(R/N,N*N)\n#define d2(U) ((U).xy+vec2(mod(floor((U).z),N),floor(floor((U).z)/N))*R/N)\n#define d3(u) vec3(mod(u,R/N),floor(u/R*N).x+floor(u/R*N).y*N)\n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define A(U) texture(iChannel0, d2(mod(U,R3D))/R)\n#define B(U) texture(iChannel1,d2(mod(U,R3D))/R)\n#define Sampler vec4 T(vec3 U) {return mix(texture(iChannel0,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel0,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define Sampler1 vec4 T1(vec3 U) {return mix(texture(iChannel1,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel1,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define Main void mainImage( out vec4 Q, in vec2 u )\n#define _3D  vec3 U = d3(u)\n#define Neighborhood vec4 n = A(U+vec3(0,1,0)), e = A(U+vec3(1,0,0)), f = A(U+vec3(0,0,1)), s = A(U-vec3(0,1,0)), w = A(U-vec3(1,0,0)), b = A(U-vec3(0,0,1));\n#define Init  if (iFrame < 1) ", "buffer_a_code": "Sampler\nSampler1\nMain {\n\t_3D;\n    Neighborhood;\n    float m = 1./6.*(n+e+s+w+f+b).x;\n    Q = A(U);\n    \n    Q.x += .05*(m-Q.x)+1e-2*((Q.x*(5.-Q.x)*(Q.x-.1))-20.*Q.y);\n\tQ.y += .003*(Q.x-Q.y);\n        \n    if (iFrame < 1&&length(U-0.5*R3D)<10.) Q.x = abs(sin(U.x))*abs(sin(U.y));\n    \n    if (iMouse.z>0.&&length(U-0.5*R3D+sin(iTime)*4.)<10.)  Q.x = 1.;\n    \n    \n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Sampler\nSampler1\nMain {\n\t_3D;\n    Neighborhood;\n    float m = 1./6.*(n+e+s+w+f+b).x;\n    Q = A(U);\n    \n    Q.x += .05*(m-Q.x)+1e-2*((Q.x*(5.-Q.x)*(Q.x-.1))-20.*Q.y);\n\tQ.y += .003*(Q.x-Q.y);\n        \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Sampler\nSampler1\nMain {\n\t_3D;\n    Neighborhood;\n    float m = 1./6.*(n+e+s+w+f+b).x;\n    Q = A(U);\n    \n    Q.x += .05*(m-Q.x)+1e-2*((Q.x*(5.-Q.x)*(Q.x-.1))-20.*Q.y);\n\tQ.y += .003*(Q.x-Q.y);\n        \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Sampler\nSampler1\nMain {\n\t_3D;\n    Neighborhood;\n    float m = 1./6.*(n+e+s+w+f+b).x;\n    Q = A(U);\n    \n    Q.x += .05*(m-Q.x)+1e-2*((Q.x*(5.-Q.x)*(Q.x-.1))-20.*Q.y);\n\tQ.y += .003*(Q.x-Q.y);\n        \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 112, 112, 957]], "test": "untested"}
{"id": "WlXcRr", "name": "Going Psych On 2nd Try", "author": "pnoqable", "description": "in principle the same as https://www.shadertoy.com/view/WsjBDt but distorted in any dimension i could get my psychedelic hands on. readability is destoyed, performance sucks and graphics glitch a lot - i guess my work is done :D", "tags": ["raymarching", "fractal", "smoothoperators"], "likes": 7, "viewed": 443, "published": 3, "date": "1591227070", "time_retrieved": "2024-07-30T21:03:15.025281", "image_code": "// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.01;\nconst float grad_step = 0.001;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_ellipsoid( vec3 pos, vec3 r ) {\n    float k0 = length( pos / r );\n    float k1 = length( pos / ( r * r ) );\n    return k0 * ( k0 - 1.0 ) / k1;\n}\n\nfloat dist_cylinder( vec3 pos, float h, float r ) {\n    vec2 d = abs( vec2( length( pos.xy ), pos.z ) ) - vec2( r, h );\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat dist_torus( vec3 pos, vec2 t ) {\n    vec2 q = vec2( length( pos.xy ) - t.x, pos.z );\n    return length( q ) - t.y;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * ( 1.0 - h );\n}\n\nfloat smoothSubtract( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 + d1 ) / k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) +  k * h * ( 1.0 - h );\n}\n\nfloat smoothIntersect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k * h * ( 1.0 - h );\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n    \n    {\n        float arc = atan( pos.y, pos.x );\n        float len = length( pos.xy );\n        arc += 0.1 * len / ( 5. - pos.z ) * sin( 0.3 * iTime + 0.001 * pos.z );\n        arc -= 0.01 * floor( ( pos.z + 2. ) / ( 8. + 2. * cos( 0.1 * iTime ) ) );\n        pos.x = len * cos( arc );\n        pos.y = len * sin( arc );\n    }\n    \n    vec2 tile = vec2( 7., 8. ) + vec2( 0.02, 0.1 ) * pos.xy * vec2( sin( 0.2 * iTime ), cos( 0.2 * iTime ) );\n    \n    float edge = 0.5 - 0.499 * cos( dot( pos, vec3( 0.02, 0.01, -0.03 ) ) + 0.7 * iTime );\n\t\n    if( pos.z <= 0.1 ) {\n        pos.x += floor( pos.z / 10. + 0.2 ) * 0.5 * sin( iTime );\n        pos.z = mod( pos.z + 2., 8. + 2. * cos( 0.1 * iTime ) ) - 2.;\n    }\n    \n    pos.xy = mod( pos.xy + 0.5 * tile, tile ) - 0.5 * tile;\n    \n\tfloat sphere = dist_sphere( pos, 1. );\n    float ellipsoid = dist_ellipsoid( pos, vec3( .6, .6, 1.1 ) );\n    float cylinder = dist_cylinder( pos, 0.0, 2.2 ) - 0.1 * edge;\n    float torus = dist_torus( pos, vec2( 1.6, 0.3 ) );\n    \n    float result = sphere;\n    result = smoothUnion( cylinder, result, edge );\n    result = smoothSubtract( ellipsoid, result, edge );\n    result = smoothUnion( torus, result, edge );\n\n    return result;\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 3.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.6, 0.5, 0.6 + 0.1 * cos( 2. * iTime + 0.01 * v.z ) );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \n        final += light_color * ( diffuse + specular );\n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -10.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.1, 0.1, 0.1 - 0.1 * sin( iTime + 0.1 * v.y - 0.07 * v.x ) );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \n        final += light_color * ( diffuse + specular );\n\t}\n\t\n\t// light 2\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, -20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.1 + 0.1 * sin( iTime + .7 * v.x - 0.3 * v.y ), 0.0, 0.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \n        final += light_color * ( diffuse + specular );\n\t}\n\n\treturn 2. * final * final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0., 0., 0., 1. );\n    \n    int antiAlias = 1;\n    \n    for( int offX = 0; offX < antiAlias; offX++ )\n    for( int offY = 0; offY < antiAlias; offY++ )\n    {\n        vec2 offset = vec2( float( offX ), float( offY ) ) / vec2( antiAlias ) - 0.5;\n        \n        // default ray dir\n        vec3 dir = ray_dir( 90. + 50. * cos( 0.2 * iTime ), iResolution.xy, fragCoord.xy + offset );\n\n        // default ray origin\n        vec3 eye = vec3( 0.0, 0.0, 3.3 + 3.2 * sin( 0.1 * iTime ) );\n\n        // rotate camera\n        mat3 rot = rotationXY( 0.11 * vec2( cos( -0.1 * iTime ), sin( 0.2 * iTime ) ) );\n        dir = rot * dir;\n        eye = rot * eye;\n\n        // ray marching\n        float depth = ray_marching( eye, dir, 0.0, clip_far );\n        \n        // shading\n        if ( depth < clip_far ) {\n            vec3 pos = eye + dir * depth;\n            vec3 n = gradient( pos );\n            fragColor.xyz += shading( pos, n, eye );\n        }\n    }\n    fragColor.xyz /= float( antiAlias * antiAlias );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 245, 285, 285, 314], [316, 316, 358, 358, 471], [473, 473, 524, 524, 660], [662, 662, 700, 700, 784], [786, 786, 836, 836, 951], [953, 953, 1006, 1006, 1123], [1125, 1125, 1179, 1179, 1294], [1296, 1325, 1355, 1382, 2597], [2599, 2616, 2658, 2684, 4035], [4037, 4066, 4093, 4093, 4427], [4429, 4445, 4514, 4514, 4764], [4766, 4787, 4835, 4835, 5011], [5013, 5045, 5076, 5076, 5232], [5234, 5234, 5291, 5291, 6312]], "test": "untested"}
{"id": "3lXczr", "name": "JetStream Dreams", "author": "Plento", "description": "POV: you're having another airplane dream.", "tags": ["3d", "raymarch", "bloom", "gaussian", "airplane"], "likes": 28, "viewed": 510, "published": 3, "date": "1591226860", "time_retrieved": "2024-07-30T21:03:16.029596", "image_code": "// Plento \n// JetStream Dreams //\n\n// Toggle the bloom in common if its slow..\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    if(iTime < 1.){\n    \tfloat di = max(25. - iTime*45., 0.);\n    \tuv.x += sin(uv.y*di)*.15;\n    }\n    \n\t#ifdef DoBloom\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 blur = texture(iChannel1, uv).xyz;\n    vec3 sum = vec3(0);\n    \n    vec2 scl = 1./R;\n    \n    for(float i = 0.; i < iter; i++){\n        float g = gauss(i, nd);\n        \n        vec3 l = texture(iChannel1, uv+vec2(0., (i+1.)*scl.y)).xyz;\n        vec3 r = texture(iChannel1, uv-vec2(0., (i+1.)*scl.y)).xyz;\n        \n        sum += l*g;\n        sum += r*g;\n    }\n    \n    col += sum*4.3;\n    col = 1.-exp(-col);\n    col = pow(col, vec3(1.32));\n    \n    #else\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    col = 1.-exp(-col*1.8);\n    col = pow(col, vec3(1.5));\n    \n    #endif\n    \n    col *= ss(.67, .25, abs(nuv.y));\n    col *= ss(1.2, .5, length(nuv));\n    \n    col = mix((1.-col)*.4, col, min(iTime*1.3, 1.));\n    \n    f = vec4(col, 1.);\n    \n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n\n\n// Turn the bloom off if its too slow for you\n#define DoBloom\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nconst float iter = 15.;\nconst float nd = iter*.5;\n\n\nfloat gauss(float i, float nd){\n     return exp(-(i*i)/(2.*nd*nd))/sqrt(2.*3.14159*nd*nd);  \n}\n\n", "buffer_a_code": "// sdf operations from https://iquilezles.org/articles/distfunctions\nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat baggage(vec3 rp){\n    rp.x = -abs(rp.x);\n    vec3 p = rp - vec3(-1. - max((rp.y-.7)*1.5, 0.), .8, 0.);\n    p.z = mod(p.z, .4)-.4*.5;\n    float d = box(p, vec3(.05, .05, .5))-.3;\n    d = smin(d, box(p, vec3(0.45, .2, .175))-.1, .2);\n   \n    return d;\n}\nfloat fuselage(vec3 rp){\n    float d = abs(length(rp.xy)-1.0)-.06; // main cylinder\n    d = min(d, .5 + rp.y); // floor\n    d = min(d, .75 - rp.y); // ceiling\n    \n    // windows\n    rp.z = mod(rp.z, .8)-.8*.5;\n    d = ssub(box(rp, vec3(12., .04, .01)), d, .33);\n    d = max(d, box(rp, vec3(1.1, 2., 8.)));\n    \n    return d;\n}\n\nfloat seats(vec3 rp){\n    rp.x = -abs(rp.x);\n    \n    vec3 b = vec3(.34, 0., .8);\n    vec3 p = mod(rp-vec3(-1.9, -0.1, -.23), b)-b*.5; // backrest\n    vec3 p1 = mod(rp-vec3(-1.9, -.3, -.05), b)-b*.5; // seat\n    \n    // add backrest\n    float d = box(p, vec3(.125 - clamp((p.y-.06)*.2, 0., 1.), .2, .01))-.03; \n    // add seat\n    d = smin(d, box(p1, vec3(.125, .01, .1))-.03, .1); \n    // clip inside\n    d = max(d, -box(vec3(rp.x, rp.y, mod(rp.z, .5)-.5*.5), vec3(.21, 1., 4.)));\n    // clip outside\n    d = max(d, box(vec3(rp.x-.04, rp.y, mod(rp.z, .5)-.5*.5), vec3(.9, 4., 4.)));\n    // Add armrest\n    vec3 p2 = rp - vec3(-.225, -.15, -.13);\n    d = min(d, box(vec3(p2.x, p2.y, mod(p2.z, .8)-.8*.5),vec3(.01,.01,.1))-.015); \n   \n    return d;\n}\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    d = fuselage(rp);\n    d = smin(d, baggage(rp), .03);\n    d = min(d, seats(rp));\n    \n    return d;\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 64; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .001 || t > 8.){\n            break;\n        }\n        t += d * .95;\n    }\n    return t;\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t){\n    vec3 lp = vec3(0., 0., iTime*.3);\n    vec3 ld = normalize(lp-p);\n    ld.x*=.01;\n    \n    float lgd = length(lp - p);   \n    float fal = max(exp(-lgd*1.6), .003);\n    \n    float dif = max(dot(n, ld), .0);\n    vec3 col = vec3(texture(iChannel1, p.yz*.7).x + .3);\n    \n    if(p.y < -.48)\n        col += vec3(3.)*ss(.02, .01, abs(-abs(p.x)+.2));\n    else if(p.y > -.33 && p.y < .13 && abs(p.x) < .85){\n     \tcol = (.75*vec3(.23, .23, .3)-texture(iChannel0, p.xy).z*.12)*.9;\n        col *= ss(0.01, 0.015, abs(p.y));\n    }\n    \n    // diffuse\n    col *= 1.-exp(-4.*dif*vec3(0.85, 0.9, 1.)*fal);\n    \n    // overhead light glow\n    vec3 fol = 4.*vec3(.5,.4,.3)*exp(-9.*abs(p.x-.5));\n    fol += 4.*vec3(.5,.4,.3)*exp(-9.*abs(p.x+.5));\n    fol *= ss(0.,.34, p.y-.6);\n    \n    col += fol;    \n    \n    // fog\n    vec3 fogCol = mix(vec3(.1), vec3(.9, .9, 1.0), ss(.15,.55,length(rd.xy)));\n    col = mix(fogCol, col, exp(-t*t*t*0.004));\n    \n\treturn col;   \n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - .5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * .3));\n    vec3 ro = vec3(0., 0.35, iTime*.3);\n   \n    ro.y += + sin(iTime*3.)*.01;\n    rd.yz *= rot(.04+sin(-iTime*3.)*.01);\n    \n    if(iMouse.z > 0.){\n        rd.xz *= rot(-m.x*3.);\n        ro.y += m.y*.7;\n    }\n    \n    float t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, u, t);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n}\n\n\n", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 f, in vec2 u ){\n    #ifdef DoBloom\n    vec2 uv = u / R;\n    vec3 sum = vec3(0);\n    vec2 scl = 1./R;\n    \n    for(float i = 0.; i < iter; i++){\n        float g = gauss(i, nd);\n        \n        vec3 l = texture(iChannel0, uv+vec2((i+1.)*scl.x, 0)).xyz;\n        vec3 r = texture(iChannel0, uv-vec2((i+1.)*scl.x, 0)).xyz;\n        \n        l = pow(l, vec3(2.2));    \n        r = pow(r, vec3(2.2));  \n        \n        sum += l*g;\n        sum += r*g;\n    }\n    f = vec4(sum, 1.0);\n    #else\n    f = vec4(0);\n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 120, 120, 1109]], "test": "untested"}
{"id": "Wlfyzr", "name": "Colorful rainbow jungle", "author": "jarble", "description": "This is another colorful \"jungle\" scene.\nClick and drag the mouse to move around.", "tags": ["3d", "raymarching", "jungle"], "likes": 0, "viewed": 312, "published": 3, "date": "1591223352", "time_retrieved": "2024-07-30T21:03:16.955121", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nvec3 surface_color(vec3 p)\n{\n    return sin(p*sin(p/2.0)/4.0);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    //p /= 40.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  4.4 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat sceneSDF(vec3 p){\n    p /= 10.0;\n    float scale_factor = .5;\n    vec3 p1 = p/scale_factor;\n\tfloat p2 = min(sceneSDF1(p1/4.0),min(sceneSDF1(p1.zxy/5.0),sceneSDF1(p1.yzx/2.0)));\n    return p2*scale_factor;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(sin(iTime/5.0)*2.0, cos(iTime/5.0)*2.0, -iTime)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlfyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 214, 214, 250], [253, 493, 518, 535, 645], [647, 647, 670, 670, 859], [861, 1282, 1373, 1373, 1679], [1694, 1948, 2013, 2013, 2145], [2147, 2236, 2265, 2265, 2575], [2577, 3069, 3209, 3209, 3799], [3801, 4171, 4256, 4256, 5014], [5016, 5343, 5392, 5427, 5558], [5560, 5560, 5617, 5617, 6532]], "test": "untested"}
{"id": "3tfcRr", "name": "Pond Ripples", "author": "JackSolace", "description": "Carter S. Jun 2020\nRain Drops on a pond\nUsing Schreck ripples (Fundamental solutions for water surface waves SIGGRAPH 2019)\n", "tags": ["waves", "ripples", "raymarch", "water", "animation"], "likes": 7, "viewed": 893, "published": 3, "date": "1591217399", "time_retrieved": "2024-07-30T21:03:18.519937", "image_code": "//Carter S. Jun 2020\n//Rain Drops on a pond\n//Using Schreck ripples (Fundamental solutions for water surface waves SIGGRAPH 2019)\n\n\n//Channel 2 is used for pond sand and also to break up the surface of the pond\n//Buffer C contains ripple height map (used as a normal map here (im on a deadline be nice ;( ))\n\n//Cubic smooth minimum union function from user TinyTexel\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n//distance to plane\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n//Plane but with pebble heightmap\nfloat sdTerrain(vec3 p, vec4 n)\n{\n\tfloat to_plane = sdPlane(p,n);\n    float to_pebble = texture(iChannel1,p.xz).x*0.2;//play with pebble max height\n    return to_plane - to_pebble;\n}\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\n//x  index is distance, y index is material type (sometimes other meta info)\nvec2 map_the_world(in vec3 p)\n{\n    \n\t//Plane is represented as a vec4 using ax+by+cz+w = 0 formulation\n    float to_ground = sdPlane(p, normalize(vec4(0.0,1.0,0.0,0.3)));\n    float to_rock = sdTerrain(p, normalize(vec4(0.0,1.0,0.0,0.3)));\n    float to_water = abs(sdPlane(p, normalize(vec4(0.0,1.0,0.0,0.0))));\n    if (to_water < to_rock) {//early quit since we expect to be closest to water often\n        return vec2(to_water,2.0);\n    }\n    //Rocks at the bottom of the pond\n    float pebble_start = 0.45;//play with this range(0.0,1.0)\n    float mat = 0.0;\n    float height = texture(iChannel1, p.xz*0.15).x;\n    if (height > pebble_start){//using pebbles to decide where pebbles are lol (play with numbers)\n        //change mat\n        float prop = height-pebble_start;\n        //nonlinear interp between ground and rocks to make sure it looks like they touch (rocks dont get cut off) \n        to_ground = mix(to_ground,to_rock,1.0 - (1.0/pow(prop+1.0,8.0)));\n    \tmat = 1.0;\n    }\n    \n    return vec2(to_ground,mat);\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ).x );  \n}\n\nvec2 march_ray(vec3 ray_origin, vec3 ray_direction, float tmax) {\n\tfloat t = 0.0;//current depth\n    float m = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        //get dist to nearest surface\n        vec2 h = map_the_world(pos);\n        m = h.y;\n        //if we hit something break\n        if( h.x<0.0001 || t>tmax ) return vec2(t,m);\n        //step forward\n        t += h.x;\n    }\n    return vec2(t,m);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize color\n    vec3 total = vec3(0.0);\n    \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    // raymarch\n    const float tmax = 4.0; //max march depth\n    vec2 res = march_ray(ray_origin,ray_direction,tmax);\n    float t = res.x;\n    \n     // ambient + diffuse light color calculations\n     vec3 color = vec3(0.0);\n     if( t<tmax )\n     {//we hit something\n        vec3 pos = ray_origin + t*ray_direction;\n        //break up the surface normal\n        vec3 normal = calculate_normal(pos) + vec3(0.2*texture(iChannel2,1.0*pos.xz)) + vec3(texture(iChannel3,vec2(0.5,1.0)*0.3*pos.xz + vec2(0.5,0.5)));//play with values make sure to index ripple height map within bounds\n        //get the refracted ray direction\n        vec3 ref_dir = refract(ray_direction, normal, 1.0/1.33);\n        vec3 refract_color = vec3(0.0);\n        vec3 water_color = vec3(0.0,0.3,0.4);\n        vec3 reflect_color = pow(texture(iChannel0, reflect(ray_direction, normal)).rbg, vec3(2.2));\n        res = march_ray(pos + ref_dir*0.001, ref_dir, tmax);\n        t = res.x;\n        float m = res.y;\n         \n        if( t<tmax )\n     \t{\n            pos = (pos + ref_dir*0.001) + t*ref_dir;\n            \n        \tif(m < 1.0) {//is dirt area\n             \trefract_color = texture(iChannel2, pos.xz*1.0).rgb;\n        \t}else{//is rock area\n            \tfloat rock_val = texture(iChannel1,pos.xz).x;\n            \tif (rock_val <0.25){//get some dirt in between rocks (play with this value)\n             \t\trefract_color =  texture(iChannel2, pos.xz*1.0).rgb;\n            \t}else{\n                    //rock color (grey whoda thunk it)\n         \t\t\trefract_color = vec3(0.8*rock_val);\n            \t}\n        \t}\n        }else{\n        \trefract_color = pow(texture(iChannel0, ref_dir).rgb, vec3(2.2));\n        }\n        //combine all effects\n        color = refract_color*0.4 + water_color*0.3 + reflect_color*0.25;//play with the combo\n     }else{//missed pond hit background\n     \tcolor = pow(texture(iChannel0, ray_direction).rgb, vec3(2.2));\n     }\n\n     // gamma color calculation    \n     color = sqrt( color );\n\t total += color;\n\n\t fragColor = vec4( total, 1.0 );\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SAMPLES 2048\n\n//Wont compile on OpenGL. Buffer A is a work around for not being able to store the pre-computed k values in a texture like you would on a local implementation. Normally you would implement the pre-computed k values and store in whatever desired format, the actual algorithm would probably work best as a .comp shader over the desired ripple radius samples and rendered as desired, (here as a height map, but also quads and other approaches can work).\n//can be first or second shader in pipeline\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0){\n        //Pre-computed using newtons method\n        vec2[] ks = vec2[] (\nvec2(0.2861794341797824,0.2863934897346819),\nvec2(0.20061590555566416,0.40117722893973395),\nvec2(0.1720867492173359,0.45968975191649225),\nvec2(0.15261028779596994,0.5099016757345705),\nvec2(0.1377020454175717,0.5563230559784037),\nvec2(0.12564308044703226,0.6006982503842606),\nvec2(0.11556003977480477,0.6439258026115396),\nvec2(0.10693864142582475,0.6865447775512182),\nvec2(0.09944665056330784,0.7289116548972585),\nvec2(0.09285524943215487,0.7712788333401895),\nvec2(0.086999265963647,0.8138342863691488),\nvec2(0.08175510555758575,0.8567235279578749),\nvec2(0.0770276164390184,0.9000626538265711),\nvec2(0.07274186201407318,0.9439465173205025),\nvec2(0.06883766396826829,0.988454086516391),\nvec2(0.0652659460039432,1.033652086652072),\nvec2(0.0619861339603901,1.0795976662678186),\nvec2(0.05896429117167248,1.1263398263333988),\nvec2(0.056171744912416076,1.1739213806695676),\nvec2(0.053584054800259795,1.2223796304824437),\nvec2(0.051180224723242525,1.2717472586069347),\nvec2(0.04894209166907347,1.3220529717647906),\nvec2(0.04685384534670588,1.3733219300475552),\nvec2(0.04490164604726302,1.4255765624882049),\nvec2(0.04307331734852076,1.4788363120415822),\nvec2(0.04135809657546535,1.5331183754982876),\nvec2(0.03974643035323149,1.5884378565392616),\nvec2(0.03822980574154618,1.6448079970704346),\nvec2(0.036800609720237555,1.7022403806773283),\nvec2(0.035452011467278874,1.7607451127906368),\nvec2(0.03417786311196838,1.820330981071856),\nvec2(0.03297261557783633,1.8810055987475933),\nvec2(0.03183124683720813,1.9427755330543963),\nvec2(0.030749200441518434,2.0056464205414954),\nvec2(0.029722332610869776,2.0696230706731544),\nvec2(0.028746864840096354,2.1347095589446266),\nvec2(0.02781935135721429,2.2009093105536732),\nvec2(0.02693663278846111,2.268225381389031),\nvec2(0.026095814586967827,2.3366598789766693),\nvec2(0.025294238035052753,2.406214828619303),\nvec2(0.02452945689529105,2.4768917685603817),\nvec2(0.023799216798230976,2.5486918991485776),\nvec2(0.023101436994907246,2.621616126281361),\nvec2(0.022434194159825473,2.6956651000767216),\nvec2(0.021795707977646142,2.770839249235207),\nvec2(0.021184328286291538,2.847138811516806),\nvec2(0.020598523582141055,2.9245638607219258),\nvec2(0.020036870720574036,3.0031143305327093),\nvec2(0.019498045668320793,3.0827900355399587),\nvec2(0.018980815183668412,3.163590689751965),\nvec2(0.01848402931715858,3.245515922854457),\nvec2(0.018006614639518956,3.328565294465642),\nvec2(0.017547568115597875,3.4127383066069483),\nvec2(0.017105951553363957,3.49803441458847),\nvec2(0.016680886565864146,3.584453036488139),\nvec2(0.016271549991634646,3.6719935613854857),\nvec2(0.015877169725619998,3.7606553564940577),\nvec2(0.015497020918332553,3.850437773321471),\nvec2(0.015130422505909995,3.941340152972104),\nvec2(0.014776734038012643,4.033361830695157),\nvec2(0.014435352774236701,4.12650213976925),\nvec2(0.014105711022983294,4.220760414804805),\nvec2(0.013787273699580509,4.3161359945361575),\nvec2(0.01347953608296382,4.412628224167211),\nvec2(0.013182021752425601,4.510236457327087),\nvec2(0.012894280687887312,4.608960057685764),\nvec2(0.012615887518863802,4.708798400273656),\nvec2(0.012346439908805499,4.809750872544131),\nvec2(0.012085557062849223,4.911816875213129),\nvec2(0.011832878348200324,5.014995822906057),\nvec2(0.011588062017430005,5.119287144638478),\nvec2(0.011350784025915413,5.22469028415379),\nvec2(0.011120736935492377,5.331204700138377),\nvec2(0.010897628897142592,5.438829866332102),\nvec2(0.010681182706209906,5.547565271549746),\nvec2(0.010471134924242655,5.657410419627151),\nvec2(0.010267235062099807,5.768364829303954),\nvec2(0.01006924481944375,5.880428034053326),\nvec2(0.009876937376179422,5.993599581867864),\nvec2(0.009690096731792431,6.107879035009395),\nvec2(0.00950851708889342,6.223265969729637),\nvec2(0.009332001965286815,6.339759975967559),\nvec2(0.00916036496878251,6.457360657028636),\nvec2(0.008993427217227646,6.576067629250332),\nvec2(0.008831018335710034,6.695880521657685),\nvec2(0.008672975624253256,6.8167989756121665),\nvec2(0.008519143645085603,6.938822644456692),\nvec2(0.008369373835687803,7.061951456727862),\nvec2(0.00822352414578674,7.1861845976852),\nvec2(0.008081458696608498,7.311521985958608),\nvec2(0.007943047460837066,7.437963319621658),\nvec2(0.007808165961846604,7.565508306989122),\nvec2(0.007676694990886176,7.694156666277897),\nvec2(0.007548520340997355,7.823908125274311),\nvec2(0.007423532556537816,7.95476242100866),\nvec2(0.007301626697269331,8.086719299437304),\nvec2(0.007182702116046236,8.219778515132797),\nvec2(0.007066662249212106,8.35393983098226),\nvec2(0.006953414418877888,8.489203017894274),\nvec2(0.0068428696463150454,8.625567854514301),\nvec2(0.006734942475752725,8.763034126948813),\nvec2(0.006629550807918796,8.901601628498026),\nvec2(0.0065266157427117015,9.041270159397254),\nvec2(0.006426061430433194,9.182039526566822),\nvec2(0.006327814931051896,9.323909543370348),\nvec2(0.006231806081004446,9.466880029381368),\nvec2(0.0061379673670749054,9.61095081015803),\nvec2(0.0060462338069244715,9.756121717025803),\nvec2(0.005956542835872521,9.902392586867911),\nvec2(0.005868834199556858,10.049763261923347),\nvec2(0.005783049852125842,10.198233589592283),\nvec2(0.005699133859638059,10.347803422248608),\nvec2(0.005617032308366477,10.498472617059408),\nvec2(0.005536693217723894,10.650241035811204),\nvec2(0.005458066457544641,10.803108544742678),\nvec2(0.005381103669474677,10.9570750143837),\nvec2(0.005305758192237935,11.112140319400464),\nvec2(0.005231984990561512,11.268304338446468),\nvec2(0.0051597405875558906,11.425566954019187),\nvec2(0.005088983000359209,11.583928052322193),\nvec2(0.005019671678866299,11.743387523132576),\nvec2(0.004951767447374347,11.903945259673398),\nvec2(0.004885232448987209,12.065601158491038),\nvec2(0.004820030092630086,12.228355119337266),\nvec2(0.0047561250025351,12.39220704505581),\nvec2(0.004693482970066749,12.557156841473287),\nvec2(0.0046320709077639225,12.723204417294296),\nvec2(0.004571856805482506,12.890349684000538),\nvec2(0.00451280968852932,13.058592555753833),\nvec2(0.004454899577684603,13.227932949302758),\nvec2(0.004398097451016116,13.398370783892954),\nvec2(0.0043423752073935154,13.569905981180767),\nvec2(0.004287705631616924,13.742538465150213),\nvec2(0.004234062361078455,13.916268162033159),\nvec2(0.0041814198538800175,14.09109500023238),\nvec2(0.004129753358335073,14.267018910247703),\nvec2(0.004079038883785996,14.444039824604795),\nvec2(0.004029253172672494,14.622157677786758),\nvec2(0.003980373673790077,14.801372406168175),\nvec2(0.003932378516680902,14.981683947951748),\nvec2(0.003885246487102459,15.163092243107211),\nvec2(0.003838957003522476,15.345597233312578),\nvec2(0.0037934900945912455,15.529198861897553),\nvec2(0.003748826377545108,15.71389707378903),\nvec2(0.0037049470374973157,15.89969181545866),\nvec2(0.0036618338075748327,16.086583034872238),\nvec2(0.0036194689498617095,16.274570681441144),\nvec2(0.003577835237111838,16.46365470597529),\nvec2(0.003536915935195688,16.65383506063809),\nvec2(0.0034966947862475825,16.845111698902794),\nvec2(0.0034571559924816268,17.037484575510636),\nvec2(0.0034182842006462107,17.230953646430255),\nvec2(0.0033800644870883145,17.42551886881888),\nvec2(0.0033424823434004955,17.62118020098455),\nvec2(0.003305523662624643,17.817937602350057),\nvec2(0.00326917472598796,18.015791033417848),\nvec2(0.0032334221901477818,18.214740455736376),\nvec2(0.003198253074923072,18.414785831867615),\nvec2(0.0031636547514914157,18.61592712535561),\nvec2(0.0031296149310314717,18.818164300696267),\nvec2(0.0030961216537917008,19.021497323308125),\nvec2(0.0030631632785672234,19.225926159504166),\nvec2(0.0030307284071807174,19.4314507764646),\nvec2(0.0029988061443858758,19.6380711422106),\nvec2(0.0029673856708028203,19.845787225578924),\nvec2(0.0029364565218766184,20.05459899619743),\nvec2(0.0029060085045111176,20.26450642446143),\nvec2(0.002876031688659585,20.475509481510855),\nvec2(0.002846516399217781,20.687608139208084),\nvec2(0.002817453208207096,20.900802370116786),\nvec2(0.002788832927235954,21.115092147481132),\nvec2(0.002760646600228226,21.330477445206014),\nvec2(0.002732885496407893,21.5469582378377),\nvec2(0.0027055411035296927,21.76453450054531),\nvec2(0.002678605121345943,21.983206209102704),\nvec2(0.002652069455300162,22.20297333987127),\nvec2(0.0026259262104385574,22.423835869782877),\nvec2(0.0026001676855307815,22.645793776323753),\nvec2(0.0025747863673918113,22.86884703751869),\nvec2(0.002549774925397101,23.092995631915816),\nvec2(0.0025251262061835437,23.31823953857183),\nvec2(0.002500833228529063,23.54457873703785),\nvec2(0.0024768891784039946,23.772013207345445),\nvec2(0.0024532874041876965,24.00054292999338),\nvec2(0.0024300214120441294,24.230167885934684),\nvec2(0.0024070848614503493,24.460888056564063),\nvec2(0.0023844715608722328,24.69270342370581),\nvec2(0.0023621754635818346,24.925613969602075),\nvec2(0.0023401906636111806,25.15961967690144),\nvec2(0.002318511391837362,25.39472052864798),\nvec2(0.0022971320121941367,25.63091650827042),\nvec2(0.002276047018005346,25.868207599572017),\nvec2(0.002255251028435724,26.10659378672031),\nvec2(0.0022347387850547864,26.34607505423761),\nvec2(0.0022145051485097317,26.586651386991356),\nvec2(0.002194545095303399,26.82832277018519),\nvec2(0.00217485371467351,27.071089189349955),\nvec2(0.002155426205569579,27.314950630335208),\nvec2(0.0021362578737240037,27.55990707930079),\nvec2(0.002117344128814005,27.80595852270887),\nvec2(0.002098680481711199,28.053104947316026),\nvec2(0.0020802625418157327,28.30134634016563),\nvec2(0.0020620860144720146,28.550682688580594),\nvec2(0.002044146698463202,28.801113980156007),\nvec2(0.002026440483581714,29.052640202752414),\nvec2(0.0020089633482731364,29.30526134448892),\nvec2(0.001991711357351021,29.558977393736722),\nvec2(0.001974680659780093,29.813788339112726),\nvec2(0.0019578674865256217,30.06969416947336),\nvec2(0.0019412681484666182,30.32669487390864),\nvec2(0.0019248790343707658,30.584790441736285),\nvec2(0.0019086966089289753,30.843980862496128),\nvec2(0.0018927174108475779,31.1042661259446),\nvec2(0.0018769380509962201,31.365646222049396),\nvec2(0.0018613552106096286,31.628121140984273),\nvec2(0.0018459656395414326,31.891690873124084),\nvec2(0.0018307661545683656,32.156355409039804),\nvec2(0.0018157536377431472,32.42211473949383),\nvec2(0.0018009250347945005,32.68896885543535),\nvec2(0.001786277353572729,32.95691774799583),\nvec2(0.001771807662539405,33.225961408484665),\nvec2(0.0017575130892997241,33.49609982838491),\nvec2(0.0017433908191761703,33.76733299934921),\nvec2(0.0017294380938221534,34.03966091319569),\nvec2(0.001715652209874355,34.3130835619041),\nvec2(0.0017020305176425389,34.58760093761205),\nvec2(0.0016885704198356596,34.86321303261125),\nvec2(0.001675269370323103,35.13991983934394),\nvec2(0.0016621248729299693,35.417721350399376),\nvec2(0.0016491344802653297,35.69661755851047),\nvec2(0.0016362957925824264,35.9766084565504),\nvec2(0.00162360645666983,36.25769403752948),\nvec2(0.0016110641647725942,36.5398742945919),\nvec2(0.0015986666535424724,36.82314922101278),\nvec2(0.0015864117030163325,37.107518810195124),\nvec2(0.0015742971356218765,37.392983055666974),\nvec2(0.0015623208152098515,37.67954195107851),\nvec2(0.001550480646111951,37.967195490199416),\nvec2(0.0015387745722236128,38.25594366691605),\nvec2(0.0015272005761109782,38.545786475229036),\nvec2(0.001515756678141294,38.83672390925048),\nvec2(0.00150444093563603,39.12875596320174),\nvec2(0.0014932514420460665,39.42188263141084),\nvec2(0.001482186326148277,39.7161039083102),\nvec2(0.0014712437512628823,40.01141978843432),\nvec2(0.0014604219144909625,40.30783026641757),\nvec2(0.001449719045971535,40.60533533699195),\nvec2(0.0014391334081576266,40.90393499498509),\nvec2(0.0014286632951107923,41.20362923531807),\nvec2(0.0014183070318135311,41.50441805300344),\nvec2(0.0014080629734991008,41.80630144314332),\nvec2(0.0013979295049982147,42.10927940092733),\nvec2(0.0013879050401021454,42.413351921630884),\nvec2(0.0013779880209417578,42.7185190006133),\nvec2(0.001368176917382031,43.024780633316006),\nvec2(0.0013584702264316094,43.332136815260824),\nvec2(0.0013488664716669796,43.64058754204825),\nvec2(0.0013393642026708454,43.95013280935588),\nvec2(0.0013299619944843063,44.26077261293673),\nvec2(0.001320658447072456,44.57250694861766),\nvec2(0.001311452184803023,44.88533581229792),\nvec2(0.0013023418559376897,45.19925919994753),\nvec2(0.0012933261321357481,45.5142771076059),\nvec2(0.001284403707969734,45.830389531380504),\nvec2(0.0012755733004527283,46.14759646744519),\nvec2(0.0012668336485769963,46.46589791203916),\nvec2(0.0012581835128636521,46.78529386146541),\nvec2(0.001249621674923059,47.10578431208953),\nvec2(0.0012411469370256648,47.42736926033846),\nvec2(0.0012327581216829853,47.75004870269913),\nvec2(0.0012244540712384874,48.07382263571748),\nvec2(0.0012162336474680709,48.39869105599702),\nvec2(0.0012080957311899176,48.724653960197855),\nvec2(0.0012000392218834515,49.05171134503547),\nvec2(0.0011920630373171575,49.379863207279755),\nvec2(0.001184166113185042,49.70910954375377),\nvec2(0.0011763474027514911,50.03945035133279),\nvec2(0.0011686058765043117,50.37088562694325),\nvec2(0.001160940521815741,50.70341536756177),\nvec2(0.0011533503426112179,51.03703957021417),\nvec2(0.0011458343590457062,51.37175823197452),\nvec2(0.0011383916071873842,51.70757134996413),\nvec2(0.001131021138708495,52.04447892135078),\nvec2(0.0011237220205831963,52.38248094334767),\nvec2(0.001116493334792195,52.72157741321266),\nvec2(0.0011093341780340346,53.06176832824733),\nvec2(0.0011022436614428219,53.403053685796245),\nvec2(0.001095220910312267,53.74543348324609),\nvec2(0.0010882650638258454,54.088907718024785),\nvec2(0.0010813752747929528,54.43347638760084),\nvec2(0.0010745507093908788,54.77913948948254),\nvec2(0.0010677905469124724,55.12589702121714),\nvec2(0.0010610939795193397,55.47374898039027),\nvec2(0.0010544602120004483,55.822695364625076),\nvec2(0.0010478884615359985,56.1727361715816),\nvec2(0.0010413779574664256,56.52387139895604),\nvec2(0.0010349279410664172,56.87610104448015),\nvec2(0.0010285376653238125,57.22942510592052),\nvec2(0.0010222063947232648,57.58384358107803),\nvec2(0.001015933405034551,57.93935646778707),\nvec2(0.001009717983105421,58.29596376391507),\nvec2(0.0010035594266588636,58.65366546736182),\nvec2(0.0009974570440946901,59.01246157605895),\nvec2(0.0009914101542953318,59.37235208796917),\nvec2(0.0009854180864357382,59.73333700108602),\nvec2(0.000979480168130647,60.09541631343299),\nvec2(0.000973595772797931,60.45859002306326),\nvec2(0.0009677642467778714,60.82285812805885),\nvec2(0.0009619849585981885,61.18822062653052),\nvec2(0.0009562572861865457,61.55467751661685),\nvec2(0.0009505806167031441,61.922228796484056),\nvec2(0.0009449543463767833,62.290874464325256),\nvec2(0.0009393778803443106,62.66061451836024),\nvec2(0.0009338506324933736,63.03144895683471),\nvec2(0.0009283720253084027,63.4033777780201),\nvec2(0.0009229414897197443,63.77640098021298),\nvec2(0.0009175584649558736,64.15051856173467),\nvec2(0.0009122223983986199,64.52573052093078),\nvec2(0.0009069327454413221,64.90203685617068),\nvec2(0.00090168896934986,65.2794375658474),\nvec2(0.0008964905411264878,65.65793264837693),\nvec2(0.0008913369393764082,66.03752210219788),\nvec2(0.0008862276501770197,66.41820592577122),\nvec2(0.0008811621669497845,66.79998411757968),\nvec2(0.000876139990334646,67.1828566761277),\nvec2(0.0008711606280669544,67.56682359994069),\nvec2(0.0008662235948568204,67.95188488756494),\nvec2(0.000861328412270866,68.33804053756712),\nvec2(0.0008564746086163008,68.72529054853412),\nvec2(0.0008516617188272828,69.11363491907242),\nvec2(0.0008468892843535042,69.50307364780808),\nvec2(0.0008421568530509598,69.89360673338611),\nvec2(0.0008374639790748422,70.28523417447042),\nvec2(0.0008328102227745236,70.67795596974334),\nvec2(0.0008281951505905707,71.07177211790534),\nvec2(0.0008236183349537586,71.4666826176748),\nvec2(0.000819079354186021,71.86268746778757),\nvec2(0.0008145777924033183,72.25978666699694),\nvec2(0.00081011323942036,72.65798021407299),\nvec2(0.0008056852906571553,73.0572681078027),\nvec2(0.0008012935470473435,73.45765034698933),\nvec2(0.0007969376149482685,73.85912693045242),\nvec2(0.0007926171060527642,74.2616978570274),\nvec2(0.0007883316373026023,74.6653631255653),\nvec2(0.0007840808308035796,75.07012273493258),\nvec2(0.0007798643137422016,75.4759766840109),\nvec2(0.0007756817183039276,75.88292497169674),\nvec2(0.00077153268159295,76.29096759690125),\nvec2(0.000767416845553473,76.70010455855008),\nvec2(0.0007633338568924497,77.11033585558299),\nvec2(0.0007592833670037612,77.52166148695383),\nvec2(0.0007552650318938004,77.93408145163016),\nvec2(0.0007512785121084249,78.34759574859295),\nvec2(0.0007473234726612603,78.76220437683664),\nvec2(0.0007433995829633222,79.17790733536877),\nvec2(0.0007395065167539242,79.59470462320972),\nvec2(0.0007356439520328523,80.01259623939255),\nvec2(0.000731811570993774,80.43158218296294),\nvec2(0.0007280090599588602,80.8516624529788),\nvec2(0.0007242361093145934,81.27283704851017),\nvec2(0.0007204924134487342,81.6951059686389),\nvec2(0.0007167776706884281,82.1184692124589),\nvec2(0.0007130915832394274,82.54292677907524),\nvec2(0.0007094338571264011,82.96847866760473),\nvec2(0.0007058042021343161,83.39512487717512),\nvec2(0.0007022023317508636,83.82286540692536),\nvec2(0.0006986279631099152,84.25170025600524),\nvec2(0.0006950808169359766,84.68162942357517),\nvec2(0.0006915606174896363,85.11265290880611),\nvec2(0.0006880670925139681,85.54477071087959),\nvec2(0.0006845999731818861,85.97798282898711),\nvec2(0.0006811589940444251,86.41228926233038),\nvec2(0.0006777438929799238,86.84769001012093),\nvec2(0.000674354411144105,87.28418507158017),\nvec2(0.0006709902929210195,87.72177444593908),\nvec2(0.0006676512858748523,88.16045813243811),\nvec2(0.0006643371407025607,88.60023613032689),\nvec2(0.0006610476111873328,89.04110843886463),\nvec2(0.0006577824541528579,89.4830750573192),\nvec2(0.0006545414294183749,89.92613598496763),\nvec2(0.0006513242997545044,90.37029122109556),\nvec2(0.000648130830839831,90.81554076499752),\nvec2(0.000644960791218232,91.26188461597643),\nvec2(0.0006418139522569369,91.70932277334363),\nvec2(0.000638690088105298,92.15785523641864),\nvec2(0.0006355889756542628,92.6074820045294),\nvec2(0.0006325103944965339,93.05820307701178),\nvec2(0.0006294541268874041,93.51001845320944),\nvec2(0.0006264199577062468,93.96292813247396),\nvec2(0.0006234076744186642,94.41693211416475),\nvec2(0.0006204170670392608,94.8720303976485),\nvec2(0.0006174479280950477,95.32822298229969),\nvec2(0.0006145000525894531,95.78550986749998),\nvec2(0.0006115732379669406,96.2438910526384),\nvec2(0.0006086672840782049,96.70336653711104),\nvec2(0.0006057819931459562,97.16393632032111),\nvec2(0.0006029171697312618,97.6256004016788),\nvec2(0.0006000726207004505,98.08835878060108),\nvec2(0.0005972481551925587,98.55221145651184),\nvec2(0.0005944435845873099,99.01715842884131),\nvec2(0.0005916587224736248,99.4832006754183),\nvec2(0.0005888933846186411,99.95033625926628),\nvec2(0.0005861473889372426,100.41856613821184),\nvec2(0.0005834205554620817,100.88789031171572),\nvec2(0.0005807127063140909,101.35830877924501),\nvec2(0.000578023665673472,101.82982154027292),\nvec2(0.0005753532597511531,102.30242859427865),\nvec2(0.0005727013167607086,102.77612994074748),\nvec2(0.0005700676668907269,103.25092557917067),\nvec2(0.0005674521422776277,103.72681550904524),\nvec2(0.0005648545769789095,104.20379972987392),\nvec2(0.0005622748069468277,104.68187824116512),\nvec2(0.0005597126700024916,105.16105104243292),\nvec2(0.0005571680058103742,105.6413181331969),\nvec2(0.0005546406558532265,106.12267951298202),\nvec2(0.0005521304634073877,106.60513518131856),\nvec2(0.0005496372735184879,107.08868513774232),\nvec2(0.0005471609329775335,107.57332938179412),\nvec2(0.0005447012902973666,108.05906791302006),\nvec2(0.0005422581956894982,108.54590073097118),\nvec2(0.0005398315010412997,109.03382783520372),\nvec2(0.0005374210598935539,109.52284922527876),\nvec2(0.0005350267274183549,110.01296490076226),\nvec2(0.000532648360397353,110.50417486122491),\nvec2(0.0005302858172003348,110.99647910624249),\nvec2(0.0005279389577641385,111.48987763539509),\nvec2(0.0005256076435718928,111.98437044826767),\nvec2(0.0005232917376325765,112.47995754444958),\nvec2(0.0005209911044608914,112.97663892353492),\nvec2(0.0005187056100574485,113.47441458512196),\nvec2(0.0005164351218892526,113.97328452881361),\nvec2(0.000514179508870488,114.47324875421691),\nvec2(0.0005119386413435968,114.97430726094336),\nvec2(0.0005097123910606456,115.47646004860853),\nvec2(0.0005075006311649743,115.97970711683222),\nvec2(0.0005053032361731234,116.48404846523833),\nvec2(0.0005031200819570357,116.98948409345485),\nvec2(0.0005009510457265238,117.4960140011138),\nvec2(0.0004987960060120054,118.00363818785104),\nvec2(0.0004966548426474954,118.51235665330644),\nvec2(0.0004945274367538518,119.0221693971236),\nvec2(0.0004924136707222765,119.53307641895019),\nvec2(0.0004903134281980591,120.04507771843735),\nvec2(0.00048822659406456314,120.55817329523997),\nvec2(0.0004861530544274516,121.07236314901687),\nvec2(0.00048409269659914527,121.58764727943007),\nvec2(0.0004820454090835129,122.10402568614555),\nvec2(0.00048001108156078446,122.62149836883252),\nvec2(0.0004779896048726901,123.14006532716381),\nvec2(0.0004759808710078152,123.6597265608157),\nvec2(0.00047398477308717256,124.18048206946777),\nvec2(0.00047200120534998365,124.702331852803),\nvec2(0.00047003006313966914,125.22527591050778),\nvec2(0.0004680712428900434,125.74931424227155),\nvec2(0.000466124642111711,126.27444684778715),\nvec2(0.00046419015937865834,126.80067372675046),\nvec2(0.0004622676943150415,127.32799487886072),\nvec2(0.00046035714758216556,127.85641030382011),\nvec2(0.00045845842086565094,128.3859200013339),\nvec2(0.0004565714168627846,128.91652397111042),\nvec2(0.0004546960392700525,129.44822221286097),\nvec2(0.0004528321927708541,129.9810147262999),\nvec2(0.00045097978302338827,130.51490151114427),\nvec2(0.000449138716648716,131.0498825671141),\nvec2(0.00044730890121899016,131.58595789393257),\nvec2(0.0004454902452458562,132.12312749132525),\nvec2(0.0004436826581690148,132.66139135902066),\nvec2(0.000441886050344948,133.20074949675012),\nvec2(0.0004401003330358036,133.74120190424756),\nvec2(0.000438325418398439,134.2827485812497),\nvec2(0.00043656121947361606,134.82538952749582),\nvec2(0.0004348076501753502,135.3691247427277),\nvec2(0.00043306462528040714,135.91395422669018),\nvec2(0.00043133206041795084,136.45987797912997),\nvec2(0.0004296098720593288,137.0068959997969),\nvec2(0.0004278979775080079,137.55500828844296),\nvec2(0.00042619629488964417,138.10421484482265),\nvec2(0.00042450474314229355,138.6545156686931),\nvec2(0.0004228232420067582,139.20591075981346),\nvec2(0.00042115171201706535,139.75840011794565),\nvec2(0.00041949007449107814,140.31198374285387),\nvec2(0.0004178382515212359,140.8666616343044),\nvec2(0.0004161961659654222,141.42243379206587),\nvec2(0.00041456374143795786,141.97930021590946),\nvec2(0.000412940902300716,142.53726090560835),\nvec2(0.0004113275736543621,143.09631586093798),\nvec2(0.00040972368132971,143.656465081676),\nvec2(0.00040812915187919723,144.21770856760216),\nvec2(0.00040654391256847694,144.78004631849836),\nvec2(0.00040496789136812205,145.34347833414878),\nvec2(0.00040340101694544343,145.90800461433938),\nvec2(0.00040184321865641836,146.47362515885843),\nvec2(0.00040029442653772613,147.04033996749627),\nvec2(0.0003987545712988942,147.60814904004496),\nvec2(0.0003972235843145461,148.17705237629892),\nvec2(0.00039570139761675694,148.74704997605423),\nvec2(0.00039418794388750814,149.3181418391092),\nvec2(0.000392683156451245,149.8903279652638),\nvec2(0.0003911869692675326,150.46360835432),\nvec2(0.0003896993169238108,151.03798300608184),\nvec2(0.00038822013462824203,151.61345192035486),\nvec2(0.00038674935820265903,152.19001509694672),\nvec2(0.000385286924075601,152.76767253566686),\nvec2(0.00038383276927544615,153.34642423632636),\nvec2(0.0003823868314236299,153.92627019873825),\nvec2(0.00038094904872795765,154.5072104227173),\nvec2(0.00037951935997600076,155.08924490807982),\nvec2(0.00037809770452858286,155.67237365464413),\nvec2(0.00037668402231334774,156.25659666223012),\nvec2(0.000375278253818415,156.84191393065933),\nvec2(0.0003738803400861157,157.4283254597549),\nvec2(0.00037249022270681046,158.01583124934166),\nvec2(0.00037110784381278773,158.60443129924624),\nvec2(0.0003697331460722421,159.19412560929663),\nvec2(0.0003683660726833288,159.78491417932258),\nvec2(0.0003670065673682957,160.3767970091553),\nvec2(0.0003656545743676925,160.9697740986277),\nvec2(0.0003643100384346523,161.5638454475739),\nvec2(0.0003629729048292471,162.15901105582992),\nvec2(0.00036164311931291657,162.7552709232331),\nvec2(0.0003603206281429679,163.35262504962236),\nvec2(0.0003590053780671447,163.95107343483787),\nvec2(0.0003576973163182672,164.5506160787215),\nvec2(0.00035639639060893857,165.1512529811164),\nvec2(0.00035510254912632014,165.75298414186724),\nvec2(0.00035381574052697194,166.3558095608201),\nvec2(0.0003525359139317589,166.9597292378223),\nvec2(0.0003512630189208218,167.5647431727228),\nvec2(0.0003499970055286106,168.17085136537173),\nvec2(0.0003487378242389813,168.7780538156206),\nvec2(0.0003474854259803545,169.38635052332216),\nvec2(0.0003462397621209334,169.9957414883307),\nvec2(0.00034500078446398307,170.60622671050163),\nvec2(0.00034376844524316893,171.21780618969183),\nvec2(0.0003425426971179518,171.8304799257591),\nvec2(0.0003413234931690412,172.44424791856298),\nvec2(0.00034011078689390574,173.059110167964),\nvec2(0.00033890453220233895,173.67506667382386),\nvec2(0.0003377046834120797,174.29211743600547),\nvec2(0.00033651119524448627,174.91026245437328),\nvec2(0.00033532402282026506,175.52950172879255),\nvec2(0.0003341431216552517,176.14983525913004),\nvec2(0.00033296844765624346,176.77126304525336),\nvec2(0.0003317999571168833,177.39378508703155),\nvec2(0.0003306376067135936,178.01740138433465),\nvec2(0.0003294813535015612,178.64211193703383),\nvec2(0.0003283311549107707,179.2679167450015),\nvec2(0.0003271869687420847,179.89481580811116),\nvec2(0.00032604875316337504,180.52280912623732),\nvec2(0.0003249164667056975,181.15189669925547),\nvec2(0.00032379006598181914,181.78207852704256),\nvec2(0.0003226695148978607,182.41335460947624),\nvec2(0.00032155477066490726,183.04572494643537),\nvec2(0.0003204457932296494,183.6791895377999),\nvec2(0.00031934254288351827,184.31374838345064),\nvec2(0.00031824498025913057,184.9494014832697),\nvec2(0.000317153066326777,185.58614883713992),\nvec2(0.00031606676239095337,186.2239904449452),\nvec2(0.0003149860300869316,186.8629263065705),\nvec2(0.0003139108313773737,187.50295642190187),\nvec2(0.00031284112854898413,188.14408079082625),\nvec2(0.00031177688420920373,188.78629941323135),\nvec2(0.00031071806128294175,189.4296122890059),\nvec2(0.000309664623009347,190.07401941803985),\nvec2(0.00030861653293861734,190.71952080022396),\nvec2(0.0003075737549288474,191.36611643544953),\nvec2(0.0003065362531429122,192.01380632360932),\nvec2(0.00030550399204538886,192.66259046459675),\nvec2(0.000304476936399513,193.3124688583061),\nvec2(0.0003034550512641732,193.96344150463258),\nvec2(0.0003024383019909383,194.61550840347226),\nvec2(0.0003014266542211208,195.26866955472212),\nvec2(0.0003004200738828741,195.92292495828002),\nvec2(0.0002994185271883238,196.57827461404452),\nvec2(0.0002984219806307333,197.23471852191523),\nvec2(0.0002974304009816998,197.8922566817925),\nvec2(0.0002964437552883856,198.55088909357752),\nvec2(0.00029546201087078075,199.2106157571722),\nvec2(0.0002944851353189956,199.87143667247923),\nvec2(0.00029351309649058746,200.53335183940257),\nvec2(0.0002925458625079157,201.1963612578464),\nvec2(0.0002915834017555291,201.8604649277159),\nvec2(0.0002906256828775816,202.52566284891694),\nvec2(0.00028967267477527866,203.19195502135645),\nvec2(0.00028872434660435375,203.85934144494183),\nvec2(0.000287780667772571,204.52782211958134),\nvec2(0.0002868416079372592,205.1973970451839),\nvec2(0.00028590713700287265,205.86806622165938),\nvec2(0.00028497722511857933,206.5398296489183),\nvec2(0.0002840518426758776,207.2126873268717),\nvec2(0.00028313096030623913,207.88663925543142),\nvec2(0.0002822145488787788,208.5616854345103),\nvec2(0.000281302579497951,209.23782586402183),\nvec2(0.00028039502350127164,209.91506054387955),\nvec2(0.00027949185245706624,210.59338947399863),\nvec2(0.00027859303816224354,211.2728126542943),\nvec2(0.00027769855264009265,211.95333008468268),\nvec2(0.00027680836813810775,212.6349417650806),\nvec2(0.0002759224571258336,213.31764769540536),\nvec2(0.0002750407922927384,214.00144787557517),\nvec2(0.0002741633465461084,214.68634230550856),\nvec2(0.00027329009300896634,215.37233098512525),\nvec2(0.0002724210050180143,216.05941391434504),\nvec2(0.00027155605612159647,216.74759109308872),\nvec2(0.00027069522007768876,217.43686252127756),\nvec2(0.0002698384708519068,218.1272281988334),\nvec2(0.00026898578261553793,218.81868812567876),\nvec2(0.00026813712974359477,219.51124230173698),\nvec2(0.00026729248681288934,220.2048907269316),\nvec2(0.0002664518286001301,220.89963340118712),\nvec2(0.000265615130080038,221.59547032442836),\nvec2(0.00026478236642348446,222.29240149658094),\nvec2(0.0002639535129956489,222.99042691757091),\nvec2(0.0002631285453541971,223.68954658732505),\nvec2(0.0002623074392474798,224.38976050577045),\nvec2(0.0002614901706127491,225.09106867283523),\nvec2(0.00026067671557439666,225.79347108844746),\nvec2(0.0002598670504422097,226.49696775253634),\nvec2(0.00025906115170964576,227.20155866503114),\nvec2(0.0002582589960521265,227.90724382586214),\nvec2(0.0002574605603253509,228.61402323495975),\nvec2(0.00025666582156362474,229.32189689225527),\nvec2(0.0002558747569782098,230.03086479768),\nvec2(0.00025508734395569,230.74092695116664),\nvec2(0.00025430356005635556,231.45208335264743),\nvec2(0.00025352338301260337,232.1643340020558),\nvec2(0.0002527467907273571,232.87767889932536),\nvec2(0.00025197376127250045,233.59211804439045),\nvec2(0.00025120427288733116,234.30765143718574),\nvec2(0.00025043830397702786,235.02427907764658),\nvec2(0.0002496758331111363,235.7420009657084),\nvec2(0.00024891683902207015,236.46081710130775),\nvec2(0.0002481613006036265,237.18072748438112),\nvec2(0.00024740919690952116,237.90173211486575),\nvec2(0.00024666050715193427,238.62383099269923),\nvec2(0.0002459152107000755,239.3470241178199),\nvec2(0.0002451732870787618,240.0713114901661),\nvec2(0.0002444347159670123,240.796693109677),\nvec2(0.00024369947719665564,241.52316897629183),\nvec2(0.00024296755075095354,242.25073908995108),\nvec2(0.00024223891676323887,242.97940345059493),\nvec2(0.00024151355551556668,243.70916205816405),\nvec2(0.00024079144743738062,244.44001491259993),\nvec2(0.00024007257310419342,245.17196201384417),\nvec2(0.00023935691323627938,245.90500336183916),\nvec2(0.00023864444869738287,246.63913895652738),\nvec2(0.000237935160493438,247.3743687978517),\nvec2(0.00023722902977130363,248.11069288575584),\nvec2(0.00023652603781751028,248.84811122018357),\nvec2(0.00023582616605701941,249.58662380107924),\nvec2(0.00023512939605199778,250.3262306283874),\nvec2(0.00023443570950060222,251.06693170205313),\nvec2(0.00023374508823577775,251.80872702202217),\nvec2(0.00023305751422406887,252.55161658824025),\nvec2(0.00023237296956444127,253.29560040065377),\nvec2(0.0002316914364871171,254.04067845920937),\nvec2(0.00023101289735242265,254.78685076385418),\nvec2(0.00023033733464964545,255.5341173145356),\nvec2(0.0002296647309959052,256.28247811120156),\nvec2(0.00022899506913503614,257.0319331538005),\nvec2(0.0002283283319364791,257.78248244228064),\nvec2(0.00022766450239418713,258.53412597659104),\nvec2(0.0002270035636255398,259.2868637566814),\nvec2(0.00022634549887027083,260.0406957825012),\nvec2(0.00022569029148940525,260.7956220540005),\nvec2(0.000225037924964207,261.5516425711299),\nvec2(0.00022438838289513913,262.3087573338401),\nvec2(0.00022374164900083147,263.06696634208225),\nvec2(0.00022309770711706147,263.82626959580796),\nvec2(0.0002224565411957441,264.586667094969),\nvec2(0.0002218181353039313,265.34815883951774),\nvec2(0.00022118247362282295,266.11074482940654),\nvec2(0.00022054954044678631,266.8744250645884),\nvec2(0.00021991932018238623,267.63919954501637),\nvec2(0.0002192917973474244,268.40506827064445),\nvec2(0.00021866695656998922,269.17203124142594),\nvec2(0.00021804478258751324,269.9400884573156),\nvec2(0.00021742526024584225,270.7092399182676),\nvec2(0.00021680837449831151,271.47948562423716),\nvec2(0.00021619411040483326,272.25082557517896),\nvec2(0.00021558245313099087,273.0232597710489),\nvec2(0.00021497338794714408,273.7967882118027),\nvec2(0.00021436690022754224,274.5714108973965),\nvec2(0.00021376297544944555,275.34712782778684),\nvec2(0.0002131615991922559,276.12393900293023),\nvec2(0.00021256275713665688,276.9018444227838),\nvec2(0.00021196643506376017,277.6808440873051),\nvec2(0.00021137261885426217,278.4609379964516),\nvec2(0.0002107812944876081,279.242126150181),\nvec2(0.00021019244804116414,280.0244085484522),\nvec2(0.00020960606568939849,280.8077851912231),\nvec2(0.000209022133703069,281.5922560784528),\nvec2(0.00020844063844842036,282.3778212101002),\nvec2(0.0002078615663863878,283.16448058612514),\nvec2(0.00020728490407180902,283.9522342064869),\nvec2(0.00020671063815264396,284.7410820711455),\nvec2(0.00020613875536920148,285.53102418006125),\nvec2(0.00020556924255337467,286.32206053319453),\nvec2(0.00020500208662788217,287.11419113050624),\nvec2(0.00020443727460551763,287.9074159719573),\nvec2(0.00020387479358840614,288.70173505750904),\nvec2(0.00020331463076726832,289.4971483871232),\nvec2(0.00020275677342069027,290.29365596076155),\nvec2(0.0002022012089144024,291.0912577783862),\nvec2(0.00020164792470056276,291.8899538399592),\nvec2(0.00020109690831704953,292.6897441454437),\nvec2(0.00020054814738675898,293.4906286948022),\nvec2(0.00020000162961691028,294.2926074879979),\nvec2(0.00019945734279835697,295.09568052499424),\nvec2(0.00019891527480490553,295.899847805755),\nvec2(0.00019837541359263937,296.7051093302438),\nvec2(0.00019783774719925066,297.5114650984246),\nvec2(0.00019730226374337678,298.31891511026197),\nvec2(0.00019676895142394407,299.12745936572094),\nvec2(0.00019623779851951848,299.93709786476563),\nvec2(0.00019570879338766042,300.7478306073616),\nvec2(0.00019518192446428716,301.55965759347396),\nvec2(0.00019465718026304146,302.3725788230682),\nvec2(0.00019413454937466446,303.18659429611034),\nvec2(0.00019361402046637655,304.0017040125661),\nvec2(0.00019309558228126184,304.81790797240177),\nvec2(0.00019257922363766054,305.6352061755842),\nvec2(0.00019206493342856584,306.45359862207954),\nvec2(0.00019155270062102628,307.27308531185474),\nvec2(0.0001910425142555541,308.0936662448776),\nvec2(0.00019053436344553952,308.9153414211145),\nvec2(0.00019002823737666912,309.73811084053386),\nvec2(0.00018952412530635118,310.5619745031028),\nvec2(0.0001890220165631455,311.3869324087896),\nvec2(0.0001885219005461983,312.2129845575626),\nvec2(0.000188023766724683,313.04013094938995),\nvec2(0.0001875276046372459,313.86837158424044),\nvec2(0.0001870334038914564,314.6977064620827),\nvec2(0.0001865411541632638,315.5281355828859),\nvec2(0.00018605084519645668,316.35965894661933),\nvec2(0.00018556246680213035,317.1922765532524),\nvec2(0.00018507600885815596,318.02598840275465),\nvec2(0.000184591461308657,318.86079449509606),\nvec2(0.0001841088141634894,319.69669483024654),\nvec2(0.00018362805749772617,320.53368940817626),\nvec2(0.00018314918145114788,321.3717782288558),\nvec2(0.00018267217622773647,322.2109612922556),\nvec2(0.00018219703209517444,323.0512385983469),\nvec2(0.00018172373938434876,323.8926101471001),\nvec2(0.0001812522884888584,324.73507593848683),\nvec2(0.00018078266986452712,325.57863597247825),\nvec2(0.0001803148740289208,326.4232902490459),\nvec2(0.00017984889156086808,327.2690387681616),\nvec2(0.00017938471309998636,328.11588152979743),\nvec2(0.0001789223293462119,328.963818533925),\nvec2(0.00017846173105933342,329.8128497805171),\nvec2(0.00017800290905853152,330.66297526954605),\nvec2(0.00017754585422191985,331.5141950009841),\nvec2(0.00017709055748609247,332.3665089748049),\nvec2(0.0001766370098456748,333.2199171909806),\nvec2(0.00017618520235287757,334.07441964948464),\nvec2(0.00017573512611705595,334.93001635029077),\nvec2(0.00017528677230427224,335.7867072933718),\nvec2(0.00017484013213686208,336.6444924787021),\nvec2(0.00017439519689300522,337.50337190625464),\nvec2(0.00017395195790629908,338.3633455760041),\nvec2(0.0001735104065653376,339.2244134879247),\nvec2(0.00017307053431329234,340.0865756419903),\nvec2(0.00017263233264749794,340.94983203817566),\nvec2(0.00017219579311904176,341.81418267645563),\nvec2(0.00017176090733235597,342.6796275568046),\nvec2(0.00017132766694481424,343.5461666791979),\nvec2(0.00017089606366633164,344.41380004361037),\nvec2(0.00017046608925896787,345.2825276500173),\nvec2(0.00017003773553653424,346.1523494983947),\nvec2(0.00016961099436420417,347.0232655887175),\nvec2(0.0001691858576581269,347.8952759209616),\nvec2(0.00016876231738504428,348.76838049510326),\nvec2(0.00016834036556191204,349.6425793111181),\nvec2(0.00016791999425552293,350.5178723689825),\nvec2(0.00016750119558213398,351.3942596686729),\nvec2(0.00016708396170709737,352.2717412101655),\nvec2(0.00016666828484449312,353.1503169934375),\nvec2(0.00016625415725676667,354.02998701846514),\nvec2(0.00016584157125436834,354.91075128522544),\nvec2(0.00016543051919539658,355.7926097936958),\nvec2(0.00016502099348524393,356.6755625438531),\nvec2(0.00016461298657624644,357.55960953567484),\nvec2(0.00016420649096733568,358.44475076913864),\nvec2(0.00016380149920369426,359.3309862442218),\nvec2(0.00016339800387641369,360.21831596090266),\nvec2(0.0001629959976221557,361.10673991915826),\nvec2(0.00016259547312281642,361.9962581189674),\nvec2(0.00016219642310519316,362.8868705603082),\nvec2(0.00016179884034065432,363.77857724315845),\nvec2(0.00016140271764481193,364.67137816749727),\nvec2(0.00016100804787719697,365.56527333330286),\nvec2(0.00016061482394093819,366.46026274055384),\nvec2(0.00016022303878244216,367.3563463892294),\nvec2(0.00015983268539107774,368.25352427930824),\nvec2(0.00015944375679886205,369.1517964107694),\nvec2(0.0001590562460801495,370.0511627835923),\nvec2(0.0001586701463513238,370.9516233977562),\nvec2(0.00015828545077049171,371.8531782532406),\nvec2(0.0001579021525371806,372.7558273500254),\nvec2(0.0001575202448920373,373.6595706880897),\nvec2(0.00015713972111653046,374.5644082674141),\nvec2(0.00015676057453265516,375.4703400879776),\nvec2(0.00015638279850263933,376.3773661497609),\nvec2(0.00015600638642865398,377.2854864527444),\nvec2(0.00015563133175252445,378.19470099690795),\nvec2(0.00015525762795544544,379.1050097822322),\nvec2(0.000154885268557697,380.016412808698),\nvec2(0.00015451424711836426,380.92891007628555),\nvec2(0.00015414455723505865,381.84250158497593),\nvec2(0.0001537761925436415,382.7571873347499),\nvec2(0.00015340914671795053,383.6729673255887),\nvec2(0.00015304341346952802,384.5898415574731),\nvec2(0.0001526789865473515,385.5078100303845),\nvec2(0.00015231585973756652,386.4268727443044),\nvec2(0.00015195402686322203,387.34702969921443),\nvec2(0.00015159348178400752,388.2682808950957),\nvec2(0.00015123421839599262,389.1906263319304),\nvec2(0.0001508762306313685,390.11406600969985),\nvec2(0.00015051951245819196,391.0385999283861),\nvec2(0.00015016405788013102,391.9642280879714),\nvec2(0.0001498098609362136,392.89095048843757),\nvec2(0.00014945691570057666,393.8187671297669),\nvec2(0.00014910521628221896,394.7476780119419),\nvec2(0.00014875475682475515,395.6776831349449),\nvec2(0.00014840553150617178,396.60878249875867),\nvec2(0.00014805753453858583,397.54097610336504),\nvec2(0.00014771076016800456,398.4742639487476),\nvec2(0.00014736520267408771,399.40864603488876),\nvec2(0.000147020856369912,400.34412236177184),\nvec2(0.0001466777156017364,401.2806929293796),\nvec2(0.00014633577474877085,402.21835773769516),\nvec2(0.00014599502822294555,403.15711678670164),\nvec2(0.00014565547046868274,404.0969700763828),\nvec2(0.00014531709596267057,405.0379176067216),\nvec2(0.00014497989921363814,405.97995937770196),\nvec2(0.00014464387476213257,406.9230953893075),\nvec2(0.00014430901718029876,407.8673256415215),\nvec2(0.00014397532107165932,408.81265013432795),\nvec2(0.0001436427810708976,409.75906886771105),\nvec2(0.0001433113918436423,410.70658184165455),\nvec2(0.00014298114808625266,411.65518905614266),\nvec2(0.0001426520445256071,412.6048905111593),\nvec2(0.0001423240759188924,413.555686206689),\nvec2(0.00014199723705339486,414.5075761427161),\nvec2(0.00014167152274629342,415.4605603192249),\nvec2(0.00014134692784445357,416.41463873619995),\nvec2(0.00014102344722422426,417.3698113936264),\nvec2(0.0001407010757912355,418.32607829148816),\nvec2(0.00014037980848019744,419.2834394297708),\nvec2(0.00014005964025470184,420.2418948084583),\nvec2(0.0001397405661070244,421.20144442753656),\nvec2(0.0001394225810579289,422.1620882869902),\nvec2(0.0001391056801564733,423.1238263868042),\nvec2(0.00013878985847981678,424.0866587269642),\nvec2(0.0001384751111330284,425.0505853074554),\nvec2(0.00013816143324889784,426.01560612826285),\nvec2(0.00013784881998774677,426.9817211893726),\nvec2(0.00013753726653724266,427.94893049076984),\nvec2(0.0001372267681122131,428.91723403244015),\nvec2(0.00013691731995446233,429.8866318143696),\nvec2(0.00013660891733258904,430.85712383654385),\nvec2(0.00013630155554180518,431.82871009894865),\nvec2(0.0001359952299037568,432.8013906015699),\nvec2(0.00013568993576634598,433.77516534439366),\nvec2(0.0001353856685035542,434.75003432740687),\nvec2(0.00013508242351526693,435.72599755059457),\nvec2(0.00013478019622709992,436.70305501394347),\nvec2(0.0001344789820902267,437.6812067174402),\nvec2(0.0001341787765812074,438.66045266107085),\nvec2(0.00013387957520181892,439.6407928448219),\nvec2(0.00013358137347888627,440.6222272686802),\nvec2(0.0001332841669641156,441.6047559326323),\nvec2(0.00013298795123392842,442.5883788366652),\nvec2(0.00013269272188929645,443.5730959807649),\nvec2(0.00013239847455557888,444.55890736491904),\nvec2(0.00013210520488236,445.5458129891144),\nvec2(0.00013181290854328865,446.53381285333785),\nvec2(0.00013152158123591826,447.52290695757637),\nvec2(0.00013123121868154883,448.51309530181743),\nvec2(0.00013094181662506987,449.50437788604825),\nvec2(0.0001306533708348043,450.49675471025614),\nvec2(0.00013036587710235387,451.49022577442804),\nvec2(0.0001300793312424455,452.4847910785518),\nvec2(0.0001297937290927794,453.480450622615),\nvec2(0.00012950906651387745,454.4772044066049),\nvec2(0.00012922533938893323,455.4750524305093),\nvec2(0.00012894254362366355,456.47399469431645),\nvec2(0.00012866067514616042,457.474031198013),\nvec2(0.00012837972990674445,458.4751619415877),\nvec2(0.0001280997038778198,459.47738692502827),\nvec2(0.00012782059305372915,460.48070614832255),\nvec2(0.0001275423934506111,461.4851196114587),\nvec2(0.0001272651011062578,462.49062731442484),\nvec2(0.00012698871207997354,463.49722925720886),\nvec2(0.00012671322245243514,464.50492543979954),\nvec2(0.00012643862832555308,465.5137158621845),\nvec2(0.00012616492582233322,466.52360052435296),\nvec2(0.0001258921110867401,467.5345794262926),\nvec2(0.00012562018028356128,468.5466525679924),\nvec2(0.00012534912959827243,469.5598199494406),\nvec2(0.0001250789552369035,470.574081570626),\nvec2(0.00012480965342590613,471.5894374315371),\nvec2(0.00012454122041202165,472.60588753216297),\nvec2(0.00012427365246215046,473.6234318724921),\nvec2(0.0001240069458632224,474.6420704525134),\nvec2(0.00012374109692206737,475.66180327221616),\nvec2(0.00012347610196528823,476.68263033158865),\nvec2(0.00012321195733913334,477.7045516306207),\nvec2(0.00012294865940937086,478.72756716930064),\nvec2(0.00012268620456116363,479.7516769476181),\nvec2(0.00012242458919894513,480.77688096556244),\nvec2(0.00012216380974629657,481.80317922312247),\nvec2(0.00012190386264582412,482.8305717202877),\nvec2(0.00012164474435903816,483.8590584570477),\nvec2(0.0001213864513662326,484.88863943339186),\nvec2(0.00012112898016636521,485.91931464930946),\nvec2(0.00012087232727693933,486.95108410479),\nvec2(0.00012061648923388589,487.9839477998234),\nvec2(0.0001203614625914465,489.01790573439945),\nvec2(0.00012010724392205745,490.05295790850715),\nvec2(0.00011985382981623464,491.089104322137),\nvec2(0.00011960121688245928,492.1263449752787),\nvec2(0.00011934940174706418,493.16467986792173),\nvec2(0.0001190983810541213,494.2041090000563),\nvec2(0.00011884815146533004,495.2446323716724),\nvec2(0.00011859870965990595,496.28624998276),\nvec2(0.00011835005233447077,497.3289618333094),\nvec2(0.00011810217620294297,498.37276792331016),\nvec2(0.00011785507799642939,499.4176682527533),\nvec2(0.00011760875446311705,500.46366282162853),\nvec2(0.00011736320236816665,501.51075162992606),\nvec2(0.0001171184184936059,502.55893467763684),\nvec2(0.00011687439963822443,503.60821196475047),\nvec2(0.00011663114261746917,504.65858349125807),\nvec2(0.00011638864426333998,505.71004925715),\nvec2(0.00011614690142428715,506.7626092624165),\nvec2(0.00011590591096510838,507.81626350704795),\nvec2(0.00011566566976684759,508.8710119910359),\nvec2(0.00011542617472669382,509.9268547143705),\nvec2(0.00011518742275788102,510.9837916770423),\nvec2(0.00011494941078958872,512.0418228790423),\nvec2(0.00011471213576684308,513.1009483203613),\nvec2(0.000114475594650419,514.1611680009903),\nvec2(0.00011423978441674283,515.2224819209202),\nvec2(0.00011400470205779568,516.2848900801418),\nvec2(0.00011377034458101738,517.3483924786462),\nvec2(0.00011353670900921159,518.4129891164247),\nvec2(0.00011330379238045087,519.4786799934683),\nvec2(0.00011307159174798295,520.5454651097679),\nvec2(0.0001128401041801376,521.6133444653148),\nvec2(0.00011260932676023387,522.6823180601007),\nvec2(0.00011237925658648871,523.7523858941164),\nvec2(0.00011214989077192508,524.823547967353),\nvec2(0.0001119212264442818,525.8958042798026),\nvec2(0.00011169326074592372,526.9691548314561),\nvec2(0.00011146599083375205,528.0435996223057),\nvec2(0.00011123941387911607,529.1191386523418),\nvec2(0.00011101352706772489,530.1957719215567),\nvec2(0.00011078832759956013,531.273499429942),\nvec2(0.00011056381268878924,532.3523211774885),\nvec2(0.00011033997956367936,533.4322371641895),\nvec2(0.00011011682501035201,534.5132473900352),\nvec2(0.00010989434721037444,535.5953518550181),\nvec2(0.00010967254296423564,536.67855055913),\nvec2(0.00010945140955576188,537.7628435023626),\nvec2(0.00010923094428245705,538.8482306847077),\nvec2(0.00010901114445541988,539.9347121061572),\nvec2(0.00010879200739926242,541.0222877667035),\nvec2(0.00010857353045202812,542.1109576663382),\nvec2(0.0001083557109651113,543.2007218050535),\nvec2(0.0001081385463031769,544.2915801828415),\nvec2(0.0001079220338440806,545.3835327996943),\nvec2(0.00010770617097878974,546.4765796556042),\nvec2(0.00010749095511130483,547.5707207505629),\nvec2(0.00010727638365858137,548.6659560845634),\nvec2(0.00010706245405045251,549.7622856575975),\nvec2(0.00010684916372955172,550.8597094696577),\nvec2(0.00010663651015123693,551.9582275207366),\nvec2(0.00010642449078351425,553.0578398108262),\nvec2(0.00010621310310696259,554.1585463399191),\nvec2(0.000106002344614659,555.2603471080074),\nvec2(0.0001057922128121043,556.3632421150845),\nvec2(0.00010558270521714918,557.467231361142),\nvec2(0.000105373819359921,558.5723148461732),\nvec2(0.00010516555278275106,559.6784925701703),\nvec2(0.00010495790304010198,560.7857645331263),\nvec2(0.00010475086769849648,561.8941307350335),\nvec2(0.00010454444433644544,563.003591175885),\nvec2(0.00010433863054437775,564.1141458556734),\nvec2(0.00010413342392456934,565.2257947743914),\nvec2(0.0001039288220910739,566.3385379320322),\nvec2(0.00010372482266965326,567.4523753285882),\nvec2(0.00010352142329770856,568.5673069640527),\nvec2(0.00010331862162421177,569.6833328384186),\nvec2(0.00010311641530963799,570.8004529516784),\nvec2(0.00010291480202589776,571.918667303826),\nvec2(0.00010271377945627005,573.0379758948536),\nvec2(0.00010251334529533585,574.1583787247548),\nvec2(0.00010231349724891202,575.2798757935225),\nvec2(0.00010211423303398565,576.4024671011499),\nvec2(0.00010191555037864866,577.5261526476302),\nvec2(0.00010171744702203342,578.6509324329567),\nvec2(0.00010151992071424823,579.7768064571225),\nvec2(0.00010132296921631328,580.903774720121),\nvec2(0.00010112659030009755,582.0318372219452),\nvec2(0.00010093078174825554,583.1609939625889),\nvec2(0.00010073554135416472,584.2912449420453),\nvec2(0.00010054086692186357,585.4225901603077),\nvec2(0.00010034675626598945,586.5550296173695),\nvec2(0.00010015320721171762,587.688563313225),\nvec2(9.996021759470016e-05,588.8231912478666),\nvec2(9.97677852610055e-05,589.9589134212881),\nvec2(9.957590806705834e-05,591.0957298334833),\nvec2(9.93845838795799e-05,592.2336404844458),\nvec2(9.919381057552865e-05,593.3726453741695),\nvec2(9.90035860420415e-05,594.5127445026473),\nvec2(9.881390817637524e-05,595.6539378698732),\nvec2(9.862477488584827e-05,596.7962254758415),\nvec2(9.843618408778326e-05,597.939607320545),\nvec2(9.824813370944938e-05,599.0840834039785),\nvec2(9.806062168800565e-05,600.2296537261349),\nvec2(9.787364597044437e-05,601.3763182870086),\nvec2(9.76872045135346e-05,602.5240770865933),\nvec2(9.750129528376683e-05,603.6729301248828),\nvec2(9.731591625729722e-05,604.8228774018711),\nvec2(9.713106541989235e-05,605.9739189175524),\nvec2(9.694674076687502e-05,607.1260546719203),\nvec2(9.676294030306963e-05,608.2792846649688),\nvec2(9.657966204274793e-05,609.4336088966927),\nvec2(9.639690400957585e-05,610.5890273670849),\nvec2(9.621466423655981e-05,611.7455400761405),\nvec2(9.603294076599435e-05,612.903147023853),\nvec2(9.585173164940877e-05,614.0618482102166),\nvec2(9.567103494751562e-05,615.2216436352261),\nvec2(9.549084873015844e-05,616.3825332988752),\nvec2(9.531117107626022e-05,617.5445172011579),\nvec2(9.51320000737724e-05,618.707595342069),\nvec2(9.495333381962389e-05,619.8717677216024),\nvec2(9.477517041967045e-05,621.037034339753),\nvec2(9.459750798864455e-05,622.2033951965144),\nvec2(9.442034465010561e-05,623.3708502918812),\nvec2(9.424367853639021e-05,624.5393996258479),\nvec2(9.40675077885633e-05,625.7090431984091),\nvec2(9.389183055636869e-05,626.8797810095591),\nvec2(9.371664499818093e-05,628.0516130592923),\nvec2(9.3541949280957e-05,629.2245393476029),\nvec2(9.336774158018809e-05,630.3985598744863),\nvec2(9.319402007985237e-05,631.5736746399361),\nvec2(9.302078297236724e-05,632.7498836439476),\nvec2(9.284802845854249e-05,633.9271868865148),\nvec2(9.26757547475339e-05,635.1055843676331),\nvec2(9.250396005679613e-05,636.2850760872964),\nvec2(9.233264261203734e-05,637.4656620454996),\nvec2(9.216180064717291e-05,638.6473422422375),\nvec2(9.199143240428006e-05,639.8301166775049),\nvec2(9.182153613355265e-05,641.0139853512962),\nvec2(9.165211009325624e-05,642.1989482636066),\nvec2(9.148315254968346e-05,643.3850054144307),\nvec2(9.131466177710962e-05,644.5721568037633),\nvec2(9.114663605774873e-05,645.7604024315989),\nvec2(9.097907368170955e-05,646.9497422979332),\nvec2(9.081197294695225e-05,648.1401764027606),\nvec2(9.064533215924515e-05,649.3317047460764),\nvec2(9.047914963212184e-05,650.5243273278746),\nvec2(9.031342368683823e-05,651.7180441481509),\nvec2(9.014815265233049e-05,652.9128552069001),\nvec2(8.998333486517274e-05,654.1087605041176),\nvec2(8.981896866953536e-05,655.3057600397977),\nvec2(8.965505241714314e-05,656.5038538139363),\nvec2(8.94915844672342e-05,657.7030418265276),\nvec2(8.932856318651875e-05,658.9033240775673),\nvec2(8.916598694913847e-05,660.1047005670504),\nvec2(8.90038541366259e-05,661.3071712949718),\nvec2(8.884216313786399e-05,662.5107362613273),\nvec2(8.868091234904647e-05,663.7153954661111),\nvec2(8.852010017363749e-05,664.9211489093193),\nvec2(8.835972502233286e-05,666.1279965909467),\nvec2(8.819978531302003e-05,667.3359385109884),\nvec2(8.804027947073969e-05,668.5449746694405),\nvec2(8.788120592764642e-05,669.7551050662977),\nvec2(8.772256312297074e-05,670.9663297015547),\nvec2(8.756434950298035e-05,672.1786485752078),\nvec2(8.740656352094251e-05,673.3920616872523),\nvec2(8.724920363708581e-05,674.6065690376827),\nvec2(8.709226831856282e-05,675.8221706264954),\nvec2(8.693575603941291e-05,677.0388664536855),\nvec2(8.677966528052483e-05,678.2566565192485),\nvec2(8.662399452960013e-05,679.4755408231792),\nvec2(8.646874228111628e-05,680.6955193654738),\nvec2(8.631390703629058e-05,681.9165921461282),\nvec2(8.615948730304371e-05,683.138759165137),\nvec2(8.600548159596393e-05,684.3620204224959),\nvec2(8.585188843627122e-05,685.586375918201),\nvec2(8.569870635178193e-05,686.8118256522471),\nvec2(8.554593387687356e-05,688.038369624631),\nvec2(8.539356955244938e-05,689.2660078353467),\nvec2(8.524161192590398e-05,690.4947402843911),\nvec2(8.509005955108836e-05,691.7245669717597),\nvec2(8.493891098827581e-05,692.9554878974477),\nvec2(8.478816480412723e-05,694.1875030614508),\nvec2(8.463781957165774e-05,695.4206124637655),\nvec2(8.448787387020252e-05,696.6548161043866),\nvec2(8.43383262853834e-05,697.8901139833108),\nvec2(8.418917540907538e-05,699.1265061005329),\nvec2(8.404041983937374e-05,700.3639924560493),\nvec2(8.389205818056067e-05,701.6025730498557),\nvec2(8.374408904307306e-05,702.8422478819474),\nvec2(8.35965110434695e-05,704.0830169523211),\nvec2(8.344932280439817e-05,705.3248802609728),\nvec2(8.330252295456482e-05,706.567837807897),\nvec2(8.315611012870042e-05,707.8118895930911),\nvec2(8.301008296752995e-05,709.0570356165503),\nvec2(8.286444011774036e-05,710.3032758782704),\nvec2(8.271918023194949e-05,711.5506103782479),\nvec2(8.257430196867501e-05,712.7990391164783),\nvec2(8.242980399230298e-05,714.0485620929579),\nvec2(8.228568497305769e-05,715.2991793076826),\nvec2(8.214194358697053e-05,716.5508907606483),\nvec2(8.199857851584991e-05,717.8036964518514),\nvec2(8.185558844725095e-05,719.0575963812875),\nvec2(8.171297207444534e-05,720.3125905489528),\nvec2(8.157072809639162e-05,721.568678954844),\nvec2(8.142885521770553e-05,722.8258615989562),\nvec2(8.128735214863021e-05,724.0841384812865),\nvec2(8.114621760500746e-05,725.3435096018301),\nvec2(8.100545030824805e-05,726.6039749605837),\nvec2(8.086504898530302e-05,727.8655345575437),\nvec2(8.07250123686349e-05,729.128188392706),\nvec2(8.058533919618901e-05,730.3919364660667),\nvec2(8.044602821136511e-05,731.6567787776225),\nvec2(8.030707816298908e-05,732.922715327369),\nvec2(8.016848780528493e-05,734.1897461153033),\nvec2(8.003025589784666e-05,735.4578711414202),\nvec2(7.989238120561068e-05,736.727090405718),\nvec2(7.975486249882835e-05,737.9974039081917),\nvec2(7.961769855303819e-05,739.2688116488375),\nvec2(7.94808881490389e-05,740.5413136276525),\nvec2(7.934443007286216e-05,741.8149098446326),\nvec2(7.920832311574586e-05,743.089600299774),\nvec2(7.907256607410711e-05,744.3653849930738),\nvec2(7.893715774951566e-05,745.6422639245283),\nvec2(7.880209694866764e-05,746.9202370941326),\nvec2(7.86673824833591e-05,748.1993045018849),\nvec2(7.853301317045992e-05,749.4794661477807),\nvec2(7.839898783188791e-05,750.7607220318162),\nvec2(7.826530529458277e-05,752.043072153989),\nvec2(7.813196439048072e-05,753.3265165142944),\nvec2(7.799896395648874e-05,754.6110551127292),\nvec2(7.786630283445931e-05,755.8966879492913),\nvec2(7.773397987116527e-05,757.1834150239749),\nvec2(7.760199391827454e-05,758.4712363367787),\nvec2(7.747034383232549e-05,759.7601518876978),\nvec2(7.733902847470188e-05,761.050161676729),\nvec2(7.720804671160845e-05,762.3412657038697),\nvec2(7.707739741404644e-05,763.6334639691163),\nvec2(7.694707945778904e-05,764.9267564724641),\nvec2(7.681709172335761e-05,766.2211432139118),\nvec2(7.668743309599714e-05,767.5166241934546),\nvec2(7.655810246565286e-05,768.8131994110895),\nvec2(7.642909872694597e-05,770.1108688668132),\nvec2(7.630042077915048e-05,771.4096325606231),\nvec2(7.617206752616945e-05,772.7094904925152),\nvec2(7.604403787651175e-05,774.010442662486),\nvec2(7.59163307432687e-05,775.3124890705324),\nvec2(7.57889450440914e-05,776.6156297166513),\nvec2(7.56618797011673e-05,777.9198646008401),\nvec2(7.553513364119773e-05,779.2251937230943),\nvec2(7.540870579537507e-05,780.5316170834116),\nvec2(7.528259509936038e-05,781.8391346817887),\nvec2(7.51568004932609e-05,783.1477465182223),\nvec2(7.503132092160767e-05,784.457452592709),\nvec2(7.49061553333336e-05,785.7682529052458),\nvec2(7.478130268175135e-05,787.0801474558302),\nvec2(7.46567619245315e-05,788.3931362444582),\nvec2(7.453253202368066e-05,789.7072192711267),\nvec2(7.440861194551996e-05,791.0223965358331),\nvec2(7.428500066066363e-05,792.338668038574),\nvec2(7.416169714399742e-05,793.6560337793468),\nvec2(7.403870037465752e-05,794.9744937581477),\nvec2(7.391600933600928e-05,796.2940479749739),\nvec2(7.379362301562626e-05,797.6146964298229),\nvec2(7.36715404052695e-05,798.9364391226907),\nvec2(7.354976050086654e-05,800.2592760535751),\nvec2(7.342828230249077e-05,801.5832072224731),\nvec2(7.330710481434112e-05,802.9082326293814),\nvec2(7.318622704472146e-05,804.2343522742965),\nvec2(7.306564800602034e-05,805.5615661572164),\nvec2(7.29453667146909e-05,806.8898742781378),\nvec2(7.282538219123071e-05,808.2192766370579),\nvec2(7.270569346016196e-05,809.5497732339732),\nvec2(7.258629955001148e-05,810.8813640688811),\nvec2(7.246719949329105e-05,812.2140491417792),\nvec2(7.234839232647803e-05,813.547828452664),\nvec2(7.222987708999551e-05,814.8827020015331),\nvec2(7.211165282819317e-05,816.218669788383),\nvec2(7.199371858932803e-05,817.5557318132111),\nvec2(7.187607342554512e-05,818.8938880760147),\nvec2(7.175871639285865e-05,820.2331385767914),\nvec2(7.164164655113286e-05,821.5734833155366),\nvec2(7.15248629640633e-05,822.9149222922499),\nvec2(7.140836469915827e-05,824.2574555069275),\nvec2(7.129215082771981e-05,825.6010829595659),\nvec2(7.117622042482565e-05,826.9458046501634),\nvec2(7.106057256931039e-05,828.291620578716),\nvec2(7.094520634374746e-05,829.6385307452227),\nvec2(7.083012083443085e-05,830.9865351496791),\nvec2(7.071531513135709e-05,832.3356337920831),\nvec2(7.060078832820707e-05,833.6858266724321),\nvec2(7.048653952232837e-05,835.0371137907237),\nvec2(7.03725678147174e-05,836.3894951469543),\nvec2(7.025887231000162e-05,837.742970741122),\nvec2(7.01454521164221e-05,839.0975405732236),\nvec2(7.003230634581587e-05,840.4532046432569),\nvec2(6.99194341135988e-05,841.8099629512193),\nvec2(6.980683453874794e-05,843.1678154971071),\nvec2(6.969450674378462e-05,844.5267622809192),\nvec2(6.958244985475727e-05,845.8868033026519),\nvec2(6.947066300122441e-05,847.2479385623031),\nvec2(6.93591453162378e-05,848.6101680598698),\nvec2(6.92478959363254e-05,849.9734917953493),\nvec2(6.913691400147502e-05,851.33790976874),\nvec2(6.902619865511745e-05,852.7034219800382),\nvec2(6.891574904410998e-05,854.0700284292423),\nvec2(6.880556431871997e-05,855.4377291163493),\nvec2(6.869564363260859e-05,856.806524041356),\nvec2(6.858598614281443e-05,858.1764132042608),\nvec2(6.847659100973739e-05,859.5473966050607),\nvec2(6.836745739712269e-05,860.9194742437537),\nvec2(6.825858447204477e-05,862.2926461203368),\nvec2(6.814997140489146e-05,863.6669122348079),\nvec2(6.804161736934821e-05,865.0422725871642),\nvec2(6.793352154238223e-05,866.4187271774033),\nvec2(6.782568310422704e-05,867.7962760055226),\nvec2(6.771810123836679e-05,869.1749190715199),\nvec2(6.761077513152099e-05,870.554656375393),\nvec2(6.750370397362881e-05,871.935487917139),\nvec2(6.739688695783415e-05,873.3174136967552),\nvec2(6.729032328047027e-05,874.7004337142401),\nvec2(6.718401214104461e-05,876.0845479695904),\nvec2(6.707795274222387e-05,877.4697564628046),\nvec2(6.697214428981905e-05,878.85605919388),\nvec2(6.686658599277051e-05,880.2434561628135),\nvec2(6.676127706313332e-05,881.6319473696041),\nvec2(6.665621671606238e-05,883.021532814248),\nvec2(6.655140416979795e-05,884.4122124967435),\nvec2(6.644683864565099e-05,885.8039864170879),\nvec2(6.634251936798874e-05,887.1968545752802),\nvec2(6.623844556422039e-05,888.5908169713165),\nvec2(6.613461646478272e-05,889.9858736051956),\nvec2(6.60310313031259e-05,891.3820244769144),\nvec2(6.592768931569928e-05,892.7792695864707),\nvec2(6.582458974193738e-05,894.1776089338628),\nvec2(6.572173182424591e-05,895.5770425190881),\nvec2(6.56191148079878e-05,896.9775703421437),\nvec2(6.551673794146935e-05,898.3791924030287),\nvec2(6.541460047592659e-05,899.7819087017399),\nvec2(6.531270166551147e-05,901.1857192382753),\nvec2(6.521104076727815e-05,902.5906240126325),\nvec2(6.510961704116974e-05,903.9966230248091),\nvec2(6.50084297500046e-05,905.4037162748034),\nvec2(6.490747815946292e-05,906.8119037626134),\nvec2(6.48067615380737e-05,908.2211854882363),\nvec2(6.47062791572011e-05,909.6315614516701),\nvec2(6.460603029103154e-05,911.0430316529128),\nvec2(6.450601421656055e-05,912.4555960919614),\nvec2(6.440623021357957e-05,913.8692547688155),\nvec2(6.430667756466318e-05,915.2840076834713),\nvec2(6.420735555515614e-05,916.6998548359271),\nvec2(6.410826347316047e-05,918.1167962261813),\nvec2(6.400940060952293e-05,919.534831854231),\nvec2(6.391076625782206e-05,920.9539617200742),\nvec2(6.381235971435567e-05,922.3741858237095),\nvec2(6.371418027812837e-05,923.7955041651339),\nvec2(6.36162272508389e-05,925.2179167443463),\nvec2(6.351849993686804e-05,926.6414235613439),\nvec2(6.342099764326582e-05,928.0660246161241),\nvec2(6.332371967973962e-05,929.491719908686),\nvec2(6.322666535864171e-05,930.918509439027),\nvec2(6.312983399495716e-05,932.3463932071447),\nvec2(6.30332249062919e-05,933.7753712130383),\nvec2(6.293683741286053e-05,935.2054434567044),\nvec2(6.284067083747428e-05,936.6366099381414),\nvec2(6.27447245055294e-05,938.0688706573476),\nvec2(6.264899774499513e-05,939.5022256143204),\nvec2(6.255348988640188e-05,940.9366748090581),\nvec2(6.245820026282977e-05,942.372218241559),\nvec2(6.23631282098967e-05,943.8088559118204),\nvec2(6.226827306574702e-05,945.2465878198408),\nvec2(6.217363417103982e-05,946.6854139656183),\nvec2(6.207921086893757e-05,948.1253343491503),\nvec2(6.198500250509468e-05,949.5663489704363),\nvec2(6.189100842764622e-05,951.0084578294725),\nvec2(6.17972279871966e-05,952.4516609262586),\nvec2(6.170366053680837e-05,953.8959582607908),\nvec2(6.161030543199099e-05,955.341349833069),\nvec2(6.151716203068986e-05,956.7878356430907),\nvec2(6.142422969327528e-05,958.235415690853),\nvec2(6.133150778253126e-05,959.6840899763549),\nvec2(6.123899566364483e-05,961.1338584995948),\nvec2(6.114669270419507e-05,962.5847212605703),\nvec2(6.105459827414236e-05,964.0366782592798),\nvec2(6.0962711745817506e-05,965.4897294957209),\nvec2(6.087103249391117e-05,966.943874969892),\nvec2(6.077955989546324e-05,968.3991146817909),\nvec2(6.068829332985208e-05,969.8554486314167),\nvec2(6.059723217878422e-05,971.3128768187664),\nvec2(6.050637582628374e-05,972.7713992438394),\nvec2(6.04157236586819e-05,974.231015906633),\nvec2(6.0325275064606864e-05,975.6917268071448),\nvec2(6.023502943497309e-05,977.1535319453744),\nvec2(6.014498616297152e-05,978.6164313213188),\nvec2(6.005514464405895e-05,980.0804249349773),\nvec2(5.9965504275948255e-05,981.5455127863464),\nvec2(5.987606445859802e-05,983.0116948754263),\nvec2(5.978682459420262e-05,984.4789712022138),\nvec2(5.969778408718225e-05,985.9473417667078),\nvec2(5.960894234417277e-05,987.4168065689062),\nvec2(5.952029877401633e-05,988.8873656088068),\nvec2(5.943185278775086e-05,990.3590188864089),\nvec2(5.934360379860085e-05,991.8317664017105),\nvec2(5.925555122196736e-05,993.3056081547091),\nvec2(5.916769447541822e-05,994.7805441454033),\nvec2(5.90800329786788e-05,996.2565743737914),\nvec2(5.899256615362201e-05,997.7336988398721),\nvec2(5.890529342425902e-05,999.2119175436427),\nvec2(5.8818214216729606e-05,1000.6912304851022),\nvec2(5.8731327959292994e-05,1002.1716376642488),\nvec2(5.86446340823181e-05,1003.6531390810809),\nvec2(5.855813201827446e-05,1005.1357347355965),\nvec2(5.847182120172288e-05,1006.6194246277946),\nvec2(5.8385701069306176e-05,1008.104208757672),\nvec2(5.829977105973999e-05,1009.5900871252283),\nvec2(5.821403061380358e-05,1011.0770597304614),\nvec2(5.812847917433089e-05,1012.56512657337),\nvec2(5.804311618620127e-05,1014.0542876539525),\nvec2(5.795794109633073e-05,1015.5445429722059),\nvec2(5.787295335366274e-05,1017.03589252813),\nvec2(5.7788152409159474e-05,1018.5283363217229),\nvec2(5.7703537715792844e-05,1020.0218743529823),\nvec2(5.761910872853577e-05,1021.5165066219076),\nvec2(5.753486490435332e-05,1023.0122331284962),\nvec2(5.7450805702194056e-05,1024.5090538727468),\nvec2(5.7366930582981265e-05,1026.0069688546575),\nvec2(5.728323900960438e-05,1027.5059780742276),\nvec2(5.7199730446910334e-05,1029.0060815314546),\nvec2(5.711640436169509e-05,1030.5072792263375),\nvec2(5.7033260222695e-05,1032.0095711588742),\nvec2(5.695029750057843e-05,1033.5129573290635),\nvec2(5.6867515667937377e-05,1035.017437736903),\nvec2(5.6784914199278864e-05,1036.5230123823922),\nvec2(5.6702492571016913e-05,1038.0296812655295),\nvec2(5.6620250261464035e-05,1039.5374443863127),\nvec2(5.6538186750823024e-05,1041.0463017447405),\nvec2(5.6456301521178735e-05,1042.5562533408113),\nvec2(5.637459405649e-05,1044.067299174523),\nvec2(5.629306384258134e-05,1045.5794392458756),\nvec2(5.621171036713502e-05,1047.0926735548658),\nvec2(5.613053311968297e-05,1048.6070021014934),\nvec2(5.604953159159867e-05,1050.122424885756),\nvec2(5.596870527608929e-05,1051.6389419076527),\nvec2(5.588805366818778e-05,1053.1565531671815),\nvec2(5.5807576264744896e-05,1054.6752586643415),\nvec2(5.5727272564421456e-05,1056.1950583991304),\nvec2(5.564714206768039e-05,1057.7159523715468),\nvec2(5.556718427677913e-05,1059.2379405815896),\nvec2(5.548739869576169e-05,1060.761023029257),\nvec2(5.540778483045126e-05,1062.285199714549),\nvec2(5.532834218844226e-05,1063.8104706374618),\nvec2(5.52490702790929e-05,1065.336835797995),\nvec2(5.5169968613517525e-05,1066.8642951961476),\nvec2(5.509103670457913e-05,1068.3928488319168),\nvec2(5.5012274066881787e-05,1069.9224967053033),\nvec2(5.493368021676335e-05,1071.453238816303),\nvec2(5.4855254672287784e-05,1072.985075164916),\nvec2(5.4776996953237994e-05,1074.5180057511411),\nvec2(5.469890658110834e-05,1076.0520305749758),\nvec2(5.462098307909736e-05,1077.5871496364207),\nvec2(5.4543225972100525e-05,1079.123362935472),\nvec2(5.446563478670298e-05,1080.6606704721291),\nvec2(5.438820905117233e-05,1082.199072246391),\nvec2(5.431094829545141e-05,1083.7385682582556),\nvec2(5.4233852051151294e-05,1085.279158507722),\nvec2(5.4156919851543996e-05,1086.8208429947892),\nvec2(5.408015123155572e-05,1088.363621719455),\nvec2(5.4003545727759455e-05,1089.9074946817184),\nvec2(5.392710287836822e-05,1091.4524618815778),\nvec2(5.385082222322803e-05,1092.9985233190314),\nvec2(5.377470330381102e-05,1094.5456789940797),\nvec2(5.3698745663208486e-05,1096.0939289067194),\nvec2(5.362294884612412e-05,1097.6432730569493),\nvec2(5.3547312398867037e-05,1099.193711444769),\nvec2(5.347183586934517e-05,1100.7452440701763),\nvec2(5.339651880705835e-05,1102.2978709331703),\nvec2(5.332136076309171e-05,1103.8515920337497),\nvec2(5.3246361290108946e-05,1105.4064073719128),\nvec2(5.317151994234557e-05,1106.9623169476583),\nvec2(5.309683627560252e-05,1108.519320760985),\nvec2(5.3022309847239264e-05,1110.0774188118914),\nvec2(5.294794021616751e-05,1111.636611100377),\nvec2(5.287372694284455e-05,1113.19689762644),\nvec2(5.27996695892668e-05,1114.7582783900782),\nvec2(5.272576771896322e-05,1116.320753391291),\nvec2(5.265202089698913e-05,1117.8843226300771),\nvec2(5.257842868991951e-05,1119.4489861064355),\nvec2(5.250499066584299e-05,1121.014743820365),\nvec2(5.243170639435511e-05,1122.5815957718632),\nvec2(5.235857544655234e-05,1124.1495419609298),\nvec2(5.22855973950256e-05,1125.7185823875632),\nvec2(5.221277181385417e-05,1127.288717051762),\nvec2(5.21400982785993e-05,1128.8599459535262),\nvec2(5.206757636629826e-05,1130.432269092852),\nvec2(5.199520565545792e-05,1132.0056864697403),\nvec2(5.192298572604881e-05,1133.5801980841889),\nvec2(5.1850916159499013e-05,1135.1558039361967),\nvec2(5.177899653868795e-05,1136.7325040257633),\nvec2(5.17072264479406e-05,1138.3102983528854),\nvec2(5.1635605473021224e-05,1139.8891869175636),\nvec2(5.156413320112757e-05,1141.469169719796),\nvec2(5.1492809220884835e-05,1143.0502467595813),\nvec2(5.1421633122339794e-05,1144.6324180369186),\nvec2(5.1350604496954894e-05,1146.2156835518067),\nvec2(5.1279722937602396e-05,1147.8000433042434),\nvec2(5.1208988038558537e-05,1149.3854972942286),\nvec2(5.1138399395497676e-05,1150.9720455217612),\nvec2(5.106795660548658e-05,1152.559687986839),\nvec2(5.099765926697871e-05,1154.1484246894618),\nvec2(5.092750697980839e-05,1155.7382556296275),\nvec2(5.0857499345185146e-05,1157.3291808073352),\nvec2(5.078763596568818e-05,1158.9212002225843),\nvec2(5.0717916445260434e-05,1160.514313875372),\nvec2(5.064834038920324e-05,1162.1085217657),\nvec2(5.057890740417068e-05,1163.7038238935645),\nvec2(5.0509617098163964e-05,1165.3002202589646),\nvec2(5.044046908052588e-05,1166.8977108619001),\nvec2(5.037146296193537e-05,1168.4962957023693),\nvec2(5.030259835440204e-05,1170.095974780372),\nvec2(5.023387487126061e-05,1171.696748095906),\nvec2(5.0165292127165636e-05,1173.2986156489699),\nvec2(5.009684973808592e-05,1174.9015774395627),\nvec2(5.00285473212994e-05,1176.5056334676844),\nvec2(4.99603844953875e-05,1178.110783733332),\nvec2(4.989236088022996e-05,1179.7170282365066),\nvec2(4.982447609699958e-05,1181.3243669772057),\nvec2(4.9756729768156924e-05,1182.9327999554275),\nvec2(4.96891215174449e-05,1184.542327171172),\nvec2(4.962165096988379e-05,1186.1529486244378),\nvec2(4.9554317751765845e-05,1187.7646643152245),\nvec2(4.9487121490650286e-05,1189.3774742435287),\nvec2(4.9420061815358e-05,1190.991378409352),\nvec2(4.9353138355966495e-05,1192.6063768126917),\nvec2(4.9286350743804804e-05,1194.2224694535462),\nvec2(4.921969861144832e-05,1195.839656331917),\nvec2(4.915318159271389e-05,1197.4579374478),\nvec2(4.908679932265467e-05,1199.0773128011954),\nvec2(4.9020551437555166e-05,1200.6977823921031),\nvec2(4.8954437574926196e-05,1202.3193462205204),\nvec2(4.8888457373499985e-05,1203.9420042864463),\nvec2(4.8822610473225276e-05,1205.5657565898816),\nvec2(4.8756896515262315e-05,1207.190603130823),\nvec2(4.869131514197801e-05,1208.8165439092702),\nvec2(4.862586599694107e-05,1210.4435789252223),\nvec2(4.856054872491714e-05,1212.0717081786781),\nvec2(4.8495362971864014e-05,1213.700931669637),\nvec2(4.843030838492686e-05,1215.3312493980973),\nvec2(4.836538461243329e-05,1216.9626613640576),\nvec2(4.8300591303888864e-05,1218.595167567518),\nvec2(4.823592810997209e-05,1220.2287680084773),\nvec2(4.817139468252994e-05,1221.8634626869336),\nvec2(4.810699067457299e-05,1223.4992516028863),\nvec2(4.8042715740270896e-05,1225.136134756334),\nvec2(4.797856953494767e-05,1226.7741121472766),\nvec2(4.7914551715077055e-05,1228.413183775712),\nvec2(4.785066193827796e-05,1230.0533496416397),\nvec2(4.7786899863309856e-05,1231.6946097450589),\nvec2(4.772326515006831e-05,1233.336964085969),\nvec2(4.765975745958023e-05,1234.9804126643676),\nvec2(4.7596376453999636e-05,1236.6249554802537),\nvec2(4.753312179660297e-05,1238.270592533628),\nvec2(4.7469993151784617e-05,1239.9173238244887),\nvec2(4.7406990185052665e-05,1241.5651493528337),\nvec2(4.7344112563024134e-05,1243.2140691186626),\nvec2(4.728135995342095e-05,1244.8640831219755),\nvec2(4.7218732025065185e-05,1246.5151913627699),\nvec2(4.715622844787498e-05,1248.1673938410465),\nvec2(4.709384889286009e-05,1249.8206905568024),\nvec2(4.703159303211742e-05,1251.4750815100376),\nvec2(4.6969460538827e-05,1253.130566700751),\nvec2(4.690745108724738e-05,1254.7871461289417),\nvec2(4.6845564352711654e-05,1256.444819794609),\nvec2(4.678380001162295e-05,1258.103587697752),\nvec2(4.672215774145045e-05,1259.7634498383682),\nvec2(4.666063722072496e-05,1261.4244062164585),\nvec2(4.6599238129034834e-05,1263.0864568320212),\nvec2(4.65379601470218e-05,1264.7496016850548),\nvec2(4.647680295637674e-05,1266.4138407755595),\nvec2(4.6415766239835635e-05,1268.0791741035332),\nvec2(4.635484968117544e-05,1269.7456016689766),\nvec2(4.629405296520996e-05,1271.4131234718857),\nvec2(4.6233375777785715e-05,1273.0817395122633),\nvec2(4.6172817805777976e-05,1274.7514497901066),\nvec2(4.611237873708677e-05,1276.4222543054138),\nvec2(4.60520582606327e-05,1278.0941530581852),\nvec2(4.599185606635304e-05,1279.76714604842),\nvec2(4.593177184519779e-05,1281.441233276116),\nvec2(4.587180528912556e-05,1283.1164147412735),\nvec2(4.581195609109977e-05,1284.792690443892),\nvec2(4.575222394508472e-05,1286.4700603839683),\nvec2(4.569260854604155e-05,1288.148524561504),\nvec2(4.563310958992443e-05,1289.828082976497),\nvec2(4.5573726773676734e-05,1291.5087356289462),\nvec2(4.551445979522703e-05,1293.1904825188515),\nvec2(4.5455308353485396e-05,1294.8733236462112),\nvec2(4.539627214833955e-05,1296.557259011025),\nvec2(4.533735088065095e-05,1298.242288613291),\nvec2(4.527854425225114e-05,1299.9284124530095),\nvec2(4.5219851965937836e-05,1301.615630530179),\nvec2(4.516127372547138e-05,1303.303942844799),\nvec2(4.510280923557074e-05,1304.9933493968686),\nvec2(4.504445820191002e-05,1306.683850186386),\nvec2(4.4986220331114606e-05,1308.3754452133517),\nvec2(4.4928095330757524e-05,1310.0681344777634),\nvec2(4.487008290935578e-05,1311.7619179796222),\nvec2(4.481218277636678e-05,1313.4567957189252),\nvec2(4.475439464218447e-05,1315.1527676956712),\nvec2(4.4696718218136e-05,1316.849833909862),\nvec2(4.463915321647784e-05,1318.5479943614946),\nvec2(4.4581699350392435e-05,1320.2472490505695),\nvec2(4.452435633398448e-05,1321.947597977083),\nvec2(4.446712388227744e-05,1323.6490411410377),\nvec2(4.441000171120989e-05,1325.3515785424315),\nvec2(4.43529895376322e-05,1327.055210181263),\nvec2(4.429608707930281e-05,1328.7599360575318),\nvec2(4.423929405488488e-05,1330.465756171238),\nvec2(4.418261018394275e-05,1332.172670522379),\nvec2(4.4126035186938484e-05,1333.8806791109537),\nvec2(4.406956878522843e-05,1335.5897819369634),\nvec2(4.40132107010598e-05,1337.2999790004053),\nvec2(4.395696065756724e-05,1339.0112703012808),\nvec2(4.390081837876944e-05,1340.7236558395873),\nvec2(4.384478358956572e-05,1342.4371356153233),\nvec2(4.378885601573272e-05,1344.1517096284904),\nvec2(4.373303538392101e-05,1345.867377879085),\nvec2(4.367732142165168e-05,1347.5841403671095),\nvec2(4.362171385731316e-05,1349.30199709256),\nvec2(4.356621242015779e-05,1351.0209480554372),\nvec2(4.35108168402986e-05,1352.7409932557393),\nvec2(4.345552684870594e-05,1354.4621326934675),\nvec2(4.3400342177204354e-05,1356.1843663686186),\nvec2(4.334526255846913e-05,1357.9076942811948),\nvec2(4.329028772602331e-05,1359.632116431192),\nvec2(4.3235417414234235e-05,1361.3576328186111),\nvec2(4.3180651358310445e-05,1363.0842434434508),\nvec2(4.31259892942985e-05,1364.8119483057112),\nvec2(4.307143095907976e-05,1366.5407474053914),\nvec2(4.301697609036727e-05,1368.2706407424885),\nvec2(4.29626244267025e-05,1370.0016283170046),\nvec2(4.2908375707452355e-05,1371.7337101289365),\nvec2(4.2854229672805886e-05,1373.466886178286),\nvec2(4.280018606377132e-05,1375.2011564650493),\nvec2(4.274624462217294e-05,1376.936520989228),\nvec2(4.269240509064788e-05,1378.6729797508206),\nvec2(4.263866721264322e-05,1380.4105327498264),\nvec2(4.258503073241279e-05,1382.1491799862433),\nvec2(4.253149539501425e-05,1383.8889214600729),\nvec2(4.247806094630598e-05,1385.6297571713133),\nvec2(4.242472713294409e-05,1387.371687119963),\nvec2(4.237149370237941e-05,1389.1147113060226),\nvec2(4.231836040285448e-05,1390.8588297294903),\nvec2(4.2265326983400686e-05,1392.6040423903657),\nvec2(4.2212393193835016e-05,1394.3503492886482),\nvec2(4.215955878475754e-05,1396.0977504243365),\nvec2(4.210682350754808e-05,1397.8462457974308),\nvec2(4.2054187114363514e-05,1399.59583540793),\nvec2(4.200164935813467e-05,1401.3465192558324),\nvec2(4.19492099925637e-05,1403.0982973411387),\nvec2(4.189686877212089e-05,1404.8511696638473),\nvec2(4.18446254520421e-05,1406.605136223958),\nvec2(4.1792479788325574e-05,1408.3601970214688),\nvec2(4.174043153772937e-05,1410.1163520563805),\nvec2(4.168848045776833e-05,1411.8736013286916),\nvec2(4.1636626306711353e-05,1413.6319448384022),\nvec2(4.158486884357865e-05,1415.3913825855104),\nvec2(4.15332078281387e-05,1417.151914570016),\nvec2(4.1481643020905766e-05,1418.913540791919),\nvec2(4.143017418313684e-05,1420.6762612512168),\nvec2(4.137880107682914e-05,1422.4400759479108),\nvec2(4.1327523464717156e-05,1424.204984881999),\nvec2(4.127634111026999e-05,1425.9709880534815),\nvec2(4.122525377768866e-05,1427.7380854623566),\nvec2(4.117426123190332e-05,1429.5062771086239),\nvec2(4.1123363238570535e-05,1431.2755629922835),\nvec2(4.107255956407079e-05,1433.0459431133343),\nvec2(4.102184997550548e-05,1434.8174174717747),\nvec2(4.097123424069455e-05,1436.5899860676054),\nvec2(4.0920712128173604e-05,1438.363648900824),\nvec2(4.087028340719143e-05,1440.1384059714317),\nvec2(4.081994784770728e-05,1441.914257279427),\nvec2(4.076970522038823e-05,1443.691202824809),\nvec2(4.071955529660668e-05,1445.4692426075774),\nvec2(4.066949784843754e-05,1447.24837662773),\nvec2(4.061953264865592e-05,1449.028604885269),\nvec2(4.056965947073426e-05,1450.8099273801924),\nvec2(4.051987808884005e-05,1452.5923441124976),\nvec2(4.0470188277833046e-05,1454.3758550821865),\nvec2(4.042058981326278e-05,1456.1604602892578),\nvec2(4.037108247136613e-05,1457.9461597337095),\nvec2(4.032166602906467e-05,1459.7329534155426),\nvec2(4.0272340263962267e-05,1461.520841334756),\nvec2(4.022310495434246e-05,1463.3098234913475),\nvec2(4.0173959879166036e-05,1465.0998998853192),\nvec2(4.012490481806852e-05,1466.8910705166686),\nvec2(4.007593955135783e-05,1468.6833353853954),\nvec2(4.002706386001153e-05,1470.4766944914995),\nvec2(3.997827752567476e-05,1472.2711478349788),\nvec2(3.992958033065751e-05,1474.066695415834),\nvec2(3.988097205793224e-05,1475.863337234064),\nvec2(3.983245249113156e-05,1477.6610732896684),\nvec2(3.9784021414545766e-05,1479.4599035826463),\nvec2(3.973567861312044e-05,1481.259828112997),\nvec2(3.968742387245404e-05,1483.06084688072),\nvec2(3.963925697879558e-05,1484.862959885814),\nvec2(3.95911777190422e-05,1486.6661671282795),\nvec2(3.9543185880736866e-05,1488.4704686081152),\nvec2(3.949528125206601e-05,1490.27586432532),\nvec2(3.944746362185713e-05,1492.0823542798948),\nvec2(3.93997326807332e-05,1493.8899384718377),\nvec2(3.93520884183233e-05,1495.6986169011484),\nvec2(3.930453052464777e-05,1497.5083895678256),\nvec2(3.925705879107598e-05,1499.3192564718709),\nvec2(3.920967300960699e-05,1501.1312176132803),\nvec2(3.916237297286704e-05,1502.9442729920556),\nvec2(3.911515847410745e-05,1504.7584226081956),\nvec2(3.9068029307202254e-05,1506.5736664616998),\nvec2(3.902098526664603e-05,1508.3900045525677),\nvec2(3.897402614755165e-05,1510.2074368807978),\nvec2(3.892715174564799e-05,1512.0259634463896),\nvec2(3.888036185727776e-05,1513.8455842493445),\nvec2(3.8833656279395254e-05,1515.6662992896595),\nvec2(3.878703480956422e-05,1517.488108567336),\nvec2(3.874049724595555e-05,1519.3110120823708),\nvec2(3.8694043387345257e-05,1521.1350098347643),\nvec2(3.864767303311209e-05,1522.9601018245173),\nvec2(3.860138598323561e-05,1524.7862880516284),\nvec2(3.855518203829381e-05,1526.6135685160955),\nvec2(3.850906099946106e-05,1528.4419432179213),\nvec2(3.846302266850608e-05,1530.271412157103),\nvec2(3.841706684778959e-05,1532.1019753336386),\nvec2(3.837119334026238e-05,1533.9336327475312),\nvec2(3.832540194946307e-05,1535.7663843987764),\nvec2(3.827969247951604e-05,1537.6002302873767),\nvec2(3.823406473512943e-05,1539.4351704133296),\nvec2(3.8188518521592926e-05,1541.2712047766347),\nvec2(3.8143053644775725e-05,1543.1083333772924),\nvec2(3.809766991112449e-05,1544.946556215302),\nvec2(3.805236712766127e-05,1546.7858732906623),\nvec2(3.800714510198148e-05,1548.6262846033726),\nvec2(3.7962003642251756e-05,1550.4677901534317),\nvec2(3.7916942557208106e-05,1552.310389940841),\nvec2(3.787196165615368e-05,1554.1540839655986),\nvec2(3.7827060748956886e-05,1555.9988722277046),\nvec2(3.778223964604932e-05,1557.8447547271576),\nvec2(3.773749815842388e-05,1559.691731463958),\nvec2(3.769283609763253e-05,1561.5398024381038),\nvec2(3.7648253275784564e-05,1563.388967649596),\nvec2(3.7603749505544535e-05,1565.239227098433),\nvec2(3.755932460013023e-05,1567.090580784616),\nvec2(3.7514978373310814e-05,1568.9430287081407),\nvec2(3.747071063940479e-05,1570.7965708690099),\nvec2(3.742652121327817e-05,1572.6512072672228),\nvec2(3.7382409910342346e-05,1574.5069379027766),\nvec2(3.7338376546552376e-05,1576.3637627756739),\nvec2(3.7294420938404907e-05,1578.221681885911),\nvec2(3.725054290293642e-05,1580.0806952334904),\nvec2(3.720674225772109e-05,1581.9408028184089),\nvec2(3.7163018820869156e-05,1583.802004640666),\nvec2(3.711937241102486e-05,1585.6643007002644),\nvec2(3.707580284736458e-05,1587.5276909972001),\nvec2(3.703230994959505e-05,1589.3921755314743),\nvec2(3.698889353795142e-05,1591.2577543030857),\nvec2(3.694555343319539e-05,1593.124427312033),\nvec2(3.6902289456613396e-05,1594.9921945583185),\nvec2(3.685910143001478e-05,1596.8610560419397),\nvec2(3.681598917572991e-05,1598.7310117628954),\nvec2(3.67729525166084e-05,1600.602061721186),\nvec2(3.6729991276017224e-05,1602.4742059168107),\nvec2(3.668710527783897e-05,1604.3474443497694),\nvec2(3.664429434647001e-05,1606.2217770200605),\nvec2(3.660155830681871e-05,1608.097203927686),\nvec2(3.655889698430361e-05,1609.9737250726428),\nvec2(3.651631020485171e-05,1611.8513404549312),\nvec2(3.647379779489656e-05,1613.7300500745498),\nvec2(3.6431359581376675e-05,1615.6098539314994),\nvec2(3.638899539173362e-05,1617.4907520257805),\nvec2(3.634670505391035e-05,1619.3727443573898),\nvec2(3.6304488396349415e-05,1621.2558309263281),\nvec2(3.6262345247991186e-05,1623.1400117325954),\nvec2(3.622027543827225e-05,1625.0252867761906),\nvec2(3.617827879712353e-05,1626.9116560571135),\nvec2(3.6136355154968695e-05,1628.799119575363),\nvec2(3.609450434272239e-05,1630.6876773309386),\nvec2(3.6052726191788485e-05,1632.577329323842),\nvec2(3.601102053405845e-05,1634.4680755540685),\nvec2(3.5969387201909655e-05,1636.3599160216215),\nvec2(3.592782602820365e-05,1638.252850726499),\nvec2(3.588633684628455e-05,1640.1468796686988),\nvec2(3.584491948997726e-05,1642.0420028482235),\nvec2(3.580357379358592e-05,1643.9382202650706),\nvec2(3.576229959189217e-05,1645.8355319192406),\nvec2(3.572109672015354e-05,1647.733937810733),\nvec2(3.5679965014101846e-05,1649.6334379395457),\nvec2(3.563890430994143e-05,1651.53403230568),\nvec2(3.559791444434763e-05,1653.435720909134),\nvec2(3.5556995254465155e-05,1655.3385037499097),\nvec2(3.551614657790639e-05,1657.2423808280037),\nvec2(3.547536825274991e-05,1659.147352143417),\nvec2(3.543466011753873e-05,1661.0534176961482),\nvec2(3.539402201127882e-05,1662.9605774861986),\nvec2(3.5353453773437464e-05,1664.8688315135662),\nvec2(3.531295524394167e-05,1666.778179778251),\nvec2(3.527252626317658e-05,1668.6886222802523),\nvec2(3.5232166671984005e-05,1670.6001590195694),\nvec2(3.5191876311660696e-05,1672.5127899962017),\nvec2(3.5151655023956925e-05,1674.4265152101498),\nvec2(3.51115026510748e-05,1676.3413346614132),\nvec2(3.507141903566682e-05,1678.25724834999),\nvec2(3.5031404020834296e-05,1680.1742562758814),\nvec2(3.4991457450125866e-05,1682.0923584390853),\nvec2(3.495157916753583e-05,1684.011554839603),\nvec2(3.491176901750277e-05,1685.9318454774314),\nvec2(3.487202684490797e-05,1687.853230352573),\nvec2(3.4832352495073936e-05,1689.775709465026),\nvec2(3.4792745813762834e-05,1691.6992828147893),\nvec2(3.4753206647175036e-05,1693.6239504018629),\nvec2(3.471373484194761e-05,1695.5497122262468),\nvec2(3.467433024515288e-05,1697.4765682879406),\nvec2(3.463499270429685e-05,1699.404518586944),\nvec2(3.459572206731781e-05,1701.333563123256),\nvec2(3.455651818258486e-05,1703.2637018968753),\nvec2(3.4517380898896356e-05,1705.1949349078031),\nvec2(3.447831006547863e-05,1707.1272621560381),\nvec2(3.443930553198431e-05,1709.0606836415795),\nvec2(3.440036714849108e-05,1710.9951993644281),\nvec2(3.436149476550014e-05,1712.930809324582),\nvec2(3.432268823393477e-05,1714.8675135220417),\nvec2(3.428394740513887e-05,1716.8053119568058),\nvec2(3.424527213087566e-05,1718.7442046288754),\nvec2(3.4206662263326174e-05,1720.6841915382488),\nvec2(3.416811765508779e-05,1722.6252726849252),\nvec2(3.4129638159172944e-05,1724.5674480689063),\nvec2(3.4091223629007676e-05,1726.5107176901886),\nvec2(3.40528739184302e-05,1728.4550815487746),\nvec2(3.401458888168958e-05,1730.4005396446623),\nvec2(3.3976368373444305e-05,1732.3470919778515),\nvec2(3.393821224876092e-05,1734.294738548342),\nvec2(3.390012036311259e-05,1736.2434793561322),\nvec2(3.3862092572377866e-05,1738.1933144012226),\nvec2(3.382412873283924e-05,1740.1442436836141),\nvec2(3.378622870118175e-05,1742.0962672033043),\nvec2(3.374839233449168e-05,1744.049384960293),\nvec2(3.3710619490255244e-05,1746.0035969545806),\nvec2(3.3672910026357146e-05,1747.9589031861667),\nvec2(3.363526380107933e-05,1749.9153036550506),\nvec2(3.359768067309963e-05,1751.8727983612307),\nvec2(3.356016050149042e-05,1753.8313873047082),\nvec2(3.35227031457173e-05,1755.7910704854814),\nvec2(3.348530846563779e-05,1757.7518479035512),\nvec2(3.344797632150001e-05,1759.7137195589164),\nvec2(3.341070657394139e-05,1761.6766854515774),\nvec2(3.337349908398735e-05,1763.6407455815317),\nvec2(3.333635371305001e-05,1765.6058999487811),\nvec2(3.329927032292691e-05,1767.5721485533245),\nvec2(3.326224877579974e-05,1769.5394913951607),\nvec2(3.3225288934232986e-05,1771.507928474292),\nvec2(3.3188390661172744e-05,1773.4774597907142),\nvec2(3.31515538199454e-05,1775.4480853444284),\nvec2(3.311477827425633e-05,1777.4198051354342),\nvec2(3.307806388818879e-05,1779.392619163732),\nvec2(3.3041410526202426e-05,1781.366527429321),\nvec2(3.300481805313228e-05,1783.3415299322005),\nvec2(3.2968286334187324e-05,1785.317626672369),\nvec2(3.2931815234949324e-05,1787.2948176498292),\nvec2(3.289540462137162e-05,1789.2731028645774),\nvec2(3.285905435977784e-05,1791.2524823166136),\nvec2(3.28227643168607e-05,1793.2329560059409),\nvec2(3.278653435968081e-05,1795.2145239325553),\nvec2(3.275036435566537e-05,1797.1971860964568),\nvec2(3.2714254172607046e-05,1799.1809424976461),\nvec2(3.267820367866272e-05,1801.1657931361224),\nvec2(3.26422127423523e-05,1803.151738011886),\nvec2(3.260628123255753e-05,1805.1387771249354),\nvec2(3.2570409018520755e-05,1807.1269104752703),\nvec2(3.2534595969843785e-05,1809.1161380628905),\nvec2(3.249884195648663e-05,1811.1064598877958),\nvec2(3.246314684876645e-05,1813.0978759499853),\nvec2(3.242751051735624e-05,1815.0903862494595),\nvec2(3.239193283328377e-05,1817.0839907862176),\nvec2(3.235641366793032e-05,1819.0786895602594),\nvec2(3.23209528930296e-05,1821.0744825715835),\nvec2(3.228555038066657e-05,1823.0713698201905),\nvec2(3.22502060032762e-05,1825.069351306081),\nvec2(3.221491963364248e-05,1827.0684270292525),\nvec2(3.217969114489718e-05,1829.0685969897052),\nvec2(3.214452041051866e-05,1831.0698611874395),\nvec2(3.210940730433087e-05,1833.072219622454),\nvec2(3.2074351700502067e-05,1835.0756722947494),\nvec2(3.2039353473543834e-05,1837.0802192043252),\nvec2(3.2004412498309884e-05,1839.0858603511801),\nvec2(3.196952864999485e-05,1841.0925957353138),\nvec2(3.193470180413339e-05,1843.1004253567264),\nvec2(3.189993183659886e-05,1845.1093492154184),\nvec2(3.1865218623602336e-05,1847.1193673113887),\nvec2(3.18305620416915e-05,1849.130479644636),\nvec2(3.1795961967749466e-05,1851.1426862151604),\nvec2(3.176141827899376e-05,1853.1559870229635),\nvec2(3.172693085297523e-05,1855.170382068041),\nvec2(3.169249956757688e-05,1857.1858713503964),\nvec2(3.165812430101294e-05,1859.2024548700274),\nvec2(3.1623804931827625e-05,1861.220132626934),\nvec2(3.158954133889416e-05,1863.2389046211156),\nvec2(3.15553334014137e-05,1865.2587708525712),\nvec2(3.152118099891419e-05,1867.279731321303),\nvec2(3.1487084011249473e-05,1869.3017860273078),\nvec2(3.1453042318598047e-05,1871.324934970587),\nvec2(3.14190558014621e-05,1873.349178151139),\nvec2(3.1385124340666464e-05,1875.3745155689644),\nvec2(3.135124781735759e-05,1877.4009472240616),\nvec2(3.1317426113002385e-05,1879.4284731164328),\nvec2(3.128365910938738e-05,1881.4570932460745),\nvec2(3.1249946688617545e-05,1883.4868076129883),\nvec2(3.121628873311526e-05,1885.517616217173),\nvec2(3.118268512561934e-05,1887.54951905863),\nvec2(3.1149135749184045e-05,1889.5825161373568),\nvec2(3.111564048717799e-05,1891.616607453353),\nvec2(3.108219922328315e-05,1893.6517930066193),\nvec2(3.1048811841493884e-05,1895.6880727971552),\nvec2(3.101547822611589e-05,1897.7254468249596),\nvec2(3.0982198261765216e-05,1899.7639150900347),\nvec2(3.094897183336732e-05,1901.803477592378),\nvec2(3.0915798826155924e-05,1903.8441343319878),\nvec2(3.08826791256722e-05,1905.8858853088661),\nvec2(3.084961261776365e-05,1907.9287305230116),\nvec2(3.08165991885832e-05,1909.972669974424),\nvec2(3.078363872458821e-05,1912.0177036631046),\nvec2(3.075073111253943e-05,1914.0638315890508),\nvec2(3.071787623950012e-05,1916.1110537522616),\nvec2(3.068507399283504e-05,1918.1593701527402),\nvec2(3.065232426020947e-05,1920.2087807904836),\nvec2(3.061962692958824e-05,1922.2592856654915),\nvec2(3.058698188923486e-05,1924.3108847777644),\nvec2(3.0554389027710456e-05,1926.3635781273017),\nvec2(3.052184823387285e-05,1928.4173657141034),\nvec2(3.048935939687567e-05,1930.4722475381673),\nvec2(3.0456922406167297e-05,1932.528223599497),\nvec2(3.0424537151490065e-05,1934.5852938980881),\nvec2(3.0392203522879217e-05,1936.6434584339424),\nvec2(3.035992141066197e-05,1938.702717207058),\nvec2(3.0327690705456656e-05,1940.763070217437),\nvec2(3.0295511298171754e-05,1942.8245174650772),\nvec2(3.0263383080004958e-05,1944.887058949979),\nvec2(3.0231305942442274e-05,1946.9506946721424),\nvec2(3.019927977725712e-05,1949.0154246315658),\nvec2(3.016730447650935e-05,1951.0812488282497),\nvec2(3.0135379932544422e-05,1953.1481672621937),\nvec2(3.0103506037992433e-05,1955.2161799333971),\nvec2(3.0071682685767262e-05,1957.2852868418613),\nvec2(3.003990976906562e-05,1959.3554879875824),\nvec2(3.0008187181366244e-05,1961.4267833705642),\nvec2(2.9976514816428852e-05,1963.4991729908036),\nvec2(2.9944892568293405e-05,1965.5726568483014),\nvec2(2.991332033127915e-05,1967.6472349430574),\nvec2(2.9881797999983778e-05,1969.7229072750702),\nvec2(2.9850325469282415e-05,1971.7996738443408),\nvec2(2.981890263432695e-05,1973.877534650868),\nvec2(2.9787529390545006e-05,1975.956489694651),\nvec2(2.9756205633639088e-05,1978.036538975692),\nvec2(2.972493125958585e-05,1980.1176824939878),\nvec2(2.9693706164635043e-05,1982.1999202495397),\nvec2(2.966253024530874e-05,1984.2832522423462),\nvec2(2.963140339840051e-05,1986.3676784724087),\nvec2(2.9600325520974547e-05,1988.4531989397262),\nvec2(2.9569296510364768e-05,1990.5398136442973),\nvec2(2.953831626417402e-05,1992.6275225861225),\nvec2(2.9507384680273208e-05,1994.7163257652014),\nvec2(2.947650165680049e-05,1996.8062231815343),\nvec2(2.944566709216036e-05,1998.8972148351202),\nvec2(2.941488088502295e-05,2000.9893007259577),\nvec2(2.9384142934322993e-05,2003.0824808540497),\nvec2(2.9353453139259214e-05,2005.176755219393),\nvec2(2.9322811399293347e-05,2007.2721238219876),\nvec2(2.9292217614149394e-05,2009.3685866618348),\nvec2(2.9261671683812763e-05,2011.4661437389332),\nvec2(2.9231173508529445e-05,2013.5647950532825),\nvec2(2.920072298880526e-05,2015.6645406048833),\nvec2(2.917032002540497e-05,2017.7653803937335),\nvec2(2.9139964519351516e-05,2019.867314419834),\nvec2(2.910965637192522e-05,2021.9703426831854),\nvec2(2.9079395484662953e-05,2024.0744651837856),\nvec2(2.904918175935731e-05,2026.1796819216352),\nvec2(2.9019015098055884e-05,2028.2859928967328),\nvec2(2.8988895403060465e-05,2030.3933981090793),\nvec2(2.8958822576926136e-05,2032.5018975586765),\nvec2(2.8928796522460665e-05,2034.611491245519),\nvec2(2.8898817142723563e-05,2036.7221791696097),\nvec2(2.8868884341025392e-05,2038.8339613309481),\nvec2(2.8838998020926946e-05,2040.9468377295352),\nvec2(2.8809158086238468e-05,2043.060808365368),\nvec2(2.877936444101892e-05,2045.175873238448),\nvec2(2.8749616989575186e-05,2047.2920323487747),\nvec2(2.8719915636461285e-05,2049.4092856963466),\nvec2(2.8690260286477638e-05,2051.5276332811636),\nvec2(2.8660650844670272e-05,2053.647075103226),\nvec2(2.863108721633007e-05,2055.7676111625365),\nvec2(2.8601569306992078e-05,2057.88924145909),\nvec2(2.8572097022434642e-05,2060.0119659928873),\nvec2(2.8542670268678714e-05,2062.1357847639297),\nvec2(2.8513288951987086e-05,2064.2606977722157),\nvec2(2.8483952978863694e-05,2066.3867050177473),\nvec2(2.8454662256052815e-05,2068.513806500521),\nvec2(2.8425416690538343e-05,2070.642002220537),\nvec2(2.839621618954304e-05,2072.7712921777966),\nvec2(2.8367060660527845e-05,2074.901676372299),\nvec2(2.8337950011191072e-05,2077.033154804044),\nvec2(2.8308884149467734e-05,2079.1657274730314),\nvec2(2.8279862983528813e-05,2081.29939437926),\nvec2(2.8250886421780503e-05,2083.4341555227315),\nvec2(2.82219543728635e-05,2085.570010903442),\nvec2(2.819306674565229e-05,2087.706960521395),\nvec2(2.8164223449254417e-05,2089.8450043765893),\nvec2(2.8135424393009814e-05,2091.984142469023),\nvec2(2.810666948649001e-05,2094.124374798696),\nvec2(2.8077958639497498e-05,2096.2657013656108),\nvec2(2.8049291762064963e-05,2098.4081221697647),\nvec2(2.802066876445464e-05,2100.5516372111565),\nvec2(2.7992089557157536e-05,2102.69624648979),\nvec2(2.7963554050892855e-05,2104.8419500056602),\nvec2(2.7935062156607114e-05,2106.98874775877),\nvec2(2.790661378547367e-05,2109.1366397491174),\nvec2(2.787820884889181e-05,2111.285625976703),\nvec2(2.7849847258486213e-05,2113.435706441527),\nvec2(2.782152892610621e-05,2115.586881143588),\nvec2(2.77932537638251e-05,2117.7391500828867),\nvec2(2.7765021683939467e-05,2119.892513259422),\nvec2(2.7736832598968503e-05,2122.046970673194),\nvec2(2.7708686421653302e-05,2124.202522324203),\nvec2(2.768058306495628e-05,2126.359168212447),\nvec2(2.765252244206037e-05,2128.5169083379274),\nvec2(2.7624504466368447e-05,2130.6757427006446),\nvec2(2.7596529051502614e-05,2132.835671300596),\nvec2(2.7568596111303563e-05,2134.996694137782),\nvec2(2.7540705559829885e-05,2137.158811212204),\nvec2(2.751285731135747e-05,2139.3220225238592),\nvec2(2.7485051280378735e-05,2141.486328072751),\nvec2(2.7457287381602058e-05,2143.6517278588753),\nvec2(2.742956552995114e-05,2145.818221882233),\nvec2(2.7401885640564243e-05,2147.9858101428254),\nvec2(2.7374247628793683e-05,2150.154492640651),\nvec2(2.7346651410205073e-05,2152.32426937571),\nvec2(2.7319096900576712e-05,2154.495140348),\nvec2(2.7291584015898972e-05,2156.667105557524),\nvec2(2.7264112672373576e-05,2158.840165004282),\nvec2(2.7236682786413104e-05,2161.0143186882688),\nvec2(2.720929427464022e-05,2163.18956660949),\nvec2(2.7181947053887067e-05,2165.365908767941),\nvec2(2.71546410411947e-05,2167.5433451636245),\nvec2(2.7127376153812376e-05,2169.7218757965375),\nvec2(2.710015230919699e-05,2171.901500666684),\nvec2(2.707296942501243e-05,2174.0822197740586),\nvec2(2.7045827419128923e-05,2176.2640331186644),\nvec2(2.701872620962247e-05,2178.4469407005004),\nvec2(2.6991665714774155e-05,2180.6309425195664),\nvec2(2.6964645853069618e-05,2182.8160385758615),\nvec2(2.6937666543198385e-05,2185.002228869386),\nvec2(2.6910727704053247e-05,2187.189513400139),\nvec2(2.688382925472969e-05,2189.3778921681205),\nvec2(2.685697111452527e-05,2191.567365173332),\nvec2(2.6830153202938968e-05,2193.7579324157714),\nvec2(2.6803375439670693e-05,2195.9495938954387),\nvec2(2.6776637744620553e-05,2198.142349612335),\nvec2(2.6749940037888328e-05,2200.3361995664573),\nvec2(2.672328223977289e-05,2202.5311437578075),\nvec2(2.669666427077154e-05,2204.7271821863847),\nvec2(2.6670086051579477e-05,2206.9243148521896),\nvec2(2.6643547503089156e-05,2209.122541755221),\nvec2(2.66170485463898e-05,2211.321862895479),\nvec2(2.659058910276665e-05,2213.522278272963),\nvec2(2.6564169093700534e-05,2215.7237878876713),\nvec2(2.6537788440867167e-05,2217.9263917396083),\nvec2(2.6511447066136685e-05,2220.130089828769),\nvec2(2.6485144891572977e-05,2222.3348821551544),\nvec2(2.645888183943313e-05,2224.5407687187653),\nvec2(2.6432657832166893e-05,2226.7477495196017),\nvec2(2.6406472792416038e-05,2228.9558245576627),\nvec2(2.6380326643013847e-05,2231.164993832948),\nvec2(2.6354219306984538e-05,2233.3752573454567),\nvec2(2.632815070754264e-05,2235.5866150951897),\nvec2(2.6302120768092494e-05,2237.7990670821446),\nvec2(2.6276129412227703e-05,2240.0126133063245),\nvec2(2.6250176563730455e-05,2242.227253767728),\nvec2(2.622426214657112e-05,2244.442988466355),\nvec2(2.619838608490759e-05,2246.6598174022033),\nvec2(2.617254830308474e-05,2248.8777405752726),\nvec2(2.6146748725633928e-05,2251.0967579855665),\nvec2(2.6120987277272333e-05,2253.3168696330827),\nvec2(2.609526388290254e-05,2255.5380755178194),\nvec2(2.6069578467611933e-05,2257.760375639777),\nvec2(2.6043930956672084e-05,2259.983769998958),\nvec2(2.601832127553833e-05,2262.2082585953594),\nvec2(2.5992749349849127e-05,2264.433841428982),\nvec2(2.59672151054256e-05,2266.660518499825),\nvec2(2.5941718468270925e-05,2268.8882898078878),\nvec2(2.5916259364569864e-05,2271.1171553531703),\nvec2(2.589083772068814e-05,2273.3471151356734),\nvec2(2.5865453463172015e-05,2275.578169155396),\nvec2(2.584010651874767e-05,2277.81031741234),\nvec2(2.5814796814320743e-05,2280.043559906501),\nvec2(2.5789524276975728e-05,2282.2778966378823),\nvec2(2.576428883397552e-05,2284.5133276064826),\nvec2(2.5739090412760864e-05,2286.7498528123),\nvec2(2.5713928940949803e-05,2288.987472255338),\nvec2(2.568880434633723e-05,2291.2261859355945),\nvec2(2.56637165568943e-05,2293.4659938530667),\nvec2(2.563866550076794e-05,2295.7068960077577),\nvec2(2.5613651106280345e-05,2297.9488923996664),\nvec2(2.5588673301928445e-05,2300.191983028792),\nvec2(2.5563732016383435e-05,2302.436167895136),\nvec2(2.5538827178490216e-05,2304.6814469986957),\nvec2(2.551395871726689e-05,2306.9278203394733),\nvec2(2.5489126561904277e-05,2309.1752879174664),\nvec2(2.5464330641765454e-05,2311.4238497326746),\nvec2(2.543957088638514e-05,2313.673505785102),\nvec2(2.541484722546928e-05,2315.924256074743),\nvec2(2.539015958889455e-05,2318.1761006016),\nvec2(2.5365507906707823e-05,2320.4290393656734),\nvec2(2.5340892109125665e-05,2322.6830723669614),\nvec2(2.5316312126533878e-05,2324.938199605464),\nvec2(2.5291767889486998e-05,2327.1944210811816),\nvec2(2.5267259328707787e-05,2329.4517367941144),\nvec2(2.524278637508677e-05,2331.710146744262),\nvec2(2.5218348959681722e-05,2333.9696509316223),\nvec2(2.519394701371717e-05,2336.230249356198),\nvec2(2.5169580468584e-05,2338.491942017986),\nvec2(2.5145249255838823e-05,2340.7547289169884),\nvec2(2.5120953307203668e-05,2343.0186100532037),\nvec2(2.5096692554565337e-05,2345.2835854266327),\nvec2(2.507246692997505e-05,2347.5496550372745),\nvec2(2.504827636564789e-05,2349.8168188851287),\nvec2(2.5024120793962414e-05,2352.085076970195));\n        \n        int index = int(fragCoord.x) + int(fragCoord.y)*int(iChannelResolution[0]);\n        \n        if (index >= SAMPLES)\n        {\n        \tfragColor = vec4(0.0,0.0,0.0,1.0);\n        }else{\n    \t\tvec2 k = ks[index];\n            fragColor = vec4(k.x,k.y,0.0,1.0);\n        }\n    }else{\n    \tfragColor = texelFetch(iChannel0, ivec2(int(fragCoord.x),int(fragCoord.y)),0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//By Carter Slocum 2020\n\n//can be first or second shader in pipeline\n//pseudo-randomly spawn ripples and update their center, time, and active state.\n\n#define MAX_WAVE_TIME 10.0\n\n//used to randomly select center\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0)\n    {//init ripples\n    \tif (fragCoord.y < 0.99 && fragCoord.x < 9.99)\n        {//Initialize ripples\n            vec2 cent = hash2(fragCoord);\n        \tfragColor = vec4(cent.x,cent.y, fragCoord.x, 1.0);\n        }\n        else\n        {\n        \tfragColor = vec4(0.0,0.0,0.0,0.0);\n        }\n    }\n    else\n    {//update ripples\n    \tvec4 last_ripple = texelFetch(iChannel0, ivec2(int(fragCoord.x),int(fragCoord.y)),0);\n        \n        if(last_ripple.a > 0.0)\n        {//Update ripples\n        \tfloat wave_time = last_ripple.b;\n            wave_time += iTimeDelta;\n            if (wave_time > MAX_WAVE_TIME)\n            {\n            \tvec2 cent = hash2(last_ripple.rg);\n                last_ripple = vec4(cent.x,cent.y,wave_time - MAX_WAVE_TIME,1.0);\n            }\n            else\n            {\n                last_ripple.b = wave_time;\n            }\n        }\n        \n        fragColor = last_ripple;\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//By Carter Slocum based on Schreck et al SIGGRAPH 2019\n\n//Note that most any change to these values requires the values of k0 and k1 to be recomputed\n//used as second to last shader (dependant on ripple data and k data)\n\n#define PI 3.14159265359 \n//density\n#define rho 1000.0 \n#define tau_star 0.074\n//gravity\n#define GRAV 9.8\n//initial ripple size\n#define R_star 0.002\n//viscosity\n#define V_star 0.000001\n\n//range of wave number values. no real solution to V exists less than V(K_MID)\n#define K_MIN 0.0000024999\n#define K_MAX 2354.35442935\n#define K_MID 0.2863\n\n//MIN V and maximum V for precomputed K samples\n#define V_MIN 1.27326851\n#define V_MAX 100.0\n\n\n#define SAMPLES 2048.0\n\n\n//these conversion are all over the code since we are in polar coords.\nfloat tau = tau_star / (rho * GRAV * R_star *R_star);\n\n\n//this function is only necessary if you plan to use newtons method instead of precomputing ks\nfloat V(float k)\n{\n    float tau = tau_star / (rho * GRAV * R_star *R_star);\n    return (1.0 + 3.0*tau*k*k) / (2.0 * sqrt(k*(1.0 + tau * k*k)));\n}\n\n//derivative of V\nfloat dV(float k)\n{\n    float ksq = k*k;\n    float tmp = tau*ksq*k + k;\n    return (3.0*tau*ksq*(tau*ksq + 2.0) - 1.0) / (4.0 * sqrt(tmp*tmp*tmp));\n}\n\n//look up pre-computed ks\nvec2 WaveNumbers(float target)\n{\n   float tg = (target - V_MIN)/(V_MAX - V_MIN)*SAMPLES;\n   int ind = int(tg);\n   vec4 samp0 = texelFetch(iChannel0,ivec2(ind % int(iChannelResolution[0]),ind/int(iChannelResolution[0])),0);\n   ind += 1;\n   vec4 samp1 = texelFetch(iChannel0,ivec2(ind % int(iChannelResolution[0]),ind/int(iChannelResolution[0])),0);\n   float frac = mod(tg, 1.0);\n   return vec2(mix(samp0.x,samp1.x,frac),mix(samp0.y,samp1.y,frac));\n}\n\n//given wave number get angular frequency\nfloat omega(float k)\n{\n    return sqrt(k*(1.0 + tau*k*k));\n}\n\nfloat gamma_star(float k)\n{\n    float k_star = k/R_star;\n    float omega_star = omega(k)*sqrt(GRAV/R_star);\n    return 0.5*sqrt((omega_star*V_star)/(2.0))*k_star + 2.0*V_star*k_star*k_star;\n}\n//wave damping (sensitive)\nfloat Damping(float k, float t_star) \n{\n   return exp(-gamma_star(k)*t_star);\n}\n\nfloat A(float k, float t_star)\n{\n   return (omega(k)*Damping(k,t_star)*sqrt(k))/sqrt(abs(dV(k)));\n}\n//calculate wave hight at this radius and wave time\nfloat height(float r_star, float t_star)\n{\n    float r = r_star/R_star;\n    float t = t_star * sqrt(GRAV/R_star);\n    if ((r/t) < V_MIN || (r/t) > V_MAX)\n    {\n        return 0.0;\n    }\n    float vamp = (3.0*(10.0/sqrt(GRAV*R_star)))/(128.0*sqrt(r*t));\n    vec2 ks = WaveNumbers(r/t);\n    float k0 = ks[0];\n    float k1 = ks[1];\n    float wave0 = A(k0,t_star)*sin(omega(k0)*t - k0*r); \n    float wave1 = A(k1,t_star)*cos(omega(k1)*t - k1*r);\n\n    return vamp*(wave0 + wave1);\n}\n\n//store the additive wave heights in a height map.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wave_height = 0.0;\n    int ripple_index = 0;\n    while (ripple_index < 10)\n    {\n    \tvec4 ripple = texelFetch(iChannel1, ivec2(ripple_index,0),0);\n        float t_star = ripple.b;\n        float r_star = length(ripple.rg - (fragCoord.xy/float(iResolution.xy)))*4.0;\n        wave_height += height(r_star,t_star);\n        ripple_index += 1;\n    }\n\n    fragColor = vec4(1000.0*wave_height,0.0,0.0,1.0);//store height in r channel\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 367, 413, 413, 499], [501, 521, 554, 554, 585], [587, 621, 654, 654, 803], [805, 1056, 1087, 1159, 2081], [2084, 2133, 2170, 2170, 2443], [2445, 2445, 2510, 2510, 2898], [2901, 2901, 2958, 2982, 5597]], "test": "untested"}
{"id": "WlXczn", "name": "Bubble Chain", "author": "yacodes", "description": "Ray marching shader", "tags": ["bubblechain"], "likes": 2, "viewed": 244, "published": 3, "date": "1591211270", "time_retrieved": "2024-07-30T21:03:19.258961", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 128.0;\nconst float EPSILON = 0.0001;\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\nvec3 opCheapBend(in vec3 p )\n{\n    const float k = -0.50;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(vec3(c),-l,l);\n    return q;\n}\n\nmat4 rotateX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotateY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotateZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvec3 opRep( in vec3 p, in vec3 c) {\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    samplePoint = (rotateY(sin(iTime / 3. + 0.6745)) * vec4(samplePoint, 1.)).xyz;\n\tsamplePoint = (rotateX(sin(iTime / 2.)) * vec4(samplePoint, 1.)).xyz;\n\tsamplePoint = (rotateZ(cos(iTime / 4.)) * vec4(samplePoint, 1.)).xyz;\n    \n    vec3 spherePoint = samplePoint;\n    spherePoint /= 4.;\n    spherePoint = translate(\n        spherePoint,\n        vec3(\n            sin(iTime) * 4.,\n            sin(iTime) * 4.,\n            sin(iTime))\n    );\n    spherePoint = opRep(spherePoint, vec3(4., 8., 0.));\n    \n    spherePoint = (rotateZ(cos(iTime + 0.125)) * vec4(spherePoint, 1.)).xyz;\n    \n    samplePoint = opRep(samplePoint, vec3(2.5, 3.9, 0.));\n    \n    return opSmoothUnion(\n        sphereSDF(spherePoint),\n        sdLink(samplePoint, 0.75, 1., 0.1),\n        5.\n    );\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 eye = vec3(cos(iTime) * 8., sin(iTime) * 4., 40.);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.101,0.064,cos(iTime + 0.8565 + p.z) / 2. + 0.5);\n    vec3 K_d = vec3(0.485,cos(iTime + 0.1254 + p.x) / 2. + 0.5,cos(iTime + 0.21312 + p.x) / 2. + 0.5);\n    vec3 K_s = vec3(sin(iTime + 0.1254 + p.x) / 2. + 0.5, 1.0, sin(iTime + 0.1254 + p.x) / 2. + 0.5);\n    float shininess = 1000.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 163, 163, 203], [205, 205, 235, 235, 390], [392, 392, 446, 446, 548], [550, 550, 602, 602, 701], [705, 705, 756, 756, 810], [812, 812, 844, 844, 983], [985, 985, 1017, 1017, 1153], [1155, 1155, 1187, 1187, 1320], [1322, 1322, 1357, 1357, 1408], [1410, 1410, 1442, 1442, 1462], [1464, 1464, 1498, 1498, 2268], [2271, 2271, 2362, 2362, 2668], [2683, 2683, 2748, 2748, 2880], [2882, 2882, 2911, 2911, 3221], [3224, 3224, 3364, 3364, 3793], [3795, 3795, 3880, 3880, 4680], [4683, 4683, 4740, 4740, 5603]], "test": "untested"}
{"id": "tsjfDt", "name": "A simple raytracer ", "author": "chen1180", "description": "A simple raytracer demo based on Inigo Quilez' youtube tutorial https://www.youtube.com/watch?v=9g8CdctxmeU.", "tags": ["raytracing", "blinnphongmodel"], "likes": 3, "viewed": 306, "published": 3, "date": "1591201965", "time_retrieved": "2024-07-30T21:03:20.103703", "image_code": "// Global setting for raytracing\n#define BlinnPhongShading true \n#define Samples 5\n#define MaxDepth 5\n#define T_MIN 0.0001\n#define T_MAX 1000.0\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\nfloat g_seed = 0.0;\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray trace helper functions\n//\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELETRIC 2\nstruct Material{\n\tint matType;\n    vec3 albedo;\n    float ior;\n};\nstruct Sphere{\n\tvec3 center;\n    float radius;\n    Material material;\n};\n struct Plane{\n\tvec3 p;\n    vec3 normal;\n    Material material;\n};\nSphere sceneList[] =Sphere[](Sphere(vec3(1.0,0.0,-3.0),0.5,Material(METAL,vec3(0.8,0.8,0.8),0.0)),\n    Sphere(vec3(1.5,0.0,-1.0),0.5,Material(DIELETRIC,vec3(0.5,.5,.5),1.3)),\n    Sphere(vec3(-0.5,0.0,-2.0),0.5,Material(LAMBERTIAN,vec3(0.1,1.0,0.1),0.0)),\nSphere(vec3(-1.0,0.0,0.0),0.5,Material(METAL,vec3(0.2,0.2,0.8),0.0)));\nPlane p=Plane(vec3(0,0.5,0.0),vec3(0.0,1.0,0.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0));\n\nstruct HitRecord{\n    //Type 1: sphere\n    //Type 2: plane\n    int type; \n    bool isHit;\n    vec3 p;\n    vec3 normal;\n    Material material;\n    \n};\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n    };\nfloat intersectSphere(Ray r,Sphere s){\n    vec3 oc=r.origin-s.center;\n    vec3 t=r.direction;\n\tfloat a=dot(t,t);\n    float b=2.0*dot(t,oc);\n    float c=dot(oc,oc)-s.radius*s.radius;\n    float discriminant=b*b-4.0*a*c;\n    if (discriminant<=0.0)\n        return -1.0;\n    else\n    {\n    \tfloat x1=(-b-sqrt(discriminant))/(2.0*a);\n        if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n        x1=(-b+sqrt(discriminant))/(2.0*a);\n         if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n    }\n}\nvec3 getSphereNormal(vec3 hitPoint,Sphere s){\n\treturn normalize(hitPoint-s.center);\n}\nfloat intersectPlane(Ray r,Plane s){\n\tvec3 op=r.origin-s.p;\n    float d=dot(op,s.normal)/dot(r.direction,s.normal);\n    return d;\n\n}\n\nvec3 getPlaneNormal(vec3 hitPoint,Plane p){\n\treturn normalize(hitPoint+p.normal);\n}\n\nvec3 skyColor(float t){\n    return (1.0-t)*vec3(1.0)+t*vec3(0.2,0.5,0.7);\n\t\n}\n\n\nHitRecord intersectScene(Ray r){\n    float tMax=T_MAX;\n    float tMin=T_MIN;\n    HitRecord hit_record;\n    hit_record.isHit=false;\n    for (int i=0;i<sceneList.length();i++)\n    {\n    \tfloat ts=intersectSphere(r, sceneList[i]);\n   \t\t if (ts>tMin && ts<tMax){\n            tMax=ts;\n            hit_record.type=1;\n             hit_record.p=r.origin+r.direction*ts;\n             vec3 normal=getSphereNormal(hit_record.p,sceneList[i]);\n            hit_record.normal=getSphereNormal(hit_record.p,sceneList[i]);\n             hit_record.material=sceneList[i].material;\n             hit_record.isHit=true;\n         }\n        \n    }\n     float tp=intersectPlane( r,p);\n\t if (tp>tMin&&tp<tMax){\n        tMax=tp;\n          hit_record.type=2;\n         hit_record.p=r.origin+r.direction*tp;\n        hit_record.normal=getPlaneNormal(hit_record.p,p);\n          hit_record.material=p.material;\n          hit_record.isHit=true;\n     }\n    return hit_record;\n\n}\n//BlinnPhong model\nvec3 blinnPhong(HitRecord hit_record,vec3 rayDir,vec2 uv){\n  \tvec3 col=vec3(1.0);\n    vec3 lightPos=vec3(1.0,1.0,-3.0);\n    vec3 lightDir=normalize(lightPos-hit_record.p);\n    if (hit_record.type==1){\n        float diff=clamp(dot(hit_record.normal,lightDir),0.0,1.0);\n        float ambient=0.4;\n        vec3 reflectDir=reflect(lightDir,hit_record.normal);\n        vec3 bisector=(reflectDir+rayDir)*0.5;\n        float specular=pow(max(dot(reflectDir,bisector),0.0),16.0);\n        col=(diff*ambient+ambient+specular)*hit_record.material.albedo;\n        \n    }else if (hit_record.type==2){\n        float diff=clamp(dot(hit_record.normal,lightDir),0.0,1.0);\n        float ambient=0.0;\n        for (int i=0;i<sceneList.length();i++)\n        {\n             ambient+= smoothstep(0.0,sceneList[i].radius,length(hit_record.p.xz-sceneList[i].center.xz));\n        }\n        col=vec3(0.2*ambient);\n        \n    }else\n        col=skyColor(uv.y);\n    return col;\n}\nfloat schlick(float cos_theta, float n2)\n{\n    const float n1 = 1.0f;  // refraction index for air\n\n    float r0s = (n1 - n2) / (n1 + n2);\n    float r0 = r0s * r0s;\n\n    return r0 + (1.0f - r0) * pow((1.0f - cos_theta), 5.0f);\n}\nbool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n\n    float dt = dot(uv, n);\n\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n\n    if (discriminant > 0.0f)\n    {\n        refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n\n        return true;\n    }\n    else\n        return false;\n}\nbool material_bsdf(HitRecord hit_record,Ray inRay, out Ray outRay,out vec3 attenuation){\n    vec3 col=vec3(0.0);\n    //lambertian\n    if(hit_record.material.matType==LAMBERTIAN){\n        vec3 ray_origin=hit_record.p;\n        vec3 ray_dir=random_cos_weighted_hemisphere_direction(hit_record.normal,g_seed);\n        outRay=Ray(ray_origin,ray_dir);\n        attenuation=hit_record.material.albedo;\n        return true;\n    }else if(hit_record.material.matType==METAL){\n     //metal\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        outRay=Ray(hit_record.p,reflected);\n        attenuation=hit_record.material.albedo;\n         return true;\n    }else if(hit_record.material.matType==DIELETRIC){\n     //dieletric\n        vec3 outward_normal,refracted;\n        float ni_over_nt,cosine,reflect_prob;\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        if (dot(inRay.direction,hit_record.normal)>0.0){\n        \toutward_normal=-hit_record.normal;\n            ni_over_nt=hit_record.material.ior;\n            cosine=dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n            cosine=sqrt(1.0-ni_over_nt*ni_over_nt*(1.0-cosine*cosine));\n            \n        }else{\n            outward_normal=hit_record.normal;\n        \tni_over_nt = 1.0f / hit_record.material.ior;\n            cosine=-dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n        }\n        if (refractVec(inRay.direction, outward_normal, ni_over_nt, refracted))\n            reflect_prob = schlick(cosine, hit_record.material.ior);\n        else\n            reflect_prob = 1.0f;\n  \n        if (hash1(g_seed)<reflect_prob)\n        {\n        \toutRay=Ray(hit_record.p,reflected);\n\n        } \t\n        else\n        {\n\n            outRay=Ray(hit_record.p,refracted);\n        }\n        attenuation=hit_record.material.albedo;\n        return true;\n\n        \n    }\n    return false;\n\n}\n\nvec3 radiance(Ray r,vec2 uv){\n  \tvec3 col=vec3(1.0);\n    HitRecord hit_record;\n    for(int bounce=0;bounce<MaxDepth;bounce++)\n    {\n        hit_record=intersectScene(r);\n\n        if (hit_record.isHit)\n        {\n\t\t\t\n            Ray outRay;\n            vec3 color;\n            bool scattered=material_bsdf(hit_record,r,outRay,color);\n            r.origin=outRay.origin;\n            r.direction=outRay.direction;\n            if (scattered)\n            {\n                col*=color;\n            }\n            \n            else\n            {\n            \tcol*=vec3(0.0);\n                break;\n            }\n               \n  \n        }else\n        {\n            col*=skyColor(uv.y);\n        \tbreak;\n        }\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    g_seed = float(base_hash(floatBitsToUint(fragCoord.xy)))/float(0xffffffffU)+iTime;\n    //camera ray calculation\n    vec3 cameraPos=vec3(5.0*cos(iTime),0,5.0*sin(iTime));\n    vec3 cameraLookAt=vec3(0.0,0.0,-1.0);\n    float ratio=iResolution.x/iResolution.y;\n    vec3 t=normalize(cameraLookAt-cameraPos);\n    vec3 up=vec3(0.0,1.0,0.0);\n    vec3 h=normalize(cross(t,up));\n    vec3 v=normalize(cross(h,t));\n\n    vec3 leftBotCorner=cameraPos+t-ratio*1.0/2.0*h-1.0/2.0*v;\n    vec3 rayDir=leftBotCorner+ratio*uv.x*h+uv.y*v-cameraPos;\n    Ray r=Ray(cameraPos,rayDir);\n    //sphere move\n    for (int i=0;i<sceneList.length();i++)\n    {\n         if ( sceneList[i].material.matType==METAL)\n             continue;\n         //sceneList[i].center.x+=sin(iTime);\n         //sceneList[i].center.z+=cos(iTime);\n    }\n    //shading\n    if (BlinnPhongShading){\n        vec3 col=vec3(0.0);\n    \tHitRecord rec=intersectScene(r);\n    \tcol=blinnPhong(rec,rayDir,uv);\n         // Output to screen\n    \tfragColor = vec4(col,1.0);\n    }\n    else{\n        vec3 col=vec3(0.0);\n        for(int i=0;i<Samples;i++){\n            float x=(fragCoord.x+ hash1(g_seed))/iResolution.x;\n            float y=(fragCoord.y+ hash1(g_seed))/iResolution.y;\n            col+=radiance(r,vec2(x,y));\n        }\n        col/=float(Samples);\n        // Output to screen\n    \tfragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n       \t\n\n    } \n    \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 262, 262, 378], [380, 380, 411, 411, 519], [521, 521, 551, 551, 717], [719, 719, 749, 749, 922], [961, 961, 1042, 1042, 1371], [2261, 2261, 2299, 2299, 2743], [2744, 2744, 2789, 2789, 2829], [2830, 2830, 2866, 2866, 2962], [2964, 2964, 3007, 3007, 3047], [3049, 3049, 3072, 3072, 3126], [3129, 3129, 3161, 3161, 4071], [4072, 4091, 4149, 4149, 5041], [5042, 5042, 5084, 5084, 5270], [5271, 5271, 5342, 5342, 5642], [5643, 5643, 5731, 5731, 7544], [7546, 7546, 7575, 7575, 8283], [8286, 8286, 8343, 8393, 9838]], "test": "untested"}
{"id": "ts2Bzm", "name": "BUDKICTT", "author": "irwatts", "description": "I'm sorry", "tags": ["fft", "dickbutt"], "likes": 4, "viewed": 368, "published": 3, "date": "1591158749", "time_retrieved": "2024-07-30T21:03:20.918524", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float row = floor(fract(-iChannelTime[0] / 4.286) * iResolution.y);\n    if (fragCoord.y > row && fragCoord.y < row + 1.0)\n    {\n        vec2 uv = fragCoord/iResolution.xy;\n\t\tfloat fft  = texture(iChannel0, vec2(uv.x,0.25)).x;\n        fragColor = vec4(vec3(sin(iTime+fft*8.0+uv.xyx+vec3(0.5,1.5,7))), 1.0);\n    }\n    else\n    {\n        discard;\n    }\n}", "image_inputs": [{"id": 23040, "src": "https://soundcloud.com/user-824100724/budkictt", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2Bzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 413]], "test": "untested"}
{"id": "wsjfWt", "name": "Swimming rainbow blobs", "author": "jarble", "description": "These rainbow blobs appear to be sentient!\nClick and drag the mouse to look around.", "tags": ["raymarching", "blobs"], "likes": 3, "viewed": 342, "published": 3, "date": "1591158675", "time_retrieved": "2024-07-30T21:03:21.705420", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nvec3 animate(vec3 p){\n    return p + sin((p/100.0+vec3(iTime/10.0+sin((p.x)/100.0))).yzx)*100.0;\n}\nvec3 surface_color(vec3 p)\n{\n    return sin(p/10.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p *= 2.0;\n    p = animate(p)/10.0;\n    return  3.9 +sin(length(p*5.0)/2.0) + (sin(p.x)+sin(p.y)+sin(p.z))*1.1;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth/500.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),0.0,0.0);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    vec3 eye = vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*1.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 268, 268, 345], [346, 346, 374, 374, 400], [402, 642, 666, 666, 783], [785, 1206, 1297, 1297, 1621], [1636, 1890, 1955, 1955, 2087], [2089, 2178, 2207, 2207, 2517], [2519, 3011, 3151, 3151, 3741], [3743, 4113, 4198, 4198, 4956], [4958, 5285, 5334, 5369, 5500], [5502, 5502, 5559, 5559, 6629]], "test": "untested"}
{"id": "WsjfDt", "name": "Dawn at a distant world", "author": "mrange", "description": "License CC0: Dawn at a distant world.\nBeen working on space themed shaders.\nCode \"borrowed\" from the usual suspects", "tags": ["terrain", "fbm"], "likes": 20, "viewed": 719, "published": 3, "date": "1591135285", "time_retrieved": "2024-07-30T21:03:22.504284", "image_code": "// License CC0: Dawn at a distant world\n//  Been working on space themed shaders\n//  Code \"borrowed\" from the usual suspects\n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.00001\n#define MAX_ITER        65\n#define MIN_DISTANCE    0.01\n#define MAX_DISTANCE    9.0\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = vec3(0.0);\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.6,0.4);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.7);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  mountainColor = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 center = sphere.xyz;\n  float radius = sphere.w;\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nfloat noise1(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n  \n  const float r = 0.225;\n \n  float d = circle(p, 2.0*r);\n  \n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat noise2(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  rot(p, TAU*hh.y);\n  const float r = 0.45;\n \n//  float d = circle(p, 1.0*r);\n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n  \n  float h = -abs(hh.x)*(smoothstep(0.0, r, -2.0*d)-0.3*smoothstep(0.0, 0.2*r, -d));\n\n  return h*0.275;\n}\n\n\nfloat height(vec2 p, float dd, int mx) {\n  const float aa   = 0.45;\n  const float ff   = 2.03;\n  const float tt   = 1.2;\n  const float oo   = 3.93;\n  const float near = 0.25;\n  const float far  = 0.65;\n  \n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.075*sin(p.x+p.y);\n  float d = 0.0;\n  \n  int i = 0;\n  \n  for (; i < 4;++i) {\n    float nn = a*noise2(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float lod = s/d;\n\n  float rdd = dd/MAX_DISTANCE;\n  mx = int(mix(float(4), float(mx), step(rdd, far)));\n  \n  for (; i < mx; ++i) {\n    float nn = a*noise1(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n  \n  float hid = (s/d);\n  \n  return mix(hid, lod, smoothstep(near, far, rdd));\n}\n\nfloat loheight(vec2 p, float d) {\n  return height(p, d, 0);\n}\n\nfloat height(vec2 p, float d) {\n  return height(p, d, 6);\n}\n\nfloat hiheight(vec2 p, float d) {\n  return height(p, d, 8);\n}\n  \nvec3 normal(vec2 p, float d) {\n  vec2 eps = vec2(0.00125, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy, d) - hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx, d) - hiheight(p + eps.yx, d));\n  \n  return normalize(n);\n}\n\nconst float stepLength[] = float[](0.9, 0.25);\n\n\nfloat march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz, d);\n    \n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE) {\n      ++currentStep;\n      if (currentStep >= stepLength.length()) {\n        max_iter = i;\n        return d;\n      }\n      \n      d = lastd;\n      continue;\n    }\n\n    float sl = stepLength[currentStep];\n\n    dt = max(hd, TOLERANCE)*sl + 0.0025*d;\n    lastd = d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 rocketDirection() {\n  return normalize(vec3(0.0, -0.2+mod(iTime, 90.0)*0.0125, 1.0));\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, skyCol2, smoothstep(0.0 , 1.0, 5.0*angle)), skyCol3, smoothstep(0.0, 1.0, -5.0*angle));\n  \n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n  \n  float dustTransparency = smoothstep(-0.075, 0.0, rd.y);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*vec3(0.9, 0.8, 0.7), 0.3*vec3(0.9, 0.8, 0.7), pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  vec3 rocketDir = rocketDirection();\n  float rocketDot = max(dot(rd, rocketDir), 0.0);\n  float rocketDot2 = max(dot(normalize(rd.xz), normalize(rocketDir.xz)), 0.0);\n  vec3 rocketCol = vec3(0.25)*(3.0*smoothstep(-1.0, 1.0, psin(iTime*15.0*TAU))*pow(rocketDot, 70000.0) + smoothstep(-0.25, 0.0, rd.y - rocketDir.y)*step(rd.y, rocketDir.y)*pow(rocketDot2, 1000000.0))*dustTransparency;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n//  float ringsDiff = max(-dot(rings.xyz, sunDir), 0.0);\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*mountainColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*dustTransparency*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  final += skyCol + sunCol + smallSunCol + dust + rocketCol;\n\n  return final;\n}\n\nvec3 getColor(vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  float id = (0.125 - ro.y)/rd.y;\n  \n  if (id > 0.0)   {\n    float d = march(ro, rd, id, max_iter);\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n\n    vec3 normal = normal(p.xz, d);\n    \n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = skyColor(p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;   \n    float fre = max(dot(normal, -rd), 0.0);\n    fre = pow(1.0 - fre, 5.0);\n    col += rcol*fre*0.5;\n    col += (1.0*p.y);\n    col = tanh(col);\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.*MAX_DISTANCE, d));\n  \n  } else {\n    col = skyCol;\n  }\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 getSample1(vec2 p, float time) {\n  float off = 0.5*iTime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.00,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd)  ;\n \n  return col;\n  \n}\n\nvec3 getSample2(vec2 p, float time) {\n  p.y-=time*0.25;\n  float h = height(p, 0.0);\n  vec3 n = normal(p, 0.0);\n  \n  vec3 lp = vec3(10.0, -1.2, 0.0);\n  \n  vec3 ld = normalize(vec3(p.x, h, p.y)- lp);\n  \n  float d = max(dot(ld, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n\n  col = vec3(1.0)*(h+0.1);\n  col += vec3(1.5)*pow(d, 0.75);\n \n  return col;\n  \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = getSample1(p, iTime);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjfDt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[900, 900, 933, 933, 1018], [1020, 1020, 1056, 1056, 1150], [1152, 1152, 1179, 1179, 1248], [1250, 1250, 1281, 1281, 1307], [1309, 1309, 1348, 1348, 1611], [1613, 1613, 1632, 1632, 1755], [1757, 1757, 1799, 1799, 1846], [1848, 1848, 1895, 1895, 2280], [2282, 2282, 2304, 2304, 2506], [2508, 2508, 2530, 2530, 2840], [2843, 2843, 2883, 2883, 3643], [3645, 3645, 3678, 3678, 3706], [3708, 3708, 3739, 3739, 3767], [3769, 3769, 3802, 3802, 3830], [3834, 3834, 3864, 3864, 4082], [4133, 4133, 4192, 4192, 4833], [4835, 4835, 4856, 4856, 4902], [4904, 4904, 4930, 4930, 4976], [4978, 4978, 5002, 5002, 5070], [5072, 5072, 5093, 5093, 5122], [5124, 5124, 5157, 5157, 7836], [7838, 7838, 7871, 7871, 8951], [8953, 8953, 8990, 8990, 9332], [9334, 9334, 9371, 9371, 9677], [9679, 9679, 9731, 9731, 9907]], "test": "untested"}
{"id": "tlKGRc", "name": "Color Weave", "author": "BackwardsCap", "description": "~~~", "tags": ["colors", "sin", "cos"], "likes": 8, "viewed": 331, "published": 3, "date": "1591132948", "time_retrieved": "2024-07-30T21:03:23.765911", "image_code": "float rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(12389.1253,8941.1283)))*12893.128933);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n    \n    vec3 o = vec3(0);\n    \n    uv.x+=iTime;\n    \n    for(float i=-5.,id=0., T=iTime*.075;i<5.;i+=.15,id++)\n    {\n        uv.y *= 1.025;\n        uv.x -= .35*T;\n        float l = abs(uv.y + sin(uv.x+T)/1.-sin(cos(uv.x+T/50.))/2.);\n        o += smoothstep((20.+i*1.)/iResolution.y,0.,l);\n        o *= 1.2 * vec3((0.5+(0.5*rand(vec2(1.,id)))),\n                        (0.5+(0.5*rand(vec2(id+i/2.0,id)))),\n                        (0.5+(0.5*rand(vec2(id-i,10.5)))));\n    }\n    \n    \n    c.rgb = o+pow(o.b,2.0)*.2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 97], [99, 99, 140, 140, 706]], "test": "untested"}
{"id": "WsjBDt", "name": "My 1st Try On Shadertoy", "author": "pnoqable", "description": "based on https://www.shadertoy.com/view/3lV3WD experimeting with some sdf stuff which i learned at iqs website. now comes with pretty expensive 2x2 anti alias as seen at https://www.shadertoy.com/view/Mt3BDj", "tags": ["raymarching", "smoothoperators"], "likes": 7, "viewed": 352, "published": 3, "date": "1591130553", "time_retrieved": "2024-07-30T21:03:24.729335", "image_code": "/// Unknown author...\n\n\n// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_ellipsoid( vec3 pos, vec3 r )\n{\n    float k0 = length( pos / r );\n    float k1 = length( pos / ( r * r ) );\n    return k0 * ( k0 - 1.0 ) / k1;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nfloat dist_torus( vec3 pos, vec2 t ) {\n    vec2 q = vec2( length( pos.xy ) - t.x, pos.z );\n    return length( q ) - t.y;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * ( 1.0 - h );\n}\n\nfloat smoothSubtract( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 + d1 ) / k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) +  k * h * ( 1.0 - h );\n}\n\nfloat smoothIntersect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k * h * ( 1.0 - h );\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n    \n    pos.xy = mod( pos.xy + vec2( 2.5 ), 5. ) - vec2( 2.5 );\n    pos.z += 1.;\n    \n    if( pos.z <= 0.1 )\n        pos.z = mod( pos.z + 1., 5. ) - 1.;\n\t\n    float edge = .5 - .49 * cos( iTime );\n\t\n\tfloat sphere = dist_sphere( pos, 1. );\n    \n    float ellipsoid = dist_ellipsoid( pos, vec3( .5, .5, 1.2 ) );\n\t\n\tfloat box = dist_box( pos, vec3( 2.3, 2.3, 0. ) ) - 0.2 * edge;\n    \n    float torus = dist_torus( pos, vec2( 1.7, 0.3 ) );\n    \n    float result = sphere;\n    result = smoothUnion( box, result, edge );\n    result = smoothSubtract( ellipsoid, result, edge );\n    result = smoothUnion( torus, result, edge );\n\n    return result;\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 3.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.4, 0.3 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.2, 0.1 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0., 0., 0., 1. );\n    \n    int antiAlias = 1;\n    \n    for( int offX = 0; offX < antiAlias; offX++ )\n    for( int offY = 0; offY < antiAlias; offY++ )\n    {\n        vec2 offset = vec2( float( offX ), float( offY ) ) / float( antiAlias ) - 0.5;\n        \n        // default ray dir\n        vec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy + offset );\n\n        // default ray origin\n        vec3 eye = vec3( 0.0, 0.0, 10.0 );\n        \n        // uncomment for lg cinema3d:\n        // eye.x -= 0.1 * ( mod( fragCoord.y, 2. ) - 1. );\n\n        // rotate camera\n        mat3 rot = rotationXY( vec2( 0.1 * iTime ) );\n        dir = rot * dir;\n        eye = rot * eye;\n\n        // ray marching\n        float depth = ray_marching( eye, dir, 0.0, clip_far );\n        \n        // shading\n        if ( depth < clip_far ) {\n            vec3 pos = eye + dir * depth;\n            vec3 n = gradient( pos );\n            fragColor.xyz += shading( pos, n, eye );\n        }\n    }\n    fragColor.xyz /= float( antiAlias * antiAlias );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 269, 309, 309, 338], [340, 340, 382, 382, 495], [497, 497, 536, 536, 587], [589, 589, 627, 627, 711], [713, 713, 763, 763, 878], [880, 880, 933, 933, 1050], [1052, 1052, 1106, 1106, 1221], [1223, 1252, 1282, 1309, 1953], [1955, 1972, 2014, 2040, 2871], [2873, 2902, 2929, 2929, 3263], [3265, 3281, 3350, 3350, 3600], [3602, 3623, 3671, 3671, 3847], [3849, 3881, 3912, 3912, 4068], [4070, 4070, 4127, 4127, 5168]], "test": "untested"}
{"id": "tsBfDd", "name": "3D matrix rain", "author": "jarble", "description": "I was trying to animate a kelp forest when I discovered this \"Matrix rain\" effect by accident.\nClick and drag the mouse to look around.", "tags": ["raymarching", "rain", "matrix"], "likes": 8, "viewed": 745, "published": 3, "date": "1591124456", "time_retrieved": "2024-07-30T21:03:25.696749", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 animate(vec3 p){\n    p *= 20.0;\n    vec3 p1 = p/100.0+vec3(iTime);\n    p += vec3(sin(p1.x),sin(p1.y),sin(p1.z))*20.0;\n    return p;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p = animate(p);\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = vec2(p.x,p.y)/(300.0);\n    p = (sin(p) + sin(p*4.0))/2.0;\n    return sin(vec3(0.0,(p.y+p.x+p.z)*2.0,0.0));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    //p *= 5.0;\n    p = animate(p);\n    return  2.0 + (sin(p.x/2.0)+cos(p.z/(4.0)))*1.1+(p.y*p.y/6.0)/1000.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(0.0, 0.0, 1.0);    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 9000.0);\n    t = t % (12*10*1024);\n    t = (t>>15|t*(-(t/10)%15)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n    \tresult += sound1(time*factor)/(factor);\n        factor *= 1.5;\n    }\n    return result;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 205, 205, 322], [324, 324, 352, 352, 547], [550, 790, 814, 830, 926], [928, 1349, 1440, 1440, 1746], [1761, 2015, 2080, 2080, 2212], [2214, 2303, 2332, 2332, 2642], [2644, 3136, 3276, 3276, 3866], [3868, 4238, 4323, 4323, 5081], [5083, 5410, 5459, 5494, 5625], [5627, 5627, 5684, 5684, 6561]], "test": "untested"}
{"id": "tsSfDd", "name": "Kelp forest", "author": "jarble", "description": "There are many blades of wavy kelp here.\nClick and drag the mouse to look around.", "tags": ["raymarching", "kelp"], "likes": 2, "viewed": 335, "published": 3, "date": "1591122707", "time_retrieved": "2024-07-30T21:03:26.471677", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\n\nvec3 animate(vec3 p){\n    p *= 10.0;\n\tp += vec3(sin(p.y/10.0+iTime*5.0),cos(p.z/10.0),0.0)*10.0;\n    return p;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p = animate(p);\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = vec2(p.x,p.y)/(300.0);\n    p = (sin(p) + sin(p*4.0))/2.0;\n    return sin(vec3(0.2*p.x,(p.y+p.x+p.z)*2.0,p.z*.2));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    //p *= 5.0;\n    p = animate(p)/10.0;\n    p.x += sin(p.z);\n    p += sin(vec3(p.xzy)/3.0)*3.0;\n    return  (2.1 + (sin(p.x/(2.0+sin(p.z/400.0)))+cos(p.z/(4.0)))*1.1+(p.y*p.y/6.0)/1000.0)/2.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    vec3 eye = vec3(0.0, 1.0, -7.0-iTime)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 268, 268, 359], [361, 361, 389, 389, 591], [594, 834, 858, 874, 1054], [1056, 1477, 1568, 1568, 1932], [1947, 2201, 2266, 2266, 2398], [2400, 2489, 2518, 2518, 2828], [2830, 3322, 3462, 3462, 4052], [4054, 4424, 4509, 4509, 5267], [5269, 5596, 5645, 5680, 5811], [5813, 5813, 5870, 5870, 6931]], "test": "untested"}
{"id": "MlVfz3", "name": "Neutron Star", "author": "milolouis", "description": "Dancing kaleidoscope star. NEW AND IMPROVED!", "tags": ["sstar"], "likes": 2, "viewed": 405, "published": 3, "date": "1591121553", "time_retrieved": "2024-07-30T21:03:27.217682", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nfloat circle(vec2 fragCoord, vec2 centreCoord, float radius)\n{\n    return radius / length(fragCoord - centreCoord);\n}\n\nvec3 drawStar(vec2 fragCoord, vec2 centreCoord, float radius)\n{\n    float r = circle(fragCoord, centreCoord, tan(iTime + 1.0) * radius + 100.);\n    float g = circle(fragCoord, centreCoord, tan(iTime + 1.2) * radius + 100.);\n    float b = circle(fragCoord, centreCoord, tan(rand(iTime) + 0.7) * radius + 100.);\n               \n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 centre = iResolution.xy / 2.0;\n    \n    vec3 val = drawStar(fragCoord, centre, 50.0);\n\n    fragColor = vec4(val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 146, 146, 194], [196, 196, 258, 258, 313], [315, 315, 378, 378, 666], [668, 668, 725, 725, 857]], "test": "untested"}
{"id": "wdBfWd", "name": "Infinite Jungle", "author": "jarble", "description": "I used the pattern from my [url=https://www.shadertoy.com/view/3djfWV]jungle planet[/url] shader to make this endless forest.\nClick and drag the mouse to look around.\n\nThere is also a version with camera control: https://www.shadertoy.com/view/tlsyRH", "tags": ["raymarching", "jungle"], "likes": 0, "viewed": 408, "published": 3, "date": "1591113787", "time_retrieved": "2024-07-30T21:03:28.142210", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0));\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    \n    vec3 eye = vec3(sin(iTime/5.0)*2.0, cos(iTime/5.0)*2.0, -iTime)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 5.0625;\n    vec2 result = vec2(0.0);\n    result = sound1(time*factor)/(factor);\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nfloat sceneSDF1(vec3 p) {\n    p /= 40.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  3.9 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    float i = 9.0;\n    for(int k = 0; k < 2; k++){\n        //add bumps to the surface\n    \tresult -= sceneSDF1(p*i)/(i*3.0);\n        i *= 9.0;\n    }\n    return result;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 451], [455, 876, 967, 967, 1322], [1337, 1591, 1656, 1656, 1788], [1790, 1879, 1908, 1908, 2218], [2220, 2712, 2852, 2852, 3442], [3444, 3814, 3899, 3899, 4657], [4659, 4986, 5035, 5070, 5201], [5203, 5203, 5260, 5260, 6357]], "test": "untested"}
{"id": "wsSBWt", "name": "dancing messy circle-goo", "author": "thefox231", "description": "not sure where i was going with this. still looks neat", "tags": ["2d", "goo", "geometry", "liquid", "noisy", "messy"], "likes": 0, "viewed": 332, "published": 3, "date": "1591091660", "time_retrieved": "2024-07-30T21:03:28.985955", "image_code": "#define pi 3.1415\n\nfloat inOutSine(float t) {\n  float b = 0.0;\n  float c = 1.0;\n  float d = 1.0;\n  return (-c / 2.0 * (cos(pi * t / d) - 1.0) + b);\n}\n\nfloat sum(vec2 vec) {return vec.x + vec.y;}\n\nfloat noise(float time, int seed) {\n    float convertRate = mod(time, 1.0);\n    \n    float noise1 = texture(iChannel0, vec2(floor(time) / 900.0 + float(seed), float(seed)))[seed % 3];\n    float noise2 = texture(iChannel0, vec2(ceil(time) / 900.0 + float(seed), float(seed)))[seed % 3];\n    \n    return noise2 * inOutSine(convertRate) + noise1 * (1.0 - inOutSine(convertRate));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float circDistance = length(\n        uv - vec2(\n            (noise(uv.x * 19.0 + iTime * 7.0, 1) * 1.0),\n        \t(noise(uv.x * 19.0 + iTime * 4.0, 1) * 1.5)\n        )) - 0.1;\n    \n    //vec4 col = vec4(vec3(sum(abs(uv - vec2(0.5))) * 0.1 + 0.1), 1.0);\n    vec4 col = texture(iChannel1, uv);  \n    \n    if (circDistance <= 0.4) {\n    \tcol = vec4(noise(iTime + uv.y * 2.0, 66), noise(iTime + uv.x + 90.0, 2), noise(iTime + uv.x + uv.y * 3.0 + 12.0, 12), 1.0);\n    }\n    if (circDistance > 0.4) {\n        col -= 0.1 - (circDistance * 0.1);\n    }\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 45, 45, 149], [151, 151, 172, 172, 194], [196, 196, 231, 231, 574], [576, 576, 633, 633, 1254]], "test": "untested"}
{"id": "3dSfDd", "name": "dust windy inverty effect", "author": "thefox231", "description": "i dunno ", "tags": ["2d", "invert", "dust", "wind"], "likes": 2, "viewed": 375, "published": 3, "date": "1591085654", "time_retrieved": "2024-07-30T21:03:29.764872", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n\n    vec3 newCol = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++) {\n        \n        float modif1 = 1.0 - texture(iChannel1, uv - vec2(iTime)).x;\n        float modif2 = texture(iChannel1, uv + vec2(iTime)).x;\n        \n        float range = mod(iTime + modif1, 2.0) - 0.5;\n        float range2 = mod(iTime + modif2 + 0.5, 2.0) - 0.5;\n    \n    \tfloat origColor = col[i];\n        \n        newCol[i] = min(abs(origColor - range), abs(origColor - range2));\n    }\n    \n    fragColor = vec4(newCol, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 642]], "test": "untested"}
{"id": "3sBBDd", "name": "WebCam Long Exposure", "author": "Zi7ar21", "description": "Originally based on https://shadertoy.com/view/Xslfzj by user rohtie, but I modified it now to work better.", "tags": ["fork", "webcam", "lowlight", "lowlight", "noisereduction", "webcamghosting", "longexposure", "webcamlongexposure", "webcamaveraging"], "likes": 6, "viewed": 1131, "published": 3, "date": "1591083871", "time_retrieved": "2024-07-30T21:03:30.510877", "image_code": "// ^^^ Change to Buffer A for settings or B for export up here ^^^\n\n// Fork of \"Extremely Long Exposure\" by rohtie. https://shadertoy.com/view/Xslfzj\n// 2020-06-02 07:38:44\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// These two numbers change the output.\n// Calibration coming soon.\n// For now, take your main exposure and then take one with the camera in a dark spot with no light or just cover it.\n// Then, use a third-party program like GIMP (https://www.gimp.org/downloads/) to subract the light from the dark.\nbool isKeyPressed(int KEY){\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv)+(texture(iChannel1, uv)/8192.0);\n    vec4 oldFragColor = vec4(0.);\n    fragColor += oldFragColor;\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(isKeyPressed(32)){\n        fragColor.rgba = vec4(0.0);\n    }\n    if(iMouse.z >= 128.0){\n        fragColor.rgba = vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Settings in Buffer A and Export in Buffer B\n// Export this with the button in the bottom left of the editor, it will save a 32-Bit OpenEXR File (I think)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n\tfragColor = vec4(color, 1);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 229, 229, 308]], "test": "untested"}
{"id": "WsSfDt", "name": "Sea of Eels", "author": "jarble", "description": "It's a sea of colorful swimming creatures.\nClick and drag the mouse to look around.", "tags": ["raymarching", "fish", "swimming", "eels"], "likes": 2, "viewed": 359, "published": 3, "date": "1591059295", "time_retrieved": "2024-07-30T21:03:31.462333", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 animate(vec3 p){\n    vec3 p1 = p/100.0+vec3(iTime/5.0);\n    p += vec3(sin(p1.y)+cos(p1.z),sin(p1.z)+cos(p1.x),sin(p1.x)+cos(p1.y))*100.0;\n    return p;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p = animate(p*2.0);\n    vec3 col;\n    col = p.xyz*sin(p.x+p.y+p.z);\n    \n    // Output to screen\n    return vec3(col.y,col.z,p.x)/500.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p *= 2.0;\n    p = animate(p)/10.0;\n    return  3.9 +sin(length(p*5.0)/2.0) + (sin(p.x+p.y+p.z)+cos(p.y)+cos(p.z))*1.1;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    vec3 eye = vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*50.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 270, 270, 407], [409, 409, 437, 437, 580], [582, 822, 846, 846, 971], [973, 1394, 1485, 1485, 1797], [1812, 2066, 2131, 2131, 2263], [2265, 2354, 2383, 2383, 2693], [2695, 3187, 3327, 3327, 3917], [3919, 4289, 4374, 4374, 5132], [5134, 5461, 5510, 5545, 5676], [5678, 5678, 5735, 5735, 6814]], "test": "untested"}
{"id": "WdSfDt", "name": "Swirling fireball", "author": "jarble", "description": "It's a ball of fire!", "tags": ["raymarching", "fire", "lava", "fireball"], "likes": 2, "viewed": 499, "published": 3, "date": "1591059172", "time_retrieved": "2024-07-30T21:03:32.286131", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p)\n{\n    //p = animate(p*2.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 1.0;\n    vec2 col = (uv.xy*scale*(sin(uv.x+time1)));\n    vec2 col2;\n    for(float i = 1.0; i < 3.0; i++){\n        uv += ceil(col+sin((col.x+col.y+iTime*10.0)));\n        col -= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(0.5+uv.y,col2.x,0.5+uv.x/200.0);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    return length(p/4.0)-1.0+sin((p.x+p.y+p.z)/10.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/5.0), 10.0*sin(iTime/5.0), 10.0*cos(iTime/5.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 205, 281, 689], [692, 932, 956, 956, 1016], [1018, 1439, 1530, 1530, 1836], [1851, 2105, 2170, 2170, 2302], [2304, 2393, 2422, 2422, 2732], [2734, 3226, 3366, 3366, 3956], [3958, 4328, 4413, 4413, 5171], [5173, 5500, 5549, 5584, 5715], [5717, 5717, 5774, 5774, 6691]], "test": "untested"}
{"id": "WsBfWt", "name": "Crystal Tetrahedron", "author": "tdhooper", "description": "Mouse enabled", "tags": ["refraction", "dispersion", "bluenoise", "polyhedra"], "likes": 90, "viewed": 1750, "published": 3, "date": "1591051302", "time_retrieved": "2024-07-30T21:03:33.398158", "image_code": "/*\n\n    Crystal Tetrahedron\n    -------------------\n\n    Brute force dispersion with a fractal zoom.\n\n    The colours come from performing the whole render multiple times,\n    each with a different refractive index and colour tint, then\n    combining the results. With so few iterations this usually results\n    in a lot of banding, but the addition of some animated blue noise\n    gives an acceptable result with just 2 samples.\n\n    If it's running slow, drop MAX_DISPERSE in Buffer A to 2.\n\tIt looks really pretty with 30 bounces and 10 dispersion samples.\n\n\tGetting good camera and lighting angles was tricky, so there are a\n\tbunch of hardcoded matrices and rotations from my tool. \n\n\tCheck out the high quality capture on my Instagram\n\t* https://www.instagram.com/p/CA09i10HgDN/\n\n\tInspired by a couple of things:\n\t* The shading in this GIF by Tatsuya M https://twitter.com/TatsuyaBot/status/1208415211360665607\n\t* This animation by ayquo https://www.shadertoy.com/view/3d2BRW\n\n*/\n\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = 1.; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 10.;\nconst float RAD_SCALE = 1.; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #ifdef DISABLE_DOF\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; ang < 10000.; ang += GOLDEN_ANGLE) {\n        if (radius >= MAX_BLUR_SIZE) break;\n\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n       // if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    //fragColor = vec4(texture2D(iChannel0, uv).aaa, 1.); return;\n    \n    vec3 col = depthOfField(uv, .65, 1.);\n\n    col = pow(col, vec3(1.25)) * 2.5;\n    col = tonemap2(col);\n\n    fragColor = vec4(col, 1);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//#define DARK_MODE\n\nconst float MAX_DISPERSE = 5.;\nconst float MAX_BOUNCE = 10.;\n\nmat4 cameraMatrix = mat4(\n    0.9780874848365784,\n    -0.07870610803365707,\n    -0.19274398684501648,\n    0,\n    0.20812205970287323,\n    0.3452317416667938,\n    0.9151507019996643,\n    0,\n    -0.005486522801220417,\n    -0.935211718082428,\n    0.35404732823371887,\n    0,\n    -4.901630745735019e-7,\n    0.00000874467059475137,\n    -9.502106666564941,\n    1\n);\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n//--------------------------------------------------------\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nmat4 rotX(float a) {\n    return mat4(1,0,0,0, 0,cos(a),-sin(a),0, 0,sin(a),cos(a),0, 0,0,0,1);\n}\n\nmat4 rotZ(float a) {\n    return mat4(cos(a),-sin(a),0,0, sin(a),cos(a),0,0, 0,0,1,0, 0,0,0,1);\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n//--------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// Polyhedra\n// Knighty https://www.shadertoy.com/view/MsKGzw\n//--------------------------------------------------------\n\nint Type=3;\n\nvec3 nc,pab,pbc,pca;\nvoid initPoly() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<3 /*Type*/;i++){\n\t\tpos.xy=abs(pos.xy);//fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;//fold about nc plane\n\t}\n\treturn pos;\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nfloat time;\n\nfloat tweenOffset(float t, float start, float duration) {\n    t = range(start, start + duration, t);\n    t = pow(t, 2.);\n    return t;\n}\n\nfloat tweenBlend(float t, float start, float duration) {\n    t = range(start, start + duration, t);\n    t = pow(t, .5);\n    t = smoothstep(0., 1., t);\n    return t;\n}\n\nconst float STEP_SCALE = 1./3.;\n\nfloat tetAnim(vec3 p, float time) {\n    \n    p = fold(p);\n\n    // config\n    float sz = .3;\n    float rBase = .04;\n    float rInner = rBase * STEP_SCALE;\n    float blendDuration = .75;\n    float offsetDuration = .75;\n    float t = time * (blendDuration + offsetDuration);\n    offsetDuration *= 2.; // extend animation beyond loop section\n    float offsetDistance = .6;\n\n    // animation\n    float blend = tweenBlend(t, .0, blendDuration);\n    float offsetT = tweenOffset(t, blendDuration, offsetDuration);\n    float offset = offsetT * offsetDistance;\n\n    // skip if animation hasn't started or is complete\n    if (t < 0. || offsetT >= 1.) {\n        return 1e12;\n    }\n\n    // tetrahedron planes\n    vec3 n1 = pca;\n    vec3 n2 = normalize(pca * vec3(-1,-1,1));\n    vec3 n3 = normalize(pbc * vec3(1,-1,-1));\n    vec3 n4 = normalize(pbc * vec3(-1,-1,-1));\n\n    float sep = .001 * (1. - offsetT);\n    float scale = 1. - offsetT;\n    \n    float bound = (dot((p + (n4 + n3) * offset) / scale, n1) - sz) * scale;\n    if (bound > .004) {\n        return bound;\n    }\n\n    vec3 pp = p;\n    \n    // octahedrons\n    p = pp + n4 * offset;\n    p /= scale;\n    float oct = dot(p, n1) - sz;\n    oct = smax(oct, (dot(p, n2) - sz), rBase);\n    oct = smax(oct, -(dot(p, n4) + .5 - sep), rInner);\n    oct = smax(oct, -(dot(p, n3) + .1 - sep), rInner);\n    oct = smax(oct, (dot(p, n4) + .1 + sep), rInner);\n    oct *= scale;\n\n    // shared edge\n\tp = pp + (n4 + n3) * offset;\n    p /= scale;\n    float edge = dot(p, n1) - sz;\n    edge = smax(edge, (dot(p, n2) - sz), rBase);    \n    \n    // side tets\n    p = pp + (n4 + n3) * offset;\n    p /= scale;\n    float side = edge;\n    side = smax(side, (dot(p, n3) + .1 + sep), rInner);\n    side = smax(side, (dot(p, n4) + .1 + sep), rInner);\n    side *= scale;\n\n    // vertex tets\n    p = pp + n4 * (offset + offset);\n    p /= scale;\n    float vert = edge; vert = smax(vert, (dot(p, n3) - sz), rBase);\n    vert = smax(vert, (dot(p, n4) + .5 + sep), rInner);\n    vert *= scale;\n\n    float sliced = 1e12;\n    sliced = min(sliced, oct);\n    sliced = min(sliced, vert);\n    sliced = min(sliced, side);\n\n    // inner tet gets replaced with the next iteration\n    if (time < 1.) {\n        p = pp;\n        float inner = -(dot(p, n4) + .1 - sep);\n        inner = smax(inner, -(dot(p, n3) + .1 - sep), rInner);\n        inner = smax(inner, -(dot(p, n2) + .1 - sep), rInner);\n        sliced = min(sliced, inner);\n    }\n\n    if (blend >= 1.) {\n        return sliced;\n    }\n\n    // base tet\n    float base = dot(p, n1) - sz;\n    base = smax(base, (dot(p, n2) - sz), rBase);\n    base = smax(base, (dot(p, n3) - sz), rBase);\n\n    float surface = 1. - saturate(-base / sz); // 1 at surface, 0 at center\n    \n    // blend indentations into the surface\n    float surfaceBlend = saturate(blend * .66 * range(.9, 1., surface));\n    base = mix(base, sliced, surfaceBlend);\n    \n    // grow the sliced tet from the center of the unsliced tet\n    float slicedS = min(sliced, -base - (.3 - .3 * blend));\n    float d = max(base, slicedS);\n    d = mix(d, sliced, smoothstep(.9, 1., blend));\n\n    return d;\n}\n\nfloat tetLoop(vec3 p) {\n    pR(p.xy, PI/2. * -time + PI/2.);\n\n    float t = time;\n    float scale = pow(STEP_SCALE, t);\n    float d = tetAnim(p * scale, time) / scale;\n\n    scale *= STEP_SCALE;\n    pR(p.xy, PI/2. * -1.);\n    d = min(d, tetAnim(p * scale, time + 1.) / scale);\n\n    return d;\n}\n\nvec2 map(vec3 p) {\n    float d = tetLoop(p);\n    return vec2(d, 1.);\n}\n\n\n//========================================================\n// Lighting\n//========================================================\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -(cameraMatrix * vec4(origin, 1)).xyz;\n    rayDir = -(cameraMatrix * vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    float hit = intersectPlane(origin, rayDir, vec3(5,-2,-8), normalize(vec3(1,-.5,-.1)), normalize(vec3(0,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.4,1.2) * 6.));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(cameraMatrix * vec4(origin, 1)).xyz;\n    rayDir = -(cameraMatrix * vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * vec3(1,1,1);\n}\n\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n\n    for (float i = 0.; i < 100.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x * invert;\n        steps += 1.;\n        if (dist < .001) {\n            res = candidate;\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initPoly();\n\n    time = iTime / 2.;\n    //time = 0.5;\n    //time = 0.1;\n    //time = 1.;\n    time = fract(time + .4);\n    \n    #ifndef DARK_MODE\n        envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n    #else\n        envOrientation = sphericalMatrix((vec2(0.7299465240641712,0.3048128342245989) * 2. - 1.) * 2.);\n    #endif\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n    float focal = 3.8;\n    bool refracted;\n\n    vec3 bgCol = vec3(.22);\n\n    invert = 1.;\n    maxDist = 15.; \n    \n    if (iMouse.z > 0.) {\n        cameraMatrix *= rotX(((iMouse.y / iResolution.y) * 2. - 1.) * 2.);\n\t    cameraMatrix *= rotZ(((iMouse.x / iResolution.x) * 2. - 1.) * 2.);\n    }    \n\n\tcamOrigin = -(cameraMatrix[3].xyz) * mat3(cameraMatrix);\n   \tcamDir = normalize(vec3(uv * .168, -1.) * mat3(cameraMatrix));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist, .9);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n   \t\tfloat rand = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy).r;\n        rand = fract(rand + float(iFrame) * 1.61803398875);\n\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, maxDist / 2., 1.);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n\n            vec3 nor = normal(p) * invert;            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(1. - abs(dot(rayDir, nor)), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n            // refract\n            float ior = mix(1.3, 1.6, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n        }\n\n        #ifndef DARK_MODE\n            sam += bounceCount == 0. ? bgCol : env(p, rayDir);\t\n        #endif\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE / 2.;\n            break;\n        } else {\n            vec3 extinction = vec3(.3,.3,1.) * .5;\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            col += sam * extinction * spectrum(-wavelength+.2);\n        }\n\t}\n    \n    // debug\n \t//fragColor = vec4(spectrum(steps / 2000.), 1); return;\n    //fragColor = vec4(vec3(bounceCount / MAX_BOUNCE), 1); return;\n    //fragColor = vec4(vec3(firstHit.steps / 100.), 1); return;\n\n    col /= MAX_DISPERSE;\n        \n    fragColor = vec4(col, range(4., 12., firstLen));\n}\n", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1312, 1312, 1380, 1380, 1498], [1500, 1500, 1570, 1570, 2769], [2772, 2834, 2864, 2864, 3031], [3033, 3033, 3088, 3088, 3412]], "test": "untested"}
{"id": "WdBfWt", "name": "Schreck Ripples", "author": "JackSolace", "description": "height map of the fundamental S-P approximation for deep-water ripples.", "tags": ["wave", "simulation", "animation", "ripple", "solution"], "likes": 2, "viewed": 501, "published": 3, "date": "1591050050", "time_retrieved": "2024-07-30T21:03:34.751539", "image_code": "//By Carter Slocum based on Schreck et al SIGGRAPH 2019\n\n//Note that most any change to these values requires the values of k0 and k1 to be recomputed\n\n\n#define PI 3.14159265359 \n//density\n#define rho 1000.0 \n#define tau_star 0.074\n//gravity\n#define GRAV 9.8\n//initial ripple size\n#define R_star 0.002\n//viscosity\n#define V_star 0.000001\n\n//range of wave number values. no real solution to V exists less than K_MID\n#define K_MIN 0.0000024999\n#define K_MAX 2354.35442935\n#define K_MID 0.2863\n\n//Corresponding V for K_MIN K_MAX\n#define V_MIN 1.27326851\n#define V_MAX 100.0\n\n\n#define SAMPLES 2048.0\n\nfloat tau = tau_star / (rho * GRAV * R_star *R_star);\n\n\n//this function is only necessary if you plan to use newtons method instead of precomputing ks\nfloat V(float k)\n{\n    float tau = tau_star / (rho * GRAV * R_star *R_star);\n    return (1.0 + 3.0*tau*k*k) / (2.0 * sqrt(k*(1.0 + tau * k*k)));\n}\n\n\nfloat dV(float k)\n{\n    float ksq = k*k;\n    float tmp = tau*ksq*k + k;\n    return (3.0*tau*ksq*(tau*ksq + 2.0) - 1.0) / (4.0 * sqrt(tmp*tmp*tmp));\n}\n\n//look up pre-computed ks\nvec2 WaveNumbers(float target)\n{\n   float tg = (target - V_MIN)/(V_MAX - V_MIN)*SAMPLES;\n   int ind = int(tg);\n   vec4 samp0 = texelFetch(iChannel0,ivec2(ind % int(iChannelResolution[0]),ind/int(iChannelResolution[0])),0);\n   ind += 1;\n   vec4 samp1 = texelFetch(iChannel0,ivec2(ind % int(iChannelResolution[0]),ind/int(iChannelResolution[0])),0);\n   float frac = mod(tg, 1.0);\n   return vec2(mix(samp0.x,samp1.x,frac),mix(samp0.y,samp1.y,frac));\n}\n\n//given wave number get angular frequency\nfloat omega(float k)\n{\n    return sqrt(k*(1.0 + tau*k*k));\n}\n\nfloat gamma_star(float k)\n{\n    float k_star = k/R_star;\n    float omega_star = omega(k)*sqrt(GRAV/R_star);\n    return 0.5*sqrt((omega_star*V_star)/(2.0))*k_star + 2.0*V_star*k_star*k_star;\n}\n//wave damping (sensitive)\nfloat Damping(float k, float t_star) \n{\n   return exp(-gamma_star(k)*t_star);\n}\n\nfloat A(float k, float t_star)\n{\n   return (omega(k)*Damping(k,t_star)*sqrt(k))/sqrt(abs(dV(k)));\n}\n//calculate wave hight at this radius and wave time\nfloat height(float r_star, float t_star)\n{\n    float r = r_star/R_star;\n    float t = t_star * sqrt(GRAV/R_star);\n    if ((r/t) < V_MIN || (r/t) > V_MAX)\n    {\n        return 0.0;\n    }\n    float vamp = (3.0*(10.0/sqrt(GRAV*R_star)))/(128.0*sqrt(r*t));\n    vec2 ks = WaveNumbers(r/t);\n    float k0 = ks[0];\n    float k1 = ks[1];\n    float wave0 = A(k0,t_star)*sin(omega(k0)*t - k0*r); \n    float wave1 = A(k1,t_star)*cos(omega(k1)*t - k1*r);\n\n    return vamp*(wave0 + wave1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float r_star = length(vec2(0.5,0.3)-(fragCoord.xy/float(iResolution.xy)))*4.0;\n    float t_star = mod(iTime,5.0);//t_effective (wave time)\n\tfloat wave_height = height(r_star,t_star);\n    fragColor = vec4(1000.0*wave_height,0.0,0.0,1.0);//store height in r channel\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[653, 748, 766, 766, 894], [897, 897, 916, 916, 1046], [1048, 1074, 1106, 1106, 1522], [1524, 1566, 1588, 1588, 1626], [1628, 1628, 1655, 1655, 1819], [1820, 1847, 1886, 1886, 1926], [1928, 1928, 1960, 1960, 2027], [2028, 2080, 2122, 2122, 2557], [2559, 2559, 2616, 2616, 2887]], "test": "untested"}
{"id": "WsByDK", "name": "Log Tunnel", "author": "BackwardsCap", "description": "Playing with log", "tags": ["log", "repeating"], "likes": 4, "viewed": 296, "published": 3, "date": "1591048477", "time_retrieved": "2024-07-30T21:03:35.689032", "image_code": "void mainImage( out vec4 c, in vec2 f )\n{\n    vec2  p = (2.*f-iResolution.xy)/iResolution.y;\n    \t  p = vec2(log(length(p.xy)),atan(p.x,p.y)+iTime/3.0)*4.0;\n    \n    float b = sin(p.x*(cos(iTime/2.)+2.0)*2.+p.y)+sin(p.y);\n    \n    c.rgb   = length(b)*vec3(f.x*p.x*.1, f.y*p.x*.5, f.y*(1.+sin(p.x)/1.4)/2.5)*.00125;\n    c.rgb  += pow(c.b,2.75);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 345]], "test": "untested"}
{"id": "ws2fDc", "name": "Volumetric Fluid", "author": "wyatt", "description": "Full screen! I wish more people know how fast and easy fluid solving is... I've shown people in the field and they just reject the idea even though its running right before their eyes. I guess its very difficult for people to unlearn what they were taught", "tags": ["3d", "fluid"], "likes": 52, "viewed": 1316, "published": 3, "date": "1591042408", "time_retrieved": "2024-07-30T21:03:36.435038", "image_code": "Sampler\nMain\n{\n    vec3 mi = 0.5*vec3(R/N,N*N);\n    vec3 p = vec3(0,0,-R.y/N);\n    vec3 d = normalize(vec3((u-0.5*R)/R.y,1));\n    if (iMouse.z>0.) {\n \t\tp.zx *= e(6.2*iMouse.x/R.x);\n\t\td.zx *= e(6.2*iMouse.x/R.x);\n        p.yz *= e(6.2*iMouse.y/R.y);\n\t\td.yz *= e(6.2*iMouse.y/R.y);\n    } else {\n\t\tp.xz *= e(.2*iTime);\n\t\td.xz *= e(.2*iTime);\n        \n\t\tp.yz *= e(.05*iTime);\n\t\td.yz *= e(.05*iTime);\n\t}\n    Q = vec4(0);\n    for (int i = 0; i < 100; i++) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m<.01)\n        { \t\n            vec4 a = 25.*T(p+mi);\n            float aa = length(a);\n            Q += 6e-3*(1.-exp(-aa))*abs(a);\n            p += d*(.1+exp(-.1*aa*aa));\n           //p = mod(p+mi,R3D)-mi;\n        } else p += d*m;\n        \n \t}\n\tQ = atan(Q)*.8;\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 10.\n#define R iResolution.xy\n#define R3D vec3(R/N,N*N)\n#define d2(U) ((U).xy+vec2(mod(floor((U).z),N),floor(floor((U).z)/N))*R/N)\n#define d3(u) vec3(mod(u,R/N),floor(u/R*N).x+floor(u/R*N).y*N)\n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define A(U) texture(iChannel0, d2(mod(U,R3D))/R)\n#define B(U) texture(iChannel1,d2(mod(U,R3D))/R)\n#define Sampler vec4 T(vec3 U) {return mix(texture(iChannel0,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel0,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define Sampler1 vec4 T1(vec3 U) {return mix(texture(iChannel1,d2(vec3(U.xy,floor(U.z)))/R),texture(iChannel1,d2(vec3(U.xy, ceil(U.z)))/R),fract(U.z));}\n#define Main void mainImage( out vec4 Q, in vec2 u )\n#define _3D  vec3 U = d3(u)\n#define Neighborhood vec4 n = A(U+vec3(0,1,0)), e = A(U+vec3(1,0,0)), f = A(U+vec3(0,0,1)), s = A(U-vec3(0,1,0)), w = A(U-vec3(1,0,0)), b = A(U-vec3(0,0,1));\n#define Init  if (iFrame < 1) ", "buffer_a_code": "Sampler\nvoid F (vec3 U, vec3 u, vec4 Q, inout vec3 f, inout float m, inout float w, inout float n) {\n    // Advect\n    vec4 a = T(U+u-A(U+u).xyz);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xyz);\n    // number of neighbors sampled\n    n++;\n}\nMain {\n\t_3D;\n    \n    Q = T(U-A(U).xyz);\n    vec3 f = vec3(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n    \n    \n    F(U,vec3(1,0,0),Q,f,m,w,n);\n    F(U,vec3(0,1,0),Q,f,m,w,n);\n    F(U,vec3(0,0,1),Q,f,m,w,n);\n    F(U,vec3(-1,0,0),Q,f,m,w,n);\n    F(U,vec3(0,-1,0),Q,f,m,w,n);\n    F(U,vec3(0,0,-1),Q,f,m,w,n);\n    \n    \n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xyz -= f;\n    \n    \n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Sampler\nvoid F (vec3 U, vec3 u, vec4 Q, inout vec3 f, inout float m, inout float w, inout float n) {\n    // Advect\n    vec4 a = T(U+u-A(U+u).xyz);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xyz);\n    // number of neighbors sampled\n    n++;\n}\nMain {\n\t_3D;\n    \n    Q = T(U-A(U).xyz);\n    vec3 f = vec3(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n    \n    \n    F(U,vec3(1,0,0),Q,f,m,w,n);\n    F(U,vec3(0,1,0),Q,f,m,w,n);\n    F(U,vec3(0,0,1),Q,f,m,w,n);\n    F(U,vec3(-1,0,0),Q,f,m,w,n);\n    F(U,vec3(0,-1,0),Q,f,m,w,n);\n    F(U,vec3(0,0,-1),Q,f,m,w,n);\n    \n    \n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xyz -= f;\n    \n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Sampler\nvoid F (vec3 U, vec3 u, vec4 Q, inout vec3 f, inout float m, inout float w, inout float n) {\n    // Advect\n    vec4 a = T(U+u-A(U+u).xyz);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xyz);\n    // number of neighbors sampled\n    n++;\n}\nMain {\n\t_3D;\n    \n    Q = T(U-A(U).xyz);\n    vec3 f = vec3(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n    \n    \n    F(U,vec3(1,0,0),Q,f,m,w,n);\n    F(U,vec3(0,1,0),Q,f,m,w,n);\n    F(U,vec3(0,0,1),Q,f,m,w,n);\n    F(U,vec3(-1,0,0),Q,f,m,w,n);\n    F(U,vec3(0,-1,0),Q,f,m,w,n);\n    F(U,vec3(0,0,-1),Q,f,m,w,n);\n    \n    \n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xyz -= f;\n    \n    if (length(U-vec3(0.5,.5,0.9)*R3D) < 5. ) {\n\t\t    \tQ.xyz = vec3(0,0,-.2)*(0.5+0.8*sin(.5*iTime));\n\t\t    }\n     if (length(U-vec3(0.51,.9,.5)*R3D) < 4. ) {\n\t\t    \tQ.xyz = vec3(0,-.4,0)*(0.5+0.8*sin(.2*iTime));\n\t\t    }\n    if (length(U-vec3(0.5,.1,.5)*R3D) < 4. ) {\n\t\t    \tQ.xyz = vec3(0,.4,0)*(0.5+0.8*sin(.4*iTime));\n\t\t    }\n    if (U.x<1.||U.y<1.||U.z<1.||R3D.x-U.x<1.||R3D.y-U.y<1.||R3D.z-U.z<2.) Q.xyz *= 0.;\n    \n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Sampler\nSampler1\nMain {\n\t_3D;\n    U -= T1(U).xyz;\n    U -= T1(U).xyz;\n    U -= T1(U).xyz;\n    Q = T(U);\n    if (length(U-vec3(0.5,.5,0.9)*R3D) < 3.) {\n\n        Q = 0.5+0.5*sin(.1*iTime*vec4(1,2,3,4));\n    }\n    if (length(U-vec3(0.51,.1,.5)*R3D) < 3. ) {\n    \tQ = 0.5+0.5*sin(.1*iTime+vec4(4,3,2,1));\n    }\n    if (length(U-vec3(0.5,.9,.5)*R3D) < 3. ) {\n    \tQ = 0.5+0.5*sin(.1*iTime-vec4(4,3,2,1));\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2fDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 791]], "test": "untested"}
{"id": "wsjfDc", "name": "Antifascism flag", "author": "Danguafer", "description": "Antifascism flag", "tags": ["flag", "antifa"], "likes": 13, "viewed": 510, "published": 3, "date": "1591041806", "time_retrieved": "2024-07-30T21:03:37.217944", "image_code": "#define EPS (2.0/iResolution.y)\n\n#define SYMBOL_START 0.975\n#define SPACE 0.02\n#define TEXT_START SYMBOL_START - SPACE*2.0\n#define TEXT_SPACE 0.25\n#define INNER_START TEXT_START - TEXT_SPACE - SPACE\n\n#define add(color,df) col = mix(col,color,smoothstep(EPS,-EPS,df));\n#define diff(a,b) max(a,-b)\n#define union(a,b) min(a,b)\n#define inter(a,b) -min(-(a),-(b))\n\nfloat circle(vec2 o, float r) { return length(o) - r; }\nfloat circum(vec2 o, float r, float width) { return diff(circle(o,r),circle(o,r-width)); }\nfloat rect(vec2 o, vec2 d) { return inter(abs(o.x)-d.x,abs(o.y)-d.y); }\n\nfloat flag(vec2 op,vec2 d) {\n    vec2 p = op - d;\n    float stick = rect(p - vec2(0.0,-0.4),vec2(0.04,0.5));\n    vec2 displacement = vec2(-0.56,0.225 + p.x * 0.1 * cos(-iTime * 2.0 - op.x * 8.0 + 1.0));\n    float flag = rect(p - displacement,vec2(0.6,0.3));\n    return min(stick,flag);\n}\n\nmat2 rotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n#define LINES 16.0\n#define COLUMNS 16.0\n#define MAP(C,L) vec2(-float(C)/COLUMNS,float(L)/LINES)\n  #define H MAP(8,4)\n  #define A MAP(1,4)\n  #define C MAP(3,4)\n  #define K MAP(11,4)\n  #define E MAP(5,4)\n  #define R MAP(2,5)\n  #define S MAP(3,5)\n\n//#define A\n  #define N MAP(14,4)\n  #define T MAP(4,5)\n  #define I MAP(9,4)\n  #define F MAP(6,4)\n//#define A\n//#define S\n//#define C\n//#define I\n//#define S\n//#define T\n//#define A\n//#define S\n\nfloat ch(vec2 p, vec2 offset) {\n    float mx = 0.0;\n    float my = (LINES-1.0)/LINES;\n    float Mx = 1.0/LINES;\n    float My = 1.0;\n    vec2 uv = clamp(p,vec2(mx,my),vec2(Mx,My)) - offset;\n    return texture(iChannel0,uv).x;\n}\n\nfloat char_mask(vec2 o) {\n    return abs(o.x)-0.1;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define advance() caret += vec2(0.03,0.0);\n#define type(C) text += vec3(ch(text_mapping - caret,C)); advance();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 n = fragCoord.xy/iResolution.xy;\n    vec2 dp = floor(n*10.0)/10.0;\n    \n    if (mod(iTime,3.0) > 2.0)\n      n = mod(n,0.1) + dp - rand(dp + floor(iTime*20.0)/20.0) + 0.5;\n    if (mod(iTime,4.0) > 3.0)\n      n.x -= sin(20.0 * rand(floor(n.yy * 100.0) - floor(iTime* 10.0)/10.0));\n    \n    vec2 p = (2.0 * n - 1.0);\n    p.x *= iResolution.x/iResolution.y; \n    vec3 col = vec3(1.0);\n\n    float border = circum(p,SYMBOL_START,SPACE);\n    border = union(border,circum(p,TEXT_START,TEXT_SPACE));\n    \n    col = add(vec3(0.0,0.0,0.0),border);\n    \n    float flag_mask = circle(p,INNER_START);\n    vec2 flag_p = p - vec2(0.36,-0.15);\n    flag_p *= rotate(-0.3);\n    float red_flag = inter(flag(flag_p,vec2(0.0,0.0)),flag_mask);\n    float black_flag = inter(flag(flag_p,vec2(-0.25,-0.25)),flag_mask);\n    black_flag = diff(black_flag,red_flag+SPACE);\n    col = add(vec3(0.0),black_flag);\n    col = add(vec3(1.0,0.0,0.0),red_flag);\n    \n    vec2 text_mapping;\n    text_mapping.x = (atan(p.x,p.y)/acos(-1.0)*0.6)+0.11;\n    text_mapping.y = (length(p) + 4.035)*0.2;\n\n    vec2 caret = vec2(0.0,0.0);\n    vec3 text = vec3(0.0);\n    type(H);\n    type(A);\n    type(C);\n    type(K);\n    type(E);\n    type(R);\n    type(S);\n    caret = vec2(0.0,0.0);\n    text_mapping.x = (-atan(-p.x,-p.y)/acos(-1.0)*0.6)+0.2;\n    text_mapping.y = (5.655 - length(p))*0.2;\n    type(A);\n    type(N);\n    type(T);\n    type(I);\n    type(F);\n    type(A);\n    type(S);\n    type(C);\n    type(I);\n    type(S);\n    type(T);\n    type(A);\n    type(S);\n\n    // Masking for removing polar coordinates artifacts on the font atlas sampling.\n    text *= step(INNER_START,length(p));\n    \n    col += text;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 391, 391, 415], [416, 416, 460, 460, 506], [507, 507, 535, 535, 578], [580, 580, 608, 608, 867], [869, 869, 891, 891, 936], [1377, 1377, 1408, 1408, 1603], [1605, 1605, 1630, 1630, 1657], [1659, 1659, 1679, 1679, 1751], [1866, 1866, 1923, 1923, 3630]], "test": "untested"}
{"id": "tdjfWc", "name": "Day 165 - Not good rasterizer", "author": "jeyko", "description": "potato", "tags": ["rasterizer", "mdmtjvm"], "likes": 8, "viewed": 398, "published": 3, "date": "1591040406", "time_retrieved": "2024-07-30T21:03:38.345928", "image_code": "// Used Inigo Quilez's rasterizer as a reference - https://www.shadertoy.com/view/4slGzn\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n#define SZ 40 \n\nvec3[SZ*3] vertices;\n\nvec3[SZ] cols;\n\nvec3 r31(float i){\n\treturn texture(iChannel0,vec2(floor(i/256.),mod(i,256.))).xyz;\n}\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float z = 10000.;\n    \n    vec3 col = vec3(0);\n\n    \n    uv *= 3.;\n    \n    // generate vertices and colours\n    for(float i = 0.; i < float(SZ*3+min(iFrame,0)); i++){\n        vec3 vertice;\n        \n        float mult = 4.8;\n        vertice.xy = vec2(cos(i*mult),sin(i*mult))*2.;\n        \n        vertice.xy *= 1.;\n        \n        \n        float kick = floor(iTime+5.) + pow(fract(iTime+5.),8.);\n        vertice.z = cos(mix(i*3.14*2.,i,abs(sin(kick/3.14/200.))))*4.4;\n        \n        vertice.xz *= rot(sin(iTime)/3.);\n        vertice.yx *= rot(cos(iTime)/3.);\n        \n        \n        vertice.z += 5.6 ; // camera offs\n        \n        //vertice.z = 1.;\n        cols[int(i)/3] = 0.5+sin(floor(i)  + uv.x/6. +iTime + sin(uv.y/3.)/1.+ vec3(1.,0.5,0.2))/2.;\n        \n    \tvertices[int(i)] = vertice;\n    }\n    \n    \n    // draw triangles\n    for(int i = 0; i < SZ+min(iFrame,0); i++){\n        vec3 va = vertices[i*3+0];\n        vec3 vb = vertices[i*3+1];\n        vec3 vc = vertices[i*3+2];\n  \t\t\n        vec3 tricol = cols[i];\n        \n        float zoffs = 0.;\n        \n        va.z -= zoffs;\n        vb.z -= zoffs;\n        vc.z -= zoffs;\n        \n        vec2 a = va.xy/va.z;\n        vec2 b = vb.xy/vb.z;\n        vec2 c = vc.xy/vc.z;\n  \t\n        vec3 cr = vec3(\n        \tcross2d(uv-a,b-a),\n            cross2d(uv-b,c-b),\n        \tcross2d(uv-c,a-c)\n        ); \n\n        if ((\n            cr.x>0. &&\n            cr.y>0. &&\n            cr.z>0.\n\t\t\t)\n           ){\n\t\t\tvec3 b = cr.zyx/(cr.z + cr.y + cr.x);\n            \n            float iz = b.x/va.z + b.y/vb.z + b.z/vc.z;\n            \n            vec3 c = 0.5+sin(floor(float(i)) + b.x + uv.x/6. +iTime + sin(uv.y/3.)/1.+ vec3(1.,0.6,0.2))/2.;\n\t\t\t//vec3 c = 0.5+sin(floor(float(i)) + b.x +iTime*0. + b.y*14.+ vec3(1.,0.5,0.2))/2.;\n\n            \n            col += (c)*(1.-length(col)*1.4);\n            \n            z = min(z,iz);\n\n        }\n\n    }\n    \n    col *= 0.9;\n    \n    \n    col = smoothstep(0.,1.,col);\n\tcol = mix(col,vec3(0.3,0.4,0.7)/11.,pow(smoothstep(0.,1.,z*0.7),2.));\n    \n    col *= 1. - dot(uv,uv)*0.06;\n    \n    col = pow(max(col,0.),vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 123, 123, 155], [210, 210, 228, 228, 294], [348, 348, 405, 405, 2626]], "test": "untested"}
{"id": "3djfDc", "name": "Starfield_", "author": "kotfind", "description": "Most ideas were taken from here: https://www.youtube.com/watch?v=dhuigO4A7RY&t=272s", "tags": ["star", "space", "stars", "starfield"], "likes": 14, "viewed": 750, "published": 3, "date": "1591040230", "time_retrieved": "2024-07-30T21:03:39.330297", "image_code": "#define NUM_LAYERS 7.\n\nfloat rand(in vec2 p) {\n    return fract(sin(p.x * 317. + p.y * 137.) * 132.);\n}\n\nfloat star(in vec2 uv, in float rays) {\n\tfloat d = length(uv);\n    float m = .1/d;\n    \n    m += 1./exp(100. * abs(uv.x * uv.y)) * rays;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\nvec3 starLayer(in vec2 uv) {\n\tfloat T = iTime * 1.8;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n   \tvec3 col = vec3(0.);\n\n    for (float y = -1.; y <= 1.; ++y) {\n        for (float x = -1.; x <= 1.; ++x) {\n            vec2 offs = vec2(x, y);\n            float r = rand(id + offs);\n            float size = max(0.3, fract(r * 127.));\n            float rays = exp((size - 1.) * 50.) * 2.;\n            float blink = sin(T * r) * 0.5 + 0.5;\n            vec3 c = 2. * normalize(vec3(0.8, 0.4, 0.9)) * fract(vec3(r * 123., r * 987., r * 567.));\n            col += blink * c * size * star(gv - offs - vec2(r, fract(r * 275.)) + .5, rays);\n        }\n    }\n    \n    return col;\n}\n\nmat2 rot(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float t = iTime*.08;\n    uv *= rot(t);\n    for (float i = 0.; i < 1.; i += 1./NUM_LAYERS) {\n        float depth = fract(i + t);\n        float scale = mix(20., 2., depth);\n        float fade = depth * smoothstep(1., .9, depth);\n    \tcol += fade * starLayer(uv * scale + 323. * i);\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 103], [105, 105, 144, 144, 301], [303, 303, 331, 331, 988], [990, 990, 1012, 1012, 1088], [1090, 1090, 1147, 1147, 1570]], "test": "untested"}
{"id": "wsjfD3", "name": "Lattice B -5c", "author": "soundmasteraj", "description": "original code by wyatt Title: Lattice Boltzmann *buf a modulate pre lookup, sine * fract calc, change in differential on buffer d related to mouse", "tags": ["fluid"], "likes": 5, "viewed": 414, "published": 3, "date": "1591031209", "time_retrieved": "2024-07-30T21:03:40.333615", "image_code": "// Fork of \"Lattice B -5\" by soundmasteraj. https://shadertoy.com/view/WlcXRr\n// 2020-06-01 17:04:18\n\n// Fork of \"Lattice B -4\" by soundmasteraj. https://shadertoy.com/view/3l3XRr\n// 2020-01-28 22:46:51\n\n// Fork of \"Lattice B -3\" by soundmasteraj. https://shadertoy.com/view/WlcSRr\n// 2020-01-28 22:43:17\n\n// Fork of \"Lattice B -2\" by soundmasteraj. https://shadertoy.com/view/WlcXzn\n// 2020-01-28 22:31:42\n\n// Fork of \"Lattice B Tests\" by soundmasteraj. https://shadertoy.com/view/wlKGDd\n// 2020-01-28 21:56:18\n\n// LENS FLAIR EFFECT\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\nvec4 F (vec2 U,vec2 r) {\n\tvec4 t = T(U+r);\n    return exp(-.01*dot(r,r))*(exp(2.*t)-1.);\n}\nvoid mainImage( out vec4 Q, vec2 U )\n{\n   \n   Q = vec4(0);\n    for (float i = 0.; i < 8.; i+=1.1) {\n    \tQ += F(U,+vec2(-i,i));\n    \tQ += F(U,+vec2(i,i*.5));\n    \tQ += F(U,-vec2(-i,i));\n    \tQ += F(U,-vec2(i,i*.5));\n    } \n\n    Q = T(U)*0.15+ 1e-5*Q;\n    Q -= texture(iChannel2,D(U).xy/R)*.47;\n    Q = atan(Q);\n\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Lighting on Buffer B\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n\nvoid mainImage( out vec4 Q, vec2 U )\n{\n   Q =  1.2-2.2*T(U);\n    Q.xyz = Q.xyz+.5*normalize(Q.xyz);\n   float\n       n = length(T(U+vec2(0,1))),\n       e = length(T(U+vec2(1,0))),\n       s = length(T(U-vec2(0,1))),\n       w = length(T(U-vec2(1,0)));\n    vec3 no = normalize(vec3(e-w,n-s,1));\n    float d = dot(reflect(no,vec3(0,0,1)),normalize(vec3(1)));\n    Q *= 8.*exp(-3.*d*d);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// LOOK UP PICTURE IN LOCATION FROM BUFFER D\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\nvoid mainImage( out vec4 Q, vec2 U )\n{\n    Q = texture(iChannel2,D(U).xy/R);\n}", "buffer_b_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// TRANSLATE LOCATION FIELD WITH v(A(coord)), INIT WITH FragCoord\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define d(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\nvec2 v (vec4 b) {\n\treturn vec2(b.x-b.y,b.z-b.w);\n}\nvec4 D(vec2 U) {\n    U-=.5*v(A(U));\n    U-=.5*v(A(U));\n\treturn d(U);\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    Q = D(U);\n    \n    float ptany = +atan(U.y);\n    float mtany = -ptany;\n    float pnamod = .25;\n    float ptanx = atan(U.x);\n    float mtanx = -ptanx;\n    float neg1 = .25;\n    float pmod = -.5;\n    \n    \n    vec4 \n        q = A(U),\n        \n        n = A(U+vec2(   mtanx * pnamod * 0.          , mtany * pnamod)),\n        \n        e = A(U+vec2(   mtanx * pnamod               , mtany * pnamod* 0. )),\n        \n        s = A(U-vec2(   mtanx * pnamod * 0.          , mtany * pnamod)),\n        \n        w = A(U-vec2(   mtanx * pnamod               , mtany * pnamod* 0. )),\n    \n        \n\n        N = A(U+vec2(   mtanx * pnamod * 0.          , mtany * pnamod)),\n        \n        E = A(U+vec2(   mtanx * pnamod               , mtany * pnamod* 0. )),\n        \n        S = A(U-vec2(   mtanx * pnamod * 0.          , mtany * pnamod)),\n        \n        W = A(U-vec2(   mtanx * pnamod               , mtany * pnamod* 0. ));\n    \n    Q += 0.25*((n.w-q.z)*(N-Q) + (e.y-q.x)*(E-Q) + (s.z-q.w)*(S-Q) + (w.x-q.y)*(W-Q));\n    \n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<R.y/9.)) Q = vec4(U,0,0); // R.y/5. prev\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// FLUID EVOLUTION\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\n#define B(U) texture(iChannel2,(U)/R)\n// Velocity\nvec2 v (vec4 b) {\n\treturn vec2(b.x-b.y,b.z-b.w);\n}\n// Pressure\nfloat p (vec4 b) {\n\treturn 0.25001*(b.x+b.y+b.z+b.w);\n}\n// TRANSLATE COORD BY Velocity THEN LOOKUP STATE\nvec4 A(vec2 U) {\n    U-=.5*v(T(U));\n    U-=.5*v(T(U));\n\treturn T(U)*.97654+sin(fract(iDate.w))*-fract(iDate.w)*.005;\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    // THIS PIXEL\n    Q = A(U);\n    // NEIGHBORHOOD\n    \n    float ptany = +atan(U.y);\n    float mtany = -ptany;\n    float pnamod = .25;\n    float ptanx = atan(U.x);\n    float mtanx = -ptanx;\n    float neg1 = .25;\n    float pmod = -.5;\n    \n  \n    vec4 \n        n = A(U+vec2(   mtanx * pnamod * 0.          , mtany * pnamod)),\n        \n        e = A(U+vec2(   mtanx * pnamod               , mtany * pnamod* 0. )),\n        \n        s = A(U-vec2(   mtanx * pnamod * 0.          , mtany * pnamod)),\n        \n        w = A(U-vec2(   mtanx * pnamod               , mtany * pnamod* 0. ));\n    \n    // GRADIENT of PRESSURE\n    float px = 0.25*(p(e)-p(w));\n    float py = 0.25*(p(n)-p(s)); \n    \n    \t\t// boundary Energy exchange in :   \n    Q += 0.25*(n.w + e.y + s.z + w.x)\n        \t// boundary Energy exchange out :\n        \t-p(Q)\n        \t// dV/dt = dP/dx,  dEnergy In dTime = dEnergy in dSpace\n        \t-vec4(px,-px,py,-py);\n    \n    // get value from picture buffer\n    float z = .9-length(B(U).xyz);\n    \n    // some kind of viscolsity thing \n    Q = mix(mix(Q,0.25*(n+e+s+w),.01),vec4(p(Q)),.01*(1.-z));\n    // gravity polarizes energy! pretty cool imo\n    Q.zw -= 0.001*z*vec2(1,-1);\n    // Init with no velocity and some pressure\n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<R.y/5.)) Q = vec4(.2);\n    // At boundarys turn all kinetic energy into potential energy\n    if(U.x<3.||R.x-U.x<3.||U.y<3.||R.y-U.y<3.)Q = vec4(p(Q));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[635, 635, 659, 659, 725], [726, 726, 764, 764, 1039]], "test": "untested"}
{"id": "wsjBD3", "name": "A battered alien planet", "author": "mrange", "description": "License CC0: A battered alien planet\nBeen experimenting with space inspired shaders\n", "tags": ["raymarching", "terrain"], "likes": 51, "viewed": 1755, "published": 3, "date": "1591024904", "time_retrieved": "2024-07-30T21:03:41.301027", "image_code": "// License CC0: A battered alien planet\n//  Been experimenting with space inspired shaders\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.00001\n#define MAX_ITER        65\n#define MIN_DISTANCE    0.01\n#define MAX_DISTANCE    9.0\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = vec3(0.4, 0.7, 1.0);\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.6,0.4);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.7);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  mountainColor = 1.0*sqrt(vec3(0.95, 0.65, 0.45));\nconst float cellWidth     = 1.0;\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 center = sphere.xyz;\n  float radius = sphere.w;\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nfloat noise1(vec2 p) {\n  vec2 n = mod2(p, vec2(cellWidth));\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n  \n  float r = 0.225*cellWidth;\n \n  float d = circle(p, 2.0*r);\n  \n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat noise2(vec2 p) {\n  vec2 n = mod2(p, vec2(cellWidth));\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  rot(p, TAU*hh.y);\n  float r = 0.45*cellWidth;\n \n//  float d = circle(p, 1.0*r);\n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n  \n  float h = (hh.x)*smoothstep(0.0, r, -2.0*d);\n\n  return h*0.275;\n}\n\n\nfloat height(vec2 p, float dd, int mx) {\n  const float aa   = 0.45;\n  const float ff   = 2.03;\n  const float tt   = 1.2;\n  const float oo   = 3.93;\n  const float near = 0.25;\n  const float far  = 0.65;\n  \n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.0;\n  float d = 0.0;\n  \n  int i = 0;\n  \n  for (; i < 4;++i) {\n    float nn = a*noise2(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float lod = s/d;\n\n  float rdd = dd/MAX_DISTANCE;\n  mx = int(mix(float(4), float(mx), step(rdd, far)));\n  \n  for (; i < mx; ++i) {\n    float nn = a*noise1(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n  \n  float hid = (s/d);\n  \n  return mix(hid, lod, smoothstep(near, far, rdd));\n}\n\nfloat loheight(vec2 p, float d) {\n  return height(p, d, 0);\n}\n\nfloat height(vec2 p, float d) {\n  return height(p, d, 6);\n}\n\nfloat hiheight(vec2 p, float d) {\n  return height(p, d, 8);\n}\n  \nvec3 normal(vec2 p, float d) {\n  vec2 eps = vec2(0.00125, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy, d) - hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx, d) - hiheight(p + eps.yx, d));\n  \n  return normalize(n);\n}\n\nconst float stepLength[] = float[](0.9, 0.25);\n\n\nfloat march(vec3 ro, vec3 rd, out int max_iter) {\n  float dt = 0.1;\n  float d = MIN_DISTANCE;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz, d);\n    \n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE) {\n      ++currentStep;\n      if (currentStep >= stepLength.length()) {\n        max_iter = i;\n        return d;\n      }\n      \n      d = lastd;\n      continue;\n    }\n\n    float sl = stepLength[currentStep];\n\n    dt = max(hd, TOLERANCE)*sl + 0.0025*d;\n    lastd = d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, skyCol2, max(0.0, angle)), skyCol3, clamp(-angle*2.0, 0.0, 1.0));\n  \n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*vec3(0.9, 0.8, 0.7), 0.3*vec3(0.9, 0.8, 0.7), pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 final = vec3(0.0);\n  \n final += step(0.0, si.x)*pow(planetDiff, 0.75)*planetCol*smoothstep(-0.075, 0.0, rd.y)*smoothstep(0.0, 0.1, planetBorder);\n\n final += skyCol + sunCol + smallSunCol + dust;\n\n\n  return final;\n}\n\nvec3 getColor(vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  float d = march(ro, rd, max_iter);\n\n  if (d < MAX_DISTANCE)   {\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n\n    vec3 normal = normal(p.xz, d);\n    \n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = skyColor(p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;   \n    float fre = max(dot(normal, -rd), 0.0);\n    fre = pow(1.0 - fre, 5.0);\n    col += rcol*fre*0.5;\n    col += (1.0*p.y);\n    col = tanh(col);\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.0*MAX_DISTANCE, d));\n  \n  } else {\n    col = skyCol;\n  }\n  \n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 getSample1(vec2 p, float time) {\n  float off = 0.5*iTime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.30,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd)  ;\n \n  return col;\n  \n}\n\nvec3 getSample2(vec2 p, float time) {\n  p.y-=time*0.25;\n  float h = height(p, 0.0);\n  vec3 n = normal(p, 0.0);\n  \n  vec3 lp = vec3(10.0, -1.2, 0.0);\n  \n  vec3 ld = normalize(vec3(p.x, h, p.y)- lp);\n  \n  float d = max(dot(ld, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n\n  col = vec3(1.0)*(h+0.1);\n  col += vec3(1.5)*pow(d, 0.75);\n \n  return col;\n  \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = getSample1(p, iTime);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjBD3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[770, 770, 803, 803, 888], [890, 890, 926, 926, 1020], [1022, 1022, 1053, 1053, 1079], [1081, 1081, 1120, 1120, 1383], [1385, 1385, 1404, 1404, 1527], [1529, 1529, 1576, 1576, 1961], [1963, 1963, 1985, 1985, 2206], [2208, 2208, 2230, 2230, 2522], [2525, 2525, 2565, 2565, 3310], [3312, 3312, 3345, 3345, 3373], [3375, 3375, 3406, 3406, 3434], [3436, 3436, 3469, 3469, 3497], [3501, 3501, 3531, 3531, 3749], [3800, 3800, 3849, 3849, 4500], [4502, 4502, 4523, 4523, 4569], [4571, 4571, 4597, 4597, 4643], [4645, 4645, 4666, 4666, 4695], [4697, 4697, 4730, 4730, 6042], [6044, 6044, 6077, 6077, 7127], [7129, 7129, 7166, 7166, 7508], [7510, 7510, 7547, 7547, 7853], [7855, 7855, 7907, 7907, 8083]], "test": "untested"}
{"id": "ts2fW3", "name": "Infinite Planets", "author": "jarble", "description": "It's an endless galaxy of randomly-textured planets.\nClick and drag the mouse to look around.", "tags": ["raymarching", "planets"], "likes": 4, "viewed": 369, "published": 3, "date": "1591023152", "time_retrieved": "2024-07-30T21:03:42.273427", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nvoid animate(inout vec3 uv){\n    float distortion = 10.0; //this makes them look like \"spaceships\"\n    //float distortion = 10.0; //this makes them look like \"planets\"\n    \n\tvec3 p1 = (uv+100.0*vec3(1.0,1.0,1.0)*iTime/2.0)/100.0;\n    uv += vec3(sin(p1.y+p1.z),cos(p1.z+p1.x),sin(p1.x+p1.y))*distortion;\n}\n\nvec3 surface_color(vec3 p)\n{\n    animate(p);\n    p /= 100.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    animate(p);\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    p /= 5.0;\n    return  (2.9 + sin(p.x)+cos(p.y)+cos(p.z))*3.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8, 0.8, 0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    vec3 eye = vec3(5.0, 5.0, 50.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2fW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 279, 279, 555], [557, 557, 585, 585, 1083], [1085, 1325, 1349, 1349, 1559], [1561, 1982, 2073, 2073, 2434], [2449, 2703, 2768, 2768, 2900], [2902, 2991, 3020, 3020, 3330], [3332, 3824, 3964, 3964, 4554], [4556, 4926, 5011, 5011, 5365], [5367, 5694, 5743, 5778, 5909], [5911, 5911, 5968, 5968, 6962]], "test": "untested"}
{"id": "wd2BW3", "name": "Light glow", "author": "Paltoquet", "description": "Some fun with sinus random function you can adjust the blur of the image and the number of ray", "tags": ["light", "glow"], "likes": 2, "viewed": 432, "published": 3, "date": "1591020040", "time_retrieved": "2024-07-30T21:03:43.215908", "image_code": "#define PI 3.142\n#define ANIMATION_DURATION 120.0\n#define ANIMATION_SPEED 15.0\n#define BLUR_RADIUS 6\n\nfloat random (float theta) {\n    float period = 230.000;\n    return fract(sin(dot(theta, period * period))* 2.856);\n}\n\nfloat getCurrentTime() {\n    float coef = mod(iTime * ANIMATION_SPEED, ANIMATION_DURATION);\n    coef = coef / ANIMATION_DURATION;\n    coef = max(0.0, coef);\n    return coef;\n}\n\nfloat period(float theta, float nbCroissant) {\n    float period = 2.0 * PI;\n\tperiod = period * nbCroissant;\n    return sin(theta * period);\n}\n\nfloat square(vec2 position, vec2 dim) {\n    if(abs(position.x) < dim.x && abs(position.y) < dim.y) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat sphere(vec2 position, vec2 center, float radius) {\n    if(length(position - center) <= radius) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat circle(vec2 position, float radius, float width){\n    float dist = abs(length(position) - radius);\n    if(dist < width) {\n        return width;\n    }\n    return 0.0;\n}\n\nfloat easingIn(float val) {\n    return pow(val, 3.0);\n}\n\nfloat easingOut(float val) {\n    return 1.0 - pow(1.0 - val, 5.0);\n}\n\nfloat generateSphere(vec2 position) {\n    vec2 centers[8];\n    float radius[8];\n    centers[0] = vec2(0.580,0.230);\n    centers[1] = vec2(0.320,0.630);\n    centers[2] = vec2(-0.340,0.260);\n    centers[3] = vec2(-0.750,0.240);\n\tcenters[4] = vec2(-0.630,-0.430);    \n\tcenters[5] = vec2(-0.120,0.770);   \n    centers[6] = vec2(0.330,-0.630);\n    centers[7] = vec2(0.440,-0.240);\n    \n    radius[0] = 0.028;\n    radius[1] = 0.037;\n    radius[2] = 0.049;\n\tradius[3] = 0.032;\n    radius[4] = 0.024;\n    radius[5] = 0.042;\n    radius[6] = 0.062;\n    radius[7] = 0.080;\n    \n    float result = 0.0;\n    float theta = atan(position.y, position.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    float coef = getCurrentTime();\n    coef = coef * 0.68;\n    for(int i = 0; i < 8; i++){\n        vec2 center = centers[i];\n        float radius = radius[i];\n        center = mix(vec2(0), center, coef);\n        radius = mix(0.001, radius, coef);\n        result = max(result, sphere(position, center, radius));\n    }\n    return result;\n}\n\nfloat generateCroissant(vec2 position, float nbCroissant) {\n    float theta = atan(position.y, position.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    float coef = getCurrentTime();\n    \n    //coef = 1.0;\n    \n    float currentCroissant = floor(current * nbCroissant);\n    \n    float amplitude = random(currentCroissant);\n    \n    float range = period(current, nbCroissant);\n    float dist = length(position);\n    range = range * amplitude * coef;\n    dist = dist < range ? range : 0.0;\n    return dist;\n}\n\n/*float glow(vec2 pos) {\n    float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); \n    float firstPeriod = PI;\n    float secondPeriod = 5.0;\n    float soft = 0.436;\n    float constant = 0.552;\n    float curve = (sin(current * firstPeriod) + sin(current * secondPeriod * firstPeriod) * soft) * 0.2 + constant;\n    float dist = length(pos);\n    return max(0.0, curve - dist);\n}*/\n        \n\nvec4 getColor(vec2 pos){\n    float nbCroissant = 120.0;\n    float currentTime = getCurrentTime();\n    //nbCroissant = mix(0.0, 200.0, currentTime);\n    \n    float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    vec4 firstRedColor = vec4(0.995,0.364,0.162,1.000);\n    vec4 firstYellowColor = vec4(0.412,0.639,0.995,1.000);\n    vec4 firstColor = mix(firstYellowColor, firstRedColor, easingIn(1.0 - abs((current - 0.5)) * 1.0));\n    vec4 secondColor = vec4(0.995,0.924,0.362,1.000);\n    vec4 backGroundColor = vec4(0.001,0.000,0.005,1.000);\n    \n    float circleRadius = mix(0.0, 0.065, currentTime);\n    float circleWidth = mix(0.01, 0.065, currentTime);\n    \n    float dist = generateCroissant(pos, nbCroissant);\n    dist = max(dist, generateCroissant(pos, nbCroissant / 6.0)); // play with thoose\n    //dist = max(dist, generateCroissant(pos, nbCroissant / 8.0)); // play with thoose\n    //dist = max(dist, square(pos, vec2(0.22, 0.22)));\n    dist = max(dist, generateSphere(pos));\n    dist = max(dist, easingIn(circle(pos, circleRadius, circleWidth)));\n    //st = max(dist, glow(pos));\n    vec4 color = dist != 0.0 ? mix(firstColor, secondColor, easingIn(dist)) : backGroundColor;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st * vec2(2.0) - vec2(1.0);\n    vec2 pixelOffset = vec2(1.0) / iResolution.xy;\n\tint blurRadius = 5;\n    vec4 color = getColor(st);\n    \n    for(int i = -1 * BLUR_RADIUS; i < BLUR_RADIUS; i++) {\n        for(int j = -1 * BLUR_RADIUS; j < BLUR_RADIUS; j++) {\n            vec2 offset = vec2(i, j) * pixelOffset;\n            color += getColor(st + offset);\n        }\n    }\n    \n    color = color / vec4(BLUR_RADIUS * BLUR_RADIUS);\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2BW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 130, 130, 219], [221, 221, 245, 245, 396], [398, 398, 444, 444, 539], [541, 541, 580, 580, 686], [688, 688, 744, 744, 835], [837, 837, 892, 892, 1010], [1012, 1012, 1039, 1039, 1067], [1069, 1069, 1097, 1097, 1137], [1139, 1139, 1176, 1176, 2310], [2312, 2312, 2371, 2371, 2978], [3522, 3522, 3546, 3546, 4907], [4909, 4909, 4965, 4965, 5469]], "test": "untested"}
{"id": "3s2BWV", "name": "Fly On, Buckaroo", "author": "blackle", "description": "this time more cuter :3\n\nbuckaroo is flying to his boyfriend's house\n\nmusic is: [url]https://soundcloud.com/h4ck4y473m32/rave-3000[/url]\n\noriginal: [url]https://www.shadertoy.com/view/3sSBDV[/url]", "tags": ["ufo", "buckaroo"], "likes": 94, "viewed": 5648, "published": 3, "date": "1591015192", "time_retrieved": "2024-07-30T21:03:44.069625", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//antialising. increasing to 8 looks pretty good, but will be 8x slower\n#define AA_SAMPLES 1\n\nconst int BLM[17] = int[17](\n    0x19B12B,0x1AB56B,0x18B167,0x1AB56B,0x18952B,0x1FFFFF,\n    0x1DAA4F,0x1DAADF,0x1DAA4F,0x1DAAEF,0x1CB64F,0x1FFFFF,\n    0xA2048,0x2B6DA,0x236C9,0xAB6DA,0xAB6CA\n);\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat comp(vec3 p, vec3 ax, float ro) {\n  \n  p = erot(p,ax,ro);\n  p = asin(sin(p));\n  return length(p)-1.;\n}\n\nfloat cloudssdf(vec3 p) {\n  p.y += iTime*.2;\n  float d1 = comp(p, normalize(vec3(1,2,5)), 0.5);\n  p.y += iTime*.2;\n  float d3 = comp(p*2., normalize(vec3(3,1,1)), 2.5)/2.;\n  p.y += iTime*.2;\n  float d4 = comp(p*3., normalize(vec3(4,-2,5)), 3.5)/3.;\n  return (d1+d3+d4)/3.;\n}\n\nfloat linedist (vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat body;\nfloat beamm;\nvec3 locl;\nfloat rm;\nfloat scene(vec3 p) {\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  beamm = 0.9*(linedist(p, vec3(0), vec3(0,0,-10))-.3-sin(p.z*3.+iTime*4.)*.05 - sin(iTime)*.2);\n  locl = p;\n  vec3 p2 =p;\n  p2.z = sqrt(p2.z*p2.z+0.02);\n  p2.z+=3.;\n  vec3 p3 =p;\n  p3.z = sqrt(p3.z*p3.z+0.02);\n  p3.z+=8.1;\n  body = length(p2)-3.8;\n  body += smoothstep(0.8,.9,sin(atan(p2.x,p2.y)*10.))*.02;\n  body += smoothstep(0.9,1.,sin(atan(p2.x,p2.y)*45.))*.003;\n  rm=length(p3)-8.525;\n  body = smin(body, rm,.01);\n  float hat = length(p-vec3(0,0,0.8))-0.7;\n  return min(min(body,hat), beamm);\n}\nfloat bpm = 124.;\nfloat eye;\nfloat buckaroo(vec3 p) {\n  float bpmt = iTime/60.*bpm;\n  float t = pow(sin(fract(bpmt)*3.14/2.), 20.);\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  p-=vec3(0,0,0.9);\n  p.z += t*.1;\n  p.x = abs(p.x);\n  float b =  length(p)-0.2;\n  float scl = cos(bpmt*3.1415)*.05+.95;\n  b = smin(b, linedist(p, vec3(0), vec3(.3,0,.3)*scl)-.03, 0.05);\n  b = smin(b, length(p-vec3(.3,0,.3)*scl)-.07, 0.1);\n  b = smin(b, linedist(p, vec3(0), vec3(0,0,-.5))-.15, .1);\n  eye = length(p-vec3(.1,.18,.0))-.03;\n  return min(b, eye);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p)-vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 norm2(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(buckaroo(p)-vec3(buckaroo(k[0]), buckaroo(k[1]), buckaroo(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n  return vec3(r*r,g*g,b*b);\n}\n\nvec3 clouds(inout vec3 p, vec3 cam, vec3 init, int depth) {\n  p = init;\n  for (int i = 0; i < depth; i++) {\n    float dist = min(scene(p),cloudssdf(p));\n    dist = sqrt(dist*dist+0.05);\n    p += dist*cam;\n  }\n  float f1 = length(sin(p)*.5+.5)/sqrt(3.);\n  float f2 = smoothstep(0., 30., distance(p,init));\n  vec3 sun = max(0.,dot(vec3(1./sqrt(3.)), cam))*vec3(1);\n  sun = pow(sun,vec3(9)) + pow(sun,vec3(4))*srgb(0.7,0.5,0.2);\n  return mix(srgb(0.2,0.3,0.7), srgb(0.8,0.3,0.3), f1) + mix(srgb(0.2,0.4,0.7), srgb(0.7,0.7,0.7), f2) + sun;\n}\n\n\nvec3 pixel_color( vec2 uv )\n{\n  //we have the moral obligation to use every platform to speak out against injustice\n  //if you're financially comfortable, donate to bail funds or charities\n  //pick a number that makes you as uncomfortable as the police brutality\n  vec2 uv2 = uv + vec2(cos(iTime)*0.03, sin(iTime)*.1);\n  ivec2 id = ivec2(floor(vec2(55,28)-uv2*100.));\n  float blm = 1.;\n  if (id.x >= 0 && id.x < 21 && id.y >= 0 && id.y < 17) {\n    blm = (BLM[id.y] >> id.x) % 2 == 0 ? 0. : 1.;\n  }\n  float bubble = sqrt(length(pow(uv2-vec2(.44,.2),vec2(2.))))-.14;\n  uv2 = uv2 - vec2(0.38,0.2);\n  uv2 = erot(vec3(uv2,0),vec3(0,0,1),1.3-sin(iTime)*.1).xy;\n  float arrow = box((vec2(2,1)*uv2)*mat2(.71,-.71,.71,.71), vec2(.1))-.01;\n  bubble = min(bubble,arrow/1.7);\n    \n    \n  vec3 cam = normalize(vec3(1,uv));\n  \n  float bpmt = iTime/60.*bpm;\n  float t = mix(floor(bpmt) + pow(sin(fract(bpmt)*3.14/2.), 20.), bpmt, 0.8);\n  vec3 init = vec3(-8.+sin(t)*2.,0,0.1);\n  cam = erot(cam, vec3(0,0,1), t*.2);\n  init = erot(init, vec3(0,0,1), t*.2);\n  vec3 clp;\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  float glow = 0.;\n  for (int i = 0; i < 180 && !hit; i++) {\n    dist = scene(p);\n    if (!isnan(beamm)) glow += .5/(1.+beamm*100.);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n    if(distance(p,init)>20.)break;\n  }\n  float stmp = smoothstep(-.05,.05,dist-rm);\n  vec3 lllocl = locl;\n  glow = min(glow,1.);\n  bool bdy = (dist == body);\n  vec3 n = norm(p);\n  vec3 obj = hit ? sin(n)*.5+.5 : vec3(0);\n  vec3 clds = clouds(clp, cam, init, 20);\n  if (hit) {\n    vec3 p2 = p+n*.1;\n    float ao = smoothstep(-.1,.1,scene(p2));\n    vec3 r = reflect(cam,n);\n    float tex = smoothstep(.4,.6,texture(iChannel0, lllocl.xy*.5).x);\n    tex=mix(tex,1.,stmp);\n    float fres = 1.-abs(dot(cam,n))*.98*(tex*.25+.5);\n    vec3 rflcld = clouds(p2, r, p2, 15-int(tex*5.));\n    obj = rflcld*fres*ao;\n    if (!bdy) {\n      p2 = p+cam;\n      r = refract(cam,n,1.1);\n      vec3 p5 = p;\n      bool hhit = false;\n      float bb;\n      for (int i = 0; i < 50 && !hhit; i++) {\n        bb = buckaroo(p5);\n        hhit = bb*bb< 1e-6;\n        p5+=bb*r;\n        if(distance(p5,p)>2.)break;\n      }\n      bool ey = eye==bb;\n      if (hhit) {\n        vec3 n5 = norm2(p5);\n        vec3 r5 = reflect(cam,n5);\n        float ss = smoothstep(-.05,.05,buckaroo(p5+.05));\n        float fk = length(sin(n5*vec3(.5,.5,2)+.2)*.5+.5)/sqrt(3.)*.5 + ss*.5;\n        float spec = length(sin(r5*vec3(.5,.5,2)+.2)*.5+.5)/sqrt(3.);\n        obj = fk*mix(ey ? srgb(0.1,0.1,0.1) : srgb(0.3,0.75,0.3), rflcld, 0.3) + obj*.5 + pow(spec, 8.)*(ey?1.:.15);\n      } else {\n      \tobj = obj*.5 + clouds(p2, r, p2, 20)*.9;\n      }\n    }\n  }\n  obj = obj  + srgb(0.2,0.4,0.6)*glow;\n  float fctr = smoothstep(-3.,1., distance(clp,init)-distance(p,init));\n  vec3 coll = mix(clds, obj, fctr) + glow*glow*.9*sqrt(fctr*.5+.5);\n  coll = abs(erot(sqrt(coll), normalize(sin(clp*.3+t)), 0.15));\n\n  blm =  mix(0.,blm,smoothstep(0.,.003,abs(bubble)-.01));\n  return mix(vec3(blm),coll*coll, smoothstep(0.,.003,bubble));\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    for (int i = 0; i < AA_SAMPLES+int(min(0,iFrame)); i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n        fragColor += vec4(pixel_color(uv2), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23017, "src": "https://soundcloud.com/h4ck4y473m32/rave-3000", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2BWV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[483, 483, 510, 510, 588], [590, 590, 628, 628, 690], [692, 692, 731, 731, 800], [802, 802, 827, 827, 1076], [1078, 1078, 1119, 1119, 1206], [1208, 1208, 1247, 1247, 1317], [1365, 1365, 1386, 1386, 1951], [1981, 1981, 2005, 2005, 2510], [2512, 2512, 2531, 2531, 2642], [2644, 2644, 2664, 2664, 2787], [2789, 2789, 2827, 2827, 2857], [2859, 2859, 2918, 2918, 3396], [3399, 3399, 3428, 3661, 6446], [6448, 6448, 6469, 6469, 6528], [6530, 6530, 6587, 6587, 6895]], "test": "untested"}
{"id": "WsBBDK", "name": "4d Perlin Noise", "author": "kotfind", "description": "4d Perlin noise code sample.\nHope, it will be useful to smb.\n\nP.S. Noise can be changed with the mouse.\n\nUPD: Spalmer, thank you for gamma correction advice.", "tags": ["noise", "perlinnoise", "4d"], "likes": 3, "viewed": 1092, "published": 3, "date": "1591012454", "time_retrieved": "2024-07-30T21:03:44.819620", "image_code": "#define inf 1000000.0\n#define M_PI 3.1415926\n\nfloat rand(in vec4 p) {\n\treturn fract(sin(p.x*1234. + p.y*2345. + p.z*3456. + p.w*4567.) * 5678.);\n}\n\nfloat smoothnoise(in vec4 p) {\n    const vec2 e = vec2(0.0, 1.0);\n    vec4 i = floor(p);    // integer\n    vec4 f = fract(p);    // fract\n    \n    f = f*f*(3. - 2.*f);\n    \n    return mix(mix(mix(mix(rand(i + e.xxxx),\n                           rand(i + e.yxxx), f.x),\n                       mix(rand(i + e.xyxx),\n                           rand(i + e.yyxx), f.x), f.y),\n                   mix(mix(rand(i + e.xxyx),\n                           rand(i + e.yxyx), f.x),\n                       mix(rand(i + e.xyyx),\n                           rand(i + e.yyyx), f.x), f.y), f.z),\n               mix(mix(mix(rand(i + e.xxxy),\n                           rand(i + e.yxxy), f.x),\n                       mix(rand(i + e.xyxy),\n                           rand(i + e.yyxy), f.x), f.y),\n                   mix(mix(rand(i + e.xxyy),\n                           rand(i + e.yxyy), f.x),\n                       mix(rand(i + e.xyyy),\n                           rand(i + e.yyyy), f.x), f.y), f.z), f.w);\n}\n\nfloat noise(in vec4 p) {\n    float s = 0.;\n    float pow2 = 1.;\n    for (int i = 0; i < 5; ++i) {\n\t    s += smoothnoise(p * pow2) / pow2;\n        pow2 *= 2.;\n    }\n    return s / 2.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(noise(vec4(uv, iMouse.xy/iResolution.xy) * 10.));\n    col = sqrt(col);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 69, 69, 146], [148, 148, 178, 178, 1132], [1134, 1134, 1158, 1158, 1318], [1320, 1320, 1375, 1375, 1591]], "test": "untested"}
{"id": "3d2BWc", "name": "shuffle-color flattening", "author": "thefox231", "description": "not sure how to describe a shader like this, but it produces a neat effect so\nworks best on b/w media", "tags": ["glitch", "colorflattening"], "likes": 8, "viewed": 419, "published": 3, "date": "1591005559", "time_retrieved": "2024-07-30T21:03:45.664361", "image_code": "/*\n\n// original version - converts to b/w beforehand, much more boring\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    float color = (col.x + col.y + col.z) / 3.0;\n    \n    float range1 = mod(iTime, 2.0) - 0.5;\n    float range2 = mod(iTime + 0.5, 2.0) - 0.5;\n    \n    vec3 bwColor;\n    \n    if (color > range1 && color < range2) {\n    \tbwColor = vec3(1.0);\n    }\n    \n    if (color < range1 && color > range2) {\n    \tbwColor = vec3(0.0);\n    }\n    \n    fragColor = vec4(bwColor, 1);\n}\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(texture(iChannel0, uv));\n    \n    vec3 newCol = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++) {\n        float color = col[i];\n        \n    \tfloat range1 = mod(iTime + float(i) / 2.0, 2.0) - 0.5;\n    \tfloat range2 = mod(iTime + float(i) / 2.0 + 0.5, 2.0) - 0.5;\n        \n    \tif (color > range1 && color < range2) {\n    \t\tnewCol[i] = 1.0;\n    \t}\n    \n    \tif (color < range1 && color > range2) {\n    \t\tnewCol[i] = 0.0;\n    \t}\n    }\n    \n    fragColor = vec4(newCol, 1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2BWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 642, 642, 1178]], "test": "untested"}
{"id": "3s2fD3", "name": "Mouse head", "author": "deni_de", "description": "thx Inigo Quilez", "tags": ["raymarching"], "likes": 4, "viewed": 355, "published": 3, "date": "1591001239", "time_retrieved": "2024-07-30T21:03:46.633769", "image_code": "float mouse(in vec3 pos)\n{\n    float timer = fract(iTime);\n    vec3 posEarL = vec3(pos.x - 0.27 ,pos.y - 0.35,pos.z / 0.5 - 0.1);\n    vec3 posEarR = vec3(pos.x + 0.27 ,pos.y - 0.35,pos.z / 0.5 - 0.1);\n    vec3 pEyeL = vec3(pos.x - 0.1 ,pos.y - 0.17,pos.z + 0.12);\n    vec3 pEyeR = vec3(pos.x + 0.1 ,pos.y - 0.17,pos.z + 0.12);\n    vec3 posNouse = vec3(pos.x ,pos.y - 0.11,pos.z + 0.27);\n    vec3 posNouseTick = vec3(pos.x ,pos.y - 0.135,pos.z * 0.9 + 0.30);\n    vec3 posMouth = vec3(pos.x /0.5,pos.y / 0.2 +0.25,pos.z+0.25);\n    \n    float head = length(pos) - 0.25;\n    float earR = length(posEarR) - 0.11;\n    float earRBool = length(vec3(pos.x + 0.27 ,pos.y - 0.35,pos.z / 0.5 + 0.1)) - 0.15;\n    float earLBool = length(vec3(pos.x - 0.27 ,pos.y - 0.35,pos.z / 0.5 + 0.1)) - 0.15;\n    float earL = length(posEarL) - 0.11;\n    float nouse = length(posNouse) - 0.05;\n    float eyeR = length(pEyeR) - 0.07;\n    float eyeL = length(pEyeL) - 0.07;\n    float nouseT = length(posNouseTick) - 0.05;\n    float mouth = length(posMouth) - 0.21;\n    \n    float result = head  * earR * earL * nouse;\n    result = min(result,eyeR * eyeL);\n    result = max(result,-earRBool * 0.1);\n    result = max(result,-earLBool * 0.1);\n    result = min (result,nouseT);\n    result = max (result,-mouth * .1);\n    return result;\n}\nfloat map(in vec3 pos)\n{\n    \n    float object = mouse(pos);\n    float plane = pos.y - -0.25;\n    return min(object,plane);\n}\nvec3 cNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize( vec3(map(pos+e.xyy)-map(pos-e.xyy),map(pos+e.yxy)-map(pos-e.yxy),map(pos+e.yyx)-map(pos-e.yyx)));\n}\nfloat Raycast(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i <300; i++)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        if(h <0.001)break;\n        t += h;\n        if(t > 20.0)break;\n    }\n    if(t>20.0) t=-1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float an = iTime * 0.7;\n    \n    vec3 ro = vec3(1.0 * sin(an),0.3,1.0 * cos(an));\n    vec3 ta = vec3(0.0);\n    \n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n    vec3 v = normalize(cross(u,w));\n    \n    vec3 rd = normalize(p.x * u + p.y *v + 1.5 * w);\n\n    vec3 color = vec3(0.6,0.7,0.9) - 0.5 * rd.y;\n    color = mix(color,vec3(0.9,0.95,1.2),exp(-10.0*rd.y));\n    \n    float a = Raycast(ro,rd);\n    if(a >0.0)\n    {\n        vec3 pos = ro + a*rd;\n        vec3 norm = cNormal(pos);\n        \n        vec3 ctrl = vec3(0.21,0.21,0.21);\n\n        \n        vec3 sunDir = normalize(vec3(1.5,2.0,-1.0));\n        float shadow = step(Raycast(pos+ norm*0.001,sunDir),0.0);\n        float diff = clamp(dot(norm,sunDir),0.0,1.0);\n        float sky = clamp(0.5 + 0.5 * dot(norm,vec3(0.0,1.0,0.0)),0.0,1.0);\n        float bounce = clamp(0.5 + 0.5 * dot(norm,vec3(0.0,-1.0,0.0)),0.0,1.0);\n        \n        color = ctrl * vec3(3.0,1.5,0.25) * diff * shadow;\n        color += ctrl * vec3(0.6,0.7,0.9) * sky;\n        color += ctrl * vec3(1.1,0.5,0.15) * bounce;\n        \n        color *= 2.0;\n    }\n    \n    //exposure\n    color = pow(color,vec3(0.53));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 1305], [1306, 1306, 1330, 1330, 1431], [1432, 1432, 1459, 1459, 1612], [1613, 1613, 1649, 1649, 1881], [1883, 1883, 1940, 1940, 3218]], "test": "untested"}
{"id": "wdSBDc", "name": "Infinite spaceships", "author": "jarble", "description": "In this galaxy, there are infinitely many spaceships.\nClick and drag the mouse to look around.", "tags": ["raymarching", "spaceship"], "likes": 3, "viewed": 336, "published": 3, "date": "1590972243", "time_retrieved": "2024-07-30T21:03:47.517407", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\n\nvoid animate(inout vec3 uv){\n    \n    float distortion = 100.0; //this makes them look like \"spaceships\"\n    //float distortion = 10.0; //this makes them look like \"planets\"\n    \n\tvec3 p1 = (uv+5.0*vec3(1.0,1.0,1.0)*iTime)/100.0;\n    uv += vec3(sin(p1.y+p1.z),cos(p1.z+p1.x),sin(p1.x+p1.y))*distortion;\n}\n\nvec3 surface_color(in vec3 uv)\n{\n    animate(uv);\n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 4.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n        uv.x = uv.y + sin(uv.x-(uv.z+uv.y))+(uv.x);\n        uv.y = uv.x + sin(uv.y-(uv.z+uv.x))-(uv.y);\n    }\n    return vec3(cos(lar * 2.0), cos(lar * 3.0), cos(lar * 1.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    animate(p);\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    return  4.0 + sin((p.x+p.y+p.z)/100.0)*.4 + sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 210, 210, 486], [488, 488, 520, 520, 828], [830, 1070, 1094, 1094, 1353], [1355, 1776, 1867, 1867, 2173], [2188, 2442, 2507, 2507, 2639], [2641, 2730, 2759, 2759, 3069], [3071, 3563, 3703, 3703, 4293], [4295, 4665, 4750, 4750, 5508], [5510, 5837, 5886, 5921, 6052], [6054, 6054, 6111, 6111, 6989]], "test": "untested"}
{"id": "tdSBWc", "name": "Two Suns", "author": "Plento", "description": "Bored and experimenting with rendering", "tags": ["3d", "raymarch", "mountain"], "likes": 11, "viewed": 381, "published": 3, "date": "1590969629", "time_retrieved": "2024-07-30T21:03:48.393066", "image_code": "// Fork of \"Two Suns\" by Plento. https://shadertoy.com/view/tdSBWc\n// 2020-06-01 01:08:54\n\n// Plento\n\nfloat map(vec3 rp){\n    rp.y-=1.;\n    rp.y += octnse(rp.xz*.06, 2)*12.;\n    return rp.y;\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    for(int i = 0; i < 68; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d) < .0025 || t > 64.)break;\n        t += d * .65;\n    }\n    return t;\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t){\n    vec3 lp = p+vec3(0.5, 16.0, -4.0);\n    vec3 ld = normalize(lp-p);\n   \t\n    float lgd = length(lp - p);\n    float faloff = exp(-lgd*.09);\n    \n    float fres = smoothstep(-.5, .5, dot(rd, n));\n    float dif = max(dot(n, ld), .0);\n    \n    vec3 col = vec3(ss(.2, .27, abs(fract(p.z*.75)-.5)));\n    \n    vec3 lights = 2.5*fres*vec3(1., 0.55, 0.);\n    lights += 6.6*dif*vec3(1., 1., 1.) * faloff;\n    \n    col *= lights;\n    \n    vec2 bgc = vec2(atan(rd.x, rd.z), max(rd.y, 0.));\n    float nse = octnse(vec2(0.47, 0.)+bgc.xy*2., 3);\n    float stamp = ss(0.005, 0.01, (rd.y + nse*.26 - .05));\n    vec3 bg2D = vec3(.99, 0., 0.)*stamp;\n    vec3 sun = vec3(.99, .75, .0)*exp(-6.*(length(vec2(0., 0.0)-rd.xy)-.1));\n    bg2D += sun*stamp;\n    \n    col = mix(vec3(0.96, 0.7, 0.5), col, exp(-t*t*t*0.00003));\n    col += sun*.6*vec3(1., 0.6, 1.);\n    col = mix(bg2D, col, .5);\n    \n\treturn col;   \n}\n\nconst float rad = 25.;\nconst float spd = .2;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, .5));\n    vec3 ro = vec3(0., 3.5, rad);\n    \n    rd.xz *= rot(iTime*spd+m.y*12.+2.);\n    rd.xy *= rot(cos(iTime*1.3)*.07);\n    \n    ro.x += cos(iTime*spd+m.y*12.+2.) * rad;\n    ro.z += sin(iTime*spd+m.y*12.+2.) * rad;\n    \n    float t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, u, t);\n    \n    col *= ss(0.54, 0.15, abs(uv.y));\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat ridges(vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = ss(0., 1., f);\n    \n    vec2 a = hash22(i);\n    vec2 b = hash22( i + vec2(1.,0.));\n    vec2 c = hash22( i + vec2(.0,1.));\n    vec2 d = hash22( i + vec2(1));\n    \n    \n    float nse = mix( mix( dot( a, f ), \n                     dot( b, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( c, f - vec2(0.0,1.0) ), \n                     dot( d, f - vec2(1) ), u.x), u.y);\n    nse = abs(nse);\n    return nse;\n}\n\n\n\nfloat octnse(vec2 p, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        n += ridges(p) * a;\t\t\n        \n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 121, 121, 192], [194, 194, 221, 221, 422], [424, 424, 454, 454, 641], [643, 643, 696, 696, 1587], [1635, 1635, 1675, 1675, 2183]], "test": "untested"}
